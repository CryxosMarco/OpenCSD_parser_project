
.\files\freertos.out:	file format elf32-littlearm

Disassembly of section .vectors:

00000000 <_vectors>:
;         LDR pc, reset_addr          // Reset
       0: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x20 <reset_addr>
;         LDR pc, undefined_addr      // Undefined Instruction
       4: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x24 <undefined_addr>
;         LDR pc, svc_addr            // Software interrupt
       8: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x28 <svc_addr>
;         LDR pc, prefetch_abort_addr // Abort (prefetch)
       c: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x2c <prefetch_abort_addr>
;         LDR pc, data_abort_addr     // Abort (data)
      10: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x30 <data_abort_addr>
;         LDR pc, reserved_addr       // rsvd
      14: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x34 <reserved_addr>
;         LDR pc, irq_addr            // IRQ
      18: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x38 <irq_addr>
;         LDR pc, fiq_addr            // FIQ
      1c: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x3c <fiq_addr>

00000020 <reset_addr>:
      20: b4 0e 0b 70  	.word	0x700b0eb4

00000024 <undefined_addr>:
      24: c1 03 0b 70  	.word	0x700b03c1

00000028 <svc_addr>:
      28: ac 04 0b 70  	.word	0x700b04ac

0000002c <prefetch_abort_addr>:
      2c: 01 04 0b 70  	.word	0x700b0401

00000030 <data_abort_addr>:
      30: d0 06 0b 70  	.word	0x700b06d0

00000034 <reserved_addr>:
      34: 81 03 0b 70  	.word	0x700b0381

00000038 <irq_addr>:
      38: 1c 05 0b 70  	.word	0x700b051c

0000003c <fiq_addr>:
      3c: 11 02 0b 70  	.word	0x700b0211

Disassembly of section .text.hwi:

700afb00 <HwiP_enableInt>:
; {
700afb00: b580         	push	{r7, lr}
700afb02: b084         	sub	sp, #0x10
700afb04: 9003         	str	r0, [sp, #0xc]
;     Hwip_dataAndInstructionBarrier();
700afb06: f7ff ff53    	bl	0x700af9b0 <Hwip_dataAndInstructionBarrier> @ imm = #-0x15a
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_EN(intNum));
700afb0a: f242 60a8    	movw	r0, #0x26a8
700afb0e: f2c7 000b    	movt	r0, #0x700b
700afb12: 6801         	ldr	r1, [r0]
700afb14: 9803         	ldr	r0, [sp, #0xc]
700afb16: f400 70f0    	and	r0, r0, #0x1e0
700afb1a: 4408         	add	r0, r1
700afb1c: f500 6081    	add.w	r0, r0, #0x408
700afb20: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700afb22: 9803         	ldr	r0, [sp, #0xc]
700afb24: f000 001f    	and	r0, r0, #0x1f
700afb28: 9001         	str	r0, [sp, #0x4]
;     *addr = ((uint32_t)0x1 << bitPos);
700afb2a: 9901         	ldr	r1, [sp, #0x4]
700afb2c: 2001         	movs	r0, #0x1
700afb2e: 4088         	lsls	r0, r1
700afb30: 9902         	ldr	r1, [sp, #0x8]
700afb32: 6008         	str	r0, [r1]
; }
700afb34: b004         	add	sp, #0x10
700afb36: bd80         	pop	{r7, pc}
700afb38: bf00         	nop
700afb3a: bf00         	nop
700afb3c: bf00         	nop
700afb3e: bf00         	nop

700afb40 <HwiP_disableInt>:
; {
700afb40: b580         	push	{r7, lr}
700afb42: b084         	sub	sp, #0x10
700afb44: 9003         	str	r0, [sp, #0xc]
700afb46: 2000         	movs	r0, #0x0
;     uint32_t isEnable = 0;
700afb48: 9000         	str	r0, [sp]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_DIS(intNum));
700afb4a: f242 60a8    	movw	r0, #0x26a8
700afb4e: f2c7 000b    	movt	r0, #0x700b
700afb52: 6801         	ldr	r1, [r0]
700afb54: 9803         	ldr	r0, [sp, #0xc]
700afb56: f400 70f0    	and	r0, r0, #0x1e0
700afb5a: 4408         	add	r0, r1
700afb5c: f200 400c    	addw	r0, r0, #0x40c
700afb60: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700afb62: 9803         	ldr	r0, [sp, #0xc]
700afb64: f000 001f    	and	r0, r0, #0x1f
700afb68: 9001         	str	r0, [sp, #0x4]
;     if( (*addr & ((uint32_t)0x1 << bitPos))!=0U)
700afb6a: 9802         	ldr	r0, [sp, #0x8]
700afb6c: 6800         	ldr	r0, [r0]
700afb6e: 9901         	ldr	r1, [sp, #0x4]
700afb70: 40c8         	lsrs	r0, r1
700afb72: 07c0         	lsls	r0, r0, #0x1f
700afb74: b118         	cbz	r0, 0x700afb7e <HwiP_disableInt+0x3e> @ imm = #0x6
700afb76: e7ff         	b	0x700afb78 <HwiP_disableInt+0x38> @ imm = #-0x2
700afb78: 2001         	movs	r0, #0x1
;         isEnable = 1;
700afb7a: 9000         	str	r0, [sp]
;     }
700afb7c: e7ff         	b	0x700afb7e <HwiP_disableInt+0x3e> @ imm = #-0x2
;     *addr = ((uint32_t)0x1 << bitPos);
700afb7e: 9901         	ldr	r1, [sp, #0x4]
700afb80: 2001         	movs	r0, #0x1
700afb82: 4088         	lsls	r0, r1
700afb84: 9902         	ldr	r1, [sp, #0x8]
700afb86: 6008         	str	r0, [r1]
;     Hwip_dataAndInstructionBarrier();
700afb88: f7ff ff12    	bl	0x700af9b0 <Hwip_dataAndInstructionBarrier> @ imm = #-0x1dc
;     return isEnable;
700afb8c: 9800         	ldr	r0, [sp]
700afb8e: b004         	add	sp, #0x10
700afb90: bd80         	pop	{r7, pc}
700afb92: bf00         	nop
700afb94: bf00         	nop
700afb96: bf00         	nop
700afb98: bf00         	nop
700afb9a: bf00         	nop
700afb9c: bf00         	nop
700afb9e: bf00         	nop

700afba0 <HwiP_restoreInt>:
; {
700afba0: b580         	push	{r7, lr}
700afba2: b082         	sub	sp, #0x8
700afba4: 9001         	str	r0, [sp, #0x4]
700afba6: 9100         	str	r1, [sp]
;     if(oldIntState!=0U)
700afba8: 9800         	ldr	r0, [sp]
700afbaa: b120         	cbz	r0, 0x700afbb6 <HwiP_restoreInt+0x16> @ imm = #0x8
700afbac: e7ff         	b	0x700afbae <HwiP_restoreInt+0xe> @ imm = #-0x2
;         HwiP_enableInt(intNum);
700afbae: 9801         	ldr	r0, [sp, #0x4]
700afbb0: f7ff ffa6    	bl	0x700afb00 <HwiP_enableInt> @ imm = #-0xb4
;     }
700afbb4: e003         	b	0x700afbbe <HwiP_restoreInt+0x1e> @ imm = #0x6
;        (void) HwiP_disableInt(intNum);
700afbb6: 9801         	ldr	r0, [sp, #0x4]
700afbb8: f7ff ffc2    	bl	0x700afb40 <HwiP_disableInt> @ imm = #-0x7c
700afbbc: e7ff         	b	0x700afbbe <HwiP_restoreInt+0x1e> @ imm = #-0x2
; }
700afbbe: b002         	add	sp, #0x8
700afbc0: bd80         	pop	{r7, pc}
700afbc2: bf00         	nop
700afbc4: bf00         	nop
700afbc6: bf00         	nop
700afbc8: bf00         	nop
700afbca: bf00         	nop
700afbcc: bf00         	nop
700afbce: bf00         	nop

700afbd0 <HwiP_clearInt>:
; {
700afbd0: b083         	sub	sp, #0xc
700afbd2: 9002         	str	r0, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_STS(intNum));
700afbd4: f242 60a8    	movw	r0, #0x26a8
700afbd8: f2c7 000b    	movt	r0, #0x700b
700afbdc: 6801         	ldr	r1, [r0]
700afbde: 9802         	ldr	r0, [sp, #0x8]
700afbe0: f400 70f0    	and	r0, r0, #0x1e0
700afbe4: 4408         	add	r0, r1
700afbe6: f200 4004    	addw	r0, r0, #0x404
700afbea: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700afbec: 9802         	ldr	r0, [sp, #0x8]
700afbee: f000 001f    	and	r0, r0, #0x1f
700afbf2: 9000         	str	r0, [sp]
;     *addr = ((uint32_t)0x1 << bitPos);
700afbf4: 9900         	ldr	r1, [sp]
700afbf6: 2001         	movs	r0, #0x1
700afbf8: 4088         	lsls	r0, r1
700afbfa: 9901         	ldr	r1, [sp, #0x4]
700afbfc: 6008         	str	r0, [r1]
; }
700afbfe: b003         	add	sp, #0xc
700afc00: 4770         	bx	lr
700afc02: bf00         	nop
700afc04: bf00         	nop
700afc06: bf00         	nop
700afc08: bf00         	nop
700afc0a: bf00         	nop
700afc0c: bf00         	nop
700afc0e: bf00         	nop

700afc10 <HwiP_post>:
; {
700afc10: b580         	push	{r7, lr}
700afc12: b084         	sub	sp, #0x10
700afc14: 9003         	str	r0, [sp, #0xc]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_RAW(intNum));
700afc16: f242 60a8    	movw	r0, #0x26a8
700afc1a: f2c7 000b    	movt	r0, #0x700b
700afc1e: 6801         	ldr	r1, [r0]
700afc20: 9803         	ldr	r0, [sp, #0xc]
700afc22: f400 70f0    	and	r0, r0, #0x1e0
700afc26: 4408         	add	r0, r1
700afc28: f500 6080    	add.w	r0, r0, #0x400
700afc2c: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700afc2e: 9803         	ldr	r0, [sp, #0xc]
700afc30: f000 001f    	and	r0, r0, #0x1f
700afc34: 9001         	str	r0, [sp, #0x4]
;     *addr = ((uint32_t)0x1 << bitPos);
700afc36: 9901         	ldr	r1, [sp, #0x4]
700afc38: 2001         	movs	r0, #0x1
700afc3a: 4088         	lsls	r0, r1
700afc3c: 9902         	ldr	r1, [sp, #0x8]
700afc3e: 6008         	str	r0, [r1]
;     Hwip_dataAndInstructionBarrier();
700afc40: f7ff feb6    	bl	0x700af9b0 <Hwip_dataAndInstructionBarrier> @ imm = #-0x294
; }
700afc44: b004         	add	sp, #0x10
700afc46: bd80         	pop	{r7, pc}
700afc48: bf00         	nop
700afc4a: bf00         	nop
700afc4c: bf00         	nop
700afc4e: bf00         	nop

700afc50 <HwiP_Params_init>:
; {
700afc50: b081         	sub	sp, #0x4
700afc52: 9000         	str	r0, [sp]
;     params->intNum = 0;
700afc54: 9900         	ldr	r1, [sp]
700afc56: 2000         	movs	r0, #0x0
700afc58: 6008         	str	r0, [r1]
;     params->callback = NULL;
700afc5a: 9900         	ldr	r1, [sp]
700afc5c: 6048         	str	r0, [r1, #0x4]
;     params->args = NULL;
700afc5e: 9900         	ldr	r1, [sp]
700afc60: 6088         	str	r0, [r1, #0x8]
;     params->eventId = 0; /* NOT USED */
700afc62: 9900         	ldr	r1, [sp]
700afc64: 8188         	strh	r0, [r1, #0xc]
;     params->priority = (HwiP_MAX_PRIORITY-1U);
700afc66: 9a00         	ldr	r2, [sp]
700afc68: 210f         	movs	r1, #0xf
700afc6a: 7391         	strb	r1, [r2, #0xe]
;     params->isFIQ = 0;
700afc6c: 9900         	ldr	r1, [sp]
700afc6e: 73c8         	strb	r0, [r1, #0xf]
;     params->isPulse = 0;
700afc70: 9900         	ldr	r1, [sp]
700afc72: 7408         	strb	r0, [r1, #0x10]
; }
700afc74: b001         	add	sp, #0x4
700afc76: 4770         	bx	lr
700afc78: bf00         	nop
700afc7a: bf00         	nop
700afc7c: bf00         	nop
700afc7e: bf00         	nop

700afc80 <HwiP_construct>:
; {
700afc80: b580         	push	{r7, lr}
700afc82: b084         	sub	sp, #0x10
700afc84: 9003         	str	r0, [sp, #0xc]
700afc86: 9102         	str	r1, [sp, #0x8]
;     HwiP_Struct *obj = (HwiP_Struct *)handle;
700afc88: 9803         	ldr	r0, [sp, #0xc]
700afc8a: 9001         	str	r0, [sp, #0x4]
700afc8c: 2001         	movs	r0, #0x1
;     DebugP_assertNoLog( sizeof(HwiP_Struct) <= sizeof(HwiP_Object) );
700afc8e: f001 f9a7    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x134e
;     DebugP_assertNoLog( params->callback != NULL );
700afc92: 9802         	ldr	r0, [sp, #0x8]
700afc94: 6840         	ldr	r0, [r0, #0x4]
700afc96: 2800         	cmp	r0, #0x0
700afc98: bf18         	it	ne
700afc9a: 2001         	movne	r0, #0x1
700afc9c: f001 f9a0    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x1340
;     DebugP_assertNoLog( params->intNum < HwiP_MAX_INTERRUPTS );
700afca0: 9802         	ldr	r0, [sp, #0x8]
700afca2: 6801         	ldr	r1, [r0]
700afca4: 2000         	movs	r0, #0x0
700afca6: 9000         	str	r0, [sp]
700afca8: f5b1 7f00    	cmp.w	r1, #0x200
700afcac: bf38         	it	lo
700afcae: 2001         	movlo	r0, #0x1
700afcb0: f001 f996    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x132c
700afcb4: 9800         	ldr	r0, [sp]
;     DebugP_assertNoLog( params->priority < HwiP_MAX_PRIORITY );
700afcb6: 9902         	ldr	r1, [sp, #0x8]
700afcb8: 7b89         	ldrb	r1, [r1, #0xe]
700afcba: 2910         	cmp	r1, #0x10
700afcbc: bf38         	it	lo
700afcbe: 2001         	movlo	r0, #0x1
700afcc0: f001 f98e    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x131c
;     (void) HwiP_disableInt(params->intNum);
700afcc4: 9802         	ldr	r0, [sp, #0x8]
700afcc6: 6800         	ldr	r0, [r0]
700afcc8: f7ff ff3a    	bl	0x700afb40 <HwiP_disableInt> @ imm = #-0x18c
;     HwiP_clearInt(params->intNum);
700afccc: 9802         	ldr	r0, [sp, #0x8]
700afcce: 6800         	ldr	r0, [r0]
700afcd0: f7ff ff7e    	bl	0x700afbd0 <HwiP_clearInt> @ imm = #-0x104
;     HwiP_setAsFIQ(params->intNum, params->isFIQ);
700afcd4: 9902         	ldr	r1, [sp, #0x8]
700afcd6: 6808         	ldr	r0, [r1]
700afcd8: 7bc9         	ldrb	r1, [r1, #0xf]
700afcda: f000 f841    	bl	0x700afd60 <HwiP_setAsFIQ> @ imm = #0x82
;     HwiP_setPri(params->intNum, params->priority);
700afcde: 9902         	ldr	r1, [sp, #0x8]
700afce0: 6808         	ldr	r0, [r1]
700afce2: 7b89         	ldrb	r1, [r1, #0xe]
700afce4: f000 f86c    	bl	0x700afdc0 <HwiP_setPri> @ imm = #0xd8
;     HwiP_setAsPulse(params->intNum, params->isPulse);
700afce8: 9902         	ldr	r1, [sp, #0x8]
700afcea: 6808         	ldr	r0, [r1]
700afcec: 7c09         	ldrb	r1, [r1, #0x10]
700afcee: f000 f87f    	bl	0x700afdf0 <HwiP_setAsPulse> @ imm = #0xfe
;     if(params->isFIQ != 0U)
700afcf2: 9802         	ldr	r0, [sp, #0x8]
700afcf4: 7bc0         	ldrb	r0, [r0, #0xf]
700afcf6: b148         	cbz	r0, 0x700afd0c <HwiP_construct+0x8c> @ imm = #0x12
700afcf8: e7ff         	b	0x700afcfa <HwiP_construct+0x7a> @ imm = #-0x2
;         HwiP_setVecAddr(params->intNum, (uintptr_t)HwiP_fiq_handler);
700afcfa: 9802         	ldr	r0, [sp, #0x8]
700afcfc: 6800         	ldr	r0, [r0]
700afcfe: f240 2111    	movw	r1, #0x211
700afd02: f2c7 010b    	movt	r1, #0x700b
700afd06: f000 f8a3    	bl	0x700afe50 <HwiP_setVecAddr> @ imm = #0x146
;     }
700afd0a: e008         	b	0x700afd1e <HwiP_construct+0x9e> @ imm = #0x10
;         HwiP_setVecAddr(params->intNum, (uintptr_t)HwiP_irq_handler);
700afd0c: 9802         	ldr	r0, [sp, #0x8]
700afd0e: 6800         	ldr	r0, [r0]
700afd10: f240 511c    	movw	r1, #0x51c
700afd14: f2c7 010b    	movt	r1, #0x700b
700afd18: f000 f89a    	bl	0x700afe50 <HwiP_setVecAddr> @ imm = #0x134
700afd1c: e7ff         	b	0x700afd1e <HwiP_construct+0x9e> @ imm = #-0x2
;     gHwiCtrl.isr[params->intNum] = params->callback;
700afd1e: 9802         	ldr	r0, [sp, #0x8]
700afd20: 6802         	ldr	r2, [r0]
700afd22: 6840         	ldr	r0, [r0, #0x4]
700afd24: f240 0100    	movw	r1, #0x0
700afd28: f2c7 0108    	movt	r1, #0x7008
700afd2c: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     gHwiCtrl.isrArgs[params->intNum] = params->args;
700afd30: 9802         	ldr	r0, [sp, #0x8]
700afd32: 6802         	ldr	r2, [r0]
700afd34: 6880         	ldr	r0, [r0, #0x8]
700afd36: eb01 0182    	add.w	r1, r1, r2, lsl #2
700afd3a: f8c1 0800    	str.w	r0, [r1, #0x800]
;     obj->intNum = params->intNum;
700afd3e: 9802         	ldr	r0, [sp, #0x8]
700afd40: 6800         	ldr	r0, [r0]
700afd42: 9901         	ldr	r1, [sp, #0x4]
700afd44: 6008         	str	r0, [r1]
;     HwiP_enableInt(params->intNum);
700afd46: 9802         	ldr	r0, [sp, #0x8]
700afd48: 6800         	ldr	r0, [r0]
700afd4a: f7ff fed9    	bl	0x700afb00 <HwiP_enableInt> @ imm = #-0x24e
700afd4e: 2000         	movs	r0, #0x0
;     return SystemP_SUCCESS;
700afd50: b004         	add	sp, #0x10
700afd52: bd80         	pop	{r7, pc}
700afd54: bf00         	nop
700afd56: bf00         	nop
700afd58: bf00         	nop
700afd5a: bf00         	nop
700afd5c: bf00         	nop
700afd5e: bf00         	nop

700afd60 <HwiP_setAsFIQ>:
; {
700afd60: b084         	sub	sp, #0x10
700afd62: 9003         	str	r0, [sp, #0xc]
700afd64: 9102         	str	r1, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_MAP(intNum));
700afd66: f242 60a8    	movw	r0, #0x26a8
700afd6a: f2c7 000b    	movt	r0, #0x700b
700afd6e: 6801         	ldr	r1, [r0]
700afd70: 9803         	ldr	r0, [sp, #0xc]
700afd72: f400 70f0    	and	r0, r0, #0x1e0
700afd76: 4408         	add	r0, r1
700afd78: f500 6083    	add.w	r0, r0, #0x418
700afd7c: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700afd7e: 9803         	ldr	r0, [sp, #0xc]
700afd80: f000 001f    	and	r0, r0, #0x1f
700afd84: 9000         	str	r0, [sp]
;     if(isFIQ != 0U)
700afd86: 9802         	ldr	r0, [sp, #0x8]
700afd88: b148         	cbz	r0, 0x700afd9e <HwiP_setAsFIQ+0x3e> @ imm = #0x12
700afd8a: e7ff         	b	0x700afd8c <HwiP_setAsFIQ+0x2c> @ imm = #-0x2
;         *addr |= ((uint32_t)0x1u << bitPos);
700afd8c: 9900         	ldr	r1, [sp]
700afd8e: 2001         	movs	r0, #0x1
700afd90: fa00 f201    	lsl.w	r2, r0, r1
700afd94: 9901         	ldr	r1, [sp, #0x4]
700afd96: 6808         	ldr	r0, [r1]
700afd98: 4310         	orrs	r0, r2
700afd9a: 6008         	str	r0, [r1]
;     }
700afd9c: e008         	b	0x700afdb0 <HwiP_setAsFIQ+0x50> @ imm = #0x10
;         *addr &= ~(0x1u << bitPos);
700afd9e: 9900         	ldr	r1, [sp]
700afda0: 2001         	movs	r0, #0x1
700afda2: fa00 f201    	lsl.w	r2, r0, r1
700afda6: 9901         	ldr	r1, [sp, #0x4]
700afda8: 6808         	ldr	r0, [r1]
700afdaa: 4390         	bics	r0, r2
700afdac: 6008         	str	r0, [r1]
700afdae: e7ff         	b	0x700afdb0 <HwiP_setAsFIQ+0x50> @ imm = #-0x2
; }
700afdb0: b004         	add	sp, #0x10
700afdb2: 4770         	bx	lr
700afdb4: bf00         	nop
700afdb6: bf00         	nop
700afdb8: bf00         	nop
700afdba: bf00         	nop
700afdbc: bf00         	nop
700afdbe: bf00         	nop

700afdc0 <HwiP_setPri>:
; {
700afdc0: b083         	sub	sp, #0xc
700afdc2: 9002         	str	r0, [sp, #0x8]
700afdc4: 9101         	str	r1, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_PRI(intNum));
700afdc6: f242 60a8    	movw	r0, #0x26a8
700afdca: f2c7 000b    	movt	r0, #0x700b
700afdce: 6800         	ldr	r0, [r0]
700afdd0: 9902         	ldr	r1, [sp, #0x8]
700afdd2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700afdd6: f500 5080    	add.w	r0, r0, #0x1000
700afdda: 9000         	str	r0, [sp]
;     *addr = (priority & 0xFu);
700afddc: 9801         	ldr	r0, [sp, #0x4]
700afdde: f000 000f    	and	r0, r0, #0xf
700afde2: 9900         	ldr	r1, [sp]
700afde4: 6008         	str	r0, [r1]
; }
700afde6: b003         	add	sp, #0xc
700afde8: 4770         	bx	lr
700afdea: bf00         	nop
700afdec: bf00         	nop
700afdee: bf00         	nop

700afdf0 <HwiP_setAsPulse>:
; {
700afdf0: b084         	sub	sp, #0x10
700afdf2: 9003         	str	r0, [sp, #0xc]
700afdf4: 9102         	str	r1, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(intNum));
700afdf6: f242 60a8    	movw	r0, #0x26a8
700afdfa: f2c7 000b    	movt	r0, #0x700b
700afdfe: 6801         	ldr	r1, [r0]
700afe00: 9803         	ldr	r0, [sp, #0xc]
700afe02: f400 70f0    	and	r0, r0, #0x1e0
700afe06: 4408         	add	r0, r1
700afe08: f200 401c    	addw	r0, r0, #0x41c
700afe0c: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700afe0e: 9803         	ldr	r0, [sp, #0xc]
700afe10: f000 001f    	and	r0, r0, #0x1f
700afe14: 9000         	str	r0, [sp]
;     if(isPulse != 0U)
700afe16: 9802         	ldr	r0, [sp, #0x8]
700afe18: b148         	cbz	r0, 0x700afe2e <HwiP_setAsPulse+0x3e> @ imm = #0x12
700afe1a: e7ff         	b	0x700afe1c <HwiP_setAsPulse+0x2c> @ imm = #-0x2
;         *addr |= ((uint32_t)0x1u << bitPos);
700afe1c: 9900         	ldr	r1, [sp]
700afe1e: 2001         	movs	r0, #0x1
700afe20: fa00 f201    	lsl.w	r2, r0, r1
700afe24: 9901         	ldr	r1, [sp, #0x4]
700afe26: 6808         	ldr	r0, [r1]
700afe28: 4310         	orrs	r0, r2
700afe2a: 6008         	str	r0, [r1]
;     }
700afe2c: e008         	b	0x700afe40 <HwiP_setAsPulse+0x50> @ imm = #0x10
;         *addr &= ~(0x1u << bitPos);
700afe2e: 9900         	ldr	r1, [sp]
700afe30: 2001         	movs	r0, #0x1
700afe32: fa00 f201    	lsl.w	r2, r0, r1
700afe36: 9901         	ldr	r1, [sp, #0x4]
700afe38: 6808         	ldr	r0, [r1]
700afe3a: 4390         	bics	r0, r2
700afe3c: 6008         	str	r0, [r1]
700afe3e: e7ff         	b	0x700afe40 <HwiP_setAsPulse+0x50> @ imm = #-0x2
; }
700afe40: b004         	add	sp, #0x10
700afe42: 4770         	bx	lr
700afe44: bf00         	nop
700afe46: bf00         	nop
700afe48: bf00         	nop
700afe4a: bf00         	nop
700afe4c: bf00         	nop
700afe4e: bf00         	nop

700afe50 <HwiP_setVecAddr>:
; {
700afe50: b083         	sub	sp, #0xc
700afe52: 9002         	str	r0, [sp, #0x8]
700afe54: 9101         	str	r1, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_VEC(intNum));
700afe56: f242 60a8    	movw	r0, #0x26a8
700afe5a: f2c7 000b    	movt	r0, #0x700b
700afe5e: 6800         	ldr	r0, [r0]
700afe60: 9902         	ldr	r1, [sp, #0x8]
700afe62: eb00 0081    	add.w	r0, r0, r1, lsl #2
700afe66: f500 5000    	add.w	r0, r0, #0x2000
700afe6a: 9000         	str	r0, [sp]
;     *addr = ((uint32_t)vecAddr & 0xFFFFFFFCU);
700afe6c: 9801         	ldr	r0, [sp, #0x4]
700afe6e: f020 0003    	bic	r0, r0, #0x3
700afe72: 9900         	ldr	r1, [sp]
700afe74: 6008         	str	r0, [r1]
; }
700afe76: b003         	add	sp, #0xc
700afe78: 4770         	bx	lr
700afe7a: bf00         	nop
700afe7c: bf00         	nop
700afe7e: bf00         	nop

700afe80 <HwiP_destruct>:
; {
700afe80: b580         	push	{r7, lr}
700afe82: b084         	sub	sp, #0x10
700afe84: 9003         	str	r0, [sp, #0xc]
;     HwiP_Struct *obj = (HwiP_Struct *)handle;
700afe86: 9803         	ldr	r0, [sp, #0xc]
700afe88: 9002         	str	r0, [sp, #0x8]
;    (void) HwiP_disableInt(obj->intNum);
700afe8a: 9802         	ldr	r0, [sp, #0x8]
700afe8c: 6800         	ldr	r0, [r0]
700afe8e: f7ff fe57    	bl	0x700afb40 <HwiP_disableInt> @ imm = #-0x352
;     HwiP_clearInt(obj->intNum);
700afe92: 9802         	ldr	r0, [sp, #0x8]
700afe94: 6800         	ldr	r0, [r0]
700afe96: f7ff fe9b    	bl	0x700afbd0 <HwiP_clearInt> @ imm = #-0x2ca
;     HwiP_setAsFIQ(obj->intNum, 0);
700afe9a: 9802         	ldr	r0, [sp, #0x8]
700afe9c: 6800         	ldr	r0, [r0]
700afe9e: 2100         	movs	r1, #0x0
700afea0: 9101         	str	r1, [sp, #0x4]
700afea2: f7ff ff5d    	bl	0x700afd60 <HwiP_setAsFIQ> @ imm = #-0x146
;     HwiP_setPri(obj->intNum, HwiP_MAX_PRIORITY-1U);
700afea6: 9802         	ldr	r0, [sp, #0x8]
700afea8: 6800         	ldr	r0, [r0]
700afeaa: 210f         	movs	r1, #0xf
700afeac: f7ff ff88    	bl	0x700afdc0 <HwiP_setPri> @ imm = #-0xf0
700afeb0: 9901         	ldr	r1, [sp, #0x4]
;     HwiP_setAsPulse(obj->intNum, 0);
700afeb2: 9802         	ldr	r0, [sp, #0x8]
700afeb4: 6800         	ldr	r0, [r0]
700afeb6: f7ff ff9b    	bl	0x700afdf0 <HwiP_setAsPulse> @ imm = #-0xca
;     HwiP_setVecAddr(obj->intNum, (uintptr_t)HwiP_irq_handler);
700afeba: 9802         	ldr	r0, [sp, #0x8]
700afebc: 6800         	ldr	r0, [r0]
700afebe: f240 511c    	movw	r1, #0x51c
700afec2: f2c7 010b    	movt	r1, #0x700b
700afec6: f7ff ffc3    	bl	0x700afe50 <HwiP_setVecAddr> @ imm = #-0x7a
700afeca: 9801         	ldr	r0, [sp, #0x4]
;     gHwiCtrl.isr[obj->intNum] = NULL;
700afecc: 9902         	ldr	r1, [sp, #0x8]
700afece: 680a         	ldr	r2, [r1]
700afed0: f240 0100    	movw	r1, #0x0
700afed4: f2c7 0108    	movt	r1, #0x7008
700afed8: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     gHwiCtrl.isrArgs[obj->intNum] = NULL;
700afedc: 9a02         	ldr	r2, [sp, #0x8]
700afede: 6812         	ldr	r2, [r2]
700afee0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700afee4: f8c1 0800    	str.w	r0, [r1, #0x800]
; }
700afee8: b004         	add	sp, #0x10
700afeea: bd80         	pop	{r7, pc}
700afeec: bf00         	nop
700afeee: bf00         	nop

700afef0 <HwiP_init>:
; {
700afef0: b580         	push	{r7, lr}
700afef2: b084         	sub	sp, #0x10
;     (void) HwiP_disable();
700afef4: f000 ebb4    	blx	0x700b0660 <HwiP_disable> @ imm = #0x768
;     (void) HwiP_disableFIQ();
700afef8: f000 ebba    	blx	0x700b0670 <HwiP_disableFIQ> @ imm = #0x774
;     DebugP_assertNoLog(gHwiConfig.intcBaseAddr != 0U);
700afefc: f242 60a8    	movw	r0, #0x26a8
700aff00: f2c7 000b    	movt	r0, #0x700b
700aff04: 6800         	ldr	r0, [r0]
700aff06: 2800         	cmp	r0, #0x0
700aff08: bf18         	it	ne
700aff0a: 2001         	movne	r0, #0x1
700aff0c: f001 f868    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x10d0
;     gHwiCtrl.spuriousIRQCount = 0;
700aff10: f240 0100    	movw	r1, #0x0
700aff14: f2c7 0108    	movt	r1, #0x7008
700aff18: f44f 5280    	mov.w	r2, #0x1000
700aff1c: 2000         	movs	r0, #0x0
700aff1e: 5088         	str	r0, [r1, r2]
700aff20: f241 0204    	movw	r2, #0x1004
;     gHwiCtrl.spuriousFIQCount = 0;
700aff24: 5088         	str	r0, [r1, r2]
;     for(i=0; i<HwiP_MAX_INTERRUPTS; i++)
700aff26: 9003         	str	r0, [sp, #0xc]
700aff28: e7ff         	b	0x700aff2a <HwiP_init+0x3a> @ imm = #-0x2
700aff2a: 9903         	ldr	r1, [sp, #0xc]
700aff2c: 2000         	movs	r0, #0x0
700aff2e: ebb0 2f51    	cmp.w	r0, r1, lsr #9
700aff32: d11d         	bne	0x700aff70 <HwiP_init+0x80> @ imm = #0x3a
700aff34: e7ff         	b	0x700aff36 <HwiP_init+0x46> @ imm = #-0x2
;         gHwiCtrl.isr[i] = NULL;
700aff36: 9a03         	ldr	r2, [sp, #0xc]
700aff38: f240 0100    	movw	r1, #0x0
700aff3c: f2c7 0108    	movt	r1, #0x7008
700aff40: 2000         	movs	r0, #0x0
700aff42: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gHwiCtrl.isrArgs[i] = NULL;
700aff46: 9a03         	ldr	r2, [sp, #0xc]
700aff48: eb01 0182    	add.w	r1, r1, r2, lsl #2
700aff4c: f8c1 0800    	str.w	r0, [r1, #0x800]
;         HwiP_setPri(i, 0xF);
700aff50: 9803         	ldr	r0, [sp, #0xc]
700aff52: 210f         	movs	r1, #0xf
700aff54: f7ff ff34    	bl	0x700afdc0 <HwiP_setPri> @ imm = #-0x198
;         HwiP_setVecAddr(i, (uintptr_t)HwiP_irq_handler);
700aff58: 9803         	ldr	r0, [sp, #0xc]
700aff5a: f240 511c    	movw	r1, #0x51c
700aff5e: f2c7 010b    	movt	r1, #0x700b
700aff62: f7ff ff75    	bl	0x700afe50 <HwiP_setVecAddr> @ imm = #-0x116
;     }
700aff66: e7ff         	b	0x700aff68 <HwiP_init+0x78> @ imm = #-0x2
;     for(i=0; i<HwiP_MAX_INTERRUPTS; i++)
700aff68: 9803         	ldr	r0, [sp, #0xc]
700aff6a: 3001         	adds	r0, #0x1
700aff6c: 9003         	str	r0, [sp, #0xc]
700aff6e: e7dc         	b	0x700aff2a <HwiP_init+0x3a> @ imm = #-0x48
700aff70: 2000         	movs	r0, #0x0
;     for(i=0; i<(HwiP_MAX_INTERRUPTS/INTERRUPT_VALUE); i++)
700aff72: 9003         	str	r0, [sp, #0xc]
700aff74: e7ff         	b	0x700aff76 <HwiP_init+0x86> @ imm = #-0x2
700aff76: 9803         	ldr	r0, [sp, #0xc]
700aff78: 280f         	cmp	r0, #0xf
700aff7a: d838         	bhi	0x700affee <HwiP_init+0xfe> @ imm = #0x70
700aff7c: e7ff         	b	0x700aff7e <HwiP_init+0x8e> @ imm = #-0x2
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_DIS(i*INTERRUPT_VALUE));
700aff7e: f242 61a8    	movw	r1, #0x26a8
700aff82: f2c7 010b    	movt	r1, #0x700b
700aff86: 6808         	ldr	r0, [r1]
700aff88: 9a03         	ldr	r2, [sp, #0xc]
700aff8a: f002 020f    	and	r2, r2, #0xf
700aff8e: eb00 1042    	add.w	r0, r0, r2, lsl #5
700aff92: f200 400c    	addw	r0, r0, #0x40c
700aff96: 9002         	str	r0, [sp, #0x8]
;         *addr = 0xFFFFFFFFu;
700aff98: 9a02         	ldr	r2, [sp, #0x8]
700aff9a: f04f 30ff    	mov.w	r0, #0xffffffff
700aff9e: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_STS(i*INTERRUPT_VALUE));
700affa0: 680a         	ldr	r2, [r1]
700affa2: 9b03         	ldr	r3, [sp, #0xc]
700affa4: f003 030f    	and	r3, r3, #0xf
700affa8: eb02 1243    	add.w	r2, r2, r3, lsl #5
700affac: f202 4204    	addw	r2, r2, #0x404
700affb0: 9202         	str	r2, [sp, #0x8]
;         *addr = 0xFFFFFFFFu;
700affb2: 9a02         	ldr	r2, [sp, #0x8]
700affb4: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(i*INTERRUPT_VALUE));
700affb6: 6808         	ldr	r0, [r1]
700affb8: 9a03         	ldr	r2, [sp, #0xc]
700affba: f002 020f    	and	r2, r2, #0xf
700affbe: eb00 1042    	add.w	r0, r0, r2, lsl #5
700affc2: f200 401c    	addw	r0, r0, #0x41c
700affc6: 9002         	str	r0, [sp, #0x8]
;         *addr = 0x0u;
700affc8: 9a02         	ldr	r2, [sp, #0x8]
700affca: 2000         	movs	r0, #0x0
700affcc: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_MAP(i*INTERRUPT_VALUE));
700affce: 6809         	ldr	r1, [r1]
700affd0: 9a03         	ldr	r2, [sp, #0xc]
700affd2: f002 020f    	and	r2, r2, #0xf
700affd6: eb01 1142    	add.w	r1, r1, r2, lsl #5
700affda: f501 6183    	add.w	r1, r1, #0x418
700affde: 9102         	str	r1, [sp, #0x8]
;         *addr = 0x0u;
700affe0: 9902         	ldr	r1, [sp, #0x8]
700affe2: 6008         	str	r0, [r1]
;     }
700affe4: e7ff         	b	0x700affe6 <HwiP_init+0xf6> @ imm = #-0x2
;     for(i=0; i<(HwiP_MAX_INTERRUPTS/INTERRUPT_VALUE); i++)
700affe6: 9803         	ldr	r0, [sp, #0xc]
700affe8: 3001         	adds	r0, #0x1
700affea: 9003         	str	r0, [sp, #0xc]
700affec: e7c3         	b	0x700aff76 <HwiP_init+0x86> @ imm = #-0x7a
;         gdummy = HwiP_getIRQVecAddr();
700affee: f000 f817    	bl	0x700b0020 <HwiP_getIRQVecAddr> @ imm = #0x2e
700afff2: f245 110c    	movw	r1, #0x510c
700afff6: f2c7 0108    	movt	r1, #0x7008
700afffa: 9100         	str	r1, [sp]
700afffc: 6008         	str	r0, [r1]
;         gdummy = HwiP_getFIQVecAddr();
700afffe: f000 f81f    	bl	0x700b0040 <HwiP_getFIQVecAddr> @ imm = #0x3e
700b0002: 9900         	ldr	r1, [sp]
700b0004: 6008         	str	r0, [r1]
700b0006: 2000         	movs	r0, #0x0
;         HwiP_ackIRQ(0);
700b0008: 9001         	str	r0, [sp, #0x4]
700b000a: f000 f829    	bl	0x700b0060 <HwiP_ackIRQ> @ imm = #0x52
700b000e: 9801         	ldr	r0, [sp, #0x4]
;         HwiP_ackFIQ(0);
700b0010: f000 f836    	bl	0x700b0080 <HwiP_ackFIQ> @ imm = #0x6c
;     HwiP_enableVIC();
700b0014: f000 eb48    	blx	0x700b06a8 <HwiP_enableVIC> @ imm = #0x690
;     HwiP_enableFIQ();
700b0018: f000 eb3a    	blx	0x700b0690 <HwiP_enableFIQ> @ imm = #0x674
; }
700b001c: b004         	add	sp, #0x10
700b001e: bd80         	pop	{r7, pc}

700b0020 <HwiP_getIRQVecAddr>:
; {
700b0020: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700b0022: f242 60a8    	movw	r0, #0x26a8
700b0026: f2c7 000b    	movt	r0, #0x700b
700b002a: 6800         	ldr	r0, [r0]
700b002c: 3018         	adds	r0, #0x18
700b002e: 9000         	str	r0, [sp]
;     return *addr;
700b0030: 9800         	ldr	r0, [sp]
700b0032: 6800         	ldr	r0, [r0]
700b0034: b001         	add	sp, #0x4
700b0036: 4770         	bx	lr
700b0038: bf00         	nop
700b003a: bf00         	nop
700b003c: bf00         	nop
700b003e: bf00         	nop

700b0040 <HwiP_getFIQVecAddr>:
; {
700b0040: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b0042: f242 60a8    	movw	r0, #0x26a8
700b0046: f2c7 000b    	movt	r0, #0x700b
700b004a: 6800         	ldr	r0, [r0]
700b004c: 301c         	adds	r0, #0x1c
700b004e: 9000         	str	r0, [sp]
;     return *addr;
700b0050: 9800         	ldr	r0, [sp]
700b0052: 6800         	ldr	r0, [r0]
700b0054: b001         	add	sp, #0x4
700b0056: 4770         	bx	lr
700b0058: bf00         	nop
700b005a: bf00         	nop
700b005c: bf00         	nop
700b005e: bf00         	nop

700b0060 <HwiP_ackIRQ>:
; {
700b0060: b082         	sub	sp, #0x8
700b0062: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700b0064: f242 60a8    	movw	r0, #0x26a8
700b0068: f2c7 000b    	movt	r0, #0x700b
700b006c: 6800         	ldr	r0, [r0]
700b006e: 3018         	adds	r0, #0x18
700b0070: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0072: 9801         	ldr	r0, [sp, #0x4]
700b0074: 9900         	ldr	r1, [sp]
700b0076: 6008         	str	r0, [r1]
; }
700b0078: b002         	add	sp, #0x8
700b007a: 4770         	bx	lr
700b007c: bf00         	nop
700b007e: bf00         	nop

700b0080 <HwiP_ackFIQ>:
; {
700b0080: b082         	sub	sp, #0x8
700b0082: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b0084: f242 60a8    	movw	r0, #0x26a8
700b0088: f2c7 000b    	movt	r0, #0x700b
700b008c: 6800         	ldr	r0, [r0]
700b008e: 301c         	adds	r0, #0x1c
700b0090: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0092: 9801         	ldr	r0, [sp, #0x4]
700b0094: 9900         	ldr	r1, [sp]
700b0096: 6008         	str	r0, [r1]
; }
700b0098: b002         	add	sp, #0x8
700b009a: 4770         	bx	lr
700b009c: bf00         	nop
700b009e: bf00         	nop

700b00a0 <HwiP_inISR>:
; {
700b00a0: b580         	push	{r7, lr}
700b00a2: b082         	sub	sp, #0x8
;     uint32_t mode = (HwiP_getCPSR() & 0x1FU);
700b00a4: f000 eb10    	blx	0x700b06c8 <HwiP_getCPSR> @ imm = #0x620
700b00a8: f000 001f    	and	r0, r0, #0x1f
700b00ac: 9001         	str	r0, [sp, #0x4]
700b00ae: 2000         	movs	r0, #0x0
;     uint32_t result =0;
700b00b0: 9000         	str	r0, [sp]
;     if(mode != ARMV7R_SYSTEM_MODE)
700b00b2: 9801         	ldr	r0, [sp, #0x4]
700b00b4: 281f         	cmp	r0, #0x1f
700b00b6: d003         	beq	0x700b00c0 <HwiP_inISR+0x20> @ imm = #0x6
700b00b8: e7ff         	b	0x700b00ba <HwiP_inISR+0x1a> @ imm = #-0x2
700b00ba: 2001         	movs	r0, #0x1
;          result= 1;
700b00bc: 9000         	str	r0, [sp]
;     }
700b00be: e7ff         	b	0x700b00c0 <HwiP_inISR+0x20> @ imm = #-0x2
;     return result;
700b00c0: 9800         	ldr	r0, [sp]
700b00c2: b002         	add	sp, #0x8
700b00c4: bd80         	pop	{r7, pc}
		...
700b00ce: 0000         	movs	r0, r0

700b00d0 <HwiP_irq_handler_c>:
; {
700b00d0: b580         	push	{r7, lr}
700b00d2: b086         	sub	sp, #0x18
700b00d4: a804         	add	r0, sp, #0x10
;     status = HwiP_getIRQ(&intNum);
700b00d6: f000 f843    	bl	0x700b0160 <HwiP_getIRQ> @ imm = #0x86
700b00da: 9005         	str	r0, [sp, #0x14]
;     if(status==SystemP_SUCCESS)
700b00dc: 9805         	ldr	r0, [sp, #0x14]
700b00de: bb78         	cbnz	r0, 0x700b0140 <HwiP_irq_handler_c+0x70> @ imm = #0x5e
700b00e0: e7ff         	b	0x700b00e2 <HwiP_irq_handler_c+0x12> @ imm = #-0x2
;         uint32_t isPulse = HwiP_isPulse(intNum);
700b00e2: 9804         	ldr	r0, [sp, #0x10]
700b00e4: f000 f864    	bl	0x700b01b0 <HwiP_isPulse> @ imm = #0xc8
700b00e8: 9003         	str	r0, [sp, #0xc]
;         if(isPulse != 0U)
700b00ea: 9803         	ldr	r0, [sp, #0xc]
700b00ec: b120         	cbz	r0, 0x700b00f8 <HwiP_irq_handler_c+0x28> @ imm = #0x8
700b00ee: e7ff         	b	0x700b00f0 <HwiP_irq_handler_c+0x20> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b00f0: 9804         	ldr	r0, [sp, #0x10]
700b00f2: f7ff fd6d    	bl	0x700afbd0 <HwiP_clearInt> @ imm = #-0x526
;         }
700b00f6: e7ff         	b	0x700b00f8 <HwiP_irq_handler_c+0x28> @ imm = #-0x2
;         isr = gHwiCtrl.isr[intNum];
700b00f8: 9904         	ldr	r1, [sp, #0x10]
700b00fa: f240 0000    	movw	r0, #0x0
700b00fe: f2c7 0008    	movt	r0, #0x7008
700b0102: f850 1021    	ldr.w	r1, [r0, r1, lsl #2]
700b0106: 9102         	str	r1, [sp, #0x8]
;         args = gHwiCtrl.isrArgs[intNum];
700b0108: 9904         	ldr	r1, [sp, #0x10]
700b010a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700b010e: f8d0 0800    	ldr.w	r0, [r0, #0x800]
700b0112: 9001         	str	r0, [sp, #0x4]
;         HwiP_enable();
700b0114: f000 eab4    	blx	0x700b0680 <HwiP_enable> @ imm = #0x568
;         if(isr!=NULL)
700b0118: 9802         	ldr	r0, [sp, #0x8]
700b011a: b120         	cbz	r0, 0x700b0126 <HwiP_irq_handler_c+0x56> @ imm = #0x8
700b011c: e7ff         	b	0x700b011e <HwiP_irq_handler_c+0x4e> @ imm = #-0x2
;             isr(args);
700b011e: 9902         	ldr	r1, [sp, #0x8]
700b0120: 9801         	ldr	r0, [sp, #0x4]
700b0122: 4788         	blx	r1
;         }
700b0124: e7ff         	b	0x700b0126 <HwiP_irq_handler_c+0x56> @ imm = #-0x2
;         (void)HwiP_disable();
700b0126: f000 ea9c    	blx	0x700b0660 <HwiP_disable> @ imm = #0x538
;         if(isPulse == 0U)
700b012a: 9803         	ldr	r0, [sp, #0xc]
700b012c: b920         	cbnz	r0, 0x700b0138 <HwiP_irq_handler_c+0x68> @ imm = #0x8
700b012e: e7ff         	b	0x700b0130 <HwiP_irq_handler_c+0x60> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b0130: 9804         	ldr	r0, [sp, #0x10]
700b0132: f7ff fd4d    	bl	0x700afbd0 <HwiP_clearInt> @ imm = #-0x566
;         }
700b0136: e7ff         	b	0x700b0138 <HwiP_irq_handler_c+0x68> @ imm = #-0x2
;         HwiP_ackIRQ(intNum);
700b0138: 9804         	ldr	r0, [sp, #0x10]
700b013a: f000 f859    	bl	0x700b01f0 <HwiP_ackIRQ> @ imm = #0xb2
;     }
700b013e: e00c         	b	0x700b015a <HwiP_irq_handler_c+0x8a> @ imm = #0x18
;         gHwiCtrl.spuriousIRQCount++;
700b0140: f240 0100    	movw	r1, #0x0
700b0144: f2c7 0108    	movt	r1, #0x7008
700b0148: f44f 5280    	mov.w	r2, #0x1000
700b014c: 5888         	ldr	r0, [r1, r2]
700b014e: 3001         	adds	r0, #0x1
700b0150: 5088         	str	r0, [r1, r2]
700b0152: 2000         	movs	r0, #0x0
;         HwiP_ackIRQ(0);
700b0154: f000 f84c    	bl	0x700b01f0 <HwiP_ackIRQ> @ imm = #0x98
700b0158: e7ff         	b	0x700b015a <HwiP_irq_handler_c+0x8a> @ imm = #-0x2
; }
700b015a: b006         	add	sp, #0x18
700b015c: bd80         	pop	{r7, pc}
700b015e: bf00         	nop

700b0160 <HwiP_getIRQ>:
; {
700b0160: b084         	sub	sp, #0x10
700b0162: 9003         	str	r0, [sp, #0xc]
700b0164: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700b0168: 9001         	str	r0, [sp, #0x4]
;     *intNum = 0;
700b016a: 9903         	ldr	r1, [sp, #0xc]
700b016c: 2000         	movs	r0, #0x0
700b016e: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_ACTIRQ);
700b0170: f242 60a8    	movw	r0, #0x26a8
700b0174: f2c7 000b    	movt	r0, #0x700b
700b0178: 6800         	ldr	r0, [r0]
700b017a: 3020         	adds	r0, #0x20
700b017c: 9002         	str	r0, [sp, #0x8]
;     value = *addr;
700b017e: 9802         	ldr	r0, [sp, #0x8]
700b0180: 6800         	ldr	r0, [r0]
700b0182: 9000         	str	r0, [sp]
;     if((value & 0x80000000U) != 0U)
700b0184: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700b0188: 0600         	lsls	r0, r0, #0x18
700b018a: 2800         	cmp	r0, #0x0
700b018c: d508         	bpl	0x700b01a0 <HwiP_getIRQ+0x40> @ imm = #0x10
700b018e: e7ff         	b	0x700b0190 <HwiP_getIRQ+0x30> @ imm = #-0x2
;         *intNum = (value & (HwiP_MAX_INTERRUPTS-1U));
700b0190: 9800         	ldr	r0, [sp]
700b0192: f36f 205f    	bfc	r0, #9, #23
700b0196: 9903         	ldr	r1, [sp, #0xc]
700b0198: 6008         	str	r0, [r1]
700b019a: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700b019c: 9001         	str	r0, [sp, #0x4]
;     }
700b019e: e7ff         	b	0x700b01a0 <HwiP_getIRQ+0x40> @ imm = #-0x2
;     return status;
700b01a0: 9801         	ldr	r0, [sp, #0x4]
700b01a2: b004         	add	sp, #0x10
700b01a4: 4770         	bx	lr
700b01a6: bf00         	nop
700b01a8: bf00         	nop
700b01aa: bf00         	nop
700b01ac: bf00         	nop
700b01ae: bf00         	nop

700b01b0 <HwiP_isPulse>:
; {
700b01b0: b083         	sub	sp, #0xc
700b01b2: 9002         	str	r0, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(intNum));
700b01b4: f242 60a8    	movw	r0, #0x26a8
700b01b8: f2c7 000b    	movt	r0, #0x700b
700b01bc: 6801         	ldr	r1, [r0]
700b01be: 9802         	ldr	r0, [sp, #0x8]
700b01c0: f400 70f0    	and	r0, r0, #0x1e0
700b01c4: 4408         	add	r0, r1
700b01c6: f200 401c    	addw	r0, r0, #0x41c
700b01ca: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700b01cc: 9802         	ldr	r0, [sp, #0x8]
700b01ce: f000 001f    	and	r0, r0, #0x1f
700b01d2: 9000         	str	r0, [sp]
;     return ((*addr >> bitPos) & 0x1u );
700b01d4: 9801         	ldr	r0, [sp, #0x4]
700b01d6: 6800         	ldr	r0, [r0]
700b01d8: 9900         	ldr	r1, [sp]
700b01da: 40c8         	lsrs	r0, r1
700b01dc: f000 0001    	and	r0, r0, #0x1
700b01e0: b003         	add	sp, #0xc
700b01e2: 4770         	bx	lr
700b01e4: bf00         	nop
700b01e6: bf00         	nop
700b01e8: bf00         	nop
700b01ea: bf00         	nop
700b01ec: bf00         	nop
700b01ee: bf00         	nop

700b01f0 <HwiP_ackIRQ>:
; {
700b01f0: b082         	sub	sp, #0x8
700b01f2: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700b01f4: f242 60a8    	movw	r0, #0x26a8
700b01f8: f2c7 000b    	movt	r0, #0x700b
700b01fc: 6800         	ldr	r0, [r0]
700b01fe: 3018         	adds	r0, #0x18
700b0200: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0202: 9801         	ldr	r0, [sp, #0x4]
700b0204: 9900         	ldr	r1, [sp]
700b0206: 6008         	str	r0, [r1]
; }
700b0208: b002         	add	sp, #0x8
700b020a: 4770         	bx	lr
700b020c: bf00         	nop
700b020e: bf00         	nop

700b0210 <HwiP_fiq_handler>:
; {
700b0210: b5df         	push	{r0, r1, r2, r3, r4, r6, r7, lr}
700b0212: af06         	add	r7, sp, #0x18
700b0214: b086         	sub	sp, #0x18
700b0216: 466c         	mov	r4, sp
700b0218: f36f 0402    	bfc	r4, #0, #3
700b021c: 46a5         	mov	sp, r4
;     gdummy = HwiP_getFIQVecAddr();
700b021e: f000 f867    	bl	0x700b02f0 <HwiP_getFIQVecAddr> @ imm = #0xce
700b0222: f244 188c    	movw	r8, #0x418c
700b0226: f2c7 0808    	movt	r8, #0x7008
700b022a: f8c8 0000    	str.w	r0, [r8]
700b022e: a804         	add	r0, sp, #0x10
;     status = HwiP_getFIQ(&intNum);
700b0230: f000 f86e    	bl	0x700b0310 <HwiP_getFIQ> @ imm = #0xdc
700b0234: 9005         	str	r0, [sp, #0x14]
;     if(status==SystemP_SUCCESS)
700b0236: f8dd 8014    	ldr.w	r8, [sp, #0x14]
700b023a: f1b8 0f00    	cmp.w	r8, #0x0
700b023e: d13b         	bne	0x700b02b8 <HwiP_fiq_handler+0xa8> @ imm = #0x76
700b0240: e7ff         	b	0x700b0242 <HwiP_fiq_handler+0x32> @ imm = #-0x2
;         uint32_t isPulse = HwiP_isPulse(intNum);
700b0242: 9804         	ldr	r0, [sp, #0x10]
700b0244: f7ff ffb4    	bl	0x700b01b0 <HwiP_isPulse> @ imm = #-0x98
700b0248: 9003         	str	r0, [sp, #0xc]
;         if(isPulse != 0U)
700b024a: f8dd 800c    	ldr.w	r8, [sp, #0xc]
700b024e: f1b8 0f00    	cmp.w	r8, #0x0
700b0252: d004         	beq	0x700b025e <HwiP_fiq_handler+0x4e> @ imm = #0x8
700b0254: e7ff         	b	0x700b0256 <HwiP_fiq_handler+0x46> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b0256: 9804         	ldr	r0, [sp, #0x10]
700b0258: f7ff fcba    	bl	0x700afbd0 <HwiP_clearInt> @ imm = #-0x68c
;         }
700b025c: e7ff         	b	0x700b025e <HwiP_fiq_handler+0x4e> @ imm = #-0x2
;         isr = gHwiCtrl.isr[intNum];
700b025e: f8dd 9010    	ldr.w	r9, [sp, #0x10]
700b0262: f240 0800    	movw	r8, #0x0
700b0266: f2c7 0808    	movt	r8, #0x7008
700b026a: f858 9029    	ldr.w	r9, [r8, r9, lsl #2]
700b026e: f8cd 9008    	str.w	r9, [sp, #0x8]
;         args = gHwiCtrl.isrArgs[intNum];
700b0272: f8dd 9010    	ldr.w	r9, [sp, #0x10]
700b0276: eb08 0889    	add.w	r8, r8, r9, lsl #2
700b027a: f8d8 8800    	ldr.w	r8, [r8, #0x800]
700b027e: f8cd 8004    	str.w	r8, [sp, #0x4]
;         if(isr!=NULL)
700b0282: f8dd 8008    	ldr.w	r8, [sp, #0x8]
700b0286: f1b8 0f00    	cmp.w	r8, #0x0
700b028a: d005         	beq	0x700b0298 <HwiP_fiq_handler+0x88> @ imm = #0xa
700b028c: e7ff         	b	0x700b028e <HwiP_fiq_handler+0x7e> @ imm = #-0x2
;             isr(args);
700b028e: f8dd 8008    	ldr.w	r8, [sp, #0x8]
700b0292: 9801         	ldr	r0, [sp, #0x4]
700b0294: 47c0         	blx	r8
;         }
700b0296: e7ff         	b	0x700b0298 <HwiP_fiq_handler+0x88> @ imm = #-0x2
;         (void)HwiP_disableFIQ();
700b0298: f000 e9ea    	blx	0x700b0670 <HwiP_disableFIQ> @ imm = #0x3d4
;         if(isPulse == 0U)
700b029c: f8dd 800c    	ldr.w	r8, [sp, #0xc]
700b02a0: f1b8 0f00    	cmp.w	r8, #0x0
700b02a4: d104         	bne	0x700b02b0 <HwiP_fiq_handler+0xa0> @ imm = #0x8
700b02a6: e7ff         	b	0x700b02a8 <HwiP_fiq_handler+0x98> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b02a8: 9804         	ldr	r0, [sp, #0x10]
700b02aa: f7ff fc91    	bl	0x700afbd0 <HwiP_clearInt> @ imm = #-0x6de
;         }
700b02ae: e7ff         	b	0x700b02b0 <HwiP_fiq_handler+0xa0> @ imm = #-0x2
;         HwiP_ackFIQ(intNum);
700b02b0: 9804         	ldr	r0, [sp, #0x10]
700b02b2: f000 f855    	bl	0x700b0360 <HwiP_ackFIQ> @ imm = #0xaa
;     }
700b02b6: e00f         	b	0x700b02d8 <HwiP_fiq_handler+0xc8> @ imm = #0x1e
;         gHwiCtrl.spuriousFIQCount++;
700b02b8: f240 0900    	movw	r9, #0x0
700b02bc: f2c7 0908    	movt	r9, #0x7008
700b02c0: f241 0a04    	movw	r10, #0x1004
700b02c4: f859 800a    	ldr.w	r8, [r9, r10]
700b02c8: f108 0801    	add.w	r8, r8, #0x1
700b02cc: f849 800a    	str.w	r8, [r9, r10]
700b02d0: 2000         	movs	r0, #0x0
;         HwiP_ackFIQ(0);
700b02d2: f000 f845    	bl	0x700b0360 <HwiP_ackFIQ> @ imm = #0x8a
700b02d6: e7ff         	b	0x700b02d8 <HwiP_fiq_handler+0xc8> @ imm = #-0x2
; }
700b02d8: f1a7 0418    	sub.w	r4, r7, #0x18
700b02dc: 46a5         	mov	sp, r4
700b02de: e8bd 40df    	pop.w	{r0, r1, r2, r3, r4, r6, r7, lr}
700b02e2: f3de 8f04    	subs	pc, lr, #0x4
700b02e6: bf00         	nop
700b02e8: bf00         	nop
700b02ea: bf00         	nop
700b02ec: bf00         	nop
700b02ee: bf00         	nop

700b02f0 <HwiP_getFIQVecAddr>:
; {
700b02f0: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b02f2: f242 60a8    	movw	r0, #0x26a8
700b02f6: f2c7 000b    	movt	r0, #0x700b
700b02fa: 6800         	ldr	r0, [r0]
700b02fc: 301c         	adds	r0, #0x1c
700b02fe: 9000         	str	r0, [sp]
;     return *addr;
700b0300: 9800         	ldr	r0, [sp]
700b0302: 6800         	ldr	r0, [r0]
700b0304: b001         	add	sp, #0x4
700b0306: 4770         	bx	lr
700b0308: bf00         	nop
700b030a: bf00         	nop
700b030c: bf00         	nop
700b030e: bf00         	nop

700b0310 <HwiP_getFIQ>:
; {
700b0310: b084         	sub	sp, #0x10
700b0312: 9003         	str	r0, [sp, #0xc]
700b0314: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700b0318: 9001         	str	r0, [sp, #0x4]
;     *intNum = 0;
700b031a: 9903         	ldr	r1, [sp, #0xc]
700b031c: 2000         	movs	r0, #0x0
700b031e: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_ACTFIQ);
700b0320: f242 60a8    	movw	r0, #0x26a8
700b0324: f2c7 000b    	movt	r0, #0x700b
700b0328: 6800         	ldr	r0, [r0]
700b032a: 3024         	adds	r0, #0x24
700b032c: 9002         	str	r0, [sp, #0x8]
;     value = *addr;
700b032e: 9802         	ldr	r0, [sp, #0x8]
700b0330: 6800         	ldr	r0, [r0]
700b0332: 9000         	str	r0, [sp]
;     if((value & 0x80000000U) != 0U)
700b0334: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700b0338: 0600         	lsls	r0, r0, #0x18
700b033a: 2800         	cmp	r0, #0x0
700b033c: d508         	bpl	0x700b0350 <HwiP_getFIQ+0x40> @ imm = #0x10
700b033e: e7ff         	b	0x700b0340 <HwiP_getFIQ+0x30> @ imm = #-0x2
;         *intNum = (value & 0x3FFU);
700b0340: 9800         	ldr	r0, [sp]
700b0342: f36f 209f    	bfc	r0, #10, #22
700b0346: 9903         	ldr	r1, [sp, #0xc]
700b0348: 6008         	str	r0, [r1]
700b034a: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700b034c: 9001         	str	r0, [sp, #0x4]
;     }
700b034e: e7ff         	b	0x700b0350 <HwiP_getFIQ+0x40> @ imm = #-0x2
;     return status;
700b0350: 9801         	ldr	r0, [sp, #0x4]
700b0352: b004         	add	sp, #0x10
700b0354: 4770         	bx	lr
700b0356: bf00         	nop
700b0358: bf00         	nop
700b035a: bf00         	nop
700b035c: bf00         	nop
700b035e: bf00         	nop

700b0360 <HwiP_ackFIQ>:
; {
700b0360: b082         	sub	sp, #0x8
700b0362: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b0364: f242 60a8    	movw	r0, #0x26a8
700b0368: f2c7 000b    	movt	r0, #0x700b
700b036c: 6800         	ldr	r0, [r0]
700b036e: 301c         	adds	r0, #0x1c
700b0370: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0372: 9801         	ldr	r0, [sp, #0x4]
700b0374: 9900         	ldr	r1, [sp]
700b0376: 6008         	str	r0, [r1]
; }
700b0378: b002         	add	sp, #0x8
700b037a: 4770         	bx	lr
700b037c: bf00         	nop
700b037e: bf00         	nop

700b0380 <HwiP_reserved_handler>:
; {
700b0380: b5d0         	push	{r4, r6, r7, lr}
700b0382: af02         	add	r7, sp, #0x8
700b0384: b082         	sub	sp, #0x8
700b0386: 466c         	mov	r4, sp
700b0388: f36f 0402    	bfc	r4, #0, #3
700b038c: 46a5         	mov	sp, r4
700b038e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b0392: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U) { ; }
700b0396: e7ff         	b	0x700b0398 <HwiP_reserved_handler+0x18> @ imm = #-0x2
700b0398: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b039c: f1be 0f00    	cmp.w	lr, #0x0
700b03a0: d001         	beq	0x700b03a6 <HwiP_reserved_handler+0x26> @ imm = #0x2
700b03a2: e7ff         	b	0x700b03a4 <HwiP_reserved_handler+0x24> @ imm = #-0x2
700b03a4: e7f8         	b	0x700b0398 <HwiP_reserved_handler+0x18> @ imm = #-0x10
; }
700b03a6: f1a7 0408    	sub.w	r4, r7, #0x8
700b03aa: 46a5         	mov	sp, r4
700b03ac: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b03b0: f3de 8f00    	subs	pc, lr, #0x0
700b03b4: bf00         	nop
700b03b6: bf00         	nop
700b03b8: bf00         	nop
700b03ba: bf00         	nop
700b03bc: bf00         	nop
700b03be: bf00         	nop

700b03c0 <HwiP_undefined_handler>:
; {
700b03c0: b5d0         	push	{r4, r6, r7, lr}
700b03c2: af02         	add	r7, sp, #0x8
700b03c4: b082         	sub	sp, #0x8
700b03c6: 466c         	mov	r4, sp
700b03c8: f36f 0402    	bfc	r4, #0, #3
700b03cc: 46a5         	mov	sp, r4
700b03ce: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b03d2: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U){  ; }
700b03d6: e7ff         	b	0x700b03d8 <HwiP_undefined_handler+0x18> @ imm = #-0x2
700b03d8: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b03dc: f1be 0f00    	cmp.w	lr, #0x0
700b03e0: d001         	beq	0x700b03e6 <HwiP_undefined_handler+0x26> @ imm = #0x2
700b03e2: e7ff         	b	0x700b03e4 <HwiP_undefined_handler+0x24> @ imm = #-0x2
700b03e4: e7f8         	b	0x700b03d8 <HwiP_undefined_handler+0x18> @ imm = #-0x10
; }
700b03e6: f1a7 0408    	sub.w	r4, r7, #0x8
700b03ea: 46a5         	mov	sp, r4
700b03ec: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b03f0: f3de 8f00    	subs	pc, lr, #0x0
700b03f4: bf00         	nop
700b03f6: bf00         	nop
700b03f8: bf00         	nop
700b03fa: bf00         	nop
700b03fc: bf00         	nop
700b03fe: bf00         	nop

700b0400 <HwiP_prefetch_abort_handler>:
; {
700b0400: b5d0         	push	{r4, r6, r7, lr}
700b0402: af02         	add	r7, sp, #0x8
700b0404: b082         	sub	sp, #0x8
700b0406: 466c         	mov	r4, sp
700b0408: f36f 0402    	bfc	r4, #0, #3
700b040c: 46a5         	mov	sp, r4
700b040e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b0412: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U)  { ;}
700b0416: e7ff         	b	0x700b0418 <HwiP_prefetch_abort_handler+0x18> @ imm = #-0x2
700b0418: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b041c: f1be 0f00    	cmp.w	lr, #0x0
700b0420: d001         	beq	0x700b0426 <HwiP_prefetch_abort_handler+0x26> @ imm = #0x2
700b0422: e7ff         	b	0x700b0424 <HwiP_prefetch_abort_handler+0x24> @ imm = #-0x2
700b0424: e7f8         	b	0x700b0418 <HwiP_prefetch_abort_handler+0x18> @ imm = #-0x10
; }
700b0426: f1a7 0408    	sub.w	r4, r7, #0x8
700b042a: 46a5         	mov	sp, r4
700b042c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b0430: f3de 8f04    	subs	pc, lr, #0x4
700b0434: bf00         	nop
700b0436: bf00         	nop
700b0438: bf00         	nop
700b043a: bf00         	nop
700b043c: bf00         	nop
700b043e: bf00         	nop

700b0440 <HwiP_data_abort_handler_c>:
; {
700b0440: b5d0         	push	{r4, r6, r7, lr}
700b0442: af02         	add	r7, sp, #0x8
700b0444: b082         	sub	sp, #0x8
700b0446: 466c         	mov	r4, sp
700b0448: f36f 0402    	bfc	r4, #0, #3
700b044c: 46a5         	mov	sp, r4
700b044e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b0452: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U){ ; }
700b0456: e7ff         	b	0x700b0458 <HwiP_data_abort_handler_c+0x18> @ imm = #-0x2
700b0458: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b045c: f1be 0f00    	cmp.w	lr, #0x0
700b0460: d001         	beq	0x700b0466 <HwiP_data_abort_handler_c+0x26> @ imm = #0x2
700b0462: e7ff         	b	0x700b0464 <HwiP_data_abort_handler_c+0x24> @ imm = #-0x2
700b0464: e7f8         	b	0x700b0458 <HwiP_data_abort_handler_c+0x18> @ imm = #-0x10
; }
700b0466: f1a7 0408    	sub.w	r4, r7, #0x8
700b046a: 46a5         	mov	sp, r4
700b046c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b0470: f3de 8f04    	subs	pc, lr, #0x4

700b0474 <vPortRestoreTaskContext>:
;         CPS     #SYS_MODE
700b0474: f102001f     	cps	#0x1f
;         portRESTORE_CONTEXT
700b0478: e59f01c8     	ldr	r0, [pc, #0x1c8]        @ 0x700b0648 <pxCurrentTCBConst>
700b047c: e5901000     	ldr	r1, [r0]
700b0480: e591d000     	ldr	sp, [r1]
700b0484: e59f01c0     	ldr	r0, [pc, #0x1c0]        @ 0x700b064c <ulPortTaskHasFPUContextConst>
700b0488: e49d1004     	ldr	r1, [sp], #4
700b048c: e5801000     	str	r1, [r0]
700b0490: e3510000     	cmp	r1, #0
700b0494: 149d0004     	ldrne	r0, [sp], #4
700b0498: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b049c: 1ee10a10     	vmsrne	fpscr, r0
700b04a0: f57ff01f     	clrex
700b04a4: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b04a8: f8bd0a00     	rfeia	sp!

700b04ac <HwiP_svc_handler>:
;         portSAVE_CONTEXT
700b04ac: f96d051f     	srsdb	sp!, #0x1f
700b04b0: f102001f     	cps	#0x1f
700b04b4: e92d5fff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b04b8: e59f218c     	ldr	r2, [pc, #0x18c]        @ 0x700b064c <ulPortTaskHasFPUContextConst>
700b04bc: e5923000     	ldr	r3, [r2]
700b04c0: e3530000     	cmp	r3, #0
700b04c4: 1ef11a10     	vmrsne	r1, fpscr
700b04c8: 1d2d0b20     	vpushne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b04cc: 152d1004     	strne	r1, [sp, #-0x4]!
700b04d0: e52d3004     	str	r3, [sp, #-0x4]!
700b04d4: e59f016c     	ldr	r0, [pc, #0x16c]        @ 0x700b0648 <pxCurrentTCBConst>
700b04d8: e5901000     	ldr	r1, [r0]
700b04dc: e581d000     	str	sp, [r1]
;         LDR     R0, vTaskSwitchContextConst
700b04e0: e59f0168     	ldr	r0, [pc, #0x168]        @ 0x700b0650 <vTaskSwitchContextConst>
;         BLX     R0
700b04e4: e12fff30     	blx	r0
;         portRESTORE_CONTEXT
700b04e8: e59f0158     	ldr	r0, [pc, #0x158]        @ 0x700b0648 <pxCurrentTCBConst>
700b04ec: e5901000     	ldr	r1, [r0]
700b04f0: e591d000     	ldr	sp, [r1]
700b04f4: e59f0150     	ldr	r0, [pc, #0x150]        @ 0x700b064c <ulPortTaskHasFPUContextConst>
700b04f8: e49d1004     	ldr	r1, [sp], #4
700b04fc: e5801000     	str	r1, [r0]
700b0500: e3510000     	cmp	r1, #0
700b0504: 149d0004     	ldrne	r0, [sp], #4
700b0508: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b050c: 1ee10a10     	vmsrne	fpscr, r0
700b0510: f57ff01f     	clrex
700b0514: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b0518: f8bd0a00     	rfeia	sp!

700b051c <HwiP_irq_handler>:
;         SUB             lr, lr, #4
700b051c: e24ee004     	sub	lr, lr, #4
;         PUSH    {lr}
700b0520: e52de004     	str	lr, [sp, #-0x4]!
;         MRS     lr, SPSR
700b0524: e14fe000     	mrs	lr, spsr
;         PUSH    {lr}
700b0528: e52de004     	str	lr, [sp, #-0x4]!
;         CPS  #SVC_MODE
700b052c: f1020013     	cps	#0x13
;         PUSH    {r0-r4, r12}
700b0530: e92d101f     	push	{r0, r1, r2, r3, r4, r12}
;         LDR     r3, ulPortInterruptNestingConst
700b0534: e59f3118     	ldr	r3, [pc, #0x118]        @ 0x700b0654 <ulPortInterruptNestingConst>
;         LDR     r1, [r3]
700b0538: e5931000     	ldr	r1, [r3]
;         ADD     r4, r1, #1
700b053c: e2814001     	add	r4, r1, #1
;         STR     r4, [r3]
700b0540: e5834000     	str	r4, [r3]
;         FMRX  R0, FPSCR
700b0544: eef10a10     	vmrs	r0, fpscr
;         VPUSH {D0-D15}
700b0548: ed2d0b20     	vpush	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
;         PUSH  {R0}
700b054c: e52d0004     	str	r0, [sp, #-0x4]!
;         MOV     r2, sp
700b0550: e1a0200d     	mov	r2, sp
;         AND     r2, r2, #4
700b0554: e2022004     	and	r2, r2, #4
;         SUB     sp, sp, r2
700b0558: e04dd002     	sub	sp, sp, r2
;         PUSH    {r0-r4, lr}
700b055c: e92d401f     	push	{r0, r1, r2, r3, r4, lr}
;         LDR     r1, vApplicationIRQHandlerConst
700b0560: e59f10f0     	ldr	r1, [pc, #0xf0]         @ 0x700b0658 <vApplicationIRQHandlerConst>
;         BLX     r1
700b0564: e12fff31     	blx	r1
;         POP     {r0-r4, lr}
700b0568: e8bd401f     	pop	{r0, r1, r2, r3, r4, lr}
;         ADD     sp, sp, r2
700b056c: e08dd002     	add	sp, sp, r2
;         CPSID   i
700b0570: f10c0080     	cpsid	i
;         DSB
700b0574: f57ff04f     	dsb	sy
;         ISB
700b0578: f57ff06f     	isb	sy
;         POP   {R0}
700b057c: e49d0004     	ldr	r0, [sp], #4
;         VPOP  {D0-D15}
700b0580: ecbd0b20     	vpop	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
;         VMSR  FPSCR, R0
700b0584: eee10a10     	vmsr	fpscr, r0
;         STR     r1, [r3]
700b0588: e5831000     	str	r1, [r3]
;         CMP     r1, #0
700b058c: e3510000     	cmp	r1, #0
;         BNE     exit_without_switch
700b0590: 1a000003     	bne	0x700b05a4 <exit_without_switch> @ imm = #0xc
;         LDR     r1, =ulPortYieldRequired
700b0594: e59f10c0     	ldr	r1, [pc, #0xc0]         @ 0x700b065c <vApplicationIRQHandlerConst+0x4>
;         LDR     r0, [r1]
700b0598: e5910000     	ldr	r0, [r1]
;         CMP     r0, #0
700b059c: e3500000     	cmp	r0, #0
;         BNE     switch_before_exit
700b05a0: 1a000005     	bne	0x700b05bc <switch_before_exit> @ imm = #0x14

700b05a4 <exit_without_switch>:
;         POP     {r0-r4, r12}
700b05a4: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         CPS  #IRQ_MODE
700b05a8: f1020012     	cps	#0x12
;         POP     {LR}
700b05ac: e49de004     	ldr	lr, [sp], #4
;         MSR     SPSR_cxsf, LR
700b05b0: e16ff00e     	msr	SPSR_fsxc, lr
;         POP     {LR}
700b05b4: e49de004     	ldr	lr, [sp], #4
;         MOVS    PC, LR
700b05b8: e1b0f00e     	movs	pc, lr

700b05bc <switch_before_exit>:
;         MOV     r0, #0
700b05bc: e3a00000     	mov	r0, #0
;         STR     r0, [r1]
700b05c0: e5810000     	str	r0, [r1]
;         POP     {r0-r4, r12}
700b05c4: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         CPS  #IRQ_MODE
700b05c8: f1020012     	cps	#0x12
;         POP     {LR}
700b05cc: e49de004     	ldr	lr, [sp], #4
;         MSR     SPSR_cxsf, LR
700b05d0: e16ff00e     	msr	SPSR_fsxc, lr
;         POP     {LR}
700b05d4: e49de004     	ldr	lr, [sp], #4
;         portSAVE_CONTEXT
700b05d8: f96d051f     	srsdb	sp!, #0x1f
700b05dc: f102001f     	cps	#0x1f
700b05e0: e92d5fff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b05e4: e59f2060     	ldr	r2, [pc, #0x60]         @ 0x700b064c <ulPortTaskHasFPUContextConst>
700b05e8: e5923000     	ldr	r3, [r2]
700b05ec: e3530000     	cmp	r3, #0
700b05f0: 1ef11a10     	vmrsne	r1, fpscr
700b05f4: 1d2d0b20     	vpushne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b05f8: 152d1004     	strne	r1, [sp, #-0x4]!
700b05fc: e52d3004     	str	r3, [sp, #-0x4]!
700b0600: e59f0040     	ldr	r0, [pc, #0x40]         @ 0x700b0648 <pxCurrentTCBConst>
700b0604: e5901000     	ldr	r1, [r0]
700b0608: e581d000     	str	sp, [r1]
;         LDR     R0, vTaskSwitchContextConst
700b060c: e59f003c     	ldr	r0, [pc, #0x3c]         @ 0x700b0650 <vTaskSwitchContextConst>
;         BLX     R0
700b0610: e12fff30     	blx	r0
;         portRESTORE_CONTEXT
700b0614: e59f002c     	ldr	r0, [pc, #0x2c]         @ 0x700b0648 <pxCurrentTCBConst>
700b0618: e5901000     	ldr	r1, [r0]
700b061c: e591d000     	ldr	sp, [r1]
700b0620: e59f0024     	ldr	r0, [pc, #0x24]         @ 0x700b064c <ulPortTaskHasFPUContextConst>
700b0624: e49d1004     	ldr	r1, [sp], #4
700b0628: e5801000     	str	r1, [r0]
700b062c: e3510000     	cmp	r1, #0
700b0630: 149d0004     	ldrne	r0, [sp], #4
700b0634: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b0638: 1ee10a10     	vmsrne	fpscr, r0
700b063c: f57ff01f     	clrex
700b0640: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b0644: f8bd0a00     	rfeia	sp!

700b0648 <pxCurrentTCBConst>:
700b0648: bc 26 0b 70  	.word	0x700b26bc

700b064c <ulPortTaskHasFPUContextConst>:
700b064c: d4 26 0b 70  	.word	0x700b26d4

700b0650 <vTaskSwitchContextConst>:
700b0650: 41 67 0a 70  	.word	0x700a6741

700b0654 <ulPortInterruptNestingConst>:
700b0654: cc 26 0b 70  	.word	0x700b26cc

700b0658 <vApplicationIRQHandlerConst>:
700b0658: d1 00 0b 70  	.word	0x700b00d1
700b065c: d8 26 0b 70  	.word	0x700b26d8

700b0660 <HwiP_disable>:
;         mrs     r0, cpsr
700b0660: e10f0000     	mrs	r0, apsr
;         orr     r12, r0, #0x80
700b0664: e380c080     	orr	r12, r0, #128
;         msr     cpsr_cf, r12
700b0668: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b066c: e12fff1e     	bx	lr

700b0670 <HwiP_disableFIQ>:
;         mrs     r0, cpsr
700b0670: e10f0000     	mrs	r0, apsr
;         orr     r12, r0, #0x40
700b0674: e380c040     	orr	r12, r0, #64
;         msr     cpsr_cf, r12
700b0678: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b067c: e12fff1e     	bx	lr

700b0680 <HwiP_enable>:
;         mrs     r0, cpsr
700b0680: e10f0000     	mrs	r0, apsr
;         bic     r12, r0, #0x80
700b0684: e3c0c080     	bic	r12, r0, #128
;         msr     cpsr_cf, r12
700b0688: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b068c: e12fff1e     	bx	lr

700b0690 <HwiP_enableFIQ>:
;         mrs     r0, cpsr
700b0690: e10f0000     	mrs	r0, apsr
;         bic     r12, r0, #0x40
700b0694: e3c0c040     	bic	r12, r0, #64
;         msr     cpsr_cf, r12
700b0698: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b069c: e12fff1e     	bx	lr

700b06a0 <HwiP_restore>:
;         msr     cpsr_cf, r0
700b06a0: e129f000     	msr	CPSR_fc, r0
;         bx      LR
700b06a4: e12fff1e     	bx	lr

700b06a8 <HwiP_enableVIC>:
;         MRC     p15, #0, r0, c1, c0, #0  /* Read SCTLR */
700b06a8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         ORR     r0, r0, #(1<<24)         /* Set VE mask (VIC controller provides handler address for IRQ) */
700b06ac: e3800401     	orr	r0, r0, #16777216
;         MCR     p15, #0, r0, c1, c0, #0  /* Write modified SCTLR */
700b06b0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b06b4: e12fff1e     	bx	lr

700b06b8 <HwiP_disableVIC>:
;         MRC     p15, #0, r0, c1, c0, #0  /* Read SCTLR */
700b06b8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         BIC     r0, r0, #(1<<24)         /* Clear VE mask (VIC controller provides handler address for IRQ) */
700b06bc: e3c00401     	bic	r0, r0, #16777216
;         MCR     p15, #0, r0, c1, c0, #0  /* Write modified SCTLR */
700b06c0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b06c4: e12fff1e     	bx	lr

700b06c8 <HwiP_getCPSR>:
;         mrs     r0, cpsr
700b06c8: e10f0000     	mrs	r0, apsr
;         bx      LR
700b06cc: e12fff1e     	bx	lr

700b06d0 <HwiP_data_abort_handler>:
;         PUSH	{r0-r4, r12}
700b06d0: e92d101f     	push	{r0, r1, r2, r3, r4, r12}
;         MRS r0, SPSR
700b06d4: e14f0000     	mrs	r0, spsr
;         AND r1, r0, #0x20
700b06d8: e2001020     	and	r1, r0, #32
;         CMP R1, #0
700b06dc: e3510000     	cmp	r1, #0
;         BEQ ARM_STATE
700b06e0: 0a000000     	beq	0x700b06e8 <ARM_STATE>  @ imm = #0x0
;         SUB lr, lr, #2
700b06e4: e24ee002     	sub	lr, lr, #2

700b06e8 <ARM_STATE>:
;         SUB lr, lr, #4
700b06e8: e24ee004     	sub	lr, lr, #4

700b06ec <END>:
;         PUSH	{lr}
700b06ec: e52de004     	str	lr, [sp, #-0x4]!
;         MRS	lr, SPSR
700b06f0: e14fe000     	mrs	lr, spsr
;         PUSH	{lr}
700b06f4: e52de004     	str	lr, [sp, #-0x4]!
;         LDR	r1, HwiP_data_abort_handler_const
700b06f8: e59f1014     	ldr	r1, [pc, #0x14]         @ 0x700b0714 <HwiP_data_abort_handler_const>
;         BLX	r1
700b06fc: e12fff31     	blx	r1
;         POP	{LR}
700b0700: e49de004     	ldr	lr, [sp], #4
;         MSR	SPSR_cxsf, LR
700b0704: e16ff00e     	msr	SPSR_fsxc, lr
;         POP	{LR}
700b0708: e49de004     	ldr	lr, [sp], #4
;         POP	{r0-r4, r12}
700b070c: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         MOVS	PC, LR
700b0710: e1b0f00e     	movs	pc, lr

700b0714 <HwiP_data_abort_handler_const>:
700b0714: 41 04 0b 70  	.word	0x700b0441
700b0718: 00 00 00 00  	.word	0x00000000
700b071c: 00 00 00 00  	.word	0x00000000

Disassembly of section .text.cache:

700b0720 <CacheP_disableL1d>:
;         push    {r0-r7, r9-r11, lr}
700b0720: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700b0724: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x0004         // clear C bit
700b0728: e3c00004     	bic	r0, r0, #4
;         dsb
700b072c: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0 // L1D cache disabled
700b0730: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         movw    r0, :lower16:CacheP_wbInvAllAsm
700b0734: e300094c     	movw	r0, #0x94c
;         movt    r0, :upper16:CacheP_wbInvAllAsm
700b0738: e347000b     	movt	r0, #0x700b
;         blx     r0
700b073c: e12fff30     	blx	r0
;         pop     {r0-r7, r9-r11, lr}
700b0740: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700b0744: e12fff1e     	bx	lr

700b0748 <CacheP_disableL1p>:
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700b0748: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x1000         // clear I bit
700b074c: e3c00a01     	bic	r0, r0, #4096
;         mcr     p15, #0, r0, c1, c0, #0 // L1P cache disabled
700b0750: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         mcr     p15, #0, r1, c7, c5, #0 // Invalidate entire instruction cache
700b0754: ee071f15     	mcr	p15, #0x0, r1, c7, c5, #0x0
;         isb
700b0758: f57ff06f     	isb	sy
;         bx      lr
700b075c: e12fff1e     	bx	lr

700b0760 <CacheP_enableL1d>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCR register
700b0760: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x0004          // set C bit (bit 2) to 1
700b0764: e3800004     	orr	r0, r0, #4
;         dsb
700b0768: f57ff04f     	dsb	sy
;         mcr     p15, #0, r1, c15, c5, #0 // Invalidate entire data cache
700b076c: ee0f1f15     	mcr	p15, #0x0, r1, c15, c5, #0x0
;         mcr     p15, #0, r0, c1, c0, #0  // L1D cache enabled
700b0770: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      lr
700b0774: e12fff1e     	bx	lr

700b0778 <CacheP_enableL1p>:
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700b0778: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x1000         // set I bit (bit 12) to 1
700b077c: e3800a01     	orr	r0, r0, #4096
;         mcr     p15, #0, r1, c7, c5, #0 // Invalidate entire instruction cache
700b0780: ee071f15     	mcr	p15, #0x0, r1, c7, c5, #0x0
;         mcr     p15, #0, r0, c1, c0, #0 // ICache enabled
700b0784: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb
700b0788: f57ff06f     	isb	sy
;         bx      lr
700b078c: e12fff1e     	bx	lr

700b0790 <CacheP_invL1d>:
;         push    {r4}
700b0790: e52d4004     	str	r4, [sp, #-0x4]!
;         add     r1, r0, r1              // calculate last address
700b0794: e0801001     	add	r1, r0, r1
;         ldr     r3, l1dCacheLineSizeInvL1dAddr
700b0798: e59f3024     	ldr	r3, [pc, #0x24]         @ 0x700b07c4 <l1dCacheLineSizeInvL1dAddr>
;         ldr     r3, [r3]
700b079c: e5933000     	ldr	r3, [r3]
;         sub     r4, r3, #1
700b07a0: e2434001     	sub	r4, r3, #1
;         bic     r0, r0, r4              // align blockPtr to cache line
700b07a4: e1c00004     	bic	r0, r0, r4

700b07a8 <invL1dCache_loop>:
;         mcr     p15, #0, r0, c7, c6, #1 // invalidate single entry in L1D cache
700b07a8: ee070f36     	mcr	p15, #0x0, r0, c7, c6, #0x1
;         add     r0, r0, r3              // increment address by cache line size
700b07ac: e0800003     	add	r0, r0, r3
;         cmp     r0, r1                  // compare to last address
700b07b0: e1500001     	cmp	r0, r1
;         blo     invL1dCache_loop        // loop if > 0
700b07b4: 3afffffb     	blo	0x700b07a8 <invL1dCache_loop> @ imm = #-0x14
;         dsb                             // drain write buffer
700b07b8: f57ff04f     	dsb	sy
;         pop     {r4}
700b07bc: e49d4004     	ldr	r4, [sp], #4
;         bx      lr                      // return
700b07c0: e12fff1e     	bx	lr

700b07c4 <l1dCacheLineSizeInvL1dAddr>:
700b07c4: f4 22 0b 70  	.word	0x700b22f4

700b07c8 <CacheP_invL1p>:
;         push    {r4}
700b07c8: e52d4004     	str	r4, [sp, #-0x4]!
;         add     r1, r0, r1              // calculate last address
700b07cc: e0801001     	add	r1, r0, r1
;         ldr     r3, l1pCacheLineSizeAddr
700b07d0: e59f3028     	ldr	r3, [pc, #0x28]         @ 0x700b0800 <l1pCacheLineSizeAddr>
;         ldr     r3, [r3]
700b07d4: e5933000     	ldr	r3, [r3]
;         sub     r4, r3, #1
700b07d8: e2434001     	sub	r4, r3, #1
;         bic     r0, r0, r4              // align blockPtr to cache line
700b07dc: e1c00004     	bic	r0, r0, r4

700b07e0 <invL1pCache_loop>:
;         mcr     p15, #0, r0, c7, c5, #1 // invalidate single entry in ICache
700b07e0: ee070f35     	mcr	p15, #0x0, r0, c7, c5, #0x1
;         add     r0, r0, r3              // increment address by cache line size
700b07e4: e0800003     	add	r0, r0, r3
;         cmp     r0, r1                  // compare to last address
700b07e8: e1500001     	cmp	r0, r1
;         blo     invL1pCache_loop        // loop if > 0
700b07ec: 3afffffb     	blo	0x700b07e0 <invL1pCache_loop> @ imm = #-0x14
;         dsb                             // drain write buffer
700b07f0: f57ff04f     	dsb	sy
;         isb                             // flush instruction pipeline
700b07f4: f57ff06f     	isb	sy
;         pop     {r4}
700b07f8: e49d4004     	ldr	r4, [sp], #4
;         bx      lr
700b07fc: e12fff1e     	bx	lr

700b0800 <l1pCacheLineSizeAddr>:
700b0800: f8 22 0b 70  	.word	0x700b22f8

700b0804 <CacheP_invL1dAll>:
;         mcr     p15, #0, r0, c15, c5, #0 // Invalidate entire data cache
700b0804: ee0f0f15     	mcr	p15, #0x0, r0, c15, c5, #0x0
;         bx      lr                       // return
700b0808: e12fff1e     	bx	lr

700b080c <CacheP_invL1pAll>:
;         mcr     p15, #0, r0, c7, c5, #0 // invalidate all entries in ICache
700b080c: ee070f15     	mcr	p15, #0x0, r0, c7, c5, #0x0
;         bx      lr                      // return
700b0810: e12fff1e     	bx	lr

700b0814 <CacheP_wb>:
;         push    {r4, r5}
700b0814: e92d0030     	push	{r4, r5}
;         dmb                              // Ensure all previous memory accesses
700b0818: f57ff05f     	dmb	sy
;         add     r1, r0, r1               // calculate last address
700b081c: e0801001     	add	r1, r0, r1
;         ldr     r4, l1dCacheLineSizeWbAddr
700b0820: e59f4024     	ldr	r4, [pc, #0x24]         @ 0x700b084c <l1dCacheLineSizeWbAddr>
;         ldr     r4, [r4]
700b0824: e5944000     	ldr	r4, [r4]
;         sub     r5, r4, #1
700b0828: e2445001     	sub	r5, r4, #1
;         bic     r0, r0, r5               // align address to cache line
700b082c: e1c00005     	bic	r0, r0, r5

700b0830 <writeback>:
;         mcr     p15, #0, r0, c7, c10, #1 // write back a cache line
700b0830: ee070f3a     	mcr	p15, #0x0, r0, c7, c10, #0x1
;         add     r0, r0, r4               // increment address by cache line size
700b0834: e0800004     	add	r0, r0, r4
;         cmp     r0, r1                   // compare to last address
700b0838: e1500001     	cmp	r0, r1
;         blo     writeback                // loop if count > 0
700b083c: 3afffffb     	blo	0x700b0830 <writeback>  @ imm = #-0x14
;         dsb                              // drain write buffer
700b0840: f57ff04f     	dsb	sy
;         pop     {r4, r5}
700b0844: e8bd0030     	pop	{r4, r5}
;         bx      lr
700b0848: e12fff1e     	bx	lr

700b084c <l1dCacheLineSizeWbAddr>:
700b084c: f4 22 0b 70  	.word	0x700b22f4

700b0850 <CacheP_wbInv>:
;         push    {r4, r5}
700b0850: e92d0030     	push	{r4, r5}
;         dmb                              // Ensure all previous memory accesses
700b0854: f57ff05f     	dmb	sy
;         add     r1, r0, r1               // calculate last address
700b0858: e0801001     	add	r1, r0, r1
;         ldr     r4, l1dCacheLineSizeWbInvAddr
700b085c: e59f4024     	ldr	r4, [pc, #0x24]         @ 0x700b0888 <l1dCacheLineSizeWbInvAddr>
;         ldr     r4, [r4]
700b0860: e5944000     	ldr	r4, [r4]
;         sub     r5, r4, #1
700b0864: e2445001     	sub	r5, r4, #1
;         bic     r0, r0, r5               // align blockPtr to cache line
700b0868: e1c00005     	bic	r0, r0, r5

700b086c <writebackInv>:
;         mcr     p15, #0, r0, c7, c14, #1 // writeback inv a cache line
700b086c: ee070f3e     	mcr	p15, #0x0, r0, c7, c14, #0x1
;         add     r0, r0, r4               // increment address by cache line size
700b0870: e0800004     	add	r0, r0, r4
;         cmp     r0, r1                   // compare to last address
700b0874: e1500001     	cmp	r0, r1
;         blo     writebackInv             // loop if count > 0
700b0878: 3afffffb     	blo	0x700b086c <writebackInv> @ imm = #-0x14
;         dsb                              // drain write buffer
700b087c: f57ff04f     	dsb	sy
;         pop     {r4, r5}
700b0880: e8bd0030     	pop	{r4, r5}
;         bx      lr
700b0884: e12fff1e     	bx	lr

700b0888 <l1dCacheLineSizeWbInvAddr>:
700b0888: f4 22 0b 70  	.word	0x700b22f4

700b088c <CacheP_wbAll>:
;         stmfd   sp!, {r0-r7, r9-r11, lr}
700b088c: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         dmb                             // Ensure all previous memory accesses
700b0890: f57ff05f     	dmb	sy
;         mrc     p15, #1, r0, c0, c0, #1 // read clidr
700b0894: ee300f30     	mrc	p15, #0x1, r0, c0, c0, #0x1
;         ands    r3, r0, #0x7000000      // extract loc from clidr
700b0898: e2103407     	ands	r3, r0, #117440512
;         mov     r3, r3, lsr #23         // left align loc bit field
700b089c: e1a03ba3     	lsr	r3, r3, #23
;         beq     wbafinished             // if loc is 0, then no need to clean
700b08a0: 0a00001d     	beq	0x700b091c <wbafinished> @ imm = #0x74
;         mov     r10, #0                 // start clean at cache level 0
700b08a4: e3a0a000     	mov	r10, #0

700b08a8 <wbaloop1>:
;         add     r2, r10, r10, lsr #1    // work out 3x current cache level
700b08a8: e08a20aa     	add	r2, r10, r10, lsr #1
;         mov     r1, r0, lsr r2          // extract cache type bits from clidr
700b08ac: e1a01230     	lsr	r1, r0, r2
;         and     r1, r1, #7              // mask of bits for current cache only
700b08b0: e2011007     	and	r1, r1, #7
;         cmp     r1, #2                  // see what cache we have at this level
700b08b4: e3510002     	cmp	r1, #2
;         blt     wbaskip                 // skip if no cache, or just i-cache
700b08b8: ba000014     	blt	0x700b0910 <wbaskip>    @ imm = #0x50
;         mrs     r6, cpsr
700b08bc: e10f6000     	mrs	r6, apsr
;         cpsid   i                       // disable interrupts
700b08c0: f10c0080     	cpsid	i
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b08c4: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         isb                             // flush prefetch buffer
700b08c8: f57ff06f     	isb	sy
;         mrc     p15, #1, r1, c0, c0, #0 // read the new csidr
700b08cc: ee301f10     	mrc	p15, #0x1, r1, c0, c0, #0x0
;         msr     cpsr_c, r6              // restore interrupts
700b08d0: e121f006     	msr	CPSR_c, r6
;         and     r2, r1, #7              // extract the length of the cache lines
700b08d4: e2012007     	and	r2, r1, #7
;         add     r2, r2, #4              // add 4 (line length offset)
700b08d8: e2822004     	add	r2, r2, #4
;         mov     r4, #0x3ff
700b08dc: e30043ff     	movw	r4, #0x3ff
;         ands    r4, r4, r1, lsr #3      // find maximum number on the way size
700b08e0: e01441a1     	ands	r4, r4, r1, lsr #3
;         clz     r5, r4                  // find bit position of way size inc.
700b08e4: e16f5f14     	clz	r5, r4
;         mov     r7, #0x7fff
700b08e8: e3077fff     	movw	r7, #0x7fff
;         ands    r7, r7, r1, lsr #13     // extract max number of the index size
700b08ec: e01776a1     	ands	r7, r7, r1, lsr #13

700b08f0 <wbaloop2>:
;         mov     r9, r4                  // create working copy of max way size
700b08f0: e1a09004     	mov	r9, r4

700b08f4 <wbaloop3>:
;         orr     r11, r10, r9, lsl r5    // factor way and cache number into r11
700b08f4: e18ab519     	orr	r11, r10, r9, lsl r5
;         orr     r11, r11, r7, lsl r2    // factor index number into r11
700b08f8: e18bb217     	orr	r11, r11, r7, lsl r2
;         mcr     p15, #0, r11, c7, c10, #2 // clean line by set/way
700b08fc: ee07bf5a     	mcr	p15, #0x0, r11, c7, c10, #0x2
;         subs    r9, r9, #1              // decrement the way
700b0900: e2599001     	subs	r9, r9, #1
;         bge     wbaloop3
700b0904: aafffffa     	bge	0x700b08f4 <wbaloop3>   @ imm = #-0x18
;         subs    r7, r7, #1              // decrement the index
700b0908: e2577001     	subs	r7, r7, #1
;         bge     wbaloop2
700b090c: aafffff7     	bge	0x700b08f0 <wbaloop2>   @ imm = #-0x24

700b0910 <wbaskip>:
;         add     r10, r10, #2            // increment cache number
700b0910: e28aa002     	add	r10, r10, #2
;         cmp     r3, r10
700b0914: e153000a     	cmp	r3, r10
;         bgt     wbaloop1
700b0918: caffffe2     	bgt	0x700b08a8 <wbaloop1>   @ imm = #-0x78

700b091c <wbafinished>:
;         mov     r10, #0                 // switch back to cache level 0
700b091c: e3a0a000     	mov	r10, #0
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b0920: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         dsb
700b0924: f57ff04f     	dsb	sy
;         isb                             // flush prefetch buffer
700b0928: f57ff06f     	isb	sy
;         ldmfd   sp!, {r0-r7, r9-r11, lr}
700b092c: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700b0930: e12fff1e     	bx	lr

700b0934 <CacheP_wbInvAll>:
;         push    {r0-r7, r9-r11, lr}
700b0934: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         movw    r0, :lower16:CacheP_wbInvAllAsm
700b0938: e300094c     	movw	r0, #0x94c
;         movt    r0, :upper16:CacheP_wbInvAllAsm
700b093c: e347000b     	movt	r0, #0x700b
;         blx     r0
700b0940: e12fff30     	blx	r0
;         pop     {r0-r7, r9-r11, lr}
700b0944: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700b0948: e12fff1e     	bx	lr

700b094c <CacheP_wbInvAllAsm>:
;         dmb                             // Ensure all previous memory accesses
700b094c: f57ff05f     	dmb	sy
;         mrc     p15, #1, r0, c0, c0, #1 // read clidr
700b0950: ee300f30     	mrc	p15, #0x1, r0, c0, c0, #0x1
;         ands    r3, r0, #0x7000000      // extract loc from clidr
700b0954: e2103407     	ands	r3, r0, #117440512
;         mov     r3, r3, lsr #23         // left align loc bit field
700b0958: e1a03ba3     	lsr	r3, r3, #23
;         beq     finished                // if loc is 0, then no need to clean
700b095c: 0a00001d     	beq	0x700b09d8 <finished>   @ imm = #0x74
;         mov     r10, #0                 // start clean at cache level 0
700b0960: e3a0a000     	mov	r10, #0

700b0964 <loop1>:
;         add     r2, r10, r10, lsr #1    // work out 3x current cache level
700b0964: e08a20aa     	add	r2, r10, r10, lsr #1
;         mov     r1, r0, lsr r2          // extract cache type bits from clidr
700b0968: e1a01230     	lsr	r1, r0, r2
;         and     r1, r1, #7              // mask of bits for current cache only
700b096c: e2011007     	and	r1, r1, #7
;         cmp     r1, #2                  // see what cache we have at this level
700b0970: e3510002     	cmp	r1, #2
;         blt     skip                    // skip if no cache, or just i-cache
700b0974: ba000014     	blt	0x700b09cc <skip>       @ imm = #0x50
;         mrs     r6, cpsr
700b0978: e10f6000     	mrs	r6, apsr
;         cpsid   i                       // disable interrupts
700b097c: f10c0080     	cpsid	i
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b0980: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         isb                             // flush prefetch buffer
700b0984: f57ff06f     	isb	sy
;         mrc     p15, #1, r1, c0, c0, #0 // read the new csidr
700b0988: ee301f10     	mrc	p15, #0x1, r1, c0, c0, #0x0
;         msr     cpsr_c, r6              // restore interrupts
700b098c: e121f006     	msr	CPSR_c, r6
;         and     r2, r1, #7              // extract the length of the cache lines
700b0990: e2012007     	and	r2, r1, #7
;         add     r2, r2, #4              // add 4 (line length offset)
700b0994: e2822004     	add	r2, r2, #4
;         mov     r4, #0x3ff
700b0998: e30043ff     	movw	r4, #0x3ff
;         ands    r4, r4, r1, lsr #3      // find maximum number on the way size
700b099c: e01441a1     	ands	r4, r4, r1, lsr #3
;         clz     r5, r4                  // find bit position of way size inc.
700b09a0: e16f5f14     	clz	r5, r4
;         mov     r7, #0x7fff
700b09a4: e3077fff     	movw	r7, #0x7fff
;         ands    r7, r7, r1, lsr #13     // extract max number of the index size
700b09a8: e01776a1     	ands	r7, r7, r1, lsr #13

700b09ac <loop2>:
;         mov     r9, r4                  // create working copy of max way size
700b09ac: e1a09004     	mov	r9, r4

700b09b0 <loop3>:
;         orr     r11, r10, r9, lsl r5    // factor way and cache number into r11
700b09b0: e18ab519     	orr	r11, r10, r9, lsl r5
;         orr     r11, r11, r7, lsl r2    // factor index number into r11
700b09b4: e18bb217     	orr	r11, r11, r7, lsl r2
;         mcr     p15, #0, r11, c7, c14, #2 // clean & invalidate by set/way
700b09b8: ee07bf5e     	mcr	p15, #0x0, r11, c7, c14, #0x2
;         subs    r9, r9, #1              // decrement the way
700b09bc: e2599001     	subs	r9, r9, #1
;         bge     loop3
700b09c0: aafffffa     	bge	0x700b09b0 <loop3>      @ imm = #-0x18
;         subs    r7, r7, #1              // decrement the index
700b09c4: e2577001     	subs	r7, r7, #1
;         bge     loop2
700b09c8: aafffff7     	bge	0x700b09ac <loop2>      @ imm = #-0x24

700b09cc <skip>:
;         add     r10, r10, #2            // increment cache number
700b09cc: e28aa002     	add	r10, r10, #2
;         cmp     r3, r10
700b09d0: e153000a     	cmp	r3, r10
;         bgt     loop1
700b09d4: caffffe2     	bgt	0x700b0964 <loop1>      @ imm = #-0x78

700b09d8 <finished>:
;         mov     r10, #0                 // swith back to cache level 0
700b09d8: e3a0a000     	mov	r10, #0
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b09dc: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         dsb
700b09e0: f57ff04f     	dsb	sy
;         isb                             // flush prefetch buffer
700b09e4: f57ff06f     	isb	sy
;         bx      lr
700b09e8: e12fff1e     	bx	lr

700b09ec <CacheP_getEnabled>:
;         mov     r0, #0
700b09ec: e3a00000     	mov	r0, #0
;         mrc     p15, #0, r1, c1, c0, #0 // fetch Control Register into r1
700b09f0: ee111f10     	mrc	p15, #0x0, r1, c1, c0, #0x0
;         tst     r1, #0x1000             // test I bit (bit 12) for L1P
700b09f4: e3110a01     	tst	r1, #4096
;         addne   r0, r0, #1              // if I is true, L1P is enabled
700b09f8: 12800001     	addne	r0, r0, #1
;         tst     r1, #0x0004             // test C bit (bit 2) for L1D
700b09fc: e3110004     	tst	r1, #4
;         addne   r0, r0, #2              // if C bit is true, L1D is enabled
700b0a00: 12800002     	addne	r0, r0, #2
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700b0a04: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         tst     r1, #0x0002             // test L2EN bit (bit 1) for L2EN
700b0a08: e3110002     	tst	r1, #2
;         beq     getEnabledDone
700b0a0c: 0a000003     	beq	0x700b0a20 <getEnabledDone> @ imm = #0xc
;         tst     r0, #0x0001
700b0a10: e3100001     	tst	r0, #1
;         addne   r0, r0, #4              // If L2EN and L1P then L2P
700b0a14: 12800004     	addne	r0, r0, #4
;         tst     r0, #0x0002
700b0a18: e3100002     	tst	r0, #2
;         addne   r0, r0, #8              // If L2EN and L1D then L2D
700b0a1c: 12800008     	addne	r0, r0, #8

700b0a20 <getEnabledDone>:
;         bx      lr
700b0a20: e12fff1e     	bx	lr

700b0a24 <CacheP_getCacheLevelInfo>:
;         mcr     p15, #2, r0, c0, c0, #0 // write to Cache Size Selection Reg
700b0a24: ee400f10     	mcr	p15, #0x2, r0, c0, c0, #0x0
;         mrc     p15, #1, r0, c0, c0, #0 // read Cache Size Id Reg
700b0a28: ee300f10     	mrc	p15, #0x1, r0, c0, c0, #0x0
;         bx      lr
700b0a2c: e12fff1e     	bx	lr

700b0a30 <CacheP_configForceWrThru>:
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700b0a30: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         cmp     r0, #0
700b0a34: e3500000     	cmp	r0, #0
;         beq     FWT_disable
700b0a38: 0a000001     	beq	0x700b0a44 <FWT_disable> @ imm = #0x4
;         orr     r1, r1, #(1 << 9)       // set (enable) force write-thru bit
700b0a3c: e3811c02     	orr	r1, r1, #512
;         b       FWT_exit
700b0a40: ea000000     	b	0x700b0a48 <FWT_exit>   @ imm = #0x0

700b0a44 <FWT_disable>:
;         bic     r1, r1, #(1 << 9)       // clear (disable) force write-thru bit
700b0a44: e3c11c02     	bic	r1, r1, #512

700b0a48 <FWT_exit>:
;         mcr     p15, #0, r1, c1, c0, #1 // write Auxiliary Ctrl Register
700b0a48: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         bx      lr
700b0a4c: e12fff1e     	bx	lr

700b0a50 <CacheP_setDLFO>:
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700b0a50: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         orr     r1, r1, #(1 << 13)      // set DLFO to disable LF optimization
700b0a54: e3811a02     	orr	r1, r1, #8192
;         mcr     p15, #0, r1, c1, c0, #1 // write Auxiliary Ctrl Register
700b0a58: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         bx      lr
700b0a5c: e12fff1e     	bx	lr

700b0a60 <CacheP_init>:
; {
700b0a60: b580         	push	{r7, lr}
700b0a62: b084         	sub	sp, #0x10
700b0a64: 2000         	movs	r0, #0x0
;     info = CacheP_getCacheLevelInfo(0);
700b0a66: f7ff efde    	blx	0x700b0a24 <CacheP_getCacheLevelInfo> @ imm = #-0x44
700b0a6a: 9003         	str	r0, [sp, #0xc]
;     DebugP_assertNoLog (gCacheL1dCacheLineSize == (4U << ((info & 0x7U) + 2U)));
700b0a6c: 9803         	ldr	r0, [sp, #0xc]
700b0a6e: f000 0007    	and	r0, r0, #0x7
700b0a72: 1c81         	adds	r1, r0, #0x2
700b0a74: 2004         	movs	r0, #0x4
700b0a76: 9001         	str	r0, [sp, #0x4]
700b0a78: 4088         	lsls	r0, r1
700b0a7a: 3820         	subs	r0, #0x20
700b0a7c: fab0 f080    	clz	r0, r0
700b0a80: 0940         	lsrs	r0, r0, #0x5
700b0a82: f000 faad    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x55a
700b0a86: 2001         	movs	r0, #0x1
;     info = CacheP_getCacheLevelInfo(1);
700b0a88: f7ff efcc    	blx	0x700b0a24 <CacheP_getCacheLevelInfo> @ imm = #-0x68
700b0a8c: 4601         	mov	r1, r0
700b0a8e: 9801         	ldr	r0, [sp, #0x4]
700b0a90: 9103         	str	r1, [sp, #0xc]
;     DebugP_assertNoLog (gCacheL1pCacheLineSize == (4U << ((info & 0x7U) + 2U)));
700b0a92: 9903         	ldr	r1, [sp, #0xc]
700b0a94: f001 0107    	and	r1, r1, #0x7
700b0a98: 3102         	adds	r1, #0x2
700b0a9a: 4088         	lsls	r0, r1
700b0a9c: 3820         	subs	r0, #0x20
700b0a9e: fab0 f080    	clz	r0, r0
700b0aa2: 0940         	lsrs	r0, r0, #0x5
700b0aa4: f000 fa9c    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x538
;     enabled = CacheP_getEnabled();
700b0aa8: f7ff efa0    	blx	0x700b09ec <CacheP_getEnabled> @ imm = #-0xc0
700b0aac: 9002         	str	r0, [sp, #0x8]
;     if (enabled!=0U) {
700b0aae: 9802         	ldr	r0, [sp, #0x8]
700b0ab0: b120         	cbz	r0, 0x700b0abc <CacheP_init+0x5c> @ imm = #0x8
700b0ab2: e7ff         	b	0x700b0ab4 <CacheP_init+0x54> @ imm = #-0x2
700b0ab4: 200f         	movs	r0, #0xf
;         CacheP_disable((uint32_t)CacheP_TYPE_ALL);
700b0ab6: f000 f81b    	bl	0x700b0af0 <CacheP_disable> @ imm = #0x36
;     }
700b0aba: e7ff         	b	0x700b0abc <CacheP_init+0x5c> @ imm = #-0x2
;     if (gCacheConfig.enable!=0U) {
700b0abc: f241 5008    	movw	r0, #0x1508
700b0ac0: f2c7 000b    	movt	r0, #0x700b
700b0ac4: 6800         	ldr	r0, [r0]
700b0ac6: b158         	cbz	r0, 0x700b0ae0 <CacheP_init+0x80> @ imm = #0x16
700b0ac8: e7ff         	b	0x700b0aca <CacheP_init+0x6a> @ imm = #-0x2
;          CacheP_configForceWrThru(gCacheConfig.enableForceWrThru);
700b0aca: f241 5008    	movw	r0, #0x1508
700b0ace: f2c7 000b    	movt	r0, #0x700b
700b0ad2: 6840         	ldr	r0, [r0, #0x4]
700b0ad4: f7ff efac    	blx	0x700b0a30 <CacheP_configForceWrThru> @ imm = #-0xa8
700b0ad8: 200f         	movs	r0, #0xf
;         CacheP_enable((uint32_t)CacheP_TYPE_ALL);
700b0ada: f000 f831    	bl	0x700b0b40 <CacheP_enable> @ imm = #0x62
;     }
700b0ade: e7ff         	b	0x700b0ae0 <CacheP_init+0x80> @ imm = #-0x2
; }
700b0ae0: b004         	add	sp, #0x10
700b0ae2: bd80         	pop	{r7, pc}
700b0ae4: bf00         	nop
700b0ae6: bf00         	nop
700b0ae8: bf00         	nop
700b0aea: bf00         	nop
700b0aec: bf00         	nop
700b0aee: bf00         	nop

700b0af0 <CacheP_disable>:
; {
700b0af0: b580         	push	{r7, lr}
700b0af2: b084         	sub	sp, #0x10
700b0af4: 9003         	str	r0, [sp, #0xc]
;     enabled = CacheP_getEnabled();
700b0af6: f7ff ef7a    	blx	0x700b09ec <CacheP_getEnabled> @ imm = #-0x10c
700b0afa: 9002         	str	r0, [sp, #0x8]
;     if ((enabled & ((type) & ((uint32_t)CacheP_TYPE_L1D)))!=0U) {
700b0afc: 9902         	ldr	r1, [sp, #0x8]
700b0afe: 9803         	ldr	r0, [sp, #0xc]
700b0b00: 4008         	ands	r0, r1
700b0b02: 0780         	lsls	r0, r0, #0x1e
700b0b04: 2800         	cmp	r0, #0x0
700b0b06: d509         	bpl	0x700b0b1c <CacheP_disable+0x2c> @ imm = #0x12
700b0b08: e7ff         	b	0x700b0b0a <CacheP_disable+0x1a> @ imm = #-0x2
;         key = HwiP_disable();
700b0b0a: f7ff edaa    	blx	0x700b0660 <HwiP_disable> @ imm = #-0x4ac
700b0b0e: 9001         	str	r0, [sp, #0x4]
;         CacheP_disableL1d();             /* Disable L1D Cache */
700b0b10: f7ff ee06    	blx	0x700b0720 <CacheP_disableL1d> @ imm = #-0x3f4
;         HwiP_restore(key);
700b0b14: 9801         	ldr	r0, [sp, #0x4]
700b0b16: f7ff edc4    	blx	0x700b06a0 <HwiP_restore> @ imm = #-0x478
;     }
700b0b1a: e7ff         	b	0x700b0b1c <CacheP_disable+0x2c> @ imm = #-0x2
;     if ((enabled & ((type) & ((uint32_t)CacheP_TYPE_L1P)))!=0U) {
700b0b1c: 9902         	ldr	r1, [sp, #0x8]
700b0b1e: 9803         	ldr	r0, [sp, #0xc]
700b0b20: 4008         	ands	r0, r1
700b0b22: 07c0         	lsls	r0, r0, #0x1f
700b0b24: b148         	cbz	r0, 0x700b0b3a <CacheP_disable+0x4a> @ imm = #0x12
700b0b26: e7ff         	b	0x700b0b28 <CacheP_disable+0x38> @ imm = #-0x2
;         key = HwiP_disable();
700b0b28: f7ff ed9a    	blx	0x700b0660 <HwiP_disable> @ imm = #-0x4cc
700b0b2c: 9001         	str	r0, [sp, #0x4]
;         CacheP_disableL1p();             /* Disable L1P Cache */
700b0b2e: f7ff ee0c    	blx	0x700b0748 <CacheP_disableL1p> @ imm = #-0x3e8
;         HwiP_restore(key);
700b0b32: 9801         	ldr	r0, [sp, #0x4]
700b0b34: f7ff edb4    	blx	0x700b06a0 <HwiP_restore> @ imm = #-0x498
;     }
700b0b38: e7ff         	b	0x700b0b3a <CacheP_disable+0x4a> @ imm = #-0x2
; }
700b0b3a: b004         	add	sp, #0x10
700b0b3c: bd80         	pop	{r7, pc}
700b0b3e: bf00         	nop

700b0b40 <CacheP_enable>:
; {
700b0b40: b580         	push	{r7, lr}
700b0b42: b082         	sub	sp, #0x8
700b0b44: 9001         	str	r0, [sp, #0x4]
;     disabled = ~(CacheP_getEnabled());
700b0b46: f7ff ef52    	blx	0x700b09ec <CacheP_getEnabled> @ imm = #-0x15c
700b0b4a: 43c0         	mvns	r0, r0
700b0b4c: 9000         	str	r0, [sp]
;     if ((disabled & ((type) & ((uint32_t)CacheP_TYPE_L1D)))!=0U) {
700b0b4e: 9900         	ldr	r1, [sp]
700b0b50: 9801         	ldr	r0, [sp, #0x4]
700b0b52: 4008         	ands	r0, r1
700b0b54: 0780         	lsls	r0, r0, #0x1e
700b0b56: 2800         	cmp	r0, #0x0
700b0b58: d503         	bpl	0x700b0b62 <CacheP_enable+0x22> @ imm = #0x6
700b0b5a: e7ff         	b	0x700b0b5c <CacheP_enable+0x1c> @ imm = #-0x2
;         CacheP_enableL1d();              /* Enable L1D Cache */
700b0b5c: f7ff ee00    	blx	0x700b0760 <CacheP_enableL1d> @ imm = #-0x400
;     }
700b0b60: e7ff         	b	0x700b0b62 <CacheP_enable+0x22> @ imm = #-0x2
;     if ((disabled & ((type) & ((uint32_t)CacheP_TYPE_L1P)))!=0U) {
700b0b62: 9900         	ldr	r1, [sp]
700b0b64: 9801         	ldr	r0, [sp, #0x4]
700b0b66: 4008         	ands	r0, r1
700b0b68: 07c0         	lsls	r0, r0, #0x1f
700b0b6a: b118         	cbz	r0, 0x700b0b74 <CacheP_enable+0x34> @ imm = #0x6
700b0b6c: e7ff         	b	0x700b0b6e <CacheP_enable+0x2e> @ imm = #-0x2
;         CacheP_enableL1p();              /* Enable L1P Cache */
700b0b6e: f7ff ee04    	blx	0x700b0778 <CacheP_enableL1p> @ imm = #-0x3f8
;     }
700b0b72: e7ff         	b	0x700b0b74 <CacheP_enable+0x34> @ imm = #-0x2
; }
700b0b74: b002         	add	sp, #0x8
700b0b76: bd80         	pop	{r7, pc}
700b0b78: bf00         	nop
700b0b7a: bf00         	nop
700b0b7c: bf00         	nop
700b0b7e: bf00         	nop

700b0b80 <CacheP_inv>:
; {
700b0b80: b580         	push	{r7, lr}
700b0b82: b084         	sub	sp, #0x10
700b0b84: 9003         	str	r0, [sp, #0xc]
700b0b86: 9102         	str	r1, [sp, #0x8]
700b0b88: 9201         	str	r2, [sp, #0x4]
;     if (((type) & ((uint32_t)CacheP_TYPE_L1P))!=0U) {
700b0b8a: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700b0b8e: 07c0         	lsls	r0, r0, #0x1f
700b0b90: b128         	cbz	r0, 0x700b0b9e <CacheP_inv+0x1e> @ imm = #0xa
700b0b92: e7ff         	b	0x700b0b94 <CacheP_inv+0x14> @ imm = #-0x2
;         CacheP_invL1p((uint32_t)blockPtr, byteCnt);
700b0b94: 9803         	ldr	r0, [sp, #0xc]
700b0b96: 9902         	ldr	r1, [sp, #0x8]
700b0b98: f7ff ee16    	blx	0x700b07c8 <CacheP_invL1p> @ imm = #-0x3d4
;     }
700b0b9c: e7ff         	b	0x700b0b9e <CacheP_inv+0x1e> @ imm = #-0x2
;     if (((type) & ((uint32_t)CacheP_TYPE_L1D))!=0U) {
700b0b9e: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700b0ba2: 0780         	lsls	r0, r0, #0x1e
700b0ba4: 2800         	cmp	r0, #0x0
700b0ba6: d505         	bpl	0x700b0bb4 <CacheP_inv+0x34> @ imm = #0xa
700b0ba8: e7ff         	b	0x700b0baa <CacheP_inv+0x2a> @ imm = #-0x2
;         CacheP_invL1d((uint32_t)blockPtr, byteCnt);
700b0baa: 9803         	ldr	r0, [sp, #0xc]
700b0bac: 9902         	ldr	r1, [sp, #0x8]
700b0bae: f7ff edf0    	blx	0x700b0790 <CacheP_invL1d> @ imm = #-0x420
;     }
700b0bb2: e7ff         	b	0x700b0bb4 <CacheP_inv+0x34> @ imm = #-0x2
; }
700b0bb4: b004         	add	sp, #0x10
700b0bb6: bd80         	pop	{r7, pc}
		...

Disassembly of section .text.mpu:

700b0bc0 <MpuP_RegionAttrs_init>:
; {
700b0bc0: b081         	sub	sp, #0x4
700b0bc2: 9000         	str	r0, [sp]
;     region->isExecuteNever = 0;
700b0bc4: 9900         	ldr	r1, [sp]
700b0bc6: 2000         	movs	r0, #0x0
700b0bc8: 7108         	strb	r0, [r1, #0x4]
;     region->accessPerm     = (uint8_t)MpuP_AP_S_RW_U_R;
700b0bca: 9a00         	ldr	r2, [sp]
700b0bcc: 2102         	movs	r1, #0x2
700b0bce: 7191         	strb	r1, [r2, #0x6]
;     region->tex            = 0;
700b0bd0: 9900         	ldr	r1, [sp]
700b0bd2: 7148         	strb	r0, [r1, #0x5]
;     region->isSharable     = 1;
700b0bd4: 9a00         	ldr	r2, [sp]
700b0bd6: 2101         	movs	r1, #0x1
700b0bd8: 70d1         	strb	r1, [r2, #0x3]
;     region->isCacheable    = 0;
700b0bda: 9900         	ldr	r1, [sp]
700b0bdc: 7048         	strb	r0, [r1, #0x1]
;     region->isBufferable   = 0;
700b0bde: 9900         	ldr	r1, [sp]
700b0be0: 7088         	strb	r0, [r1, #0x2]
;     region->isEnable       = 0;
700b0be2: 9900         	ldr	r1, [sp]
700b0be4: 7008         	strb	r0, [r1]
;     region->subregionDisableMask = 0;
700b0be6: 9900         	ldr	r1, [sp]
700b0be8: 71c8         	strb	r0, [r1, #0x7]
; }
700b0bea: b001         	add	sp, #0x4
700b0bec: 4770         	bx	lr
700b0bee: bf00         	nop

700b0bf0 <MpuP_setRegion>:
; {
700b0bf0: b580         	push	{r7, lr}
700b0bf2: b08a         	sub	sp, #0x28
700b0bf4: 9009         	str	r0, [sp, #0x24]
700b0bf6: 9108         	str	r1, [sp, #0x20]
700b0bf8: 9207         	str	r2, [sp, #0x1c]
700b0bfa: 9306         	str	r3, [sp, #0x18]
;     uint32_t value = size;
700b0bfc: 9807         	ldr	r0, [sp, #0x1c]
700b0bfe: 9000         	str	r0, [sp]
;     DebugP_assertNoLog( regionNum < MpuP_MAX_REGIONS);
700b0c00: 9909         	ldr	r1, [sp, #0x24]
700b0c02: 2000         	movs	r0, #0x0
700b0c04: 2910         	cmp	r1, #0x10
700b0c06: bf38         	it	lo
700b0c08: 2001         	movlo	r0, #0x1
700b0c0a: f000 f9e9    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x3d2
;     value = (value & (uint32_t)0x1F);
700b0c0e: 9800         	ldr	r0, [sp]
700b0c10: f000 001f    	and	r0, r0, #0x1f
700b0c14: 9000         	str	r0, [sp]
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700b0c16: 9806         	ldr	r0, [sp, #0x18]
;                   | ((uint32_t)(attrs->isEnable &  (uint32_t)0x1) << (uint32_t)0);
700b0c18: 7801         	ldrb	r1, [r0]
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700b0c1a: 79c0         	ldrb	r0, [r0, #0x7]
700b0c1c: 0200         	lsls	r0, r0, #0x8
;                   | ((uint32_t)(value            & (uint32_t)0x1F) << (uint32_t)1)
700b0c1e: 9a00         	ldr	r2, [sp]
700b0c20: f002 021f    	and	r2, r2, #0x1f
700b0c24: ea40 0042    	orr.w	r0, r0, r2, lsl #1
;                   | ((uint32_t)(attrs->isEnable &  (uint32_t)0x1) << (uint32_t)0);
700b0c28: f001 0101    	and	r1, r1, #0x1
700b0c2c: 4408         	add	r0, r1
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700b0c2e: 9004         	str	r0, [sp, #0x10]
;     baseAddress = ((uint32_t)addr & ~( (1U <<((uint64_t)value+1U))-1U ));
700b0c30: 9808         	ldr	r0, [sp, #0x20]
700b0c32: 9900         	ldr	r1, [sp]
700b0c34: 1c4a         	adds	r2, r1, #0x1
700b0c36: 2101         	movs	r1, #0x1
700b0c38: 4091         	lsls	r1, r2
700b0c3a: 4249         	rsbs	r1, r1, #0
700b0c3c: 4008         	ands	r0, r1
700b0c3e: 9005         	str	r0, [sp, #0x14]
;     regionAttrs = MpuP_getAttrs(attrs);
700b0c40: 9806         	ldr	r0, [sp, #0x18]
700b0c42: f000 f81d    	bl	0x700b0c80 <MpuP_getAttrs> @ imm = #0x3a
700b0c46: 9003         	str	r0, [sp, #0xc]
;     enabled = MpuP_isEnable();
700b0c48: f000 f84a    	bl	0x700b0ce0 <MpuP_isEnable> @ imm = #0x94
700b0c4c: 9002         	str	r0, [sp, #0x8]
;     MpuP_disable();
700b0c4e: f000 f84f    	bl	0x700b0cf0 <MpuP_disable> @ imm = #0x9e
;     key = HwiP_disable();
700b0c52: f7ff ed06    	blx	0x700b0660 <HwiP_disable> @ imm = #-0x5f4
700b0c56: 9001         	str	r0, [sp, #0x4]
;     MpuP_setRegionAsm(regionNum, baseAddress, sizeAndEnable, regionAttrs);
700b0c58: 9809         	ldr	r0, [sp, #0x24]
700b0c5a: 9905         	ldr	r1, [sp, #0x14]
700b0c5c: 9a04         	ldr	r2, [sp, #0x10]
700b0c5e: 9b03         	ldr	r3, [sp, #0xc]
700b0c60: f000 e90c    	blx	0x700b0e7c <MpuP_setRegionAsm> @ imm = #0x218
;     HwiP_restore(key);
700b0c64: 9801         	ldr	r0, [sp, #0x4]
700b0c66: f7ff ed1c    	blx	0x700b06a0 <HwiP_restore> @ imm = #-0x5c8
;     if (enabled != 0U) {
700b0c6a: 9802         	ldr	r0, [sp, #0x8]
700b0c6c: b118         	cbz	r0, 0x700b0c76 <MpuP_setRegion+0x86> @ imm = #0x6
700b0c6e: e7ff         	b	0x700b0c70 <MpuP_setRegion+0x80> @ imm = #-0x2
;         MpuP_enable();
700b0c70: f000 f85e    	bl	0x700b0d30 <MpuP_enable> @ imm = #0xbc
;     }
700b0c74: e7ff         	b	0x700b0c76 <MpuP_setRegion+0x86> @ imm = #-0x2
; }
700b0c76: b00a         	add	sp, #0x28
700b0c78: bd80         	pop	{r7, pc}
700b0c7a: bf00         	nop
700b0c7c: bf00         	nop
700b0c7e: bf00         	nop

700b0c80 <MpuP_getAttrs>:
; {
700b0c80: b580         	push	{r7, lr}
700b0c82: b082         	sub	sp, #0x8
700b0c84: 9001         	str	r0, [sp, #0x4]
;           ((uint32_t)(region->isExecuteNever & (uint32_t)0x1) << (uint32_t)12)
700b0c86: f8dd c004    	ldr.w	r12, [sp, #0x4]
;         | ((uint32_t)(region->isCacheable    & (uint32_t)0x1) << (uint32_t)1)
700b0c8a: f89c 2001    	ldrb.w	r2, [r12, #0x1]
;         | ((uint32_t)(region->isBufferable   & (uint32_t)0x1) << (uint32_t)0);
700b0c8e: f89c 1002    	ldrb.w	r1, [r12, #0x2]
;         | ((uint32_t)(region->isSharable     & (uint32_t)0x1) << (uint32_t)2)
700b0c92: f89c 3003    	ldrb.w	r3, [r12, #0x3]
;           ((uint32_t)(region->isExecuteNever & (uint32_t)0x1) << (uint32_t)12)
700b0c96: f89c 0004    	ldrb.w	r0, [r12, #0x4]
700b0c9a: f000 0001    	and	r0, r0, #0x1
700b0c9e: 0300         	lsls	r0, r0, #0xc
;         | ((uint32_t)(region->accessPerm     & (uint32_t)0x7) << (uint32_t)8)
700b0ca0: f89c e006    	ldrb.w	lr, [r12, #0x6]
700b0ca4: f00e 0e07    	and	lr, lr, #0x7
700b0ca8: ea40 200e    	orr.w	r0, r0, lr, lsl #8
;         | ((uint32_t)(region->tex            & (uint32_t)0x7) << (uint32_t)3)
700b0cac: f89c c005    	ldrb.w	r12, [r12, #0x5]
700b0cb0: f00c 0c07    	and	r12, r12, #0x7
700b0cb4: ea40 00cc    	orr.w	r0, r0, r12, lsl #3
;         | ((uint32_t)(region->isSharable     & (uint32_t)0x1) << (uint32_t)2)
700b0cb8: f003 0301    	and	r3, r3, #0x1
700b0cbc: ea40 0083    	orr.w	r0, r0, r3, lsl #2
;         | ((uint32_t)(region->isCacheable    & (uint32_t)0x1) << (uint32_t)1)
700b0cc0: f002 0201    	and	r2, r2, #0x1
700b0cc4: ea40 0042    	orr.w	r0, r0, r2, lsl #1
;         | ((uint32_t)(region->isBufferable   & (uint32_t)0x1) << (uint32_t)0);
700b0cc8: f001 0101    	and	r1, r1, #0x1
700b0ccc: 4408         	add	r0, r1
;     uint32_t regionAttrs =
700b0cce: 9000         	str	r0, [sp]
;     return regionAttrs;
700b0cd0: 9800         	ldr	r0, [sp]
700b0cd2: b002         	add	sp, #0x8
700b0cd4: bd80         	pop	{r7, pc}
700b0cd6: bf00         	nop
700b0cd8: bf00         	nop
700b0cda: bf00         	nop
700b0cdc: bf00         	nop
700b0cde: bf00         	nop

700b0ce0 <MpuP_isEnable>:
; {
700b0ce0: b580         	push	{r7, lr}
;     return MpuP_isEnableAsm();
700b0ce2: f000 e8c2    	blx	0x700b0e68 <MpuP_isEnableAsm> @ imm = #0x184
700b0ce6: bd80         	pop	{r7, pc}
700b0ce8: bf00         	nop
700b0cea: bf00         	nop
700b0cec: bf00         	nop
700b0cee: bf00         	nop

700b0cf0 <MpuP_disable>:
; {
700b0cf0: b580         	push	{r7, lr}
700b0cf2: b082         	sub	sp, #0x8
;     if(MpuP_isEnable()!=0U)
700b0cf4: f7ff fff4    	bl	0x700b0ce0 <MpuP_isEnable> @ imm = #-0x18
700b0cf8: b1a0         	cbz	r0, 0x700b0d24 <MpuP_disable+0x34> @ imm = #0x28
700b0cfa: e7ff         	b	0x700b0cfc <MpuP_disable+0xc> @ imm = #-0x2
;         key = HwiP_disable();
700b0cfc: f7ff ecb0    	blx	0x700b0660 <HwiP_disable> @ imm = #-0x6a0
700b0d00: 9000         	str	r0, [sp]
;         type = CacheP_getEnabled();
700b0d02: f7ff ee74    	blx	0x700b09ec <CacheP_getEnabled> @ imm = #-0x318
700b0d06: 9001         	str	r0, [sp, #0x4]
;         CacheP_disable(type);
700b0d08: 9801         	ldr	r0, [sp, #0x4]
700b0d0a: f7ff fef1    	bl	0x700b0af0 <CacheP_disable> @ imm = #-0x21e
;         __asm__ __volatile__ (" dsb" "\n\t": : : "memory");
700b0d0e: f3bf 8f4f    	dsb	sy
;         MpuP_disableAsm();
700b0d12: f000 e882    	blx	0x700b0e18 <MpuP_disableAsm> @ imm = #0x104
;         CacheP_enable(type);
700b0d16: 9801         	ldr	r0, [sp, #0x4]
700b0d18: f7ff ff12    	bl	0x700b0b40 <CacheP_enable> @ imm = #-0x1dc
;         HwiP_restore(key);
700b0d1c: 9800         	ldr	r0, [sp]
700b0d1e: f7ff ecc0    	blx	0x700b06a0 <HwiP_restore> @ imm = #-0x680
;     }
700b0d22: e7ff         	b	0x700b0d24 <MpuP_disable+0x34> @ imm = #-0x2
; }
700b0d24: b002         	add	sp, #0x8
700b0d26: bd80         	pop	{r7, pc}
700b0d28: bf00         	nop
700b0d2a: bf00         	nop
700b0d2c: bf00         	nop
700b0d2e: bf00         	nop

700b0d30 <MpuP_enable>:
; {
700b0d30: b580         	push	{r7, lr}
700b0d32: b082         	sub	sp, #0x8
;     if(MpuP_isEnable()==(uint32_t) 0U)
700b0d34: f7ff ffd4    	bl	0x700b0ce0 <MpuP_isEnable> @ imm = #-0x58
700b0d38: b9e0         	cbnz	r0, 0x700b0d74 <MpuP_enable+0x44> @ imm = #0x38
700b0d3a: e7ff         	b	0x700b0d3c <MpuP_enable+0xc> @ imm = #-0x2
;         key = HwiP_disable();
700b0d3c: f7ff ec90    	blx	0x700b0660 <HwiP_disable> @ imm = #-0x6e0
700b0d40: 9000         	str	r0, [sp]
;         type = (uint32_t)CacheP_getEnabled();
700b0d42: f7ff ee54    	blx	0x700b09ec <CacheP_getEnabled> @ imm = #-0x358
700b0d46: 9001         	str	r0, [sp, #0x4]
;         if (type & CacheP_TYPE_L1) {
700b0d48: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700b0d4c: 0780         	lsls	r0, r0, #0x1e
700b0d4e: b120         	cbz	r0, 0x700b0d5a <MpuP_enable+0x2a> @ imm = #0x8
700b0d50: e7ff         	b	0x700b0d52 <MpuP_enable+0x22> @ imm = #-0x2
700b0d52: 2003         	movs	r0, #0x3
;             CacheP_disable(CacheP_TYPE_L1);
700b0d54: f7ff fecc    	bl	0x700b0af0 <CacheP_disable> @ imm = #-0x268
;         }
700b0d58: e7ff         	b	0x700b0d5a <MpuP_enable+0x2a> @ imm = #-0x2
;         MpuP_enableAsm();
700b0d5a: f000 e872    	blx	0x700b0e40 <MpuP_enableAsm> @ imm = #0xe4
;         CacheP_enable(type);
700b0d5e: 9801         	ldr	r0, [sp, #0x4]
700b0d60: f7ff feee    	bl	0x700b0b40 <CacheP_enable> @ imm = #-0x224
;         __asm__  __volatile__ (" dsb" "\n\t": : : "memory");
700b0d64: f3bf 8f4f    	dsb	sy
;         __asm__  __volatile__ (" isb" "\n\t": : : "memory");
700b0d68: f3bf 8f6f    	isb	sy
;         HwiP_restore(key);
700b0d6c: 9800         	ldr	r0, [sp]
700b0d6e: f7ff ec98    	blx	0x700b06a0 <HwiP_restore> @ imm = #-0x6d0
;     }
700b0d72: e7ff         	b	0x700b0d74 <MpuP_enable+0x44> @ imm = #-0x2
; }
700b0d74: b002         	add	sp, #0x8
700b0d76: bd80         	pop	{r7, pc}
700b0d78: bf00         	nop
700b0d7a: bf00         	nop
700b0d7c: bf00         	nop
700b0d7e: bf00         	nop

700b0d80 <MpuP_init>:
; {
700b0d80: b580         	push	{r7, lr}
700b0d82: b082         	sub	sp, #0x8
;     if (MpuP_isEnable()!=0U) {
700b0d84: f7ff ffac    	bl	0x700b0ce0 <MpuP_isEnable> @ imm = #-0xa8
700b0d88: b118         	cbz	r0, 0x700b0d92 <MpuP_init+0x12> @ imm = #0x6
700b0d8a: e7ff         	b	0x700b0d8c <MpuP_init+0xc> @ imm = #-0x2
;         MpuP_disable();
700b0d8c: f7ff ffb0    	bl	0x700b0cf0 <MpuP_disable> @ imm = #-0xa0
;     }
700b0d90: e7ff         	b	0x700b0d92 <MpuP_init+0x12> @ imm = #-0x2
;     MpuP_disableBRAsm();
700b0d92: f000 e84e    	blx	0x700b0e30 <MpuP_disableBRAsm> @ imm = #0x9c
;     DebugP_assertNoLog( gMpuConfig.numRegions < MpuP_MAX_REGIONS);
700b0d96: f241 5010    	movw	r0, #0x1510
700b0d9a: f2c7 000b    	movt	r0, #0x700b
700b0d9e: 6801         	ldr	r1, [r0]
700b0da0: 2000         	movs	r0, #0x0
700b0da2: 9000         	str	r0, [sp]
700b0da4: 2910         	cmp	r1, #0x10
700b0da6: bf38         	it	lo
700b0da8: 2001         	movlo	r0, #0x1
700b0daa: f000 f919    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x232
700b0dae: 9800         	ldr	r0, [sp]
;     for (i = 0; i < gMpuConfig.numRegions; i++)
700b0db0: 9001         	str	r0, [sp, #0x4]
700b0db2: e7ff         	b	0x700b0db4 <MpuP_init+0x34> @ imm = #-0x2
700b0db4: 9801         	ldr	r0, [sp, #0x4]
700b0db6: f241 5110    	movw	r1, #0x1510
700b0dba: f2c7 010b    	movt	r1, #0x700b
700b0dbe: 6809         	ldr	r1, [r1]
700b0dc0: 4288         	cmp	r0, r1
700b0dc2: d212         	bhs	0x700b0dea <MpuP_init+0x6a> @ imm = #0x24
700b0dc4: e7ff         	b	0x700b0dc6 <MpuP_init+0x46> @ imm = #-0x2
;         MpuP_setRegion(i,
700b0dc6: 9801         	ldr	r0, [sp, #0x4]
;                 (void*)gMpuRegionConfig[i].baseAddr,
700b0dc8: f241 511c    	movw	r1, #0x151c
700b0dcc: f2c7 010b    	movt	r1, #0x700b
700b0dd0: eb01 1300    	add.w	r3, r1, r0, lsl #4
700b0dd4: 0102         	lsls	r2, r0, #0x4
700b0dd6: 5889         	ldr	r1, [r1, r2]
;                 gMpuRegionConfig[i].size,
700b0dd8: 685a         	ldr	r2, [r3, #0x4]
;                 &gMpuRegionConfig[i].attrs
700b0dda: 3308         	adds	r3, #0x8
;         MpuP_setRegion(i,
700b0ddc: f7ff ff08    	bl	0x700b0bf0 <MpuP_setRegion> @ imm = #-0x1f0
;     }
700b0de0: e7ff         	b	0x700b0de2 <MpuP_init+0x62> @ imm = #-0x2
;     for (i = 0; i < gMpuConfig.numRegions; i++)
700b0de2: 9801         	ldr	r0, [sp, #0x4]
700b0de4: 3001         	adds	r0, #0x1
700b0de6: 9001         	str	r0, [sp, #0x4]
700b0de8: e7e4         	b	0x700b0db4 <MpuP_init+0x34> @ imm = #-0x38
;     if (gMpuConfig.enableBackgroundRegion!=0U) {
700b0dea: f241 5010    	movw	r0, #0x1510
700b0dee: f2c7 000b    	movt	r0, #0x700b
700b0df2: 6840         	ldr	r0, [r0, #0x4]
700b0df4: b118         	cbz	r0, 0x700b0dfe <MpuP_init+0x7e> @ imm = #0x6
700b0df6: e7ff         	b	0x700b0df8 <MpuP_init+0x78> @ imm = #-0x2
;         MpuP_enableBRAsm();
700b0df8: f000 e82e    	blx	0x700b0e58 <MpuP_enableBRAsm> @ imm = #0x5c
;     }
700b0dfc: e7ff         	b	0x700b0dfe <MpuP_init+0x7e> @ imm = #-0x2
;     if (gMpuConfig.enableMpu!=0U) {
700b0dfe: f241 5010    	movw	r0, #0x1510
700b0e02: f2c7 000b    	movt	r0, #0x700b
700b0e06: 6880         	ldr	r0, [r0, #0x8]
700b0e08: b118         	cbz	r0, 0x700b0e12 <MpuP_init+0x92> @ imm = #0x6
700b0e0a: e7ff         	b	0x700b0e0c <MpuP_init+0x8c> @ imm = #-0x2
;         MpuP_enable();
700b0e0c: f7ff ff90    	bl	0x700b0d30 <MpuP_enable> @ imm = #-0xe0
;     }
700b0e10: e7ff         	b	0x700b0e12 <MpuP_init+0x92> @ imm = #-0x2
; }
700b0e12: b002         	add	sp, #0x8
700b0e14: bd80         	pop	{r7, pc}
700b0e16: 0000         	movs	r0, r0

700b0e18 <MpuP_disableAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b0e18: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x1             // clear bit 0 in r0
700b0e1c: e3c00001     	bic	r0, r0, #1
;         dsb
700b0e20: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0  // MPU disabled (bit 0 = 0)
700b0e24: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb                              // flush instruction pipeline
700b0e28: f57ff06f     	isb	sy
;         bx      LR
700b0e2c: e12fff1e     	bx	lr

700b0e30 <MpuP_disableBRAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b0e30: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x20000         // clear bit 17 in r0
700b0e34: e3c00802     	bic	r0, r0, #131072
;         mcr     p15, #0, r0, c1, c0, #0  // disable background region
700b0e38: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b0e3c: e12fff1e     	bx	lr

700b0e40 <MpuP_enableAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b0e40: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x1             // set bit 0 in r0
700b0e44: e3800001     	orr	r0, r0, #1
;         dsb
700b0e48: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0  // MPU enabled (bit 0 = 1)
700b0e4c: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb                              // flush instruction pipeline
700b0e50: f57ff06f     	isb	sy
;         bx      LR
700b0e54: e12fff1e     	bx	lr

700b0e58 <MpuP_enableBRAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b0e58: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x20000         // set bit 17 in r0
700b0e5c: e3800802     	orr	r0, r0, #131072
;         mcr     p15, #0, r0, c1, c0, #0  // background region enabled
700b0e60: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b0e64: e12fff1e     	bx	lr

700b0e68 <MpuP_isEnableAsm>:
;         mov     r0, #0
700b0e68: e3a00000     	mov	r0, #0
;         mrc     p15, #0, r1, c1, c0, #0  // read SCTLR register to r1
700b0e6c: ee111f10     	mrc	p15, #0x0, r1, c1, c0, #0x0
;         tst     r1, #0x1                 // test bit 0
700b0e70: e3110001     	tst	r1, #1
;         movne   r0, #1                   // if not 0, MPU is enabled
700b0e74: 13a00001     	movne	r0, #1
;         bx      LR
700b0e78: e12fff1e     	bx	lr

700b0e7c <MpuP_setRegionAsm>:
;         mcr     p15, #0, r0, c6, c2, #0  // select MPU region
700b0e7c: ee060f12     	mcr	p15, #0x0, r0, c6, c2, #0x0
;         mcr     p15, #0, r1, c6, c1, #0  // set region base address
700b0e80: ee061f11     	mcr	p15, #0x0, r1, c6, c1, #0x0
;         mcr     p15, #0, r2, c6, c1, #2  // set region size and enable it
700b0e84: ee062f51     	mcr	p15, #0x0, r2, c6, c1, #0x2
;         mcr     p15, #0, r3, c6, c1, #4  // set protection attributes
700b0e88: ee063f91     	mcr	p15, #0x0, r3, c6, c1, #0x4
;         bx      LR
700b0e8c: e12fff1e     	bx	lr

Disassembly of section .text.boot:

700b0e90 <_c_int00_sbl>:
;         MRC     p15, #0, r1, c0, c0, #5
700b0e90: ee101fb0     	mrc	p15, #0x0, r1, c0, c0, #0x5
;         BFC     r1, #8, #24
700b0e94: e7df141f     	bfc	r1, #8, #24
;         CMP     r1, #0
700b0e98: e3510000     	cmp	r1, #0
;         BNE     _sblLoopForever
700b0e9c: 1a000001     	bne	0x700b0ea8 <_sblLoopForever> @ imm = #0x4
;         LDR     r1, _c_int00_addr
700b0ea0: e59f1008     	ldr	r1, [pc, #0x8]          @ 0x700b0eb0 <_c_int00_addr>
;         BLX     r1
700b0ea4: e12fff31     	blx	r1

700b0ea8 <_sblLoopForever>:
;         WFI
700b0ea8: e320f003     	wfi
;         B       _sblLoopForever
700b0eac: eafffffd     	b	0x700b0ea8 <_sblLoopForever> @ imm = #-0xc

700b0eb0 <_c_int00_addr>:
700b0eb0: b4 0e 0b 70  	.word	0x700b0eb4

700b0eb4 <_c_int00>:
;         mrs     r0, cpsr
700b0eb4: e10f0000     	mrs	r0, apsr
;         orr     r0, r0, #0xC0
700b0eb8: e38000c0     	orr	r0, r0, #192
;         msr     cpsr_cf, r0
700b0ebc: e129f000     	msr	CPSR_fc, r0
;         MRC      p15,#0x0,r0,c1,c0,#2
700b0ec0: ee110f50     	mrc	p15, #0x0, r0, c1, c0, #0x2
;         MOV      r3,#0xf00000
700b0ec4: e3a0360f     	mov	r3, #15728640
;         ORR      r0,r0,r3
700b0ec8: e1800003     	orr	r0, r0, r3
;         MCR      p15,#0x0,r0,c1,c0,#2
700b0ecc: ee010f50     	mcr	p15, #0x0, r0, c1, c0, #0x2
;         MOV      r0,#0x40000000
700b0ed0: e3a00101     	mov	r0, #1073741824
;         FMXR     FPEXC,r0
700b0ed4: eee80a10     	vmsr	fpexc, r0
;         MRS     r0, cpsr
700b0ed8: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b0edc: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x11  // SET FIQ MODE
700b0ee0: e3800011     	orr	r0, r0, #17
;         MSR     cpsr_cf, r0
700b0ee4: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_FIQ_STACK_END
700b0ee8: e59fd0d4     	ldr	sp, [pc, #0xd4]         @ 0x700b0fc4 <c_FIQ_STACK_END>
;         MRS     r0, cpsr
700b0eec: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b0ef0: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x12  // SET IRQ MODE
700b0ef4: e3800012     	orr	r0, r0, #18
;         MSR     cpsr_cf, r0
700b0ef8: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_IRQ_STACK_END
700b0efc: e59fd0bc     	ldr	sp, [pc, #0xbc]         @ 0x700b0fc0 <c_IRQ_STACK_END>
;         MRS     r0, cpsr
700b0f00: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b0f04: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x13  // SET SVC MODE
700b0f08: e3800013     	orr	r0, r0, #19
;         MSR     cpsr_cf, r0
700b0f0c: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_SVC_STACK_END
700b0f10: e59fd0b0     	ldr	sp, [pc, #0xb0]         @ 0x700b0fc8 <c_SVC_STACK_END>
;         MRS     r0, cpsr
700b0f14: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b0f18: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x17  // SET ABORT MODE
700b0f1c: e3800017     	orr	r0, r0, #23
;         MSR     cpsr_cf, r0
700b0f20: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_ABORT_STACK_END
700b0f24: e59fd0a0     	ldr	sp, [pc, #0xa0]         @ 0x700b0fcc <c_ABORT_STACK_END>
;         MRS     r0, cpsr
700b0f28: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b0f2c: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x1B  // SET ABORT MODE
700b0f30: e380001b     	orr	r0, r0, #27
;         MSR     cpsr_cf, r0
700b0f34: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_UNDEFINED_STACK_END
700b0f38: e59fd090     	ldr	sp, [pc, #0x90]         @ 0x700b0fd0 <c_UNDEFINED_STACK_END>
;         MRS     r0, cpsr
700b0f3c: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b0f40: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x1F  // SET SYSTEM MODE
700b0f44: e380001f     	orr	r0, r0, #31
;         MSR     cpsr_cf, r0
700b0f48: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_STACK_END
700b0f4c: e59fd068     	ldr	sp, [pc, #0x68]         @ 0x700b0fbc <c_STACK_END>
;         MRC p15, 0, r0, c1, c0, 0  // Read System Control Register
700b0f50: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         BIC r0, r0, #0x1 << 2      // Disable data cache bit
700b0f54: e3c00004     	bic	r0, r0, #4
;         BIC r0, r0, #0x1 << 12     // Disable instruction cache bit
700b0f58: e3c00a01     	bic	r0, r0, #4096
;         DSB
700b0f5c: f57ff04f     	dsb	sy
;         MCR p15, 0, r0, c1, c0, 0  // Write System Control Register
700b0f60: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         ISB                        // Ensures following instructions are not executed from cache
700b0f64: f57ff06f     	isb	sy
;         MRC p15, 0, r1, c1, c0, 1  // Read Auxiliary Control Register
700b0f68: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         ORR r1, r1, #(0x1 << 3)    //Enable ECC for Cache
700b0f6c: e3811008     	orr	r1, r1, #8
;         ORR r1,r1,#(0x1 << 5)
700b0f70: e3811020     	orr	r1, r1, #32
;         MCR p15, 0, r1, c1, c0, 1  // Write Auxiliary Control Register
700b0f74: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         MCR p15, 0, r0, c15, c5, 0 // Invalidate entire data cache
700b0f78: ee0f0f15     	mcr	p15, #0x0, r0, c15, c5, #0x0
;         MCR p15, 0, r0, c7, c5, 0  // Invalidate entire instruction cache
700b0f7c: ee070f15     	mcr	p15, #0x0, r0, c7, c5, #0x0
;         MRC p15, 0, r0, c1, c0, 0  // Read System Control Register
700b0f80: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         ORR r0, r0, #0x1 << 2      // Enable data cache bit
700b0f84: e3800004     	orr	r0, r0, #4
;         ORR r0, r0, #0x1 << 12     // Enable instruction cache bit
700b0f88: e3800a01     	orr	r0, r0, #4096
;         DSB
700b0f8c: f57ff04f     	dsb	sy
;         MCR p15, 0, r0, c1, c0, 0  // Write System Control Register
700b0f90: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         ISB
700b0f94: f57ff06f     	isb	sy
;         BL      __mpu_init
700b0f98: fa000028     	blx	0x700b1040 <__mpu_init> @ imm = #0xa0
;         BL      _system_pre_init
700b0f9c: fa00001b     	blx	0x700b1010 <_system_pre_init> @ imm = #0x6c
;         CMP     R0, #0
700b0fa0: e3500000     	cmp	r0, #0
;         BEQ     bypass_auto_init
700b0fa4: 0a000000     	beq	0x700b0fac <bypass_auto_init> @ imm = #0x0
;         BL      __TI_auto_init
700b0fa8: ebffee4c     	bl	0x700ac8e0 <__TI_auto_init_nobinit_nopinit> @ imm = #-0x46d0

700b0fac <bypass_auto_init>:
;         BL      main
700b0fac: fafffaaf     	blx	0x700afa70 <main>       @ imm = #-0x1544
;         MOV     R0, #1
700b0fb0: e3a00001     	mov	r0, #1
;         BL      exit
700b0fb4: eb000025     	bl	0x700b1050 <abort>      @ imm = #0x94

700b0fb8 <L1>:
; L1:     B       L1
700b0fb8: eafffffe     	b	0x700b0fb8 <L1>         @ imm = #-0x8

700b0fbc <c_STACK_END>:
700b0fbc: 80 92 09 70  	.word	0x70099280

700b0fc0 <c_IRQ_STACK_END>:
700b0fc0: 20 28 0b 70  	.word	0x700b2820

700b0fc4 <c_FIQ_STACK_END>:
700b0fc4: 20 29 0b 70  	.word	0x700b2920

700b0fc8 <c_SVC_STACK_END>:
700b0fc8: 20 39 0b 70  	.word	0x700b3920

700b0fcc <c_ABORT_STACK_END>:
700b0fcc: 20 3a 0b 70  	.word	0x700b3a20

700b0fd0 <c_UNDEFINED_STACK_END>:
700b0fd0: 20 3b 0b 70  	.word	0x700b3b20
700b0fd4: 00 00 00 00  	.word	0x00000000
700b0fd8: 00 00 00 00  	.word	0x00000000
700b0fdc: 00 00 00 00  	.word	0x00000000

700b0fe0 <_DebugP_assertNoLog>:
; {
700b0fe0: b580         	push	{r7, lr}
700b0fe2: b082         	sub	sp, #0x8
700b0fe4: 9001         	str	r0, [sp, #0x4]
;     if(expression==0)
700b0fe6: 9801         	ldr	r0, [sp, #0x4]
700b0fe8: b950         	cbnz	r0, 0x700b1000 <_DebugP_assertNoLog+0x20> @ imm = #0x14
700b0fea: e7ff         	b	0x700b0fec <_DebugP_assertNoLog+0xc> @ imm = #-0x2
700b0fec: 2001         	movs	r0, #0x1
;         volatile uint32_t assert_loop = 1;
700b0fee: 9000         	str	r0, [sp]
;         (void) HwiP_disable();
700b0ff0: f7ff eb36    	blx	0x700b0660 <HwiP_disable> @ imm = #-0x994
;         while(assert_loop!= 0U)
700b0ff4: e7ff         	b	0x700b0ff6 <_DebugP_assertNoLog+0x16> @ imm = #-0x2
700b0ff6: 9800         	ldr	r0, [sp]
700b0ff8: b108         	cbz	r0, 0x700b0ffe <_DebugP_assertNoLog+0x1e> @ imm = #0x2
700b0ffa: e7ff         	b	0x700b0ffc <_DebugP_assertNoLog+0x1c> @ imm = #-0x2
700b0ffc: e7fb         	b	0x700b0ff6 <_DebugP_assertNoLog+0x16> @ imm = #-0xa
;     }
700b0ffe: e7ff         	b	0x700b1000 <_DebugP_assertNoLog+0x20> @ imm = #-0x2
; }
700b1000: b002         	add	sp, #0x8
700b1002: bd80         	pop	{r7, pc}
		...

700b1010 <_system_pre_init>:
; {
700b1010: b580         	push	{r7, lr}
700b1012: b082         	sub	sp, #0x8
;     uint32_t bss_size = ((uintptr_t)&__BSS_END - (uintptr_t)&__BSS_START);
700b1014: f240 0000    	movw	r0, #0x0
700b1018: f2c7 0008    	movt	r0, #0x7008
700b101c: f245 2180    	movw	r1, #0x5280
700b1020: f2c7 0108    	movt	r1, #0x7008
700b1024: 1a09         	subs	r1, r1, r0
700b1026: 9101         	str	r1, [sp, #0x4]
;     (void) memset((void*)&__BSS_START, 0x00, bss_size);
700b1028: 9901         	ldr	r1, [sp, #0x4]
700b102a: f7ea e834    	blx	0x7009b094 <__aeabi_memclr8> @ imm = #-0x15f98
700b102e: 2001         	movs	r0, #0x1
;     return 1;
700b1030: b002         	add	sp, #0x8
700b1032: bd80         	pop	{r7, pc}
		...

700b1040 <__mpu_init>:
; {
700b1040: b580         	push	{r7, lr}
;     MpuP_init();
700b1042: f7ff fe9d    	bl	0x700b0d80 <MpuP_init>  @ imm = #-0x2c6
;     CacheP_init();
700b1046: e8bd 4080    	pop.w	{r7, lr}
700b104a: f7ff bd09    	b.w	0x700b0a60 <CacheP_init> @ imm = #-0x5ee
700b104e: 0000         	movs	r0, r0

Disassembly of section .text:abort:

700b1050 <abort>:
700b1050: e320f000     	nop
700b1054: eafffffe     	b	0x700b1054 <abort+0x4>  @ imm = #-0x8

Disassembly of section .text:

70099280 <__TI_printfi_nofloat>:
70099280: e92d4ff0     	push	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
70099284: e24ddf89     	sub	sp, sp, #548
70099288: e5907000     	ldr	r7, [r0]
7009928c: e1a08000     	mov	r8, r0
70099290: e1a05003     	mov	r5, r3
70099294: e1a06002     	mov	r6, r2
70099298: e58d1220     	str	r1, [sp, #0x220]
7009929c: e1a00007     	mov	r0, r7
700992a0: eb005809     	bl	0x700af2cc <strlen>     @ imm = #0x16024
700992a4: e0879000     	add	r9, r7, r0
700992a8: e3a0a000     	mov	r10, #0
700992ac: e28dbf83     	add	r11, sp, #524
700992b0: e3a04000     	mov	r4, #0
700992b4: e3e00000     	mvn	r0, #0
700992b8: e58da21c     	str	r10, [sp, #0x21c]
700992bc: e1570009     	cmp	r7, r9
700992c0: 2a0000a4     	bhs	0x70099558 <__TI_printfi_nofloat+0x2d8> @ imm = #0x290
700992c4: e2877001     	add	r7, r7, #1
700992c8: e58da20c     	str	r10, [sp, #0x20c]
700992cc: e5cda218     	strb	r10, [sp, #0x218]
700992d0: e58da210     	str	r10, [sp, #0x210]
700992d4: e58d0214     	str	r0, [sp, #0x214]
700992d8: e5570001     	ldrb	r0, [r7, #-0x1]
700992dc: e3500000     	cmp	r0, #0
700992e0: 0a00009c     	beq	0x70099558 <__TI_printfi_nofloat+0x2d8> @ imm = #0x270
700992e4: e3500025     	cmp	r0, #37
700992e8: 0a000005     	beq	0x70099304 <__TI_printfi_nofloat+0x84> @ imm = #0x14
700992ec: e1a01006     	mov	r1, r6
700992f0: e5887000     	str	r7, [r8]
700992f4: e12fff35     	blx	r5
700992f8: e2844001     	add	r4, r4, #1
700992fc: e2877001     	add	r7, r7, #1
70099300: eafffff4     	b	0x700992d8 <__TI_printfi_nofloat+0x58> @ imm = #-0x30
70099304: e1a0000b     	mov	r0, r11
70099308: e1a01008     	mov	r1, r8
7009930c: e58d421c     	str	r4, [sp, #0x21c]
70099310: e5887000     	str	r7, [r8]
70099314: eb000092     	bl	0x70099564 <pproc_fflags___TI_printfi_nofloat> @ imm = #0x248
70099318: e1a0000b     	mov	r0, r11
7009931c: e1a01008     	mov	r1, r8
70099320: e28d2e22     	add	r2, sp, #544
70099324: eb0000a8     	bl	0x700995cc <_pproc_fwp___TI_printfi_nofloat> @ imm = #0x2a0
70099328: e5980000     	ldr	r0, [r8]
7009932c: e5d02000     	ldrb	r2, [r0]
70099330: e2421068     	sub	r1, r2, #104
70099334: e1a010e1     	ror	r1, r1, #1
70099338: e3510009     	cmp	r1, #9
7009933c: 8a000026     	bhi	0x700993dc <__TI_printfi_nofloat+0x15c> @ imm = #0x98
70099340: e28f3000     	add	r3, pc, #0
70099344: e793f101     	ldr	pc, [r3, r1, lsl #2]
70099348: 70 93 09 70  	.word	0x70099370
7009934c: 8c 93 09 70  	.word	0x7009938c
70099350: 98 93 09 70  	.word	0x70099398
70099354: dc 93 09 70  	.word	0x700993dc
70099358: dc 93 09 70  	.word	0x700993dc
7009935c: dc 93 09 70  	.word	0x700993dc
70099360: b8 93 09 70  	.word	0x700993b8
70099364: dc 93 09 70  	.word	0x700993dc
70099368: dc 93 09 70  	.word	0x700993dc
7009936c: c4 93 09 70  	.word	0x700993c4
70099370: e1a01000     	mov	r1, r0
70099374: e59d220c     	ldr	r2, [sp, #0x20c]
70099378: e5f13001     	ldrb	r3, [r1, #0x1]!
7009937c: e3530068     	cmp	r3, #104
70099380: 1a00005b     	bne	0x700994f4 <__TI_printfi_nofloat+0x274> @ imm = #0x16c
70099384: e3822c02     	orr	r2, r2, #512
70099388: ea000008     	b	0x700993b0 <__TI_printfi_nofloat+0x130> @ imm = #0x20
7009938c: e59d120c     	ldr	r1, [sp, #0x20c]
70099390: e3812b02     	orr	r2, r1, #2048
70099394: ea00000c     	b	0x700993cc <__TI_printfi_nofloat+0x14c> @ imm = #0x30
70099398: e1a01000     	mov	r1, r0
7009939c: e59d220c     	ldr	r2, [sp, #0x20c]
700993a0: e5f13001     	ldrb	r3, [r1, #0x1]!
700993a4: e353006c     	cmp	r3, #108
700993a8: 1a000053     	bne	0x700994fc <__TI_printfi_nofloat+0x27c> @ imm = #0x14c
700993ac: e3822c01     	orr	r2, r2, #256
700993b0: e2801002     	add	r1, r0, #2
700993b4: ea000005     	b	0x700993d0 <__TI_printfi_nofloat+0x150> @ imm = #0x14
700993b8: e59d120c     	ldr	r1, [sp, #0x20c]
700993bc: e3812a02     	orr	r2, r1, #8192
700993c0: ea000001     	b	0x700993cc <__TI_printfi_nofloat+0x14c> @ imm = #0x4
700993c4: e59d120c     	ldr	r1, [sp, #0x20c]
700993c8: e3812a01     	orr	r2, r1, #4096
700993cc: e2801001     	add	r1, r0, #1
700993d0: e58d220c     	str	r2, [sp, #0x20c]
700993d4: e5d12000     	ldrb	r2, [r1]
700993d8: e1a00001     	mov	r0, r1
700993dc: e2807001     	add	r7, r0, #1
700993e0: e5cd2218     	strb	r2, [sp, #0x218]
700993e4: e3520073     	cmp	r2, #115
700993e8: e5887000     	str	r7, [r8]
700993ec: 0a00001a     	beq	0x7009945c <__TI_printfi_nofloat+0x1dc> @ imm = #0x68
700993f0: e352006e     	cmp	r2, #110
700993f4: 1a000022     	bne	0x70099484 <__TI_printfi_nofloat+0x204> @ imm = #0x88
700993f8: e59d020c     	ldr	r0, [sp, #0x20c]
700993fc: e3031f60     	movw	r1, #0x3f60
70099400: e0000001     	and	r0, r0, r1
70099404: e3500020     	cmp	r0, #32
70099408: 0a00003e     	beq	0x70099508 <__TI_printfi_nofloat+0x288> @ imm = #0xf8
7009940c: e3500040     	cmp	r0, #64
70099410: 0a000041     	beq	0x7009951c <__TI_printfi_nofloat+0x29c> @ imm = #0x104
70099414: e3a0a000     	mov	r10, #0
70099418: e3500a02     	cmp	r0, #8192
7009941c: 0a00002f     	beq	0x700994e0 <__TI_printfi_nofloat+0x260> @ imm = #0xbc
70099420: e3500c02     	cmp	r0, #512
70099424: 0a000042     	beq	0x70099534 <__TI_printfi_nofloat+0x2b4> @ imm = #0x108
70099428: e3500b02     	cmp	r0, #2048
7009942c: 0a000003     	beq	0x70099440 <__TI_printfi_nofloat+0x1c0> @ imm = #0xc
70099430: e3500a01     	cmp	r0, #4096
70099434: 0a000029     	beq	0x700994e0 <__TI_printfi_nofloat+0x260> @ imm = #0xa4
70099438: e3500c01     	cmp	r0, #256
7009943c: 1a000027     	bne	0x700994e0 <__TI_printfi_nofloat+0x260> @ imm = #0x9c
70099440: e59d0220     	ldr	r0, [sp, #0x220]
70099444: e1a03fc4     	asr	r3, r4, #31
70099448: e4901004     	ldr	r1, [r0], #4
7009944c: e58d0220     	str	r0, [sp, #0x220]
70099450: e5814000     	str	r4, [r1]
70099454: e5813004     	str	r3, [r1, #0x4]
70099458: ea000039     	b	0x70099544 <__TI_printfi_nofloat+0x2c4> @ imm = #0xe4
7009945c: e5dd020c     	ldrb	r0, [sp, #0x20c]
70099460: e3100040     	tst	r0, #64
70099464: 1a000016     	bne	0x700994c4 <__TI_printfi_nofloat+0x244> @ imm = #0x58
70099468: e1a0000b     	mov	r0, r11
7009946c: e1a01006     	mov	r1, r6
70099470: e28d2e22     	add	r2, sp, #544
70099474: e28d3f87     	add	r3, sp, #540
70099478: e58d5000     	str	r5, [sp]
7009947c: eb0000f9     	bl	0x70099868 <_pproc_str___TI_printfi_nofloat> @ imm = #0x3e4
70099480: ea00002f     	b	0x70099544 <__TI_printfi_nofloat+0x2c4> @ imm = #0xbc
70099484: e28da00e     	add	r10, sp, #14
70099488: e1a0100b     	mov	r1, r11
7009948c: e28d2e22     	add	r2, sp, #544
70099490: e1a0000a     	mov	r0, r10
70099494: eb000138     	bl	0x7009997c <_setfield___TI_printfi_nofloat> @ imm = #0x4e0
70099498: e59d3248     	ldr	r3, [sp, #0x248]
7009949c: e1a02000     	mov	r2, r0
700994a0: e1a0000a     	mov	r0, r10
700994a4: e1a01006     	mov	r1, r6
700994a8: e12fff33     	blx	r3
700994ac: e3700001     	cmn	r0, #1
700994b0: 10800004     	addne	r0, r0, r4
700994b4: e3a0a000     	mov	r10, #0
700994b8: e1a04000     	mov	r4, r0
700994bc: e58d021c     	str	r0, [sp, #0x21c]
700994c0: ea000020     	b	0x70099548 <__TI_printfi_nofloat+0x2c8> @ imm = #0x80
700994c4: e1a0000b     	mov	r0, r11
700994c8: e1a01006     	mov	r1, r6
700994cc: e28d2e22     	add	r2, sp, #544
700994d0: e28d3f87     	add	r3, sp, #540
700994d4: e58d5000     	str	r5, [sp]
700994d8: eb000092     	bl	0x70099728 <_pproc_wstr___TI_printfi_nofloat> @ imm = #0x248
700994dc: ea000018     	b	0x70099544 <__TI_printfi_nofloat+0x2c4> @ imm = #0x60
700994e0: e59d0220     	ldr	r0, [sp, #0x220]
700994e4: e4901004     	ldr	r1, [r0], #4
700994e8: e58d0220     	str	r0, [sp, #0x220]
700994ec: e5814000     	str	r4, [r1]
700994f0: ea000013     	b	0x70099544 <__TI_printfi_nofloat+0x2c4> @ imm = #0x4c
700994f4: e3820020     	orr	r0, r2, #32
700994f8: ea000000     	b	0x70099500 <__TI_printfi_nofloat+0x280> @ imm = #0x0
700994fc: e3820040     	orr	r0, r2, #64
70099500: e58d020c     	str	r0, [sp, #0x20c]
70099504: eaffffb2     	b	0x700993d4 <__TI_printfi_nofloat+0x154> @ imm = #-0x138
70099508: e59d0220     	ldr	r0, [sp, #0x220]
7009950c: e4901004     	ldr	r1, [r0], #4
70099510: e58d0220     	str	r0, [sp, #0x220]
70099514: e1c140b0     	strh	r4, [r1]
70099518: ea000003     	b	0x7009952c <__TI_printfi_nofloat+0x2ac> @ imm = #0xc
7009951c: e59d0220     	ldr	r0, [sp, #0x220]
70099520: e4901004     	ldr	r1, [r0], #4
70099524: e58d0220     	str	r0, [sp, #0x220]
70099528: e5814000     	str	r4, [r1]
7009952c: e3a0a000     	mov	r10, #0
70099530: ea000003     	b	0x70099544 <__TI_printfi_nofloat+0x2c4> @ imm = #0xc
70099534: e59d0220     	ldr	r0, [sp, #0x220]
70099538: e4901004     	ldr	r1, [r0], #4
7009953c: e58d0220     	str	r0, [sp, #0x220]
70099540: e5c14000     	strb	r4, [r1]
70099544: e59d421c     	ldr	r4, [sp, #0x21c]
70099548: e3e00000     	mvn	r0, #0
7009954c: e3740001     	cmn	r4, #1
70099550: 1affff59     	bne	0x700992bc <__TI_printfi_nofloat+0x3c> @ imm = #-0x29c
70099554: e3e04000     	mvn	r4, #0
70099558: e1a00004     	mov	r0, r4
7009955c: e28ddf89     	add	sp, sp, #548
70099560: e8bd8ff0     	pop	{r4, r5, r6, r7, r8, r9, r10, r11, pc}

70099564 <pproc_fflags___TI_printfi_nofloat>:
70099564: e591c000     	ldr	r12, [r1]
70099568: e5dc3000     	ldrb	r3, [r12]
7009956c: e3530020     	cmp	r3, #32
70099570: 0a00000a     	beq	0x700995a0 <pproc_fflags___TI_printfi_nofloat+0x3c> @ imm = #0x28
70099574: e3530023     	cmp	r3, #35
70099578: 0a00000a     	beq	0x700995a8 <pproc_fflags___TI_printfi_nofloat+0x44> @ imm = #0x28
7009957c: e3530030     	cmp	r3, #48
70099580: 0a00000a     	beq	0x700995b0 <pproc_fflags___TI_printfi_nofloat+0x4c> @ imm = #0x28
70099584: e3a02001     	mov	r2, #1
70099588: e353002d     	cmp	r3, #45
7009958c: 0a000008     	beq	0x700995b4 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x20
70099590: e353002b     	cmp	r3, #43
70099594: 112fff1e     	bxne	lr
70099598: e3a02002     	mov	r2, #2
7009959c: ea000004     	b	0x700995b4 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x10
700995a0: e3a02004     	mov	r2, #4
700995a4: ea000002     	b	0x700995b4 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x8
700995a8: e3a02008     	mov	r2, #8
700995ac: ea000000     	b	0x700995b4 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x0
700995b0: e3a02010     	mov	r2, #16
700995b4: e5903000     	ldr	r3, [r0]
700995b8: e1832002     	orr	r2, r3, r2
700995bc: e28c3001     	add	r3, r12, #1
700995c0: e5802000     	str	r2, [r0]
700995c4: e5813000     	str	r3, [r1]
700995c8: eaffffe5     	b	0x70099564 <pproc_fflags___TI_printfi_nofloat> @ imm = #-0x6c

700995cc <_pproc_fwp___TI_printfi_nofloat>:
700995cc: e92d48ff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r11, lr}
700995d0: e1a05001     	mov	r5, r1
700995d4: e5911000     	ldr	r1, [r1]
700995d8: e1a06002     	mov	r6, r2
700995dc: e1a04000     	mov	r4, r0
700995e0: e5d13000     	ldrb	r3, [r1]
700995e4: e353002a     	cmp	r3, #42
700995e8: 1a00000f     	bne	0x7009962c <_pproc_fwp___TI_printfi_nofloat+0x60> @ imm = #0x3c
700995ec: e5960000     	ldr	r0, [r6]
700995f0: e2801004     	add	r1, r0, #4
700995f4: e5861000     	str	r1, [r6]
700995f8: e5900000     	ldr	r0, [r0]
700995fc: e3700001     	cmn	r0, #1
70099600: e5840004     	str	r0, [r4, #0x4]
70099604: ca000004     	bgt	0x7009961c <_pproc_fwp___TI_printfi_nofloat+0x50> @ imm = #0x10
70099608: e5941000     	ldr	r1, [r4]
7009960c: e2600000     	rsb	r0, r0, #0
70099610: e3811001     	orr	r1, r1, #1
70099614: e5840004     	str	r0, [r4, #0x4]
70099618: e5841000     	str	r1, [r4]
7009961c: e5950000     	ldr	r0, [r5]
70099620: e2807001     	add	r7, r0, #1
70099624: e5857000     	str	r7, [r5]
70099628: ea000015     	b	0x70099684 <_pproc_fwp___TI_printfi_nofloat+0xb8> @ imm = #0x54
7009962c: e3a00000     	mov	r0, #0
70099630: e28d2006     	add	r2, sp, #6
70099634: e2433030     	sub	r3, r3, #48
70099638: e3530009     	cmp	r3, #9
7009963c: 8a000007     	bhi	0x70099660 <_pproc_fwp___TI_printfi_nofloat+0x94> @ imm = #0x1c
70099640: e0813000     	add	r3, r1, r0
70099644: e2837001     	add	r7, r3, #1
70099648: e5857000     	str	r7, [r5]
7009964c: e7d17000     	ldrb	r7, [r1, r0]
70099650: e5d33001     	ldrb	r3, [r3, #0x1]
70099654: e7c27000     	strb	r7, [r2, r0]
70099658: e2800001     	add	r0, r0, #1
7009965c: eafffff4     	b	0x70099634 <_pproc_fwp___TI_printfi_nofloat+0x68> @ imm = #-0x30
70099660: e3a03000     	mov	r3, #0
70099664: e0817000     	add	r7, r1, r0
70099668: e7c23000     	strb	r3, [r2, r0]
7009966c: e5dd2006     	ldrb	r2, [sp, #0x6]
70099670: e3520000     	cmp	r2, #0
70099674: 0a000002     	beq	0x70099684 <_pproc_fwp___TI_printfi_nofloat+0xb8> @ imm = #0x8
70099678: e28d0006     	add	r0, sp, #6
7009967c: eb00478e     	bl	0x700ab4bc <atoi>       @ imm = #0x11e38
70099680: e5840004     	str	r0, [r4, #0x4]
70099684: e5d70000     	ldrb	r0, [r7]
70099688: e350002e     	cmp	r0, #46
7009968c: 18bd88ff     	popne	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}
70099690: e2870001     	add	r0, r7, #1
70099694: e5850000     	str	r0, [r5]
70099698: e5d72001     	ldrb	r2, [r7, #0x1]
7009969c: e352002a     	cmp	r2, #42
700996a0: 1a000008     	bne	0x700996c8 <_pproc_fwp___TI_printfi_nofloat+0xfc> @ imm = #0x20
700996a4: e5960000     	ldr	r0, [r6]
700996a8: e2801004     	add	r1, r0, #4
700996ac: e5861000     	str	r1, [r6]
700996b0: e5951000     	ldr	r1, [r5]
700996b4: e5900000     	ldr	r0, [r0]
700996b8: e2811001     	add	r1, r1, #1
700996bc: e5840008     	str	r0, [r4, #0x8]
700996c0: e5851000     	str	r1, [r5]
700996c4: e8bd88ff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}
700996c8: e3a00000     	mov	r0, #0
700996cc: e28d1006     	add	r1, sp, #6
700996d0: e2422030     	sub	r2, r2, #48
700996d4: e3520009     	cmp	r2, #9
700996d8: 8a000007     	bhi	0x700996fc <_pproc_fwp___TI_printfi_nofloat+0x130> @ imm = #0x1c
700996dc: e0872000     	add	r2, r7, r0
700996e0: e2823002     	add	r3, r2, #2
700996e4: e5853000     	str	r3, [r5]
700996e8: e5d23001     	ldrb	r3, [r2, #0x1]
700996ec: e5d22002     	ldrb	r2, [r2, #0x2]
700996f0: e7c13000     	strb	r3, [r1, r0]
700996f4: e2800001     	add	r0, r0, #1
700996f8: eafffff4     	b	0x700996d0 <_pproc_fwp___TI_printfi_nofloat+0x104> @ imm = #-0x30
700996fc: e3a02000     	mov	r2, #0
70099700: e7c12000     	strb	r2, [r1, r0]
70099704: e5dd0006     	ldrb	r0, [sp, #0x6]
70099708: e3500000     	cmp	r0, #0
7009970c: 0a000003     	beq	0x70099720 <_pproc_fwp___TI_printfi_nofloat+0x154> @ imm = #0xc
70099710: e28d0006     	add	r0, sp, #6
70099714: eb004768     	bl	0x700ab4bc <atoi>       @ imm = #0x11da0
70099718: e5840008     	str	r0, [r4, #0x8]
7009971c: e8bd88ff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}
70099720: e5842008     	str	r2, [r4, #0x8]
70099724: e8bd88ff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}

70099728 <_pproc_wstr___TI_printfi_nofloat>:
70099728: e92d4ff8     	push	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
7009972c: e5927000     	ldr	r7, [r2]
70099730: e1a04001     	mov	r4, r1
70099734: e59dc028     	ldr	r12, [sp, #0x28]
70099738: e2876004     	add	r6, r7, #4
7009973c: e5826000     	str	r6, [r2]
70099740: e5976000     	ldr	r6, [r7]
70099744: e3560000     	cmp	r6, #0
70099748: 0a00002d     	beq	0x70099804 <_pproc_wstr___TI_printfi_nofloat+0xdc> @ imm = #0xb4
7009974c: e5907008     	ldr	r7, [r0, #0x8]
70099750: e1a05003     	mov	r5, r3
70099754: e1a09000     	mov	r9, r0
70099758: e1a0800c     	mov	r8, r12
7009975c: e3570000     	cmp	r7, #0
70099760: 4a000003     	bmi	0x70099774 <_pproc_wstr___TI_printfi_nofloat+0x4c> @ imm = #0xc
70099764: e1a00006     	mov	r0, r6
70099768: eb005660     	bl	0x700af0f0 <wcslen>     @ imm = #0x15980
7009976c: e1570000     	cmp	r7, r0
70099770: 3a000002     	blo	0x70099780 <_pproc_wstr___TI_printfi_nofloat+0x58> @ imm = #0x8
70099774: e1a00006     	mov	r0, r6
70099778: eb00565c     	bl	0x700af0f0 <wcslen>     @ imm = #0x15970
7009977c: e1a07000     	mov	r7, r0
70099780: e599a004     	ldr	r10, [r9, #0x4]
70099784: e1a0b007     	mov	r11, r7
70099788: e5950000     	ldr	r0, [r5]
7009978c: e58d5000     	str	r5, [sp]
70099790: e15a0007     	cmp	r10, r7
70099794: c1a0b00a     	movgt	r11, r10
70099798: e080000b     	add	r0, r0, r11
7009979c: e5850000     	str	r0, [r5]
700997a0: da00000b     	ble	0x700997d4 <_pproc_wstr___TI_printfi_nofloat+0xac> @ imm = #0x2c
700997a4: e5d90000     	ldrb	r0, [r9]
700997a8: e3100001     	tst	r0, #1
700997ac: 1a000008     	bne	0x700997d4 <_pproc_wstr___TI_printfi_nofloat+0xac> @ imm = #0x20
700997b0: e04b0007     	sub	r0, r11, r7
700997b4: e1c05fc0     	bic	r5, r0, r0, asr #31
700997b8: e3550000     	cmp	r5, #0
700997bc: 0a000004     	beq	0x700997d4 <_pproc_wstr___TI_printfi_nofloat+0xac> @ imm = #0x10
700997c0: e3a00020     	mov	r0, #32
700997c4: e1a01004     	mov	r1, r4
700997c8: e12fff38     	blx	r8
700997cc: e2455001     	sub	r5, r5, #1
700997d0: eafffff8     	b	0x700997b8 <_pproc_wstr___TI_printfi_nofloat+0x90> @ imm = #-0x20
700997d4: e1c75fc7     	bic	r5, r7, r7, asr #31
700997d8: e3550000     	cmp	r5, #0
700997dc: 0a00000c     	beq	0x70099814 <_pproc_wstr___TI_printfi_nofloat+0xec> @ imm = #0x30
700997e0: e5960000     	ldr	r0, [r6]
700997e4: e3500c01     	cmp	r0, #256
700997e8: 2a000017     	bhs	0x7009984c <_pproc_wstr___TI_printfi_nofloat+0x124> @ imm = #0x5c
700997ec: e6ef0070     	uxtb	r0, r0
700997f0: e1a01004     	mov	r1, r4
700997f4: e2866004     	add	r6, r6, #4
700997f8: e12fff38     	blx	r8
700997fc: e2455001     	sub	r5, r5, #1
70099800: eafffff4     	b	0x700997d8 <_pproc_wstr___TI_printfi_nofloat+0xb0> @ imm = #-0x30
70099804: e3a00000     	mov	r0, #0
70099808: e1a01004     	mov	r1, r4
7009980c: e8bd4ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
70099810: e12fff1c     	bx	r12
70099814: e15a0007     	cmp	r10, r7
70099818: da000011     	ble	0x70099864 <_pproc_wstr___TI_printfi_nofloat+0x13c> @ imm = #0x44
7009981c: e5d90000     	ldrb	r0, [r9]
70099820: e3100001     	tst	r0, #1
70099824: 08bd8ff8     	popeq	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
70099828: e04b0007     	sub	r0, r11, r7
7009982c: e1c05fc0     	bic	r5, r0, r0, asr #31
70099830: e3550000     	cmp	r5, #0
70099834: 0a00000a     	beq	0x70099864 <_pproc_wstr___TI_printfi_nofloat+0x13c> @ imm = #0x28
70099838: e3a00020     	mov	r0, #32
7009983c: e1a01004     	mov	r1, r4
70099840: e12fff38     	blx	r8
70099844: e2455001     	sub	r5, r5, #1
70099848: eafffff8     	b	0x70099830 <_pproc_wstr___TI_printfi_nofloat+0x108> @ imm = #-0x20
7009984c: e3e00000     	mvn	r0, #0
70099850: e59d1000     	ldr	r1, [sp]
70099854: e5810000     	str	r0, [r1]
70099858: eb00048d     	bl	0x7009aa94 <__aeabi_errno_addr> @ imm = #0x1234
7009985c: e3a01058     	mov	r1, #88
70099860: e5801000     	str	r1, [r0]
70099864: e8bd8ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}

70099868 <_pproc_str___TI_printfi_nofloat>:
70099868: e92d4ff8     	push	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
7009986c: e5927000     	ldr	r7, [r2]
70099870: e1a04001     	mov	r4, r1
70099874: e59dc028     	ldr	r12, [sp, #0x28]
70099878: e2876004     	add	r6, r7, #4
7009987c: e5826000     	str	r6, [r2]
70099880: e5977000     	ldr	r7, [r7]
70099884: e3570000     	cmp	r7, #0
70099888: 0a000037     	beq	0x7009996c <_pproc_str___TI_printfi_nofloat+0x104> @ imm = #0xdc
7009988c: e590b008     	ldr	r11, [r0, #0x8]
70099890: e1a05003     	mov	r5, r3
70099894: e1a08000     	mov	r8, r0
70099898: e1a0600c     	mov	r6, r12
7009989c: e35b0000     	cmp	r11, #0
700998a0: 4a000003     	bmi	0x700998b4 <_pproc_str___TI_printfi_nofloat+0x4c> @ imm = #0xc
700998a4: e1a00007     	mov	r0, r7
700998a8: eb005687     	bl	0x700af2cc <strlen>     @ imm = #0x15a1c
700998ac: e15b0000     	cmp	r11, r0
700998b0: 3a000002     	blo	0x700998c0 <_pproc_str___TI_printfi_nofloat+0x58> @ imm = #0x8
700998b4: e1a00007     	mov	r0, r7
700998b8: eb005683     	bl	0x700af2cc <strlen>     @ imm = #0x15a0c
700998bc: e1a0b000     	mov	r11, r0
700998c0: e598a004     	ldr	r10, [r8, #0x4]
700998c4: e1a0900b     	mov	r9, r11
700998c8: e5950000     	ldr	r0, [r5]
700998cc: e15a000b     	cmp	r10, r11
700998d0: c1a0900a     	movgt	r9, r10
700998d4: e0800009     	add	r0, r0, r9
700998d8: e5850000     	str	r0, [r5]
700998dc: da00000b     	ble	0x70099910 <_pproc_str___TI_printfi_nofloat+0xa8> @ imm = #0x2c
700998e0: e5d80000     	ldrb	r0, [r8]
700998e4: e3100001     	tst	r0, #1
700998e8: 1a000008     	bne	0x70099910 <_pproc_str___TI_printfi_nofloat+0xa8> @ imm = #0x20
700998ec: e049000b     	sub	r0, r9, r11
700998f0: e1c05fc0     	bic	r5, r0, r0, asr #31
700998f4: e3550000     	cmp	r5, #0
700998f8: 0a000004     	beq	0x70099910 <_pproc_str___TI_printfi_nofloat+0xa8> @ imm = #0x10
700998fc: e3a00020     	mov	r0, #32
70099900: e1a01004     	mov	r1, r4
70099904: e12fff36     	blx	r6
70099908: e2455001     	sub	r5, r5, #1
7009990c: eafffff8     	b	0x700998f4 <_pproc_str___TI_printfi_nofloat+0x8c> @ imm = #-0x20
70099910: e1cb5fcb     	bic	r5, r11, r11, asr #31
70099914: e3550000     	cmp	r5, #0
70099918: 0a000004     	beq	0x70099930 <_pproc_str___TI_printfi_nofloat+0xc8> @ imm = #0x10
7009991c: e4d70001     	ldrb	r0, [r7], #1
70099920: e1a01004     	mov	r1, r4
70099924: e12fff36     	blx	r6
70099928: e2455001     	sub	r5, r5, #1
7009992c: eafffff8     	b	0x70099914 <_pproc_str___TI_printfi_nofloat+0xac> @ imm = #-0x20
70099930: e15a000b     	cmp	r10, r11
70099934: da00000b     	ble	0x70099968 <_pproc_str___TI_printfi_nofloat+0x100> @ imm = #0x2c
70099938: e5d80000     	ldrb	r0, [r8]
7009993c: e3100001     	tst	r0, #1
70099940: 08bd8ff8     	popeq	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
70099944: e049000b     	sub	r0, r9, r11
70099948: e1c05fc0     	bic	r5, r0, r0, asr #31
7009994c: e3550000     	cmp	r5, #0
70099950: 0a000004     	beq	0x70099968 <_pproc_str___TI_printfi_nofloat+0x100> @ imm = #0x10
70099954: e3a00020     	mov	r0, #32
70099958: e1a01004     	mov	r1, r4
7009995c: e12fff36     	blx	r6
70099960: e2455001     	sub	r5, r5, #1
70099964: eafffff8     	b	0x7009994c <_pproc_str___TI_printfi_nofloat+0xe4> @ imm = #-0x20
70099968: e8bd8ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
7009996c: e3a00000     	mov	r0, #0
70099970: e1a01004     	mov	r1, r4
70099974: e8bd4ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
70099978: e12fff1c     	bx	r12

7009997c <_setfield___TI_printfi_nofloat>:
7009997c: e92d4ffe     	push	{r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
70099980: e1a05001     	mov	r5, r1
70099984: e5918004     	ldr	r8, [r1, #0x4]
70099988: e3a09000     	mov	r9, #0
7009998c: e1a06002     	mov	r6, r2
70099990: e30011fd     	movw	r1, #0x1fd
70099994: e3a02020     	mov	r2, #32
70099998: e1a04000     	mov	r4, r0
7009999c: e58d9004     	str	r9, [sp, #0x4]
700999a0: eb0057ba     	bl	0x700af890 <__aeabi_memset8> @ imm = #0x15ee8
700999a4: e1a0b004     	mov	r11, r4
700999a8: e2842f7f     	add	r2, r4, #508
700999ac: e5eb91fd     	strb	r9, [r11, #0x1fd]!
700999b0: e5d5000c     	ldrb	r0, [r5, #0xc]
700999b4: e58d2008     	str	r2, [sp, #0x8]
700999b8: e2401063     	sub	r1, r0, #99
700999bc: e3510015     	cmp	r1, #21
700999c0: 8a000080     	bhi	0x70099bc8 <_setfield___TI_printfi_nofloat+0x24c> @ imm = #0x200
700999c4: e59f2258     	ldr	r2, [pc, #0x258]        @ 0x70099c24 <_setfield___TI_printfi_nofloat+0x2a8>
700999c8: e3a03001     	mov	r3, #1
700999cc: e1120113     	tst	r2, r3, lsl r1
700999d0: 0a00006b     	beq	0x70099b84 <_setfield___TI_printfi_nofloat+0x208> @ imm = #0x1ac
700999d4: e28d1004     	add	r1, sp, #4
700999d8: e28d2008     	add	r2, sp, #8
700999dc: e1a00005     	mov	r0, r5
700999e0: e1a03006     	mov	r3, r6
700999e4: eb00008f     	bl	0x70099c28 <_pproc_diouxp___TI_printfi_nofloat> @ imm = #0x23c
700999e8: e3a09000     	mov	r9, #0
700999ec: e5d5000c     	ldrb	r0, [r5, #0xc]
700999f0: e240106f     	sub	r1, r0, #111
700999f4: e3510009     	cmp	r1, #9
700999f8: 8a00003c     	bhi	0x70099af0 <_setfield___TI_printfi_nofloat+0x174> @ imm = #0xf0
700999fc: e3a02001     	mov	r2, #1
70099a00: e3003243     	movw	r3, #0x243
70099a04: e1130112     	tst	r3, r2, lsl r1
70099a08: 0a000038     	beq	0x70099af0 <_setfield___TI_printfi_nofloat+0x174> @ imm = #0xe0
70099a0c: e3a0a000     	mov	r10, #0
70099a10: e5d51000     	ldrb	r1, [r5]
70099a14: e0847008     	add	r7, r4, r8
70099a18: e59d0008     	ldr	r0, [sp, #0x8]
70099a1c: e1a06004     	mov	r6, r4
70099a20: e3110001     	tst	r1, #1
70099a24: 1a000006     	bne	0x70099a44 <_setfield___TI_printfi_nofloat+0xc8> @ imm = #0x18
70099a28: e5952004     	ldr	r2, [r5, #0x4]
70099a2c: e04b1000     	sub	r1, r11, r0
70099a30: e1a06004     	mov	r6, r4
70099a34: e1510002     	cmp	r1, r2
70099a38: ca000001     	bgt	0x70099a44 <_setfield___TI_printfi_nofloat+0xc8> @ imm = #0x4
70099a3c: e0471001     	sub	r1, r7, r1
70099a40: e2816001     	add	r6, r1, #1
70099a44: e2801001     	add	r1, r0, #1
70099a48: e1a00006     	mov	r0, r6
70099a4c: e3a02000     	mov	r2, #0
70099a50: e30031fe     	movw	r3, #0x1fe
70099a54: e3a08000     	mov	r8, #0
70099a58: eb004e5e     	bl	0x700ad3d8 <memccpy>    @ imm = #0x13978
70099a5c: e58d0008     	str	r0, [sp, #0x8]
70099a60: e3590000     	cmp	r9, #0
70099a64: 0a000001     	beq	0x70099a70 <_setfield___TI_printfi_nofloat+0xf4> @ imm = #0x4
70099a68: e4c08001     	strb	r8, [r0], #1
70099a6c: e58d0008     	str	r0, [sp, #0x8]
70099a70: e1500007     	cmp	r0, r7
70099a74: 8a000006     	bhi	0x70099a94 <_setfield___TI_printfi_nofloat+0x118> @ imm = #0x18
70099a78: e0471000     	sub	r1, r7, r0
70099a7c: e2400001     	sub	r0, r0, #1
70099a80: e3a02020     	mov	r2, #32
70099a84: e2811001     	add	r1, r1, #1
70099a88: eb005780     	bl	0x700af890 <__aeabi_memset8> @ imm = #0x15e00
70099a8c: e3a00000     	mov	r0, #0
70099a90: e5c70000     	strb	r0, [r7]
70099a94: e5d50000     	ldrb	r0, [r5]
70099a98: e3100010     	tst	r0, #16
70099a9c: 1a000004     	bne	0x70099ab4 <_setfield___TI_printfi_nofloat+0x138> @ imm = #0x10
70099aa0: e0461004     	sub	r1, r6, r4
70099aa4: e1a00004     	mov	r0, r4
70099aa8: e3a02020     	mov	r2, #32
70099aac: eb005777     	bl	0x700af890 <__aeabi_memset8> @ imm = #0x15ddc
70099ab0: ea00002f     	b	0x70099b74 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0xbc
70099ab4: e1560004     	cmp	r6, r4
70099ab8: 0a00002d     	beq	0x70099b74 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0xb4
70099abc: e0461004     	sub	r1, r6, r4
70099ac0: e1a00004     	mov	r0, r4
70099ac4: e3a02030     	mov	r2, #48
70099ac8: e3a07030     	mov	r7, #48
70099acc: eb00576f     	bl	0x700af890 <__aeabi_memset8> @ imm = #0x15dbc
70099ad0: e59d0004     	ldr	r0, [sp, #0x4]
70099ad4: e190000a     	orrs	r0, r0, r10
70099ad8: 1a00000e     	bne	0x70099b18 <_setfield___TI_printfi_nofloat+0x19c> @ imm = #0x38
70099adc: e5d50000     	ldrb	r0, [r5]
70099ae0: e3100004     	tst	r0, #4
70099ae4: 1a00000b     	bne	0x70099b18 <_setfield___TI_printfi_nofloat+0x19c> @ imm = #0x2c
70099ae8: e1a00004     	mov	r0, r4
70099aec: ea00000d     	b	0x70099b28 <_setfield___TI_printfi_nofloat+0x1ac> @ imm = #0x34
70099af0: e3500058     	cmp	r0, #88
70099af4: 0affffc4     	beq	0x70099a0c <_setfield___TI_printfi_nofloat+0x90> @ imm = #-0xf0
70099af8: e5950000     	ldr	r0, [r5]
70099afc: e59d1004     	ldr	r1, [sp, #0x4]
70099b00: e200a002     	and	r10, r0, #2
70099b04: e3510000     	cmp	r1, #0
70099b08: 0a000037     	beq	0x70099bec <_setfield___TI_printfi_nofloat+0x270> @ imm = #0xdc
70099b0c: e3a0002d     	mov	r0, #45
70099b10: e59d1008     	ldr	r1, [sp, #0x8]
70099b14: ea00003f     	b	0x70099c18 <_setfield___TI_printfi_nofloat+0x29c> @ imm = #0xfc
70099b18: e5d61000     	ldrb	r1, [r6]
70099b1c: e1a00004     	mov	r0, r4
70099b20: e4c01001     	strb	r1, [r0], #1
70099b24: e4c67001     	strb	r7, [r6], #1
70099b28: e5d5100c     	ldrb	r1, [r5, #0xc]
70099b2c: e3510041     	cmp	r1, #65
70099b30: 0a00000b     	beq	0x70099b64 <_setfield___TI_printfi_nofloat+0x1e8> @ imm = #0x2c
70099b34: e3510058     	cmp	r1, #88
70099b38: 0a000004     	beq	0x70099b50 <_setfield___TI_printfi_nofloat+0x1d4> @ imm = #0x10
70099b3c: e3510061     	cmp	r1, #97
70099b40: 0a000007     	beq	0x70099b64 <_setfield___TI_printfi_nofloat+0x1e8> @ imm = #0x1c
70099b44: e3510078     	cmp	r1, #120
70099b48: 13510070     	cmpne	r1, #112
70099b4c: 1a000008     	bne	0x70099b74 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0x20
70099b50: e5d52000     	ldrb	r2, [r5]
70099b54: e3120008     	tst	r2, #8
70099b58: 1a000001     	bne	0x70099b64 <_setfield___TI_printfi_nofloat+0x1e8> @ imm = #0x4
70099b5c: e3510061     	cmp	r1, #97
70099b60: 1a000003     	bne	0x70099b74 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0xc
70099b64: e5d61001     	ldrb	r1, [r6, #0x1]
70099b68: e3a02030     	mov	r2, #48
70099b6c: e5c01001     	strb	r1, [r0, #0x1]
70099b70: e5c62001     	strb	r2, [r6, #0x1]
70099b74: e1a00004     	mov	r0, r4
70099b78: eb0055d3     	bl	0x700af2cc <strlen>     @ imm = #0x1574c
70099b7c: e0800009     	add	r0, r0, r9
70099b80: e8bd8ffe     	pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
70099b84: e3510000     	cmp	r1, #0
70099b88: 1a00000e     	bne	0x70099bc8 <_setfield___TI_printfi_nofloat+0x24c> @ imm = #0x38
70099b8c: e5960000     	ldr	r0, [r6]
70099b90: e2801004     	add	r1, r0, #4
70099b94: e5861000     	str	r1, [r6]
70099b98: e5900000     	ldr	r0, [r0]
70099b9c: e6ef1070     	uxtb	r1, r0
70099ba0: e5c401fc     	strb	r0, [r4, #0x1fc]
70099ba4: e30001fb     	movw	r0, #0x1fb
70099ba8: e5952000     	ldr	r2, [r5]
70099bac: e16f1f11     	clz	r1, r1
70099bb0: e0840000     	add	r0, r4, r0
70099bb4: e3c22002     	bic	r2, r2, #2
70099bb8: e1a092a1     	lsr	r9, r1, #5
70099bbc: e58d0008     	str	r0, [sp, #0x8]
70099bc0: e5852000     	str	r2, [r5]
70099bc4: eaffff88     	b	0x700999ec <_setfield___TI_printfi_nofloat+0x70> @ imm = #-0x1e0
70099bc8: e3500025     	cmp	r0, #37
70099bcc: 0a000002     	beq	0x70099bdc <_setfield___TI_printfi_nofloat+0x260> @ imm = #0x8
70099bd0: e3500058     	cmp	r0, #88
70099bd4: 0affff7e     	beq	0x700999d4 <_setfield___TI_printfi_nofloat+0x58> @ imm = #-0x208
70099bd8: eaffff84     	b	0x700999f0 <_setfield___TI_printfi_nofloat+0x74> @ imm = #-0x1f0
70099bdc: e3a01025     	mov	r1, #37
70099be0: e3a00001     	mov	r0, #1
70099be4: e1c410b0     	strh	r1, [r4]
70099be8: e8bd8ffe     	pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
70099bec: e35a0000     	cmp	r10, #0
70099bf0: 1a000005     	bne	0x70099c0c <_setfield___TI_printfi_nofloat+0x290> @ imm = #0x14
70099bf4: e3100004     	tst	r0, #4
70099bf8: 0affff83     	beq	0x70099a0c <_setfield___TI_printfi_nofloat+0x90> @ imm = #-0x1f4
70099bfc: e3a00020     	mov	r0, #32
70099c00: e59d1008     	ldr	r1, [sp, #0x8]
70099c04: e3a0a000     	mov	r10, #0
70099c08: ea000002     	b	0x70099c18 <_setfield___TI_printfi_nofloat+0x29c> @ imm = #0x8
70099c0c: e3a0002b     	mov	r0, #43
70099c10: e59d1008     	ldr	r1, [sp, #0x8]
70099c14: e3a0a001     	mov	r10, #1
70099c18: e4410001     	strb	r0, [r1], #-1
70099c1c: e58d1008     	str	r1, [sp, #0x8]
70099c20: eaffff7a     	b	0x70099a10 <_setfield___TI_printfi_nofloat+0x94> @ imm = #-0x218
70099c24: 42 30 24 00  	.word	0x00243042

70099c28 <_pproc_diouxp___TI_printfi_nofloat>:
70099c28: e92d48fc     	push	{r2, r3, r4, r5, r6, r7, r11, lr}
70099c2c: e1a05000     	mov	r5, r0
70099c30: e5900008     	ldr	r0, [r0, #0x8]
70099c34: e1a04002     	mov	r4, r2
70099c38: e1a07001     	mov	r7, r1
70099c3c: e3a06010     	mov	r6, #16
70099c40: e3700001     	cmn	r0, #1
70099c44: c5950000     	ldrgt	r0, [r5]
70099c48: c3c00010     	bicgt	r0, r0, #16
70099c4c: c5850000     	strgt	r0, [r5]
70099c50: d3a00001     	movle	r0, #1
70099c54: d5850008     	strle	r0, [r5, #0x8]
70099c58: e5d5000c     	ldrb	r0, [r5, #0xc]
70099c5c: e3500058     	cmp	r0, #88
70099c60: 0a000005     	beq	0x70099c7c <_pproc_diouxp___TI_printfi_nofloat+0x54> @ imm = #0x14
70099c64: e3500078     	cmp	r0, #120
70099c68: 13500070     	cmpne	r0, #112
70099c6c: 0a000002     	beq	0x70099c7c <_pproc_diouxp___TI_printfi_nofloat+0x54> @ imm = #0x8
70099c70: e350006f     	cmp	r0, #111
70099c74: 13a0600a     	movne	r6, #10
70099c78: 03a06008     	moveq	r6, #8
70099c7c: e1a00005     	mov	r0, r5
70099c80: e1a01003     	mov	r1, r3
70099c84: eb00004d     	bl	0x70099dc0 <_getarg_diouxp___TI_printfi_nofloat> @ imm = #0x134
70099c88: e5952008     	ldr	r2, [r5, #0x8]
70099c8c: e3520000     	cmp	r2, #0
70099c90: 01902001     	orrseq	r2, r0, r1
70099c94: 0a000007     	beq	0x70099cb8 <_pproc_diouxp___TI_printfi_nofloat+0x90> @ imm = #0x1c
70099c98: e5d5300c     	ldrb	r3, [r5, #0xc]
70099c9c: e3530064     	cmp	r3, #100
70099ca0: 1a00000b     	bne	0x70099cd4 <_pproc_diouxp___TI_printfi_nofloat+0xac> @ imm = #0x2c
70099ca4: e3a02064     	mov	r2, #100
70099ca8: e3a03064     	mov	r3, #100
70099cac: e3710001     	cmn	r1, #1
70099cb0: ca000011     	bgt	0x70099cfc <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x44
70099cb4: ea00000b     	b	0x70099ce8 <_pproc_diouxp___TI_printfi_nofloat+0xc0> @ imm = #0x2c
70099cb8: e5d50000     	ldrb	r0, [r5]
70099cbc: e3100008     	tst	r0, #8
70099cc0: 0a00003d     	beq	0x70099dbc <_pproc_diouxp___TI_printfi_nofloat+0x194> @ imm = #0xf4
70099cc4: e5d5300c     	ldrb	r3, [r5, #0xc]
70099cc8: e3a00000     	mov	r0, #0
70099ccc: e3a01000     	mov	r1, #0
70099cd0: ea000009     	b	0x70099cfc <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x24
70099cd4: e3530069     	cmp	r3, #105
70099cd8: 1a000007     	bne	0x70099cfc <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x1c
70099cdc: e3a02069     	mov	r2, #105
70099ce0: e3510000     	cmp	r1, #0
70099ce4: 5a000004     	bpl	0x70099cfc <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x10
70099ce8: e2700000     	rsbs	r0, r0, #0
70099cec: e3a0c001     	mov	r12, #1
70099cf0: e2e11000     	rsc	r1, r1, #0
70099cf4: e1a03002     	mov	r3, r2
70099cf8: e587c000     	str	r12, [r7]
70099cfc: e1a02006     	mov	r2, r6
70099d00: e58d4000     	str	r4, [sp]
70099d04: eb00009c     	bl	0x70099f7c <_ltostr___TI_printfi_nofloat> @ imm = #0x270
70099d08: e3a01030     	mov	r1, #48
70099d0c: e5952008     	ldr	r2, [r5, #0x8]
70099d10: e1500002     	cmp	r0, r2
70099d14: aa000005     	bge	0x70099d30 <_pproc_diouxp___TI_printfi_nofloat+0x108> @ imm = #0x14
70099d18: e5942000     	ldr	r2, [r4]
70099d1c: e2800001     	add	r0, r0, #1
70099d20: e2423001     	sub	r3, r2, #1
70099d24: e5843000     	str	r3, [r4]
70099d28: e5c21000     	strb	r1, [r2]
70099d2c: eafffff6     	b	0x70099d0c <_pproc_diouxp___TI_printfi_nofloat+0xe4> @ imm = #-0x28
70099d30: e5d5000c     	ldrb	r0, [r5, #0xc]
70099d34: e3500058     	cmp	r0, #88
70099d38: 13500078     	cmpne	r0, #120
70099d3c: 1a00000f     	bne	0x70099d80 <_pproc_diouxp___TI_printfi_nofloat+0x158> @ imm = #0x3c
70099d40: e5d51000     	ldrb	r1, [r5]
70099d44: e3110008     	tst	r1, #8
70099d48: 0a00000e     	beq	0x70099d88 <_pproc_diouxp___TI_printfi_nofloat+0x160> @ imm = #0x38
70099d4c: e5941000     	ldr	r1, [r4]
70099d50: e3500070     	cmp	r0, #112
70099d54: 03000078     	movweq	r0, #0x78
70099d58: e2412001     	sub	r2, r1, #1
70099d5c: e5842000     	str	r2, [r4]
70099d60: e3a02030     	mov	r2, #48
70099d64: e5c10000     	strb	r0, [r1]
70099d68: e5940000     	ldr	r0, [r4]
70099d6c: e2401001     	sub	r1, r0, #1
70099d70: e5841000     	str	r1, [r4]
70099d74: e5c02000     	strb	r2, [r0]
70099d78: e5d5000c     	ldrb	r0, [r5, #0xc]
70099d7c: ea000001     	b	0x70099d88 <_pproc_diouxp___TI_printfi_nofloat+0x160> @ imm = #0x4
70099d80: e3500070     	cmp	r0, #112
70099d84: 0affffed     	beq	0x70099d40 <_pproc_diouxp___TI_printfi_nofloat+0x118> @ imm = #-0x4c
70099d88: e350006f     	cmp	r0, #111
70099d8c: 1a00000a     	bne	0x70099dbc <_pproc_diouxp___TI_printfi_nofloat+0x194> @ imm = #0x28
70099d90: e5d50000     	ldrb	r0, [r5]
70099d94: e3100008     	tst	r0, #8
70099d98: 0a000007     	beq	0x70099dbc <_pproc_diouxp___TI_printfi_nofloat+0x194> @ imm = #0x1c
70099d9c: e5940000     	ldr	r0, [r4]
70099da0: e5d01001     	ldrb	r1, [r0, #0x1]
70099da4: e3510030     	cmp	r1, #48
70099da8: 08bd88fc     	popeq	{r2, r3, r4, r5, r6, r7, r11, pc}
70099dac: e2401001     	sub	r1, r0, #1
70099db0: e3a02030     	mov	r2, #48
70099db4: e5841000     	str	r1, [r4]
70099db8: e5c02000     	strb	r2, [r0]
70099dbc: e8bd88fc     	pop	{r2, r3, r4, r5, r6, r7, r11, pc}

70099dc0 <_getarg_diouxp___TI_printfi_nofloat>:
70099dc0: e92d4800     	push	{r11, lr}
70099dc4: e5d0200c     	ldrb	r2, [r0, #0xc]
70099dc8: e3520070     	cmp	r2, #112
70099dcc: 1a000002     	bne	0x70099ddc <_getarg_diouxp___TI_printfi_nofloat+0x1c> @ imm = #0x8
70099dd0: e5910000     	ldr	r0, [r1]
70099dd4: e3a03000     	mov	r3, #0
70099dd8: ea000037     	b	0x70099ebc <_getarg_diouxp___TI_printfi_nofloat+0xfc> @ imm = #0xdc
70099ddc: e5900000     	ldr	r0, [r0]
70099de0: e3033f60     	movw	r3, #0x3f60
70099de4: e0000003     	and	r0, r0, r3
70099de8: e3500a02     	cmp	r0, #8192
70099dec: 13500040     	cmpne	r0, #64
70099df0: 1a000011     	bne	0x70099e3c <_getarg_diouxp___TI_printfi_nofloat+0x7c> @ imm = #0x44
70099df4: e3a03000     	mov	r3, #0
70099df8: e242e064     	sub	lr, r2, #100
70099dfc: e35e0014     	cmp	lr, #20
70099e00: 8a00002a     	bhi	0x70099eb0 <_getarg_diouxp___TI_printfi_nofloat+0xf0> @ imm = #0xa8
70099e04: e3000800     	movw	r0, #0x800
70099e08: e3a0c001     	mov	r12, #1
70099e0c: e3400012     	movt	r0, #0x12
70099e10: e1100e1c     	tst	r0, r12, lsl lr
70099e14: 1a000027     	bne	0x70099eb8 <_getarg_diouxp___TI_printfi_nofloat+0xf8> @ imm = #0x9c
70099e18: e3a00021     	mov	r0, #33
70099e1c: e1100e1c     	tst	r0, r12, lsl lr
70099e20: 0a000022     	beq	0x70099eb0 <_getarg_diouxp___TI_printfi_nofloat+0xf0> @ imm = #0x88
70099e24: e5910000     	ldr	r0, [r1]
70099e28: e2802004     	add	r2, r0, #4
70099e2c: e5812000     	str	r2, [r1]
70099e30: e5900000     	ldr	r0, [r0]
70099e34: e1a03fc0     	asr	r3, r0, #31
70099e38: ea000022     	b	0x70099ec8 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #0x88
70099e3c: e3500c01     	cmp	r0, #256
70099e40: 0a000022     	beq	0x70099ed0 <_getarg_diouxp___TI_printfi_nofloat+0x110> @ imm = #0x88
70099e44: e3500c02     	cmp	r0, #512
70099e48: 0a000036     	beq	0x70099f28 <_getarg_diouxp___TI_printfi_nofloat+0x168> @ imm = #0xd8
70099e4c: e3500b02     	cmp	r0, #2048
70099e50: 0a00001e     	beq	0x70099ed0 <_getarg_diouxp___TI_printfi_nofloat+0x110> @ imm = #0x78
70099e54: e3a03000     	mov	r3, #0
70099e58: e242e064     	sub	lr, r2, #100
70099e5c: e3500a01     	cmp	r0, #4096
70099e60: 0affffe5     	beq	0x70099dfc <_getarg_diouxp___TI_printfi_nofloat+0x3c> @ imm = #-0x6c
70099e64: e3500020     	cmp	r0, #32
70099e68: 1affffe3     	bne	0x70099dfc <_getarg_diouxp___TI_printfi_nofloat+0x3c> @ imm = #-0x74
70099e6c: e35e0014     	cmp	lr, #20
70099e70: 8a000007     	bhi	0x70099e94 <_getarg_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x1c
70099e74: e3000800     	movw	r0, #0x800
70099e78: e3a0c001     	mov	r12, #1
70099e7c: e3400012     	movt	r0, #0x12
70099e80: e1100e1c     	tst	r0, r12, lsl lr
70099e84: 1a000004     	bne	0x70099e9c <_getarg_diouxp___TI_printfi_nofloat+0xdc> @ imm = #0x10
70099e88: e3a00021     	mov	r0, #33
70099e8c: e1100e1c     	tst	r0, r12, lsl lr
70099e90: 1affffe3     	bne	0x70099e24 <_getarg_diouxp___TI_printfi_nofloat+0x64> @ imm = #-0x74
70099e94: e3520058     	cmp	r2, #88
70099e98: 1a000035     	bne	0x70099f74 <_getarg_diouxp___TI_printfi_nofloat+0x1b4> @ imm = #0xd4
70099e9c: e5910000     	ldr	r0, [r1]
70099ea0: e2802004     	add	r2, r0, #4
70099ea4: e5812000     	str	r2, [r1]
70099ea8: e1d000b0     	ldrh	r0, [r0]
70099eac: ea000005     	b	0x70099ec8 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #0x14
70099eb0: e3520058     	cmp	r2, #88
70099eb4: 1a00002e     	bne	0x70099f74 <_getarg_diouxp___TI_printfi_nofloat+0x1b4> @ imm = #0xb8
70099eb8: e5910000     	ldr	r0, [r1]
70099ebc: e2802004     	add	r2, r0, #4
70099ec0: e5812000     	str	r2, [r1]
70099ec4: e5900000     	ldr	r0, [r0]
70099ec8: e1a01003     	mov	r1, r3
70099ecc: e8bd8800     	pop	{r11, pc}
70099ed0: e2420064     	sub	r0, r2, #100
70099ed4: e3500014     	cmp	r0, #20
70099ed8: 8a000007     	bhi	0x70099efc <_getarg_diouxp___TI_printfi_nofloat+0x13c> @ imm = #0x1c
70099edc: e3003800     	movw	r3, #0x800
70099ee0: e3a0c001     	mov	r12, #1
70099ee4: e3403012     	movt	r3, #0x12
70099ee8: e113001c     	tst	r3, r12, lsl r0
70099eec: 1a000006     	bne	0x70099f0c <_getarg_diouxp___TI_printfi_nofloat+0x14c> @ imm = #0x18
70099ef0: e3a03021     	mov	r3, #33
70099ef4: e113001c     	tst	r3, r12, lsl r0
70099ef8: 1a000003     	bne	0x70099f0c <_getarg_diouxp___TI_printfi_nofloat+0x14c> @ imm = #0xc
70099efc: e3a00000     	mov	r0, #0
70099f00: e3a03000     	mov	r3, #0
70099f04: e3520058     	cmp	r2, #88
70099f08: 1affffee     	bne	0x70099ec8 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0x48
70099f0c: e5910000     	ldr	r0, [r1]
70099f10: e2800007     	add	r0, r0, #7
70099f14: e3c00007     	bic	r0, r0, #7
70099f18: e2802008     	add	r2, r0, #8
70099f1c: e5812000     	str	r2, [r1]
70099f20: e8900009     	ldm	r0, {r0, r3}
70099f24: eaffffe7     	b	0x70099ec8 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0x64
70099f28: e3a03000     	mov	r3, #0
70099f2c: e242e064     	sub	lr, r2, #100
70099f30: e35e0014     	cmp	lr, #20
70099f34: 8a000007     	bhi	0x70099f58 <_getarg_diouxp___TI_printfi_nofloat+0x198> @ imm = #0x1c
70099f38: e3000800     	movw	r0, #0x800
70099f3c: e3a0c001     	mov	r12, #1
70099f40: e3400012     	movt	r0, #0x12
70099f44: e1100e1c     	tst	r0, r12, lsl lr
70099f48: 1a000004     	bne	0x70099f60 <_getarg_diouxp___TI_printfi_nofloat+0x1a0> @ imm = #0x10
70099f4c: e3a00021     	mov	r0, #33
70099f50: e1100e1c     	tst	r0, r12, lsl lr
70099f54: 1affffb2     	bne	0x70099e24 <_getarg_diouxp___TI_printfi_nofloat+0x64> @ imm = #-0x138
70099f58: e3520058     	cmp	r2, #88
70099f5c: 1a000004     	bne	0x70099f74 <_getarg_diouxp___TI_printfi_nofloat+0x1b4> @ imm = #0x10
70099f60: e5910000     	ldr	r0, [r1]
70099f64: e2802004     	add	r2, r0, #4
70099f68: e5812000     	str	r2, [r1]
70099f6c: e5d00000     	ldrb	r0, [r0]
70099f70: eaffffd4     	b	0x70099ec8 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0xb0
70099f74: e3a00000     	mov	r0, #0
70099f78: eaffffd2     	b	0x70099ec8 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0xb8

70099f7c <_ltostr___TI_printfi_nofloat>:
70099f7c: e92d41f0     	push	{r4, r5, r6, r7, r8, lr}
70099f80: e59fc074     	ldr	r12, [pc, #0x74]        @ 0x70099ffc <_ltostr___TI_printfi_nofloat+0x80>
70099f84: e1a04002     	mov	r4, r2
70099f88: e59f6070     	ldr	r6, [pc, #0x70]         @ 0x7009a000 <_ltostr___TI_printfi_nofloat+0x84>
70099f8c: e1a05000     	mov	r5, r0
70099f90: e59d8018     	ldr	r8, [sp, #0x18]
70099f94: e3530058     	cmp	r3, #88
70099f98: 01a0600c     	moveq	r6, r12
70099f9c: e1900001     	orrs	r0, r0, r1
70099fa0: 1a00000f     	bne	0x70099fe4 <_ltostr___TI_printfi_nofloat+0x68> @ imm = #0x3c
70099fa4: e5980000     	ldr	r0, [r8]
70099fa8: e3a03030     	mov	r3, #48
70099fac: e2402001     	sub	r2, r0, #1
70099fb0: e5882000     	str	r2, [r8]
70099fb4: e5c03000     	strb	r3, [r0]
70099fb8: ea000009     	b	0x70099fe4 <_ltostr___TI_printfi_nofloat+0x68> @ imm = #0x24
70099fbc: e1a00005     	mov	r0, r5
70099fc0: e1a02004     	mov	r2, r4
70099fc4: eb00000e     	bl	0x7009a004 <_div___TI_printfi_nofloat> @ imm = #0x38
70099fc8: e0625490     	mls	r2, r0, r4, r5
70099fcc: e5983000     	ldr	r3, [r8]
70099fd0: e1a05000     	mov	r5, r0
70099fd4: e2437001     	sub	r7, r3, #1
70099fd8: e7d62002     	ldrb	r2, [r6, r2]
70099fdc: e5887000     	str	r7, [r8]
70099fe0: e5c32000     	strb	r2, [r3]
70099fe4: e1950001     	orrs	r0, r5, r1
70099fe8: 1afffff3     	bne	0x70099fbc <_ltostr___TI_printfi_nofloat+0x40> @ imm = #-0x34
70099fec: e5980000     	ldr	r0, [r8]
70099ff0: eb0054b5     	bl	0x700af2cc <strlen>     @ imm = #0x152d4
70099ff4: e2400001     	sub	r0, r0, #1
70099ff8: e8bd81f0     	pop	{r4, r5, r6, r7, r8, pc}
70099ffc: 1f 1d 0b 70  	.word	0x700b1d1f
7009a000: 30 1d 0b 70  	.word	0x700b1d30

7009a004 <_div___TI_printfi_nofloat>:
7009a004: e92d4800     	push	{r11, lr}
7009a008: e3520010     	cmp	r2, #16
7009a00c: 0a000005     	beq	0x7009a028 <_div___TI_printfi_nofloat+0x24> @ imm = #0x14
7009a010: e3520008     	cmp	r2, #8
7009a014: 1a000007     	bne	0x7009a038 <_div___TI_printfi_nofloat+0x34> @ imm = #0x1c
7009a018: e1a001a0     	lsr	r0, r0, #3
7009a01c: e1800e81     	orr	r0, r0, r1, lsl #29
7009a020: e1a011a1     	lsr	r1, r1, #3
7009a024: e8bd8800     	pop	{r11, pc}
7009a028: e1a00220     	lsr	r0, r0, #4
7009a02c: e1800e01     	orr	r0, r0, r1, lsl #28
7009a030: e1a01221     	lsr	r1, r1, #4
7009a034: e8bd8800     	pop	{r11, pc}
7009a038: e3510000     	cmp	r1, #0
7009a03c: 1a000003     	bne	0x7009a050 <_div___TI_printfi_nofloat+0x4c> @ imm = #0xc
7009a040: e1a01002     	mov	r1, r2
7009a044: eb00151f     	bl	0x7009f4c8 <__udivsi3>  @ imm = #0x547c
7009a048: e3a01000     	mov	r1, #0
7009a04c: e8bd8800     	pop	{r11, pc}
7009a050: e3a03000     	mov	r3, #0
7009a054: eb0053b6     	bl	0x700aef34 <__aeabi_uldivmod> @ imm = #0x14ed8
7009a058: e8bd8800     	pop	{r11, pc}

7009a05c <__aeabi_memcpy8>:
7009a05c: ea0054aa     	b	0x700af30c <TI_memcpy_small> @ imm = #0x152a8

7009a060 <_vsnprintf>:
; {
7009a060: e92d 43f0    	push.w	{r4, r5, r6, r7, r8, r9, lr}
7009a064: b0c1         	sub	sp, #0x104
7009a066: f8dd c120    	ldr.w	r12, [sp, #0x120]
7009a06a: f8cd c100    	str.w	r12, [sp, #0x100]
7009a06e: 903f         	str	r0, [sp, #0xfc]
7009a070: 913e         	str	r1, [sp, #0xf8]
7009a072: 923d         	str	r2, [sp, #0xf4]
7009a074: 933c         	str	r3, [sp, #0xf0]
7009a076: 2000         	movs	r0, #0x0
;   size_t idx = 0U;
7009a078: 9037         	str	r0, [sp, #0xdc]
;   if (!buffer) {
7009a07a: 983e         	ldr	r0, [sp, #0xf8]
7009a07c: b930         	cbnz	r0, 0x7009a08c <_vsnprintf+0x2c> @ imm = #0xc
7009a07e: e7ff         	b	0x7009a080 <_vsnprintf+0x20> @ imm = #-0x2
;     out = _out_null;
7009a080: f64f 00a1    	movw	r0, #0xf8a1
7009a084: f2c7 000a    	movt	r0, #0x700a
7009a088: 903f         	str	r0, [sp, #0xfc]
;   }
7009a08a: e7ff         	b	0x7009a08c <_vsnprintf+0x2c> @ imm = #-0x2
;   while (*format)
7009a08c: e7ff         	b	0x7009a08e <_vsnprintf+0x2e> @ imm = #-0x2
7009a08e: 983c         	ldr	r0, [sp, #0xf0]
7009a090: 7800         	ldrb	r0, [r0]
7009a092: 2800         	cmp	r0, #0x0
7009a094: f000 84e3    	beq.w	0x7009aa5e <_vsnprintf+0x9fe> @ imm = #0x9c6
7009a098: e7ff         	b	0x7009a09a <_vsnprintf+0x3a> @ imm = #-0x2
;     if (*format != '%') {
7009a09a: 983c         	ldr	r0, [sp, #0xf0]
7009a09c: 7800         	ldrb	r0, [r0]
7009a09e: 2825         	cmp	r0, #0x25
7009a0a0: d00e         	beq	0x7009a0c0 <_vsnprintf+0x60> @ imm = #0x1c
7009a0a2: e7ff         	b	0x7009a0a4 <_vsnprintf+0x44> @ imm = #-0x2
;       out(*format, buffer, idx++, maxlen);
7009a0a4: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a0a8: 983c         	ldr	r0, [sp, #0xf0]
7009a0aa: 7800         	ldrb	r0, [r0]
7009a0ac: 993e         	ldr	r1, [sp, #0xf8]
7009a0ae: 9a37         	ldr	r2, [sp, #0xdc]
7009a0b0: 1c53         	adds	r3, r2, #0x1
7009a0b2: 9337         	str	r3, [sp, #0xdc]
7009a0b4: 9b3d         	ldr	r3, [sp, #0xf4]
7009a0b6: 47e0         	blx	r12
;       format++;
7009a0b8: 983c         	ldr	r0, [sp, #0xf0]
7009a0ba: 3001         	adds	r0, #0x1
7009a0bc: 903c         	str	r0, [sp, #0xf0]
;       continue;
7009a0be: e7e6         	b	0x7009a08e <_vsnprintf+0x2e> @ imm = #-0x34
;       format++;
7009a0c0: 983c         	ldr	r0, [sp, #0xf0]
7009a0c2: 3001         	adds	r0, #0x1
7009a0c4: 903c         	str	r0, [sp, #0xf0]
7009a0c6: e7ff         	b	0x7009a0c8 <_vsnprintf+0x68> @ imm = #-0x2
7009a0c8: 2000         	movs	r0, #0x0
;     flags = 0U;
7009a0ca: 903b         	str	r0, [sp, #0xec]
;     do {
7009a0cc: e7ff         	b	0x7009a0ce <_vsnprintf+0x6e> @ imm = #-0x2
;       switch (*format) {
7009a0ce: 983c         	ldr	r0, [sp, #0xf0]
7009a0d0: 7800         	ldrb	r0, [r0]
7009a0d2: 3820         	subs	r0, #0x20
7009a0d4: 4601         	mov	r1, r0
7009a0d6: 912a         	str	r1, [sp, #0xa8]
7009a0d8: 2810         	cmp	r0, #0x10
7009a0da: d83d         	bhi	0x7009a158 <_vsnprintf+0xf8> @ imm = #0x7a
7009a0dc: 992a         	ldr	r1, [sp, #0xa8]
7009a0de: e8df f001    	tbb	[pc, r1]
7009a0e2: 27 3b 3b 31  	.word	0x313b3b27
7009a0e6: 3b 3b 3b 3b  	.word	0x3b3b3b3b
7009a0ea: 3b 3b 3b 1d  	.word	0x1d3b3b3b
7009a0ee: 3b 13 3b 3b  	.word	0x3b3b133b
7009a0f2: 09 00        	.short	0x0009
;         case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
7009a0f4: 983b         	ldr	r0, [sp, #0xec]
7009a0f6: f040 0001    	orr	r0, r0, #0x1
7009a0fa: 903b         	str	r0, [sp, #0xec]
7009a0fc: 983c         	ldr	r0, [sp, #0xf0]
7009a0fe: 3001         	adds	r0, #0x1
7009a100: 903c         	str	r0, [sp, #0xf0]
7009a102: 2001         	movs	r0, #0x1
7009a104: 9038         	str	r0, [sp, #0xe0]
7009a106: e02a         	b	0x7009a15e <_vsnprintf+0xfe> @ imm = #0x54
;         case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
7009a108: 983b         	ldr	r0, [sp, #0xec]
7009a10a: f040 0002    	orr	r0, r0, #0x2
7009a10e: 903b         	str	r0, [sp, #0xec]
7009a110: 983c         	ldr	r0, [sp, #0xf0]
7009a112: 3001         	adds	r0, #0x1
7009a114: 903c         	str	r0, [sp, #0xf0]
7009a116: 2001         	movs	r0, #0x1
7009a118: 9038         	str	r0, [sp, #0xe0]
7009a11a: e020         	b	0x7009a15e <_vsnprintf+0xfe> @ imm = #0x40
;         case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
7009a11c: 983b         	ldr	r0, [sp, #0xec]
7009a11e: f040 0004    	orr	r0, r0, #0x4
7009a122: 903b         	str	r0, [sp, #0xec]
7009a124: 983c         	ldr	r0, [sp, #0xf0]
7009a126: 3001         	adds	r0, #0x1
7009a128: 903c         	str	r0, [sp, #0xf0]
7009a12a: 2001         	movs	r0, #0x1
7009a12c: 9038         	str	r0, [sp, #0xe0]
7009a12e: e016         	b	0x7009a15e <_vsnprintf+0xfe> @ imm = #0x2c
;         case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
7009a130: 983b         	ldr	r0, [sp, #0xec]
7009a132: f040 0008    	orr	r0, r0, #0x8
7009a136: 903b         	str	r0, [sp, #0xec]
7009a138: 983c         	ldr	r0, [sp, #0xf0]
7009a13a: 3001         	adds	r0, #0x1
7009a13c: 903c         	str	r0, [sp, #0xf0]
7009a13e: 2001         	movs	r0, #0x1
7009a140: 9038         	str	r0, [sp, #0xe0]
7009a142: e00c         	b	0x7009a15e <_vsnprintf+0xfe> @ imm = #0x18
;         case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
7009a144: 983b         	ldr	r0, [sp, #0xec]
7009a146: f040 0010    	orr	r0, r0, #0x10
7009a14a: 903b         	str	r0, [sp, #0xec]
7009a14c: 983c         	ldr	r0, [sp, #0xf0]
7009a14e: 3001         	adds	r0, #0x1
7009a150: 903c         	str	r0, [sp, #0xf0]
7009a152: 2001         	movs	r0, #0x1
7009a154: 9038         	str	r0, [sp, #0xe0]
7009a156: e002         	b	0x7009a15e <_vsnprintf+0xfe> @ imm = #0x4
7009a158: 2000         	movs	r0, #0x0
;         default :                                   n = 0U; break;
7009a15a: 9038         	str	r0, [sp, #0xe0]
7009a15c: e7ff         	b	0x7009a15e <_vsnprintf+0xfe> @ imm = #-0x2
;     } while (n);
7009a15e: e7ff         	b	0x7009a160 <_vsnprintf+0x100> @ imm = #-0x2
7009a160: 9838         	ldr	r0, [sp, #0xe0]
7009a162: 2800         	cmp	r0, #0x0
7009a164: d1b3         	bne	0x7009a0ce <_vsnprintf+0x6e> @ imm = #-0x9a
7009a166: e7ff         	b	0x7009a168 <_vsnprintf+0x108> @ imm = #-0x2
7009a168: 2000         	movs	r0, #0x0
;     width = 0U;
7009a16a: 903a         	str	r0, [sp, #0xe8]
;     if (_is_digit(*format)) {
7009a16c: 983c         	ldr	r0, [sp, #0xf0]
7009a16e: 7800         	ldrb	r0, [r0]
7009a170: f014 fade    	bl	0x700ae730 <_is_digit>  @ imm = #0x145bc
7009a174: b128         	cbz	r0, 0x7009a182 <_vsnprintf+0x122> @ imm = #0xa
7009a176: e7ff         	b	0x7009a178 <_vsnprintf+0x118> @ imm = #-0x2
7009a178: a83c         	add	r0, sp, #0xf0
;       width = _atoi(&format);
7009a17a: f013 fef1    	bl	0x700adf60 <_atoi>      @ imm = #0x13de2
7009a17e: 903a         	str	r0, [sp, #0xe8]
;     }
7009a180: e01e         	b	0x7009a1c0 <_vsnprintf+0x160> @ imm = #0x3c
;     else if (*format == '*') {
7009a182: 983c         	ldr	r0, [sp, #0xf0]
7009a184: 7800         	ldrb	r0, [r0]
7009a186: 282a         	cmp	r0, #0x2a
7009a188: d119         	bne	0x7009a1be <_vsnprintf+0x15e> @ imm = #0x32
7009a18a: e7ff         	b	0x7009a18c <_vsnprintf+0x12c> @ imm = #-0x2
;       const int w = va_arg(va, int);
7009a18c: 9840         	ldr	r0, [sp, #0x100]
7009a18e: 1d01         	adds	r1, r0, #0x4
7009a190: 9140         	str	r1, [sp, #0x100]
7009a192: 6800         	ldr	r0, [r0]
7009a194: 9036         	str	r0, [sp, #0xd8]
;       if (w < 0) {
7009a196: 9836         	ldr	r0, [sp, #0xd8]
7009a198: f1b0 3fff    	cmp.w	r0, #0xffffffff
7009a19c: dc08         	bgt	0x7009a1b0 <_vsnprintf+0x150> @ imm = #0x10
7009a19e: e7ff         	b	0x7009a1a0 <_vsnprintf+0x140> @ imm = #-0x2
;         flags |= FLAGS_LEFT;    // reverse padding
7009a1a0: 983b         	ldr	r0, [sp, #0xec]
7009a1a2: f040 0002    	orr	r0, r0, #0x2
7009a1a6: 903b         	str	r0, [sp, #0xec]
;         width = (unsigned int)-w;
7009a1a8: 9836         	ldr	r0, [sp, #0xd8]
7009a1aa: 4240         	rsbs	r0, r0, #0
7009a1ac: 903a         	str	r0, [sp, #0xe8]
;       }
7009a1ae: e002         	b	0x7009a1b6 <_vsnprintf+0x156> @ imm = #0x4
;         width = (unsigned int)w;
7009a1b0: 9836         	ldr	r0, [sp, #0xd8]
7009a1b2: 903a         	str	r0, [sp, #0xe8]
7009a1b4: e7ff         	b	0x7009a1b6 <_vsnprintf+0x156> @ imm = #-0x2
;       format++;
7009a1b6: 983c         	ldr	r0, [sp, #0xf0]
7009a1b8: 3001         	adds	r0, #0x1
7009a1ba: 903c         	str	r0, [sp, #0xf0]
;     }
7009a1bc: e7ff         	b	0x7009a1be <_vsnprintf+0x15e> @ imm = #-0x2
7009a1be: e7ff         	b	0x7009a1c0 <_vsnprintf+0x160> @ imm = #-0x2
7009a1c0: 2000         	movs	r0, #0x0
;     precision = 0U;
7009a1c2: 9039         	str	r0, [sp, #0xe4]
;     if (*format == '.') {
7009a1c4: 983c         	ldr	r0, [sp, #0xf0]
7009a1c6: 7800         	ldrb	r0, [r0]
7009a1c8: 282e         	cmp	r0, #0x2e
7009a1ca: d12e         	bne	0x7009a22a <_vsnprintf+0x1ca> @ imm = #0x5c
7009a1cc: e7ff         	b	0x7009a1ce <_vsnprintf+0x16e> @ imm = #-0x2
;       flags |= FLAGS_PRECISION;
7009a1ce: 983b         	ldr	r0, [sp, #0xec]
7009a1d0: f440 6080    	orr	r0, r0, #0x400
7009a1d4: 903b         	str	r0, [sp, #0xec]
;       format++;
7009a1d6: 983c         	ldr	r0, [sp, #0xf0]
7009a1d8: 3001         	adds	r0, #0x1
7009a1da: 903c         	str	r0, [sp, #0xf0]
;       if (_is_digit(*format)) {
7009a1dc: 983c         	ldr	r0, [sp, #0xf0]
7009a1de: 7800         	ldrb	r0, [r0]
7009a1e0: f014 faa6    	bl	0x700ae730 <_is_digit>  @ imm = #0x1454c
7009a1e4: b128         	cbz	r0, 0x7009a1f2 <_vsnprintf+0x192> @ imm = #0xa
7009a1e6: e7ff         	b	0x7009a1e8 <_vsnprintf+0x188> @ imm = #-0x2
7009a1e8: a83c         	add	r0, sp, #0xf0
;         precision = _atoi(&format);
7009a1ea: f013 feb9    	bl	0x700adf60 <_atoi>      @ imm = #0x13d72
7009a1ee: 9039         	str	r0, [sp, #0xe4]
;       }
7009a1f0: e01a         	b	0x7009a228 <_vsnprintf+0x1c8> @ imm = #0x34
;       else if (*format == '*') {
7009a1f2: 983c         	ldr	r0, [sp, #0xf0]
7009a1f4: 7800         	ldrb	r0, [r0]
7009a1f6: 282a         	cmp	r0, #0x2a
7009a1f8: d115         	bne	0x7009a226 <_vsnprintf+0x1c6> @ imm = #0x2a
7009a1fa: e7ff         	b	0x7009a1fc <_vsnprintf+0x19c> @ imm = #-0x2
;         const int prec = (int)va_arg(va, int);
7009a1fc: 9840         	ldr	r0, [sp, #0x100]
7009a1fe: 1d01         	adds	r1, r0, #0x4
7009a200: 9140         	str	r1, [sp, #0x100]
7009a202: 6800         	ldr	r0, [r0]
7009a204: 9035         	str	r0, [sp, #0xd4]
;         precision = prec > 0 ? (unsigned int)prec : 0U;
7009a206: 9835         	ldr	r0, [sp, #0xd4]
7009a208: 2801         	cmp	r0, #0x1
7009a20a: db03         	blt	0x7009a214 <_vsnprintf+0x1b4> @ imm = #0x6
7009a20c: e7ff         	b	0x7009a20e <_vsnprintf+0x1ae> @ imm = #-0x2
7009a20e: 9835         	ldr	r0, [sp, #0xd4]
7009a210: 9029         	str	r0, [sp, #0xa4]
7009a212: e002         	b	0x7009a21a <_vsnprintf+0x1ba> @ imm = #0x4
7009a214: 2000         	movs	r0, #0x0
;         precision = prec > 0 ? (unsigned int)prec : 0U;
7009a216: 9029         	str	r0, [sp, #0xa4]
7009a218: e7ff         	b	0x7009a21a <_vsnprintf+0x1ba> @ imm = #-0x2
7009a21a: 9829         	ldr	r0, [sp, #0xa4]
7009a21c: 9039         	str	r0, [sp, #0xe4]
;         format++;
7009a21e: 983c         	ldr	r0, [sp, #0xf0]
7009a220: 3001         	adds	r0, #0x1
7009a222: 903c         	str	r0, [sp, #0xf0]
;       }
7009a224: e7ff         	b	0x7009a226 <_vsnprintf+0x1c6> @ imm = #-0x2
7009a226: e7ff         	b	0x7009a228 <_vsnprintf+0x1c8> @ imm = #-0x2
;     }
7009a228: e7ff         	b	0x7009a22a <_vsnprintf+0x1ca> @ imm = #-0x2
;     switch (*format) {
7009a22a: 983c         	ldr	r0, [sp, #0xf0]
7009a22c: 7800         	ldrb	r0, [r0]
7009a22e: 3868         	subs	r0, #0x68
7009a230: 4601         	mov	r1, r0
7009a232: 9128         	str	r1, [sp, #0xa0]
7009a234: 2812         	cmp	r0, #0x12
7009a236: d84e         	bhi	0x7009a2d6 <_vsnprintf+0x276> @ imm = #0x9c
7009a238: 9928         	ldr	r1, [sp, #0xa0]
7009a23a: e8df f001    	tbb	[pc, r1]
7009a23e: 1f 4c 3c 4c  	.word	0x4c3c4c1f
7009a242: 0a 4c 4c 4c  	.word	0x4c4c4c0a
7009a246: 4c 4c 4c 4c  	.word	0x4c4c4c4c
7009a24a: 34 4c 4c 4c  	.word	0x4c4c4c34
7009a24e: 4c 4c 44 00  	.word	0x00444c4c
;         flags |= FLAGS_LONG;
7009a252: 983b         	ldr	r0, [sp, #0xec]
7009a254: f440 7080    	orr	r0, r0, #0x100
7009a258: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a25a: 983c         	ldr	r0, [sp, #0xf0]
7009a25c: 3001         	adds	r0, #0x1
7009a25e: 903c         	str	r0, [sp, #0xf0]
;         if (*format == 'l') {
7009a260: 983c         	ldr	r0, [sp, #0xf0]
7009a262: 7800         	ldrb	r0, [r0]
7009a264: 286c         	cmp	r0, #0x6c
7009a266: d108         	bne	0x7009a27a <_vsnprintf+0x21a> @ imm = #0x10
7009a268: e7ff         	b	0x7009a26a <_vsnprintf+0x20a> @ imm = #-0x2
;           flags |= FLAGS_LONG_LONG;
7009a26a: 983b         	ldr	r0, [sp, #0xec]
7009a26c: f440 7000    	orr	r0, r0, #0x200
7009a270: 903b         	str	r0, [sp, #0xec]
;           format++;
7009a272: 983c         	ldr	r0, [sp, #0xf0]
7009a274: 3001         	adds	r0, #0x1
7009a276: 903c         	str	r0, [sp, #0xf0]
;         }
7009a278: e7ff         	b	0x7009a27a <_vsnprintf+0x21a> @ imm = #-0x2
;         break;
7009a27a: e02d         	b	0x7009a2d8 <_vsnprintf+0x278> @ imm = #0x5a
;         flags |= FLAGS_SHORT;
7009a27c: 983b         	ldr	r0, [sp, #0xec]
7009a27e: f040 0080    	orr	r0, r0, #0x80
7009a282: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a284: 983c         	ldr	r0, [sp, #0xf0]
7009a286: 3001         	adds	r0, #0x1
7009a288: 903c         	str	r0, [sp, #0xf0]
;         if (*format == 'h') {
7009a28a: 983c         	ldr	r0, [sp, #0xf0]
7009a28c: 7800         	ldrb	r0, [r0]
7009a28e: 2868         	cmp	r0, #0x68
7009a290: d108         	bne	0x7009a2a4 <_vsnprintf+0x244> @ imm = #0x10
7009a292: e7ff         	b	0x7009a294 <_vsnprintf+0x234> @ imm = #-0x2
;           flags |= FLAGS_CHAR;
7009a294: 983b         	ldr	r0, [sp, #0xec]
7009a296: f040 0040    	orr	r0, r0, #0x40
7009a29a: 903b         	str	r0, [sp, #0xec]
;           format++;
7009a29c: 983c         	ldr	r0, [sp, #0xf0]
7009a29e: 3001         	adds	r0, #0x1
7009a2a0: 903c         	str	r0, [sp, #0xf0]
;         }
7009a2a2: e7ff         	b	0x7009a2a4 <_vsnprintf+0x244> @ imm = #-0x2
;         break;
7009a2a4: e018         	b	0x7009a2d8 <_vsnprintf+0x278> @ imm = #0x30
;         flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
7009a2a6: 983b         	ldr	r0, [sp, #0xec]
7009a2a8: f440 7080    	orr	r0, r0, #0x100
7009a2ac: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a2ae: 983c         	ldr	r0, [sp, #0xf0]
7009a2b0: 3001         	adds	r0, #0x1
7009a2b2: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a2b4: e010         	b	0x7009a2d8 <_vsnprintf+0x278> @ imm = #0x20
;         flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
7009a2b6: 983b         	ldr	r0, [sp, #0xec]
7009a2b8: f440 7000    	orr	r0, r0, #0x200
7009a2bc: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a2be: 983c         	ldr	r0, [sp, #0xf0]
7009a2c0: 3001         	adds	r0, #0x1
7009a2c2: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a2c4: e008         	b	0x7009a2d8 <_vsnprintf+0x278> @ imm = #0x10
;         flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
7009a2c6: 983b         	ldr	r0, [sp, #0xec]
7009a2c8: f440 7080    	orr	r0, r0, #0x100
7009a2cc: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a2ce: 983c         	ldr	r0, [sp, #0xf0]
7009a2d0: 3001         	adds	r0, #0x1
7009a2d2: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a2d4: e000         	b	0x7009a2d8 <_vsnprintf+0x278> @ imm = #0x0
;         break;
7009a2d6: e7ff         	b	0x7009a2d8 <_vsnprintf+0x278> @ imm = #-0x2
;     switch (*format) {
7009a2d8: 983c         	ldr	r0, [sp, #0xf0]
7009a2da: 7800         	ldrb	r0, [r0]
7009a2dc: 3825         	subs	r0, #0x25
7009a2de: 4601         	mov	r1, r0
7009a2e0: 9127         	str	r1, [sp, #0x9c]
7009a2e2: 2853         	cmp	r0, #0x53
7009a2e4: f200 83ab    	bhi.w	0x7009aa3e <_vsnprintf+0x9de> @ imm = #0x756
7009a2e8: 9927         	ldr	r1, [sp, #0x9c]
7009a2ea: e8df f011    	tbh	[pc, r1, lsl #1]
7009a2ee: 9b 03 a8 03  	.word	0x03a8039b
7009a2f2: a8 03 a8 03  	.word	0x03a803a8
7009a2f6: a8 03 a8 03  	.word	0x03a803a8
7009a2fa: a8 03 a8 03  	.word	0x03a803a8
7009a2fe: a8 03 a8 03  	.word	0x03a803a8
7009a302: a8 03 a8 03  	.word	0x03a803a8
7009a306: a8 03 a8 03  	.word	0x03a803a8
7009a30a: a8 03 a8 03  	.word	0x03a803a8
7009a30e: a8 03 a8 03  	.word	0x03a803a8
7009a312: a8 03 a8 03  	.word	0x03a803a8
7009a316: a8 03 a8 03  	.word	0x03a803a8
7009a31a: a8 03 a8 03  	.word	0x03a803a8
7009a31e: a8 03 a8 03  	.word	0x03a803a8
7009a322: a8 03 a8 03  	.word	0x03a803a8
7009a326: a8 03 a8 03  	.word	0x03a803a8
7009a32a: a8 03 a8 03  	.word	0x03a803a8
7009a32e: 5e 02 32 02  	.word	0x0232025e
7009a332: 5e 02 a8 03  	.word	0x03a8025e
7009a336: a8 03 a8 03  	.word	0x03a803a8
7009a33a: a8 03 a8 03  	.word	0x03a803a8
7009a33e: a8 03 a8 03  	.word	0x03a803a8
7009a342: a8 03 a8 03  	.word	0x03a803a8
7009a346: a8 03 a8 03  	.word	0x03a803a8
7009a34a: a8 03 a8 03  	.word	0x03a803a8
7009a34e: a8 03 a8 03  	.word	0x03a803a8
7009a352: a8 03 54 00  	.word	0x005403a8
7009a356: a8 03 a8 03  	.word	0x03a803a8
7009a35a: a8 03 a8 03  	.word	0x03a803a8
7009a35e: a8 03 a8 03  	.word	0x03a803a8
7009a362: a8 03 a8 03  	.word	0x03a803a8
7009a366: a8 03 54 00  	.word	0x005403a8
7009a36a: 9e 02 54 00  	.word	0x0054029e
7009a36e: 5e 02 32 02  	.word	0x0232025e
7009a372: 5e 02 a8 03  	.word	0x03a8025e
7009a376: 54 00 a8 03  	.word	0x03a80054
7009a37a: a8 03 a8 03  	.word	0x03a803a8
7009a37e: a8 03 a8 03  	.word	0x03a803a8
7009a382: 54 00 6e 03  	.word	0x036e0054
7009a386: a8 03 a8 03  	.word	0x03a803a8
7009a38a: e2 02 a8 03  	.word	0x03a802e2
7009a38e: 54 00 a8 03  	.word	0x03a80054
7009a392: a8 03 54 00  	.word	0x005403a8
;         if (*format == 'x' || *format == 'X') {
7009a396: 983c         	ldr	r0, [sp, #0xf0]
7009a398: 7800         	ldrb	r0, [r0]
7009a39a: 2878         	cmp	r0, #0x78
7009a39c: d005         	beq	0x7009a3aa <_vsnprintf+0x34a> @ imm = #0xa
7009a39e: e7ff         	b	0x7009a3a0 <_vsnprintf+0x340> @ imm = #-0x2
7009a3a0: 983c         	ldr	r0, [sp, #0xf0]
7009a3a2: 7800         	ldrb	r0, [r0]
7009a3a4: 2858         	cmp	r0, #0x58
7009a3a6: d103         	bne	0x7009a3b0 <_vsnprintf+0x350> @ imm = #0x6
7009a3a8: e7ff         	b	0x7009a3aa <_vsnprintf+0x34a> @ imm = #-0x2
7009a3aa: 2010         	movs	r0, #0x10
;           base = 16U;
7009a3ac: 9034         	str	r0, [sp, #0xd0]
;         }
7009a3ae: e018         	b	0x7009a3e2 <_vsnprintf+0x382> @ imm = #0x30
;         else if (*format == 'o') {
7009a3b0: 983c         	ldr	r0, [sp, #0xf0]
7009a3b2: 7800         	ldrb	r0, [r0]
7009a3b4: 286f         	cmp	r0, #0x6f
7009a3b6: d103         	bne	0x7009a3c0 <_vsnprintf+0x360> @ imm = #0x6
7009a3b8: e7ff         	b	0x7009a3ba <_vsnprintf+0x35a> @ imm = #-0x2
7009a3ba: 2008         	movs	r0, #0x8
;           base =  8U;
7009a3bc: 9034         	str	r0, [sp, #0xd0]
;         }
7009a3be: e00f         	b	0x7009a3e0 <_vsnprintf+0x380> @ imm = #0x1e
;         else if (*format == 'b') {
7009a3c0: 983c         	ldr	r0, [sp, #0xf0]
7009a3c2: 7800         	ldrb	r0, [r0]
7009a3c4: 2862         	cmp	r0, #0x62
7009a3c6: d103         	bne	0x7009a3d0 <_vsnprintf+0x370> @ imm = #0x6
7009a3c8: e7ff         	b	0x7009a3ca <_vsnprintf+0x36a> @ imm = #-0x2
7009a3ca: 2002         	movs	r0, #0x2
;           base =  2U;
7009a3cc: 9034         	str	r0, [sp, #0xd0]
;         }
7009a3ce: e006         	b	0x7009a3de <_vsnprintf+0x37e> @ imm = #0xc
7009a3d0: 200a         	movs	r0, #0xa
;           base = 10U;
7009a3d2: 9034         	str	r0, [sp, #0xd0]
;           flags &= ~FLAGS_HASH;   // no hash for dec format
7009a3d4: 983b         	ldr	r0, [sp, #0xec]
7009a3d6: f020 0010    	bic	r0, r0, #0x10
7009a3da: 903b         	str	r0, [sp, #0xec]
7009a3dc: e7ff         	b	0x7009a3de <_vsnprintf+0x37e> @ imm = #-0x2
7009a3de: e7ff         	b	0x7009a3e0 <_vsnprintf+0x380> @ imm = #-0x2
7009a3e0: e7ff         	b	0x7009a3e2 <_vsnprintf+0x382> @ imm = #-0x2
;         if (*format == 'X') {
7009a3e2: 983c         	ldr	r0, [sp, #0xf0]
7009a3e4: 7800         	ldrb	r0, [r0]
7009a3e6: 2858         	cmp	r0, #0x58
7009a3e8: d105         	bne	0x7009a3f6 <_vsnprintf+0x396> @ imm = #0xa
7009a3ea: e7ff         	b	0x7009a3ec <_vsnprintf+0x38c> @ imm = #-0x2
;           flags |= FLAGS_UPPERCASE;
7009a3ec: 983b         	ldr	r0, [sp, #0xec]
7009a3ee: f040 0020    	orr	r0, r0, #0x20
7009a3f2: 903b         	str	r0, [sp, #0xec]
;         }
7009a3f4: e7ff         	b	0x7009a3f6 <_vsnprintf+0x396> @ imm = #-0x2
;         if ((*format != 'i') && (*format != 'd')) {
7009a3f6: 983c         	ldr	r0, [sp, #0xf0]
7009a3f8: 7800         	ldrb	r0, [r0]
7009a3fa: 2869         	cmp	r0, #0x69
7009a3fc: d00a         	beq	0x7009a414 <_vsnprintf+0x3b4> @ imm = #0x14
7009a3fe: e7ff         	b	0x7009a400 <_vsnprintf+0x3a0> @ imm = #-0x2
7009a400: 983c         	ldr	r0, [sp, #0xf0]
7009a402: 7800         	ldrb	r0, [r0]
7009a404: 2864         	cmp	r0, #0x64
7009a406: d005         	beq	0x7009a414 <_vsnprintf+0x3b4> @ imm = #0xa
7009a408: e7ff         	b	0x7009a40a <_vsnprintf+0x3aa> @ imm = #-0x2
;           flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
7009a40a: 983b         	ldr	r0, [sp, #0xec]
7009a40c: f020 000c    	bic	r0, r0, #0xc
7009a410: 903b         	str	r0, [sp, #0xec]
;         }
7009a412: e7ff         	b	0x7009a414 <_vsnprintf+0x3b4> @ imm = #-0x2
;         if (flags & FLAGS_PRECISION) {
7009a414: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a418: 0740         	lsls	r0, r0, #0x1d
7009a41a: 2800         	cmp	r0, #0x0
7009a41c: d505         	bpl	0x7009a42a <_vsnprintf+0x3ca> @ imm = #0xa
7009a41e: e7ff         	b	0x7009a420 <_vsnprintf+0x3c0> @ imm = #-0x2
;           flags &= ~FLAGS_ZEROPAD;
7009a420: 983b         	ldr	r0, [sp, #0xec]
7009a422: f020 0001    	bic	r0, r0, #0x1
7009a426: 903b         	str	r0, [sp, #0xec]
;         }
7009a428: e7ff         	b	0x7009a42a <_vsnprintf+0x3ca> @ imm = #-0x2
;         if ((*format == 'i') || (*format == 'd')) {
7009a42a: 983c         	ldr	r0, [sp, #0xf0]
7009a42c: 7800         	ldrb	r0, [r0]
7009a42e: 2869         	cmp	r0, #0x69
7009a430: d006         	beq	0x7009a440 <_vsnprintf+0x3e0> @ imm = #0xc
7009a432: e7ff         	b	0x7009a434 <_vsnprintf+0x3d4> @ imm = #-0x2
7009a434: 983c         	ldr	r0, [sp, #0xf0]
7009a436: 7800         	ldrb	r0, [r0]
7009a438: 2864         	cmp	r0, #0x64
7009a43a: f040 80e9    	bne.w	0x7009a610 <_vsnprintf+0x5b0> @ imm = #0x1d2
7009a43e: e7ff         	b	0x7009a440 <_vsnprintf+0x3e0> @ imm = #-0x2
;           if (flags & FLAGS_LONG_LONG) {
7009a440: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a444: 0780         	lsls	r0, r0, #0x1e
7009a446: 2800         	cmp	r0, #0x0
7009a448: d550         	bpl	0x7009a4ec <_vsnprintf+0x48c> @ imm = #0xa0
7009a44a: e7ff         	b	0x7009a44c <_vsnprintf+0x3ec> @ imm = #-0x2
;             const long long value = va_arg(va, long long);
7009a44c: 9840         	ldr	r0, [sp, #0x100]
7009a44e: 3007         	adds	r0, #0x7
7009a450: f020 0107    	bic	r1, r0, #0x7
7009a454: f101 0008    	add.w	r0, r1, #0x8
7009a458: 9040         	str	r0, [sp, #0x100]
7009a45a: 6808         	ldr	r0, [r1]
7009a45c: 6849         	ldr	r1, [r1, #0x4]
7009a45e: 9133         	str	r1, [sp, #0xcc]
7009a460: 9032         	str	r0, [sp, #0xc8]
;             idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009a462: 983f         	ldr	r0, [sp, #0xfc]
7009a464: 9023         	str	r0, [sp, #0x8c]
7009a466: 983e         	ldr	r0, [sp, #0xf8]
7009a468: 9024         	str	r0, [sp, #0x90]
7009a46a: 9837         	ldr	r0, [sp, #0xdc]
7009a46c: 9025         	str	r0, [sp, #0x94]
7009a46e: 983d         	ldr	r0, [sp, #0xf4]
7009a470: 9026         	str	r0, [sp, #0x98]
7009a472: 9932         	ldr	r1, [sp, #0xc8]
7009a474: 9833         	ldr	r0, [sp, #0xcc]
7009a476: 3901         	subs	r1, #0x1
7009a478: f170 0000    	sbcs	r0, r0, #0x0
7009a47c: db05         	blt	0x7009a48a <_vsnprintf+0x42a> @ imm = #0xa
7009a47e: e7ff         	b	0x7009a480 <_vsnprintf+0x420> @ imm = #-0x2
7009a480: 9932         	ldr	r1, [sp, #0xc8]
7009a482: 9833         	ldr	r0, [sp, #0xcc]
7009a484: 9121         	str	r1, [sp, #0x84]
7009a486: 9022         	str	r0, [sp, #0x88]
7009a488: e008         	b	0x7009a49c <_vsnprintf+0x43c> @ imm = #0x10
7009a48a: 9832         	ldr	r0, [sp, #0xc8]
7009a48c: 9a33         	ldr	r2, [sp, #0xcc]
7009a48e: 4241         	rsbs	r1, r0, #0
7009a490: f04f 0000    	mov.w	r0, #0x0
7009a494: 4190         	sbcs	r0, r2
7009a496: 9121         	str	r1, [sp, #0x84]
7009a498: 9022         	str	r0, [sp, #0x88]
7009a49a: e7ff         	b	0x7009a49c <_vsnprintf+0x43c> @ imm = #-0x2
7009a49c: 9b26         	ldr	r3, [sp, #0x98]
7009a49e: 9a25         	ldr	r2, [sp, #0x94]
7009a4a0: 9924         	ldr	r1, [sp, #0x90]
7009a4a2: 9823         	ldr	r0, [sp, #0x8c]
7009a4a4: f8dd c084    	ldr.w	r12, [sp, #0x84]
7009a4a8: 9c22         	ldr	r4, [sp, #0x88]
7009a4aa: 9d33         	ldr	r5, [sp, #0xcc]
7009a4ac: 9e34         	ldr	r6, [sp, #0xd0]
7009a4ae: 9f39         	ldr	r7, [sp, #0xe4]
7009a4b0: f8dd 80e8    	ldr.w	r8, [sp, #0xe8]
7009a4b4: f8dd 90ec    	ldr.w	r9, [sp, #0xec]
7009a4b8: 46ee         	mov	lr, sp
7009a4ba: f8cd e080    	str.w	lr, [sp, #0x80]
7009a4be: f8ce 9020    	str.w	r9, [lr, #0x20]
7009a4c2: f8ce 801c    	str.w	r8, [lr, #0x1c]
7009a4c6: f8ce 7018    	str.w	r7, [lr, #0x18]
7009a4ca: 2700         	movs	r7, #0x0
7009a4cc: f8ce 7014    	str.w	r7, [lr, #0x14]
7009a4d0: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a4d4: ea4f 75d5    	lsr.w	r5, r5, #0x1f
7009a4d8: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a4dc: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a4e0: f8ce c000    	str.w	r12, [lr]
7009a4e4: f008 faf4    	bl	0x700a2ad0 <_ntoa_long_long> @ imm = #0x85e8
7009a4e8: 9037         	str	r0, [sp, #0xdc]
;           }
7009a4ea: e090         	b	0x7009a60e <_vsnprintf+0x5ae> @ imm = #0x120
;           else if (flags & FLAGS_LONG) {
7009a4ec: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a4f0: 07c0         	lsls	r0, r0, #0x1f
7009a4f2: b3b0         	cbz	r0, 0x7009a562 <_vsnprintf+0x502> @ imm = #0x6c
7009a4f4: e7ff         	b	0x7009a4f6 <_vsnprintf+0x496> @ imm = #-0x2
;             const long value = va_arg(va, long);
7009a4f6: 9840         	ldr	r0, [sp, #0x100]
7009a4f8: 1d01         	adds	r1, r0, #0x4
7009a4fa: 9140         	str	r1, [sp, #0x100]
7009a4fc: 6800         	ldr	r0, [r0]
7009a4fe: 9031         	str	r0, [sp, #0xc4]
;             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009a500: 983f         	ldr	r0, [sp, #0xfc]
7009a502: 901c         	str	r0, [sp, #0x70]
7009a504: 983e         	ldr	r0, [sp, #0xf8]
7009a506: 901d         	str	r0, [sp, #0x74]
7009a508: 9837         	ldr	r0, [sp, #0xdc]
7009a50a: 901e         	str	r0, [sp, #0x78]
7009a50c: 983d         	ldr	r0, [sp, #0xf4]
7009a50e: 901f         	str	r0, [sp, #0x7c]
7009a510: 9831         	ldr	r0, [sp, #0xc4]
7009a512: 2801         	cmp	r0, #0x1
7009a514: db03         	blt	0x7009a51e <_vsnprintf+0x4be> @ imm = #0x6
7009a516: e7ff         	b	0x7009a518 <_vsnprintf+0x4b8> @ imm = #-0x2
7009a518: 9831         	ldr	r0, [sp, #0xc4]
7009a51a: 901b         	str	r0, [sp, #0x6c]
7009a51c: e003         	b	0x7009a526 <_vsnprintf+0x4c6> @ imm = #0x6
7009a51e: 9831         	ldr	r0, [sp, #0xc4]
7009a520: 4240         	rsbs	r0, r0, #0
7009a522: 901b         	str	r0, [sp, #0x6c]
7009a524: e7ff         	b	0x7009a526 <_vsnprintf+0x4c6> @ imm = #-0x2
7009a526: 9b1f         	ldr	r3, [sp, #0x7c]
7009a528: 9a1e         	ldr	r2, [sp, #0x78]
7009a52a: 991d         	ldr	r1, [sp, #0x74]
7009a52c: 981c         	ldr	r0, [sp, #0x70]
7009a52e: f8dd c06c    	ldr.w	r12, [sp, #0x6c]
7009a532: 9c31         	ldr	r4, [sp, #0xc4]
7009a534: 9d34         	ldr	r5, [sp, #0xd0]
7009a536: 9e39         	ldr	r6, [sp, #0xe4]
7009a538: 9f3a         	ldr	r7, [sp, #0xe8]
7009a53a: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
7009a53e: 46ee         	mov	lr, sp
7009a540: f8ce 8014    	str.w	r8, [lr, #0x14]
7009a544: f8ce 7010    	str.w	r7, [lr, #0x10]
7009a548: f8ce 600c    	str.w	r6, [lr, #0xc]
7009a54c: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a550: 0fe4         	lsrs	r4, r4, #0x1f
7009a552: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a556: f8ce c000    	str.w	r12, [lr]
7009a55a: f00a fa91    	bl	0x700a4a80 <_ntoa_long> @ imm = #0xa522
7009a55e: 9037         	str	r0, [sp, #0xdc]
;           }
7009a560: e054         	b	0x7009a60c <_vsnprintf+0x5ac> @ imm = #0xa8
;             const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
7009a562: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a566: 0640         	lsls	r0, r0, #0x19
7009a568: 2800         	cmp	r0, #0x0
7009a56a: d506         	bpl	0x7009a57a <_vsnprintf+0x51a> @ imm = #0xc
7009a56c: e7ff         	b	0x7009a56e <_vsnprintf+0x50e> @ imm = #-0x2
7009a56e: 9840         	ldr	r0, [sp, #0x100]
7009a570: 1d01         	adds	r1, r0, #0x4
7009a572: 9140         	str	r1, [sp, #0x100]
7009a574: 7800         	ldrb	r0, [r0]
7009a576: 901a         	str	r0, [sp, #0x68]
7009a578: e015         	b	0x7009a5a6 <_vsnprintf+0x546> @ imm = #0x2a
7009a57a: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a57e: 0600         	lsls	r0, r0, #0x18
7009a580: 2800         	cmp	r0, #0x0
7009a582: d507         	bpl	0x7009a594 <_vsnprintf+0x534> @ imm = #0xe
7009a584: e7ff         	b	0x7009a586 <_vsnprintf+0x526> @ imm = #-0x2
7009a586: 9840         	ldr	r0, [sp, #0x100]
7009a588: 1d01         	adds	r1, r0, #0x4
7009a58a: 9140         	str	r1, [sp, #0x100]
7009a58c: f9b0 0000    	ldrsh.w	r0, [r0]
7009a590: 9019         	str	r0, [sp, #0x64]
7009a592: e005         	b	0x7009a5a0 <_vsnprintf+0x540> @ imm = #0xa
7009a594: 9840         	ldr	r0, [sp, #0x100]
7009a596: 1d01         	adds	r1, r0, #0x4
7009a598: 9140         	str	r1, [sp, #0x100]
7009a59a: 6800         	ldr	r0, [r0]
7009a59c: 9019         	str	r0, [sp, #0x64]
7009a59e: e7ff         	b	0x7009a5a0 <_vsnprintf+0x540> @ imm = #-0x2
7009a5a0: 9819         	ldr	r0, [sp, #0x64]
7009a5a2: 901a         	str	r0, [sp, #0x68]
7009a5a4: e7ff         	b	0x7009a5a6 <_vsnprintf+0x546> @ imm = #-0x2
7009a5a6: 981a         	ldr	r0, [sp, #0x68]
7009a5a8: 9030         	str	r0, [sp, #0xc0]
;             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009a5aa: 983f         	ldr	r0, [sp, #0xfc]
7009a5ac: 9015         	str	r0, [sp, #0x54]
7009a5ae: 983e         	ldr	r0, [sp, #0xf8]
7009a5b0: 9016         	str	r0, [sp, #0x58]
7009a5b2: 9837         	ldr	r0, [sp, #0xdc]
7009a5b4: 9017         	str	r0, [sp, #0x5c]
7009a5b6: 983d         	ldr	r0, [sp, #0xf4]
7009a5b8: 9018         	str	r0, [sp, #0x60]
7009a5ba: 9830         	ldr	r0, [sp, #0xc0]
7009a5bc: 2801         	cmp	r0, #0x1
7009a5be: db03         	blt	0x7009a5c8 <_vsnprintf+0x568> @ imm = #0x6
7009a5c0: e7ff         	b	0x7009a5c2 <_vsnprintf+0x562> @ imm = #-0x2
7009a5c2: 9830         	ldr	r0, [sp, #0xc0]
7009a5c4: 9014         	str	r0, [sp, #0x50]
7009a5c6: e003         	b	0x7009a5d0 <_vsnprintf+0x570> @ imm = #0x6
7009a5c8: 9830         	ldr	r0, [sp, #0xc0]
7009a5ca: 4240         	rsbs	r0, r0, #0
7009a5cc: 9014         	str	r0, [sp, #0x50]
7009a5ce: e7ff         	b	0x7009a5d0 <_vsnprintf+0x570> @ imm = #-0x2
7009a5d0: 9b18         	ldr	r3, [sp, #0x60]
7009a5d2: 9a17         	ldr	r2, [sp, #0x5c]
7009a5d4: 9916         	ldr	r1, [sp, #0x58]
7009a5d6: 9815         	ldr	r0, [sp, #0x54]
7009a5d8: f8dd c050    	ldr.w	r12, [sp, #0x50]
7009a5dc: 9c30         	ldr	r4, [sp, #0xc0]
7009a5de: 9d34         	ldr	r5, [sp, #0xd0]
7009a5e0: 9e39         	ldr	r6, [sp, #0xe4]
7009a5e2: 9f3a         	ldr	r7, [sp, #0xe8]
7009a5e4: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
7009a5e8: 46ee         	mov	lr, sp
7009a5ea: f8ce 8014    	str.w	r8, [lr, #0x14]
7009a5ee: f8ce 7010    	str.w	r7, [lr, #0x10]
7009a5f2: f8ce 600c    	str.w	r6, [lr, #0xc]
7009a5f6: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a5fa: 0fe4         	lsrs	r4, r4, #0x1f
7009a5fc: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a600: f8ce c000    	str.w	r12, [lr]
7009a604: f00a fa3c    	bl	0x700a4a80 <_ntoa_long> @ imm = #0xa478
7009a608: 9037         	str	r0, [sp, #0xdc]
7009a60a: e7ff         	b	0x7009a60c <_vsnprintf+0x5ac> @ imm = #-0x2
7009a60c: e7ff         	b	0x7009a60e <_vsnprintf+0x5ae> @ imm = #-0x2
;         }
7009a60e: e09c         	b	0x7009a74a <_vsnprintf+0x6ea> @ imm = #0x138
;           if (flags & FLAGS_LONG_LONG) {
7009a610: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a614: 0780         	lsls	r0, r0, #0x1e
7009a616: 2800         	cmp	r0, #0x0
7009a618: d52f         	bpl	0x7009a67a <_vsnprintf+0x61a> @ imm = #0x5e
7009a61a: e7ff         	b	0x7009a61c <_vsnprintf+0x5bc> @ imm = #-0x2
;             idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
7009a61c: 983f         	ldr	r0, [sp, #0xfc]
7009a61e: 993e         	ldr	r1, [sp, #0xf8]
7009a620: 9a37         	ldr	r2, [sp, #0xdc]
7009a622: 9b3d         	ldr	r3, [sp, #0xf4]
7009a624: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a628: f10c 0c07    	add.w	r12, r12, #0x7
7009a62c: f02c 0e07    	bic	lr, r12, #0x7
7009a630: f10e 0c08    	add.w	r12, lr, #0x8
7009a634: f8cd c100    	str.w	r12, [sp, #0x100]
7009a638: f8de c000    	ldr.w	r12, [lr]
7009a63c: f8de 4004    	ldr.w	r4, [lr, #0x4]
7009a640: 9e34         	ldr	r6, [sp, #0xd0]
7009a642: 9d39         	ldr	r5, [sp, #0xe4]
7009a644: 9f3a         	ldr	r7, [sp, #0xe8]
7009a646: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
7009a64a: 46ee         	mov	lr, sp
7009a64c: f8cd e04c    	str.w	lr, [sp, #0x4c]
7009a650: f8ce 8020    	str.w	r8, [lr, #0x20]
7009a654: f8ce 701c    	str.w	r7, [lr, #0x1c]
7009a658: f8ce 5018    	str.w	r5, [lr, #0x18]
7009a65c: 2500         	movs	r5, #0x0
7009a65e: f8ce 5014    	str.w	r5, [lr, #0x14]
7009a662: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a666: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a66a: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a66e: f8ce c000    	str.w	r12, [lr]
7009a672: f008 fa2d    	bl	0x700a2ad0 <_ntoa_long_long> @ imm = #0x845a
7009a676: 9037         	str	r0, [sp, #0xdc]
;           }
7009a678: e066         	b	0x7009a748 <_vsnprintf+0x6e8> @ imm = #0xcc
;           else if (flags & FLAGS_LONG) {
7009a67a: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a67e: 07c0         	lsls	r0, r0, #0x1f
7009a680: b310         	cbz	r0, 0x7009a6c8 <_vsnprintf+0x668> @ imm = #0x44
7009a682: e7ff         	b	0x7009a684 <_vsnprintf+0x624> @ imm = #-0x2
;             idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
7009a684: 983f         	ldr	r0, [sp, #0xfc]
7009a686: 993e         	ldr	r1, [sp, #0xf8]
7009a688: 9a37         	ldr	r2, [sp, #0xdc]
7009a68a: 9b3d         	ldr	r3, [sp, #0xf4]
7009a68c: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a690: f10c 0e04    	add.w	lr, r12, #0x4
7009a694: f8cd e100    	str.w	lr, [sp, #0x100]
7009a698: f8dc c000    	ldr.w	r12, [r12]
7009a69c: 9c34         	ldr	r4, [sp, #0xd0]
7009a69e: 9d39         	ldr	r5, [sp, #0xe4]
7009a6a0: 9e3a         	ldr	r6, [sp, #0xe8]
7009a6a2: 9f3b         	ldr	r7, [sp, #0xec]
7009a6a4: 46ee         	mov	lr, sp
7009a6a6: f8ce 7014    	str.w	r7, [lr, #0x14]
7009a6aa: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a6ae: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a6b2: f8ce 4008    	str.w	r4, [lr, #0x8]
7009a6b6: 2400         	movs	r4, #0x0
7009a6b8: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a6bc: f8ce c000    	str.w	r12, [lr]
7009a6c0: f00a f9de    	bl	0x700a4a80 <_ntoa_long> @ imm = #0xa3bc
7009a6c4: 9037         	str	r0, [sp, #0xdc]
;           }
7009a6c6: e03e         	b	0x7009a746 <_vsnprintf+0x6e6> @ imm = #0x7c
;             const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
7009a6c8: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a6cc: 0640         	lsls	r0, r0, #0x19
7009a6ce: 2800         	cmp	r0, #0x0
7009a6d0: d506         	bpl	0x7009a6e0 <_vsnprintf+0x680> @ imm = #0xc
7009a6d2: e7ff         	b	0x7009a6d4 <_vsnprintf+0x674> @ imm = #-0x2
7009a6d4: 9840         	ldr	r0, [sp, #0x100]
7009a6d6: 1d01         	adds	r1, r0, #0x4
7009a6d8: 9140         	str	r1, [sp, #0x100]
7009a6da: 7800         	ldrb	r0, [r0]
7009a6dc: 9012         	str	r0, [sp, #0x48]
7009a6de: e014         	b	0x7009a70a <_vsnprintf+0x6aa> @ imm = #0x28
7009a6e0: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a6e4: 0600         	lsls	r0, r0, #0x18
7009a6e6: 2800         	cmp	r0, #0x0
7009a6e8: d506         	bpl	0x7009a6f8 <_vsnprintf+0x698> @ imm = #0xc
7009a6ea: e7ff         	b	0x7009a6ec <_vsnprintf+0x68c> @ imm = #-0x2
7009a6ec: 9840         	ldr	r0, [sp, #0x100]
7009a6ee: 1d01         	adds	r1, r0, #0x4
7009a6f0: 9140         	str	r1, [sp, #0x100]
7009a6f2: 8800         	ldrh	r0, [r0]
7009a6f4: 9011         	str	r0, [sp, #0x44]
7009a6f6: e005         	b	0x7009a704 <_vsnprintf+0x6a4> @ imm = #0xa
7009a6f8: 9840         	ldr	r0, [sp, #0x100]
7009a6fa: 1d01         	adds	r1, r0, #0x4
7009a6fc: 9140         	str	r1, [sp, #0x100]
7009a6fe: 6800         	ldr	r0, [r0]
7009a700: 9011         	str	r0, [sp, #0x44]
7009a702: e7ff         	b	0x7009a704 <_vsnprintf+0x6a4> @ imm = #-0x2
7009a704: 9811         	ldr	r0, [sp, #0x44]
7009a706: 9012         	str	r0, [sp, #0x48]
7009a708: e7ff         	b	0x7009a70a <_vsnprintf+0x6aa> @ imm = #-0x2
7009a70a: 9812         	ldr	r0, [sp, #0x48]
7009a70c: 902f         	str	r0, [sp, #0xbc]
;             idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
7009a70e: 983f         	ldr	r0, [sp, #0xfc]
7009a710: 993e         	ldr	r1, [sp, #0xf8]
7009a712: 9a37         	ldr	r2, [sp, #0xdc]
7009a714: 9b3d         	ldr	r3, [sp, #0xf4]
7009a716: f8dd c0bc    	ldr.w	r12, [sp, #0xbc]
7009a71a: 9c34         	ldr	r4, [sp, #0xd0]
7009a71c: 9d39         	ldr	r5, [sp, #0xe4]
7009a71e: 9e3a         	ldr	r6, [sp, #0xe8]
7009a720: 9f3b         	ldr	r7, [sp, #0xec]
7009a722: 46ee         	mov	lr, sp
7009a724: f8ce 7014    	str.w	r7, [lr, #0x14]
7009a728: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a72c: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a730: f8ce 4008    	str.w	r4, [lr, #0x8]
7009a734: 2400         	movs	r4, #0x0
7009a736: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a73a: f8ce c000    	str.w	r12, [lr]
7009a73e: f00a f99f    	bl	0x700a4a80 <_ntoa_long> @ imm = #0xa33e
7009a742: 9037         	str	r0, [sp, #0xdc]
7009a744: e7ff         	b	0x7009a746 <_vsnprintf+0x6e6> @ imm = #-0x2
7009a746: e7ff         	b	0x7009a748 <_vsnprintf+0x6e8> @ imm = #-0x2
7009a748: e7ff         	b	0x7009a74a <_vsnprintf+0x6ea> @ imm = #-0x2
;         format++;
7009a74a: 983c         	ldr	r0, [sp, #0xf0]
7009a74c: 3001         	adds	r0, #0x1
7009a74e: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a750: e183         	b	0x7009aa5a <_vsnprintf+0x9fa> @ imm = #0x306
;         if (*format == 'F') flags |= FLAGS_UPPERCASE;
7009a752: 983c         	ldr	r0, [sp, #0xf0]
7009a754: 7800         	ldrb	r0, [r0]
7009a756: 2846         	cmp	r0, #0x46
7009a758: d105         	bne	0x7009a766 <_vsnprintf+0x706> @ imm = #0xa
7009a75a: e7ff         	b	0x7009a75c <_vsnprintf+0x6fc> @ imm = #-0x2
7009a75c: 983b         	ldr	r0, [sp, #0xec]
7009a75e: f040 0020    	orr	r0, r0, #0x20
7009a762: 903b         	str	r0, [sp, #0xec]
7009a764: e7ff         	b	0x7009a766 <_vsnprintf+0x706> @ imm = #-0x2
;         idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
7009a766: 983f         	ldr	r0, [sp, #0xfc]
7009a768: 993e         	ldr	r1, [sp, #0xf8]
7009a76a: 9a37         	ldr	r2, [sp, #0xdc]
7009a76c: 9b3d         	ldr	r3, [sp, #0xf4]
7009a76e: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a772: f10c 0c07    	add.w	r12, r12, #0x7
7009a776: f02c 0c07    	bic	r12, r12, #0x7
7009a77a: f10c 0e08    	add.w	lr, r12, #0x8
7009a77e: f8cd e100    	str.w	lr, [sp, #0x100]
7009a782: ed9c 0b00    	vldr	d0, [r12]
7009a786: f8dd c0e4    	ldr.w	r12, [sp, #0xe4]
7009a78a: 9c3a         	ldr	r4, [sp, #0xe8]
7009a78c: 9d3b         	ldr	r5, [sp, #0xec]
7009a78e: 46ee         	mov	lr, sp
7009a790: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a794: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a798: f8ce c000    	str.w	r12, [lr]
7009a79c: f000 fc80    	bl	0x7009b0a0 <_ftoa>      @ imm = #0x900
7009a7a0: 9037         	str	r0, [sp, #0xdc]
;         format++;
7009a7a2: 983c         	ldr	r0, [sp, #0xf0]
7009a7a4: 3001         	adds	r0, #0x1
7009a7a6: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a7a8: e157         	b	0x7009aa5a <_vsnprintf+0x9fa> @ imm = #0x2ae
;         if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
7009a7aa: 983c         	ldr	r0, [sp, #0xf0]
7009a7ac: 7800         	ldrb	r0, [r0]
7009a7ae: 2867         	cmp	r0, #0x67
7009a7b0: d005         	beq	0x7009a7be <_vsnprintf+0x75e> @ imm = #0xa
7009a7b2: e7ff         	b	0x7009a7b4 <_vsnprintf+0x754> @ imm = #-0x2
7009a7b4: 983c         	ldr	r0, [sp, #0xf0]
7009a7b6: 7800         	ldrb	r0, [r0]
7009a7b8: 2847         	cmp	r0, #0x47
7009a7ba: d105         	bne	0x7009a7c8 <_vsnprintf+0x768> @ imm = #0xa
7009a7bc: e7ff         	b	0x7009a7be <_vsnprintf+0x75e> @ imm = #-0x2
7009a7be: 983b         	ldr	r0, [sp, #0xec]
7009a7c0: f440 6000    	orr	r0, r0, #0x800
7009a7c4: 903b         	str	r0, [sp, #0xec]
7009a7c6: e7ff         	b	0x7009a7c8 <_vsnprintf+0x768> @ imm = #-0x2
;         if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
7009a7c8: 983c         	ldr	r0, [sp, #0xf0]
7009a7ca: 7800         	ldrb	r0, [r0]
7009a7cc: 2845         	cmp	r0, #0x45
7009a7ce: d005         	beq	0x7009a7dc <_vsnprintf+0x77c> @ imm = #0xa
7009a7d0: e7ff         	b	0x7009a7d2 <_vsnprintf+0x772> @ imm = #-0x2
7009a7d2: 983c         	ldr	r0, [sp, #0xf0]
7009a7d4: 7800         	ldrb	r0, [r0]
7009a7d6: 2847         	cmp	r0, #0x47
7009a7d8: d105         	bne	0x7009a7e6 <_vsnprintf+0x786> @ imm = #0xa
7009a7da: e7ff         	b	0x7009a7dc <_vsnprintf+0x77c> @ imm = #-0x2
7009a7dc: 983b         	ldr	r0, [sp, #0xec]
7009a7de: f040 0020    	orr	r0, r0, #0x20
7009a7e2: 903b         	str	r0, [sp, #0xec]
7009a7e4: e7ff         	b	0x7009a7e6 <_vsnprintf+0x786> @ imm = #-0x2
;         idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
7009a7e6: 983f         	ldr	r0, [sp, #0xfc]
7009a7e8: 993e         	ldr	r1, [sp, #0xf8]
7009a7ea: 9a37         	ldr	r2, [sp, #0xdc]
7009a7ec: 9b3d         	ldr	r3, [sp, #0xf4]
7009a7ee: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a7f2: f10c 0c07    	add.w	r12, r12, #0x7
7009a7f6: f02c 0c07    	bic	r12, r12, #0x7
7009a7fa: f10c 0e08    	add.w	lr, r12, #0x8
7009a7fe: f8cd e100    	str.w	lr, [sp, #0x100]
7009a802: ed9c 0b00    	vldr	d0, [r12]
7009a806: f8dd c0e4    	ldr.w	r12, [sp, #0xe4]
7009a80a: 9c3a         	ldr	r4, [sp, #0xe8]
7009a80c: 9d3b         	ldr	r5, [sp, #0xec]
7009a80e: 46ee         	mov	lr, sp
7009a810: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a814: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a818: f8ce c000    	str.w	r12, [lr]
7009a81c: f000 fed0    	bl	0x7009b5c0 <_etoa>      @ imm = #0xda0
7009a820: 9037         	str	r0, [sp, #0xdc]
;         format++;
7009a822: 983c         	ldr	r0, [sp, #0xf0]
7009a824: 3001         	adds	r0, #0x1
7009a826: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a828: e117         	b	0x7009aa5a <_vsnprintf+0x9fa> @ imm = #0x22e
7009a82a: 2001         	movs	r0, #0x1
;         unsigned int l = 1U;
7009a82c: 902e         	str	r0, [sp, #0xb8]
;         if (!(flags & FLAGS_LEFT)) {
7009a82e: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a832: 0780         	lsls	r0, r0, #0x1e
7009a834: 2800         	cmp	r0, #0x0
7009a836: d413         	bmi	0x7009a860 <_vsnprintf+0x800> @ imm = #0x26
7009a838: e7ff         	b	0x7009a83a <_vsnprintf+0x7da> @ imm = #-0x2
;           while (l++ < width) {
7009a83a: e7ff         	b	0x7009a83c <_vsnprintf+0x7dc> @ imm = #-0x2
7009a83c: 982e         	ldr	r0, [sp, #0xb8]
7009a83e: 1c41         	adds	r1, r0, #0x1
7009a840: 912e         	str	r1, [sp, #0xb8]
7009a842: 993a         	ldr	r1, [sp, #0xe8]
7009a844: 4288         	cmp	r0, r1
7009a846: d20a         	bhs	0x7009a85e <_vsnprintf+0x7fe> @ imm = #0x14
7009a848: e7ff         	b	0x7009a84a <_vsnprintf+0x7ea> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009a84a: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a84e: 993e         	ldr	r1, [sp, #0xf8]
7009a850: 9a37         	ldr	r2, [sp, #0xdc]
7009a852: 1c50         	adds	r0, r2, #0x1
7009a854: 9037         	str	r0, [sp, #0xdc]
7009a856: 9b3d         	ldr	r3, [sp, #0xf4]
7009a858: 2020         	movs	r0, #0x20
7009a85a: 47e0         	blx	r12
;           while (l++ < width) {
7009a85c: e7ee         	b	0x7009a83c <_vsnprintf+0x7dc> @ imm = #-0x24
;         }
7009a85e: e7ff         	b	0x7009a860 <_vsnprintf+0x800> @ imm = #-0x2
;         out((char)va_arg(va, int), buffer, idx++, maxlen);
7009a860: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a864: 9840         	ldr	r0, [sp, #0x100]
7009a866: 1d01         	adds	r1, r0, #0x4
7009a868: 9140         	str	r1, [sp, #0x100]
7009a86a: 7800         	ldrb	r0, [r0]
7009a86c: 993e         	ldr	r1, [sp, #0xf8]
7009a86e: 9a37         	ldr	r2, [sp, #0xdc]
7009a870: 1c53         	adds	r3, r2, #0x1
7009a872: 9337         	str	r3, [sp, #0xdc]
7009a874: 9b3d         	ldr	r3, [sp, #0xf4]
7009a876: 47e0         	blx	r12
;         if (flags & FLAGS_LEFT) {
7009a878: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a87c: 0780         	lsls	r0, r0, #0x1e
7009a87e: 2800         	cmp	r0, #0x0
7009a880: d513         	bpl	0x7009a8aa <_vsnprintf+0x84a> @ imm = #0x26
7009a882: e7ff         	b	0x7009a884 <_vsnprintf+0x824> @ imm = #-0x2
;           while (l++ < width) {
7009a884: e7ff         	b	0x7009a886 <_vsnprintf+0x826> @ imm = #-0x2
7009a886: 982e         	ldr	r0, [sp, #0xb8]
7009a888: 1c41         	adds	r1, r0, #0x1
7009a88a: 912e         	str	r1, [sp, #0xb8]
7009a88c: 993a         	ldr	r1, [sp, #0xe8]
7009a88e: 4288         	cmp	r0, r1
7009a890: d20a         	bhs	0x7009a8a8 <_vsnprintf+0x848> @ imm = #0x14
7009a892: e7ff         	b	0x7009a894 <_vsnprintf+0x834> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009a894: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a898: 993e         	ldr	r1, [sp, #0xf8]
7009a89a: 9a37         	ldr	r2, [sp, #0xdc]
7009a89c: 1c50         	adds	r0, r2, #0x1
7009a89e: 9037         	str	r0, [sp, #0xdc]
7009a8a0: 9b3d         	ldr	r3, [sp, #0xf4]
7009a8a2: 2020         	movs	r0, #0x20
7009a8a4: 47e0         	blx	r12
;           while (l++ < width) {
7009a8a6: e7ee         	b	0x7009a886 <_vsnprintf+0x826> @ imm = #-0x24
;         }
7009a8a8: e7ff         	b	0x7009a8aa <_vsnprintf+0x84a> @ imm = #-0x2
;         format++;
7009a8aa: 983c         	ldr	r0, [sp, #0xf0]
7009a8ac: 3001         	adds	r0, #0x1
7009a8ae: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a8b0: e0d3         	b	0x7009aa5a <_vsnprintf+0x9fa> @ imm = #0x1a6
;         const char* p = va_arg(va, char*);
7009a8b2: 9840         	ldr	r0, [sp, #0x100]
7009a8b4: 1d01         	adds	r1, r0, #0x4
7009a8b6: 9140         	str	r1, [sp, #0x100]
7009a8b8: 6800         	ldr	r0, [r0]
7009a8ba: 902d         	str	r0, [sp, #0xb4]
;         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
7009a8bc: 982d         	ldr	r0, [sp, #0xb4]
7009a8be: 9010         	str	r0, [sp, #0x40]
7009a8c0: 9839         	ldr	r0, [sp, #0xe4]
7009a8c2: b118         	cbz	r0, 0x7009a8cc <_vsnprintf+0x86c> @ imm = #0x6
7009a8c4: e7ff         	b	0x7009a8c6 <_vsnprintf+0x866> @ imm = #-0x2
7009a8c6: 9839         	ldr	r0, [sp, #0xe4]
7009a8c8: 900f         	str	r0, [sp, #0x3c]
7009a8ca: e003         	b	0x7009a8d4 <_vsnprintf+0x874> @ imm = #0x6
7009a8cc: f04f 30ff    	mov.w	r0, #0xffffffff
;         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
7009a8d0: 900f         	str	r0, [sp, #0x3c]
7009a8d2: e7ff         	b	0x7009a8d4 <_vsnprintf+0x874> @ imm = #-0x2
7009a8d4: 9810         	ldr	r0, [sp, #0x40]
7009a8d6: 990f         	ldr	r1, [sp, #0x3c]
7009a8d8: f012 ff0a    	bl	0x700ad6f0 <_strnlen_s> @ imm = #0x12e14
7009a8dc: 902c         	str	r0, [sp, #0xb0]
;         if (flags & FLAGS_PRECISION) {
7009a8de: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a8e2: 0740         	lsls	r0, r0, #0x1d
7009a8e4: 2800         	cmp	r0, #0x0
7009a8e6: d50e         	bpl	0x7009a906 <_vsnprintf+0x8a6> @ imm = #0x1c
7009a8e8: e7ff         	b	0x7009a8ea <_vsnprintf+0x88a> @ imm = #-0x2
;           l = (l < precision ? l : precision);
7009a8ea: 982c         	ldr	r0, [sp, #0xb0]
7009a8ec: 9939         	ldr	r1, [sp, #0xe4]
7009a8ee: 4288         	cmp	r0, r1
7009a8f0: d203         	bhs	0x7009a8fa <_vsnprintf+0x89a> @ imm = #0x6
7009a8f2: e7ff         	b	0x7009a8f4 <_vsnprintf+0x894> @ imm = #-0x2
7009a8f4: 982c         	ldr	r0, [sp, #0xb0]
7009a8f6: 900e         	str	r0, [sp, #0x38]
7009a8f8: e002         	b	0x7009a900 <_vsnprintf+0x8a0> @ imm = #0x4
7009a8fa: 9839         	ldr	r0, [sp, #0xe4]
7009a8fc: 900e         	str	r0, [sp, #0x38]
7009a8fe: e7ff         	b	0x7009a900 <_vsnprintf+0x8a0> @ imm = #-0x2
7009a900: 980e         	ldr	r0, [sp, #0x38]
7009a902: 902c         	str	r0, [sp, #0xb0]
;         }
7009a904: e7ff         	b	0x7009a906 <_vsnprintf+0x8a6> @ imm = #-0x2
;         if (!(flags & FLAGS_LEFT)) {
7009a906: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a90a: 0780         	lsls	r0, r0, #0x1e
7009a90c: 2800         	cmp	r0, #0x0
7009a90e: d413         	bmi	0x7009a938 <_vsnprintf+0x8d8> @ imm = #0x26
7009a910: e7ff         	b	0x7009a912 <_vsnprintf+0x8b2> @ imm = #-0x2
;           while (l++ < width) {
7009a912: e7ff         	b	0x7009a914 <_vsnprintf+0x8b4> @ imm = #-0x2
7009a914: 982c         	ldr	r0, [sp, #0xb0]
7009a916: 1c41         	adds	r1, r0, #0x1
7009a918: 912c         	str	r1, [sp, #0xb0]
7009a91a: 993a         	ldr	r1, [sp, #0xe8]
7009a91c: 4288         	cmp	r0, r1
7009a91e: d20a         	bhs	0x7009a936 <_vsnprintf+0x8d6> @ imm = #0x14
7009a920: e7ff         	b	0x7009a922 <_vsnprintf+0x8c2> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009a922: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a926: 993e         	ldr	r1, [sp, #0xf8]
7009a928: 9a37         	ldr	r2, [sp, #0xdc]
7009a92a: 1c50         	adds	r0, r2, #0x1
7009a92c: 9037         	str	r0, [sp, #0xdc]
7009a92e: 9b3d         	ldr	r3, [sp, #0xf4]
7009a930: 2020         	movs	r0, #0x20
7009a932: 47e0         	blx	r12
;           while (l++ < width) {
7009a934: e7ee         	b	0x7009a914 <_vsnprintf+0x8b4> @ imm = #-0x24
;         }
7009a936: e7ff         	b	0x7009a938 <_vsnprintf+0x8d8> @ imm = #-0x2
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009a938: e7ff         	b	0x7009a93a <_vsnprintf+0x8da> @ imm = #-0x2
7009a93a: 982d         	ldr	r0, [sp, #0xb4]
7009a93c: 7801         	ldrb	r1, [r0]
7009a93e: 2000         	movs	r0, #0x0
7009a940: 900d         	str	r0, [sp, #0x34]
7009a942: b1a1         	cbz	r1, 0x7009a96e <_vsnprintf+0x90e> @ imm = #0x28
7009a944: e7ff         	b	0x7009a946 <_vsnprintf+0x8e6> @ imm = #-0x2
7009a946: 2001         	movs	r0, #0x1
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009a948: f89d 10ed    	ldrb.w	r1, [sp, #0xed]
7009a94c: ea4f 7141    	lsl.w	r1, r1, #0x1d
7009a950: 2900         	cmp	r1, #0x0
7009a952: 900c         	str	r0, [sp, #0x30]
7009a954: d508         	bpl	0x7009a968 <_vsnprintf+0x908> @ imm = #0x10
7009a956: e7ff         	b	0x7009a958 <_vsnprintf+0x8f8> @ imm = #-0x2
7009a958: 9839         	ldr	r0, [sp, #0xe4]
7009a95a: 1e41         	subs	r1, r0, #0x1
7009a95c: 9139         	str	r1, [sp, #0xe4]
7009a95e: 2800         	cmp	r0, #0x0
7009a960: bf18         	it	ne
7009a962: 2001         	movne	r0, #0x1
7009a964: 900c         	str	r0, [sp, #0x30]
7009a966: e7ff         	b	0x7009a968 <_vsnprintf+0x908> @ imm = #-0x2
7009a968: 980c         	ldr	r0, [sp, #0x30]
7009a96a: 900d         	str	r0, [sp, #0x34]
7009a96c: e7ff         	b	0x7009a96e <_vsnprintf+0x90e> @ imm = #-0x2
7009a96e: 980d         	ldr	r0, [sp, #0x34]
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009a970: 07c0         	lsls	r0, r0, #0x1f
7009a972: b168         	cbz	r0, 0x7009a990 <_vsnprintf+0x930> @ imm = #0x1a
7009a974: e7ff         	b	0x7009a976 <_vsnprintf+0x916> @ imm = #-0x2
;           out(*(p++), buffer, idx++, maxlen);
7009a976: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a97a: 982d         	ldr	r0, [sp, #0xb4]
7009a97c: 1c41         	adds	r1, r0, #0x1
7009a97e: 912d         	str	r1, [sp, #0xb4]
7009a980: 7800         	ldrb	r0, [r0]
7009a982: 993e         	ldr	r1, [sp, #0xf8]
7009a984: 9a37         	ldr	r2, [sp, #0xdc]
7009a986: 1c53         	adds	r3, r2, #0x1
7009a988: 9337         	str	r3, [sp, #0xdc]
7009a98a: 9b3d         	ldr	r3, [sp, #0xf4]
7009a98c: 47e0         	blx	r12
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009a98e: e7d4         	b	0x7009a93a <_vsnprintf+0x8da> @ imm = #-0x58
;         if (flags & FLAGS_LEFT) {
7009a990: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a994: 0780         	lsls	r0, r0, #0x1e
7009a996: 2800         	cmp	r0, #0x0
7009a998: d513         	bpl	0x7009a9c2 <_vsnprintf+0x962> @ imm = #0x26
7009a99a: e7ff         	b	0x7009a99c <_vsnprintf+0x93c> @ imm = #-0x2
;           while (l++ < width) {
7009a99c: e7ff         	b	0x7009a99e <_vsnprintf+0x93e> @ imm = #-0x2
7009a99e: 982c         	ldr	r0, [sp, #0xb0]
7009a9a0: 1c41         	adds	r1, r0, #0x1
7009a9a2: 912c         	str	r1, [sp, #0xb0]
7009a9a4: 993a         	ldr	r1, [sp, #0xe8]
7009a9a6: 4288         	cmp	r0, r1
7009a9a8: d20a         	bhs	0x7009a9c0 <_vsnprintf+0x960> @ imm = #0x14
7009a9aa: e7ff         	b	0x7009a9ac <_vsnprintf+0x94c> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009a9ac: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a9b0: 993e         	ldr	r1, [sp, #0xf8]
7009a9b2: 9a37         	ldr	r2, [sp, #0xdc]
7009a9b4: 1c50         	adds	r0, r2, #0x1
7009a9b6: 9037         	str	r0, [sp, #0xdc]
7009a9b8: 9b3d         	ldr	r3, [sp, #0xf4]
7009a9ba: 2020         	movs	r0, #0x20
7009a9bc: 47e0         	blx	r12
;           while (l++ < width) {
7009a9be: e7ee         	b	0x7009a99e <_vsnprintf+0x93e> @ imm = #-0x24
;         }
7009a9c0: e7ff         	b	0x7009a9c2 <_vsnprintf+0x962> @ imm = #-0x2
;         format++;
7009a9c2: 983c         	ldr	r0, [sp, #0xf0]
7009a9c4: 3001         	adds	r0, #0x1
7009a9c6: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a9c8: e047         	b	0x7009aa5a <_vsnprintf+0x9fa> @ imm = #0x8e
7009a9ca: 2008         	movs	r0, #0x8
;         width = sizeof(void*) * 2U;
7009a9cc: 903a         	str	r0, [sp, #0xe8]
;         flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
7009a9ce: 983b         	ldr	r0, [sp, #0xec]
7009a9d0: f040 0021    	orr	r0, r0, #0x21
7009a9d4: 903b         	str	r0, [sp, #0xec]
7009a9d6: 2400         	movs	r4, #0x0
;         const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
7009a9d8: f88d 40af    	strb.w	r4, [sp, #0xaf]
;           idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
7009a9dc: 983f         	ldr	r0, [sp, #0xfc]
7009a9de: 993e         	ldr	r1, [sp, #0xf8]
7009a9e0: 9a37         	ldr	r2, [sp, #0xdc]
7009a9e2: 9b3d         	ldr	r3, [sp, #0xf4]
7009a9e4: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a9e8: f10c 0e04    	add.w	lr, r12, #0x4
7009a9ec: f8cd e100    	str.w	lr, [sp, #0x100]
7009a9f0: f8dc c000    	ldr.w	r12, [r12]
7009a9f4: 9d39         	ldr	r5, [sp, #0xe4]
7009a9f6: 9e3a         	ldr	r6, [sp, #0xe8]
7009a9f8: 9f3b         	ldr	r7, [sp, #0xec]
7009a9fa: 46ee         	mov	lr, sp
7009a9fc: f8ce 7014    	str.w	r7, [lr, #0x14]
7009aa00: f8ce 6010    	str.w	r6, [lr, #0x10]
7009aa04: f8ce 500c    	str.w	r5, [lr, #0xc]
7009aa08: 2510         	movs	r5, #0x10
7009aa0a: f8ce 5008    	str.w	r5, [lr, #0x8]
7009aa0e: f8ce 4004    	str.w	r4, [lr, #0x4]
7009aa12: f8ce c000    	str.w	r12, [lr]
7009aa16: f00a f833    	bl	0x700a4a80 <_ntoa_long> @ imm = #0xa066
7009aa1a: 9037         	str	r0, [sp, #0xdc]
;         format++;
7009aa1c: 983c         	ldr	r0, [sp, #0xf0]
7009aa1e: 3001         	adds	r0, #0x1
7009aa20: 903c         	str	r0, [sp, #0xf0]
;         break;
7009aa22: e01a         	b	0x7009aa5a <_vsnprintf+0x9fa> @ imm = #0x34
;         out('%', buffer, idx++, maxlen);
7009aa24: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009aa28: 993e         	ldr	r1, [sp, #0xf8]
7009aa2a: 9a37         	ldr	r2, [sp, #0xdc]
7009aa2c: 1c50         	adds	r0, r2, #0x1
7009aa2e: 9037         	str	r0, [sp, #0xdc]
7009aa30: 9b3d         	ldr	r3, [sp, #0xf4]
7009aa32: 2025         	movs	r0, #0x25
7009aa34: 47e0         	blx	r12
;         format++;
7009aa36: 983c         	ldr	r0, [sp, #0xf0]
7009aa38: 3001         	adds	r0, #0x1
7009aa3a: 903c         	str	r0, [sp, #0xf0]
;         break;
7009aa3c: e00d         	b	0x7009aa5a <_vsnprintf+0x9fa> @ imm = #0x1a
;         out(*format, buffer, idx++, maxlen);
7009aa3e: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009aa42: 983c         	ldr	r0, [sp, #0xf0]
7009aa44: 7800         	ldrb	r0, [r0]
7009aa46: 993e         	ldr	r1, [sp, #0xf8]
7009aa48: 9a37         	ldr	r2, [sp, #0xdc]
7009aa4a: 1c53         	adds	r3, r2, #0x1
7009aa4c: 9337         	str	r3, [sp, #0xdc]
7009aa4e: 9b3d         	ldr	r3, [sp, #0xf4]
7009aa50: 47e0         	blx	r12
;         format++;
7009aa52: 983c         	ldr	r0, [sp, #0xf0]
7009aa54: 3001         	adds	r0, #0x1
7009aa56: 903c         	str	r0, [sp, #0xf0]
;         break;
7009aa58: e7ff         	b	0x7009aa5a <_vsnprintf+0x9fa> @ imm = #-0x2
;   while (*format)
7009aa5a: f7ff bb18    	b.w	0x7009a08e <_vsnprintf+0x2e> @ imm = #-0x9d0
;   out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
7009aa5e: 983f         	ldr	r0, [sp, #0xfc]
7009aa60: 900a         	str	r0, [sp, #0x28]
7009aa62: 983e         	ldr	r0, [sp, #0xf8]
7009aa64: 900b         	str	r0, [sp, #0x2c]
7009aa66: 9837         	ldr	r0, [sp, #0xdc]
7009aa68: 993d         	ldr	r1, [sp, #0xf4]
7009aa6a: 4288         	cmp	r0, r1
7009aa6c: d203         	bhs	0x7009aa76 <_vsnprintf+0xa16> @ imm = #0x6
7009aa6e: e7ff         	b	0x7009aa70 <_vsnprintf+0xa10> @ imm = #-0x2
7009aa70: 9837         	ldr	r0, [sp, #0xdc]
7009aa72: 9009         	str	r0, [sp, #0x24]
7009aa74: e003         	b	0x7009aa7e <_vsnprintf+0xa1e> @ imm = #0x6
7009aa76: 983d         	ldr	r0, [sp, #0xf4]
7009aa78: 3801         	subs	r0, #0x1
7009aa7a: 9009         	str	r0, [sp, #0x24]
7009aa7c: e7ff         	b	0x7009aa7e <_vsnprintf+0xa1e> @ imm = #-0x2
7009aa7e: f8dd c028    	ldr.w	r12, [sp, #0x28]
7009aa82: 990b         	ldr	r1, [sp, #0x2c]
7009aa84: 9a09         	ldr	r2, [sp, #0x24]
7009aa86: 9b3d         	ldr	r3, [sp, #0xf4]
7009aa88: 2000         	movs	r0, #0x0
7009aa8a: 47e0         	blx	r12
;   return (int)idx;
7009aa8c: 9837         	ldr	r0, [sp, #0xdc]
7009aa8e: b041         	add	sp, #0x104
7009aa90: e8bd 83f0    	pop.w	{r4, r5, r6, r7, r8, r9, pc}

7009aa94 <__aeabi_errno_addr>:
7009aa94: e59f0000     	ldr	r0, [pc]                @ 0x7009aa9c <__aeabi_errno_addr+0x8>
7009aa98: e12fff1e     	bx	lr
7009aa9c: 80 26 0b 70  	.word	0x700b2680

7009aaa0 <Sciclient_rmIrqRouteValidate>:
; {
7009aaa0: b580         	push	{r7, lr}
7009aaa2: b09e         	sub	sp, #0x78
7009aaa4: 901d         	str	r0, [sp, #0x74]
7009aaa6: 2001         	movs	r0, #0x1
;     bool valid = true;
7009aaa8: f88d 0073    	strb.w	r0, [sp, #0x73]
7009aaac: 2000         	movs	r0, #0x0
;     const struct Sciclient_rmIrqNode *cur_n, *next_n = NULL;
7009aaae: 9009         	str	r0, [sp, #0x24]
7009aab0: 9019         	str	r0, [sp, #0x64]
;     bool cur_outp_valid = false, next_inp_valid = false;
7009aab2: f88d 005f    	strb.w	r0, [sp, #0x5f]
7009aab6: f88d 005e    	strb.w	r0, [sp, #0x5e]
;     uint16_t cur_outp = 0, next_inp = 0;
7009aaba: f8ad 0056    	strh.w	r0, [sp, #0x56]
7009aabe: f8ad 0054    	strh.w	r0, [sp, #0x54]
;     struct tisci_msg_rm_get_resource_range_req req = {{0}};
7009aac2: 9014         	str	r0, [sp, #0x50]
7009aac4: 9013         	str	r0, [sp, #0x4c]
7009aac6: 9012         	str	r0, [sp, #0x48]
;     struct tisci_msg_rm_get_resource_range_resp host_resp = {{0}};
7009aac8: 9011         	str	r0, [sp, #0x44]
7009aaca: 9010         	str	r0, [sp, #0x40]
7009aacc: 900f         	str	r0, [sp, #0x3c]
7009aace: 900e         	str	r0, [sp, #0x38]
;     struct tisci_msg_rm_get_resource_range_resp all_resp = {{0}};
7009aad0: 900d         	str	r0, [sp, #0x34]
7009aad2: 900c         	str	r0, [sp, #0x30]
7009aad4: 900b         	str	r0, [sp, #0x2c]
7009aad6: 900a         	str	r0, [sp, #0x28]
;     if (cfg->s_ia == SCICLIENT_RM_DEV_NONE) {
7009aad8: 981d         	ldr	r0, [sp, #0x74]
7009aada: 8a00         	ldrh	r0, [r0, #0x10]
7009aadc: 28ff         	cmp	r0, #0xff
7009aade: d12c         	bne	0x7009ab3a <Sciclient_rmIrqRouteValidate+0x9a> @ imm = #0x58
7009aae0: e7ff         	b	0x7009aae2 <Sciclient_rmIrqRouteValidate+0x42> @ imm = #-0x2
7009aae2: 2000         	movs	r0, #0x0
;         cur_n = Sciclient_rmPsGetIrqNode(0u);
7009aae4: f014 fb34    	bl	0x700af150 <Sciclient_rmPsGetIrqNode> @ imm = #0x14668
7009aae8: 901a         	str	r0, [sp, #0x68]
;         if (cur_n == NULL) {
7009aaea: 981a         	ldr	r0, [sp, #0x68]
7009aaec: b920         	cbnz	r0, 0x7009aaf8 <Sciclient_rmIrqRouteValidate+0x58> @ imm = #0x8
7009aaee: e7ff         	b	0x7009aaf0 <Sciclient_rmIrqRouteValidate+0x50> @ imm = #-0x2
7009aaf0: 2000         	movs	r0, #0x0
;             valid = false;
7009aaf2: f88d 0073    	strb.w	r0, [sp, #0x73]
;         } else {
7009aaf6: e01f         	b	0x7009ab38 <Sciclient_rmIrqRouteValidate+0x98> @ imm = #0x3e
;             cur_if = cur_n->p_if[Sciclient_rmPsGetIfIdx(0u)];
7009aaf8: 981a         	ldr	r0, [sp, #0x68]
7009aafa: 6840         	ldr	r0, [r0, #0x4]
7009aafc: 9008         	str	r0, [sp, #0x20]
7009aafe: 2000         	movs	r0, #0x0
7009ab00: f012 ff4e    	bl	0x700ad9a0 <Sciclient_rmPsGetIfIdx> @ imm = #0x12e9c
7009ab04: 4601         	mov	r1, r0
7009ab06: 9808         	ldr	r0, [sp, #0x20]
7009ab08: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009ab0c: 9018         	str	r0, [sp, #0x60]
;             if ((cfg->s_idx < cur_if->lbase) ||
7009ab0e: 981d         	ldr	r0, [sp, #0x74]
7009ab10: 8900         	ldrh	r0, [r0, #0x8]
7009ab12: 9918         	ldr	r1, [sp, #0x60]
7009ab14: 8809         	ldrh	r1, [r1]
7009ab16: 4288         	cmp	r0, r1
7009ab18: db09         	blt	0x7009ab2e <Sciclient_rmIrqRouteValidate+0x8e> @ imm = #0x12
7009ab1a: e7ff         	b	0x7009ab1c <Sciclient_rmIrqRouteValidate+0x7c> @ imm = #-0x2
;                 (cfg->s_idx >= (cur_if->lbase + cur_if->len))) {
7009ab1c: 981d         	ldr	r0, [sp, #0x74]
7009ab1e: 8900         	ldrh	r0, [r0, #0x8]
7009ab20: 9a18         	ldr	r2, [sp, #0x60]
7009ab22: 8811         	ldrh	r1, [r2]
7009ab24: 8892         	ldrh	r2, [r2, #0x4]
7009ab26: 4411         	add	r1, r2
;             if ((cfg->s_idx < cur_if->lbase) ||
7009ab28: 4288         	cmp	r0, r1
7009ab2a: db04         	blt	0x7009ab36 <Sciclient_rmIrqRouteValidate+0x96> @ imm = #0x8
7009ab2c: e7ff         	b	0x7009ab2e <Sciclient_rmIrqRouteValidate+0x8e> @ imm = #-0x2
7009ab2e: 2000         	movs	r0, #0x0
;                 valid = false;
7009ab30: f88d 0073    	strb.w	r0, [sp, #0x73]
;             }
7009ab34: e7ff         	b	0x7009ab36 <Sciclient_rmIrqRouteValidate+0x96> @ imm = #-0x2
7009ab36: e7ff         	b	0x7009ab38 <Sciclient_rmIrqRouteValidate+0x98> @ imm = #-0x2
;     }
7009ab38: e7ff         	b	0x7009ab3a <Sciclient_rmIrqRouteValidate+0x9a> @ imm = #-0x2
;     if ((valid == true) &&
7009ab3a: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009ab3e: 07c0         	lsls	r0, r0, #0x1f
7009ab40: b148         	cbz	r0, 0x7009ab56 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #0x12
7009ab42: e7ff         	b	0x7009ab44 <Sciclient_rmIrqRouteValidate+0xa4> @ imm = #-0x2
;         (Sciclient_rmPsGetPsp() <= 1U)) {
7009ab44: f014 ff14    	bl	0x700af970 <Sciclient_rmPsGetPsp> @ imm = #0x14e28
;     if ((valid == true) &&
7009ab48: 2801         	cmp	r0, #0x1
7009ab4a: d804         	bhi	0x7009ab56 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #0x8
7009ab4c: e7ff         	b	0x7009ab4e <Sciclient_rmIrqRouteValidate+0xae> @ imm = #-0x2
7009ab4e: 2000         	movs	r0, #0x0
;         valid = false;
7009ab50: f88d 0073    	strb.w	r0, [sp, #0x73]
;     }
7009ab54: e7ff         	b	0x7009ab56 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #-0x2
;     if (valid == true) {
7009ab56: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009ab5a: 07c0         	lsls	r0, r0, #0x1f
7009ab5c: b150         	cbz	r0, 0x7009ab74 <Sciclient_rmIrqRouteValidate+0xd4> @ imm = #0x14
7009ab5e: e7ff         	b	0x7009ab60 <Sciclient_rmIrqRouteValidate+0xc0> @ imm = #-0x2
;         if (Sciclient_rmIrqCheckLoop(cfg) == true) {
7009ab60: 981d         	ldr	r0, [sp, #0x74]
7009ab62: f00d fce5    	bl	0x700a8530 <Sciclient_rmIrqCheckLoop> @ imm = #0xd9ca
7009ab66: b120         	cbz	r0, 0x7009ab72 <Sciclient_rmIrqRouteValidate+0xd2> @ imm = #0x8
7009ab68: e7ff         	b	0x7009ab6a <Sciclient_rmIrqRouteValidate+0xca> @ imm = #-0x2
7009ab6a: 2000         	movs	r0, #0x0
;             valid = false;
7009ab6c: f88d 0073    	strb.w	r0, [sp, #0x73]
;         }
7009ab70: e7ff         	b	0x7009ab72 <Sciclient_rmIrqRouteValidate+0xd2> @ imm = #-0x2
;     }
7009ab72: e7ff         	b	0x7009ab74 <Sciclient_rmIrqRouteValidate+0xd4> @ imm = #-0x2
7009ab74: 2000         	movs	r0, #0x0
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
7009ab76: f8ad 0070    	strh.w	r0, [sp, #0x70]
7009ab7a: e7ff         	b	0x7009ab7c <Sciclient_rmIrqRouteValidate+0xdc> @ imm = #-0x2
7009ab7c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ab80: 9006         	str	r0, [sp, #0x18]
7009ab82: f014 fef5    	bl	0x700af970 <Sciclient_rmPsGetPsp> @ imm = #0x14dea
7009ab86: 9906         	ldr	r1, [sp, #0x18]
7009ab88: 4602         	mov	r2, r0
7009ab8a: 2000         	movs	r0, #0x0
7009ab8c: 4291         	cmp	r1, r2
7009ab8e: 9007         	str	r0, [sp, #0x1c]
7009ab90: da06         	bge	0x7009aba0 <Sciclient_rmIrqRouteValidate+0x100> @ imm = #0xc
7009ab92: e7ff         	b	0x7009ab94 <Sciclient_rmIrqRouteValidate+0xf4> @ imm = #-0x2
7009ab94: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009ab98: f000 0001    	and	r0, r0, #0x1
7009ab9c: 9007         	str	r0, [sp, #0x1c]
7009ab9e: e7ff         	b	0x7009aba0 <Sciclient_rmIrqRouteValidate+0x100> @ imm = #-0x2
7009aba0: 9807         	ldr	r0, [sp, #0x1c]
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
7009aba2: 07c0         	lsls	r0, r0, #0x1f
7009aba4: 2800         	cmp	r0, #0x0
7009aba6: f000 826f    	beq.w	0x7009b088 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x4de
7009abaa: e7ff         	b	0x7009abac <Sciclient_rmIrqRouteValidate+0x10c> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
7009abac: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009abb0: f014 face    	bl	0x700af150 <Sciclient_rmPsGetIrqNode> @ imm = #0x1459c
7009abb4: 901a         	str	r0, [sp, #0x68]
;         cur_if = cur_n->p_if[Sciclient_rmPsGetIfIdx(i)];
7009abb6: 981a         	ldr	r0, [sp, #0x68]
7009abb8: 6840         	ldr	r0, [r0, #0x4]
7009abba: 9004         	str	r0, [sp, #0x10]
7009abbc: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009abc0: f012 feee    	bl	0x700ad9a0 <Sciclient_rmPsGetIfIdx> @ imm = #0x12ddc
7009abc4: 4601         	mov	r1, r0
7009abc6: 9804         	ldr	r0, [sp, #0x10]
7009abc8: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009abcc: 9018         	str	r0, [sp, #0x60]
;         if (i < (Sciclient_rmPsGetPsp() - 1u)) {
7009abce: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009abd2: 9005         	str	r0, [sp, #0x14]
7009abd4: f014 fecc    	bl	0x700af970 <Sciclient_rmPsGetPsp> @ imm = #0x14d98
7009abd8: 4601         	mov	r1, r0
7009abda: 9805         	ldr	r0, [sp, #0x14]
7009abdc: 3901         	subs	r1, #0x1
7009abde: 4288         	cmp	r0, r1
7009abe0: d20f         	bhs	0x7009ac02 <Sciclient_rmIrqRouteValidate+0x162> @ imm = #0x1e
7009abe2: e7ff         	b	0x7009abe4 <Sciclient_rmIrqRouteValidate+0x144> @ imm = #-0x2
;             next_n = Sciclient_rmPsGetIrqNode(i + 1u);
7009abe4: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009abe8: 3001         	adds	r0, #0x1
7009abea: b280         	uxth	r0, r0
7009abec: f014 fab0    	bl	0x700af150 <Sciclient_rmPsGetIrqNode> @ imm = #0x14560
7009abf0: 9019         	str	r0, [sp, #0x64]
;             if (next_n == NULL) {
7009abf2: 9819         	ldr	r0, [sp, #0x64]
7009abf4: b920         	cbnz	r0, 0x7009ac00 <Sciclient_rmIrqRouteValidate+0x160> @ imm = #0x8
7009abf6: e7ff         	b	0x7009abf8 <Sciclient_rmIrqRouteValidate+0x158> @ imm = #-0x2
7009abf8: 2000         	movs	r0, #0x0
;                 valid = false;
7009abfa: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009abfe: e243         	b	0x7009b088 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x486
;         }
7009ac00: e7ff         	b	0x7009ac02 <Sciclient_rmIrqRouteValidate+0x162> @ imm = #-0x2
;         if (i > 0u) {
7009ac02: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac06: b158         	cbz	r0, 0x7009ac20 <Sciclient_rmIrqRouteValidate+0x180> @ imm = #0x16
7009ac08: e7ff         	b	0x7009ac0a <Sciclient_rmIrqRouteValidate+0x16a> @ imm = #-0x2
;             if (Sciclient_rmIrIsIr(cur_n->id) != true) {
7009ac0a: 981a         	ldr	r0, [sp, #0x68]
7009ac0c: 8800         	ldrh	r0, [r0]
7009ac0e: f013 fd47    	bl	0x700ae6a0 <Sciclient_rmIrIsIr> @ imm = #0x13a8e
7009ac12: b920         	cbnz	r0, 0x7009ac1e <Sciclient_rmIrqRouteValidate+0x17e> @ imm = #0x8
7009ac14: e7ff         	b	0x7009ac16 <Sciclient_rmIrqRouteValidate+0x176> @ imm = #-0x2
7009ac16: 2000         	movs	r0, #0x0
;                 valid = false;
7009ac18: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009ac1c: e234         	b	0x7009b088 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x468
;         }
7009ac1e: e7ff         	b	0x7009ac20 <Sciclient_rmIrqRouteValidate+0x180> @ imm = #-0x2
;         if ((i == 0u) && (i < (Sciclient_rmPsGetPsp() - 1u))) {
7009ac20: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac24: 2800         	cmp	r0, #0x0
7009ac26: f040 8080    	bne.w	0x7009ad2a <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #0x100
7009ac2a: e7ff         	b	0x7009ac2c <Sciclient_rmIrqRouteValidate+0x18c> @ imm = #-0x2
7009ac2c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac30: 9003         	str	r0, [sp, #0xc]
7009ac32: f014 fe9d    	bl	0x700af970 <Sciclient_rmPsGetPsp> @ imm = #0x14d3a
7009ac36: 4601         	mov	r1, r0
7009ac38: 9803         	ldr	r0, [sp, #0xc]
7009ac3a: 3901         	subs	r1, #0x1
7009ac3c: 4288         	cmp	r0, r1
7009ac3e: d274         	bhs	0x7009ad2a <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #0xe8
7009ac40: e7ff         	b	0x7009ac42 <Sciclient_rmIrqRouteValidate+0x1a2> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cur_n->id) == true) {
7009ac42: 981a         	ldr	r0, [sp, #0x68]
7009ac44: 8800         	ldrh	r0, [r0]
7009ac46: f013 fd13    	bl	0x700ae670 <Sciclient_rmIaIsIa> @ imm = #0x13a26
7009ac4a: 2800         	cmp	r0, #0x0
7009ac4c: d049         	beq	0x7009ace2 <Sciclient_rmIrqRouteValidate+0x242> @ imm = #0x92
7009ac4e: e7ff         	b	0x7009ac50 <Sciclient_rmIrqRouteValidate+0x1b0> @ imm = #-0x2
7009ac50: 2000         	movs	r0, #0x0
;                 cur_outp_valid = false;
7009ac52: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 next_inp_valid = false;
7009ac56: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cfg->vint,
7009ac5a: 9a18         	ldr	r2, [sp, #0x60]
7009ac5c: 8850         	ldrh	r0, [r2, #0x2]
7009ac5e: 991d         	ldr	r1, [sp, #0x74]
7009ac60: 8a49         	ldrh	r1, [r1, #0x12]
7009ac62: 8812         	ldrh	r2, [r2]
7009ac64: 1a89         	subs	r1, r1, r2
7009ac66: 4408         	add	r0, r1
7009ac68: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 cur_outp = cfg->vint;
7009ac6c: 981d         	ldr	r0, [sp, #0x74]
7009ac6e: 8a40         	ldrh	r0, [r0, #0x12]
7009ac70: f8ad 0056    	strh.w	r0, [sp, #0x56]
7009ac74: 2001         	movs	r0, #0x1
;                 cur_outp_valid = true;
7009ac76: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 if ((next_n != NULL) && (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
7009ac7a: 9819         	ldr	r0, [sp, #0x64]
7009ac7c: b160         	cbz	r0, 0x7009ac98 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #0x18
7009ac7e: e7ff         	b	0x7009ac80 <Sciclient_rmIrqRouteValidate+0x1e0> @ imm = #-0x2
7009ac80: 9819         	ldr	r0, [sp, #0x64]
7009ac82: 8800         	ldrh	r0, [r0]
7009ac84: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009ac88: f00b f96a    	bl	0x700a5f60 <Sciclient_rmIrInpIsFree> @ imm = #0xb2d4
7009ac8c: b920         	cbnz	r0, 0x7009ac98 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #0x8
7009ac8e: e7ff         	b	0x7009ac90 <Sciclient_rmIrqRouteValidate+0x1f0> @ imm = #-0x2
7009ac90: 2001         	movs	r0, #0x1
;                     next_inp_valid = true;
7009ac92: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 }
7009ac96: e7ff         	b	0x7009ac98 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #-0x2
;                 if (Sciclient_rmParamIsValid(cfg->valid_params,
7009ac98: 981d         	ldr	r0, [sp, #0x74]
7009ac9a: 6800         	ldr	r0, [r0]
7009ac9c: 2110         	movs	r1, #0x10
7009ac9e: f013 fedf    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x13dbe
7009aca2: b1e8         	cbz	r0, 0x7009ace0 <Sciclient_rmIrqRouteValidate+0x240> @ imm = #0x3a
7009aca4: e7ff         	b	0x7009aca6 <Sciclient_rmIrqRouteValidate+0x206> @ imm = #-0x2
;                     cur_inp = cfg->global_evt;
7009aca6: 981d         	ldr	r0, [sp, #0x74]
7009aca8: 89c0         	ldrh	r0, [r0, #0xe]
7009acaa: 9016         	str	r0, [sp, #0x58]
;                     if (Sciclient_rmIaValidateGlobalEvt(cur_n->id,
7009acac: 981a         	ldr	r0, [sp, #0x68]
7009acae: 8800         	ldrh	r0, [r0]
;                                       cur_inp) ==
7009acb0: f8bd 1058    	ldrh.w	r1, [sp, #0x58]
;                     if (Sciclient_rmIaValidateGlobalEvt(cur_n->id,
7009acb4: f011 fbdc    	bl	0x700ac470 <Sciclient_rmIaValidateGlobalEvt> @ imm = #0x117b8
7009acb8: b968         	cbnz	r0, 0x7009acd6 <Sciclient_rmIrqRouteValidate+0x236> @ imm = #0x1a
7009acba: e7ff         	b	0x7009acbc <Sciclient_rmIrqRouteValidate+0x21c> @ imm = #-0x2
;                         if (Sciclient_rmPsSetInp(i, cur_inp) != SystemP_SUCCESS) {
7009acbc: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009acc0: f8bd 1058    	ldrh.w	r1, [sp, #0x58]
7009acc4: f012 f9d4    	bl	0x700ad070 <Sciclient_rmPsSetInp> @ imm = #0x123a8
7009acc8: b120         	cbz	r0, 0x7009acd4 <Sciclient_rmIrqRouteValidate+0x234> @ imm = #0x8
7009acca: e7ff         	b	0x7009accc <Sciclient_rmIrqRouteValidate+0x22c> @ imm = #-0x2
7009accc: 2000         	movs	r0, #0x0
;                             valid = false;
7009acce: f88d 0073    	strb.w	r0, [sp, #0x73]
;                             break;
7009acd2: e1d9         	b	0x7009b088 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x3b2
;                     } else {
7009acd4: e003         	b	0x7009acde <Sciclient_rmIrqRouteValidate+0x23e> @ imm = #0x6
7009acd6: 2000         	movs	r0, #0x0
;                         valid = false;
7009acd8: f88d 0073    	strb.w	r0, [sp, #0x73]
;                         break;
7009acdc: e1d4         	b	0x7009b088 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x3a8
;                 }
7009acde: e7ff         	b	0x7009ace0 <Sciclient_rmIrqRouteValidate+0x240> @ imm = #-0x2
;             } else {
7009ace0: e022         	b	0x7009ad28 <Sciclient_rmIrqRouteValidate+0x288> @ imm = #0x44
7009ace2: 2001         	movs	r0, #0x1
;                 cur_outp_valid = true;
7009ace4: f88d 005f    	strb.w	r0, [sp, #0x5f]
7009ace8: 2000         	movs	r0, #0x0
;                 next_inp_valid = false;
7009acea: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 cur_outp = cfg->s_idx;
7009acee: 981d         	ldr	r0, [sp, #0x74]
7009acf0: 8900         	ldrh	r0, [r0, #0x8]
7009acf2: f8ad 0056    	strh.w	r0, [sp, #0x56]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cur_outp, cur_if->lbase,
7009acf6: 9a18         	ldr	r2, [sp, #0x60]
7009acf8: 8850         	ldrh	r0, [r2, #0x2]
7009acfa: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009acfe: 8812         	ldrh	r2, [r2]
7009ad00: 1a89         	subs	r1, r1, r2
7009ad02: 4408         	add	r0, r1
7009ad04: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 if ((next_n != NULL) && (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
7009ad08: 9819         	ldr	r0, [sp, #0x64]
7009ad0a: b160         	cbz	r0, 0x7009ad26 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #0x18
7009ad0c: e7ff         	b	0x7009ad0e <Sciclient_rmIrqRouteValidate+0x26e> @ imm = #-0x2
7009ad0e: 9819         	ldr	r0, [sp, #0x64]
7009ad10: 8800         	ldrh	r0, [r0]
7009ad12: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009ad16: f00b f923    	bl	0x700a5f60 <Sciclient_rmIrInpIsFree> @ imm = #0xb246
7009ad1a: b920         	cbnz	r0, 0x7009ad26 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #0x8
7009ad1c: e7ff         	b	0x7009ad1e <Sciclient_rmIrqRouteValidate+0x27e> @ imm = #-0x2
7009ad1e: 2001         	movs	r0, #0x1
;                     next_inp_valid = true;
7009ad20: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 }
7009ad24: e7ff         	b	0x7009ad26 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #-0x2
7009ad26: e7ff         	b	0x7009ad28 <Sciclient_rmIrqRouteValidate+0x288> @ imm = #-0x2
;         }
7009ad28: e7ff         	b	0x7009ad2a <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #-0x2
;         if ((i > 0u) && (i < (Sciclient_rmPsGetPsp() - 1u))) {
7009ad2a: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ad2e: 2800         	cmp	r0, #0x0
7009ad30: f000 80c4    	beq.w	0x7009aebc <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #0x188
7009ad34: e7ff         	b	0x7009ad36 <Sciclient_rmIrqRouteValidate+0x296> @ imm = #-0x2
7009ad36: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ad3a: 9002         	str	r0, [sp, #0x8]
7009ad3c: f014 fe18    	bl	0x700af970 <Sciclient_rmPsGetPsp> @ imm = #0x14c30
7009ad40: 4601         	mov	r1, r0
7009ad42: 9802         	ldr	r0, [sp, #0x8]
7009ad44: 3901         	subs	r1, #0x1
7009ad46: 4288         	cmp	r0, r1
7009ad48: f080 80b8    	bhs.w	0x7009aebc <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #0x170
7009ad4c: e7ff         	b	0x7009ad4e <Sciclient_rmIrqRouteValidate+0x2ae> @ imm = #-0x2
;             req.secondary_host = cfg->host;
7009ad4e: 981d         	ldr	r0, [sp, #0x74]
7009ad50: 7900         	ldrb	r0, [r0, #0x4]
7009ad52: f88d 0053    	strb.w	r0, [sp, #0x53]
;             req.type = cur_n->id;
7009ad56: 981a         	ldr	r0, [sp, #0x68]
7009ad58: 8800         	ldrh	r0, [r0]
7009ad5a: f8ad 0050    	strh.w	r0, [sp, #0x50]
7009ad5e: 2000         	movs	r0, #0x0
;             req.subtype = TISCI_RESASG_SUBTYPE_IR_OUTPUT;
7009ad60: f88d 0052    	strb.w	r0, [sp, #0x52]
7009ad64: a812         	add	r0, sp, #0x48
7009ad66: a90e         	add	r1, sp, #0x38
7009ad68: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &host_resp,
7009ad6c: f010 fa58    	bl	0x700ab220 <Sciclient_rmGetResourceRange> @ imm = #0x104b0
7009ad70: b120         	cbz	r0, 0x7009ad7c <Sciclient_rmIrqRouteValidate+0x2dc> @ imm = #0x8
7009ad72: e7ff         	b	0x7009ad74 <Sciclient_rmIrqRouteValidate+0x2d4> @ imm = #-0x2
7009ad74: 2000         	movs	r0, #0x0
;                 valid = false;
7009ad76: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009ad7a: e185         	b	0x7009b088 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x30a
7009ad7c: 2080         	movs	r0, #0x80
;             req.secondary_host = TISCI_HOST_ID_ALL;
7009ad7e: f88d 0053    	strb.w	r0, [sp, #0x53]
7009ad82: a812         	add	r0, sp, #0x48
7009ad84: a90a         	add	r1, sp, #0x28
7009ad86: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &all_resp,
7009ad8a: f010 fa49    	bl	0x700ab220 <Sciclient_rmGetResourceRange> @ imm = #0x10492
7009ad8e: b120         	cbz	r0, 0x7009ad9a <Sciclient_rmIrqRouteValidate+0x2fa> @ imm = #0x8
7009ad90: e7ff         	b	0x7009ad92 <Sciclient_rmIrqRouteValidate+0x2f2> @ imm = #-0x2
7009ad92: 2000         	movs	r0, #0x0
;                 valid = false;
7009ad94: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009ad98: e176         	b	0x7009b088 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x2ec
;             for (j = cur_if->lbase; j < cur_if->lbase + cur_if->len;
7009ad9a: 9818         	ldr	r0, [sp, #0x60]
7009ad9c: 8800         	ldrh	r0, [r0]
7009ad9e: f8ad 006e    	strh.w	r0, [sp, #0x6e]
7009ada2: e7ff         	b	0x7009ada4 <Sciclient_rmIrqRouteValidate+0x304> @ imm = #-0x2
7009ada4: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
7009ada8: 9a18         	ldr	r2, [sp, #0x60]
7009adaa: 8811         	ldrh	r1, [r2]
7009adac: 8892         	ldrh	r2, [r2, #0x4]
7009adae: 4411         	add	r1, r2
7009adb0: 4288         	cmp	r0, r1
7009adb2: f280 8082    	bge.w	0x7009aeba <Sciclient_rmIrqRouteValidate+0x41a> @ imm = #0x104
7009adb6: e7ff         	b	0x7009adb8 <Sciclient_rmIrqRouteValidate+0x318> @ imm = #-0x2
7009adb8: 2000         	movs	r0, #0x0
;                 cur_outp_valid = false;
7009adba: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 next_inp_valid = false;
7009adbe: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 cur_outp = j;
7009adc2: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
7009adc6: f8ad 0056    	strh.w	r0, [sp, #0x56]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cur_outp, cur_if->lbase,
7009adca: 9a18         	ldr	r2, [sp, #0x60]
7009adcc: 8850         	ldrh	r0, [r2, #0x2]
7009adce: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009add2: 8812         	ldrh	r2, [r2]
7009add4: 1a89         	subs	r1, r1, r2
7009add6: 4408         	add	r0, r1
7009add8: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 if ((((cur_outp >= host_resp.range_start) &&
7009addc: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ade0: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009ade4: 4288         	cmp	r0, r1
7009ade6: db0a         	blt	0x7009adfe <Sciclient_rmIrqRouteValidate+0x35e> @ imm = #0x14
7009ade8: e7ff         	b	0x7009adea <Sciclient_rmIrqRouteValidate+0x34a> @ imm = #-0x2
;                       (cur_outp < host_resp.range_start + host_resp.range_num)) ||
7009adea: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009adee: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009adf2: f8bd 2042    	ldrh.w	r2, [sp, #0x42]
7009adf6: 4411         	add	r1, r2
7009adf8: 4288         	cmp	r0, r1
7009adfa: db33         	blt	0x7009ae64 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x66
7009adfc: e7ff         	b	0x7009adfe <Sciclient_rmIrqRouteValidate+0x35e> @ imm = #-0x2
;                      ((cur_outp >= host_resp.range_start_sec) &&
7009adfe: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae02: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
7009ae06: 4288         	cmp	r0, r1
7009ae08: db0a         	blt	0x7009ae20 <Sciclient_rmIrqRouteValidate+0x380> @ imm = #0x14
7009ae0a: e7ff         	b	0x7009ae0c <Sciclient_rmIrqRouteValidate+0x36c> @ imm = #-0x2
;                       (cur_outp < host_resp.range_start_sec +
7009ae0c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae10: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
;                                   host_resp.range_num_sec))) ||
7009ae14: f8bd 2046    	ldrh.w	r2, [sp, #0x46]
;                       (cur_outp < host_resp.range_start_sec +
7009ae18: 4411         	add	r1, r2
;                                   host_resp.range_num_sec))) ||
7009ae1a: 4288         	cmp	r0, r1
7009ae1c: db22         	blt	0x7009ae64 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x44
7009ae1e: e7ff         	b	0x7009ae20 <Sciclient_rmIrqRouteValidate+0x380> @ imm = #-0x2
;                     (((cur_outp >= all_resp.range_start) &&
7009ae20: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae24: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009ae28: 4288         	cmp	r0, r1
7009ae2a: db0a         	blt	0x7009ae42 <Sciclient_rmIrqRouteValidate+0x3a2> @ imm = #0x14
7009ae2c: e7ff         	b	0x7009ae2e <Sciclient_rmIrqRouteValidate+0x38e> @ imm = #-0x2
;                       (cur_outp < all_resp.range_start + all_resp.range_num)) ||
7009ae2e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae32: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009ae36: f8bd 2032    	ldrh.w	r2, [sp, #0x32]
7009ae3a: 4411         	add	r1, r2
7009ae3c: 4288         	cmp	r0, r1
7009ae3e: db11         	blt	0x7009ae64 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x22
7009ae40: e7ff         	b	0x7009ae42 <Sciclient_rmIrqRouteValidate+0x3a2> @ imm = #-0x2
;                      ((cur_outp >= all_resp.range_start_sec) &&
7009ae42: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae46: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
7009ae4a: 4288         	cmp	r0, r1
7009ae4c: db2e         	blt	0x7009aeac <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #0x5c
7009ae4e: e7ff         	b	0x7009ae50 <Sciclient_rmIrqRouteValidate+0x3b0> @ imm = #-0x2
;                       (cur_outp < all_resp.range_start_sec +
7009ae50: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae54: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
;                                   all_resp.range_num_sec)))) {
7009ae58: f8bd 2036    	ldrh.w	r2, [sp, #0x36]
;                       (cur_outp < all_resp.range_start_sec +
7009ae5c: 4411         	add	r1, r2
;                 if ((((cur_outp >= host_resp.range_start) &&
7009ae5e: 4288         	cmp	r0, r1
7009ae60: da24         	bge	0x7009aeac <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #0x48
7009ae62: e7ff         	b	0x7009ae64 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #-0x2
;                     if (Sciclient_rmIrOutpIsFree(cur_n->id, cur_outp) ==
7009ae64: 981a         	ldr	r0, [sp, #0x68]
7009ae66: 8800         	ldrh	r0, [r0]
7009ae68: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009ae6c: f00e f838    	bl	0x700a8ee0 <Sciclient_rmIrOutpIsFree> @ imm = #0xe070
7009ae70: b920         	cbnz	r0, 0x7009ae7c <Sciclient_rmIrqRouteValidate+0x3dc> @ imm = #0x8
7009ae72: e7ff         	b	0x7009ae74 <Sciclient_rmIrqRouteValidate+0x3d4> @ imm = #-0x2
7009ae74: 2001         	movs	r0, #0x1
;                         cur_outp_valid = true;
7009ae76: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                     }
7009ae7a: e7ff         	b	0x7009ae7c <Sciclient_rmIrqRouteValidate+0x3dc> @ imm = #-0x2
;                     if (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
7009ae7c: 9819         	ldr	r0, [sp, #0x64]
7009ae7e: 8800         	ldrh	r0, [r0]
7009ae80: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009ae84: f00b f86c    	bl	0x700a5f60 <Sciclient_rmIrInpIsFree> @ imm = #0xb0d8
7009ae88: b920         	cbnz	r0, 0x7009ae94 <Sciclient_rmIrqRouteValidate+0x3f4> @ imm = #0x8
7009ae8a: e7ff         	b	0x7009ae8c <Sciclient_rmIrqRouteValidate+0x3ec> @ imm = #-0x2
7009ae8c: 2001         	movs	r0, #0x1
;                         next_inp_valid = true;
7009ae8e: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                     }
7009ae92: e7ff         	b	0x7009ae94 <Sciclient_rmIrqRouteValidate+0x3f4> @ imm = #-0x2
;                     if ((cur_outp_valid == true) &&
7009ae94: f89d 005f    	ldrb.w	r0, [sp, #0x5f]
7009ae98: 07c0         	lsls	r0, r0, #0x1f
7009ae9a: b130         	cbz	r0, 0x7009aeaa <Sciclient_rmIrqRouteValidate+0x40a> @ imm = #0xc
7009ae9c: e7ff         	b	0x7009ae9e <Sciclient_rmIrqRouteValidate+0x3fe> @ imm = #-0x2
;                         (next_inp_valid == true)) {
7009ae9e: f89d 005e    	ldrb.w	r0, [sp, #0x5e]
;                     if ((cur_outp_valid == true) &&
7009aea2: 07c0         	lsls	r0, r0, #0x1f
7009aea4: b108         	cbz	r0, 0x7009aeaa <Sciclient_rmIrqRouteValidate+0x40a> @ imm = #0x2
7009aea6: e7ff         	b	0x7009aea8 <Sciclient_rmIrqRouteValidate+0x408> @ imm = #-0x2
;                         break;
7009aea8: e007         	b	0x7009aeba <Sciclient_rmIrqRouteValidate+0x41a> @ imm = #0xe
;                 }
7009aeaa: e7ff         	b	0x7009aeac <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #-0x2
;             }
7009aeac: e7ff         	b	0x7009aeae <Sciclient_rmIrqRouteValidate+0x40e> @ imm = #-0x2
;                  j++) {
7009aeae: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
7009aeb2: 3001         	adds	r0, #0x1
7009aeb4: f8ad 006e    	strh.w	r0, [sp, #0x6e]
;             for (j = cur_if->lbase; j < cur_if->lbase + cur_if->len;
7009aeb8: e774         	b	0x7009ada4 <Sciclient_rmIrqRouteValidate+0x304> @ imm = #-0x118
;         }
7009aeba: e7ff         	b	0x7009aebc <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #-0x2
;         if (i == (Sciclient_rmPsGetPsp() - 1u)) {
7009aebc: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009aec0: 9001         	str	r0, [sp, #0x4]
7009aec2: f014 fd55    	bl	0x700af970 <Sciclient_rmPsGetPsp> @ imm = #0x14aaa
7009aec6: 4601         	mov	r1, r0
7009aec8: 9801         	ldr	r0, [sp, #0x4]
7009aeca: 3901         	subs	r1, #0x1
7009aecc: 4288         	cmp	r0, r1
7009aece: f040 809f    	bne.w	0x7009b010 <Sciclient_rmIrqRouteValidate+0x570> @ imm = #0x13e
7009aed2: e7ff         	b	0x7009aed4 <Sciclient_rmIrqRouteValidate+0x434> @ imm = #-0x2
7009aed4: 2000         	movs	r0, #0x0
;             cur_outp_valid = false;
7009aed6: f88d 005f    	strb.w	r0, [sp, #0x5f]
7009aeda: 2101         	movs	r1, #0x1
;             next_inp_valid = true;
7009aedc: f88d 105e    	strb.w	r1, [sp, #0x5e]
;             req.secondary_host = cfg->host;
7009aee0: 991d         	ldr	r1, [sp, #0x74]
7009aee2: 7909         	ldrb	r1, [r1, #0x4]
7009aee4: f88d 1053    	strb.w	r1, [sp, #0x53]
;             req.type = cur_n->id;
7009aee8: 991a         	ldr	r1, [sp, #0x68]
7009aeea: 8809         	ldrh	r1, [r1]
7009aeec: f8ad 1050    	strh.w	r1, [sp, #0x50]
;             req.subtype = TISCI_RESASG_SUBTYPE_IR_OUTPUT;
7009aef0: f88d 0052    	strb.w	r0, [sp, #0x52]
7009aef4: a812         	add	r0, sp, #0x48
7009aef6: a90e         	add	r1, sp, #0x38
7009aef8: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &host_resp,
7009aefc: f010 f990    	bl	0x700ab220 <Sciclient_rmGetResourceRange> @ imm = #0x10320
7009af00: b120         	cbz	r0, 0x7009af0c <Sciclient_rmIrqRouteValidate+0x46c> @ imm = #0x8
7009af02: e7ff         	b	0x7009af04 <Sciclient_rmIrqRouteValidate+0x464> @ imm = #-0x2
7009af04: 2000         	movs	r0, #0x0
;                 valid = false;
7009af06: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009af0a: e0bd         	b	0x7009b088 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x17a
7009af0c: 2080         	movs	r0, #0x80
;             req.secondary_host = TISCI_HOST_ID_ALL;
7009af0e: f88d 0053    	strb.w	r0, [sp, #0x53]
7009af12: a812         	add	r0, sp, #0x48
7009af14: a90a         	add	r1, sp, #0x28
7009af16: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &all_resp,
7009af1a: f010 f981    	bl	0x700ab220 <Sciclient_rmGetResourceRange> @ imm = #0x10302
7009af1e: b120         	cbz	r0, 0x7009af2a <Sciclient_rmIrqRouteValidate+0x48a> @ imm = #0x8
7009af20: e7ff         	b	0x7009af22 <Sciclient_rmIrqRouteValidate+0x482> @ imm = #-0x2
7009af22: 2000         	movs	r0, #0x0
;                 valid = false;
7009af24: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009af28: e0ae         	b	0x7009b088 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x15c
;             cur_outp = SCICLIENT_INP_TO_OUTP(cfg->d_irq,
7009af2a: 9a18         	ldr	r2, [sp, #0x60]
7009af2c: 8810         	ldrh	r0, [r2]
7009af2e: 991d         	ldr	r1, [sp, #0x74]
7009af30: 8989         	ldrh	r1, [r1, #0xc]
7009af32: 8852         	ldrh	r2, [r2, #0x2]
7009af34: 1a89         	subs	r1, r1, r2
7009af36: 4408         	add	r0, r1
7009af38: f8ad 0056    	strh.w	r0, [sp, #0x56]
;             if ((((cur_outp >= host_resp.range_start) &&
7009af3c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009af40: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009af44: 4288         	cmp	r0, r1
7009af46: db0a         	blt	0x7009af5e <Sciclient_rmIrqRouteValidate+0x4be> @ imm = #0x14
7009af48: e7ff         	b	0x7009af4a <Sciclient_rmIrqRouteValidate+0x4aa> @ imm = #-0x2
;                   (cur_outp < host_resp.range_start + host_resp.range_num)) ||
7009af4a: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009af4e: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009af52: f8bd 2042    	ldrh.w	r2, [sp, #0x42]
7009af56: 4411         	add	r1, r2
7009af58: 4288         	cmp	r0, r1
7009af5a: db33         	blt	0x7009afc4 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x66
7009af5c: e7ff         	b	0x7009af5e <Sciclient_rmIrqRouteValidate+0x4be> @ imm = #-0x2
;                  ((cur_outp >= host_resp.range_start_sec) &&
7009af5e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009af62: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
7009af66: 4288         	cmp	r0, r1
7009af68: db0a         	blt	0x7009af80 <Sciclient_rmIrqRouteValidate+0x4e0> @ imm = #0x14
7009af6a: e7ff         	b	0x7009af6c <Sciclient_rmIrqRouteValidate+0x4cc> @ imm = #-0x2
;                   (cur_outp < host_resp.range_start_sec +
7009af6c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009af70: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
;                               host_resp.range_num_sec))) ||
7009af74: f8bd 2046    	ldrh.w	r2, [sp, #0x46]
;                   (cur_outp < host_resp.range_start_sec +
7009af78: 4411         	add	r1, r2
;                               host_resp.range_num_sec))) ||
7009af7a: 4288         	cmp	r0, r1
7009af7c: db22         	blt	0x7009afc4 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x44
7009af7e: e7ff         	b	0x7009af80 <Sciclient_rmIrqRouteValidate+0x4e0> @ imm = #-0x2
;                 (((cur_outp >= all_resp.range_start) &&
7009af80: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009af84: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009af88: 4288         	cmp	r0, r1
7009af8a: db0a         	blt	0x7009afa2 <Sciclient_rmIrqRouteValidate+0x502> @ imm = #0x14
7009af8c: e7ff         	b	0x7009af8e <Sciclient_rmIrqRouteValidate+0x4ee> @ imm = #-0x2
;                   (cur_outp < all_resp.range_start + all_resp.range_num)) ||
7009af8e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009af92: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009af96: f8bd 2032    	ldrh.w	r2, [sp, #0x32]
7009af9a: 4411         	add	r1, r2
7009af9c: 4288         	cmp	r0, r1
7009af9e: db11         	blt	0x7009afc4 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x22
7009afa0: e7ff         	b	0x7009afa2 <Sciclient_rmIrqRouteValidate+0x502> @ imm = #-0x2
;                  ((cur_outp >= all_resp.range_start_sec) &&
7009afa2: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009afa6: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
7009afaa: 4288         	cmp	r0, r1
7009afac: db2f         	blt	0x7009b00e <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #0x5e
7009afae: e7ff         	b	0x7009afb0 <Sciclient_rmIrqRouteValidate+0x510> @ imm = #-0x2
;                   (cur_outp < all_resp.range_start_sec +
7009afb0: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009afb4: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
;                               all_resp.range_num_sec)))) {
7009afb8: f8bd 2036    	ldrh.w	r2, [sp, #0x36]
;                   (cur_outp < all_resp.range_start_sec +
7009afbc: 4411         	add	r1, r2
;             if ((((cur_outp >= host_resp.range_start) &&
7009afbe: 4288         	cmp	r0, r1
7009afc0: da25         	bge	0x7009b00e <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #0x4a
7009afc2: e7ff         	b	0x7009afc4 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #-0x2
;                 if ((cur_if->rid == cfg->d_id) &&
7009afc4: 9818         	ldr	r0, [sp, #0x60]
7009afc6: 88c0         	ldrh	r0, [r0, #0x6]
7009afc8: 991d         	ldr	r1, [sp, #0x74]
7009afca: 8949         	ldrh	r1, [r1, #0xa]
7009afcc: 4288         	cmp	r0, r1
7009afce: d11d         	bne	0x7009b00c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x3a
7009afd0: e7ff         	b	0x7009afd2 <Sciclient_rmIrqRouteValidate+0x532> @ imm = #-0x2
;                     (cfg->d_irq >= (cur_if->rbase)) &&
7009afd2: 981d         	ldr	r0, [sp, #0x74]
7009afd4: 8980         	ldrh	r0, [r0, #0xc]
7009afd6: 9918         	ldr	r1, [sp, #0x60]
7009afd8: 8849         	ldrh	r1, [r1, #0x2]
7009afda: 4288         	cmp	r0, r1
7009afdc: db16         	blt	0x7009b00c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x2c
7009afde: e7ff         	b	0x7009afe0 <Sciclient_rmIrqRouteValidate+0x540> @ imm = #-0x2
;                     (cfg->d_irq < (cur_if->rbase + cur_if->len))) {
7009afe0: 981d         	ldr	r0, [sp, #0x74]
7009afe2: 8980         	ldrh	r0, [r0, #0xc]
7009afe4: 9a18         	ldr	r2, [sp, #0x60]
7009afe6: 8851         	ldrh	r1, [r2, #0x2]
7009afe8: 8892         	ldrh	r2, [r2, #0x4]
7009afea: 4411         	add	r1, r2
;                 if ((cur_if->rid == cfg->d_id) &&
7009afec: 4288         	cmp	r0, r1
7009afee: da0d         	bge	0x7009b00c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x1a
7009aff0: e7ff         	b	0x7009aff2 <Sciclient_rmIrqRouteValidate+0x552> @ imm = #-0x2
;                     if (Sciclient_rmIrOutpIsFree(cur_n->id, cur_outp) ==
7009aff2: 981a         	ldr	r0, [sp, #0x68]
7009aff4: 8800         	ldrh	r0, [r0]
7009aff6: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009affa: f00d ff71    	bl	0x700a8ee0 <Sciclient_rmIrOutpIsFree> @ imm = #0xdee2
7009affe: b920         	cbnz	r0, 0x7009b00a <Sciclient_rmIrqRouteValidate+0x56a> @ imm = #0x8
7009b000: e7ff         	b	0x7009b002 <Sciclient_rmIrqRouteValidate+0x562> @ imm = #-0x2
7009b002: 2001         	movs	r0, #0x1
;                         cur_outp_valid = true;
7009b004: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                     }
7009b008: e7ff         	b	0x7009b00a <Sciclient_rmIrqRouteValidate+0x56a> @ imm = #-0x2
;                 }
7009b00a: e7ff         	b	0x7009b00c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #-0x2
; 	    }
7009b00c: e7ff         	b	0x7009b00e <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #-0x2
;         }
7009b00e: e7ff         	b	0x7009b010 <Sciclient_rmIrqRouteValidate+0x570> @ imm = #-0x2
;         if ((cur_outp_valid == true) && (next_inp_valid == true)) {
7009b010: f89d 005f    	ldrb.w	r0, [sp, #0x5f]
7009b014: 07c0         	lsls	r0, r0, #0x1f
7009b016: b360         	cbz	r0, 0x7009b072 <Sciclient_rmIrqRouteValidate+0x5d2> @ imm = #0x58
7009b018: e7ff         	b	0x7009b01a <Sciclient_rmIrqRouteValidate+0x57a> @ imm = #-0x2
7009b01a: f89d 005e    	ldrb.w	r0, [sp, #0x5e]
7009b01e: 07c0         	lsls	r0, r0, #0x1f
7009b020: b338         	cbz	r0, 0x7009b072 <Sciclient_rmIrqRouteValidate+0x5d2> @ imm = #0x4e
7009b022: e7ff         	b	0x7009b024 <Sciclient_rmIrqRouteValidate+0x584> @ imm = #-0x2
;             if (i < (Sciclient_rmPsGetPsp() - (1u))) {
7009b024: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009b028: 9000         	str	r0, [sp]
7009b02a: f014 fca1    	bl	0x700af970 <Sciclient_rmPsGetPsp> @ imm = #0x14942
7009b02e: 4601         	mov	r1, r0
7009b030: 9800         	ldr	r0, [sp]
7009b032: 3901         	subs	r1, #0x1
7009b034: 4288         	cmp	r0, r1
7009b036: d20f         	bhs	0x7009b058 <Sciclient_rmIrqRouteValidate+0x5b8> @ imm = #0x1e
7009b038: e7ff         	b	0x7009b03a <Sciclient_rmIrqRouteValidate+0x59a> @ imm = #-0x2
;                 if (Sciclient_rmPsSetInp(i + (1u), next_inp) != SystemP_SUCCESS) {
7009b03a: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009b03e: 3001         	adds	r0, #0x1
7009b040: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009b044: b280         	uxth	r0, r0
7009b046: f012 f813    	bl	0x700ad070 <Sciclient_rmPsSetInp> @ imm = #0x12026
7009b04a: b120         	cbz	r0, 0x7009b056 <Sciclient_rmIrqRouteValidate+0x5b6> @ imm = #0x8
7009b04c: e7ff         	b	0x7009b04e <Sciclient_rmIrqRouteValidate+0x5ae> @ imm = #-0x2
7009b04e: 2000         	movs	r0, #0x0
;                     valid = false;
7009b050: f88d 0073    	strb.w	r0, [sp, #0x73]
;                     break;
7009b054: e018         	b	0x7009b088 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x30
;             }
7009b056: e7ff         	b	0x7009b058 <Sciclient_rmIrqRouteValidate+0x5b8> @ imm = #-0x2
;             if (Sciclient_rmPsSetOutp(i, cur_outp) != SystemP_SUCCESS) {
7009b058: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009b05c: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009b060: f012 f82e    	bl	0x700ad0c0 <Sciclient_rmPsSetOutp> @ imm = #0x1205c
7009b064: b120         	cbz	r0, 0x7009b070 <Sciclient_rmIrqRouteValidate+0x5d0> @ imm = #0x8
7009b066: e7ff         	b	0x7009b068 <Sciclient_rmIrqRouteValidate+0x5c8> @ imm = #-0x2
7009b068: 2000         	movs	r0, #0x0
;                 valid = false;
7009b06a: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009b06e: e00b         	b	0x7009b088 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x16
;         } else {
7009b070: e003         	b	0x7009b07a <Sciclient_rmIrqRouteValidate+0x5da> @ imm = #0x6
7009b072: 2000         	movs	r0, #0x0
;             valid = false;
7009b074: f88d 0073    	strb.w	r0, [sp, #0x73]
;             break;
7009b078: e006         	b	0x7009b088 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0xc
;     }
7009b07a: e7ff         	b	0x7009b07c <Sciclient_rmIrqRouteValidate+0x5dc> @ imm = #-0x2
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
7009b07c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009b080: 3001         	adds	r0, #0x1
7009b082: f8ad 0070    	strh.w	r0, [sp, #0x70]
7009b086: e579         	b	0x7009ab7c <Sciclient_rmIrqRouteValidate+0xdc> @ imm = #-0x50e
;     return valid;
7009b088: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009b08c: f000 0001    	and	r0, r0, #0x1
7009b090: b01e         	add	sp, #0x78
7009b092: bd80         	pop	{r7, pc}

7009b094 <__aeabi_memclr8>:
7009b094: e1a02001     	mov	r2, r1
7009b098: e3b01000     	movs	r1, #0
7009b09c: ea0050f9     	b	0x700af488 <TI_memset_small> @ imm = #0x143e4

7009b0a0 <_ftoa>:
; {
7009b0a0: b570         	push	{r4, r5, r6, lr}
7009b0a2: b0a2         	sub	sp, #0x88
7009b0a4: f8dd c0a0    	ldr.w	r12, [sp, #0xa0]
7009b0a8: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009b0ac: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009b0b0: 9020         	str	r0, [sp, #0x80]
7009b0b2: 911f         	str	r1, [sp, #0x7c]
7009b0b4: 921e         	str	r2, [sp, #0x78]
7009b0b6: 931d         	str	r3, [sp, #0x74]
7009b0b8: ed8d 0b1a    	vstr	d0, [sp, #104]
7009b0bc: 2000         	movs	r0, #0x0
;   size_t len  = 0U;
7009b0be: 9011         	str	r0, [sp, #0x44]
;   double diff = 0.0;
7009b0c0: 900f         	str	r0, [sp, #0x3c]
7009b0c2: 900e         	str	r0, [sp, #0x38]
;   if (value != value)
7009b0c4: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b0c8: eeb4 0b40    	vcmp.f64	d0, d0
7009b0cc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b0d0: d71a         	bvc	0x7009b108 <_ftoa+0x68> @ imm = #0x34
7009b0d2: e7ff         	b	0x7009b0d4 <_ftoa+0x34> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
7009b0d4: 9820         	ldr	r0, [sp, #0x80]
7009b0d6: 991f         	ldr	r1, [sp, #0x7c]
7009b0d8: 9a1e         	ldr	r2, [sp, #0x78]
7009b0da: 9b1d         	ldr	r3, [sp, #0x74]
7009b0dc: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009b0e0: 9c28         	ldr	r4, [sp, #0xa0]
7009b0e2: 46ee         	mov	lr, sp
7009b0e4: f8ce 400c    	str.w	r4, [lr, #0xc]
7009b0e8: f8ce c008    	str.w	r12, [lr, #0x8]
7009b0ec: f04f 0c03    	mov.w	r12, #0x3
7009b0f0: f8ce c004    	str.w	r12, [lr, #0x4]
7009b0f4: f242 3c04    	movw	r12, #0x2304
7009b0f8: f2c7 0c0b    	movt	r12, #0x700b
7009b0fc: f8ce c000    	str.w	r12, [lr]
7009b100: f00c f936    	bl	0x700a7370 <_out_rev>   @ imm = #0xc26c
7009b104: 9021         	str	r0, [sp, #0x84]
7009b106: e257         	b	0x7009b5b8 <_ftoa+0x518> @ imm = #0x4ae
;   if (value < -DBL_MAX)
7009b108: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b10c: ed9f 1bd2    	vldr	d1, [pc, #840]          @ 0x7009b458 <_ftoa+0x3b8>
7009b110: eeb4 0b41    	vcmp.f64	d0, d1
7009b114: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b118: d51a         	bpl	0x7009b150 <_ftoa+0xb0> @ imm = #0x34
7009b11a: e7ff         	b	0x7009b11c <_ftoa+0x7c> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
7009b11c: 9820         	ldr	r0, [sp, #0x80]
7009b11e: 991f         	ldr	r1, [sp, #0x7c]
7009b120: 9a1e         	ldr	r2, [sp, #0x78]
7009b122: 9b1d         	ldr	r3, [sp, #0x74]
7009b124: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009b128: 9c28         	ldr	r4, [sp, #0xa0]
7009b12a: 46ee         	mov	lr, sp
7009b12c: f8ce 400c    	str.w	r4, [lr, #0xc]
7009b130: f8ce c008    	str.w	r12, [lr, #0x8]
7009b134: f04f 0c04    	mov.w	r12, #0x4
7009b138: f8ce c004    	str.w	r12, [lr, #0x4]
7009b13c: f242 2cdf    	movw	r12, #0x22df
7009b140: f2c7 0c0b    	movt	r12, #0x700b
7009b144: f8ce c000    	str.w	r12, [lr]
7009b148: f00c f912    	bl	0x700a7370 <_out_rev>   @ imm = #0xc224
7009b14c: 9021         	str	r0, [sp, #0x84]
7009b14e: e233         	b	0x7009b5b8 <_ftoa+0x518> @ imm = #0x466
;   if (value > DBL_MAX)
7009b150: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b154: ed9f 1bc2    	vldr	d1, [pc, #776]          @ 0x7009b460 <_ftoa+0x3c0>
7009b158: eeb4 0b41    	vcmp.f64	d0, d1
7009b15c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b160: dd26         	ble	0x7009b1b0 <_ftoa+0x110> @ imm = #0x4c
7009b162: e7ff         	b	0x7009b164 <_ftoa+0xc4> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
7009b164: 9820         	ldr	r0, [sp, #0x80]
7009b166: 991f         	ldr	r1, [sp, #0x7c]
7009b168: 9a1e         	ldr	r2, [sp, #0x78]
7009b16a: 9b1d         	ldr	r3, [sp, #0x74]
7009b16c: 9e28         	ldr	r6, [sp, #0xa0]
7009b16e: f006 0e04    	and	lr, r6, #0x4
7009b172: f242 24e9    	movw	r4, #0x22e9
7009b176: f2c7 040b    	movt	r4, #0x700b
7009b17a: f242 3c00    	movw	r12, #0x2300
7009b17e: f2c7 0c0b    	movt	r12, #0x700b
7009b182: f1be 0f00    	cmp.w	lr, #0x0
7009b186: bf18         	it	ne
7009b188: 46a4         	movne	r12, r4
7009b18a: 2403         	movs	r4, #0x3
7009b18c: f1be 0f00    	cmp.w	lr, #0x0
7009b190: bf18         	it	ne
7009b192: 2404         	movne	r4, #0x4
7009b194: 9d27         	ldr	r5, [sp, #0x9c]
7009b196: 46ee         	mov	lr, sp
7009b198: f8ce 600c    	str.w	r6, [lr, #0xc]
7009b19c: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b1a0: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b1a4: f8ce c000    	str.w	r12, [lr]
7009b1a8: f00c f8e2    	bl	0x700a7370 <_out_rev>   @ imm = #0xc1c4
7009b1ac: 9021         	str	r0, [sp, #0x84]
7009b1ae: e203         	b	0x7009b5b8 <_ftoa+0x518> @ imm = #0x406
;   if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
7009b1b0: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b1b4: ed9f 1bac    	vldr	d1, [pc, #688]          @ 0x7009b468 <_ftoa+0x3c8>
7009b1b8: eeb4 0b41    	vcmp.f64	d0, d1
7009b1bc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b1c0: dc0a         	bgt	0x7009b1d8 <_ftoa+0x138> @ imm = #0x14
7009b1c2: e7ff         	b	0x7009b1c4 <_ftoa+0x124> @ imm = #-0x2
7009b1c4: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b1c8: ed9f 1ba9    	vldr	d1, [pc, #676]          @ 0x7009b470 <_ftoa+0x3d0>
7009b1cc: eeb4 0b41    	vcmp.f64	d0, d1
7009b1d0: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b1d4: d515         	bpl	0x7009b202 <_ftoa+0x162> @ imm = #0x2a
7009b1d6: e7ff         	b	0x7009b1d8 <_ftoa+0x138> @ imm = #-0x2
;     return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
7009b1d8: 9820         	ldr	r0, [sp, #0x80]
7009b1da: 991f         	ldr	r1, [sp, #0x7c]
7009b1dc: 9a1e         	ldr	r2, [sp, #0x78]
7009b1de: 9b1d         	ldr	r3, [sp, #0x74]
7009b1e0: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b1e4: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009b1e8: 9c27         	ldr	r4, [sp, #0x9c]
7009b1ea: 9d28         	ldr	r5, [sp, #0xa0]
7009b1ec: 46ee         	mov	lr, sp
7009b1ee: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b1f2: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b1f6: f8ce c000    	str.w	r12, [lr]
7009b1fa: f000 f9e1    	bl	0x7009b5c0 <_etoa>      @ imm = #0x3c2
7009b1fe: 9021         	str	r0, [sp, #0x84]
7009b200: e1da         	b	0x7009b5b8 <_ftoa+0x518> @ imm = #0x3b4
7009b202: f04f 0000    	mov.w	r0, #0x0
;   bool negative = false;
7009b206: f88d 0037    	strb.w	r0, [sp, #0x37]
;   if (value < 0) {
7009b20a: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b20e: eeb5 0b40    	vcmp.f64	d0, #0
7009b212: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b216: d50d         	bpl	0x7009b234 <_ftoa+0x194> @ imm = #0x1a
7009b218: e7ff         	b	0x7009b21a <_ftoa+0x17a> @ imm = #-0x2
7009b21a: f04f 0001    	mov.w	r0, #0x1
;     negative = true;
7009b21e: f88d 0037    	strb.w	r0, [sp, #0x37]
;     value = 0 - value;
7009b222: ed9d 1b1a    	vldr	d1, [sp, #104]
7009b226: ed9f 0b94    	vldr	d0, [pc, #592]          @ 0x7009b478 <_ftoa+0x3d8>
7009b22a: ee30 0b41    	vsub.f64	d0, d0, d1
7009b22e: ed8d 0b1a    	vstr	d0, [sp, #104]
;   }
7009b232: e7ff         	b	0x7009b234 <_ftoa+0x194> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION)) {
7009b234: f89d 00a1    	ldrb.w	r0, [sp, #0xa1]
7009b238: ea4f 7040    	lsl.w	r0, r0, #0x1d
7009b23c: 2800         	cmp	r0, #0x0
7009b23e: d403         	bmi	0x7009b248 <_ftoa+0x1a8> @ imm = #0x6
7009b240: e7ff         	b	0x7009b242 <_ftoa+0x1a2> @ imm = #-0x2
7009b242: 2006         	movs	r0, #0x6
;     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
7009b244: 9026         	str	r0, [sp, #0x98]
;   }
7009b246: e7ff         	b	0x7009b248 <_ftoa+0x1a8> @ imm = #-0x2
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009b248: e7ff         	b	0x7009b24a <_ftoa+0x1aa> @ imm = #-0x2
7009b24a: 9911         	ldr	r1, [sp, #0x44]
7009b24c: 2000         	movs	r0, #0x0
7009b24e: 291f         	cmp	r1, #0x1f
7009b250: 9007         	str	r0, [sp, #0x1c]
7009b252: d807         	bhi	0x7009b264 <_ftoa+0x1c4> @ imm = #0xe
7009b254: e7ff         	b	0x7009b256 <_ftoa+0x1b6> @ imm = #-0x2
7009b256: 9926         	ldr	r1, [sp, #0x98]
7009b258: 2000         	movs	r0, #0x0
7009b25a: 2909         	cmp	r1, #0x9
7009b25c: bf88         	it	hi
7009b25e: 2001         	movhi	r0, #0x1
7009b260: 9007         	str	r0, [sp, #0x1c]
7009b262: e7ff         	b	0x7009b264 <_ftoa+0x1c4> @ imm = #-0x2
7009b264: 9807         	ldr	r0, [sp, #0x1c]
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009b266: 07c0         	lsls	r0, r0, #0x1f
7009b268: b150         	cbz	r0, 0x7009b280 <_ftoa+0x1e0> @ imm = #0x14
7009b26a: e7ff         	b	0x7009b26c <_ftoa+0x1cc> @ imm = #-0x2
;     buf[len++] = '0';
7009b26c: 9a11         	ldr	r2, [sp, #0x44]
7009b26e: 1c50         	adds	r0, r2, #0x1
7009b270: 9011         	str	r0, [sp, #0x44]
7009b272: a912         	add	r1, sp, #0x48
7009b274: 2030         	movs	r0, #0x30
7009b276: 5488         	strb	r0, [r1, r2]
;     prec--;
7009b278: 9826         	ldr	r0, [sp, #0x98]
7009b27a: 3801         	subs	r0, #0x1
7009b27c: 9026         	str	r0, [sp, #0x98]
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009b27e: e7e4         	b	0x7009b24a <_ftoa+0x1aa> @ imm = #-0x38
;   int whole = (int)value;
7009b280: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b284: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009b288: ed8d 0a0c    	vstr	s0, [sp, #48]
;   double tmp = (value - whole) * pow10[prec];
7009b28c: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b290: ed9d 1a0c    	vldr	s2, [sp, #48]
7009b294: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009b298: ee30 0b41    	vsub.f64	d0, d0, d1
7009b29c: 9926         	ldr	r1, [sp, #0x98]
7009b29e: f241 6020    	movw	r0, #0x1620
7009b2a2: f2c7 000b    	movt	r0, #0x700b
7009b2a6: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009b2aa: ed90 1b00    	vldr	d1, [r0]
7009b2ae: ee20 0b01    	vmul.f64	d0, d0, d1
7009b2b2: ed8d 0b0a    	vstr	d0, [sp, #40]
;   unsigned long frac = (unsigned long)tmp;
7009b2b6: ed9d 0b0a    	vldr	d0, [sp, #40]
7009b2ba: eebc 0bc0    	vcvt.u32.f64	s0, d0
7009b2be: ed8d 0a09    	vstr	s0, [sp, #36]
;   diff = tmp - frac;
7009b2c2: ed9d 0b0a    	vldr	d0, [sp, #40]
7009b2c6: ed9d 1a09    	vldr	s2, [sp, #36]
7009b2ca: eeb8 1b41    	vcvt.f64.u32	d1, s2
7009b2ce: ee30 0b41    	vsub.f64	d0, d0, d1
7009b2d2: ed8d 0b0e    	vstr	d0, [sp, #56]
;   if (diff > 0.5) {
7009b2d6: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b2da: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b2de: eeb4 0b41    	vcmp.f64	d0, d1
7009b2e2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b2e6: dd1e         	ble	0x7009b326 <_ftoa+0x286> @ imm = #0x3c
7009b2e8: e7ff         	b	0x7009b2ea <_ftoa+0x24a> @ imm = #-0x2
;     ++frac;
7009b2ea: 9809         	ldr	r0, [sp, #0x24]
7009b2ec: 3001         	adds	r0, #0x1
7009b2ee: 9009         	str	r0, [sp, #0x24]
;     if (frac >= pow10[prec]) {
7009b2f0: ed9d 0a09    	vldr	s0, [sp, #36]
7009b2f4: eeb8 0b40    	vcvt.f64.u32	d0, s0
7009b2f8: 9926         	ldr	r1, [sp, #0x98]
7009b2fa: f241 6020    	movw	r0, #0x1620
7009b2fe: f2c7 000b    	movt	r0, #0x700b
7009b302: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009b306: ed90 1b00    	vldr	d1, [r0]
7009b30a: eeb4 0b41    	vcmp.f64	d0, d1
7009b30e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b312: db07         	blt	0x7009b324 <_ftoa+0x284> @ imm = #0xe
7009b314: e7ff         	b	0x7009b316 <_ftoa+0x276> @ imm = #-0x2
7009b316: f04f 0000    	mov.w	r0, #0x0
;       frac = 0;
7009b31a: 9009         	str	r0, [sp, #0x24]
;       ++whole;
7009b31c: 980c         	ldr	r0, [sp, #0x30]
7009b31e: 3001         	adds	r0, #0x1
7009b320: 900c         	str	r0, [sp, #0x30]
;     }
7009b322: e7ff         	b	0x7009b324 <_ftoa+0x284> @ imm = #-0x2
;   }
7009b324: e018         	b	0x7009b358 <_ftoa+0x2b8> @ imm = #0x30
;   else if (diff < 0.5) {
7009b326: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b32a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b32e: eeb4 0b41    	vcmp.f64	d0, d1
7009b332: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b336: d501         	bpl	0x7009b33c <_ftoa+0x29c> @ imm = #0x2
7009b338: e7ff         	b	0x7009b33a <_ftoa+0x29a> @ imm = #-0x2
;   }
7009b33a: e00c         	b	0x7009b356 <_ftoa+0x2b6> @ imm = #0x18
;   else if ((frac == 0U) || (frac & 1U)) {
7009b33c: 9809         	ldr	r0, [sp, #0x24]
7009b33e: b128         	cbz	r0, 0x7009b34c <_ftoa+0x2ac> @ imm = #0xa
7009b340: e7ff         	b	0x7009b342 <_ftoa+0x2a2> @ imm = #-0x2
7009b342: f89d 0024    	ldrb.w	r0, [sp, #0x24]
7009b346: 07c0         	lsls	r0, r0, #0x1f
7009b348: b120         	cbz	r0, 0x7009b354 <_ftoa+0x2b4> @ imm = #0x8
7009b34a: e7ff         	b	0x7009b34c <_ftoa+0x2ac> @ imm = #-0x2
;     ++frac;
7009b34c: 9809         	ldr	r0, [sp, #0x24]
7009b34e: 3001         	adds	r0, #0x1
7009b350: 9009         	str	r0, [sp, #0x24]
;   }
7009b352: e7ff         	b	0x7009b354 <_ftoa+0x2b4> @ imm = #-0x2
7009b354: e7ff         	b	0x7009b356 <_ftoa+0x2b6> @ imm = #-0x2
7009b356: e7ff         	b	0x7009b358 <_ftoa+0x2b8> @ imm = #-0x2
;   if (prec == 0U) {
7009b358: 9826         	ldr	r0, [sp, #0x98]
7009b35a: bb48         	cbnz	r0, 0x7009b3b0 <_ftoa+0x310> @ imm = #0x52
7009b35c: e7ff         	b	0x7009b35e <_ftoa+0x2be> @ imm = #-0x2
;     diff = value - (double)whole;
7009b35e: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b362: ed9d 1a0c    	vldr	s2, [sp, #48]
7009b366: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009b36a: ee30 0b41    	vsub.f64	d0, d0, d1
7009b36e: ed8d 0b0e    	vstr	d0, [sp, #56]
;     if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
7009b372: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b376: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b37a: eeb4 0b41    	vcmp.f64	d0, d1
7009b37e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b382: d50a         	bpl	0x7009b39a <_ftoa+0x2fa> @ imm = #0x14
7009b384: e7ff         	b	0x7009b386 <_ftoa+0x2e6> @ imm = #-0x2
7009b386: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b38a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b38e: eeb4 0b41    	vcmp.f64	d0, d1
7009b392: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b396: dd0a         	ble	0x7009b3ae <_ftoa+0x30e> @ imm = #0x14
7009b398: e7ff         	b	0x7009b39a <_ftoa+0x2fa> @ imm = #-0x2
7009b39a: f89d 0030    	ldrb.w	r0, [sp, #0x30]
7009b39e: ea4f 70c0    	lsl.w	r0, r0, #0x1f
7009b3a2: b120         	cbz	r0, 0x7009b3ae <_ftoa+0x30e> @ imm = #0x8
7009b3a4: e7ff         	b	0x7009b3a6 <_ftoa+0x306> @ imm = #-0x2
;       ++whole;
7009b3a6: 980c         	ldr	r0, [sp, #0x30]
7009b3a8: 3001         	adds	r0, #0x1
7009b3aa: 900c         	str	r0, [sp, #0x30]
;     }
7009b3ac: e7ff         	b	0x7009b3ae <_ftoa+0x30e> @ imm = #-0x2
;   }
7009b3ae: e04d         	b	0x7009b44c <_ftoa+0x3ac> @ imm = #0x9a
;     unsigned int count = prec;
7009b3b0: 9826         	ldr	r0, [sp, #0x98]
7009b3b2: 9008         	str	r0, [sp, #0x20]
;     while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b3b4: e7ff         	b	0x7009b3b6 <_ftoa+0x316> @ imm = #-0x2
7009b3b6: 9811         	ldr	r0, [sp, #0x44]
7009b3b8: 281f         	cmp	r0, #0x1f
7009b3ba: d821         	bhi	0x7009b400 <_ftoa+0x360> @ imm = #0x42
7009b3bc: e7ff         	b	0x7009b3be <_ftoa+0x31e> @ imm = #-0x2
;       --count;
7009b3be: 9808         	ldr	r0, [sp, #0x20]
7009b3c0: 3801         	subs	r0, #0x1
7009b3c2: 9008         	str	r0, [sp, #0x20]
;       buf[len++] = (char)(48U + (frac % 10U));
7009b3c4: 9809         	ldr	r0, [sp, #0x24]
7009b3c6: f64c 41cd    	movw	r1, #0xcccd
7009b3ca: f6cc 41cc    	movt	r1, #0xcccc
7009b3ce: fba0 3201    	umull	r3, r2, r0, r1
7009b3d2: ea4f 02d2    	lsr.w	r2, r2, #0x3
7009b3d6: eb02 0282    	add.w	r2, r2, r2, lsl #2
7009b3da: eba0 0042    	sub.w	r0, r0, r2, lsl #1
7009b3de: f040 0030    	orr	r0, r0, #0x30
7009b3e2: 9b11         	ldr	r3, [sp, #0x44]
7009b3e4: 1c5a         	adds	r2, r3, #0x1
7009b3e6: 9211         	str	r2, [sp, #0x44]
7009b3e8: aa12         	add	r2, sp, #0x48
7009b3ea: 54d0         	strb	r0, [r2, r3]
;       if (!(frac /= 10U)) {
7009b3ec: 9809         	ldr	r0, [sp, #0x24]
7009b3ee: fba0 1001    	umull	r1, r0, r0, r1
7009b3f2: ea4f 00d0    	lsr.w	r0, r0, #0x3
7009b3f6: 9009         	str	r0, [sp, #0x24]
7009b3f8: b908         	cbnz	r0, 0x7009b3fe <_ftoa+0x35e> @ imm = #0x2
7009b3fa: e7ff         	b	0x7009b3fc <_ftoa+0x35c> @ imm = #-0x2
;         break;
7009b3fc: e000         	b	0x7009b400 <_ftoa+0x360> @ imm = #0x0
;     while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b3fe: e7da         	b	0x7009b3b6 <_ftoa+0x316> @ imm = #-0x4c
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009b400: e7ff         	b	0x7009b402 <_ftoa+0x362> @ imm = #-0x2
7009b402: 9911         	ldr	r1, [sp, #0x44]
7009b404: 2000         	movs	r0, #0x0
7009b406: 291f         	cmp	r1, #0x1f
7009b408: 9006         	str	r0, [sp, #0x18]
7009b40a: d808         	bhi	0x7009b41e <_ftoa+0x37e> @ imm = #0x10
7009b40c: e7ff         	b	0x7009b40e <_ftoa+0x36e> @ imm = #-0x2
7009b40e: 9808         	ldr	r0, [sp, #0x20]
7009b410: 1e41         	subs	r1, r0, #0x1
7009b412: 9108         	str	r1, [sp, #0x20]
7009b414: 2800         	cmp	r0, #0x0
7009b416: bf18         	it	ne
7009b418: 2001         	movne	r0, #0x1
7009b41a: 9006         	str	r0, [sp, #0x18]
7009b41c: e7ff         	b	0x7009b41e <_ftoa+0x37e> @ imm = #-0x2
7009b41e: 9806         	ldr	r0, [sp, #0x18]
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009b420: 07c0         	lsls	r0, r0, #0x1f
7009b422: b138         	cbz	r0, 0x7009b434 <_ftoa+0x394> @ imm = #0xe
7009b424: e7ff         	b	0x7009b426 <_ftoa+0x386> @ imm = #-0x2
;       buf[len++] = '0';
7009b426: 9a11         	ldr	r2, [sp, #0x44]
7009b428: 1c50         	adds	r0, r2, #0x1
7009b42a: 9011         	str	r0, [sp, #0x44]
7009b42c: a912         	add	r1, sp, #0x48
7009b42e: 2030         	movs	r0, #0x30
7009b430: 5488         	strb	r0, [r1, r2]
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009b432: e7e6         	b	0x7009b402 <_ftoa+0x362> @ imm = #-0x34
;     if (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b434: 9811         	ldr	r0, [sp, #0x44]
7009b436: 281f         	cmp	r0, #0x1f
7009b438: d807         	bhi	0x7009b44a <_ftoa+0x3aa> @ imm = #0xe
7009b43a: e7ff         	b	0x7009b43c <_ftoa+0x39c> @ imm = #-0x2
;       buf[len++] = '.';
7009b43c: 9a11         	ldr	r2, [sp, #0x44]
7009b43e: 1c50         	adds	r0, r2, #0x1
7009b440: 9011         	str	r0, [sp, #0x44]
7009b442: a912         	add	r1, sp, #0x48
7009b444: 202e         	movs	r0, #0x2e
7009b446: 5488         	strb	r0, [r1, r2]
;     }
7009b448: e7ff         	b	0x7009b44a <_ftoa+0x3aa> @ imm = #-0x2
7009b44a: e7ff         	b	0x7009b44c <_ftoa+0x3ac> @ imm = #-0x2
;   while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b44c: e7ff         	b	0x7009b44e <_ftoa+0x3ae> @ imm = #-0x2
7009b44e: 9811         	ldr	r0, [sp, #0x44]
7009b450: 281f         	cmp	r0, #0x1f
7009b452: d835         	bhi	0x7009b4c0 <_ftoa+0x420> @ imm = #0x6a
7009b454: e014         	b	0x7009b480 <_ftoa+0x3e0> @ imm = #0x28
7009b456: bf00         	nop
7009b458: ff ff ff ff  	.word	0xffffffff
7009b45c: ff ff ef ff  	.word	0xffefffff
7009b460: ff ff ff ff  	.word	0xffffffff
7009b464: ff ff ef 7f  	.word	0x7fefffff
7009b468: 00 00 00 00  	.word	0x00000000
7009b46c: 65 cd cd 41  	.word	0x41cdcd65
7009b470: 00 00 00 00  	.word	0x00000000
7009b474: 65 cd cd c1  	.word	0xc1cdcd65
7009b478: 00 00 00 00  	.word	0x00000000
7009b47c: 00 00 00 00  	.word	0x00000000
;     buf[len++] = (char)(48 + (whole % 10));
7009b480: 980c         	ldr	r0, [sp, #0x30]
7009b482: f246 6167    	movw	r1, #0x6667
7009b486: f2c6 6166    	movt	r1, #0x6666
7009b48a: fb50 f301    	smmul	r3, r0, r1
7009b48e: 089a         	lsrs	r2, r3, #0x2
7009b490: eb02 72d3    	add.w	r2, r2, r3, lsr #31
7009b494: eb02 0282    	add.w	r2, r2, r2, lsl #2
7009b498: eba0 0042    	sub.w	r0, r0, r2, lsl #1
7009b49c: 3030         	adds	r0, #0x30
7009b49e: 9b11         	ldr	r3, [sp, #0x44]
7009b4a0: 1c5a         	adds	r2, r3, #0x1
7009b4a2: 9211         	str	r2, [sp, #0x44]
7009b4a4: aa12         	add	r2, sp, #0x48
7009b4a6: 54d0         	strb	r0, [r2, r3]
;     if (!(whole /= 10)) {
7009b4a8: 980c         	ldr	r0, [sp, #0x30]
7009b4aa: fb50 f101    	smmul	r1, r0, r1
7009b4ae: ea4f 00a1    	asr.w	r0, r1, #0x2
7009b4b2: eb00 70d1    	add.w	r0, r0, r1, lsr #31
7009b4b6: 900c         	str	r0, [sp, #0x30]
7009b4b8: b908         	cbnz	r0, 0x7009b4be <_ftoa+0x41e> @ imm = #0x2
7009b4ba: e7ff         	b	0x7009b4bc <_ftoa+0x41c> @ imm = #-0x2
;       break;
7009b4bc: e000         	b	0x7009b4c0 <_ftoa+0x420> @ imm = #0x0
;   while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b4be: e7c6         	b	0x7009b44e <_ftoa+0x3ae> @ imm = #-0x74
;   if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
7009b4c0: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b4c4: 0780         	lsls	r0, r0, #0x1e
7009b4c6: 2800         	cmp	r0, #0x0
7009b4c8: d432         	bmi	0x7009b530 <_ftoa+0x490> @ imm = #0x64
7009b4ca: e7ff         	b	0x7009b4cc <_ftoa+0x42c> @ imm = #-0x2
7009b4cc: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b4d0: 07c0         	lsls	r0, r0, #0x1f
7009b4d2: b368         	cbz	r0, 0x7009b530 <_ftoa+0x490> @ imm = #0x5a
7009b4d4: e7ff         	b	0x7009b4d6 <_ftoa+0x436> @ imm = #-0x2
;     if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
7009b4d6: 9827         	ldr	r0, [sp, #0x9c]
7009b4d8: b178         	cbz	r0, 0x7009b4fa <_ftoa+0x45a> @ imm = #0x1e
7009b4da: e7ff         	b	0x7009b4dc <_ftoa+0x43c> @ imm = #-0x2
7009b4dc: f89d 0037    	ldrb.w	r0, [sp, #0x37]
7009b4e0: 07c0         	lsls	r0, r0, #0x1f
7009b4e2: b930         	cbnz	r0, 0x7009b4f2 <_ftoa+0x452> @ imm = #0xc
7009b4e4: e7ff         	b	0x7009b4e6 <_ftoa+0x446> @ imm = #-0x2
7009b4e6: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b4ea: f010 0f0c    	tst.w	r0, #0xc
7009b4ee: d004         	beq	0x7009b4fa <_ftoa+0x45a> @ imm = #0x8
7009b4f0: e7ff         	b	0x7009b4f2 <_ftoa+0x452> @ imm = #-0x2
;       width--;
7009b4f2: 9827         	ldr	r0, [sp, #0x9c]
7009b4f4: 3801         	subs	r0, #0x1
7009b4f6: 9027         	str	r0, [sp, #0x9c]
;     }
7009b4f8: e7ff         	b	0x7009b4fa <_ftoa+0x45a> @ imm = #-0x2
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009b4fa: e7ff         	b	0x7009b4fc <_ftoa+0x45c> @ imm = #-0x2
7009b4fc: 9911         	ldr	r1, [sp, #0x44]
7009b4fe: 9a27         	ldr	r2, [sp, #0x9c]
7009b500: 2000         	movs	r0, #0x0
7009b502: 4291         	cmp	r1, r2
7009b504: 9005         	str	r0, [sp, #0x14]
7009b506: d207         	bhs	0x7009b518 <_ftoa+0x478> @ imm = #0xe
7009b508: e7ff         	b	0x7009b50a <_ftoa+0x46a> @ imm = #-0x2
7009b50a: 9911         	ldr	r1, [sp, #0x44]
7009b50c: 2000         	movs	r0, #0x0
7009b50e: 2920         	cmp	r1, #0x20
7009b510: bf38         	it	lo
7009b512: 2001         	movlo	r0, #0x1
7009b514: 9005         	str	r0, [sp, #0x14]
7009b516: e7ff         	b	0x7009b518 <_ftoa+0x478> @ imm = #-0x2
7009b518: 9805         	ldr	r0, [sp, #0x14]
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009b51a: 07c0         	lsls	r0, r0, #0x1f
7009b51c: b138         	cbz	r0, 0x7009b52e <_ftoa+0x48e> @ imm = #0xe
7009b51e: e7ff         	b	0x7009b520 <_ftoa+0x480> @ imm = #-0x2
;       buf[len++] = '0';
7009b520: 9a11         	ldr	r2, [sp, #0x44]
7009b522: 1c50         	adds	r0, r2, #0x1
7009b524: 9011         	str	r0, [sp, #0x44]
7009b526: a912         	add	r1, sp, #0x48
7009b528: 2030         	movs	r0, #0x30
7009b52a: 5488         	strb	r0, [r1, r2]
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009b52c: e7e6         	b	0x7009b4fc <_ftoa+0x45c> @ imm = #-0x34
;   }
7009b52e: e7ff         	b	0x7009b530 <_ftoa+0x490> @ imm = #-0x2
;   if (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b530: 9811         	ldr	r0, [sp, #0x44]
7009b532: 281f         	cmp	r0, #0x1f
7009b534: d829         	bhi	0x7009b58a <_ftoa+0x4ea> @ imm = #0x52
7009b536: e7ff         	b	0x7009b538 <_ftoa+0x498> @ imm = #-0x2
;     if (negative) {
7009b538: f89d 0037    	ldrb.w	r0, [sp, #0x37]
7009b53c: 07c0         	lsls	r0, r0, #0x1f
7009b53e: b138         	cbz	r0, 0x7009b550 <_ftoa+0x4b0> @ imm = #0xe
7009b540: e7ff         	b	0x7009b542 <_ftoa+0x4a2> @ imm = #-0x2
;       buf[len++] = '-';
7009b542: 9a11         	ldr	r2, [sp, #0x44]
7009b544: 1c50         	adds	r0, r2, #0x1
7009b546: 9011         	str	r0, [sp, #0x44]
7009b548: a912         	add	r1, sp, #0x48
7009b54a: 202d         	movs	r0, #0x2d
7009b54c: 5488         	strb	r0, [r1, r2]
;     }
7009b54e: e01b         	b	0x7009b588 <_ftoa+0x4e8> @ imm = #0x36
;     else if (flags & FLAGS_PLUS) {
7009b550: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b554: 0740         	lsls	r0, r0, #0x1d
7009b556: 2800         	cmp	r0, #0x0
7009b558: d507         	bpl	0x7009b56a <_ftoa+0x4ca> @ imm = #0xe
7009b55a: e7ff         	b	0x7009b55c <_ftoa+0x4bc> @ imm = #-0x2
;       buf[len++] = '+';  // ignore the space if the '+' exists
7009b55c: 9a11         	ldr	r2, [sp, #0x44]
7009b55e: 1c50         	adds	r0, r2, #0x1
7009b560: 9011         	str	r0, [sp, #0x44]
7009b562: a912         	add	r1, sp, #0x48
7009b564: 202b         	movs	r0, #0x2b
7009b566: 5488         	strb	r0, [r1, r2]
;     }
7009b568: e00d         	b	0x7009b586 <_ftoa+0x4e6> @ imm = #0x1a
;     else if (flags & FLAGS_SPACE) {
7009b56a: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b56e: 0700         	lsls	r0, r0, #0x1c
7009b570: 2800         	cmp	r0, #0x0
7009b572: d507         	bpl	0x7009b584 <_ftoa+0x4e4> @ imm = #0xe
7009b574: e7ff         	b	0x7009b576 <_ftoa+0x4d6> @ imm = #-0x2
;       buf[len++] = ' ';
7009b576: 9a11         	ldr	r2, [sp, #0x44]
7009b578: 1c50         	adds	r0, r2, #0x1
7009b57a: 9011         	str	r0, [sp, #0x44]
7009b57c: a912         	add	r1, sp, #0x48
7009b57e: 2020         	movs	r0, #0x20
7009b580: 5488         	strb	r0, [r1, r2]
;     }
7009b582: e7ff         	b	0x7009b584 <_ftoa+0x4e4> @ imm = #-0x2
7009b584: e7ff         	b	0x7009b586 <_ftoa+0x4e6> @ imm = #-0x2
7009b586: e7ff         	b	0x7009b588 <_ftoa+0x4e8> @ imm = #-0x2
;   }
7009b588: e7ff         	b	0x7009b58a <_ftoa+0x4ea> @ imm = #-0x2
;   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
7009b58a: 9820         	ldr	r0, [sp, #0x80]
7009b58c: 991f         	ldr	r1, [sp, #0x7c]
7009b58e: 9a1e         	ldr	r2, [sp, #0x78]
7009b590: 9b1d         	ldr	r3, [sp, #0x74]
7009b592: f8dd c044    	ldr.w	r12, [sp, #0x44]
7009b596: 9c27         	ldr	r4, [sp, #0x9c]
7009b598: 9d28         	ldr	r5, [sp, #0xa0]
7009b59a: 46ee         	mov	lr, sp
7009b59c: f8ce 500c    	str.w	r5, [lr, #0xc]
7009b5a0: f8ce 4008    	str.w	r4, [lr, #0x8]
7009b5a4: f8ce c004    	str.w	r12, [lr, #0x4]
7009b5a8: f10d 0c48    	add.w	r12, sp, #0x48
7009b5ac: f8ce c000    	str.w	r12, [lr]
7009b5b0: f00b fede    	bl	0x700a7370 <_out_rev>   @ imm = #0xbdbc
7009b5b4: 9021         	str	r0, [sp, #0x84]
7009b5b6: e7ff         	b	0x7009b5b8 <_ftoa+0x518> @ imm = #-0x2
; }
7009b5b8: 9821         	ldr	r0, [sp, #0x84]
7009b5ba: b022         	add	sp, #0x88
7009b5bc: bd70         	pop	{r4, r5, r6, pc}
7009b5be: 0000         	movs	r0, r0

7009b5c0 <_etoa>:
; {
7009b5c0: b570         	push	{r4, r5, r6, lr}
7009b5c2: b0a8         	sub	sp, #0xa0
7009b5c4: f8dd c0b8    	ldr.w	r12, [sp, #0xb8]
7009b5c8: f8dd c0b4    	ldr.w	r12, [sp, #0xb4]
7009b5cc: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009b5d0: 9026         	str	r0, [sp, #0x98]
7009b5d2: 9125         	str	r1, [sp, #0x94]
7009b5d4: 9224         	str	r2, [sp, #0x90]
7009b5d6: 9323         	str	r3, [sp, #0x8c]
7009b5d8: ed8d 0b20    	vstr	d0, [sp, #128]
;   if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
7009b5dc: ed9d 0b20    	vldr	d0, [sp, #128]
7009b5e0: eeb4 0b40    	vcmp.f64	d0, d0
7009b5e4: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b5e8: d614         	bvs	0x7009b614 <_etoa+0x54> @ imm = #0x28
7009b5ea: e7ff         	b	0x7009b5ec <_etoa+0x2c> @ imm = #-0x2
7009b5ec: ed9d 0b20    	vldr	d0, [sp, #128]
7009b5f0: ed9f 1bdb    	vldr	d1, [pc, #876]          @ 0x7009b960 <_etoa+0x3a0>
7009b5f4: eeb4 0b41    	vcmp.f64	d0, d1
7009b5f8: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b5fc: dc0a         	bgt	0x7009b614 <_etoa+0x54> @ imm = #0x14
7009b5fe: e7ff         	b	0x7009b600 <_etoa+0x40> @ imm = #-0x2
7009b600: ed9d 0b20    	vldr	d0, [sp, #128]
7009b604: ed9f 1bd8    	vldr	d1, [pc, #864]          @ 0x7009b968 <_etoa+0x3a8>
7009b608: eeb4 0b41    	vcmp.f64	d0, d1
7009b60c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b610: d515         	bpl	0x7009b63e <_etoa+0x7e> @ imm = #0x2a
7009b612: e7ff         	b	0x7009b614 <_etoa+0x54> @ imm = #-0x2
;     return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
7009b614: 9826         	ldr	r0, [sp, #0x98]
7009b616: 9925         	ldr	r1, [sp, #0x94]
7009b618: 9a24         	ldr	r2, [sp, #0x90]
7009b61a: 9b23         	ldr	r3, [sp, #0x8c]
7009b61c: ed9d 0b20    	vldr	d0, [sp, #128]
7009b620: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009b624: 9c2d         	ldr	r4, [sp, #0xb4]
7009b626: 9d2e         	ldr	r5, [sp, #0xb8]
7009b628: 46ee         	mov	lr, sp
7009b62a: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b62e: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b632: f8ce c000    	str.w	r12, [lr]
7009b636: f7ff fd33    	bl	0x7009b0a0 <_ftoa>      @ imm = #-0x59a
7009b63a: 9027         	str	r0, [sp, #0x9c]
7009b63c: e1d8         	b	0x7009b9f0 <_etoa+0x430> @ imm = #0x3b0
;   const bool negative = value < 0;
7009b63e: ed9d 0b20    	vldr	d0, [sp, #128]
7009b642: f04f 0000    	mov.w	r0, #0x0
7009b646: eeb5 0b40    	vcmp.f64	d0, #0
7009b64a: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b64e: bf48         	it	mi
7009b650: 2001         	movmi	r0, #0x1
7009b652: f88d 007f    	strb.w	r0, [sp, #0x7f]
;   if (negative) {
7009b656: f89d 007f    	ldrb.w	r0, [sp, #0x7f]
7009b65a: ea4f 70c0    	lsl.w	r0, r0, #0x1f
7009b65e: b138         	cbz	r0, 0x7009b670 <_etoa+0xb0> @ imm = #0xe
7009b660: e7ff         	b	0x7009b662 <_etoa+0xa2> @ imm = #-0x2
;     value = -value;
7009b662: ed9d 0b20    	vldr	d0, [sp, #128]
7009b666: eeb1 0b40    	vneg.f64	d0, d0
7009b66a: ed8d 0b20    	vstr	d0, [sp, #128]
;   }
7009b66e: e7ff         	b	0x7009b670 <_etoa+0xb0> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION)) {
7009b670: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009b674: 0740         	lsls	r0, r0, #0x1d
7009b676: 2800         	cmp	r0, #0x0
7009b678: d403         	bmi	0x7009b682 <_etoa+0xc2> @ imm = #0x6
7009b67a: e7ff         	b	0x7009b67c <_etoa+0xbc> @ imm = #-0x2
7009b67c: 2006         	movs	r0, #0x6
;     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
7009b67e: 902c         	str	r0, [sp, #0xb0]
;   }
7009b680: e7ff         	b	0x7009b682 <_etoa+0xc2> @ imm = #-0x2
;   conv.F = value;
7009b682: ed9d 0b20    	vldr	d0, [sp, #128]
7009b686: ed8d 0b1c    	vstr	d0, [sp, #112]
;   int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
7009b68a: 981d         	ldr	r0, [sp, #0x74]
7009b68c: f3c0 500a    	ubfx	r0, r0, #0x14, #0xb
7009b690: f2a0 30ff    	subw	r0, r0, #0x3ff
7009b694: 901b         	str	r0, [sp, #0x6c]
;   conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
7009b696: 981d         	ldr	r0, [sp, #0x74]
7009b698: f240 31ff    	movw	r1, #0x3ff
7009b69c: f361 501f    	bfi	r0, r1, #20, #12
7009b6a0: 901d         	str	r0, [sp, #0x74]
;   int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
7009b6a2: ed9d 0a1b    	vldr	s0, [sp, #108]
7009b6a6: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009b6aa: ed9f 1bd3    	vldr	d1, [pc, #844]          @ 0x7009b9f8 <_etoa+0x438>
7009b6ae: ee20 0b01    	vmul.f64	d0, d0, d1
7009b6b2: ed9f 1bd3    	vldr	d1, [pc, #844]          @ 0x7009ba00 <_etoa+0x440>
7009b6b6: ee30 1b01    	vadd.f64	d1, d0, d1
7009b6ba: ed9d 0b1c    	vldr	d0, [sp, #112]
7009b6be: eebf 2b08    	vmov.f64	d2, #-1.500000e+00
7009b6c2: ee30 0b02    	vadd.f64	d0, d0, d2
7009b6c6: ed9f 2bd0    	vldr	d2, [pc, #832]          @ 0x7009ba08 <_etoa+0x448>
7009b6ca: ee20 0b02    	vmul.f64	d0, d0, d2
7009b6ce: ee30 0b01    	vadd.f64	d0, d0, d1
7009b6d2: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009b6d6: ed8d 0a1a    	vstr	s0, [sp, #104]
;   exp2 = (int)(expval * 3.321928094887362 + 0.5);
7009b6da: ed9d 0a1a    	vldr	s0, [sp, #104]
7009b6de: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009b6e2: ed9f 1bcb    	vldr	d1, [pc, #812]          @ 0x7009ba10 <_etoa+0x450>
7009b6e6: ee20 0b01    	vmul.f64	d0, d0, d1
7009b6ea: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b6ee: ee30 0b01    	vadd.f64	d0, d0, d1
7009b6f2: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009b6f6: ed8d 0a1b    	vstr	s0, [sp, #108]
;   const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
7009b6fa: ed9d 0a1a    	vldr	s0, [sp, #104]
7009b6fe: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009b702: ed9d 1a1b    	vldr	s2, [sp, #108]
7009b706: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009b70a: ed9f 2bc3    	vldr	d2, [pc, #780]          @ 0x7009ba18 <_etoa+0x458>
7009b70e: ee21 1b02    	vmul.f64	d1, d1, d2
7009b712: ed9f 2bc3    	vldr	d2, [pc, #780]          @ 0x7009ba20 <_etoa+0x460>
7009b716: ee20 0b02    	vmul.f64	d0, d0, d2
7009b71a: ee30 0b01    	vadd.f64	d0, d0, d1
7009b71e: ed8d 0b18    	vstr	d0, [sp, #96]
;   const double z2 = z * z;
7009b722: ed9d 0b18    	vldr	d0, [sp, #96]
7009b726: ee20 0b00    	vmul.f64	d0, d0, d0
7009b72a: ed8d 0b16    	vstr	d0, [sp, #88]
;   conv.U = (uint64_t)(exp2 + 1023) << 52U;
7009b72e: 981b         	ldr	r0, [sp, #0x6c]
7009b730: f200 30ff    	addw	r0, r0, #0x3ff
7009b734: 0500         	lsls	r0, r0, #0x14
7009b736: 2100         	movs	r1, #0x0
7009b738: 911c         	str	r1, [sp, #0x70]
7009b73a: 901d         	str	r0, [sp, #0x74]
;   conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
7009b73c: ed9d 2b18    	vldr	d2, [sp, #96]
7009b740: ee32 0b02    	vadd.f64	d0, d2, d2
7009b744: eeb0 1b00    	vmov.f64	d1, #2.000000e+00
7009b748: ee31 1b42    	vsub.f64	d1, d1, d2
7009b74c: ed9d 2b16    	vldr	d2, [sp, #88]
7009b750: eeb2 3b0c    	vmov.f64	d3, #1.400000e+01
7009b754: ee82 3b03    	vdiv.f64	d3, d2, d3
7009b758: eeb2 4b04    	vmov.f64	d4, #1.000000e+01
7009b75c: ee33 3b04    	vadd.f64	d3, d3, d4
7009b760: ee82 3b03    	vdiv.f64	d3, d2, d3
7009b764: eeb1 4b08    	vmov.f64	d4, #6.000000e+00
7009b768: ee33 3b04    	vadd.f64	d3, d3, d4
7009b76c: ee82 2b03    	vdiv.f64	d2, d2, d3
7009b770: ee31 1b02    	vadd.f64	d1, d1, d2
7009b774: ee80 0b01    	vdiv.f64	d0, d0, d1
7009b778: eeb7 1b00    	vmov.f64	d1, #1.000000e+00
7009b77c: ee30 1b01    	vadd.f64	d1, d0, d1
7009b780: ed9d 0b1c    	vldr	d0, [sp, #112]
7009b784: ee20 0b01    	vmul.f64	d0, d0, d1
7009b788: ed8d 0b1c    	vstr	d0, [sp, #112]
;   if (value < conv.F) {
7009b78c: ed9d 0b20    	vldr	d0, [sp, #128]
7009b790: ed9d 1b1c    	vldr	d1, [sp, #112]
7009b794: eeb4 0b41    	vcmp.f64	d0, d1
7009b798: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b79c: d50c         	bpl	0x7009b7b8 <_etoa+0x1f8> @ imm = #0x18
7009b79e: e7ff         	b	0x7009b7a0 <_etoa+0x1e0> @ imm = #-0x2
;     expval--;
7009b7a0: 981a         	ldr	r0, [sp, #0x68]
7009b7a2: 3801         	subs	r0, #0x1
7009b7a4: 901a         	str	r0, [sp, #0x68]
;     conv.F /= 10;
7009b7a6: ed9d 0b1c    	vldr	d0, [sp, #112]
7009b7aa: eeb2 1b04    	vmov.f64	d1, #1.000000e+01
7009b7ae: ee80 0b01    	vdiv.f64	d0, d0, d1
7009b7b2: ed8d 0b1c    	vstr	d0, [sp, #112]
;   }
7009b7b6: e7ff         	b	0x7009b7b8 <_etoa+0x1f8> @ imm = #-0x2
;   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
7009b7b8: 991a         	ldr	r1, [sp, #0x68]
7009b7ba: f04f 0000    	mov.w	r0, #0x0
7009b7be: 2963         	cmp	r1, #0x63
7009b7c0: 9012         	str	r0, [sp, #0x48]
7009b7c2: dc08         	bgt	0x7009b7d6 <_etoa+0x216> @ imm = #0x10
7009b7c4: e7ff         	b	0x7009b7c6 <_etoa+0x206> @ imm = #-0x2
7009b7c6: 991a         	ldr	r1, [sp, #0x68]
7009b7c8: 2000         	movs	r0, #0x0
7009b7ca: f111 0f64    	cmn.w	r1, #0x64
7009b7ce: bfc8         	it	gt
7009b7d0: 2001         	movgt	r0, #0x1
7009b7d2: 9012         	str	r0, [sp, #0x48]
7009b7d4: e7ff         	b	0x7009b7d6 <_etoa+0x216> @ imm = #-0x2
7009b7d6: 9812         	ldr	r0, [sp, #0x48]
;   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
7009b7d8: 07c1         	lsls	r1, r0, #0x1f
7009b7da: 2005         	movs	r0, #0x5
7009b7dc: 2900         	cmp	r1, #0x0
7009b7de: bf18         	it	ne
7009b7e0: 2004         	movne	r0, #0x4
7009b7e2: 9015         	str	r0, [sp, #0x54]
;   if (flags & FLAGS_ADAPT_EXP) {
7009b7e4: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009b7e8: ea4f 7000    	lsl.w	r0, r0, #0x1c
7009b7ec: 2800         	cmp	r0, #0x0
7009b7ee: d539         	bpl	0x7009b864 <_etoa+0x2a4> @ imm = #0x72
7009b7f0: e7ff         	b	0x7009b7f2 <_etoa+0x232> @ imm = #-0x2
;     if ((value >= 1e-4) && (value < 1e6)) {
7009b7f2: ed9d 0b20    	vldr	d0, [sp, #128]
7009b7f6: ed9f 1b8c    	vldr	d1, [pc, #560]          @ 0x7009ba28 <_etoa+0x468>
7009b7fa: eeb4 0b41    	vcmp.f64	d0, d1
7009b7fe: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b802: db20         	blt	0x7009b846 <_etoa+0x286> @ imm = #0x40
7009b804: e7ff         	b	0x7009b806 <_etoa+0x246> @ imm = #-0x2
7009b806: ed9d 0b20    	vldr	d0, [sp, #128]
7009b80a: ed9f 1b89    	vldr	d1, [pc, #548]          @ 0x7009ba30 <_etoa+0x470>
7009b80e: eeb4 0b41    	vcmp.f64	d0, d1
7009b812: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b816: d516         	bpl	0x7009b846 <_etoa+0x286> @ imm = #0x2c
7009b818: e7ff         	b	0x7009b81a <_etoa+0x25a> @ imm = #-0x2
;       if ((int)prec > expval) {
7009b81a: 982c         	ldr	r0, [sp, #0xb0]
7009b81c: 991a         	ldr	r1, [sp, #0x68]
7009b81e: 4288         	cmp	r0, r1
7009b820: dd06         	ble	0x7009b830 <_etoa+0x270> @ imm = #0xc
7009b822: e7ff         	b	0x7009b824 <_etoa+0x264> @ imm = #-0x2
;         prec = (unsigned)((int)prec - expval - 1);
7009b824: 992c         	ldr	r1, [sp, #0xb0]
7009b826: 981a         	ldr	r0, [sp, #0x68]
7009b828: 43c0         	mvns	r0, r0
7009b82a: 4408         	add	r0, r1
7009b82c: 902c         	str	r0, [sp, #0xb0]
;       }
7009b82e: e002         	b	0x7009b836 <_etoa+0x276> @ imm = #0x4
7009b830: 2000         	movs	r0, #0x0
;         prec = 0;
7009b832: 902c         	str	r0, [sp, #0xb0]
7009b834: e7ff         	b	0x7009b836 <_etoa+0x276> @ imm = #-0x2
;       flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
7009b836: 982e         	ldr	r0, [sp, #0xb8]
7009b838: f440 6080    	orr	r0, r0, #0x400
7009b83c: 902e         	str	r0, [sp, #0xb8]
7009b83e: 2000         	movs	r0, #0x0
;       minwidth = 0U;
7009b840: 9015         	str	r0, [sp, #0x54]
;       expval   = 0;
7009b842: 901a         	str	r0, [sp, #0x68]
;     }
7009b844: e00d         	b	0x7009b862 <_etoa+0x2a2> @ imm = #0x1a
;       if ((prec > 0) && (flags & FLAGS_PRECISION)) {
7009b846: 982c         	ldr	r0, [sp, #0xb0]
7009b848: b150         	cbz	r0, 0x7009b860 <_etoa+0x2a0> @ imm = #0x14
7009b84a: e7ff         	b	0x7009b84c <_etoa+0x28c> @ imm = #-0x2
7009b84c: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009b850: 0740         	lsls	r0, r0, #0x1d
7009b852: 2800         	cmp	r0, #0x0
7009b854: d504         	bpl	0x7009b860 <_etoa+0x2a0> @ imm = #0x8
7009b856: e7ff         	b	0x7009b858 <_etoa+0x298> @ imm = #-0x2
;         --prec;
7009b858: 982c         	ldr	r0, [sp, #0xb0]
7009b85a: 3801         	subs	r0, #0x1
7009b85c: 902c         	str	r0, [sp, #0xb0]
;       }
7009b85e: e7ff         	b	0x7009b860 <_etoa+0x2a0> @ imm = #-0x2
7009b860: e7ff         	b	0x7009b862 <_etoa+0x2a2> @ imm = #-0x2
;   }
7009b862: e7ff         	b	0x7009b864 <_etoa+0x2a4> @ imm = #-0x2
;   unsigned int fwidth = width;
7009b864: 982d         	ldr	r0, [sp, #0xb4]
7009b866: 9014         	str	r0, [sp, #0x50]
;   if (width > minwidth) {
7009b868: 982d         	ldr	r0, [sp, #0xb4]
7009b86a: 9915         	ldr	r1, [sp, #0x54]
7009b86c: 4288         	cmp	r0, r1
7009b86e: d905         	bls	0x7009b87c <_etoa+0x2bc> @ imm = #0xa
7009b870: e7ff         	b	0x7009b872 <_etoa+0x2b2> @ imm = #-0x2
;     fwidth -= minwidth;
7009b872: 9915         	ldr	r1, [sp, #0x54]
7009b874: 9814         	ldr	r0, [sp, #0x50]
7009b876: 1a40         	subs	r0, r0, r1
7009b878: 9014         	str	r0, [sp, #0x50]
;   } else {
7009b87a: e002         	b	0x7009b882 <_etoa+0x2c2> @ imm = #0x4
7009b87c: 2000         	movs	r0, #0x0
;     fwidth = 0U;
7009b87e: 9014         	str	r0, [sp, #0x50]
7009b880: e7ff         	b	0x7009b882 <_etoa+0x2c2> @ imm = #-0x2
;   if ((flags & FLAGS_LEFT) && minwidth) {
7009b882: f89d 00b8    	ldrb.w	r0, [sp, #0xb8]
7009b886: 0780         	lsls	r0, r0, #0x1e
7009b888: 2800         	cmp	r0, #0x0
7009b88a: d506         	bpl	0x7009b89a <_etoa+0x2da> @ imm = #0xc
7009b88c: e7ff         	b	0x7009b88e <_etoa+0x2ce> @ imm = #-0x2
7009b88e: 9815         	ldr	r0, [sp, #0x54]
7009b890: b118         	cbz	r0, 0x7009b89a <_etoa+0x2da> @ imm = #0x6
7009b892: e7ff         	b	0x7009b894 <_etoa+0x2d4> @ imm = #-0x2
7009b894: 2000         	movs	r0, #0x0
;     fwidth = 0U;
7009b896: 9014         	str	r0, [sp, #0x50]
;   }
7009b898: e7ff         	b	0x7009b89a <_etoa+0x2da> @ imm = #-0x2
;   if (expval) {
7009b89a: 981a         	ldr	r0, [sp, #0x68]
7009b89c: b148         	cbz	r0, 0x7009b8b2 <_etoa+0x2f2> @ imm = #0x12
7009b89e: e7ff         	b	0x7009b8a0 <_etoa+0x2e0> @ imm = #-0x2
;     value /= conv.F;
7009b8a0: ed9d 1b1c    	vldr	d1, [sp, #112]
7009b8a4: ed9d 0b20    	vldr	d0, [sp, #128]
7009b8a8: ee80 0b01    	vdiv.f64	d0, d0, d1
7009b8ac: ed8d 0b20    	vstr	d0, [sp, #128]
;   }
7009b8b0: e7ff         	b	0x7009b8b2 <_etoa+0x2f2> @ imm = #-0x2
;   const size_t start_idx = idx;
7009b8b2: 9824         	ldr	r0, [sp, #0x90]
7009b8b4: 9013         	str	r0, [sp, #0x4c]
;   idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
7009b8b6: 9826         	ldr	r0, [sp, #0x98]
7009b8b8: 900e         	str	r0, [sp, #0x38]
7009b8ba: 9825         	ldr	r0, [sp, #0x94]
7009b8bc: 900f         	str	r0, [sp, #0x3c]
7009b8be: 9824         	ldr	r0, [sp, #0x90]
7009b8c0: 9010         	str	r0, [sp, #0x40]
7009b8c2: 9823         	ldr	r0, [sp, #0x8c]
7009b8c4: 9011         	str	r0, [sp, #0x44]
7009b8c6: f89d 007f    	ldrb.w	r0, [sp, #0x7f]
7009b8ca: 07c0         	lsls	r0, r0, #0x1f
7009b8cc: b138         	cbz	r0, 0x7009b8de <_etoa+0x31e> @ imm = #0xe
7009b8ce: e7ff         	b	0x7009b8d0 <_etoa+0x310> @ imm = #-0x2
7009b8d0: ed9d 0b20    	vldr	d0, [sp, #128]
7009b8d4: eeb1 0b40    	vneg.f64	d0, d0
7009b8d8: ed8d 0b0c    	vstr	d0, [sp, #48]
7009b8dc: e004         	b	0x7009b8e8 <_etoa+0x328> @ imm = #0x8
7009b8de: ed9d 0b20    	vldr	d0, [sp, #128]
7009b8e2: ed8d 0b0c    	vstr	d0, [sp, #48]
7009b8e6: e7ff         	b	0x7009b8e8 <_etoa+0x328> @ imm = #-0x2
7009b8e8: 9b11         	ldr	r3, [sp, #0x44]
7009b8ea: 9a10         	ldr	r2, [sp, #0x40]
7009b8ec: 990f         	ldr	r1, [sp, #0x3c]
7009b8ee: 980e         	ldr	r0, [sp, #0x38]
7009b8f0: ed9d 0b0c    	vldr	d0, [sp, #48]
7009b8f4: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009b8f8: 9c14         	ldr	r4, [sp, #0x50]
7009b8fa: f8dd e0b8    	ldr.w	lr, [sp, #0xb8]
7009b8fe: f42e 6500    	bic	r5, lr, #0x800
7009b902: 46ee         	mov	lr, sp
7009b904: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b908: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b90c: f8ce c000    	str.w	r12, [lr]
7009b910: f7ff fbc6    	bl	0x7009b0a0 <_ftoa>      @ imm = #-0x874
7009b914: 9024         	str	r0, [sp, #0x90]
;   if (minwidth) {
7009b916: 9815         	ldr	r0, [sp, #0x54]
7009b918: 2800         	cmp	r0, #0x0
7009b91a: d066         	beq	0x7009b9ea <_etoa+0x42a> @ imm = #0xcc
7009b91c: e7ff         	b	0x7009b91e <_etoa+0x35e> @ imm = #-0x2
;     out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
7009b91e: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009b922: 982e         	ldr	r0, [sp, #0xb8]
7009b924: 0681         	lsls	r1, r0, #0x1a
7009b926: 2065         	movs	r0, #0x65
7009b928: 2900         	cmp	r1, #0x0
7009b92a: bf48         	it	mi
7009b92c: 2045         	movmi	r0, #0x45
7009b92e: 9925         	ldr	r1, [sp, #0x94]
7009b930: 9a24         	ldr	r2, [sp, #0x90]
7009b932: 1c53         	adds	r3, r2, #0x1
7009b934: 9324         	str	r3, [sp, #0x90]
7009b936: 9b23         	ldr	r3, [sp, #0x8c]
7009b938: 47e0         	blx	r12
;     idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
7009b93a: 9826         	ldr	r0, [sp, #0x98]
7009b93c: 9008         	str	r0, [sp, #0x20]
7009b93e: 9825         	ldr	r0, [sp, #0x94]
7009b940: 9009         	str	r0, [sp, #0x24]
7009b942: 9824         	ldr	r0, [sp, #0x90]
7009b944: 900a         	str	r0, [sp, #0x28]
7009b946: 9823         	ldr	r0, [sp, #0x8c]
7009b948: 900b         	str	r0, [sp, #0x2c]
7009b94a: 981a         	ldr	r0, [sp, #0x68]
7009b94c: f1b0 3fff    	cmp.w	r0, #0xffffffff
7009b950: dc0e         	bgt	0x7009b970 <_etoa+0x3b0> @ imm = #0x1c
7009b952: e7ff         	b	0x7009b954 <_etoa+0x394> @ imm = #-0x2
7009b954: 981a         	ldr	r0, [sp, #0x68]
7009b956: 4240         	rsbs	r0, r0, #0
7009b958: 9007         	str	r0, [sp, #0x1c]
7009b95a: e00c         	b	0x7009b976 <_etoa+0x3b6> @ imm = #0x18
7009b95c: bf00         	nop
7009b95e: bf00         	nop
7009b960: ff ff ff ff  	.word	0xffffffff
7009b964: ff ff ef 7f  	.word	0x7fefffff
7009b968: ff ff ff ff  	.word	0xffffffff
7009b96c: ff ff ef ff  	.word	0xffefffff
7009b970: 981a         	ldr	r0, [sp, #0x68]
7009b972: 9007         	str	r0, [sp, #0x1c]
7009b974: e7ff         	b	0x7009b976 <_etoa+0x3b6> @ imm = #-0x2
7009b976: 9b0b         	ldr	r3, [sp, #0x2c]
7009b978: 9a0a         	ldr	r2, [sp, #0x28]
7009b97a: 9909         	ldr	r1, [sp, #0x24]
7009b97c: 9808         	ldr	r0, [sp, #0x20]
7009b97e: f8dd c01c    	ldr.w	r12, [sp, #0x1c]
7009b982: 9c1a         	ldr	r4, [sp, #0x68]
7009b984: f8dd e054    	ldr.w	lr, [sp, #0x54]
7009b988: f1ae 0501    	sub.w	r5, lr, #0x1
7009b98c: 46ee         	mov	lr, sp
7009b98e: 2605         	movs	r6, #0x5
7009b990: f8ce 6014    	str.w	r6, [lr, #0x14]
7009b994: f8ce 5010    	str.w	r5, [lr, #0x10]
7009b998: 2500         	movs	r5, #0x0
7009b99a: f8ce 500c    	str.w	r5, [lr, #0xc]
7009b99e: 250a         	movs	r5, #0xa
7009b9a0: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b9a4: ea4f 74d4    	lsr.w	r4, r4, #0x1f
7009b9a8: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b9ac: f8ce c000    	str.w	r12, [lr]
7009b9b0: f009 f866    	bl	0x700a4a80 <_ntoa_long> @ imm = #0x90cc
7009b9b4: 9024         	str	r0, [sp, #0x90]
;     if (flags & FLAGS_LEFT) {
7009b9b6: f89d 00b8    	ldrb.w	r0, [sp, #0xb8]
7009b9ba: 0780         	lsls	r0, r0, #0x1e
7009b9bc: 2800         	cmp	r0, #0x0
7009b9be: d513         	bpl	0x7009b9e8 <_etoa+0x428> @ imm = #0x26
7009b9c0: e7ff         	b	0x7009b9c2 <_etoa+0x402> @ imm = #-0x2
;       while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
7009b9c2: e7ff         	b	0x7009b9c4 <_etoa+0x404> @ imm = #-0x2
7009b9c4: 9824         	ldr	r0, [sp, #0x90]
7009b9c6: 9913         	ldr	r1, [sp, #0x4c]
7009b9c8: 1a40         	subs	r0, r0, r1
7009b9ca: 992d         	ldr	r1, [sp, #0xb4]
7009b9cc: 4288         	cmp	r0, r1
7009b9ce: d20a         	bhs	0x7009b9e6 <_etoa+0x426> @ imm = #0x14
7009b9d0: e7ff         	b	0x7009b9d2 <_etoa+0x412> @ imm = #-0x2
7009b9d2: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009b9d6: 9925         	ldr	r1, [sp, #0x94]
7009b9d8: 9a24         	ldr	r2, [sp, #0x90]
7009b9da: 1c50         	adds	r0, r2, #0x1
7009b9dc: 9024         	str	r0, [sp, #0x90]
7009b9de: 9b23         	ldr	r3, [sp, #0x8c]
7009b9e0: 2020         	movs	r0, #0x20
7009b9e2: 47e0         	blx	r12
7009b9e4: e7ee         	b	0x7009b9c4 <_etoa+0x404> @ imm = #-0x24
;     }
7009b9e6: e7ff         	b	0x7009b9e8 <_etoa+0x428> @ imm = #-0x2
;   }
7009b9e8: e7ff         	b	0x7009b9ea <_etoa+0x42a> @ imm = #-0x2
;   return idx;
7009b9ea: 9824         	ldr	r0, [sp, #0x90]
7009b9ec: 9027         	str	r0, [sp, #0x9c]
7009b9ee: e7ff         	b	0x7009b9f0 <_etoa+0x430> @ imm = #-0x2
; }
7009b9f0: 9827         	ldr	r0, [sp, #0x9c]
7009b9f2: b028         	add	sp, #0xa0
7009b9f4: bd70         	pop	{r4, r5, r6, pc}
7009b9f6: bf00         	nop
7009b9f8: fb 79 9f 50  	.word	0x509f79fb
7009b9fc: 13 44 d3 3f  	.word	0x3fd34413
7009ba00: b3 c8 60 8b  	.word	0x8b60c8b3
7009ba04: 28 8a c6 3f  	.word	0x3fc68a28
7009ba08: 61 43 6f 63  	.word	0x636f4361
7009ba0c: a7 87 d2 3f  	.word	0x3fd287a7
7009ba10: 71 a3 79 09  	.word	0x0979a371
7009ba14: 4f 93 0a 40  	.word	0x400a934f
7009ba18: ef 39 fa fe  	.word	0xfefa39ef
7009ba1c: 42 2e e6 bf  	.word	0xbfe62e42
7009ba20: 16 55 b5 bb  	.word	0xbbb55516
7009ba24: b1 6b 02 40  	.word	0x40026bb1
7009ba28: 2d 43 1c eb  	.word	0xeb1c432d
7009ba2c: e2 36 1a 3f  	.word	0x3f1a36e2
7009ba30: 00 00 00 00  	.word	0x00000000
7009ba34: 80 84 2e 41  	.word	0x412e8480

7009ba38 <_nop>:
7009ba38: e12fff1e     	bx	lr
7009ba3c: 00000000     	andeq	r0, r0, r0

7009ba40 <UART_open>:
; {
7009ba40: b580         	push	{r7, lr}
7009ba42: b092         	sub	sp, #0x48
7009ba44: 9011         	str	r0, [sp, #0x44]
7009ba46: 9110         	str	r1, [sp, #0x40]
7009ba48: 2000         	movs	r0, #0x0
;     int32_t             status = SystemP_SUCCESS;
7009ba4a: 900f         	str	r0, [sp, #0x3c]
;     UART_Handle         handle = NULL;
7009ba4c: 900e         	str	r0, [sp, #0x38]
;     UART_Config        *config = NULL;
7009ba4e: 900d         	str	r0, [sp, #0x34]
;     UART_Object        *object    = NULL;
7009ba50: 900c         	str	r0, [sp, #0x30]
;     if(index >= gUartConfigNum)
7009ba52: 9811         	ldr	r0, [sp, #0x44]
7009ba54: f242 61ac    	movw	r1, #0x26ac
7009ba58: f2c7 010b    	movt	r1, #0x700b
7009ba5c: 6809         	ldr	r1, [r1]
7009ba5e: 4288         	cmp	r0, r1
7009ba60: d304         	blo	0x7009ba6c <UART_open+0x2c> @ imm = #0x8
7009ba62: e7ff         	b	0x7009ba64 <UART_open+0x24> @ imm = #-0x2
7009ba64: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009ba68: 900f         	str	r0, [sp, #0x3c]
;     }
7009ba6a: e008         	b	0x7009ba7e <UART_open+0x3e> @ imm = #0x10
;         config = &gUartConfig[index];
7009ba6c: 9911         	ldr	r1, [sp, #0x44]
7009ba6e: f242 6064    	movw	r0, #0x2664
7009ba72: f2c7 000b    	movt	r0, #0x700b
7009ba76: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009ba7a: 900d         	str	r0, [sp, #0x34]
7009ba7c: e7ff         	b	0x7009ba7e <UART_open+0x3e> @ imm = #-0x2
;     DebugP_assert(NULL_PTR != gUartDrvObj.lock);
7009ba7e: f242 31e8    	movw	r1, #0x23e8
7009ba82: f2c7 010b    	movt	r1, #0x700b
7009ba86: f851 0b04    	ldr	r0, [r1], #4
7009ba8a: 9103         	str	r1, [sp, #0xc]
7009ba8c: 2800         	cmp	r0, #0x0
7009ba8e: bf18         	it	ne
7009ba90: 2001         	movne	r0, #0x1
7009ba92: f641 21a4    	movw	r1, #0x1aa4
7009ba96: f2c7 010b    	movt	r1, #0x700b
7009ba9a: 466a         	mov	r2, sp
7009ba9c: 6011         	str	r1, [r2]
7009ba9e: f641 41c5    	movw	r1, #0x1cc5
7009baa2: f2c7 010b    	movt	r1, #0x700b
7009baa6: f641 6220    	movw	r2, #0x1e20
7009baaa: f2c7 020b    	movt	r2, #0x700b
7009baae: f240 1301    	movw	r3, #0x101
7009bab2: f00e ffbd    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xef7a
7009bab6: 9803         	ldr	r0, [sp, #0xc]
7009bab8: f04f 31ff    	mov.w	r1, #0xffffffff
;     (void)SemaphoreP_pend(&gUartDrvObj.lockObj, SystemP_WAIT_FOREVER);
7009babc: f00e fd60    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0xeac0
;     if(SystemP_SUCCESS  == status)
7009bac0: 980f         	ldr	r0, [sp, #0x3c]
7009bac2: bb38         	cbnz	r0, 0x7009bb14 <UART_open+0xd4> @ imm = #0x4e
7009bac4: e7ff         	b	0x7009bac6 <UART_open+0x86> @ imm = #-0x2
;         object = config->object;
7009bac6: 980d         	ldr	r0, [sp, #0x34]
7009bac8: 6840         	ldr	r0, [r0, #0x4]
7009baca: 900c         	str	r0, [sp, #0x30]
;         attrs  = config->attrs;
7009bacc: 980d         	ldr	r0, [sp, #0x34]
7009bace: 6800         	ldr	r0, [r0]
7009bad0: 900b         	str	r0, [sp, #0x2c]
;         DebugP_assert(NULL_PTR != object);
7009bad2: 980c         	ldr	r0, [sp, #0x30]
7009bad4: 2800         	cmp	r0, #0x0
7009bad6: bf18         	it	ne
7009bad8: 2001         	movne	r0, #0x1
7009bada: f641 41b2    	movw	r1, #0x1cb2
7009bade: f2c7 010b    	movt	r1, #0x700b
7009bae2: 466a         	mov	r2, sp
7009bae4: 6011         	str	r1, [r2]
7009bae6: f641 41c5    	movw	r1, #0x1cc5
7009baea: f2c7 010b    	movt	r1, #0x700b
7009baee: f641 6220    	movw	r2, #0x1e20
7009baf2: f2c7 020b    	movt	r2, #0x700b
7009baf6: f44f 7384    	mov.w	r3, #0x108
7009bafa: f00e ff99    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xef32
;         if(TRUE == object->isOpen)
7009bafe: 980c         	ldr	r0, [sp, #0x30]
7009bb00: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009bb04: 2801         	cmp	r0, #0x1
7009bb06: d104         	bne	0x7009bb12 <UART_open+0xd2> @ imm = #0x8
7009bb08: e7ff         	b	0x7009bb0a <UART_open+0xca> @ imm = #-0x2
7009bb0a: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009bb0e: 900f         	str	r0, [sp, #0x3c]
;         }
7009bb10: e7ff         	b	0x7009bb12 <UART_open+0xd2> @ imm = #-0x2
;     }
7009bb12: e7ff         	b	0x7009bb14 <UART_open+0xd4> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009bb14: 980f         	ldr	r0, [sp, #0x3c]
7009bb16: 2800         	cmp	r0, #0x0
7009bb18: f040 80cd    	bne.w	0x7009bcb6 <UART_open+0x276> @ imm = #0x19a
7009bb1c: e7ff         	b	0x7009bb1e <UART_open+0xde> @ imm = #-0x2
;         object->handle = (UART_Handle) config;
7009bb1e: 980d         	ldr	r0, [sp, #0x34]
7009bb20: 990c         	ldr	r1, [sp, #0x30]
7009bb22: 6008         	str	r0, [r1]
;         if(NULL != prms)
7009bb24: 9810         	ldr	r0, [sp, #0x40]
7009bb26: b138         	cbz	r0, 0x7009bb38 <UART_open+0xf8> @ imm = #0xe
7009bb28: e7ff         	b	0x7009bb2a <UART_open+0xea> @ imm = #-0x2
;             ( void )memcpy(&object->prms, prms, sizeof(UART_Params));
7009bb2a: 980c         	ldr	r0, [sp, #0x30]
7009bb2c: 3004         	adds	r0, #0x4
7009bb2e: 9910         	ldr	r1, [sp, #0x40]
7009bb30: 2258         	movs	r2, #0x58
7009bb32: f7fe ea94    	blx	0x7009a05c <__aeabi_memcpy8> @ imm = #-0x1ad8
;         }
7009bb36: e004         	b	0x7009bb42 <UART_open+0x102> @ imm = #0x8
;             UART_Params_init(&object->prms);
7009bb38: 980c         	ldr	r0, [sp, #0x30]
7009bb3a: 3004         	adds	r0, #0x4
7009bb3c: f00e ffb8    	bl	0x700aaab0 <UART_Params_init> @ imm = #0xef70
7009bb40: e7ff         	b	0x7009bb42 <UART_open+0x102> @ imm = #-0x2
;         object->uartLld_handle             = &object->uartLld_object;
7009bb42: 990c         	ldr	r1, [sp, #0x30]
7009bb44: f501 7022    	add.w	r0, r1, #0x288
7009bb48: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;         uartLld_handle                     = object->uartLld_handle;
7009bb4c: 980c         	ldr	r0, [sp, #0x30]
7009bb4e: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009bb52: 9005         	str	r0, [sp, #0x14]
;         object->uartLld_initHandle         = &object->uartLld_initObject;
7009bb54: 990c         	ldr	r1, [sp, #0x30]
7009bb56: f501 7040    	add.w	r0, r1, #0x300
7009bb5a: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;         uartLldInit_handle                 = object->uartLld_initHandle;
7009bb5e: 980c         	ldr	r0, [sp, #0x30]
7009bb60: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
7009bb64: 9004         	str	r0, [sp, #0x10]
;         uartLld_handle->hUartInit          = uartLldInit_handle;
7009bb66: 9804         	ldr	r0, [sp, #0x10]
7009bb68: 9905         	ldr	r1, [sp, #0x14]
7009bb6a: 6048         	str	r0, [r1, #0x4]
;         uartLld_handle->baseAddr           = attrs->baseAddr;
7009bb6c: 980b         	ldr	r0, [sp, #0x2c]
7009bb6e: 6800         	ldr	r0, [r0]
7009bb70: 9905         	ldr	r1, [sp, #0x14]
7009bb72: 6008         	str	r0, [r1]
;         uartLld_handle->args               = (void *)object->handle;
7009bb74: 980c         	ldr	r0, [sp, #0x30]
7009bb76: 6800         	ldr	r0, [r0]
7009bb78: 9905         	ldr	r1, [sp, #0x14]
7009bb7a: 6608         	str	r0, [r1, #0x60]
;         uartLld_handle->writeBuf           = object->writeBuf;
7009bb7c: 980c         	ldr	r0, [sp, #0x30]
7009bb7e: 6dc0         	ldr	r0, [r0, #0x5c]
7009bb80: 9905         	ldr	r1, [sp, #0x14]
7009bb82: 6088         	str	r0, [r1, #0x8]
;         uartLld_handle->writeCount         = object->writeCount;
7009bb84: 980c         	ldr	r0, [sp, #0x30]
7009bb86: 6e00         	ldr	r0, [r0, #0x60]
7009bb88: 9905         	ldr	r1, [sp, #0x14]
7009bb8a: 60c8         	str	r0, [r1, #0xc]
;         uartLld_handle->writeSizeRemaining = object->writeSizeRemaining;
7009bb8c: 980c         	ldr	r0, [sp, #0x30]
7009bb8e: 6e40         	ldr	r0, [r0, #0x64]
7009bb90: 9905         	ldr	r1, [sp, #0x14]
7009bb92: 6108         	str	r0, [r1, #0x10]
;         uartLld_handle->readBuf            = object->readBuf;
7009bb94: 980c         	ldr	r0, [sp, #0x30]
7009bb96: 6e80         	ldr	r0, [r0, #0x68]
7009bb98: 9905         	ldr	r1, [sp, #0x14]
7009bb9a: 6148         	str	r0, [r1, #0x14]
;         uartLld_handle->readCount          = object->readCount;
7009bb9c: 980c         	ldr	r0, [sp, #0x30]
7009bb9e: 6ec0         	ldr	r0, [r0, #0x6c]
7009bba0: 9905         	ldr	r1, [sp, #0x14]
7009bba2: 6188         	str	r0, [r1, #0x18]
;         uartLld_handle->readSizeRemaining  = object->readSizeRemaining;
7009bba4: 980c         	ldr	r0, [sp, #0x30]
7009bba6: 6f00         	ldr	r0, [r0, #0x70]
7009bba8: 9905         	ldr	r1, [sp, #0x14]
7009bbaa: 61c8         	str	r0, [r1, #0x1c]
;         uartLld_handle->rxTimeoutCnt       = object->rxTimeoutCnt;
7009bbac: 980c         	ldr	r0, [sp, #0x30]
7009bbae: 6f40         	ldr	r0, [r0, #0x74]
7009bbb0: 9905         	ldr	r1, [sp, #0x14]
7009bbb2: 6208         	str	r0, [r1, #0x20]
;         uartLld_handle->readErrorCnt       = object->readErrorCnt;
7009bbb4: 980c         	ldr	r0, [sp, #0x30]
7009bbb6: 6f80         	ldr	r0, [r0, #0x78]
7009bbb8: 9905         	ldr	r1, [sp, #0x14]
7009bbba: 6248         	str	r0, [r1, #0x24]
;         uartLld_handle->state              = UART_STATE_RESET;
7009bbbc: 9905         	ldr	r1, [sp, #0x14]
7009bbbe: 2000         	movs	r0, #0x0
7009bbc0: 6548         	str	r0, [r1, #0x54]
;         uartLldInit_handle->inputClkFreq      = attrs->inputClkFreq;
7009bbc2: 990b         	ldr	r1, [sp, #0x2c]
7009bbc4: 6849         	ldr	r1, [r1, #0x4]
7009bbc6: 9a04         	ldr	r2, [sp, #0x10]
7009bbc8: 6011         	str	r1, [r2]
;         uartLldInit_handle->baudRate          = object->prms.baudRate;
7009bbca: 990c         	ldr	r1, [sp, #0x30]
7009bbcc: 6849         	ldr	r1, [r1, #0x4]
7009bbce: 9a04         	ldr	r2, [sp, #0x10]
7009bbd0: 6051         	str	r1, [r2, #0x4]
;         uartLldInit_handle->baudRate          = object->prms.baudRate;
7009bbd2: 990c         	ldr	r1, [sp, #0x30]
7009bbd4: 6849         	ldr	r1, [r1, #0x4]
7009bbd6: 9a04         	ldr	r2, [sp, #0x10]
7009bbd8: 6051         	str	r1, [r2, #0x4]
;         uartLldInit_handle->dataLength        = object->prms.dataLength;
7009bbda: 990c         	ldr	r1, [sp, #0x30]
7009bbdc: 6889         	ldr	r1, [r1, #0x8]
7009bbde: 9a04         	ldr	r2, [sp, #0x10]
7009bbe0: 6091         	str	r1, [r2, #0x8]
;         uartLldInit_handle->stopBits          = object->prms.stopBits;
7009bbe2: 990c         	ldr	r1, [sp, #0x30]
7009bbe4: 68c9         	ldr	r1, [r1, #0xc]
7009bbe6: 9a04         	ldr	r2, [sp, #0x10]
7009bbe8: 60d1         	str	r1, [r2, #0xc]
;         uartLldInit_handle->parityType        = object->prms.parityType;
7009bbea: 990c         	ldr	r1, [sp, #0x30]
7009bbec: 6909         	ldr	r1, [r1, #0x10]
7009bbee: 9a04         	ldr	r2, [sp, #0x10]
7009bbf0: 6111         	str	r1, [r2, #0x10]
;         uartLldInit_handle->readReturnMode    = object->prms.readReturnMode;
7009bbf2: 990c         	ldr	r1, [sp, #0x30]
7009bbf4: 6989         	ldr	r1, [r1, #0x18]
7009bbf6: 9a04         	ldr	r2, [sp, #0x10]
7009bbf8: 6151         	str	r1, [r2, #0x14]
;         uartLldInit_handle->hwFlowControl     = object->prms.hwFlowControl;
7009bbfa: 990c         	ldr	r1, [sp, #0x30]
7009bbfc: 6a89         	ldr	r1, [r1, #0x28]
7009bbfe: 9a04         	ldr	r2, [sp, #0x10]
7009bc00: 6191         	str	r1, [r2, #0x18]
;         uartLldInit_handle->hwFlowControlThr  = object->prms.hwFlowControlThr;
7009bc02: 990c         	ldr	r1, [sp, #0x30]
7009bc04: 6ac9         	ldr	r1, [r1, #0x2c]
7009bc06: 9a04         	ldr	r2, [sp, #0x10]
7009bc08: 61d1         	str	r1, [r2, #0x1c]
;         uartLldInit_handle->intrNum           = object->prms.intrNum;
7009bc0a: 990c         	ldr	r1, [sp, #0x30]
7009bc0c: 6b49         	ldr	r1, [r1, #0x34]
7009bc0e: 9a04         	ldr	r2, [sp, #0x10]
7009bc10: 6251         	str	r1, [r2, #0x24]
;         uartLldInit_handle->transferMode      = object->prms.transferMode;
7009bc12: 990c         	ldr	r1, [sp, #0x30]
7009bc14: 6b09         	ldr	r1, [r1, #0x30]
7009bc16: 9a04         	ldr	r2, [sp, #0x10]
7009bc18: 6211         	str	r1, [r2, #0x20]
;         uartLldInit_handle->intrPriority      = object->prms.intrPriority;
7009bc1a: 990c         	ldr	r1, [sp, #0x30]
7009bc1c: f891 1038    	ldrb.w	r1, [r1, #0x38]
7009bc20: 9a04         	ldr	r2, [sp, #0x10]
7009bc22: f882 1028    	strb.w	r1, [r2, #0x28]
;         uartLldInit_handle->operMode          = object->prms.operMode;
7009bc26: 990c         	ldr	r1, [sp, #0x30]
7009bc28: 6c49         	ldr	r1, [r1, #0x44]
7009bc2a: 9a04         	ldr	r2, [sp, #0x10]
7009bc2c: 62d1         	str	r1, [r2, #0x2c]
;         uartLldInit_handle->rxTrigLvl         = object->prms.rxTrigLvl;
7009bc2e: 990c         	ldr	r1, [sp, #0x30]
7009bc30: 6c89         	ldr	r1, [r1, #0x48]
7009bc32: 9a04         	ldr	r2, [sp, #0x10]
7009bc34: 6391         	str	r1, [r2, #0x38]
;         uartLldInit_handle->txTrigLvl         = object->prms.txTrigLvl;
7009bc36: 990c         	ldr	r1, [sp, #0x30]
7009bc38: 6cc9         	ldr	r1, [r1, #0x4c]
7009bc3a: 9a04         	ldr	r2, [sp, #0x10]
7009bc3c: 63d1         	str	r1, [r2, #0x3c]
;         uartLldInit_handle->uartDmaHandle     = NULL;
7009bc3e: 9904         	ldr	r1, [sp, #0x10]
7009bc40: 6488         	str	r0, [r1, #0x48]
;         uartLldInit_handle->dmaChCfg          = NULL;
7009bc42: 9904         	ldr	r1, [sp, #0x10]
7009bc44: 64c8         	str	r0, [r1, #0x4c]
;         uartLldInit_handle->rxEvtNum          = object->prms.rxEvtNum;
7009bc46: 980c         	ldr	r0, [sp, #0x30]
7009bc48: 6d00         	ldr	r0, [r0, #0x50]
7009bc4a: 9904         	ldr	r1, [sp, #0x10]
7009bc4c: 6408         	str	r0, [r1, #0x40]
;         uartLldInit_handle->txEvtNum          = object->prms.txEvtNum;
7009bc4e: 980c         	ldr	r0, [sp, #0x30]
7009bc50: 6d40         	ldr	r0, [r0, #0x54]
7009bc52: 9904         	ldr	r1, [sp, #0x10]
7009bc54: 6448         	str	r0, [r1, #0x44]
;         uartLldInit_handle->writeMode         = object->prms.writeMode;
7009bc56: 980c         	ldr	r0, [sp, #0x30]
7009bc58: 69c0         	ldr	r0, [r0, #0x1c]
7009bc5a: 9904         	ldr	r1, [sp, #0x10]
7009bc5c: 6348         	str	r0, [r1, #0x34]
;         uartLldInit_handle->readMode          = object->prms.readMode;
7009bc5e: 980c         	ldr	r0, [sp, #0x30]
7009bc60: 6940         	ldr	r0, [r0, #0x14]
7009bc62: 9904         	ldr	r1, [sp, #0x10]
7009bc64: 6308         	str	r0, [r1, #0x30]
;         uartLldInit_handle->timeGuardVal      = object->prms.timeGuardVal;
7009bc66: 980c         	ldr	r0, [sp, #0x30]
7009bc68: 6d80         	ldr	r0, [r0, #0x58]
7009bc6a: 9904         	ldr	r1, [sp, #0x10]
7009bc6c: 6508         	str	r0, [r1, #0x50]
;         uartLldInit_handle->clockP_get        = ClockP_getTicks;
7009bc6e: 9904         	ldr	r1, [sp, #0x10]
7009bc70: f64f 10e1    	movw	r0, #0xf9e1
7009bc74: f2c7 000a    	movt	r0, #0x700a
7009bc78: 6548         	str	r0, [r1, #0x54]
;         uartLldInit_handle->clockP_usecToTick = ClockP_usecToTicks;
7009bc7a: 9904         	ldr	r1, [sp, #0x10]
7009bc7c: f24f 0051    	movw	r0, #0xf051
7009bc80: f2c7 000a    	movt	r0, #0x700a
7009bc84: 6588         	str	r0, [r1, #0x58]
;         uartLldInit_handle->readCompleteCallbackFxn =  UART_lld_readCompleteCallback;
7009bc86: 9904         	ldr	r1, [sp, #0x10]
7009bc88: f24c 40d1    	movw	r0, #0xc4d1
7009bc8c: f2c7 000a    	movt	r0, #0x700a
7009bc90: 65c8         	str	r0, [r1, #0x5c]
;         uartLldInit_handle->writeCompleteCallbackFxn = UART_lld_writeCompleteCallback;
7009bc92: 9904         	ldr	r1, [sp, #0x10]
7009bc94: f24c 4011    	movw	r0, #0xc411
7009bc98: f2c7 000a    	movt	r0, #0x700a
7009bc9c: 6608         	str	r0, [r1, #0x60]
;         uartLldInit_handle->errorCallbackFxn =         UART_lld_errorCallback;
7009bc9e: 9904         	ldr	r1, [sp, #0x10]
7009bca0: f64f 10f1    	movw	r0, #0xf9f1
7009bca4: f2c7 000a    	movt	r0, #0x700a
7009bca8: 6648         	str	r0, [r1, #0x64]
;         status = UART_checkOpenParams(&object->prms);
7009bcaa: 980c         	ldr	r0, [sp, #0x30]
7009bcac: 3004         	adds	r0, #0x4
7009bcae: f011 fdbf    	bl	0x700ad830 <UART_checkOpenParams> @ imm = #0x11b7e
7009bcb2: 900f         	str	r0, [sp, #0x3c]
;     }
7009bcb4: e7ff         	b	0x7009bcb6 <UART_open+0x276> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009bcb6: 980f         	ldr	r0, [sp, #0x3c]
7009bcb8: 2800         	cmp	r0, #0x0
7009bcba: f040 80b8    	bne.w	0x7009be2e <UART_open+0x3ee> @ imm = #0x170
7009bcbe: e7ff         	b	0x7009bcc0 <UART_open+0x280> @ imm = #-0x2
;         uartLld_handle->state = UART_STATE_RESET;
7009bcc0: 9905         	ldr	r1, [sp, #0x14]
7009bcc2: 2000         	movs	r0, #0x0
7009bcc4: 6548         	str	r0, [r1, #0x54]
;         if(UART_CONFIG_MODE_DMA == object->prms.transferMode)
7009bcc6: 980c         	ldr	r0, [sp, #0x30]
7009bcc8: 6b00         	ldr	r0, [r0, #0x30]
7009bcca: 2803         	cmp	r0, #0x3
7009bccc: d117         	bne	0x7009bcfe <UART_open+0x2be> @ imm = #0x2e
7009bcce: e7ff         	b	0x7009bcd0 <UART_open+0x290> @ imm = #-0x2
;             uartLldInit_handle->uartDmaHandle = (UART_DmaHandle) gUartDmaHandle[index];
7009bcd0: 9911         	ldr	r1, [sp, #0x44]
7009bcd2: f242 3030    	movw	r0, #0x2330
7009bcd6: f2c7 000b    	movt	r0, #0x700b
7009bcda: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009bcde: 9904         	ldr	r1, [sp, #0x10]
7009bce0: 6488         	str	r0, [r1, #0x48]
;             uartLldInit_handle->dmaChCfg      = gUartDmaChConfig[index];
7009bce2: 9911         	ldr	r1, [sp, #0x44]
7009bce4: f242 60b0    	movw	r0, #0x26b0
7009bce8: f2c7 000b    	movt	r0, #0x700b
7009bcec: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009bcf0: 9904         	ldr	r1, [sp, #0x10]
7009bcf2: 64c8         	str	r0, [r1, #0x4c]
;             status = UART_lld_initDma(uartLld_handle);
7009bcf4: 9805         	ldr	r0, [sp, #0x14]
7009bcf6: f006 f873    	bl	0x700a1de0 <UART_lld_initDma> @ imm = #0x60e6
7009bcfa: 900f         	str	r0, [sp, #0x3c]
;         }
7009bcfc: e008         	b	0x7009bd10 <UART_open+0x2d0> @ imm = #0x10
;             status = UART_lld_init(uartLld_handle);
7009bcfe: 9805         	ldr	r0, [sp, #0x14]
7009bd00: f007 fa8e    	bl	0x700a3220 <UART_lld_init> @ imm = #0x751c
7009bd04: 900f         	str	r0, [sp, #0x3c]
;             object->uartDmaHandle = NULL;
7009bd06: 990c         	ldr	r1, [sp, #0x30]
7009bd08: 2000         	movs	r0, #0x0
7009bd0a: f8c1 0280    	str.w	r0, [r1, #0x280]
7009bd0e: e7ff         	b	0x7009bd10 <UART_open+0x2d0> @ imm = #-0x2
;         if(SystemP_SUCCESS == status)
7009bd10: 980f         	ldr	r0, [sp, #0x3c]
7009bd12: 2800         	cmp	r0, #0x0
7009bd14: f040 808a    	bne.w	0x7009be2c <UART_open+0x3ec> @ imm = #0x114
7009bd18: e7ff         	b	0x7009bd1a <UART_open+0x2da> @ imm = #-0x2
;             status = SemaphoreP_constructMutex(&object->lockObj);
7009bd1a: 980c         	ldr	r0, [sp, #0x30]
7009bd1c: 308c         	adds	r0, #0x8c
7009bd1e: f00f fb5f    	bl	0x700ab3e0 <SemaphoreP_constructMutex> @ imm = #0xf6be
7009bd22: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009bd24: 980f         	ldr	r0, [sp, #0x3c]
7009bd26: b930         	cbnz	r0, 0x7009bd36 <UART_open+0x2f6> @ imm = #0xc
7009bd28: e7ff         	b	0x7009bd2a <UART_open+0x2ea> @ imm = #-0x2
;                 object->lock = &object->lockObj;
7009bd2a: 990c         	ldr	r1, [sp, #0x30]
7009bd2c: f101 008c    	add.w	r0, r1, #0x8c
7009bd30: f8c1 0088    	str.w	r0, [r1, #0x88]
;             }
7009bd34: e7ff         	b	0x7009bd36 <UART_open+0x2f6> @ imm = #-0x2
;             status += SemaphoreP_constructBinary(&object->readTransferSemObj, 0U);
7009bd36: 980c         	ldr	r0, [sp, #0x30]
7009bd38: f500 7094    	add.w	r0, r0, #0x128
7009bd3c: 2100         	movs	r1, #0x0
7009bd3e: f00b ffd7    	bl	0x700a7cf0 <SemaphoreP_constructBinary> @ imm = #0xbfae
7009bd42: 4601         	mov	r1, r0
7009bd44: 980f         	ldr	r0, [sp, #0x3c]
7009bd46: 4408         	add	r0, r1
7009bd48: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009bd4a: 980f         	ldr	r0, [sp, #0x3c]
7009bd4c: b958         	cbnz	r0, 0x7009bd66 <UART_open+0x326> @ imm = #0x16
7009bd4e: e7ff         	b	0x7009bd50 <UART_open+0x310> @ imm = #-0x2
;                 object->readTransferSem = &object->readTransferSemObj;
7009bd50: 990c         	ldr	r1, [sp, #0x30]
7009bd52: f501 7094    	add.w	r0, r1, #0x128
7009bd56: f8c1 0124    	str.w	r0, [r1, #0x124]
;                 uartLld_handle->readTransferMutex = object->readTransferSem;
7009bd5a: 980c         	ldr	r0, [sp, #0x30]
7009bd5c: f8d0 0124    	ldr.w	r0, [r0, #0x124]
7009bd60: 9905         	ldr	r1, [sp, #0x14]
7009bd62: 6588         	str	r0, [r1, #0x58]
;             }
7009bd64: e7ff         	b	0x7009bd66 <UART_open+0x326> @ imm = #-0x2
;             status += SemaphoreP_constructBinary(&object->writeTransferSemObj, 0U);
7009bd66: 980c         	ldr	r0, [sp, #0x30]
7009bd68: f500 70e2    	add.w	r0, r0, #0x1c4
7009bd6c: 2100         	movs	r1, #0x0
7009bd6e: f00b ffbf    	bl	0x700a7cf0 <SemaphoreP_constructBinary> @ imm = #0xbf7e
7009bd72: 4601         	mov	r1, r0
7009bd74: 980f         	ldr	r0, [sp, #0x3c]
7009bd76: 4408         	add	r0, r1
7009bd78: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009bd7a: 980f         	ldr	r0, [sp, #0x3c]
7009bd7c: b958         	cbnz	r0, 0x7009bd96 <UART_open+0x356> @ imm = #0x16
7009bd7e: e7ff         	b	0x7009bd80 <UART_open+0x340> @ imm = #-0x2
;                 object->writeTransferSem = &object->writeTransferSemObj;
7009bd80: 990c         	ldr	r1, [sp, #0x30]
7009bd82: f501 70e2    	add.w	r0, r1, #0x1c4
7009bd86: f8c1 01c0    	str.w	r0, [r1, #0x1c0]
;                 uartLld_handle->writeTransferMutex = object->writeTransferSem;
7009bd8a: 980c         	ldr	r0, [sp, #0x30]
7009bd8c: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
7009bd90: 9905         	ldr	r1, [sp, #0x14]
7009bd92: 65c8         	str	r0, [r1, #0x5c]
;             }
7009bd94: e7ff         	b	0x7009bd96 <UART_open+0x356> @ imm = #-0x2
;             if((UART_CONFIG_MODE_INTERRUPT == object->prms.transferMode) && (TRUE != object->prms.skipIntrReg))
7009bd96: 980c         	ldr	r0, [sp, #0x30]
7009bd98: 6b00         	ldr	r0, [r0, #0x30]
7009bd9a: 2801         	cmp	r0, #0x1
7009bd9c: d145         	bne	0x7009be2a <UART_open+0x3ea> @ imm = #0x8a
7009bd9e: e7ff         	b	0x7009bda0 <UART_open+0x360> @ imm = #-0x2
7009bda0: 980c         	ldr	r0, [sp, #0x30]
7009bda2: 6bc0         	ldr	r0, [r0, #0x3c]
7009bda4: 2801         	cmp	r0, #0x1
7009bda6: d040         	beq	0x7009be2a <UART_open+0x3ea> @ imm = #0x80
7009bda8: e7ff         	b	0x7009bdaa <UART_open+0x36a> @ imm = #-0x2
;                 DebugP_assert(object->prms.intrNum != 0xFFFFU);
7009bdaa: 980c         	ldr	r0, [sp, #0x30]
7009bdac: 6b40         	ldr	r0, [r0, #0x34]
7009bdae: f64f 71ff    	movw	r1, #0xffff
7009bdb2: 1a40         	subs	r0, r0, r1
7009bdb4: bf18         	it	ne
7009bdb6: 2001         	movne	r0, #0x1
7009bdb8: f641 11c9    	movw	r1, #0x19c9
7009bdbc: f2c7 010b    	movt	r1, #0x700b
7009bdc0: 466a         	mov	r2, sp
7009bdc2: 6011         	str	r1, [r2]
7009bdc4: f641 41c5    	movw	r1, #0x1cc5
7009bdc8: f2c7 010b    	movt	r1, #0x700b
7009bdcc: f641 6220    	movw	r2, #0x1e20
7009bdd0: f2c7 020b    	movt	r2, #0x700b
7009bdd4: f44f 73bf    	mov.w	r3, #0x17e
7009bdd8: f00e fe2a    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xec54
7009bddc: a806         	add	r0, sp, #0x18
;                 HwiP_Params_init(&hwiPrms);
7009bdde: 9002         	str	r0, [sp, #0x8]
7009bde0: f013 ff36    	bl	0x700afc50 <HwiP_Params_init> @ imm = #0x13e6c
7009bde4: 9902         	ldr	r1, [sp, #0x8]
;                 hwiPrms.intNum      = object->prms.intrNum;
7009bde6: 980c         	ldr	r0, [sp, #0x30]
7009bde8: 6b40         	ldr	r0, [r0, #0x34]
7009bdea: 9006         	str	r0, [sp, #0x18]
;                 hwiPrms.callback    = &UART_lld_controllerIsr;
7009bdec: f64f 7041    	movw	r0, #0xff41
7009bdf0: f2c7 0009    	movt	r0, #0x7009
7009bdf4: 9007         	str	r0, [sp, #0x1c]
;                 hwiPrms.priority    = object->prms.intrPriority;
7009bdf6: 980c         	ldr	r0, [sp, #0x30]
7009bdf8: f890 0038    	ldrb.w	r0, [r0, #0x38]
7009bdfc: f88d 0026    	strb.w	r0, [sp, #0x26]
;                 hwiPrms.args        = (void *) uartLld_handle;
7009be00: 9805         	ldr	r0, [sp, #0x14]
7009be02: 9008         	str	r0, [sp, #0x20]
;                 status += HwiP_construct(&object->hwiObj, &hwiPrms);
7009be04: 980c         	ldr	r0, [sp, #0x30]
7009be06: f500 7018    	add.w	r0, r0, #0x260
7009be0a: f013 ff39    	bl	0x700afc80 <HwiP_construct> @ imm = #0x13e72
7009be0e: 4601         	mov	r1, r0
7009be10: 980f         	ldr	r0, [sp, #0x3c]
7009be12: 4408         	add	r0, r1
7009be14: 900f         	str	r0, [sp, #0x3c]
;                 if(SystemP_SUCCESS == status)
7009be16: 980f         	ldr	r0, [sp, #0x3c]
7009be18: b930         	cbnz	r0, 0x7009be28 <UART_open+0x3e8> @ imm = #0xc
7009be1a: e7ff         	b	0x7009be1c <UART_open+0x3dc> @ imm = #-0x2
;                     object->hwiHandle = &object->hwiObj;
7009be1c: 990c         	ldr	r1, [sp, #0x30]
7009be1e: f501 7018    	add.w	r0, r1, #0x260
7009be22: f8c1 025c    	str.w	r0, [r1, #0x25c]
;                 }
7009be26: e7ff         	b	0x7009be28 <UART_open+0x3e8> @ imm = #-0x2
;             }
7009be28: e7ff         	b	0x7009be2a <UART_open+0x3ea> @ imm = #-0x2
;         }
7009be2a: e7ff         	b	0x7009be2c <UART_open+0x3ec> @ imm = #-0x2
;     }
7009be2c: e7ff         	b	0x7009be2e <UART_open+0x3ee> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009be2e: 980f         	ldr	r0, [sp, #0x3c]
7009be30: b938         	cbnz	r0, 0x7009be42 <UART_open+0x402> @ imm = #0xe
7009be32: e7ff         	b	0x7009be34 <UART_open+0x3f4> @ imm = #-0x2
;         object->isOpen = TRUE;
7009be34: 990c         	ldr	r1, [sp, #0x30]
7009be36: 2001         	movs	r0, #0x1
7009be38: f8c1 0084    	str.w	r0, [r1, #0x84]
;         handle = (UART_Handle) config;
7009be3c: 980d         	ldr	r0, [sp, #0x34]
7009be3e: 900e         	str	r0, [sp, #0x38]
;     }
7009be40: e7ff         	b	0x7009be42 <UART_open+0x402> @ imm = #-0x2
;     SemaphoreP_post(&gUartDrvObj.lockObj);
7009be42: f242 30e8    	movw	r0, #0x23e8
7009be46: f2c7 000b    	movt	r0, #0x700b
7009be4a: 3004         	adds	r0, #0x4
7009be4c: f00f ff28    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0xfe50
;     if(SystemP_SUCCESS != status)
7009be50: 980f         	ldr	r0, [sp, #0x3c]
7009be52: b140         	cbz	r0, 0x7009be66 <UART_open+0x426> @ imm = #0x10
7009be54: e7ff         	b	0x7009be56 <UART_open+0x416> @ imm = #-0x2
;         if(NULL != config)
7009be56: 980d         	ldr	r0, [sp, #0x34]
7009be58: b120         	cbz	r0, 0x7009be64 <UART_open+0x424> @ imm = #0x8
7009be5a: e7ff         	b	0x7009be5c <UART_open+0x41c> @ imm = #-0x2
;             UART_close((UART_Handle) config);
7009be5c: 980d         	ldr	r0, [sp, #0x34]
7009be5e: f003 feb7    	bl	0x7009fbd0 <UART_close> @ imm = #0x3d6e
;         }
7009be62: e7ff         	b	0x7009be64 <UART_open+0x424> @ imm = #-0x2
;     }
7009be64: e7ff         	b	0x7009be66 <UART_open+0x426> @ imm = #-0x2
;     return (handle);
7009be66: 980e         	ldr	r0, [sp, #0x38]
7009be68: b012         	add	sp, #0x48
7009be6a: bd80         	pop	{r7, pc}
7009be6c: 0000         	movs	r0, r0
7009be6e: 0000         	movs	r0, r0

7009be70 <Udma_chAllocResource>:
; {
7009be70: b580         	push	{r7, lr}
7009be72: b088         	sub	sp, #0x20
7009be74: 9007         	str	r0, [sp, #0x1c]
7009be76: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK, tempRetVal;
7009be78: 9006         	str	r0, [sp, #0x18]
7009be7a: f64f 70ff    	movw	r0, #0xffff
;     uint16_t                ringNum = UDMA_RING_INVALID;
7009be7e: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     drvHandle = chHandle->drvHandle;
7009be82: 9807         	ldr	r0, [sp, #0x1c]
7009be84: 6e80         	ldr	r0, [r0, #0x68]
7009be86: 9004         	str	r0, [sp, #0x10]
;     if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009be88: 9807         	ldr	r0, [sp, #0x1c]
7009be8a: 7800         	ldrb	r0, [r0]
7009be8c: 0740         	lsls	r0, r0, #0x1d
7009be8e: 2800         	cmp	r0, #0x0
7009be90: d54d         	bpl	0x7009bf2e <Udma_chAllocResource+0xbe> @ imm = #0x9a
7009be92: e7ff         	b	0x7009be94 <Udma_chAllocResource+0x24> @ imm = #-0x2
;         if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009be94: 9807         	ldr	r0, [sp, #0x1c]
7009be96: 7800         	ldrb	r0, [r0]
7009be98: 0640         	lsls	r0, r0, #0x19
7009be9a: 2800         	cmp	r0, #0x0
7009be9c: d508         	bpl	0x7009beb0 <Udma_chAllocResource+0x40> @ imm = #0x10
7009be9e: e7ff         	b	0x7009bea0 <Udma_chAllocResource+0x30> @ imm = #-0x2
;                 Udma_rmAllocBlkCopyHcCh(chHandle->chPrms.chNum, drvHandle);
7009bea0: 9807         	ldr	r0, [sp, #0x1c]
7009bea2: 6840         	ldr	r0, [r0, #0x4]
7009bea4: 9904         	ldr	r1, [sp, #0x10]
7009bea6: f007 fcb3    	bl	0x700a3810 <Udma_rmAllocBlkCopyHcCh> @ imm = #0x7966
;             chHandle->txChNum =
7009beaa: 9907         	ldr	r1, [sp, #0x1c]
7009beac: 66c8         	str	r0, [r1, #0x6c]
;         }
7009beae: e016         	b	0x7009bede <Udma_chAllocResource+0x6e> @ imm = #0x2c
;         else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009beb0: 9807         	ldr	r0, [sp, #0x1c]
7009beb2: 7800         	ldrb	r0, [r0]
7009beb4: 0600         	lsls	r0, r0, #0x18
7009beb6: 2800         	cmp	r0, #0x0
7009beb8: d508         	bpl	0x7009becc <Udma_chAllocResource+0x5c> @ imm = #0x10
7009beba: e7ff         	b	0x7009bebc <Udma_chAllocResource+0x4c> @ imm = #-0x2
;                 Udma_rmAllocBlkCopyUhcCh(chHandle->chPrms.chNum, drvHandle);
7009bebc: 9807         	ldr	r0, [sp, #0x1c]
7009bebe: 6840         	ldr	r0, [r0, #0x4]
7009bec0: 9904         	ldr	r1, [sp, #0x10]
7009bec2: f007 fd3d    	bl	0x700a3940 <Udma_rmAllocBlkCopyUhcCh> @ imm = #0x7a7a
;             chHandle->txChNum =
7009bec6: 9907         	ldr	r1, [sp, #0x1c]
7009bec8: 66c8         	str	r0, [r1, #0x6c]
;         }
7009beca: e007         	b	0x7009bedc <Udma_chAllocResource+0x6c> @ imm = #0xe
;                 Udma_rmAllocBlkCopyCh(chHandle->chPrms.chNum, drvHandle);
7009becc: 9807         	ldr	r0, [sp, #0x1c]
7009bece: 6840         	ldr	r0, [r0, #0x4]
7009bed0: 9904         	ldr	r1, [sp, #0x10]
7009bed2: f007 fc05    	bl	0x700a36e0 <Udma_rmAllocBlkCopyCh> @ imm = #0x780a
;             chHandle->txChNum =
7009bed6: 9907         	ldr	r1, [sp, #0x1c]
7009bed8: 66c8         	str	r0, [r1, #0x6c]
7009beda: e7ff         	b	0x7009bedc <Udma_chAllocResource+0x6c> @ imm = #-0x2
7009bedc: e7ff         	b	0x7009bede <Udma_chAllocResource+0x6e> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID == chHandle->txChNum)
7009bede: 9807         	ldr	r0, [sp, #0x1c]
7009bee0: 6ec0         	ldr	r0, [r0, #0x6c]
7009bee2: f510 3f80    	cmn.w	r0, #0x10000
7009bee6: d104         	bne	0x7009bef2 <Udma_chAllocResource+0x82> @ imm = #0x8
7009bee8: e7ff         	b	0x7009beea <Udma_chAllocResource+0x7a> @ imm = #-0x2
7009beea: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
7009beee: 9006         	str	r0, [sp, #0x18]
;         }
7009bef0: e01c         	b	0x7009bf2c <Udma_chAllocResource+0xbc> @ imm = #0x38
;             if (UDMA_INST_TYPE_LCDMA_BCDMA == chHandle->drvHandle->instType)
7009bef2: 9807         	ldr	r0, [sp, #0x1c]
7009bef4: 6e80         	ldr	r0, [r0, #0x68]
7009bef6: 6800         	ldr	r0, [r0]
7009bef8: 2801         	cmp	r0, #0x1
7009befa: d10b         	bne	0x7009bf14 <Udma_chAllocResource+0xa4> @ imm = #0x16
7009befc: e7ff         	b	0x7009befe <Udma_chAllocResource+0x8e> @ imm = #-0x2
;                 chHandle->rxChNum     = UDMA_DMA_CH_INVALID;
7009befe: 9907         	ldr	r1, [sp, #0x1c]
7009bf00: 2000         	movs	r0, #0x0
7009bf02: f6cf 70ff    	movt	r0, #0xffff
7009bf06: 6708         	str	r0, [r1, #0x70]
;                 chHandle->peerThreadId = UDMA_THREAD_ID_INVALID;
7009bf08: 9907         	ldr	r1, [sp, #0x1c]
7009bf0a: 2004         	movs	r0, #0x4
7009bf0c: f6cf 70ff    	movt	r0, #0xffff
7009bf10: 67c8         	str	r0, [r1, #0x7c]
;             }
7009bf12: e00a         	b	0x7009bf2a <Udma_chAllocResource+0xba> @ imm = #0x14
;                 chHandle->rxChNum = chHandle->txChNum;
7009bf14: 9907         	ldr	r1, [sp, #0x1c]
7009bf16: 6ec8         	ldr	r0, [r1, #0x6c]
7009bf18: 6708         	str	r0, [r1, #0x70]
;                     chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
7009bf1a: 9907         	ldr	r1, [sp, #0x1c]
7009bf1c: 6f08         	ldr	r0, [r1, #0x70]
7009bf1e: 9a04         	ldr	r2, [sp, #0x10]
7009bf20: f8d2 20d8    	ldr.w	r2, [r2, #0xd8]
7009bf24: 4410         	add	r0, r2
;                 chHandle->peerThreadId =
7009bf26: 67c8         	str	r0, [r1, #0x7c]
7009bf28: e7ff         	b	0x7009bf2a <Udma_chAllocResource+0xba> @ imm = #-0x2
7009bf2a: e7ff         	b	0x7009bf2c <Udma_chAllocResource+0xbc> @ imm = #-0x2
;     }
7009bf2c: e0bd         	b	0x7009c0aa <Udma_chAllocResource+0x23a> @ imm = #0x17a
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009bf2e: 9807         	ldr	r0, [sp, #0x1c]
7009bf30: 7800         	ldrb	r0, [r0]
7009bf32: 07c0         	lsls	r0, r0, #0x1f
7009bf34: 2800         	cmp	r0, #0x0
7009bf36: d03f         	beq	0x7009bfb8 <Udma_chAllocResource+0x148> @ imm = #0x7e
7009bf38: e7ff         	b	0x7009bf3a <Udma_chAllocResource+0xca> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009bf3a: 9807         	ldr	r0, [sp, #0x1c]
7009bf3c: 7800         	ldrb	r0, [r0]
7009bf3e: 0640         	lsls	r0, r0, #0x19
7009bf40: 2800         	cmp	r0, #0x0
7009bf42: d508         	bpl	0x7009bf56 <Udma_chAllocResource+0xe6> @ imm = #0x10
7009bf44: e7ff         	b	0x7009bf46 <Udma_chAllocResource+0xd6> @ imm = #-0x2
;                     Udma_rmAllocTxHcCh(chHandle->chPrms.chNum, drvHandle);
7009bf46: 9807         	ldr	r0, [sp, #0x1c]
7009bf48: 6840         	ldr	r0, [r0, #0x4]
7009bf4a: 9904         	ldr	r1, [sp, #0x10]
7009bf4c: f007 fff0    	bl	0x700a3f30 <Udma_rmAllocTxHcCh> @ imm = #0x7fe0
;                 chHandle->txChNum =
7009bf50: 9907         	ldr	r1, [sp, #0x1c]
7009bf52: 66c8         	str	r0, [r1, #0x6c]
;             }
7009bf54: e025         	b	0x7009bfa2 <Udma_chAllocResource+0x132> @ imm = #0x4a
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009bf56: 9807         	ldr	r0, [sp, #0x1c]
7009bf58: 7840         	ldrb	r0, [r0, #0x1]
7009bf5a: 07c0         	lsls	r0, r0, #0x1f
7009bf5c: b148         	cbz	r0, 0x7009bf72 <Udma_chAllocResource+0x102> @ imm = #0x12
7009bf5e: e7ff         	b	0x7009bf60 <Udma_chAllocResource+0xf0> @ imm = #-0x2
;                     Udma_rmAllocMappedTxCh(chHandle->chPrms.chNum, drvHandle, chHandle->chPrms.mappedChGrp);
7009bf60: 9a07         	ldr	r2, [sp, #0x1c]
7009bf62: 9904         	ldr	r1, [sp, #0x10]
7009bf64: 6850         	ldr	r0, [r2, #0x4]
7009bf66: 68d2         	ldr	r2, [r2, #0xc]
7009bf68: f005 fdda    	bl	0x700a1b20 <Udma_rmAllocMappedTxCh> @ imm = #0x5bb4
;                 chHandle->txChNum =
7009bf6c: 9907         	ldr	r1, [sp, #0x1c]
7009bf6e: 66c8         	str	r0, [r1, #0x6c]
;             }
7009bf70: e016         	b	0x7009bfa0 <Udma_chAllocResource+0x130> @ imm = #0x2c
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009bf72: 9807         	ldr	r0, [sp, #0x1c]
7009bf74: 7800         	ldrb	r0, [r0]
7009bf76: 0600         	lsls	r0, r0, #0x18
7009bf78: 2800         	cmp	r0, #0x0
7009bf7a: d508         	bpl	0x7009bf8e <Udma_chAllocResource+0x11e> @ imm = #0x10
7009bf7c: e7ff         	b	0x7009bf7e <Udma_chAllocResource+0x10e> @ imm = #-0x2
;                     Udma_rmAllocTxUhcCh(chHandle->chPrms.chNum, drvHandle);
7009bf7e: 9807         	ldr	r0, [sp, #0x1c]
7009bf80: 6840         	ldr	r0, [r0, #0x4]
7009bf82: 9904         	ldr	r1, [sp, #0x10]
7009bf84: f008 f86c    	bl	0x700a4060 <Udma_rmAllocTxUhcCh> @ imm = #0x80d8
;                 chHandle->txChNum =
7009bf88: 9907         	ldr	r1, [sp, #0x1c]
7009bf8a: 66c8         	str	r0, [r1, #0x6c]
;             }
7009bf8c: e007         	b	0x7009bf9e <Udma_chAllocResource+0x12e> @ imm = #0xe
;                     Udma_rmAllocTxCh(chHandle->chPrms.chNum, drvHandle);
7009bf8e: 9807         	ldr	r0, [sp, #0x1c]
7009bf90: 6840         	ldr	r0, [r0, #0x4]
7009bf92: 9904         	ldr	r1, [sp, #0x10]
7009bf94: f007 ff34    	bl	0x700a3e00 <Udma_rmAllocTxCh> @ imm = #0x7e68
;                 chHandle->txChNum =
7009bf98: 9907         	ldr	r1, [sp, #0x1c]
7009bf9a: 66c8         	str	r0, [r1, #0x6c]
7009bf9c: e7ff         	b	0x7009bf9e <Udma_chAllocResource+0x12e> @ imm = #-0x2
7009bf9e: e7ff         	b	0x7009bfa0 <Udma_chAllocResource+0x130> @ imm = #-0x2
7009bfa0: e7ff         	b	0x7009bfa2 <Udma_chAllocResource+0x132> @ imm = #-0x2
;             if(UDMA_DMA_CH_INVALID == chHandle->txChNum)
7009bfa2: 9807         	ldr	r0, [sp, #0x1c]
7009bfa4: 6ec0         	ldr	r0, [r0, #0x6c]
7009bfa6: f510 3f80    	cmn.w	r0, #0x10000
7009bfaa: d104         	bne	0x7009bfb6 <Udma_chAllocResource+0x146> @ imm = #0x8
7009bfac: e7ff         	b	0x7009bfae <Udma_chAllocResource+0x13e> @ imm = #-0x2
7009bfae: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009bfb2: 9006         	str	r0, [sp, #0x18]
;             }
7009bfb4: e7ff         	b	0x7009bfb6 <Udma_chAllocResource+0x146> @ imm = #-0x2
;         }
7009bfb6: e05c         	b	0x7009c072 <Udma_chAllocResource+0x202> @ imm = #0xb8
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009bfb8: 9807         	ldr	r0, [sp, #0x1c]
7009bfba: 7800         	ldrb	r0, [r0]
7009bfbc: 0640         	lsls	r0, r0, #0x19
7009bfbe: 2800         	cmp	r0, #0x0
7009bfc0: d508         	bpl	0x7009bfd4 <Udma_chAllocResource+0x164> @ imm = #0x10
7009bfc2: e7ff         	b	0x7009bfc4 <Udma_chAllocResource+0x154> @ imm = #-0x2
;                     Udma_rmAllocRxHcCh(chHandle->chPrms.chNum, drvHandle);
7009bfc4: 9807         	ldr	r0, [sp, #0x1c]
7009bfc6: 6840         	ldr	r0, [r0, #0x4]
7009bfc8: 9904         	ldr	r1, [sp, #0x10]
7009bfca: f007 fde9    	bl	0x700a3ba0 <Udma_rmAllocRxHcCh> @ imm = #0x7bd2
;                 chHandle->rxChNum =
7009bfce: 9907         	ldr	r1, [sp, #0x1c]
7009bfd0: 6708         	str	r0, [r1, #0x70]
;             }
7009bfd2: e026         	b	0x7009c022 <Udma_chAllocResource+0x1b2> @ imm = #0x4c
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009bfd4: 9807         	ldr	r0, [sp, #0x1c]
7009bfd6: 7840         	ldrb	r0, [r0, #0x1]
7009bfd8: 07c0         	lsls	r0, r0, #0x1f
7009bfda: b150         	cbz	r0, 0x7009bff2 <Udma_chAllocResource+0x182> @ imm = #0x14
7009bfdc: e7ff         	b	0x7009bfde <Udma_chAllocResource+0x16e> @ imm = #-0x2
;                     Udma_rmAllocMappedRxCh(chHandle->chPrms.chNum, drvHandle, chHandle->chPrms.mappedChGrp - UDMA_NUM_MAPPED_TX_GROUP);
7009bfde: 9a07         	ldr	r2, [sp, #0x1c]
7009bfe0: 9904         	ldr	r1, [sp, #0x10]
7009bfe2: 6850         	ldr	r0, [r2, #0x4]
7009bfe4: 68d2         	ldr	r2, [r2, #0xc]
7009bfe6: 3a04         	subs	r2, #0x4
7009bfe8: f005 fcea    	bl	0x700a19c0 <Udma_rmAllocMappedRxCh> @ imm = #0x59d4
;                 chHandle->rxChNum =
7009bfec: 9907         	ldr	r1, [sp, #0x1c]
7009bfee: 6708         	str	r0, [r1, #0x70]
;             }
7009bff0: e016         	b	0x7009c020 <Udma_chAllocResource+0x1b0> @ imm = #0x2c
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009bff2: 9807         	ldr	r0, [sp, #0x1c]
7009bff4: 7800         	ldrb	r0, [r0]
7009bff6: 0600         	lsls	r0, r0, #0x18
7009bff8: 2800         	cmp	r0, #0x0
7009bffa: d508         	bpl	0x7009c00e <Udma_chAllocResource+0x19e> @ imm = #0x10
7009bffc: e7ff         	b	0x7009bffe <Udma_chAllocResource+0x18e> @ imm = #-0x2
;                     Udma_rmAllocRxUhcCh(chHandle->chPrms.chNum, drvHandle);
7009bffe: 9807         	ldr	r0, [sp, #0x1c]
7009c000: 6840         	ldr	r0, [r0, #0x4]
7009c002: 9904         	ldr	r1, [sp, #0x10]
7009c004: f007 fe64    	bl	0x700a3cd0 <Udma_rmAllocRxUhcCh> @ imm = #0x7cc8
;                 chHandle->rxChNum =
7009c008: 9907         	ldr	r1, [sp, #0x1c]
7009c00a: 6708         	str	r0, [r1, #0x70]
;             }
7009c00c: e007         	b	0x7009c01e <Udma_chAllocResource+0x1ae> @ imm = #0xe
;                     Udma_rmAllocRxCh(chHandle->chPrms.chNum, drvHandle);
7009c00e: 9807         	ldr	r0, [sp, #0x1c]
7009c010: 6840         	ldr	r0, [r0, #0x4]
7009c012: 9904         	ldr	r1, [sp, #0x10]
7009c014: f007 fd2c    	bl	0x700a3a70 <Udma_rmAllocRxCh> @ imm = #0x7a58
;                 chHandle->rxChNum =
7009c018: 9907         	ldr	r1, [sp, #0x1c]
7009c01a: 6708         	str	r0, [r1, #0x70]
7009c01c: e7ff         	b	0x7009c01e <Udma_chAllocResource+0x1ae> @ imm = #-0x2
7009c01e: e7ff         	b	0x7009c020 <Udma_chAllocResource+0x1b0> @ imm = #-0x2
7009c020: e7ff         	b	0x7009c022 <Udma_chAllocResource+0x1b2> @ imm = #-0x2
;             if(UDMA_DMA_CH_INVALID == chHandle->rxChNum)
7009c022: 9807         	ldr	r0, [sp, #0x1c]
7009c024: 6f00         	ldr	r0, [r0, #0x70]
7009c026: f510 3f80    	cmn.w	r0, #0x10000
7009c02a: d104         	bne	0x7009c036 <Udma_chAllocResource+0x1c6> @ imm = #0x8
7009c02c: e7ff         	b	0x7009c02e <Udma_chAllocResource+0x1be> @ imm = #-0x2
7009c02e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009c032: 9006         	str	r0, [sp, #0x18]
;             }
7009c034: e01c         	b	0x7009c070 <Udma_chAllocResource+0x200> @ imm = #0x38
;                 chHandle->defaultFlow               = &chHandle->defaultFlowObj;
7009c036: 9907         	ldr	r1, [sp, #0x1c]
7009c038: f501 70e6    	add.w	r0, r1, #0x1cc
7009c03c: f8c1 01c8    	str.w	r0, [r1, #0x1c8]
;                 chHandle->defaultFlow->drvHandle    = drvHandle;
7009c040: 9804         	ldr	r0, [sp, #0x10]
7009c042: 9907         	ldr	r1, [sp, #0x1c]
7009c044: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009c048: 6008         	str	r0, [r1]
;                 chHandle->defaultFlow->flowStart    = chHandle->rxChNum;
7009c04a: 9907         	ldr	r1, [sp, #0x1c]
7009c04c: 6f08         	ldr	r0, [r1, #0x70]
7009c04e: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009c052: 6048         	str	r0, [r1, #0x4]
;                 chHandle->defaultFlow->flowCnt      = 1U;
7009c054: 9807         	ldr	r0, [sp, #0x1c]
7009c056: f8d0 11c8    	ldr.w	r1, [r0, #0x1c8]
7009c05a: 2001         	movs	r0, #0x1
7009c05c: 6088         	str	r0, [r1, #0x8]
;                 chHandle->defaultFlow->flowInitDone = UDMA_INIT_DONE;
7009c05e: 9807         	ldr	r0, [sp, #0x1c]
7009c060: f8d0 11c8    	ldr.w	r1, [r0, #0x1c8]
7009c064: f64a 30cd    	movw	r0, #0xabcd
7009c068: f6ca 30dc    	movt	r0, #0xabdc
7009c06c: 60c8         	str	r0, [r1, #0xc]
7009c06e: e7ff         	b	0x7009c070 <Udma_chAllocResource+0x200> @ imm = #-0x2
7009c070: e7ff         	b	0x7009c072 <Udma_chAllocResource+0x202> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
7009c072: 9806         	ldr	r0, [sp, #0x18]
7009c074: b9c0         	cbnz	r0, 0x7009c0a8 <Udma_chAllocResource+0x238> @ imm = #0x30
7009c076: e7ff         	b	0x7009c078 <Udma_chAllocResource+0x208> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA)
7009c078: 9807         	ldr	r0, [sp, #0x1c]
7009c07a: 7800         	ldrb	r0, [r0]
7009c07c: 0700         	lsls	r0, r0, #0x1c
7009c07e: 2800         	cmp	r0, #0x0
7009c080: d507         	bpl	0x7009c092 <Udma_chAllocResource+0x222> @ imm = #0xe
7009c082: e7ff         	b	0x7009c084 <Udma_chAllocResource+0x214> @ imm = #-0x2
;                 chHandle->pdmaChNum = chHandle->chPrms.peerChNum;
7009c084: 9907         	ldr	r1, [sp, #0x1c]
7009c086: 6888         	ldr	r0, [r1, #0x8]
7009c088: 6788         	str	r0, [r1, #0x78]
;                 chHandle->peerThreadId = chHandle->pdmaChNum;
7009c08a: 9907         	ldr	r1, [sp, #0x1c]
7009c08c: 6f88         	ldr	r0, [r1, #0x78]
7009c08e: 67c8         	str	r0, [r1, #0x7c]
;             }
7009c090: e7ff         	b	0x7009c092 <Udma_chAllocResource+0x222> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_PSIL) == UDMA_CH_FLAG_PSIL)
7009c092: 9807         	ldr	r0, [sp, #0x1c]
7009c094: 7800         	ldrb	r0, [r0]
7009c096: 06c0         	lsls	r0, r0, #0x1b
7009c098: 2800         	cmp	r0, #0x0
7009c09a: d504         	bpl	0x7009c0a6 <Udma_chAllocResource+0x236> @ imm = #0x8
7009c09c: e7ff         	b	0x7009c09e <Udma_chAllocResource+0x22e> @ imm = #-0x2
;                 chHandle->peerThreadId = chHandle->chPrms.peerChNum;
7009c09e: 9907         	ldr	r1, [sp, #0x1c]
7009c0a0: 6888         	ldr	r0, [r1, #0x8]
7009c0a2: 67c8         	str	r0, [r1, #0x7c]
;             }
7009c0a4: e7ff         	b	0x7009c0a6 <Udma_chAllocResource+0x236> @ imm = #-0x2
;         }
7009c0a6: e7ff         	b	0x7009c0a8 <Udma_chAllocResource+0x238> @ imm = #-0x2
7009c0a8: e7ff         	b	0x7009c0aa <Udma_chAllocResource+0x23a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c0aa: 9806         	ldr	r0, [sp, #0x18]
7009c0ac: 2800         	cmp	r0, #0x0
7009c0ae: f040 8088    	bne.w	0x7009c1c2 <Udma_chAllocResource+0x352> @ imm = #0x110
7009c0b2: e7ff         	b	0x7009c0b4 <Udma_chAllocResource+0x244> @ imm = #-0x2
;         if(NULL_PTR != chHandle->chPrms.fqRingPrms.ringMem)
7009c0b4: 9807         	ldr	r0, [sp, #0x1c]
7009c0b6: 6940         	ldr	r0, [r0, #0x14]
7009c0b8: 2800         	cmp	r0, #0x0
7009c0ba: f000 8081    	beq.w	0x7009c1c0 <Udma_chAllocResource+0x350> @ imm = #0x102
7009c0be: e7ff         	b	0x7009c0c0 <Udma_chAllocResource+0x250> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) ==
7009c0c0: 9807         	ldr	r0, [sp, #0x1c]
7009c0c2: 7800         	ldrb	r0, [r0]
7009c0c4: 0740         	lsls	r0, r0, #0x1d
7009c0c6: 2800         	cmp	r0, #0x0
7009c0c8: d505         	bpl	0x7009c0d6 <Udma_chAllocResource+0x266> @ imm = #0xa
7009c0ca: e7ff         	b	0x7009c0cc <Udma_chAllocResource+0x25c> @ imm = #-0x2
;                 ringNum = (uint16_t)chHandle->txChNum;
7009c0cc: 9807         	ldr	r0, [sp, #0x1c]
7009c0ce: 6ec0         	ldr	r0, [r0, #0x6c]
7009c0d0: f8ad 000e    	strh.w	r0, [sp, #0xe]
;             }
7009c0d4: e044         	b	0x7009c160 <Udma_chAllocResource+0x2f0> @ imm = #0x88
;                 if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009c0d6: 9807         	ldr	r0, [sp, #0x1c]
7009c0d8: 7840         	ldrb	r0, [r0, #0x1]
7009c0da: 07c0         	lsls	r0, r0, #0x1f
7009c0dc: b338         	cbz	r0, 0x7009c12e <Udma_chAllocResource+0x2be> @ imm = #0x4e
7009c0de: e7ff         	b	0x7009c0e0 <Udma_chAllocResource+0x270> @ imm = #-0x2
;                     chHandle->chPrms.fqRingPrms.mappedRingGrp  = chHandle->chPrms.mappedChGrp;
7009c0e0: 9907         	ldr	r1, [sp, #0x1c]
7009c0e2: 68c8         	ldr	r0, [r1, #0xc]
7009c0e4: 6288         	str	r0, [r1, #0x28]
;                     if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009c0e6: 9807         	ldr	r0, [sp, #0x1c]
7009c0e8: 7800         	ldrb	r0, [r0]
7009c0ea: 07c0         	lsls	r0, r0, #0x1f
7009c0ec: b178         	cbz	r0, 0x7009c10e <Udma_chAllocResource+0x29e> @ imm = #0x1e
7009c0ee: e7ff         	b	0x7009c0f0 <Udma_chAllocResource+0x280> @ imm = #-0x2
;                         chHandle->chPrms.fqRingPrms.mappedChNum    = chHandle->txChNum;
7009c0f0: 9907         	ldr	r1, [sp, #0x1c]
7009c0f2: 6ec8         	ldr	r0, [r1, #0x6c]
7009c0f4: 62c8         	str	r0, [r1, #0x2c]
;                         retVal = Udma_getMappedChRingAttributes(drvHandle, chHandle->chPrms.mappedChGrp, chHandle->txChNum, &chAttr);
7009c0f6: 9804         	ldr	r0, [sp, #0x10]
7009c0f8: 9a07         	ldr	r2, [sp, #0x1c]
7009c0fa: 68d1         	ldr	r1, [r2, #0xc]
7009c0fc: 6ed2         	ldr	r2, [r2, #0x6c]
7009c0fe: 466b         	mov	r3, sp
7009c100: f00b fd46    	bl	0x700a7b90 <Udma_getMappedChRingAttributes> @ imm = #0xba8c
7009c104: 9006         	str	r0, [sp, #0x18]
;                         ringNum = chAttr.defaultRing;
7009c106: 9800         	ldr	r0, [sp]
7009c108: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                     }
7009c10c: e00e         	b	0x7009c12c <Udma_chAllocResource+0x2bc> @ imm = #0x1c
;                         chHandle->chPrms.fqRingPrms.mappedChNum    = chHandle->rxChNum;
7009c10e: 9907         	ldr	r1, [sp, #0x1c]
7009c110: 6f08         	ldr	r0, [r1, #0x70]
7009c112: 62c8         	str	r0, [r1, #0x2c]
;                         retVal = Udma_getMappedChRingAttributes(drvHandle, chHandle->chPrms.mappedChGrp, chHandle->rxChNum, &chAttr);
7009c114: 9804         	ldr	r0, [sp, #0x10]
7009c116: 9a07         	ldr	r2, [sp, #0x1c]
7009c118: 68d1         	ldr	r1, [r2, #0xc]
7009c11a: 6f12         	ldr	r2, [r2, #0x70]
7009c11c: 466b         	mov	r3, sp
7009c11e: f00b fd37    	bl	0x700a7b90 <Udma_getMappedChRingAttributes> @ imm = #0xba6e
7009c122: 9006         	str	r0, [sp, #0x18]
;                         ringNum = chAttr.defaultRing;
7009c124: 9800         	ldr	r0, [sp]
7009c126: f8ad 000e    	strh.w	r0, [sp, #0xe]
7009c12a: e7ff         	b	0x7009c12c <Udma_chAllocResource+0x2bc> @ imm = #-0x2
;                 }
7009c12c: e017         	b	0x7009c15e <Udma_chAllocResource+0x2ee> @ imm = #0x2e
;                 else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009c12e: 9807         	ldr	r0, [sp, #0x1c]
7009c130: 7800         	ldrb	r0, [r0]
7009c132: 07c0         	lsls	r0, r0, #0x1f
7009c134: b148         	cbz	r0, 0x7009c14a <Udma_chAllocResource+0x2da> @ imm = #0x12
7009c136: e7ff         	b	0x7009c138 <Udma_chAllocResource+0x2c8> @ imm = #-0x2
;                     ringNum = (uint16_t)(chHandle->txChNum + drvHandle->txChOffset);
7009c138: 9807         	ldr	r0, [sp, #0x1c]
7009c13a: 6ec0         	ldr	r0, [r0, #0x6c]
7009c13c: 9904         	ldr	r1, [sp, #0x10]
7009c13e: f8d1 110c    	ldr.w	r1, [r1, #0x10c]
7009c142: 4408         	add	r0, r1
7009c144: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                 }
7009c148: e008         	b	0x7009c15c <Udma_chAllocResource+0x2ec> @ imm = #0x10
;                     ringNum = (uint16_t)(chHandle->rxChNum + drvHandle->rxChOffset);
7009c14a: 9807         	ldr	r0, [sp, #0x1c]
7009c14c: 6f00         	ldr	r0, [r0, #0x70]
7009c14e: 9904         	ldr	r1, [sp, #0x10]
7009c150: f8d1 1114    	ldr.w	r1, [r1, #0x114]
7009c154: 4408         	add	r0, r1
7009c156: f8ad 000e    	strh.w	r0, [sp, #0xe]
7009c15a: e7ff         	b	0x7009c15c <Udma_chAllocResource+0x2ec> @ imm = #-0x2
7009c15c: e7ff         	b	0x7009c15e <Udma_chAllocResource+0x2ee> @ imm = #-0x2
7009c15e: e7ff         	b	0x7009c160 <Udma_chAllocResource+0x2f0> @ imm = #-0x2
;             chHandle->fqRing = &chHandle->fqRingObj;
7009c160: 9907         	ldr	r1, [sp, #0x1c]
7009c162: f101 0090    	add.w	r0, r1, #0x90
7009c166: f8c1 0080    	str.w	r0, [r1, #0x80]
;                          drvHandle,
7009c16a: 9804         	ldr	r0, [sp, #0x10]
;                          chHandle->fqRing,
7009c16c: 9b07         	ldr	r3, [sp, #0x1c]
7009c16e: f8d3 1080    	ldr.w	r1, [r3, #0x80]
;                          ringNum,
7009c172: f8bd 200e    	ldrh.w	r2, [sp, #0xe]
;                          &chHandle->chPrms.fqRingPrms);
7009c176: 3314         	adds	r3, #0x14
;             retVal = Udma_ringAlloc(
7009c178: f002 fdb2    	bl	0x7009ece0 <Udma_ringAlloc> @ imm = #0x2b64
7009c17c: 9006         	str	r0, [sp, #0x18]
;             if(UDMA_SOK != retVal)
7009c17e: 9806         	ldr	r0, [sp, #0x18]
7009c180: b128         	cbz	r0, 0x7009c18e <Udma_chAllocResource+0x31e> @ imm = #0xa
7009c182: e7ff         	b	0x7009c184 <Udma_chAllocResource+0x314> @ imm = #-0x2
;                 chHandle->fqRing = (Udma_RingHandleInt) NULL_PTR;
7009c184: 9907         	ldr	r1, [sp, #0x1c]
7009c186: 2000         	movs	r0, #0x0
7009c188: f8c1 0080    	str.w	r0, [r1, #0x80]
;             }
7009c18c: e017         	b	0x7009c1be <Udma_chAllocResource+0x34e> @ imm = #0x2e
;             else if(((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED) &&
7009c18e: 9807         	ldr	r0, [sp, #0x1c]
7009c190: 7840         	ldrb	r0, [r0, #0x1]
7009c192: 07c0         	lsls	r0, r0, #0x1f
7009c194: b190         	cbz	r0, 0x7009c1bc <Udma_chAllocResource+0x34c> @ imm = #0x24
7009c196: e7ff         	b	0x7009c198 <Udma_chAllocResource+0x328> @ imm = #-0x2
;                     ((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX))
7009c198: 9807         	ldr	r0, [sp, #0x1c]
;             else if(((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED) &&
7009c19a: 7800         	ldrb	r0, [r0]
7009c19c: 0780         	lsls	r0, r0, #0x1e
7009c19e: 2800         	cmp	r0, #0x0
7009c1a0: d50c         	bpl	0x7009c1bc <Udma_chAllocResource+0x34c> @ imm = #0x18
7009c1a2: e7ff         	b	0x7009c1a4 <Udma_chAllocResource+0x334> @ imm = #-0x2
;                 chHandle->defaultFlow->flowStart    = chHandle->fqRing->ringNum - drvHandle->rxChOffset;
7009c1a4: 9907         	ldr	r1, [sp, #0x1c]
7009c1a6: f8d1 0080    	ldr.w	r0, [r1, #0x80]
7009c1aa: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009c1ae: 8880         	ldrh	r0, [r0, #0x4]
7009c1b0: 9a04         	ldr	r2, [sp, #0x10]
7009c1b2: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c1b6: 1a80         	subs	r0, r0, r2
7009c1b8: 6048         	str	r0, [r1, #0x4]
;             }
7009c1ba: e7ff         	b	0x7009c1bc <Udma_chAllocResource+0x34c> @ imm = #-0x2
7009c1bc: e7ff         	b	0x7009c1be <Udma_chAllocResource+0x34e> @ imm = #-0x2
;         }
7009c1be: e7ff         	b	0x7009c1c0 <Udma_chAllocResource+0x350> @ imm = #-0x2
;     }
7009c1c0: e7ff         	b	0x7009c1c2 <Udma_chAllocResource+0x352> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c1c2: 9806         	ldr	r0, [sp, #0x18]
7009c1c4: b930         	cbnz	r0, 0x7009c1d4 <Udma_chAllocResource+0x364> @ imm = #0xc
7009c1c6: e7ff         	b	0x7009c1c8 <Udma_chAllocResource+0x358> @ imm = #-0x2
;         chHandle->cqRing = &chHandle->fqRingObj;
7009c1c8: 9907         	ldr	r1, [sp, #0x1c]
7009c1ca: f101 0090    	add.w	r0, r1, #0x90
7009c1ce: f8c1 0084    	str.w	r0, [r1, #0x84]
;     }
7009c1d2: e7ff         	b	0x7009c1d4 <Udma_chAllocResource+0x364> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c1d4: 9806         	ldr	r0, [sp, #0x18]
7009c1d6: b928         	cbnz	r0, 0x7009c1e4 <Udma_chAllocResource+0x374> @ imm = #0xa
7009c1d8: e7ff         	b	0x7009c1da <Udma_chAllocResource+0x36a> @ imm = #-0x2
;         chHandle->tdCqRing = (Udma_RingHandleInt) NULL_PTR;
7009c1da: 9907         	ldr	r1, [sp, #0x1c]
7009c1dc: 2000         	movs	r0, #0x0
7009c1de: f8c1 0088    	str.w	r0, [r1, #0x88]
;     }
7009c1e2: e7ff         	b	0x7009c1e4 <Udma_chAllocResource+0x374> @ imm = #-0x2
;     if(UDMA_SOK != retVal)
7009c1e4: 9806         	ldr	r0, [sp, #0x18]
7009c1e6: b148         	cbz	r0, 0x7009c1fc <Udma_chAllocResource+0x38c> @ imm = #0x12
7009c1e8: e7ff         	b	0x7009c1ea <Udma_chAllocResource+0x37a> @ imm = #-0x2
;         tempRetVal = Udma_chFreeResource(chHandle);
7009c1ea: 9807         	ldr	r0, [sp, #0x1c]
7009c1ec: f002 fc70    	bl	0x7009ead0 <Udma_chFreeResource> @ imm = #0x28e0
7009c1f0: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK != tempRetVal)
7009c1f2: 9805         	ldr	r0, [sp, #0x14]
7009c1f4: b108         	cbz	r0, 0x7009c1fa <Udma_chAllocResource+0x38a> @ imm = #0x2
7009c1f6: e7ff         	b	0x7009c1f8 <Udma_chAllocResource+0x388> @ imm = #-0x2
;         }
7009c1f8: e7ff         	b	0x7009c1fa <Udma_chAllocResource+0x38a> @ imm = #-0x2
;     }
7009c1fa: e004         	b	0x7009c206 <Udma_chAllocResource+0x396> @ imm = #0x8
;         Udma_chAssignRegOverlay(drvHandle, chHandle);
7009c1fc: 9804         	ldr	r0, [sp, #0x10]
7009c1fe: 9907         	ldr	r1, [sp, #0x1c]
7009c200: f005 ffee    	bl	0x700a21e0 <Udma_chAssignRegOverlay> @ imm = #0x5fdc
7009c204: e7ff         	b	0x7009c206 <Udma_chAllocResource+0x396> @ imm = #-0x2
;     return (retVal);
7009c206: 9806         	ldr	r0, [sp, #0x18]
7009c208: b008         	add	sp, #0x20
7009c20a: bd80         	pop	{r7, pc}
7009c20c: 0000         	movs	r0, r0
7009c20e: 0000         	movs	r0, r0

7009c210 <CSL_REG32_WR_RAW>:
; {
7009c210: b082         	sub	sp, #0x8
7009c212: 9001         	str	r0, [sp, #0x4]
7009c214: 9100         	str	r1, [sp]
;     *p = v;
7009c216: 9800         	ldr	r0, [sp]
7009c218: 9901         	ldr	r1, [sp, #0x4]
7009c21a: 6008         	str	r0, [r1]
;     return;
7009c21c: b002         	add	sp, #0x8
7009c21e: 4770         	bx	lr

7009c220 <strcmp>:
7009c220: e5d02000     	ldrb	r2, [r0]
7009c224: e5d13000     	ldrb	r3, [r1]
7009c228: e3520001     	cmp	r2, #1
7009c22c: 21520003     	cmphs	r2, r3
7009c230: 1a004dda     	bne	0x700af9a0 <.Lfastpath_exit> @ imm = #0x13768
7009c234: e16d41f0     	strd	r4, r5, [sp, #-16]!
7009c238: e1804001     	orr	r4, r0, r1
7009c23c: e1cd60f8     	strd	r6, r7, [sp, #8]
7009c240: e3e0c000     	mvn	r12, #0
7009c244: e1a02e84     	lsl	r2, r4, #29
7009c248: e3520000     	cmp	r2, #0
7009c24c: 0a000013     	beq	0x7009c2a0 <strcmp+0x80> @ imm = #0x4c
7009c250: e0204001     	eor	r4, r0, r1
7009c254: e3140007     	tst	r4, #7
7009c258: 1a00003e     	bne	0x7009c358 <strcmp+0x138> @ imm = #0xf8
7009c25c: e2004007     	and	r4, r0, #7
7009c260: e3c00007     	bic	r0, r0, #7
7009c264: e2045003     	and	r5, r4, #3
7009c268: e3c11007     	bic	r1, r1, #7
7009c26c: e1a05185     	lsl	r5, r5, #3
7009c270: e0c021d0     	ldrd	r2, r3, [r0], #16
7009c274: e3140004     	tst	r4, #4
7009c278: e0c161d0     	ldrd	r6, r7, [r1], #16
7009c27c: e1e0451c     	mvn	r4, r12, lsl r5
7009c280: e1822004     	orr	r2, r2, r4
7009c284: e1866004     	orr	r6, r6, r4
7009c288: 0a000006     	beq	0x7009c2a8 <strcmp+0x88> @ imm = #0x18
7009c28c: e1833004     	orr	r3, r3, r4
7009c290: e1a0200c     	mov	r2, r12
7009c294: e1877004     	orr	r7, r7, r4
7009c298: e1a0600c     	mov	r6, r12
7009c29c: ea000001     	b	0x7009c2a8 <strcmp+0x88> @ imm = #0x4
7009c2a0: e0c021d0     	ldrd	r2, r3, [r0], #16
7009c2a4: e0c161d0     	ldrd	r6, r7, [r1], #16
7009c2a8: e6525f9c     	uadd8	r5, r2, r12
7009c2ac: e0224006     	eor	r4, r2, r6
7009c2b0: e6844fbc     	sel	r4, r4, r12
7009c2b4: e3540000     	cmp	r4, #0
7009c2b8: 1a00001b     	bne	0x7009c32c <strcmp+0x10c> @ imm = #0x6c
7009c2bc: e6535f9c     	uadd8	r5, r3, r12
7009c2c0: e0235007     	eor	r5, r3, r7
7009c2c4: e6855fbc     	sel	r5, r5, r12
7009c2c8: e3550000     	cmp	r5, #0
7009c2cc: 1a00000b     	bne	0x7009c300 <strcmp+0xe0> @ imm = #0x2c
7009c2d0: e14020d8     	ldrd	r2, r3, [r0, #-8]
7009c2d4: e14160d8     	ldrd	r6, r7, [r1, #-8]
7009c2d8: e6525f9c     	uadd8	r5, r2, r12
7009c2dc: e0224006     	eor	r4, r2, r6
7009c2e0: e6844fbc     	sel	r4, r4, r12
7009c2e4: e6535f9c     	uadd8	r5, r3, r12
7009c2e8: e0235007     	eor	r5, r3, r7
7009c2ec: e6855fbc     	sel	r5, r5, r12
7009c2f0: e1955004     	orrs	r5, r5, r4
7009c2f4: 0affffe9     	beq	0x7009c2a0 <strcmp+0x80> @ imm = #-0x5c
7009c2f8: e3540000     	cmp	r4, #0
7009c2fc: 1a00000a     	bne	0x7009c32c <strcmp+0x10c> @ imm = #0x28
7009c300: e6bf5f35     	rev	r5, r5
7009c304: e16f4f15     	clz	r4, r5
7009c308: e3c44007     	bic	r4, r4, #7
7009c30c: e1a01437     	lsr	r1, r7, r4
7009c310: e1cd60d8     	ldrd	r6, r7, [sp, #8]
7009c314: e1a03433     	lsr	r3, r3, r4
7009c318: e20300ff     	and	r0, r3, #255
7009c31c: e20110ff     	and	r1, r1, #255
7009c320: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c324: e0400001     	sub	r0, r0, r1
7009c328: e12fff1e     	bx	lr
7009c32c: e6bf4f34     	rev	r4, r4
7009c330: e16f4f14     	clz	r4, r4
7009c334: e3c44007     	bic	r4, r4, #7
7009c338: e1a01436     	lsr	r1, r6, r4
7009c33c: e1cd60d8     	ldrd	r6, r7, [sp, #8]
7009c340: e1a02432     	lsr	r2, r2, r4
7009c344: e20200ff     	and	r0, r2, #255
7009c348: e20110ff     	and	r1, r1, #255
7009c34c: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c350: e0400001     	sub	r0, r0, r1
7009c354: e12fff1e     	bx	lr
7009c358: e3140003     	tst	r4, #3
7009c35c: 1a000022     	bne	0x7009c3ec <strcmp+0x1cc> @ imm = #0x88
7009c360: e2104003     	ands	r4, r0, #3
7009c364: 1a000017     	bne	0x7009c3c8 <strcmp+0x1a8> @ imm = #0x5c
7009c368: e4902008     	ldr	r2, [r0], #8
7009c36c: e4913008     	ldr	r3, [r1], #8
7009c370: e6525f9c     	uadd8	r5, r2, r12
7009c374: e0225003     	eor	r5, r2, r3
7009c378: e6855fbc     	sel	r5, r5, r12
7009c37c: e3550000     	cmp	r5, #0
7009c380: 1a000006     	bne	0x7009c3a0 <strcmp+0x180> @ imm = #0x18
7009c384: e5102004     	ldr	r2, [r0, #-0x4]
7009c388: e5113004     	ldr	r3, [r1, #-0x4]
7009c38c: e6525f9c     	uadd8	r5, r2, r12
7009c390: e0225003     	eor	r5, r2, r3
7009c394: e6855fbc     	sel	r5, r5, r12
7009c398: e3550000     	cmp	r5, #0
7009c39c: 0afffff1     	beq	0x7009c368 <strcmp+0x148> @ imm = #-0x3c
7009c3a0: e6bf5f35     	rev	r5, r5
7009c3a4: e16f4f15     	clz	r4, r5
7009c3a8: e3c44007     	bic	r4, r4, #7
7009c3ac: e1a01433     	lsr	r1, r3, r4
7009c3b0: e1a02432     	lsr	r2, r2, r4
7009c3b4: e20200ff     	and	r0, r2, #255
7009c3b8: e20110ff     	and	r1, r1, #255
7009c3bc: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c3c0: e0400001     	sub	r0, r0, r1
7009c3c4: e12fff1e     	bx	lr
7009c3c8: e1a04184     	lsl	r4, r4, #3
7009c3cc: e3c00003     	bic	r0, r0, #3
7009c3d0: e4902008     	ldr	r2, [r0], #8
7009c3d4: e3c11003     	bic	r1, r1, #3
7009c3d8: e4913008     	ldr	r3, [r1], #8
7009c3dc: e1e0441c     	mvn	r4, r12, lsl r4
7009c3e0: e1822004     	orr	r2, r2, r4
7009c3e4: e1833004     	orr	r3, r3, r4
7009c3e8: eaffffe0     	b	0x7009c370 <strcmp+0x150> @ imm = #-0x80
7009c3ec: e2104003     	ands	r4, r0, #3
7009c3f0: 0a000015     	beq	0x7009c44c <strcmp+0x22c> @ imm = #0x54
7009c3f4: e0411004     	sub	r1, r1, r4
7009c3f8: e3c00003     	bic	r0, r0, #3
7009c3fc: e1b04f84     	lsls	r4, r4, #31
7009c400: e4902004     	ldr	r2, [r0], #4
7009c404: 0a000006     	beq	0x7009c424 <strcmp+0x204> @ imm = #0x18
7009c408: 2a00000e     	bhs	0x7009c448 <strcmp+0x228> @ imm = #0x38
7009c40c: e5d13002     	ldrb	r3, [r1, #0x2]
7009c410: e6ef4872     	uxtb	r4, r2, ror #16
7009c414: e0544003     	subs	r4, r4, r3
7009c418: 1a000007     	bne	0x7009c43c <strcmp+0x21c> @ imm = #0x1c
7009c41c: e3530000     	cmp	r3, #0
7009c420: 0a000005     	beq	0x7009c43c <strcmp+0x21c> @ imm = #0x14
7009c424: e5d13003     	ldrb	r3, [r1, #0x3]
7009c428: e6ef4c72     	uxtb	r4, r2, ror #24
7009c42c: e0544003     	subs	r4, r4, r3
7009c430: 1a000001     	bne	0x7009c43c <strcmp+0x21c> @ imm = #0x4
7009c434: e3530000     	cmp	r3, #0
7009c438: 1a000002     	bne	0x7009c448 <strcmp+0x228> @ imm = #0x8
7009c43c: e1a00004     	mov	r0, r4
7009c440: e49d4010     	ldr	r4, [sp], #16
7009c444: e12fff1e     	bx	lr
7009c448: e2811004     	add	r1, r1, #4
7009c44c: e4902004     	ldr	r2, [r0], #4
7009c450: e1b04f81     	lsls	r4, r1, #31
7009c454: e3c11003     	bic	r1, r1, #3
7009c458: e4913004     	ldr	r3, [r1], #4
7009c45c: 8a00002f     	bhi	0x7009c520 <strcmp+0x300> @ imm = #0xbc
7009c460: 2a000017     	bhs	0x7009c4c4 <strcmp+0x2a4> @ imm = #0x5c
7009c464: e3c244ff     	bic	r4, r2, #-16777216
7009c468: e6525f9c     	uadd8	r5, r2, r12
7009c46c: e0345423     	eors	r5, r4, r3, lsr #8
7009c470: e6855fbc     	sel	r5, r5, r12
7009c474: 1a000007     	bne	0x7009c498 <strcmp+0x278> @ imm = #0x1c
7009c478: e3550000     	cmp	r5, #0
7009c47c: 1a000007     	bne	0x7009c4a0 <strcmp+0x280> @ imm = #0x1c
7009c480: e4913004     	ldr	r3, [r1], #4
7009c484: e0244002     	eor	r4, r4, r2
7009c488: e1540c03     	cmp	r4, r3, lsl #24
7009c48c: 1a000009     	bne	0x7009c4b8 <strcmp+0x298> @ imm = #0x24
7009c490: e4902004     	ldr	r2, [r0], #4
7009c494: eafffff2     	b	0x7009c464 <strcmp+0x244> @ imm = #-0x38
7009c498: e1a03423     	lsr	r3, r3, #8
7009c49c: ea000037     	b	0x7009c580 <strcmp+0x360> @ imm = #0xdc
7009c4a0: e3d554ff     	bics	r5, r5, #-16777216
7009c4a4: 1a000032     	bne	0x7009c574 <strcmp+0x354> @ imm = #0xc8
7009c4a8: e5d10000     	ldrb	r0, [r1]
7009c4ac: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c4b0: e2600000     	rsb	r0, r0, #0
7009c4b4: e12fff1e     	bx	lr
7009c4b8: e1a02c22     	lsr	r2, r2, #24
7009c4bc: e20330ff     	and	r3, r3, #255
7009c4c0: ea00002e     	b	0x7009c580 <strcmp+0x360> @ imm = #0xb8
7009c4c4: e002482c     	and	r4, r2, r12, lsr #16
7009c4c8: e6525f9c     	uadd8	r5, r2, r12
7009c4cc: e0345823     	eors	r5, r4, r3, lsr #16
7009c4d0: e6855fbc     	sel	r5, r5, r12
7009c4d4: 1a000007     	bne	0x7009c4f8 <strcmp+0x2d8> @ imm = #0x1c
7009c4d8: e3550000     	cmp	r5, #0
7009c4dc: 1a000007     	bne	0x7009c500 <strcmp+0x2e0> @ imm = #0x1c
7009c4e0: e4913004     	ldr	r3, [r1], #4
7009c4e4: e0244002     	eor	r4, r4, r2
7009c4e8: e1540803     	cmp	r4, r3, lsl #16
7009c4ec: 1a000008     	bne	0x7009c514 <strcmp+0x2f4> @ imm = #0x20
7009c4f0: e4902004     	ldr	r2, [r0], #4
7009c4f4: eafffff2     	b	0x7009c4c4 <strcmp+0x2a4> @ imm = #-0x38
7009c4f8: e1a03823     	lsr	r3, r3, #16
7009c4fc: ea00001f     	b	0x7009c580 <strcmp+0x360> @ imm = #0x7c
7009c500: e015582c     	ands	r5, r5, r12, lsr #16
7009c504: 1a00001a     	bne	0x7009c574 <strcmp+0x354> @ imm = #0x68
7009c508: e1d130b0     	ldrh	r3, [r1]
7009c50c: e1a02822     	lsr	r2, r2, #16
7009c510: ea00001a     	b	0x7009c580 <strcmp+0x360> @ imm = #0x68
7009c514: e1a02822     	lsr	r2, r2, #16
7009c518: e003382c     	and	r3, r3, r12, lsr #16
7009c51c: ea000017     	b	0x7009c580 <strcmp+0x360> @ imm = #0x5c
7009c520: e20240ff     	and	r4, r2, #255
7009c524: e6525f9c     	uadd8	r5, r2, r12
7009c528: e0345c23     	eors	r5, r4, r3, lsr #24
7009c52c: e6855fbc     	sel	r5, r5, r12
7009c530: 1a000007     	bne	0x7009c554 <strcmp+0x334> @ imm = #0x1c
7009c534: e3550000     	cmp	r5, #0
7009c538: 1a000007     	bne	0x7009c55c <strcmp+0x33c> @ imm = #0x1c
7009c53c: e4913004     	ldr	r3, [r1], #4
7009c540: e0244002     	eor	r4, r4, r2
7009c544: e1540403     	cmp	r4, r3, lsl #8
7009c548: 1a000006     	bne	0x7009c568 <strcmp+0x348> @ imm = #0x18
7009c54c: e4902004     	ldr	r2, [r0], #4
7009c550: eafffff2     	b	0x7009c520 <strcmp+0x300> @ imm = #-0x38
7009c554: e1a03c23     	lsr	r3, r3, #24
7009c558: ea000008     	b	0x7009c580 <strcmp+0x360> @ imm = #0x20
7009c55c: e31500ff     	tst	r5, #255
7009c560: 1a000003     	bne	0x7009c574 <strcmp+0x354> @ imm = #0xc
7009c564: e5913000     	ldr	r3, [r1]
7009c568: e1a02422     	lsr	r2, r2, #8
7009c56c: e3c334ff     	bic	r3, r3, #-16777216
7009c570: ea000002     	b	0x7009c580 <strcmp+0x360> @ imm = #0x8
7009c574: e3a00000     	mov	r0, #0
7009c578: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c57c: e12fff1e     	bx	lr
7009c580: e6bf2f32     	rev	r2, r2
7009c584: e6bf3f33     	rev	r3, r3
7009c588: e6524f9c     	uadd8	r4, r2, r12
7009c58c: e0224003     	eor	r4, r2, r3
7009c590: e6845fbc     	sel	r5, r4, r12
7009c594: e16f4f15     	clz	r4, r5
7009c598: e1a02412     	lsl	r2, r2, r4
7009c59c: e1a03413     	lsl	r3, r3, r4
7009c5a0: e1a00c22     	lsr	r0, r2, #24
7009c5a4: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c5a8: e0400c23     	sub	r0, r0, r3, lsr #24
7009c5ac: e12fff1e     	bx	lr

7009c5b0 <Udma_chDisableTxChan>:
; {
7009c5b0: b580         	push	{r7, lr}
7009c5b2: b09a         	sub	sp, #0x68
7009c5b4: 9019         	str	r0, [sp, #0x64]
7009c5b6: 9118         	str	r1, [sp, #0x60]
7009c5b8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009c5ba: 9017         	str	r0, [sp, #0x5c]
;     uint32_t            peerRtEnable = 0U, currTimeout = 0U;
7009c5bc: 9016         	str	r0, [sp, #0x58]
7009c5be: 9015         	str	r0, [sp, #0x54]
;     drvHandle = chHandle->drvHandle;
7009c5c0: 9819         	ldr	r0, [sp, #0x64]
7009c5c2: 6e80         	ldr	r0, [r0, #0x68]
7009c5c4: 9014         	str	r0, [sp, #0x50]
7009c5c6: 2008         	movs	r0, #0x8
;     rtEnableRegOffset = CSL_PSILCFG_REG_RT_ENABLE - CSL_PSILCFG_REG_STATIC_TR;
7009c5c8: 9008         	str	r0, [sp, #0x20]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c5ca: 9814         	ldr	r0, [sp, #0x50]
7009c5cc: 6800         	ldr	r0, [r0]
7009c5ce: 2801         	cmp	r0, #0x1
7009c5d0: d10e         	bne	0x7009c5f0 <Udma_chDisableTxChan+0x40> @ imm = #0x1c
7009c5d2: e7ff         	b	0x7009c5d4 <Udma_chDisableTxChan+0x24> @ imm = #-0x2
;                  &drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, (bool)false, (bool)false);
7009c5d4: 9a14         	ldr	r2, [sp, #0x50]
7009c5d6: f102 0008    	add.w	r0, r2, #0x8
7009c5da: 9919         	ldr	r1, [sp, #0x64]
7009c5dc: 6ec9         	ldr	r1, [r1, #0x6c]
7009c5de: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c5e2: 4411         	add	r1, r2
7009c5e4: 2300         	movs	r3, #0x0
;         retVal = CSL_bcdmaTeardownTxChan(
7009c5e6: 461a         	mov	r2, r3
7009c5e8: f010 ff92    	bl	0x700ad510 <CSL_bcdmaTeardownTxChan> @ imm = #0x10f24
7009c5ec: 9017         	str	r0, [sp, #0x5c]
;     }
7009c5ee: e00f         	b	0x7009c610 <Udma_chDisableTxChan+0x60> @ imm = #0x1e
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c5f0: 9814         	ldr	r0, [sp, #0x50]
7009c5f2: 6800         	ldr	r0, [r0]
7009c5f4: 2802         	cmp	r0, #0x2
7009c5f6: d10a         	bne	0x7009c60e <Udma_chDisableTxChan+0x5e> @ imm = #0x14
7009c5f8: e7ff         	b	0x7009c5fa <Udma_chDisableTxChan+0x4a> @ imm = #-0x2
;                  &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009c5fa: 9814         	ldr	r0, [sp, #0x50]
7009c5fc: 3054         	adds	r0, #0x54
7009c5fe: 9919         	ldr	r1, [sp, #0x64]
7009c600: 6ec9         	ldr	r1, [r1, #0x6c]
7009c602: 2300         	movs	r3, #0x0
;         retVal = CSL_pktdmaTeardownTxChan(
7009c604: 461a         	mov	r2, r3
7009c606: f011 fe2b    	bl	0x700ae260 <CSL_pktdmaTeardownTxChan> @ imm = #0x11c56
7009c60a: 9017         	str	r0, [sp, #0x5c]
;     }
7009c60c: e7ff         	b	0x7009c60e <Udma_chDisableTxChan+0x5e> @ imm = #-0x2
7009c60e: e7ff         	b	0x7009c610 <Udma_chDisableTxChan+0x60> @ imm = #-0x2
;     if(CSL_PASS != retVal)
7009c610: 9817         	ldr	r0, [sp, #0x5c]
7009c612: b108         	cbz	r0, 0x7009c618 <Udma_chDisableTxChan+0x68> @ imm = #0x2
7009c614: e7ff         	b	0x7009c616 <Udma_chDisableTxChan+0x66> @ imm = #-0x2
;     }
7009c616: e7ff         	b	0x7009c618 <Udma_chDisableTxChan+0x68> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009c618: e7ff         	b	0x7009c61a <Udma_chDisableTxChan+0x6a> @ imm = #-0x2
7009c61a: 9817         	ldr	r0, [sp, #0x5c]
7009c61c: bbc8         	cbnz	r0, 0x7009c692 <Udma_chDisableTxChan+0xe2> @ imm = #0x72
7009c61e: e7ff         	b	0x7009c620 <Udma_chDisableTxChan+0x70> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c620: 9814         	ldr	r0, [sp, #0x50]
7009c622: 6800         	ldr	r0, [r0]
7009c624: 2801         	cmp	r0, #0x1
7009c626: d110         	bne	0x7009c64a <Udma_chDisableTxChan+0x9a> @ imm = #0x20
7009c628: e7ff         	b	0x7009c62a <Udma_chDisableTxChan+0x7a> @ imm = #-0x2
;             (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009c62a: 9a14         	ldr	r2, [sp, #0x50]
7009c62c: f102 0008    	add.w	r0, r2, #0x8
7009c630: 9919         	ldr	r1, [sp, #0x64]
7009c632: 6ec9         	ldr	r1, [r1, #0x6c]
7009c634: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c638: 4411         	add	r1, r2
7009c63a: aa0e         	add	r2, sp, #0x38
7009c63c: f012 f908    	bl	0x700ae850 <CSL_bcdmaGetTxRT> @ imm = #0x12210
;             if(FALSE == bcdmaRtStatus.enable)
7009c640: 980e         	ldr	r0, [sp, #0x38]
7009c642: b908         	cbnz	r0, 0x7009c648 <Udma_chDisableTxChan+0x98> @ imm = #0x2
7009c644: e7ff         	b	0x7009c646 <Udma_chDisableTxChan+0x96> @ imm = #-0x2
;                 break;
7009c646: e024         	b	0x7009c692 <Udma_chDisableTxChan+0xe2> @ imm = #0x48
;         }
7009c648: e011         	b	0x7009c66e <Udma_chDisableTxChan+0xbe> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c64a: 9814         	ldr	r0, [sp, #0x50]
7009c64c: 6800         	ldr	r0, [r0]
7009c64e: 2802         	cmp	r0, #0x2
7009c650: d10c         	bne	0x7009c66c <Udma_chDisableTxChan+0xbc> @ imm = #0x18
7009c652: e7ff         	b	0x7009c654 <Udma_chDisableTxChan+0xa4> @ imm = #-0x2
;             (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009c654: 9814         	ldr	r0, [sp, #0x50]
7009c656: 3054         	adds	r0, #0x54
7009c658: 9919         	ldr	r1, [sp, #0x64]
7009c65a: 6ec9         	ldr	r1, [r1, #0x6c]
7009c65c: aa09         	add	r2, sp, #0x24
7009c65e: f010 fda7    	bl	0x700ad1b0 <CSL_pktdmaGetTxRT> @ imm = #0x10b4e
;             if(FALSE == pktdmaRtStatus.enable)
7009c662: 9809         	ldr	r0, [sp, #0x24]
7009c664: b908         	cbnz	r0, 0x7009c66a <Udma_chDisableTxChan+0xba> @ imm = #0x2
7009c666: e7ff         	b	0x7009c668 <Udma_chDisableTxChan+0xb8> @ imm = #-0x2
;                 break;
7009c668: e013         	b	0x7009c692 <Udma_chDisableTxChan+0xe2> @ imm = #0x26
;         }
7009c66a: e7ff         	b	0x7009c66c <Udma_chDisableTxChan+0xbc> @ imm = #-0x2
7009c66c: e7ff         	b	0x7009c66e <Udma_chDisableTxChan+0xbe> @ imm = #-0x2
;         if(currTimeout > timeout)
7009c66e: 9815         	ldr	r0, [sp, #0x54]
7009c670: 9918         	ldr	r1, [sp, #0x60]
7009c672: 4288         	cmp	r0, r1
7009c674: d904         	bls	0x7009c680 <Udma_chDisableTxChan+0xd0> @ imm = #0x8
7009c676: e7ff         	b	0x7009c678 <Udma_chDisableTxChan+0xc8> @ imm = #-0x2
7009c678: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009c67c: 9017         	str	r0, [sp, #0x5c]
;         }
7009c67e: e007         	b	0x7009c690 <Udma_chDisableTxChan+0xe0> @ imm = #0xe
7009c680: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009c684: f00e fc54    	bl	0x700aaf30 <ClockP_usleep> @ imm = #0xe8a8
;             currTimeout++;
7009c688: 9815         	ldr	r0, [sp, #0x54]
7009c68a: 3001         	adds	r0, #0x1
7009c68c: 9015         	str	r0, [sp, #0x54]
7009c68e: e7ff         	b	0x7009c690 <Udma_chDisableTxChan+0xe0> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009c690: e7c3         	b	0x7009c61a <Udma_chDisableTxChan+0x6a> @ imm = #-0x7a
;     if(UDMA_SOK != retVal)
7009c692: 9817         	ldr	r0, [sp, #0x5c]
7009c694: 2800         	cmp	r0, #0x0
7009c696: f000 80e4    	beq.w	0x7009c862 <Udma_chDisableTxChan+0x2b2> @ imm = #0x1c8
7009c69a: e7ff         	b	0x7009c69c <Udma_chDisableTxChan+0xec> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c69c: 9814         	ldr	r0, [sp, #0x50]
7009c69e: 6800         	ldr	r0, [r0]
7009c6a0: 2801         	cmp	r0, #0x1
7009c6a2: d10e         	bne	0x7009c6c2 <Udma_chDisableTxChan+0x112> @ imm = #0x1c
7009c6a4: e7ff         	b	0x7009c6a6 <Udma_chDisableTxChan+0xf6> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, (bool)true, (bool)false);
7009c6a6: 9a14         	ldr	r2, [sp, #0x50]
7009c6a8: f102 0008    	add.w	r0, r2, #0x8
7009c6ac: 9919         	ldr	r1, [sp, #0x64]
7009c6ae: 6ec9         	ldr	r1, [r1, #0x6c]
7009c6b0: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c6b4: 4411         	add	r1, r2
7009c6b6: 2201         	movs	r2, #0x1
7009c6b8: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownTxChan(
7009c6ba: f010 ff29    	bl	0x700ad510 <CSL_bcdmaTeardownTxChan> @ imm = #0x10e52
7009c6be: 9017         	str	r0, [sp, #0x5c]
;         }
7009c6c0: e00f         	b	0x7009c6e2 <Udma_chDisableTxChan+0x132> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c6c2: 9814         	ldr	r0, [sp, #0x50]
7009c6c4: 6800         	ldr	r0, [r0]
7009c6c6: 2802         	cmp	r0, #0x2
7009c6c8: d10a         	bne	0x7009c6e0 <Udma_chDisableTxChan+0x130> @ imm = #0x14
7009c6ca: e7ff         	b	0x7009c6cc <Udma_chDisableTxChan+0x11c> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009c6cc: 9814         	ldr	r0, [sp, #0x50]
7009c6ce: 3054         	adds	r0, #0x54
7009c6d0: 9919         	ldr	r1, [sp, #0x64]
7009c6d2: 6ec9         	ldr	r1, [r1, #0x6c]
7009c6d4: 2201         	movs	r2, #0x1
7009c6d6: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownTxChan(
7009c6d8: f011 fdc2    	bl	0x700ae260 <CSL_pktdmaTeardownTxChan> @ imm = #0x11b84
7009c6dc: 9017         	str	r0, [sp, #0x5c]
;         }
7009c6de: e7ff         	b	0x7009c6e0 <Udma_chDisableTxChan+0x130> @ imm = #-0x2
7009c6e0: e7ff         	b	0x7009c6e2 <Udma_chDisableTxChan+0x132> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009c6e2: 9817         	ldr	r0, [sp, #0x5c]
7009c6e4: b108         	cbz	r0, 0x7009c6ea <Udma_chDisableTxChan+0x13a> @ imm = #0x2
7009c6e6: e7ff         	b	0x7009c6e8 <Udma_chDisableTxChan+0x138> @ imm = #-0x2
;         }
7009c6e8: e7ff         	b	0x7009c6ea <Udma_chDisableTxChan+0x13a> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c6ea: 9814         	ldr	r0, [sp, #0x50]
7009c6ec: 6800         	ldr	r0, [r0]
7009c6ee: 2801         	cmp	r0, #0x1
7009c6f0: d128         	bne	0x7009c744 <Udma_chDisableTxChan+0x194> @ imm = #0x50
7009c6f2: e7ff         	b	0x7009c6f4 <Udma_chDisableTxChan+0x144> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs,
7009c6f4: 9a14         	ldr	r2, [sp, #0x50]
7009c6f6: f102 0008    	add.w	r0, r2, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009c6fa: 9919         	ldr	r1, [sp, #0x64]
7009c6fc: 6ec9         	ldr	r1, [r1, #0x6c]
7009c6fe: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c702: 4411         	add	r1, r2
;                 rtEnableRegOffset,
7009c704: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaGetChanPeerReg(
7009c706: 46ec         	mov	r12, sp
7009c708: aa16         	add	r2, sp, #0x58
7009c70a: 9206         	str	r2, [sp, #0x18]
7009c70c: f8cc 2000    	str.w	r2, [r12]
7009c710: 2200         	movs	r2, #0x0
7009c712: 9207         	str	r2, [sp, #0x1c]
7009c714: f010 ffc4    	bl	0x700ad6a0 <CSL_bcdmaGetChanPeerReg> @ imm = #0x10f88
7009c718: f8dd c018    	ldr.w	r12, [sp, #0x18]
7009c71c: 9a07         	ldr	r2, [sp, #0x1c]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_FLUSH, (uint32_t) 1U);
7009c71e: 9816         	ldr	r0, [sp, #0x58]
7009c720: f040 5080    	orr	r0, r0, #0x10000000
7009c724: 9016         	str	r0, [sp, #0x58]
;                 &drvHandle->bcdmaRegs,
7009c726: 9b14         	ldr	r3, [sp, #0x50]
7009c728: f103 0008    	add.w	r0, r3, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009c72c: 9919         	ldr	r1, [sp, #0x64]
7009c72e: 6ec9         	ldr	r1, [r1, #0x6c]
7009c730: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
7009c734: 4419         	add	r1, r3
;                 rtEnableRegOffset,
7009c736: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaSetChanPeerReg(
7009c738: 46ee         	mov	lr, sp
7009c73a: f8ce c000    	str.w	r12, [lr]
7009c73e: f011 fa8f    	bl	0x700adc60 <CSL_bcdmaSetChanPeerReg> @ imm = #0x1151e
;         }
7009c742: e025         	b	0x7009c790 <Udma_chDisableTxChan+0x1e0> @ imm = #0x4a
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c744: 9814         	ldr	r0, [sp, #0x50]
7009c746: 6800         	ldr	r0, [r0]
7009c748: 2802         	cmp	r0, #0x2
7009c74a: d120         	bne	0x7009c78e <Udma_chDisableTxChan+0x1de> @ imm = #0x40
7009c74c: e7ff         	b	0x7009c74e <Udma_chDisableTxChan+0x19e> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs,
7009c74e: 9814         	ldr	r0, [sp, #0x50]
7009c750: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009c752: 9919         	ldr	r1, [sp, #0x64]
7009c754: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009c756: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaGetChanPeerReg(
7009c758: 46ec         	mov	r12, sp
7009c75a: aa16         	add	r2, sp, #0x58
7009c75c: 9204         	str	r2, [sp, #0x10]
7009c75e: f8cc 2000    	str.w	r2, [r12]
7009c762: 2200         	movs	r2, #0x0
7009c764: 9205         	str	r2, [sp, #0x14]
7009c766: f011 fef3    	bl	0x700ae550 <CSL_pktdmaGetChanPeerReg> @ imm = #0x11de6
7009c76a: f8dd c010    	ldr.w	r12, [sp, #0x10]
7009c76e: 9a05         	ldr	r2, [sp, #0x14]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_FLUSH, (uint32_t) 1U);
7009c770: 9816         	ldr	r0, [sp, #0x58]
7009c772: f040 5080    	orr	r0, r0, #0x10000000
7009c776: 9016         	str	r0, [sp, #0x58]
;                 &drvHandle->pktdmaRegs,
7009c778: 9814         	ldr	r0, [sp, #0x50]
7009c77a: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009c77c: 9919         	ldr	r1, [sp, #0x64]
7009c77e: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009c780: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaSetChanPeerReg(
7009c782: 46ee         	mov	lr, sp
7009c784: f8ce c000    	str.w	r12, [lr]
7009c788: f011 fefa    	bl	0x700ae580 <CSL_pktdmaSetChanPeerReg> @ imm = #0x11df4
;         }
7009c78c: e7ff         	b	0x7009c78e <Udma_chDisableTxChan+0x1de> @ imm = #-0x2
7009c78e: e7ff         	b	0x7009c790 <Udma_chDisableTxChan+0x1e0> @ imm = #-0x2
7009c790: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009c792: 9015         	str	r0, [sp, #0x54]
;         while(UDMA_SOK == retVal)
7009c794: e7ff         	b	0x7009c796 <Udma_chDisableTxChan+0x1e6> @ imm = #-0x2
7009c796: 9817         	ldr	r0, [sp, #0x5c]
7009c798: 2800         	cmp	r0, #0x0
7009c79a: d161         	bne	0x7009c860 <Udma_chDisableTxChan+0x2b0> @ imm = #0xc2
7009c79c: e7ff         	b	0x7009c79e <Udma_chDisableTxChan+0x1ee> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c79e: 9814         	ldr	r0, [sp, #0x50]
7009c7a0: 6800         	ldr	r0, [r0]
7009c7a2: 2801         	cmp	r0, #0x1
7009c7a4: d126         	bne	0x7009c7f4 <Udma_chDisableTxChan+0x244> @ imm = #0x4c
7009c7a6: e7ff         	b	0x7009c7a8 <Udma_chDisableTxChan+0x1f8> @ imm = #-0x2
;                 (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009c7a8: 9a14         	ldr	r2, [sp, #0x50]
7009c7aa: f102 0008    	add.w	r0, r2, #0x8
7009c7ae: 9919         	ldr	r1, [sp, #0x64]
7009c7b0: 6ec9         	ldr	r1, [r1, #0x6c]
7009c7b2: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c7b6: 4411         	add	r1, r2
7009c7b8: aa0e         	add	r2, sp, #0x38
7009c7ba: f012 f849    	bl	0x700ae850 <CSL_bcdmaGetTxRT> @ imm = #0x12092
;                     &drvHandle->bcdmaRegs,
7009c7be: 9a14         	ldr	r2, [sp, #0x50]
7009c7c0: f102 0008    	add.w	r0, r2, #0x8
;                     chHandle->txChNum + drvHandle->txChOffset,
7009c7c4: 9919         	ldr	r1, [sp, #0x64]
7009c7c6: 6ec9         	ldr	r1, [r1, #0x6c]
7009c7c8: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c7cc: 4411         	add	r1, r2
;                     rtEnableRegOffset, &peerRtEnable);
7009c7ce: 9b08         	ldr	r3, [sp, #0x20]
;                 (void) CSL_bcdmaGetChanPeerReg(
7009c7d0: 46ec         	mov	r12, sp
7009c7d2: aa16         	add	r2, sp, #0x58
7009c7d4: f8cc 2000    	str.w	r2, [r12]
7009c7d8: 2200         	movs	r2, #0x0
7009c7da: f010 ff61    	bl	0x700ad6a0 <CSL_bcdmaGetChanPeerReg> @ imm = #0x10ec2
;                 if((FALSE == bcdmaRtStatus.enable) &&
7009c7de: 980e         	ldr	r0, [sp, #0x38]
7009c7e0: b938         	cbnz	r0, 0x7009c7f2 <Udma_chDisableTxChan+0x242> @ imm = #0xe
7009c7e2: e7ff         	b	0x7009c7e4 <Udma_chDisableTxChan+0x234> @ imm = #-0x2
;                 (CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE) == FALSE))
7009c7e4: 9916         	ldr	r1, [sp, #0x58]
7009c7e6: 2000         	movs	r0, #0x0
;                 if((FALSE == bcdmaRtStatus.enable) &&
7009c7e8: ebb0 7fd1    	cmp.w	r0, r1, lsr #31
7009c7ec: d101         	bne	0x7009c7f2 <Udma_chDisableTxChan+0x242> @ imm = #0x2
7009c7ee: e7ff         	b	0x7009c7f0 <Udma_chDisableTxChan+0x240> @ imm = #-0x2
;                     break;
7009c7f0: e036         	b	0x7009c860 <Udma_chDisableTxChan+0x2b0> @ imm = #0x6c
;             }
7009c7f2: e023         	b	0x7009c83c <Udma_chDisableTxChan+0x28c> @ imm = #0x46
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c7f4: 9814         	ldr	r0, [sp, #0x50]
7009c7f6: 6800         	ldr	r0, [r0]
7009c7f8: 2802         	cmp	r0, #0x2
7009c7fa: d11e         	bne	0x7009c83a <Udma_chDisableTxChan+0x28a> @ imm = #0x3c
7009c7fc: e7ff         	b	0x7009c7fe <Udma_chDisableTxChan+0x24e> @ imm = #-0x2
;                 (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009c7fe: 9814         	ldr	r0, [sp, #0x50]
7009c800: 3054         	adds	r0, #0x54
7009c802: 9919         	ldr	r1, [sp, #0x64]
7009c804: 6ec9         	ldr	r1, [r1, #0x6c]
7009c806: aa09         	add	r2, sp, #0x24
7009c808: f010 fcd2    	bl	0x700ad1b0 <CSL_pktdmaGetTxRT> @ imm = #0x109a4
;                     &drvHandle->pktdmaRegs,
7009c80c: 9814         	ldr	r0, [sp, #0x50]
7009c80e: 3054         	adds	r0, #0x54
;                     chHandle->txChNum,
7009c810: 9919         	ldr	r1, [sp, #0x64]
7009c812: 6ec9         	ldr	r1, [r1, #0x6c]
;                     rtEnableRegOffset, &peerRtEnable);
7009c814: 9b08         	ldr	r3, [sp, #0x20]
;                 (void) CSL_pktdmaGetChanPeerReg(
7009c816: 46ec         	mov	r12, sp
7009c818: aa16         	add	r2, sp, #0x58
7009c81a: f8cc 2000    	str.w	r2, [r12]
7009c81e: 2200         	movs	r2, #0x0
7009c820: f011 fe96    	bl	0x700ae550 <CSL_pktdmaGetChanPeerReg> @ imm = #0x11d2c
;                 if((FALSE == pktdmaRtStatus.enable) &&
7009c824: 9809         	ldr	r0, [sp, #0x24]
7009c826: b938         	cbnz	r0, 0x7009c838 <Udma_chDisableTxChan+0x288> @ imm = #0xe
7009c828: e7ff         	b	0x7009c82a <Udma_chDisableTxChan+0x27a> @ imm = #-0x2
;                 (CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE) == FALSE))
7009c82a: 9916         	ldr	r1, [sp, #0x58]
7009c82c: 2000         	movs	r0, #0x0
;                 if((FALSE == pktdmaRtStatus.enable) &&
7009c82e: ebb0 7fd1    	cmp.w	r0, r1, lsr #31
7009c832: d101         	bne	0x7009c838 <Udma_chDisableTxChan+0x288> @ imm = #0x2
7009c834: e7ff         	b	0x7009c836 <Udma_chDisableTxChan+0x286> @ imm = #-0x2
;                     break;
7009c836: e013         	b	0x7009c860 <Udma_chDisableTxChan+0x2b0> @ imm = #0x26
;             }
7009c838: e7ff         	b	0x7009c83a <Udma_chDisableTxChan+0x28a> @ imm = #-0x2
7009c83a: e7ff         	b	0x7009c83c <Udma_chDisableTxChan+0x28c> @ imm = #-0x2
;             if(currTimeout > timeout)
7009c83c: 9815         	ldr	r0, [sp, #0x54]
7009c83e: 9918         	ldr	r1, [sp, #0x60]
7009c840: 4288         	cmp	r0, r1
7009c842: d904         	bls	0x7009c84e <Udma_chDisableTxChan+0x29e> @ imm = #0x8
7009c844: e7ff         	b	0x7009c846 <Udma_chDisableTxChan+0x296> @ imm = #-0x2
7009c846: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009c84a: 9017         	str	r0, [sp, #0x5c]
;             }
7009c84c: e007         	b	0x7009c85e <Udma_chDisableTxChan+0x2ae> @ imm = #0xe
7009c84e: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009c852: f00e fb6d    	bl	0x700aaf30 <ClockP_usleep> @ imm = #0xe6da
;                 currTimeout++;
7009c856: 9815         	ldr	r0, [sp, #0x54]
7009c858: 3001         	adds	r0, #0x1
7009c85a: 9015         	str	r0, [sp, #0x54]
7009c85c: e7ff         	b	0x7009c85e <Udma_chDisableTxChan+0x2ae> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009c85e: e79a         	b	0x7009c796 <Udma_chDisableTxChan+0x1e6> @ imm = #-0xcc
;     }
7009c860: e7ff         	b	0x7009c862 <Udma_chDisableTxChan+0x2b2> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c862: 9817         	ldr	r0, [sp, #0x5c]
7009c864: 2800         	cmp	r0, #0x0
7009c866: d150         	bne	0x7009c90a <Udma_chDisableTxChan+0x35a> @ imm = #0xa0
7009c868: e7ff         	b	0x7009c86a <Udma_chDisableTxChan+0x2ba> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c86a: 9814         	ldr	r0, [sp, #0x50]
7009c86c: 6800         	ldr	r0, [r0]
7009c86e: 2801         	cmp	r0, #0x1
7009c870: d126         	bne	0x7009c8c0 <Udma_chDisableTxChan+0x310> @ imm = #0x4c
7009c872: e7ff         	b	0x7009c874 <Udma_chDisableTxChan+0x2c4> @ imm = #-0x2
7009c874: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.enable   = FALSE;
7009c876: 9003         	str	r0, [sp, #0xc]
7009c878: 900e         	str	r0, [sp, #0x38]
;             bcdmaRtStatus.teardown = FALSE;
7009c87a: 900f         	str	r0, [sp, #0x3c]
;             bcdmaRtStatus.forcedTeardown = FALSE;
7009c87c: 9012         	str	r0, [sp, #0x48]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 0U);
7009c87e: 9816         	ldr	r0, [sp, #0x58]
7009c880: f020 4080    	bic	r0, r0, #0x40000000
7009c884: 9016         	str	r0, [sp, #0x58]
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009c886: 9a14         	ldr	r2, [sp, #0x50]
7009c888: f102 0008    	add.w	r0, r2, #0x8
7009c88c: 9919         	ldr	r1, [sp, #0x64]
7009c88e: 6ec9         	ldr	r1, [r1, #0x6c]
7009c890: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c894: 4411         	add	r1, r2
7009c896: aa0e         	add	r2, sp, #0x38
7009c898: f012 f80a    	bl	0x700ae8b0 <CSL_bcdmaSetTxRT> @ imm = #0x12014
7009c89c: 9a03         	ldr	r2, [sp, #0xc]
;                 &drvHandle->bcdmaRegs,
7009c89e: 9b14         	ldr	r3, [sp, #0x50]
7009c8a0: f103 0008    	add.w	r0, r3, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009c8a4: 9919         	ldr	r1, [sp, #0x64]
7009c8a6: 6ec9         	ldr	r1, [r1, #0x6c]
7009c8a8: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
7009c8ac: 4419         	add	r1, r3
;                 rtEnableRegOffset,
7009c8ae: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaSetChanPeerReg(
7009c8b0: 46ee         	mov	lr, sp
7009c8b2: f10d 0c58    	add.w	r12, sp, #0x58
7009c8b6: f8ce c000    	str.w	r12, [lr]
7009c8ba: f011 f9d1    	bl	0x700adc60 <CSL_bcdmaSetChanPeerReg> @ imm = #0x113a2
;         }
7009c8be: e023         	b	0x7009c908 <Udma_chDisableTxChan+0x358> @ imm = #0x46
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c8c0: 9814         	ldr	r0, [sp, #0x50]
7009c8c2: 6800         	ldr	r0, [r0]
7009c8c4: 2802         	cmp	r0, #0x2
7009c8c6: d11e         	bne	0x7009c906 <Udma_chDisableTxChan+0x356> @ imm = #0x3c
7009c8c8: e7ff         	b	0x7009c8ca <Udma_chDisableTxChan+0x31a> @ imm = #-0x2
7009c8ca: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.enable   = FALSE;
7009c8cc: 9002         	str	r0, [sp, #0x8]
7009c8ce: 9009         	str	r0, [sp, #0x24]
;             pktdmaRtStatus.teardown = FALSE;
7009c8d0: 900a         	str	r0, [sp, #0x28]
;             pktdmaRtStatus.forcedTeardown = FALSE;
7009c8d2: 900d         	str	r0, [sp, #0x34]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 0U);
7009c8d4: 9816         	ldr	r0, [sp, #0x58]
7009c8d6: f020 4080    	bic	r0, r0, #0x40000000
7009c8da: 9016         	str	r0, [sp, #0x58]
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009c8dc: 9814         	ldr	r0, [sp, #0x50]
7009c8de: 3054         	adds	r0, #0x54
7009c8e0: 9919         	ldr	r1, [sp, #0x64]
7009c8e2: 6ec9         	ldr	r1, [r1, #0x6c]
7009c8e4: aa09         	add	r2, sp, #0x24
7009c8e6: f011 fa1b    	bl	0x700add20 <CSL_pktdmaSetTxRT> @ imm = #0x11436
7009c8ea: 9a02         	ldr	r2, [sp, #0x8]
;                 &drvHandle->pktdmaRegs,
7009c8ec: 9814         	ldr	r0, [sp, #0x50]
7009c8ee: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009c8f0: 9919         	ldr	r1, [sp, #0x64]
7009c8f2: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009c8f4: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaSetChanPeerReg(
7009c8f6: 46ee         	mov	lr, sp
7009c8f8: f10d 0c58    	add.w	r12, sp, #0x58
7009c8fc: f8ce c000    	str.w	r12, [lr]
7009c900: f011 fe3e    	bl	0x700ae580 <CSL_pktdmaSetChanPeerReg> @ imm = #0x11c7c
;         }
7009c904: e7ff         	b	0x7009c906 <Udma_chDisableTxChan+0x356> @ imm = #-0x2
7009c906: e7ff         	b	0x7009c908 <Udma_chDisableTxChan+0x358> @ imm = #-0x2
;     }
7009c908: e7ff         	b	0x7009c90a <Udma_chDisableTxChan+0x35a> @ imm = #-0x2
;     return (retVal);
7009c90a: 9817         	ldr	r0, [sp, #0x5c]
7009c90c: b01a         	add	sp, #0x68
7009c90e: bd80         	pop	{r7, pc}

7009c910 <Udma_eventConfig>:
; {
7009c910: b580         	push	{r7, lr}
7009c912: b098         	sub	sp, #0x60
7009c914: 9017         	str	r0, [sp, #0x5c]
7009c916: 9116         	str	r1, [sp, #0x58]
7009c918: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009c91a: 9001         	str	r0, [sp, #0x4]
7009c91c: 9015         	str	r0, [sp, #0x54]
;     eventPrms = &eventHandle->eventPrms;
7009c91e: 9916         	ldr	r1, [sp, #0x58]
7009c920: 3108         	adds	r1, #0x8
7009c922: 9110         	str	r1, [sp, #0x40]
;     rmIrqReq.valid_params           = 0U;
7009c924: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.global_event           = 0U;
7009c926: f8ad 0028    	strh.w	r0, [sp, #0x28]
;     rmIrqReq.src_id                 = 0U;
7009c92a: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.src_index              = 0U;
7009c92e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     rmIrqReq.dst_id                 = 0U;
7009c932: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     rmIrqReq.dst_host_irq           = 0U;
7009c936: f8ad 0022    	strh.w	r0, [sp, #0x22]
;     rmIrqReq.ia_id                  = 0U;
7009c93a: f8ad 0024    	strh.w	r0, [sp, #0x24]
;     rmIrqReq.vint                   = 0U;
7009c93e: f8ad 0026    	strh.w	r0, [sp, #0x26]
;     rmIrqReq.vint_status_bit_index  = 0U;
7009c942: f88d 002a    	strb.w	r0, [sp, #0x2a]
7009c946: 20ff         	movs	r0, #0xff
;     rmIrqReq.secondary_host         = TISCI_MSG_VALUE_RM_UNUSED_SECONDARY_HOST;
7009c948: f88d 002b    	strb.w	r0, [sp, #0x2b]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009c94c: 9810         	ldr	r0, [sp, #0x40]
7009c94e: 6800         	ldr	r0, [r0]
7009c950: 2805         	cmp	r0, #0x5
7009c952: d00a         	beq	0x7009c96a <Udma_eventConfig+0x5a> @ imm = #0x14
7009c954: e7ff         	b	0x7009c956 <Udma_eventConfig+0x46> @ imm = #-0x2
;         rmIrqReq.valid_params  |= TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID;
7009c956: 9806         	ldr	r0, [sp, #0x18]
7009c958: f040 0010    	orr	r0, r0, #0x10
7009c95c: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.global_event   = (uint16_t)Udma_eventGetId(eventHandle);
7009c95e: 9816         	ldr	r0, [sp, #0x58]
7009c960: f010 fbd6    	bl	0x700ad110 <Udma_eventGetId> @ imm = #0x107ac
7009c964: f8ad 0028    	strh.w	r0, [sp, #0x28]
;     }
7009c968: e7ff         	b	0x7009c96a <Udma_eventConfig+0x5a> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009c96a: 9816         	ldr	r0, [sp, #0x58]
7009c96c: 6d80         	ldr	r0, [r0, #0x58]
7009c96e: f510 3f80    	cmn.w	r0, #0x10000
7009c972: d012         	beq	0x7009c99a <Udma_eventConfig+0x8a> @ imm = #0x24
7009c974: e7ff         	b	0x7009c976 <Udma_eventConfig+0x66> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_ID_VALID;
7009c976: 9806         	ldr	r0, [sp, #0x18]
7009c978: f040 0001    	orr	r0, r0, #0x1
7009c97c: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID;
7009c97e: 9806         	ldr	r0, [sp, #0x18]
7009c980: f040 0002    	orr	r0, r0, #0x2
7009c984: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.dst_id        = drvHandle->devIdCore;
7009c986: 9817         	ldr	r0, [sp, #0x5c]
7009c988: f8b0 00ea    	ldrh.w	r0, [r0, #0xea]
7009c98c: f8ad 0020    	strh.w	r0, [sp, #0x20]
;         rmIrqReq.dst_host_irq  = (uint16_t)eventHandle->coreIntrNum;
7009c990: 9816         	ldr	r0, [sp, #0x58]
7009c992: 6d80         	ldr	r0, [r0, #0x58]
7009c994: f8ad 0022    	strh.w	r0, [sp, #0x22]
;     }
7009c998: e7ff         	b	0x7009c99a <Udma_eventConfig+0x8a> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->eventPrms.controllerEventHandle)
7009c99a: 9816         	ldr	r0, [sp, #0x58]
7009c99c: 6980         	ldr	r0, [r0, #0x18]
7009c99e: b128         	cbz	r0, 0x7009c9ac <Udma_eventConfig+0x9c> @ imm = #0xa
7009c9a0: e7ff         	b	0x7009c9a2 <Udma_eventConfig+0x92> @ imm = #-0x2
;         vintrNum = ((Udma_EventHandleInt) (eventHandle->eventPrms.controllerEventHandle))->vintrNum;
7009c9a2: 9816         	ldr	r0, [sp, #0x58]
7009c9a4: 6980         	ldr	r0, [r0, #0x18]
7009c9a6: 6cc0         	ldr	r0, [r0, #0x4c]
7009c9a8: 9014         	str	r0, [sp, #0x50]
;     }
7009c9aa: e003         	b	0x7009c9b4 <Udma_eventConfig+0xa4> @ imm = #0x6
;         vintrNum = eventHandle->vintrNum;
7009c9ac: 9816         	ldr	r0, [sp, #0x58]
7009c9ae: 6cc0         	ldr	r0, [r0, #0x4c]
7009c9b0: 9014         	str	r0, [sp, #0x50]
7009c9b2: e7ff         	b	0x7009c9b4 <Udma_eventConfig+0xa4> @ imm = #-0x2
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_IA_ID_VALID;
7009c9b4: 9806         	ldr	r0, [sp, #0x18]
7009c9b6: f040 0004    	orr	r0, r0, #0x4
7009c9ba: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_VALID;
7009c9bc: 9806         	ldr	r0, [sp, #0x18]
7009c9be: f040 0008    	orr	r0, r0, #0x8
7009c9c2: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.ia_id         = drvHandle->devIdIa;
7009c9c4: 9817         	ldr	r0, [sp, #0x5c]
7009c9c6: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009c9ca: f8ad 0024    	strh.w	r0, [sp, #0x24]
;     rmIrqReq.vint          = (uint16_t)vintrNum;
7009c9ce: 9814         	ldr	r0, [sp, #0x50]
7009c9d0: f8ad 0026    	strh.w	r0, [sp, #0x26]
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
7009c9d4: 9816         	ldr	r0, [sp, #0x58]
7009c9d6: 6d00         	ldr	r0, [r0, #0x50]
7009c9d8: f64f 71ff    	movw	r1, #0xffff
7009c9dc: 4288         	cmp	r0, r1
7009c9de: d009         	beq	0x7009c9f4 <Udma_eventConfig+0xe4> @ imm = #0x12
7009c9e0: e7ff         	b	0x7009c9e2 <Udma_eventConfig+0xd2> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_STATUS_BIT_INDEX_VALID;
7009c9e2: 9806         	ldr	r0, [sp, #0x18]
7009c9e4: f040 0020    	orr	r0, r0, #0x20
7009c9e8: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.vint_status_bit_index  = (uint8_t)eventHandle->vintrBitNum;
7009c9ea: 9816         	ldr	r0, [sp, #0x58]
7009c9ec: 6d00         	ldr	r0, [r0, #0x50]
7009c9ee: f88d 002a    	strb.w	r0, [sp, #0x2a]
;     }
7009c9f2: e7ff         	b	0x7009c9f4 <Udma_eventConfig+0xe4> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009c9f4: 9810         	ldr	r0, [sp, #0x40]
7009c9f6: 6800         	ldr	r0, [r0]
7009c9f8: 2801         	cmp	r0, #0x1
7009c9fa: d00a         	beq	0x7009ca12 <Udma_eventConfig+0x102> @ imm = #0x14
7009c9fc: e7ff         	b	0x7009c9fe <Udma_eventConfig+0xee> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType) ||
7009c9fe: 9810         	ldr	r0, [sp, #0x40]
7009ca00: 6800         	ldr	r0, [r0]
7009ca02: 2802         	cmp	r0, #0x2
7009ca04: d005         	beq	0x7009ca12 <Udma_eventConfig+0x102> @ imm = #0xa
7009ca06: e7ff         	b	0x7009ca08 <Udma_eventConfig+0xf8> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009ca08: 9810         	ldr	r0, [sp, #0x40]
7009ca0a: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009ca0c: 2806         	cmp	r0, #0x6
7009ca0e: d14d         	bne	0x7009caac <Udma_eventConfig+0x19c> @ imm = #0x9a
7009ca10: e7ff         	b	0x7009ca12 <Udma_eventConfig+0x102> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009ca12: 9810         	ldr	r0, [sp, #0x40]
7009ca14: 6880         	ldr	r0, [r0, #0x8]
7009ca16: 9012         	str	r0, [sp, #0x48]
;         rmIrqReq.src_id = drvHandle->srcIdRingIrq;
7009ca18: 9817         	ldr	r0, [sp, #0x5c]
7009ca1a: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009ca1e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009ca22: 9810         	ldr	r0, [sp, #0x40]
7009ca24: 6800         	ldr	r0, [r0]
7009ca26: 2801         	cmp	r0, #0x1
7009ca28: d005         	beq	0x7009ca36 <Udma_eventConfig+0x126> @ imm = #0xa
7009ca2a: e7ff         	b	0x7009ca2c <Udma_eventConfig+0x11c> @ imm = #-0x2
7009ca2c: 9810         	ldr	r0, [sp, #0x40]
7009ca2e: 6800         	ldr	r0, [r0]
7009ca30: 2806         	cmp	r0, #0x6
7009ca32: d12e         	bne	0x7009ca92 <Udma_eventConfig+0x182> @ imm = #0x5c
7009ca34: e7ff         	b	0x7009ca36 <Udma_eventConfig+0x126> @ imm = #-0x2
;             rmIrqReq.src_index = chHandle->cqRing->ringNum;
7009ca36: 9812         	ldr	r0, [sp, #0x48]
7009ca38: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009ca3c: 8880         	ldrh	r0, [r0, #0x4]
7009ca3e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009ca42: 9812         	ldr	r0, [sp, #0x48]
7009ca44: 7800         	ldrb	r0, [r0]
7009ca46: 0740         	lsls	r0, r0, #0x1d
7009ca48: 2800         	cmp	r0, #0x0
7009ca4a: d509         	bpl	0x7009ca60 <Udma_eventConfig+0x150> @ imm = #0x12
7009ca4c: e7ff         	b	0x7009ca4e <Udma_eventConfig+0x13e> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->blkCopyRingIrqOffset;
7009ca4e: 9817         	ldr	r0, [sp, #0x5c]
7009ca50: f8d0 10f0    	ldr.w	r1, [r0, #0xf0]
7009ca54: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009ca58: 4408         	add	r0, r1
7009ca5a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009ca5e: e017         	b	0x7009ca90 <Udma_eventConfig+0x180> @ imm = #0x2e
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009ca60: 9812         	ldr	r0, [sp, #0x48]
7009ca62: 7800         	ldrb	r0, [r0]
7009ca64: 07c0         	lsls	r0, r0, #0x1f
7009ca66: b148         	cbz	r0, 0x7009ca7c <Udma_eventConfig+0x16c> @ imm = #0x12
7009ca68: e7ff         	b	0x7009ca6a <Udma_eventConfig+0x15a> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009ca6a: 9817         	ldr	r0, [sp, #0x5c]
7009ca6c: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009ca70: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009ca74: 4408         	add	r0, r1
7009ca76: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009ca7a: e008         	b	0x7009ca8e <Udma_eventConfig+0x17e> @ imm = #0x10
;                 rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009ca7c: 9817         	ldr	r0, [sp, #0x5c]
7009ca7e: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009ca82: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009ca86: 4408         	add	r0, r1
7009ca88: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009ca8c: e7ff         	b	0x7009ca8e <Udma_eventConfig+0x17e> @ imm = #-0x2
7009ca8e: e7ff         	b	0x7009ca90 <Udma_eventConfig+0x180> @ imm = #-0x2
;         }
7009ca90: e00b         	b	0x7009caaa <Udma_eventConfig+0x19a> @ imm = #0x16
;             rmIrqReq.src_index = chHandle->tdCqRing->ringNum;
7009ca92: 9812         	ldr	r0, [sp, #0x48]
7009ca94: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009ca98: 8880         	ldrh	r0, [r0, #0x4]
7009ca9a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             rmIrqReq.src_index += TISCI_RINGACC0_OES_IRQ_SRC_IDX_START;
7009ca9e: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009caa2: 3014         	adds	r0, #0x14
7009caa4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009caa8: e7ff         	b	0x7009caaa <Udma_eventConfig+0x19a> @ imm = #-0x2
;     }
7009caaa: e7ff         	b	0x7009caac <Udma_eventConfig+0x19c> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009caac: 9810         	ldr	r0, [sp, #0x40]
7009caae: 6800         	ldr	r0, [r0]
7009cab0: 2803         	cmp	r0, #0x3
7009cab2: d156         	bne	0x7009cb62 <Udma_eventConfig+0x252> @ imm = #0xac
7009cab4: e7ff         	b	0x7009cab6 <Udma_eventConfig+0x1a6> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009cab6: 9817         	ldr	r0, [sp, #0x5c]
7009cab8: 6800         	ldr	r0, [r0]
7009caba: 2802         	cmp	r0, #0x2
7009cabc: d104         	bne	0x7009cac8 <Udma_eventConfig+0x1b8> @ imm = #0x8
7009cabe: e7ff         	b	0x7009cac0 <Udma_eventConfig+0x1b0> @ imm = #-0x2
7009cac0: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009cac4: 9015         	str	r0, [sp, #0x54]
;         }
7009cac6: e04b         	b	0x7009cb60 <Udma_eventConfig+0x250> @ imm = #0x96
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009cac8: 9810         	ldr	r0, [sp, #0x40]
7009caca: 6880         	ldr	r0, [r0, #0x8]
7009cacc: 9012         	str	r0, [sp, #0x48]
;             rmIrqReq.src_id = drvHandle->srcIdTrIrq;
7009cace: 9817         	ldr	r0, [sp, #0x5c]
7009cad0: f8b0 00fc    	ldrh.w	r0, [r0, #0xfc]
7009cad4: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009cad8: 9812         	ldr	r0, [sp, #0x48]
7009cada: 7800         	ldrb	r0, [r0]
7009cadc: 0740         	lsls	r0, r0, #0x1d
7009cade: 2800         	cmp	r0, #0x0
7009cae0: d50d         	bpl	0x7009cafe <Udma_eventConfig+0x1ee> @ imm = #0x1a
7009cae2: e7ff         	b	0x7009cae4 <Udma_eventConfig+0x1d4> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009cae4: 9812         	ldr	r0, [sp, #0x48]
7009cae6: 6ec0         	ldr	r0, [r0, #0x6c]
7009cae8: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->blkCopyTrIrqOffset;
7009caec: 9817         	ldr	r0, [sp, #0x5c]
7009caee: f8d0 1100    	ldr.w	r1, [r0, #0x100]
7009caf2: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009caf6: 4408         	add	r0, r1
7009caf8: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009cafc: e02f         	b	0x7009cb5e <Udma_eventConfig+0x24e> @ imm = #0x5e
;             else if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009cafe: 9812         	ldr	r0, [sp, #0x48]
7009cb00: 7800         	ldrb	r0, [r0]
7009cb02: 0780         	lsls	r0, r0, #0x1e
7009cb04: 2800         	cmp	r0, #0x0
7009cb06: d50d         	bpl	0x7009cb24 <Udma_eventConfig+0x214> @ imm = #0x1a
7009cb08: e7ff         	b	0x7009cb0a <Udma_eventConfig+0x1fa> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->rxChNum;
7009cb0a: 9812         	ldr	r0, [sp, #0x48]
7009cb0c: 6f00         	ldr	r0, [r0, #0x70]
7009cb0e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->rxTrIrqOffset;
7009cb12: 9817         	ldr	r0, [sp, #0x5c]
7009cb14: f8d0 1108    	ldr.w	r1, [r0, #0x108]
7009cb18: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cb1c: 4408         	add	r0, r1
7009cb1e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009cb22: e01b         	b	0x7009cb5c <Udma_eventConfig+0x24c> @ imm = #0x36
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009cb24: 9812         	ldr	r0, [sp, #0x48]
7009cb26: 7800         	ldrb	r0, [r0]
7009cb28: 07c0         	lsls	r0, r0, #0x1f
7009cb2a: b168         	cbz	r0, 0x7009cb48 <Udma_eventConfig+0x238> @ imm = #0x1a
7009cb2c: e7ff         	b	0x7009cb2e <Udma_eventConfig+0x21e> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009cb2e: 9812         	ldr	r0, [sp, #0x48]
7009cb30: 6ec0         	ldr	r0, [r0, #0x6c]
7009cb32: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->txTrIrqOffset;
7009cb36: 9817         	ldr	r0, [sp, #0x5c]
7009cb38: f8d0 1104    	ldr.w	r1, [r0, #0x104]
7009cb3c: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cb40: 4408         	add	r0, r1
7009cb42: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009cb46: e008         	b	0x7009cb5a <Udma_eventConfig+0x24a> @ imm = #0x10
;                 rmIrqReq.src_id = drvHandle->devIdIa;
7009cb48: 9817         	ldr	r0, [sp, #0x5c]
7009cb4a: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009cb4e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
7009cb52: 2000         	movs	r0, #0x0
;                 rmIrqReq.src_index = 0U;                /* Not used by DMSC RM */
7009cb54: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009cb58: e7ff         	b	0x7009cb5a <Udma_eventConfig+0x24a> @ imm = #-0x2
7009cb5a: e7ff         	b	0x7009cb5c <Udma_eventConfig+0x24c> @ imm = #-0x2
7009cb5c: e7ff         	b	0x7009cb5e <Udma_eventConfig+0x24e> @ imm = #-0x2
7009cb5e: e7ff         	b	0x7009cb60 <Udma_eventConfig+0x250> @ imm = #-0x2
;     }
7009cb60: e7ff         	b	0x7009cb62 <Udma_eventConfig+0x252> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
7009cb62: 9810         	ldr	r0, [sp, #0x40]
7009cb64: 6800         	ldr	r0, [r0]
7009cb66: 2804         	cmp	r0, #0x4
7009cb68: d130         	bne	0x7009cbcc <Udma_eventConfig+0x2bc> @ imm = #0x60
7009cb6a: e7ff         	b	0x7009cb6c <Udma_eventConfig+0x25c> @ imm = #-0x2
;         ringHandle = (Udma_RingHandleInt) eventPrms->ringHandle;
7009cb6c: 9810         	ldr	r0, [sp, #0x40]
7009cb6e: 68c0         	ldr	r0, [r0, #0xc]
7009cb70: 9011         	str	r0, [sp, #0x44]
;         rmIrqReq.src_id     = drvHandle->srcIdRingIrq;
7009cb72: 9817         	ldr	r0, [sp, #0x5c]
7009cb74: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009cb78: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         rmIrqReq.src_index  = ringHandle->ringNum;
7009cb7c: 9811         	ldr	r0, [sp, #0x44]
7009cb7e: 8880         	ldrh	r0, [r0, #0x4]
7009cb80: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009cb84: 9817         	ldr	r0, [sp, #0x5c]
7009cb86: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009cb8a: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cb8e: 4408         	add	r0, r1
7009cb90: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009cb94: 9811         	ldr	r0, [sp, #0x44]
7009cb96: 6dc0         	ldr	r0, [r0, #0x5c]
7009cb98: 2804         	cmp	r0, #0x4
7009cb9a: d316         	blo	0x7009cbca <Udma_eventConfig+0x2ba> @ imm = #0x2c
7009cb9c: e7ff         	b	0x7009cb9e <Udma_eventConfig+0x28e> @ imm = #-0x2
;            (ringHandle->mappedRingGrp < (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
7009cb9e: 9811         	ldr	r0, [sp, #0x44]
7009cba0: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009cba2: 2807         	cmp	r0, #0x7
7009cba4: d811         	bhi	0x7009cbca <Udma_eventConfig+0x2ba> @ imm = #0x22
7009cba6: e7ff         	b	0x7009cba8 <Udma_eventConfig+0x298> @ imm = #-0x2
;             rmIrqReq.src_index -= drvHandle->txRingIrqOffset;
7009cba8: 9817         	ldr	r0, [sp, #0x5c]
7009cbaa: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009cbae: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cbb2: 1a40         	subs	r0, r0, r1
7009cbb4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009cbb8: 9817         	ldr	r0, [sp, #0x5c]
7009cbba: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009cbbe: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cbc2: 4408         	add	r0, r1
7009cbc4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         }
7009cbc8: e7ff         	b	0x7009cbca <Udma_eventConfig+0x2ba> @ imm = #-0x2
;     }
7009cbca: e7ff         	b	0x7009cbcc <Udma_eventConfig+0x2bc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009cbcc: 9815         	ldr	r0, [sp, #0x54]
7009cbce: b9d8         	cbnz	r0, 0x7009cc08 <Udma_eventConfig+0x2f8> @ imm = #0x36
7009cbd0: e7ff         	b	0x7009cbd2 <Udma_eventConfig+0x2c2> @ imm = #-0x2
;         Udma_eventProgramSteering(drvHandle, eventHandle);
7009cbd2: 9817         	ldr	r0, [sp, #0x5c]
7009cbd4: 9916         	ldr	r1, [sp, #0x58]
7009cbd6: f011 ffeb    	bl	0x700aebb0 <Udma_eventProgramSteering> @ imm = #0x11fd6
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009cbda: 9817         	ldr	r0, [sp, #0x5c]
7009cbdc: 6800         	ldr	r0, [r0]
7009cbde: b130         	cbz	r0, 0x7009cbee <Udma_eventConfig+0x2de> @ imm = #0xc
7009cbe0: e7ff         	b	0x7009cbe2 <Udma_eventConfig+0x2d2> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009cbe2: 9810         	ldr	r0, [sp, #0x40]
7009cbe4: 6800         	ldr	r0, [r0]
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009cbe6: 2805         	cmp	r0, #0x5
7009cbe8: d101         	bne	0x7009cbee <Udma_eventConfig+0x2de> @ imm = #0x2
7009cbea: e7ff         	b	0x7009cbec <Udma_eventConfig+0x2dc> @ imm = #-0x2
;         }
7009cbec: e00b         	b	0x7009cc06 <Udma_eventConfig+0x2f6> @ imm = #0x16
7009cbee: a804         	add	r0, sp, #0x10
7009cbf0: a902         	add	r1, sp, #0x8
7009cbf2: f04f 32ff    	mov.w	r2, #0xffffffff
;             retVal = Sciclient_rmIrqSet(
7009cbf6: f012 fbdb    	bl	0x700af3b0 <Sciclient_rmIrqSet> @ imm = #0x127b6
7009cbfa: 9015         	str	r0, [sp, #0x54]
;             if(CSL_PASS != retVal)
7009cbfc: 9815         	ldr	r0, [sp, #0x54]
7009cbfe: b108         	cbz	r0, 0x7009cc04 <Udma_eventConfig+0x2f4> @ imm = #0x2
7009cc00: e7ff         	b	0x7009cc02 <Udma_eventConfig+0x2f2> @ imm = #-0x2
;             }
7009cc02: e7ff         	b	0x7009cc04 <Udma_eventConfig+0x2f4> @ imm = #-0x2
7009cc04: e7ff         	b	0x7009cc06 <Udma_eventConfig+0x2f6> @ imm = #-0x2
;     }
7009cc06: e7ff         	b	0x7009cc08 <Udma_eventConfig+0x2f8> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009cc08: 9815         	ldr	r0, [sp, #0x54]
7009cc0a: bb58         	cbnz	r0, 0x7009cc64 <Udma_eventConfig+0x354> @ imm = #0x56
7009cc0c: e7ff         	b	0x7009cc0e <Udma_eventConfig+0x2fe> @ imm = #-0x2
;         if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009cc0e: 9816         	ldr	r0, [sp, #0x58]
7009cc10: 6d80         	ldr	r0, [r0, #0x58]
7009cc12: f510 3f80    	cmn.w	r0, #0x10000
7009cc16: d024         	beq	0x7009cc62 <Udma_eventConfig+0x352> @ imm = #0x48
7009cc18: e7ff         	b	0x7009cc1a <Udma_eventConfig+0x30a> @ imm = #-0x2
;             coreIntrNum = eventHandle->coreIntrNum;
7009cc1a: 9816         	ldr	r0, [sp, #0x58]
7009cc1c: 6d80         	ldr	r0, [r0, #0x58]
7009cc1e: 9013         	str	r0, [sp, #0x4c]
7009cc20: a80b         	add	r0, sp, #0x2c
;             HwiP_Params_init(&hwiPrms);
7009cc22: 9000         	str	r0, [sp]
7009cc24: f013 f814    	bl	0x700afc50 <HwiP_Params_init> @ imm = #0x13028
7009cc28: 9900         	ldr	r1, [sp]
;             hwiPrms.intNum = coreIntrNum;
7009cc2a: 9813         	ldr	r0, [sp, #0x4c]
7009cc2c: 900b         	str	r0, [sp, #0x2c]
;             hwiPrms.callback = &Udma_eventIsrFxn;
7009cc2e: f245 7021    	movw	r0, #0x5721
7009cc32: f2c7 000a    	movt	r0, #0x700a
7009cc36: 900c         	str	r0, [sp, #0x30]
;             hwiPrms.args = eventHandle;
7009cc38: 9816         	ldr	r0, [sp, #0x58]
7009cc3a: 900d         	str	r0, [sp, #0x34]
;             hwiPrms.priority = eventHandle->eventPrms.intrPriority;
7009cc3c: 9816         	ldr	r0, [sp, #0x58]
7009cc3e: 6a00         	ldr	r0, [r0, #0x20]
7009cc40: f88d 003a    	strb.w	r0, [sp, #0x3a]
;             retVal = HwiP_construct(&eventHandle->hwiObject, &hwiPrms);
7009cc44: 9816         	ldr	r0, [sp, #0x58]
7009cc46: 3068         	adds	r0, #0x68
7009cc48: f013 f81a    	bl	0x700afc80 <HwiP_construct> @ imm = #0x13034
7009cc4c: 9015         	str	r0, [sp, #0x54]
;             if(SystemP_SUCCESS != retVal)
7009cc4e: 9815         	ldr	r0, [sp, #0x54]
7009cc50: b108         	cbz	r0, 0x7009cc56 <Udma_eventConfig+0x346> @ imm = #0x2
7009cc52: e7ff         	b	0x7009cc54 <Udma_eventConfig+0x344> @ imm = #-0x2
;             }
7009cc54: e004         	b	0x7009cc60 <Udma_eventConfig+0x350> @ imm = #0x8
;                 eventHandle->hwiHandle = &eventHandle->hwiObject;
7009cc56: 9916         	ldr	r1, [sp, #0x58]
7009cc58: f101 0068    	add.w	r0, r1, #0x68
7009cc5c: 6648         	str	r0, [r1, #0x64]
7009cc5e: e7ff         	b	0x7009cc60 <Udma_eventConfig+0x350> @ imm = #-0x2
;         }
7009cc60: e7ff         	b	0x7009cc62 <Udma_eventConfig+0x352> @ imm = #-0x2
;     }
7009cc62: e7ff         	b	0x7009cc64 <Udma_eventConfig+0x354> @ imm = #-0x2
;     return (retVal);
7009cc64: 9815         	ldr	r0, [sp, #0x54]
7009cc66: b018         	add	sp, #0x60
7009cc68: bd80         	pop	{r7, pc}
7009cc6a: 0000         	movs	r0, r0
7009cc6c: 0000         	movs	r0, r0
7009cc6e: 0000         	movs	r0, r0

7009cc70 <Sciclient_rmIrqGetRoute>:
; {
7009cc70: b580         	push	{r7, lr}
7009cc72: b08e         	sub	sp, #0x38
7009cc74: 900d         	str	r0, [sp, #0x34]
7009cc76: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009cc78: 900c         	str	r0, [sp, #0x30]
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009cc7a: 980d         	ldr	r0, [sp, #0x34]
7009cc7c: 88c0         	ldrh	r0, [r0, #0x6]
7009cc7e: f011 fd0f    	bl	0x700ae6a0 <Sciclient_rmIrIsIr> @ imm = #0x11a1e
7009cc82: b930         	cbnz	r0, 0x7009cc92 <Sciclient_rmIrqGetRoute+0x22> @ imm = #0xc
7009cc84: e7ff         	b	0x7009cc86 <Sciclient_rmIrqGetRoute+0x16> @ imm = #-0x2
;         (Sciclient_rmIrIsIr(cfg->d_id) == true)) {
7009cc86: 980d         	ldr	r0, [sp, #0x34]
7009cc88: 8940         	ldrh	r0, [r0, #0xa]
7009cc8a: f011 fd09    	bl	0x700ae6a0 <Sciclient_rmIrIsIr> @ imm = #0x11a12
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009cc8e: b120         	cbz	r0, 0x7009cc9a <Sciclient_rmIrqGetRoute+0x2a> @ imm = #0x8
7009cc90: e7ff         	b	0x7009cc92 <Sciclient_rmIrqGetRoute+0x22> @ imm = #-0x2
7009cc92: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009cc96: 900c         	str	r0, [sp, #0x30]
;     }
7009cc98: e7ff         	b	0x7009cc9a <Sciclient_rmIrqGetRoute+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009cc9a: 980c         	ldr	r0, [sp, #0x30]
7009cc9c: 2800         	cmp	r0, #0x0
7009cc9e: d156         	bne	0x7009cd4e <Sciclient_rmIrqGetRoute+0xde> @ imm = #0xac
7009cca0: e7ff         	b	0x7009cca2 <Sciclient_rmIrqGetRoute+0x32> @ imm = #-0x2
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009cca2: 980d         	ldr	r0, [sp, #0x34]
7009cca4: 8a00         	ldrh	r0, [r0, #0x10]
7009cca6: 28ff         	cmp	r0, #0xff
7009cca8: d042         	beq	0x7009cd30 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x84
7009ccaa: e7ff         	b	0x7009ccac <Sciclient_rmIrqGetRoute+0x3c> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009ccac: 980d         	ldr	r0, [sp, #0x34]
7009ccae: 6800         	ldr	r0, [r0]
7009ccb0: 2104         	movs	r1, #0x4
7009ccb2: f011 fed5    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x11daa
;              true) &&
7009ccb6: b3d8         	cbz	r0, 0x7009cd30 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x76
7009ccb8: e7ff         	b	0x7009ccba <Sciclient_rmIrqGetRoute+0x4a> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009ccba: 980d         	ldr	r0, [sp, #0x34]
7009ccbc: 6800         	ldr	r0, [r0]
7009ccbe: 2108         	movs	r1, #0x8
7009ccc0: f011 fece    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x11d9c
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009ccc4: b3a0         	cbz	r0, 0x7009cd30 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x68
7009ccc6: e7ff         	b	0x7009ccc8 <Sciclient_rmIrqGetRoute+0x58> @ imm = #-0x2
;             if ((Sciclient_rmParamIsValid(cfg->valid_params,
7009ccc8: 980d         	ldr	r0, [sp, #0x34]
7009ccca: 6800         	ldr	r0, [r0]
7009cccc: 2110         	movs	r1, #0x10
7009ccce: f011 fec7    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x11d8e
;                  true) &&
7009ccd2: b1d0         	cbz	r0, 0x7009cd0a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #0x34
7009ccd4: e7ff         	b	0x7009ccd6 <Sciclient_rmIrqGetRoute+0x66> @ imm = #-0x2
;                 (Sciclient_rmParamIsValid(cfg->valid_params,
7009ccd6: 980d         	ldr	r0, [sp, #0x34]
7009ccd8: 6800         	ldr	r0, [r0]
7009ccda: 2120         	movs	r1, #0x20
7009ccdc: f011 fec0    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x11d80
;             if ((Sciclient_rmParamIsValid(cfg->valid_params,
7009cce0: b198         	cbz	r0, 0x7009cd0a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #0x26
7009cce2: e7ff         	b	0x7009cce4 <Sciclient_rmIrqGetRoute+0x74> @ imm = #-0x2
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009cce4: f8dd c034    	ldr.w	r12, [sp, #0x34]
7009cce8: f8bc 1010    	ldrh.w	r1, [r12, #0x10]
;                                cfg->vint, cfg->global_evt,
7009ccec: f8bc 2012    	ldrh.w	r2, [r12, #0x12]
7009ccf0: f8bc 300e    	ldrh.w	r3, [r12, #0xe]
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009ccf4: f89c 0004    	ldrb.w	r0, [r12, #0x4]
;                                cfg->vint_sb);
7009ccf8: f89c c014    	ldrb.w	r12, [r12, #0x14]
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009ccfc: 46ee         	mov	lr, sp
7009ccfe: f8ce c000    	str.w	r12, [lr]
7009cd02: f005 fc65    	bl	0x700a25d0 <Sciclient_rmIaValidateMapping> @ imm = #0x58ca
7009cd06: 900c         	str	r0, [sp, #0x30]
;             }
7009cd08: e7ff         	b	0x7009cd0a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #-0x2
;             if (r == SystemP_SUCCESS) {
7009cd0a: 980c         	ldr	r0, [sp, #0x30]
7009cd0c: b978         	cbnz	r0, 0x7009cd2e <Sciclient_rmIrqGetRoute+0xbe> @ imm = #0x1e
7009cd0e: e7ff         	b	0x7009cd10 <Sciclient_rmIrqGetRoute+0xa0> @ imm = #-0x2
;                 inp = cfg->global_evt;
7009cd10: 980d         	ldr	r0, [sp, #0x34]
7009cd12: 89c0         	ldrh	r0, [r0, #0xe]
7009cd14: f8ad 0028    	strh.w	r0, [sp, #0x28]
;                 outp = cfg->vint;
7009cd18: 980d         	ldr	r0, [sp, #0x34]
7009cd1a: 8a40         	ldrh	r0, [r0, #0x12]
7009cd1c: f8ad 0024    	strh.w	r0, [sp, #0x24]
;                 r = Sciclient_rmIrqGetNode(cfg->s_ia, &cur_n);
7009cd20: 980d         	ldr	r0, [sp, #0x34]
7009cd22: 8a00         	ldrh	r0, [r0, #0x10]
7009cd24: a906         	add	r1, sp, #0x18
7009cd26: f008 ff53    	bl	0x700a5bd0 <Sciclient_rmIrqGetNode> @ imm = #0x8ea6
7009cd2a: 900c         	str	r0, [sp, #0x30]
;             }
7009cd2c: e7ff         	b	0x7009cd2e <Sciclient_rmIrqGetRoute+0xbe> @ imm = #-0x2
;         } else {
7009cd2e: e00d         	b	0x7009cd4c <Sciclient_rmIrqGetRoute+0xdc> @ imm = #0x1a
7009cd30: 2000         	movs	r0, #0x0
;             inp = 0u;
7009cd32: f8ad 0028    	strh.w	r0, [sp, #0x28]
;             outp = cfg->s_idx;
7009cd36: 980d         	ldr	r0, [sp, #0x34]
7009cd38: 8900         	ldrh	r0, [r0, #0x8]
7009cd3a: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             r = Sciclient_rmIrqGetNode(cfg->s_id, &cur_n);
7009cd3e: 980d         	ldr	r0, [sp, #0x34]
7009cd40: 88c0         	ldrh	r0, [r0, #0x6]
7009cd42: a906         	add	r1, sp, #0x18
7009cd44: f008 ff44    	bl	0x700a5bd0 <Sciclient_rmIrqGetNode> @ imm = #0x8e88
7009cd48: 900c         	str	r0, [sp, #0x30]
7009cd4a: e7ff         	b	0x7009cd4c <Sciclient_rmIrqGetRoute+0xdc> @ imm = #-0x2
;     }
7009cd4c: e7ff         	b	0x7009cd4e <Sciclient_rmIrqGetRoute+0xde> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009cd4e: 980c         	ldr	r0, [sp, #0x30]
7009cd50: b948         	cbnz	r0, 0x7009cd66 <Sciclient_rmIrqGetRoute+0xf6> @ imm = #0x12
7009cd52: e7ff         	b	0x7009cd54 <Sciclient_rmIrqGetRoute+0xe4> @ imm = #-0x2
7009cd54: 2001         	movs	r0, #0x1
;         search = true;
7009cd56: f88d 0021    	strb.w	r0, [sp, #0x21]
7009cd5a: 2000         	movs	r0, #0x0
;         rt_complete = false;
7009cd5c: f88d 0020    	strb.w	r0, [sp, #0x20]
;         Sciclient_rmPsInit();
7009cd60: f012 fa06    	bl	0x700af170 <Sciclient_rmPsInit> @ imm = #0x1240c
;     } else {
7009cd64: e003         	b	0x7009cd6e <Sciclient_rmIrqGetRoute+0xfe> @ imm = #0x6
7009cd66: 2000         	movs	r0, #0x0
;         search = false;
7009cd68: f88d 0021    	strb.w	r0, [sp, #0x21]
7009cd6c: e7ff         	b	0x7009cd6e <Sciclient_rmIrqGetRoute+0xfe> @ imm = #-0x2
7009cd6e: 2000         	movs	r0, #0x0
;     for (search_depth = 0u;
7009cd70: f8ad 002e    	strh.w	r0, [sp, #0x2e]
7009cd74: e7ff         	b	0x7009cd76 <Sciclient_rmIrqGetRoute+0x106> @ imm = #-0x2
;          (search_depth < Sciclient_rmPsGetMaxPsp()) && (search == true);
7009cd76: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cd7a: 9002         	str	r0, [sp, #0x8]
7009cd7c: f012 fe58    	bl	0x700afa30 <Sciclient_rmPsGetMaxPsp> @ imm = #0x12cb0
7009cd80: 9902         	ldr	r1, [sp, #0x8]
7009cd82: 4602         	mov	r2, r0
7009cd84: 2000         	movs	r0, #0x0
7009cd86: 4291         	cmp	r1, r2
7009cd88: 9003         	str	r0, [sp, #0xc]
7009cd8a: da06         	bge	0x7009cd9a <Sciclient_rmIrqGetRoute+0x12a> @ imm = #0xc
7009cd8c: e7ff         	b	0x7009cd8e <Sciclient_rmIrqGetRoute+0x11e> @ imm = #-0x2
7009cd8e: f89d 0021    	ldrb.w	r0, [sp, #0x21]
7009cd92: f000 0001    	and	r0, r0, #0x1
7009cd96: 9003         	str	r0, [sp, #0xc]
7009cd98: e7ff         	b	0x7009cd9a <Sciclient_rmIrqGetRoute+0x12a> @ imm = #-0x2
7009cd9a: 9803         	ldr	r0, [sp, #0xc]
;     for (search_depth = 0u;
7009cd9c: 07c0         	lsls	r0, r0, #0x1f
7009cd9e: 2800         	cmp	r0, #0x0
7009cda0: f000 80d8    	beq.w	0x7009cf54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x1b0
7009cda4: e7ff         	b	0x7009cda6 <Sciclient_rmIrqGetRoute+0x136> @ imm = #-0x2
7009cda6: 2000         	movs	r0, #0x0
;         push_node = false;
7009cda8: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         for (if_idx = 0u; if_idx < cur_n->n_if; if_idx++) {
7009cdac: f8ad 002c    	strh.w	r0, [sp, #0x2c]
7009cdb0: e7ff         	b	0x7009cdb2 <Sciclient_rmIrqGetRoute+0x142> @ imm = #-0x2
7009cdb2: f8bd 002c    	ldrh.w	r0, [sp, #0x2c]
7009cdb6: 9906         	ldr	r1, [sp, #0x18]
7009cdb8: 8849         	ldrh	r1, [r1, #0x2]
7009cdba: 4288         	cmp	r0, r1
7009cdbc: da6b         	bge	0x7009ce96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0xd6
7009cdbe: e7ff         	b	0x7009cdc0 <Sciclient_rmIrqGetRoute+0x150> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(cur_n, if_idx, &cur_if);
7009cdc0: 9806         	ldr	r0, [sp, #0x18]
7009cdc2: f8bd 102c    	ldrh.w	r1, [sp, #0x2c]
7009cdc6: aa04         	add	r2, sp, #0x10
7009cdc8: f010 fd0a    	bl	0x700ad7e0 <Sciclient_rmIrqGetNodeItf> @ imm = #0x10a14
7009cdcc: 900c         	str	r0, [sp, #0x30]
;             if (r != SystemP_SUCCESS) {
7009cdce: 980c         	ldr	r0, [sp, #0x30]
7009cdd0: b108         	cbz	r0, 0x7009cdd6 <Sciclient_rmIrqGetRoute+0x166> @ imm = #0x2
7009cdd2: e7ff         	b	0x7009cdd4 <Sciclient_rmIrqGetRoute+0x164> @ imm = #-0x2
;                 break;
7009cdd4: e05f         	b	0x7009ce96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0xbe
;             if ((outp >= cur_if->lbase) &&
7009cdd6: f8bd 0024    	ldrh.w	r0, [sp, #0x24]
7009cdda: 9904         	ldr	r1, [sp, #0x10]
7009cddc: 8809         	ldrh	r1, [r1]
7009cdde: 4288         	cmp	r0, r1
7009cde0: db52         	blt	0x7009ce88 <Sciclient_rmIrqGetRoute+0x218> @ imm = #0xa4
7009cde2: e7ff         	b	0x7009cde4 <Sciclient_rmIrqGetRoute+0x174> @ imm = #-0x2
;                 (outp < (cur_if->lbase + cur_if->len))) {
7009cde4: f8bd 0024    	ldrh.w	r0, [sp, #0x24]
7009cde8: 9a04         	ldr	r2, [sp, #0x10]
7009cdea: 8811         	ldrh	r1, [r2]
7009cdec: 8892         	ldrh	r2, [r2, #0x4]
7009cdee: 4411         	add	r1, r2
;             if ((outp >= cur_if->lbase) &&
7009cdf0: 4288         	cmp	r0, r1
7009cdf2: da49         	bge	0x7009ce88 <Sciclient_rmIrqGetRoute+0x218> @ imm = #0x92
7009cdf4: e7ff         	b	0x7009cdf6 <Sciclient_rmIrqGetRoute+0x186> @ imm = #-0x2
;                 if ((cur_if->rid == cfg->d_id) &&
7009cdf6: 9804         	ldr	r0, [sp, #0x10]
7009cdf8: 88c0         	ldrh	r0, [r0, #0x6]
7009cdfa: 990d         	ldr	r1, [sp, #0x34]
7009cdfc: 8949         	ldrh	r1, [r1, #0xa]
7009cdfe: 4288         	cmp	r0, r1
7009ce00: d110         	bne	0x7009ce24 <Sciclient_rmIrqGetRoute+0x1b4> @ imm = #0x20
7009ce02: e7ff         	b	0x7009ce04 <Sciclient_rmIrqGetRoute+0x194> @ imm = #-0x2
;                     (SCICLIENT_OUTP_TO_INP(outp, cur_if->lbase,
7009ce04: 9a04         	ldr	r2, [sp, #0x10]
7009ce06: 8850         	ldrh	r0, [r2, #0x2]
7009ce08: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
7009ce0c: 8812         	ldrh	r2, [r2]
7009ce0e: 1a89         	subs	r1, r1, r2
7009ce10: 4408         	add	r0, r1
;                      cfg->d_irq)) {
7009ce12: 990d         	ldr	r1, [sp, #0x34]
7009ce14: 8989         	ldrh	r1, [r1, #0xc]
;                 if ((cur_if->rid == cfg->d_id) &&
7009ce16: 4288         	cmp	r0, r1
7009ce18: d104         	bne	0x7009ce24 <Sciclient_rmIrqGetRoute+0x1b4> @ imm = #0x8
7009ce1a: e7ff         	b	0x7009ce1c <Sciclient_rmIrqGetRoute+0x1ac> @ imm = #-0x2
7009ce1c: 2001         	movs	r0, #0x1
;                     rt_complete = true;
7009ce1e: f88d 0020    	strb.w	r0, [sp, #0x20]
;                     break;
7009ce22: e038         	b	0x7009ce96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x70
;                 if (Sciclient_rmIrIsIr(cur_if->rid) == true) {
7009ce24: 9804         	ldr	r0, [sp, #0x10]
7009ce26: 88c0         	ldrh	r0, [r0, #0x6]
7009ce28: f011 fc3a    	bl	0x700ae6a0 <Sciclient_rmIrIsIr> @ imm = #0x11874
7009ce2c: b358         	cbz	r0, 0x7009ce86 <Sciclient_rmIrqGetRoute+0x216> @ imm = #0x56
7009ce2e: e7ff         	b	0x7009ce30 <Sciclient_rmIrqGetRoute+0x1c0> @ imm = #-0x2
;                     r = Sciclient_rmIrqGetNode(cur_if->rid, &next_n);
7009ce30: 9804         	ldr	r0, [sp, #0x10]
7009ce32: 88c0         	ldrh	r0, [r0, #0x6]
7009ce34: a905         	add	r1, sp, #0x14
7009ce36: f008 fecb    	bl	0x700a5bd0 <Sciclient_rmIrqGetNode> @ imm = #0x8d96
7009ce3a: 900c         	str	r0, [sp, #0x30]
;                     if (r != SystemP_SUCCESS) {
7009ce3c: 980c         	ldr	r0, [sp, #0x30]
7009ce3e: b108         	cbz	r0, 0x7009ce44 <Sciclient_rmIrqGetRoute+0x1d4> @ imm = #0x2
7009ce40: e7ff         	b	0x7009ce42 <Sciclient_rmIrqGetRoute+0x1d2> @ imm = #-0x2
;                         break;
7009ce42: e028         	b	0x7009ce96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x50
;                     next_inp = SCICLIENT_OUTP_TO_INP(outp,
7009ce44: 9a04         	ldr	r2, [sp, #0x10]
7009ce46: 8850         	ldrh	r0, [r2, #0x2]
7009ce48: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
7009ce4c: 8812         	ldrh	r2, [r2]
7009ce4e: 1a89         	subs	r1, r1, r2
7009ce50: 4408         	add	r0, r1
7009ce52: f8ad 0026    	strh.w	r0, [sp, #0x26]
;                     r = Sciclient_rmIrGetOutp(next_n->id, next_inp,
7009ce56: 9805         	ldr	r0, [sp, #0x14]
7009ce58: 8800         	ldrh	r0, [r0]
7009ce5a: f8bd 1026    	ldrh.w	r1, [sp, #0x26]
7009ce5e: f10d 0222    	add.w	r2, sp, #0x22
7009ce62: f008 fae5    	bl	0x700a5430 <Sciclient_rmIrGetOutp> @ imm = #0x85ca
7009ce66: 900c         	str	r0, [sp, #0x30]
;                     if (r == SystemP_SUCCESS) {
7009ce68: 980c         	ldr	r0, [sp, #0x30]
7009ce6a: b930         	cbnz	r0, 0x7009ce7a <Sciclient_rmIrqGetRoute+0x20a> @ imm = #0xc
7009ce6c: e7ff         	b	0x7009ce6e <Sciclient_rmIrqGetRoute+0x1fe> @ imm = #-0x2
7009ce6e: 2001         	movs	r0, #0x1
;                         push_node = true;
7009ce70: f88d 001f    	strb.w	r0, [sp, #0x1f]
7009ce74: 2000         	movs	r0, #0x0
;                         r = SystemP_SUCCESS;
7009ce76: 900c         	str	r0, [sp, #0x30]
;                         break;
7009ce78: e00d         	b	0x7009ce96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x1a
;                     if (r != SystemP_FAILURE) {
7009ce7a: 980c         	ldr	r0, [sp, #0x30]
7009ce7c: 3001         	adds	r0, #0x1
7009ce7e: b108         	cbz	r0, 0x7009ce84 <Sciclient_rmIrqGetRoute+0x214> @ imm = #0x2
7009ce80: e7ff         	b	0x7009ce82 <Sciclient_rmIrqGetRoute+0x212> @ imm = #-0x2
;                         break;
7009ce82: e008         	b	0x7009ce96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x10
;                 }
7009ce84: e7ff         	b	0x7009ce86 <Sciclient_rmIrqGetRoute+0x216> @ imm = #-0x2
;             }
7009ce86: e7ff         	b	0x7009ce88 <Sciclient_rmIrqGetRoute+0x218> @ imm = #-0x2
;         }
7009ce88: e7ff         	b	0x7009ce8a <Sciclient_rmIrqGetRoute+0x21a> @ imm = #-0x2
;         for (if_idx = 0u; if_idx < cur_n->n_if; if_idx++) {
7009ce8a: f8bd 002c    	ldrh.w	r0, [sp, #0x2c]
7009ce8e: 3001         	adds	r0, #0x1
7009ce90: f8ad 002c    	strh.w	r0, [sp, #0x2c]
7009ce94: e78d         	b	0x7009cdb2 <Sciclient_rmIrqGetRoute+0x142> @ imm = #-0xe6
;         if (r != SystemP_SUCCESS) {
7009ce96: 980c         	ldr	r0, [sp, #0x30]
7009ce98: b108         	cbz	r0, 0x7009ce9e <Sciclient_rmIrqGetRoute+0x22e> @ imm = #0x2
7009ce9a: e7ff         	b	0x7009ce9c <Sciclient_rmIrqGetRoute+0x22c> @ imm = #-0x2
;             break;
7009ce9c: e05a         	b	0x7009cf54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0xb4
;         if ((rt_complete == true) || (push_node == true)) {
7009ce9e: f89d 0020    	ldrb.w	r0, [sp, #0x20]
7009cea2: 07c0         	lsls	r0, r0, #0x1f
7009cea4: b930         	cbnz	r0, 0x7009ceb4 <Sciclient_rmIrqGetRoute+0x244> @ imm = #0xc
7009cea6: e7ff         	b	0x7009cea8 <Sciclient_rmIrqGetRoute+0x238> @ imm = #-0x2
7009cea8: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009ceac: 07c0         	lsls	r0, r0, #0x1f
7009ceae: 2800         	cmp	r0, #0x0
7009ceb0: d049         	beq	0x7009cf46 <Sciclient_rmIrqGetRoute+0x2d6> @ imm = #0x92
7009ceb2: e7ff         	b	0x7009ceb4 <Sciclient_rmIrqGetRoute+0x244> @ imm = #-0x2
;             r = Sciclient_rmPsPush(cur_n, if_idx);
7009ceb4: 9806         	ldr	r0, [sp, #0x18]
7009ceb6: f8bd 102c    	ldrh.w	r1, [sp, #0x2c]
7009ceba: f00f fa49    	bl	0x700ac350 <Sciclient_rmPsPush> @ imm = #0xf492
7009cebe: 900c         	str	r0, [sp, #0x30]
;             if (r != SystemP_SUCCESS) {
7009cec0: 980c         	ldr	r0, [sp, #0x30]
7009cec2: b108         	cbz	r0, 0x7009cec8 <Sciclient_rmIrqGetRoute+0x258> @ imm = #0x2
7009cec4: e7ff         	b	0x7009cec6 <Sciclient_rmIrqGetRoute+0x256> @ imm = #-0x2
;                 break;
7009cec6: e045         	b	0x7009cf54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x8a
;             if ((search_depth > 0u) ||
7009cec8: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cecc: b950         	cbnz	r0, 0x7009cee4 <Sciclient_rmIrqGetRoute+0x274> @ imm = #0x14
7009cece: e7ff         	b	0x7009ced0 <Sciclient_rmIrqGetRoute+0x260> @ imm = #-0x2
;                 ((search_depth == 0u) &&
7009ced0: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009ced4: bb28         	cbnz	r0, 0x7009cf22 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #0x4a
7009ced6: e7ff         	b	0x7009ced8 <Sciclient_rmIrqGetRoute+0x268> @ imm = #-0x2
;                  (Sciclient_rmIaIsIa(cur_n->id) == true))) {
7009ced8: 9806         	ldr	r0, [sp, #0x18]
7009ceda: 8800         	ldrh	r0, [r0]
7009cedc: f011 fbc8    	bl	0x700ae670 <Sciclient_rmIaIsIa> @ imm = #0x11790
;             if ((search_depth > 0u) ||
7009cee0: b1f8         	cbz	r0, 0x7009cf22 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #0x3e
7009cee2: e7ff         	b	0x7009cee4 <Sciclient_rmIrqGetRoute+0x274> @ imm = #-0x2
;                 cur_psp = Sciclient_rmPsGetPsp();
7009cee4: f012 fd44    	bl	0x700af970 <Sciclient_rmPsGetPsp> @ imm = #0x12a88
7009cee8: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;                 r = Sciclient_rmPsSetInp(cur_psp - (1u), inp);
7009ceec: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009cef0: 3801         	subs	r0, #0x1
7009cef2: f8bd 1028    	ldrh.w	r1, [sp, #0x28]
7009cef6: b280         	uxth	r0, r0
7009cef8: f010 f8ba    	bl	0x700ad070 <Sciclient_rmPsSetInp> @ imm = #0x10174
7009cefc: 900c         	str	r0, [sp, #0x30]
;                 if (r != SystemP_SUCCESS) {
7009cefe: 980c         	ldr	r0, [sp, #0x30]
7009cf00: b108         	cbz	r0, 0x7009cf06 <Sciclient_rmIrqGetRoute+0x296> @ imm = #0x2
7009cf02: e7ff         	b	0x7009cf04 <Sciclient_rmIrqGetRoute+0x294> @ imm = #-0x2
;                     break;
7009cf04: e026         	b	0x7009cf54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x4c
;                 r = Sciclient_rmPsSetOutp(cur_psp - (1u),
7009cf06: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009cf0a: 3801         	subs	r0, #0x1
;                         outp);
7009cf0c: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
;                 r = Sciclient_rmPsSetOutp(cur_psp - (1u),
7009cf10: b280         	uxth	r0, r0
7009cf12: f010 f8d5    	bl	0x700ad0c0 <Sciclient_rmPsSetOutp> @ imm = #0x101aa
7009cf16: 900c         	str	r0, [sp, #0x30]
;                 if (r != SystemP_SUCCESS) {
7009cf18: 980c         	ldr	r0, [sp, #0x30]
7009cf1a: b108         	cbz	r0, 0x7009cf20 <Sciclient_rmIrqGetRoute+0x2b0> @ imm = #0x2
7009cf1c: e7ff         	b	0x7009cf1e <Sciclient_rmIrqGetRoute+0x2ae> @ imm = #-0x2
;                     break;
7009cf1e: e019         	b	0x7009cf54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x32
;             }
7009cf20: e7ff         	b	0x7009cf22 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #-0x2
;             if (rt_complete == true) {
7009cf22: f89d 0020    	ldrb.w	r0, [sp, #0x20]
7009cf26: 07c0         	lsls	r0, r0, #0x1f
7009cf28: b108         	cbz	r0, 0x7009cf2e <Sciclient_rmIrqGetRoute+0x2be> @ imm = #0x2
7009cf2a: e7ff         	b	0x7009cf2c <Sciclient_rmIrqGetRoute+0x2bc> @ imm = #-0x2
;                 break;
7009cf2c: e012         	b	0x7009cf54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x24
;                 cur_n = next_n;
7009cf2e: 9805         	ldr	r0, [sp, #0x14]
7009cf30: 9006         	str	r0, [sp, #0x18]
;                 inp = next_inp;
7009cf32: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
7009cf36: f8ad 0028    	strh.w	r0, [sp, #0x28]
;                 outp = next_outp;
7009cf3a: f8bd 0022    	ldrh.w	r0, [sp, #0x22]
7009cf3e: f8ad 0024    	strh.w	r0, [sp, #0x24]
7009cf42: e7ff         	b	0x7009cf44 <Sciclient_rmIrqGetRoute+0x2d4> @ imm = #-0x2
;         }
7009cf44: e7ff         	b	0x7009cf46 <Sciclient_rmIrqGetRoute+0x2d6> @ imm = #-0x2
;     }
7009cf46: e7ff         	b	0x7009cf48 <Sciclient_rmIrqGetRoute+0x2d8> @ imm = #-0x2
;          search_depth++) {
7009cf48: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cf4c: 3001         	adds	r0, #0x1
7009cf4e: f8ad 002e    	strh.w	r0, [sp, #0x2e]
;     for (search_depth = 0u;
7009cf52: e710         	b	0x7009cd76 <Sciclient_rmIrqGetRoute+0x106> @ imm = #-0x1e0
;     if (search_depth >= Sciclient_rmPsGetMaxPsp()) {
7009cf54: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cf58: 9001         	str	r0, [sp, #0x4]
7009cf5a: f012 fd69    	bl	0x700afa30 <Sciclient_rmPsGetMaxPsp> @ imm = #0x12ad2
7009cf5e: 4601         	mov	r1, r0
7009cf60: 9801         	ldr	r0, [sp, #0x4]
7009cf62: 4288         	cmp	r0, r1
7009cf64: db04         	blt	0x7009cf70 <Sciclient_rmIrqGetRoute+0x300> @ imm = #0x8
7009cf66: e7ff         	b	0x7009cf68 <Sciclient_rmIrqGetRoute+0x2f8> @ imm = #-0x2
7009cf68: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
7009cf6c: 900c         	str	r0, [sp, #0x30]
;     }
7009cf6e: e7ff         	b	0x7009cf70 <Sciclient_rmIrqGetRoute+0x300> @ imm = #-0x2
;     return r;
7009cf70: 980c         	ldr	r0, [sp, #0x30]
7009cf72: b00e         	add	sp, #0x38
7009cf74: bd80         	pop	{r7, pc}
7009cf76: 0000         	movs	r0, r0

7009cf78 <$Ven$TA$L$PI$$HwiP_enable>:
7009cf78: f8df f000    	ldr.w	pc, [pc, #0x0]          @ 0x7009cf7c <$Ven$TA$L$PI$$HwiP_enable+0x4>
7009cf7c: 80 06 0b 70  	.word	0x700b0680

7009cf80 <Udma_eventReset>:
; {
7009cf80: b580         	push	{r7, lr}
7009cf82: b090         	sub	sp, #0x40
7009cf84: 900f         	str	r0, [sp, #0x3c]
7009cf86: 910e         	str	r1, [sp, #0x38]
7009cf88: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009cf8a: 9001         	str	r0, [sp, #0x4]
7009cf8c: 900d         	str	r0, [sp, #0x34]
;     eventPrms = &eventHandle->eventPrms;
7009cf8e: 990e         	ldr	r1, [sp, #0x38]
7009cf90: 3108         	adds	r1, #0x8
7009cf92: 9109         	str	r1, [sp, #0x24]
;     rmIrqReq.valid_params           = 0U;
7009cf94: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.global_event           = 0U;
7009cf96: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     rmIrqReq.src_id                 = 0U;
7009cf9a: f8ad 0014    	strh.w	r0, [sp, #0x14]
;     rmIrqReq.src_index              = 0U;
7009cf9e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;     rmIrqReq.dst_id                 = 0U;
7009cfa2: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     rmIrqReq.dst_host_irq           = 0U;
7009cfa6: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     rmIrqReq.ia_id                  = 0U;
7009cfaa: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.vint                   = 0U;
7009cfae: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     rmIrqReq.vint_status_bit_index  = 0U;
7009cfb2: f88d 0022    	strb.w	r0, [sp, #0x22]
7009cfb6: 20ff         	movs	r0, #0xff
;     rmIrqReq.secondary_host         = TISCI_MSG_VALUE_RM_UNUSED_SECONDARY_HOST;
7009cfb8: f88d 0023    	strb.w	r0, [sp, #0x23]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009cfbc: 9809         	ldr	r0, [sp, #0x24]
7009cfbe: 6800         	ldr	r0, [r0]
7009cfc0: 2805         	cmp	r0, #0x5
7009cfc2: d00a         	beq	0x7009cfda <Udma_eventReset+0x5a> @ imm = #0x14
7009cfc4: e7ff         	b	0x7009cfc6 <Udma_eventReset+0x46> @ imm = #-0x2
;         rmIrqReq.valid_params  |= TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID;
7009cfc6: 9804         	ldr	r0, [sp, #0x10]
7009cfc8: f040 0010    	orr	r0, r0, #0x10
7009cfcc: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.global_event   = (uint16_t)Udma_eventGetId(eventHandle);
7009cfce: 980e         	ldr	r0, [sp, #0x38]
7009cfd0: f010 f89e    	bl	0x700ad110 <Udma_eventGetId> @ imm = #0x1013c
7009cfd4: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     }
7009cfd8: e7ff         	b	0x7009cfda <Udma_eventReset+0x5a> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009cfda: 980e         	ldr	r0, [sp, #0x38]
7009cfdc: 6d80         	ldr	r0, [r0, #0x58]
7009cfde: f510 3f80    	cmn.w	r0, #0x10000
7009cfe2: d012         	beq	0x7009d00a <Udma_eventReset+0x8a> @ imm = #0x24
7009cfe4: e7ff         	b	0x7009cfe6 <Udma_eventReset+0x66> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_ID_VALID;
7009cfe6: 9804         	ldr	r0, [sp, #0x10]
7009cfe8: f040 0001    	orr	r0, r0, #0x1
7009cfec: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID;
7009cfee: 9804         	ldr	r0, [sp, #0x10]
7009cff0: f040 0002    	orr	r0, r0, #0x2
7009cff4: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.dst_id       = drvHandle->devIdCore;
7009cff6: 980f         	ldr	r0, [sp, #0x3c]
7009cff8: f8b0 00ea    	ldrh.w	r0, [r0, #0xea]
7009cffc: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         rmIrqReq.dst_host_irq = (uint16_t)eventHandle->coreIntrNum;
7009d000: 980e         	ldr	r0, [sp, #0x38]
7009d002: 6d80         	ldr	r0, [r0, #0x58]
7009d004: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     }
7009d008: e7ff         	b	0x7009d00a <Udma_eventReset+0x8a> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->eventPrms.controllerEventHandle)
7009d00a: 980e         	ldr	r0, [sp, #0x38]
7009d00c: 6980         	ldr	r0, [r0, #0x18]
7009d00e: b128         	cbz	r0, 0x7009d01c <Udma_eventReset+0x9c> @ imm = #0xa
7009d010: e7ff         	b	0x7009d012 <Udma_eventReset+0x92> @ imm = #-0x2
;         vintrNum = ((Udma_EventHandleInt) (eventHandle->eventPrms.controllerEventHandle))->vintrNum;
7009d012: 980e         	ldr	r0, [sp, #0x38]
7009d014: 6980         	ldr	r0, [r0, #0x18]
7009d016: 6cc0         	ldr	r0, [r0, #0x4c]
7009d018: 900c         	str	r0, [sp, #0x30]
;     }
7009d01a: e003         	b	0x7009d024 <Udma_eventReset+0xa4> @ imm = #0x6
;         vintrNum = eventHandle->vintrNum;
7009d01c: 980e         	ldr	r0, [sp, #0x38]
7009d01e: 6cc0         	ldr	r0, [r0, #0x4c]
7009d020: 900c         	str	r0, [sp, #0x30]
7009d022: e7ff         	b	0x7009d024 <Udma_eventReset+0xa4> @ imm = #-0x2
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_IA_ID_VALID;
7009d024: 9804         	ldr	r0, [sp, #0x10]
7009d026: f040 0004    	orr	r0, r0, #0x4
7009d02a: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_VALID;
7009d02c: 9804         	ldr	r0, [sp, #0x10]
7009d02e: f040 0008    	orr	r0, r0, #0x8
7009d032: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.ia_id         = drvHandle->devIdIa;
7009d034: 980f         	ldr	r0, [sp, #0x3c]
7009d036: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009d03a: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.vint          = (uint16_t)vintrNum;
7009d03e: 980c         	ldr	r0, [sp, #0x30]
7009d040: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
7009d044: 980e         	ldr	r0, [sp, #0x38]
7009d046: 6d00         	ldr	r0, [r0, #0x50]
7009d048: f64f 71ff    	movw	r1, #0xffff
7009d04c: 4288         	cmp	r0, r1
7009d04e: d009         	beq	0x7009d064 <Udma_eventReset+0xe4> @ imm = #0x12
7009d050: e7ff         	b	0x7009d052 <Udma_eventReset+0xd2> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_STATUS_BIT_INDEX_VALID;
7009d052: 9804         	ldr	r0, [sp, #0x10]
7009d054: f040 0020    	orr	r0, r0, #0x20
7009d058: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.vint_status_bit_index  = (uint8_t)eventHandle->vintrBitNum;
7009d05a: 980e         	ldr	r0, [sp, #0x38]
7009d05c: 6d00         	ldr	r0, [r0, #0x50]
7009d05e: f88d 0022    	strb.w	r0, [sp, #0x22]
;     }
7009d062: e7ff         	b	0x7009d064 <Udma_eventReset+0xe4> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009d064: 9809         	ldr	r0, [sp, #0x24]
7009d066: 6800         	ldr	r0, [r0]
7009d068: 2801         	cmp	r0, #0x1
7009d06a: d00a         	beq	0x7009d082 <Udma_eventReset+0x102> @ imm = #0x14
7009d06c: e7ff         	b	0x7009d06e <Udma_eventReset+0xee> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType)||
7009d06e: 9809         	ldr	r0, [sp, #0x24]
7009d070: 6800         	ldr	r0, [r0]
7009d072: 2806         	cmp	r0, #0x6
7009d074: d005         	beq	0x7009d082 <Udma_eventReset+0x102> @ imm = #0xa
7009d076: e7ff         	b	0x7009d078 <Udma_eventReset+0xf8> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType))
7009d078: 9809         	ldr	r0, [sp, #0x24]
7009d07a: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009d07c: 2802         	cmp	r0, #0x2
7009d07e: d14d         	bne	0x7009d11c <Udma_eventReset+0x19c> @ imm = #0x9a
7009d080: e7ff         	b	0x7009d082 <Udma_eventReset+0x102> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009d082: 9809         	ldr	r0, [sp, #0x24]
7009d084: 6880         	ldr	r0, [r0, #0x8]
7009d086: 900b         	str	r0, [sp, #0x2c]
;         rmIrqReq.src_id = drvHandle->srcIdRingIrq;
7009d088: 980f         	ldr	r0, [sp, #0x3c]
7009d08a: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009d08e: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009d092: 9809         	ldr	r0, [sp, #0x24]
7009d094: 6800         	ldr	r0, [r0]
7009d096: 2801         	cmp	r0, #0x1
7009d098: d005         	beq	0x7009d0a6 <Udma_eventReset+0x126> @ imm = #0xa
7009d09a: e7ff         	b	0x7009d09c <Udma_eventReset+0x11c> @ imm = #-0x2
7009d09c: 9809         	ldr	r0, [sp, #0x24]
7009d09e: 6800         	ldr	r0, [r0]
7009d0a0: 2806         	cmp	r0, #0x6
7009d0a2: d12e         	bne	0x7009d102 <Udma_eventReset+0x182> @ imm = #0x5c
7009d0a4: e7ff         	b	0x7009d0a6 <Udma_eventReset+0x126> @ imm = #-0x2
;             rmIrqReq.src_index = chHandle->cqRing->ringNum;
7009d0a6: 980b         	ldr	r0, [sp, #0x2c]
7009d0a8: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009d0ac: 8880         	ldrh	r0, [r0, #0x4]
7009d0ae: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009d0b2: 980b         	ldr	r0, [sp, #0x2c]
7009d0b4: 7800         	ldrb	r0, [r0]
7009d0b6: 0740         	lsls	r0, r0, #0x1d
7009d0b8: 2800         	cmp	r0, #0x0
7009d0ba: d509         	bpl	0x7009d0d0 <Udma_eventReset+0x150> @ imm = #0x12
7009d0bc: e7ff         	b	0x7009d0be <Udma_eventReset+0x13e> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->blkCopyRingIrqOffset;
7009d0be: 980f         	ldr	r0, [sp, #0x3c]
7009d0c0: f8d0 10f0    	ldr.w	r1, [r0, #0xf0]
7009d0c4: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d0c8: 4408         	add	r0, r1
7009d0ca: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d0ce: e017         	b	0x7009d100 <Udma_eventReset+0x180> @ imm = #0x2e
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009d0d0: 980b         	ldr	r0, [sp, #0x2c]
7009d0d2: 7800         	ldrb	r0, [r0]
7009d0d4: 07c0         	lsls	r0, r0, #0x1f
7009d0d6: b148         	cbz	r0, 0x7009d0ec <Udma_eventReset+0x16c> @ imm = #0x12
7009d0d8: e7ff         	b	0x7009d0da <Udma_eventReset+0x15a> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009d0da: 980f         	ldr	r0, [sp, #0x3c]
7009d0dc: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009d0e0: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d0e4: 4408         	add	r0, r1
7009d0e6: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d0ea: e008         	b	0x7009d0fe <Udma_eventReset+0x17e> @ imm = #0x10
;                 rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009d0ec: 980f         	ldr	r0, [sp, #0x3c]
7009d0ee: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009d0f2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d0f6: 4408         	add	r0, r1
7009d0f8: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d0fc: e7ff         	b	0x7009d0fe <Udma_eventReset+0x17e> @ imm = #-0x2
7009d0fe: e7ff         	b	0x7009d100 <Udma_eventReset+0x180> @ imm = #-0x2
;         }
7009d100: e00b         	b	0x7009d11a <Udma_eventReset+0x19a> @ imm = #0x16
;             rmIrqReq.src_index = chHandle->tdCqRing->ringNum;
7009d102: 980b         	ldr	r0, [sp, #0x2c]
7009d104: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009d108: 8880         	ldrh	r0, [r0, #0x4]
7009d10a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             rmIrqReq.src_index += TISCI_RINGACC0_OES_IRQ_SRC_IDX_START;
7009d10e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d112: 3014         	adds	r0, #0x14
7009d114: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d118: e7ff         	b	0x7009d11a <Udma_eventReset+0x19a> @ imm = #-0x2
;     }
7009d11a: e7ff         	b	0x7009d11c <Udma_eventReset+0x19c> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009d11c: 9809         	ldr	r0, [sp, #0x24]
7009d11e: 6800         	ldr	r0, [r0]
7009d120: 2803         	cmp	r0, #0x3
7009d122: d156         	bne	0x7009d1d2 <Udma_eventReset+0x252> @ imm = #0xac
7009d124: e7ff         	b	0x7009d126 <Udma_eventReset+0x1a6> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d126: 980f         	ldr	r0, [sp, #0x3c]
7009d128: 6800         	ldr	r0, [r0]
7009d12a: 2802         	cmp	r0, #0x2
7009d12c: d104         	bne	0x7009d138 <Udma_eventReset+0x1b8> @ imm = #0x8
7009d12e: e7ff         	b	0x7009d130 <Udma_eventReset+0x1b0> @ imm = #-0x2
7009d130: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009d134: 900d         	str	r0, [sp, #0x34]
;         }
7009d136: e04b         	b	0x7009d1d0 <Udma_eventReset+0x250> @ imm = #0x96
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009d138: 9809         	ldr	r0, [sp, #0x24]
7009d13a: 6880         	ldr	r0, [r0, #0x8]
7009d13c: 900b         	str	r0, [sp, #0x2c]
;             rmIrqReq.src_id = drvHandle->srcIdTrIrq;
7009d13e: 980f         	ldr	r0, [sp, #0x3c]
7009d140: f8b0 00fc    	ldrh.w	r0, [r0, #0xfc]
7009d144: f8ad 0014    	strh.w	r0, [sp, #0x14]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009d148: 980b         	ldr	r0, [sp, #0x2c]
7009d14a: 7800         	ldrb	r0, [r0]
7009d14c: 0740         	lsls	r0, r0, #0x1d
7009d14e: 2800         	cmp	r0, #0x0
7009d150: d50d         	bpl	0x7009d16e <Udma_eventReset+0x1ee> @ imm = #0x1a
7009d152: e7ff         	b	0x7009d154 <Udma_eventReset+0x1d4> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009d154: 980b         	ldr	r0, [sp, #0x2c]
7009d156: 6ec0         	ldr	r0, [r0, #0x6c]
7009d158: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->blkCopyTrIrqOffset;
7009d15c: 980f         	ldr	r0, [sp, #0x3c]
7009d15e: f8d0 1100    	ldr.w	r1, [r0, #0x100]
7009d162: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d166: 4408         	add	r0, r1
7009d168: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d16c: e02f         	b	0x7009d1ce <Udma_eventReset+0x24e> @ imm = #0x5e
;             else if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009d16e: 980b         	ldr	r0, [sp, #0x2c]
7009d170: 7800         	ldrb	r0, [r0]
7009d172: 0780         	lsls	r0, r0, #0x1e
7009d174: 2800         	cmp	r0, #0x0
7009d176: d50d         	bpl	0x7009d194 <Udma_eventReset+0x214> @ imm = #0x1a
7009d178: e7ff         	b	0x7009d17a <Udma_eventReset+0x1fa> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->rxChNum;
7009d17a: 980b         	ldr	r0, [sp, #0x2c]
7009d17c: 6f00         	ldr	r0, [r0, #0x70]
7009d17e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->rxTrIrqOffset;
7009d182: 980f         	ldr	r0, [sp, #0x3c]
7009d184: f8d0 1108    	ldr.w	r1, [r0, #0x108]
7009d188: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d18c: 4408         	add	r0, r1
7009d18e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d192: e01b         	b	0x7009d1cc <Udma_eventReset+0x24c> @ imm = #0x36
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009d194: 980b         	ldr	r0, [sp, #0x2c]
7009d196: 7800         	ldrb	r0, [r0]
7009d198: 07c0         	lsls	r0, r0, #0x1f
7009d19a: b168         	cbz	r0, 0x7009d1b8 <Udma_eventReset+0x238> @ imm = #0x1a
7009d19c: e7ff         	b	0x7009d19e <Udma_eventReset+0x21e> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009d19e: 980b         	ldr	r0, [sp, #0x2c]
7009d1a0: 6ec0         	ldr	r0, [r0, #0x6c]
7009d1a2: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->txTrIrqOffset;
7009d1a6: 980f         	ldr	r0, [sp, #0x3c]
7009d1a8: f8d0 1104    	ldr.w	r1, [r0, #0x104]
7009d1ac: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d1b0: 4408         	add	r0, r1
7009d1b2: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d1b6: e008         	b	0x7009d1ca <Udma_eventReset+0x24a> @ imm = #0x10
;                 rmIrqReq.src_id = drvHandle->devIdIa;
7009d1b8: 980f         	ldr	r0, [sp, #0x3c]
7009d1ba: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009d1be: f8ad 0014    	strh.w	r0, [sp, #0x14]
7009d1c2: 2000         	movs	r0, #0x0
;                 rmIrqReq.src_index = 0U;                /* Not used by DMSC RM */
7009d1c4: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d1c8: e7ff         	b	0x7009d1ca <Udma_eventReset+0x24a> @ imm = #-0x2
7009d1ca: e7ff         	b	0x7009d1cc <Udma_eventReset+0x24c> @ imm = #-0x2
7009d1cc: e7ff         	b	0x7009d1ce <Udma_eventReset+0x24e> @ imm = #-0x2
7009d1ce: e7ff         	b	0x7009d1d0 <Udma_eventReset+0x250> @ imm = #-0x2
;     }
7009d1d0: e7ff         	b	0x7009d1d2 <Udma_eventReset+0x252> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
7009d1d2: 9809         	ldr	r0, [sp, #0x24]
7009d1d4: 6800         	ldr	r0, [r0]
7009d1d6: 2804         	cmp	r0, #0x4
7009d1d8: d130         	bne	0x7009d23c <Udma_eventReset+0x2bc> @ imm = #0x60
7009d1da: e7ff         	b	0x7009d1dc <Udma_eventReset+0x25c> @ imm = #-0x2
;         ringHandle = (Udma_RingHandleInt) eventPrms->ringHandle;
7009d1dc: 9809         	ldr	r0, [sp, #0x24]
7009d1de: 68c0         	ldr	r0, [r0, #0xc]
7009d1e0: 900a         	str	r0, [sp, #0x28]
;         rmIrqReq.src_id     = drvHandle->srcIdRingIrq;
7009d1e2: 980f         	ldr	r0, [sp, #0x3c]
7009d1e4: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009d1e8: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmIrqReq.src_index  = ringHandle->ringNum;
7009d1ec: 980a         	ldr	r0, [sp, #0x28]
7009d1ee: 8880         	ldrh	r0, [r0, #0x4]
7009d1f0: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009d1f4: 980f         	ldr	r0, [sp, #0x3c]
7009d1f6: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009d1fa: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d1fe: 4408         	add	r0, r1
7009d200: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009d204: 980a         	ldr	r0, [sp, #0x28]
7009d206: 6dc0         	ldr	r0, [r0, #0x5c]
7009d208: 2804         	cmp	r0, #0x4
7009d20a: d316         	blo	0x7009d23a <Udma_eventReset+0x2ba> @ imm = #0x2c
7009d20c: e7ff         	b	0x7009d20e <Udma_eventReset+0x28e> @ imm = #-0x2
;            (ringHandle->mappedRingGrp < (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
7009d20e: 980a         	ldr	r0, [sp, #0x28]
7009d210: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009d212: 2807         	cmp	r0, #0x7
7009d214: d811         	bhi	0x7009d23a <Udma_eventReset+0x2ba> @ imm = #0x22
7009d216: e7ff         	b	0x7009d218 <Udma_eventReset+0x298> @ imm = #-0x2
;             rmIrqReq.src_index -= drvHandle->txRingIrqOffset;
7009d218: 980f         	ldr	r0, [sp, #0x3c]
7009d21a: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009d21e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d222: 1a40         	subs	r0, r0, r1
7009d224: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009d228: 980f         	ldr	r0, [sp, #0x3c]
7009d22a: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009d22e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d232: 4408         	add	r0, r1
7009d234: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         }
7009d238: e7ff         	b	0x7009d23a <Udma_eventReset+0x2ba> @ imm = #-0x2
;     }
7009d23a: e7ff         	b	0x7009d23c <Udma_eventReset+0x2bc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d23c: 980d         	ldr	r0, [sp, #0x34]
7009d23e: b9b0         	cbnz	r0, 0x7009d26e <Udma_eventReset+0x2ee> @ imm = #0x2c
7009d240: e7ff         	b	0x7009d242 <Udma_eventReset+0x2c2> @ imm = #-0x2
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009d242: 980f         	ldr	r0, [sp, #0x3c]
7009d244: 6800         	ldr	r0, [r0]
7009d246: b130         	cbz	r0, 0x7009d256 <Udma_eventReset+0x2d6> @ imm = #0xc
7009d248: e7ff         	b	0x7009d24a <Udma_eventReset+0x2ca> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009d24a: 9809         	ldr	r0, [sp, #0x24]
7009d24c: 6800         	ldr	r0, [r0]
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009d24e: 2805         	cmp	r0, #0x5
7009d250: d101         	bne	0x7009d256 <Udma_eventReset+0x2d6> @ imm = #0x2
7009d252: e7ff         	b	0x7009d254 <Udma_eventReset+0x2d4> @ imm = #-0x2
;         }
7009d254: e00a         	b	0x7009d26c <Udma_eventReset+0x2ec> @ imm = #0x14
7009d256: a802         	add	r0, sp, #0x8
7009d258: f04f 31ff    	mov.w	r1, #0xffffffff
;             retVal = Sciclient_rmIrqRelease(&rmIrqReq, UDMA_SCICLIENT_TIMEOUT);
7009d25c: f012 f990    	bl	0x700af580 <Sciclient_rmIrqRelease> @ imm = #0x12320
7009d260: 900d         	str	r0, [sp, #0x34]
;             if(CSL_PASS != retVal)
7009d262: 980d         	ldr	r0, [sp, #0x34]
7009d264: b108         	cbz	r0, 0x7009d26a <Udma_eventReset+0x2ea> @ imm = #0x2
7009d266: e7ff         	b	0x7009d268 <Udma_eventReset+0x2e8> @ imm = #-0x2
;             }
7009d268: e7ff         	b	0x7009d26a <Udma_eventReset+0x2ea> @ imm = #-0x2
7009d26a: e7ff         	b	0x7009d26c <Udma_eventReset+0x2ec> @ imm = #-0x2
;     }
7009d26c: e7ff         	b	0x7009d26e <Udma_eventReset+0x2ee> @ imm = #-0x2
;     return (retVal);
7009d26e: 980d         	ldr	r0, [sp, #0x34]
7009d270: b010         	add	sp, #0x40
7009d272: bd80         	pop	{r7, pc}

7009d274 <malloc>:
7009d274: e1a01000     	mov	r1, r0
7009d278: e3a00008     	mov	r0, #8
7009d27c: ea0009e4     	b	0x7009fa14 <memalign>   @ imm = #0x2790

7009d280 <Sciclient_service>:
; {
7009d280: b580         	push	{r7, lr}
7009d282: b094         	sub	sp, #0x50
7009d284: 9013         	str	r0, [sp, #0x4c]
7009d286: 9112         	str	r1, [sp, #0x48]
7009d288: 2000         	movs	r0, #0x0
;     int32_t   status        = SystemP_SUCCESS;
7009d28a: 9011         	str	r0, [sp, #0x44]
7009d28c: 210f         	movs	r1, #0xf
;     uint32_t  contextId     = SCICLIENT_CONTEXT_MAX_NUM;
7009d28e: 9110         	str	r1, [sp, #0x40]
;     uint32_t  initialCount  = 0U;
7009d290: 900f         	str	r0, [sp, #0x3c]
;     uint8_t   localSeqId    = gSciclientHandle.currSeqId;
7009d292: f242 6108    	movw	r1, #0x2608
7009d296: f2c7 010b    	movt	r1, #0x700b
7009d29a: 6809         	ldr	r1, [r1]
7009d29c: f88d 103b    	strb.w	r1, [sp, #0x3b]
;     uint32_t  txPayloadSize = 0U;
7009d2a0: 900d         	str	r0, [sp, #0x34]
;     uint32_t  rxPayloadSize = 0U;
7009d2a2: 900c         	str	r0, [sp, #0x30]
;     uint8_t  *pLocalRespPayload = NULL;
7009d2a4: 900b         	str	r0, [sp, #0x2c]
;     uint8_t  *pSecHeader = NULL;
7009d2a6: 9007         	str	r0, [sp, #0x1c]
;     if((pReqPrm == NULL) || (pRespPrm == NULL) || (pReqPrm->pReqPayload == NULL))
7009d2a8: 9813         	ldr	r0, [sp, #0x4c]
7009d2aa: b138         	cbz	r0, 0x7009d2bc <Sciclient_service+0x3c> @ imm = #0xe
7009d2ac: e7ff         	b	0x7009d2ae <Sciclient_service+0x2e> @ imm = #-0x2
7009d2ae: 9812         	ldr	r0, [sp, #0x48]
7009d2b0: b120         	cbz	r0, 0x7009d2bc <Sciclient_service+0x3c> @ imm = #0x8
7009d2b2: e7ff         	b	0x7009d2b4 <Sciclient_service+0x34> @ imm = #-0x2
7009d2b4: 9813         	ldr	r0, [sp, #0x4c]
7009d2b6: 6880         	ldr	r0, [r0, #0x8]
7009d2b8: b920         	cbnz	r0, 0x7009d2c4 <Sciclient_service+0x44> @ imm = #0x8
7009d2ba: e7ff         	b	0x7009d2bc <Sciclient_service+0x3c> @ imm = #-0x2
7009d2bc: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009d2c0: 9011         	str	r0, [sp, #0x44]
;     }
7009d2c2: e09e         	b	0x7009d402 <Sciclient_service+0x182> @ imm = #0x13c
;         contextId = Sciclient_getCurrentContext(pReqPrm->messageType);
7009d2c4: 9813         	ldr	r0, [sp, #0x4c]
7009d2c6: 8800         	ldrh	r0, [r0]
7009d2c8: f00a fb52    	bl	0x700a7970 <Sciclient_getCurrentContext> @ imm = #0xa6a4
7009d2cc: 9010         	str	r0, [sp, #0x40]
;         if(contextId < SCICLIENT_CONTEXT_MAX_NUM)
7009d2ce: 9810         	ldr	r0, [sp, #0x40]
7009d2d0: 280e         	cmp	r0, #0xe
7009d2d2: f200 8091    	bhi.w	0x7009d3f8 <Sciclient_service+0x178> @ imm = #0x122
7009d2d6: e7ff         	b	0x7009d2d8 <Sciclient_service+0x58> @ imm = #-0x2
;             txThread = Sciclient_getTxThreadId(contextId);
7009d2d8: 9810         	ldr	r0, [sp, #0x40]
7009d2da: f011 fee9    	bl	0x700af0b0 <Sciclient_getTxThreadId> @ imm = #0x11dd2
7009d2de: 900a         	str	r0, [sp, #0x28]
;             rxThread = Sciclient_getRxThreadId(contextId);
7009d2e0: 9810         	ldr	r0, [sp, #0x40]
7009d2e2: f011 fed5    	bl	0x700af090 <Sciclient_getRxThreadId> @ imm = #0x11daa
7009d2e6: 9009         	str	r0, [sp, #0x24]
;             if(gSciclientMap[contextId].context == SCICLIENT_SECURE_CONTEXT)
7009d2e8: 9810         	ldr	r0, [sp, #0x40]
7009d2ea: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009d2ee: f241 0060    	movw	r0, #0x1060
7009d2f2: f2c7 000b    	movt	r0, #0x700b
7009d2f6: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
7009d2fa: b938         	cbnz	r0, 0x7009d30c <Sciclient_service+0x8c> @ imm = #0xe
7009d2fc: e7ff         	b	0x7009d2fe <Sciclient_service+0x7e> @ imm = #-0x2
;                 gSecHeaderSizeWords = sizeof(struct tisci_sec_header)/sizeof(uint32_t);
7009d2fe: f242 7114    	movw	r1, #0x2714
7009d302: f2c7 010b    	movt	r1, #0x700b
7009d306: 2001         	movs	r0, #0x1
7009d308: 7008         	strb	r0, [r1]
;             }
7009d30a: e006         	b	0x7009d31a <Sciclient_service+0x9a> @ imm = #0xc
;                 gSecHeaderSizeWords = 0;
7009d30c: f242 7114    	movw	r1, #0x2714
7009d310: f2c7 010b    	movt	r1, #0x700b
7009d314: 2000         	movs	r0, #0x0
7009d316: 7008         	strb	r0, [r1]
7009d318: e7ff         	b	0x7009d31a <Sciclient_service+0x9a> @ imm = #-0x2
;             gSciclientHandle.maxMsgSizeBytes = CSL_secProxyGetMaxMsgSize(&gSciclientSecProxyCfg) -
7009d31a: f242 5080    	movw	r0, #0x2580
7009d31e: f2c7 000b    	movt	r0, #0x700b
7009d322: f011 f98d    	bl	0x700ae640 <CSL_secProxyGetMaxMsgSize> @ imm = #0x1131a
7009d326: 3804         	subs	r0, #0x4
7009d328: f242 6108    	movw	r1, #0x2608
7009d32c: f2c7 010b    	movt	r1, #0x700b
7009d330: 6148         	str	r0, [r1, #0x14]
;             if(gSciclientMap[contextId].context == SCICLIENT_SECURE_CONTEXT)
7009d332: 9810         	ldr	r0, [sp, #0x40]
7009d334: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009d338: f241 0060    	movw	r0, #0x1060
7009d33c: f2c7 000b    	movt	r0, #0x700b
7009d340: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
7009d344: b940         	cbnz	r0, 0x7009d358 <Sciclient_service+0xd8> @ imm = #0x10
7009d346: e7ff         	b	0x7009d348 <Sciclient_service+0xc8> @ imm = #-0x2
7009d348: 2000         	movs	r0, #0x0
;                 secHeader.integ_check = (uint16_t)0;
7009d34a: f8ad 0014    	strh.w	r0, [sp, #0x14]
;                 secHeader.rsvd = (uint16_t)0;
7009d34e: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d352: a805         	add	r0, sp, #0x14
;                 pSecHeader = (uint8_t * )(&secHeader);
7009d354: 9007         	str	r0, [sp, #0x1c]
;             }
7009d356: e7ff         	b	0x7009d358 <Sciclient_service+0xd8> @ imm = #-0x2
;             if (pReqPrm->reqPayloadSize > 0U)
7009d358: 9813         	ldr	r0, [sp, #0x4c]
7009d35a: 68c0         	ldr	r0, [r0, #0xc]
7009d35c: b128         	cbz	r0, 0x7009d36a <Sciclient_service+0xea> @ imm = #0xa
7009d35e: e7ff         	b	0x7009d360 <Sciclient_service+0xe0> @ imm = #-0x2
;                 txPayloadSize = pReqPrm->reqPayloadSize - sizeof(struct tisci_header);
7009d360: 9813         	ldr	r0, [sp, #0x4c]
7009d362: 68c0         	ldr	r0, [r0, #0xc]
7009d364: 3808         	subs	r0, #0x8
7009d366: 900d         	str	r0, [sp, #0x34]
;             }
7009d368: e002         	b	0x7009d370 <Sciclient_service+0xf0> @ imm = #0x4
7009d36a: 2000         	movs	r0, #0x0
;                 txPayloadSize = 0U;
7009d36c: 900d         	str	r0, [sp, #0x34]
7009d36e: e7ff         	b	0x7009d370 <Sciclient_service+0xf0> @ imm = #-0x2
;             if (txPayloadSize > (gSciclientHandle.maxMsgSizeBytes - sizeof(struct tisci_header)))
7009d370: 980d         	ldr	r0, [sp, #0x34]
7009d372: f242 6108    	movw	r1, #0x2608
7009d376: f2c7 010b    	movt	r1, #0x700b
7009d37a: 6949         	ldr	r1, [r1, #0x14]
7009d37c: 3908         	subs	r1, #0x8
7009d37e: 4288         	cmp	r0, r1
7009d380: d904         	bls	0x7009d38c <Sciclient_service+0x10c> @ imm = #0x8
7009d382: e7ff         	b	0x7009d384 <Sciclient_service+0x104> @ imm = #-0x2
7009d384: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d388: 9011         	str	r0, [sp, #0x44]
;             }
7009d38a: e7ff         	b	0x7009d38c <Sciclient_service+0x10c> @ imm = #-0x2
;             if ((txPayloadSize > 0U) && (pReqPrm->pReqPayload == NULL))
7009d38c: 980d         	ldr	r0, [sp, #0x34]
7009d38e: b140         	cbz	r0, 0x7009d3a2 <Sciclient_service+0x122> @ imm = #0x10
7009d390: e7ff         	b	0x7009d392 <Sciclient_service+0x112> @ imm = #-0x2
7009d392: 9813         	ldr	r0, [sp, #0x4c]
7009d394: 6880         	ldr	r0, [r0, #0x8]
7009d396: b920         	cbnz	r0, 0x7009d3a2 <Sciclient_service+0x122> @ imm = #0x8
7009d398: e7ff         	b	0x7009d39a <Sciclient_service+0x11a> @ imm = #-0x2
7009d39a: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d39e: 9011         	str	r0, [sp, #0x44]
;             }
7009d3a0: e7ff         	b	0x7009d3a2 <Sciclient_service+0x122> @ imm = #-0x2
;             if (pRespPrm->respPayloadSize > 0U)
7009d3a2: 9812         	ldr	r0, [sp, #0x48]
7009d3a4: 6880         	ldr	r0, [r0, #0x8]
7009d3a6: b128         	cbz	r0, 0x7009d3b4 <Sciclient_service+0x134> @ imm = #0xa
7009d3a8: e7ff         	b	0x7009d3aa <Sciclient_service+0x12a> @ imm = #-0x2
;                 rxPayloadSize = pRespPrm->respPayloadSize - sizeof(struct tisci_header);
7009d3aa: 9812         	ldr	r0, [sp, #0x48]
7009d3ac: 6880         	ldr	r0, [r0, #0x8]
7009d3ae: 3808         	subs	r0, #0x8
7009d3b0: 900c         	str	r0, [sp, #0x30]
;             }
7009d3b2: e002         	b	0x7009d3ba <Sciclient_service+0x13a> @ imm = #0x4
7009d3b4: 2000         	movs	r0, #0x0
;                 rxPayloadSize = 0U;
7009d3b6: 900c         	str	r0, [sp, #0x30]
7009d3b8: e7ff         	b	0x7009d3ba <Sciclient_service+0x13a> @ imm = #-0x2
;             if (rxPayloadSize > (gSciclientHandle.maxMsgSizeBytes - sizeof(struct tisci_header)))
7009d3ba: 980c         	ldr	r0, [sp, #0x30]
7009d3bc: f242 6108    	movw	r1, #0x2608
7009d3c0: f2c7 010b    	movt	r1, #0x700b
7009d3c4: 6949         	ldr	r1, [r1, #0x14]
7009d3c6: 3908         	subs	r1, #0x8
7009d3c8: 4288         	cmp	r0, r1
7009d3ca: d904         	bls	0x7009d3d6 <Sciclient_service+0x156> @ imm = #0x8
7009d3cc: e7ff         	b	0x7009d3ce <Sciclient_service+0x14e> @ imm = #-0x2
7009d3ce: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d3d2: 9011         	str	r0, [sp, #0x44]
;             }
7009d3d4: e7ff         	b	0x7009d3d6 <Sciclient_service+0x156> @ imm = #-0x2
;             if ((rxPayloadSize > 0U) && (pRespPrm->pRespPayload == NULL))
7009d3d6: 980c         	ldr	r0, [sp, #0x30]
7009d3d8: b140         	cbz	r0, 0x7009d3ec <Sciclient_service+0x16c> @ imm = #0x10
7009d3da: e7ff         	b	0x7009d3dc <Sciclient_service+0x15c> @ imm = #-0x2
7009d3dc: 9812         	ldr	r0, [sp, #0x48]
7009d3de: 6840         	ldr	r0, [r0, #0x4]
7009d3e0: b920         	cbnz	r0, 0x7009d3ec <Sciclient_service+0x16c> @ imm = #0x8
7009d3e2: e7ff         	b	0x7009d3e4 <Sciclient_service+0x164> @ imm = #-0x2
7009d3e4: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d3e8: 9011         	str	r0, [sp, #0x44]
;             }
7009d3ea: e004         	b	0x7009d3f6 <Sciclient_service+0x176> @ imm = #0x8
;                 pLocalRespPayload = (uint8_t *)(pRespPrm->pRespPayload + sizeof(struct tisci_header));
7009d3ec: 9812         	ldr	r0, [sp, #0x48]
7009d3ee: 6840         	ldr	r0, [r0, #0x4]
7009d3f0: 3008         	adds	r0, #0x8
7009d3f2: 900b         	str	r0, [sp, #0x2c]
7009d3f4: e7ff         	b	0x7009d3f6 <Sciclient_service+0x176> @ imm = #-0x2
;         }
7009d3f6: e003         	b	0x7009d400 <Sciclient_service+0x180> @ imm = #0x6
7009d3f8: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009d3fc: 9011         	str	r0, [sp, #0x44]
7009d3fe: e7ff         	b	0x7009d400 <Sciclient_service+0x180> @ imm = #-0x2
7009d400: e7ff         	b	0x7009d402 <Sciclient_service+0x182> @ imm = #-0x2
;     key = HwiP_disable();
7009d402: f013 e92e    	blx	0x700b0660 <HwiP_disable> @ imm = #0x1325c
7009d406: 9008         	str	r0, [sp, #0x20]
;     if (SystemP_SUCCESS == status)
7009d408: 9811         	ldr	r0, [sp, #0x44]
7009d40a: 2800         	cmp	r0, #0x0
7009d40c: d159         	bne	0x7009d4c2 <Sciclient_service+0x242> @ imm = #0xb2
7009d40e: e7ff         	b	0x7009d410 <Sciclient_service+0x190> @ imm = #-0x2
;         Sciclient_secProxyFlush(rxThread);
7009d410: 9809         	ldr	r0, [sp, #0x24]
7009d412: f010 fe45    	bl	0x700ae0a0 <Sciclient_secProxyFlush> @ imm = #0x10c8a
;         header = (struct tisci_header*)pReqPrm->pReqPayload;
7009d416: 9813         	ldr	r0, [sp, #0x4c]
7009d418: 6880         	ldr	r0, [r0, #0x8]
7009d41a: 9006         	str	r0, [sp, #0x18]
;         header->type = pReqPrm->messageType;
7009d41c: 9813         	ldr	r0, [sp, #0x4c]
7009d41e: 8800         	ldrh	r0, [r0]
7009d420: 9906         	ldr	r1, [sp, #0x18]
7009d422: 8008         	strh	r0, [r1]
;         header->host = (uint8_t) gSciclientMap[contextId].hostId;
7009d424: 9810         	ldr	r0, [sp, #0x40]
7009d426: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009d42a: f241 0060    	movw	r0, #0x1060
7009d42e: f2c7 000b    	movt	r0, #0x700b
7009d432: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009d436: 6840         	ldr	r0, [r0, #0x4]
7009d438: 9906         	ldr	r1, [sp, #0x18]
7009d43a: 7088         	strb	r0, [r1, #0x2]
;         header->seq = localSeqId;
7009d43c: f89d 003b    	ldrb.w	r0, [sp, #0x3b]
7009d440: 9906         	ldr	r1, [sp, #0x18]
7009d442: 70c8         	strb	r0, [r1, #0x3]
;         pFlags = (uint8_t*)&pReqPrm->flags;
7009d444: 9813         	ldr	r0, [sp, #0x4c]
7009d446: 3004         	adds	r0, #0x4
7009d448: 9004         	str	r0, [sp, #0x10]
7009d44a: 2000         	movs	r0, #0x0
;         for (numBytes = 0; numBytes < sizeof(pReqPrm->flags); numBytes++)
7009d44c: 9003         	str	r0, [sp, #0xc]
7009d44e: e7ff         	b	0x7009d450 <Sciclient_service+0x1d0> @ imm = #-0x2
7009d450: 9803         	ldr	r0, [sp, #0xc]
7009d452: 2803         	cmp	r0, #0x3
7009d454: d811         	bhi	0x7009d47a <Sciclient_service+0x1fa> @ imm = #0x22
7009d456: e7ff         	b	0x7009d458 <Sciclient_service+0x1d8> @ imm = #-0x2
;             uint8_t *pDestFlags = ((uint8_t*)&header->flags) + numBytes;
7009d458: 9806         	ldr	r0, [sp, #0x18]
7009d45a: 9903         	ldr	r1, [sp, #0xc]
7009d45c: 4408         	add	r0, r1
7009d45e: 3004         	adds	r0, #0x4
7009d460: 9002         	str	r0, [sp, #0x8]
;             *pDestFlags = *pFlags;
7009d462: 9804         	ldr	r0, [sp, #0x10]
7009d464: 7800         	ldrb	r0, [r0]
7009d466: 9902         	ldr	r1, [sp, #0x8]
7009d468: 7008         	strb	r0, [r1]
;             pFlags++;
7009d46a: 9804         	ldr	r0, [sp, #0x10]
7009d46c: 3001         	adds	r0, #0x1
7009d46e: 9004         	str	r0, [sp, #0x10]
;         }
7009d470: e7ff         	b	0x7009d472 <Sciclient_service+0x1f2> @ imm = #-0x2
;         for (numBytes = 0; numBytes < sizeof(pReqPrm->flags); numBytes++)
7009d472: 9803         	ldr	r0, [sp, #0xc]
7009d474: 3001         	adds	r0, #0x1
7009d476: 9003         	str	r0, [sp, #0xc]
7009d478: e7ea         	b	0x7009d450 <Sciclient_service+0x1d0> @ imm = #-0x2c
;         gSciclientHandle.currSeqId = (gSciclientHandle.currSeqId + 1U) %
7009d47a: f242 6108    	movw	r1, #0x2608
7009d47e: f2c7 010b    	movt	r1, #0x700b
7009d482: 6808         	ldr	r0, [r1]
7009d484: 3001         	adds	r0, #0x1
7009d486: f644 1225    	movw	r2, #0x4925
7009d48a: f2c2 4292    	movt	r2, #0x2492
7009d48e: fba0 3202    	umull	r3, r2, r0, r2
7009d492: 1a83         	subs	r3, r0, r2
7009d494: eb02 0353    	add.w	r3, r2, r3, lsr #1
7009d498: 089a         	lsrs	r2, r3, #0x2
7009d49a: 00d2         	lsls	r2, r2, #0x3
7009d49c: eba2 0293    	sub.w	r2, r2, r3, lsr #2
7009d4a0: 1a80         	subs	r0, r0, r2
7009d4a2: 6008         	str	r0, [r1]
;         status = Sciclient_secProxyVerifyThread(txThread);
7009d4a4: 980a         	ldr	r0, [sp, #0x28]
7009d4a6: f011 fbb3    	bl	0x700aec10 <Sciclient_secProxyVerifyThread> @ imm = #0x11766
7009d4aa: 9011         	str	r0, [sp, #0x44]
;         if (SystemP_SUCCESS == status)
7009d4ac: 9811         	ldr	r0, [sp, #0x44]
7009d4ae: b938         	cbnz	r0, 0x7009d4c0 <Sciclient_service+0x240> @ imm = #0xe
7009d4b0: e7ff         	b	0x7009d4b2 <Sciclient_service+0x232> @ imm = #-0x2
;             status = Sciclient_secProxyWaitThread(txThread, pReqPrm->timeout);
7009d4b2: 980a         	ldr	r0, [sp, #0x28]
7009d4b4: 9913         	ldr	r1, [sp, #0x4c]
7009d4b6: 6909         	ldr	r1, [r1, #0x10]
7009d4b8: f010 fb12    	bl	0x700adae0 <Sciclient_secProxyWaitThread> @ imm = #0x10624
7009d4bc: 9011         	str	r0, [sp, #0x44]
;         }
7009d4be: e7ff         	b	0x7009d4c0 <Sciclient_service+0x240> @ imm = #-0x2
;     }
7009d4c0: e7ff         	b	0x7009d4c2 <Sciclient_service+0x242> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
7009d4c2: 9811         	ldr	r0, [sp, #0x44]
7009d4c4: b9b0         	cbnz	r0, 0x7009d4f4 <Sciclient_service+0x274> @ imm = #0x2c
7009d4c6: e7ff         	b	0x7009d4c8 <Sciclient_service+0x248> @ imm = #-0x2
;         initialCount = Sciclient_secProxyReadThreadCount(rxThread);
7009d4c8: 9809         	ldr	r0, [sp, #0x24]
7009d4ca: f012 f869    	bl	0x700af5a0 <Sciclient_secProxyReadThreadCount> @ imm = #0x120d2
7009d4ce: 900f         	str	r0, [sp, #0x3c]
;         Sciclient_sendMessage(txThread, pSecHeader ,(uint8_t *) header,
7009d4d0: 980a         	ldr	r0, [sp, #0x28]
7009d4d2: 9907         	ldr	r1, [sp, #0x1c]
7009d4d4: 9a06         	ldr	r2, [sp, #0x18]
;                               (pReqPrm->pReqPayload + sizeof(struct tisci_header)),
7009d4d6: 9b13         	ldr	r3, [sp, #0x4c]
7009d4d8: 689b         	ldr	r3, [r3, #0x8]
7009d4da: 3308         	adds	r3, #0x8
;                               txPayloadSize);
7009d4dc: f8dd c034    	ldr.w	r12, [sp, #0x34]
;         Sciclient_sendMessage(txThread, pSecHeader ,(uint8_t *) header,
7009d4e0: 46ee         	mov	lr, sp
7009d4e2: f8ce c000    	str.w	r12, [lr]
7009d4e6: f004 ffcb    	bl	0x700a2480 <Sciclient_sendMessage> @ imm = #0x4f96
;         status = Sciclient_secProxyVerifyThread(rxThread);
7009d4ea: 9809         	ldr	r0, [sp, #0x24]
7009d4ec: f011 fb90    	bl	0x700aec10 <Sciclient_secProxyVerifyThread> @ imm = #0x11720
7009d4f0: 9011         	str	r0, [sp, #0x44]
;     }
7009d4f2: e7ff         	b	0x7009d4f4 <Sciclient_service+0x274> @ imm = #-0x2
;     if ((status == SystemP_SUCCESS) &&
7009d4f4: 9811         	ldr	r0, [sp, #0x44]
7009d4f6: b978         	cbnz	r0, 0x7009d518 <Sciclient_service+0x298> @ imm = #0x1e
7009d4f8: e7ff         	b	0x7009d4fa <Sciclient_service+0x27a> @ imm = #-0x2
;         ((pReqPrm->flags & TISCI_MSG_FLAG_MASK) != 0U))
7009d4fa: 9813         	ldr	r0, [sp, #0x4c]
;     if ((status == SystemP_SUCCESS) &&
7009d4fc: 7900         	ldrb	r0, [r0, #0x4]
7009d4fe: 0780         	lsls	r0, r0, #0x1e
7009d500: b150         	cbz	r0, 0x7009d518 <Sciclient_service+0x298> @ imm = #0x14
7009d502: e7ff         	b	0x7009d504 <Sciclient_service+0x284> @ imm = #-0x2
;         status = Sciclient_waitForMessage(rxThread, pReqPrm->timeout, initialCount, localSeqId);
7009d504: 9809         	ldr	r0, [sp, #0x24]
7009d506: 9913         	ldr	r1, [sp, #0x4c]
7009d508: 6909         	ldr	r1, [r1, #0x10]
7009d50a: 9a0f         	ldr	r2, [sp, #0x3c]
7009d50c: f89d 303b    	ldrb.w	r3, [sp, #0x3b]
7009d510: f008 fc46    	bl	0x700a5da0 <Sciclient_waitForMessage> @ imm = #0x888c
7009d514: 9011         	str	r0, [sp, #0x44]
;     }
7009d516: e7ff         	b	0x7009d518 <Sciclient_service+0x298> @ imm = #-0x2
;     if(status == SystemP_SUCCESS)
7009d518: 9811         	ldr	r0, [sp, #0x44]
7009d51a: b990         	cbnz	r0, 0x7009d542 <Sciclient_service+0x2c2> @ imm = #0x24
7009d51c: e7ff         	b	0x7009d51e <Sciclient_service+0x29e> @ imm = #-0x2
;         pRespPrm->flags = Sciclient_secProxyReadThread32(rxThread, 1U+gSecHeaderSizeWords);
7009d51e: 9809         	ldr	r0, [sp, #0x24]
7009d520: f242 7114    	movw	r1, #0x2714
7009d524: f2c7 010b    	movt	r1, #0x700b
7009d528: 7809         	ldrb	r1, [r1]
7009d52a: 3101         	adds	r1, #0x1
7009d52c: b2c9         	uxtb	r1, r1
7009d52e: f011 f8cf    	bl	0x700ae6d0 <Sciclient_secProxyReadThread32> @ imm = #0x1119e
7009d532: 9912         	ldr	r1, [sp, #0x48]
7009d534: 6008         	str	r0, [r1]
;         Sciclient_recvMessage(rxThread, pLocalRespPayload, rxPayloadSize);
7009d536: 9809         	ldr	r0, [sp, #0x24]
7009d538: 990b         	ldr	r1, [sp, #0x2c]
7009d53a: 9a0c         	ldr	r2, [sp, #0x30]
7009d53c: f005 fca8    	bl	0x700a2e90 <Sciclient_recvMessage> @ imm = #0x5950
;     }
7009d540: e7ff         	b	0x7009d542 <Sciclient_service+0x2c2> @ imm = #-0x2
;     HwiP_restore(key);
7009d542: 9808         	ldr	r0, [sp, #0x20]
7009d544: f013 e8ac    	blx	0x700b06a0 <HwiP_restore> @ imm = #0x13158
;     return status;
7009d548: 9811         	ldr	r0, [sp, #0x44]
7009d54a: b014         	add	sp, #0x50
7009d54c: bd80         	pop	{r7, pc}
7009d54e: 0000         	movs	r0, r0

7009d550 <Udma_chDisableRxChan>:
; {
7009d550: b580         	push	{r7, lr}
7009d552: b096         	sub	sp, #0x58
7009d554: 9015         	str	r0, [sp, #0x54]
7009d556: 9114         	str	r1, [sp, #0x50]
7009d558: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009d55a: 9013         	str	r0, [sp, #0x4c]
;     uint32_t            currTimeout = 0U, regVal;
7009d55c: 9012         	str	r0, [sp, #0x48]
;     uint32_t            peerRtEnable = 0U, peerRtEnableBit = 0U;
7009d55e: 9004         	str	r0, [sp, #0x10]
7009d560: 9003         	str	r0, [sp, #0xc]
;     drvHandle = chHandle->drvHandle;
7009d562: 9815         	ldr	r0, [sp, #0x54]
7009d564: 6e80         	ldr	r0, [r0, #0x68]
7009d566: 9010         	str	r0, [sp, #0x40]
7009d568: 2008         	movs	r0, #0x8
;     rtEnableRegOffset = CSL_PSILCFG_REG_RT_ENABLE - CSL_PSILCFG_REG_STATIC_TR;
7009d56a: 9002         	str	r0, [sp, #0x8]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d56c: 9810         	ldr	r0, [sp, #0x40]
7009d56e: 6800         	ldr	r0, [r0]
7009d570: 2801         	cmp	r0, #0x1
7009d572: d115         	bne	0x7009d5a0 <Udma_chDisableRxChan+0x50> @ imm = #0x2a
7009d574: e7ff         	b	0x7009d576 <Udma_chDisableRxChan+0x26> @ imm = #-0x2
;         regVal = CSL_REG32_RD(&chHandle->pBcdmaRxRtRegs->PEER8);
7009d576: 9815         	ldr	r0, [sp, #0x54]
7009d578: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009d57c: f500 7008    	add.w	r0, r0, #0x220
7009d580: f012 f9de    	bl	0x700af940 <CSL_REG32_RD_RAW> @ imm = #0x123bc
7009d584: 9011         	str	r0, [sp, #0x44]
;         CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 1U);
7009d586: 9811         	ldr	r0, [sp, #0x44]
7009d588: f040 4080    	orr	r0, r0, #0x40000000
7009d58c: 9011         	str	r0, [sp, #0x44]
;         CSL_REG32_WR(&chHandle->pBcdmaRxRtRegs->PEER8, regVal);
7009d58e: 9815         	ldr	r0, [sp, #0x54]
7009d590: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009d594: f500 7008    	add.w	r0, r0, #0x220
7009d598: 9911         	ldr	r1, [sp, #0x44]
7009d59a: f012 f931    	bl	0x700af800 <CSL_REG32_WR_RAW> @ imm = #0x12262
;     }
7009d59e: e01a         	b	0x7009d5d6 <Udma_chDisableRxChan+0x86> @ imm = #0x34
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d5a0: 9810         	ldr	r0, [sp, #0x40]
7009d5a2: 6800         	ldr	r0, [r0]
7009d5a4: 2802         	cmp	r0, #0x2
7009d5a6: d115         	bne	0x7009d5d4 <Udma_chDisableRxChan+0x84> @ imm = #0x2a
7009d5a8: e7ff         	b	0x7009d5aa <Udma_chDisableRxChan+0x5a> @ imm = #-0x2
;         regVal = CSL_REG32_RD(&chHandle->pPktdmaRxRtRegs->PEER8);
7009d5aa: 9815         	ldr	r0, [sp, #0x54]
7009d5ac: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009d5b0: f500 7008    	add.w	r0, r0, #0x220
7009d5b4: f012 f9c4    	bl	0x700af940 <CSL_REG32_RD_RAW> @ imm = #0x12388
7009d5b8: 9011         	str	r0, [sp, #0x44]
;         CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 1U);
7009d5ba: 9811         	ldr	r0, [sp, #0x44]
7009d5bc: f040 4080    	orr	r0, r0, #0x40000000
7009d5c0: 9011         	str	r0, [sp, #0x44]
;         CSL_REG32_WR(&chHandle->pPktdmaRxRtRegs->PEER8, regVal);
7009d5c2: 9815         	ldr	r0, [sp, #0x54]
7009d5c4: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009d5c8: f500 7008    	add.w	r0, r0, #0x220
7009d5cc: 9911         	ldr	r1, [sp, #0x44]
7009d5ce: f012 f917    	bl	0x700af800 <CSL_REG32_WR_RAW> @ imm = #0x1222e
;     }
7009d5d2: e7ff         	b	0x7009d5d4 <Udma_chDisableRxChan+0x84> @ imm = #-0x2
7009d5d4: e7ff         	b	0x7009d5d6 <Udma_chDisableRxChan+0x86> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009d5d6: e7ff         	b	0x7009d5d8 <Udma_chDisableRxChan+0x88> @ imm = #-0x2
7009d5d8: 9813         	ldr	r0, [sp, #0x4c]
7009d5da: bbc8         	cbnz	r0, 0x7009d650 <Udma_chDisableRxChan+0x100> @ imm = #0x72
7009d5dc: e7ff         	b	0x7009d5de <Udma_chDisableRxChan+0x8e> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d5de: 9810         	ldr	r0, [sp, #0x40]
7009d5e0: 6800         	ldr	r0, [r0]
7009d5e2: 2801         	cmp	r0, #0x1
7009d5e4: d110         	bne	0x7009d608 <Udma_chDisableRxChan+0xb8> @ imm = #0x20
7009d5e6: e7ff         	b	0x7009d5e8 <Udma_chDisableRxChan+0x98> @ imm = #-0x2
;             (void) CSL_bcdmaGetRxRT(&drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009d5e8: 9a10         	ldr	r2, [sp, #0x40]
7009d5ea: f102 0008    	add.w	r0, r2, #0x8
7009d5ee: 9915         	ldr	r1, [sp, #0x54]
7009d5f0: 6f09         	ldr	r1, [r1, #0x70]
7009d5f2: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d5f6: 4411         	add	r1, r2
7009d5f8: aa0a         	add	r2, sp, #0x28
7009d5fa: f011 f911    	bl	0x700ae820 <CSL_bcdmaGetRxRT> @ imm = #0x11222
;             if(FALSE == bcdmaRtStatus.enable)
7009d5fe: 980a         	ldr	r0, [sp, #0x28]
7009d600: b908         	cbnz	r0, 0x7009d606 <Udma_chDisableRxChan+0xb6> @ imm = #0x2
7009d602: e7ff         	b	0x7009d604 <Udma_chDisableRxChan+0xb4> @ imm = #-0x2
;                 break;
7009d604: e024         	b	0x7009d650 <Udma_chDisableRxChan+0x100> @ imm = #0x48
;         }
7009d606: e011         	b	0x7009d62c <Udma_chDisableRxChan+0xdc> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d608: 9810         	ldr	r0, [sp, #0x40]
7009d60a: 6800         	ldr	r0, [r0]
7009d60c: 2802         	cmp	r0, #0x2
7009d60e: d10c         	bne	0x7009d62a <Udma_chDisableRxChan+0xda> @ imm = #0x18
7009d610: e7ff         	b	0x7009d612 <Udma_chDisableRxChan+0xc2> @ imm = #-0x2
;             (void) CSL_pktdmaGetRxRT(&drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009d612: 9810         	ldr	r0, [sp, #0x40]
7009d614: 3054         	adds	r0, #0x54
7009d616: 9915         	ldr	r1, [sp, #0x54]
7009d618: 6f09         	ldr	r1, [r1, #0x70]
7009d61a: aa05         	add	r2, sp, #0x14
7009d61c: f00f fda0    	bl	0x700ad160 <CSL_pktdmaGetRxRT> @ imm = #0xfb40
;             if(FALSE == pktdmaRtStatus.enable)
7009d620: 9805         	ldr	r0, [sp, #0x14]
7009d622: b908         	cbnz	r0, 0x7009d628 <Udma_chDisableRxChan+0xd8> @ imm = #0x2
7009d624: e7ff         	b	0x7009d626 <Udma_chDisableRxChan+0xd6> @ imm = #-0x2
;                 break;
7009d626: e013         	b	0x7009d650 <Udma_chDisableRxChan+0x100> @ imm = #0x26
;         }
7009d628: e7ff         	b	0x7009d62a <Udma_chDisableRxChan+0xda> @ imm = #-0x2
7009d62a: e7ff         	b	0x7009d62c <Udma_chDisableRxChan+0xdc> @ imm = #-0x2
;         if(currTimeout > timeout)
7009d62c: 9812         	ldr	r0, [sp, #0x48]
7009d62e: 9914         	ldr	r1, [sp, #0x50]
7009d630: 4288         	cmp	r0, r1
7009d632: d904         	bls	0x7009d63e <Udma_chDisableRxChan+0xee> @ imm = #0x8
7009d634: e7ff         	b	0x7009d636 <Udma_chDisableRxChan+0xe6> @ imm = #-0x2
7009d636: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009d63a: 9013         	str	r0, [sp, #0x4c]
;         }
7009d63c: e007         	b	0x7009d64e <Udma_chDisableRxChan+0xfe> @ imm = #0xe
7009d63e: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009d642: f00d fc75    	bl	0x700aaf30 <ClockP_usleep> @ imm = #0xd8ea
;             currTimeout++;
7009d646: 9812         	ldr	r0, [sp, #0x48]
7009d648: 3001         	adds	r0, #0x1
7009d64a: 9012         	str	r0, [sp, #0x48]
7009d64c: e7ff         	b	0x7009d64e <Udma_chDisableRxChan+0xfe> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009d64e: e7c3         	b	0x7009d5d8 <Udma_chDisableRxChan+0x88> @ imm = #-0x7a
;     if(UDMA_SOK != retVal)
7009d650: 9813         	ldr	r0, [sp, #0x4c]
7009d652: 2800         	cmp	r0, #0x0
7009d654: f000 8091    	beq.w	0x7009d77a <Udma_chDisableRxChan+0x22a> @ imm = #0x122
7009d658: e7ff         	b	0x7009d65a <Udma_chDisableRxChan+0x10a> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d65a: 9810         	ldr	r0, [sp, #0x40]
7009d65c: 6800         	ldr	r0, [r0]
7009d65e: 2801         	cmp	r0, #0x1
7009d660: d10e         	bne	0x7009d680 <Udma_chDisableRxChan+0x130> @ imm = #0x1c
7009d662: e7ff         	b	0x7009d664 <Udma_chDisableRxChan+0x114> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, (bool)true, (bool)false);
7009d664: 9a10         	ldr	r2, [sp, #0x40]
7009d666: f102 0008    	add.w	r0, r2, #0x8
7009d66a: 9915         	ldr	r1, [sp, #0x54]
7009d66c: 6f09         	ldr	r1, [r1, #0x70]
7009d66e: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d672: 4411         	add	r1, r2
7009d674: 2201         	movs	r2, #0x1
7009d676: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownRxChan(
7009d678: f00f ff22    	bl	0x700ad4c0 <CSL_bcdmaTeardownRxChan> @ imm = #0xfe44
7009d67c: 9013         	str	r0, [sp, #0x4c]
;         }
7009d67e: e00f         	b	0x7009d6a0 <Udma_chDisableRxChan+0x150> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d680: 9810         	ldr	r0, [sp, #0x40]
7009d682: 6800         	ldr	r0, [r0]
7009d684: 2802         	cmp	r0, #0x2
7009d686: d10a         	bne	0x7009d69e <Udma_chDisableRxChan+0x14e> @ imm = #0x14
7009d688: e7ff         	b	0x7009d68a <Udma_chDisableRxChan+0x13a> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->rxChNum, (bool)true, (bool)false);
7009d68a: 9810         	ldr	r0, [sp, #0x40]
7009d68c: 3054         	adds	r0, #0x54
7009d68e: 9915         	ldr	r1, [sp, #0x54]
7009d690: 6f09         	ldr	r1, [r1, #0x70]
7009d692: 2201         	movs	r2, #0x1
7009d694: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownRxChan(
7009d696: f010 fdc3    	bl	0x700ae220 <CSL_pktdmaTeardownRxChan> @ imm = #0x10b86
7009d69a: 9013         	str	r0, [sp, #0x4c]
;         }
7009d69c: e7ff         	b	0x7009d69e <Udma_chDisableRxChan+0x14e> @ imm = #-0x2
7009d69e: e7ff         	b	0x7009d6a0 <Udma_chDisableRxChan+0x150> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009d6a0: 9813         	ldr	r0, [sp, #0x4c]
7009d6a2: b108         	cbz	r0, 0x7009d6a8 <Udma_chDisableRxChan+0x158> @ imm = #0x2
7009d6a4: e7ff         	b	0x7009d6a6 <Udma_chDisableRxChan+0x156> @ imm = #-0x2
;         }
7009d6a6: e7ff         	b	0x7009d6a8 <Udma_chDisableRxChan+0x158> @ imm = #-0x2
7009d6a8: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009d6aa: 9012         	str	r0, [sp, #0x48]
;         while(UDMA_SOK == retVal)
7009d6ac: e7ff         	b	0x7009d6ae <Udma_chDisableRxChan+0x15e> @ imm = #-0x2
7009d6ae: 9813         	ldr	r0, [sp, #0x4c]
7009d6b0: 2800         	cmp	r0, #0x0
7009d6b2: d161         	bne	0x7009d778 <Udma_chDisableRxChan+0x228> @ imm = #0xc2
7009d6b4: e7ff         	b	0x7009d6b6 <Udma_chDisableRxChan+0x166> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d6b6: 9810         	ldr	r0, [sp, #0x40]
7009d6b8: 6800         	ldr	r0, [r0]
7009d6ba: 2801         	cmp	r0, #0x1
7009d6bc: d126         	bne	0x7009d70c <Udma_chDisableRxChan+0x1bc> @ imm = #0x4c
7009d6be: e7ff         	b	0x7009d6c0 <Udma_chDisableRxChan+0x170> @ imm = #-0x2
;                 (void) CSL_bcdmaGetRxRT(&drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009d6c0: 9a10         	ldr	r2, [sp, #0x40]
7009d6c2: f102 0008    	add.w	r0, r2, #0x8
7009d6c6: 9915         	ldr	r1, [sp, #0x54]
7009d6c8: 6f09         	ldr	r1, [r1, #0x70]
7009d6ca: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d6ce: 4411         	add	r1, r2
7009d6d0: aa0a         	add	r2, sp, #0x28
7009d6d2: f011 f8a5    	bl	0x700ae820 <CSL_bcdmaGetRxRT> @ imm = #0x1114a
;                     &drvHandle->bcdmaRegs,
7009d6d6: 9a10         	ldr	r2, [sp, #0x40]
7009d6d8: f102 0008    	add.w	r0, r2, #0x8
;                     chHandle->rxChNum + drvHandle->rxChOffset,
7009d6dc: 9915         	ldr	r1, [sp, #0x54]
7009d6de: 6f09         	ldr	r1, [r1, #0x70]
7009d6e0: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d6e4: 4411         	add	r1, r2
;                     rtEnableRegOffset, &peerRtEnable);
7009d6e6: 9b02         	ldr	r3, [sp, #0x8]
;                 (void) CSL_bcdmaGetChanPeerReg(
7009d6e8: 46ec         	mov	r12, sp
7009d6ea: aa04         	add	r2, sp, #0x10
7009d6ec: f8cc 2000    	str.w	r2, [r12]
7009d6f0: 2201         	movs	r2, #0x1
7009d6f2: f00f ffd5    	bl	0x700ad6a0 <CSL_bcdmaGetChanPeerReg> @ imm = #0xffaa
;                 peerRtEnableBit = CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE);
7009d6f6: 9804         	ldr	r0, [sp, #0x10]
7009d6f8: 0fc0         	lsrs	r0, r0, #0x1f
7009d6fa: 9003         	str	r0, [sp, #0xc]
;                 if((FALSE == bcdmaRtStatus.enable) && (FALSE == peerRtEnableBit))
7009d6fc: 980a         	ldr	r0, [sp, #0x28]
7009d6fe: b920         	cbnz	r0, 0x7009d70a <Udma_chDisableRxChan+0x1ba> @ imm = #0x8
7009d700: e7ff         	b	0x7009d702 <Udma_chDisableRxChan+0x1b2> @ imm = #-0x2
7009d702: 9803         	ldr	r0, [sp, #0xc]
7009d704: b908         	cbnz	r0, 0x7009d70a <Udma_chDisableRxChan+0x1ba> @ imm = #0x2
7009d706: e7ff         	b	0x7009d708 <Udma_chDisableRxChan+0x1b8> @ imm = #-0x2
;                     break;
7009d708: e036         	b	0x7009d778 <Udma_chDisableRxChan+0x228> @ imm = #0x6c
;             }
7009d70a: e023         	b	0x7009d754 <Udma_chDisableRxChan+0x204> @ imm = #0x46
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d70c: 9810         	ldr	r0, [sp, #0x40]
7009d70e: 6800         	ldr	r0, [r0]
7009d710: 2802         	cmp	r0, #0x2
7009d712: d11e         	bne	0x7009d752 <Udma_chDisableRxChan+0x202> @ imm = #0x3c
7009d714: e7ff         	b	0x7009d716 <Udma_chDisableRxChan+0x1c6> @ imm = #-0x2
;                 (void) CSL_pktdmaGetRxRT(&drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009d716: 9810         	ldr	r0, [sp, #0x40]
7009d718: 3054         	adds	r0, #0x54
7009d71a: 9915         	ldr	r1, [sp, #0x54]
7009d71c: 6f09         	ldr	r1, [r1, #0x70]
7009d71e: aa05         	add	r2, sp, #0x14
7009d720: f00f fd1e    	bl	0x700ad160 <CSL_pktdmaGetRxRT> @ imm = #0xfa3c
;                     &drvHandle->pktdmaRegs,
7009d724: 9810         	ldr	r0, [sp, #0x40]
7009d726: 3054         	adds	r0, #0x54
;                     chHandle->rxChNum,
7009d728: 9915         	ldr	r1, [sp, #0x54]
7009d72a: 6f09         	ldr	r1, [r1, #0x70]
;                     rtEnableRegOffset, &peerRtEnable);
7009d72c: 9b02         	ldr	r3, [sp, #0x8]
;                 (void) CSL_pktdmaGetChanPeerReg(
7009d72e: 46ec         	mov	r12, sp
7009d730: aa04         	add	r2, sp, #0x10
7009d732: f8cc 2000    	str.w	r2, [r12]
7009d736: 2201         	movs	r2, #0x1
7009d738: f010 ff0a    	bl	0x700ae550 <CSL_pktdmaGetChanPeerReg> @ imm = #0x10e14
;                 peerRtEnableBit = CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE);
7009d73c: 9804         	ldr	r0, [sp, #0x10]
7009d73e: 0fc0         	lsrs	r0, r0, #0x1f
7009d740: 9003         	str	r0, [sp, #0xc]
;                 if((FALSE == pktdmaRtStatus.enable) && (FALSE == peerRtEnableBit))
7009d742: 9805         	ldr	r0, [sp, #0x14]
7009d744: b920         	cbnz	r0, 0x7009d750 <Udma_chDisableRxChan+0x200> @ imm = #0x8
7009d746: e7ff         	b	0x7009d748 <Udma_chDisableRxChan+0x1f8> @ imm = #-0x2
7009d748: 9803         	ldr	r0, [sp, #0xc]
7009d74a: b908         	cbnz	r0, 0x7009d750 <Udma_chDisableRxChan+0x200> @ imm = #0x2
7009d74c: e7ff         	b	0x7009d74e <Udma_chDisableRxChan+0x1fe> @ imm = #-0x2
;                     break;
7009d74e: e013         	b	0x7009d778 <Udma_chDisableRxChan+0x228> @ imm = #0x26
;             }
7009d750: e7ff         	b	0x7009d752 <Udma_chDisableRxChan+0x202> @ imm = #-0x2
7009d752: e7ff         	b	0x7009d754 <Udma_chDisableRxChan+0x204> @ imm = #-0x2
;             if(currTimeout > timeout)
7009d754: 9812         	ldr	r0, [sp, #0x48]
7009d756: 9914         	ldr	r1, [sp, #0x50]
7009d758: 4288         	cmp	r0, r1
7009d75a: d904         	bls	0x7009d766 <Udma_chDisableRxChan+0x216> @ imm = #0x8
7009d75c: e7ff         	b	0x7009d75e <Udma_chDisableRxChan+0x20e> @ imm = #-0x2
7009d75e: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009d762: 9013         	str	r0, [sp, #0x4c]
;             }
7009d764: e007         	b	0x7009d776 <Udma_chDisableRxChan+0x226> @ imm = #0xe
7009d766: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009d76a: f00d fbe1    	bl	0x700aaf30 <ClockP_usleep> @ imm = #0xd7c2
;                 currTimeout++;
7009d76e: 9812         	ldr	r0, [sp, #0x48]
7009d770: 3001         	adds	r0, #0x1
7009d772: 9012         	str	r0, [sp, #0x48]
7009d774: e7ff         	b	0x7009d776 <Udma_chDisableRxChan+0x226> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009d776: e79a         	b	0x7009d6ae <Udma_chDisableRxChan+0x15e> @ imm = #-0xcc
;     }
7009d778: e7ff         	b	0x7009d77a <Udma_chDisableRxChan+0x22a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d77a: 9813         	ldr	r0, [sp, #0x4c]
7009d77c: 2800         	cmp	r0, #0x0
7009d77e: d148         	bne	0x7009d812 <Udma_chDisableRxChan+0x2c2> @ imm = #0x90
7009d780: e7ff         	b	0x7009d782 <Udma_chDisableRxChan+0x232> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d782: 9810         	ldr	r0, [sp, #0x40]
7009d784: 6800         	ldr	r0, [r0]
7009d786: 2801         	cmp	r0, #0x1
7009d788: d122         	bne	0x7009d7d0 <Udma_chDisableRxChan+0x280> @ imm = #0x44
7009d78a: e7ff         	b	0x7009d78c <Udma_chDisableRxChan+0x23c> @ imm = #-0x2
7009d78c: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.teardown = FALSE;   /* Note that other bits are cleared from previous call */
7009d78e: 900b         	str	r0, [sp, #0x2c]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) FALSE);
7009d790: 9804         	ldr	r0, [sp, #0x10]
7009d792: f020 4080    	bic	r0, r0, #0x40000000
7009d796: 9004         	str	r0, [sp, #0x10]
;                 &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009d798: 9a10         	ldr	r2, [sp, #0x40]
7009d79a: f102 0008    	add.w	r0, r2, #0x8
7009d79e: 9915         	ldr	r1, [sp, #0x54]
7009d7a0: 6f09         	ldr	r1, [r1, #0x70]
7009d7a2: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d7a6: 4411         	add	r1, r2
7009d7a8: aa0a         	add	r2, sp, #0x28
;             (void) CSL_bcdmaSetRxRT(
7009d7aa: f011 f869    	bl	0x700ae880 <CSL_bcdmaSetRxRT> @ imm = #0x110d2
;                 &drvHandle->bcdmaRegs,
7009d7ae: 9a10         	ldr	r2, [sp, #0x40]
7009d7b0: f102 0008    	add.w	r0, r2, #0x8
;                 chHandle->rxChNum + drvHandle->rxChOffset,
7009d7b4: 9915         	ldr	r1, [sp, #0x54]
7009d7b6: 6f09         	ldr	r1, [r1, #0x70]
7009d7b8: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d7bc: 4411         	add	r1, r2
;                 rtEnableRegOffset,
7009d7be: 9b02         	ldr	r3, [sp, #0x8]
;             (void) CSL_bcdmaSetChanPeerReg(
7009d7c0: 46ec         	mov	r12, sp
7009d7c2: aa04         	add	r2, sp, #0x10
7009d7c4: f8cc 2000    	str.w	r2, [r12]
7009d7c8: 2201         	movs	r2, #0x1
7009d7ca: f010 fa49    	bl	0x700adc60 <CSL_bcdmaSetChanPeerReg> @ imm = #0x10492
;         }
7009d7ce: e01f         	b	0x7009d810 <Udma_chDisableRxChan+0x2c0> @ imm = #0x3e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d7d0: 9810         	ldr	r0, [sp, #0x40]
7009d7d2: 6800         	ldr	r0, [r0]
7009d7d4: 2802         	cmp	r0, #0x2
7009d7d6: d11a         	bne	0x7009d80e <Udma_chDisableRxChan+0x2be> @ imm = #0x34
7009d7d8: e7ff         	b	0x7009d7da <Udma_chDisableRxChan+0x28a> @ imm = #-0x2
7009d7da: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.teardown = FALSE;   /* Note that other bits are cleared from previous call */
7009d7dc: 9006         	str	r0, [sp, #0x18]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) FALSE);
7009d7de: 9804         	ldr	r0, [sp, #0x10]
7009d7e0: f020 4080    	bic	r0, r0, #0x40000000
7009d7e4: 9004         	str	r0, [sp, #0x10]
;                 &drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009d7e6: 9810         	ldr	r0, [sp, #0x40]
7009d7e8: 3054         	adds	r0, #0x54
7009d7ea: 9915         	ldr	r1, [sp, #0x54]
7009d7ec: 6f09         	ldr	r1, [r1, #0x70]
7009d7ee: aa05         	add	r2, sp, #0x14
;             (void) CSL_pktdmaSetRxRT(
7009d7f0: f010 fa76    	bl	0x700adce0 <CSL_pktdmaSetRxRT> @ imm = #0x104ec
;                 &drvHandle->pktdmaRegs,
7009d7f4: 9810         	ldr	r0, [sp, #0x40]
7009d7f6: 3054         	adds	r0, #0x54
;                 chHandle->rxChNum,
7009d7f8: 9915         	ldr	r1, [sp, #0x54]
7009d7fa: 6f09         	ldr	r1, [r1, #0x70]
;                 rtEnableRegOffset,
7009d7fc: 9b02         	ldr	r3, [sp, #0x8]
;             (void) CSL_pktdmaSetChanPeerReg(
7009d7fe: 46ec         	mov	r12, sp
7009d800: aa04         	add	r2, sp, #0x10
7009d802: f8cc 2000    	str.w	r2, [r12]
7009d806: 2201         	movs	r2, #0x1
7009d808: f010 feba    	bl	0x700ae580 <CSL_pktdmaSetChanPeerReg> @ imm = #0x10d74
;         }
7009d80c: e7ff         	b	0x7009d80e <Udma_chDisableRxChan+0x2be> @ imm = #-0x2
7009d80e: e7ff         	b	0x7009d810 <Udma_chDisableRxChan+0x2c0> @ imm = #-0x2
;     }
7009d810: e7ff         	b	0x7009d812 <Udma_chDisableRxChan+0x2c2> @ imm = #-0x2
;     return (retVal);
7009d812: 9813         	ldr	r0, [sp, #0x4c]
7009d814: b016         	add	sp, #0x58
7009d816: bd80         	pop	{r7, pc}
		...

7009d820 <CSL_bcdmaChanOpCfgChan>:
; {
7009d820: b580         	push	{r7, lr}
7009d822: b08a         	sub	sp, #0x28
7009d824: 9009         	str	r0, [sp, #0x24]
7009d826: 9108         	str	r1, [sp, #0x20]
7009d828: 9207         	str	r2, [sp, #0x1c]
7009d82a: 9306         	str	r3, [sp, #0x18]
7009d82c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
7009d82e: 9005         	str	r0, [sp, #0x14]
;     if( pOpData == NULL )
7009d830: 9806         	ldr	r0, [sp, #0x18]
7009d832: b920         	cbnz	r0, 0x7009d83e <CSL_bcdmaChanOpCfgChan+0x1e> @ imm = #0x8
7009d834: e7ff         	b	0x7009d836 <CSL_bcdmaChanOpCfgChan+0x16> @ imm = #-0x2
7009d836: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
7009d83a: 9005         	str	r0, [sp, #0x14]
;     }
7009d83c: e137         	b	0x7009daae <CSL_bcdmaChanOpCfgChan+0x28e> @ imm = #0x26e
;         switch( chanType )
7009d83e: 9808         	ldr	r0, [sp, #0x20]
7009d840: 9000         	str	r0, [sp]
7009d842: b148         	cbz	r0, 0x7009d858 <CSL_bcdmaChanOpCfgChan+0x38> @ imm = #0x12
7009d844: e7ff         	b	0x7009d846 <CSL_bcdmaChanOpCfgChan+0x26> @ imm = #-0x2
7009d846: 9800         	ldr	r0, [sp]
7009d848: 2801         	cmp	r0, #0x1
7009d84a: d057         	beq	0x7009d8fc <CSL_bcdmaChanOpCfgChan+0xdc> @ imm = #0xae
7009d84c: e7ff         	b	0x7009d84e <CSL_bcdmaChanOpCfgChan+0x2e> @ imm = #-0x2
7009d84e: 9800         	ldr	r0, [sp]
7009d850: 2802         	cmp	r0, #0x2
7009d852: f000 80c1    	beq.w	0x7009d9d8 <CSL_bcdmaChanOpCfgChan+0x1b8> @ imm = #0x182
7009d856: e125         	b	0x7009daa4 <CSL_bcdmaChanOpCfgChan+0x284> @ imm = #0x24a
;                     CSL_BcdmaTxChanCfg *pChanCfg = (CSL_BcdmaTxChanCfg *)pOpData;
7009d858: 9806         	ldr	r0, [sp, #0x18]
7009d85a: 9003         	str	r0, [sp, #0xc]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES)   ||    /* Block-copy supports 32, 64, and 128-byte bursts */
7009d85c: 9803         	ldr	r0, [sp, #0xc]
7009d85e: 6c40         	ldr	r0, [r0, #0x44]
7009d860: 2802         	cmp	r0, #0x2
7009d862: d80a         	bhi	0x7009d87a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #0x14
7009d864: e7ff         	b	0x7009d866 <CSL_bcdmaChanOpCfgChan+0x46> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009d866: 9803         	ldr	r0, [sp, #0xc]
7009d868: 6a00         	ldr	r0, [r0, #0x20]
7009d86a: 2807         	cmp	r0, #0x7
7009d86c: d805         	bhi	0x7009d87a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #0xa
7009d86e: e7ff         	b	0x7009d870 <CSL_bcdmaChanOpCfgChan+0x50> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009d870: 9803         	ldr	r0, [sp, #0xc]
7009d872: 6ac0         	ldr	r0, [r0, #0x2c]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES)   ||    /* Block-copy supports 32, 64, and 128-byte bursts */
7009d874: 2804         	cmp	r0, #0x4
7009d876: d304         	blo	0x7009d882 <CSL_bcdmaChanOpCfgChan+0x62> @ imm = #0x8
7009d878: e7ff         	b	0x7009d87a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #-0x2
7009d87a: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009d87e: 9005         	str	r0, [sp, #0x14]
;                     }
7009d880: e03b         	b	0x7009d8fa <CSL_bcdmaChanOpCfgChan+0xda> @ imm = #0x76
;                         regVal = CSL_REG32_RD( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG );
7009d882: 9809         	ldr	r0, [sp, #0x24]
7009d884: 6840         	ldr	r0, [r0, #0x4]
7009d886: 9907         	ldr	r1, [sp, #0x1c]
7009d888: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d88c: f012 f830    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0x12060
7009d890: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_BCCFG_CHAN_CFG_PAUSE_ON_ERR, pChanCfg->pauseOnError );
7009d892: 9804         	ldr	r0, [sp, #0x10]
7009d894: f020 4000    	bic	r0, r0, #0x80000000
7009d898: 9903         	ldr	r1, [sp, #0xc]
7009d89a: 6809         	ldr	r1, [r1]
7009d89c: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009d8a0: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_BCCFG_CHAN_CFG_BURST_SIZE, pChanCfg->burstSize );
7009d8a2: 9804         	ldr	r0, [sp, #0x10]
7009d8a4: 9903         	ldr	r1, [sp, #0xc]
7009d8a6: 6c49         	ldr	r1, [r1, #0x44]
7009d8a8: f361 208b    	bfi	r0, r1, #10, #2
7009d8ac: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG, regVal );
7009d8ae: 9809         	ldr	r0, [sp, #0x24]
7009d8b0: 6840         	ldr	r0, [r0, #0x4]
7009d8b2: 9907         	ldr	r1, [sp, #0x1c]
7009d8b4: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d8b8: 9904         	ldr	r1, [sp, #0x10]
7009d8ba: f7fe fca9    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x16ae
;                         regVal = CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009d8be: 9803         	ldr	r0, [sp, #0xc]
7009d8c0: 6a01         	ldr	r1, [r0, #0x20]
;                                  CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009d8c2: 6a80         	ldr	r0, [r0, #0x28]
7009d8c4: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009d8c8: f361 701e    	bfi	r0, r1, #28, #3
7009d8cc: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].PRI_CTRL, regVal );
7009d8ce: 9809         	ldr	r0, [sp, #0x24]
7009d8d0: 6840         	ldr	r0, [r0, #0x4]
7009d8d2: 9907         	ldr	r1, [sp, #0x1c]
7009d8d4: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d8d8: 3064         	adds	r0, #0x64
7009d8da: 9904         	ldr	r1, [sp, #0x10]
7009d8dc: f7fe fc98    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x16d0
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].TST_SCHED, CSL_FMK(BCDMA_BCCFG_CHAN_TST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009d8e0: 9809         	ldr	r0, [sp, #0x24]
7009d8e2: 6840         	ldr	r0, [r0, #0x4]
7009d8e4: 9907         	ldr	r1, [sp, #0x1c]
7009d8e6: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d8ea: 3080         	adds	r0, #0x80
7009d8ec: 9903         	ldr	r1, [sp, #0xc]
7009d8ee: 6ac9         	ldr	r1, [r1, #0x2c]
7009d8f0: f001 0103    	and	r1, r1, #0x3
7009d8f4: f7fe fc8c    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x16e8
7009d8f8: e7ff         	b	0x7009d8fa <CSL_bcdmaChanOpCfgChan+0xda> @ imm = #-0x2
;                 break;
7009d8fa: e0d7         	b	0x7009daac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0x1ae
;                     CSL_BcdmaTxChanCfg *pChanCfg = (CSL_BcdmaTxChanCfg *)pOpData;
7009d8fc: 9806         	ldr	r0, [sp, #0x18]
7009d8fe: 9002         	str	r0, [sp, #0x8]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||    /* Split-tx supports 32, and 64-byte bursts */
7009d900: 9802         	ldr	r0, [sp, #0x8]
7009d902: 6c40         	ldr	r0, [r0, #0x44]
7009d904: 2801         	cmp	r0, #0x1
7009d906: d80a         	bhi	0x7009d91e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #0x14
7009d908: e7ff         	b	0x7009d90a <CSL_bcdmaChanOpCfgChan+0xea> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009d90a: 9802         	ldr	r0, [sp, #0x8]
7009d90c: 6a00         	ldr	r0, [r0, #0x20]
7009d90e: 2807         	cmp	r0, #0x7
7009d910: d805         	bhi	0x7009d91e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #0xa
7009d912: e7ff         	b	0x7009d914 <CSL_bcdmaChanOpCfgChan+0xf4> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009d914: 9802         	ldr	r0, [sp, #0x8]
7009d916: 6ac0         	ldr	r0, [r0, #0x2c]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||    /* Split-tx supports 32, and 64-byte bursts */
7009d918: 2804         	cmp	r0, #0x4
7009d91a: d304         	blo	0x7009d926 <CSL_bcdmaChanOpCfgChan+0x106> @ imm = #0x8
7009d91c: e7ff         	b	0x7009d91e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #-0x2
7009d91e: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009d922: 9005         	str	r0, [sp, #0x14]
;                     }
7009d924: e057         	b	0x7009d9d6 <CSL_bcdmaChanOpCfgChan+0x1b6> @ imm = #0xae
;                         regVal = CSL_REG32_RD( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG );
7009d926: 9809         	ldr	r0, [sp, #0x24]
7009d928: 68c0         	ldr	r0, [r0, #0xc]
7009d92a: 9907         	ldr	r1, [sp, #0x1c]
7009d92c: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d930: f011 ffde    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0x11fbc
7009d934: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_PAUSE_ON_ERR, pChanCfg->pauseOnError);
7009d936: 9804         	ldr	r0, [sp, #0x10]
7009d938: f020 4000    	bic	r0, r0, #0x80000000
7009d93c: 9902         	ldr	r1, [sp, #0x8]
7009d93e: 6809         	ldr	r1, [r1]
7009d940: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009d944: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_BURST_SIZE, pChanCfg->burstSize );
7009d946: 9804         	ldr	r0, [sp, #0x10]
7009d948: 9902         	ldr	r1, [sp, #0x8]
7009d94a: 6c49         	ldr	r1, [r1, #0x44]
7009d94c: f361 208b    	bfi	r0, r1, #10, #2
7009d950: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_TDTYPE, pChanCfg->tdType );
7009d952: 9804         	ldr	r0, [sp, #0x10]
7009d954: 9902         	ldr	r1, [sp, #0x8]
7009d956: 6c09         	ldr	r1, [r1, #0x40]
7009d958: f361 2049    	bfi	r0, r1, #9, #1
7009d95c: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_NOTDPKT, pChanCfg->bNoTeardownCompletePkt );
7009d95e: 9804         	ldr	r0, [sp, #0x10]
7009d960: f420 7080    	bic	r0, r0, #0x100
7009d964: 9902         	ldr	r1, [sp, #0x8]
7009d966: f891 103c    	ldrb.w	r1, [r1, #0x3c]
7009d96a: f001 0101    	and	r1, r1, #0x1
7009d96e: ea40 2001    	orr.w	r0, r0, r1, lsl #8
7009d972: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG, regVal );
7009d974: 9809         	ldr	r0, [sp, #0x24]
7009d976: 68c0         	ldr	r0, [r0, #0xc]
7009d978: 9907         	ldr	r1, [sp, #0x1c]
7009d97a: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d97e: 9904         	ldr	r1, [sp, #0x10]
7009d980: f7fe fc46    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x1774
;                         regVal = CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009d984: 9802         	ldr	r0, [sp, #0x8]
7009d986: 6a01         	ldr	r1, [r0, #0x20]
;                                  CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009d988: 6a80         	ldr	r0, [r0, #0x28]
7009d98a: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009d98e: f361 701e    	bfi	r0, r1, #28, #3
7009d992: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TPRI_CTRL, regVal );
7009d994: 9809         	ldr	r0, [sp, #0x24]
7009d996: 68c0         	ldr	r0, [r0, #0xc]
7009d998: 9907         	ldr	r1, [sp, #0x1c]
7009d99a: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d99e: 3064         	adds	r0, #0x64
7009d9a0: 9904         	ldr	r1, [sp, #0x10]
7009d9a2: f7fe fc35    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x1796
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].THREAD, CSL_FMK(BCDMA_TXCCFG_CHAN_THREAD_ID, pChanCfg->threadId) );
7009d9a6: 9809         	ldr	r0, [sp, #0x24]
7009d9a8: 68c0         	ldr	r0, [r0, #0xc]
7009d9aa: 9907         	ldr	r1, [sp, #0x1c]
7009d9ac: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d9b0: 3068         	adds	r0, #0x68
7009d9b2: 9902         	ldr	r1, [sp, #0x8]
7009d9b4: f8b1 1048    	ldrh.w	r1, [r1, #0x48]
7009d9b8: f7fe fc2a    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x17ac
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TST_SCHED, CSL_FMK(BCDMA_TXCCFG_CHAN_TST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009d9bc: 9809         	ldr	r0, [sp, #0x24]
7009d9be: 68c0         	ldr	r0, [r0, #0xc]
7009d9c0: 9907         	ldr	r1, [sp, #0x1c]
7009d9c2: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d9c6: 3080         	adds	r0, #0x80
7009d9c8: 9902         	ldr	r1, [sp, #0x8]
7009d9ca: 6ac9         	ldr	r1, [r1, #0x2c]
7009d9cc: f001 0103    	and	r1, r1, #0x3
7009d9d0: f7fe fc1e    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x17c4
7009d9d4: e7ff         	b	0x7009d9d6 <CSL_bcdmaChanOpCfgChan+0x1b6> @ imm = #-0x2
;                 break;
7009d9d6: e069         	b	0x7009daac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0xd2
;                     CSL_BcdmaRxChanCfg *pChanCfg = (CSL_BcdmaRxChanCfg *)pOpData;
7009d9d8: 9806         	ldr	r0, [sp, #0x18]
7009d9da: 9001         	str	r0, [sp, #0x4]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||     /* Split-rx supports 32, and 64-byte bursts */
7009d9dc: 9801         	ldr	r0, [sp, #0x4]
7009d9de: 6bc0         	ldr	r0, [r0, #0x3c]
7009d9e0: 2801         	cmp	r0, #0x1
7009d9e2: d80a         	bhi	0x7009d9fa <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #0x14
7009d9e4: e7ff         	b	0x7009d9e6 <CSL_bcdmaChanOpCfgChan+0x1c6> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009d9e6: 9801         	ldr	r0, [sp, #0x4]
7009d9e8: 6980         	ldr	r0, [r0, #0x18]
7009d9ea: 2807         	cmp	r0, #0x7
7009d9ec: d805         	bhi	0x7009d9fa <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #0xa
7009d9ee: e7ff         	b	0x7009d9f0 <CSL_bcdmaChanOpCfgChan+0x1d0> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009d9f0: 9801         	ldr	r0, [sp, #0x4]
7009d9f2: 6b80         	ldr	r0, [r0, #0x38]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||     /* Split-rx supports 32, and 64-byte bursts */
7009d9f4: 2804         	cmp	r0, #0x4
7009d9f6: d304         	blo	0x7009da02 <CSL_bcdmaChanOpCfgChan+0x1e2> @ imm = #0x8
7009d9f8: e7ff         	b	0x7009d9fa <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #-0x2
7009d9fa: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009d9fe: 9005         	str	r0, [sp, #0x14]
;                     }
7009da00: e04f         	b	0x7009daa2 <CSL_bcdmaChanOpCfgChan+0x282> @ imm = #0x9e
;                         regVal = CSL_REG32_RD( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG );
7009da02: 9809         	ldr	r0, [sp, #0x24]
7009da04: 6940         	ldr	r0, [r0, #0x14]
7009da06: 9907         	ldr	r1, [sp, #0x1c]
7009da08: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009da0c: f011 ff70    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0x11ee0
7009da10: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_PAUSE_ON_ERR, pChanCfg->pauseOnError);
7009da12: 9804         	ldr	r0, [sp, #0x10]
7009da14: f020 4000    	bic	r0, r0, #0x80000000
7009da18: 9901         	ldr	r1, [sp, #0x4]
7009da1a: 6809         	ldr	r1, [r1]
7009da1c: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009da20: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_BURST_SIZE, pChanCfg->burstSize );
7009da22: 9804         	ldr	r0, [sp, #0x10]
7009da24: 9901         	ldr	r1, [sp, #0x4]
7009da26: 6bc9         	ldr	r1, [r1, #0x3c]
7009da28: f361 208b    	bfi	r0, r1, #10, #2
7009da2c: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_IGNORE_LONG, pChanCfg->bIgnoreLongPkts ? (uint32_t)1U : (uint32_t)0U );
7009da2e: 9804         	ldr	r0, [sp, #0x10]
7009da30: f420 4080    	bic	r0, r0, #0x4000
7009da34: 9901         	ldr	r1, [sp, #0x4]
7009da36: f891 1035    	ldrb.w	r1, [r1, #0x35]
7009da3a: f361 308e    	bfi	r0, r1, #14, #1
7009da3e: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG, regVal );
7009da40: 9809         	ldr	r0, [sp, #0x24]
7009da42: 6940         	ldr	r0, [r0, #0x14]
7009da44: 9907         	ldr	r1, [sp, #0x1c]
7009da46: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009da4a: 9904         	ldr	r1, [sp, #0x10]
7009da4c: f7fe fbe0    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x1840
;                         regVal = CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009da50: 9801         	ldr	r0, [sp, #0x4]
7009da52: 6981         	ldr	r1, [r0, #0x18]
;                                  CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009da54: 6a00         	ldr	r0, [r0, #0x20]
7009da56: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009da5a: f361 701e    	bfi	r0, r1, #28, #3
7009da5e: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RPRI_CTRL, regVal );
7009da60: 9809         	ldr	r0, [sp, #0x24]
7009da62: 6940         	ldr	r0, [r0, #0x14]
7009da64: 9907         	ldr	r1, [sp, #0x1c]
7009da66: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009da6a: 3064         	adds	r0, #0x64
7009da6c: 9904         	ldr	r1, [sp, #0x10]
7009da6e: f7fe fbcf    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x1862
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].THREAD, CSL_FMK(BCDMA_RXCCFG_CHAN_THREAD_ID, pChanCfg->threadId) );
7009da72: 9809         	ldr	r0, [sp, #0x24]
7009da74: 6940         	ldr	r0, [r0, #0x14]
7009da76: 9907         	ldr	r1, [sp, #0x1c]
7009da78: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009da7c: 3068         	adds	r0, #0x68
7009da7e: 9901         	ldr	r1, [sp, #0x4]
7009da80: f8b1 1040    	ldrh.w	r1, [r1, #0x40]
7009da84: f7fe fbc4    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x1878
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RST_SCHED, CSL_FMK(BCDMA_RXCCFG_CHAN_RST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009da88: 9809         	ldr	r0, [sp, #0x24]
7009da8a: 6940         	ldr	r0, [r0, #0x14]
7009da8c: 9907         	ldr	r1, [sp, #0x1c]
7009da8e: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009da92: 3080         	adds	r0, #0x80
7009da94: 9901         	ldr	r1, [sp, #0x4]
7009da96: 6b89         	ldr	r1, [r1, #0x38]
7009da98: f001 0103    	and	r1, r1, #0x3
7009da9c: f7fe fbb8    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x1890
7009daa0: e7ff         	b	0x7009daa2 <CSL_bcdmaChanOpCfgChan+0x282> @ imm = #-0x2
;                 break;
7009daa2: e003         	b	0x7009daac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0x6
7009daa4: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
7009daa8: 9005         	str	r0, [sp, #0x14]
;                 break;
7009daaa: e7ff         	b	0x7009daac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #-0x2
7009daac: e7ff         	b	0x7009daae <CSL_bcdmaChanOpCfgChan+0x28e> @ imm = #-0x2
;     return retVal;
7009daae: 9805         	ldr	r0, [sp, #0x14]
7009dab0: b00a         	add	sp, #0x28
7009dab2: bd80         	pop	{r7, pc}
		...

7009dac0 <TimerP_setup>:
; {
7009dac0: b510         	push	{r4, lr}
7009dac2: b096         	sub	sp, #0x58
7009dac4: 9015         	str	r0, [sp, #0x54]
7009dac6: 9114         	str	r1, [sp, #0x50]
;     DebugP_assert( baseAddr!=0U);
7009dac8: 9815         	ldr	r0, [sp, #0x54]
7009daca: 2800         	cmp	r0, #0x0
7009dacc: bf18         	it	ne
7009dace: 2001         	movne	r0, #0x1
7009dad0: f641 51b6    	movw	r1, #0x1db6
7009dad4: f2c7 010b    	movt	r1, #0x700b
7009dad8: 466a         	mov	r2, sp
7009dada: 6011         	str	r1, [r2]
7009dadc: f641 2169    	movw	r1, #0x1a69
7009dae0: f2c7 010b    	movt	r1, #0x700b
7009dae4: 9106         	str	r1, [sp, #0x18]
7009dae6: f641 52c3    	movw	r2, #0x1dc3
7009daea: f2c7 020b    	movt	r2, #0x700b
7009daee: 9207         	str	r2, [sp, #0x1c]
7009daf0: 2342         	movs	r3, #0x42
7009daf2: f00c ff9d    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xcf3a
7009daf6: 9906         	ldr	r1, [sp, #0x18]
7009daf8: 9a07         	ldr	r2, [sp, #0x1c]
;     DebugP_assert( params->inputPreScaler != 0U);
7009dafa: 9814         	ldr	r0, [sp, #0x50]
7009dafc: 6800         	ldr	r0, [r0]
7009dafe: 2800         	cmp	r0, #0x0
7009db00: bf18         	it	ne
7009db02: 2001         	movne	r0, #0x1
7009db04: f641 2387    	movw	r3, #0x1a87
7009db08: f2c7 030b    	movt	r3, #0x700b
7009db0c: 46ec         	mov	r12, sp
7009db0e: f8cc 3000    	str.w	r3, [r12]
7009db12: 2343         	movs	r3, #0x43
7009db14: f00c ff8c    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xcf18
7009db18: 9906         	ldr	r1, [sp, #0x18]
7009db1a: 9a07         	ldr	r2, [sp, #0x1c]
;     DebugP_assert( params->inputClkHz != 0U);
7009db1c: 9814         	ldr	r0, [sp, #0x50]
7009db1e: 6840         	ldr	r0, [r0, #0x4]
7009db20: 2800         	cmp	r0, #0x0
7009db22: bf18         	it	ne
7009db24: 2001         	movne	r0, #0x1
7009db26: f641 339e    	movw	r3, #0x1b9e
7009db2a: f2c7 030b    	movt	r3, #0x700b
7009db2e: 46ec         	mov	r12, sp
7009db30: f8cc 3000    	str.w	r3, [r12]
7009db34: 2344         	movs	r3, #0x44
7009db36: f00c ff7b    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xcef6
;     DebugP_assert(( params->periodInUsec != 0U) || (params->periodInNsec != 0U) );
7009db3a: 9814         	ldr	r0, [sp, #0x50]
7009db3c: 6881         	ldr	r1, [r0, #0x8]
7009db3e: 2001         	movs	r0, #0x1
7009db40: 9008         	str	r0, [sp, #0x20]
7009db42: b939         	cbnz	r1, 0x7009db54 <TimerP_setup+0x94> @ imm = #0xe
7009db44: e7ff         	b	0x7009db46 <TimerP_setup+0x86> @ imm = #-0x2
7009db46: 9814         	ldr	r0, [sp, #0x50]
7009db48: 68c0         	ldr	r0, [r0, #0xc]
7009db4a: 2800         	cmp	r0, #0x0
7009db4c: bf18         	it	ne
7009db4e: 2001         	movne	r0, #0x1
7009db50: 9008         	str	r0, [sp, #0x20]
7009db52: e7ff         	b	0x7009db54 <TimerP_setup+0x94> @ imm = #-0x2
7009db54: 9808         	ldr	r0, [sp, #0x20]
;     DebugP_assert(( params->periodInUsec != 0U) || (params->periodInNsec != 0U) );
7009db56: f000 0001    	and	r0, r0, #0x1
7009db5a: f241 6170    	movw	r1, #0x1670
7009db5e: f2c7 010b    	movt	r1, #0x700b
7009db62: 466a         	mov	r2, sp
7009db64: 6011         	str	r1, [r2]
7009db66: f641 2169    	movw	r1, #0x1a69
7009db6a: f2c7 010b    	movt	r1, #0x700b
7009db6e: 9103         	str	r1, [sp, #0xc]
7009db70: f641 52c3    	movw	r2, #0x1dc3
7009db74: f2c7 020b    	movt	r2, #0x700b
7009db78: 9204         	str	r2, [sp, #0x10]
7009db7a: 2345         	movs	r3, #0x45
7009db7c: f00c ff58    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xceb0
7009db80: 9903         	ldr	r1, [sp, #0xc]
7009db82: 9a04         	ldr	r2, [sp, #0x10]
;     DebugP_assert( params->inputPreScaler <= 256U);
7009db84: 9814         	ldr	r0, [sp, #0x50]
7009db86: 6803         	ldr	r3, [r0]
7009db88: 2000         	movs	r0, #0x0
7009db8a: 9005         	str	r0, [sp, #0x14]
7009db8c: f5b3 7f80    	cmp.w	r3, #0x100
7009db90: bf98         	it	ls
7009db92: 2001         	movls	r0, #0x1
7009db94: f641 232b    	movw	r3, #0x1a2b
7009db98: f2c7 030b    	movt	r3, #0x700b
7009db9c: 46ec         	mov	r12, sp
7009db9e: f8cc 3000    	str.w	r3, [r12]
7009dba2: 2347         	movs	r3, #0x47
7009dba4: f00c ff44    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xce88
7009dba8: 9903         	ldr	r1, [sp, #0xc]
7009dbaa: 9a04         	ldr	r2, [sp, #0x10]
;     DebugP_assert( (params->inputClkHz % params->inputPreScaler) == 0U);
7009dbac: 9814         	ldr	r0, [sp, #0x50]
7009dbae: 6803         	ldr	r3, [r0]
7009dbb0: f8d0 c004    	ldr.w	r12, [r0, #0x4]
7009dbb4: fbbc f0f3    	udiv	r0, r12, r3
7009dbb8: fb00 c013    	mls	r0, r0, r3, r12
7009dbbc: fab0 f080    	clz	r0, r0
7009dbc0: 0940         	lsrs	r0, r0, #0x5
7009dbc2: f241 7352    	movw	r3, #0x1752
7009dbc6: f2c7 030b    	movt	r3, #0x700b
7009dbca: 46ec         	mov	r12, sp
7009dbcc: f8cc 3000    	str.w	r3, [r12]
7009dbd0: 2349         	movs	r3, #0x49
7009dbd2: f00c ff2d    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xce5a
;     TimerP_stop(baseAddr);
7009dbd6: 9815         	ldr	r0, [sp, #0x54]
7009dbd8: f011 fc1a    	bl	0x700af410 <TimerP_stop> @ imm = #0x11834
;     TimerP_clearOverflowInt(baseAddr);
7009dbdc: 9815         	ldr	r0, [sp, #0x54]
7009dbde: f010 fec7    	bl	0x700ae970 <TimerP_clearOverflowInt> @ imm = #0x10d8e
7009dbe2: 9905         	ldr	r1, [sp, #0x14]
;     timeInNsec = (uint64_t)params->periodInNsec;
7009dbe4: 9814         	ldr	r0, [sp, #0x50]
7009dbe6: 68c0         	ldr	r0, [r0, #0xc]
7009dbe8: 910f         	str	r1, [sp, #0x3c]
7009dbea: 900e         	str	r0, [sp, #0x38]
;     if(timeInNsec == 0U)
7009dbec: 980e         	ldr	r0, [sp, #0x38]
7009dbee: 990f         	ldr	r1, [sp, #0x3c]
7009dbf0: 4308         	orrs	r0, r1
7009dbf2: b948         	cbnz	r0, 0x7009dc08 <TimerP_setup+0x148> @ imm = #0x12
7009dbf4: e7ff         	b	0x7009dbf6 <TimerP_setup+0x136> @ imm = #-0x2
;         timeInNsec = (uint64_t)params->periodInUsec*1000U;
7009dbf6: 9814         	ldr	r0, [sp, #0x50]
7009dbf8: 6880         	ldr	r0, [r0, #0x8]
7009dbfa: f44f 717a    	mov.w	r1, #0x3e8
7009dbfe: fba0 0101    	umull	r0, r1, r0, r1
7009dc02: 910f         	str	r1, [sp, #0x3c]
7009dc04: 900e         	str	r0, [sp, #0x38]
;     }
7009dc06: e7ff         	b	0x7009dc08 <TimerP_setup+0x148> @ imm = #-0x2
;     inputClkHz = (uint64_t)params->inputClkHz / (uint64_t)params->inputPreScaler;
7009dc08: 9814         	ldr	r0, [sp, #0x50]
7009dc0a: 6802         	ldr	r2, [r0]
7009dc0c: 6840         	ldr	r0, [r0, #0x4]
7009dc0e: 2300         	movs	r3, #0x0
7009dc10: 9302         	str	r3, [sp, #0x8]
7009dc12: 4619         	mov	r1, r3
7009dc14: f011 e98e    	blx	0x700aef34 <__aeabi_uldivmod> @ imm = #0x1131c
7009dc18: 9b02         	ldr	r3, [sp, #0x8]
7009dc1a: 910d         	str	r1, [sp, #0x34]
7009dc1c: 900c         	str	r0, [sp, #0x30]
;     timerCycles =  ( inputClkHz * timeInNsec ) / 1000000000U;
7009dc1e: f8dd c030    	ldr.w	r12, [sp, #0x30]
7009dc22: 990d         	ldr	r1, [sp, #0x34]
7009dc24: 9a0e         	ldr	r2, [sp, #0x38]
7009dc26: f8dd e03c    	ldr.w	lr, [sp, #0x3c]
7009dc2a: fbac 0402    	umull	r0, r4, r12, r2
7009dc2e: fb0c 4c0e    	mla	r12, r12, lr, r4
7009dc32: fb01 c102    	mla	r1, r1, r2, r12
7009dc36: f64c 2200    	movw	r2, #0xca00
7009dc3a: f6c3 329a    	movt	r2, #0x3b9a
7009dc3e: f011 e97a    	blx	0x700aef34 <__aeabi_uldivmod> @ imm = #0x112f4
7009dc42: 4602         	mov	r2, r0
7009dc44: 9802         	ldr	r0, [sp, #0x8]
7009dc46: 9201         	str	r2, [sp, #0x4]
7009dc48: 460a         	mov	r2, r1
7009dc4a: 9901         	ldr	r1, [sp, #0x4]
7009dc4c: 920b         	str	r2, [sp, #0x2c]
7009dc4e: 910a         	str	r1, [sp, #0x28]
;     DebugP_assert( timerCycles < 0xFFFFFFFFU );
7009dc50: 9a0a         	ldr	r2, [sp, #0x28]
7009dc52: 990b         	ldr	r1, [sp, #0x2c]
7009dc54: f1b2 32ff    	subs.w	r2, r2, #0xffffffff
7009dc58: f171 0100    	sbcs	r1, r1, #0x0
7009dc5c: bf38         	it	lo
7009dc5e: 2001         	movlo	r0, #0x1
7009dc60: f641 3184    	movw	r1, #0x1b84
7009dc64: f2c7 010b    	movt	r1, #0x700b
7009dc68: 466a         	mov	r2, sp
7009dc6a: 6011         	str	r1, [r2]
7009dc6c: f641 2169    	movw	r1, #0x1a69
7009dc70: f2c7 010b    	movt	r1, #0x700b
7009dc74: f641 52c3    	movw	r2, #0x1dc3
7009dc78: f2c7 020b    	movt	r2, #0x700b
7009dc7c: 2359         	movs	r3, #0x59
7009dc7e: f00c fed7    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xcdae
7009dc82: 9802         	ldr	r0, [sp, #0x8]
;     countVal = 0xFFFFFFFFu - (timerCycles - 1U);
7009dc84: 990a         	ldr	r1, [sp, #0x28]
7009dc86: 4249         	rsbs	r1, r1, #0
7009dc88: 9111         	str	r1, [sp, #0x44]
;     reloadVal = 0;
7009dc8a: 9010         	str	r0, [sp, #0x40]
;     ctrlVal = 0;
7009dc8c: 9012         	str	r0, [sp, #0x48]
;     if(params->inputPreScaler>1U)
7009dc8e: 9814         	ldr	r0, [sp, #0x50]
7009dc90: 6800         	ldr	r0, [r0]
7009dc92: 2802         	cmp	r0, #0x2
7009dc94: d320         	blo	0x7009dcd8 <TimerP_setup+0x218> @ imm = #0x40
7009dc96: e7ff         	b	0x7009dc98 <TimerP_setup+0x1d8> @ imm = #-0x2
7009dc98: 2008         	movs	r0, #0x8
;         for(preScaleVal=8U; preScaleVal>=1U; preScaleVal--)
7009dc9a: 9009         	str	r0, [sp, #0x24]
7009dc9c: e7ff         	b	0x7009dc9e <TimerP_setup+0x1de> @ imm = #-0x2
7009dc9e: 9809         	ldr	r0, [sp, #0x24]
7009dca0: b168         	cbz	r0, 0x7009dcbe <TimerP_setup+0x1fe> @ imm = #0x1a
7009dca2: e7ff         	b	0x7009dca4 <TimerP_setup+0x1e4> @ imm = #-0x2
;             if( (params->inputPreScaler & (0x1U << preScaleVal)) != 0U )
7009dca4: 9814         	ldr	r0, [sp, #0x50]
7009dca6: 6800         	ldr	r0, [r0]
7009dca8: 9909         	ldr	r1, [sp, #0x24]
7009dcaa: 40c8         	lsrs	r0, r1
7009dcac: 07c0         	lsls	r0, r0, #0x1f
7009dcae: b108         	cbz	r0, 0x7009dcb4 <TimerP_setup+0x1f4> @ imm = #0x2
7009dcb0: e7ff         	b	0x7009dcb2 <TimerP_setup+0x1f2> @ imm = #-0x2
;                 break;
7009dcb2: e004         	b	0x7009dcbe <TimerP_setup+0x1fe> @ imm = #0x8
;         }
7009dcb4: e7ff         	b	0x7009dcb6 <TimerP_setup+0x1f6> @ imm = #-0x2
;         for(preScaleVal=8U; preScaleVal>=1U; preScaleVal--)
7009dcb6: 9809         	ldr	r0, [sp, #0x24]
7009dcb8: 3801         	subs	r0, #0x1
7009dcba: 9009         	str	r0, [sp, #0x24]
7009dcbc: e7ef         	b	0x7009dc9e <TimerP_setup+0x1de> @ imm = #-0x22
;         ctrlVal |= (0x1U << 5);
7009dcbe: 9812         	ldr	r0, [sp, #0x48]
7009dcc0: f040 0020    	orr	r0, r0, #0x20
7009dcc4: 9012         	str	r0, [sp, #0x48]
;         ctrlVal |= ( ((preScaleVal - 1U) & 0x7U) << 2);
7009dcc6: 9809         	ldr	r0, [sp, #0x24]
7009dcc8: 3801         	subs	r0, #0x1
7009dcca: f000 0107    	and	r1, r0, #0x7
7009dcce: 9812         	ldr	r0, [sp, #0x48]
7009dcd0: ea40 0081    	orr.w	r0, r0, r1, lsl #2
7009dcd4: 9012         	str	r0, [sp, #0x48]
;     }
7009dcd6: e7ff         	b	0x7009dcd8 <TimerP_setup+0x218> @ imm = #-0x2
;     if(params->oneshotMode==0U)
7009dcd8: 9814         	ldr	r0, [sp, #0x50]
7009dcda: 6900         	ldr	r0, [r0, #0x10]
7009dcdc: b938         	cbnz	r0, 0x7009dcee <TimerP_setup+0x22e> @ imm = #0xe
7009dcde: e7ff         	b	0x7009dce0 <TimerP_setup+0x220> @ imm = #-0x2
;         ctrlVal |= (0x1U << 1);
7009dce0: 9812         	ldr	r0, [sp, #0x48]
7009dce2: f040 0002    	orr	r0, r0, #0x2
7009dce6: 9012         	str	r0, [sp, #0x48]
;         reloadVal = countVal;
7009dce8: 9811         	ldr	r0, [sp, #0x44]
7009dcea: 9010         	str	r0, [sp, #0x40]
;     }
7009dcec: e7ff         	b	0x7009dcee <TimerP_setup+0x22e> @ imm = #-0x2
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TCLR);
7009dcee: 9815         	ldr	r0, [sp, #0x54]
7009dcf0: 3038         	adds	r0, #0x38
7009dcf2: 9013         	str	r0, [sp, #0x4c]
;     *addr = ctrlVal;
7009dcf4: 9812         	ldr	r0, [sp, #0x48]
7009dcf6: 9913         	ldr	r1, [sp, #0x4c]
7009dcf8: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TCRR);
7009dcfa: 9815         	ldr	r0, [sp, #0x54]
7009dcfc: 303c         	adds	r0, #0x3c
7009dcfe: 9013         	str	r0, [sp, #0x4c]
;     *addr = countVal;
7009dd00: 9811         	ldr	r0, [sp, #0x44]
7009dd02: 9913         	ldr	r1, [sp, #0x4c]
7009dd04: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TLDR);
7009dd06: 9815         	ldr	r0, [sp, #0x54]
7009dd08: 3040         	adds	r0, #0x40
7009dd0a: 9013         	str	r0, [sp, #0x4c]
;     *addr = reloadVal;
7009dd0c: 9810         	ldr	r0, [sp, #0x40]
7009dd0e: 9913         	ldr	r1, [sp, #0x4c]
7009dd10: 6008         	str	r0, [r1]
;     if((params->enableOverflowInt) != 0U)
7009dd12: 9814         	ldr	r0, [sp, #0x50]
7009dd14: 6940         	ldr	r0, [r0, #0x14]
7009dd16: b138         	cbz	r0, 0x7009dd28 <TimerP_setup+0x268> @ imm = #0xe
7009dd18: e7ff         	b	0x7009dd1a <TimerP_setup+0x25a> @ imm = #-0x2
;         addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_INT_ENABLE);
7009dd1a: 9815         	ldr	r0, [sp, #0x54]
7009dd1c: 302c         	adds	r0, #0x2c
7009dd1e: 9013         	str	r0, [sp, #0x4c]
;         *addr = (0x1U << TIMER_OVF_INT_SHIFT);
7009dd20: 9913         	ldr	r1, [sp, #0x4c]
7009dd22: 2002         	movs	r0, #0x2
7009dd24: 6008         	str	r0, [r1]
;     }
7009dd26: e006         	b	0x7009dd36 <TimerP_setup+0x276> @ imm = #0xc
;         addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_INT_DISABLE);
7009dd28: 9815         	ldr	r0, [sp, #0x54]
7009dd2a: 3030         	adds	r0, #0x30
7009dd2c: 9013         	str	r0, [sp, #0x4c]
;         *addr = (0x1U << TIMER_OVF_INT_SHIFT);
7009dd2e: 9913         	ldr	r1, [sp, #0x4c]
7009dd30: 2002         	movs	r0, #0x2
7009dd32: 6008         	str	r0, [r1]
7009dd34: e7ff         	b	0x7009dd36 <TimerP_setup+0x276> @ imm = #-0x2
; }
7009dd36: b016         	add	sp, #0x58
7009dd38: bd10         	pop	{r4, pc}
7009dd3a: 0000         	movs	r0, r0
7009dd3c: 0000         	movs	r0, r0
7009dd3e: 0000         	movs	r0, r0

7009dd40 <Udma_chConfigRx>:
; {
7009dd40: b580         	push	{r7, lr}
7009dd42: b09c         	sub	sp, #0x70
7009dd44: 901b         	str	r0, [sp, #0x6c]
7009dd46: 911a         	str	r1, [sp, #0x68]
7009dd48: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009dd4a: 9019         	str	r0, [sp, #0x64]
;     Udma_ChHandleInt        chHandleInt = (Udma_ChHandleInt) chHandle;
7009dd4c: 981b         	ldr	r0, [sp, #0x6c]
7009dd4e: 9017         	str	r0, [sp, #0x5c]
;     if((NULL_PTR == chHandleInt) ||
7009dd50: 9817         	ldr	r0, [sp, #0x5c]
7009dd52: b188         	cbz	r0, 0x7009dd78 <Udma_chConfigRx+0x38> @ imm = #0x22
7009dd54: e7ff         	b	0x7009dd56 <Udma_chConfigRx+0x16> @ imm = #-0x2
;         (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
7009dd56: 9817         	ldr	r0, [sp, #0x5c]
7009dd58: f8d0 0244    	ldr.w	r0, [r0, #0x244]
7009dd5c: f64a 31cd    	movw	r1, #0xabcd
7009dd60: f6ca 31dc    	movt	r1, #0xabdc
7009dd64: 4288         	cmp	r0, r1
7009dd66: d107         	bne	0x7009dd78 <Udma_chConfigRx+0x38> @ imm = #0xe
7009dd68: e7ff         	b	0x7009dd6a <Udma_chConfigRx+0x2a> @ imm = #-0x2
;         ((chHandleInt->chType & UDMA_CH_FLAG_RX) != UDMA_CH_FLAG_RX))
7009dd6a: 9817         	ldr	r0, [sp, #0x5c]
7009dd6c: 6800         	ldr	r0, [r0]
7009dd6e: f000 0002    	and	r0, r0, #0x2
;     if((NULL_PTR == chHandleInt) ||
7009dd72: 2802         	cmp	r0, #0x2
7009dd74: d004         	beq	0x7009dd80 <Udma_chConfigRx+0x40> @ imm = #0x8
7009dd76: e7ff         	b	0x7009dd78 <Udma_chConfigRx+0x38> @ imm = #-0x2
7009dd78: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009dd7c: 9019         	str	r0, [sp, #0x64]
;     }
7009dd7e: e7ff         	b	0x7009dd80 <Udma_chConfigRx+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dd80: 9819         	ldr	r0, [sp, #0x64]
7009dd82: b9a8         	cbnz	r0, 0x7009ddb0 <Udma_chConfigRx+0x70> @ imm = #0x2a
7009dd84: e7ff         	b	0x7009dd86 <Udma_chConfigRx+0x46> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
7009dd86: 9817         	ldr	r0, [sp, #0x5c]
7009dd88: 6e80         	ldr	r0, [r0, #0x68]
7009dd8a: 9018         	str	r0, [sp, #0x60]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009dd8c: 9818         	ldr	r0, [sp, #0x60]
7009dd8e: b150         	cbz	r0, 0x7009dda6 <Udma_chConfigRx+0x66> @ imm = #0x14
7009dd90: e7ff         	b	0x7009dd92 <Udma_chConfigRx+0x52> @ imm = #-0x2
7009dd92: 9818         	ldr	r0, [sp, #0x60]
7009dd94: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009dd98: f64a 31cd    	movw	r1, #0xabcd
7009dd9c: f6ca 31dc    	movt	r1, #0xabdc
7009dda0: 4288         	cmp	r0, r1
7009dda2: d004         	beq	0x7009ddae <Udma_chConfigRx+0x6e> @ imm = #0x8
7009dda4: e7ff         	b	0x7009dda6 <Udma_chConfigRx+0x66> @ imm = #-0x2
7009dda6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009ddaa: 9019         	str	r0, [sp, #0x64]
;         }
7009ddac: e7ff         	b	0x7009ddae <Udma_chConfigRx+0x6e> @ imm = #-0x2
;     }
7009ddae: e7ff         	b	0x7009ddb0 <Udma_chConfigRx+0x70> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ddb0: 9819         	ldr	r0, [sp, #0x64]
7009ddb2: 2800         	cmp	r0, #0x0
7009ddb4: f040 80f1    	bne.w	0x7009df9a <Udma_chConfigRx+0x25a> @ imm = #0x1e2
7009ddb8: e7ff         	b	0x7009ddba <Udma_chConfigRx+0x7a> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
7009ddba: 9818         	ldr	r0, [sp, #0x60]
7009ddbc: 6800         	ldr	r0, [r0]
7009ddbe: 2801         	cmp	r0, #0x1
7009ddc0: d107         	bne	0x7009ddd2 <Udma_chConfigRx+0x92> @ imm = #0xe
7009ddc2: e7ff         	b	0x7009ddc4 <Udma_chConfigRx+0x84> @ imm = #-0x2
;             ((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
7009ddc4: 9817         	ldr	r0, [sp, #0x5c]
;         if ((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
7009ddc6: 7800         	ldrb	r0, [r0]
7009ddc8: 0740         	lsls	r0, r0, #0x1d
7009ddca: 2800         	cmp	r0, #0x0
7009ddcc: d501         	bpl	0x7009ddd2 <Udma_chConfigRx+0x92> @ imm = #0x2
7009ddce: e7ff         	b	0x7009ddd0 <Udma_chConfigRx+0x90> @ imm = #-0x2
;         }
7009ddd0: e0e2         	b	0x7009df98 <Udma_chConfigRx+0x258> @ imm = #0x1c4
7009ddd2: f645 70ff    	movw	r0, #0x5fff
;             rmUdmaRxReq.valid_params        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERR_VALID |
7009ddd6: 9010         	str	r0, [sp, #0x40]
;             rmUdmaRxReq.nav_id              = drvHandle->devIdUdma;
7009ddd8: 9818         	ldr	r0, [sp, #0x60]
7009ddda: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009ddde: f8ad 0044    	strh.w	r0, [sp, #0x44]
;             rmUdmaRxReq.index               = (uint16_t)chHandleInt->rxChNum;
7009dde2: 9817         	ldr	r0, [sp, #0x5c]
7009dde4: 6f00         	ldr	r0, [r0, #0x70]
7009dde6: f8ad 0046    	strh.w	r0, [sp, #0x46]
;             rmUdmaRxReq.rx_pause_on_err     = rxPrms->pauseOnError;
7009ddea: 981a         	ldr	r0, [sp, #0x68]
7009ddec: 7800         	ldrb	r0, [r0]
7009ddee: f88d 0054    	strb.w	r0, [sp, #0x54]
;             rmUdmaRxReq.rx_atype            = rxPrms->addrType;
7009ddf2: 981a         	ldr	r0, [sp, #0x68]
7009ddf4: 7840         	ldrb	r0, [r0, #0x1]
7009ddf6: f88d 0055    	strb.w	r0, [sp, #0x55]
;             rmUdmaRxReq.rx_chan_type        = rxPrms->chanType;
7009ddfa: 981a         	ldr	r0, [sp, #0x68]
7009ddfc: 7880         	ldrb	r0, [r0, #0x2]
7009ddfe: f88d 0056    	strb.w	r0, [sp, #0x56]
;             rmUdmaRxReq.rx_fetch_size       = rxPrms->fetchWordSize;
7009de02: 981a         	ldr	r0, [sp, #0x68]
7009de04: 8880         	ldrh	r0, [r0, #0x4]
7009de06: f8ad 0048    	strh.w	r0, [sp, #0x48]
;             rmUdmaRxReq.rx_priority         = rxPrms->busPriority;
7009de0a: 981a         	ldr	r0, [sp, #0x68]
7009de0c: 7980         	ldrb	r0, [r0, #0x6]
7009de0e: f88d 004c    	strb.w	r0, [sp, #0x4c]
;             rmUdmaRxReq.rx_qos              = rxPrms->busQos;
7009de12: 981a         	ldr	r0, [sp, #0x68]
7009de14: 79c0         	ldrb	r0, [r0, #0x7]
7009de16: f88d 004d    	strb.w	r0, [sp, #0x4d]
;             rmUdmaRxReq.rx_orderid          = rxPrms->busOrderId;
7009de1a: 981a         	ldr	r0, [sp, #0x68]
7009de1c: 7a00         	ldrb	r0, [r0, #0x8]
7009de1e: f88d 004e    	strb.w	r0, [sp, #0x4e]
;             rmUdmaRxReq.rx_sched_priority   = rxPrms->dmaPriority;
7009de22: 981a         	ldr	r0, [sp, #0x68]
7009de24: 7a40         	ldrb	r0, [r0, #0x9]
7009de26: f88d 004f    	strb.w	r0, [sp, #0x4f]
;             rmUdmaRxReq.flowid_start        = rxPrms->flowIdFwRangeStart;
7009de2a: 981a         	ldr	r0, [sp, #0x68]
7009de2c: 8940         	ldrh	r0, [r0, #0xa]
7009de2e: f8ad 0050    	strh.w	r0, [sp, #0x50]
;             rmUdmaRxReq.flowid_cnt          = rxPrms->flowIdFwRangeCnt;
7009de32: 981a         	ldr	r0, [sp, #0x68]
7009de34: 8980         	ldrh	r0, [r0, #0xc]
7009de36: f8ad 0052    	strh.w	r0, [sp, #0x52]
;             rmUdmaRxReq.rx_ignore_short     = rxPrms->ignoreShortPkts;
7009de3a: 981a         	ldr	r0, [sp, #0x68]
7009de3c: 7c80         	ldrb	r0, [r0, #0x12]
7009de3e: f88d 0057    	strb.w	r0, [sp, #0x57]
;             rmUdmaRxReq.rx_ignore_long      = rxPrms->ignoreLongPkts;
7009de42: 981a         	ldr	r0, [sp, #0x68]
7009de44: 7cc0         	ldrb	r0, [r0, #0x13]
7009de46: f88d 0058    	strb.w	r0, [sp, #0x58]
;             rmUdmaRxReq.rx_burst_size       = rxPrms->burstSize;
7009de4a: 981a         	ldr	r0, [sp, #0x68]
7009de4c: 7e00         	ldrb	r0, [r0, #0x18]
7009de4e: f88d 0059    	strb.w	r0, [sp, #0x59]
;             if(NULL_PTR != chHandleInt->tdCqRing)
7009de52: 9817         	ldr	r0, [sp, #0x5c]
7009de54: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009de58: b138         	cbz	r0, 0x7009de6a <Udma_chConfigRx+0x12a> @ imm = #0xe
7009de5a: e7ff         	b	0x7009de5c <Udma_chConfigRx+0x11c> @ imm = #-0x2
;                 rmUdmaRxReq.rxcq_qnum          = chHandleInt->tdCqRing->ringNum;
7009de5c: 9817         	ldr	r0, [sp, #0x5c]
7009de5e: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009de62: 8880         	ldrh	r0, [r0, #0x4]
7009de64: f8ad 004a    	strh.w	r0, [sp, #0x4a]
;             }
7009de68: e004         	b	0x7009de74 <Udma_chConfigRx+0x134> @ imm = #0x8
7009de6a: f64f 70ff    	movw	r0, #0xffff
;                 rmUdmaRxReq.rxcq_qnum          = UDMA_RING_INVALID;
7009de6e: f8ad 004a    	strh.w	r0, [sp, #0x4a]
7009de72: e7ff         	b	0x7009de74 <Udma_chConfigRx+0x134> @ imm = #-0x2
7009de74: a80e         	add	r0, sp, #0x38
7009de76: a90c         	add	r1, sp, #0x30
7009de78: f04f 32ff    	mov.w	r2, #0xffffffff
;             retVal = Sciclient_rmUdmapRxChCfg(
7009de7c: f00e fca8    	bl	0x700ac7d0 <Sciclient_rmUdmapRxChCfg> @ imm = #0xe950
7009de80: 9019         	str	r0, [sp, #0x64]
;             if(CSL_PASS != retVal)
7009de82: 9819         	ldr	r0, [sp, #0x64]
7009de84: b108         	cbz	r0, 0x7009de8a <Udma_chConfigRx+0x14a> @ imm = #0x2
7009de86: e7ff         	b	0x7009de88 <Udma_chConfigRx+0x148> @ imm = #-0x2
;             }
7009de88: e7ff         	b	0x7009de8a <Udma_chConfigRx+0x14a> @ imm = #-0x2
;             if((((chHandleInt->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA) ||
7009de8a: 9817         	ldr	r0, [sp, #0x5c]
7009de8c: 6800         	ldr	r0, [r0]
7009de8e: f000 0008    	and	r0, r0, #0x8
7009de92: 2808         	cmp	r0, #0x8
7009de94: d006         	beq	0x7009dea4 <Udma_chConfigRx+0x164> @ imm = #0xc
7009de96: e7ff         	b	0x7009de98 <Udma_chConfigRx+0x158> @ imm = #-0x2
;                     ((chHandleInt->chType & UDMA_CH_FLAG_PSIL) == UDMA_CH_FLAG_PSIL)) &&
7009de98: 9817         	ldr	r0, [sp, #0x5c]
7009de9a: 7800         	ldrb	r0, [r0]
7009de9c: 06c0         	lsls	r0, r0, #0x1b
7009de9e: 2800         	cmp	r0, #0x0
7009dea0: d569         	bpl	0x7009df76 <Udma_chConfigRx+0x236> @ imm = #0xd2
7009dea2: e7ff         	b	0x7009dea4 <Udma_chConfigRx+0x164> @ imm = #-0x2
;                (TRUE == rxPrms->configDefaultFlow))
7009dea4: 981a         	ldr	r0, [sp, #0x68]
7009dea6: 6940         	ldr	r0, [r0, #0x14]
;             if((((chHandleInt->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA) ||
7009dea8: 2801         	cmp	r0, #0x1
7009deaa: d164         	bne	0x7009df76 <Udma_chConfigRx+0x236> @ imm = #0xc8
7009deac: e7ff         	b	0x7009deae <Udma_chConfigRx+0x16e> @ imm = #-0x2
;                 UdmaFlowPrms_init(&flowPrms, chHandleInt->chType);
7009deae: 9817         	ldr	r0, [sp, #0x5c]
7009deb0: 6801         	ldr	r1, [r0]
7009deb2: a801         	add	r0, sp, #0x4
7009deb4: f00b fbd4    	bl	0x700a9660 <UdmaFlowPrms_init> @ imm = #0xb7a8
;                 flowPrms.psInfoPresent = rxPrms->flowPsInfoPresent;
7009deb8: 981a         	ldr	r0, [sp, #0x68]
7009deba: 7bc0         	ldrb	r0, [r0, #0xf]
7009debc: f88d 0009    	strb.w	r0, [sp, #0x9]
;                 flowPrms.einfoPresent  = rxPrms->flowEInfoPresent;
7009dec0: 981a         	ldr	r0, [sp, #0x68]
7009dec2: 7b80         	ldrb	r0, [r0, #0xe]
7009dec4: f88d 0008    	strb.w	r0, [sp, #0x8]
;                 flowPrms.errorHandling = rxPrms->flowErrorHandling;
7009dec8: 981a         	ldr	r0, [sp, #0x68]
7009deca: 7c00         	ldrb	r0, [r0, #0x10]
7009decc: f88d 000a    	strb.w	r0, [sp, #0xa]
;                 flowPrms.sopOffset     = rxPrms->flowSopOffset;
7009ded0: 981a         	ldr	r0, [sp, #0x68]
7009ded2: 7c40         	ldrb	r0, [r0, #0x11]
7009ded4: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                 if(NULL_PTR == chHandleInt->cqRing)
7009ded8: 9817         	ldr	r0, [sp, #0x5c]
7009deda: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009dede: b928         	cbnz	r0, 0x7009deec <Udma_chConfigRx+0x1ac> @ imm = #0xa
7009dee0: e7ff         	b	0x7009dee2 <Udma_chConfigRx+0x1a2> @ imm = #-0x2
7009dee2: f64f 70ff    	movw	r0, #0xffff
;                     cqRing = UDMA_RING_INVALID;
7009dee6: f8ad 0002    	strh.w	r0, [sp, #0x2]
;                 }
7009deea: e006         	b	0x7009defa <Udma_chConfigRx+0x1ba> @ imm = #0xc
;                     cqRing = chHandleInt->cqRing->ringNum;
7009deec: 9817         	ldr	r0, [sp, #0x5c]
7009deee: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009def2: 8880         	ldrh	r0, [r0, #0x4]
7009def4: f8ad 0002    	strh.w	r0, [sp, #0x2]
7009def8: e7ff         	b	0x7009defa <Udma_chConfigRx+0x1ba> @ imm = #-0x2
;                 if(NULL_PTR == chHandleInt->fqRing)
7009defa: 9817         	ldr	r0, [sp, #0x5c]
7009defc: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009df00: b928         	cbnz	r0, 0x7009df0e <Udma_chConfigRx+0x1ce> @ imm = #0xa
7009df02: e7ff         	b	0x7009df04 <Udma_chConfigRx+0x1c4> @ imm = #-0x2
7009df04: f64f 70ff    	movw	r0, #0xffff
;                     fqRing = UDMA_RING_INVALID;
7009df08: f8ad 0000    	strh.w	r0, [sp]
;                 }
7009df0c: e006         	b	0x7009df1c <Udma_chConfigRx+0x1dc> @ imm = #0xc
;                     fqRing = chHandleInt->fqRing->ringNum;
7009df0e: 9817         	ldr	r0, [sp, #0x5c]
7009df10: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009df14: 8880         	ldrh	r0, [r0, #0x4]
7009df16: f8ad 0000    	strh.w	r0, [sp]
7009df1a: e7ff         	b	0x7009df1c <Udma_chConfigRx+0x1dc> @ imm = #-0x2
;                 flowPrms.defaultRxCQ    = cqRing;
7009df1c: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
7009df20: f8ad 0010    	strh.w	r0, [sp, #0x10]
;                 flowPrms.fdq0Sz0Qnum    = fqRing;
7009df24: f8bd 0000    	ldrh.w	r0, [sp]
7009df28: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;                 flowPrms.fdq0Sz1Qnum    = fqRing;
7009df2c: f8bd 0000    	ldrh.w	r0, [sp]
7009df30: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;                 flowPrms.fdq0Sz2Qnum    = fqRing;
7009df34: f8bd 0000    	ldrh.w	r0, [sp]
7009df38: f8ad 002c    	strh.w	r0, [sp, #0x2c]
;                 flowPrms.fdq0Sz3Qnum    = fqRing;
7009df3c: f8bd 0000    	ldrh.w	r0, [sp]
7009df40: f8ad 002e    	strh.w	r0, [sp, #0x2e]
;                 flowPrms.fdq1Qnum       = fqRing;
7009df44: f8bd 0000    	ldrh.w	r0, [sp]
7009df48: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 flowPrms.fdq2Qnum       = fqRing;
7009df4c: f8bd 0000    	ldrh.w	r0, [sp]
7009df50: f8ad 0020    	strh.w	r0, [sp, #0x20]
;                 flowPrms.fdq3Qnum       = fqRing;
7009df54: f8bd 0000    	ldrh.w	r0, [sp]
7009df58: f8ad 0022    	strh.w	r0, [sp, #0x22]
;                 retVal = Udma_flowConfig(chHandleInt->defaultFlow, 0U, &flowPrms);
7009df5c: 9817         	ldr	r0, [sp, #0x5c]
7009df5e: f8d0 01c8    	ldr.w	r0, [r0, #0x1c8]
7009df62: 2100         	movs	r1, #0x0
7009df64: aa01         	add	r2, sp, #0x4
7009df66: f001 f9c3    	bl	0x7009f2f0 <Udma_flowConfig> @ imm = #0x1386
7009df6a: 9019         	str	r0, [sp, #0x64]
;                 if(UDMA_SOK != retVal)
7009df6c: 9819         	ldr	r0, [sp, #0x64]
7009df6e: b108         	cbz	r0, 0x7009df74 <Udma_chConfigRx+0x234> @ imm = #0x2
7009df70: e7ff         	b	0x7009df72 <Udma_chConfigRx+0x232> @ imm = #-0x2
;                 }
7009df72: e7ff         	b	0x7009df74 <Udma_chConfigRx+0x234> @ imm = #-0x2
;             }
7009df74: e7ff         	b	0x7009df76 <Udma_chConfigRx+0x236> @ imm = #-0x2
;             if(UDMA_SOK == retVal)
7009df76: 9819         	ldr	r0, [sp, #0x64]
7009df78: b968         	cbnz	r0, 0x7009df96 <Udma_chConfigRx+0x256> @ imm = #0x1a
7009df7a: e7ff         	b	0x7009df7c <Udma_chConfigRx+0x23c> @ imm = #-0x2
;                 (void) memcpy(&chHandleInt->rxPrms, rxPrms, sizeof(chHandleInt->rxPrms));
7009df7c: 9817         	ldr	r0, [sp, #0x5c]
7009df7e: f500 70fc    	add.w	r0, r0, #0x1f8
7009df82: 991a         	ldr	r1, [sp, #0x68]
7009df84: e8b1 100c    	ldm.w	r1!, {r2, r3, r12}
7009df88: e8a0 100c    	stm.w	r0!, {r2, r3, r12}
7009df8c: e891 500c    	ldm.w	r1, {r2, r3, r12, lr}
7009df90: e880 500c    	stm.w	r0, {r2, r3, r12, lr}
;             }
7009df94: e7ff         	b	0x7009df96 <Udma_chConfigRx+0x256> @ imm = #-0x2
7009df96: e7ff         	b	0x7009df98 <Udma_chConfigRx+0x258> @ imm = #-0x2
;     }
7009df98: e7ff         	b	0x7009df9a <Udma_chConfigRx+0x25a> @ imm = #-0x2
;     return (retVal);
7009df9a: 9819         	ldr	r0, [sp, #0x64]
7009df9c: b01c         	add	sp, #0x70
7009df9e: bd80         	pop	{r7, pc}

7009dfa0 <Sciclient_rmIrqFindRoute>:
; {
7009dfa0: b580         	push	{r7, lr}
7009dfa2: b08a         	sub	sp, #0x28
7009dfa4: 9009         	str	r0, [sp, #0x24]
7009dfa6: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009dfa8: 9008         	str	r0, [sp, #0x20]
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009dfaa: 9809         	ldr	r0, [sp, #0x24]
7009dfac: 88c0         	ldrh	r0, [r0, #0x6]
7009dfae: f010 fb77    	bl	0x700ae6a0 <Sciclient_rmIrIsIr> @ imm = #0x106ee
7009dfb2: b930         	cbnz	r0, 0x7009dfc2 <Sciclient_rmIrqFindRoute+0x22> @ imm = #0xc
7009dfb4: e7ff         	b	0x7009dfb6 <Sciclient_rmIrqFindRoute+0x16> @ imm = #-0x2
;         (Sciclient_rmIrIsIr(cfg->d_id) == true)) {
7009dfb6: 9809         	ldr	r0, [sp, #0x24]
7009dfb8: 8940         	ldrh	r0, [r0, #0xa]
7009dfba: f010 fb71    	bl	0x700ae6a0 <Sciclient_rmIrIsIr> @ imm = #0x106e2
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009dfbe: b120         	cbz	r0, 0x7009dfca <Sciclient_rmIrqFindRoute+0x2a> @ imm = #0x8
7009dfc0: e7ff         	b	0x7009dfc2 <Sciclient_rmIrqFindRoute+0x22> @ imm = #-0x2
7009dfc2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009dfc6: 9008         	str	r0, [sp, #0x20]
;     }
7009dfc8: e7ff         	b	0x7009dfca <Sciclient_rmIrqFindRoute+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009dfca: 9808         	ldr	r0, [sp, #0x20]
7009dfcc: bb20         	cbnz	r0, 0x7009e018 <Sciclient_rmIrqFindRoute+0x78> @ imm = #0x48
7009dfce: e7ff         	b	0x7009dfd0 <Sciclient_rmIrqFindRoute+0x30> @ imm = #-0x2
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009dfd0: 9809         	ldr	r0, [sp, #0x24]
7009dfd2: 8a00         	ldrh	r0, [r0, #0x10]
7009dfd4: 28ff         	cmp	r0, #0xff
7009dfd6: d015         	beq	0x7009e004 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0x2a
7009dfd8: e7ff         	b	0x7009dfda <Sciclient_rmIrqFindRoute+0x3a> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009dfda: 9809         	ldr	r0, [sp, #0x24]
7009dfdc: 6800         	ldr	r0, [r0]
7009dfde: 2104         	movs	r1, #0x4
7009dfe0: f010 fd3e    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x10a7c
;              true) &&
7009dfe4: b170         	cbz	r0, 0x7009e004 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0x1c
7009dfe6: e7ff         	b	0x7009dfe8 <Sciclient_rmIrqFindRoute+0x48> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009dfe8: 9809         	ldr	r0, [sp, #0x24]
7009dfea: 6800         	ldr	r0, [r0]
7009dfec: 2108         	movs	r1, #0x8
7009dfee: f010 fd37    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x10a6e
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009dff2: b138         	cbz	r0, 0x7009e004 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0xe
7009dff4: e7ff         	b	0x7009dff6 <Sciclient_rmIrqFindRoute+0x56> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNode(cfg->s_ia, &cur_n);
7009dff6: 9809         	ldr	r0, [sp, #0x24]
7009dff8: 8a00         	ldrh	r0, [r0, #0x10]
7009dffa: a905         	add	r1, sp, #0x14
7009dffc: f007 fde8    	bl	0x700a5bd0 <Sciclient_rmIrqGetNode> @ imm = #0x7bd0
7009e000: 9008         	str	r0, [sp, #0x20]
;         } else {
7009e002: e006         	b	0x7009e012 <Sciclient_rmIrqFindRoute+0x72> @ imm = #0xc
;             r = Sciclient_rmIrqGetNode(cfg->s_id, &cur_n);
7009e004: 9809         	ldr	r0, [sp, #0x24]
7009e006: 88c0         	ldrh	r0, [r0, #0x6]
7009e008: a905         	add	r1, sp, #0x14
7009e00a: f007 fde1    	bl	0x700a5bd0 <Sciclient_rmIrqGetNode> @ imm = #0x7bc2
7009e00e: 9008         	str	r0, [sp, #0x20]
7009e010: e7ff         	b	0x7009e012 <Sciclient_rmIrqFindRoute+0x72> @ imm = #-0x2
;         root_n = cur_n;
7009e012: 9805         	ldr	r0, [sp, #0x14]
7009e014: 9004         	str	r0, [sp, #0x10]
;     }
7009e016: e7ff         	b	0x7009e018 <Sciclient_rmIrqFindRoute+0x78> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009e018: 9808         	ldr	r0, [sp, #0x20]
7009e01a: b968         	cbnz	r0, 0x7009e038 <Sciclient_rmIrqFindRoute+0x98> @ imm = #0x1a
7009e01c: e7ff         	b	0x7009e01e <Sciclient_rmIrqFindRoute+0x7e> @ imm = #-0x2
7009e01e: 2001         	movs	r0, #0x1
;         search = true;
7009e020: 9002         	str	r0, [sp, #0x8]
7009e022: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         Sciclient_rmPsInit();
7009e026: f011 f8a3    	bl	0x700af170 <Sciclient_rmPsInit> @ imm = #0x11146
7009e02a: 9802         	ldr	r0, [sp, #0x8]
;         search_depth = 1u;
7009e02c: f8ad 001c    	strh.w	r0, [sp, #0x1c]
7009e030: 2000         	movs	r0, #0x0
;         if_idx = 0u;
7009e032: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     } else {
7009e036: e003         	b	0x7009e040 <Sciclient_rmIrqFindRoute+0xa0> @ imm = #0x6
7009e038: 2000         	movs	r0, #0x0
;         search = false;
7009e03a: f88d 001f    	strb.w	r0, [sp, #0x1f]
7009e03e: e7ff         	b	0x7009e040 <Sciclient_rmIrqFindRoute+0xa0> @ imm = #-0x2
;     while (search == true) {
7009e040: e7ff         	b	0x7009e042 <Sciclient_rmIrqFindRoute+0xa2> @ imm = #-0x2
7009e042: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009e046: 07c0         	lsls	r0, r0, #0x1f
7009e048: 2800         	cmp	r0, #0x0
7009e04a: f000 80ca    	beq.w	0x7009e1e2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x194
7009e04e: e7ff         	b	0x7009e050 <Sciclient_rmIrqFindRoute+0xb0> @ imm = #-0x2
7009e050: 2000         	movs	r0, #0x0
;         node_clear = false;
7009e052: f88d 0019    	strb.w	r0, [sp, #0x19]
;         if (if_idx < cur_n->n_if) {
7009e056: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009e05a: 9905         	ldr	r1, [sp, #0x14]
7009e05c: 8849         	ldrh	r1, [r1, #0x2]
7009e05e: 4288         	cmp	r0, r1
7009e060: f280 8087    	bge.w	0x7009e172 <Sciclient_rmIrqFindRoute+0x1d2> @ imm = #0x10e
7009e064: e7ff         	b	0x7009e066 <Sciclient_rmIrqFindRoute+0xc6> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(cur_n, if_idx, &cur_if);
7009e066: 9805         	ldr	r0, [sp, #0x14]
7009e068: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009e06c: aa03         	add	r2, sp, #0xc
7009e06e: f00f fbb7    	bl	0x700ad7e0 <Sciclient_rmIrqGetNodeItf> @ imm = #0xf76e
7009e072: 9008         	str	r0, [sp, #0x20]
;             if (r != SystemP_SUCCESS) {
7009e074: 9808         	ldr	r0, [sp, #0x20]
7009e076: b108         	cbz	r0, 0x7009e07c <Sciclient_rmIrqFindRoute+0xdc> @ imm = #0x2
7009e078: e7ff         	b	0x7009e07a <Sciclient_rmIrqFindRoute+0xda> @ imm = #-0x2
;                 break;
7009e07a: e0b2         	b	0x7009e1e2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x164
;             if ((Sciclient_rmIaIsIa(cur_n->id) == false) &&
7009e07c: 9805         	ldr	r0, [sp, #0x14]
7009e07e: 8800         	ldrh	r0, [r0]
7009e080: f010 faf6    	bl	0x700ae670 <Sciclient_rmIaIsIa> @ imm = #0x105ec
7009e084: b9d0         	cbnz	r0, 0x7009e0bc <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0x34
7009e086: e7ff         	b	0x7009e088 <Sciclient_rmIrqFindRoute+0xe8> @ imm = #-0x2
;                 (Sciclient_rmPsIsEmpty() == true) &&
7009e088: f010 fd02    	bl	0x700aea90 <Sciclient_rmPsIsEmpty> @ imm = #0x10a04
7009e08c: b1b0         	cbz	r0, 0x7009e0bc <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0x2c
7009e08e: e7ff         	b	0x7009e090 <Sciclient_rmIrqFindRoute+0xf0> @ imm = #-0x2
;                 ((cfg->s_idx < cur_if->lbase) ||
7009e090: 9809         	ldr	r0, [sp, #0x24]
7009e092: 8900         	ldrh	r0, [r0, #0x8]
7009e094: 9903         	ldr	r1, [sp, #0xc]
7009e096: 8809         	ldrh	r1, [r1]
7009e098: 4288         	cmp	r0, r1
7009e09a: db09         	blt	0x7009e0b0 <Sciclient_rmIrqFindRoute+0x110> @ imm = #0x12
7009e09c: e7ff         	b	0x7009e09e <Sciclient_rmIrqFindRoute+0xfe> @ imm = #-0x2
;                  (cfg->s_idx >= (cur_if->lbase + cur_if->len)))) {
7009e09e: 9809         	ldr	r0, [sp, #0x24]
7009e0a0: 8900         	ldrh	r0, [r0, #0x8]
7009e0a2: 9a03         	ldr	r2, [sp, #0xc]
7009e0a4: 8811         	ldrh	r1, [r2]
7009e0a6: 8892         	ldrh	r2, [r2, #0x4]
7009e0a8: 4411         	add	r1, r2
;             if ((Sciclient_rmIaIsIa(cur_n->id) == false) &&
7009e0aa: 4288         	cmp	r0, r1
7009e0ac: db06         	blt	0x7009e0bc <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0xc
7009e0ae: e7ff         	b	0x7009e0b0 <Sciclient_rmIrqFindRoute+0x110> @ imm = #-0x2
;                 if_idx++;
7009e0b0: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009e0b4: 3001         	adds	r0, #0x1
7009e0b6: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             } else if (Sciclient_rmPsGetPsp() < search_depth) {
7009e0ba: e059         	b	0x7009e170 <Sciclient_rmIrqFindRoute+0x1d0> @ imm = #0xb2
7009e0bc: f011 fc58    	bl	0x700af970 <Sciclient_rmPsGetPsp> @ imm = #0x118b0
7009e0c0: f8bd 101c    	ldrh.w	r1, [sp, #0x1c]
7009e0c4: 4288         	cmp	r0, r1
7009e0c6: da1e         	bge	0x7009e106 <Sciclient_rmIrqFindRoute+0x166> @ imm = #0x3c
7009e0c8: e7ff         	b	0x7009e0ca <Sciclient_rmIrqFindRoute+0x12a> @ imm = #-0x2
;                 r = Sciclient_rmPsPush(cur_n, if_idx);
7009e0ca: 9805         	ldr	r0, [sp, #0x14]
7009e0cc: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009e0d0: f00e f93e    	bl	0x700ac350 <Sciclient_rmPsPush> @ imm = #0xe27c
7009e0d4: 9008         	str	r0, [sp, #0x20]
;                 if (r != SystemP_SUCCESS) {
7009e0d6: 9808         	ldr	r0, [sp, #0x20]
7009e0d8: b108         	cbz	r0, 0x7009e0de <Sciclient_rmIrqFindRoute+0x13e> @ imm = #0x2
7009e0da: e7ff         	b	0x7009e0dc <Sciclient_rmIrqFindRoute+0x13c> @ imm = #-0x2
;                     break;
7009e0dc: e081         	b	0x7009e1e2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x102
;                 r = Sciclient_rmIrqGetNode(cur_if->rid, &cur_n);
7009e0de: 9803         	ldr	r0, [sp, #0xc]
7009e0e0: 88c0         	ldrh	r0, [r0, #0x6]
7009e0e2: a905         	add	r1, sp, #0x14
7009e0e4: f007 fd74    	bl	0x700a5bd0 <Sciclient_rmIrqGetNode> @ imm = #0x7ae8
7009e0e8: 9008         	str	r0, [sp, #0x20]
;                 if (cur_n == NULL) {
7009e0ea: 9805         	ldr	r0, [sp, #0x14]
7009e0ec: b930         	cbnz	r0, 0x7009e0fc <Sciclient_rmIrqFindRoute+0x15c> @ imm = #0xc
7009e0ee: e7ff         	b	0x7009e0f0 <Sciclient_rmIrqFindRoute+0x150> @ imm = #-0x2
7009e0f0: 2001         	movs	r0, #0x1
;                     node_clear = true;
7009e0f2: f88d 0019    	strb.w	r0, [sp, #0x19]
7009e0f6: 2000         	movs	r0, #0x0
;                     r = SystemP_SUCCESS;
7009e0f8: 9008         	str	r0, [sp, #0x20]
;                 } else {
7009e0fa: e003         	b	0x7009e104 <Sciclient_rmIrqFindRoute+0x164> @ imm = #0x6
7009e0fc: 2000         	movs	r0, #0x0
;                     if_idx = 0u;
7009e0fe: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009e102: e7ff         	b	0x7009e104 <Sciclient_rmIrqFindRoute+0x164> @ imm = #-0x2
;             } else {
7009e104: e033         	b	0x7009e16e <Sciclient_rmIrqFindRoute+0x1ce> @ imm = #0x66
;                 if ((cur_if->rid == cfg->d_id) &&
7009e106: 9803         	ldr	r0, [sp, #0xc]
7009e108: 88c0         	ldrh	r0, [r0, #0x6]
7009e10a: 9909         	ldr	r1, [sp, #0x24]
7009e10c: 8949         	ldrh	r1, [r1, #0xa]
7009e10e: 4288         	cmp	r0, r1
7009e110: d127         	bne	0x7009e162 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x4e
7009e112: e7ff         	b	0x7009e114 <Sciclient_rmIrqFindRoute+0x174> @ imm = #-0x2
;                     (cfg->d_irq >= (cur_if->rbase)) &&
7009e114: 9809         	ldr	r0, [sp, #0x24]
7009e116: 8980         	ldrh	r0, [r0, #0xc]
7009e118: 9903         	ldr	r1, [sp, #0xc]
7009e11a: 8849         	ldrh	r1, [r1, #0x2]
7009e11c: 4288         	cmp	r0, r1
7009e11e: db20         	blt	0x7009e162 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x40
7009e120: e7ff         	b	0x7009e122 <Sciclient_rmIrqFindRoute+0x182> @ imm = #-0x2
;                     (cfg->d_irq <
7009e122: 9809         	ldr	r0, [sp, #0x24]
7009e124: 8980         	ldrh	r0, [r0, #0xc]
;                      (cur_if->rbase + cur_if->len))) {
7009e126: 9a03         	ldr	r2, [sp, #0xc]
7009e128: 8851         	ldrh	r1, [r2, #0x2]
7009e12a: 8892         	ldrh	r2, [r2, #0x4]
7009e12c: 4411         	add	r1, r2
;                 if ((cur_if->rid == cfg->d_id) &&
7009e12e: 4288         	cmp	r0, r1
7009e130: da17         	bge	0x7009e162 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x2e
7009e132: e7ff         	b	0x7009e134 <Sciclient_rmIrqFindRoute+0x194> @ imm = #-0x2
;                     r = Sciclient_rmPsPush(cur_n, if_idx);
7009e134: 9805         	ldr	r0, [sp, #0x14]
7009e136: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009e13a: f00e f909    	bl	0x700ac350 <Sciclient_rmPsPush> @ imm = #0xe212
7009e13e: 9008         	str	r0, [sp, #0x20]
;                     if (r != SystemP_SUCCESS) {
7009e140: 9808         	ldr	r0, [sp, #0x20]
7009e142: b108         	cbz	r0, 0x7009e148 <Sciclient_rmIrqFindRoute+0x1a8> @ imm = #0x2
7009e144: e7ff         	b	0x7009e146 <Sciclient_rmIrqFindRoute+0x1a6> @ imm = #-0x2
;                         break;
7009e146: e04c         	b	0x7009e1e2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x98
;                     if (Sciclient_rmIrqRouteValidate(cfg) == true) {
7009e148: 9809         	ldr	r0, [sp, #0x24]
7009e14a: f7fc fca9    	bl	0x7009aaa0 <Sciclient_rmIrqRouteValidate> @ imm = #-0x36ae
7009e14e: b108         	cbz	r0, 0x7009e154 <Sciclient_rmIrqFindRoute+0x1b4> @ imm = #0x2
7009e150: e7ff         	b	0x7009e152 <Sciclient_rmIrqFindRoute+0x1b2> @ imm = #-0x2
;                         break;
7009e152: e046         	b	0x7009e1e2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x8c
7009e154: a805         	add	r0, sp, #0x14
7009e156: f10d 011a    	add.w	r1, sp, #0x1a
;                         Sciclient_rmPsPop(&cur_n, &if_idx);
7009e15a: f00b fc61    	bl	0x700a9a20 <Sciclient_rmPsPop> @ imm = #0xb8c2
7009e15e: e7ff         	b	0x7009e160 <Sciclient_rmIrqFindRoute+0x1c0> @ imm = #-0x2
;                 }
7009e160: e7ff         	b	0x7009e162 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #-0x2
;                 if_idx++;
7009e162: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009e166: 3001         	adds	r0, #0x1
7009e168: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009e16c: e7ff         	b	0x7009e16e <Sciclient_rmIrqFindRoute+0x1ce> @ imm = #-0x2
7009e16e: e7ff         	b	0x7009e170 <Sciclient_rmIrqFindRoute+0x1d0> @ imm = #-0x2
;         } else {
7009e170: e003         	b	0x7009e17a <Sciclient_rmIrqFindRoute+0x1da> @ imm = #0x6
7009e172: 2001         	movs	r0, #0x1
;             node_clear = true;
7009e174: f88d 0019    	strb.w	r0, [sp, #0x19]
7009e178: e7ff         	b	0x7009e17a <Sciclient_rmIrqFindRoute+0x1da> @ imm = #-0x2
;         if (node_clear == true) {
7009e17a: f89d 0019    	ldrb.w	r0, [sp, #0x19]
7009e17e: 07c0         	lsls	r0, r0, #0x1f
7009e180: b370         	cbz	r0, 0x7009e1e0 <Sciclient_rmIrqFindRoute+0x240> @ imm = #0x5c
7009e182: e7ff         	b	0x7009e184 <Sciclient_rmIrqFindRoute+0x1e4> @ imm = #-0x2
;             if (Sciclient_rmPsIsEmpty() == true) {
7009e184: f010 fc84    	bl	0x700aea90 <Sciclient_rmPsIsEmpty> @ imm = #0x10908
7009e188: b1c8         	cbz	r0, 0x7009e1be <Sciclient_rmIrqFindRoute+0x21e> @ imm = #0x32
7009e18a: e7ff         	b	0x7009e18c <Sciclient_rmIrqFindRoute+0x1ec> @ imm = #-0x2
;                 search_depth++;
7009e18c: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
7009e190: 3001         	adds	r0, #0x1
7009e192: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;                 cur_n = root_n;
7009e196: 9804         	ldr	r0, [sp, #0x10]
7009e198: 9005         	str	r0, [sp, #0x14]
7009e19a: 2000         	movs	r0, #0x0
;                 if_idx = 0u;
7009e19c: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;                 if (search_depth >= Sciclient_rmPsGetMaxPsp()) {
7009e1a0: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
7009e1a4: 9001         	str	r0, [sp, #0x4]
7009e1a6: f011 fc43    	bl	0x700afa30 <Sciclient_rmPsGetMaxPsp> @ imm = #0x11886
7009e1aa: 4601         	mov	r1, r0
7009e1ac: 9801         	ldr	r0, [sp, #0x4]
7009e1ae: 4288         	cmp	r0, r1
7009e1b0: db04         	blt	0x7009e1bc <Sciclient_rmIrqFindRoute+0x21c> @ imm = #0x8
7009e1b2: e7ff         	b	0x7009e1b4 <Sciclient_rmIrqFindRoute+0x214> @ imm = #-0x2
7009e1b4: f04f 30ff    	mov.w	r0, #0xffffffff
;                     r = SystemP_FAILURE;
7009e1b8: 9008         	str	r0, [sp, #0x20]
;                     break;
7009e1ba: e012         	b	0x7009e1e2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x24
;             } else {
7009e1bc: e00f         	b	0x7009e1de <Sciclient_rmIrqFindRoute+0x23e> @ imm = #0x1e
7009e1be: a805         	add	r0, sp, #0x14
7009e1c0: f10d 011a    	add.w	r1, sp, #0x1a
;                 r = Sciclient_rmPsPop(&cur_n, &if_idx);
7009e1c4: f00b fc2c    	bl	0x700a9a20 <Sciclient_rmPsPop> @ imm = #0xb858
7009e1c8: 9008         	str	r0, [sp, #0x20]
;                 if (r != SystemP_SUCCESS) {
7009e1ca: 9808         	ldr	r0, [sp, #0x20]
7009e1cc: b108         	cbz	r0, 0x7009e1d2 <Sciclient_rmIrqFindRoute+0x232> @ imm = #0x2
7009e1ce: e7ff         	b	0x7009e1d0 <Sciclient_rmIrqFindRoute+0x230> @ imm = #-0x2
;                     break;
7009e1d0: e007         	b	0x7009e1e2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0xe
;                 if_idx++;
7009e1d2: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009e1d6: 3001         	adds	r0, #0x1
7009e1d8: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009e1dc: e7ff         	b	0x7009e1de <Sciclient_rmIrqFindRoute+0x23e> @ imm = #-0x2
;         }
7009e1de: e7ff         	b	0x7009e1e0 <Sciclient_rmIrqFindRoute+0x240> @ imm = #-0x2
;     while (search == true) {
7009e1e0: e72f         	b	0x7009e042 <Sciclient_rmIrqFindRoute+0xa2> @ imm = #-0x1a2
;     return r;
7009e1e2: 9808         	ldr	r0, [sp, #0x20]
7009e1e4: b00a         	add	sp, #0x28
7009e1e6: bd80         	pop	{r7, pc}
		...

7009e1f0 <UART_fifoConfig>:
; {
7009e1f0: b580         	push	{r7, lr}
7009e1f2: b092         	sub	sp, #0x48
7009e1f4: 9011         	str	r0, [sp, #0x44]
7009e1f6: 9110         	str	r1, [sp, #0x40]
7009e1f8: 2000         	movs	r0, #0x0
;     uint32_t fcrValue = 0U;
7009e1fa: 900c         	str	r0, [sp, #0x30]
;     uint32_t txGra = (fifoConfig & UART_FIFO_CONFIG_TXGRA) >> 26;
7009e1fc: 9810         	ldr	r0, [sp, #0x40]
7009e1fe: f3c0 6083    	ubfx	r0, r0, #0x1a, #0x4
7009e202: 900b         	str	r0, [sp, #0x2c]
;     uint32_t rxGra = (fifoConfig & UART_FIFO_CONFIG_RXGRA) >> 22;
7009e204: 9810         	ldr	r0, [sp, #0x40]
7009e206: f3c0 5083    	ubfx	r0, r0, #0x16, #0x4
7009e20a: 900a         	str	r0, [sp, #0x28]
;     uint32_t txTrig = (fifoConfig & UART_FIFO_CONFIG_TXTRIG) >> 14;
7009e20c: 9810         	ldr	r0, [sp, #0x40]
7009e20e: f3c0 3087    	ubfx	r0, r0, #0xe, #0x8
7009e212: 9009         	str	r0, [sp, #0x24]
;     uint32_t rxTrig = (fifoConfig & UART_FIFO_CONFIG_RXTRIG) >> 6;
7009e214: 9810         	ldr	r0, [sp, #0x40]
7009e216: f3c0 1087    	ubfx	r0, r0, #0x6, #0x8
7009e21a: 9008         	str	r0, [sp, #0x20]
;     uint32_t txClr = (fifoConfig & UART_FIFO_CONFIG_TXCLR) >> 5;
7009e21c: 9810         	ldr	r0, [sp, #0x40]
7009e21e: f3c0 1040    	ubfx	r0, r0, #0x5, #0x1
7009e222: 9007         	str	r0, [sp, #0x1c]
;     uint32_t rxClr = (fifoConfig & UART_FIFO_CONFIG_RXCLR) >> 4;
7009e224: 9810         	ldr	r0, [sp, #0x40]
7009e226: f3c0 1000    	ubfx	r0, r0, #0x4, #0x1
7009e22a: 9006         	str	r0, [sp, #0x18]
;     uint32_t dmaEnPath = (fifoConfig & UART_FIFO_CONFIG_DMAENPATH) >> 3;
7009e22c: 9810         	ldr	r0, [sp, #0x40]
7009e22e: f3c0 00c0    	ubfx	r0, r0, #0x3, #0x1
7009e232: 9005         	str	r0, [sp, #0x14]
;     uint32_t dmaMode   = (fifoConfig & UART_FIFO_CONFIG_DMAMODE);
7009e234: 9810         	ldr	r0, [sp, #0x40]
7009e236: f000 0007    	and	r0, r0, #0x7
7009e23a: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = UART_enhanFuncEnable(baseAddr);
7009e23c: 9811         	ldr	r0, [sp, #0x44]
7009e23e: f00f fdef    	bl	0x700ade20 <UART_enhanFuncEnable> @ imm = #0xfbde
7009e242: 900f         	str	r0, [sp, #0x3c]
;     tcrTlrBitVal = UART_subConfigTCRTLRModeEn(baseAddr);
7009e244: 9811         	ldr	r0, [sp, #0x44]
7009e246: f00b f91b    	bl	0x700a9480 <UART_subConfigTCRTLRModeEn> @ imm = #0xb236
7009e24a: 900e         	str	r0, [sp, #0x38]
;     fcrValue |= UART_FCR_FIFO_EN_MASK;
7009e24c: 980c         	ldr	r0, [sp, #0x30]
7009e24e: f040 0001    	orr	r0, r0, #0x1
7009e252: 900c         	str	r0, [sp, #0x30]
;     if(UART_TRIG_LVL_GRANULARITY_1 != rxGra)
7009e254: 980a         	ldr	r0, [sp, #0x28]
7009e256: 2801         	cmp	r0, #0x1
7009e258: d033         	beq	0x7009e2c2 <UART_fifoConfig+0xd2> @ imm = #0x66
7009e25a: e7ff         	b	0x7009e25c <UART_fifoConfig+0x6c> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_RX_TRIG_GRANU1,
7009e25c: 9811         	ldr	r0, [sp, #0x44]
7009e25e: 3040         	adds	r0, #0x40
7009e260: 2180         	movs	r1, #0x80
7009e262: 2207         	movs	r2, #0x7
7009e264: 2300         	movs	r3, #0x0
7009e266: 9303         	str	r3, [sp, #0xc]
7009e268: f010 f8d2    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x101a4
7009e26c: 9b03         	ldr	r3, [sp, #0xc]
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA,
7009e26e: 9811         	ldr	r0, [sp, #0x44]
7009e270: 301c         	adds	r0, #0x1c
7009e272: 21f0         	movs	r1, #0xf0
7009e274: 2204         	movs	r2, #0x4
7009e276: f010 f8cb    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x10196
;         fcrValue &= ~((uint32_t) UART_FCR_RX_FIFO_TRIG_MASK);
7009e27a: 980c         	ldr	r0, [sp, #0x30]
7009e27c: f020 00c0    	bic	r0, r0, #0xc0
7009e280: 900c         	str	r0, [sp, #0x30]
;         if((UART_RXTRIGLVL_8 == rxTrig) ||
7009e282: 9808         	ldr	r0, [sp, #0x20]
7009e284: 2808         	cmp	r0, #0x8
7009e286: d00c         	beq	0x7009e2a2 <UART_fifoConfig+0xb2> @ imm = #0x18
7009e288: e7ff         	b	0x7009e28a <UART_fifoConfig+0x9a> @ imm = #-0x2
;            (UART_RXTRIGLVL_16 == rxTrig) ||
7009e28a: 9808         	ldr	r0, [sp, #0x20]
7009e28c: 2810         	cmp	r0, #0x10
7009e28e: d008         	beq	0x7009e2a2 <UART_fifoConfig+0xb2> @ imm = #0x10
7009e290: e7ff         	b	0x7009e292 <UART_fifoConfig+0xa2> @ imm = #-0x2
;            (UART_RXTRIGLVL_56 == rxTrig) ||
7009e292: 9808         	ldr	r0, [sp, #0x20]
7009e294: 2838         	cmp	r0, #0x38
7009e296: d004         	beq	0x7009e2a2 <UART_fifoConfig+0xb2> @ imm = #0x8
7009e298: e7ff         	b	0x7009e29a <UART_fifoConfig+0xaa> @ imm = #-0x2
;            (UART_RXTRIGLVL_60 == rxTrig))
7009e29a: 9808         	ldr	r0, [sp, #0x20]
;         if((UART_RXTRIGLVL_8 == rxTrig) ||
7009e29c: 283c         	cmp	r0, #0x3c
7009e29e: d107         	bne	0x7009e2b0 <UART_fifoConfig+0xc0> @ imm = #0xe
7009e2a0: e7ff         	b	0x7009e2a2 <UART_fifoConfig+0xb2> @ imm = #-0x2
;             fcrValue |= rxTrig & UART_FCR_RX_FIFO_TRIG_MASK;
7009e2a2: 9808         	ldr	r0, [sp, #0x20]
7009e2a4: f000 01c0    	and	r1, r0, #0xc0
7009e2a8: 980c         	ldr	r0, [sp, #0x30]
7009e2aa: 4308         	orrs	r0, r1
7009e2ac: 900c         	str	r0, [sp, #0x30]
;         }
7009e2ae: e007         	b	0x7009e2c0 <UART_fifoConfig+0xd0> @ imm = #0xe
;             HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA,
7009e2b0: 9811         	ldr	r0, [sp, #0x44]
7009e2b2: 301c         	adds	r0, #0x1c
7009e2b4: 9b08         	ldr	r3, [sp, #0x20]
7009e2b6: 21f0         	movs	r1, #0xf0
7009e2b8: 2204         	movs	r2, #0x4
7009e2ba: f010 f8a9    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x10152
7009e2be: e7ff         	b	0x7009e2c0 <UART_fifoConfig+0xd0> @ imm = #-0x2
;     }
7009e2c0: e01d         	b	0x7009e2fe <UART_fifoConfig+0x10e> @ imm = #0x3a
;         rxTrig &= 0x003FU;
7009e2c2: 9808         	ldr	r0, [sp, #0x20]
7009e2c4: f000 003f    	and	r0, r0, #0x3f
7009e2c8: 9008         	str	r0, [sp, #0x20]
;         tlrValue = (rxTrig & 0x003CU) >> 2;
7009e2ca: 9808         	ldr	r0, [sp, #0x20]
7009e2cc: f3c0 0083    	ubfx	r0, r0, #0x2, #0x4
7009e2d0: 900d         	str	r0, [sp, #0x34]
;         fcrValue |= (rxTrig & 0x0003U) << UART_FCR_RX_FIFO_TRIG_SHIFT;
7009e2d2: 9808         	ldr	r0, [sp, #0x20]
7009e2d4: f000 0103    	and	r1, r0, #0x3
7009e2d8: 980c         	ldr	r0, [sp, #0x30]
7009e2da: ea40 1081    	orr.w	r0, r0, r1, lsl #6
7009e2de: 900c         	str	r0, [sp, #0x30]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_RX_TRIG_GRANU1,
7009e2e0: 9811         	ldr	r0, [sp, #0x44]
7009e2e2: 3040         	adds	r0, #0x40
7009e2e4: 2180         	movs	r1, #0x80
7009e2e6: 2207         	movs	r2, #0x7
7009e2e8: 2301         	movs	r3, #0x1
7009e2ea: f010 f891    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x10122
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA, tlrValue);
7009e2ee: 9811         	ldr	r0, [sp, #0x44]
7009e2f0: 301c         	adds	r0, #0x1c
7009e2f2: 9b0d         	ldr	r3, [sp, #0x34]
7009e2f4: 21f0         	movs	r1, #0xf0
7009e2f6: 2204         	movs	r2, #0x4
7009e2f8: f010 f88a    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x10114
7009e2fc: e7ff         	b	0x7009e2fe <UART_fifoConfig+0x10e> @ imm = #-0x2
;     if(UART_TRIG_LVL_GRANULARITY_1 != txGra)
7009e2fe: 980b         	ldr	r0, [sp, #0x2c]
7009e300: 2801         	cmp	r0, #0x1
7009e302: d033         	beq	0x7009e36c <UART_fifoConfig+0x17c> @ imm = #0x66
7009e304: e7ff         	b	0x7009e306 <UART_fifoConfig+0x116> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_TX_TRIG_GRANU1,
7009e306: 9811         	ldr	r0, [sp, #0x44]
7009e308: 3040         	adds	r0, #0x40
7009e30a: 2140         	movs	r1, #0x40
7009e30c: 2206         	movs	r2, #0x6
7009e30e: 2300         	movs	r3, #0x0
7009e310: 9302         	str	r3, [sp, #0x8]
7009e312: f010 f87d    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x100fa
7009e316: 9b02         	ldr	r3, [sp, #0x8]
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA,
7009e318: 9811         	ldr	r0, [sp, #0x44]
7009e31a: 301c         	adds	r0, #0x1c
7009e31c: 210f         	movs	r1, #0xf
7009e31e: 461a         	mov	r2, r3
7009e320: f010 f876    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x100ec
;         fcrValue &= ~((uint32_t) UART_FCR_TX_FIFO_TRIG_MASK);
7009e324: 980c         	ldr	r0, [sp, #0x30]
7009e326: f020 0030    	bic	r0, r0, #0x30
7009e32a: 900c         	str	r0, [sp, #0x30]
;         if((UART_TXTRIGLVL_8 == (txTrig)) ||
7009e32c: 9809         	ldr	r0, [sp, #0x24]
7009e32e: 2808         	cmp	r0, #0x8
7009e330: d00c         	beq	0x7009e34c <UART_fifoConfig+0x15c> @ imm = #0x18
7009e332: e7ff         	b	0x7009e334 <UART_fifoConfig+0x144> @ imm = #-0x2
;            (UART_TXTRIGLVL_16 == (txTrig)) ||
7009e334: 9809         	ldr	r0, [sp, #0x24]
7009e336: 2810         	cmp	r0, #0x10
7009e338: d008         	beq	0x7009e34c <UART_fifoConfig+0x15c> @ imm = #0x10
7009e33a: e7ff         	b	0x7009e33c <UART_fifoConfig+0x14c> @ imm = #-0x2
;            (UART_TXTRIGLVL_32 == (txTrig)) ||
7009e33c: 9809         	ldr	r0, [sp, #0x24]
7009e33e: 2820         	cmp	r0, #0x20
7009e340: d004         	beq	0x7009e34c <UART_fifoConfig+0x15c> @ imm = #0x8
7009e342: e7ff         	b	0x7009e344 <UART_fifoConfig+0x154> @ imm = #-0x2
;            (UART_TXTRIGLVL_56 == (txTrig)))
7009e344: 9809         	ldr	r0, [sp, #0x24]
;         if((UART_TXTRIGLVL_8 == (txTrig)) ||
7009e346: 2838         	cmp	r0, #0x38
7009e348: d107         	bne	0x7009e35a <UART_fifoConfig+0x16a> @ imm = #0xe
7009e34a: e7ff         	b	0x7009e34c <UART_fifoConfig+0x15c> @ imm = #-0x2
;             fcrValue |= txTrig & UART_FCR_TX_FIFO_TRIG_MASK;
7009e34c: 9809         	ldr	r0, [sp, #0x24]
7009e34e: f000 0130    	and	r1, r0, #0x30
7009e352: 980c         	ldr	r0, [sp, #0x30]
7009e354: 4308         	orrs	r0, r1
7009e356: 900c         	str	r0, [sp, #0x30]
;         }
7009e358: e007         	b	0x7009e36a <UART_fifoConfig+0x17a> @ imm = #0xe
;             HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA,
7009e35a: 9811         	ldr	r0, [sp, #0x44]
7009e35c: 301c         	adds	r0, #0x1c
7009e35e: 9b09         	ldr	r3, [sp, #0x24]
7009e360: 210f         	movs	r1, #0xf
7009e362: 2200         	movs	r2, #0x0
7009e364: f010 f854    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x100a8
7009e368: e7ff         	b	0x7009e36a <UART_fifoConfig+0x17a> @ imm = #-0x2
;     }
7009e36a: e01d         	b	0x7009e3a8 <UART_fifoConfig+0x1b8> @ imm = #0x3a
;         txTrig &= 0x003FU;
7009e36c: 9809         	ldr	r0, [sp, #0x24]
7009e36e: f000 003f    	and	r0, r0, #0x3f
7009e372: 9009         	str	r0, [sp, #0x24]
;         tlrValue = (txTrig & 0x003CU) >> 2;
7009e374: 9809         	ldr	r0, [sp, #0x24]
7009e376: f3c0 0083    	ubfx	r0, r0, #0x2, #0x4
7009e37a: 900d         	str	r0, [sp, #0x34]
;         fcrValue |= (txTrig & 0x0003U) << UART_FCR_TX_FIFO_TRIG_SHIFT;
7009e37c: 9809         	ldr	r0, [sp, #0x24]
7009e37e: f000 0103    	and	r1, r0, #0x3
7009e382: 980c         	ldr	r0, [sp, #0x30]
7009e384: ea40 1001    	orr.w	r0, r0, r1, lsl #4
7009e388: 900c         	str	r0, [sp, #0x30]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_TX_TRIG_GRANU1,
7009e38a: 9811         	ldr	r0, [sp, #0x44]
7009e38c: 3040         	adds	r0, #0x40
7009e38e: 2140         	movs	r1, #0x40
7009e390: 2206         	movs	r2, #0x6
7009e392: 2301         	movs	r3, #0x1
7009e394: f010 f83c    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x10078
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA, tlrValue);
7009e398: 9811         	ldr	r0, [sp, #0x44]
7009e39a: 301c         	adds	r0, #0x1c
7009e39c: 9b0d         	ldr	r3, [sp, #0x34]
7009e39e: 210f         	movs	r1, #0xf
7009e3a0: 2200         	movs	r2, #0x0
7009e3a2: f010 f835    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x1006a
7009e3a6: e7ff         	b	0x7009e3a8 <UART_fifoConfig+0x1b8> @ imm = #-0x2
;     if(UART_DMA_EN_PATH_FCR == dmaEnPath)
7009e3a8: 9805         	ldr	r0, [sp, #0x14]
7009e3aa: b9a8         	cbnz	r0, 0x7009e3d8 <UART_fifoConfig+0x1e8> @ imm = #0x2a
7009e3ac: e7ff         	b	0x7009e3ae <UART_fifoConfig+0x1be> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_CTL,
7009e3ae: 9811         	ldr	r0, [sp, #0x44]
7009e3b0: 3040         	adds	r0, #0x40
7009e3b2: 2101         	movs	r1, #0x1
7009e3b4: 2300         	movs	r3, #0x0
7009e3b6: 461a         	mov	r2, r3
7009e3b8: f010 f82a    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x10054
;         dmaMode &= 0x1U;
7009e3bc: 9804         	ldr	r0, [sp, #0x10]
7009e3be: f000 0001    	and	r0, r0, #0x1
7009e3c2: 9004         	str	r0, [sp, #0x10]
;         fcrValue &= ~((uint32_t) UART_FCR_DMA_MODE_MASK);
7009e3c4: 980c         	ldr	r0, [sp, #0x30]
7009e3c6: f020 0008    	bic	r0, r0, #0x8
7009e3ca: 900c         	str	r0, [sp, #0x30]
;         fcrValue |= dmaMode << UART_FCR_DMA_MODE_SHIFT;
7009e3cc: 9904         	ldr	r1, [sp, #0x10]
7009e3ce: 980c         	ldr	r0, [sp, #0x30]
7009e3d0: ea40 00c1    	orr.w	r0, r0, r1, lsl #3
7009e3d4: 900c         	str	r0, [sp, #0x30]
;     }
7009e3d6: e013         	b	0x7009e400 <UART_fifoConfig+0x210> @ imm = #0x26
;         dmaMode &= 0x3U;
7009e3d8: 9804         	ldr	r0, [sp, #0x10]
7009e3da: f000 0003    	and	r0, r0, #0x3
7009e3de: 9004         	str	r0, [sp, #0x10]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_CTL,
7009e3e0: 9811         	ldr	r0, [sp, #0x44]
7009e3e2: 3040         	adds	r0, #0x40
7009e3e4: 2200         	movs	r2, #0x0
7009e3e6: 2301         	movs	r3, #0x1
7009e3e8: 9301         	str	r3, [sp, #0x4]
7009e3ea: 4619         	mov	r1, r3
7009e3ec: f010 f810    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x10020
7009e3f0: 9a01         	ldr	r2, [sp, #0x4]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_2, dmaMode);
7009e3f2: 9811         	ldr	r0, [sp, #0x44]
7009e3f4: 3040         	adds	r0, #0x40
7009e3f6: 9b04         	ldr	r3, [sp, #0x10]
7009e3f8: 2106         	movs	r1, #0x6
7009e3fa: f010 f809    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x10012
7009e3fe: e7ff         	b	0x7009e400 <UART_fifoConfig+0x210> @ imm = #-0x2
;     fcrValue |= rxClr << UART_FCR_RX_FIFO_CLEAR_SHIFT;
7009e400: 9906         	ldr	r1, [sp, #0x18]
7009e402: 980c         	ldr	r0, [sp, #0x30]
7009e404: ea40 0041    	orr.w	r0, r0, r1, lsl #1
7009e408: 900c         	str	r0, [sp, #0x30]
;     fcrValue |= txClr << UART_FCR_TX_FIFO_CLEAR_SHIFT;
7009e40a: 9907         	ldr	r1, [sp, #0x1c]
7009e40c: 980c         	ldr	r0, [sp, #0x30]
7009e40e: ea40 0081    	orr.w	r0, r0, r1, lsl #2
7009e412: 900c         	str	r0, [sp, #0x30]
;     UART_fifoRegisterWrite(baseAddr, fcrValue);
7009e414: 9811         	ldr	r0, [sp, #0x44]
7009e416: 990c         	ldr	r1, [sp, #0x30]
7009e418: f00d faba    	bl	0x700ab990 <UART_fifoRegisterWrite> @ imm = #0xd574
;     UART_tcrTlrBitValRestore(baseAddr, tcrTlrBitVal);
7009e41c: 9811         	ldr	r0, [sp, #0x44]
7009e41e: 990e         	ldr	r1, [sp, #0x38]
7009e420: f00b ff46    	bl	0x700aa2b0 <UART_tcrTlrBitValRestore> @ imm = #0xbe8c
;     UART_enhanFuncBitValRestore(baseAddr, enhanFnBitVal);
7009e424: 9811         	ldr	r0, [sp, #0x44]
7009e426: 990f         	ldr	r1, [sp, #0x3c]
7009e428: f010 f812    	bl	0x700ae450 <UART_enhanFuncBitValRestore> @ imm = #0x10024
;     return fcrValue;
7009e42c: 980c         	ldr	r0, [sp, #0x30]
7009e42e: b012         	add	sp, #0x48
7009e430: bd80         	pop	{r7, pc}
		...
7009e43e: 0000         	movs	r0, r0

7009e440 <_ntoa_format>:
; {
7009e440: b570         	push	{r4, r5, r6, lr}
7009e442: b08c         	sub	sp, #0x30
7009e444: 4684         	mov	r12, r0
7009e446: 9816         	ldr	r0, [sp, #0x58]
7009e448: 9815         	ldr	r0, [sp, #0x54]
7009e44a: 9814         	ldr	r0, [sp, #0x50]
7009e44c: 9813         	ldr	r0, [sp, #0x4c]
7009e44e: 9812         	ldr	r0, [sp, #0x48]
7009e450: f8dd e044    	ldr.w	lr, [sp, #0x44]
7009e454: f8dd e040    	ldr.w	lr, [sp, #0x40]
7009e458: f8cd c02c    	str.w	r12, [sp, #0x2c]
7009e45c: 910a         	str	r1, [sp, #0x28]
7009e45e: 9209         	str	r2, [sp, #0x24]
7009e460: 9308         	str	r3, [sp, #0x20]
7009e462: f88d 001f    	strb.w	r0, [sp, #0x1f]
;   if (!(flags & FLAGS_LEFT)) {
7009e466: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e46a: 0780         	lsls	r0, r0, #0x1e
7009e46c: 2800         	cmp	r0, #0x0
7009e46e: d454         	bmi	0x7009e51a <_ntoa_format+0xda> @ imm = #0xa8
7009e470: e7ff         	b	0x7009e472 <_ntoa_format+0x32> @ imm = #-0x2
;     if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
7009e472: 9815         	ldr	r0, [sp, #0x54]
7009e474: b1a0         	cbz	r0, 0x7009e4a0 <_ntoa_format+0x60> @ imm = #0x28
7009e476: e7ff         	b	0x7009e478 <_ntoa_format+0x38> @ imm = #-0x2
7009e478: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e47c: 07c0         	lsls	r0, r0, #0x1f
7009e47e: b178         	cbz	r0, 0x7009e4a0 <_ntoa_format+0x60> @ imm = #0x1e
7009e480: e7ff         	b	0x7009e482 <_ntoa_format+0x42> @ imm = #-0x2
7009e482: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009e486: 07c0         	lsls	r0, r0, #0x1f
7009e488: b930         	cbnz	r0, 0x7009e498 <_ntoa_format+0x58> @ imm = #0xc
7009e48a: e7ff         	b	0x7009e48c <_ntoa_format+0x4c> @ imm = #-0x2
7009e48c: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e490: f010 0f0c    	tst.w	r0, #0xc
7009e494: d004         	beq	0x7009e4a0 <_ntoa_format+0x60> @ imm = #0x8
7009e496: e7ff         	b	0x7009e498 <_ntoa_format+0x58> @ imm = #-0x2
;       width--;
7009e498: 9815         	ldr	r0, [sp, #0x54]
7009e49a: 3801         	subs	r0, #0x1
7009e49c: 9015         	str	r0, [sp, #0x54]
;     }
7009e49e: e7ff         	b	0x7009e4a0 <_ntoa_format+0x60> @ imm = #-0x2
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e4a0: e7ff         	b	0x7009e4a2 <_ntoa_format+0x62> @ imm = #-0x2
7009e4a2: 9911         	ldr	r1, [sp, #0x44]
7009e4a4: 9a14         	ldr	r2, [sp, #0x50]
7009e4a6: 2000         	movs	r0, #0x0
7009e4a8: 4291         	cmp	r1, r2
7009e4aa: 9006         	str	r0, [sp, #0x18]
7009e4ac: d207         	bhs	0x7009e4be <_ntoa_format+0x7e> @ imm = #0xe
7009e4ae: e7ff         	b	0x7009e4b0 <_ntoa_format+0x70> @ imm = #-0x2
7009e4b0: 9911         	ldr	r1, [sp, #0x44]
7009e4b2: 2000         	movs	r0, #0x0
7009e4b4: 2920         	cmp	r1, #0x20
7009e4b6: bf38         	it	lo
7009e4b8: 2001         	movlo	r0, #0x1
7009e4ba: 9006         	str	r0, [sp, #0x18]
7009e4bc: e7ff         	b	0x7009e4be <_ntoa_format+0x7e> @ imm = #-0x2
7009e4be: 9806         	ldr	r0, [sp, #0x18]
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e4c0: 07c0         	lsls	r0, r0, #0x1f
7009e4c2: b138         	cbz	r0, 0x7009e4d4 <_ntoa_format+0x94> @ imm = #0xe
7009e4c4: e7ff         	b	0x7009e4c6 <_ntoa_format+0x86> @ imm = #-0x2
;       buf[len++] = '0';
7009e4c6: 9910         	ldr	r1, [sp, #0x40]
7009e4c8: 9a11         	ldr	r2, [sp, #0x44]
7009e4ca: 1c50         	adds	r0, r2, #0x1
7009e4cc: 9011         	str	r0, [sp, #0x44]
7009e4ce: 2030         	movs	r0, #0x30
7009e4d0: 5488         	strb	r0, [r1, r2]
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e4d2: e7e6         	b	0x7009e4a2 <_ntoa_format+0x62> @ imm = #-0x34
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e4d4: e7ff         	b	0x7009e4d6 <_ntoa_format+0x96> @ imm = #-0x2
7009e4d6: 2000         	movs	r0, #0x0
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e4d8: f89d 1058    	ldrb.w	r1, [sp, #0x58]
7009e4dc: ea4f 71c1    	lsl.w	r1, r1, #0x1f
7009e4e0: 9005         	str	r0, [sp, #0x14]
7009e4e2: b171         	cbz	r1, 0x7009e502 <_ntoa_format+0xc2> @ imm = #0x1c
7009e4e4: e7ff         	b	0x7009e4e6 <_ntoa_format+0xa6> @ imm = #-0x2
7009e4e6: 9911         	ldr	r1, [sp, #0x44]
7009e4e8: 9a15         	ldr	r2, [sp, #0x54]
7009e4ea: 2000         	movs	r0, #0x0
7009e4ec: 4291         	cmp	r1, r2
7009e4ee: 9005         	str	r0, [sp, #0x14]
7009e4f0: d207         	bhs	0x7009e502 <_ntoa_format+0xc2> @ imm = #0xe
7009e4f2: e7ff         	b	0x7009e4f4 <_ntoa_format+0xb4> @ imm = #-0x2
7009e4f4: 9911         	ldr	r1, [sp, #0x44]
7009e4f6: 2000         	movs	r0, #0x0
7009e4f8: 2920         	cmp	r1, #0x20
7009e4fa: bf38         	it	lo
7009e4fc: 2001         	movlo	r0, #0x1
7009e4fe: 9005         	str	r0, [sp, #0x14]
7009e500: e7ff         	b	0x7009e502 <_ntoa_format+0xc2> @ imm = #-0x2
7009e502: 9805         	ldr	r0, [sp, #0x14]
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e504: 07c0         	lsls	r0, r0, #0x1f
7009e506: b138         	cbz	r0, 0x7009e518 <_ntoa_format+0xd8> @ imm = #0xe
7009e508: e7ff         	b	0x7009e50a <_ntoa_format+0xca> @ imm = #-0x2
;       buf[len++] = '0';
7009e50a: 9910         	ldr	r1, [sp, #0x40]
7009e50c: 9a11         	ldr	r2, [sp, #0x44]
7009e50e: 1c50         	adds	r0, r2, #0x1
7009e510: 9011         	str	r0, [sp, #0x44]
7009e512: 2030         	movs	r0, #0x30
7009e514: 5488         	strb	r0, [r1, r2]
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e516: e7de         	b	0x7009e4d6 <_ntoa_format+0x96> @ imm = #-0x44
;   }
7009e518: e7ff         	b	0x7009e51a <_ntoa_format+0xda> @ imm = #-0x2
;   if (flags & FLAGS_HASH) {
7009e51a: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e51e: 06c0         	lsls	r0, r0, #0x1b
7009e520: 2800         	cmp	r0, #0x0
7009e522: d569         	bpl	0x7009e5f8 <_ntoa_format+0x1b8> @ imm = #0xd2
7009e524: e7ff         	b	0x7009e526 <_ntoa_format+0xe6> @ imm = #-0x2
;     if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
7009e526: f89d 0059    	ldrb.w	r0, [sp, #0x59]
7009e52a: 0740         	lsls	r0, r0, #0x1d
7009e52c: 2800         	cmp	r0, #0x0
7009e52e: d41c         	bmi	0x7009e56a <_ntoa_format+0x12a> @ imm = #0x38
7009e530: e7ff         	b	0x7009e532 <_ntoa_format+0xf2> @ imm = #-0x2
7009e532: 9811         	ldr	r0, [sp, #0x44]
7009e534: b1c8         	cbz	r0, 0x7009e56a <_ntoa_format+0x12a> @ imm = #0x32
7009e536: e7ff         	b	0x7009e538 <_ntoa_format+0xf8> @ imm = #-0x2
7009e538: 9811         	ldr	r0, [sp, #0x44]
7009e53a: 9914         	ldr	r1, [sp, #0x50]
7009e53c: 4288         	cmp	r0, r1
7009e53e: d005         	beq	0x7009e54c <_ntoa_format+0x10c> @ imm = #0xa
7009e540: e7ff         	b	0x7009e542 <_ntoa_format+0x102> @ imm = #-0x2
7009e542: 9811         	ldr	r0, [sp, #0x44]
7009e544: 9915         	ldr	r1, [sp, #0x54]
7009e546: 4288         	cmp	r0, r1
7009e548: d10f         	bne	0x7009e56a <_ntoa_format+0x12a> @ imm = #0x1e
7009e54a: e7ff         	b	0x7009e54c <_ntoa_format+0x10c> @ imm = #-0x2
;       len--;
7009e54c: 9811         	ldr	r0, [sp, #0x44]
7009e54e: 3801         	subs	r0, #0x1
7009e550: 9011         	str	r0, [sp, #0x44]
;       if (len && (base == 16U)) {
7009e552: 9811         	ldr	r0, [sp, #0x44]
7009e554: b140         	cbz	r0, 0x7009e568 <_ntoa_format+0x128> @ imm = #0x10
7009e556: e7ff         	b	0x7009e558 <_ntoa_format+0x118> @ imm = #-0x2
7009e558: 9813         	ldr	r0, [sp, #0x4c]
7009e55a: 2810         	cmp	r0, #0x10
7009e55c: d104         	bne	0x7009e568 <_ntoa_format+0x128> @ imm = #0x8
7009e55e: e7ff         	b	0x7009e560 <_ntoa_format+0x120> @ imm = #-0x2
;         len--;
7009e560: 9811         	ldr	r0, [sp, #0x44]
7009e562: 3801         	subs	r0, #0x1
7009e564: 9011         	str	r0, [sp, #0x44]
;       }
7009e566: e7ff         	b	0x7009e568 <_ntoa_format+0x128> @ imm = #-0x2
;     }
7009e568: e7ff         	b	0x7009e56a <_ntoa_format+0x12a> @ imm = #-0x2
;     if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e56a: 9813         	ldr	r0, [sp, #0x4c]
7009e56c: 2810         	cmp	r0, #0x10
7009e56e: d111         	bne	0x7009e594 <_ntoa_format+0x154> @ imm = #0x22
7009e570: e7ff         	b	0x7009e572 <_ntoa_format+0x132> @ imm = #-0x2
7009e572: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e576: 0680         	lsls	r0, r0, #0x1a
7009e578: 2800         	cmp	r0, #0x0
7009e57a: d40b         	bmi	0x7009e594 <_ntoa_format+0x154> @ imm = #0x16
7009e57c: e7ff         	b	0x7009e57e <_ntoa_format+0x13e> @ imm = #-0x2
7009e57e: 9811         	ldr	r0, [sp, #0x44]
7009e580: 281f         	cmp	r0, #0x1f
7009e582: d807         	bhi	0x7009e594 <_ntoa_format+0x154> @ imm = #0xe
7009e584: e7ff         	b	0x7009e586 <_ntoa_format+0x146> @ imm = #-0x2
;       buf[len++] = 'x';
7009e586: 9910         	ldr	r1, [sp, #0x40]
7009e588: 9a11         	ldr	r2, [sp, #0x44]
7009e58a: 1c50         	adds	r0, r2, #0x1
7009e58c: 9011         	str	r0, [sp, #0x44]
7009e58e: 2078         	movs	r0, #0x78
7009e590: 5488         	strb	r0, [r1, r2]
;     }
7009e592: e025         	b	0x7009e5e0 <_ntoa_format+0x1a0> @ imm = #0x4a
;     else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e594: 9813         	ldr	r0, [sp, #0x4c]
7009e596: 2810         	cmp	r0, #0x10
7009e598: d111         	bne	0x7009e5be <_ntoa_format+0x17e> @ imm = #0x22
7009e59a: e7ff         	b	0x7009e59c <_ntoa_format+0x15c> @ imm = #-0x2
7009e59c: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e5a0: 0680         	lsls	r0, r0, #0x1a
7009e5a2: 2800         	cmp	r0, #0x0
7009e5a4: d50b         	bpl	0x7009e5be <_ntoa_format+0x17e> @ imm = #0x16
7009e5a6: e7ff         	b	0x7009e5a8 <_ntoa_format+0x168> @ imm = #-0x2
7009e5a8: 9811         	ldr	r0, [sp, #0x44]
7009e5aa: 281f         	cmp	r0, #0x1f
7009e5ac: d807         	bhi	0x7009e5be <_ntoa_format+0x17e> @ imm = #0xe
7009e5ae: e7ff         	b	0x7009e5b0 <_ntoa_format+0x170> @ imm = #-0x2
;       buf[len++] = 'X';
7009e5b0: 9910         	ldr	r1, [sp, #0x40]
7009e5b2: 9a11         	ldr	r2, [sp, #0x44]
7009e5b4: 1c50         	adds	r0, r2, #0x1
7009e5b6: 9011         	str	r0, [sp, #0x44]
7009e5b8: 2058         	movs	r0, #0x58
7009e5ba: 5488         	strb	r0, [r1, r2]
;     }
7009e5bc: e00f         	b	0x7009e5de <_ntoa_format+0x19e> @ imm = #0x1e
;     else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e5be: 9813         	ldr	r0, [sp, #0x4c]
7009e5c0: 2802         	cmp	r0, #0x2
7009e5c2: d10b         	bne	0x7009e5dc <_ntoa_format+0x19c> @ imm = #0x16
7009e5c4: e7ff         	b	0x7009e5c6 <_ntoa_format+0x186> @ imm = #-0x2
7009e5c6: 9811         	ldr	r0, [sp, #0x44]
7009e5c8: 281f         	cmp	r0, #0x1f
7009e5ca: d807         	bhi	0x7009e5dc <_ntoa_format+0x19c> @ imm = #0xe
7009e5cc: e7ff         	b	0x7009e5ce <_ntoa_format+0x18e> @ imm = #-0x2
;       buf[len++] = 'b';
7009e5ce: 9910         	ldr	r1, [sp, #0x40]
7009e5d0: 9a11         	ldr	r2, [sp, #0x44]
7009e5d2: 1c50         	adds	r0, r2, #0x1
7009e5d4: 9011         	str	r0, [sp, #0x44]
7009e5d6: 2062         	movs	r0, #0x62
7009e5d8: 5488         	strb	r0, [r1, r2]
;     }
7009e5da: e7ff         	b	0x7009e5dc <_ntoa_format+0x19c> @ imm = #-0x2
7009e5dc: e7ff         	b	0x7009e5de <_ntoa_format+0x19e> @ imm = #-0x2
7009e5de: e7ff         	b	0x7009e5e0 <_ntoa_format+0x1a0> @ imm = #-0x2
;     if (len < PRINTF_NTOA_BUFFER_SIZE) {
7009e5e0: 9811         	ldr	r0, [sp, #0x44]
7009e5e2: 281f         	cmp	r0, #0x1f
7009e5e4: d807         	bhi	0x7009e5f6 <_ntoa_format+0x1b6> @ imm = #0xe
7009e5e6: e7ff         	b	0x7009e5e8 <_ntoa_format+0x1a8> @ imm = #-0x2
;       buf[len++] = '0';
7009e5e8: 9910         	ldr	r1, [sp, #0x40]
7009e5ea: 9a11         	ldr	r2, [sp, #0x44]
7009e5ec: 1c50         	adds	r0, r2, #0x1
7009e5ee: 9011         	str	r0, [sp, #0x44]
7009e5f0: 2030         	movs	r0, #0x30
7009e5f2: 5488         	strb	r0, [r1, r2]
;     }
7009e5f4: e7ff         	b	0x7009e5f6 <_ntoa_format+0x1b6> @ imm = #-0x2
;   }
7009e5f6: e7ff         	b	0x7009e5f8 <_ntoa_format+0x1b8> @ imm = #-0x2
;   if (len < PRINTF_NTOA_BUFFER_SIZE) {
7009e5f8: 9811         	ldr	r0, [sp, #0x44]
7009e5fa: 281f         	cmp	r0, #0x1f
7009e5fc: d829         	bhi	0x7009e652 <_ntoa_format+0x212> @ imm = #0x52
7009e5fe: e7ff         	b	0x7009e600 <_ntoa_format+0x1c0> @ imm = #-0x2
;     if (negative) {
7009e600: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009e604: 07c0         	lsls	r0, r0, #0x1f
7009e606: b138         	cbz	r0, 0x7009e618 <_ntoa_format+0x1d8> @ imm = #0xe
7009e608: e7ff         	b	0x7009e60a <_ntoa_format+0x1ca> @ imm = #-0x2
;       buf[len++] = '-';
7009e60a: 9910         	ldr	r1, [sp, #0x40]
7009e60c: 9a11         	ldr	r2, [sp, #0x44]
7009e60e: 1c50         	adds	r0, r2, #0x1
7009e610: 9011         	str	r0, [sp, #0x44]
7009e612: 202d         	movs	r0, #0x2d
7009e614: 5488         	strb	r0, [r1, r2]
;     }
7009e616: e01b         	b	0x7009e650 <_ntoa_format+0x210> @ imm = #0x36
;     else if (flags & FLAGS_PLUS) {
7009e618: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e61c: 0740         	lsls	r0, r0, #0x1d
7009e61e: 2800         	cmp	r0, #0x0
7009e620: d507         	bpl	0x7009e632 <_ntoa_format+0x1f2> @ imm = #0xe
7009e622: e7ff         	b	0x7009e624 <_ntoa_format+0x1e4> @ imm = #-0x2
;       buf[len++] = '+';  // ignore the space if the '+' exists
7009e624: 9910         	ldr	r1, [sp, #0x40]
7009e626: 9a11         	ldr	r2, [sp, #0x44]
7009e628: 1c50         	adds	r0, r2, #0x1
7009e62a: 9011         	str	r0, [sp, #0x44]
7009e62c: 202b         	movs	r0, #0x2b
7009e62e: 5488         	strb	r0, [r1, r2]
;     }
7009e630: e00d         	b	0x7009e64e <_ntoa_format+0x20e> @ imm = #0x1a
;     else if (flags & FLAGS_SPACE) {
7009e632: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e636: 0700         	lsls	r0, r0, #0x1c
7009e638: 2800         	cmp	r0, #0x0
7009e63a: d507         	bpl	0x7009e64c <_ntoa_format+0x20c> @ imm = #0xe
7009e63c: e7ff         	b	0x7009e63e <_ntoa_format+0x1fe> @ imm = #-0x2
;       buf[len++] = ' ';
7009e63e: 9910         	ldr	r1, [sp, #0x40]
7009e640: 9a11         	ldr	r2, [sp, #0x44]
7009e642: 1c50         	adds	r0, r2, #0x1
7009e644: 9011         	str	r0, [sp, #0x44]
7009e646: 2020         	movs	r0, #0x20
7009e648: 5488         	strb	r0, [r1, r2]
;     }
7009e64a: e7ff         	b	0x7009e64c <_ntoa_format+0x20c> @ imm = #-0x2
7009e64c: e7ff         	b	0x7009e64e <_ntoa_format+0x20e> @ imm = #-0x2
7009e64e: e7ff         	b	0x7009e650 <_ntoa_format+0x210> @ imm = #-0x2
;   }
7009e650: e7ff         	b	0x7009e652 <_ntoa_format+0x212> @ imm = #-0x2
;   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
7009e652: 980b         	ldr	r0, [sp, #0x2c]
7009e654: 990a         	ldr	r1, [sp, #0x28]
7009e656: 9a09         	ldr	r2, [sp, #0x24]
7009e658: 9b08         	ldr	r3, [sp, #0x20]
7009e65a: f8dd c040    	ldr.w	r12, [sp, #0x40]
7009e65e: 9c11         	ldr	r4, [sp, #0x44]
7009e660: 9d15         	ldr	r5, [sp, #0x54]
7009e662: 9e16         	ldr	r6, [sp, #0x58]
7009e664: 46ee         	mov	lr, sp
7009e666: f8ce 600c    	str.w	r6, [lr, #0xc]
7009e66a: f8ce 5008    	str.w	r5, [lr, #0x8]
7009e66e: f8ce 4004    	str.w	r4, [lr, #0x4]
7009e672: f8ce c000    	str.w	r12, [lr]
7009e676: f008 fe7b    	bl	0x700a7370 <_out_rev>   @ imm = #0x8cf6
7009e67a: b00c         	add	sp, #0x30
7009e67c: bd70         	pop	{r4, r5, r6, pc}
7009e67e: 0000         	movs	r0, r0

7009e680 <Udma_eventRegister>:
; {
7009e680: b5b0         	push	{r4, r5, r7, lr}
7009e682: b088         	sub	sp, #0x20
7009e684: 9007         	str	r0, [sp, #0x1c]
7009e686: 9106         	str	r1, [sp, #0x18]
7009e688: 9205         	str	r2, [sp, #0x14]
7009e68a: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009e68c: 9004         	str	r0, [sp, #0x10]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009e68e: 9003         	str	r0, [sp, #0xc]
;     if((NULL_PTR == drvHandle) || (NULL_PTR == eventHandle) || (NULL_PTR == eventPrms))
7009e690: 9807         	ldr	r0, [sp, #0x1c]
7009e692: b130         	cbz	r0, 0x7009e6a2 <Udma_eventRegister+0x22> @ imm = #0xc
7009e694: e7ff         	b	0x7009e696 <Udma_eventRegister+0x16> @ imm = #-0x2
7009e696: 9806         	ldr	r0, [sp, #0x18]
7009e698: b118         	cbz	r0, 0x7009e6a2 <Udma_eventRegister+0x22> @ imm = #0x6
7009e69a: e7ff         	b	0x7009e69c <Udma_eventRegister+0x1c> @ imm = #-0x2
7009e69c: 9805         	ldr	r0, [sp, #0x14]
7009e69e: b920         	cbnz	r0, 0x7009e6aa <Udma_eventRegister+0x2a> @ imm = #0x8
7009e6a0: e7ff         	b	0x7009e6a2 <Udma_eventRegister+0x22> @ imm = #-0x2
7009e6a2: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009e6a6: 9004         	str	r0, [sp, #0x10]
;     }
7009e6a8: e7ff         	b	0x7009e6aa <Udma_eventRegister+0x2a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e6aa: 9804         	ldr	r0, [sp, #0x10]
7009e6ac: b988         	cbnz	r0, 0x7009e6d2 <Udma_eventRegister+0x52> @ imm = #0x22
7009e6ae: e7ff         	b	0x7009e6b0 <Udma_eventRegister+0x30> @ imm = #-0x2
;         drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009e6b0: 9807         	ldr	r0, [sp, #0x1c]
7009e6b2: 9002         	str	r0, [sp, #0x8]
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009e6b4: 9802         	ldr	r0, [sp, #0x8]
7009e6b6: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009e6ba: f64a 31cd    	movw	r1, #0xabcd
7009e6be: f6ca 31dc    	movt	r1, #0xabdc
7009e6c2: 4288         	cmp	r0, r1
7009e6c4: d004         	beq	0x7009e6d0 <Udma_eventRegister+0x50> @ imm = #0x8
7009e6c6: e7ff         	b	0x7009e6c8 <Udma_eventRegister+0x48> @ imm = #-0x2
7009e6c8: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009e6cc: 9004         	str	r0, [sp, #0x10]
;         }
7009e6ce: e7ff         	b	0x7009e6d0 <Udma_eventRegister+0x50> @ imm = #-0x2
;     }
7009e6d0: e7ff         	b	0x7009e6d2 <Udma_eventRegister+0x52> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e6d2: 9804         	ldr	r0, [sp, #0x10]
7009e6d4: b930         	cbnz	r0, 0x7009e6e4 <Udma_eventRegister+0x64> @ imm = #0xc
7009e6d6: e7ff         	b	0x7009e6d8 <Udma_eventRegister+0x58> @ imm = #-0x2
;         retVal = Udma_eventCheckParams(drvHandleInt, eventPrms);
7009e6d8: 9802         	ldr	r0, [sp, #0x8]
7009e6da: 9905         	ldr	r1, [sp, #0x14]
7009e6dc: f006 fd10    	bl	0x700a5100 <Udma_eventCheckParams> @ imm = #0x6a20
7009e6e0: 9004         	str	r0, [sp, #0x10]
;     }
7009e6e2: e7ff         	b	0x7009e6e4 <Udma_eventRegister+0x64> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e6e4: 9804         	ldr	r0, [sp, #0x10]
7009e6e6: bbb0         	cbnz	r0, 0x7009e756 <Udma_eventRegister+0xd6> @ imm = #0x6c
7009e6e8: e7ff         	b	0x7009e6ea <Udma_eventRegister+0x6a> @ imm = #-0x2
;         eventHandleInt = (Udma_EventHandleInt) eventHandle;
7009e6ea: 9806         	ldr	r0, [sp, #0x18]
7009e6ec: 9001         	str	r0, [sp, #0x4]
;             &eventHandleInt->eventPrms, eventPrms, sizeof(eventHandleInt->eventPrms));
7009e6ee: 9801         	ldr	r0, [sp, #0x4]
7009e6f0: 3008         	adds	r0, #0x8
7009e6f2: 9905         	ldr	r1, [sp, #0x14]
;         (void) memcpy(
7009e6f4: e8b1 501c    	ldm.w	r1!, {r2, r3, r4, r12, lr}
7009e6f8: e8a0 501c    	stm.w	r0!, {r2, r3, r4, r12, lr}
7009e6fc: e8b1 501c    	ldm.w	r1!, {r2, r3, r4, r12, lr}
7009e700: e8a0 501c    	stm.w	r0!, {r2, r3, r4, r12, lr}
7009e704: e891 503c    	ldm.w	r1, {r2, r3, r4, r5, r12, lr}
7009e708: e880 503c    	stm.w	r0, {r2, r3, r4, r5, r12, lr}
;         eventHandleInt->drvHandle       = drvHandleInt;
7009e70c: 9802         	ldr	r0, [sp, #0x8]
7009e70e: 9901         	ldr	r1, [sp, #0x4]
7009e710: 6008         	str	r0, [r1]
;         eventHandleInt->globalEvent     = UDMA_EVENT_INVALID;
7009e712: 9901         	ldr	r1, [sp, #0x4]
7009e714: f64f 70ff    	movw	r0, #0xffff
7009e718: 6488         	str	r0, [r1, #0x48]
;         eventHandleInt->vintrNum        = UDMA_EVENT_INVALID;
7009e71a: 9901         	ldr	r1, [sp, #0x4]
7009e71c: 64c8         	str	r0, [r1, #0x4c]
;         eventHandleInt->vintrBitNum     = UDMA_EVENT_INVALID;
7009e71e: 9901         	ldr	r1, [sp, #0x4]
7009e720: 6508         	str	r0, [r1, #0x50]
;         eventHandleInt->irIntrNum       = UDMA_INTR_INVALID;
7009e722: 9901         	ldr	r1, [sp, #0x4]
7009e724: 2000         	movs	r0, #0x0
7009e726: f6cf 70ff    	movt	r0, #0xffff
7009e72a: 6548         	str	r0, [r1, #0x54]
;         eventHandleInt->coreIntrNum     = UDMA_INTR_INVALID;
7009e72c: 9901         	ldr	r1, [sp, #0x4]
7009e72e: 6588         	str	r0, [r1, #0x58]
;         eventHandleInt->nextEvent       = (Udma_EventHandleInt) NULL_PTR;
7009e730: 9901         	ldr	r1, [sp, #0x4]
7009e732: 2000         	movs	r0, #0x0
7009e734: 65c8         	str	r0, [r1, #0x5c]
;         eventHandleInt->prevEvent       = (Udma_EventHandleInt) NULL_PTR;
7009e736: 9901         	ldr	r1, [sp, #0x4]
7009e738: 6608         	str	r0, [r1, #0x60]
;         eventHandleInt->hwiHandle       = NULL_PTR;
7009e73a: 9901         	ldr	r1, [sp, #0x4]
7009e73c: 6648         	str	r0, [r1, #0x64]
;         eventHandleInt->vintrBitAllocFlag = 0U;
7009e73e: 9901         	ldr	r1, [sp, #0x4]
7009e740: f8c1 008c    	str.w	r0, [r1, #0x8c]
7009e744: f8c1 0088    	str.w	r0, [r1, #0x88]
;         eventHandleInt->pIaGeviRegs     = (volatile CSL_intaggr_imapRegs_gevi *) NULL_PTR;
7009e748: 9901         	ldr	r1, [sp, #0x4]
7009e74a: f8c1 0090    	str.w	r0, [r1, #0x90]
;         eventHandleInt->pIaVintrRegs    = (volatile CSL_intaggr_intrRegs_vint *) NULL_PTR;
7009e74e: 9901         	ldr	r1, [sp, #0x4]
7009e750: f8c1 0094    	str.w	r0, [r1, #0x94]
;     }
7009e754: e7ff         	b	0x7009e756 <Udma_eventRegister+0xd6> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e756: 9804         	ldr	r0, [sp, #0x10]
7009e758: 2800         	cmp	r0, #0x0
7009e75a: f040 809f    	bne.w	0x7009e89c <Udma_eventRegister+0x21c> @ imm = #0x13e
7009e75e: e7ff         	b	0x7009e760 <Udma_eventRegister+0xe0> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandleInt->instType) &&
7009e760: 9802         	ldr	r0, [sp, #0x8]
7009e762: 6800         	ldr	r0, [r0]
7009e764: b130         	cbz	r0, 0x7009e774 <Udma_eventRegister+0xf4> @ imm = #0xc
7009e766: e7ff         	b	0x7009e768 <Udma_eventRegister+0xe8> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType))
7009e768: 9805         	ldr	r0, [sp, #0x14]
7009e76a: 6800         	ldr	r0, [r0]
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandleInt->instType) &&
7009e76c: 2802         	cmp	r0, #0x2
7009e76e: d101         	bne	0x7009e774 <Udma_eventRegister+0xf4> @ imm = #0x2
7009e770: e7ff         	b	0x7009e772 <Udma_eventRegister+0xf2> @ imm = #-0x2
;         }
7009e772: e092         	b	0x7009e89a <Udma_eventRegister+0x21a> @ imm = #0x124
;             retVal = Udma_eventAllocResource(drvHandleInt, eventHandleInt);
7009e774: 9802         	ldr	r0, [sp, #0x8]
7009e776: 9901         	ldr	r1, [sp, #0x4]
7009e778: f000 f89a    	bl	0x7009e8b0 <Udma_eventAllocResource> @ imm = #0x134
7009e77c: 9004         	str	r0, [sp, #0x10]
;             if(UDMA_SOK == retVal)
7009e77e: 9804         	ldr	r0, [sp, #0x10]
7009e780: b918         	cbnz	r0, 0x7009e78a <Udma_eventRegister+0x10a> @ imm = #0x6
7009e782: e7ff         	b	0x7009e784 <Udma_eventRegister+0x104> @ imm = #-0x2
7009e784: 2001         	movs	r0, #0x1
;                 allocDone = (uint32_t) TRUE;
7009e786: 9003         	str	r0, [sp, #0xc]
;             }
7009e788: e000         	b	0x7009e78c <Udma_eventRegister+0x10c> @ imm = #0x0
7009e78a: e7ff         	b	0x7009e78c <Udma_eventRegister+0x10c> @ imm = #-0x2
;             if(UDMA_SOK == retVal)
7009e78c: 9804         	ldr	r0, [sp, #0x10]
7009e78e: b9a0         	cbnz	r0, 0x7009e7ba <Udma_eventRegister+0x13a> @ imm = #0x28
7009e790: e7ff         	b	0x7009e792 <Udma_eventRegister+0x112> @ imm = #-0x2
;                 eventHandleInt->eventInitDone = UDMA_INIT_DONE;
7009e792: 9901         	ldr	r1, [sp, #0x4]
7009e794: f64a 30cd    	movw	r0, #0xabcd
7009e798: f6ca 30dc    	movt	r0, #0xabdc
7009e79c: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 retVal = Udma_eventConfig(drvHandleInt, eventHandleInt);
7009e7a0: 9802         	ldr	r0, [sp, #0x8]
7009e7a2: 9901         	ldr	r1, [sp, #0x4]
7009e7a4: f7fe f8b4    	bl	0x7009c910 <Udma_eventConfig> @ imm = #-0x1e98
7009e7a8: 9004         	str	r0, [sp, #0x10]
;                 if(UDMA_SOK == retVal)
7009e7aa: 9804         	ldr	r0, [sp, #0x10]
7009e7ac: b918         	cbnz	r0, 0x7009e7b6 <Udma_eventRegister+0x136> @ imm = #0x6
7009e7ae: e7ff         	b	0x7009e7b0 <Udma_eventRegister+0x130> @ imm = #-0x2
7009e7b0: 2001         	movs	r0, #0x1
;                     allocDone = (uint32_t) TRUE;
7009e7b2: 9003         	str	r0, [sp, #0xc]
;                 }
7009e7b4: e000         	b	0x7009e7b8 <Udma_eventRegister+0x138> @ imm = #0x0
7009e7b6: e7ff         	b	0x7009e7b8 <Udma_eventRegister+0x138> @ imm = #-0x2
;             }
7009e7b8: e7ff         	b	0x7009e7ba <Udma_eventRegister+0x13a> @ imm = #-0x2
;             if(UDMA_SOK != retVal)
7009e7ba: 9804         	ldr	r0, [sp, #0x10]
7009e7bc: b170         	cbz	r0, 0x7009e7dc <Udma_eventRegister+0x15c> @ imm = #0x1c
7009e7be: e7ff         	b	0x7009e7c0 <Udma_eventRegister+0x140> @ imm = #-0x2
;                 if(((uint32_t) TRUE) == allocDone)
7009e7c0: 9803         	ldr	r0, [sp, #0xc]
7009e7c2: 2801         	cmp	r0, #0x1
7009e7c4: d109         	bne	0x7009e7da <Udma_eventRegister+0x15a> @ imm = #0x12
7009e7c6: e7ff         	b	0x7009e7c8 <Udma_eventRegister+0x148> @ imm = #-0x2
;                     Udma_eventFreeResource(drvHandleInt, eventHandleInt);
7009e7c8: 9802         	ldr	r0, [sp, #0x8]
7009e7ca: 9901         	ldr	r1, [sp, #0x4]
7009e7cc: f007 f910    	bl	0x700a59f0 <Udma_eventFreeResource> @ imm = #0x7220
;                     eventHandleInt->eventInitDone = UDMA_DEINIT_DONE;
7009e7d0: 9901         	ldr	r1, [sp, #0x4]
7009e7d2: 2000         	movs	r0, #0x0
7009e7d4: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 }
7009e7d8: e7ff         	b	0x7009e7da <Udma_eventRegister+0x15a> @ imm = #-0x2
;             }
7009e7da: e05d         	b	0x7009e898 <Udma_eventRegister+0x218> @ imm = #0xba
;                 eventPrms->intrStatusReg    = &eventHandleInt->pIaVintrRegs->STATUSM;
7009e7dc: 9801         	ldr	r0, [sp, #0x4]
7009e7de: f8d0 0094    	ldr.w	r0, [r0, #0x94]
7009e7e2: 3020         	adds	r0, #0x20
7009e7e4: 9905         	ldr	r1, [sp, #0x14]
7009e7e6: 6248         	str	r0, [r1, #0x24]
;                 eventPrms->intrClearReg     = &eventHandleInt->pIaVintrRegs->STATUS_CLEAR;
7009e7e8: 9801         	ldr	r0, [sp, #0x4]
7009e7ea: f8d0 0094    	ldr.w	r0, [r0, #0x94]
7009e7ee: 3018         	adds	r0, #0x18
7009e7f0: 9905         	ldr	r1, [sp, #0x14]
7009e7f2: 6288         	str	r0, [r1, #0x28]
;                 if(eventHandleInt->vintrBitNum != UDMA_EVENT_INVALID)
7009e7f4: 9801         	ldr	r0, [sp, #0x4]
7009e7f6: 6d00         	ldr	r0, [r0, #0x50]
7009e7f8: f64f 71ff    	movw	r1, #0xffff
7009e7fc: 4288         	cmp	r0, r1
7009e7fe: d017         	beq	0x7009e830 <Udma_eventRegister+0x1b0> @ imm = #0x2e
7009e800: e7ff         	b	0x7009e802 <Udma_eventRegister+0x182> @ imm = #-0x2
;                     eventPrms->intrMask     = ((uint64_t)1U << eventHandleInt->vintrBitNum);
7009e802: 9801         	ldr	r0, [sp, #0x4]
7009e804: 6d03         	ldr	r3, [r0, #0x50]
7009e806: f1a3 0120    	sub.w	r1, r3, #0x20
7009e80a: 2201         	movs	r2, #0x1
7009e80c: fa02 fc01    	lsl.w	r12, r2, r1
7009e810: f1c3 0020    	rsb.w	r0, r3, #0x20
7009e814: fa22 f000    	lsr.w	r0, r2, r0
7009e818: 2900         	cmp	r1, #0x0
7009e81a: bf58         	it	pl
7009e81c: 4660         	movpl	r0, r12
7009e81e: fa02 f203    	lsl.w	r2, r2, r3
7009e822: 2900         	cmp	r1, #0x0
7009e824: bf58         	it	pl
7009e826: 2200         	movpl	r2, #0x0
7009e828: 9905         	ldr	r1, [sp, #0x14]
7009e82a: 630a         	str	r2, [r1, #0x30]
7009e82c: 6348         	str	r0, [r1, #0x34]
;                 }
7009e82e: e004         	b	0x7009e83a <Udma_eventRegister+0x1ba> @ imm = #0x8
;                     eventPrms->intrMask     = 0U;
7009e830: 9905         	ldr	r1, [sp, #0x14]
7009e832: 2000         	movs	r0, #0x0
7009e834: 6348         	str	r0, [r1, #0x34]
7009e836: 6308         	str	r0, [r1, #0x30]
7009e838: e7ff         	b	0x7009e83a <Udma_eventRegister+0x1ba> @ imm = #-0x2
;                 if(NULL_PTR == eventHandleInt->eventPrms.controllerEventHandle)
7009e83a: 9801         	ldr	r0, [sp, #0x4]
7009e83c: 6980         	ldr	r0, [r0, #0x18]
7009e83e: b948         	cbnz	r0, 0x7009e854 <Udma_eventRegister+0x1d4> @ imm = #0x12
7009e840: e7ff         	b	0x7009e842 <Udma_eventRegister+0x1c2> @ imm = #-0x2
;                     eventPrms->vintrNum     = eventHandleInt->vintrNum;
7009e842: 9801         	ldr	r0, [sp, #0x4]
7009e844: 6cc0         	ldr	r0, [r0, #0x4c]
7009e846: 9905         	ldr	r1, [sp, #0x14]
7009e848: 6388         	str	r0, [r1, #0x38]
;                     eventPrms->coreIntrNum  = eventHandleInt->coreIntrNum;
7009e84a: 9801         	ldr	r0, [sp, #0x4]
7009e84c: 6d80         	ldr	r0, [r0, #0x58]
7009e84e: 9905         	ldr	r1, [sp, #0x14]
7009e850: 63c8         	str	r0, [r1, #0x3c]
;                 }
7009e852: e00a         	b	0x7009e86a <Udma_eventRegister+0x1ea> @ imm = #0x14
;                        ((Udma_EventHandleInt) (eventHandleInt->eventPrms.controllerEventHandle))->vintrNum;
7009e854: 9801         	ldr	r0, [sp, #0x4]
7009e856: 6980         	ldr	r0, [r0, #0x18]
7009e858: 6cc0         	ldr	r0, [r0, #0x4c]
;                     eventPrms->vintrNum       =
7009e85a: 9905         	ldr	r1, [sp, #0x14]
7009e85c: 6388         	str	r0, [r1, #0x38]
;                         ((Udma_EventHandleInt) (eventHandleInt->eventPrms.controllerEventHandle))->coreIntrNum;
7009e85e: 9801         	ldr	r0, [sp, #0x4]
7009e860: 6980         	ldr	r0, [r0, #0x18]
7009e862: 6d80         	ldr	r0, [r0, #0x58]
;                     eventPrms->coreIntrNum    =
7009e864: 9905         	ldr	r1, [sp, #0x14]
7009e866: 63c8         	str	r0, [r1, #0x3c]
7009e868: e7ff         	b	0x7009e86a <Udma_eventRegister+0x1ea> @ imm = #-0x2
;                 eventHandleInt->eventPrms.intrStatusReg   = eventPrms->intrStatusReg;
7009e86a: 9805         	ldr	r0, [sp, #0x14]
7009e86c: 6a40         	ldr	r0, [r0, #0x24]
7009e86e: 9901         	ldr	r1, [sp, #0x4]
7009e870: 62c8         	str	r0, [r1, #0x2c]
;                 eventHandleInt->eventPrms.intrClearReg    = eventPrms->intrClearReg;
7009e872: 9805         	ldr	r0, [sp, #0x14]
7009e874: 6a80         	ldr	r0, [r0, #0x28]
7009e876: 9901         	ldr	r1, [sp, #0x4]
7009e878: 6308         	str	r0, [r1, #0x30]
;                 eventHandleInt->eventPrms.intrMask        = eventPrms->intrMask;
7009e87a: 9905         	ldr	r1, [sp, #0x14]
7009e87c: 6b08         	ldr	r0, [r1, #0x30]
7009e87e: 6b4a         	ldr	r2, [r1, #0x34]
7009e880: 9901         	ldr	r1, [sp, #0x4]
7009e882: 63ca         	str	r2, [r1, #0x3c]
7009e884: 6388         	str	r0, [r1, #0x38]
;                 eventHandleInt->eventPrms.vintrNum        = eventPrms->vintrNum;
7009e886: 9805         	ldr	r0, [sp, #0x14]
7009e888: 6b80         	ldr	r0, [r0, #0x38]
7009e88a: 9901         	ldr	r1, [sp, #0x4]
7009e88c: 6408         	str	r0, [r1, #0x40]
;                 eventHandleInt->eventPrms.coreIntrNum     = eventPrms->coreIntrNum;
7009e88e: 9805         	ldr	r0, [sp, #0x14]
7009e890: 6bc0         	ldr	r0, [r0, #0x3c]
7009e892: 9901         	ldr	r1, [sp, #0x4]
7009e894: 6448         	str	r0, [r1, #0x44]
7009e896: e7ff         	b	0x7009e898 <Udma_eventRegister+0x218> @ imm = #-0x2
7009e898: e7ff         	b	0x7009e89a <Udma_eventRegister+0x21a> @ imm = #-0x2
;     }
7009e89a: e7ff         	b	0x7009e89c <Udma_eventRegister+0x21c> @ imm = #-0x2
;     return (retVal);
7009e89c: 9804         	ldr	r0, [sp, #0x10]
7009e89e: b008         	add	sp, #0x20
7009e8a0: bdb0         	pop	{r4, r5, r7, pc}
		...
7009e8ae: 0000         	movs	r0, r0

7009e8b0 <Udma_eventAllocResource>:
; {
7009e8b0: b580         	push	{r7, lr}
7009e8b2: b08a         	sub	sp, #0x28
7009e8b4: 9009         	str	r0, [sp, #0x24]
7009e8b6: 9108         	str	r1, [sp, #0x20]
7009e8b8: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009e8ba: 9007         	str	r0, [sp, #0x1c]
;     eventPrms = &eventHandle->eventPrms;
7009e8bc: 9808         	ldr	r0, [sp, #0x20]
7009e8be: 3008         	adds	r0, #0x8
7009e8c0: 9004         	str	r0, [sp, #0x10]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009e8c2: 9804         	ldr	r0, [sp, #0x10]
7009e8c4: 6800         	ldr	r0, [r0]
7009e8c6: 2805         	cmp	r0, #0x5
7009e8c8: d01b         	beq	0x7009e902 <Udma_eventAllocResource+0x52> @ imm = #0x36
7009e8ca: e7ff         	b	0x7009e8cc <Udma_eventAllocResource+0x1c> @ imm = #-0x2
;         eventHandle->globalEvent = Udma_rmAllocEvent(drvHandle);
7009e8cc: 9809         	ldr	r0, [sp, #0x24]
7009e8ce: f00a f837    	bl	0x700a8940 <Udma_rmAllocEvent> @ imm = #0xa06e
7009e8d2: 9908         	ldr	r1, [sp, #0x20]
7009e8d4: 6488         	str	r0, [r1, #0x48]
;         if(UDMA_EVENT_INVALID == eventHandle->globalEvent)
7009e8d6: 9808         	ldr	r0, [sp, #0x20]
7009e8d8: 6c80         	ldr	r0, [r0, #0x48]
7009e8da: f64f 71ff    	movw	r1, #0xffff
7009e8de: 4288         	cmp	r0, r1
7009e8e0: d104         	bne	0x7009e8ec <Udma_eventAllocResource+0x3c> @ imm = #0x8
7009e8e2: e7ff         	b	0x7009e8e4 <Udma_eventAllocResource+0x34> @ imm = #-0x2
7009e8e4: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
7009e8e8: 9007         	str	r0, [sp, #0x1c]
;         }
7009e8ea: e009         	b	0x7009e900 <Udma_eventAllocResource+0x50> @ imm = #0x12
;                 &drvHandle->iaRegs.pImapRegs->GEVI[eventHandle->globalEvent];
7009e8ec: 9809         	ldr	r0, [sp, #0x24]
7009e8ee: f8d0 00a0    	ldr.w	r0, [r0, #0xa0]
7009e8f2: 9908         	ldr	r1, [sp, #0x20]
7009e8f4: 6c8a         	ldr	r2, [r1, #0x48]
7009e8f6: eb00 00c2    	add.w	r0, r0, r2, lsl #3
;             eventHandle->pIaGeviRegs =
7009e8fa: f8c1 0090    	str.w	r0, [r1, #0x90]
7009e8fe: e7ff         	b	0x7009e900 <Udma_eventAllocResource+0x50> @ imm = #-0x2
;     }
7009e900: e7ff         	b	0x7009e902 <Udma_eventAllocResource+0x52> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e902: 9807         	ldr	r0, [sp, #0x1c]
7009e904: bb00         	cbnz	r0, 0x7009e948 <Udma_eventAllocResource+0x98> @ imm = #0x40
7009e906: e7ff         	b	0x7009e908 <Udma_eventAllocResource+0x58> @ imm = #-0x2
;         if((UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode) ||
7009e908: 9804         	ldr	r0, [sp, #0x10]
7009e90a: 6840         	ldr	r0, [r0, #0x4]
7009e90c: 2801         	cmp	r0, #0x1
7009e90e: d009         	beq	0x7009e924 <Udma_eventAllocResource+0x74> @ imm = #0x12
7009e910: e7ff         	b	0x7009e912 <Udma_eventAllocResource+0x62> @ imm = #-0x2
;             ((UDMA_EVENT_MODE_SHARED == eventPrms->eventMode) &&
7009e912: 9804         	ldr	r0, [sp, #0x10]
7009e914: 6840         	ldr	r0, [r0, #0x4]
7009e916: 2802         	cmp	r0, #0x2
7009e918: d115         	bne	0x7009e946 <Udma_eventAllocResource+0x96> @ imm = #0x2a
7009e91a: e7ff         	b	0x7009e91c <Udma_eventAllocResource+0x6c> @ imm = #-0x2
;                 (NULL_PTR == eventPrms->controllerEventHandle)))
7009e91c: 9804         	ldr	r0, [sp, #0x10]
7009e91e: 6900         	ldr	r0, [r0, #0x10]
;         if((UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode) ||
7009e920: b988         	cbnz	r0, 0x7009e946 <Udma_eventAllocResource+0x96> @ imm = #0x22
7009e922: e7ff         	b	0x7009e924 <Udma_eventAllocResource+0x74> @ imm = #-0x2
;             eventHandle->vintrNum = Udma_rmAllocVintr(drvHandle);
7009e924: 9809         	ldr	r0, [sp, #0x24]
7009e926: f00a f85b    	bl	0x700a89e0 <Udma_rmAllocVintr> @ imm = #0xa0b6
7009e92a: 9908         	ldr	r1, [sp, #0x20]
7009e92c: 64c8         	str	r0, [r1, #0x4c]
;             if(UDMA_EVENT_INVALID == eventHandle->vintrNum)
7009e92e: 9808         	ldr	r0, [sp, #0x20]
7009e930: 6cc0         	ldr	r0, [r0, #0x4c]
7009e932: f64f 71ff    	movw	r1, #0xffff
7009e936: 4288         	cmp	r0, r1
7009e938: d104         	bne	0x7009e944 <Udma_eventAllocResource+0x94> @ imm = #0x8
7009e93a: e7ff         	b	0x7009e93c <Udma_eventAllocResource+0x8c> @ imm = #-0x2
7009e93c: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009e940: 9007         	str	r0, [sp, #0x1c]
;             }
7009e942: e7ff         	b	0x7009e944 <Udma_eventAllocResource+0x94> @ imm = #-0x2
;         }
7009e944: e7ff         	b	0x7009e946 <Udma_eventAllocResource+0x96> @ imm = #-0x2
;     }
7009e946: e7ff         	b	0x7009e948 <Udma_eventAllocResource+0x98> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e948: 9807         	ldr	r0, [sp, #0x1c]
7009e94a: b9b8         	cbnz	r0, 0x7009e97c <Udma_eventAllocResource+0xcc> @ imm = #0x2e
7009e94c: e7ff         	b	0x7009e94e <Udma_eventAllocResource+0x9e> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009e94e: 9804         	ldr	r0, [sp, #0x10]
7009e950: 6800         	ldr	r0, [r0]
7009e952: 2805         	cmp	r0, #0x5
7009e954: d011         	beq	0x7009e97a <Udma_eventAllocResource+0xca> @ imm = #0x22
7009e956: e7ff         	b	0x7009e958 <Udma_eventAllocResource+0xa8> @ imm = #-0x2
;             eventHandle->vintrBitNum = Udma_rmAllocVintrBit(eventHandle);
7009e958: 9808         	ldr	r0, [sp, #0x20]
7009e95a: f007 ff61    	bl	0x700a6820 <Udma_rmAllocVintrBit> @ imm = #0x7ec2
7009e95e: 9908         	ldr	r1, [sp, #0x20]
7009e960: 6508         	str	r0, [r1, #0x50]
;             if(UDMA_EVENT_INVALID == eventHandle->vintrBitNum)
7009e962: 9808         	ldr	r0, [sp, #0x20]
7009e964: 6d00         	ldr	r0, [r0, #0x50]
7009e966: f64f 71ff    	movw	r1, #0xffff
7009e96a: 4288         	cmp	r0, r1
7009e96c: d104         	bne	0x7009e978 <Udma_eventAllocResource+0xc8> @ imm = #0x8
7009e96e: e7ff         	b	0x7009e970 <Udma_eventAllocResource+0xc0> @ imm = #-0x2
7009e970: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009e974: 9007         	str	r0, [sp, #0x1c]
;             }
7009e976: e7ff         	b	0x7009e978 <Udma_eventAllocResource+0xc8> @ imm = #-0x2
;         }
7009e978: e7ff         	b	0x7009e97a <Udma_eventAllocResource+0xca> @ imm = #-0x2
;     }
7009e97a: e7ff         	b	0x7009e97c <Udma_eventAllocResource+0xcc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e97c: 9807         	ldr	r0, [sp, #0x1c]
7009e97e: 2800         	cmp	r0, #0x0
7009e980: d146         	bne	0x7009ea10 <Udma_eventAllocResource+0x160> @ imm = #0x8c
7009e982: e7ff         	b	0x7009e984 <Udma_eventAllocResource+0xd4> @ imm = #-0x2
;         if((((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
7009e984: 9804         	ldr	r0, [sp, #0x10]
7009e986: 6940         	ldr	r0, [r0, #0x14]
7009e988: b120         	cbz	r0, 0x7009e994 <Udma_eventAllocResource+0xe4> @ imm = #0x8
7009e98a: e7ff         	b	0x7009e98c <Udma_eventAllocResource+0xdc> @ imm = #-0x2
;                 (NULL_PTR == eventPrms->controllerEventHandle)) ||
7009e98c: 9804         	ldr	r0, [sp, #0x10]
7009e98e: 6900         	ldr	r0, [r0, #0x10]
7009e990: b128         	cbz	r0, 0x7009e99e <Udma_eventAllocResource+0xee> @ imm = #0xa
7009e992: e7ff         	b	0x7009e994 <Udma_eventAllocResource+0xe4> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009e994: 9804         	ldr	r0, [sp, #0x10]
7009e996: 6800         	ldr	r0, [r0]
;         if((((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
7009e998: 2805         	cmp	r0, #0x5
7009e99a: d138         	bne	0x7009ea0e <Udma_eventAllocResource+0x15e> @ imm = #0x70
7009e99c: e7ff         	b	0x7009e99e <Udma_eventAllocResource+0xee> @ imm = #-0x2
;             if(UDMA_CORE_INTR_ANY != eventPrms->preferredCoreIntrNum)
7009e99e: 9804         	ldr	r0, [sp, #0x10]
7009e9a0: 6a00         	ldr	r0, [r0, #0x20]
7009e9a2: 2101         	movs	r1, #0x1
7009e9a4: f6cf 71ff    	movt	r1, #0xffff
7009e9a8: 4288         	cmp	r0, r1
7009e9aa: d007         	beq	0x7009e9bc <Udma_eventAllocResource+0x10c> @ imm = #0xe
7009e9ac: e7ff         	b	0x7009e9ae <Udma_eventAllocResource+0xfe> @ imm = #-0x2
;                 preferredIrIntrNum = Udma_rmTranslateCoreIntrInput(drvHandle, eventPrms->preferredCoreIntrNum);
7009e9ae: 9809         	ldr	r0, [sp, #0x24]
7009e9b0: 9904         	ldr	r1, [sp, #0x10]
7009e9b2: 6a09         	ldr	r1, [r1, #0x20]
7009e9b4: f010 fb1c    	bl	0x700aeff0 <Udma_rmTranslateCoreIntrInput> @ imm = #0x10638
7009e9b8: 9005         	str	r0, [sp, #0x14]
;             }
7009e9ba: e003         	b	0x7009e9c4 <Udma_eventAllocResource+0x114> @ imm = #0x6
;                 preferredIrIntrNum = eventPrms->preferredCoreIntrNum;
7009e9bc: 9804         	ldr	r0, [sp, #0x10]
7009e9be: 6a00         	ldr	r0, [r0, #0x20]
7009e9c0: 9005         	str	r0, [sp, #0x14]
7009e9c2: e7ff         	b	0x7009e9c4 <Udma_eventAllocResource+0x114> @ imm = #-0x2
;             if(UDMA_INTR_INVALID != preferredIrIntrNum)
7009e9c4: 9805         	ldr	r0, [sp, #0x14]
7009e9c6: f510 3f80    	cmn.w	r0, #0x10000
7009e9ca: d015         	beq	0x7009e9f8 <Udma_eventAllocResource+0x148> @ imm = #0x2a
7009e9cc: e7ff         	b	0x7009e9ce <Udma_eventAllocResource+0x11e> @ imm = #-0x2
;                     Udma_rmAllocIrIntr(preferredIrIntrNum, drvHandle);
7009e9ce: 9805         	ldr	r0, [sp, #0x14]
7009e9d0: 9909         	ldr	r1, [sp, #0x24]
7009e9d2: f004 faf5    	bl	0x700a2fc0 <Udma_rmAllocIrIntr> @ imm = #0x45ea
;                 eventHandle->irIntrNum =
7009e9d6: 9908         	ldr	r1, [sp, #0x20]
7009e9d8: 6548         	str	r0, [r1, #0x54]
;                 if(UDMA_INTR_INVALID != eventHandle->irIntrNum)
7009e9da: 9808         	ldr	r0, [sp, #0x20]
7009e9dc: 6d40         	ldr	r0, [r0, #0x54]
7009e9de: f510 3f80    	cmn.w	r0, #0x10000
7009e9e2: d008         	beq	0x7009e9f6 <Udma_eventAllocResource+0x146> @ imm = #0x10
7009e9e4: e7ff         	b	0x7009e9e6 <Udma_eventAllocResource+0x136> @ imm = #-0x2
;                     eventHandle->coreIntrNum = Udma_rmTranslateIrOutput(drvHandle, eventHandle->irIntrNum);
7009e9e6: 9809         	ldr	r0, [sp, #0x24]
7009e9e8: 9908         	ldr	r1, [sp, #0x20]
7009e9ea: 6d49         	ldr	r1, [r1, #0x54]
7009e9ec: f010 fb18    	bl	0x700af020 <Udma_rmTranslateIrOutput> @ imm = #0x10630
7009e9f0: 9908         	ldr	r1, [sp, #0x20]
7009e9f2: 6588         	str	r0, [r1, #0x58]
;                 }
7009e9f4: e7ff         	b	0x7009e9f6 <Udma_eventAllocResource+0x146> @ imm = #-0x2
;             }
7009e9f6: e7ff         	b	0x7009e9f8 <Udma_eventAllocResource+0x148> @ imm = #-0x2
;             if(UDMA_INTR_INVALID == eventHandle->coreIntrNum)
7009e9f8: 9808         	ldr	r0, [sp, #0x20]
7009e9fa: 6d80         	ldr	r0, [r0, #0x58]
7009e9fc: f510 3f80    	cmn.w	r0, #0x10000
7009ea00: d104         	bne	0x7009ea0c <Udma_eventAllocResource+0x15c> @ imm = #0x8
7009ea02: e7ff         	b	0x7009ea04 <Udma_eventAllocResource+0x154> @ imm = #-0x2
7009ea04: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009ea08: 9007         	str	r0, [sp, #0x1c]
;             }
7009ea0a: e7ff         	b	0x7009ea0c <Udma_eventAllocResource+0x15c> @ imm = #-0x2
;         }
7009ea0c: e7ff         	b	0x7009ea0e <Udma_eventAllocResource+0x15e> @ imm = #-0x2
;     }
7009ea0e: e7ff         	b	0x7009ea10 <Udma_eventAllocResource+0x160> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ea10: 9807         	ldr	r0, [sp, #0x1c]
7009ea12: bb18         	cbnz	r0, 0x7009ea5c <Udma_eventAllocResource+0x1ac> @ imm = #0x46
7009ea14: e7ff         	b	0x7009ea16 <Udma_eventAllocResource+0x166> @ imm = #-0x2
;         cookie = HwiP_disable();
7009ea16: f011 ee24    	blx	0x700b0660 <HwiP_disable> @ imm = #0x11c48
7009ea1a: 9002         	str	r0, [sp, #0x8]
;         eventHandle->prevEvent = (Udma_EventHandleInt) NULL_PTR;
7009ea1c: 9908         	ldr	r1, [sp, #0x20]
7009ea1e: 2000         	movs	r0, #0x0
7009ea20: 6608         	str	r0, [r1, #0x60]
;         eventHandle->nextEvent = (Udma_EventHandleInt) NULL_PTR;
7009ea22: 9908         	ldr	r1, [sp, #0x20]
7009ea24: 65c8         	str	r0, [r1, #0x5c]
;         if(NULL_PTR != eventPrms->controllerEventHandle)
7009ea26: 9804         	ldr	r0, [sp, #0x10]
7009ea28: 6900         	ldr	r0, [r0, #0x10]
7009ea2a: b198         	cbz	r0, 0x7009ea54 <Udma_eventAllocResource+0x1a4> @ imm = #0x26
7009ea2c: e7ff         	b	0x7009ea2e <Udma_eventAllocResource+0x17e> @ imm = #-0x2
;             lastEvent = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
7009ea2e: 9804         	ldr	r0, [sp, #0x10]
7009ea30: 6900         	ldr	r0, [r0, #0x10]
7009ea32: 9003         	str	r0, [sp, #0xc]
;             while(NULL_PTR != lastEvent->nextEvent)
7009ea34: e7ff         	b	0x7009ea36 <Udma_eventAllocResource+0x186> @ imm = #-0x2
7009ea36: 9803         	ldr	r0, [sp, #0xc]
7009ea38: 6dc0         	ldr	r0, [r0, #0x5c]
7009ea3a: b120         	cbz	r0, 0x7009ea46 <Udma_eventAllocResource+0x196> @ imm = #0x8
7009ea3c: e7ff         	b	0x7009ea3e <Udma_eventAllocResource+0x18e> @ imm = #-0x2
;                 lastEvent = lastEvent->nextEvent;
7009ea3e: 9803         	ldr	r0, [sp, #0xc]
7009ea40: 6dc0         	ldr	r0, [r0, #0x5c]
7009ea42: 9003         	str	r0, [sp, #0xc]
;             while(NULL_PTR != lastEvent->nextEvent)
7009ea44: e7f7         	b	0x7009ea36 <Udma_eventAllocResource+0x186> @ imm = #-0x12
;             eventHandle->prevEvent = lastEvent;
7009ea46: 9803         	ldr	r0, [sp, #0xc]
7009ea48: 9908         	ldr	r1, [sp, #0x20]
7009ea4a: 6608         	str	r0, [r1, #0x60]
;             lastEvent->nextEvent   = eventHandle;
7009ea4c: 9808         	ldr	r0, [sp, #0x20]
7009ea4e: 9903         	ldr	r1, [sp, #0xc]
7009ea50: 65c8         	str	r0, [r1, #0x5c]
;         }
7009ea52: e7ff         	b	0x7009ea54 <Udma_eventAllocResource+0x1a4> @ imm = #-0x2
;         HwiP_restore(cookie);
7009ea54: 9802         	ldr	r0, [sp, #0x8]
7009ea56: f011 ee24    	blx	0x700b06a0 <HwiP_restore> @ imm = #0x11c48
;     }
7009ea5a: e7ff         	b	0x7009ea5c <Udma_eventAllocResource+0x1ac> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ea5c: 9807         	ldr	r0, [sp, #0x1c]
7009ea5e: b9a0         	cbnz	r0, 0x7009ea8a <Udma_eventAllocResource+0x1da> @ imm = #0x28
7009ea60: e7ff         	b	0x7009ea62 <Udma_eventAllocResource+0x1b2> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009ea62: 9804         	ldr	r0, [sp, #0x10]
7009ea64: 6800         	ldr	r0, [r0]
7009ea66: 2803         	cmp	r0, #0x3
7009ea68: d10e         	bne	0x7009ea88 <Udma_eventAllocResource+0x1d8> @ imm = #0x1c
7009ea6a: e7ff         	b	0x7009ea6c <Udma_eventAllocResource+0x1bc> @ imm = #-0x2
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009ea6c: 9804         	ldr	r0, [sp, #0x10]
7009ea6e: 6880         	ldr	r0, [r0, #0x8]
7009ea70: 9001         	str	r0, [sp, #0x4]
;             if(TRUE == chHandle->chOesAllocDone)
7009ea72: 9801         	ldr	r0, [sp, #0x4]
7009ea74: f8d0 0248    	ldr.w	r0, [r0, #0x248]
7009ea78: 2801         	cmp	r0, #0x1
7009ea7a: d104         	bne	0x7009ea86 <Udma_eventAllocResource+0x1d6> @ imm = #0x8
7009ea7c: e7ff         	b	0x7009ea7e <Udma_eventAllocResource+0x1ce> @ imm = #-0x2
7009ea7e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009ea82: 9007         	str	r0, [sp, #0x1c]
;             }
7009ea84: e7ff         	b	0x7009ea86 <Udma_eventAllocResource+0x1d6> @ imm = #-0x2
;         }
7009ea86: e7ff         	b	0x7009ea88 <Udma_eventAllocResource+0x1d8> @ imm = #-0x2
;     }
7009ea88: e7ff         	b	0x7009ea8a <Udma_eventAllocResource+0x1da> @ imm = #-0x2
;     if(UDMA_SOK != retVal)
7009ea8a: 9807         	ldr	r0, [sp, #0x1c]
7009ea8c: b128         	cbz	r0, 0x7009ea9a <Udma_eventAllocResource+0x1ea> @ imm = #0xa
7009ea8e: e7ff         	b	0x7009ea90 <Udma_eventAllocResource+0x1e0> @ imm = #-0x2
;         Udma_eventFreeResource(drvHandle, eventHandle);
7009ea90: 9809         	ldr	r0, [sp, #0x24]
7009ea92: 9908         	ldr	r1, [sp, #0x20]
7009ea94: f006 ffac    	bl	0x700a59f0 <Udma_eventFreeResource> @ imm = #0x6f58
;     }
7009ea98: e016         	b	0x7009eac8 <Udma_eventAllocResource+0x218> @ imm = #0x2c
;         if(NULL_PTR == eventPrms->controllerEventHandle)
7009ea9a: 9804         	ldr	r0, [sp, #0x10]
7009ea9c: 6900         	ldr	r0, [r0, #0x10]
7009ea9e: b920         	cbnz	r0, 0x7009eaaa <Udma_eventAllocResource+0x1fa> @ imm = #0x8
7009eaa0: e7ff         	b	0x7009eaa2 <Udma_eventAllocResource+0x1f2> @ imm = #-0x2
;             vintrNum = eventHandle->vintrNum;
7009eaa2: 9808         	ldr	r0, [sp, #0x20]
7009eaa4: 6cc0         	ldr	r0, [r0, #0x4c]
7009eaa6: 9006         	str	r0, [sp, #0x18]
;         }
7009eaa8: e004         	b	0x7009eab4 <Udma_eventAllocResource+0x204> @ imm = #0x8
;             vintrNum = ((Udma_EventHandleInt) (eventPrms->controllerEventHandle))->vintrNum;
7009eaaa: 9804         	ldr	r0, [sp, #0x10]
7009eaac: 6900         	ldr	r0, [r0, #0x10]
7009eaae: 6cc0         	ldr	r0, [r0, #0x4c]
7009eab0: 9006         	str	r0, [sp, #0x18]
7009eab2: e7ff         	b	0x7009eab4 <Udma_eventAllocResource+0x204> @ imm = #-0x2
;         eventHandle->pIaVintrRegs = &drvHandle->iaRegs.pIntrRegs->VINT[vintrNum];
7009eab4: 9809         	ldr	r0, [sp, #0x24]
7009eab6: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
7009eaba: 9906         	ldr	r1, [sp, #0x18]
7009eabc: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009eac0: 9908         	ldr	r1, [sp, #0x20]
7009eac2: f8c1 0094    	str.w	r0, [r1, #0x94]
7009eac6: e7ff         	b	0x7009eac8 <Udma_eventAllocResource+0x218> @ imm = #-0x2
;     return (retVal);
7009eac8: 9807         	ldr	r0, [sp, #0x1c]
7009eaca: b00a         	add	sp, #0x28
7009eacc: bd80         	pop	{r7, pc}
7009eace: 0000         	movs	r0, r0

7009ead0 <Udma_chFreeResource>:
; {
7009ead0: b580         	push	{r7, lr}
7009ead2: b084         	sub	sp, #0x10
7009ead4: 9003         	str	r0, [sp, #0xc]
7009ead6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009ead8: 9002         	str	r0, [sp, #0x8]
;     drvHandle = chHandle->drvHandle;
7009eada: 9803         	ldr	r0, [sp, #0xc]
7009eadc: 6e80         	ldr	r0, [r0, #0x68]
7009eade: 9001         	str	r0, [sp, #0x4]
;     if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009eae0: 9803         	ldr	r0, [sp, #0xc]
7009eae2: 7800         	ldrb	r0, [r0]
7009eae4: 0740         	lsls	r0, r0, #0x1d
7009eae6: 2800         	cmp	r0, #0x0
7009eae8: d52e         	bpl	0x7009eb48 <Udma_chFreeResource+0x78> @ imm = #0x5c
7009eaea: e7ff         	b	0x7009eaec <Udma_chFreeResource+0x1c> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID != chHandle->txChNum)
7009eaec: 9803         	ldr	r0, [sp, #0xc]
7009eaee: 6ec0         	ldr	r0, [r0, #0x6c]
7009eaf0: f510 3f80    	cmn.w	r0, #0x10000
7009eaf4: d027         	beq	0x7009eb46 <Udma_chFreeResource+0x76> @ imm = #0x4e
7009eaf6: e7ff         	b	0x7009eaf8 <Udma_chFreeResource+0x28> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009eaf8: 9803         	ldr	r0, [sp, #0xc]
7009eafa: 7800         	ldrb	r0, [r0]
7009eafc: 0640         	lsls	r0, r0, #0x19
7009eafe: 2800         	cmp	r0, #0x0
7009eb00: d506         	bpl	0x7009eb10 <Udma_chFreeResource+0x40> @ imm = #0xc
7009eb02: e7ff         	b	0x7009eb04 <Udma_chFreeResource+0x34> @ imm = #-0x2
;                 Udma_rmFreeBlkCopyHcCh(chHandle->txChNum, drvHandle);
7009eb04: 9803         	ldr	r0, [sp, #0xc]
7009eb06: 6ec0         	ldr	r0, [r0, #0x6c]
7009eb08: 9901         	ldr	r1, [sp, #0x4]
7009eb0a: f00d f971    	bl	0x700abdf0 <Udma_rmFreeBlkCopyHcCh> @ imm = #0xd2e2
;             }
7009eb0e: e012         	b	0x7009eb36 <Udma_chFreeResource+0x66> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009eb10: 9803         	ldr	r0, [sp, #0xc]
7009eb12: 7800         	ldrb	r0, [r0]
7009eb14: 0600         	lsls	r0, r0, #0x18
7009eb16: 2800         	cmp	r0, #0x0
7009eb18: d506         	bpl	0x7009eb28 <Udma_chFreeResource+0x58> @ imm = #0xc
7009eb1a: e7ff         	b	0x7009eb1c <Udma_chFreeResource+0x4c> @ imm = #-0x2
;                 Udma_rmFreeBlkCopyUhcCh(chHandle->txChNum, drvHandle);
7009eb1c: 9803         	ldr	r0, [sp, #0xc]
7009eb1e: 6ec0         	ldr	r0, [r0, #0x6c]
7009eb20: 9901         	ldr	r1, [sp, #0x4]
7009eb22: f00d f99d    	bl	0x700abe60 <Udma_rmFreeBlkCopyUhcCh> @ imm = #0xd33a
;             }
7009eb26: e005         	b	0x7009eb34 <Udma_chFreeResource+0x64> @ imm = #0xa
;                 Udma_rmFreeBlkCopyCh(chHandle->txChNum, drvHandle);
7009eb28: 9803         	ldr	r0, [sp, #0xc]
7009eb2a: 6ec0         	ldr	r0, [r0, #0x6c]
7009eb2c: 9901         	ldr	r1, [sp, #0x4]
7009eb2e: f00d f927    	bl	0x700abd80 <Udma_rmFreeBlkCopyCh> @ imm = #0xd24e
7009eb32: e7ff         	b	0x7009eb34 <Udma_chFreeResource+0x64> @ imm = #-0x2
7009eb34: e7ff         	b	0x7009eb36 <Udma_chFreeResource+0x66> @ imm = #-0x2
;             chHandle->txChNum = UDMA_DMA_CH_INVALID;
7009eb36: 9903         	ldr	r1, [sp, #0xc]
7009eb38: 2000         	movs	r0, #0x0
7009eb3a: f6cf 70ff    	movt	r0, #0xffff
7009eb3e: 66c8         	str	r0, [r1, #0x6c]
;             chHandle->rxChNum = UDMA_DMA_CH_INVALID;
7009eb40: 9903         	ldr	r1, [sp, #0xc]
7009eb42: 6708         	str	r0, [r1, #0x70]
;         }
7009eb44: e7ff         	b	0x7009eb46 <Udma_chFreeResource+0x76> @ imm = #-0x2
;     }
7009eb46: e084         	b	0x7009ec52 <Udma_chFreeResource+0x182> @ imm = #0x108
;         if(UDMA_DMA_CH_INVALID != chHandle->txChNum)
7009eb48: 9803         	ldr	r0, [sp, #0xc]
7009eb4a: 6ec0         	ldr	r0, [r0, #0x6c]
7009eb4c: f510 3f80    	cmn.w	r0, #0x10000
7009eb50: d032         	beq	0x7009ebb8 <Udma_chFreeResource+0xe8> @ imm = #0x64
7009eb52: e7ff         	b	0x7009eb54 <Udma_chFreeResource+0x84> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009eb54: 9803         	ldr	r0, [sp, #0xc]
7009eb56: 7800         	ldrb	r0, [r0]
7009eb58: 0640         	lsls	r0, r0, #0x19
7009eb5a: 2800         	cmp	r0, #0x0
7009eb5c: d506         	bpl	0x7009eb6c <Udma_chFreeResource+0x9c> @ imm = #0xc
7009eb5e: e7ff         	b	0x7009eb60 <Udma_chFreeResource+0x90> @ imm = #-0x2
;                 Udma_rmFreeTxHcCh(chHandle->txChNum, drvHandle);
7009eb60: 9803         	ldr	r0, [sp, #0xc]
7009eb62: 6ec0         	ldr	r0, [r0, #0x6c]
7009eb64: 9901         	ldr	r1, [sp, #0x4]
7009eb66: f00d fa93    	bl	0x700ac090 <Udma_rmFreeTxHcCh> @ imm = #0xd526
;             }
7009eb6a: e01f         	b	0x7009ebac <Udma_chFreeResource+0xdc> @ imm = #0x3e
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009eb6c: 9803         	ldr	r0, [sp, #0xc]
7009eb6e: 7840         	ldrb	r0, [r0, #0x1]
7009eb70: 07c0         	lsls	r0, r0, #0x1f
7009eb72: b138         	cbz	r0, 0x7009eb84 <Udma_chFreeResource+0xb4> @ imm = #0xe
7009eb74: e7ff         	b	0x7009eb76 <Udma_chFreeResource+0xa6> @ imm = #-0x2
;                 Udma_rmFreeMappedTxCh(chHandle->txChNum, drvHandle, chHandle->chPrms.mappedChGrp);
7009eb76: 9803         	ldr	r0, [sp, #0xc]
7009eb78: 68c2         	ldr	r2, [r0, #0xc]
7009eb7a: 6ec0         	ldr	r0, [r0, #0x6c]
7009eb7c: 9901         	ldr	r1, [sp, #0x4]
7009eb7e: f00c fbbf    	bl	0x700ab300 <Udma_rmFreeMappedTxCh> @ imm = #0xc77e
;             }
7009eb82: e012         	b	0x7009ebaa <Udma_chFreeResource+0xda> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009eb84: 9803         	ldr	r0, [sp, #0xc]
7009eb86: 7800         	ldrb	r0, [r0]
7009eb88: 0600         	lsls	r0, r0, #0x18
7009eb8a: 2800         	cmp	r0, #0x0
7009eb8c: d506         	bpl	0x7009eb9c <Udma_chFreeResource+0xcc> @ imm = #0xc
7009eb8e: e7ff         	b	0x7009eb90 <Udma_chFreeResource+0xc0> @ imm = #-0x2
;                 Udma_rmFreeTxUhcCh(chHandle->txChNum, drvHandle);
7009eb90: 9803         	ldr	r0, [sp, #0xc]
7009eb92: 6ec0         	ldr	r0, [r0, #0x6c]
7009eb94: 9901         	ldr	r1, [sp, #0x4]
7009eb96: f00d fab3    	bl	0x700ac100 <Udma_rmFreeTxUhcCh> @ imm = #0xd566
;             }
7009eb9a: e005         	b	0x7009eba8 <Udma_chFreeResource+0xd8> @ imm = #0xa
;                 Udma_rmFreeTxCh(chHandle->txChNum, drvHandle);
7009eb9c: 9803         	ldr	r0, [sp, #0xc]
7009eb9e: 6ec0         	ldr	r0, [r0, #0x6c]
7009eba0: 9901         	ldr	r1, [sp, #0x4]
7009eba2: f00d fa3d    	bl	0x700ac020 <Udma_rmFreeTxCh> @ imm = #0xd47a
7009eba6: e7ff         	b	0x7009eba8 <Udma_chFreeResource+0xd8> @ imm = #-0x2
7009eba8: e7ff         	b	0x7009ebaa <Udma_chFreeResource+0xda> @ imm = #-0x2
7009ebaa: e7ff         	b	0x7009ebac <Udma_chFreeResource+0xdc> @ imm = #-0x2
;             chHandle->txChNum = UDMA_DMA_CH_INVALID;
7009ebac: 9903         	ldr	r1, [sp, #0xc]
7009ebae: 2000         	movs	r0, #0x0
7009ebb0: f6cf 70ff    	movt	r0, #0xffff
7009ebb4: 66c8         	str	r0, [r1, #0x6c]
;         }
7009ebb6: e7ff         	b	0x7009ebb8 <Udma_chFreeResource+0xe8> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID != chHandle->rxChNum)
7009ebb8: 9803         	ldr	r0, [sp, #0xc]
7009ebba: 6f00         	ldr	r0, [r0, #0x70]
7009ebbc: f510 3f80    	cmn.w	r0, #0x10000
7009ebc0: d033         	beq	0x7009ec2a <Udma_chFreeResource+0x15a> @ imm = #0x66
7009ebc2: e7ff         	b	0x7009ebc4 <Udma_chFreeResource+0xf4> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009ebc4: 9803         	ldr	r0, [sp, #0xc]
7009ebc6: 7800         	ldrb	r0, [r0]
7009ebc8: 0640         	lsls	r0, r0, #0x19
7009ebca: 2800         	cmp	r0, #0x0
7009ebcc: d506         	bpl	0x7009ebdc <Udma_chFreeResource+0x10c> @ imm = #0xc
7009ebce: e7ff         	b	0x7009ebd0 <Udma_chFreeResource+0x100> @ imm = #-0x2
;                 Udma_rmFreeRxHcCh(chHandle->rxChNum, drvHandle);
7009ebd0: 9803         	ldr	r0, [sp, #0xc]
7009ebd2: 6f00         	ldr	r0, [r0, #0x70]
7009ebd4: 9901         	ldr	r1, [sp, #0x4]
7009ebd6: f00d f9b3    	bl	0x700abf40 <Udma_rmFreeRxHcCh> @ imm = #0xd366
;             }
7009ebda: e020         	b	0x7009ec1e <Udma_chFreeResource+0x14e> @ imm = #0x40
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009ebdc: 9803         	ldr	r0, [sp, #0xc]
7009ebde: 7840         	ldrb	r0, [r0, #0x1]
7009ebe0: 07c0         	lsls	r0, r0, #0x1f
7009ebe2: b140         	cbz	r0, 0x7009ebf6 <Udma_chFreeResource+0x126> @ imm = #0x10
7009ebe4: e7ff         	b	0x7009ebe6 <Udma_chFreeResource+0x116> @ imm = #-0x2
;                 Udma_rmFreeMappedRxCh(chHandle->rxChNum, drvHandle, chHandle->chPrms.mappedChGrp - UDMA_NUM_MAPPED_TX_GROUP);
7009ebe6: 9803         	ldr	r0, [sp, #0xc]
7009ebe8: 68c2         	ldr	r2, [r0, #0xc]
7009ebea: 6f00         	ldr	r0, [r0, #0x70]
7009ebec: 9901         	ldr	r1, [sp, #0x4]
7009ebee: 3a04         	subs	r2, #0x4
7009ebf0: f00c fb4e    	bl	0x700ab290 <Udma_rmFreeMappedRxCh> @ imm = #0xc69c
;             }
7009ebf4: e012         	b	0x7009ec1c <Udma_chFreeResource+0x14c> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009ebf6: 9803         	ldr	r0, [sp, #0xc]
7009ebf8: 7800         	ldrb	r0, [r0]
7009ebfa: 0600         	lsls	r0, r0, #0x18
7009ebfc: 2800         	cmp	r0, #0x0
7009ebfe: d506         	bpl	0x7009ec0e <Udma_chFreeResource+0x13e> @ imm = #0xc
7009ec00: e7ff         	b	0x7009ec02 <Udma_chFreeResource+0x132> @ imm = #-0x2
;                 Udma_rmFreeRxUhcCh(chHandle->rxChNum, drvHandle);
7009ec02: 9803         	ldr	r0, [sp, #0xc]
7009ec04: 6f00         	ldr	r0, [r0, #0x70]
7009ec06: 9901         	ldr	r1, [sp, #0x4]
7009ec08: f00d f9d2    	bl	0x700abfb0 <Udma_rmFreeRxUhcCh> @ imm = #0xd3a4
;             }
7009ec0c: e005         	b	0x7009ec1a <Udma_chFreeResource+0x14a> @ imm = #0xa
;                 Udma_rmFreeRxCh(chHandle->rxChNum, drvHandle);
7009ec0e: 9803         	ldr	r0, [sp, #0xc]
7009ec10: 6f00         	ldr	r0, [r0, #0x70]
7009ec12: 9901         	ldr	r1, [sp, #0x4]
7009ec14: f00d f95c    	bl	0x700abed0 <Udma_rmFreeRxCh> @ imm = #0xd2b8
7009ec18: e7ff         	b	0x7009ec1a <Udma_chFreeResource+0x14a> @ imm = #-0x2
7009ec1a: e7ff         	b	0x7009ec1c <Udma_chFreeResource+0x14c> @ imm = #-0x2
7009ec1c: e7ff         	b	0x7009ec1e <Udma_chFreeResource+0x14e> @ imm = #-0x2
;             chHandle->rxChNum = UDMA_DMA_CH_INVALID;
7009ec1e: 9903         	ldr	r1, [sp, #0xc]
7009ec20: 2000         	movs	r0, #0x0
7009ec22: f6cf 70ff    	movt	r0, #0xffff
7009ec26: 6708         	str	r0, [r1, #0x70]
;         }
7009ec28: e7ff         	b	0x7009ec2a <Udma_chFreeResource+0x15a> @ imm = #-0x2
;         chHandle->defaultFlowObj.drvHandle    = (Udma_DrvHandleInt) NULL_PTR;
7009ec2a: 9903         	ldr	r1, [sp, #0xc]
7009ec2c: 2000         	movs	r0, #0x0
7009ec2e: f8c1 01cc    	str.w	r0, [r1, #0x1cc]
;         chHandle->defaultFlowObj.flowStart    = UDMA_FLOW_INVALID;
7009ec32: 9a03         	ldr	r2, [sp, #0xc]
7009ec34: 2100         	movs	r1, #0x0
7009ec36: f6cf 71ff    	movt	r1, #0xffff
7009ec3a: f8c2 11d0    	str.w	r1, [r2, #0x1d0]
;         chHandle->defaultFlowObj.flowCnt      = 0U;
7009ec3e: 9903         	ldr	r1, [sp, #0xc]
7009ec40: f8c1 01d4    	str.w	r0, [r1, #0x1d4]
;         chHandle->defaultFlowObj.flowInitDone = UDMA_DEINIT_DONE;
7009ec44: 9903         	ldr	r1, [sp, #0xc]
7009ec46: f8c1 01d8    	str.w	r0, [r1, #0x1d8]
;         chHandle->defaultFlow                 = (Udma_FlowHandleInt) NULL_PTR;
7009ec4a: 9903         	ldr	r1, [sp, #0xc]
7009ec4c: f8c1 01c8    	str.w	r0, [r1, #0x1c8]
7009ec50: e7ff         	b	0x7009ec52 <Udma_chFreeResource+0x182> @ imm = #-0x2
;     chHandle->pdmaChNum = UDMA_DMA_CH_INVALID;
7009ec52: 9903         	ldr	r1, [sp, #0xc]
7009ec54: 2000         	movs	r0, #0x0
7009ec56: f6cf 70ff    	movt	r0, #0xffff
7009ec5a: 6788         	str	r0, [r1, #0x78]
;     chHandle->peerThreadId = UDMA_THREAD_ID_INVALID;
7009ec5c: 9903         	ldr	r1, [sp, #0xc]
7009ec5e: 2004         	movs	r0, #0x4
7009ec60: f6cf 70ff    	movt	r0, #0xffff
7009ec64: 67c8         	str	r0, [r1, #0x7c]
;     if(NULL_PTR != chHandle->fqRing)
7009ec66: 9803         	ldr	r0, [sp, #0xc]
7009ec68: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009ec6c: b190         	cbz	r0, 0x7009ec94 <Udma_chFreeResource+0x1c4> @ imm = #0x24
7009ec6e: e7ff         	b	0x7009ec70 <Udma_chFreeResource+0x1a0> @ imm = #-0x2
;         retVal += Udma_ringFree(chHandle->fqRing);
7009ec70: 9803         	ldr	r0, [sp, #0xc]
7009ec72: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009ec76: f008 f8ab    	bl	0x700a6dd0 <Udma_ringFree> @ imm = #0x8156
7009ec7a: 4601         	mov	r1, r0
7009ec7c: 9802         	ldr	r0, [sp, #0x8]
7009ec7e: 4408         	add	r0, r1
7009ec80: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
7009ec82: 9802         	ldr	r0, [sp, #0x8]
7009ec84: b108         	cbz	r0, 0x7009ec8a <Udma_chFreeResource+0x1ba> @ imm = #0x2
7009ec86: e7ff         	b	0x7009ec88 <Udma_chFreeResource+0x1b8> @ imm = #-0x2
;         }
7009ec88: e7ff         	b	0x7009ec8a <Udma_chFreeResource+0x1ba> @ imm = #-0x2
;         chHandle->fqRing = (Udma_RingHandleInt) NULL_PTR;
7009ec8a: 9903         	ldr	r1, [sp, #0xc]
7009ec8c: 2000         	movs	r0, #0x0
7009ec8e: f8c1 0080    	str.w	r0, [r1, #0x80]
;     }
7009ec92: e7ff         	b	0x7009ec94 <Udma_chFreeResource+0x1c4> @ imm = #-0x2
;     if(NULL_PTR != chHandle->cqRing)
7009ec94: 9803         	ldr	r0, [sp, #0xc]
7009ec96: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009ec9a: b128         	cbz	r0, 0x7009eca8 <Udma_chFreeResource+0x1d8> @ imm = #0xa
7009ec9c: e7ff         	b	0x7009ec9e <Udma_chFreeResource+0x1ce> @ imm = #-0x2
;         chHandle->cqRing = (Udma_RingHandleInt) NULL_PTR;
7009ec9e: 9903         	ldr	r1, [sp, #0xc]
7009eca0: 2000         	movs	r0, #0x0
7009eca2: f8c1 0084    	str.w	r0, [r1, #0x84]
;     }
7009eca6: e7ff         	b	0x7009eca8 <Udma_chFreeResource+0x1d8> @ imm = #-0x2
;     if(NULL_PTR != chHandle->tdCqRing)
7009eca8: 9803         	ldr	r0, [sp, #0xc]
7009ecaa: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009ecae: b190         	cbz	r0, 0x7009ecd6 <Udma_chFreeResource+0x206> @ imm = #0x24
7009ecb0: e7ff         	b	0x7009ecb2 <Udma_chFreeResource+0x1e2> @ imm = #-0x2
;         retVal += Udma_ringFree(chHandle->tdCqRing);
7009ecb2: 9803         	ldr	r0, [sp, #0xc]
7009ecb4: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009ecb8: f008 f88a    	bl	0x700a6dd0 <Udma_ringFree> @ imm = #0x8114
7009ecbc: 4601         	mov	r1, r0
7009ecbe: 9802         	ldr	r0, [sp, #0x8]
7009ecc0: 4408         	add	r0, r1
7009ecc2: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
7009ecc4: 9802         	ldr	r0, [sp, #0x8]
7009ecc6: b108         	cbz	r0, 0x7009eccc <Udma_chFreeResource+0x1fc> @ imm = #0x2
7009ecc8: e7ff         	b	0x7009ecca <Udma_chFreeResource+0x1fa> @ imm = #-0x2
;         }
7009ecca: e7ff         	b	0x7009eccc <Udma_chFreeResource+0x1fc> @ imm = #-0x2
;         chHandle->tdCqRing = (Udma_RingHandleInt) NULL_PTR;
7009eccc: 9903         	ldr	r1, [sp, #0xc]
7009ecce: 2000         	movs	r0, #0x0
7009ecd0: f8c1 0088    	str.w	r0, [r1, #0x88]
;     }
7009ecd4: e7ff         	b	0x7009ecd6 <Udma_chFreeResource+0x206> @ imm = #-0x2
;     return (retVal);
7009ecd6: 9802         	ldr	r0, [sp, #0x8]
7009ecd8: b004         	add	sp, #0x10
7009ecda: bd80         	pop	{r7, pc}
7009ecdc: 0000         	movs	r0, r0
7009ecde: 0000         	movs	r0, r0

7009ece0 <Udma_ringAlloc>:
; {
7009ece0: b580         	push	{r7, lr}
7009ece2: b096         	sub	sp, #0x58
7009ece4: 9015         	str	r0, [sp, #0x54]
7009ece6: 9114         	str	r1, [sp, #0x50]
7009ece8: f8ad 204e    	strh.w	r2, [sp, #0x4e]
7009ecec: 9312         	str	r3, [sp, #0x48]
7009ecee: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009ecf0: 9011         	str	r0, [sp, #0x44]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009ecf2: 900d         	str	r0, [sp, #0x34]
;     Udma_DrvHandleInt   drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009ecf4: 9815         	ldr	r0, [sp, #0x54]
7009ecf6: 900c         	str	r0, [sp, #0x30]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
7009ecf8: 9814         	ldr	r0, [sp, #0x50]
7009ecfa: 900b         	str	r0, [sp, #0x2c]
;     if((NULL_PTR == drvHandleInt) ||
7009ecfc: 980c         	ldr	r0, [sp, #0x30]
7009ecfe: b130         	cbz	r0, 0x7009ed0e <Udma_ringAlloc+0x2e> @ imm = #0xc
7009ed00: e7ff         	b	0x7009ed02 <Udma_ringAlloc+0x22> @ imm = #-0x2
;        (NULL_PTR == ringHandleInt) ||
7009ed02: 980b         	ldr	r0, [sp, #0x2c]
7009ed04: b118         	cbz	r0, 0x7009ed0e <Udma_ringAlloc+0x2e> @ imm = #0x6
7009ed06: e7ff         	b	0x7009ed08 <Udma_ringAlloc+0x28> @ imm = #-0x2
;        (NULL_PTR == ringPrms))
7009ed08: 9812         	ldr	r0, [sp, #0x48]
;     if((NULL_PTR == drvHandleInt) ||
7009ed0a: b920         	cbnz	r0, 0x7009ed16 <Udma_ringAlloc+0x36> @ imm = #0x8
7009ed0c: e7ff         	b	0x7009ed0e <Udma_ringAlloc+0x2e> @ imm = #-0x2
7009ed0e: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009ed12: 9011         	str	r0, [sp, #0x44]
;     }
7009ed14: e7ff         	b	0x7009ed16 <Udma_ringAlloc+0x36> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ed16: 9811         	ldr	r0, [sp, #0x44]
7009ed18: b978         	cbnz	r0, 0x7009ed3a <Udma_ringAlloc+0x5a> @ imm = #0x1e
7009ed1a: e7ff         	b	0x7009ed1c <Udma_ringAlloc+0x3c> @ imm = #-0x2
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009ed1c: 980c         	ldr	r0, [sp, #0x30]
7009ed1e: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009ed22: f64a 31cd    	movw	r1, #0xabcd
7009ed26: f6ca 31dc    	movt	r1, #0xabdc
7009ed2a: 4288         	cmp	r0, r1
7009ed2c: d004         	beq	0x7009ed38 <Udma_ringAlloc+0x58> @ imm = #0x8
7009ed2e: e7ff         	b	0x7009ed30 <Udma_ringAlloc+0x50> @ imm = #-0x2
7009ed30: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009ed34: 9011         	str	r0, [sp, #0x44]
;         }
7009ed36: e7ff         	b	0x7009ed38 <Udma_ringAlloc+0x58> @ imm = #-0x2
;     }
7009ed38: e7ff         	b	0x7009ed3a <Udma_ringAlloc+0x5a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ed3a: 9811         	ldr	r0, [sp, #0x44]
7009ed3c: b930         	cbnz	r0, 0x7009ed4c <Udma_ringAlloc+0x6c> @ imm = #0xc
7009ed3e: e7ff         	b	0x7009ed40 <Udma_ringAlloc+0x60> @ imm = #-0x2
;         retVal = Udma_ringCheckParams(drvHandleInt, ringPrms);
7009ed40: 980c         	ldr	r0, [sp, #0x30]
7009ed42: 9912         	ldr	r1, [sp, #0x48]
7009ed44: f007 fea4    	bl	0x700a6a90 <Udma_ringCheckParams> @ imm = #0x7d48
7009ed48: 9011         	str	r0, [sp, #0x44]
;     }
7009ed4a: e7ff         	b	0x7009ed4c <Udma_ringAlloc+0x6c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ed4c: 9811         	ldr	r0, [sp, #0x44]
7009ed4e: 2800         	cmp	r0, #0x0
7009ed50: d140         	bne	0x7009edd4 <Udma_ringAlloc+0xf4> @ imm = #0x80
7009ed52: e7ff         	b	0x7009ed54 <Udma_ringAlloc+0x74> @ imm = #-0x2
;         if(UDMA_RING_ANY == ringNum)
7009ed54: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009ed58: f64f 71fe    	movw	r1, #0xfffe
7009ed5c: 4288         	cmp	r0, r1
7009ed5e: d126         	bne	0x7009edae <Udma_ringAlloc+0xce> @ imm = #0x4c
7009ed60: e7ff         	b	0x7009ed62 <Udma_ringAlloc+0x82> @ imm = #-0x2
;             if(UDMA_MAPPED_GROUP_INVALID == ringPrms->mappedRingGrp)
7009ed62: 9812         	ldr	r0, [sp, #0x48]
7009ed64: 6940         	ldr	r0, [r0, #0x14]
7009ed66: 2104         	movs	r1, #0x4
7009ed68: f6cf 71ff    	movt	r1, #0xffff
7009ed6c: 4288         	cmp	r0, r1
7009ed6e: d106         	bne	0x7009ed7e <Udma_ringAlloc+0x9e> @ imm = #0xc
7009ed70: e7ff         	b	0x7009ed72 <Udma_ringAlloc+0x92> @ imm = #-0x2
;                 ringHandleInt->ringNum = Udma_rmAllocFreeRing(drvHandleInt);
7009ed72: 980c         	ldr	r0, [sp, #0x30]
7009ed74: f010 fc84    	bl	0x700af680 <Udma_rmAllocFreeRing> @ imm = #0x10908
7009ed78: 990b         	ldr	r1, [sp, #0x2c]
7009ed7a: 8088         	strh	r0, [r1, #0x4]
;             }
7009ed7c: e008         	b	0x7009ed90 <Udma_ringAlloc+0xb0> @ imm = #0x10
;                 ringHandleInt->ringNum = Udma_rmAllocMappedRing(drvHandleInt, ringPrms->mappedRingGrp, ringPrms->mappedChNum);
7009ed7e: 980c         	ldr	r0, [sp, #0x30]
7009ed80: 9a12         	ldr	r2, [sp, #0x48]
7009ed82: 6951         	ldr	r1, [r2, #0x14]
7009ed84: 6992         	ldr	r2, [r2, #0x18]
7009ed86: f003 fcc3    	bl	0x700a2710 <Udma_rmAllocMappedRing> @ imm = #0x3986
7009ed8a: 990b         	ldr	r1, [sp, #0x2c]
7009ed8c: 8088         	strh	r0, [r1, #0x4]
7009ed8e: e7ff         	b	0x7009ed90 <Udma_ringAlloc+0xb0> @ imm = #-0x2
;             if(UDMA_RING_INVALID == ringHandleInt->ringNum)
7009ed90: 980b         	ldr	r0, [sp, #0x2c]
7009ed92: 8880         	ldrh	r0, [r0, #0x4]
7009ed94: f64f 71ff    	movw	r1, #0xffff
7009ed98: 4288         	cmp	r0, r1
7009ed9a: d104         	bne	0x7009eda6 <Udma_ringAlloc+0xc6> @ imm = #0x8
7009ed9c: e7ff         	b	0x7009ed9e <Udma_ringAlloc+0xbe> @ imm = #-0x2
7009ed9e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009eda2: 9011         	str	r0, [sp, #0x44]
;             }
7009eda4: e002         	b	0x7009edac <Udma_ringAlloc+0xcc> @ imm = #0x4
7009eda6: 2001         	movs	r0, #0x1
;                 allocDone = (uint32_t) TRUE;
7009eda8: 900d         	str	r0, [sp, #0x34]
7009edaa: e7ff         	b	0x7009edac <Udma_ringAlloc+0xcc> @ imm = #-0x2
;         }
7009edac: e011         	b	0x7009edd2 <Udma_ringAlloc+0xf2> @ imm = #0x22
;             if(ringNum >= drvHandleInt->maxRings)
7009edae: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009edb2: 990c         	ldr	r1, [sp, #0x30]
7009edb4: f8d1 10dc    	ldr.w	r1, [r1, #0xdc]
7009edb8: 4288         	cmp	r0, r1
7009edba: d304         	blo	0x7009edc6 <Udma_ringAlloc+0xe6> @ imm = #0x8
7009edbc: e7ff         	b	0x7009edbe <Udma_ringAlloc+0xde> @ imm = #-0x2
7009edbe: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
7009edc2: 9011         	str	r0, [sp, #0x44]
;             }
7009edc4: e004         	b	0x7009edd0 <Udma_ringAlloc+0xf0> @ imm = #0x8
;                 ringHandleInt->ringNum = ringNum;
7009edc6: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009edca: 990b         	ldr	r1, [sp, #0x2c]
7009edcc: 8088         	strh	r0, [r1, #0x4]
7009edce: e7ff         	b	0x7009edd0 <Udma_ringAlloc+0xf0> @ imm = #-0x2
7009edd0: e7ff         	b	0x7009edd2 <Udma_ringAlloc+0xf2> @ imm = #-0x2
;     }
7009edd2: e7ff         	b	0x7009edd4 <Udma_ringAlloc+0xf4> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009edd4: 9811         	ldr	r0, [sp, #0x44]
7009edd6: b9a8         	cbnz	r0, 0x7009ee04 <Udma_ringAlloc+0x124> @ imm = #0x2a
7009edd8: e7ff         	b	0x7009edda <Udma_ringAlloc+0xfa> @ imm = #-0x2
;         Udma_ringAssertFnPointers(drvHandleInt);
7009edda: 980c         	ldr	r0, [sp, #0x30]
7009eddc: f010 fe10    	bl	0x700afa00 <Udma_ringAssertFnPointers> @ imm = #0x10c20
;         ringHandleInt->drvHandle = drvHandleInt;
7009ede0: 980c         	ldr	r0, [sp, #0x30]
7009ede2: 990b         	ldr	r1, [sp, #0x2c]
7009ede4: 6008         	str	r0, [r1]
;         ringHandleInt->mappedRingGrp   = ringPrms->mappedRingGrp;
7009ede6: 9812         	ldr	r0, [sp, #0x48]
7009ede8: 6940         	ldr	r0, [r0, #0x14]
7009edea: 990b         	ldr	r1, [sp, #0x2c]
7009edec: 65c8         	str	r0, [r1, #0x5c]
;         ringHandleInt->mappedChNum     = ringPrms->mappedChNum;
7009edee: 9812         	ldr	r0, [sp, #0x48]
7009edf0: 6980         	ldr	r0, [r0, #0x18]
7009edf2: 990b         	ldr	r1, [sp, #0x2c]
7009edf4: 6608         	str	r0, [r1, #0x60]
;         drvHandleInt->ringSetCfg(drvHandleInt, ringHandleInt, ringPrms);
7009edf6: 980c         	ldr	r0, [sp, #0x30]
7009edf8: f8d0 35c4    	ldr.w	r3, [r0, #0x5c4]
7009edfc: 990b         	ldr	r1, [sp, #0x2c]
7009edfe: 9a12         	ldr	r2, [sp, #0x48]
7009ee00: 4798         	blx	r3
;     }
7009ee02: e7ff         	b	0x7009ee04 <Udma_ringAlloc+0x124> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ee04: 9811         	ldr	r0, [sp, #0x44]
7009ee06: 2800         	cmp	r0, #0x0
7009ee08: d146         	bne	0x7009ee98 <Udma_ringAlloc+0x1b8> @ imm = #0x8c
7009ee0a: e7ff         	b	0x7009ee0c <Udma_ringAlloc+0x12c> @ imm = #-0x2
7009ee0c: 20bf         	movs	r0, #0xbf
;         rmRingReq.valid_params  = TISCI_MSG_VALUE_RM_RING_ADDR_LO_VALID |
7009ee0e: 9004         	str	r0, [sp, #0x10]
;         rmRingReq.nav_id        = drvHandleInt->devIdRing;
7009ee10: 980c         	ldr	r0, [sp, #0x30]
7009ee12: f8b0 00e0    	ldrh.w	r0, [r0, #0xe0]
7009ee16: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmRingReq.index         = ringHandleInt->ringNum;
7009ee1a: 980b         	ldr	r0, [sp, #0x2c]
7009ee1c: 8880         	ldrh	r0, [r0, #0x4]
7009ee1e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         physBase = Udma_virtToPhyFxn(ringPrms->ringMem, drvHandleInt, (Udma_ChHandleInt) NULL_PTR);
7009ee22: 9812         	ldr	r0, [sp, #0x48]
7009ee24: 6800         	ldr	r0, [r0]
7009ee26: 990c         	ldr	r1, [sp, #0x30]
7009ee28: 2200         	movs	r2, #0x0
7009ee2a: f00d fa01    	bl	0x700ac230 <Udma_virtToPhyFxn> @ imm = #0xd402
7009ee2e: 910f         	str	r1, [sp, #0x3c]
7009ee30: 900e         	str	r0, [sp, #0x38]
;         rmRingReq.addr_lo       = (uint32_t)physBase;
7009ee32: 980e         	ldr	r0, [sp, #0x38]
7009ee34: 9006         	str	r0, [sp, #0x18]
;         rmRingReq.addr_hi       = (uint32_t)(physBase >> 32UL);
7009ee36: 980f         	ldr	r0, [sp, #0x3c]
7009ee38: 9007         	str	r0, [sp, #0x1c]
;         rmRingReq.count         = ringPrms->elemCnt;
7009ee3a: 9812         	ldr	r0, [sp, #0x48]
7009ee3c: 68c0         	ldr	r0, [r0, #0xc]
7009ee3e: 9008         	str	r0, [sp, #0x20]
;         rmRingReq.mode          = ringPrms->mode;
7009ee40: 9812         	ldr	r0, [sp, #0x48]
7009ee42: 7a00         	ldrb	r0, [r0, #0x8]
7009ee44: f88d 0024    	strb.w	r0, [sp, #0x24]
;         rmRingReq.size          = ringPrms->elemSize;
7009ee48: 9812         	ldr	r0, [sp, #0x48]
7009ee4a: 7c00         	ldrb	r0, [r0, #0x10]
7009ee4c: f88d 0025    	strb.w	r0, [sp, #0x25]
;         rmRingReq.order_id      = ringPrms->orderId;
7009ee50: 9812         	ldr	r0, [sp, #0x48]
7009ee52: 7c40         	ldrb	r0, [r0, #0x11]
7009ee54: f88d 0026    	strb.w	r0, [sp, #0x26]
;         rmRingReq.asel          = ringPrms->asel;
7009ee58: 9812         	ldr	r0, [sp, #0x48]
7009ee5a: 7c80         	ldrb	r0, [r0, #0x12]
7009ee5c: f88d 0029    	strb.w	r0, [sp, #0x29]
;         if(UDMA_RING_VIRTID_INVALID != ringPrms->virtId)
7009ee60: 9812         	ldr	r0, [sp, #0x48]
7009ee62: 8940         	ldrh	r0, [r0, #0xa]
7009ee64: f64f 71ff    	movw	r1, #0xffff
7009ee68: 4288         	cmp	r0, r1
7009ee6a: d009         	beq	0x7009ee80 <Udma_ringAlloc+0x1a0> @ imm = #0x12
7009ee6c: e7ff         	b	0x7009ee6e <Udma_ringAlloc+0x18e> @ imm = #-0x2
;             rmRingReq.valid_params |= TISCI_MSG_VALUE_RM_RING_VIRTID_VALID;
7009ee6e: 9804         	ldr	r0, [sp, #0x10]
7009ee70: f040 0040    	orr	r0, r0, #0x40
7009ee74: 9004         	str	r0, [sp, #0x10]
;             rmRingReq.virtid        = ringPrms->virtId;
7009ee76: 9812         	ldr	r0, [sp, #0x48]
7009ee78: 8940         	ldrh	r0, [r0, #0xa]
7009ee7a: f8ad 0027    	strh.w	r0, [sp, #0x27]
;         }
7009ee7e: e7ff         	b	0x7009ee80 <Udma_ringAlloc+0x1a0> @ imm = #-0x2
7009ee80: a802         	add	r0, sp, #0x8
7009ee82: 4669         	mov	r1, sp
7009ee84: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmRingCfg(
7009ee88: f00d fc12    	bl	0x700ac6b0 <Sciclient_rmRingCfg> @ imm = #0xd824
7009ee8c: 9011         	str	r0, [sp, #0x44]
;         if(CSL_PASS != retVal)
7009ee8e: 9811         	ldr	r0, [sp, #0x44]
7009ee90: b108         	cbz	r0, 0x7009ee96 <Udma_ringAlloc+0x1b6> @ imm = #0x2
7009ee92: e7ff         	b	0x7009ee94 <Udma_ringAlloc+0x1b4> @ imm = #-0x2
;         }
7009ee94: e7ff         	b	0x7009ee96 <Udma_ringAlloc+0x1b6> @ imm = #-0x2
;     }
7009ee96: e7ff         	b	0x7009ee98 <Udma_ringAlloc+0x1b8> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ee98: 9811         	ldr	r0, [sp, #0x44]
7009ee9a: b938         	cbnz	r0, 0x7009eeac <Udma_ringAlloc+0x1cc> @ imm = #0xe
7009ee9c: e7ff         	b	0x7009ee9e <Udma_ringAlloc+0x1be> @ imm = #-0x2
;         ringHandleInt->ringInitDone = UDMA_INIT_DONE;
7009ee9e: 990b         	ldr	r1, [sp, #0x2c]
7009eea0: f64a 30cd    	movw	r0, #0xabcd
7009eea4: f6ca 30dc    	movt	r0, #0xabdc
7009eea8: 6588         	str	r0, [r1, #0x58]
;     }
7009eeaa: e01b         	b	0x7009eee4 <Udma_ringAlloc+0x204> @ imm = #0x36
;         if(((uint32_t) TRUE) == allocDone)
7009eeac: 980d         	ldr	r0, [sp, #0x34]
7009eeae: 2801         	cmp	r0, #0x1
7009eeb0: d117         	bne	0x7009eee2 <Udma_ringAlloc+0x202> @ imm = #0x2e
7009eeb2: e7ff         	b	0x7009eeb4 <Udma_ringAlloc+0x1d4> @ imm = #-0x2
;             if(UDMA_MAPPED_GROUP_INVALID == ringPrms->mappedRingGrp)
7009eeb4: 9812         	ldr	r0, [sp, #0x48]
7009eeb6: 6940         	ldr	r0, [r0, #0x14]
7009eeb8: 2104         	movs	r1, #0x4
7009eeba: f6cf 71ff    	movt	r1, #0xffff
7009eebe: 4288         	cmp	r0, r1
7009eec0: d106         	bne	0x7009eed0 <Udma_ringAlloc+0x1f0> @ imm = #0xc
7009eec2: e7ff         	b	0x7009eec4 <Udma_ringAlloc+0x1e4> @ imm = #-0x2
;                 Udma_rmFreeFreeRing(ringHandleInt->ringNum, drvHandleInt);
7009eec4: 980b         	ldr	r0, [sp, #0x2c]
7009eec6: 8880         	ldrh	r0, [r0, #0x4]
7009eec8: 990c         	ldr	r1, [sp, #0x30]
7009eeca: f010 fd59    	bl	0x700af980 <Udma_rmFreeFreeRing> @ imm = #0x10ab2
;             }
7009eece: e007         	b	0x7009eee0 <Udma_ringAlloc+0x200> @ imm = #0xe
;                 Udma_rmFreeMappedRing(ringHandleInt->ringNum, drvHandleInt, ringHandleInt->mappedRingGrp, ringHandleInt->mappedChNum);
7009eed0: 9b0b         	ldr	r3, [sp, #0x2c]
7009eed2: 8898         	ldrh	r0, [r3, #0x4]
7009eed4: 990c         	ldr	r1, [sp, #0x30]
7009eed6: 6dda         	ldr	r2, [r3, #0x5c]
7009eed8: 6e1b         	ldr	r3, [r3, #0x60]
7009eeda: f00a fe41    	bl	0x700a9b60 <Udma_rmFreeMappedRing> @ imm = #0xac82
7009eede: e7ff         	b	0x7009eee0 <Udma_ringAlloc+0x200> @ imm = #-0x2
;         }
7009eee0: e7ff         	b	0x7009eee2 <Udma_ringAlloc+0x202> @ imm = #-0x2
7009eee2: e7ff         	b	0x7009eee4 <Udma_ringAlloc+0x204> @ imm = #-0x2
;     return (retVal);
7009eee4: 9811         	ldr	r0, [sp, #0x44]
7009eee6: b016         	add	sp, #0x58
7009eee8: bd80         	pop	{r7, pc}
7009eeea: 0000         	movs	r0, r0
7009eeec: 0000         	movs	r0, r0
7009eeee: 0000         	movs	r0, r0

7009eef0 <tm_thread_locking_test_initialize>:
; {
7009eef0: b5b0         	push	{r4, r5, r7, lr}
;    tm_setup_pmu();
7009eef2: f010 fc45    	bl	0x700af780 <tm_setup_pmu> @ imm = #0x1088a
;       snprintf(pmu_lock_numbers[i], sizeof(pmu_lock_numbers[i]), "L%02d", i);
7009eef6: f244 7578    	movw	r5, #0x4778
7009eefa: f242 24d9    	movw	r4, #0x22d9
7009eefe: f2c7 0508    	movt	r5, #0x7008
7009ef02: f2c7 040b    	movt	r4, #0x700b
7009ef06: 2110         	movs	r1, #0x10
7009ef08: 2300         	movs	r3, #0x0
7009ef0a: 4628         	mov	r0, r5
7009ef0c: 4622         	mov	r2, r4
7009ef0e: f00b ee4e    	blx	0x700aabac <snprintf>   @ imm = #0xbc9c
7009ef12: f105 0010    	add.w	r0, r5, #0x10
7009ef16: 4622         	mov	r2, r4
7009ef18: 2110         	movs	r1, #0x10
7009ef1a: 2301         	movs	r3, #0x1
7009ef1c: f00b ee46    	blx	0x700aabac <snprintf>   @ imm = #0xbc8c
7009ef20: f105 0020    	add.w	r0, r5, #0x20
7009ef24: 4622         	mov	r2, r4
7009ef26: 2110         	movs	r1, #0x10
7009ef28: 2302         	movs	r3, #0x2
7009ef2a: f00b ee40    	blx	0x700aabac <snprintf>   @ imm = #0xbc80
7009ef2e: f105 0030    	add.w	r0, r5, #0x30
7009ef32: 4622         	mov	r2, r4
7009ef34: 2110         	movs	r1, #0x10
7009ef36: 2303         	movs	r3, #0x3
7009ef38: f00b ee38    	blx	0x700aabac <snprintf>   @ imm = #0xbc70
7009ef3c: f105 0040    	add.w	r0, r5, #0x40
7009ef40: 4622         	mov	r2, r4
7009ef42: 2110         	movs	r1, #0x10
7009ef44: 2304         	movs	r3, #0x4
7009ef46: f00b ee32    	blx	0x700aabac <snprintf>   @ imm = #0xbc64
7009ef4a: f105 0050    	add.w	r0, r5, #0x50
7009ef4e: 4622         	mov	r2, r4
7009ef50: 2110         	movs	r1, #0x10
7009ef52: 2305         	movs	r3, #0x5
7009ef54: f00b ee2a    	blx	0x700aabac <snprintf>   @ imm = #0xbc54
7009ef58: f105 0060    	add.w	r0, r5, #0x60
7009ef5c: 4622         	mov	r2, r4
7009ef5e: 2110         	movs	r1, #0x10
7009ef60: 2306         	movs	r3, #0x6
7009ef62: f00b ee24    	blx	0x700aabac <snprintf>   @ imm = #0xbc48
7009ef66: f105 0070    	add.w	r0, r5, #0x70
7009ef6a: 4622         	mov	r2, r4
7009ef6c: 2110         	movs	r1, #0x10
7009ef6e: 2307         	movs	r3, #0x7
7009ef70: f00b ee1c    	blx	0x700aabac <snprintf>   @ imm = #0xbc38
7009ef74: f105 0080    	add.w	r0, r5, #0x80
7009ef78: 4622         	mov	r2, r4
7009ef7a: 2110         	movs	r1, #0x10
7009ef7c: 2308         	movs	r3, #0x8
7009ef7e: f00b ee16    	blx	0x700aabac <snprintf>   @ imm = #0xbc2c
7009ef82: f105 0090    	add.w	r0, r5, #0x90
7009ef86: 4622         	mov	r2, r4
7009ef88: 2110         	movs	r1, #0x10
7009ef8a: 2309         	movs	r3, #0x9
7009ef8c: f00b ee0e    	blx	0x700aabac <snprintf>   @ imm = #0xbc1c
7009ef90: f105 00a0    	add.w	r0, r5, #0xa0
7009ef94: 4622         	mov	r2, r4
7009ef96: 2110         	movs	r1, #0x10
7009ef98: 230a         	movs	r3, #0xa
7009ef9a: f00b ee08    	blx	0x700aabac <snprintf>   @ imm = #0xbc10
7009ef9e: f105 00b0    	add.w	r0, r5, #0xb0
7009efa2: 4622         	mov	r2, r4
7009efa4: 2110         	movs	r1, #0x10
7009efa6: 230b         	movs	r3, #0xb
7009efa8: f00b ee00    	blx	0x700aabac <snprintf>   @ imm = #0xbc00
7009efac: f105 00c0    	add.w	r0, r5, #0xc0
7009efb0: 4622         	mov	r2, r4
7009efb2: 2110         	movs	r1, #0x10
7009efb4: 230c         	movs	r3, #0xc
7009efb6: f00b edfa    	blx	0x700aabac <snprintf>   @ imm = #0xbbf4
7009efba: f105 00d0    	add.w	r0, r5, #0xd0
7009efbe: 4622         	mov	r2, r4
7009efc0: 2110         	movs	r1, #0x10
7009efc2: 230d         	movs	r3, #0xd
7009efc4: f00b edf2    	blx	0x700aabac <snprintf>   @ imm = #0xbbe4
7009efc8: f105 00e0    	add.w	r0, r5, #0xe0
7009efcc: 4622         	mov	r2, r4
7009efce: 2110         	movs	r1, #0x10
7009efd0: 230e         	movs	r3, #0xe
7009efd2: f00b edec    	blx	0x700aabac <snprintf>   @ imm = #0xbbd8
7009efd6: f105 00f0    	add.w	r0, r5, #0xf0
7009efda: 4622         	mov	r2, r4
7009efdc: 2110         	movs	r1, #0x10
7009efde: 230f         	movs	r3, #0xf
7009efe0: f00b ede4    	blx	0x700aabac <snprintf>   @ imm = #0xbbc8
7009efe4: f505 7080    	add.w	r0, r5, #0x100
7009efe8: 4622         	mov	r2, r4
7009efea: 2110         	movs	r1, #0x10
7009efec: 2310         	movs	r3, #0x10
7009efee: f00b edde    	blx	0x700aabac <snprintf>   @ imm = #0xbbbc
7009eff2: f505 7088    	add.w	r0, r5, #0x110
7009eff6: 4622         	mov	r2, r4
7009eff8: 2110         	movs	r1, #0x10
7009effa: 2311         	movs	r3, #0x11
7009effc: f00b edd6    	blx	0x700aabac <snprintf>   @ imm = #0xbbac
7009f000: f505 7090    	add.w	r0, r5, #0x120
7009f004: 4622         	mov	r2, r4
7009f006: 2110         	movs	r1, #0x10
7009f008: 2312         	movs	r3, #0x12
7009f00a: f00b edd0    	blx	0x700aabac <snprintf>   @ imm = #0xbba0
7009f00e: f505 7098    	add.w	r0, r5, #0x130
7009f012: 4622         	mov	r2, r4
7009f014: 2110         	movs	r1, #0x10
7009f016: 2313         	movs	r3, #0x13
7009f018: f00b edc8    	blx	0x700aabac <snprintf>   @ imm = #0xbb90
7009f01c: f505 70a0    	add.w	r0, r5, #0x140
7009f020: 4622         	mov	r2, r4
7009f022: 2110         	movs	r1, #0x10
7009f024: 2314         	movs	r3, #0x14
7009f026: f00b edc2    	blx	0x700aabac <snprintf>   @ imm = #0xbb84
7009f02a: f505 70a8    	add.w	r0, r5, #0x150
7009f02e: 4622         	mov	r2, r4
7009f030: 2110         	movs	r1, #0x10
7009f032: 2315         	movs	r3, #0x15
7009f034: f00b edba    	blx	0x700aabac <snprintf>   @ imm = #0xbb74
7009f038: f505 70b0    	add.w	r0, r5, #0x160
7009f03c: 4622         	mov	r2, r4
7009f03e: 2110         	movs	r1, #0x10
7009f040: 2316         	movs	r3, #0x16
7009f042: f00b edb4    	blx	0x700aabac <snprintf>   @ imm = #0xbb68
7009f046: f505 70b8    	add.w	r0, r5, #0x170
7009f04a: 4622         	mov	r2, r4
7009f04c: 2110         	movs	r1, #0x10
7009f04e: 2317         	movs	r3, #0x17
7009f050: f00b edac    	blx	0x700aabac <snprintf>   @ imm = #0xbb58
7009f054: f505 70c0    	add.w	r0, r5, #0x180
7009f058: 4622         	mov	r2, r4
7009f05a: 2110         	movs	r1, #0x10
7009f05c: 2318         	movs	r3, #0x18
7009f05e: f00b eda6    	blx	0x700aabac <snprintf>   @ imm = #0xbb4c
7009f062: f505 70c8    	add.w	r0, r5, #0x190
7009f066: 4622         	mov	r2, r4
7009f068: 2110         	movs	r1, #0x10
7009f06a: 2319         	movs	r3, #0x19
7009f06c: f00b ed9e    	blx	0x700aabac <snprintf>   @ imm = #0xbb3c
7009f070: f505 70d0    	add.w	r0, r5, #0x1a0
7009f074: 4622         	mov	r2, r4
7009f076: 2110         	movs	r1, #0x10
7009f078: 231a         	movs	r3, #0x1a
7009f07a: f00b ed98    	blx	0x700aabac <snprintf>   @ imm = #0xbb30
7009f07e: f505 70d8    	add.w	r0, r5, #0x1b0
7009f082: 4622         	mov	r2, r4
7009f084: 2110         	movs	r1, #0x10
7009f086: 231b         	movs	r3, #0x1b
7009f088: f00b ed90    	blx	0x700aabac <snprintf>   @ imm = #0xbb20
7009f08c: f505 70e0    	add.w	r0, r5, #0x1c0
7009f090: 4622         	mov	r2, r4
7009f092: 2110         	movs	r1, #0x10
7009f094: 231c         	movs	r3, #0x1c
7009f096: f00b ed8a    	blx	0x700aabac <snprintf>   @ imm = #0xbb14
7009f09a: f505 70e8    	add.w	r0, r5, #0x1d0
7009f09e: 4622         	mov	r2, r4
7009f0a0: 2110         	movs	r1, #0x10
7009f0a2: 231d         	movs	r3, #0x1d
7009f0a4: f00b ed82    	blx	0x700aabac <snprintf>   @ imm = #0xbb04
7009f0a8: f505 70f0    	add.w	r0, r5, #0x1e0
7009f0ac: 4622         	mov	r2, r4
7009f0ae: 2110         	movs	r1, #0x10
7009f0b0: 231e         	movs	r3, #0x1e
7009f0b2: f00b ed7c    	blx	0x700aabac <snprintf>   @ imm = #0xbaf8
7009f0b6: f505 70f8    	add.w	r0, r5, #0x1f0
7009f0ba: 4622         	mov	r2, r4
7009f0bc: 2110         	movs	r1, #0x10
7009f0be: 231f         	movs	r3, #0x1f
7009f0c0: f00b ed74    	blx	0x700aabac <snprintf>   @ imm = #0xbae8
;    tm_thread_create(0, 5, tm_thread_locking_benchmark_thread);
7009f0c4: f647 02b1    	movw	r2, #0x78b1
7009f0c8: 2000         	movs	r0, #0x0
7009f0ca: f2c7 020a    	movt	r2, #0x700a
7009f0ce: 2105         	movs	r1, #0x5
7009f0d0: f00f f846    	bl	0x700ae160 <tm_thread_create> @ imm = #0xf08c
;    tm_thread_resume(0);
7009f0d4: 2000         	movs	r0, #0x0
7009f0d6: f010 faa3    	bl	0x700af620 <tm_thread_resume> @ imm = #0x10546
;    tm_thread_create(1, 1, tm_thread_locking_reporting_thread);
7009f0da: f240 02f1    	movw	r2, #0xf1
7009f0de: 2001         	movs	r0, #0x1
7009f0e0: f2c7 020a    	movt	r2, #0x700a
7009f0e4: 2101         	movs	r1, #0x1
7009f0e6: f00f f83b    	bl	0x700ae160 <tm_thread_create> @ imm = #0xf076
;    tm_thread_resume(1);
7009f0ea: 2001         	movs	r0, #0x1
7009f0ec: e8bd 40b0    	pop.w	{r4, r5, r7, lr}
7009f0f0: f010 ba96    	b.w	0x700af620 <tm_thread_resume> @ imm = #0x1052c
		...

7009f100 <Udma_chDisableBlkCpyChan>:
; {
7009f100: b580         	push	{r7, lr}
7009f102: b090         	sub	sp, #0x40
7009f104: 900f         	str	r0, [sp, #0x3c]
7009f106: 910e         	str	r1, [sp, #0x38]
7009f108: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f10a: 900d         	str	r0, [sp, #0x34]
;     uint32_t            currTimeout = 0U;
7009f10c: 900c         	str	r0, [sp, #0x30]
;     drvHandle = chHandle->drvHandle;
7009f10e: 980f         	ldr	r0, [sp, #0x3c]
7009f110: 6e80         	ldr	r0, [r0, #0x68]
7009f112: 900b         	str	r0, [sp, #0x2c]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f114: 980b         	ldr	r0, [sp, #0x2c]
7009f116: 6800         	ldr	r0, [r0]
7009f118: 2801         	cmp	r0, #0x1
7009f11a: d10a         	bne	0x7009f132 <Udma_chDisableBlkCpyChan+0x32> @ imm = #0x14
7009f11c: e7ff         	b	0x7009f11e <Udma_chDisableBlkCpyChan+0x1e> @ imm = #-0x2
;                  &drvHandle->bcdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009f11e: 980b         	ldr	r0, [sp, #0x2c]
7009f120: 3008         	adds	r0, #0x8
7009f122: 990f         	ldr	r1, [sp, #0x3c]
7009f124: 6ec9         	ldr	r1, [r1, #0x6c]
7009f126: 2300         	movs	r3, #0x0
;         retVal = CSL_bcdmaTeardownTxChan(
7009f128: 461a         	mov	r2, r3
7009f12a: f00e f9f1    	bl	0x700ad510 <CSL_bcdmaTeardownTxChan> @ imm = #0xe3e2
7009f12e: 900d         	str	r0, [sp, #0x34]
;     }
7009f130: e00f         	b	0x7009f152 <Udma_chDisableBlkCpyChan+0x52> @ imm = #0x1e
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f132: 980b         	ldr	r0, [sp, #0x2c]
7009f134: 6800         	ldr	r0, [r0]
7009f136: 2802         	cmp	r0, #0x2
7009f138: d10a         	bne	0x7009f150 <Udma_chDisableBlkCpyChan+0x50> @ imm = #0x14
7009f13a: e7ff         	b	0x7009f13c <Udma_chDisableBlkCpyChan+0x3c> @ imm = #-0x2
;                  &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009f13c: 980b         	ldr	r0, [sp, #0x2c]
7009f13e: 3054         	adds	r0, #0x54
7009f140: 990f         	ldr	r1, [sp, #0x3c]
7009f142: 6ec9         	ldr	r1, [r1, #0x6c]
7009f144: 2300         	movs	r3, #0x0
;         retVal = CSL_pktdmaTeardownTxChan(
7009f146: 461a         	mov	r2, r3
7009f148: f00f f88a    	bl	0x700ae260 <CSL_pktdmaTeardownTxChan> @ imm = #0xf114
7009f14c: 900d         	str	r0, [sp, #0x34]
;     }
7009f14e: e7ff         	b	0x7009f150 <Udma_chDisableBlkCpyChan+0x50> @ imm = #-0x2
7009f150: e7ff         	b	0x7009f152 <Udma_chDisableBlkCpyChan+0x52> @ imm = #-0x2
;     if(CSL_PASS != retVal)
7009f152: 980d         	ldr	r0, [sp, #0x34]
7009f154: b108         	cbz	r0, 0x7009f15a <Udma_chDisableBlkCpyChan+0x5a> @ imm = #0x2
7009f156: e7ff         	b	0x7009f158 <Udma_chDisableBlkCpyChan+0x58> @ imm = #-0x2
;     }
7009f158: e7ff         	b	0x7009f15a <Udma_chDisableBlkCpyChan+0x5a> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009f15a: e7ff         	b	0x7009f15c <Udma_chDisableBlkCpyChan+0x5c> @ imm = #-0x2
7009f15c: 980d         	ldr	r0, [sp, #0x34]
7009f15e: bba8         	cbnz	r0, 0x7009f1cc <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x6a
7009f160: e7ff         	b	0x7009f162 <Udma_chDisableBlkCpyChan+0x62> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f162: 980b         	ldr	r0, [sp, #0x2c]
7009f164: 6800         	ldr	r0, [r0]
7009f166: 2801         	cmp	r0, #0x1
7009f168: d10c         	bne	0x7009f184 <Udma_chDisableBlkCpyChan+0x84> @ imm = #0x18
7009f16a: e7ff         	b	0x7009f16c <Udma_chDisableBlkCpyChan+0x6c> @ imm = #-0x2
;             (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009f16c: 980b         	ldr	r0, [sp, #0x2c]
7009f16e: 3008         	adds	r0, #0x8
7009f170: 990f         	ldr	r1, [sp, #0x3c]
7009f172: 6ec9         	ldr	r1, [r1, #0x6c]
7009f174: aa05         	add	r2, sp, #0x14
7009f176: f00f fb6b    	bl	0x700ae850 <CSL_bcdmaGetTxRT> @ imm = #0xf6d6
;             if(FALSE == bcdmaRtStatus.enable)
7009f17a: 9805         	ldr	r0, [sp, #0x14]
7009f17c: b908         	cbnz	r0, 0x7009f182 <Udma_chDisableBlkCpyChan+0x82> @ imm = #0x2
7009f17e: e7ff         	b	0x7009f180 <Udma_chDisableBlkCpyChan+0x80> @ imm = #-0x2
;                 break;
7009f180: e024         	b	0x7009f1cc <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x48
;         }
7009f182: e011         	b	0x7009f1a8 <Udma_chDisableBlkCpyChan+0xa8> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f184: 980b         	ldr	r0, [sp, #0x2c]
7009f186: 6800         	ldr	r0, [r0]
7009f188: 2802         	cmp	r0, #0x2
7009f18a: d10c         	bne	0x7009f1a6 <Udma_chDisableBlkCpyChan+0xa6> @ imm = #0x18
7009f18c: e7ff         	b	0x7009f18e <Udma_chDisableBlkCpyChan+0x8e> @ imm = #-0x2
;             (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009f18e: 980b         	ldr	r0, [sp, #0x2c]
7009f190: 3054         	adds	r0, #0x54
7009f192: 990f         	ldr	r1, [sp, #0x3c]
7009f194: 6ec9         	ldr	r1, [r1, #0x6c]
7009f196: 466a         	mov	r2, sp
7009f198: f00e f80a    	bl	0x700ad1b0 <CSL_pktdmaGetTxRT> @ imm = #0xe014
;             if(FALSE == pktdmaRtStatus.enable)
7009f19c: 9800         	ldr	r0, [sp]
7009f19e: b908         	cbnz	r0, 0x7009f1a4 <Udma_chDisableBlkCpyChan+0xa4> @ imm = #0x2
7009f1a0: e7ff         	b	0x7009f1a2 <Udma_chDisableBlkCpyChan+0xa2> @ imm = #-0x2
;                 break;
7009f1a2: e013         	b	0x7009f1cc <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x26
;         }
7009f1a4: e7ff         	b	0x7009f1a6 <Udma_chDisableBlkCpyChan+0xa6> @ imm = #-0x2
7009f1a6: e7ff         	b	0x7009f1a8 <Udma_chDisableBlkCpyChan+0xa8> @ imm = #-0x2
;         if(currTimeout > timeout)
7009f1a8: 980c         	ldr	r0, [sp, #0x30]
7009f1aa: 990e         	ldr	r1, [sp, #0x38]
7009f1ac: 4288         	cmp	r0, r1
7009f1ae: d904         	bls	0x7009f1ba <Udma_chDisableBlkCpyChan+0xba> @ imm = #0x8
7009f1b0: e7ff         	b	0x7009f1b2 <Udma_chDisableBlkCpyChan+0xb2> @ imm = #-0x2
7009f1b2: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009f1b6: 900d         	str	r0, [sp, #0x34]
;         }
7009f1b8: e007         	b	0x7009f1ca <Udma_chDisableBlkCpyChan+0xca> @ imm = #0xe
7009f1ba: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009f1be: f00b feb7    	bl	0x700aaf30 <ClockP_usleep> @ imm = #0xbd6e
;             currTimeout++;
7009f1c2: 980c         	ldr	r0, [sp, #0x30]
7009f1c4: 3001         	adds	r0, #0x1
7009f1c6: 900c         	str	r0, [sp, #0x30]
7009f1c8: e7ff         	b	0x7009f1ca <Udma_chDisableBlkCpyChan+0xca> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009f1ca: e7c7         	b	0x7009f15c <Udma_chDisableBlkCpyChan+0x5c> @ imm = #-0x72
;     if(UDMA_SOK != retVal)
7009f1cc: 980d         	ldr	r0, [sp, #0x34]
7009f1ce: 2800         	cmp	r0, #0x0
7009f1d0: d05f         	beq	0x7009f292 <Udma_chDisableBlkCpyChan+0x192> @ imm = #0xbe
7009f1d2: e7ff         	b	0x7009f1d4 <Udma_chDisableBlkCpyChan+0xd4> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f1d4: 980b         	ldr	r0, [sp, #0x2c]
7009f1d6: 6800         	ldr	r0, [r0]
7009f1d8: 2801         	cmp	r0, #0x1
7009f1da: d10a         	bne	0x7009f1f2 <Udma_chDisableBlkCpyChan+0xf2> @ imm = #0x14
7009f1dc: e7ff         	b	0x7009f1de <Udma_chDisableBlkCpyChan+0xde> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009f1de: 980b         	ldr	r0, [sp, #0x2c]
7009f1e0: 3008         	adds	r0, #0x8
7009f1e2: 990f         	ldr	r1, [sp, #0x3c]
7009f1e4: 6ec9         	ldr	r1, [r1, #0x6c]
7009f1e6: 2201         	movs	r2, #0x1
7009f1e8: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownTxChan(
7009f1ea: f00e f991    	bl	0x700ad510 <CSL_bcdmaTeardownTxChan> @ imm = #0xe322
7009f1ee: 900d         	str	r0, [sp, #0x34]
;         }
7009f1f0: e00f         	b	0x7009f212 <Udma_chDisableBlkCpyChan+0x112> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f1f2: 980b         	ldr	r0, [sp, #0x2c]
7009f1f4: 6800         	ldr	r0, [r0]
7009f1f6: 2802         	cmp	r0, #0x2
7009f1f8: d10a         	bne	0x7009f210 <Udma_chDisableBlkCpyChan+0x110> @ imm = #0x14
7009f1fa: e7ff         	b	0x7009f1fc <Udma_chDisableBlkCpyChan+0xfc> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009f1fc: 980b         	ldr	r0, [sp, #0x2c]
7009f1fe: 3054         	adds	r0, #0x54
7009f200: 990f         	ldr	r1, [sp, #0x3c]
7009f202: 6ec9         	ldr	r1, [r1, #0x6c]
7009f204: 2201         	movs	r2, #0x1
7009f206: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownTxChan(
7009f208: f00f f82a    	bl	0x700ae260 <CSL_pktdmaTeardownTxChan> @ imm = #0xf054
7009f20c: 900d         	str	r0, [sp, #0x34]
;         }
7009f20e: e7ff         	b	0x7009f210 <Udma_chDisableBlkCpyChan+0x110> @ imm = #-0x2
7009f210: e7ff         	b	0x7009f212 <Udma_chDisableBlkCpyChan+0x112> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009f212: 980d         	ldr	r0, [sp, #0x34]
7009f214: b108         	cbz	r0, 0x7009f21a <Udma_chDisableBlkCpyChan+0x11a> @ imm = #0x2
7009f216: e7ff         	b	0x7009f218 <Udma_chDisableBlkCpyChan+0x118> @ imm = #-0x2
;         }
7009f218: e7ff         	b	0x7009f21a <Udma_chDisableBlkCpyChan+0x11a> @ imm = #-0x2
7009f21a: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009f21c: 900c         	str	r0, [sp, #0x30]
;         while(UDMA_SOK == retVal)
7009f21e: e7ff         	b	0x7009f220 <Udma_chDisableBlkCpyChan+0x120> @ imm = #-0x2
7009f220: 980d         	ldr	r0, [sp, #0x34]
7009f222: bba8         	cbnz	r0, 0x7009f290 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x6a
7009f224: e7ff         	b	0x7009f226 <Udma_chDisableBlkCpyChan+0x126> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f226: 980b         	ldr	r0, [sp, #0x2c]
7009f228: 6800         	ldr	r0, [r0]
7009f22a: 2801         	cmp	r0, #0x1
7009f22c: d10c         	bne	0x7009f248 <Udma_chDisableBlkCpyChan+0x148> @ imm = #0x18
7009f22e: e7ff         	b	0x7009f230 <Udma_chDisableBlkCpyChan+0x130> @ imm = #-0x2
;                 (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009f230: 980b         	ldr	r0, [sp, #0x2c]
7009f232: 3008         	adds	r0, #0x8
7009f234: 990f         	ldr	r1, [sp, #0x3c]
7009f236: 6ec9         	ldr	r1, [r1, #0x6c]
7009f238: aa05         	add	r2, sp, #0x14
7009f23a: f00f fb09    	bl	0x700ae850 <CSL_bcdmaGetTxRT> @ imm = #0xf612
;                 if(FALSE == bcdmaRtStatus.enable)
7009f23e: 9805         	ldr	r0, [sp, #0x14]
7009f240: b908         	cbnz	r0, 0x7009f246 <Udma_chDisableBlkCpyChan+0x146> @ imm = #0x2
7009f242: e7ff         	b	0x7009f244 <Udma_chDisableBlkCpyChan+0x144> @ imm = #-0x2
;                     break;
7009f244: e024         	b	0x7009f290 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x48
;             }
7009f246: e011         	b	0x7009f26c <Udma_chDisableBlkCpyChan+0x16c> @ imm = #0x22
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f248: 980b         	ldr	r0, [sp, #0x2c]
7009f24a: 6800         	ldr	r0, [r0]
7009f24c: 2802         	cmp	r0, #0x2
7009f24e: d10c         	bne	0x7009f26a <Udma_chDisableBlkCpyChan+0x16a> @ imm = #0x18
7009f250: e7ff         	b	0x7009f252 <Udma_chDisableBlkCpyChan+0x152> @ imm = #-0x2
;                 (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009f252: 980b         	ldr	r0, [sp, #0x2c]
7009f254: 3054         	adds	r0, #0x54
7009f256: 990f         	ldr	r1, [sp, #0x3c]
7009f258: 6ec9         	ldr	r1, [r1, #0x6c]
7009f25a: 466a         	mov	r2, sp
7009f25c: f00d ffa8    	bl	0x700ad1b0 <CSL_pktdmaGetTxRT> @ imm = #0xdf50
;                 if(FALSE == pktdmaRtStatus.enable)
7009f260: 9800         	ldr	r0, [sp]
7009f262: b908         	cbnz	r0, 0x7009f268 <Udma_chDisableBlkCpyChan+0x168> @ imm = #0x2
7009f264: e7ff         	b	0x7009f266 <Udma_chDisableBlkCpyChan+0x166> @ imm = #-0x2
;                     break;
7009f266: e013         	b	0x7009f290 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x26
;             }
7009f268: e7ff         	b	0x7009f26a <Udma_chDisableBlkCpyChan+0x16a> @ imm = #-0x2
7009f26a: e7ff         	b	0x7009f26c <Udma_chDisableBlkCpyChan+0x16c> @ imm = #-0x2
;             if(currTimeout > timeout)
7009f26c: 980c         	ldr	r0, [sp, #0x30]
7009f26e: 990e         	ldr	r1, [sp, #0x38]
7009f270: 4288         	cmp	r0, r1
7009f272: d904         	bls	0x7009f27e <Udma_chDisableBlkCpyChan+0x17e> @ imm = #0x8
7009f274: e7ff         	b	0x7009f276 <Udma_chDisableBlkCpyChan+0x176> @ imm = #-0x2
7009f276: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009f27a: 900d         	str	r0, [sp, #0x34]
;             }
7009f27c: e007         	b	0x7009f28e <Udma_chDisableBlkCpyChan+0x18e> @ imm = #0xe
7009f27e: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009f282: f00b fe55    	bl	0x700aaf30 <ClockP_usleep> @ imm = #0xbcaa
;                 currTimeout++;
7009f286: 980c         	ldr	r0, [sp, #0x30]
7009f288: 3001         	adds	r0, #0x1
7009f28a: 900c         	str	r0, [sp, #0x30]
7009f28c: e7ff         	b	0x7009f28e <Udma_chDisableBlkCpyChan+0x18e> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009f28e: e7c7         	b	0x7009f220 <Udma_chDisableBlkCpyChan+0x120> @ imm = #-0x72
;     }
7009f290: e7ff         	b	0x7009f292 <Udma_chDisableBlkCpyChan+0x192> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f292: 980d         	ldr	r0, [sp, #0x34]
7009f294: bb20         	cbnz	r0, 0x7009f2e0 <Udma_chDisableBlkCpyChan+0x1e0> @ imm = #0x48
7009f296: e7ff         	b	0x7009f298 <Udma_chDisableBlkCpyChan+0x198> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f298: 980b         	ldr	r0, [sp, #0x2c]
7009f29a: 6800         	ldr	r0, [r0]
7009f29c: 2801         	cmp	r0, #0x1
7009f29e: d10c         	bne	0x7009f2ba <Udma_chDisableBlkCpyChan+0x1ba> @ imm = #0x18
7009f2a0: e7ff         	b	0x7009f2a2 <Udma_chDisableBlkCpyChan+0x1a2> @ imm = #-0x2
7009f2a2: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.enable   = FALSE;
7009f2a4: 9005         	str	r0, [sp, #0x14]
;             bcdmaRtStatus.teardown = FALSE;
7009f2a6: 9006         	str	r0, [sp, #0x18]
;             bcdmaRtStatus.forcedTeardown = FALSE;
7009f2a8: 9009         	str	r0, [sp, #0x24]
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009f2aa: 980b         	ldr	r0, [sp, #0x2c]
7009f2ac: 3008         	adds	r0, #0x8
7009f2ae: 990f         	ldr	r1, [sp, #0x3c]
7009f2b0: 6ec9         	ldr	r1, [r1, #0x6c]
7009f2b2: aa05         	add	r2, sp, #0x14
7009f2b4: f00f fafc    	bl	0x700ae8b0 <CSL_bcdmaSetTxRT> @ imm = #0xf5f8
;         }
7009f2b8: e011         	b	0x7009f2de <Udma_chDisableBlkCpyChan+0x1de> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f2ba: 980b         	ldr	r0, [sp, #0x2c]
7009f2bc: 6800         	ldr	r0, [r0]
7009f2be: 2802         	cmp	r0, #0x2
7009f2c0: d10c         	bne	0x7009f2dc <Udma_chDisableBlkCpyChan+0x1dc> @ imm = #0x18
7009f2c2: e7ff         	b	0x7009f2c4 <Udma_chDisableBlkCpyChan+0x1c4> @ imm = #-0x2
7009f2c4: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.enable   = FALSE;
7009f2c6: 9000         	str	r0, [sp]
;             pktdmaRtStatus.teardown = FALSE;
7009f2c8: 9001         	str	r0, [sp, #0x4]
;             pktdmaRtStatus.forcedTeardown = FALSE;
7009f2ca: 9004         	str	r0, [sp, #0x10]
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009f2cc: 980b         	ldr	r0, [sp, #0x2c]
7009f2ce: 3054         	adds	r0, #0x54
7009f2d0: 990f         	ldr	r1, [sp, #0x3c]
7009f2d2: 6ec9         	ldr	r1, [r1, #0x6c]
7009f2d4: 466a         	mov	r2, sp
7009f2d6: f00e fd23    	bl	0x700add20 <CSL_pktdmaSetTxRT> @ imm = #0xea46
;         }
7009f2da: e7ff         	b	0x7009f2dc <Udma_chDisableBlkCpyChan+0x1dc> @ imm = #-0x2
7009f2dc: e7ff         	b	0x7009f2de <Udma_chDisableBlkCpyChan+0x1de> @ imm = #-0x2
;     }
7009f2de: e7ff         	b	0x7009f2e0 <Udma_chDisableBlkCpyChan+0x1e0> @ imm = #-0x2
;     return (retVal);
7009f2e0: 980d         	ldr	r0, [sp, #0x34]
7009f2e2: b010         	add	sp, #0x40
7009f2e4: bd80         	pop	{r7, pc}
		...
7009f2ee: 0000         	movs	r0, r0

7009f2f0 <Udma_flowConfig>:
; {
7009f2f0: b580         	push	{r7, lr}
7009f2f2: b09e         	sub	sp, #0x78
7009f2f4: 901d         	str	r0, [sp, #0x74]
7009f2f6: 911c         	str	r1, [sp, #0x70]
7009f2f8: 921b         	str	r2, [sp, #0x6c]
7009f2fa: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f2fc: 901a         	str	r0, [sp, #0x68]
;     Udma_FlowHandleInt  flowHandleInt = (Udma_FlowHandleInt) flowHandle;
7009f2fe: 981d         	ldr	r0, [sp, #0x74]
7009f300: 9018         	str	r0, [sp, #0x60]
;     if((NULL_PTR == flowHandleInt) ||
7009f302: 9818         	ldr	r0, [sp, #0x60]
7009f304: b160         	cbz	r0, 0x7009f320 <Udma_flowConfig+0x30> @ imm = #0x18
7009f306: e7ff         	b	0x7009f308 <Udma_flowConfig+0x18> @ imm = #-0x2
;        (flowHandleInt->flowInitDone != UDMA_INIT_DONE) ||
7009f308: 9818         	ldr	r0, [sp, #0x60]
7009f30a: 68c0         	ldr	r0, [r0, #0xc]
7009f30c: f64a 31cd    	movw	r1, #0xabcd
7009f310: f6ca 31dc    	movt	r1, #0xabdc
7009f314: 4288         	cmp	r0, r1
7009f316: d103         	bne	0x7009f320 <Udma_flowConfig+0x30> @ imm = #0x6
7009f318: e7ff         	b	0x7009f31a <Udma_flowConfig+0x2a> @ imm = #-0x2
;        (NULL_PTR == flowPrms))
7009f31a: 981b         	ldr	r0, [sp, #0x6c]
;     if((NULL_PTR == flowHandleInt) ||
7009f31c: b920         	cbnz	r0, 0x7009f328 <Udma_flowConfig+0x38> @ imm = #0x8
7009f31e: e7ff         	b	0x7009f320 <Udma_flowConfig+0x30> @ imm = #-0x2
7009f320: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009f324: 901a         	str	r0, [sp, #0x68]
;     }
7009f326: e7ff         	b	0x7009f328 <Udma_flowConfig+0x38> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f328: 981a         	ldr	r0, [sp, #0x68]
7009f32a: b9a8         	cbnz	r0, 0x7009f358 <Udma_flowConfig+0x68> @ imm = #0x2a
7009f32c: e7ff         	b	0x7009f32e <Udma_flowConfig+0x3e> @ imm = #-0x2
;         drvHandle = flowHandleInt->drvHandle;
7009f32e: 9818         	ldr	r0, [sp, #0x60]
7009f330: 6800         	ldr	r0, [r0]
7009f332: 9019         	str	r0, [sp, #0x64]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009f334: 9819         	ldr	r0, [sp, #0x64]
7009f336: b150         	cbz	r0, 0x7009f34e <Udma_flowConfig+0x5e> @ imm = #0x14
7009f338: e7ff         	b	0x7009f33a <Udma_flowConfig+0x4a> @ imm = #-0x2
7009f33a: 9819         	ldr	r0, [sp, #0x64]
7009f33c: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009f340: f64a 31cd    	movw	r1, #0xabcd
7009f344: f6ca 31dc    	movt	r1, #0xabdc
7009f348: 4288         	cmp	r0, r1
7009f34a: d004         	beq	0x7009f356 <Udma_flowConfig+0x66> @ imm = #0x8
7009f34c: e7ff         	b	0x7009f34e <Udma_flowConfig+0x5e> @ imm = #-0x2
7009f34e: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009f352: 901a         	str	r0, [sp, #0x68]
;         }
7009f354: e7ff         	b	0x7009f356 <Udma_flowConfig+0x66> @ imm = #-0x2
;     }
7009f356: e7ff         	b	0x7009f358 <Udma_flowConfig+0x68> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f358: 981a         	ldr	r0, [sp, #0x68]
7009f35a: b958         	cbnz	r0, 0x7009f374 <Udma_flowConfig+0x84> @ imm = #0x16
7009f35c: e7ff         	b	0x7009f35e <Udma_flowConfig+0x6e> @ imm = #-0x2
;         if(flowIdx >= flowHandleInt->flowCnt)
7009f35e: 981c         	ldr	r0, [sp, #0x70]
7009f360: 9918         	ldr	r1, [sp, #0x60]
7009f362: 6889         	ldr	r1, [r1, #0x8]
7009f364: 4288         	cmp	r0, r1
7009f366: d304         	blo	0x7009f372 <Udma_flowConfig+0x82> @ imm = #0x8
7009f368: e7ff         	b	0x7009f36a <Udma_flowConfig+0x7a> @ imm = #-0x2
7009f36a: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
7009f36e: 901a         	str	r0, [sp, #0x68]
;         }
7009f370: e7ff         	b	0x7009f372 <Udma_flowConfig+0x82> @ imm = #-0x2
;     }
7009f372: e7ff         	b	0x7009f374 <Udma_flowConfig+0x84> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f374: 981a         	ldr	r0, [sp, #0x68]
7009f376: 2800         	cmp	r0, #0x0
7009f378: f040 80a3    	bne.w	0x7009f4c2 <Udma_flowConfig+0x1d2> @ imm = #0x146
7009f37c: e7ff         	b	0x7009f37e <Udma_flowConfig+0x8e> @ imm = #-0x2
7009f37e: f64f 70ff    	movw	r0, #0xffff
7009f382: f2c0 0007    	movt	r0, #0x7
;         rmFlowReq.valid_params          = TISCI_MSG_VALUE_RM_UDMAP_FLOW_EINFO_PRESENT_VALID |
7009f386: 900f         	str	r0, [sp, #0x3c]
;         rmFlowReq.nav_id                = drvHandle->devIdUdma;
7009f388: 9819         	ldr	r0, [sp, #0x64]
7009f38a: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009f38e: f8ad 0040    	strh.w	r0, [sp, #0x40]
;         rmFlowReq.flow_index            = (uint16_t)(flowHandleInt->flowStart + flowIdx);
7009f392: 9818         	ldr	r0, [sp, #0x60]
7009f394: 6840         	ldr	r0, [r0, #0x4]
7009f396: 991c         	ldr	r1, [sp, #0x70]
7009f398: 4408         	add	r0, r1
7009f39a: f8ad 0042    	strh.w	r0, [sp, #0x42]
;         rmFlowReq.rx_einfo_present      = flowPrms->einfoPresent;
7009f39e: 981b         	ldr	r0, [sp, #0x6c]
7009f3a0: 7900         	ldrb	r0, [r0, #0x4]
7009f3a2: f88d 0044    	strb.w	r0, [sp, #0x44]
;         rmFlowReq.rx_psinfo_present     = flowPrms->psInfoPresent;
7009f3a6: 981b         	ldr	r0, [sp, #0x6c]
7009f3a8: 7940         	ldrb	r0, [r0, #0x5]
7009f3aa: f88d 0045    	strb.w	r0, [sp, #0x45]
;         rmFlowReq.rx_error_handling     = flowPrms->errorHandling;
7009f3ae: 981b         	ldr	r0, [sp, #0x6c]
7009f3b0: 7980         	ldrb	r0, [r0, #0x6]
7009f3b2: f88d 0046    	strb.w	r0, [sp, #0x46]
;         rmFlowReq.rx_desc_type          = flowPrms->descType;
7009f3b6: 981b         	ldr	r0, [sp, #0x6c]
7009f3b8: 79c0         	ldrb	r0, [r0, #0x7]
7009f3ba: f88d 0047    	strb.w	r0, [sp, #0x47]
;         rmFlowReq.rx_ps_location        = flowPrms->psLocation;
7009f3be: 981b         	ldr	r0, [sp, #0x6c]
7009f3c0: 7a00         	ldrb	r0, [r0, #0x8]
7009f3c2: f88d 005c    	strb.w	r0, [sp, #0x5c]
;         rmFlowReq.rx_sop_offset         = flowPrms->sopOffset;
7009f3c6: 981b         	ldr	r0, [sp, #0x6c]
7009f3c8: 8940         	ldrh	r0, [r0, #0xa]
7009f3ca: f8ad 0048    	strh.w	r0, [sp, #0x48]
;         rmFlowReq.rx_dest_qnum          = flowPrms->defaultRxCQ;
7009f3ce: 981b         	ldr	r0, [sp, #0x6c]
7009f3d0: 8980         	ldrh	r0, [r0, #0xc]
7009f3d2: f8ad 004a    	strh.w	r0, [sp, #0x4a]
;         rmFlowReq.rx_src_tag_hi         = flowPrms->srcTagHi;
7009f3d6: 981b         	ldr	r0, [sp, #0x6c]
7009f3d8: 7b80         	ldrb	r0, [r0, #0xe]
7009f3da: f88d 004c    	strb.w	r0, [sp, #0x4c]
;         rmFlowReq.rx_src_tag_lo         = flowPrms->srcTagLo;
7009f3de: 981b         	ldr	r0, [sp, #0x6c]
7009f3e0: 7bc0         	ldrb	r0, [r0, #0xf]
7009f3e2: f88d 004d    	strb.w	r0, [sp, #0x4d]
;         rmFlowReq.rx_src_tag_hi_sel     = flowPrms->srcTagHiSel;
7009f3e6: 981b         	ldr	r0, [sp, #0x6c]
7009f3e8: 7c00         	ldrb	r0, [r0, #0x10]
7009f3ea: f88d 0050    	strb.w	r0, [sp, #0x50]
;         rmFlowReq.rx_src_tag_lo_sel     = flowPrms->srcTagLoSel;
7009f3ee: 981b         	ldr	r0, [sp, #0x6c]
7009f3f0: 7c40         	ldrb	r0, [r0, #0x11]
7009f3f2: f88d 0051    	strb.w	r0, [sp, #0x51]
;         rmFlowReq.rx_dest_tag_hi        = flowPrms->destTagHi;
7009f3f6: 981b         	ldr	r0, [sp, #0x6c]
7009f3f8: 7c80         	ldrb	r0, [r0, #0x12]
7009f3fa: f88d 004e    	strb.w	r0, [sp, #0x4e]
;         rmFlowReq.rx_dest_tag_lo        = flowPrms->destTagLo;
7009f3fe: 981b         	ldr	r0, [sp, #0x6c]
7009f400: 7cc0         	ldrb	r0, [r0, #0x13]
7009f402: f88d 004f    	strb.w	r0, [sp, #0x4f]
;         rmFlowReq.rx_dest_tag_hi_sel    = flowPrms->destTagHiSel;
7009f406: 981b         	ldr	r0, [sp, #0x6c]
7009f408: 7d00         	ldrb	r0, [r0, #0x14]
7009f40a: f88d 0052    	strb.w	r0, [sp, #0x52]
;         rmFlowReq.rx_dest_tag_lo_sel    = flowPrms->destTagLoSel;
7009f40e: 981b         	ldr	r0, [sp, #0x6c]
7009f410: 7d40         	ldrb	r0, [r0, #0x15]
7009f412: f88d 0053    	strb.w	r0, [sp, #0x53]
;         rmFlowReq.rx_fdq0_sz0_qnum      = flowPrms->fdq0Sz0Qnum;
7009f416: 981b         	ldr	r0, [sp, #0x6c]
7009f418: 8b00         	ldrh	r0, [r0, #0x18]
7009f41a: f8ad 0054    	strh.w	r0, [sp, #0x54]
;         rmFlowReq.rx_fdq1_qnum          = flowPrms->fdq1Qnum;
7009f41e: 981b         	ldr	r0, [sp, #0x6c]
7009f420: 8b40         	ldrh	r0, [r0, #0x1a]
7009f422: f8ad 0056    	strh.w	r0, [sp, #0x56]
;         rmFlowReq.rx_fdq2_qnum          = flowPrms->fdq2Qnum;
7009f426: 981b         	ldr	r0, [sp, #0x6c]
7009f428: 8b80         	ldrh	r0, [r0, #0x1c]
7009f42a: f8ad 0058    	strh.w	r0, [sp, #0x58]
;         rmFlowReq.rx_fdq3_qnum          = flowPrms->fdq3Qnum;
7009f42e: 981b         	ldr	r0, [sp, #0x6c]
7009f430: 8bc0         	ldrh	r0, [r0, #0x1e]
7009f432: f8ad 005a    	strh.w	r0, [sp, #0x5a]
7009f436: a80d         	add	r0, sp, #0x34
7009f438: a90b         	add	r1, sp, #0x2c
7009f43a: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmUdmapFlowCfg(
7009f43e: f00d f967    	bl	0x700ac710 <Sciclient_rmUdmapFlowCfg> @ imm = #0xd2ce
7009f442: 901a         	str	r0, [sp, #0x68]
;         if(CSL_PASS != retVal)
7009f444: 981a         	ldr	r0, [sp, #0x68]
7009f446: b108         	cbz	r0, 0x7009f44c <Udma_flowConfig+0x15c> @ imm = #0x2
7009f448: e7ff         	b	0x7009f44a <Udma_flowConfig+0x15a> @ imm = #-0x2
;         }
7009f44a: e7ff         	b	0x7009f44c <Udma_flowConfig+0x15c> @ imm = #-0x2
7009f44c: 207f         	movs	r0, #0x7f
;         rmOptFlowReq.valid_params       = TISCI_MSG_VALUE_RM_UDMAP_FLOW_SIZE_THRESH0_VALID |
7009f44e: 9005         	str	r0, [sp, #0x14]
;         rmOptFlowReq.nav_id             = drvHandle->devIdUdma;
7009f450: 9819         	ldr	r0, [sp, #0x64]
7009f452: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009f456: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         rmOptFlowReq.flow_index         = (uint16_t)(flowHandleInt->flowStart + flowIdx);
7009f45a: 9818         	ldr	r0, [sp, #0x60]
7009f45c: 6840         	ldr	r0, [r0, #0x4]
7009f45e: 991c         	ldr	r1, [sp, #0x70]
7009f460: 4408         	add	r0, r1
7009f462: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         rmOptFlowReq.rx_size_thresh0    = (flowPrms->sizeThresh0 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009f466: 981b         	ldr	r0, [sp, #0x6c]
7009f468: 8c00         	ldrh	r0, [r0, #0x20]
7009f46a: 0940         	lsrs	r0, r0, #0x5
7009f46c: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         rmOptFlowReq.rx_size_thresh1    = (flowPrms->sizeThresh1 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009f470: 981b         	ldr	r0, [sp, #0x6c]
7009f472: 8c40         	ldrh	r0, [r0, #0x22]
7009f474: 0940         	lsrs	r0, r0, #0x5
7009f476: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmOptFlowReq.rx_size_thresh2    = (flowPrms->sizeThresh2 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009f47a: 981b         	ldr	r0, [sp, #0x6c]
7009f47c: 8c80         	ldrh	r0, [r0, #0x24]
7009f47e: 0940         	lsrs	r0, r0, #0x5
7009f480: f8ad 0020    	strh.w	r0, [sp, #0x20]
;         rmOptFlowReq.rx_fdq0_sz1_qnum   = flowPrms->fdq0Sz1Qnum;
7009f484: 981b         	ldr	r0, [sp, #0x6c]
7009f486: 8cc0         	ldrh	r0, [r0, #0x26]
7009f488: f8ad 0022    	strh.w	r0, [sp, #0x22]
;         rmOptFlowReq.rx_fdq0_sz2_qnum   = flowPrms->fdq0Sz2Qnum;
7009f48c: 981b         	ldr	r0, [sp, #0x6c]
7009f48e: 8d00         	ldrh	r0, [r0, #0x28]
7009f490: f8ad 0024    	strh.w	r0, [sp, #0x24]
;         rmOptFlowReq.rx_fdq0_sz3_qnum   = flowPrms->fdq0Sz3Qnum;
7009f494: 981b         	ldr	r0, [sp, #0x6c]
7009f496: 8d40         	ldrh	r0, [r0, #0x2a]
7009f498: f8ad 0026    	strh.w	r0, [sp, #0x26]
;         rmOptFlowReq.rx_size_thresh_en  = flowPrms->sizeThreshEn;
7009f49c: 981b         	ldr	r0, [sp, #0x6c]
7009f49e: 7d80         	ldrb	r0, [r0, #0x16]
7009f4a0: f88d 0028    	strb.w	r0, [sp, #0x28]
7009f4a4: a803         	add	r0, sp, #0xc
7009f4a6: a901         	add	r1, sp, #0x4
7009f4a8: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal += Sciclient_rmUdmapFlowSizeThreshCfg(
7009f4ac: f00d f960    	bl	0x700ac770 <Sciclient_rmUdmapFlowSizeThreshCfg> @ imm = #0xd2c0
7009f4b0: 4601         	mov	r1, r0
7009f4b2: 981a         	ldr	r0, [sp, #0x68]
7009f4b4: 4408         	add	r0, r1
7009f4b6: 901a         	str	r0, [sp, #0x68]
;         if(CSL_PASS != retVal)
7009f4b8: 981a         	ldr	r0, [sp, #0x68]
7009f4ba: b108         	cbz	r0, 0x7009f4c0 <Udma_flowConfig+0x1d0> @ imm = #0x2
7009f4bc: e7ff         	b	0x7009f4be <Udma_flowConfig+0x1ce> @ imm = #-0x2
;         }
7009f4be: e7ff         	b	0x7009f4c0 <Udma_flowConfig+0x1d0> @ imm = #-0x2
;     }
7009f4c0: e7ff         	b	0x7009f4c2 <Udma_flowConfig+0x1d2> @ imm = #-0x2
;     return (retVal);
7009f4c2: 981a         	ldr	r0, [sp, #0x68]
7009f4c4: b01e         	add	sp, #0x78
7009f4c6: bd80         	pop	{r7, pc}

7009f4c8 <__udivsi3>:
7009f4c8: e3510001     	cmp	r1, #1
7009f4cc: 3a00000b     	blo	0x7009f500 <__udivsi3+0x38> @ imm = #0x2c
7009f4d0: 012fff1e     	bxeq	lr
7009f4d4: e1500001     	cmp	r0, r1
7009f4d8: 33a00000     	movlo	r0, #0
7009f4dc: 312fff1e     	bxlo	lr
7009f4e0: e16fcf10     	clz	r12, r0
7009f4e4: e16f3f11     	clz	r3, r1
7009f4e8: e043300c     	sub	r3, r3, r12
7009f4ec: e28fce19     	add	r12, pc, #400
7009f4f0: e04cc103     	sub	r12, r12, r3, lsl #2
7009f4f4: e04cc183     	sub	r12, r12, r3, lsl #3
7009f4f8: e3a03000     	mov	r3, #0
7009f4fc: e12fff1c     	bx	r12
7009f500: e3b00000     	movs	r0, #0
7009f504: e92d4080     	push	{r7, lr}
7009f508: eb004150     	bl	0x700afa50 <__aeabi_idiv0> @ imm = #0x10540
7009f50c: e8bd8080     	pop	{r7, pc}
7009f510: e1500f81     	cmp	r0, r1, lsl #31
7009f514: 22833102     	addhs	r3, r3, #-2147483648
7009f518: 20400f81     	subhs	r0, r0, r1, lsl #31
7009f51c: e1500f01     	cmp	r0, r1, lsl #30
7009f520: 22833101     	addhs	r3, r3, #1073741824
7009f524: 20400f01     	subhs	r0, r0, r1, lsl #30
7009f528: e1500e81     	cmp	r0, r1, lsl #29
7009f52c: 22833202     	addhs	r3, r3, #536870912
7009f530: 20400e81     	subhs	r0, r0, r1, lsl #29
7009f534: e1500e01     	cmp	r0, r1, lsl #28
7009f538: 22833201     	addhs	r3, r3, #268435456
7009f53c: 20400e01     	subhs	r0, r0, r1, lsl #28
7009f540: e1500d81     	cmp	r0, r1, lsl #27
7009f544: 22833302     	addhs	r3, r3, #134217728
7009f548: 20400d81     	subhs	r0, r0, r1, lsl #27
7009f54c: e1500d01     	cmp	r0, r1, lsl #26
7009f550: 22833301     	addhs	r3, r3, #67108864
7009f554: 20400d01     	subhs	r0, r0, r1, lsl #26
7009f558: e1500c81     	cmp	r0, r1, lsl #25
7009f55c: 22833402     	addhs	r3, r3, #33554432
7009f560: 20400c81     	subhs	r0, r0, r1, lsl #25
7009f564: e1500c01     	cmp	r0, r1, lsl #24
7009f568: 22833401     	addhs	r3, r3, #16777216
7009f56c: 20400c01     	subhs	r0, r0, r1, lsl #24
7009f570: e1500b81     	cmp	r0, r1, lsl #23
7009f574: 22833502     	addhs	r3, r3, #8388608
7009f578: 20400b81     	subhs	r0, r0, r1, lsl #23
7009f57c: e1500b01     	cmp	r0, r1, lsl #22
7009f580: 22833501     	addhs	r3, r3, #4194304
7009f584: 20400b01     	subhs	r0, r0, r1, lsl #22
7009f588: e1500a81     	cmp	r0, r1, lsl #21
7009f58c: 22833602     	addhs	r3, r3, #2097152
7009f590: 20400a81     	subhs	r0, r0, r1, lsl #21
7009f594: e1500a01     	cmp	r0, r1, lsl #20
7009f598: 22833601     	addhs	r3, r3, #1048576
7009f59c: 20400a01     	subhs	r0, r0, r1, lsl #20
7009f5a0: e1500981     	cmp	r0, r1, lsl #19
7009f5a4: 22833702     	addhs	r3, r3, #524288
7009f5a8: 20400981     	subhs	r0, r0, r1, lsl #19
7009f5ac: e1500901     	cmp	r0, r1, lsl #18
7009f5b0: 22833701     	addhs	r3, r3, #262144
7009f5b4: 20400901     	subhs	r0, r0, r1, lsl #18
7009f5b8: e1500881     	cmp	r0, r1, lsl #17
7009f5bc: 22833802     	addhs	r3, r3, #131072
7009f5c0: 20400881     	subhs	r0, r0, r1, lsl #17
7009f5c4: e1500801     	cmp	r0, r1, lsl #16
7009f5c8: 22833801     	addhs	r3, r3, #65536
7009f5cc: 20400801     	subhs	r0, r0, r1, lsl #16
7009f5d0: e1500781     	cmp	r0, r1, lsl #15
7009f5d4: 22833902     	addhs	r3, r3, #32768
7009f5d8: 20400781     	subhs	r0, r0, r1, lsl #15
7009f5dc: e1500701     	cmp	r0, r1, lsl #14
7009f5e0: 22833901     	addhs	r3, r3, #16384
7009f5e4: 20400701     	subhs	r0, r0, r1, lsl #14
7009f5e8: e1500681     	cmp	r0, r1, lsl #13
7009f5ec: 22833a02     	addhs	r3, r3, #8192
7009f5f0: 20400681     	subhs	r0, r0, r1, lsl #13
7009f5f4: e1500601     	cmp	r0, r1, lsl #12
7009f5f8: 22833a01     	addhs	r3, r3, #4096
7009f5fc: 20400601     	subhs	r0, r0, r1, lsl #12
7009f600: e1500581     	cmp	r0, r1, lsl #11
7009f604: 22833b02     	addhs	r3, r3, #2048
7009f608: 20400581     	subhs	r0, r0, r1, lsl #11
7009f60c: e1500501     	cmp	r0, r1, lsl #10
7009f610: 22833b01     	addhs	r3, r3, #1024
7009f614: 20400501     	subhs	r0, r0, r1, lsl #10
7009f618: e1500481     	cmp	r0, r1, lsl #9
7009f61c: 22833c02     	addhs	r3, r3, #512
7009f620: 20400481     	subhs	r0, r0, r1, lsl #9
7009f624: e1500401     	cmp	r0, r1, lsl #8
7009f628: 22833c01     	addhs	r3, r3, #256
7009f62c: 20400401     	subhs	r0, r0, r1, lsl #8
7009f630: e1500381     	cmp	r0, r1, lsl #7
7009f634: 22833080     	addhs	r3, r3, #128
7009f638: 20400381     	subhs	r0, r0, r1, lsl #7
7009f63c: e1500301     	cmp	r0, r1, lsl #6
7009f640: 22833040     	addhs	r3, r3, #64
7009f644: 20400301     	subhs	r0, r0, r1, lsl #6
7009f648: e1500281     	cmp	r0, r1, lsl #5
7009f64c: 22833020     	addhs	r3, r3, #32
7009f650: 20400281     	subhs	r0, r0, r1, lsl #5
7009f654: e1500201     	cmp	r0, r1, lsl #4
7009f658: 22833010     	addhs	r3, r3, #16
7009f65c: 20400201     	subhs	r0, r0, r1, lsl #4
7009f660: e1500181     	cmp	r0, r1, lsl #3
7009f664: 22833008     	addhs	r3, r3, #8
7009f668: 20400181     	subhs	r0, r0, r1, lsl #3
7009f66c: e1500101     	cmp	r0, r1, lsl #2
7009f670: 22833004     	addhs	r3, r3, #4
7009f674: 20400101     	subhs	r0, r0, r1, lsl #2
7009f678: e1500081     	cmp	r0, r1, lsl #1
7009f67c: 22833002     	addhs	r3, r3, #2
7009f680: 20400081     	subhs	r0, r0, r1, lsl #1
7009f684: e1500001     	cmp	r0, r1
7009f688: 22833001     	addhs	r3, r3, #1
7009f68c: 20400001     	subhs	r0, r0, r1
7009f690: e1a00003     	mov	r0, r3
7009f694: e12fff1e     	bx	lr
		...

7009f6a0 <SOC_moduleSetClockFrequency>:
; {
7009f6a0: b580         	push	{r7, lr}
7009f6a2: b090         	sub	sp, #0x40
7009f6a4: 900f         	str	r0, [sp, #0x3c]
7009f6a6: 910e         	str	r1, [sp, #0x38]
7009f6a8: 930d         	str	r3, [sp, #0x34]
7009f6aa: 920c         	str	r2, [sp, #0x30]
7009f6ac: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
7009f6ae: 9002         	str	r0, [sp, #0x8]
7009f6b0: 900b         	str	r0, [sp, #0x2c]
;     uint32_t i = 0U;
7009f6b2: 900a         	str	r0, [sp, #0x28]
;     uint64_t respClkRate = 0;
7009f6b4: 9009         	str	r0, [sp, #0x24]
7009f6b6: 9008         	str	r0, [sp, #0x20]
;     uint32_t numParents = 0U;
7009f6b8: 9007         	str	r0, [sp, #0x1c]
;     uint32_t moduleClockParentChanged = 0U;
7009f6ba: 9006         	str	r0, [sp, #0x18]
;     uint32_t clockStatus = 0U;
7009f6bc: 9005         	str	r0, [sp, #0x14]
;     uint32_t origParent = 0U;
7009f6be: 9004         	str	r0, [sp, #0x10]
;     uint32_t foundParent = 0U;
7009f6c0: 9003         	str	r0, [sp, #0xc]
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009f6c2: 980f         	ldr	r0, [sp, #0x3c]
;                                             clkId,
7009f6c4: 990e         	ldr	r1, [sp, #0x38]
7009f6c6: aa05         	add	r2, sp, #0x14
7009f6c8: f04f 33ff    	mov.w	r3, #0xffffffff
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009f6cc: f009 fd48    	bl	0x700a9160 <Sciclient_pmModuleGetClkStatus> @ imm = #0x9a90
7009f6d0: 900b         	str	r0, [sp, #0x2c]
;     if (status == SystemP_SUCCESS)
7009f6d2: 980b         	ldr	r0, [sp, #0x2c]
7009f6d4: b948         	cbnz	r0, 0x7009f6ea <SOC_moduleSetClockFrequency+0x4a> @ imm = #0x12
7009f6d6: e7ff         	b	0x7009f6d8 <SOC_moduleSetClockFrequency+0x38> @ imm = #-0x2
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009f6d8: 980f         	ldr	r0, [sp, #0x3c]
;                                                    clkId,
7009f6da: 990e         	ldr	r1, [sp, #0x38]
7009f6dc: aa07         	add	r2, sp, #0x1c
7009f6de: f04f 33ff    	mov.w	r3, #0xffffffff
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009f6e2: f008 fe1d    	bl	0x700a8320 <Sciclient_pmGetModuleClkNumParent> @ imm = #0x8c3a
7009f6e6: 900b         	str	r0, [sp, #0x2c]
;     }
7009f6e8: e7ff         	b	0x7009f6ea <SOC_moduleSetClockFrequency+0x4a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f6ea: 980b         	ldr	r0, [sp, #0x2c]
7009f6ec: b970         	cbnz	r0, 0x7009f70c <SOC_moduleSetClockFrequency+0x6c> @ imm = #0x1c
7009f6ee: e7ff         	b	0x7009f6f0 <SOC_moduleSetClockFrequency+0x50> @ imm = #-0x2
;         if(numParents > 1U)
7009f6f0: 9807         	ldr	r0, [sp, #0x1c]
7009f6f2: 2802         	cmp	r0, #0x2
7009f6f4: d309         	blo	0x7009f70a <SOC_moduleSetClockFrequency+0x6a> @ imm = #0x12
7009f6f6: e7ff         	b	0x7009f6f8 <SOC_moduleSetClockFrequency+0x58> @ imm = #-0x2
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009f6f8: 980f         	ldr	r0, [sp, #0x3c]
;                                                     clkId,
7009f6fa: 990e         	ldr	r1, [sp, #0x38]
7009f6fc: aa04         	add	r2, sp, #0x10
7009f6fe: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009f702: f009 fb4d    	bl	0x700a8da0 <Sciclient_pmGetModuleClkParent> @ imm = #0x969a
7009f706: 900b         	str	r0, [sp, #0x2c]
;         }
7009f708: e7ff         	b	0x7009f70a <SOC_moduleSetClockFrequency+0x6a> @ imm = #-0x2
;     }
7009f70a: e7ff         	b	0x7009f70c <SOC_moduleSetClockFrequency+0x6c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f70c: 980b         	ldr	r0, [sp, #0x2c]
7009f70e: b960         	cbnz	r0, 0x7009f72a <SOC_moduleSetClockFrequency+0x8a> @ imm = #0x18
7009f710: e7ff         	b	0x7009f712 <SOC_moduleSetClockFrequency+0x72> @ imm = #-0x2
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009f712: 980f         	ldr	r0, [sp, #0x3c]
;                                               clkId,
7009f714: 990e         	ldr	r1, [sp, #0x38]
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009f716: 466b         	mov	r3, sp
7009f718: f04f 32ff    	mov.w	r2, #0xffffffff
7009f71c: 601a         	str	r2, [r3]
7009f71e: 2300         	movs	r3, #0x0
7009f720: 461a         	mov	r2, r3
7009f722: f00a faf5    	bl	0x700a9d10 <Sciclient_pmModuleClkRequest> @ imm = #0xa5ea
7009f726: 900b         	str	r0, [sp, #0x2c]
;     }
7009f728: e7ff         	b	0x7009f72a <SOC_moduleSetClockFrequency+0x8a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f72a: 980b         	ldr	r0, [sp, #0x2c]
7009f72c: 2800         	cmp	r0, #0x0
7009f72e: d14d         	bne	0x7009f7cc <SOC_moduleSetClockFrequency+0x12c> @ imm = #0x9a
7009f730: e7ff         	b	0x7009f732 <SOC_moduleSetClockFrequency+0x92> @ imm = #-0x2
7009f732: 2000         	movs	r0, #0x0
;         foundParent = 0U;
7009f734: 9003         	str	r0, [sp, #0xc]
;         for(i=0U;i<numParents;i++)
7009f736: 900a         	str	r0, [sp, #0x28]
7009f738: e7ff         	b	0x7009f73a <SOC_moduleSetClockFrequency+0x9a> @ imm = #-0x2
7009f73a: 980a         	ldr	r0, [sp, #0x28]
7009f73c: 9907         	ldr	r1, [sp, #0x1c]
7009f73e: 4288         	cmp	r0, r1
7009f740: d243         	bhs	0x7009f7ca <SOC_moduleSetClockFrequency+0x12a> @ imm = #0x86
7009f742: e7ff         	b	0x7009f744 <SOC_moduleSetClockFrequency+0xa4> @ imm = #-0x2
;             if (numParents > 1U)
7009f744: 9807         	ldr	r0, [sp, #0x1c]
7009f746: 2802         	cmp	r0, #0x2
7009f748: d311         	blo	0x7009f76e <SOC_moduleSetClockFrequency+0xce> @ imm = #0x22
7009f74a: e7ff         	b	0x7009f74c <SOC_moduleSetClockFrequency+0xac> @ imm = #-0x2
;                 status = Sciclient_pmSetModuleClkParent(moduleId,
7009f74c: 980f         	ldr	r0, [sp, #0x3c]
;                                                         clkId,
7009f74e: 990e         	ldr	r1, [sp, #0x38]
;                                                         clkId+i+1,
7009f750: 9a0a         	ldr	r2, [sp, #0x28]
7009f752: 440a         	add	r2, r1
7009f754: 3201         	adds	r2, #0x1
7009f756: f04f 33ff    	mov.w	r3, #0xffffffff
;                 status = Sciclient_pmSetModuleClkParent(moduleId,
7009f75a: f009 fb71    	bl	0x700a8e40 <Sciclient_pmSetModuleClkParent> @ imm = #0x96e2
7009f75e: 900b         	str	r0, [sp, #0x2c]
;                 if (status == SystemP_SUCCESS)
7009f760: 980b         	ldr	r0, [sp, #0x2c]
7009f762: b918         	cbnz	r0, 0x7009f76c <SOC_moduleSetClockFrequency+0xcc> @ imm = #0x6
7009f764: e7ff         	b	0x7009f766 <SOC_moduleSetClockFrequency+0xc6> @ imm = #-0x2
7009f766: 2001         	movs	r0, #0x1
;                     moduleClockParentChanged = 1U;
7009f768: 9006         	str	r0, [sp, #0x18]
;                 }
7009f76a: e7ff         	b	0x7009f76c <SOC_moduleSetClockFrequency+0xcc> @ imm = #-0x2
;             }
7009f76c: e7ff         	b	0x7009f76e <SOC_moduleSetClockFrequency+0xce> @ imm = #-0x2
;             if (status == SystemP_SUCCESS)
7009f76e: 980b         	ldr	r0, [sp, #0x2c]
7009f770: b988         	cbnz	r0, 0x7009f796 <SOC_moduleSetClockFrequency+0xf6> @ imm = #0x22
7009f772: e7ff         	b	0x7009f774 <SOC_moduleSetClockFrequency+0xd4> @ imm = #-0x2
;                 status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009f774: 980f         	ldr	r0, [sp, #0x3c]
;                                                         clkId,
7009f776: 990e         	ldr	r1, [sp, #0x38]
;                                                         clkRate,
7009f778: 9a0c         	ldr	r2, [sp, #0x30]
7009f77a: 9b0d         	ldr	r3, [sp, #0x34]
;                 status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009f77c: 46ee         	mov	lr, sp
7009f77e: f04f 3cff    	mov.w	r12, #0xffffffff
7009f782: f8ce c004    	str.w	r12, [lr, #0x4]
7009f786: f10d 0c20    	add.w	r12, sp, #0x20
7009f78a: f8ce c000    	str.w	r12, [lr]
7009f78e: f003 fddf    	bl	0x700a3350 <Sciclient_pmQueryModuleClkFreq> @ imm = #0x3bbe
7009f792: 900b         	str	r0, [sp, #0x2c]
;             }
7009f794: e7ff         	b	0x7009f796 <SOC_moduleSetClockFrequency+0xf6> @ imm = #-0x2
;             if (status == SystemP_SUCCESS)
7009f796: 980b         	ldr	r0, [sp, #0x2c]
7009f798: b970         	cbnz	r0, 0x7009f7b8 <SOC_moduleSetClockFrequency+0x118> @ imm = #0x1c
7009f79a: e7ff         	b	0x7009f79c <SOC_moduleSetClockFrequency+0xfc> @ imm = #-0x2
;                 if(respClkRate == clkRate)
7009f79c: 9808         	ldr	r0, [sp, #0x20]
7009f79e: 9909         	ldr	r1, [sp, #0x24]
7009f7a0: 9a0c         	ldr	r2, [sp, #0x30]
7009f7a2: 9b0d         	ldr	r3, [sp, #0x34]
7009f7a4: 4059         	eors	r1, r3
7009f7a6: ea80 0002    	eor.w	r0, r0, r2
7009f7aa: 4308         	orrs	r0, r1
7009f7ac: b918         	cbnz	r0, 0x7009f7b6 <SOC_moduleSetClockFrequency+0x116> @ imm = #0x6
7009f7ae: e7ff         	b	0x7009f7b0 <SOC_moduleSetClockFrequency+0x110> @ imm = #-0x2
7009f7b0: 2001         	movs	r0, #0x1
;                     foundParent = 1U;
7009f7b2: 9003         	str	r0, [sp, #0xc]
;                 }
7009f7b4: e7ff         	b	0x7009f7b6 <SOC_moduleSetClockFrequency+0x116> @ imm = #-0x2
;             }
7009f7b6: e7ff         	b	0x7009f7b8 <SOC_moduleSetClockFrequency+0x118> @ imm = #-0x2
;             if(foundParent)
7009f7b8: 9803         	ldr	r0, [sp, #0xc]
7009f7ba: b108         	cbz	r0, 0x7009f7c0 <SOC_moduleSetClockFrequency+0x120> @ imm = #0x2
7009f7bc: e7ff         	b	0x7009f7be <SOC_moduleSetClockFrequency+0x11e> @ imm = #-0x2
;                 break; /* found a parent to set clock frequency, rebak form the loop */
7009f7be: e004         	b	0x7009f7ca <SOC_moduleSetClockFrequency+0x12a> @ imm = #0x8
;         }
7009f7c0: e7ff         	b	0x7009f7c2 <SOC_moduleSetClockFrequency+0x122> @ imm = #-0x2
;         for(i=0U;i<numParents;i++)
7009f7c2: 980a         	ldr	r0, [sp, #0x28]
7009f7c4: 3001         	adds	r0, #0x1
7009f7c6: 900a         	str	r0, [sp, #0x28]
7009f7c8: e7b7         	b	0x7009f73a <SOC_moduleSetClockFrequency+0x9a> @ imm = #-0x92
;     }
7009f7ca: e7ff         	b	0x7009f7cc <SOC_moduleSetClockFrequency+0x12c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f7cc: 980b         	ldr	r0, [sp, #0x2c]
7009f7ce: b9d0         	cbnz	r0, 0x7009f806 <SOC_moduleSetClockFrequency+0x166> @ imm = #0x34
7009f7d0: e7ff         	b	0x7009f7d2 <SOC_moduleSetClockFrequency+0x132> @ imm = #-0x2
;         if(foundParent == 1U)
7009f7d2: 9803         	ldr	r0, [sp, #0xc]
7009f7d4: 2801         	cmp	r0, #0x1
7009f7d6: d111         	bne	0x7009f7fc <SOC_moduleSetClockFrequency+0x15c> @ imm = #0x22
7009f7d8: e7ff         	b	0x7009f7da <SOC_moduleSetClockFrequency+0x13a> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009f7da: 980f         	ldr	r0, [sp, #0x3c]
;                                                   clkId,
7009f7dc: 990e         	ldr	r1, [sp, #0x38]
;                                                   clkRate,
7009f7de: 9a0c         	ldr	r2, [sp, #0x30]
7009f7e0: 9b0d         	ldr	r3, [sp, #0x34]
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009f7e2: 46ee         	mov	lr, sp
7009f7e4: f04f 3cff    	mov.w	r12, #0xffffffff
7009f7e8: f8ce c004    	str.w	r12, [lr, #0x4]
7009f7ec: f44f 7c00    	mov.w	r12, #0x200
7009f7f0: f8ce c000    	str.w	r12, [lr]
7009f7f4: f005 fa64    	bl	0x700a4cc0 <Sciclient_pmSetModuleClkFreq> @ imm = #0x54c8
7009f7f8: 900b         	str	r0, [sp, #0x2c]
;         }
7009f7fa: e003         	b	0x7009f804 <SOC_moduleSetClockFrequency+0x164> @ imm = #0x6
7009f7fc: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009f800: 900b         	str	r0, [sp, #0x2c]
7009f802: e7ff         	b	0x7009f804 <SOC_moduleSetClockFrequency+0x164> @ imm = #-0x2
;     }
7009f804: e7ff         	b	0x7009f806 <SOC_moduleSetClockFrequency+0x166> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f806: 980b         	ldr	r0, [sp, #0x2c]
7009f808: b988         	cbnz	r0, 0x7009f82e <SOC_moduleSetClockFrequency+0x18e> @ imm = #0x22
7009f80a: e7ff         	b	0x7009f80c <SOC_moduleSetClockFrequency+0x16c> @ imm = #-0x2
;         if (clockStatus == TISCI_MSG_VALUE_CLOCK_HW_STATE_NOT_READY)
7009f80c: 9805         	ldr	r0, [sp, #0x14]
7009f80e: b968         	cbnz	r0, 0x7009f82c <SOC_moduleSetClockFrequency+0x18c> @ imm = #0x1a
7009f810: e7ff         	b	0x7009f812 <SOC_moduleSetClockFrequency+0x172> @ imm = #-0x2
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009f812: 980f         	ldr	r0, [sp, #0x3c]
;                                                   clkId,
7009f814: 990e         	ldr	r1, [sp, #0x38]
;                                                   clockStatus,
7009f816: 9a05         	ldr	r2, [sp, #0x14]
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009f818: 46ec         	mov	r12, sp
7009f81a: f04f 33ff    	mov.w	r3, #0xffffffff
7009f81e: f8cc 3000    	str.w	r3, [r12]
7009f822: 2300         	movs	r3, #0x0
7009f824: f00a fa74    	bl	0x700a9d10 <Sciclient_pmModuleClkRequest> @ imm = #0xa4e8
7009f828: 900b         	str	r0, [sp, #0x2c]
;         }
7009f82a: e7ff         	b	0x7009f82c <SOC_moduleSetClockFrequency+0x18c> @ imm = #-0x2
;     }
7009f82c: e7ff         	b	0x7009f82e <SOC_moduleSetClockFrequency+0x18e> @ imm = #-0x2
;     if (status != SystemP_SUCCESS)
7009f82e: 980b         	ldr	r0, [sp, #0x2c]
7009f830: b168         	cbz	r0, 0x7009f84e <SOC_moduleSetClockFrequency+0x1ae> @ imm = #0x1a
7009f832: e7ff         	b	0x7009f834 <SOC_moduleSetClockFrequency+0x194> @ imm = #-0x2
;         if (moduleClockParentChanged == 1U)
7009f834: 9806         	ldr	r0, [sp, #0x18]
7009f836: 2801         	cmp	r0, #0x1
7009f838: d108         	bne	0x7009f84c <SOC_moduleSetClockFrequency+0x1ac> @ imm = #0x10
7009f83a: e7ff         	b	0x7009f83c <SOC_moduleSetClockFrequency+0x19c> @ imm = #-0x2
;             Sciclient_pmSetModuleClkParent(moduleId,
7009f83c: 980f         	ldr	r0, [sp, #0x3c]
;                                            clkId,
7009f83e: 990e         	ldr	r1, [sp, #0x38]
;                                            origParent,
7009f840: 9a04         	ldr	r2, [sp, #0x10]
7009f842: f04f 33ff    	mov.w	r3, #0xffffffff
;             Sciclient_pmSetModuleClkParent(moduleId,
7009f846: f009 fafb    	bl	0x700a8e40 <Sciclient_pmSetModuleClkParent> @ imm = #0x95f6
;         }
7009f84a: e7ff         	b	0x7009f84c <SOC_moduleSetClockFrequency+0x1ac> @ imm = #-0x2
;     }
7009f84c: e7ff         	b	0x7009f84e <SOC_moduleSetClockFrequency+0x1ae> @ imm = #-0x2
;     return status;
7009f84e: 980b         	ldr	r0, [sp, #0x2c]
7009f850: b010         	add	sp, #0x40
7009f852: bd80         	pop	{r7, pc}
		...

7009f860 <SOC_moduleSetClockFrequencyWithParent>:
; {
7009f860: b580         	push	{r7, lr}
7009f862: b092         	sub	sp, #0x48
7009f864: 460b         	mov	r3, r1
7009f866: 4684         	mov	r12, r0
7009f868: 9915         	ldr	r1, [sp, #0x54]
7009f86a: 9814         	ldr	r0, [sp, #0x50]
7009f86c: f8cd c044    	str.w	r12, [sp, #0x44]
7009f870: 9310         	str	r3, [sp, #0x40]
7009f872: 920f         	str	r2, [sp, #0x3c]
7009f874: 910d         	str	r1, [sp, #0x34]
7009f876: 900c         	str	r0, [sp, #0x30]
7009f878: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
7009f87a: 9002         	str	r0, [sp, #0x8]
7009f87c: 900b         	str	r0, [sp, #0x2c]
;     uint64_t respClkRate = 0;
7009f87e: 9009         	str	r0, [sp, #0x24]
7009f880: 9008         	str	r0, [sp, #0x20]
;     uint32_t numParents = 0U;
7009f882: 9007         	str	r0, [sp, #0x1c]
;     uint32_t moduleClockParentChanged = 0U;
7009f884: 9006         	str	r0, [sp, #0x18]
;     uint32_t clockStatus = 0U;
7009f886: 9005         	str	r0, [sp, #0x14]
;     uint32_t origParent = 0U;
7009f888: 9004         	str	r0, [sp, #0x10]
;     uint32_t foundParent = 0U;
7009f88a: 9003         	str	r0, [sp, #0xc]
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009f88c: 9811         	ldr	r0, [sp, #0x44]
;                                             clkId,
7009f88e: 9910         	ldr	r1, [sp, #0x40]
7009f890: aa05         	add	r2, sp, #0x14
7009f892: f04f 33ff    	mov.w	r3, #0xffffffff
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009f896: f009 fc63    	bl	0x700a9160 <Sciclient_pmModuleGetClkStatus> @ imm = #0x98c6
7009f89a: 900b         	str	r0, [sp, #0x2c]
;     if (status == SystemP_SUCCESS)
7009f89c: 980b         	ldr	r0, [sp, #0x2c]
7009f89e: b948         	cbnz	r0, 0x7009f8b4 <SOC_moduleSetClockFrequencyWithParent+0x54> @ imm = #0x12
7009f8a0: e7ff         	b	0x7009f8a2 <SOC_moduleSetClockFrequencyWithParent+0x42> @ imm = #-0x2
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009f8a2: 9811         	ldr	r0, [sp, #0x44]
;                                                    clkId,
7009f8a4: 9910         	ldr	r1, [sp, #0x40]
7009f8a6: aa07         	add	r2, sp, #0x1c
7009f8a8: f04f 33ff    	mov.w	r3, #0xffffffff
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009f8ac: f008 fd38    	bl	0x700a8320 <Sciclient_pmGetModuleClkNumParent> @ imm = #0x8a70
7009f8b0: 900b         	str	r0, [sp, #0x2c]
;     }
7009f8b2: e7ff         	b	0x7009f8b4 <SOC_moduleSetClockFrequencyWithParent+0x54> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f8b4: 980b         	ldr	r0, [sp, #0x2c]
7009f8b6: b970         	cbnz	r0, 0x7009f8d6 <SOC_moduleSetClockFrequencyWithParent+0x76> @ imm = #0x1c
7009f8b8: e7ff         	b	0x7009f8ba <SOC_moduleSetClockFrequencyWithParent+0x5a> @ imm = #-0x2
;         if(numParents > 1U)
7009f8ba: 9807         	ldr	r0, [sp, #0x1c]
7009f8bc: 2802         	cmp	r0, #0x2
7009f8be: d309         	blo	0x7009f8d4 <SOC_moduleSetClockFrequencyWithParent+0x74> @ imm = #0x12
7009f8c0: e7ff         	b	0x7009f8c2 <SOC_moduleSetClockFrequencyWithParent+0x62> @ imm = #-0x2
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009f8c2: 9811         	ldr	r0, [sp, #0x44]
;                                                     clkId,
7009f8c4: 9910         	ldr	r1, [sp, #0x40]
7009f8c6: aa04         	add	r2, sp, #0x10
7009f8c8: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009f8cc: f009 fa68    	bl	0x700a8da0 <Sciclient_pmGetModuleClkParent> @ imm = #0x94d0
7009f8d0: 900b         	str	r0, [sp, #0x2c]
;         }
7009f8d2: e7ff         	b	0x7009f8d4 <SOC_moduleSetClockFrequencyWithParent+0x74> @ imm = #-0x2
;     }
7009f8d4: e7ff         	b	0x7009f8d6 <SOC_moduleSetClockFrequencyWithParent+0x76> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f8d6: 980b         	ldr	r0, [sp, #0x2c]
7009f8d8: b960         	cbnz	r0, 0x7009f8f4 <SOC_moduleSetClockFrequencyWithParent+0x94> @ imm = #0x18
7009f8da: e7ff         	b	0x7009f8dc <SOC_moduleSetClockFrequencyWithParent+0x7c> @ imm = #-0x2
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009f8dc: 9811         	ldr	r0, [sp, #0x44]
;                                               clkId,
7009f8de: 9910         	ldr	r1, [sp, #0x40]
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009f8e0: 466b         	mov	r3, sp
7009f8e2: f04f 32ff    	mov.w	r2, #0xffffffff
7009f8e6: 601a         	str	r2, [r3]
7009f8e8: 2300         	movs	r3, #0x0
7009f8ea: 461a         	mov	r2, r3
7009f8ec: f00a fa10    	bl	0x700a9d10 <Sciclient_pmModuleClkRequest> @ imm = #0xa420
7009f8f0: 900b         	str	r0, [sp, #0x2c]
;     }
7009f8f2: e7ff         	b	0x7009f8f4 <SOC_moduleSetClockFrequencyWithParent+0x94> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f8f4: 980b         	ldr	r0, [sp, #0x2c]
7009f8f6: b960         	cbnz	r0, 0x7009f912 <SOC_moduleSetClockFrequencyWithParent+0xb2> @ imm = #0x18
7009f8f8: e7ff         	b	0x7009f8fa <SOC_moduleSetClockFrequencyWithParent+0x9a> @ imm = #-0x2
;         if (clkParent > (clkId + numParents))
7009f8fa: 980f         	ldr	r0, [sp, #0x3c]
7009f8fc: 9910         	ldr	r1, [sp, #0x40]
7009f8fe: 9a07         	ldr	r2, [sp, #0x1c]
7009f900: 4411         	add	r1, r2
7009f902: 4288         	cmp	r0, r1
7009f904: d904         	bls	0x7009f910 <SOC_moduleSetClockFrequencyWithParent+0xb0> @ imm = #0x8
7009f906: e7ff         	b	0x7009f908 <SOC_moduleSetClockFrequencyWithParent+0xa8> @ imm = #-0x2
7009f908: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009f90c: 900b         	str	r0, [sp, #0x2c]
;         }
7009f90e: e7ff         	b	0x7009f910 <SOC_moduleSetClockFrequencyWithParent+0xb0> @ imm = #-0x2
;     }
7009f910: e7ff         	b	0x7009f912 <SOC_moduleSetClockFrequencyWithParent+0xb2> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f912: 980b         	ldr	r0, [sp, #0x2c]
7009f914: b9a8         	cbnz	r0, 0x7009f942 <SOC_moduleSetClockFrequencyWithParent+0xe2> @ imm = #0x2a
7009f916: e7ff         	b	0x7009f918 <SOC_moduleSetClockFrequencyWithParent+0xb8> @ imm = #-0x2
;         if (clkParent != origParent)
7009f918: 980f         	ldr	r0, [sp, #0x3c]
7009f91a: 9904         	ldr	r1, [sp, #0x10]
7009f91c: 4288         	cmp	r0, r1
7009f91e: d00f         	beq	0x7009f940 <SOC_moduleSetClockFrequencyWithParent+0xe0> @ imm = #0x1e
7009f920: e7ff         	b	0x7009f922 <SOC_moduleSetClockFrequencyWithParent+0xc2> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkParent(moduleId,
7009f922: 9811         	ldr	r0, [sp, #0x44]
;                                                         clkId,
7009f924: 9910         	ldr	r1, [sp, #0x40]
;                                                         clkParent,
7009f926: 9a0f         	ldr	r2, [sp, #0x3c]
7009f928: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmSetModuleClkParent(moduleId,
7009f92c: f009 fa88    	bl	0x700a8e40 <Sciclient_pmSetModuleClkParent> @ imm = #0x9510
7009f930: 900b         	str	r0, [sp, #0x2c]
;             if (status == SystemP_SUCCESS)
7009f932: 980b         	ldr	r0, [sp, #0x2c]
7009f934: b918         	cbnz	r0, 0x7009f93e <SOC_moduleSetClockFrequencyWithParent+0xde> @ imm = #0x6
7009f936: e7ff         	b	0x7009f938 <SOC_moduleSetClockFrequencyWithParent+0xd8> @ imm = #-0x2
7009f938: 2001         	movs	r0, #0x1
;                 moduleClockParentChanged = 1U;
7009f93a: 9006         	str	r0, [sp, #0x18]
;             }
7009f93c: e7ff         	b	0x7009f93e <SOC_moduleSetClockFrequencyWithParent+0xde> @ imm = #-0x2
;         }
7009f93e: e7ff         	b	0x7009f940 <SOC_moduleSetClockFrequencyWithParent+0xe0> @ imm = #-0x2
;     }
7009f940: e7ff         	b	0x7009f942 <SOC_moduleSetClockFrequencyWithParent+0xe2> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f942: 980b         	ldr	r0, [sp, #0x2c]
7009f944: b988         	cbnz	r0, 0x7009f96a <SOC_moduleSetClockFrequencyWithParent+0x10a> @ imm = #0x22
7009f946: e7ff         	b	0x7009f948 <SOC_moduleSetClockFrequencyWithParent+0xe8> @ imm = #-0x2
;         status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009f948: 9811         	ldr	r0, [sp, #0x44]
;                                                 clkId,
7009f94a: 9910         	ldr	r1, [sp, #0x40]
;                                                 clkRate,
7009f94c: 9a0c         	ldr	r2, [sp, #0x30]
7009f94e: 9b0d         	ldr	r3, [sp, #0x34]
;         status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009f950: 46ee         	mov	lr, sp
7009f952: f04f 3cff    	mov.w	r12, #0xffffffff
7009f956: f8ce c004    	str.w	r12, [lr, #0x4]
7009f95a: f10d 0c20    	add.w	r12, sp, #0x20
7009f95e: f8ce c000    	str.w	r12, [lr]
7009f962: f003 fcf5    	bl	0x700a3350 <Sciclient_pmQueryModuleClkFreq> @ imm = #0x39ea
7009f966: 900b         	str	r0, [sp, #0x2c]
;     }
7009f968: e7ff         	b	0x7009f96a <SOC_moduleSetClockFrequencyWithParent+0x10a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f96a: 980b         	ldr	r0, [sp, #0x2c]
7009f96c: b970         	cbnz	r0, 0x7009f98c <SOC_moduleSetClockFrequencyWithParent+0x12c> @ imm = #0x1c
7009f96e: e7ff         	b	0x7009f970 <SOC_moduleSetClockFrequencyWithParent+0x110> @ imm = #-0x2
;         if(respClkRate == clkRate)
7009f970: 9808         	ldr	r0, [sp, #0x20]
7009f972: 9909         	ldr	r1, [sp, #0x24]
7009f974: 9a0c         	ldr	r2, [sp, #0x30]
7009f976: 9b0d         	ldr	r3, [sp, #0x34]
7009f978: 4059         	eors	r1, r3
7009f97a: ea80 0002    	eor.w	r0, r0, r2
7009f97e: 4308         	orrs	r0, r1
7009f980: b918         	cbnz	r0, 0x7009f98a <SOC_moduleSetClockFrequencyWithParent+0x12a> @ imm = #0x6
7009f982: e7ff         	b	0x7009f984 <SOC_moduleSetClockFrequencyWithParent+0x124> @ imm = #-0x2
7009f984: 2001         	movs	r0, #0x1
;             foundParent = 1U;
7009f986: 9003         	str	r0, [sp, #0xc]
;         }
7009f988: e7ff         	b	0x7009f98a <SOC_moduleSetClockFrequencyWithParent+0x12a> @ imm = #-0x2
;     }
7009f98a: e7ff         	b	0x7009f98c <SOC_moduleSetClockFrequencyWithParent+0x12c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f98c: 980b         	ldr	r0, [sp, #0x2c]
7009f98e: b9d0         	cbnz	r0, 0x7009f9c6 <SOC_moduleSetClockFrequencyWithParent+0x166> @ imm = #0x34
7009f990: e7ff         	b	0x7009f992 <SOC_moduleSetClockFrequencyWithParent+0x132> @ imm = #-0x2
;         if(foundParent == 1U)
7009f992: 9803         	ldr	r0, [sp, #0xc]
7009f994: 2801         	cmp	r0, #0x1
7009f996: d111         	bne	0x7009f9bc <SOC_moduleSetClockFrequencyWithParent+0x15c> @ imm = #0x22
7009f998: e7ff         	b	0x7009f99a <SOC_moduleSetClockFrequencyWithParent+0x13a> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009f99a: 9811         	ldr	r0, [sp, #0x44]
;                                                   clkId,
7009f99c: 9910         	ldr	r1, [sp, #0x40]
;                                                   clkRate,
7009f99e: 9a0c         	ldr	r2, [sp, #0x30]
7009f9a0: 9b0d         	ldr	r3, [sp, #0x34]
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009f9a2: 46ee         	mov	lr, sp
7009f9a4: f04f 3cff    	mov.w	r12, #0xffffffff
7009f9a8: f8ce c004    	str.w	r12, [lr, #0x4]
7009f9ac: f44f 7c00    	mov.w	r12, #0x200
7009f9b0: f8ce c000    	str.w	r12, [lr]
7009f9b4: f005 f984    	bl	0x700a4cc0 <Sciclient_pmSetModuleClkFreq> @ imm = #0x5308
7009f9b8: 900b         	str	r0, [sp, #0x2c]
;         }
7009f9ba: e003         	b	0x7009f9c4 <SOC_moduleSetClockFrequencyWithParent+0x164> @ imm = #0x6
7009f9bc: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009f9c0: 900b         	str	r0, [sp, #0x2c]
7009f9c2: e7ff         	b	0x7009f9c4 <SOC_moduleSetClockFrequencyWithParent+0x164> @ imm = #-0x2
;     }
7009f9c4: e7ff         	b	0x7009f9c6 <SOC_moduleSetClockFrequencyWithParent+0x166> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f9c6: 980b         	ldr	r0, [sp, #0x2c]
7009f9c8: b988         	cbnz	r0, 0x7009f9ee <SOC_moduleSetClockFrequencyWithParent+0x18e> @ imm = #0x22
7009f9ca: e7ff         	b	0x7009f9cc <SOC_moduleSetClockFrequencyWithParent+0x16c> @ imm = #-0x2
;         if (clockStatus == TISCI_MSG_VALUE_CLOCK_HW_STATE_NOT_READY)
7009f9cc: 9805         	ldr	r0, [sp, #0x14]
7009f9ce: b968         	cbnz	r0, 0x7009f9ec <SOC_moduleSetClockFrequencyWithParent+0x18c> @ imm = #0x1a
7009f9d0: e7ff         	b	0x7009f9d2 <SOC_moduleSetClockFrequencyWithParent+0x172> @ imm = #-0x2
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009f9d2: 9811         	ldr	r0, [sp, #0x44]
;                                                   clkId,
7009f9d4: 9910         	ldr	r1, [sp, #0x40]
;                                                   clockStatus,
7009f9d6: 9a05         	ldr	r2, [sp, #0x14]
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009f9d8: 46ec         	mov	r12, sp
7009f9da: f04f 33ff    	mov.w	r3, #0xffffffff
7009f9de: f8cc 3000    	str.w	r3, [r12]
7009f9e2: 2300         	movs	r3, #0x0
7009f9e4: f00a f994    	bl	0x700a9d10 <Sciclient_pmModuleClkRequest> @ imm = #0xa328
7009f9e8: 900b         	str	r0, [sp, #0x2c]
;         }
7009f9ea: e7ff         	b	0x7009f9ec <SOC_moduleSetClockFrequencyWithParent+0x18c> @ imm = #-0x2
;     }
7009f9ec: e7ff         	b	0x7009f9ee <SOC_moduleSetClockFrequencyWithParent+0x18e> @ imm = #-0x2
;     if (status != SystemP_SUCCESS)
7009f9ee: 980b         	ldr	r0, [sp, #0x2c]
7009f9f0: b168         	cbz	r0, 0x7009fa0e <SOC_moduleSetClockFrequencyWithParent+0x1ae> @ imm = #0x1a
7009f9f2: e7ff         	b	0x7009f9f4 <SOC_moduleSetClockFrequencyWithParent+0x194> @ imm = #-0x2
;         if (moduleClockParentChanged == 1U)
7009f9f4: 9806         	ldr	r0, [sp, #0x18]
7009f9f6: 2801         	cmp	r0, #0x1
7009f9f8: d108         	bne	0x7009fa0c <SOC_moduleSetClockFrequencyWithParent+0x1ac> @ imm = #0x10
7009f9fa: e7ff         	b	0x7009f9fc <SOC_moduleSetClockFrequencyWithParent+0x19c> @ imm = #-0x2
;             Sciclient_pmSetModuleClkParent(moduleId,
7009f9fc: 9811         	ldr	r0, [sp, #0x44]
;                                            clkId,
7009f9fe: 9910         	ldr	r1, [sp, #0x40]
;                                            origParent,
7009fa00: 9a04         	ldr	r2, [sp, #0x10]
7009fa02: f04f 33ff    	mov.w	r3, #0xffffffff
;             Sciclient_pmSetModuleClkParent(moduleId,
7009fa06: f009 fa1b    	bl	0x700a8e40 <Sciclient_pmSetModuleClkParent> @ imm = #0x9436
;         }
7009fa0a: e7ff         	b	0x7009fa0c <SOC_moduleSetClockFrequencyWithParent+0x1ac> @ imm = #-0x2
;     }
7009fa0c: e7ff         	b	0x7009fa0e <SOC_moduleSetClockFrequencyWithParent+0x1ae> @ imm = #-0x2
;     return status;
7009fa0e: 980b         	ldr	r0, [sp, #0x2c]
7009fa10: b012         	add	sp, #0x48
7009fa12: bd80         	pop	{r7, pc}

7009fa14 <memalign>:
7009fa14: e92d4bf0     	push	{r4, r5, r6, r7, r8, r9, r11, lr}
7009fa18: e59f5190     	ldr	r5, [pc, #0x190]        @ 0x7009fbb0 <memalign+0x19c>
7009fa1c: e3a02000     	mov	r2, #0
7009fa20: e3a08000     	mov	r8, #0
7009fa24: e2413001     	sub	r3, r1, #1
7009fa28: e2454008     	sub	r4, r5, #8
7009fa2c: e3550007     	cmp	r5, #7
7009fa30: 81a02004     	movhi	r2, r4
7009fa34: e1530002     	cmp	r3, r2
7009fa38: 2a00005a     	bhs	0x7009fba8 <memalign+0x194> @ imm = #0x168
7009fa3c: e2402001     	sub	r2, r0, #1
7009fa40: e59f316c     	ldr	r3, [pc, #0x16c]        @ 0x7009fbb4 <memalign+0x1a0>
7009fa44: e3a07008     	mov	r7, #8
7009fa48: e2816007     	add	r6, r1, #7
7009fa4c: e1100002     	tst	r0, r2
7009fa50: 01a07000     	moveq	r7, r0
7009fa54: e3500007     	cmp	r0, #7
7009fa58: e5930000     	ldr	r0, [r3]
7009fa5c: e3a02008     	mov	r2, #8
7009fa60: 91a07002     	movls	r7, r2
7009fa64: e12fff30     	blx	r0
7009fa68: e59f0148     	ldr	r0, [pc, #0x148]        @ 0x7009fbb8 <memalign+0x1a4>
7009fa6c: e5d01000     	ldrb	r1, [r0]
7009fa70: e3510000     	cmp	r1, #0
7009fa74: 1a000011     	bne	0x7009fac0 <memalign+0xac> @ imm = #0x44
7009fa78: e3a02000     	mov	r2, #0
7009fa7c: e3a01000     	mov	r1, #0
7009fa80: e3550007     	cmp	r5, #7
7009fa84: 81a02004     	movhi	r2, r4
7009fa88: e3520000     	cmp	r2, #0
7009fa8c: 1a000002     	bne	0x7009fa9c <memalign+0x88> @ imm = #0x8
7009fa90: e59f2124     	ldr	r2, [pc, #0x124]        @ 0x7009fbbc <memalign+0x1a8>
7009fa94: e5821000     	str	r1, [r2]
7009fa98: ea000006     	b	0x7009fab8 <memalign+0xa4> @ imm = #0x18
7009fa9c: e59f211c     	ldr	r2, [pc, #0x11c]        @ 0x7009fbc0 <memalign+0x1ac>
7009faa0: e3550007     	cmp	r5, #7
7009faa4: 91a04001     	movls	r4, r1
7009faa8: e59f310c     	ldr	r3, [pc, #0x10c]        @ 0x7009fbbc <memalign+0x1a8>
7009faac: e5821008     	str	r1, [r2, #0x8]
7009fab0: e5832000     	str	r2, [r3]
7009fab4: e5824000     	str	r4, [r2]
7009fab8: e3a01001     	mov	r1, #1
7009fabc: e5c01000     	strb	r1, [r0]
7009fac0: e59f50f4     	ldr	r5, [pc, #0xf4]         @ 0x7009fbbc <memalign+0x1a8>
7009fac4: e3c69007     	bic	r9, r6, #7
7009fac8: e2470001     	sub	r0, r7, #1
7009facc: e2671000     	rsb	r1, r7, #0
7009fad0: e5956000     	ldr	r6, [r5]
7009fad4: e3560000     	cmp	r6, #0
7009fad8: 0a00002f     	beq	0x7009fb9c <memalign+0x188> @ imm = #0xbc
7009fadc: e2865008     	add	r5, r6, #8
7009fae0: e0802005     	add	r2, r0, r5
7009fae4: e0024001     	and	r4, r2, r1
7009fae8: e1550004     	cmp	r5, r4
7009faec: 0a00000c     	beq	0x7009fb24 <memalign+0x110> @ imm = #0x30
7009faf0: e2862010     	add	r2, r6, #16
7009faf4: e2443008     	sub	r3, r4, #8
7009faf8: e1520003     	cmp	r2, r3
7009fafc: 9a000001     	bls	0x7009fb08 <memalign+0xf4> @ imm = #0x4
7009fb00: e0844007     	add	r4, r4, r7
7009fb04: eafffffa     	b	0x7009faf4 <memalign+0xe0> @ imm = #-0x18
7009fb08: e5962000     	ldr	r2, [r6]
7009fb0c: e0843009     	add	r3, r4, r9
7009fb10: e3c22001     	bic	r2, r2, #1
7009fb14: e0852002     	add	r2, r5, r2
7009fb18: e1520003     	cmp	r2, r3
7009fb1c: 3affffeb     	blo	0x7009fad0 <memalign+0xbc> @ imm = #-0x54
7009fb20: ea000004     	b	0x7009fb38 <memalign+0x124> @ imm = #0x10
7009fb24: e5962000     	ldr	r2, [r6]
7009fb28: e3c22001     	bic	r2, r2, #1
7009fb2c: e1520009     	cmp	r2, r9
7009fb30: baffffe6     	blt	0x7009fad0 <memalign+0xbc> @ imm = #-0x68
7009fb34: e1a04005     	mov	r4, r5
7009fb38: e1a00006     	mov	r0, r6
7009fb3c: eb003a04     	bl	0x700ae354 <free_list_remove> @ imm = #0xe810
7009fb40: e1540005     	cmp	r4, r5
7009fb44: 0a00000c     	beq	0x7009fb7c <memalign+0x168> @ imm = #0x30
7009fb48: e5960000     	ldr	r0, [r6]
7009fb4c: e0441005     	sub	r1, r4, r5
7009fb50: e2412008     	sub	r2, r1, #8
7009fb54: e1a04006     	mov	r4, r6
7009fb58: e3c00001     	bic	r0, r0, #1
7009fb5c: e0400001     	sub	r0, r0, r1
7009fb60: e3c21001     	bic	r1, r2, #1
7009fb64: e3800001     	orr	r0, r0, #1
7009fb68: e6842001     	str	r2, [r4], r1
7009fb6c: e5a40008     	str	r0, [r4, #0x8]!
7009fb70: e1a00006     	mov	r0, r6
7009fb74: eb0037b9     	bl	0x700ada60 <free_list_insert> @ imm = #0xdee4
7009fb78: e1a06004     	mov	r6, r4
7009fb7c: e1a00006     	mov	r0, r6
7009fb80: e1a01009     	mov	r1, r9
7009fb84: eb0022be     	bl	0x700a8684 <split>      @ imm = #0x8af8
7009fb88: e59f0034     	ldr	r0, [pc, #0x34]         @ 0x7009fbc4 <memalign+0x1b0>
7009fb8c: e5900000     	ldr	r0, [r0]
7009fb90: e12fff30     	blx	r0
7009fb94: e2868008     	add	r8, r6, #8
7009fb98: ea000002     	b	0x7009fba8 <memalign+0x194> @ imm = #0x8
7009fb9c: e59f0020     	ldr	r0, [pc, #0x20]         @ 0x7009fbc4 <memalign+0x1b0>
7009fba0: e5900000     	ldr	r0, [r0]
7009fba4: e12fff30     	blx	r0
7009fba8: e1a00008     	mov	r0, r8
7009fbac: e8bd8bf0     	pop	{r4, r5, r6, r7, r8, r9, r11, pc}
7009fbb0: 00 00 01 00  	.word	0x00010000
7009fbb4: 84 26 0b 70  	.word	0x700b2684
7009fbb8: 18 27 0b 70  	.word	0x700b2718
7009fbbc: 2c 52 08 70  	.word	0x7008522c
7009fbc0: 80 52 08 70  	.word	0x70085280
7009fbc4: 88 26 0b 70  	.word	0x700b2688
7009fbc8: 00 00 00 00  	.word	0x00000000
7009fbcc: 00 00 00 00  	.word	0x00000000

7009fbd0 <UART_close>:
; {
7009fbd0: b580         	push	{r7, lr}
7009fbd2: b08a         	sub	sp, #0x28
7009fbd4: 9009         	str	r0, [sp, #0x24]
;     config = (UART_Config *) handle;
7009fbd6: 9809         	ldr	r0, [sp, #0x24]
7009fbd8: 9008         	str	r0, [sp, #0x20]
;     if ((NULL != config) && (config->object != NULL) && (config->object->isOpen != FALSE))
7009fbda: 9808         	ldr	r0, [sp, #0x20]
7009fbdc: 2800         	cmp	r0, #0x0
7009fbde: f000 80ce    	beq.w	0x7009fd7e <UART_close+0x1ae> @ imm = #0x19c
7009fbe2: e7ff         	b	0x7009fbe4 <UART_close+0x14> @ imm = #-0x2
7009fbe4: 9808         	ldr	r0, [sp, #0x20]
7009fbe6: 6840         	ldr	r0, [r0, #0x4]
7009fbe8: 2800         	cmp	r0, #0x0
7009fbea: f000 80c8    	beq.w	0x7009fd7e <UART_close+0x1ae> @ imm = #0x190
7009fbee: e7ff         	b	0x7009fbf0 <UART_close+0x20> @ imm = #-0x2
7009fbf0: 9808         	ldr	r0, [sp, #0x20]
7009fbf2: 6840         	ldr	r0, [r0, #0x4]
7009fbf4: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009fbf8: 2800         	cmp	r0, #0x0
7009fbfa: f000 80c0    	beq.w	0x7009fd7e <UART_close+0x1ae> @ imm = #0x180
7009fbfe: e7ff         	b	0x7009fc00 <UART_close+0x30> @ imm = #-0x2
;         object = config->object;
7009fc00: 9808         	ldr	r0, [sp, #0x20]
7009fc02: 6840         	ldr	r0, [r0, #0x4]
7009fc04: 9007         	str	r0, [sp, #0x1c]
;         attrs = config->attrs;
7009fc06: 9808         	ldr	r0, [sp, #0x20]
7009fc08: 6800         	ldr	r0, [r0]
7009fc0a: 9006         	str	r0, [sp, #0x18]
;         object->uartLld_handle = &object->uartLld_object;
7009fc0c: 9907         	ldr	r1, [sp, #0x1c]
7009fc0e: f501 7022    	add.w	r0, r1, #0x288
7009fc12: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;         uartLld_handle = object->uartLld_handle;
7009fc16: 9807         	ldr	r0, [sp, #0x1c]
7009fc18: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009fc1c: 9005         	str	r0, [sp, #0x14]
;         DebugP_assert(NULL_PTR != object);
7009fc1e: 9807         	ldr	r0, [sp, #0x1c]
7009fc20: 2800         	cmp	r0, #0x0
7009fc22: bf18         	it	ne
7009fc24: 2001         	movne	r0, #0x1
7009fc26: f641 41b2    	movw	r1, #0x1cb2
7009fc2a: f2c7 010b    	movt	r1, #0x700b
7009fc2e: 466a         	mov	r2, sp
7009fc30: 6011         	str	r1, [r2]
7009fc32: f641 41c5    	movw	r1, #0x1cc5
7009fc36: f2c7 010b    	movt	r1, #0x700b
7009fc3a: 9101         	str	r1, [sp, #0x4]
7009fc3c: f641 620b    	movw	r2, #0x1e0b
7009fc40: f2c7 020b    	movt	r2, #0x700b
7009fc44: 9202         	str	r2, [sp, #0x8]
7009fc46: f240 13c5    	movw	r3, #0x1c5
7009fc4a: f00a fef1    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xade2
7009fc4e: 9901         	ldr	r1, [sp, #0x4]
7009fc50: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != attrs);
7009fc52: 9806         	ldr	r0, [sp, #0x18]
7009fc54: 2800         	cmp	r0, #0x0
7009fc56: bf18         	it	ne
7009fc58: 2001         	movne	r0, #0x1
7009fc5a: f641 43fb    	movw	r3, #0x1cfb
7009fc5e: f2c7 030b    	movt	r3, #0x700b
7009fc62: 46ec         	mov	r12, sp
7009fc64: f8cc 3000    	str.w	r3, [r12]
7009fc68: f44f 73e3    	mov.w	r3, #0x1c6
7009fc6c: f00a fee0    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xadc0
7009fc70: 9901         	ldr	r1, [sp, #0x4]
7009fc72: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != gUartDrvObj.lock);
7009fc74: f242 33e8    	movw	r3, #0x23e8
7009fc78: f2c7 030b    	movt	r3, #0x700b
7009fc7c: f853 0b04    	ldr	r0, [r3], #4
7009fc80: 9303         	str	r3, [sp, #0xc]
7009fc82: 2800         	cmp	r0, #0x0
7009fc84: bf18         	it	ne
7009fc86: 2001         	movne	r0, #0x1
7009fc88: f641 23a4    	movw	r3, #0x1aa4
7009fc8c: f2c7 030b    	movt	r3, #0x700b
7009fc90: 46ec         	mov	r12, sp
7009fc92: f8cc 3000    	str.w	r3, [r12]
7009fc96: f44f 73e4    	mov.w	r3, #0x1c8
7009fc9a: f00a fec9    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xad92
7009fc9e: 9803         	ldr	r0, [sp, #0xc]
7009fca0: f04f 31ff    	mov.w	r1, #0xffffffff
;         (void)SemaphoreP_pend(&gUartDrvObj.lockObj, SystemP_WAIT_FOREVER);
7009fca4: f00a fc6c    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0xa8d8
;         UART_flushTxFifo(handle);
7009fca8: 9809         	ldr	r0, [sp, #0x24]
7009fcaa: f007 fa31    	bl	0x700a7110 <UART_flushTxFifo> @ imm = #0x7462
;         UART_intrDisable(attrs->baseAddr,
7009fcae: 9806         	ldr	r0, [sp, #0x18]
7009fcb0: 6800         	ldr	r0, [r0]
7009fcb2: 2107         	movs	r1, #0x7
7009fcb4: 9104         	str	r1, [sp, #0x10]
7009fcb6: f006 f9c3    	bl	0x700a6040 <UART_intrDisable> @ imm = #0x6386
;         UART_intr2Disable(attrs->baseAddr, UART_INT2_TX_EMPTY);
7009fcba: 9806         	ldr	r0, [sp, #0x18]
7009fcbc: 6800         	ldr	r0, [r0]
7009fcbe: 2102         	movs	r1, #0x2
7009fcc0: f00e ff16    	bl	0x700aeaf0 <UART_intr2Disable> @ imm = #0xee2c
7009fcc4: 9904         	ldr	r1, [sp, #0x10]
;         (void)UART_operatingModeSelect(attrs->baseAddr, UART_OPER_MODE_DISABLED);
7009fcc6: 9806         	ldr	r0, [sp, #0x18]
7009fcc8: 6800         	ldr	r0, [r0]
7009fcca: f00e ff59    	bl	0x700aeb80 <UART_operatingModeSelect> @ imm = #0xeeb2
;         if(UART_CONFIG_MODE_DMA == object->prms.transferMode)
7009fcce: 9807         	ldr	r0, [sp, #0x1c]
7009fcd0: 6b00         	ldr	r0, [r0, #0x30]
7009fcd2: 2803         	cmp	r0, #0x3
7009fcd4: d104         	bne	0x7009fce0 <UART_close+0x110> @ imm = #0x8
7009fcd6: e7ff         	b	0x7009fcd8 <UART_close+0x108> @ imm = #-0x2
;             (void)UART_lld_deInitDma(uartLld_handle);
7009fcd8: 9805         	ldr	r0, [sp, #0x14]
7009fcda: f00b fe91    	bl	0x700aba00 <UART_lld_deInitDma> @ imm = #0xbd22
;         }
7009fcde: e003         	b	0x7009fce8 <UART_close+0x118> @ imm = #0x6
;             (void)UART_lld_deInit(uartLld_handle);
7009fce0: 9805         	ldr	r0, [sp, #0x14]
7009fce2: f00c fb65    	bl	0x700ac3b0 <UART_lld_deInit> @ imm = #0xc6ca
7009fce6: e7ff         	b	0x7009fce8 <UART_close+0x118> @ imm = #-0x2
;         if(NULL != object->lock)
7009fce8: 9807         	ldr	r0, [sp, #0x1c]
7009fcea: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009fcee: b148         	cbz	r0, 0x7009fd04 <UART_close+0x134> @ imm = #0x12
7009fcf0: e7ff         	b	0x7009fcf2 <UART_close+0x122> @ imm = #-0x2
;             SemaphoreP_destruct(&object->lockObj);
7009fcf2: 9807         	ldr	r0, [sp, #0x1c]
7009fcf4: 308c         	adds	r0, #0x8c
7009fcf6: f00f fc63    	bl	0x700af5c0 <SemaphoreP_destruct> @ imm = #0xf8c6
;             object->lock = NULL;
7009fcfa: 9907         	ldr	r1, [sp, #0x1c]
7009fcfc: 2000         	movs	r0, #0x0
7009fcfe: f8c1 0088    	str.w	r0, [r1, #0x88]
;         }
7009fd02: e7ff         	b	0x7009fd04 <UART_close+0x134> @ imm = #-0x2
;         if(NULL != object->readTransferSem)
7009fd04: 9807         	ldr	r0, [sp, #0x1c]
7009fd06: f8d0 0124    	ldr.w	r0, [r0, #0x124]
7009fd0a: b160         	cbz	r0, 0x7009fd26 <UART_close+0x156> @ imm = #0x18
7009fd0c: e7ff         	b	0x7009fd0e <UART_close+0x13e> @ imm = #-0x2
;             SemaphoreP_destruct(&object->readTransferSemObj);
7009fd0e: 9807         	ldr	r0, [sp, #0x1c]
7009fd10: f500 7094    	add.w	r0, r0, #0x128
7009fd14: f00f fc54    	bl	0x700af5c0 <SemaphoreP_destruct> @ imm = #0xf8a8
;             object->readTransferSem = NULL;
7009fd18: 9907         	ldr	r1, [sp, #0x1c]
7009fd1a: 2000         	movs	r0, #0x0
7009fd1c: f8c1 0124    	str.w	r0, [r1, #0x124]
;             uartLld_handle->readTransferMutex = NULL;
7009fd20: 9905         	ldr	r1, [sp, #0x14]
7009fd22: 6588         	str	r0, [r1, #0x58]
;         }
7009fd24: e7ff         	b	0x7009fd26 <UART_close+0x156> @ imm = #-0x2
;         if(NULL != object->writeTransferSem)
7009fd26: 9807         	ldr	r0, [sp, #0x1c]
7009fd28: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
7009fd2c: b160         	cbz	r0, 0x7009fd48 <UART_close+0x178> @ imm = #0x18
7009fd2e: e7ff         	b	0x7009fd30 <UART_close+0x160> @ imm = #-0x2
;             SemaphoreP_destruct(&object->writeTransferSemObj);
7009fd30: 9807         	ldr	r0, [sp, #0x1c]
7009fd32: f500 70e2    	add.w	r0, r0, #0x1c4
7009fd36: f00f fc43    	bl	0x700af5c0 <SemaphoreP_destruct> @ imm = #0xf886
;             object->writeTransferSem = NULL;
7009fd3a: 9907         	ldr	r1, [sp, #0x1c]
7009fd3c: 2000         	movs	r0, #0x0
7009fd3e: f8c1 01c0    	str.w	r0, [r1, #0x1c0]
;             uartLld_handle->writeTransferMutex = NULL;
7009fd42: 9905         	ldr	r1, [sp, #0x14]
7009fd44: 65c8         	str	r0, [r1, #0x5c]
;         }
7009fd46: e7ff         	b	0x7009fd48 <UART_close+0x178> @ imm = #-0x2
;         if(NULL != object->hwiHandle)
7009fd48: 9807         	ldr	r0, [sp, #0x1c]
7009fd4a: f8d0 025c    	ldr.w	r0, [r0, #0x25c]
7009fd4e: b150         	cbz	r0, 0x7009fd66 <UART_close+0x196> @ imm = #0x14
7009fd50: e7ff         	b	0x7009fd52 <UART_close+0x182> @ imm = #-0x2
;             HwiP_destruct(&object->hwiObj);
7009fd52: 9807         	ldr	r0, [sp, #0x1c]
7009fd54: f500 7018    	add.w	r0, r0, #0x260
7009fd58: f010 f892    	bl	0x700afe80 <HwiP_destruct> @ imm = #0x10124
;             object->hwiHandle = NULL;
7009fd5c: 9907         	ldr	r1, [sp, #0x1c]
7009fd5e: 2000         	movs	r0, #0x0
7009fd60: f8c1 025c    	str.w	r0, [r1, #0x25c]
;         }
7009fd64: e7ff         	b	0x7009fd66 <UART_close+0x196> @ imm = #-0x2
;         object->isOpen = FALSE;
7009fd66: 9907         	ldr	r1, [sp, #0x1c]
7009fd68: 2000         	movs	r0, #0x0
7009fd6a: f8c1 0084    	str.w	r0, [r1, #0x84]
;         SemaphoreP_post(&gUartDrvObj.lockObj);
7009fd6e: f242 30e8    	movw	r0, #0x23e8
7009fd72: f2c7 000b    	movt	r0, #0x700b
7009fd76: 3004         	adds	r0, #0x4
7009fd78: f00b ff92    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0xbf24
;     }
7009fd7c: e7ff         	b	0x7009fd7e <UART_close+0x1ae> @ imm = #-0x2
;     return;
7009fd7e: b00a         	add	sp, #0x28
7009fd80: bd80         	pop	{r7, pc}
7009fd82: 0000         	movs	r0, r0

7009fd84 <free>:
7009fd84: e3500000     	cmp	r0, #0
7009fd88: 012fff1e     	bxeq	lr
7009fd8c: e92d41f0     	push	{r4, r5, r6, r7, r8, lr}
7009fd90: e1a04000     	mov	r4, r0
7009fd94: e59f0188     	ldr	r0, [pc, #0x188]        @ 0x7009ff24 <free+0x1a0>
7009fd98: e5900000     	ldr	r0, [r0]
7009fd9c: e12fff30     	blx	r0
7009fda0: e59f0180     	ldr	r0, [pc, #0x180]        @ 0x7009ff28 <free+0x1a4>
7009fda4: e2444008     	sub	r4, r4, #8
7009fda8: e3a05000     	mov	r5, #0
7009fdac: e5901000     	ldr	r1, [r0]
7009fdb0: e1500004     	cmp	r0, r4
7009fdb4: e3c12001     	bic	r2, r1, #1
7009fdb8: 2a000004     	bhs	0x7009fdd0 <free+0x4c>  @ imm = #0x10
7009fdbc: e0801002     	add	r1, r0, r2
7009fdc0: e1a05000     	mov	r5, r0
7009fdc4: e2811008     	add	r1, r1, #8
7009fdc8: e1a00001     	mov	r0, r1
7009fdcc: eafffff6     	b	0x7009fdac <free+0x28>  @ imm = #-0x28
7009fdd0: e59f3150     	ldr	r3, [pc, #0x150]        @ 0x7009ff28 <free+0x1a4>
7009fdd4: e0802002     	add	r2, r0, r2
7009fdd8: e59f714c     	ldr	r7, [pc, #0x14c]        @ 0x7009ff2c <free+0x1a8>
7009fddc: e2826008     	add	r6, r2, #8
7009fde0: e0872003     	add	r2, r7, r3
7009fde4: e3570007     	cmp	r7, #7
7009fde8: 82423008     	subhi	r3, r2, #8
7009fdec: e1560003     	cmp	r6, r3
7009fdf0: 83006000     	movwhi	r6, #0x0
7009fdf4: e1500004     	cmp	r0, r4
7009fdf8: 1a000045     	bne	0x7009ff14 <free+0x190> @ imm = #0x114
7009fdfc: e2110001     	ands	r0, r1, #1
7009fe00: 0a000043     	beq	0x7009ff14 <free+0x190> @ imm = #0x10c
7009fe04: e3550000     	cmp	r5, #0
7009fe08: 0a000009     	beq	0x7009fe34 <free+0xb0>  @ imm = #0x24
7009fe0c: e5951000     	ldr	r1, [r5]
7009fe10: e3a00000     	mov	r0, #0
7009fe14: e3a07000     	mov	r7, #0
7009fe18: e2111001     	ands	r1, r1, #1
7009fe1c: 01a00005     	moveq	r0, r5
7009fe20: e3560000     	cmp	r6, #0
7009fe24: 1a000005     	bne	0x7009fe40 <free+0xbc>  @ imm = #0x14
7009fe28: e3510000     	cmp	r1, #0
7009fe2c: 0a00000b     	beq	0x7009fe60 <free+0xdc>  @ imm = #0x2c
7009fe30: ea000022     	b	0x7009fec0 <free+0x13c> @ imm = #0x88
7009fe34: e3a00000     	mov	r0, #0
7009fe38: e3560000     	cmp	r6, #0
7009fe3c: 0a00001f     	beq	0x7009fec0 <free+0x13c> @ imm = #0x7c
7009fe40: e5d61000     	ldrb	r1, [r6]
7009fe44: e3a07000     	mov	r7, #0
7009fe48: e3a08000     	mov	r8, #0
7009fe4c: e3110001     	tst	r1, #1
7009fe50: 01a07006     	moveq	r7, r6
7009fe54: e3500000     	cmp	r0, #0
7009fe58: 0a000007     	beq	0x7009fe7c <free+0xf8>  @ imm = #0x1c
7009fe5c: e1a05000     	mov	r5, r0
7009fe60: e1a00005     	mov	r0, r5
7009fe64: eb00393a     	bl	0x700ae354 <free_list_remove> @ imm = #0xe4e8
7009fe68: e3a08001     	mov	r8, #1
7009fe6c: e3570000     	cmp	r7, #0
7009fe70: 0a00001d     	beq	0x7009feec <free+0x168> @ imm = #0x74
7009fe74: e1a06007     	mov	r6, r7
7009fe78: ea000002     	b	0x7009fe88 <free+0x104> @ imm = #0x8
7009fe7c: e3a05000     	mov	r5, #0
7009fe80: e3570000     	cmp	r7, #0
7009fe84: 0a00000d     	beq	0x7009fec0 <free+0x13c> @ imm = #0x34
7009fe88: e1a00006     	mov	r0, r6
7009fe8c: eb003930     	bl	0x700ae354 <free_list_remove> @ imm = #0xe4c0
7009fe90: e3580000     	cmp	r8, #0
7009fe94: 0a00000c     	beq	0x7009fecc <free+0x148> @ imm = #0x30
7009fe98: e5950000     	ldr	r0, [r5]
7009fe9c: e5941000     	ldr	r1, [r4]
7009fea0: e5962000     	ldr	r2, [r6]
7009fea4: e2800010     	add	r0, r0, #16
7009fea8: e3c11001     	bic	r1, r1, #1
7009feac: e3c00001     	bic	r0, r0, #1
7009feb0: e3c22001     	bic	r2, r2, #1
7009feb4: e0800001     	add	r0, r0, r1
7009feb8: e0800002     	add	r0, r0, r2
7009febc: ea000010     	b	0x7009ff04 <free+0x180> @ imm = #0x40
7009fec0: e5940000     	ldr	r0, [r4]
7009fec4: e3c00001     	bic	r0, r0, #1
7009fec8: ea000005     	b	0x7009fee4 <free+0x160> @ imm = #0x14
7009fecc: e5940000     	ldr	r0, [r4]
7009fed0: e5961000     	ldr	r1, [r6]
7009fed4: e2800008     	add	r0, r0, #8
7009fed8: e3c11001     	bic	r1, r1, #1
7009fedc: e3c00001     	bic	r0, r0, #1
7009fee0: e0800001     	add	r0, r0, r1
7009fee4: e5840000     	str	r0, [r4]
7009fee8: ea000007     	b	0x7009ff0c <free+0x188> @ imm = #0x1c
7009feec: e5950000     	ldr	r0, [r5]
7009fef0: e5941000     	ldr	r1, [r4]
7009fef4: e2800008     	add	r0, r0, #8
7009fef8: e3c11001     	bic	r1, r1, #1
7009fefc: e3c00001     	bic	r0, r0, #1
7009ff00: e0800001     	add	r0, r0, r1
7009ff04: e1a04005     	mov	r4, r5
7009ff08: e5850000     	str	r0, [r5]
7009ff0c: e1a00004     	mov	r0, r4
7009ff10: eb0036d2     	bl	0x700ada60 <free_list_insert> @ imm = #0xdb48
7009ff14: e59f0014     	ldr	r0, [pc, #0x14]         @ 0x7009ff30 <free+0x1ac>
7009ff18: e5900000     	ldr	r0, [r0]
7009ff1c: e8bd41f0     	pop	{r4, r5, r6, r7, r8, lr}
7009ff20: e12fff10     	bx	r0
7009ff24: 84 26 0b 70  	.word	0x700b2684
7009ff28: 80 52 08 70  	.word	0x70085280
7009ff2c: 00 00 01 00  	.word	0x00010000
7009ff30: 88 26 0b 70  	.word	0x700b2688
7009ff34: 00 00 00 00  	.word	0x00000000
7009ff38: 00 00 00 00  	.word	0x00000000
7009ff3c: 00 00 00 00  	.word	0x00000000

7009ff40 <UART_lld_controllerIsr>:
; {
7009ff40: b580         	push	{r7, lr}
7009ff42: b086         	sub	sp, #0x18
7009ff44: 9005         	str	r0, [sp, #0x14]
7009ff46: 2001         	movs	r0, #0x1
;     uint32_t            retVal = TRUE;
7009ff48: 9001         	str	r0, [sp, #0x4]
;     if(NULL != args)
7009ff4a: 9805         	ldr	r0, [sp, #0x14]
7009ff4c: 2800         	cmp	r0, #0x0
7009ff4e: f000 80c8    	beq.w	0x700a00e2 <UART_lld_controllerIsr+0x1a2> @ imm = #0x190
7009ff52: e7ff         	b	0x7009ff54 <UART_lld_controllerIsr+0x14> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
7009ff54: 9805         	ldr	r0, [sp, #0x14]
7009ff56: 9002         	str	r0, [sp, #0x8]
;         while (retVal == TRUE)
7009ff58: e7ff         	b	0x7009ff5a <UART_lld_controllerIsr+0x1a> @ imm = #-0x2
7009ff5a: 9801         	ldr	r0, [sp, #0x4]
7009ff5c: 2801         	cmp	r0, #0x1
7009ff5e: f040 80bf    	bne.w	0x700a00e0 <UART_lld_controllerIsr+0x1a0> @ imm = #0x17e
7009ff62: e7ff         	b	0x7009ff64 <UART_lld_controllerIsr+0x24> @ imm = #-0x2
;             intType = UART_getIntrIdentityStatus(hUart->baseAddr);
7009ff64: 9802         	ldr	r0, [sp, #0x8]
7009ff66: 6800         	ldr	r0, [r0]
7009ff68: f00d f972    	bl	0x700ad250 <UART_getIntrIdentityStatus> @ imm = #0xd2e4
7009ff6c: 9004         	str	r0, [sp, #0x10]
;             if ((intType & UART_INTID_RX_THRES_REACH) == UART_INTID_RX_THRES_REACH)
7009ff6e: f89d 0010    	ldrb.w	r0, [sp, #0x10]
7009ff72: 0740         	lsls	r0, r0, #0x1d
7009ff74: 2800         	cmp	r0, #0x0
7009ff76: d561         	bpl	0x700a003c <UART_lld_controllerIsr+0xfc> @ imm = #0xc2
7009ff78: e7ff         	b	0x7009ff7a <UART_lld_controllerIsr+0x3a> @ imm = #-0x2
;                 if ((intType & UART_INTID_RX_LINE_STAT_ERROR) ==
7009ff7a: 9804         	ldr	r0, [sp, #0x10]
7009ff7c: f000 0006    	and	r0, r0, #0x6
7009ff80: 2806         	cmp	r0, #0x6
7009ff82: d104         	bne	0x7009ff8e <UART_lld_controllerIsr+0x4e> @ imm = #0x8
7009ff84: e7ff         	b	0x7009ff86 <UART_lld_controllerIsr+0x46> @ imm = #-0x2
;                     (void)UART_procLineStatusErr(hUart);
7009ff86: 9802         	ldr	r0, [sp, #0x8]
7009ff88: f002 fc62    	bl	0x700a2850 <UART_procLineStatusErr> @ imm = #0x28c4
;                 }
7009ff8c: e055         	b	0x700a003a <UART_lld_controllerIsr+0xfa> @ imm = #0xaa
;                     if ((intType & UART_INTID_CHAR_TIMEOUT) == UART_INTID_CHAR_TIMEOUT)
7009ff8e: 9804         	ldr	r0, [sp, #0x10]
7009ff90: f000 000c    	and	r0, r0, #0xc
7009ff94: 280c         	cmp	r0, #0xc
7009ff96: d10a         	bne	0x7009ffae <UART_lld_controllerIsr+0x6e> @ imm = #0x14
7009ff98: e7ff         	b	0x7009ff9a <UART_lld_controllerIsr+0x5a> @ imm = #-0x2
;                         UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009ff9a: 9802         	ldr	r0, [sp, #0x8]
7009ff9c: 6800         	ldr	r0, [r0]
7009ff9e: 2105         	movs	r1, #0x5
7009ffa0: f006 f84e    	bl	0x700a6040 <UART_intrDisable> @ imm = #0x609c
;                         hUart->rxTimeoutCnt++;
7009ffa4: 9902         	ldr	r1, [sp, #0x8]
7009ffa6: 6a08         	ldr	r0, [r1, #0x20]
7009ffa8: 3001         	adds	r0, #0x1
7009ffaa: 6208         	str	r0, [r1, #0x20]
;                     }
7009ffac: e7ff         	b	0x7009ffae <UART_lld_controllerIsr+0x6e> @ imm = #-0x2
;                     if (hUart->readSizeRemaining > 0U)
7009ffae: 9802         	ldr	r0, [sp, #0x8]
7009ffb0: 69c0         	ldr	r0, [r0, #0x1c]
7009ffb2: b3a8         	cbz	r0, 0x700a0020 <UART_lld_controllerIsr+0xe0> @ imm = #0x6a
7009ffb4: e7ff         	b	0x7009ffb6 <UART_lld_controllerIsr+0x76> @ imm = #-0x2
;                         hUart->readSizeRemaining = UART_readData(hUart, hUart->readSizeRemaining);
7009ffb6: 9802         	ldr	r0, [sp, #0x8]
7009ffb8: 69c1         	ldr	r1, [r0, #0x1c]
7009ffba: f00a fcf9    	bl	0x700aa9b0 <UART_readData> @ imm = #0xa9f2
7009ffbe: 9902         	ldr	r1, [sp, #0x8]
7009ffc0: 61c8         	str	r0, [r1, #0x1c]
;                         if ((hUart->readSizeRemaining == 0U) ||
7009ffc2: 9802         	ldr	r0, [sp, #0x8]
7009ffc4: 69c0         	ldr	r0, [r0, #0x1c]
7009ffc6: b130         	cbz	r0, 0x7009ffd6 <UART_lld_controllerIsr+0x96> @ imm = #0xc
7009ffc8: e7ff         	b	0x7009ffca <UART_lld_controllerIsr+0x8a> @ imm = #-0x2
;                             (hUart->hUartInit->readReturnMode == UART_READ_RETURN_MODE_PARTIAL))
7009ffca: 9802         	ldr	r0, [sp, #0x8]
7009ffcc: 6840         	ldr	r0, [r0, #0x4]
7009ffce: 6940         	ldr	r0, [r0, #0x14]
;                         if ((hUart->readSizeRemaining == 0U) ||
7009ffd0: 2801         	cmp	r0, #0x1
7009ffd2: d11e         	bne	0x700a0012 <UART_lld_controllerIsr+0xd2> @ imm = #0x3c
7009ffd4: e7ff         	b	0x7009ffd6 <UART_lld_controllerIsr+0x96> @ imm = #-0x2
;                             UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009ffd6: 9802         	ldr	r0, [sp, #0x8]
7009ffd8: 6800         	ldr	r0, [r0]
7009ffda: 2105         	movs	r1, #0x5
7009ffdc: f006 f830    	bl	0x700a6040 <UART_intrDisable> @ imm = #0x6060
;                             hUart->readBuf = (uint8_t *)hUart->readBuf - hUart->readCount;
7009ffe0: 9902         	ldr	r1, [sp, #0x8]
7009ffe2: 6948         	ldr	r0, [r1, #0x14]
7009ffe4: 698a         	ldr	r2, [r1, #0x18]
7009ffe6: 1a80         	subs	r0, r0, r2
7009ffe8: 6148         	str	r0, [r1, #0x14]
;                             if (hUart->readTrans.buf != NULL)
7009ffea: 9802         	ldr	r0, [sp, #0x8]
7009ffec: 6a80         	ldr	r0, [r0, #0x28]
7009ffee: b138         	cbz	r0, 0x700a0000 <UART_lld_controllerIsr+0xc0> @ imm = #0xe
7009fff0: e7ff         	b	0x7009fff2 <UART_lld_controllerIsr+0xb2> @ imm = #-0x2
;                                 hUart->readTrans.count = (uint32_t)(hUart->readCount);
7009fff2: 9902         	ldr	r1, [sp, #0x8]
7009fff4: 6988         	ldr	r0, [r1, #0x18]
7009fff6: 62c8         	str	r0, [r1, #0x2c]
;                                 hUart->readTrans.status = UART_TRANSFER_STATUS_SUCCESS;
7009fff8: 9902         	ldr	r1, [sp, #0x8]
7009fffa: 2000         	movs	r0, #0x0
7009fffc: 6348         	str	r0, [r1, #0x34]
;                             }
7009fffe: e7ff         	b	0x700a0000 <UART_lld_controllerIsr+0xc0> @ imm = #-0x2
;                             hUart->hUartInit->readCompleteCallbackFxn(hUart);
700a0000: 9802         	ldr	r0, [sp, #0x8]
700a0002: 6841         	ldr	r1, [r0, #0x4]
700a0004: 6dc9         	ldr	r1, [r1, #0x5c]
700a0006: 4788         	blx	r1
;                             UART_lld_Transaction_deInit(&hUart->readTrans);
700a0008: 9802         	ldr	r0, [sp, #0x8]
700a000a: 3028         	adds	r0, #0x28
700a000c: f00f f8d0    	bl	0x700af1b0 <UART_lld_Transaction_deInit> @ imm = #0xf1a0
;                         }
700a0010: e005         	b	0x700a001e <UART_lld_controllerIsr+0xde> @ imm = #0xa
;                             UART_intrEnable(hUart->baseAddr, (uint32_t) UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a0012: 9802         	ldr	r0, [sp, #0x8]
700a0014: 6800         	ldr	r0, [r0]
700a0016: 2105         	movs	r1, #0x5
700a0018: f005 ff32    	bl	0x700a5e80 <UART_intrEnable> @ imm = #0x5e64
700a001c: e7ff         	b	0x700a001e <UART_lld_controllerIsr+0xde> @ imm = #-0x2
;                     }
700a001e: e00b         	b	0x700a0038 <UART_lld_controllerIsr+0xf8> @ imm = #0x16
;                         (void)UART_getChar(hUart->baseAddr, &rdData);
700a0020: 9802         	ldr	r0, [sp, #0x8]
700a0022: 6800         	ldr	r0, [r0]
700a0024: f10d 010f    	add.w	r1, sp, #0xf
700a0028: f00c f8a2    	bl	0x700ac170 <UART_getChar> @ imm = #0xc144
;                         UART_intrDisable(hUart->baseAddr, (uint32_t) UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a002c: 9802         	ldr	r0, [sp, #0x8]
700a002e: 6800         	ldr	r0, [r0]
700a0030: 2105         	movs	r1, #0x5
700a0032: f006 f805    	bl	0x700a6040 <UART_intrDisable> @ imm = #0x600a
700a0036: e7ff         	b	0x700a0038 <UART_lld_controllerIsr+0xf8> @ imm = #-0x2
700a0038: e7ff         	b	0x700a003a <UART_lld_controllerIsr+0xfa> @ imm = #-0x2
;             }
700a003a: e050         	b	0x700a00de <UART_lld_controllerIsr+0x19e> @ imm = #0xa0
;             else if ((intType & UART_INTID_TX_THRES_REACH) == UART_INTID_TX_THRES_REACH)
700a003c: f89d 0010    	ldrb.w	r0, [sp, #0x10]
700a0040: 0780         	lsls	r0, r0, #0x1e
700a0042: 2800         	cmp	r0, #0x0
700a0044: d534         	bpl	0x700a00b0 <UART_lld_controllerIsr+0x170> @ imm = #0x68
700a0046: e7ff         	b	0x700a0048 <UART_lld_controllerIsr+0x108> @ imm = #-0x2
;                 if (hUart->writeSizeRemaining > 0U)
700a0048: 9802         	ldr	r0, [sp, #0x8]
700a004a: 6900         	ldr	r0, [r0, #0x10]
700a004c: b348         	cbz	r0, 0x700a00a2 <UART_lld_controllerIsr+0x162> @ imm = #0x52
700a004e: e7ff         	b	0x700a0050 <UART_lld_controllerIsr+0x110> @ imm = #-0x2
;                     hUart->writeSizeRemaining = (uint32_t)UART_writeData(hUart, (hUart->writeSizeRemaining));
700a0050: 9802         	ldr	r0, [sp, #0x8]
700a0052: 6901         	ldr	r1, [r0, #0x10]
700a0054: f00c f8bc    	bl	0x700ac1d0 <UART_writeData> @ imm = #0xc178
700a0058: 9902         	ldr	r1, [sp, #0x8]
700a005a: 6108         	str	r0, [r1, #0x10]
;                     if ((hUart->writeSizeRemaining) == 0U)
700a005c: 9802         	ldr	r0, [sp, #0x8]
700a005e: 6900         	ldr	r0, [r0, #0x10]
700a0060: b9f0         	cbnz	r0, 0x700a00a0 <UART_lld_controllerIsr+0x160> @ imm = #0x3c
700a0062: e7ff         	b	0x700a0064 <UART_lld_controllerIsr+0x124> @ imm = #-0x2
;                         UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
700a0064: 9802         	ldr	r0, [sp, #0x8]
700a0066: 6800         	ldr	r0, [r0]
700a0068: 2102         	movs	r1, #0x2
700a006a: f005 ffe9    	bl	0x700a6040 <UART_intrDisable> @ imm = #0x5fd2
;                         hUart->writeBuf = (const void *)((uint8_t *)hUart->writeBuf - hUart->writeCount);
700a006e: 9902         	ldr	r1, [sp, #0x8]
700a0070: 6888         	ldr	r0, [r1, #0x8]
700a0072: 68ca         	ldr	r2, [r1, #0xc]
700a0074: 1a80         	subs	r0, r0, r2
700a0076: 6088         	str	r0, [r1, #0x8]
;                         if (hUart->writeTrans.buf != NULL)
700a0078: 9802         	ldr	r0, [sp, #0x8]
700a007a: 6bc0         	ldr	r0, [r0, #0x3c]
700a007c: b138         	cbz	r0, 0x700a008e <UART_lld_controllerIsr+0x14e> @ imm = #0xe
700a007e: e7ff         	b	0x700a0080 <UART_lld_controllerIsr+0x140> @ imm = #-0x2
;                             hUart->writeTrans.count = (uint32_t)(hUart->writeCount);
700a0080: 9902         	ldr	r1, [sp, #0x8]
700a0082: 68c8         	ldr	r0, [r1, #0xc]
700a0084: 6408         	str	r0, [r1, #0x40]
;                             hUart->writeTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a0086: 9902         	ldr	r1, [sp, #0x8]
700a0088: 2000         	movs	r0, #0x0
700a008a: 6488         	str	r0, [r1, #0x48]
;                         }
700a008c: e7ff         	b	0x700a008e <UART_lld_controllerIsr+0x14e> @ imm = #-0x2
;                         hUart->hUartInit->writeCompleteCallbackFxn(hUart);
700a008e: 9802         	ldr	r0, [sp, #0x8]
700a0090: 6841         	ldr	r1, [r0, #0x4]
700a0092: 6e09         	ldr	r1, [r1, #0x60]
700a0094: 4788         	blx	r1
;                         UART_lld_Transaction_deInit(&hUart->writeTrans);
700a0096: 9802         	ldr	r0, [sp, #0x8]
700a0098: 303c         	adds	r0, #0x3c
700a009a: f00f f889    	bl	0x700af1b0 <UART_lld_Transaction_deInit> @ imm = #0xf112
;                     }
700a009e: e7ff         	b	0x700a00a0 <UART_lld_controllerIsr+0x160> @ imm = #-0x2
;                 }
700a00a0: e005         	b	0x700a00ae <UART_lld_controllerIsr+0x16e> @ imm = #0xa
;                     UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
700a00a2: 9802         	ldr	r0, [sp, #0x8]
700a00a4: 6800         	ldr	r0, [r0]
700a00a6: 2102         	movs	r1, #0x2
700a00a8: f005 ffca    	bl	0x700a6040 <UART_intrDisable> @ imm = #0x5f94
700a00ac: e7ff         	b	0x700a00ae <UART_lld_controllerIsr+0x16e> @ imm = #-0x2
;             }
700a00ae: e015         	b	0x700a00dc <UART_lld_controllerIsr+0x19c> @ imm = #0x2a
;             else if ((intType & UART_INTID_CHAR_TIMEOUT) == UART_INTID_CHAR_TIMEOUT)
700a00b0: 9804         	ldr	r0, [sp, #0x10]
700a00b2: f000 000c    	and	r0, r0, #0xc
700a00b6: 280c         	cmp	r0, #0xc
700a00b8: d10c         	bne	0x700a00d4 <UART_lld_controllerIsr+0x194> @ imm = #0x18
700a00ba: e7ff         	b	0x700a00bc <UART_lld_controllerIsr+0x17c> @ imm = #-0x2
;                 if (FALSE == UART_checkCharsAvailInFifo(hUart->baseAddr))
700a00bc: 9802         	ldr	r0, [sp, #0x8]
700a00be: 6800         	ldr	r0, [r0]
700a00c0: f00c ff0e    	bl	0x700acee0 <UART_checkCharsAvailInFifo> @ imm = #0xce1c
700a00c4: b928         	cbnz	r0, 0x700a00d2 <UART_lld_controllerIsr+0x192> @ imm = #0xa
700a00c6: e7ff         	b	0x700a00c8 <UART_lld_controllerIsr+0x188> @ imm = #-0x2
;                     UART_i2310WA(hUart->baseAddr);
700a00c8: 9802         	ldr	r0, [sp, #0x8]
700a00ca: 6800         	ldr	r0, [r0]
700a00cc: f00d fd88    	bl	0x700adbe0 <UART_i2310WA> @ imm = #0xdb10
;                 }
700a00d0: e7ff         	b	0x700a00d2 <UART_lld_controllerIsr+0x192> @ imm = #-0x2
;             }
700a00d2: e002         	b	0x700a00da <UART_lld_controllerIsr+0x19a> @ imm = #0x4
700a00d4: 2000         	movs	r0, #0x0
;                 retVal = FALSE;
700a00d6: 9001         	str	r0, [sp, #0x4]
700a00d8: e7ff         	b	0x700a00da <UART_lld_controllerIsr+0x19a> @ imm = #-0x2
700a00da: e7ff         	b	0x700a00dc <UART_lld_controllerIsr+0x19c> @ imm = #-0x2
700a00dc: e7ff         	b	0x700a00de <UART_lld_controllerIsr+0x19e> @ imm = #-0x2
;         while (retVal == TRUE)
700a00de: e73c         	b	0x7009ff5a <UART_lld_controllerIsr+0x1a> @ imm = #-0x188
;     }
700a00e0: e000         	b	0x700a00e4 <UART_lld_controllerIsr+0x1a4> @ imm = #0x0
700a00e2: e7ff         	b	0x700a00e4 <UART_lld_controllerIsr+0x1a4> @ imm = #-0x2
; }
700a00e4: b006         	add	sp, #0x18
700a00e6: bd80         	pop	{r7, pc}
		...

700a00f0 <tm_thread_locking_reporting_thread>:
; {
700a00f0: b086         	sub	sp, #0x18
700a00f2: f244 7678    	movw	r6, #0x4778
700a00f6: f241 65ae    	movw	r5, #0x16ae
700a00fa: f2c7 0608    	movt	r6, #0x7008
700a00fe: f242 67c4    	movw	r7, #0x26c4
700a0102: f2c7 050b    	movt	r5, #0x700b
700a0106: f2c7 070b    	movt	r7, #0x700b
700a010a: f04f 0800    	mov.w	r8, #0x0
700a010e: 241e         	movs	r4, #0x1e
700a0110: f106 0010    	add.w	r0, r6, #0x10
700a0114: f106 0970    	add.w	r9, r6, #0x70
700a0118: f106 0a80    	add.w	r10, r6, #0x80
700a011c: f106 0b90    	add.w	r11, r6, #0x90
700a0120: 9005         	str	r0, [sp, #0x14]
700a0122: f106 0020    	add.w	r0, r6, #0x20
700a0126: 9004         	str	r0, [sp, #0x10]
700a0128: f106 0030    	add.w	r0, r6, #0x30
700a012c: 9003         	str	r0, [sp, #0xc]
700a012e: f106 0040    	add.w	r0, r6, #0x40
700a0132: 9002         	str	r0, [sp, #0x8]
700a0134: f106 0050    	add.w	r0, r6, #0x50
700a0138: 9001         	str	r0, [sp, #0x4]
700a013a: f106 0060    	add.w	r0, r6, #0x60
700a013e: 9000         	str	r0, [sp]
700a0140: e009         	b	0x700a0156 <tm_thread_locking_reporting_thread+0x66> @ imm = #0x12
700a0142: bf00         	nop
700a0144: bf00         	nop
700a0146: bf00         	nop
700a0148: bf00         	nop
700a014a: bf00         	nop
700a014c: bf00         	nop
700a014e: bf00         	nop
;       last_counter = thread_locking_counter;
700a0150: f8d7 8000    	ldr.w	r8, [r7]
;    while (1)
700a0154: 341e         	adds	r4, #0x1e
;       tm_thread_sleep(TM_TEST_DURATION);
700a0156: 201e         	movs	r0, #0x1e
700a0158: f00f fc3a    	bl	0x700af9d0 <tm_thread_sleep> @ imm = #0xf874
;       printf("**** Thread Locking Benchmark **** Relative Time: %lu\r\n", relative_time);
700a015c: 4629         	mov	r1, r5
700a015e: 4622         	mov	r2, r4
700a0160: 2001         	movs	r0, #0x1
700a0162: f009 fcad    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #0x995a
;       if (thread_locking_counter == last_counter)
700a0166: 6838         	ldr	r0, [r7]
700a0168: 4540         	cmp	r0, r8
700a016a: d111         	bne	0x700a0190 <tm_thread_locking_reporting_thread+0xa0> @ imm = #0x22
;          printf("ERROR: No progress in thread locking counter!\r\n");
700a016c: f241 71bc    	movw	r1, #0x17bc
700a0170: 2001         	movs	r0, #0x1
700a0172: f2c7 010b    	movt	r1, #0x700b
700a0176: f009 fca3    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #0x9946
;       if (last_counter == 0)
700a017a: f1b8 0f00    	cmp.w	r8, #0x0
700a017e: d1e7         	bne	0x700a0150 <tm_thread_locking_reporting_thread+0x60> @ imm = #-0x32
700a0180: e013         	b	0x700a01aa <tm_thread_locking_reporting_thread+0xba> @ imm = #0x26
700a0182: bf00         	nop
700a0184: bf00         	nop
700a0186: bf00         	nop
700a0188: bf00         	nop
700a018a: bf00         	nop
700a018c: bf00         	nop
700a018e: bf00         	nop
;          printf("Locking Operations in Period: %lu\r\n", thread_locking_counter - last_counter);
700a0190: 6838         	ldr	r0, [r7]
700a0192: f641 0192    	movw	r1, #0x1892
700a0196: f2c7 010b    	movt	r1, #0x700b
700a019a: eba0 0208    	sub.w	r2, r0, r8
700a019e: 2001         	movs	r0, #0x1
700a01a0: f009 fc8e    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #0x991c
;       if (last_counter == 0)
700a01a4: f1b8 0f00    	cmp.w	r8, #0x0
700a01a8: d1d2         	bne	0x700a0150 <tm_thread_locking_reporting_thread+0x60> @ imm = #-0x5c
;             tm_pmu_profile_print(pmu_lock_numbers[i]);
700a01aa: 4630         	mov	r0, r6
700a01ac: f00f fc70    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf8e0
700a01b0: 9805         	ldr	r0, [sp, #0x14]
700a01b2: f00f fc6d    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf8da
700a01b6: 9804         	ldr	r0, [sp, #0x10]
700a01b8: f00f fc6a    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf8d4
700a01bc: 9803         	ldr	r0, [sp, #0xc]
700a01be: f00f fc67    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf8ce
700a01c2: 9802         	ldr	r0, [sp, #0x8]
700a01c4: f00f fc64    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf8c8
700a01c8: 9801         	ldr	r0, [sp, #0x4]
700a01ca: f00f fc61    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf8c2
700a01ce: 9800         	ldr	r0, [sp]
700a01d0: f00f fc5e    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf8bc
700a01d4: 4648         	mov	r0, r9
700a01d6: f00f fc5b    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf8b6
700a01da: 4650         	mov	r0, r10
700a01dc: f00f fc58    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf8b0
700a01e0: 4658         	mov	r0, r11
700a01e2: f00f fc55    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf8aa
700a01e6: f106 00a0    	add.w	r0, r6, #0xa0
700a01ea: f00f fc51    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf8a2
700a01ee: f106 00b0    	add.w	r0, r6, #0xb0
700a01f2: f00f fc4d    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf89a
700a01f6: f106 00c0    	add.w	r0, r6, #0xc0
700a01fa: f00f fc49    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf892
700a01fe: f106 00d0    	add.w	r0, r6, #0xd0
700a0202: f00f fc45    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf88a
700a0206: f106 00e0    	add.w	r0, r6, #0xe0
700a020a: f00f fc41    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf882
700a020e: f106 00f0    	add.w	r0, r6, #0xf0
700a0212: f00f fc3d    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf87a
700a0216: f506 7080    	add.w	r0, r6, #0x100
700a021a: f00f fc39    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf872
700a021e: f506 7088    	add.w	r0, r6, #0x110
700a0222: f00f fc35    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf86a
700a0226: f506 7090    	add.w	r0, r6, #0x120
700a022a: f00f fc31    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf862
700a022e: f506 7098    	add.w	r0, r6, #0x130
700a0232: f00f fc2d    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf85a
700a0236: f506 70a0    	add.w	r0, r6, #0x140
700a023a: f00f fc29    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf852
700a023e: f506 70a8    	add.w	r0, r6, #0x150
700a0242: f00f fc25    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf84a
700a0246: f506 70b0    	add.w	r0, r6, #0x160
700a024a: f00f fc21    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf842
700a024e: f506 70b8    	add.w	r0, r6, #0x170
700a0252: f00f fc1d    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf83a
700a0256: f506 70c0    	add.w	r0, r6, #0x180
700a025a: f00f fc19    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf832
700a025e: f506 70c8    	add.w	r0, r6, #0x190
700a0262: f00f fc15    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf82a
700a0266: f506 70d0    	add.w	r0, r6, #0x1a0
700a026a: f00f fc11    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf822
700a026e: f506 70d8    	add.w	r0, r6, #0x1b0
700a0272: f00f fc0d    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf81a
700a0276: f506 70e0    	add.w	r0, r6, #0x1c0
700a027a: f00f fc09    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf812
700a027e: f506 70e8    	add.w	r0, r6, #0x1d0
700a0282: f00f fc05    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf80a
700a0286: f506 70f0    	add.w	r0, r6, #0x1e0
700a028a: f00f fc01    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf802
700a028e: f506 70f8    	add.w	r0, r6, #0x1f0
700a0292: f00f fbfd    	bl	0x700afa90 <tm_pmu_profile_print> @ imm = #0xf7fa
700a0296: e75b         	b	0x700a0150 <tm_thread_locking_reporting_thread+0x60> @ imm = #-0x14a
		...

700a02a0 <UART_write>:
; {
700a02a0: b580         	push	{r7, lr}
700a02a2: b08e         	sub	sp, #0x38
700a02a4: 900d         	str	r0, [sp, #0x34]
700a02a6: 910c         	str	r1, [sp, #0x30]
700a02a8: 2000         	movs	r0, #0x0
;     int32_t             status = SystemP_SUCCESS, semStatus = SystemP_SUCCESS;
700a02aa: 900b         	str	r0, [sp, #0x2c]
700a02ac: 900a         	str	r0, [sp, #0x28]
;     if ((NULL_PTR == handle) || (NULL_PTR == trans))
700a02ae: 980d         	ldr	r0, [sp, #0x34]
700a02b0: b118         	cbz	r0, 0x700a02ba <UART_write+0x1a> @ imm = #0x6
700a02b2: e7ff         	b	0x700a02b4 <UART_write+0x14> @ imm = #-0x2
700a02b4: 980c         	ldr	r0, [sp, #0x30]
700a02b6: b920         	cbnz	r0, 0x700a02c2 <UART_write+0x22> @ imm = #0x8
700a02b8: e7ff         	b	0x700a02ba <UART_write+0x1a> @ imm = #-0x2
700a02ba: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700a02be: 900b         	str	r0, [sp, #0x2c]
;     }
700a02c0: e7ff         	b	0x700a02c2 <UART_write+0x22> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
700a02c2: 980b         	ldr	r0, [sp, #0x2c]
700a02c4: 2800         	cmp	r0, #0x0
700a02c6: d141         	bne	0x700a034c <UART_write+0xac> @ imm = #0x82
700a02c8: e7ff         	b	0x700a02ca <UART_write+0x2a> @ imm = #-0x2
;         config  = (UART_Config *) handle;
700a02ca: 980d         	ldr	r0, [sp, #0x34]
700a02cc: 9009         	str	r0, [sp, #0x24]
;         object  = config->object;
700a02ce: 9809         	ldr	r0, [sp, #0x24]
700a02d0: 6840         	ldr	r0, [r0, #0x4]
700a02d2: 9008         	str	r0, [sp, #0x20]
;         attrs   = config->attrs;
700a02d4: 9809         	ldr	r0, [sp, #0x24]
700a02d6: 6800         	ldr	r0, [r0]
700a02d8: 9007         	str	r0, [sp, #0x1c]
;         prms    = &config->object->prms;
700a02da: 9809         	ldr	r0, [sp, #0x24]
700a02dc: 6840         	ldr	r0, [r0, #0x4]
700a02de: 3004         	adds	r0, #0x4
700a02e0: 9006         	str	r0, [sp, #0x18]
;         uartLld_handle = object->uartLld_handle;
700a02e2: 9808         	ldr	r0, [sp, #0x20]
700a02e4: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a02e8: 9004         	str	r0, [sp, #0x10]
;         object->writeTrans = trans;
700a02ea: 980c         	ldr	r0, [sp, #0x30]
700a02ec: 9908         	ldr	r1, [sp, #0x20]
700a02ee: f8c1 0080    	str.w	r0, [r1, #0x80]
;         DebugP_assert(NULL_PTR != object);
700a02f2: 9808         	ldr	r0, [sp, #0x20]
700a02f4: 2800         	cmp	r0, #0x0
700a02f6: bf18         	it	ne
700a02f8: 2001         	movne	r0, #0x1
700a02fa: f641 41b2    	movw	r1, #0x1cb2
700a02fe: f2c7 010b    	movt	r1, #0x700b
700a0302: 466a         	mov	r2, sp
700a0304: 6011         	str	r1, [r2]
700a0306: f641 41c5    	movw	r1, #0x1cc5
700a030a: f2c7 010b    	movt	r1, #0x700b
700a030e: 9101         	str	r1, [sp, #0x4]
700a0310: f641 6200    	movw	r2, #0x1e00
700a0314: f2c7 020b    	movt	r2, #0x700b
700a0318: 9202         	str	r2, [sp, #0x8]
700a031a: f44f 7305    	mov.w	r3, #0x214
700a031e: f00a fb87    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xa70e
700a0322: 9901         	ldr	r1, [sp, #0x4]
700a0324: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != attrs);
700a0326: 9807         	ldr	r0, [sp, #0x1c]
700a0328: 2800         	cmp	r0, #0x0
700a032a: bf18         	it	ne
700a032c: 2001         	movne	r0, #0x1
700a032e: f641 43fb    	movw	r3, #0x1cfb
700a0332: f2c7 030b    	movt	r3, #0x700b
700a0336: 46ec         	mov	r12, sp
700a0338: f8cc 3000    	str.w	r3, [r12]
700a033c: f240 2315    	movw	r3, #0x215
700a0340: f00a fb76    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xa6ec
;         extendedParams.args = trans->args;
700a0344: 980c         	ldr	r0, [sp, #0x30]
700a0346: 6900         	ldr	r0, [r0, #0x10]
700a0348: 9003         	str	r0, [sp, #0xc]
;     }
700a034a: e7ff         	b	0x700a034c <UART_write+0xac> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
700a034c: 980b         	ldr	r0, [sp, #0x2c]
700a034e: b950         	cbnz	r0, 0x700a0366 <UART_write+0xc6> @ imm = #0x14
700a0350: e7ff         	b	0x700a0352 <UART_write+0xb2> @ imm = #-0x2
;         if (TRUE == prms->skipIntrReg)
700a0352: 9806         	ldr	r0, [sp, #0x18]
700a0354: 6b80         	ldr	r0, [r0, #0x38]
700a0356: 2801         	cmp	r0, #0x1
700a0358: d104         	bne	0x700a0364 <UART_write+0xc4> @ imm = #0x8
700a035a: e7ff         	b	0x700a035c <UART_write+0xbc> @ imm = #-0x2
700a035c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
700a0360: 900b         	str	r0, [sp, #0x2c]
;         }
700a0362: e7ff         	b	0x700a0364 <UART_write+0xc4> @ imm = #-0x2
;     }
700a0364: e7ff         	b	0x700a0366 <UART_write+0xc6> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
700a0366: 980b         	ldr	r0, [sp, #0x2c]
700a0368: 2800         	cmp	r0, #0x0
700a036a: d168         	bne	0x700a043e <UART_write+0x19e> @ imm = #0xd0
700a036c: e7ff         	b	0x700a036e <UART_write+0xce> @ imm = #-0x2
;         key = HwiP_disable();
700a036e: f010 e978    	blx	0x700b0660 <HwiP_disable> @ imm = #0x102f0
700a0372: 9005         	str	r0, [sp, #0x14]
;         HwiP_restore(key);
700a0374: 9805         	ldr	r0, [sp, #0x14]
700a0376: f010 e994    	blx	0x700b06a0 <HwiP_restore> @ imm = #0x10328
;         uartLld_handle->state = UART_STATE_READY;
700a037a: 9904         	ldr	r1, [sp, #0x10]
700a037c: 2001         	movs	r0, #0x1
700a037e: 6548         	str	r0, [r1, #0x54]
;         if ((UART_CONFIG_MODE_INTERRUPT == prms->transferMode) ||
700a0380: 9806         	ldr	r0, [sp, #0x18]
700a0382: 6ac0         	ldr	r0, [r0, #0x2c]
700a0384: 2801         	cmp	r0, #0x1
700a0386: d005         	beq	0x700a0394 <UART_write+0xf4> @ imm = #0xa
700a0388: e7ff         	b	0x700a038a <UART_write+0xea> @ imm = #-0x2
;             (UART_CONFIG_MODE_DMA == prms->transferMode))
700a038a: 9806         	ldr	r0, [sp, #0x18]
700a038c: 6ac0         	ldr	r0, [r0, #0x2c]
;         if ((UART_CONFIG_MODE_INTERRUPT == prms->transferMode) ||
700a038e: 2803         	cmp	r0, #0x3
700a0390: d146         	bne	0x700a0420 <UART_write+0x180> @ imm = #0x8c
700a0392: e7ff         	b	0x700a0394 <UART_write+0xf4> @ imm = #-0x2
;             if (UART_CONFIG_MODE_INTERRUPT == prms->transferMode)
700a0394: 9806         	ldr	r0, [sp, #0x18]
700a0396: 6ac0         	ldr	r0, [r0, #0x2c]
700a0398: 2801         	cmp	r0, #0x1
700a039a: d109         	bne	0x700a03b0 <UART_write+0x110> @ imm = #0x12
700a039c: e7ff         	b	0x700a039e <UART_write+0xfe> @ imm = #-0x2
;                 status = UART_lld_writeIntr(uartLld_handle, trans->buf, trans->count, &extendedParams);
700a039e: 9804         	ldr	r0, [sp, #0x10]
700a03a0: 9a0c         	ldr	r2, [sp, #0x30]
700a03a2: 6811         	ldr	r1, [r2]
700a03a4: 6852         	ldr	r2, [r2, #0x4]
700a03a6: ab03         	add	r3, sp, #0xc
700a03a8: f006 fd7a    	bl	0x700a6ea0 <UART_lld_writeIntr> @ imm = #0x6af4
700a03ac: 900b         	str	r0, [sp, #0x2c]
;             }
700a03ae: e008         	b	0x700a03c2 <UART_write+0x122> @ imm = #0x10
;                 status = UART_lld_writeDma(uartLld_handle, trans->buf, trans->count, &extendedParams);
700a03b0: 9804         	ldr	r0, [sp, #0x10]
700a03b2: 9a0c         	ldr	r2, [sp, #0x30]
700a03b4: 6811         	ldr	r1, [r2]
700a03b6: 6852         	ldr	r2, [r2, #0x4]
700a03b8: ab03         	add	r3, sp, #0xc
700a03ba: f006 fbd1    	bl	0x700a6b60 <UART_lld_writeDma> @ imm = #0x67a2
700a03be: 900b         	str	r0, [sp, #0x2c]
700a03c0: e7ff         	b	0x700a03c2 <UART_write+0x122> @ imm = #-0x2
;             if (SystemP_SUCCESS == status)
700a03c2: 980b         	ldr	r0, [sp, #0x2c]
700a03c4: bb58         	cbnz	r0, 0x700a041e <UART_write+0x17e> @ imm = #0x56
700a03c6: e7ff         	b	0x700a03c8 <UART_write+0x128> @ imm = #-0x2
;                 if(object->prms.writeMode == UART_TRANSFER_MODE_BLOCKING)
700a03c8: 9808         	ldr	r0, [sp, #0x20]
700a03ca: 69c0         	ldr	r0, [r0, #0x1c]
700a03cc: bb18         	cbnz	r0, 0x700a0416 <UART_write+0x176> @ imm = #0x46
700a03ce: e7ff         	b	0x700a03d0 <UART_write+0x130> @ imm = #-0x2
;                     semStatus = SemaphoreP_pend(&object->writeTransferSemObj, trans->timeout);
700a03d0: 9808         	ldr	r0, [sp, #0x20]
700a03d2: f500 70e2    	add.w	r0, r0, #0x1c4
700a03d6: 990c         	ldr	r1, [sp, #0x30]
700a03d8: 6889         	ldr	r1, [r1, #0x8]
700a03da: f00a f8d1    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0xa1a2
700a03de: 900a         	str	r0, [sp, #0x28]
;                     if (semStatus == SystemP_SUCCESS)
700a03e0: 980a         	ldr	r0, [sp, #0x28]
700a03e2: b960         	cbnz	r0, 0x700a03fe <UART_write+0x15e> @ imm = #0x18
700a03e4: e7ff         	b	0x700a03e6 <UART_write+0x146> @ imm = #-0x2
;                         if (trans->status == (uint32_t)UART_STATUS_SUCCESS)
700a03e6: 980c         	ldr	r0, [sp, #0x30]
700a03e8: 68c0         	ldr	r0, [r0, #0xc]
700a03ea: b918         	cbnz	r0, 0x700a03f4 <UART_write+0x154> @ imm = #0x6
700a03ec: e7ff         	b	0x700a03ee <UART_write+0x14e> @ imm = #-0x2
700a03ee: 2000         	movs	r0, #0x0
;                             status = SystemP_SUCCESS;
700a03f0: 900b         	str	r0, [sp, #0x2c]
;                         }
700a03f2: e003         	b	0x700a03fc <UART_write+0x15c> @ imm = #0x6
700a03f4: f04f 30ff    	mov.w	r0, #0xffffffff
;                             status = SystemP_FAILURE;
700a03f8: 900b         	str	r0, [sp, #0x2c]
700a03fa: e7ff         	b	0x700a03fc <UART_write+0x15c> @ imm = #-0x2
;                     }
700a03fc: e00a         	b	0x700a0414 <UART_write+0x174> @ imm = #0x14
;                         trans->status = UART_TRANSFER_TIMEOUT;
700a03fe: 990c         	ldr	r1, [sp, #0x30]
700a0400: f06f 0001    	mvn	r0, #0x1
700a0404: 60c8         	str	r0, [r1, #0xc]
;                         (void)UART_writeCancelNoCB(uartLld_handle);
700a0406: 9804         	ldr	r0, [sp, #0x10]
700a0408: f009 fd5a    	bl	0x700a9ec0 <UART_writeCancelNoCB> @ imm = #0x9ab4
700a040c: f04f 30ff    	mov.w	r0, #0xffffffff
;                         status = SystemP_FAILURE;
700a0410: 900b         	str	r0, [sp, #0x2c]
700a0412: e7ff         	b	0x700a0414 <UART_write+0x174> @ imm = #-0x2
;                 }
700a0414: e002         	b	0x700a041c <UART_write+0x17c> @ imm = #0x4
700a0416: 2000         	movs	r0, #0x0
;                     status = SystemP_SUCCESS;
700a0418: 900b         	str	r0, [sp, #0x2c]
700a041a: e7ff         	b	0x700a041c <UART_write+0x17c> @ imm = #-0x2
;             }
700a041c: e7ff         	b	0x700a041e <UART_write+0x17e> @ imm = #-0x2
;         }
700a041e: e00d         	b	0x700a043c <UART_write+0x19c> @ imm = #0x1a
;             status = UART_lld_write(uartLld_handle, trans->buf, trans->count, trans->timeout, &extendedParams);
700a0420: 9804         	ldr	r0, [sp, #0x10]
700a0422: 9b0c         	ldr	r3, [sp, #0x30]
700a0424: 6819         	ldr	r1, [r3]
700a0426: 685a         	ldr	r2, [r3, #0x4]
700a0428: 689b         	ldr	r3, [r3, #0x8]
700a042a: 46ee         	mov	lr, sp
700a042c: f10d 0c0c    	add.w	r12, sp, #0xc
700a0430: f8ce c000    	str.w	r12, [lr]
700a0434: f006 f8a4    	bl	0x700a6580 <UART_lld_write> @ imm = #0x6148
700a0438: 900b         	str	r0, [sp, #0x2c]
700a043a: e7ff         	b	0x700a043c <UART_write+0x19c> @ imm = #-0x2
;     }
700a043c: e7ff         	b	0x700a043e <UART_write+0x19e> @ imm = #-0x2
;     return (status);
700a043e: 980b         	ldr	r0, [sp, #0x2c]
700a0440: b00e         	add	sp, #0x38
700a0442: bd80         	pop	{r7, pc}
		...

700a0450 <Sciclient_rmClearInterruptRoute>:
; {
700a0450: b580         	push	{r7, lr}
700a0452: b08e         	sub	sp, #0x38
700a0454: 900d         	str	r0, [sp, #0x34]
700a0456: 910c         	str	r1, [sp, #0x30]
700a0458: 920b         	str	r2, [sp, #0x2c]
700a045a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a045c: 9001         	str	r0, [sp, #0x4]
700a045e: 900a         	str	r0, [sp, #0x28]
700a0460: f241 0101    	movw	r1, #0x1001
;     uint16_t messageType = TISCI_MSG_RM_IRQ_RELEASE;
700a0464: f8ad 1026    	strh.w	r1, [sp, #0x26]
;     memset(&cfg, 0, sizeof(cfg));
700a0468: 9008         	str	r0, [sp, #0x20]
700a046a: 9007         	str	r0, [sp, #0x1c]
700a046c: 9006         	str	r0, [sp, #0x18]
700a046e: 9005         	str	r0, [sp, #0x14]
700a0470: 9004         	str	r0, [sp, #0x10]
700a0472: 9003         	str	r0, [sp, #0xc]
700a0474: 9002         	str	r0, [sp, #0x8]
;     if((req == NULL) || (resp == NULL)) {
700a0476: 980d         	ldr	r0, [sp, #0x34]
700a0478: b118         	cbz	r0, 0x700a0482 <Sciclient_rmClearInterruptRoute+0x32> @ imm = #0x6
700a047a: e7ff         	b	0x700a047c <Sciclient_rmClearInterruptRoute+0x2c> @ imm = #-0x2
700a047c: 980c         	ldr	r0, [sp, #0x30]
700a047e: b920         	cbnz	r0, 0x700a048a <Sciclient_rmClearInterruptRoute+0x3a> @ imm = #0x8
700a0480: e7ff         	b	0x700a0482 <Sciclient_rmClearInterruptRoute+0x32> @ imm = #-0x2
700a0482: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a0486: 900a         	str	r0, [sp, #0x28]
;     }
700a0488: e7ff         	b	0x700a048a <Sciclient_rmClearInterruptRoute+0x3a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a048a: 980a         	ldr	r0, [sp, #0x28]
700a048c: b968         	cbnz	r0, 0x700a04aa <Sciclient_rmClearInterruptRoute+0x5a> @ imm = #0x1a
700a048e: e7ff         	b	0x700a0490 <Sciclient_rmClearInterruptRoute+0x40> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a0490: 980d         	ldr	r0, [sp, #0x34]
700a0492: 6880         	ldr	r0, [r0, #0x8]
700a0494: f04f 4100    	mov.w	r1, #0x80000000
700a0498: f00e fae2    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0xe5c4
;     if (r == SystemP_SUCCESS &&
700a049c: b128         	cbz	r0, 0x700a04aa <Sciclient_rmClearInterruptRoute+0x5a> @ imm = #0xa
700a049e: e7ff         	b	0x700a04a0 <Sciclient_rmClearInterruptRoute+0x50> @ imm = #-0x2
;         dst_host = req->secondary_host;
700a04a0: 980d         	ldr	r0, [sp, #0x34]
700a04a2: 7ec0         	ldrb	r0, [r0, #0x1b]
700a04a4: f88d 0025    	strb.w	r0, [sp, #0x25]
;     } else {
700a04a8: e00f         	b	0x700a04ca <Sciclient_rmClearInterruptRoute+0x7a> @ imm = #0x1e
;         dst_host = (uint8_t) gSciclientMap[Sciclient_getCurrentContext(messageType)].hostId;
700a04aa: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
700a04ae: f007 fa5f    	bl	0x700a7970 <Sciclient_getCurrentContext> @ imm = #0x74be
700a04b2: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a04b6: f241 0060    	movw	r0, #0x1060
700a04ba: f2c7 000b    	movt	r0, #0x700b
700a04be: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a04c2: 6840         	ldr	r0, [r0, #0x4]
700a04c4: f88d 0025    	strb.w	r0, [sp, #0x25]
700a04c8: e7ff         	b	0x700a04ca <Sciclient_rmClearInterruptRoute+0x7a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a04ca: 980a         	ldr	r0, [sp, #0x28]
700a04cc: b960         	cbnz	r0, 0x700a04e8 <Sciclient_rmClearInterruptRoute+0x98> @ imm = #0x18
700a04ce: e7ff         	b	0x700a04d0 <Sciclient_rmClearInterruptRoute+0x80> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a04d0: 980d         	ldr	r0, [sp, #0x34]
700a04d2: 6880         	ldr	r0, [r0, #0x8]
700a04d4: 2104         	movs	r1, #0x4
700a04d6: f00e fac3    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0xe586
;     if (r == SystemP_SUCCESS &&
700a04da: b128         	cbz	r0, 0x700a04e8 <Sciclient_rmClearInterruptRoute+0x98> @ imm = #0xa
700a04dc: e7ff         	b	0x700a04de <Sciclient_rmClearInterruptRoute+0x8e> @ imm = #-0x2
;         cfg.s_ia = req->ia_id;
700a04de: 980d         	ldr	r0, [sp, #0x34]
700a04e0: 8a80         	ldrh	r0, [r0, #0x14]
700a04e2: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     } else {
700a04e6: e003         	b	0x700a04f0 <Sciclient_rmClearInterruptRoute+0xa0> @ imm = #0x6
700a04e8: 20ff         	movs	r0, #0xff
;         cfg.s_ia = SCICLIENT_RM_DEV_NONE;
700a04ea: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a04ee: e7ff         	b	0x700a04f0 <Sciclient_rmClearInterruptRoute+0xa0> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a04f0: 980a         	ldr	r0, [sp, #0x28]
700a04f2: 2800         	cmp	r0, #0x0
700a04f4: d175         	bne	0x700a05e2 <Sciclient_rmClearInterruptRoute+0x192> @ imm = #0xea
700a04f6: e7ff         	b	0x700a04f8 <Sciclient_rmClearInterruptRoute+0xa8> @ imm = #-0x2
;         cfg.valid_params = req->valid_params;
700a04f8: 980d         	ldr	r0, [sp, #0x34]
700a04fa: 6880         	ldr	r0, [r0, #0x8]
700a04fc: 9002         	str	r0, [sp, #0x8]
;         cfg.host = dst_host;
700a04fe: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a0502: f88d 000c    	strb.w	r0, [sp, #0xc]
;         cfg.s_id = req->src_id;
700a0506: 980d         	ldr	r0, [sp, #0x34]
700a0508: 8980         	ldrh	r0, [r0, #0xc]
700a050a: f8ad 000e    	strh.w	r0, [sp, #0xe]
;         cfg.s_idx = req->src_index;
700a050e: 980d         	ldr	r0, [sp, #0x34]
700a0510: 89c0         	ldrh	r0, [r0, #0xe]
700a0512: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         cfg.d_id = req->dst_id;
700a0516: 980d         	ldr	r0, [sp, #0x34]
700a0518: 8a00         	ldrh	r0, [r0, #0x10]
700a051a: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         cfg.d_irq = req->dst_host_irq;
700a051e: 980d         	ldr	r0, [sp, #0x34]
700a0520: 8a40         	ldrh	r0, [r0, #0x12]
700a0522: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         cfg.global_evt = req->global_event;
700a0526: 980d         	ldr	r0, [sp, #0x34]
700a0528: 8b00         	ldrh	r0, [r0, #0x18]
700a052a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         cfg.vint = req->vint;
700a052e: 980d         	ldr	r0, [sp, #0x34]
700a0530: 8ac0         	ldrh	r0, [r0, #0x16]
700a0532: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         cfg.vint_sb = req->vint_status_bit_index;
700a0536: 980d         	ldr	r0, [sp, #0x34]
700a0538: 7e80         	ldrb	r0, [r0, #0x1a]
700a053a: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         if (Sciclient_rmIrqCfgIsDirectNonEvent(cfg.valid_params) == true) {
700a053e: 9802         	ldr	r0, [sp, #0x8]
700a0540: f00b f89e    	bl	0x700ab680 <Sciclient_rmIrqCfgIsDirectNonEvent> @ imm = #0xb13c
700a0544: b310         	cbz	r0, 0x700a058c <Sciclient_rmClearInterruptRoute+0x13c> @ imm = #0x44
700a0546: e7ff         	b	0x700a0548 <Sciclient_rmClearInterruptRoute+0xf8> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cfg.s_id) == true) {
700a0548: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a054c: f00e f890    	bl	0x700ae670 <Sciclient_rmIaIsIa> @ imm = #0xe120
700a0550: b168         	cbz	r0, 0x700a056e <Sciclient_rmClearInterruptRoute+0x11e> @ imm = #0x1a
700a0552: e7ff         	b	0x700a0554 <Sciclient_rmClearInterruptRoute+0x104> @ imm = #-0x2
;                 cfg.s_ia = cfg.s_id;
700a0554: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a0558: f8ad 0018    	strh.w	r0, [sp, #0x18]
;                 cfg.vint = cfg.s_idx;
700a055c: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a0560: f8ad 001a    	strh.w	r0, [sp, #0x1a]
700a0564: a802         	add	r0, sp, #0x8
;                 r = Sciclient_rmIrqUnmappedVintRouteDelete(&cfg);
700a0566: f00c f873    	bl	0x700ac650 <Sciclient_rmIrqUnmappedVintRouteDelete> @ imm = #0xc0e6
700a056a: 900a         	str	r0, [sp, #0x28]
;             } else {
700a056c: e00d         	b	0x700a058a <Sciclient_rmClearInterruptRoute+0x13a> @ imm = #0x1a
700a056e: a802         	add	r0, sp, #0x8
;                 r = Sciclient_rmIrqGetRoute(&cfg);
700a0570: f7fc fb7e    	bl	0x7009cc70 <Sciclient_rmIrqGetRoute> @ imm = #-0x3904
700a0574: 900a         	str	r0, [sp, #0x28]
;                 if (r == SystemP_SUCCESS) {
700a0576: 980a         	ldr	r0, [sp, #0x28]
700a0578: b930         	cbnz	r0, 0x700a0588 <Sciclient_rmClearInterruptRoute+0x138> @ imm = #0xc
700a057a: e7ff         	b	0x700a057c <Sciclient_rmClearInterruptRoute+0x12c> @ imm = #-0x2
700a057c: a802         	add	r0, sp, #0x8
700a057e: 2100         	movs	r1, #0x0
;                     r = Sciclient_rmIrqDeleteRoute(&cfg, false);
700a0580: f000 f9ce    	bl	0x700a0920 <Sciclient_rmIrqDeleteRoute> @ imm = #0x39c
700a0584: 900a         	str	r0, [sp, #0x28]
;                 }
700a0586: e7ff         	b	0x700a0588 <Sciclient_rmClearInterruptRoute+0x138> @ imm = #-0x2
700a0588: e7ff         	b	0x700a058a <Sciclient_rmClearInterruptRoute+0x13a> @ imm = #-0x2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a058a: e029         	b	0x700a05e0 <Sciclient_rmClearInterruptRoute+0x190> @ imm = #0x52
700a058c: 9802         	ldr	r0, [sp, #0x8]
700a058e: f00b f83f    	bl	0x700ab610 <Sciclient_rmIrqCfgIsDirectEvent> @ imm = #0xb07e
;                 true) ||
700a0592: b928         	cbnz	r0, 0x700a05a0 <Sciclient_rmClearInterruptRoute+0x150> @ imm = #0xa
700a0594: e7ff         	b	0x700a0596 <Sciclient_rmClearInterruptRoute+0x146> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg.valid_params) ==
700a0596: 9802         	ldr	r0, [sp, #0x8]
700a0598: f00b f8aa    	bl	0x700ab6f0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0xb154
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a059c: b128         	cbz	r0, 0x700a05aa <Sciclient_rmClearInterruptRoute+0x15a> @ imm = #0xa
700a059e: e7ff         	b	0x700a05a0 <Sciclient_rmClearInterruptRoute+0x150> @ imm = #-0x2
700a05a0: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqVintDelete(&cfg);
700a05a2: f002 fb35    	bl	0x700a2c10 <Sciclient_rmIrqVintDelete> @ imm = #0x266a
700a05a6: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsUnmappedVintDirectEvent(cfg.valid_params) ==
700a05a8: e019         	b	0x700a05de <Sciclient_rmClearInterruptRoute+0x18e> @ imm = #0x32
700a05aa: 9802         	ldr	r0, [sp, #0x8]
700a05ac: f00b f910    	bl	0x700ab7d0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent> @ imm = #0xb220
700a05b0: b128         	cbz	r0, 0x700a05be <Sciclient_rmClearInterruptRoute+0x16e> @ imm = #0xa
700a05b2: e7ff         	b	0x700a05b4 <Sciclient_rmClearInterruptRoute+0x164> @ imm = #-0x2
700a05b4: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqUnmappedVintRouteDelete(&cfg);
700a05b6: f00c f84b    	bl	0x700ac650 <Sciclient_rmIrqUnmappedVintRouteDelete> @ imm = #0xc096
700a05ba: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsOesOnly(cfg.valid_params) == true) {
700a05bc: e00e         	b	0x700a05dc <Sciclient_rmClearInterruptRoute+0x18c> @ imm = #0x1c
700a05be: 9802         	ldr	r0, [sp, #0x8]
700a05c0: f00b f8ce    	bl	0x700ab760 <Sciclient_rmIrqCfgIsOesOnly> @ imm = #0xb19c
700a05c4: b128         	cbz	r0, 0x700a05d2 <Sciclient_rmClearInterruptRoute+0x182> @ imm = #0xa
700a05c6: e7ff         	b	0x700a05c8 <Sciclient_rmClearInterruptRoute+0x178> @ imm = #-0x2
700a05c8: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqClearOesRegister(&cfg);
700a05ca: f00d fbc9    	bl	0x700add60 <Sciclient_rmIrqClearOesRegister> @ imm = #0xd792
700a05ce: 900a         	str	r0, [sp, #0x28]
;         } else {
700a05d0: e003         	b	0x700a05da <Sciclient_rmClearInterruptRoute+0x18a> @ imm = #0x6
700a05d2: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a05d6: 900a         	str	r0, [sp, #0x28]
700a05d8: e7ff         	b	0x700a05da <Sciclient_rmClearInterruptRoute+0x18a> @ imm = #-0x2
700a05da: e7ff         	b	0x700a05dc <Sciclient_rmClearInterruptRoute+0x18c> @ imm = #-0x2
700a05dc: e7ff         	b	0x700a05de <Sciclient_rmClearInterruptRoute+0x18e> @ imm = #-0x2
700a05de: e7ff         	b	0x700a05e0 <Sciclient_rmClearInterruptRoute+0x190> @ imm = #-0x2
;     }
700a05e0: e7ff         	b	0x700a05e2 <Sciclient_rmClearInterruptRoute+0x192> @ imm = #-0x2
;     return r;
700a05e2: 980a         	ldr	r0, [sp, #0x28]
700a05e4: b00e         	add	sp, #0x38
700a05e6: bd80         	pop	{r7, pc}
		...

700a05f0 <Udma_chConfigTx>:
; {
700a05f0: b580         	push	{r7, lr}
700a05f2: b090         	sub	sp, #0x40
700a05f4: 900f         	str	r0, [sp, #0x3c]
700a05f6: 910e         	str	r1, [sp, #0x38]
700a05f8: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
700a05fa: 900d         	str	r0, [sp, #0x34]
;     Udma_ChHandleInt        chHandleInt = (Udma_ChHandleInt) chHandle;
700a05fc: 980f         	ldr	r0, [sp, #0x3c]
700a05fe: 900b         	str	r0, [sp, #0x2c]
;     if((NULL_PTR == chHandleInt) ||
700a0600: 980b         	ldr	r0, [sp, #0x2c]
700a0602: b178         	cbz	r0, 0x700a0624 <Udma_chConfigTx+0x34> @ imm = #0x1e
700a0604: e7ff         	b	0x700a0606 <Udma_chConfigTx+0x16> @ imm = #-0x2
;        (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
700a0606: 980b         	ldr	r0, [sp, #0x2c]
700a0608: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a060c: f64a 31cd    	movw	r1, #0xabcd
700a0610: f6ca 31dc    	movt	r1, #0xabdc
700a0614: 4288         	cmp	r0, r1
700a0616: d105         	bne	0x700a0624 <Udma_chConfigTx+0x34> @ imm = #0xa
700a0618: e7ff         	b	0x700a061a <Udma_chConfigTx+0x2a> @ imm = #-0x2
;        ((chHandleInt->chType & UDMA_CH_FLAG_TX) != UDMA_CH_FLAG_TX))
700a061a: 980b         	ldr	r0, [sp, #0x2c]
;     if((NULL_PTR == chHandleInt) ||
700a061c: 7800         	ldrb	r0, [r0]
700a061e: 07c0         	lsls	r0, r0, #0x1f
700a0620: b920         	cbnz	r0, 0x700a062c <Udma_chConfigTx+0x3c> @ imm = #0x8
700a0622: e7ff         	b	0x700a0624 <Udma_chConfigTx+0x34> @ imm = #-0x2
700a0624: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a0628: 900d         	str	r0, [sp, #0x34]
;     }
700a062a: e7ff         	b	0x700a062c <Udma_chConfigTx+0x3c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a062c: 980d         	ldr	r0, [sp, #0x34]
700a062e: b9a8         	cbnz	r0, 0x700a065c <Udma_chConfigTx+0x6c> @ imm = #0x2a
700a0630: e7ff         	b	0x700a0632 <Udma_chConfigTx+0x42> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a0632: 980b         	ldr	r0, [sp, #0x2c]
700a0634: 6e80         	ldr	r0, [r0, #0x68]
700a0636: 900c         	str	r0, [sp, #0x30]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a0638: 980c         	ldr	r0, [sp, #0x30]
700a063a: b150         	cbz	r0, 0x700a0652 <Udma_chConfigTx+0x62> @ imm = #0x14
700a063c: e7ff         	b	0x700a063e <Udma_chConfigTx+0x4e> @ imm = #-0x2
700a063e: 980c         	ldr	r0, [sp, #0x30]
700a0640: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a0644: f64a 31cd    	movw	r1, #0xabcd
700a0648: f6ca 31dc    	movt	r1, #0xabdc
700a064c: 4288         	cmp	r0, r1
700a064e: d004         	beq	0x700a065a <Udma_chConfigTx+0x6a> @ imm = #0x8
700a0650: e7ff         	b	0x700a0652 <Udma_chConfigTx+0x62> @ imm = #-0x2
700a0652: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a0656: 900d         	str	r0, [sp, #0x34]
;         }
700a0658: e7ff         	b	0x700a065a <Udma_chConfigTx+0x6a> @ imm = #-0x2
;     }
700a065a: e7ff         	b	0x700a065c <Udma_chConfigTx+0x6c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a065c: 980d         	ldr	r0, [sp, #0x34]
700a065e: 2800         	cmp	r0, #0x0
700a0660: f040 808e    	bne.w	0x700a0780 <Udma_chConfigTx+0x190> @ imm = #0x11c
700a0664: e7ff         	b	0x700a0666 <Udma_chConfigTx+0x76> @ imm = #-0x2
700a0666: f647 70ff    	movw	r0, #0x7fff
;         rmUdmaTxReq.valid_params        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERR_VALID |
700a066a: 9004         	str	r0, [sp, #0x10]
;         rmUdmaTxReq.nav_id              = drvHandle->devIdUdma;
700a066c: 980c         	ldr	r0, [sp, #0x30]
700a066e: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
700a0672: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmUdmaTxReq.index               = (uint16_t)chHandleInt->txChNum;
700a0676: 980b         	ldr	r0, [sp, #0x2c]
700a0678: 6ec0         	ldr	r0, [r0, #0x6c]
700a067a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         rmUdmaTxReq.tx_pause_on_err     = txPrms->pauseOnError;
700a067e: 980e         	ldr	r0, [sp, #0x38]
700a0680: 7800         	ldrb	r0, [r0]
700a0682: f88d 0018    	strb.w	r0, [sp, #0x18]
;         rmUdmaTxReq.tx_filt_einfo       = txPrms->filterEinfo;
700a0686: 980e         	ldr	r0, [sp, #0x38]
700a0688: 7840         	ldrb	r0, [r0, #0x1]
700a068a: f88d 0019    	strb.w	r0, [sp, #0x19]
;         rmUdmaTxReq.tx_filt_pswords     = txPrms->filterPsWords;
700a068e: 980e         	ldr	r0, [sp, #0x38]
700a0690: 7880         	ldrb	r0, [r0, #0x2]
700a0692: f88d 001a    	strb.w	r0, [sp, #0x1a]
;         rmUdmaTxReq.tx_atype            = txPrms->addrType;
700a0696: 980e         	ldr	r0, [sp, #0x38]
700a0698: 78c0         	ldrb	r0, [r0, #0x3]
700a069a: f88d 001b    	strb.w	r0, [sp, #0x1b]
;         rmUdmaTxReq.tx_chan_type        = txPrms->chanType;
700a069e: 980e         	ldr	r0, [sp, #0x38]
700a06a0: 7900         	ldrb	r0, [r0, #0x4]
700a06a2: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         rmUdmaTxReq.tx_fetch_size       = txPrms->fetchWordSize;
700a06a6: 980e         	ldr	r0, [sp, #0x38]
700a06a8: 88c0         	ldrh	r0, [r0, #0x6]
700a06aa: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmUdmaTxReq.tx_priority         = txPrms->busPriority;
700a06ae: 980e         	ldr	r0, [sp, #0x38]
700a06b0: 7a00         	ldrb	r0, [r0, #0x8]
700a06b2: f88d 0023    	strb.w	r0, [sp, #0x23]
;         rmUdmaTxReq.tx_qos              = txPrms->busQos;
700a06b6: 980e         	ldr	r0, [sp, #0x38]
700a06b8: 7a40         	ldrb	r0, [r0, #0x9]
700a06ba: f88d 0024    	strb.w	r0, [sp, #0x24]
;         rmUdmaTxReq.tx_orderid          = txPrms->busOrderId;
700a06be: 980e         	ldr	r0, [sp, #0x38]
700a06c0: 7a80         	ldrb	r0, [r0, #0xa]
700a06c2: f88d 0025    	strb.w	r0, [sp, #0x25]
;         rmUdmaTxReq.fdepth              = txPrms->fifoDepth;
700a06c6: 980e         	ldr	r0, [sp, #0x38]
700a06c8: 89c0         	ldrh	r0, [r0, #0xe]
700a06ca: f8ad 0026    	strh.w	r0, [sp, #0x26]
;         rmUdmaTxReq.tx_burst_size       = txPrms->burstSize;
700a06ce: 980e         	ldr	r0, [sp, #0x38]
700a06d0: 7c00         	ldrb	r0, [r0, #0x10]
700a06d2: f88d 0029    	strb.w	r0, [sp, #0x29]
;         rmUdmaTxReq.tx_sched_priority   = txPrms->dmaPriority;
700a06d6: 980e         	ldr	r0, [sp, #0x38]
700a06d8: 7ac0         	ldrb	r0, [r0, #0xb]
700a06da: f88d 0028    	strb.w	r0, [sp, #0x28]
;         rmUdmaTxReq.tx_credit_count     = txPrms->txCredit;
700a06de: 980e         	ldr	r0, [sp, #0x38]
700a06e0: 7b00         	ldrb	r0, [r0, #0xc]
700a06e2: f88d 0020    	strb.w	r0, [sp, #0x20]
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a06e6: 980c         	ldr	r0, [sp, #0x30]
700a06e8: 6800         	ldr	r0, [r0]
700a06ea: 2801         	cmp	r0, #0x1
700a06ec: d11d         	bne	0x700a072a <Udma_chConfigTx+0x13a> @ imm = #0x3a
700a06ee: e7ff         	b	0x700a06f0 <Udma_chConfigTx+0x100> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a06f0: 980b         	ldr	r0, [sp, #0x2c]
700a06f2: 7800         	ldrb	r0, [r0]
700a06f4: 0740         	lsls	r0, r0, #0x1d
700a06f6: 2800         	cmp	r0, #0x0
700a06f8: d508         	bpl	0x700a070c <Udma_chConfigTx+0x11c> @ imm = #0x10
700a06fa: e7ff         	b	0x700a06fc <Udma_chConfigTx+0x10c> @ imm = #-0x2
;                 rmUdmaTxReq.valid_params    |= TISCI_MSG_VALUE_RM_UDMAP_EXTENDED_CH_TYPE_VALID;
700a06fc: 9804         	ldr	r0, [sp, #0x10]
700a06fe: f440 3080    	orr	r0, r0, #0x10000
700a0702: 9004         	str	r0, [sp, #0x10]
700a0704: 2001         	movs	r0, #0x1
;                 rmUdmaTxReq.extended_ch_type = UDMA_DMSC_EXTENDED_CH_TYPE_BCDMA_BLK_CPY;
700a0706: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             }
700a070a: e00d         	b	0x700a0728 <Udma_chConfigTx+0x138> @ imm = #0x1a
;             else if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a070c: 980b         	ldr	r0, [sp, #0x2c]
700a070e: 7800         	ldrb	r0, [r0]
700a0710: 07c0         	lsls	r0, r0, #0x1f
700a0712: b140         	cbz	r0, 0x700a0726 <Udma_chConfigTx+0x136> @ imm = #0x10
700a0714: e7ff         	b	0x700a0716 <Udma_chConfigTx+0x126> @ imm = #-0x2
;                 rmUdmaTxReq.valid_params    |= TISCI_MSG_VALUE_RM_UDMAP_EXTENDED_CH_TYPE_VALID;
700a0716: 9804         	ldr	r0, [sp, #0x10]
700a0718: f440 3080    	orr	r0, r0, #0x10000
700a071c: 9004         	str	r0, [sp, #0x10]
700a071e: 2000         	movs	r0, #0x0
;                 rmUdmaTxReq.extended_ch_type = UDMA_DMSC_EXTENDED_CH_TYPE_BCDMA_SPLIT_TR_TX;
700a0720: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             }
700a0724: e7ff         	b	0x700a0726 <Udma_chConfigTx+0x136> @ imm = #-0x2
700a0726: e7ff         	b	0x700a0728 <Udma_chConfigTx+0x138> @ imm = #-0x2
;         }
700a0728: e7ff         	b	0x700a072a <Udma_chConfigTx+0x13a> @ imm = #-0x2
;         if(NULL_PTR != chHandleInt->tdCqRing)
700a072a: 980b         	ldr	r0, [sp, #0x2c]
700a072c: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a0730: b158         	cbz	r0, 0x700a074a <Udma_chConfigTx+0x15a> @ imm = #0x16
700a0732: e7ff         	b	0x700a0734 <Udma_chConfigTx+0x144> @ imm = #-0x2
;             rmUdmaTxReq.txcq_qnum       = chHandleInt->tdCqRing->ringNum;
700a0734: 980b         	ldr	r0, [sp, #0x2c]
700a0736: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a073a: 8880         	ldrh	r0, [r0, #0x4]
700a073c: f8ad 0021    	strh.w	r0, [sp, #0x21]
;             rmUdmaTxReq.tx_supr_tdpkt   = txPrms->supressTdCqPkt;
700a0740: 980e         	ldr	r0, [sp, #0x38]
700a0742: 7c40         	ldrb	r0, [r0, #0x11]
700a0744: f88d 001d    	strb.w	r0, [sp, #0x1d]
;         }
700a0748: e007         	b	0x700a075a <Udma_chConfigTx+0x16a> @ imm = #0xe
700a074a: f64f 70ff    	movw	r0, #0xffff
;             rmUdmaTxReq.txcq_qnum       = UDMA_RING_INVALID;
700a074e: f8ad 0021    	strh.w	r0, [sp, #0x21]
700a0752: 2001         	movs	r0, #0x1
;             rmUdmaTxReq.tx_supr_tdpkt   = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_SUPPRESS_TD_ENABLED;
700a0754: f88d 001d    	strb.w	r0, [sp, #0x1d]
700a0758: e7ff         	b	0x700a075a <Udma_chConfigTx+0x16a> @ imm = #-0x2
700a075a: a802         	add	r0, sp, #0x8
700a075c: 4669         	mov	r1, sp
700a075e: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmUdmapTxChCfg(
700a0762: f00c f865    	bl	0x700ac830 <Sciclient_rmUdmapTxChCfg> @ imm = #0xc0ca
700a0766: 900d         	str	r0, [sp, #0x34]
;         if(CSL_PASS != retVal)
700a0768: 980d         	ldr	r0, [sp, #0x34]
700a076a: b108         	cbz	r0, 0x700a0770 <Udma_chConfigTx+0x180> @ imm = #0x2
700a076c: e7ff         	b	0x700a076e <Udma_chConfigTx+0x17e> @ imm = #-0x2
;         }
700a076e: e7ff         	b	0x700a0770 <Udma_chConfigTx+0x180> @ imm = #-0x2
;         (void) memcpy(&chHandleInt->txPrms, txPrms, sizeof(chHandleInt->txPrms));
700a0770: 980b         	ldr	r0, [sp, #0x2c]
700a0772: f500 70f2    	add.w	r0, r0, #0x1e4
700a0776: 990e         	ldr	r1, [sp, #0x38]
700a0778: 2212         	movs	r2, #0x12
700a077a: f7f9 ec70    	blx	0x7009a05c <__aeabi_memcpy8> @ imm = #-0x6720
;     }
700a077e: e7ff         	b	0x700a0780 <Udma_chConfigTx+0x190> @ imm = #-0x2
;     return (retVal);
700a0780: 980d         	ldr	r0, [sp, #0x34]
700a0782: b010         	add	sp, #0x40
700a0784: bd80         	pop	{r7, pc}
		...
700a078e: 0000         	movs	r0, r0

700a0790 <ClockP_init>:
; {
700a0790: b580         	push	{r7, lr}
700a0792: b096         	sub	sp, #0x58
;     DebugP_assert( gClockConfig.timerInputPreScaler != 0U);
700a0794: f242 50c0    	movw	r0, #0x25c0
700a0798: f2c7 000b    	movt	r0, #0x700b
700a079c: 9009         	str	r0, [sp, #0x24]
700a079e: 68c0         	ldr	r0, [r0, #0xc]
700a07a0: 2800         	cmp	r0, #0x0
700a07a2: bf18         	it	ne
700a07a4: 2001         	movne	r0, #0x1
700a07a6: f641 0146    	movw	r1, #0x1846
700a07aa: f2c7 010b    	movt	r1, #0x700b
700a07ae: 466a         	mov	r2, sp
700a07b0: 6011         	str	r1, [r2]
700a07b2: f641 21dd    	movw	r1, #0x1add
700a07b6: f2c7 010b    	movt	r1, #0x700b
700a07ba: 9107         	str	r1, [sp, #0x1c]
700a07bc: f641 52d0    	movw	r2, #0x1dd0
700a07c0: f2c7 020b    	movt	r2, #0x700b
700a07c4: 9208         	str	r2, [sp, #0x20]
700a07c6: 2334         	movs	r3, #0x34
700a07c8: f00a f932    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xa264
700a07cc: 9907         	ldr	r1, [sp, #0x1c]
700a07ce: 9a08         	ldr	r2, [sp, #0x20]
700a07d0: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.timerInputClkHz != 0U);
700a07d2: 6880         	ldr	r0, [r0, #0x8]
700a07d4: 2800         	cmp	r0, #0x0
700a07d6: bf18         	it	ne
700a07d8: 2001         	movne	r0, #0x1
700a07da: f641 03dc    	movw	r3, #0x18dc
700a07de: f2c7 030b    	movt	r3, #0x700b
700a07e2: 46ec         	mov	r12, sp
700a07e4: f8cc 3000    	str.w	r3, [r12]
700a07e8: 2335         	movs	r3, #0x35
700a07ea: f00a f921    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xa242
700a07ee: 9907         	ldr	r1, [sp, #0x1c]
700a07f0: 9a08         	ldr	r2, [sp, #0x20]
700a07f2: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.usecPerTick != 0U);
700a07f4: 6900         	ldr	r0, [r0, #0x10]
700a07f6: 2800         	cmp	r0, #0x0
700a07f8: bf18         	it	ne
700a07fa: 2001         	movne	r0, #0x1
700a07fc: f641 230c    	movw	r3, #0x1a0c
700a0800: f2c7 030b    	movt	r3, #0x700b
700a0804: 46ec         	mov	r12, sp
700a0806: f8cc 3000    	str.w	r3, [r12]
700a080a: 2336         	movs	r3, #0x36
700a080c: f00a f910    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xa220
700a0810: 9907         	ldr	r1, [sp, #0x1c]
700a0812: 9a08         	ldr	r2, [sp, #0x20]
700a0814: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.timerBaseAddr != 0U);
700a0816: 6800         	ldr	r0, [r0]
700a0818: 2800         	cmp	r0, #0x0
700a081a: bf18         	it	ne
700a081c: 2001         	movne	r0, #0x1
700a081e: f641 1387    	movw	r3, #0x1987
700a0822: f2c7 030b    	movt	r3, #0x700b
700a0826: 46ec         	mov	r12, sp
700a0828: f8cc 3000    	str.w	r3, [r12]
700a082c: 2337         	movs	r3, #0x37
700a082e: f00a f8ff    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0xa1fe
700a0832: 9809         	ldr	r0, [sp, #0x24]
;     gClockCtrl.ticks = 0;
700a0834: f245 1210    	movw	r2, #0x5110
700a0838: f2c7 0208    	movt	r2, #0x7008
700a083c: 2100         	movs	r1, #0x0
700a083e: 6051         	str	r1, [r2, #0x4]
700a0840: 6011         	str	r1, [r2]
;     gClockCtrl.usecPerTick = gClockConfig.usecPerTick;
700a0842: 6903         	ldr	r3, [r0, #0x10]
700a0844: 6093         	str	r3, [r2, #0x8]
;     gClockCtrl.timerBaseAddr = gClockConfig.timerBaseAddr;
700a0846: 6800         	ldr	r0, [r0]
700a0848: 62d0         	str	r0, [r2, #0x2c]
700a084a: f244 2040    	movw	r0, #0x4240
700a084e: f2c0 000f    	movt	r0, #0xf
;     if( pdMS_TO_TICKS( TIME_IN_MILLI_SECONDS ) != ClockP_usecToTicks( TIME_IN_MICRO_SECONDS ) )
700a0852: f00e fbfd    	bl	0x700af050 <ClockP_usecToTicks> @ imm = #0xe7fa
700a0856: f5b0 7f7a    	cmp.w	r0, #0x3e8
700a085a: d01d         	beq	0x700a0898 <ClockP_init+0x108> @ imm = #0x3a
700a085c: e7ff         	b	0x700a085e <ClockP_init+0xce> @ imm = #-0x2
;         DebugP_logWarn("FreeRTOS configTICK_RATE_HZ (%d), does not match ClockP tick rate Hz (%d)\r\n",
700a085e: f242 50c0    	movw	r0, #0x25c0
700a0862: f2c7 000b    	movt	r0, #0x700b
700a0866: 6901         	ldr	r1, [r0, #0x10]
700a0868: f244 2040    	movw	r0, #0x4240
700a086c: f2c0 000f    	movt	r0, #0xf
700a0870: fbb0 f0f1    	udiv	r0, r0, r1
700a0874: 4669         	mov	r1, sp
700a0876: 6048         	str	r0, [r1, #0x4]
700a0878: f44f 707a    	mov.w	r0, #0x3e8
700a087c: 6008         	str	r0, [r1]
700a087e: f241 516c    	movw	r1, #0x156c
700a0882: f2c7 010b    	movt	r1, #0x700b
700a0886: f641 52d0    	movw	r2, #0x1dd0
700a088a: f2c7 020b    	movt	r2, #0x700b
700a088e: 2004         	movs	r0, #0x4
700a0890: 2346         	movs	r3, #0x46
700a0892: f009 f915    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #0x922a
;     }
700a0896: e7ff         	b	0x700a0898 <ClockP_init+0x108> @ imm = #-0x2
700a0898: a80f         	add	r0, sp, #0x3c
;     TimerP_Params_init(&timerParams);
700a089a: 9002         	str	r0, [sp, #0x8]
700a089c: f00d fd00    	bl	0x700ae2a0 <TimerP_Params_init> @ imm = #0xda00
700a08a0: 9902         	ldr	r1, [sp, #0x8]
;     timerParams.inputPreScaler    = gClockConfig.timerInputPreScaler;
700a08a2: f242 50c0    	movw	r0, #0x25c0
700a08a6: f2c7 000b    	movt	r0, #0x700b
700a08aa: 9004         	str	r0, [sp, #0x10]
700a08ac: 68c2         	ldr	r2, [r0, #0xc]
700a08ae: 920f         	str	r2, [sp, #0x3c]
;     timerParams.inputClkHz        = gClockConfig.timerInputClkHz;
700a08b0: 6882         	ldr	r2, [r0, #0x8]
700a08b2: 9210         	str	r2, [sp, #0x40]
;     timerParams.periodInUsec      = gClockConfig.usecPerTick;
700a08b4: 6900         	ldr	r0, [r0, #0x10]
700a08b6: 9011         	str	r0, [sp, #0x44]
700a08b8: 2000         	movs	r0, #0x0
;     timerParams.oneshotMode       = 0;
700a08ba: 9003         	str	r0, [sp, #0xc]
700a08bc: 9013         	str	r0, [sp, #0x4c]
700a08be: 2001         	movs	r0, #0x1
;     timerParams.enableOverflowInt = 1;
700a08c0: 9014         	str	r0, [sp, #0x50]
;     TimerP_setup(gClockCtrl.timerBaseAddr, &timerParams);
700a08c2: f245 1010    	movw	r0, #0x5110
700a08c6: f2c7 0008    	movt	r0, #0x7008
700a08ca: 9006         	str	r0, [sp, #0x18]
700a08cc: 6ac0         	ldr	r0, [r0, #0x2c]
700a08ce: f7fd f8f7    	bl	0x7009dac0 <TimerP_setup> @ imm = #-0x2e12
700a08d2: 9806         	ldr	r0, [sp, #0x18]
;     gClockCtrl.timerReloadCount = TimerP_getReloadCount(gClockCtrl.timerBaseAddr);
700a08d4: 6ac0         	ldr	r0, [r0, #0x2c]
700a08d6: f00e ff13    	bl	0x700af700 <TimerP_getReloadCount> @ imm = #0xee26
700a08da: 9906         	ldr	r1, [sp, #0x18]
700a08dc: 6308         	str	r0, [r1, #0x30]
700a08de: a80a         	add	r0, sp, #0x28
;     HwiP_Params_init(&timerHwiParams);
700a08e0: 9005         	str	r0, [sp, #0x14]
700a08e2: f00f f9b5    	bl	0x700afc50 <HwiP_Params_init> @ imm = #0xf36a
700a08e6: 9b03         	ldr	r3, [sp, #0xc]
700a08e8: 9a04         	ldr	r2, [sp, #0x10]
700a08ea: 9905         	ldr	r1, [sp, #0x14]
700a08ec: 9806         	ldr	r0, [sp, #0x18]
;     timerHwiParams.intNum = gClockConfig.timerHwiIntNum;
700a08ee: f8d2 c004    	ldr.w	r12, [r2, #0x4]
700a08f2: f8cd c028    	str.w	r12, [sp, #0x28]
;     timerHwiParams.callback = ClockP_timerTickIsr;
700a08f6: f24e 3cd1    	movw	r12, #0xe3d1
700a08fa: f2c7 0c0a    	movt	r12, #0x700a
700a08fe: f8cd c02c    	str.w	r12, [sp, #0x2c]
;     timerHwiParams.isPulse = 0;
700a0902: f88d 3038    	strb.w	r3, [sp, #0x38]
;     timerHwiParams.priority = gClockConfig.intrPriority;
700a0906: 7d12         	ldrb	r2, [r2, #0x14]
700a0908: f88d 2036    	strb.w	r2, [sp, #0x36]
;     (void)HwiP_construct(&gClockCtrl.timerHwiObj, &timerHwiParams);
700a090c: 300c         	adds	r0, #0xc
700a090e: f00f f9b7    	bl	0x700afc80 <HwiP_construct> @ imm = #0xf36e
;     TimerP_start(gClockCtrl.timerBaseAddr);
700a0912: 9806         	ldr	r0, [sp, #0x18]
700a0914: 6ac0         	ldr	r0, [r0, #0x2c]
700a0916: f00e fd6b    	bl	0x700af3f0 <TimerP_start> @ imm = #0xead6
; }
700a091a: b016         	add	sp, #0x58
700a091c: bd80         	pop	{r7, pc}
700a091e: 0000         	movs	r0, r0

700a0920 <Sciclient_rmIrqDeleteRoute>:
; {
700a0920: b580         	push	{r7, lr}
700a0922: b090         	sub	sp, #0x40
700a0924: 900f         	str	r0, [sp, #0x3c]
700a0926: f88d 103b    	strb.w	r1, [sp, #0x3b]
700a092a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a092c: 900d         	str	r0, [sp, #0x34]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a092e: 9002         	str	r0, [sp, #0x8]
;     struct Sciclient_rmIrInst *ir_inst = NULL;
700a0930: 9001         	str	r0, [sp, #0x4]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a0932: f8ad 0032    	strh.w	r0, [sp, #0x32]
700a0936: e7ff         	b	0x700a0938 <Sciclient_rmIrqDeleteRoute+0x18> @ imm = #-0x2
700a0938: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a093c: 9000         	str	r0, [sp]
700a093e: f00f f817    	bl	0x700af970 <Sciclient_rmPsGetPsp> @ imm = #0xf02e
700a0942: 4601         	mov	r1, r0
700a0944: 9800         	ldr	r0, [sp]
700a0946: 4288         	cmp	r0, r1
700a0948: f280 80ac    	bge.w	0x700a0aa4 <Sciclient_rmIrqDeleteRoute+0x184> @ imm = #0x158
700a094c: e7ff         	b	0x700a094e <Sciclient_rmIrqDeleteRoute+0x2e> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a094e: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0952: f00e fbfd    	bl	0x700af150 <Sciclient_rmPsGetIrqNode> @ imm = #0xe7fa
700a0956: 900b         	str	r0, [sp, #0x2c]
;         cur_inp = Sciclient_rmPsGetInp(i);
700a0958: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a095c: f00d f840    	bl	0x700ad9e0 <Sciclient_rmPsGetInp> @ imm = #0xd080
700a0960: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;         cur_outp = Sciclient_rmPsGetOutp(i);
700a0964: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0968: f00d f85a    	bl	0x700ada20 <Sciclient_rmPsGetOutp> @ imm = #0xd0b4
700a096c: f8ad 0028    	strh.w	r0, [sp, #0x28]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a0970: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0974: 2800         	cmp	r0, #0x0
700a0976: d156         	bne	0x700a0a26 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0xac
700a0978: e7ff         	b	0x700a097a <Sciclient_rmIrqDeleteRoute+0x5a> @ imm = #-0x2
700a097a: 980b         	ldr	r0, [sp, #0x2c]
700a097c: 8800         	ldrh	r0, [r0]
700a097e: f00d fe77    	bl	0x700ae670 <Sciclient_rmIaIsIa> @ imm = #0xdcee
700a0982: 2800         	cmp	r0, #0x0
700a0984: d04f         	beq	0x700a0a26 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0x9e
700a0986: e7ff         	b	0x700a0988 <Sciclient_rmIrqDeleteRoute+0x68> @ imm = #-0x2
;             (unmap_vint == true)) {
700a0988: f89d 003b    	ldrb.w	r0, [sp, #0x3b]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a098c: 07c0         	lsls	r0, r0, #0x1f
700a098e: 2800         	cmp	r0, #0x0
700a0990: d049         	beq	0x700a0a26 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0x92
700a0992: e7ff         	b	0x700a0994 <Sciclient_rmIrqDeleteRoute+0x74> @ imm = #-0x2
700a0994: 203c         	movs	r0, #0x3c
700a0996: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a099a: 9005         	str	r0, [sp, #0x14]
;             req.secondary_host = cfg->host;
700a099c: 980f         	ldr	r0, [sp, #0x3c]
700a099e: 7900         	ldrb	r0, [r0, #0x4]
700a09a0: f88d 0027    	strb.w	r0, [sp, #0x27]
;             req.src_id = cfg->s_id;
700a09a4: 980f         	ldr	r0, [sp, #0x3c]
700a09a6: 88c0         	ldrh	r0, [r0, #0x6]
700a09a8: f8ad 0018    	strh.w	r0, [sp, #0x18]
;             req.src_index = cfg->s_idx;
700a09ac: 980f         	ldr	r0, [sp, #0x3c]
700a09ae: 8900         	ldrh	r0, [r0, #0x8]
700a09b0: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             req.ia_id = cfg->s_ia;
700a09b4: 980f         	ldr	r0, [sp, #0x3c]
700a09b6: 8a00         	ldrh	r0, [r0, #0x10]
700a09b8: f8ad 0020    	strh.w	r0, [sp, #0x20]
;             req.vint = cur_outp;
700a09bc: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
700a09c0: f8ad 0022    	strh.w	r0, [sp, #0x22]
;             req.global_event = cur_inp;
700a09c4: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
700a09c8: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             req.vint_status_bit_index = cfg->vint_sb;
700a09cc: 980f         	ldr	r0, [sp, #0x3c]
700a09ce: 7d00         	ldrb	r0, [r0, #0x14]
700a09d0: f88d 0026    	strb.w	r0, [sp, #0x26]
700a09d4: a803         	add	r0, sp, #0xc
700a09d6: f04f 31ff    	mov.w	r1, #0xffffffff
;             r = Sciclient_rmIrqReleaseRaw(&req,
700a09da: f00b ffb1    	bl	0x700ac940 <Sciclient_rmIrqReleaseRaw> @ imm = #0xbf62
700a09de: 900d         	str	r0, [sp, #0x34]
;             if (r == SystemP_SUCCESS) {
700a09e0: 980d         	ldr	r0, [sp, #0x34]
700a09e2: b9f8         	cbnz	r0, 0x700a0a24 <Sciclient_rmIrqDeleteRoute+0x104> @ imm = #0x3e
700a09e4: e7ff         	b	0x700a09e6 <Sciclient_rmIrqDeleteRoute+0xc6> @ imm = #-0x2
;                 ia_inst = Sciclient_rmIaGetInst(cur_n->id);
700a09e6: 980b         	ldr	r0, [sp, #0x2c]
700a09e8: 8800         	ldrh	r0, [r0]
700a09ea: f00b fc81    	bl	0x700ac2f0 <Sciclient_rmIaGetInst> @ imm = #0xb902
700a09ee: 9002         	str	r0, [sp, #0x8]
;                 if (ia_inst != NULL) {
700a09f0: 9802         	ldr	r0, [sp, #0x8]
700a09f2: b1b0         	cbz	r0, 0x700a0a22 <Sciclient_rmIrqDeleteRoute+0x102> @ imm = #0x2c
700a09f4: e7ff         	b	0x700a09f6 <Sciclient_rmIrqDeleteRoute+0xd6> @ imm = #-0x2
;                     ia_inst->vint_usage_count[cur_outp]--;
700a09f6: 9802         	ldr	r0, [sp, #0x8]
700a09f8: 6901         	ldr	r1, [r0, #0x10]
700a09fa: f8bd 2028    	ldrh.w	r2, [sp, #0x28]
700a09fe: 5c88         	ldrb	r0, [r1, r2]
700a0a00: 3801         	subs	r0, #0x1
700a0a02: 5488         	strb	r0, [r1, r2]
;                     if (ia_inst->v0_b0_evt == cur_inp - ia_inst->sevt_offset) {
700a0a04: 9a02         	ldr	r2, [sp, #0x8]
700a0a06: 8a90         	ldrh	r0, [r2, #0x14]
700a0a08: f8bd 102a    	ldrh.w	r1, [sp, #0x2a]
700a0a0c: 8912         	ldrh	r2, [r2, #0x8]
700a0a0e: 1a89         	subs	r1, r1, r2
700a0a10: 4288         	cmp	r0, r1
700a0a12: d105         	bne	0x700a0a20 <Sciclient_rmIrqDeleteRoute+0x100> @ imm = #0xa
700a0a14: e7ff         	b	0x700a0a16 <Sciclient_rmIrqDeleteRoute+0xf6> @ imm = #-0x2
;                         ia_inst->v0_b0_evt = SCICLIENT_RM_IA_GENERIC_EVT_RESETVAL;
700a0a16: 9902         	ldr	r1, [sp, #0x8]
700a0a18: f64f 70ff    	movw	r0, #0xffff
700a0a1c: 8288         	strh	r0, [r1, #0x14]
;                     }
700a0a1e: e7ff         	b	0x700a0a20 <Sciclient_rmIrqDeleteRoute+0x100> @ imm = #-0x2
;                 }
700a0a20: e7ff         	b	0x700a0a22 <Sciclient_rmIrqDeleteRoute+0x102> @ imm = #-0x2
;             }
700a0a22: e7ff         	b	0x700a0a24 <Sciclient_rmIrqDeleteRoute+0x104> @ imm = #-0x2
;         }
700a0a24: e7ff         	b	0x700a0a26 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #-0x2
;         if (i > 0u) {
700a0a26: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0a2a: b3a0         	cbz	r0, 0x700a0a96 <Sciclient_rmIrqDeleteRoute+0x176> @ imm = #0x68
700a0a2c: e7ff         	b	0x700a0a2e <Sciclient_rmIrqDeleteRoute+0x10e> @ imm = #-0x2
700a0a2e: 2003         	movs	r0, #0x3
700a0a30: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_DST_ID_VALID |
700a0a34: 9005         	str	r0, [sp, #0x14]
;             req.secondary_host = cfg->host;
700a0a36: 980f         	ldr	r0, [sp, #0x3c]
700a0a38: 7900         	ldrb	r0, [r0, #0x4]
700a0a3a: f88d 0027    	strb.w	r0, [sp, #0x27]
;             req.src_id = cur_n->id;
700a0a3e: 980b         	ldr	r0, [sp, #0x2c]
700a0a40: 8800         	ldrh	r0, [r0]
700a0a42: f8ad 0018    	strh.w	r0, [sp, #0x18]
;             req.src_index = cur_inp;
700a0a46: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
700a0a4a: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             req.dst_id = cur_n->id;
700a0a4e: 980b         	ldr	r0, [sp, #0x2c]
700a0a50: 8800         	ldrh	r0, [r0]
700a0a52: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.dst_host_irq = cur_outp;
700a0a56: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
700a0a5a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
700a0a5e: a803         	add	r0, sp, #0xc
700a0a60: f04f 31ff    	mov.w	r1, #0xffffffff
;             r = Sciclient_rmIrqReleaseRaw(&req,
700a0a64: f00b ff6c    	bl	0x700ac940 <Sciclient_rmIrqReleaseRaw> @ imm = #0xbed8
700a0a68: 900d         	str	r0, [sp, #0x34]
;             if ((r == SystemP_SUCCESS) && (cur_outp == 0)) {
700a0a6a: 980d         	ldr	r0, [sp, #0x34]
700a0a6c: b990         	cbnz	r0, 0x700a0a94 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #0x24
700a0a6e: e7ff         	b	0x700a0a70 <Sciclient_rmIrqDeleteRoute+0x150> @ imm = #-0x2
700a0a70: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
700a0a74: b970         	cbnz	r0, 0x700a0a94 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #0x1c
700a0a76: e7ff         	b	0x700a0a78 <Sciclient_rmIrqDeleteRoute+0x158> @ imm = #-0x2
;                 ir_inst = Sciclient_rmIrGetInst(cur_n->id);
700a0a78: 980b         	ldr	r0, [sp, #0x2c]
700a0a7a: 8800         	ldrh	r0, [r0]
700a0a7c: f00a ff50    	bl	0x700ab920 <Sciclient_rmIrGetInst> @ imm = #0xaea0
700a0a80: 9001         	str	r0, [sp, #0x4]
;                 if (ir_inst != NULL) {
700a0a82: 9801         	ldr	r0, [sp, #0x4]
700a0a84: b128         	cbz	r0, 0x700a0a92 <Sciclient_rmIrqDeleteRoute+0x172> @ imm = #0xa
700a0a86: e7ff         	b	0x700a0a88 <Sciclient_rmIrqDeleteRoute+0x168> @ imm = #-0x2
;                     ir_inst->inp0_mapping = SCICLIENT_RM_IR_MAPPING_FREE;
700a0a88: 9901         	ldr	r1, [sp, #0x4]
700a0a8a: f64f 70ff    	movw	r0, #0xffff
700a0a8e: 8188         	strh	r0, [r1, #0xc]
;                 }
700a0a90: e7ff         	b	0x700a0a92 <Sciclient_rmIrqDeleteRoute+0x172> @ imm = #-0x2
;             }
700a0a92: e7ff         	b	0x700a0a94 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #-0x2
;         }
700a0a94: e7ff         	b	0x700a0a96 <Sciclient_rmIrqDeleteRoute+0x176> @ imm = #-0x2
;     }
700a0a96: e7ff         	b	0x700a0a98 <Sciclient_rmIrqDeleteRoute+0x178> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a0a98: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0a9c: 3001         	adds	r0, #0x1
700a0a9e: f8ad 0032    	strh.w	r0, [sp, #0x32]
700a0aa2: e749         	b	0x700a0938 <Sciclient_rmIrqDeleteRoute+0x18> @ imm = #-0x16e
;     return r;
700a0aa4: 980d         	ldr	r0, [sp, #0x34]
700a0aa6: b010         	add	sp, #0x40
700a0aa8: bd80         	pop	{r7, pc}
700a0aaa: 0000         	movs	r0, r0
700a0aac: 0000         	movs	r0, r0
700a0aae: 0000         	movs	r0, r0

700a0ab0 <Sciclient_rmProgramInterruptRoute>:
; {
700a0ab0: b580         	push	{r7, lr}
700a0ab2: b08e         	sub	sp, #0x38
700a0ab4: 900d         	str	r0, [sp, #0x34]
700a0ab6: 910c         	str	r1, [sp, #0x30]
700a0ab8: 920b         	str	r2, [sp, #0x2c]
700a0aba: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a0abc: 9001         	str	r0, [sp, #0x4]
700a0abe: 900a         	str	r0, [sp, #0x28]
700a0ac0: f44f 5180    	mov.w	r1, #0x1000
;     uint16_t messageType = TISCI_MSG_RM_IRQ_SET;
700a0ac4: f8ad 1026    	strh.w	r1, [sp, #0x26]
;     memset(&cfg, 0, sizeof(cfg));
700a0ac8: 9008         	str	r0, [sp, #0x20]
700a0aca: 9007         	str	r0, [sp, #0x1c]
700a0acc: 9006         	str	r0, [sp, #0x18]
700a0ace: 9005         	str	r0, [sp, #0x14]
700a0ad0: 9004         	str	r0, [sp, #0x10]
700a0ad2: 9003         	str	r0, [sp, #0xc]
700a0ad4: 9002         	str	r0, [sp, #0x8]
;     if((req == NULL) || (resp == NULL)) {
700a0ad6: 980d         	ldr	r0, [sp, #0x34]
700a0ad8: b118         	cbz	r0, 0x700a0ae2 <Sciclient_rmProgramInterruptRoute+0x32> @ imm = #0x6
700a0ada: e7ff         	b	0x700a0adc <Sciclient_rmProgramInterruptRoute+0x2c> @ imm = #-0x2
700a0adc: 980c         	ldr	r0, [sp, #0x30]
700a0ade: b920         	cbnz	r0, 0x700a0aea <Sciclient_rmProgramInterruptRoute+0x3a> @ imm = #0x8
700a0ae0: e7ff         	b	0x700a0ae2 <Sciclient_rmProgramInterruptRoute+0x32> @ imm = #-0x2
700a0ae2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a0ae6: 900a         	str	r0, [sp, #0x28]
;     }
700a0ae8: e7ff         	b	0x700a0aea <Sciclient_rmProgramInterruptRoute+0x3a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a0aea: 980a         	ldr	r0, [sp, #0x28]
700a0aec: b968         	cbnz	r0, 0x700a0b0a <Sciclient_rmProgramInterruptRoute+0x5a> @ imm = #0x1a
700a0aee: e7ff         	b	0x700a0af0 <Sciclient_rmProgramInterruptRoute+0x40> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a0af0: 980d         	ldr	r0, [sp, #0x34]
700a0af2: 6880         	ldr	r0, [r0, #0x8]
700a0af4: f04f 4100    	mov.w	r1, #0x80000000
700a0af8: f00d ffb2    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0xdf64
;     if (r == SystemP_SUCCESS &&
700a0afc: b128         	cbz	r0, 0x700a0b0a <Sciclient_rmProgramInterruptRoute+0x5a> @ imm = #0xa
700a0afe: e7ff         	b	0x700a0b00 <Sciclient_rmProgramInterruptRoute+0x50> @ imm = #-0x2
;         dst_host = req->secondary_host;
700a0b00: 980d         	ldr	r0, [sp, #0x34]
700a0b02: 7ec0         	ldrb	r0, [r0, #0x1b]
700a0b04: f88d 0025    	strb.w	r0, [sp, #0x25]
;     } else {
700a0b08: e00f         	b	0x700a0b2a <Sciclient_rmProgramInterruptRoute+0x7a> @ imm = #0x1e
;         dst_host = (uint8_t) gSciclientMap[Sciclient_getCurrentContext(messageType)].hostId;
700a0b0a: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
700a0b0e: f006 ff2f    	bl	0x700a7970 <Sciclient_getCurrentContext> @ imm = #0x6e5e
700a0b12: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a0b16: f241 0060    	movw	r0, #0x1060
700a0b1a: f2c7 000b    	movt	r0, #0x700b
700a0b1e: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a0b22: 6840         	ldr	r0, [r0, #0x4]
700a0b24: f88d 0025    	strb.w	r0, [sp, #0x25]
700a0b28: e7ff         	b	0x700a0b2a <Sciclient_rmProgramInterruptRoute+0x7a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a0b2a: 980a         	ldr	r0, [sp, #0x28]
700a0b2c: b960         	cbnz	r0, 0x700a0b48 <Sciclient_rmProgramInterruptRoute+0x98> @ imm = #0x18
700a0b2e: e7ff         	b	0x700a0b30 <Sciclient_rmProgramInterruptRoute+0x80> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a0b30: 980d         	ldr	r0, [sp, #0x34]
700a0b32: 6880         	ldr	r0, [r0, #0x8]
700a0b34: 2104         	movs	r1, #0x4
700a0b36: f00d ff93    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0xdf26
;     if (r == SystemP_SUCCESS &&
700a0b3a: b128         	cbz	r0, 0x700a0b48 <Sciclient_rmProgramInterruptRoute+0x98> @ imm = #0xa
700a0b3c: e7ff         	b	0x700a0b3e <Sciclient_rmProgramInterruptRoute+0x8e> @ imm = #-0x2
;         cfg.s_ia = req->ia_id;
700a0b3e: 980d         	ldr	r0, [sp, #0x34]
700a0b40: 8a80         	ldrh	r0, [r0, #0x14]
700a0b42: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     } else {
700a0b46: e003         	b	0x700a0b50 <Sciclient_rmProgramInterruptRoute+0xa0> @ imm = #0x6
700a0b48: 20ff         	movs	r0, #0xff
;         cfg.s_ia = SCICLIENT_RM_DEV_NONE;
700a0b4a: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a0b4e: e7ff         	b	0x700a0b50 <Sciclient_rmProgramInterruptRoute+0xa0> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a0b50: 980a         	ldr	r0, [sp, #0x28]
700a0b52: 2800         	cmp	r0, #0x0
700a0b54: d16e         	bne	0x700a0c34 <Sciclient_rmProgramInterruptRoute+0x184> @ imm = #0xdc
700a0b56: e7ff         	b	0x700a0b58 <Sciclient_rmProgramInterruptRoute+0xa8> @ imm = #-0x2
;         cfg.valid_params = req->valid_params;
700a0b58: 980d         	ldr	r0, [sp, #0x34]
700a0b5a: 6880         	ldr	r0, [r0, #0x8]
700a0b5c: 9002         	str	r0, [sp, #0x8]
;         cfg.host = dst_host;
700a0b5e: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a0b62: f88d 000c    	strb.w	r0, [sp, #0xc]
;         cfg.s_id = req->src_id;
700a0b66: 980d         	ldr	r0, [sp, #0x34]
700a0b68: 8980         	ldrh	r0, [r0, #0xc]
700a0b6a: f8ad 000e    	strh.w	r0, [sp, #0xe]
;         cfg.s_idx = req->src_index;
700a0b6e: 980d         	ldr	r0, [sp, #0x34]
700a0b70: 89c0         	ldrh	r0, [r0, #0xe]
700a0b72: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         cfg.d_id = req->dst_id;
700a0b76: 980d         	ldr	r0, [sp, #0x34]
700a0b78: 8a00         	ldrh	r0, [r0, #0x10]
700a0b7a: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         cfg.d_irq = req->dst_host_irq;
700a0b7e: 980d         	ldr	r0, [sp, #0x34]
700a0b80: 8a40         	ldrh	r0, [r0, #0x12]
700a0b82: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         cfg.global_evt = req->global_event;
700a0b86: 980d         	ldr	r0, [sp, #0x34]
700a0b88: 8b00         	ldrh	r0, [r0, #0x18]
700a0b8a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         cfg.vint = req->vint;
700a0b8e: 980d         	ldr	r0, [sp, #0x34]
700a0b90: 8ac0         	ldrh	r0, [r0, #0x16]
700a0b92: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         cfg.vint_sb = req->vint_status_bit_index;
700a0b96: 980d         	ldr	r0, [sp, #0x34]
700a0b98: 7e80         	ldrb	r0, [r0, #0x1a]
700a0b9a: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         cfg.set_resp = resp;
700a0b9e: 980c         	ldr	r0, [sp, #0x30]
700a0ba0: 9008         	str	r0, [sp, #0x20]
;         if (Sciclient_rmIrqCfgIsDirectNonEvent(cfg.valid_params) == true) {
700a0ba2: 9802         	ldr	r0, [sp, #0x8]
700a0ba4: f00a fd6c    	bl	0x700ab680 <Sciclient_rmIrqCfgIsDirectNonEvent> @ imm = #0xaad8
700a0ba8: b1c8         	cbz	r0, 0x700a0bde <Sciclient_rmProgramInterruptRoute+0x12e> @ imm = #0x32
700a0baa: e7ff         	b	0x700a0bac <Sciclient_rmProgramInterruptRoute+0xfc> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cfg.s_id) == true) {
700a0bac: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a0bb0: f00d fd5e    	bl	0x700ae670 <Sciclient_rmIaIsIa> @ imm = #0xdabc
700a0bb4: b128         	cbz	r0, 0x700a0bc2 <Sciclient_rmProgramInterruptRoute+0x112> @ imm = #0xa
700a0bb6: e7ff         	b	0x700a0bb8 <Sciclient_rmProgramInterruptRoute+0x108> @ imm = #-0x2
;                 cfg.vint = cfg.s_idx;
700a0bb8: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a0bbc: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             }
700a0bc0: e7ff         	b	0x700a0bc2 <Sciclient_rmProgramInterruptRoute+0x112> @ imm = #-0x2
700a0bc2: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqFindRoute(&cfg);
700a0bc4: f7fd f9ec    	bl	0x7009dfa0 <Sciclient_rmIrqFindRoute> @ imm = #-0x2c28
700a0bc8: 900a         	str	r0, [sp, #0x28]
;             if (r == SystemP_SUCCESS) {
700a0bca: 980a         	ldr	r0, [sp, #0x28]
700a0bcc: b930         	cbnz	r0, 0x700a0bdc <Sciclient_rmProgramInterruptRoute+0x12c> @ imm = #0xc
700a0bce: e7ff         	b	0x700a0bd0 <Sciclient_rmProgramInterruptRoute+0x120> @ imm = #-0x2
700a0bd0: a802         	add	r0, sp, #0x8
700a0bd2: 2100         	movs	r1, #0x0
;                 r = Sciclient_rmIrqProgramRoute(&cfg, false);
700a0bd4: f000 f8fc    	bl	0x700a0dd0 <Sciclient_rmIrqProgramRoute> @ imm = #0x1f8
700a0bd8: 900a         	str	r0, [sp, #0x28]
;             }
700a0bda: e7ff         	b	0x700a0bdc <Sciclient_rmProgramInterruptRoute+0x12c> @ imm = #-0x2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a0bdc: e029         	b	0x700a0c32 <Sciclient_rmProgramInterruptRoute+0x182> @ imm = #0x52
700a0bde: 9802         	ldr	r0, [sp, #0x8]
700a0be0: f00a fd16    	bl	0x700ab610 <Sciclient_rmIrqCfgIsDirectEvent> @ imm = #0xaa2c
;                 true) ||
700a0be4: b928         	cbnz	r0, 0x700a0bf2 <Sciclient_rmProgramInterruptRoute+0x142> @ imm = #0xa
700a0be6: e7ff         	b	0x700a0be8 <Sciclient_rmProgramInterruptRoute+0x138> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg.valid_params) ==
700a0be8: 9802         	ldr	r0, [sp, #0x8]
700a0bea: f00a fd81    	bl	0x700ab6f0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0xab02
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a0bee: b128         	cbz	r0, 0x700a0bfc <Sciclient_rmProgramInterruptRoute+0x14c> @ imm = #0xa
700a0bf0: e7ff         	b	0x700a0bf2 <Sciclient_rmProgramInterruptRoute+0x142> @ imm = #-0x2
700a0bf2: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqVintAdd(&cfg);
700a0bf4: f003 fc7c    	bl	0x700a44f0 <Sciclient_rmIrqVintAdd> @ imm = #0x38f8
700a0bf8: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsUnmappedVintDirectEvent(cfg.valid_params) ==
700a0bfa: e019         	b	0x700a0c30 <Sciclient_rmProgramInterruptRoute+0x180> @ imm = #0x32
700a0bfc: 9802         	ldr	r0, [sp, #0x8]
700a0bfe: f00a fde7    	bl	0x700ab7d0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent> @ imm = #0xabce
700a0c02: b128         	cbz	r0, 0x700a0c10 <Sciclient_rmProgramInterruptRoute+0x160> @ imm = #0xa
700a0c04: e7ff         	b	0x700a0c06 <Sciclient_rmProgramInterruptRoute+0x156> @ imm = #-0x2
700a0c06: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmUnmappedVintRouteCreate(&cfg);
700a0c08: f00b ffba    	bl	0x700acb80 <Sciclient_rmUnmappedVintRouteCreate> @ imm = #0xbf74
700a0c0c: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsOesOnly(cfg.valid_params) == true) {
700a0c0e: e00e         	b	0x700a0c2e <Sciclient_rmProgramInterruptRoute+0x17e> @ imm = #0x1c
700a0c10: 9802         	ldr	r0, [sp, #0x8]
700a0c12: f00a fda5    	bl	0x700ab760 <Sciclient_rmIrqCfgIsOesOnly> @ imm = #0xab4a
700a0c16: b128         	cbz	r0, 0x700a0c24 <Sciclient_rmProgramInterruptRoute+0x174> @ imm = #0xa
700a0c18: e7ff         	b	0x700a0c1a <Sciclient_rmProgramInterruptRoute+0x16a> @ imm = #-0x2
700a0c1a: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqProgramOesRegister(&cfg);
700a0c1c: f00c fea0    	bl	0x700ad960 <Sciclient_rmIrqProgramOesRegister> @ imm = #0xcd40
700a0c20: 900a         	str	r0, [sp, #0x28]
;         } else {
700a0c22: e003         	b	0x700a0c2c <Sciclient_rmProgramInterruptRoute+0x17c> @ imm = #0x6
700a0c24: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a0c28: 900a         	str	r0, [sp, #0x28]
700a0c2a: e7ff         	b	0x700a0c2c <Sciclient_rmProgramInterruptRoute+0x17c> @ imm = #-0x2
700a0c2c: e7ff         	b	0x700a0c2e <Sciclient_rmProgramInterruptRoute+0x17e> @ imm = #-0x2
700a0c2e: e7ff         	b	0x700a0c30 <Sciclient_rmProgramInterruptRoute+0x180> @ imm = #-0x2
700a0c30: e7ff         	b	0x700a0c32 <Sciclient_rmProgramInterruptRoute+0x182> @ imm = #-0x2
;     }
700a0c32: e7ff         	b	0x700a0c34 <Sciclient_rmProgramInterruptRoute+0x184> @ imm = #-0x2
;     return r;
700a0c34: 980a         	ldr	r0, [sp, #0x28]
700a0c36: b00e         	add	sp, #0x38
700a0c38: bd80         	pop	{r7, pc}
700a0c3a: 0000         	movs	r0, r0
700a0c3c: 0000         	movs	r0, r0
700a0c3e: 0000         	movs	r0, r0

700a0c40 <PMU_init>:
; int32_t PMU_init(PMU_Config *cfg) {
700a0c40: b580         	push	{r7, lr}
700a0c42: b08a         	sub	sp, #0x28
700a0c44: 9009         	str	r0, [sp, #0x24]
;   memset((void *)&gProfileObject, 0U, sizeof(gProfileObject));
700a0c46: f243 0080    	movw	r0, #0x3080
700a0c4a: f2c7 0008    	movt	r0, #0x7008
700a0c4e: 9003         	str	r0, [sp, #0xc]
700a0c50: f640 510c    	movw	r1, #0xd0c
700a0c54: f7fa ea1e    	blx	0x7009b094 <__aeabi_memclr8> @ imm = #-0x5bc4
700a0c58: 9a03         	ldr	r2, [sp, #0xc]
700a0c5a: 2000         	movs	r0, #0x0
;   gProfileObject.logIndex = 0U;
700a0c5c: 9004         	str	r0, [sp, #0x10]
700a0c5e: 6010         	str	r0, [r2]
;   gProfileObject.bCycleCounter = cfg->bCycleCounter;
700a0c60: 9909         	ldr	r1, [sp, #0x24]
700a0c62: 6809         	ldr	r1, [r1]
700a0c64: 6051         	str	r1, [r2, #0x4]
;   DebugP_assert(cfg->numEventCounters <= 3U);
700a0c66: 9909         	ldr	r1, [sp, #0x24]
700a0c68: 6849         	ldr	r1, [r1, #0x4]
700a0c6a: 2904         	cmp	r1, #0x4
700a0c6c: bf38         	it	lo
700a0c6e: 2001         	movlo	r0, #0x1
700a0c70: f641 21c1    	movw	r1, #0x1ac1
700a0c74: f2c7 010b    	movt	r1, #0x700b
700a0c78: 466a         	mov	r2, sp
700a0c7a: 6011         	str	r1, [r2]
700a0c7c: f641 612a    	movw	r1, #0x1e2a
700a0c80: f2c7 010b    	movt	r1, #0x700b
700a0c84: f641 6234    	movw	r2, #0x1e34
700a0c88: f2c7 020b    	movt	r2, #0x700b
700a0c8c: 236e         	movs	r3, #0x6e
700a0c8e: f009 fecf    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x9d9e
700a0c92: 9a03         	ldr	r2, [sp, #0xc]
700a0c94: 9804         	ldr	r0, [sp, #0x10]
;   gProfileObject.numEvents = cfg->numEventCounters;
700a0c96: 9909         	ldr	r1, [sp, #0x24]
700a0c98: 6849         	ldr	r1, [r1, #0x4]
700a0c9a: 6091         	str	r1, [r2, #0x8]
;   for (i = 0; i < PMU_MAX_LOG_ENTRIES; i++) {
700a0c9c: 9008         	str	r0, [sp, #0x20]
700a0c9e: e7ff         	b	0x700a0ca0 <PMU_init+0x60> @ imm = #-0x2
700a0ca0: 9808         	ldr	r0, [sp, #0x20]
700a0ca2: 283f         	cmp	r0, #0x3f
700a0ca4: d833         	bhi	0x700a0d0e <PMU_init+0xce> @ imm = #0x66
700a0ca6: e7ff         	b	0x700a0ca8 <PMU_init+0x68> @ imm = #-0x2
;     PMU_ProfilePoint *p = &gProfileObject.point[i];
700a0ca8: 9808         	ldr	r0, [sp, #0x20]
700a0caa: f243 0280    	movw	r2, #0x3080
700a0cae: f2c7 0208    	movt	r2, #0x7008
700a0cb2: 2134         	movs	r1, #0x34
700a0cb4: fb00 2001    	mla	r0, r0, r1, r2
700a0cb8: 300c         	adds	r0, #0xc
700a0cba: 9006         	str	r0, [sp, #0x18]
700a0cbc: 2000         	movs	r0, #0x0
;     for (j = 0; j < cfg->numEventCounters; j++) {
700a0cbe: 9007         	str	r0, [sp, #0x1c]
700a0cc0: e7ff         	b	0x700a0cc2 <PMU_init+0x82> @ imm = #-0x2
700a0cc2: 9807         	ldr	r0, [sp, #0x1c]
700a0cc4: 9909         	ldr	r1, [sp, #0x24]
700a0cc6: 6849         	ldr	r1, [r1, #0x4]
700a0cc8: 4288         	cmp	r0, r1
700a0cca: d21b         	bhs	0x700a0d04 <PMU_init+0xc4> @ imm = #0x36
700a0ccc: e7ff         	b	0x700a0cce <PMU_init+0x8e> @ imm = #-0x2
;       p->events[j].name = cfg->eventCounters[j].name;
700a0cce: 9809         	ldr	r0, [sp, #0x24]
700a0cd0: 6880         	ldr	r0, [r0, #0x8]
700a0cd2: 9a07         	ldr	r2, [sp, #0x1c]
700a0cd4: eb00 00c2    	add.w	r0, r0, r2, lsl #3
700a0cd8: 6840         	ldr	r0, [r0, #0x4]
700a0cda: 9906         	ldr	r1, [sp, #0x18]
700a0cdc: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a0ce0: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;       p->events[j].type = cfg->eventCounters[j].type;
700a0ce4: 9809         	ldr	r0, [sp, #0x24]
700a0ce6: 6880         	ldr	r0, [r0, #0x8]
700a0ce8: 9a07         	ldr	r2, [sp, #0x1c]
700a0cea: f850 0032    	ldr.w	r0, [r0, r2, lsl #3]
700a0cee: 9906         	ldr	r1, [sp, #0x18]
700a0cf0: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a0cf4: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0cf8: 6048         	str	r0, [r1, #0x4]
;     }
700a0cfa: e7ff         	b	0x700a0cfc <PMU_init+0xbc> @ imm = #-0x2
;     for (j = 0; j < cfg->numEventCounters; j++) {
700a0cfc: 9807         	ldr	r0, [sp, #0x1c]
700a0cfe: 3001         	adds	r0, #0x1
700a0d00: 9007         	str	r0, [sp, #0x1c]
700a0d02: e7de         	b	0x700a0cc2 <PMU_init+0x82> @ imm = #-0x44
;   }
700a0d04: e7ff         	b	0x700a0d06 <PMU_init+0xc6> @ imm = #-0x2
;   for (i = 0; i < PMU_MAX_LOG_ENTRIES; i++) {
700a0d06: 9808         	ldr	r0, [sp, #0x20]
700a0d08: 3001         	adds	r0, #0x1
700a0d0a: 9008         	str	r0, [sp, #0x20]
700a0d0c: e7c8         	b	0x700a0ca0 <PMU_init+0x60> @ imm = #-0x70
;   int32_t numCount = CSL_armR5PmuGetNumCntrs();
700a0d0e: f001 e946    	blx	0x700a1f9c <CSL_armR5PmuGetNumCntrs> @ imm = #0x128c
700a0d12: 9005         	str	r0, [sp, #0x14]
;   DebugP_assert(numCount == cfg->numEventCounters);
700a0d14: 9805         	ldr	r0, [sp, #0x14]
700a0d16: 9909         	ldr	r1, [sp, #0x24]
700a0d18: 6849         	ldr	r1, [r1, #0x4]
700a0d1a: 1a40         	subs	r0, r0, r1
700a0d1c: fab0 f080    	clz	r0, r0
700a0d20: 0940         	lsrs	r0, r0, #0x5
700a0d22: f641 01ff    	movw	r1, #0x18ff
700a0d26: f2c7 010b    	movt	r1, #0x700b
700a0d2a: 466a         	mov	r2, sp
700a0d2c: 6011         	str	r1, [r2]
700a0d2e: f641 612a    	movw	r1, #0x1e2a
700a0d32: f2c7 010b    	movt	r1, #0x700b
700a0d36: f641 6234    	movw	r2, #0x1e34
700a0d3a: f2c7 020b    	movt	r2, #0x700b
700a0d3e: 237d         	movs	r3, #0x7d
700a0d40: f009 fe76    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x9cec
700a0d44: 2100         	movs	r1, #0x0
700a0d46: 9102         	str	r1, [sp, #0x8]
700a0d48: 2201         	movs	r2, #0x1
;   CSL_armR5PmuCfg(0, 0, 1);
700a0d4a: 4608         	mov	r0, r1
700a0d4c: f001 e8f8    	blx	0x700a1f40 <CSL_armR5PmuCfg> @ imm = #0x11f0
700a0d50: 9802         	ldr	r0, [sp, #0x8]
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0d52: 9008         	str	r0, [sp, #0x20]
700a0d54: e7ff         	b	0x700a0d56 <PMU_init+0x116> @ imm = #-0x2
700a0d56: 9808         	ldr	r0, [sp, #0x20]
700a0d58: 9909         	ldr	r1, [sp, #0x24]
700a0d5a: 6849         	ldr	r1, [r1, #0x4]
700a0d5c: 4288         	cmp	r0, r1
700a0d5e: d20c         	bhs	0x700a0d7a <PMU_init+0x13a> @ imm = #0x18
700a0d60: e7ff         	b	0x700a0d62 <PMU_init+0x122> @ imm = #-0x2
;     CSL_armR5PmuCfgCntr(i, (cfg->eventCounters[i].type & 0xFF));
700a0d62: 9808         	ldr	r0, [sp, #0x20]
700a0d64: 9909         	ldr	r1, [sp, #0x24]
700a0d66: 6889         	ldr	r1, [r1, #0x8]
700a0d68: f811 1030    	ldrb.w	r1, [r1, r0, lsl #3]
700a0d6c: f001 e91e    	blx	0x700a1fac <CSL_armR5PmuCfgCntr> @ imm = #0x123c
;   }
700a0d70: e7ff         	b	0x700a0d72 <PMU_init+0x132> @ imm = #-0x2
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0d72: 9808         	ldr	r0, [sp, #0x20]
700a0d74: 3001         	adds	r0, #0x1
700a0d76: 9008         	str	r0, [sp, #0x20]
700a0d78: e7ed         	b	0x700a0d56 <PMU_init+0x116> @ imm = #-0x26
700a0d7a: 2000         	movs	r0, #0x0
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0d7c: 9008         	str	r0, [sp, #0x20]
700a0d7e: e7ff         	b	0x700a0d80 <PMU_init+0x140> @ imm = #-0x2
700a0d80: 9808         	ldr	r0, [sp, #0x20]
700a0d82: 9909         	ldr	r1, [sp, #0x24]
700a0d84: 6849         	ldr	r1, [r1, #0x4]
700a0d86: 4288         	cmp	r0, r1
700a0d88: d209         	bhs	0x700a0d9e <PMU_init+0x15e> @ imm = #0x12
700a0d8a: e7ff         	b	0x700a0d8c <PMU_init+0x14c> @ imm = #-0x2
;     CSL_armR5PmuEnableCntrOverflowIntr(i, 0);
700a0d8c: 9808         	ldr	r0, [sp, #0x20]
700a0d8e: 2100         	movs	r1, #0x0
700a0d90: f001 e918    	blx	0x700a1fc4 <CSL_armR5PmuEnableCntrOverflowIntr> @ imm = #0x1230
;   }
700a0d94: e7ff         	b	0x700a0d96 <PMU_init+0x156> @ imm = #-0x2
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0d96: 9808         	ldr	r0, [sp, #0x20]
700a0d98: 3001         	adds	r0, #0x1
700a0d9a: 9008         	str	r0, [sp, #0x20]
700a0d9c: e7f0         	b	0x700a0d80 <PMU_init+0x140> @ imm = #-0x20
;   if (cfg->bCycleCounter == TRUE) {
700a0d9e: 9809         	ldr	r0, [sp, #0x24]
700a0da0: 6800         	ldr	r0, [r0]
700a0da2: 2801         	cmp	r0, #0x1
700a0da4: d105         	bne	0x700a0db2 <PMU_init+0x172> @ imm = #0xa
700a0da6: e7ff         	b	0x700a0da8 <PMU_init+0x168> @ imm = #-0x2
700a0da8: 201f         	movs	r0, #0x1f
700a0daa: 2100         	movs	r1, #0x0
;     CSL_armR5PmuEnableCntrOverflowIntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM, 0);
700a0dac: f001 e90a    	blx	0x700a1fc4 <CSL_armR5PmuEnableCntrOverflowIntr> @ imm = #0x1214
;   }
700a0db0: e7ff         	b	0x700a0db2 <PMU_init+0x172> @ imm = #-0x2
;   CSL_armR5PmuResetCntrs();
700a0db2: f001 e960    	blx	0x700a2074 <CSL_armR5PmuResetCntrs> @ imm = #0x12c0
;   CSL_armR5PmuResetCycleCnt();
700a0db6: f001 e956    	blx	0x700a2064 <CSL_armR5PmuResetCycleCnt> @ imm = #0x12ac
;   PMU_enableAllCounters(cfg->numEventCounters);
700a0dba: 9809         	ldr	r0, [sp, #0x24]
700a0dbc: 6840         	ldr	r0, [r0, #0x4]
700a0dbe: f00d f8af    	bl	0x700adf20 <PMU_enableAllCounters> @ imm = #0xd15e
700a0dc2: 2000         	movs	r0, #0x0
;   return SystemP_SUCCESS;
700a0dc4: b00a         	add	sp, #0x28
700a0dc6: bd80         	pop	{r7, pc}
		...

700a0dd0 <Sciclient_rmIrqProgramRoute>:
; {
700a0dd0: b580         	push	{r7, lr}
700a0dd2: b092         	sub	sp, #0x48
700a0dd4: 9011         	str	r0, [sp, #0x44]
700a0dd6: f88d 1043    	strb.w	r1, [sp, #0x43]
700a0dda: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a0ddc: 900f         	str	r0, [sp, #0x3c]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a0dde: 9003         	str	r0, [sp, #0xc]
;     struct Sciclient_rmIrInst *ir_inst = NULL;
700a0de0: 9002         	str	r0, [sp, #0x8]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a0de2: f8ad 003a    	strh.w	r0, [sp, #0x3a]
700a0de6: e7ff         	b	0x700a0de8 <Sciclient_rmIrqProgramRoute+0x18> @ imm = #-0x2
700a0de8: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0dec: 9001         	str	r0, [sp, #0x4]
700a0dee: f00e fdbf    	bl	0x700af970 <Sciclient_rmPsGetPsp> @ imm = #0xeb7e
700a0df2: 4601         	mov	r1, r0
700a0df4: 9801         	ldr	r0, [sp, #0x4]
700a0df6: 4288         	cmp	r0, r1
700a0df8: f280 80aa    	bge.w	0x700a0f50 <Sciclient_rmIrqProgramRoute+0x180> @ imm = #0x154
700a0dfc: e7ff         	b	0x700a0dfe <Sciclient_rmIrqProgramRoute+0x2e> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a0dfe: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0e02: f00e f9a5    	bl	0x700af150 <Sciclient_rmPsGetIrqNode> @ imm = #0xe34a
700a0e06: 900d         	str	r0, [sp, #0x34]
;         cur_inp = Sciclient_rmPsGetInp(i);
700a0e08: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0e0c: f00c fde8    	bl	0x700ad9e0 <Sciclient_rmPsGetInp> @ imm = #0xcbd0
700a0e10: 900c         	str	r0, [sp, #0x30]
;         cur_outp = Sciclient_rmPsGetOutp(i);
700a0e12: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0e16: f00c fe03    	bl	0x700ada20 <Sciclient_rmPsGetOutp> @ imm = #0xcc06
700a0e1a: 900b         	str	r0, [sp, #0x2c]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a0e1c: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0e20: 2800         	cmp	r0, #0x0
700a0e22: d154         	bne	0x700a0ece <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0xa8
700a0e24: e7ff         	b	0x700a0e26 <Sciclient_rmIrqProgramRoute+0x56> @ imm = #-0x2
700a0e26: 980d         	ldr	r0, [sp, #0x34]
700a0e28: 8800         	ldrh	r0, [r0]
700a0e2a: f00d fc21    	bl	0x700ae670 <Sciclient_rmIaIsIa> @ imm = #0xd842
700a0e2e: 2800         	cmp	r0, #0x0
700a0e30: d04d         	beq	0x700a0ece <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0x9a
700a0e32: e7ff         	b	0x700a0e34 <Sciclient_rmIrqProgramRoute+0x64> @ imm = #-0x2
;             (map_vint == true)) {
700a0e34: f89d 0043    	ldrb.w	r0, [sp, #0x43]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a0e38: 07c0         	lsls	r0, r0, #0x1f
700a0e3a: 2800         	cmp	r0, #0x0
700a0e3c: d047         	beq	0x700a0ece <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0x8e
700a0e3e: e7ff         	b	0x700a0e40 <Sciclient_rmIrqProgramRoute+0x70> @ imm = #-0x2
700a0e40: 203c         	movs	r0, #0x3c
700a0e42: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a0e46: 9006         	str	r0, [sp, #0x18]
;             req.secondary_host = cfg->host;
700a0e48: 9811         	ldr	r0, [sp, #0x44]
700a0e4a: 7900         	ldrb	r0, [r0, #0x4]
700a0e4c: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             req.src_id = cfg->s_id;
700a0e50: 9811         	ldr	r0, [sp, #0x44]
700a0e52: 88c0         	ldrh	r0, [r0, #0x6]
700a0e54: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.src_index = cfg->s_idx;
700a0e58: 9811         	ldr	r0, [sp, #0x44]
700a0e5a: 8900         	ldrh	r0, [r0, #0x8]
700a0e5c: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             req.ia_id = cfg->s_ia;
700a0e60: 9811         	ldr	r0, [sp, #0x44]
700a0e62: 8a00         	ldrh	r0, [r0, #0x10]
700a0e64: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             req.vint = cur_outp;
700a0e68: 980b         	ldr	r0, [sp, #0x2c]
700a0e6a: f8ad 0026    	strh.w	r0, [sp, #0x26]
;             req.global_event = cur_inp;
700a0e6e: 980c         	ldr	r0, [sp, #0x30]
700a0e70: f8ad 0028    	strh.w	r0, [sp, #0x28]
;             req.vint_status_bit_index = cfg->vint_sb;
700a0e74: 9811         	ldr	r0, [sp, #0x44]
700a0e76: 7d00         	ldrb	r0, [r0, #0x14]
700a0e78: f88d 002a    	strb.w	r0, [sp, #0x2a]
;                                       cfg->set_resp,
700a0e7c: 9811         	ldr	r0, [sp, #0x44]
700a0e7e: 6981         	ldr	r1, [r0, #0x18]
700a0e80: a804         	add	r0, sp, #0x10
700a0e82: f04f 32ff    	mov.w	r2, #0xffffffff
;             r = Sciclient_rmIrqSetRaw(&req,
700a0e86: f00b fbb3    	bl	0x700ac5f0 <Sciclient_rmIrqSetRaw> @ imm = #0xb766
700a0e8a: 900f         	str	r0, [sp, #0x3c]
;             if (r == SystemP_SUCCESS) {
700a0e8c: 980f         	ldr	r0, [sp, #0x3c]
700a0e8e: b9e8         	cbnz	r0, 0x700a0ecc <Sciclient_rmIrqProgramRoute+0xfc> @ imm = #0x3a
700a0e90: e7ff         	b	0x700a0e92 <Sciclient_rmIrqProgramRoute+0xc2> @ imm = #-0x2
;                 ia_inst = Sciclient_rmIaGetInst(cur_n->id);
700a0e92: 980d         	ldr	r0, [sp, #0x34]
700a0e94: 8800         	ldrh	r0, [r0]
700a0e96: f00b fa2b    	bl	0x700ac2f0 <Sciclient_rmIaGetInst> @ imm = #0xb456
700a0e9a: 9003         	str	r0, [sp, #0xc]
;                 if (ia_inst != NULL) {
700a0e9c: 9803         	ldr	r0, [sp, #0xc]
700a0e9e: b1a0         	cbz	r0, 0x700a0eca <Sciclient_rmIrqProgramRoute+0xfa> @ imm = #0x28
700a0ea0: e7ff         	b	0x700a0ea2 <Sciclient_rmIrqProgramRoute+0xd2> @ imm = #-0x2
;                     ia_inst->vint_usage_count[cur_outp]++;
700a0ea2: 9803         	ldr	r0, [sp, #0xc]
700a0ea4: 6901         	ldr	r1, [r0, #0x10]
700a0ea6: 9a0b         	ldr	r2, [sp, #0x2c]
700a0ea8: 5c88         	ldrb	r0, [r1, r2]
700a0eaa: 3001         	adds	r0, #0x1
700a0eac: 5488         	strb	r0, [r1, r2]
;                     if ((cur_outp == 0) && (cfg->vint_sb == 0)) {
700a0eae: 980b         	ldr	r0, [sp, #0x2c]
700a0eb0: b950         	cbnz	r0, 0x700a0ec8 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #0x14
700a0eb2: e7ff         	b	0x700a0eb4 <Sciclient_rmIrqProgramRoute+0xe4> @ imm = #-0x2
700a0eb4: 9811         	ldr	r0, [sp, #0x44]
700a0eb6: 7d00         	ldrb	r0, [r0, #0x14]
700a0eb8: b930         	cbnz	r0, 0x700a0ec8 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #0xc
700a0eba: e7ff         	b	0x700a0ebc <Sciclient_rmIrqProgramRoute+0xec> @ imm = #-0x2
;                         ia_inst->v0_b0_evt = cur_inp - ia_inst->sevt_offset;
700a0ebc: 980c         	ldr	r0, [sp, #0x30]
700a0ebe: 9903         	ldr	r1, [sp, #0xc]
700a0ec0: 890a         	ldrh	r2, [r1, #0x8]
700a0ec2: 1a80         	subs	r0, r0, r2
700a0ec4: 8288         	strh	r0, [r1, #0x14]
;                     }
700a0ec6: e7ff         	b	0x700a0ec8 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #-0x2
;                 }
700a0ec8: e7ff         	b	0x700a0eca <Sciclient_rmIrqProgramRoute+0xfa> @ imm = #-0x2
;             }
700a0eca: e7ff         	b	0x700a0ecc <Sciclient_rmIrqProgramRoute+0xfc> @ imm = #-0x2
;         }
700a0ecc: e7ff         	b	0x700a0ece <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #-0x2
;         if (i > 0u) {
700a0ece: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0ed2: b390         	cbz	r0, 0x700a0f3a <Sciclient_rmIrqProgramRoute+0x16a> @ imm = #0x64
700a0ed4: e7ff         	b	0x700a0ed6 <Sciclient_rmIrqProgramRoute+0x106> @ imm = #-0x2
700a0ed6: 2003         	movs	r0, #0x3
700a0ed8: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_DST_ID_VALID |
700a0edc: 9006         	str	r0, [sp, #0x18]
;             req.secondary_host = cfg->host;
700a0ede: 9811         	ldr	r0, [sp, #0x44]
700a0ee0: 7900         	ldrb	r0, [r0, #0x4]
700a0ee2: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             req.src_id = cur_n->id;
700a0ee6: 980d         	ldr	r0, [sp, #0x34]
700a0ee8: 8800         	ldrh	r0, [r0]
700a0eea: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.src_index = cur_inp;
700a0eee: 980c         	ldr	r0, [sp, #0x30]
700a0ef0: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             req.dst_id = cur_n->id;
700a0ef4: 980d         	ldr	r0, [sp, #0x34]
700a0ef6: 8800         	ldrh	r0, [r0]
700a0ef8: f8ad 0020    	strh.w	r0, [sp, #0x20]
;             req.dst_host_irq = cur_outp;
700a0efc: 980b         	ldr	r0, [sp, #0x2c]
700a0efe: f8ad 0022    	strh.w	r0, [sp, #0x22]
;                                       cfg->set_resp,
700a0f02: 9811         	ldr	r0, [sp, #0x44]
700a0f04: 6981         	ldr	r1, [r0, #0x18]
700a0f06: a804         	add	r0, sp, #0x10
700a0f08: f04f 32ff    	mov.w	r2, #0xffffffff
;             r = Sciclient_rmIrqSetRaw(&req,
700a0f0c: f00b fb70    	bl	0x700ac5f0 <Sciclient_rmIrqSetRaw> @ imm = #0xb6e0
700a0f10: 900f         	str	r0, [sp, #0x3c]
;             if ((r == SystemP_SUCCESS) && (cur_outp == 0)) {
700a0f12: 980f         	ldr	r0, [sp, #0x3c]
700a0f14: b980         	cbnz	r0, 0x700a0f38 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #0x20
700a0f16: e7ff         	b	0x700a0f18 <Sciclient_rmIrqProgramRoute+0x148> @ imm = #-0x2
700a0f18: 980b         	ldr	r0, [sp, #0x2c]
700a0f1a: b968         	cbnz	r0, 0x700a0f38 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #0x1a
700a0f1c: e7ff         	b	0x700a0f1e <Sciclient_rmIrqProgramRoute+0x14e> @ imm = #-0x2
;                 ir_inst = Sciclient_rmIrGetInst(cur_n->id);
700a0f1e: 980d         	ldr	r0, [sp, #0x34]
700a0f20: 8800         	ldrh	r0, [r0]
700a0f22: f00a fcfd    	bl	0x700ab920 <Sciclient_rmIrGetInst> @ imm = #0xa9fa
700a0f26: 9002         	str	r0, [sp, #0x8]
;                 if (ir_inst != NULL) {
700a0f28: 9802         	ldr	r0, [sp, #0x8]
700a0f2a: b120         	cbz	r0, 0x700a0f36 <Sciclient_rmIrqProgramRoute+0x166> @ imm = #0x8
700a0f2c: e7ff         	b	0x700a0f2e <Sciclient_rmIrqProgramRoute+0x15e> @ imm = #-0x2
;                     ir_inst->inp0_mapping = cur_outp;
700a0f2e: 980b         	ldr	r0, [sp, #0x2c]
700a0f30: 9902         	ldr	r1, [sp, #0x8]
700a0f32: 8188         	strh	r0, [r1, #0xc]
;                 }
700a0f34: e7ff         	b	0x700a0f36 <Sciclient_rmIrqProgramRoute+0x166> @ imm = #-0x2
;             }
700a0f36: e7ff         	b	0x700a0f38 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #-0x2
;         }
700a0f38: e7ff         	b	0x700a0f3a <Sciclient_rmIrqProgramRoute+0x16a> @ imm = #-0x2
;         if (r != SystemP_SUCCESS) {
700a0f3a: 980f         	ldr	r0, [sp, #0x3c]
700a0f3c: b108         	cbz	r0, 0x700a0f42 <Sciclient_rmIrqProgramRoute+0x172> @ imm = #0x2
700a0f3e: e7ff         	b	0x700a0f40 <Sciclient_rmIrqProgramRoute+0x170> @ imm = #-0x2
;             break;
700a0f40: e006         	b	0x700a0f50 <Sciclient_rmIrqProgramRoute+0x180> @ imm = #0xc
;     }
700a0f42: e7ff         	b	0x700a0f44 <Sciclient_rmIrqProgramRoute+0x174> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a0f44: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0f48: 3001         	adds	r0, #0x1
700a0f4a: f8ad 003a    	strh.w	r0, [sp, #0x3a]
700a0f4e: e74b         	b	0x700a0de8 <Sciclient_rmIrqProgramRoute+0x18> @ imm = #-0x16a
;     return r;
700a0f50: 980f         	ldr	r0, [sp, #0x3c]
700a0f52: b012         	add	sp, #0x48
700a0f54: bd80         	pop	{r7, pc}
		...
700a0f5e: 0000         	movs	r0, r0

700a0f60 <Udma_chEnableLocal>:
; {
700a0f60: b580         	push	{r7, lr}
700a0f62: b08e         	sub	sp, #0x38
700a0f64: 900d         	str	r0, [sp, #0x34]
;     drvHandle = chHandle->drvHandle;
700a0f66: 980d         	ldr	r0, [sp, #0x34]
700a0f68: 6e80         	ldr	r0, [r0, #0x68]
700a0f6a: 900b         	str	r0, [sp, #0x2c]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a0f6c: 980b         	ldr	r0, [sp, #0x2c]
700a0f6e: 6800         	ldr	r0, [r0]
700a0f70: 2801         	cmp	r0, #0x1
700a0f72: d163         	bne	0x700a103c <Udma_chEnableLocal+0xdc> @ imm = #0xc6
700a0f74: e7ff         	b	0x700a0f76 <Udma_chEnableLocal+0x16> @ imm = #-0x2
700a0f76: 2001         	movs	r0, #0x1
;         bcdmaRtEnable.enable         = TRUE;
700a0f78: 9005         	str	r0, [sp, #0x14]
700a0f7a: 2000         	movs	r0, #0x0
;         bcdmaRtEnable.teardown       = FALSE;
700a0f7c: 9006         	str	r0, [sp, #0x18]
;         bcdmaRtEnable.forcedTeardown = FALSE;
700a0f7e: 9009         	str	r0, [sp, #0x24]
;         bcdmaRtEnable.pause          = FALSE;
700a0f80: 9007         	str	r0, [sp, #0x1c]
;         bcdmaRtEnable.error          = FALSE;
700a0f82: 9008         	str	r0, [sp, #0x20]
;         if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a0f84: 980d         	ldr	r0, [sp, #0x34]
700a0f86: 7800         	ldrb	r0, [r0]
700a0f88: 0740         	lsls	r0, r0, #0x1d
700a0f8a: 2800         	cmp	r0, #0x0
700a0f8c: d508         	bpl	0x700a0fa0 <Udma_chEnableLocal+0x40> @ imm = #0x10
700a0f8e: e7ff         	b	0x700a0f90 <Udma_chEnableLocal+0x30> @ imm = #-0x2
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum , &bcdmaRtEnable);
700a0f90: 980b         	ldr	r0, [sp, #0x2c]
700a0f92: 3008         	adds	r0, #0x8
700a0f94: 990d         	ldr	r1, [sp, #0x34]
700a0f96: 6ec9         	ldr	r1, [r1, #0x6c]
700a0f98: aa05         	add	r2, sp, #0x14
700a0f9a: f00d fc89    	bl	0x700ae8b0 <CSL_bcdmaSetTxRT> @ imm = #0xd912
;         }
700a0f9e: e04c         	b	0x700a103a <Udma_chEnableLocal+0xda> @ imm = #0x98
;         else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a0fa0: 980d         	ldr	r0, [sp, #0x34]
700a0fa2: 7800         	ldrb	r0, [r0]
700a0fa4: 07c0         	lsls	r0, r0, #0x1f
700a0fa6: b300         	cbz	r0, 0x700a0fea <Udma_chEnableLocal+0x8a> @ imm = #0x40
700a0fa8: e7ff         	b	0x700a0faa <Udma_chEnableLocal+0x4a> @ imm = #-0x2
;             regVal = CSL_REG32_RD(&chHandle->pBcdmaTxRtRegs->PEER8);
700a0faa: 980d         	ldr	r0, [sp, #0x34]
700a0fac: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a0fb0: f500 7008    	add.w	r0, r0, #0x220
700a0fb4: f00e fcc4    	bl	0x700af940 <CSL_REG32_RD_RAW> @ imm = #0xe988
700a0fb8: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a0fba: 980c         	ldr	r0, [sp, #0x30]
700a0fbc: f040 4000    	orr	r0, r0, #0x80000000
700a0fc0: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pBcdmaTxRtRegs->PEER8, regVal);
700a0fc2: 980d         	ldr	r0, [sp, #0x34]
700a0fc4: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a0fc8: f500 7008    	add.w	r0, r0, #0x220
700a0fcc: 990c         	ldr	r1, [sp, #0x30]
700a0fce: f00e fc17    	bl	0x700af800 <CSL_REG32_WR_RAW> @ imm = #0xe82e
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtEnable);
700a0fd2: 9a0b         	ldr	r2, [sp, #0x2c]
700a0fd4: f102 0008    	add.w	r0, r2, #0x8
700a0fd8: 990d         	ldr	r1, [sp, #0x34]
700a0fda: 6ec9         	ldr	r1, [r1, #0x6c]
700a0fdc: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
700a0fe0: 4411         	add	r1, r2
700a0fe2: aa05         	add	r2, sp, #0x14
700a0fe4: f00d fc64    	bl	0x700ae8b0 <CSL_bcdmaSetTxRT> @ imm = #0xd8c8
;         }
700a0fe8: e026         	b	0x700a1038 <Udma_chEnableLocal+0xd8> @ imm = #0x4c
;         else if ((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a0fea: 980d         	ldr	r0, [sp, #0x34]
700a0fec: 7800         	ldrb	r0, [r0]
700a0fee: 0780         	lsls	r0, r0, #0x1e
700a0ff0: 2800         	cmp	r0, #0x0
700a0ff2: d520         	bpl	0x700a1036 <Udma_chEnableLocal+0xd6> @ imm = #0x40
700a0ff4: e7ff         	b	0x700a0ff6 <Udma_chEnableLocal+0x96> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtEnable);
700a0ff6: 9a0b         	ldr	r2, [sp, #0x2c]
700a0ff8: f102 0008    	add.w	r0, r2, #0x8
700a0ffc: 990d         	ldr	r1, [sp, #0x34]
700a0ffe: 6f09         	ldr	r1, [r1, #0x70]
700a1000: f8d2 2114    	ldr.w	r2, [r2, #0x114]
700a1004: 4411         	add	r1, r2
700a1006: aa05         	add	r2, sp, #0x14
;             (void) CSL_bcdmaSetRxRT(
700a1008: f00d fc3a    	bl	0x700ae880 <CSL_bcdmaSetRxRT> @ imm = #0xd874
;             regVal = CSL_REG32_RD(&chHandle->pBcdmaRxRtRegs->PEER8);
700a100c: 980d         	ldr	r0, [sp, #0x34]
700a100e: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a1012: f500 7008    	add.w	r0, r0, #0x220
700a1016: f00e fc93    	bl	0x700af940 <CSL_REG32_RD_RAW> @ imm = #0xe926
700a101a: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a101c: 980c         	ldr	r0, [sp, #0x30]
700a101e: f040 4000    	orr	r0, r0, #0x80000000
700a1022: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pBcdmaRxRtRegs->PEER8, regVal);
700a1024: 980d         	ldr	r0, [sp, #0x34]
700a1026: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a102a: f500 7008    	add.w	r0, r0, #0x220
700a102e: 990c         	ldr	r1, [sp, #0x30]
700a1030: f00e fbe6    	bl	0x700af800 <CSL_REG32_WR_RAW> @ imm = #0xe7cc
;         }
700a1034: e7ff         	b	0x700a1036 <Udma_chEnableLocal+0xd6> @ imm = #-0x2
700a1036: e7ff         	b	0x700a1038 <Udma_chEnableLocal+0xd8> @ imm = #-0x2
700a1038: e7ff         	b	0x700a103a <Udma_chEnableLocal+0xda> @ imm = #-0x2
;     }
700a103a: e050         	b	0x700a10de <Udma_chEnableLocal+0x17e> @ imm = #0xa0
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a103c: 980b         	ldr	r0, [sp, #0x2c]
700a103e: 6800         	ldr	r0, [r0]
700a1040: 2802         	cmp	r0, #0x2
700a1042: d14b         	bne	0x700a10dc <Udma_chEnableLocal+0x17c> @ imm = #0x96
700a1044: e7ff         	b	0x700a1046 <Udma_chEnableLocal+0xe6> @ imm = #-0x2
700a1046: 2001         	movs	r0, #0x1
;         pktdmaRtEnable.enable         = TRUE;
700a1048: 9000         	str	r0, [sp]
700a104a: 2000         	movs	r0, #0x0
;         pktdmaRtEnable.teardown       = FALSE;
700a104c: 9001         	str	r0, [sp, #0x4]
;         pktdmaRtEnable.forcedTeardown = FALSE;
700a104e: 9004         	str	r0, [sp, #0x10]
;         pktdmaRtEnable.pause          = FALSE;
700a1050: 9002         	str	r0, [sp, #0x8]
;         pktdmaRtEnable.error          = FALSE;
700a1052: 9003         	str	r0, [sp, #0xc]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a1054: 980d         	ldr	r0, [sp, #0x34]
700a1056: 7800         	ldrb	r0, [r0]
700a1058: 07c0         	lsls	r0, r0, #0x1f
700a105a: b1e0         	cbz	r0, 0x700a1096 <Udma_chEnableLocal+0x136> @ imm = #0x38
700a105c: e7ff         	b	0x700a105e <Udma_chEnableLocal+0xfe> @ imm = #-0x2
;             regVal = CSL_REG32_RD(&chHandle->pPktdmaTxRtRegs->PEER8);
700a105e: 980d         	ldr	r0, [sp, #0x34]
700a1060: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a1064: f500 7008    	add.w	r0, r0, #0x220
700a1068: f00e fc6a    	bl	0x700af940 <CSL_REG32_RD_RAW> @ imm = #0xe8d4
700a106c: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a106e: 980c         	ldr	r0, [sp, #0x30]
700a1070: f040 4000    	orr	r0, r0, #0x80000000
700a1074: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pPktdmaTxRtRegs->PEER8, regVal);
700a1076: 980d         	ldr	r0, [sp, #0x34]
700a1078: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a107c: f500 7008    	add.w	r0, r0, #0x220
700a1080: 990c         	ldr	r1, [sp, #0x30]
700a1082: f00e fbbd    	bl	0x700af800 <CSL_REG32_WR_RAW> @ imm = #0xe77a
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtEnable);
700a1086: 980b         	ldr	r0, [sp, #0x2c]
700a1088: 3054         	adds	r0, #0x54
700a108a: 990d         	ldr	r1, [sp, #0x34]
700a108c: 6ec9         	ldr	r1, [r1, #0x6c]
700a108e: 466a         	mov	r2, sp
700a1090: f00c fe46    	bl	0x700add20 <CSL_pktdmaSetTxRT> @ imm = #0xcc8c
;         }
700a1094: e7ff         	b	0x700a1096 <Udma_chEnableLocal+0x136> @ imm = #-0x2
;         if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a1096: 980d         	ldr	r0, [sp, #0x34]
700a1098: 7800         	ldrb	r0, [r0]
700a109a: 0780         	lsls	r0, r0, #0x1e
700a109c: 2800         	cmp	r0, #0x0
700a109e: d51c         	bpl	0x700a10da <Udma_chEnableLocal+0x17a> @ imm = #0x38
700a10a0: e7ff         	b	0x700a10a2 <Udma_chEnableLocal+0x142> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtEnable);
700a10a2: 980b         	ldr	r0, [sp, #0x2c]
700a10a4: 3054         	adds	r0, #0x54
700a10a6: 990d         	ldr	r1, [sp, #0x34]
700a10a8: 6f09         	ldr	r1, [r1, #0x70]
700a10aa: 466a         	mov	r2, sp
;             (void) CSL_pktdmaSetRxRT(
700a10ac: f00c fe18    	bl	0x700adce0 <CSL_pktdmaSetRxRT> @ imm = #0xcc30
;             regVal = CSL_REG32_RD(&chHandle->pPktdmaRxRtRegs->PEER8);
700a10b0: 980d         	ldr	r0, [sp, #0x34]
700a10b2: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a10b6: f500 7008    	add.w	r0, r0, #0x220
700a10ba: f00e fc41    	bl	0x700af940 <CSL_REG32_RD_RAW> @ imm = #0xe882
700a10be: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a10c0: 980c         	ldr	r0, [sp, #0x30]
700a10c2: f040 4000    	orr	r0, r0, #0x80000000
700a10c6: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pPktdmaRxRtRegs->PEER8, regVal);
700a10c8: 980d         	ldr	r0, [sp, #0x34]
700a10ca: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a10ce: f500 7008    	add.w	r0, r0, #0x220
700a10d2: 990c         	ldr	r1, [sp, #0x30]
700a10d4: f00e fb94    	bl	0x700af800 <CSL_REG32_WR_RAW> @ imm = #0xe728
;         }
700a10d8: e7ff         	b	0x700a10da <Udma_chEnableLocal+0x17a> @ imm = #-0x2
;     }
700a10da: e7ff         	b	0x700a10dc <Udma_chEnableLocal+0x17c> @ imm = #-0x2
700a10dc: e7ff         	b	0x700a10de <Udma_chEnableLocal+0x17e> @ imm = #-0x2
;     return;
700a10de: b00e         	add	sp, #0x38
700a10e0: bd80         	pop	{r7, pc}
		...
700a10ee: 0000         	movs	r0, r0

700a10f0 <Udma_chConfigPdma>:
; {
700a10f0: b580         	push	{r7, lr}
700a10f2: b08a         	sub	sp, #0x28
700a10f4: 9009         	str	r0, [sp, #0x24]
700a10f6: 9108         	str	r1, [sp, #0x20]
700a10f8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a10fa: 9007         	str	r0, [sp, #0x1c]
;     volatile uint32_t  *PEER8=NULL, *PEER0=NULL, *PEER1=NULL;
700a10fc: 9006         	str	r0, [sp, #0x18]
700a10fe: 9005         	str	r0, [sp, #0x14]
700a1100: 9004         	str	r0, [sp, #0x10]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a1102: 9809         	ldr	r0, [sp, #0x24]
700a1104: 9002         	str	r0, [sp, #0x8]
;     if((NULL_PTR == chHandleInt) ||
700a1106: 9802         	ldr	r0, [sp, #0x8]
700a1108: b1a0         	cbz	r0, 0x700a1134 <Udma_chConfigPdma+0x44> @ imm = #0x28
700a110a: e7ff         	b	0x700a110c <Udma_chConfigPdma+0x1c> @ imm = #-0x2
;        (NULL_PTR == pdmaPrms) ||
700a110c: 9808         	ldr	r0, [sp, #0x20]
700a110e: b188         	cbz	r0, 0x700a1134 <Udma_chConfigPdma+0x44> @ imm = #0x22
700a1110: e7ff         	b	0x700a1112 <Udma_chConfigPdma+0x22> @ imm = #-0x2
;        (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
700a1112: 9802         	ldr	r0, [sp, #0x8]
700a1114: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a1118: f64a 31cd    	movw	r1, #0xabcd
700a111c: f6ca 31dc    	movt	r1, #0xabdc
700a1120: 4288         	cmp	r0, r1
700a1122: d107         	bne	0x700a1134 <Udma_chConfigPdma+0x44> @ imm = #0xe
700a1124: e7ff         	b	0x700a1126 <Udma_chConfigPdma+0x36> @ imm = #-0x2
;        ((chHandleInt->chType & UDMA_CH_FLAG_PDMA) != UDMA_CH_FLAG_PDMA))
700a1126: 9802         	ldr	r0, [sp, #0x8]
700a1128: 6800         	ldr	r0, [r0]
700a112a: f000 0008    	and	r0, r0, #0x8
;     if((NULL_PTR == chHandleInt) ||
700a112e: 2808         	cmp	r0, #0x8
700a1130: d004         	beq	0x700a113c <Udma_chConfigPdma+0x4c> @ imm = #0x8
700a1132: e7ff         	b	0x700a1134 <Udma_chConfigPdma+0x44> @ imm = #-0x2
700a1134: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a1138: 9007         	str	r0, [sp, #0x1c]
;     }
700a113a: e7ff         	b	0x700a113c <Udma_chConfigPdma+0x4c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a113c: 9807         	ldr	r0, [sp, #0x1c]
700a113e: b9a8         	cbnz	r0, 0x700a116c <Udma_chConfigPdma+0x7c> @ imm = #0x2a
700a1140: e7ff         	b	0x700a1142 <Udma_chConfigPdma+0x52> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a1142: 9802         	ldr	r0, [sp, #0x8]
700a1144: 6e80         	ldr	r0, [r0, #0x68]
700a1146: 9003         	str	r0, [sp, #0xc]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a1148: 9803         	ldr	r0, [sp, #0xc]
700a114a: b150         	cbz	r0, 0x700a1162 <Udma_chConfigPdma+0x72> @ imm = #0x14
700a114c: e7ff         	b	0x700a114e <Udma_chConfigPdma+0x5e> @ imm = #-0x2
700a114e: 9803         	ldr	r0, [sp, #0xc]
700a1150: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a1154: f64a 31cd    	movw	r1, #0xabcd
700a1158: f6ca 31dc    	movt	r1, #0xabdc
700a115c: 4288         	cmp	r0, r1
700a115e: d004         	beq	0x700a116a <Udma_chConfigPdma+0x7a> @ imm = #0x8
700a1160: e7ff         	b	0x700a1162 <Udma_chConfigPdma+0x72> @ imm = #-0x2
700a1162: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a1166: 9007         	str	r0, [sp, #0x1c]
;         }
700a1168: e7ff         	b	0x700a116a <Udma_chConfigPdma+0x7a> @ imm = #-0x2
;     }
700a116a: e7ff         	b	0x700a116c <Udma_chConfigPdma+0x7c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a116c: 9807         	ldr	r0, [sp, #0x1c]
700a116e: 2800         	cmp	r0, #0x0
700a1170: d17a         	bne	0x700a1268 <Udma_chConfigPdma+0x178> @ imm = #0xf4
700a1172: e7ff         	b	0x700a1174 <Udma_chConfigPdma+0x84> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a1174: 9803         	ldr	r0, [sp, #0xc]
700a1176: 6800         	ldr	r0, [r0]
700a1178: 2801         	cmp	r0, #0x1
700a117a: d137         	bne	0x700a11ec <Udma_chConfigPdma+0xfc> @ imm = #0x6e
700a117c: e7ff         	b	0x700a117e <Udma_chConfigPdma+0x8e> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a117e: 9802         	ldr	r0, [sp, #0x8]
700a1180: 7800         	ldrb	r0, [r0]
700a1182: 07c0         	lsls	r0, r0, #0x1f
700a1184: b198         	cbz	r0, 0x700a11ae <Udma_chConfigPdma+0xbe> @ imm = #0x26
700a1186: e7ff         	b	0x700a1188 <Udma_chConfigPdma+0x98> @ imm = #-0x2
;                 PEER8 = &chHandleInt->pBcdmaTxRtRegs->PEER8;
700a1188: 9802         	ldr	r0, [sp, #0x8]
700a118a: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a118e: f500 7008    	add.w	r0, r0, #0x220
700a1192: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pBcdmaTxRtRegs->PEER1;
700a1194: 9802         	ldr	r0, [sp, #0x8]
700a1196: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a119a: f500 7001    	add.w	r0, r0, #0x204
700a119e: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pBcdmaTxRtRegs->PEER0;
700a11a0: 9802         	ldr	r0, [sp, #0x8]
700a11a2: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a11a6: f500 7000    	add.w	r0, r0, #0x200
700a11aa: 9005         	str	r0, [sp, #0x14]
;             }
700a11ac: e012         	b	0x700a11d4 <Udma_chConfigPdma+0xe4> @ imm = #0x24
;                 PEER8 = &chHandleInt->pBcdmaRxRtRegs->PEER8;
700a11ae: 9802         	ldr	r0, [sp, #0x8]
700a11b0: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a11b4: f500 7008    	add.w	r0, r0, #0x220
700a11b8: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pBcdmaRxRtRegs->PEER1;
700a11ba: 9802         	ldr	r0, [sp, #0x8]
700a11bc: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a11c0: f500 7001    	add.w	r0, r0, #0x204
700a11c4: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pBcdmaRxRtRegs->PEER0;
700a11c6: 9802         	ldr	r0, [sp, #0x8]
700a11c8: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a11cc: f500 7000    	add.w	r0, r0, #0x200
700a11d0: 9005         	str	r0, [sp, #0x14]
700a11d2: e7ff         	b	0x700a11d4 <Udma_chConfigPdma+0xe4> @ imm = #-0x2
;             Udma_chSetPeerReg(drvHandle, pdmaPrms, PEER8, PEER1, PEER0);
700a11d4: 9803         	ldr	r0, [sp, #0xc]
700a11d6: 9908         	ldr	r1, [sp, #0x20]
700a11d8: 9a06         	ldr	r2, [sp, #0x18]
700a11da: 9b04         	ldr	r3, [sp, #0x10]
700a11dc: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a11e0: 46ee         	mov	lr, sp
700a11e2: f8ce c000    	str.w	r12, [lr]
700a11e6: f00b fc3b    	bl	0x700aca60 <Udma_chSetPeerReg> @ imm = #0xb876
;         }
700a11ea: e03c         	b	0x700a1266 <Udma_chConfigPdma+0x176> @ imm = #0x78
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a11ec: 9803         	ldr	r0, [sp, #0xc]
700a11ee: 6800         	ldr	r0, [r0]
700a11f0: 2802         	cmp	r0, #0x2
700a11f2: d137         	bne	0x700a1264 <Udma_chConfigPdma+0x174> @ imm = #0x6e
700a11f4: e7ff         	b	0x700a11f6 <Udma_chConfigPdma+0x106> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a11f6: 9802         	ldr	r0, [sp, #0x8]
700a11f8: 7800         	ldrb	r0, [r0]
700a11fa: 07c0         	lsls	r0, r0, #0x1f
700a11fc: b198         	cbz	r0, 0x700a1226 <Udma_chConfigPdma+0x136> @ imm = #0x26
700a11fe: e7ff         	b	0x700a1200 <Udma_chConfigPdma+0x110> @ imm = #-0x2
;                 PEER8 = &chHandleInt->pPktdmaTxRtRegs->PEER8;
700a1200: 9802         	ldr	r0, [sp, #0x8]
700a1202: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a1206: f500 7008    	add.w	r0, r0, #0x220
700a120a: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pPktdmaTxRtRegs->PEER1;
700a120c: 9802         	ldr	r0, [sp, #0x8]
700a120e: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a1212: f500 7001    	add.w	r0, r0, #0x204
700a1216: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pPktdmaTxRtRegs->PEER0;
700a1218: 9802         	ldr	r0, [sp, #0x8]
700a121a: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a121e: f500 7000    	add.w	r0, r0, #0x200
700a1222: 9005         	str	r0, [sp, #0x14]
;             }
700a1224: e012         	b	0x700a124c <Udma_chConfigPdma+0x15c> @ imm = #0x24
;                 PEER8 = &chHandleInt->pPktdmaRxRtRegs->PEER8;
700a1226: 9802         	ldr	r0, [sp, #0x8]
700a1228: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a122c: f500 7008    	add.w	r0, r0, #0x220
700a1230: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pPktdmaRxRtRegs->PEER1;
700a1232: 9802         	ldr	r0, [sp, #0x8]
700a1234: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a1238: f500 7001    	add.w	r0, r0, #0x204
700a123c: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pPktdmaRxRtRegs->PEER0;
700a123e: 9802         	ldr	r0, [sp, #0x8]
700a1240: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a1244: f500 7000    	add.w	r0, r0, #0x200
700a1248: 9005         	str	r0, [sp, #0x14]
700a124a: e7ff         	b	0x700a124c <Udma_chConfigPdma+0x15c> @ imm = #-0x2
;             Udma_chSetPeerReg(drvHandle, pdmaPrms, PEER8, PEER1, PEER0);
700a124c: 9803         	ldr	r0, [sp, #0xc]
700a124e: 9908         	ldr	r1, [sp, #0x20]
700a1250: 9a06         	ldr	r2, [sp, #0x18]
700a1252: 9b04         	ldr	r3, [sp, #0x10]
700a1254: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a1258: 46ee         	mov	lr, sp
700a125a: f8ce c000    	str.w	r12, [lr]
700a125e: f00b fbff    	bl	0x700aca60 <Udma_chSetPeerReg> @ imm = #0xb7fe
;         }
700a1262: e7ff         	b	0x700a1264 <Udma_chConfigPdma+0x174> @ imm = #-0x2
700a1264: e7ff         	b	0x700a1266 <Udma_chConfigPdma+0x176> @ imm = #-0x2
;     }
700a1266: e7ff         	b	0x700a1268 <Udma_chConfigPdma+0x178> @ imm = #-0x2
;     return (retVal);
700a1268: 9807         	ldr	r0, [sp, #0x1c]
700a126a: b00a         	add	sp, #0x28
700a126c: bd80         	pop	{r7, pc}
700a126e: 0000         	movs	r0, r0

700a1270 <xQueueSemaphoreTake>:
; {
700a1270: b580         	push	{r7, lr}
700a1272: b08a         	sub	sp, #0x28
700a1274: 9008         	str	r0, [sp, #0x20]
700a1276: 9107         	str	r1, [sp, #0x1c]
700a1278: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
700a127a: 9006         	str	r0, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a127c: 9908         	ldr	r1, [sp, #0x20]
700a127e: 9103         	str	r1, [sp, #0xc]
;         BaseType_t xInheritanceOccurred = pdFALSE;
700a1280: 9002         	str	r0, [sp, #0x8]
;     for( ; ; )
700a1282: e7ff         	b	0x700a1284 <xQueueSemaphoreTake+0x14> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a1284: f00d f924    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0xd248
;             const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
700a1288: 9803         	ldr	r0, [sp, #0xc]
700a128a: 6b80         	ldr	r0, [r0, #0x38]
700a128c: 9001         	str	r0, [sp, #0x4]
;             if( uxSemaphoreCount > ( UBaseType_t ) 0 )
700a128e: 9801         	ldr	r0, [sp, #0x4]
700a1290: b310         	cbz	r0, 0x700a12d8 <xQueueSemaphoreTake+0x68> @ imm = #0x44
700a1292: e7ff         	b	0x700a1294 <xQueueSemaphoreTake+0x24> @ imm = #-0x2
;                 pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
700a1294: 9801         	ldr	r0, [sp, #0x4]
700a1296: 3801         	subs	r0, #0x1
700a1298: 9903         	ldr	r1, [sp, #0xc]
700a129a: 6388         	str	r0, [r1, #0x38]
;                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a129c: 9803         	ldr	r0, [sp, #0xc]
700a129e: 6800         	ldr	r0, [r0]
700a12a0: b928         	cbnz	r0, 0x700a12ae <xQueueSemaphoreTake+0x3e> @ imm = #0xa
700a12a2: e7ff         	b	0x700a12a4 <xQueueSemaphoreTake+0x34> @ imm = #-0x2
;                             pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
700a12a4: f00d fb94    	bl	0x700ae9d0 <pvTaskIncrementMutexHeldCount> @ imm = #0xd728
700a12a8: 9903         	ldr	r1, [sp, #0xc]
700a12aa: 6088         	str	r0, [r1, #0x8]
;                         }
700a12ac: e000         	b	0x700a12b0 <xQueueSemaphoreTake+0x40> @ imm = #0x0
700a12ae: e7ff         	b	0x700a12b0 <xQueueSemaphoreTake+0x40> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a12b0: 9803         	ldr	r0, [sp, #0xc]
700a12b2: 6900         	ldr	r0, [r0, #0x10]
700a12b4: b150         	cbz	r0, 0x700a12cc <xQueueSemaphoreTake+0x5c> @ imm = #0x14
700a12b6: e7ff         	b	0x700a12b8 <xQueueSemaphoreTake+0x48> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a12b8: 9803         	ldr	r0, [sp, #0xc]
700a12ba: 3010         	adds	r0, #0x10
700a12bc: f006 fa98    	bl	0x700a77f0 <xTaskRemoveFromEventList> @ imm = #0x6530
700a12c0: b110         	cbz	r0, 0x700a12c8 <xQueueSemaphoreTake+0x58> @ imm = #0x4
700a12c2: e7ff         	b	0x700a12c4 <xQueueSemaphoreTake+0x54> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
700a12c4: df00         	svc	#0x0
;                     }
700a12c6: e000         	b	0x700a12ca <xQueueSemaphoreTake+0x5a> @ imm = #0x0
700a12c8: e7ff         	b	0x700a12ca <xQueueSemaphoreTake+0x5a> @ imm = #-0x2
;                 }
700a12ca: e000         	b	0x700a12ce <xQueueSemaphoreTake+0x5e> @ imm = #0x0
700a12cc: e7ff         	b	0x700a12ce <xQueueSemaphoreTake+0x5e> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a12ce: f00c f9bf    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xc37e
700a12d2: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a12d4: 9009         	str	r0, [sp, #0x24]
700a12d6: e083         	b	0x700a13e0 <xQueueSemaphoreTake+0x170> @ imm = #0x106
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a12d8: 9807         	ldr	r0, [sp, #0x1c]
700a12da: b928         	cbnz	r0, 0x700a12e8 <xQueueSemaphoreTake+0x78> @ imm = #0xa
700a12dc: e7ff         	b	0x700a12de <xQueueSemaphoreTake+0x6e> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a12de: f00c f9b7    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xc36e
700a12e2: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
700a12e4: 9009         	str	r0, [sp, #0x24]
700a12e6: e07b         	b	0x700a13e0 <xQueueSemaphoreTake+0x170> @ imm = #0xf6
;                 else if( xEntryTimeSet == pdFALSE )
700a12e8: 9806         	ldr	r0, [sp, #0x18]
700a12ea: b930         	cbnz	r0, 0x700a12fa <xQueueSemaphoreTake+0x8a> @ imm = #0xc
700a12ec: e7ff         	b	0x700a12ee <xQueueSemaphoreTake+0x7e> @ imm = #-0x2
700a12ee: a804         	add	r0, sp, #0x10
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a12f0: f00d fe4e    	bl	0x700aef90 <vTaskInternalSetTimeOutState> @ imm = #0xdc9c
700a12f4: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a12f6: 9006         	str	r0, [sp, #0x18]
;                 }
700a12f8: e000         	b	0x700a12fc <xQueueSemaphoreTake+0x8c> @ imm = #0x0
700a12fa: e7ff         	b	0x700a12fc <xQueueSemaphoreTake+0x8c> @ imm = #-0x2
700a12fc: e7ff         	b	0x700a12fe <xQueueSemaphoreTake+0x8e> @ imm = #-0x2
700a12fe: e7ff         	b	0x700a1300 <xQueueSemaphoreTake+0x90> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a1300: f00c f9a6    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xc34c
;         vTaskSuspendAll();
700a1304: f00e fad4    	bl	0x700af8b0 <vTaskSuspendAll> @ imm = #0xe5a8
;         prvLockQueue( pxQueue );
700a1308: f00d f8e2    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0xd1c4
700a130c: 9803         	ldr	r0, [sp, #0xc]
700a130e: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a1312: 3001         	adds	r0, #0x1
700a1314: b928         	cbnz	r0, 0x700a1322 <xQueueSemaphoreTake+0xb2> @ imm = #0xa
700a1316: e7ff         	b	0x700a1318 <xQueueSemaphoreTake+0xa8> @ imm = #-0x2
700a1318: 9903         	ldr	r1, [sp, #0xc]
700a131a: 2000         	movs	r0, #0x0
700a131c: f881 0044    	strb.w	r0, [r1, #0x44]
700a1320: e7ff         	b	0x700a1322 <xQueueSemaphoreTake+0xb2> @ imm = #-0x2
700a1322: 9803         	ldr	r0, [sp, #0xc]
700a1324: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a1328: 3001         	adds	r0, #0x1
700a132a: b928         	cbnz	r0, 0x700a1338 <xQueueSemaphoreTake+0xc8> @ imm = #0xa
700a132c: e7ff         	b	0x700a132e <xQueueSemaphoreTake+0xbe> @ imm = #-0x2
700a132e: 9903         	ldr	r1, [sp, #0xc]
700a1330: 2000         	movs	r0, #0x0
700a1332: f881 0045    	strb.w	r0, [r1, #0x45]
700a1336: e7ff         	b	0x700a1338 <xQueueSemaphoreTake+0xc8> @ imm = #-0x2
700a1338: f00c f98a    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xc314
700a133c: a804         	add	r0, sp, #0x10
700a133e: a907         	add	r1, sp, #0x1c
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a1340: f007 fe6e    	bl	0x700a9020 <xTaskCheckForTimeOut> @ imm = #0x7cdc
700a1344: bb58         	cbnz	r0, 0x700a139e <xQueueSemaphoreTake+0x12e> @ imm = #0x56
700a1346: e7ff         	b	0x700a1348 <xQueueSemaphoreTake+0xd8> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a1348: 9803         	ldr	r0, [sp, #0xc]
700a134a: f00d fc79    	bl	0x700aec40 <prvIsQueueEmpty> @ imm = #0xd8f2
700a134e: b1f8         	cbz	r0, 0x700a1390 <xQueueSemaphoreTake+0x120> @ imm = #0x3e
700a1350: e7ff         	b	0x700a1352 <xQueueSemaphoreTake+0xe2> @ imm = #-0x2
;                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a1352: 9803         	ldr	r0, [sp, #0xc]
700a1354: 6800         	ldr	r0, [r0]
700a1356: b950         	cbnz	r0, 0x700a136e <xQueueSemaphoreTake+0xfe> @ imm = #0x14
700a1358: e7ff         	b	0x700a135a <xQueueSemaphoreTake+0xea> @ imm = #-0x2
;                             taskENTER_CRITICAL();
700a135a: f00d f8b9    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0xd172
;                                 xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
700a135e: 9803         	ldr	r0, [sp, #0xc]
700a1360: 6880         	ldr	r0, [r0, #0x8]
700a1362: f003 fdbd    	bl	0x700a4ee0 <xTaskPriorityInherit> @ imm = #0x3b7a
700a1366: 9002         	str	r0, [sp, #0x8]
;                             taskEXIT_CRITICAL();
700a1368: f00c f972    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xc2e4
;                         }
700a136c: e000         	b	0x700a1370 <xQueueSemaphoreTake+0x100> @ imm = #0x0
700a136e: e7ff         	b	0x700a1370 <xQueueSemaphoreTake+0x100> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
700a1370: 9803         	ldr	r0, [sp, #0xc]
700a1372: 3024         	adds	r0, #0x24
700a1374: 9907         	ldr	r1, [sp, #0x1c]
700a1376: f00d fd23    	bl	0x700aedc0 <vTaskPlaceOnEventList> @ imm = #0xda46
;                 prvUnlockQueue( pxQueue );
700a137a: 9803         	ldr	r0, [sp, #0xc]
700a137c: f006 fc60    	bl	0x700a7c40 <prvUnlockQueue> @ imm = #0x68c0
;                 if( xTaskResumeAll() == pdFALSE )
700a1380: f000 fe86    	bl	0x700a2090 <xTaskResumeAll> @ imm = #0xd0c
700a1384: b910         	cbnz	r0, 0x700a138c <xQueueSemaphoreTake+0x11c> @ imm = #0x4
700a1386: e7ff         	b	0x700a1388 <xQueueSemaphoreTake+0x118> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a1388: df00         	svc	#0x0
;                 }
700a138a: e000         	b	0x700a138e <xQueueSemaphoreTake+0x11e> @ imm = #0x0
700a138c: e7ff         	b	0x700a138e <xQueueSemaphoreTake+0x11e> @ imm = #-0x2
;             }
700a138e: e005         	b	0x700a139c <xQueueSemaphoreTake+0x12c> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a1390: 9803         	ldr	r0, [sp, #0xc]
700a1392: f006 fc55    	bl	0x700a7c40 <prvUnlockQueue> @ imm = #0x68aa
;                 ( void ) xTaskResumeAll();
700a1396: f000 fe7b    	bl	0x700a2090 <xTaskResumeAll> @ imm = #0xcf6
700a139a: e7ff         	b	0x700a139c <xQueueSemaphoreTake+0x12c> @ imm = #-0x2
;         }
700a139c: e01f         	b	0x700a13de <xQueueSemaphoreTake+0x16e> @ imm = #0x3e
;             prvUnlockQueue( pxQueue );
700a139e: 9803         	ldr	r0, [sp, #0xc]
700a13a0: f006 fc4e    	bl	0x700a7c40 <prvUnlockQueue> @ imm = #0x689c
;             ( void ) xTaskResumeAll();
700a13a4: f000 fe74    	bl	0x700a2090 <xTaskResumeAll> @ imm = #0xce8
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a13a8: 9803         	ldr	r0, [sp, #0xc]
700a13aa: f00d fc49    	bl	0x700aec40 <prvIsQueueEmpty> @ imm = #0xd892
700a13ae: b1a0         	cbz	r0, 0x700a13da <xQueueSemaphoreTake+0x16a> @ imm = #0x28
700a13b0: e7ff         	b	0x700a13b2 <xQueueSemaphoreTake+0x142> @ imm = #-0x2
;                         if( xInheritanceOccurred != pdFALSE )
700a13b2: 9802         	ldr	r0, [sp, #0x8]
700a13b4: b170         	cbz	r0, 0x700a13d4 <xQueueSemaphoreTake+0x164> @ imm = #0x1c
700a13b6: e7ff         	b	0x700a13b8 <xQueueSemaphoreTake+0x148> @ imm = #-0x2
;                             taskENTER_CRITICAL();
700a13b8: f00d f88a    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0xd114
;                                 uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
700a13bc: 9803         	ldr	r0, [sp, #0xc]
700a13be: f00d fce7    	bl	0x700aed90 <prvGetDisinheritPriorityAfterTimeout> @ imm = #0xd9ce
700a13c2: 9000         	str	r0, [sp]
;                                 vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
700a13c4: 9803         	ldr	r0, [sp, #0xc]
700a13c6: 6880         	ldr	r0, [r0, #0x8]
700a13c8: 9900         	ldr	r1, [sp]
700a13ca: f004 fa21    	bl	0x700a5810 <vTaskPriorityDisinheritAfterTimeout> @ imm = #0x4442
;                             taskEXIT_CRITICAL();
700a13ce: f00c f93f    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xc27e
;                         }
700a13d2: e7ff         	b	0x700a13d4 <xQueueSemaphoreTake+0x164> @ imm = #-0x2
700a13d4: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
700a13d6: 9009         	str	r0, [sp, #0x24]
700a13d8: e002         	b	0x700a13e0 <xQueueSemaphoreTake+0x170> @ imm = #0x4
700a13da: e7ff         	b	0x700a13dc <xQueueSemaphoreTake+0x16c> @ imm = #-0x2
700a13dc: e7ff         	b	0x700a13de <xQueueSemaphoreTake+0x16e> @ imm = #-0x2
;     for( ; ; )
700a13de: e751         	b	0x700a1284 <xQueueSemaphoreTake+0x14> @ imm = #-0x15e
; }
700a13e0: 9809         	ldr	r0, [sp, #0x24]
700a13e2: b00a         	add	sp, #0x28
700a13e4: bd80         	pop	{r7, pc}
		...
700a13ee: 0000         	movs	r0, r0

700a13f0 <xTaskIncrementTick>:
; BaseType_t xTaskIncrementTick(void) {
700a13f0: b580         	push	{r7, lr}
700a13f2: b086         	sub	sp, #0x18
700a13f4: 2000         	movs	r0, #0x0
;   BaseType_t xSwitchRequired = pdFALSE;
700a13f6: 9003         	str	r0, [sp, #0xc]
;   if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a13f8: f242 60e4    	movw	r0, #0x26e4
700a13fc: f2c7 000b    	movt	r0, #0x700b
700a1400: 6800         	ldr	r0, [r0]
700a1402: 2800         	cmp	r0, #0x0
700a1404: f040 80a3    	bne.w	0x700a154e <xTaskIncrementTick+0x15e> @ imm = #0x146
700a1408: e7ff         	b	0x700a140a <xTaskIncrementTick+0x1a> @ imm = #-0x2
;     const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
700a140a: f242 7104    	movw	r1, #0x2704
700a140e: f2c7 010b    	movt	r1, #0x700b
700a1412: 6808         	ldr	r0, [r1]
700a1414: 3001         	adds	r0, #0x1
700a1416: 9002         	str	r0, [sp, #0x8]
;     xTickCount = xConstTickCount;
700a1418: 9802         	ldr	r0, [sp, #0x8]
700a141a: 6008         	str	r0, [r1]
;     if (xConstTickCount ==
700a141c: 9802         	ldr	r0, [sp, #0x8]
700a141e: b9c0         	cbnz	r0, 0x700a1452 <xTaskIncrementTick+0x62> @ imm = #0x30
700a1420: e7ff         	b	0x700a1422 <xTaskIncrementTick+0x32> @ imm = #-0x2
;       taskSWITCH_DELAYED_LISTS();
700a1422: f245 2220    	movw	r2, #0x5220
700a1426: f2c7 0208    	movt	r2, #0x7008
700a142a: 6810         	ldr	r0, [r2]
700a142c: 9001         	str	r0, [sp, #0x4]
700a142e: f245 2124    	movw	r1, #0x5224
700a1432: f2c7 0108    	movt	r1, #0x7008
700a1436: 6808         	ldr	r0, [r1]
700a1438: 6010         	str	r0, [r2]
700a143a: 9801         	ldr	r0, [sp, #0x4]
700a143c: 6008         	str	r0, [r1]
700a143e: f242 61f8    	movw	r1, #0x26f8
700a1442: f2c7 010b    	movt	r1, #0x700b
700a1446: 6808         	ldr	r0, [r1]
700a1448: 3001         	adds	r0, #0x1
700a144a: 6008         	str	r0, [r1]
700a144c: f00c fd48    	bl	0x700adee0 <prvResetNextTaskUnblockTime> @ imm = #0xca90
;     } else {
700a1450: e000         	b	0x700a1454 <xTaskIncrementTick+0x64> @ imm = #0x0
700a1452: e7ff         	b	0x700a1454 <xTaskIncrementTick+0x64> @ imm = #-0x2
;     if (xConstTickCount >= xNextTaskUnblockTime) {
700a1454: 9802         	ldr	r0, [sp, #0x8]
700a1456: f242 61f4    	movw	r1, #0x26f4
700a145a: f2c7 010b    	movt	r1, #0x700b
700a145e: 6809         	ldr	r1, [r1]
700a1460: 4288         	cmp	r0, r1
700a1462: d368         	blo	0x700a1536 <xTaskIncrementTick+0x146> @ imm = #0xd0
700a1464: e7ff         	b	0x700a1466 <xTaskIncrementTick+0x76> @ imm = #-0x2
;       for (;;) {
700a1466: e7ff         	b	0x700a1468 <xTaskIncrementTick+0x78> @ imm = #-0x2
;         if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
700a1468: f245 2020    	movw	r0, #0x5220
700a146c: f2c7 0008    	movt	r0, #0x7008
700a1470: 6800         	ldr	r0, [r0]
700a1472: 6800         	ldr	r0, [r0]
700a1474: b940         	cbnz	r0, 0x700a1488 <xTaskIncrementTick+0x98> @ imm = #0x10
700a1476: e7ff         	b	0x700a1478 <xTaskIncrementTick+0x88> @ imm = #-0x2
;           xNextTaskUnblockTime =
700a1478: f242 61f4    	movw	r1, #0x26f4
700a147c: f2c7 010b    	movt	r1, #0x700b
700a1480: f04f 30ff    	mov.w	r0, #0xffffffff
700a1484: 6008         	str	r0, [r1]
;           break;
700a1486: e055         	b	0x700a1534 <xTaskIncrementTick+0x144> @ imm = #0xaa
;           pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a1488: f245 2020    	movw	r0, #0x5220
700a148c: f2c7 0008    	movt	r0, #0x7008
700a1490: 6800         	ldr	r0, [r0]
700a1492: 68c0         	ldr	r0, [r0, #0xc]
700a1494: 68c0         	ldr	r0, [r0, #0xc]
700a1496: 9005         	str	r0, [sp, #0x14]
;           xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
700a1498: 9805         	ldr	r0, [sp, #0x14]
700a149a: 6840         	ldr	r0, [r0, #0x4]
700a149c: 9004         	str	r0, [sp, #0x10]
;           if (xConstTickCount < xItemValue) {
700a149e: 9802         	ldr	r0, [sp, #0x8]
700a14a0: 9904         	ldr	r1, [sp, #0x10]
700a14a2: 4288         	cmp	r0, r1
700a14a4: d207         	bhs	0x700a14b6 <xTaskIncrementTick+0xc6> @ imm = #0xe
700a14a6: e7ff         	b	0x700a14a8 <xTaskIncrementTick+0xb8> @ imm = #-0x2
;             xNextTaskUnblockTime = xItemValue;
700a14a8: 9804         	ldr	r0, [sp, #0x10]
700a14aa: f242 61f4    	movw	r1, #0x26f4
700a14ae: f2c7 010b    	movt	r1, #0x700b
700a14b2: 6008         	str	r0, [r1]
;             break; /*lint !e9011 Code structure here is deedmed easier to
700a14b4: e03e         	b	0x700a1534 <xTaskIncrementTick+0x144> @ imm = #0x7c
700a14b6: e7ff         	b	0x700a14b8 <xTaskIncrementTick+0xc8> @ imm = #-0x2
;           (void)uxListRemove(&(pxTCB->xStateListItem));
700a14b8: 9805         	ldr	r0, [sp, #0x14]
700a14ba: 3004         	adds	r0, #0x4
700a14bc: f00b ffd8    	bl	0x700ad470 <uxListRemove> @ imm = #0xbfb0
;           if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a14c0: 9805         	ldr	r0, [sp, #0x14]
700a14c2: 6a80         	ldr	r0, [r0, #0x28]
700a14c4: b128         	cbz	r0, 0x700a14d2 <xTaskIncrementTick+0xe2> @ imm = #0xa
700a14c6: e7ff         	b	0x700a14c8 <xTaskIncrementTick+0xd8> @ imm = #-0x2
;             (void)uxListRemove(&(pxTCB->xEventListItem));
700a14c8: 9805         	ldr	r0, [sp, #0x14]
700a14ca: 3018         	adds	r0, #0x18
700a14cc: f00b ffd0    	bl	0x700ad470 <uxListRemove> @ imm = #0xbfa0
;           } else {
700a14d0: e000         	b	0x700a14d4 <xTaskIncrementTick+0xe4> @ imm = #0x0
700a14d2: e7ff         	b	0x700a14d4 <xTaskIncrementTick+0xe4> @ imm = #-0x2
;           prvAddTaskToReadyList(pxTCB);
700a14d4: 9805         	ldr	r0, [sp, #0x14]
700a14d6: 6ac0         	ldr	r0, [r0, #0x2c]
700a14d8: f242 61ec    	movw	r1, #0x26ec
700a14dc: f2c7 010b    	movt	r1, #0x700b
700a14e0: 6809         	ldr	r1, [r1]
700a14e2: 4288         	cmp	r0, r1
700a14e4: d908         	bls	0x700a14f8 <xTaskIncrementTick+0x108> @ imm = #0x10
700a14e6: e7ff         	b	0x700a14e8 <xTaskIncrementTick+0xf8> @ imm = #-0x2
700a14e8: 9805         	ldr	r0, [sp, #0x14]
700a14ea: 6ac0         	ldr	r0, [r0, #0x2c]
700a14ec: f242 61ec    	movw	r1, #0x26ec
700a14f0: f2c7 010b    	movt	r1, #0x700b
700a14f4: 6008         	str	r0, [r1]
700a14f6: e7ff         	b	0x700a14f8 <xTaskIncrementTick+0x108> @ imm = #-0x2
700a14f8: 9905         	ldr	r1, [sp, #0x14]
700a14fa: 6ac8         	ldr	r0, [r1, #0x2c]
700a14fc: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a1500: f244 40f8    	movw	r0, #0x44f8
700a1504: f2c7 0008    	movt	r0, #0x7008
700a1508: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a150c: 3104         	adds	r1, #0x4
700a150e: f00c fd67    	bl	0x700adfe0 <vListInsertEnd> @ imm = #0xcace
;             if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a1512: 9805         	ldr	r0, [sp, #0x14]
700a1514: 6ac0         	ldr	r0, [r0, #0x2c]
700a1516: f242 61bc    	movw	r1, #0x26bc
700a151a: f2c7 010b    	movt	r1, #0x700b
700a151e: 6809         	ldr	r1, [r1]
700a1520: 6ac9         	ldr	r1, [r1, #0x2c]
700a1522: 4288         	cmp	r0, r1
700a1524: d303         	blo	0x700a152e <xTaskIncrementTick+0x13e> @ imm = #0x6
700a1526: e7ff         	b	0x700a1528 <xTaskIncrementTick+0x138> @ imm = #-0x2
700a1528: 2001         	movs	r0, #0x1
;               xSwitchRequired = pdTRUE;
700a152a: 9003         	str	r0, [sp, #0xc]
;             } else {
700a152c: e000         	b	0x700a1530 <xTaskIncrementTick+0x140> @ imm = #0x0
700a152e: e7ff         	b	0x700a1530 <xTaskIncrementTick+0x140> @ imm = #-0x2
700a1530: e7ff         	b	0x700a1532 <xTaskIncrementTick+0x142> @ imm = #-0x2
;       for (;;) {
700a1532: e799         	b	0x700a1468 <xTaskIncrementTick+0x78> @ imm = #-0xce
;     }
700a1534: e7ff         	b	0x700a1536 <xTaskIncrementTick+0x146> @ imm = #-0x2
;       if (xYieldPending != pdFALSE) {
700a1536: f242 7010    	movw	r0, #0x2710
700a153a: f2c7 000b    	movt	r0, #0x700b
700a153e: 6800         	ldr	r0, [r0]
700a1540: b118         	cbz	r0, 0x700a154a <xTaskIncrementTick+0x15a> @ imm = #0x6
700a1542: e7ff         	b	0x700a1544 <xTaskIncrementTick+0x154> @ imm = #-0x2
700a1544: 2001         	movs	r0, #0x1
;         xSwitchRequired = pdTRUE;
700a1546: 9003         	str	r0, [sp, #0xc]
;       } else {
700a1548: e000         	b	0x700a154c <xTaskIncrementTick+0x15c> @ imm = #0x0
700a154a: e7ff         	b	0x700a154c <xTaskIncrementTick+0x15c> @ imm = #-0x2
;   } else {
700a154c: e007         	b	0x700a155e <xTaskIncrementTick+0x16e> @ imm = #0xe
;     ++xPendedTicks;
700a154e: f242 61fc    	movw	r1, #0x26fc
700a1552: f2c7 010b    	movt	r1, #0x700b
700a1556: 6808         	ldr	r0, [r1]
700a1558: 3001         	adds	r0, #0x1
700a155a: 6008         	str	r0, [r1]
700a155c: e7ff         	b	0x700a155e <xTaskIncrementTick+0x16e> @ imm = #-0x2
;   return xSwitchRequired;
700a155e: 9803         	ldr	r0, [sp, #0xc]
700a1560: b006         	add	sp, #0x18
700a1562: bd80         	pop	{r7, pc}
		...

700a1570 <CSL_bcdmaChanOpTeardownChan>:
; {
700a1570: b580         	push	{r7, lr}
700a1572: b08c         	sub	sp, #0x30
700a1574: 900b         	str	r0, [sp, #0x2c]
700a1576: 910a         	str	r1, [sp, #0x28]
700a1578: 9209         	str	r2, [sp, #0x24]
700a157a: 9308         	str	r3, [sp, #0x20]
700a157c: 2000         	movs	r0, #0x0
;     int32_t  retVal = CSL_PASS;
700a157e: 9007         	str	r0, [sp, #0x1c]
;     if( CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)false )
700a1580: 980b         	ldr	r0, [sp, #0x2c]
700a1582: 990a         	ldr	r1, [sp, #0x28]
700a1584: 9a09         	ldr	r2, [sp, #0x24]
700a1586: f009 f913    	bl	0x700aa7b0 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x9226
700a158a: b920         	cbnz	r0, 0x700a1596 <CSL_bcdmaChanOpTeardownChan+0x26> @ imm = #0x8
700a158c: e7ff         	b	0x700a158e <CSL_bcdmaChanOpTeardownChan+0x1e> @ imm = #-0x2
700a158e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a1592: 9007         	str	r0, [sp, #0x1c]
;     }
700a1594: e09f         	b	0x700a16d6 <CSL_bcdmaChanOpTeardownChan+0x166> @ imm = #0x13e
700a1596: 2000         	movs	r0, #0x0
;         uint32_t force = (uint32_t)0U, wait = (uint32_t)0U;
700a1598: 9005         	str	r0, [sp, #0x14]
700a159a: 9004         	str	r0, [sp, #0x10]
;         if( pOpData != NULL )
700a159c: 9808         	ldr	r0, [sp, #0x20]
700a159e: b148         	cbz	r0, 0x700a15b4 <CSL_bcdmaChanOpTeardownChan+0x44> @ imm = #0x12
700a15a0: e7ff         	b	0x700a15a2 <CSL_bcdmaChanOpTeardownChan+0x32> @ imm = #-0x2
;             CSL_BcdmaTeardownOpts *pTdOpts = (CSL_BcdmaTeardownOpts *)pOpData;
700a15a2: 9808         	ldr	r0, [sp, #0x20]
700a15a4: 9003         	str	r0, [sp, #0xc]
;             force = pTdOpts->force;
700a15a6: 9803         	ldr	r0, [sp, #0xc]
700a15a8: 6800         	ldr	r0, [r0]
700a15aa: 9005         	str	r0, [sp, #0x14]
;             wait  = pTdOpts->wait;
700a15ac: 9803         	ldr	r0, [sp, #0xc]
700a15ae: 6840         	ldr	r0, [r0, #0x4]
700a15b0: 9004         	str	r0, [sp, #0x10]
;         }
700a15b2: e7ff         	b	0x700a15b4 <CSL_bcdmaChanOpTeardownChan+0x44> @ imm = #-0x2
;         switch( chanType )
700a15b4: 980a         	ldr	r0, [sp, #0x28]
700a15b6: 9001         	str	r0, [sp, #0x4]
700a15b8: b148         	cbz	r0, 0x700a15ce <CSL_bcdmaChanOpTeardownChan+0x5e> @ imm = #0x12
700a15ba: e7ff         	b	0x700a15bc <CSL_bcdmaChanOpTeardownChan+0x4c> @ imm = #-0x2
700a15bc: 9801         	ldr	r0, [sp, #0x4]
700a15be: 2801         	cmp	r0, #0x1
700a15c0: d024         	beq	0x700a160c <CSL_bcdmaChanOpTeardownChan+0x9c> @ imm = #0x48
700a15c2: e7ff         	b	0x700a15c4 <CSL_bcdmaChanOpTeardownChan+0x54> @ imm = #-0x2
700a15c4: 9801         	ldr	r0, [sp, #0x4]
700a15c6: 2802         	cmp	r0, #0x2
700a15c8: d03f         	beq	0x700a164a <CSL_bcdmaChanOpTeardownChan+0xda> @ imm = #0x7e
700a15ca: e7ff         	b	0x700a15cc <CSL_bcdmaChanOpTeardownChan+0x5c> @ imm = #-0x2
;         {
700a15cc: e7ff         	b	0x700a15ce <CSL_bcdmaChanOpTeardownChan+0x5e> @ imm = #-0x2
;                 regVal = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL );
700a15ce: 980b         	ldr	r0, [sp, #0x2c]
700a15d0: 6880         	ldr	r0, [r0, #0x8]
700a15d2: 9909         	ldr	r1, [sp, #0x24]
700a15d4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a15d8: f00e f98a    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0xe314
700a15dc: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_BCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a15de: 9806         	ldr	r0, [sp, #0x18]
700a15e0: f040 4080    	orr	r0, r0, #0x40000000
700a15e4: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_BCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
700a15e6: 9806         	ldr	r0, [sp, #0x18]
700a15e8: f020 5180    	bic	r1, r0, #0x10000000
700a15ec: 9a05         	ldr	r2, [sp, #0x14]
700a15ee: f101 5080    	add.w	r0, r1, #0x10000000
700a15f2: 2a00         	cmp	r2, #0x0
700a15f4: bf08         	it	eq
700a15f6: 4608         	moveq	r0, r1
700a15f8: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a15fa: 980b         	ldr	r0, [sp, #0x2c]
700a15fc: 6880         	ldr	r0, [r0, #0x8]
700a15fe: 9909         	ldr	r1, [sp, #0x24]
700a1600: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1604: 9906         	ldr	r1, [sp, #0x18]
700a1606: f7fa fe03    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x53fa
;                 break;
700a160a: e03d         	b	0x700a1688 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #0x7a
;                 regVal = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a160c: 980b         	ldr	r0, [sp, #0x2c]
700a160e: 6900         	ldr	r0, [r0, #0x10]
700a1610: 9909         	ldr	r1, [sp, #0x24]
700a1612: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1616: f00e f96b    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0xe2d6
700a161a: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_TXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a161c: 9806         	ldr	r0, [sp, #0x18]
700a161e: f040 4080    	orr	r0, r0, #0x40000000
700a1622: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_TXCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
700a1624: 9806         	ldr	r0, [sp, #0x18]
700a1626: f020 5180    	bic	r1, r0, #0x10000000
700a162a: 9a05         	ldr	r2, [sp, #0x14]
700a162c: f101 5080    	add.w	r0, r1, #0x10000000
700a1630: 2a00         	cmp	r2, #0x0
700a1632: bf08         	it	eq
700a1634: 4608         	moveq	r0, r1
700a1636: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a1638: 980b         	ldr	r0, [sp, #0x2c]
700a163a: 6900         	ldr	r0, [r0, #0x10]
700a163c: 9909         	ldr	r1, [sp, #0x24]
700a163e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1642: 9906         	ldr	r1, [sp, #0x18]
700a1644: f7fa fde4    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x5438
;                 break;
700a1648: e01e         	b	0x700a1688 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #0x3c
;                 regVal = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a164a: 980b         	ldr	r0, [sp, #0x2c]
700a164c: 6980         	ldr	r0, [r0, #0x18]
700a164e: 9909         	ldr	r1, [sp, #0x24]
700a1650: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1654: f00e f94c    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0xe298
700a1658: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_RXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a165a: 9806         	ldr	r0, [sp, #0x18]
700a165c: f040 4080    	orr	r0, r0, #0x40000000
700a1660: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_RXCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
700a1662: 9806         	ldr	r0, [sp, #0x18]
700a1664: f020 5180    	bic	r1, r0, #0x10000000
700a1668: 9a05         	ldr	r2, [sp, #0x14]
700a166a: f101 5080    	add.w	r0, r1, #0x10000000
700a166e: 2a00         	cmp	r2, #0x0
700a1670: bf08         	it	eq
700a1672: 4608         	moveq	r0, r1
700a1674: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a1676: 980b         	ldr	r0, [sp, #0x2c]
700a1678: 6980         	ldr	r0, [r0, #0x18]
700a167a: 9909         	ldr	r1, [sp, #0x24]
700a167c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1680: 9906         	ldr	r1, [sp, #0x18]
700a1682: f7fa fdc5    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x5476
;                 break;
700a1686: e7ff         	b	0x700a1688 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #-0x2
;         if(wait != 0U)
700a1688: 9804         	ldr	r0, [sp, #0x10]
700a168a: b318         	cbz	r0, 0x700a16d4 <CSL_bcdmaChanOpTeardownChan+0x164> @ imm = #0x46
700a168c: e7ff         	b	0x700a168e <CSL_bcdmaChanOpTeardownChan+0x11e> @ imm = #-0x2
700a168e: 2080         	movs	r0, #0x80
;             uint32_t retryCnt = CSL_BCDMA_TEARDOWN_COMPLETE_WAIT_MAX_CNT;
700a1690: 9002         	str	r0, [sp, #0x8]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a1692: e7ff         	b	0x700a1694 <CSL_bcdmaChanOpTeardownChan+0x124> @ imm = #-0x2
700a1694: 980b         	ldr	r0, [sp, #0x2c]
700a1696: 990a         	ldr	r1, [sp, #0x28]
700a1698: 9a09         	ldr	r2, [sp, #0x24]
700a169a: f009 f889    	bl	0x700aa7b0 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x9112
700a169e: 4601         	mov	r1, r0
700a16a0: 2000         	movs	r0, #0x0
700a16a2: 9000         	str	r0, [sp]
700a16a4: b131         	cbz	r1, 0x700a16b4 <CSL_bcdmaChanOpTeardownChan+0x144> @ imm = #0xc
700a16a6: e7ff         	b	0x700a16a8 <CSL_bcdmaChanOpTeardownChan+0x138> @ imm = #-0x2
700a16a8: 9802         	ldr	r0, [sp, #0x8]
700a16aa: 2800         	cmp	r0, #0x0
700a16ac: bf18         	it	ne
700a16ae: 2001         	movne	r0, #0x1
700a16b0: 9000         	str	r0, [sp]
700a16b2: e7ff         	b	0x700a16b4 <CSL_bcdmaChanOpTeardownChan+0x144> @ imm = #-0x2
700a16b4: 9800         	ldr	r0, [sp]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a16b6: 07c0         	lsls	r0, r0, #0x1f
700a16b8: b120         	cbz	r0, 0x700a16c4 <CSL_bcdmaChanOpTeardownChan+0x154> @ imm = #0x8
700a16ba: e7ff         	b	0x700a16bc <CSL_bcdmaChanOpTeardownChan+0x14c> @ imm = #-0x2
;                 retryCnt--;
700a16bc: 9802         	ldr	r0, [sp, #0x8]
700a16be: 3801         	subs	r0, #0x1
700a16c0: 9002         	str	r0, [sp, #0x8]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a16c2: e7e7         	b	0x700a1694 <CSL_bcdmaChanOpTeardownChan+0x124> @ imm = #-0x32
;             if( retryCnt == (uint32_t)0U ) {
700a16c4: 9802         	ldr	r0, [sp, #0x8]
700a16c6: b920         	cbnz	r0, 0x700a16d2 <CSL_bcdmaChanOpTeardownChan+0x162> @ imm = #0x8
700a16c8: e7ff         	b	0x700a16ca <CSL_bcdmaChanOpTeardownChan+0x15a> @ imm = #-0x2
700a16ca: f04f 30ff    	mov.w	r0, #0xffffffff
;                 retVal = CSL_EFAIL;
700a16ce: 9007         	str	r0, [sp, #0x1c]
;             }
700a16d0: e7ff         	b	0x700a16d2 <CSL_bcdmaChanOpTeardownChan+0x162> @ imm = #-0x2
;         }
700a16d2: e7ff         	b	0x700a16d4 <CSL_bcdmaChanOpTeardownChan+0x164> @ imm = #-0x2
700a16d4: e7ff         	b	0x700a16d6 <CSL_bcdmaChanOpTeardownChan+0x166> @ imm = #-0x2
;     return retVal;
700a16d6: 9807         	ldr	r0, [sp, #0x1c]
700a16d8: b00c         	add	sp, #0x30
700a16da: bd80         	pop	{r7, pc}
700a16dc: 0000         	movs	r0, r0
700a16de: 0000         	movs	r0, r0

700a16e0 <CSL_bcdmaChanOp>:
; {
700a16e0: b580         	push	{r7, lr}
700a16e2: b088         	sub	sp, #0x20
700a16e4: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a16e8: 9007         	str	r0, [sp, #0x1c]
700a16ea: 9106         	str	r1, [sp, #0x18]
700a16ec: 9205         	str	r2, [sp, #0x14]
700a16ee: 9304         	str	r3, [sp, #0x10]
700a16f0: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a16f2: 9003         	str	r0, [sp, #0xc]
;     if( ( pCfg == NULL )                                    ||
700a16f4: 9807         	ldr	r0, [sp, #0x1c]
700a16f6: b158         	cbz	r0, 0x700a1710 <CSL_bcdmaChanOp+0x30> @ imm = #0x16
700a16f8: e7ff         	b	0x700a16fa <CSL_bcdmaChanOp+0x1a> @ imm = #-0x2
;         ( chanType > CSL_BCDMA_CHAN_TYPE_SPLIT_RX )         ||
700a16fa: 9805         	ldr	r0, [sp, #0x14]
700a16fc: 2802         	cmp	r0, #0x2
700a16fe: d807         	bhi	0x700a1710 <CSL_bcdmaChanOp+0x30> @ imm = #0xe
700a1700: e7ff         	b	0x700a1702 <CSL_bcdmaChanOp+0x22> @ imm = #-0x2
;         ( !CSL_bcdmaChanOpIsValidChanIdx( pCfg, chanType, chanIdx ) )
700a1702: 9807         	ldr	r0, [sp, #0x1c]
700a1704: 9905         	ldr	r1, [sp, #0x14]
700a1706: 9a04         	ldr	r2, [sp, #0x10]
700a1708: f009 f892    	bl	0x700aa830 <CSL_bcdmaChanOpIsValidChanIdx> @ imm = #0x9124
;     if( ( pCfg == NULL )                                    ||
700a170c: b920         	cbnz	r0, 0x700a1718 <CSL_bcdmaChanOp+0x38> @ imm = #0x8
700a170e: e7ff         	b	0x700a1710 <CSL_bcdmaChanOp+0x30> @ imm = #-0x2
700a1710: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a1714: 9003         	str	r0, [sp, #0xc]
;     }
700a1716: e094         	b	0x700a1842 <CSL_bcdmaChanOp+0x162> @ imm = #0x128
;         switch(chanOp )
700a1718: 9806         	ldr	r0, [sp, #0x18]
700a171a: 9002         	str	r0, [sp, #0x8]
700a171c: 280e         	cmp	r0, #0xe
700a171e: f200 808b    	bhi.w	0x700a1838 <CSL_bcdmaChanOp+0x158> @ imm = #0x116
700a1722: 9902         	ldr	r1, [sp, #0x8]
700a1724: e8df f001    	tbb	[pc, r1]
700a1728: 08 10 18 20  	.word	0x20181008
700a172c: 28 30 38 3f  	.word	0x3f383028
700a1730: 47 4f 57 5f  	.word	0x5f574f47
700a1734: 6c 79 81 00  	.word	0x0081796c
;                 retVal = CSL_bcdmaChanOpCfgChan( pCfg, chanType, chanIdx, pOpData );
700a1738: 9807         	ldr	r0, [sp, #0x1c]
700a173a: 9905         	ldr	r1, [sp, #0x14]
700a173c: 9a04         	ldr	r2, [sp, #0x10]
700a173e: 9b0a         	ldr	r3, [sp, #0x28]
700a1740: f7fc f86e    	bl	0x7009d820 <CSL_bcdmaChanOpCfgChan> @ imm = #-0x3f24
700a1744: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1746: e07b         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0xf6
;                 retVal = CSL_bcdmaChanOpSetChanEnable( pCfg, chanType, chanIdx, (bool)true );
700a1748: 9807         	ldr	r0, [sp, #0x1c]
700a174a: 9905         	ldr	r1, [sp, #0x14]
700a174c: 9a04         	ldr	r2, [sp, #0x10]
700a174e: 2301         	movs	r3, #0x1
700a1750: f007 fcb6    	bl	0x700a90c0 <CSL_bcdmaChanOpSetChanEnable> @ imm = #0x796c
700a1754: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1756: e073         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0xe6
;                 retVal = CSL_bcdmaChanOpSetChanEnable( pCfg, chanType, chanIdx, (bool)false );
700a1758: 9807         	ldr	r0, [sp, #0x1c]
700a175a: 9905         	ldr	r1, [sp, #0x14]
700a175c: 9a04         	ldr	r2, [sp, #0x10]
700a175e: 2300         	movs	r3, #0x0
700a1760: f007 fcae    	bl	0x700a90c0 <CSL_bcdmaChanOpSetChanEnable> @ imm = #0x795c
700a1764: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1766: e06b         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0xd6
;                 retVal = CSL_bcdmaChanOpSetChanPause( pCfg, chanType, chanIdx, (bool)true );
700a1768: 9807         	ldr	r0, [sp, #0x1c]
700a176a: 9905         	ldr	r1, [sp, #0x14]
700a176c: 9a04         	ldr	r2, [sp, #0x10]
700a176e: 2301         	movs	r3, #0x1
700a1770: f006 fc1e    	bl	0x700a7fb0 <CSL_bcdmaChanOpSetChanPause> @ imm = #0x683c
700a1774: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1776: e063         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0xc6
;                 retVal = CSL_bcdmaChanOpSetChanPause( pCfg, chanType, chanIdx, (bool)false );
700a1778: 9807         	ldr	r0, [sp, #0x1c]
700a177a: 9905         	ldr	r1, [sp, #0x14]
700a177c: 9a04         	ldr	r2, [sp, #0x10]
700a177e: 2300         	movs	r3, #0x0
700a1780: f006 fc16    	bl	0x700a7fb0 <CSL_bcdmaChanOpSetChanPause> @ imm = #0x682c
700a1784: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1786: e05b         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0xb6
;                 retVal = CSL_bcdmaChanOpTeardownChan( pCfg, chanType, chanIdx, pOpData );
700a1788: 9807         	ldr	r0, [sp, #0x1c]
700a178a: 9905         	ldr	r1, [sp, #0x14]
700a178c: 9a04         	ldr	r2, [sp, #0x10]
700a178e: 9b0a         	ldr	r3, [sp, #0x28]
700a1790: f7ff feee    	bl	0x700a1570 <CSL_bcdmaChanOpTeardownChan> @ imm = #-0x224
700a1794: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1796: e053         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0xa6
;                 retVal = CSL_bcdmaChanOpTriggerChan( pCfg, chanType, chanIdx );
700a1798: 9807         	ldr	r0, [sp, #0x1c]
700a179a: 9905         	ldr	r1, [sp, #0x14]
700a179c: 9a04         	ldr	r2, [sp, #0x10]
700a179e: f009 fc47    	bl	0x700ab030 <CSL_bcdmaChanOpTriggerChan> @ imm = #0x988e
700a17a2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a17a4: e04c         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0x98
;                 retVal = CSL_bcdmaChanOpGetChanRT( pCfg, chanType, chanIdx, pOpData );
700a17a6: 9807         	ldr	r0, [sp, #0x1c]
700a17a8: 9905         	ldr	r1, [sp, #0x14]
700a17aa: 9a04         	ldr	r2, [sp, #0x10]
700a17ac: 9b0a         	ldr	r3, [sp, #0x28]
700a17ae: f004 fd97    	bl	0x700a62e0 <CSL_bcdmaChanOpGetChanRT> @ imm = #0x4b2e
700a17b2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a17b4: e044         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0x88
;                 retVal = CSL_bcdmaChanOpSetChanRT( pCfg, chanType, chanIdx, pOpData );
700a17b6: 9807         	ldr	r0, [sp, #0x1c]
700a17b8: 9905         	ldr	r1, [sp, #0x14]
700a17ba: 9a04         	ldr	r2, [sp, #0x10]
700a17bc: 9b0a         	ldr	r3, [sp, #0x28]
700a17be: f006 fc4f    	bl	0x700a8060 <CSL_bcdmaChanOpSetChanRT> @ imm = #0x689e
700a17c2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a17c4: e03c         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0x78
;                 retVal = CSL_bcdmaChanOpGetChanStats( pCfg, chanType, chanIdx, pOpData );
700a17c6: 9807         	ldr	r0, [sp, #0x1c]
700a17c8: 9905         	ldr	r1, [sp, #0x14]
700a17ca: 9a04         	ldr	r2, [sp, #0x10]
700a17cc: 9b0a         	ldr	r3, [sp, #0x28]
700a17ce: f000 fa57    	bl	0x700a1c80 <CSL_bcdmaChanOpGetChanStats> @ imm = #0x4ae
700a17d2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a17d4: e034         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0x68
;                 retVal = CSL_bcdmaChanOpDecChanStats( pCfg, chanType, chanIdx, pOpData );
700a17d6: 9807         	ldr	r0, [sp, #0x1c]
700a17d8: 9905         	ldr	r1, [sp, #0x14]
700a17da: 9a04         	ldr	r2, [sp, #0x10]
700a17dc: 9b0a         	ldr	r3, [sp, #0x28]
700a17de: f003 f82f    	bl	0x700a4840 <CSL_bcdmaChanOpDecChanStats> @ imm = #0x305e
700a17e2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a17e4: e02c         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0x58
;                 retVal = CSL_bcdmaChanOpAccessRemotePeerReg( pCfg, chanType, chanIdx, pOpData, (bool)true );
700a17e6: 9807         	ldr	r0, [sp, #0x1c]
700a17e8: 9905         	ldr	r1, [sp, #0x14]
700a17ea: 9a04         	ldr	r2, [sp, #0x10]
700a17ec: 9b0a         	ldr	r3, [sp, #0x28]
700a17ee: 46ee         	mov	lr, sp
700a17f0: f04f 0c01    	mov.w	r12, #0x1
700a17f4: f8ce c000    	str.w	r12, [lr]
700a17f8: f005 fd5a    	bl	0x700a72b0 <CSL_bcdmaChanOpAccessRemotePeerReg> @ imm = #0x5ab4
700a17fc: 9003         	str	r0, [sp, #0xc]
;                 break;
700a17fe: e01f         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0x3e
;                 retVal = CSL_bcdmaChanOpAccessRemotePeerReg( pCfg, chanType, chanIdx, pOpData, (bool)false );
700a1800: 9807         	ldr	r0, [sp, #0x1c]
700a1802: 9905         	ldr	r1, [sp, #0x14]
700a1804: 9a04         	ldr	r2, [sp, #0x10]
700a1806: 9b0a         	ldr	r3, [sp, #0x28]
700a1808: 46ee         	mov	lr, sp
700a180a: f04f 0c00    	mov.w	r12, #0x0
700a180e: f8ce c000    	str.w	r12, [lr]
700a1812: f005 fd4d    	bl	0x700a72b0 <CSL_bcdmaChanOpAccessRemotePeerReg> @ imm = #0x5a9a
700a1816: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1818: e012         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0x24
;                 retVal = CSL_bcdmaChanOpSetBurstSize( pCfg, chanType, chanIdx, pOpData );
700a181a: 9807         	ldr	r0, [sp, #0x1c]
700a181c: 9905         	ldr	r1, [sp, #0x14]
700a181e: 9a04         	ldr	r2, [sp, #0x10]
700a1820: 9b0a         	ldr	r3, [sp, #0x28]
700a1822: f005 f8cd    	bl	0x700a69c0 <CSL_bcdmaChanOpSetBurstSize> @ imm = #0x519a
700a1826: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1828: e00a         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0x14
;                 retVal = CSL_bcdmaChanOpClearError( pCfg, chanType, chanIdx );
700a182a: 9807         	ldr	r0, [sp, #0x1c]
700a182c: 9905         	ldr	r1, [sp, #0x14]
700a182e: 9a04         	ldr	r2, [sp, #0x10]
700a1830: f009 fa3e    	bl	0x700aacb0 <CSL_bcdmaChanOpClearError> @ imm = #0x947c
700a1834: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1836: e003         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #0x6
700a1838: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a183c: 9003         	str	r0, [sp, #0xc]
;                 break;
700a183e: e7ff         	b	0x700a1840 <CSL_bcdmaChanOp+0x160> @ imm = #-0x2
700a1840: e7ff         	b	0x700a1842 <CSL_bcdmaChanOp+0x162> @ imm = #-0x2
;     return retVal;
700a1842: 9803         	ldr	r0, [sp, #0xc]
700a1844: b008         	add	sp, #0x20
700a1846: bd80         	pop	{r7, pc}
		...

700a1850 <Udma_chOpen>:
; {
700a1850: b580         	push	{r7, lr}
700a1852: b08a         	sub	sp, #0x28
700a1854: 9009         	str	r0, [sp, #0x24]
700a1856: 9108         	str	r1, [sp, #0x20]
700a1858: 9207         	str	r2, [sp, #0x1c]
700a185a: 9306         	str	r3, [sp, #0x18]
700a185c: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK, tempRetVal;
700a185e: 9005         	str	r0, [sp, #0x14]
;     uint32_t            allocDone = (uint32_t) FALSE;
700a1860: 9003         	str	r0, [sp, #0xc]
;     Udma_DrvHandleInt   drvHandleInt = (Udma_DrvHandleInt) drvHandle;
700a1862: 9809         	ldr	r0, [sp, #0x24]
700a1864: 9001         	str	r0, [sp, #0x4]
;     if((drvHandleInt == NULL_PTR) || (NULL_PTR == chHandle) || (NULL_PTR == chPrms))
700a1866: 9801         	ldr	r0, [sp, #0x4]
700a1868: b130         	cbz	r0, 0x700a1878 <Udma_chOpen+0x28> @ imm = #0xc
700a186a: e7ff         	b	0x700a186c <Udma_chOpen+0x1c> @ imm = #-0x2
700a186c: 9808         	ldr	r0, [sp, #0x20]
700a186e: b118         	cbz	r0, 0x700a1878 <Udma_chOpen+0x28> @ imm = #0x6
700a1870: e7ff         	b	0x700a1872 <Udma_chOpen+0x22> @ imm = #-0x2
700a1872: 9806         	ldr	r0, [sp, #0x18]
700a1874: b920         	cbnz	r0, 0x700a1880 <Udma_chOpen+0x30> @ imm = #0x8
700a1876: e7ff         	b	0x700a1878 <Udma_chOpen+0x28> @ imm = #-0x2
700a1878: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a187c: 9005         	str	r0, [sp, #0x14]
;     }
700a187e: e7ff         	b	0x700a1880 <Udma_chOpen+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1880: 9805         	ldr	r0, [sp, #0x14]
700a1882: b978         	cbnz	r0, 0x700a18a4 <Udma_chOpen+0x54> @ imm = #0x1e
700a1884: e7ff         	b	0x700a1886 <Udma_chOpen+0x36> @ imm = #-0x2
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
700a1886: 9801         	ldr	r0, [sp, #0x4]
700a1888: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a188c: f64a 31cd    	movw	r1, #0xabcd
700a1890: f6ca 31dc    	movt	r1, #0xabdc
700a1894: 4288         	cmp	r0, r1
700a1896: d004         	beq	0x700a18a2 <Udma_chOpen+0x52> @ imm = #0x8
700a1898: e7ff         	b	0x700a189a <Udma_chOpen+0x4a> @ imm = #-0x2
700a189a: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a189e: 9005         	str	r0, [sp, #0x14]
;         }
700a18a0: e7ff         	b	0x700a18a2 <Udma_chOpen+0x52> @ imm = #-0x2
;     }
700a18a2: e7ff         	b	0x700a18a4 <Udma_chOpen+0x54> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a18a4: 9805         	ldr	r0, [sp, #0x14]
700a18a6: b938         	cbnz	r0, 0x700a18b8 <Udma_chOpen+0x68> @ imm = #0xe
700a18a8: e7ff         	b	0x700a18aa <Udma_chOpen+0x5a> @ imm = #-0x2
;         retVal = Udma_chCheckParams(drvHandleInt, chType, chPrms);
700a18aa: 9801         	ldr	r0, [sp, #0x4]
700a18ac: 9907         	ldr	r1, [sp, #0x1c]
700a18ae: 9a06         	ldr	r2, [sp, #0x18]
700a18b0: f006 f916    	bl	0x700a7ae0 <Udma_chCheckParams> @ imm = #0x622c
700a18b4: 9005         	str	r0, [sp, #0x14]
;     }
700a18b6: e7ff         	b	0x700a18b8 <Udma_chOpen+0x68> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a18b8: 9805         	ldr	r0, [sp, #0x14]
700a18ba: 2800         	cmp	r0, #0x0
700a18bc: d145         	bne	0x700a194a <Udma_chOpen+0xfa> @ imm = #0x8a
700a18be: e7ff         	b	0x700a18c0 <Udma_chOpen+0x70> @ imm = #-0x2
;         chHandleInt = (Udma_ChHandleInt) chHandle;
700a18c0: 9808         	ldr	r0, [sp, #0x20]
700a18c2: 9002         	str	r0, [sp, #0x8]
;         (void) memset(chHandleInt, 0, sizeof(Udma_ChObject));
700a18c4: 9802         	ldr	r0, [sp, #0x8]
700a18c6: f44f 7116    	mov.w	r1, #0x258
700a18ca: f7f9 ebe4    	blx	0x7009b094 <__aeabi_memclr8> @ imm = #-0x6838
;         (void) memcpy(&chHandleInt->chPrms, chPrms, sizeof(Udma_ChPrms));
700a18ce: 9802         	ldr	r0, [sp, #0x8]
700a18d0: 3004         	adds	r0, #0x4
700a18d2: 9906         	ldr	r1, [sp, #0x18]
700a18d4: 2264         	movs	r2, #0x64
700a18d6: f7f8 ebc2    	blx	0x7009a05c <__aeabi_memcpy8> @ imm = #-0x787c
;         chHandleInt->chType            = chType;
700a18da: 9807         	ldr	r0, [sp, #0x1c]
700a18dc: 9902         	ldr	r1, [sp, #0x8]
700a18de: 6008         	str	r0, [r1]
;         chHandleInt->drvHandle         = drvHandleInt;
700a18e0: 9801         	ldr	r0, [sp, #0x4]
700a18e2: 9902         	ldr	r1, [sp, #0x8]
700a18e4: 6688         	str	r0, [r1, #0x68]
;         chHandleInt->txChNum           = UDMA_DMA_CH_INVALID;
700a18e6: 9902         	ldr	r1, [sp, #0x8]
700a18e8: 2000         	movs	r0, #0x0
700a18ea: f6cf 70ff    	movt	r0, #0xffff
700a18ee: 66c8         	str	r0, [r1, #0x6c]
;         chHandleInt->rxChNum           = UDMA_DMA_CH_INVALID;
700a18f0: 9902         	ldr	r1, [sp, #0x8]
700a18f2: 6708         	str	r0, [r1, #0x70]
;         chHandleInt->extChNum          = UDMA_DMA_CH_INVALID;
700a18f4: 9902         	ldr	r1, [sp, #0x8]
700a18f6: 6748         	str	r0, [r1, #0x74]
;         chHandleInt->pdmaChNum         = UDMA_DMA_CH_INVALID;
700a18f8: 9902         	ldr	r1, [sp, #0x8]
700a18fa: 6788         	str	r0, [r1, #0x78]
;         chHandleInt->peerThreadId      = UDMA_THREAD_ID_INVALID;
700a18fc: 9902         	ldr	r1, [sp, #0x8]
700a18fe: 2004         	movs	r0, #0x4
700a1900: f6cf 70ff    	movt	r0, #0xffff
700a1904: 67c8         	str	r0, [r1, #0x7c]
;         chHandleInt->fqRing            = (Udma_RingHandleInt) NULL_PTR;
700a1906: 9902         	ldr	r1, [sp, #0x8]
700a1908: 2000         	movs	r0, #0x0
700a190a: 9000         	str	r0, [sp]
700a190c: f8c1 0080    	str.w	r0, [r1, #0x80]
;         chHandleInt->cqRing            = (Udma_RingHandleInt) NULL_PTR;
700a1910: 9902         	ldr	r1, [sp, #0x8]
700a1912: f8c1 0084    	str.w	r0, [r1, #0x84]
;         chHandleInt->tdCqRing          = (Udma_RingHandleInt) NULL_PTR;
700a1916: 9902         	ldr	r1, [sp, #0x8]
700a1918: f8c1 0088    	str.w	r0, [r1, #0x88]
;         UdmaChTxPrms_init(&chHandleInt->txPrms, chType);
700a191c: 9802         	ldr	r0, [sp, #0x8]
700a191e: f500 70f2    	add.w	r0, r0, #0x1e4
700a1922: 9907         	ldr	r1, [sp, #0x1c]
700a1924: f006 fa94    	bl	0x700a7e50 <UdmaChTxPrms_init> @ imm = #0x6528
;         UdmaChRxPrms_init(&chHandleInt->rxPrms, chType);
700a1928: 9802         	ldr	r0, [sp, #0x8]
700a192a: f500 70fc    	add.w	r0, r0, #0x1f8
700a192e: 9907         	ldr	r1, [sp, #0x1c]
700a1930: f006 fa36    	bl	0x700a7da0 <UdmaChRxPrms_init> @ imm = #0x646c
;         Udma_chInitRegs(chHandleInt);
700a1934: 9802         	ldr	r0, [sp, #0x8]
700a1936: f00b fa43    	bl	0x700acdc0 <Udma_chInitRegs> @ imm = #0xb486
700a193a: 9800         	ldr	r0, [sp]
;         chHandleInt->chOesAllocDone    = FALSE;
700a193c: 9902         	ldr	r1, [sp, #0x8]
700a193e: f8c1 0248    	str.w	r0, [r1, #0x248]
;         chHandleInt->trigger           = CSL_UDMAP_TR_FLAGS_TRIGGER_NONE;
700a1942: 9902         	ldr	r1, [sp, #0x8]
700a1944: f8c1 024c    	str.w	r0, [r1, #0x24c]
;     }
700a1948: e7ff         	b	0x700a194a <Udma_chOpen+0xfa> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a194a: 9805         	ldr	r0, [sp, #0x14]
700a194c: b960         	cbnz	r0, 0x700a1968 <Udma_chOpen+0x118> @ imm = #0x18
700a194e: e7ff         	b	0x700a1950 <Udma_chOpen+0x100> @ imm = #-0x2
;         retVal = Udma_chAllocResource(chHandleInt);
700a1950: 9802         	ldr	r0, [sp, #0x8]
700a1952: f7fa fa8d    	bl	0x7009be70 <Udma_chAllocResource> @ imm = #-0x5ae6
700a1956: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK == retVal)
700a1958: 9805         	ldr	r0, [sp, #0x14]
700a195a: b918         	cbnz	r0, 0x700a1964 <Udma_chOpen+0x114> @ imm = #0x6
700a195c: e7ff         	b	0x700a195e <Udma_chOpen+0x10e> @ imm = #-0x2
700a195e: 2001         	movs	r0, #0x1
;             allocDone = (uint32_t) TRUE;
700a1960: 9003         	str	r0, [sp, #0xc]
;         }
700a1962: e000         	b	0x700a1966 <Udma_chOpen+0x116> @ imm = #0x0
700a1964: e7ff         	b	0x700a1966 <Udma_chOpen+0x116> @ imm = #-0x2
;     }
700a1966: e7ff         	b	0x700a1968 <Udma_chOpen+0x118> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1968: 9805         	ldr	r0, [sp, #0x14]
700a196a: b948         	cbnz	r0, 0x700a1980 <Udma_chOpen+0x130> @ imm = #0x12
700a196c: e7ff         	b	0x700a196e <Udma_chOpen+0x11e> @ imm = #-0x2
;         retVal = Udma_chPair(chHandleInt);
700a196e: 9802         	ldr	r0, [sp, #0x8]
700a1970: f008 fe4e    	bl	0x700aa610 <Udma_chPair> @ imm = #0x8c9c
700a1974: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK != retVal)
700a1976: 9805         	ldr	r0, [sp, #0x14]
700a1978: b108         	cbz	r0, 0x700a197e <Udma_chOpen+0x12e> @ imm = #0x2
700a197a: e7ff         	b	0x700a197c <Udma_chOpen+0x12c> @ imm = #-0x2
;         }
700a197c: e7ff         	b	0x700a197e <Udma_chOpen+0x12e> @ imm = #-0x2
;     }
700a197e: e7ff         	b	0x700a1980 <Udma_chOpen+0x130> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1980: 9805         	ldr	r0, [sp, #0x14]
700a1982: b940         	cbnz	r0, 0x700a1996 <Udma_chOpen+0x146> @ imm = #0x10
700a1984: e7ff         	b	0x700a1986 <Udma_chOpen+0x136> @ imm = #-0x2
;         chHandleInt->chInitDone = UDMA_INIT_DONE;
700a1986: 9902         	ldr	r1, [sp, #0x8]
700a1988: f64a 30cd    	movw	r0, #0xabcd
700a198c: f6ca 30dc    	movt	r0, #0xabdc
700a1990: f8c1 0244    	str.w	r0, [r1, #0x244]
;     }
700a1994: e00d         	b	0x700a19b2 <Udma_chOpen+0x162> @ imm = #0x1a
;         if(((uint32_t) TRUE) == allocDone)
700a1996: 9803         	ldr	r0, [sp, #0xc]
700a1998: 2801         	cmp	r0, #0x1
700a199a: d109         	bne	0x700a19b0 <Udma_chOpen+0x160> @ imm = #0x12
700a199c: e7ff         	b	0x700a199e <Udma_chOpen+0x14e> @ imm = #-0x2
;             tempRetVal = Udma_chFreeResource(chHandleInt);
700a199e: 9802         	ldr	r0, [sp, #0x8]
700a19a0: f7fd f896    	bl	0x7009ead0 <Udma_chFreeResource> @ imm = #-0x2ed4
700a19a4: 9004         	str	r0, [sp, #0x10]
;             if(UDMA_SOK != tempRetVal)
700a19a6: 9804         	ldr	r0, [sp, #0x10]
700a19a8: b108         	cbz	r0, 0x700a19ae <Udma_chOpen+0x15e> @ imm = #0x2
700a19aa: e7ff         	b	0x700a19ac <Udma_chOpen+0x15c> @ imm = #-0x2
;             }
700a19ac: e7ff         	b	0x700a19ae <Udma_chOpen+0x15e> @ imm = #-0x2
;         }
700a19ae: e7ff         	b	0x700a19b0 <Udma_chOpen+0x160> @ imm = #-0x2
700a19b0: e7ff         	b	0x700a19b2 <Udma_chOpen+0x162> @ imm = #-0x2
;     return (retVal);
700a19b2: 9805         	ldr	r0, [sp, #0x14]
700a19b4: b00a         	add	sp, #0x28
700a19b6: bd80         	pop	{r7, pc}
		...

700a19c0 <Udma_rmAllocMappedRxCh>:
; {
700a19c0: b580         	push	{r7, lr}
700a19c2: b08a         	sub	sp, #0x28
700a19c4: 9009         	str	r0, [sp, #0x24]
700a19c6: 9108         	str	r1, [sp, #0x20]
700a19c8: 9207         	str	r2, [sp, #0x1c]
700a19ca: 2000         	movs	r0, #0x0
700a19cc: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a19d0: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a19d2: 9808         	ldr	r0, [sp, #0x20]
700a19d4: f500 70ea    	add.w	r0, r0, #0x1d4
700a19d8: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a19da: 9808         	ldr	r0, [sp, #0x20]
700a19dc: f500 609f    	add.w	r0, r0, #0x4f8
700a19e0: f04f 31ff    	mov.w	r1, #0xffffffff
700a19e4: f008 fdcc    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x8b98
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a19e8: 9809         	ldr	r0, [sp, #0x24]
700a19ea: 2101         	movs	r1, #0x1
700a19ec: f6cf 71ff    	movt	r1, #0xffff
700a19f0: 4288         	cmp	r0, r1
700a19f2: d142         	bne	0x700a1a7a <Udma_rmAllocMappedRxCh+0xba> @ imm = #0x84
700a19f4: e7ff         	b	0x700a19f6 <Udma_rmAllocMappedRxCh+0x36> @ imm = #-0x2
700a19f6: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numMappedRxCh[mappedChGrp]; i++)
700a19f8: 9005         	str	r0, [sp, #0x14]
700a19fa: e7ff         	b	0x700a19fc <Udma_rmAllocMappedRxCh+0x3c> @ imm = #-0x2
700a19fc: 9805         	ldr	r0, [sp, #0x14]
700a19fe: 9901         	ldr	r1, [sp, #0x4]
700a1a00: 9a07         	ldr	r2, [sp, #0x1c]
700a1a02: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1a06: 6f89         	ldr	r1, [r1, #0x78]
700a1a08: 4288         	cmp	r0, r1
700a1a0a: d235         	bhs	0x700a1a78 <Udma_rmAllocMappedRxCh+0xb8> @ imm = #0x6a
700a1a0c: e7ff         	b	0x700a1a0e <Udma_rmAllocMappedRxCh+0x4e> @ imm = #-0x2
;             offset = i >> 5U;
700a1a0e: 9805         	ldr	r0, [sp, #0x14]
700a1a10: 0940         	lsrs	r0, r0, #0x5
700a1a12: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1a14: 9805         	ldr	r0, [sp, #0x14]
700a1a16: 9904         	ldr	r1, [sp, #0x10]
700a1a18: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1a1c: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1a1e: 9903         	ldr	r1, [sp, #0xc]
700a1a20: 2001         	movs	r0, #0x1
700a1a22: 4088         	lsls	r0, r1
700a1a24: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedRxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1a26: 9808         	ldr	r0, [sp, #0x20]
700a1a28: 9907         	ldr	r1, [sp, #0x1c]
700a1a2a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1a2e: 9904         	ldr	r1, [sp, #0x10]
700a1a30: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1a34: f8d0 0334    	ldr.w	r0, [r0, #0x334]
700a1a38: 9902         	ldr	r1, [sp, #0x8]
700a1a3a: 4008         	ands	r0, r1
700a1a3c: 4288         	cmp	r0, r1
700a1a3e: d116         	bne	0x700a1a6e <Udma_rmAllocMappedRxCh+0xae> @ imm = #0x2c
700a1a40: e7ff         	b	0x700a1a42 <Udma_rmAllocMappedRxCh+0x82> @ imm = #-0x2
;                 drvHandle->mappedRxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1a42: 9a02         	ldr	r2, [sp, #0x8]
700a1a44: 9808         	ldr	r0, [sp, #0x20]
700a1a46: 9907         	ldr	r1, [sp, #0x1c]
700a1a48: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1a4c: 9904         	ldr	r1, [sp, #0x10]
700a1a4e: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1a52: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700a1a56: 4390         	bics	r0, r2
700a1a58: f8c1 0334    	str.w	r0, [r1, #0x334]
;                 chNum = i + rmInitPrms->startMappedRxCh[mappedChGrp];  /* Add start offset */
700a1a5c: 9805         	ldr	r0, [sp, #0x14]
700a1a5e: 9901         	ldr	r1, [sp, #0x4]
700a1a60: 9a07         	ldr	r2, [sp, #0x1c]
700a1a62: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1a66: 6e89         	ldr	r1, [r1, #0x68]
700a1a68: 4408         	add	r0, r1
700a1a6a: 9006         	str	r0, [sp, #0x18]
;                 break;
700a1a6c: e004         	b	0x700a1a78 <Udma_rmAllocMappedRxCh+0xb8> @ imm = #0x8
;         }
700a1a6e: e7ff         	b	0x700a1a70 <Udma_rmAllocMappedRxCh+0xb0> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numMappedRxCh[mappedChGrp]; i++)
700a1a70: 9805         	ldr	r0, [sp, #0x14]
700a1a72: 3001         	adds	r0, #0x1
700a1a74: 9005         	str	r0, [sp, #0x14]
700a1a76: e7c1         	b	0x700a19fc <Udma_rmAllocMappedRxCh+0x3c> @ imm = #-0x7e
;     }
700a1a78: e047         	b	0x700a1b0a <Udma_rmAllocMappedRxCh+0x14a> @ imm = #0x8e
;         if((preferredChNum >= rmInitPrms->startMappedRxCh[mappedChGrp]) &&
700a1a7a: 9809         	ldr	r0, [sp, #0x24]
700a1a7c: 9901         	ldr	r1, [sp, #0x4]
700a1a7e: 9a07         	ldr	r2, [sp, #0x1c]
700a1a80: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1a84: 6e89         	ldr	r1, [r1, #0x68]
700a1a86: 4288         	cmp	r0, r1
700a1a88: d33e         	blo	0x700a1b08 <Udma_rmAllocMappedRxCh+0x148> @ imm = #0x7c
700a1a8a: e7ff         	b	0x700a1a8c <Udma_rmAllocMappedRxCh+0xcc> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startMappedRxCh[mappedChGrp] + rmInitPrms->numMappedRxCh[mappedChGrp])))
700a1a8c: 9809         	ldr	r0, [sp, #0x24]
700a1a8e: 9901         	ldr	r1, [sp, #0x4]
700a1a90: 9a07         	ldr	r2, [sp, #0x1c]
700a1a92: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a1a96: 6e91         	ldr	r1, [r2, #0x68]
700a1a98: 6f92         	ldr	r2, [r2, #0x78]
700a1a9a: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startMappedRxCh[mappedChGrp]) &&
700a1a9c: 4288         	cmp	r0, r1
700a1a9e: d233         	bhs	0x700a1b08 <Udma_rmAllocMappedRxCh+0x148> @ imm = #0x66
700a1aa0: e7ff         	b	0x700a1aa2 <Udma_rmAllocMappedRxCh+0xe2> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startMappedRxCh[mappedChGrp];
700a1aa2: 9809         	ldr	r0, [sp, #0x24]
700a1aa4: 9901         	ldr	r1, [sp, #0x4]
700a1aa6: 9a07         	ldr	r2, [sp, #0x1c]
700a1aa8: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1aac: 6e89         	ldr	r1, [r1, #0x68]
700a1aae: 1a40         	subs	r0, r0, r1
700a1ab0: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1ab2: 9805         	ldr	r0, [sp, #0x14]
700a1ab4: 0940         	lsrs	r0, r0, #0x5
700a1ab6: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1ab8: 9805         	ldr	r0, [sp, #0x14]
700a1aba: 9904         	ldr	r1, [sp, #0x10]
700a1abc: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1ac0: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1ac2: 9903         	ldr	r1, [sp, #0xc]
700a1ac4: 2001         	movs	r0, #0x1
700a1ac6: 4088         	lsls	r0, r1
700a1ac8: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedRxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1aca: 9808         	ldr	r0, [sp, #0x20]
700a1acc: 9907         	ldr	r1, [sp, #0x1c]
700a1ace: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1ad2: 9904         	ldr	r1, [sp, #0x10]
700a1ad4: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1ad8: f8d0 0334    	ldr.w	r0, [r0, #0x334]
700a1adc: 9902         	ldr	r1, [sp, #0x8]
700a1ade: 4008         	ands	r0, r1
700a1ae0: 4288         	cmp	r0, r1
700a1ae2: d110         	bne	0x700a1b06 <Udma_rmAllocMappedRxCh+0x146> @ imm = #0x20
700a1ae4: e7ff         	b	0x700a1ae6 <Udma_rmAllocMappedRxCh+0x126> @ imm = #-0x2
;                 drvHandle->mappedRxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1ae6: 9a02         	ldr	r2, [sp, #0x8]
700a1ae8: 9808         	ldr	r0, [sp, #0x20]
700a1aea: 9907         	ldr	r1, [sp, #0x1c]
700a1aec: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1af0: 9904         	ldr	r1, [sp, #0x10]
700a1af2: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1af6: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700a1afa: 4390         	bics	r0, r2
700a1afc: f8c1 0334    	str.w	r0, [r1, #0x334]
;                 chNum = preferredChNum;
700a1b00: 9809         	ldr	r0, [sp, #0x24]
700a1b02: 9006         	str	r0, [sp, #0x18]
;             }
700a1b04: e7ff         	b	0x700a1b06 <Udma_rmAllocMappedRxCh+0x146> @ imm = #-0x2
;         }
700a1b06: e7ff         	b	0x700a1b08 <Udma_rmAllocMappedRxCh+0x148> @ imm = #-0x2
700a1b08: e7ff         	b	0x700a1b0a <Udma_rmAllocMappedRxCh+0x14a> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1b0a: 9808         	ldr	r0, [sp, #0x20]
700a1b0c: f500 609f    	add.w	r0, r0, #0x4f8
700a1b10: f00a f8c6    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0xa18c
;     return (chNum);
700a1b14: 9806         	ldr	r0, [sp, #0x18]
700a1b16: b00a         	add	sp, #0x28
700a1b18: bd80         	pop	{r7, pc}
700a1b1a: 0000         	movs	r0, r0
700a1b1c: 0000         	movs	r0, r0
700a1b1e: 0000         	movs	r0, r0

700a1b20 <Udma_rmAllocMappedTxCh>:
; {
700a1b20: b580         	push	{r7, lr}
700a1b22: b08a         	sub	sp, #0x28
700a1b24: 9009         	str	r0, [sp, #0x24]
700a1b26: 9108         	str	r1, [sp, #0x20]
700a1b28: 9207         	str	r2, [sp, #0x1c]
700a1b2a: 2000         	movs	r0, #0x0
700a1b2c: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1b30: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1b32: 9808         	ldr	r0, [sp, #0x20]
700a1b34: f500 70ea    	add.w	r0, r0, #0x1d4
700a1b38: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1b3a: 9808         	ldr	r0, [sp, #0x20]
700a1b3c: f500 609f    	add.w	r0, r0, #0x4f8
700a1b40: f04f 31ff    	mov.w	r1, #0xffffffff
700a1b44: f008 fd1c    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x8a38
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1b48: 9809         	ldr	r0, [sp, #0x24]
700a1b4a: 2101         	movs	r1, #0x1
700a1b4c: f6cf 71ff    	movt	r1, #0xffff
700a1b50: 4288         	cmp	r0, r1
700a1b52: d142         	bne	0x700a1bda <Udma_rmAllocMappedTxCh+0xba> @ imm = #0x84
700a1b54: e7ff         	b	0x700a1b56 <Udma_rmAllocMappedTxCh+0x36> @ imm = #-0x2
700a1b56: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numMappedTxCh[mappedChGrp]; i++)
700a1b58: 9005         	str	r0, [sp, #0x14]
700a1b5a: e7ff         	b	0x700a1b5c <Udma_rmAllocMappedTxCh+0x3c> @ imm = #-0x2
700a1b5c: 9805         	ldr	r0, [sp, #0x14]
700a1b5e: 9901         	ldr	r1, [sp, #0x4]
700a1b60: 9a07         	ldr	r2, [sp, #0x1c]
700a1b62: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1b66: 6d89         	ldr	r1, [r1, #0x58]
700a1b68: 4288         	cmp	r0, r1
700a1b6a: d235         	bhs	0x700a1bd8 <Udma_rmAllocMappedTxCh+0xb8> @ imm = #0x6a
700a1b6c: e7ff         	b	0x700a1b6e <Udma_rmAllocMappedTxCh+0x4e> @ imm = #-0x2
;             offset = i >> 5U;
700a1b6e: 9805         	ldr	r0, [sp, #0x14]
700a1b70: 0940         	lsrs	r0, r0, #0x5
700a1b72: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1b74: 9805         	ldr	r0, [sp, #0x14]
700a1b76: 9904         	ldr	r1, [sp, #0x10]
700a1b78: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1b7c: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1b7e: 9903         	ldr	r1, [sp, #0xc]
700a1b80: 2001         	movs	r0, #0x1
700a1b82: 4088         	lsls	r0, r1
700a1b84: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedTxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1b86: 9808         	ldr	r0, [sp, #0x20]
700a1b88: 9907         	ldr	r1, [sp, #0x1c]
700a1b8a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1b8e: 9904         	ldr	r1, [sp, #0x10]
700a1b90: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1b94: f8d0 0324    	ldr.w	r0, [r0, #0x324]
700a1b98: 9902         	ldr	r1, [sp, #0x8]
700a1b9a: 4008         	ands	r0, r1
700a1b9c: 4288         	cmp	r0, r1
700a1b9e: d116         	bne	0x700a1bce <Udma_rmAllocMappedTxCh+0xae> @ imm = #0x2c
700a1ba0: e7ff         	b	0x700a1ba2 <Udma_rmAllocMappedTxCh+0x82> @ imm = #-0x2
;                 drvHandle->mappedTxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1ba2: 9a02         	ldr	r2, [sp, #0x8]
700a1ba4: 9808         	ldr	r0, [sp, #0x20]
700a1ba6: 9907         	ldr	r1, [sp, #0x1c]
700a1ba8: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1bac: 9904         	ldr	r1, [sp, #0x10]
700a1bae: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1bb2: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a1bb6: 4390         	bics	r0, r2
700a1bb8: f8c1 0324    	str.w	r0, [r1, #0x324]
;                 chNum = i + rmInitPrms->startMappedTxCh[mappedChGrp];  /* Add start offset */
700a1bbc: 9805         	ldr	r0, [sp, #0x14]
700a1bbe: 9901         	ldr	r1, [sp, #0x4]
700a1bc0: 9a07         	ldr	r2, [sp, #0x1c]
700a1bc2: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1bc6: 6c89         	ldr	r1, [r1, #0x48]
700a1bc8: 4408         	add	r0, r1
700a1bca: 9006         	str	r0, [sp, #0x18]
;                 break;
700a1bcc: e004         	b	0x700a1bd8 <Udma_rmAllocMappedTxCh+0xb8> @ imm = #0x8
;         }
700a1bce: e7ff         	b	0x700a1bd0 <Udma_rmAllocMappedTxCh+0xb0> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numMappedTxCh[mappedChGrp]; i++)
700a1bd0: 9805         	ldr	r0, [sp, #0x14]
700a1bd2: 3001         	adds	r0, #0x1
700a1bd4: 9005         	str	r0, [sp, #0x14]
700a1bd6: e7c1         	b	0x700a1b5c <Udma_rmAllocMappedTxCh+0x3c> @ imm = #-0x7e
;     }
700a1bd8: e047         	b	0x700a1c6a <Udma_rmAllocMappedTxCh+0x14a> @ imm = #0x8e
;         if((preferredChNum >= rmInitPrms->startMappedTxCh[mappedChGrp]) &&
700a1bda: 9809         	ldr	r0, [sp, #0x24]
700a1bdc: 9901         	ldr	r1, [sp, #0x4]
700a1bde: 9a07         	ldr	r2, [sp, #0x1c]
700a1be0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1be4: 6c89         	ldr	r1, [r1, #0x48]
700a1be6: 4288         	cmp	r0, r1
700a1be8: d33e         	blo	0x700a1c68 <Udma_rmAllocMappedTxCh+0x148> @ imm = #0x7c
700a1bea: e7ff         	b	0x700a1bec <Udma_rmAllocMappedTxCh+0xcc> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startMappedTxCh[mappedChGrp] + rmInitPrms->numMappedTxCh[mappedChGrp])))
700a1bec: 9809         	ldr	r0, [sp, #0x24]
700a1bee: 9901         	ldr	r1, [sp, #0x4]
700a1bf0: 9a07         	ldr	r2, [sp, #0x1c]
700a1bf2: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a1bf6: 6c91         	ldr	r1, [r2, #0x48]
700a1bf8: 6d92         	ldr	r2, [r2, #0x58]
700a1bfa: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startMappedTxCh[mappedChGrp]) &&
700a1bfc: 4288         	cmp	r0, r1
700a1bfe: d233         	bhs	0x700a1c68 <Udma_rmAllocMappedTxCh+0x148> @ imm = #0x66
700a1c00: e7ff         	b	0x700a1c02 <Udma_rmAllocMappedTxCh+0xe2> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startMappedTxCh[mappedChGrp];
700a1c02: 9809         	ldr	r0, [sp, #0x24]
700a1c04: 9901         	ldr	r1, [sp, #0x4]
700a1c06: 9a07         	ldr	r2, [sp, #0x1c]
700a1c08: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1c0c: 6c89         	ldr	r1, [r1, #0x48]
700a1c0e: 1a40         	subs	r0, r0, r1
700a1c10: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1c12: 9805         	ldr	r0, [sp, #0x14]
700a1c14: 0940         	lsrs	r0, r0, #0x5
700a1c16: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1c18: 9805         	ldr	r0, [sp, #0x14]
700a1c1a: 9904         	ldr	r1, [sp, #0x10]
700a1c1c: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1c20: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1c22: 9903         	ldr	r1, [sp, #0xc]
700a1c24: 2001         	movs	r0, #0x1
700a1c26: 4088         	lsls	r0, r1
700a1c28: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedTxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1c2a: 9808         	ldr	r0, [sp, #0x20]
700a1c2c: 9907         	ldr	r1, [sp, #0x1c]
700a1c2e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1c32: 9904         	ldr	r1, [sp, #0x10]
700a1c34: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1c38: f8d0 0324    	ldr.w	r0, [r0, #0x324]
700a1c3c: 9902         	ldr	r1, [sp, #0x8]
700a1c3e: 4008         	ands	r0, r1
700a1c40: 4288         	cmp	r0, r1
700a1c42: d110         	bne	0x700a1c66 <Udma_rmAllocMappedTxCh+0x146> @ imm = #0x20
700a1c44: e7ff         	b	0x700a1c46 <Udma_rmAllocMappedTxCh+0x126> @ imm = #-0x2
;                 drvHandle->mappedTxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1c46: 9a02         	ldr	r2, [sp, #0x8]
700a1c48: 9808         	ldr	r0, [sp, #0x20]
700a1c4a: 9907         	ldr	r1, [sp, #0x1c]
700a1c4c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1c50: 9904         	ldr	r1, [sp, #0x10]
700a1c52: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1c56: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a1c5a: 4390         	bics	r0, r2
700a1c5c: f8c1 0324    	str.w	r0, [r1, #0x324]
;                 chNum = preferredChNum;
700a1c60: 9809         	ldr	r0, [sp, #0x24]
700a1c62: 9006         	str	r0, [sp, #0x18]
;             }
700a1c64: e7ff         	b	0x700a1c66 <Udma_rmAllocMappedTxCh+0x146> @ imm = #-0x2
;         }
700a1c66: e7ff         	b	0x700a1c68 <Udma_rmAllocMappedTxCh+0x148> @ imm = #-0x2
700a1c68: e7ff         	b	0x700a1c6a <Udma_rmAllocMappedTxCh+0x14a> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1c6a: 9808         	ldr	r0, [sp, #0x20]
700a1c6c: f500 609f    	add.w	r0, r0, #0x4f8
700a1c70: f00a f816    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0xa02c
;     return (chNum);
700a1c74: 9806         	ldr	r0, [sp, #0x18]
700a1c76: b00a         	add	sp, #0x28
700a1c78: bd80         	pop	{r7, pc}
700a1c7a: 0000         	movs	r0, r0
700a1c7c: 0000         	movs	r0, r0
700a1c7e: 0000         	movs	r0, r0

700a1c80 <CSL_bcdmaChanOpGetChanStats>:
; {
700a1c80: b580         	push	{r7, lr}
700a1c82: b088         	sub	sp, #0x20
700a1c84: 9007         	str	r0, [sp, #0x1c]
700a1c86: 9106         	str	r1, [sp, #0x18]
700a1c88: 9205         	str	r2, [sp, #0x14]
700a1c8a: 9304         	str	r3, [sp, #0x10]
700a1c8c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a1c8e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a1c90: 9804         	ldr	r0, [sp, #0x10]
700a1c92: b920         	cbnz	r0, 0x700a1c9e <CSL_bcdmaChanOpGetChanStats+0x1e> @ imm = #0x8
700a1c94: e7ff         	b	0x700a1c96 <CSL_bcdmaChanOpGetChanStats+0x16> @ imm = #-0x2
700a1c96: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a1c9a: 9003         	str	r0, [sp, #0xc]
;     }
700a1c9c: e099         	b	0x700a1dd2 <CSL_bcdmaChanOpGetChanStats+0x152> @ imm = #0x132
;         CSL_BcdmaChanStats *pChanStats = (CSL_BcdmaChanStats *)pOpData;
700a1c9e: 9804         	ldr	r0, [sp, #0x10]
700a1ca0: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a1ca2: 9806         	ldr	r0, [sp, #0x18]
700a1ca4: 9001         	str	r0, [sp, #0x4]
700a1ca6: b140         	cbz	r0, 0x700a1cba <CSL_bcdmaChanOpGetChanStats+0x3a> @ imm = #0x10
700a1ca8: e7ff         	b	0x700a1caa <CSL_bcdmaChanOpGetChanStats+0x2a> @ imm = #-0x2
700a1caa: 9801         	ldr	r0, [sp, #0x4]
700a1cac: 2801         	cmp	r0, #0x1
700a1cae: d031         	beq	0x700a1d14 <CSL_bcdmaChanOpGetChanStats+0x94> @ imm = #0x62
700a1cb0: e7ff         	b	0x700a1cb2 <CSL_bcdmaChanOpGetChanStats+0x32> @ imm = #-0x2
700a1cb2: 9801         	ldr	r0, [sp, #0x4]
700a1cb4: 2802         	cmp	r0, #0x2
700a1cb6: d05a         	beq	0x700a1d6e <CSL_bcdmaChanOpGetChanStats+0xee> @ imm = #0xb4
700a1cb8: e086         	b	0x700a1dc8 <CSL_bcdmaChanOpGetChanStats+0x148> @ imm = #0x10c
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].PCNT );
700a1cba: 9807         	ldr	r0, [sp, #0x1c]
700a1cbc: 6880         	ldr	r0, [r0, #0x8]
700a1cbe: 9905         	ldr	r1, [sp, #0x14]
700a1cc0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1cc4: f500 6080    	add.w	r0, r0, #0x400
700a1cc8: f00d fe12    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0xdc24
700a1ccc: 9902         	ldr	r1, [sp, #0x8]
700a1cce: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].BCNT );
700a1cd0: 9807         	ldr	r0, [sp, #0x1c]
700a1cd2: 6880         	ldr	r0, [r0, #0x8]
700a1cd4: 9905         	ldr	r1, [sp, #0x14]
700a1cd6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1cda: f500 6081    	add.w	r0, r0, #0x408
700a1cde: f00d fe07    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0xdc0e
700a1ce2: 9902         	ldr	r1, [sp, #0x8]
700a1ce4: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].SBCNT );
700a1ce6: 9807         	ldr	r0, [sp, #0x1c]
700a1ce8: 6880         	ldr	r0, [r0, #0x8]
700a1cea: 9905         	ldr	r1, [sp, #0x14]
700a1cec: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1cf0: f500 6082    	add.w	r0, r0, #0x410
700a1cf4: f00d fdfc    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0xdbf8
700a1cf8: 9902         	ldr	r1, [sp, #0x8]
700a1cfa: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = (uint32_t)0U;
700a1cfc: 9902         	ldr	r1, [sp, #0x8]
700a1cfe: 2000         	movs	r0, #0x0
700a1d00: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = (uint32_t)0U;
700a1d02: 9902         	ldr	r1, [sp, #0x8]
700a1d04: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->txPayloadByteCnt;
700a1d06: 9902         	ldr	r1, [sp, #0x8]
700a1d08: 6848         	ldr	r0, [r1, #0x4]
700a1d0a: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->txStartedByteCnt;
700a1d0c: 9902         	ldr	r1, [sp, #0x8]
700a1d0e: 6888         	ldr	r0, [r1, #0x8]
700a1d10: 6188         	str	r0, [r1, #0x18]
;                 break;
700a1d12: e05d         	b	0x700a1dd0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0xba
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].PCNT );
700a1d14: 9807         	ldr	r0, [sp, #0x1c]
700a1d16: 6900         	ldr	r0, [r0, #0x10]
700a1d18: 9905         	ldr	r1, [sp, #0x14]
700a1d1a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1d1e: f500 6080    	add.w	r0, r0, #0x400
700a1d22: f00d fde5    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0xdbca
700a1d26: 9902         	ldr	r1, [sp, #0x8]
700a1d28: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].BCNT );
700a1d2a: 9807         	ldr	r0, [sp, #0x1c]
700a1d2c: 6900         	ldr	r0, [r0, #0x10]
700a1d2e: 9905         	ldr	r1, [sp, #0x14]
700a1d30: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1d34: f500 6081    	add.w	r0, r0, #0x408
700a1d38: f00d fdda    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0xdbb4
700a1d3c: 9902         	ldr	r1, [sp, #0x8]
700a1d3e: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].SBCNT );
700a1d40: 9807         	ldr	r0, [sp, #0x1c]
700a1d42: 6900         	ldr	r0, [r0, #0x10]
700a1d44: 9905         	ldr	r1, [sp, #0x14]
700a1d46: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1d4a: f500 6082    	add.w	r0, r0, #0x410
700a1d4e: f00d fdcf    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0xdb9e
700a1d52: 9902         	ldr	r1, [sp, #0x8]
700a1d54: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = (uint32_t)0U;
700a1d56: 9902         	ldr	r1, [sp, #0x8]
700a1d58: 2000         	movs	r0, #0x0
700a1d5a: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = (uint32_t)0U;
700a1d5c: 9902         	ldr	r1, [sp, #0x8]
700a1d5e: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->txPayloadByteCnt;
700a1d60: 9902         	ldr	r1, [sp, #0x8]
700a1d62: 6848         	ldr	r0, [r1, #0x4]
700a1d64: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->txStartedByteCnt;
700a1d66: 9902         	ldr	r1, [sp, #0x8]
700a1d68: 6888         	ldr	r0, [r1, #0x8]
700a1d6a: 6188         	str	r0, [r1, #0x18]
;                 break;
700a1d6c: e030         	b	0x700a1dd0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0x60
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].PCNT );
700a1d6e: 9807         	ldr	r0, [sp, #0x1c]
700a1d70: 6980         	ldr	r0, [r0, #0x18]
700a1d72: 9905         	ldr	r1, [sp, #0x14]
700a1d74: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1d78: f500 6080    	add.w	r0, r0, #0x400
700a1d7c: f00d fdb8    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0xdb70
700a1d80: 9902         	ldr	r1, [sp, #0x8]
700a1d82: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = (uint32_t)0U;
700a1d84: 9902         	ldr	r1, [sp, #0x8]
700a1d86: 2000         	movs	r0, #0x0
700a1d88: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = (uint32_t)0U;
700a1d8a: 9902         	ldr	r1, [sp, #0x8]
700a1d8c: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].BCNT );
700a1d8e: 9807         	ldr	r0, [sp, #0x1c]
700a1d90: 6980         	ldr	r0, [r0, #0x18]
700a1d92: 9905         	ldr	r1, [sp, #0x14]
700a1d94: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1d98: f500 6081    	add.w	r0, r0, #0x408
700a1d9c: f00d fda8    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0xdb50
700a1da0: 9902         	ldr	r1, [sp, #0x8]
700a1da2: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].SBCNT );
700a1da4: 9807         	ldr	r0, [sp, #0x1c]
700a1da6: 6980         	ldr	r0, [r0, #0x18]
700a1da8: 9905         	ldr	r1, [sp, #0x14]
700a1daa: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1dae: f500 6082    	add.w	r0, r0, #0x410
700a1db2: f00d fd9d    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0xdb3a
700a1db6: 9902         	ldr	r1, [sp, #0x8]
700a1db8: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->rxPayloadByteCnt;
700a1dba: 9902         	ldr	r1, [sp, #0x8]
700a1dbc: 68c8         	ldr	r0, [r1, #0xc]
700a1dbe: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->rxStartedByteCnt;
700a1dc0: 9902         	ldr	r1, [sp, #0x8]
700a1dc2: 6908         	ldr	r0, [r1, #0x10]
700a1dc4: 6188         	str	r0, [r1, #0x18]
;                 break;
700a1dc6: e003         	b	0x700a1dd0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0x6
700a1dc8: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a1dcc: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1dce: e7ff         	b	0x700a1dd0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #-0x2
700a1dd0: e7ff         	b	0x700a1dd2 <CSL_bcdmaChanOpGetChanStats+0x152> @ imm = #-0x2
;     return retVal;
700a1dd2: 9803         	ldr	r0, [sp, #0xc]
700a1dd4: b008         	add	sp, #0x20
700a1dd6: bd80         	pop	{r7, pc}
		...

700a1de0 <UART_lld_initDma>:
; {
700a1de0: b580         	push	{r7, lr}
700a1de2: b084         	sub	sp, #0x10
700a1de4: 9003         	str	r0, [sp, #0xc]
700a1de6: 2000         	movs	r0, #0x0
;     int32_t                status = UART_STATUS_SUCCESS;
700a1de8: 9002         	str	r0, [sp, #0x8]
;     if((hUart != NULL_PTR) && (hUart->hUartInit != NULL_PTR))
700a1dea: 9803         	ldr	r0, [sp, #0xc]
700a1dec: b168         	cbz	r0, 0x700a1e0a <UART_lld_initDma+0x2a> @ imm = #0x1a
700a1dee: e7ff         	b	0x700a1df0 <UART_lld_initDma+0x10> @ imm = #-0x2
700a1df0: 9803         	ldr	r0, [sp, #0xc]
700a1df2: 6840         	ldr	r0, [r0, #0x4]
700a1df4: b148         	cbz	r0, 0x700a1e0a <UART_lld_initDma+0x2a> @ imm = #0x12
700a1df6: e7ff         	b	0x700a1df8 <UART_lld_initDma+0x18> @ imm = #-0x2
;         if(hUart->state != UART_STATE_RESET)
700a1df8: 9803         	ldr	r0, [sp, #0xc]
700a1dfa: 6d40         	ldr	r0, [r0, #0x54]
700a1dfc: b120         	cbz	r0, 0x700a1e08 <UART_lld_initDma+0x28> @ imm = #0x8
700a1dfe: e7ff         	b	0x700a1e00 <UART_lld_initDma+0x20> @ imm = #-0x2
700a1e00: f06f 0004    	mvn	r0, #0x4
;             status = UART_TRANSFER_INVALID_STATE;
700a1e04: 9002         	str	r0, [sp, #0x8]
;         }
700a1e06: e7ff         	b	0x700a1e08 <UART_lld_initDma+0x28> @ imm = #-0x2
;     }
700a1e08: e003         	b	0x700a1e12 <UART_lld_initDma+0x32> @ imm = #0x6
700a1e0a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a1e0e: 9002         	str	r0, [sp, #0x8]
700a1e10: e7ff         	b	0x700a1e12 <UART_lld_initDma+0x32> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a1e12: 9802         	ldr	r0, [sp, #0x8]
700a1e14: 2800         	cmp	r0, #0x0
700a1e16: d170         	bne	0x700a1efa <UART_lld_initDma+0x11a> @ imm = #0xe0
700a1e18: e7ff         	b	0x700a1e1a <UART_lld_initDma+0x3a> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a1e1a: 9903         	ldr	r1, [sp, #0xc]
700a1e1c: 2002         	movs	r0, #0x2
700a1e1e: 6548         	str	r0, [r1, #0x54]
;         hUartInit = hUart->hUartInit;
700a1e20: 9803         	ldr	r0, [sp, #0xc]
700a1e22: 6840         	ldr	r0, [r0, #0x4]
700a1e24: 9001         	str	r0, [sp, #0x4]
;         hUart->lineStatusTimeout = hUartInit->clockP_usecToTick(UART_READ_LINE_STATUS_TIMEOUT_IN_US);
700a1e26: 9801         	ldr	r0, [sp, #0x4]
700a1e28: 6d82         	ldr	r2, [r0, #0x58]
700a1e2a: f244 2040    	movw	r0, #0x4240
700a1e2e: f2c0 000f    	movt	r0, #0xf
700a1e32: 2100         	movs	r1, #0x0
700a1e34: 9100         	str	r1, [sp]
700a1e36: 4790         	blx	r2
700a1e38: 9a00         	ldr	r2, [sp]
700a1e3a: 9903         	ldr	r1, [sp, #0xc]
700a1e3c: 66ca         	str	r2, [r1, #0x6c]
700a1e3e: 6688         	str	r0, [r1, #0x68]
;         status += UART_IsBaseAddrValid(hUart->baseAddr);
700a1e40: 9803         	ldr	r0, [sp, #0xc]
700a1e42: 6800         	ldr	r0, [r0]
700a1e44: f006 fbcc    	bl	0x700a85e0 <UART_IsBaseAddrValid> @ imm = #0x6798
700a1e48: 4601         	mov	r1, r0
700a1e4a: 9802         	ldr	r0, [sp, #0x8]
700a1e4c: 4408         	add	r0, r1
700a1e4e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->inputClkFreq);
700a1e50: 9801         	ldr	r0, [sp, #0x4]
700a1e52: 6800         	ldr	r0, [r0]
700a1e54: f00d fa1c    	bl	0x700af290 <UART_IsParameter> @ imm = #0xd438
700a1e58: 4601         	mov	r1, r0
700a1e5a: 9802         	ldr	r0, [sp, #0x8]
700a1e5c: 4408         	add	r0, r1
700a1e5e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->baudRate);
700a1e60: 9801         	ldr	r0, [sp, #0x4]
700a1e62: 6840         	ldr	r0, [r0, #0x4]
700a1e64: f00d fa14    	bl	0x700af290 <UART_IsParameter> @ imm = #0xd428
700a1e68: 4601         	mov	r1, r0
700a1e6a: 9802         	ldr	r0, [sp, #0x8]
700a1e6c: 4408         	add	r0, r1
700a1e6e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsDataLengthValid(hUartInit->dataLength);
700a1e70: 9801         	ldr	r0, [sp, #0x4]
700a1e72: 6880         	ldr	r0, [r0, #0x8]
700a1e74: f00c fa34    	bl	0x700ae2e0 <UART_IsDataLengthValid> @ imm = #0xc468
700a1e78: 4601         	mov	r1, r0
700a1e7a: 9802         	ldr	r0, [sp, #0x8]
700a1e7c: 4408         	add	r0, r1
700a1e7e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsStopBitsValid(hUartInit->stopBits);
700a1e80: 9801         	ldr	r0, [sp, #0x4]
700a1e82: 68c0         	ldr	r0, [r0, #0xc]
700a1e84: f00d f844    	bl	0x700aef10 <UART_IsStopBitsValid> @ imm = #0xd088
700a1e88: 4601         	mov	r1, r0
700a1e8a: 9802         	ldr	r0, [sp, #0x8]
700a1e8c: 4408         	add	r0, r1
700a1e8e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParityTypeValid(hUartInit->parityType);
700a1e90: 9801         	ldr	r0, [sp, #0x4]
700a1e92: 6900         	ldr	r0, [r0, #0x10]
700a1e94: f00b ff84    	bl	0x700adda0 <UART_IsParityTypeValid> @ imm = #0xbf08
700a1e98: 4601         	mov	r1, r0
700a1e9a: 9802         	ldr	r0, [sp, #0x8]
700a1e9c: 4408         	add	r0, r1
700a1e9e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsHWFlowCtrlValid(hUartInit->hwFlowControlThr);
700a1ea0: 9801         	ldr	r0, [sp, #0x4]
700a1ea2: 69c0         	ldr	r0, [r0, #0x1c]
700a1ea4: f00b fe3c    	bl	0x700adb20 <UART_IsHWFlowCtrlValid> @ imm = #0xbc78
700a1ea8: 4601         	mov	r1, r0
700a1eaa: 9802         	ldr	r0, [sp, #0x8]
700a1eac: 4408         	add	r0, r1
700a1eae: 9002         	str	r0, [sp, #0x8]
;         status += UART_OperModeValid(hUartInit->operMode);
700a1eb0: 9801         	ldr	r0, [sp, #0x4]
700a1eb2: 6ac0         	ldr	r0, [r0, #0x2c]
700a1eb4: f00a fe94    	bl	0x700acbe0 <UART_OperModeValid> @ imm = #0xad28
700a1eb8: 4601         	mov	r1, r0
700a1eba: 9802         	ldr	r0, [sp, #0x8]
700a1ebc: 4408         	add	r0, r1
700a1ebe: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsRxTrigLvlValid(hUartInit->rxTrigLvl);
700a1ec0: 9801         	ldr	r0, [sp, #0x4]
700a1ec2: 6b80         	ldr	r0, [r0, #0x38]
700a1ec4: f00b fe4c    	bl	0x700adb60 <UART_IsRxTrigLvlValid> @ imm = #0xbc98
700a1ec8: 4601         	mov	r1, r0
700a1eca: 9802         	ldr	r0, [sp, #0x8]
700a1ecc: 4408         	add	r0, r1
700a1ece: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsTxTrigLvlValid(hUartInit->txTrigLvl);
700a1ed0: 9801         	ldr	r0, [sp, #0x4]
700a1ed2: 6bc0         	ldr	r0, [r0, #0x3c]
700a1ed4: f00b fe64    	bl	0x700adba0 <UART_IsTxTrigLvlValid> @ imm = #0xbcc8
700a1ed8: 4601         	mov	r1, r0
700a1eda: 9802         	ldr	r0, [sp, #0x8]
700a1edc: 4408         	add	r0, r1
700a1ede: 9002         	str	r0, [sp, #0x8]
;         if((hUartInit->uartDmaHandle == NULL_PTR)
700a1ee0: 9801         	ldr	r0, [sp, #0x4]
700a1ee2: 6c80         	ldr	r0, [r0, #0x48]
;             || (hUartInit->dmaChCfg == NULL_PTR))
700a1ee4: b120         	cbz	r0, 0x700a1ef0 <UART_lld_initDma+0x110> @ imm = #0x8
700a1ee6: e7ff         	b	0x700a1ee8 <UART_lld_initDma+0x108> @ imm = #-0x2
700a1ee8: 9801         	ldr	r0, [sp, #0x4]
700a1eea: 6cc0         	ldr	r0, [r0, #0x4c]
;         if((hUartInit->uartDmaHandle == NULL_PTR)
700a1eec: b920         	cbnz	r0, 0x700a1ef8 <UART_lld_initDma+0x118> @ imm = #0x8
700a1eee: e7ff         	b	0x700a1ef0 <UART_lld_initDma+0x110> @ imm = #-0x2
;             status += UART_INVALID_PARAM;
700a1ef0: 9802         	ldr	r0, [sp, #0x8]
700a1ef2: 3803         	subs	r0, #0x3
700a1ef4: 9002         	str	r0, [sp, #0x8]
;         }
700a1ef6: e7ff         	b	0x700a1ef8 <UART_lld_initDma+0x118> @ imm = #-0x2
;     }
700a1ef8: e7ff         	b	0x700a1efa <UART_lld_initDma+0x11a> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a1efa: 9802         	ldr	r0, [sp, #0x8]
700a1efc: b950         	cbnz	r0, 0x700a1f14 <UART_lld_initDma+0x134> @ imm = #0x14
700a1efe: e7ff         	b	0x700a1f00 <UART_lld_initDma+0x120> @ imm = #-0x2
;         UART_configInstance(hUart);
700a1f00: 9803         	ldr	r0, [sp, #0xc]
700a1f02: f003 fa0d    	bl	0x700a5320 <UART_configInstance> @ imm = #0x341a
;         status = UART_lld_dmaInit(hUart, hUart->hUartInit->dmaChCfg);
700a1f06: 9803         	ldr	r0, [sp, #0xc]
700a1f08: 6841         	ldr	r1, [r0, #0x4]
700a1f0a: 6cc9         	ldr	r1, [r1, #0x4c]
700a1f0c: f00b f9f0    	bl	0x700ad2f0 <UART_lld_dmaInit> @ imm = #0xb3e0
700a1f10: 9002         	str	r0, [sp, #0x8]
;     }
700a1f12: e7ff         	b	0x700a1f14 <UART_lld_initDma+0x134> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a1f14: 9802         	ldr	r0, [sp, #0x8]
700a1f16: b920         	cbnz	r0, 0x700a1f22 <UART_lld_initDma+0x142> @ imm = #0x8
700a1f18: e7ff         	b	0x700a1f1a <UART_lld_initDma+0x13a> @ imm = #-0x2
;         hUart->state = UART_STATE_READY;
700a1f1a: 9903         	ldr	r1, [sp, #0xc]
700a1f1c: 2001         	movs	r0, #0x1
700a1f1e: 6548         	str	r0, [r1, #0x54]
;     }
700a1f20: e004         	b	0x700a1f2c <UART_lld_initDma+0x14c> @ imm = #0x8
;        status = UART_lld_deInitDma(hUart);
700a1f22: 9803         	ldr	r0, [sp, #0xc]
700a1f24: f009 fd6c    	bl	0x700aba00 <UART_lld_deInitDma> @ imm = #0x9ad8
700a1f28: 9002         	str	r0, [sp, #0x8]
700a1f2a: e7ff         	b	0x700a1f2c <UART_lld_initDma+0x14c> @ imm = #-0x2
;     return status;
700a1f2c: 9802         	ldr	r0, [sp, #0x8]
700a1f2e: b004         	add	sp, #0x10
700a1f30: bd80         	pop	{r7, pc}
700a1f32: 0000         	movs	r0, r0

700a1f34 <CSL_armR5PmuSelectCntr>:
;     AND     r0, r0, #0x1F
700a1f34: e200001f     	and	r0, r0, #31
;     MCR     p15, #0, r0, c9, c12, #5        /* Write PMSELR Register */
700a1f38: ee090fbc     	mcr	p15, #0x0, r0, c9, c12, #0x5
;     BX      lr
700a1f3c: e12fff1e     	bx	lr

700a1f40 <CSL_armR5PmuCfg>:
;     MRC     p15, #0, r3, c9, c12, #0        /* Read PMCR Register */
700a1f40: ee193f1c     	mrc	p15, #0x0, r3, c9, c12, #0x0
;     BIC     r3, r3, #((1<<3) | (1<<4))      /* Clear D and X bits */
700a1f44: e3c33018     	bic	r3, r3, #24
;     CMP     r0, #0
700a1f48: e3500000     	cmp	r0, #0
;     BEQ     armR5PmuCfg_00
700a1f4c: 0a000000     	beq	0x700a1f54 <armR5PmuCfg_00> @ imm = #0x0
;     ORR     r3, r3, #(1<<3)                 /* Set D bit */
700a1f50: e3833008     	orr	r3, r3, #8

700a1f54 <armR5PmuCfg_00>:
;     CMP     r1, #0
700a1f54: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuCfg_01
700a1f58: 0a000000     	beq	0x700a1f60 <armR5PmuCfg_01> @ imm = #0x0
;     ORR     r3, r3, #(1<<4)                 /* Set X bit */
700a1f5c: e3833010     	orr	r3, r3, #16

700a1f60 <armR5PmuCfg_01>:
;     MCR     p15, #0, r3, c9, c12, #0        /* Write PMCR Register */
700a1f60: ee093f1c     	mcr	p15, #0x0, r3, c9, c12, #0x0
;     EOR     r3, r3, r3                      /* Clear r3 */
700a1f64: e0233003     	eor	r3, r3, r3
;     CMP     r2, #0
700a1f68: e3520000     	cmp	r2, #0
;     BEQ     armR5PmuCfg_02
700a1f6c: 0a000000     	beq	0x700a1f74 <armR5PmuCfg_02> @ imm = #0x0
;     ORR     r3, r3, #1
700a1f70: e3833001     	orr	r3, r3, #1

700a1f74 <armR5PmuCfg_02>:
;     MCR     p15, #0, r3, c9, c14, #0        /* Write PMUSERENR Register */
700a1f74: ee093f1e     	mcr	p15, #0x0, r3, c9, c14, #0x0
;     BX      lr
700a1f78: e12fff1e     	bx	lr

700a1f7c <CSL_armR5PmuEnableAllCntrs>:
;     MRC     p15, #0, r1, c9, c12, #0        /* Read PMCR */
700a1f7c: ee191f1c     	mrc	p15, #0x0, r1, c9, c12, #0x0
;     CMP     r0, #0
700a1f80: e3500000     	cmp	r0, #0
;     BEQ     armR5PmuEnableAllCntrs_disable
700a1f84: 0a000001     	beq	0x700a1f90 <armR5PmuEnableAllCntrs_disable> @ imm = #0x4
;     ORR     r1, r1, #0x1                    /* Set E bit to enable all counters */
700a1f88: e3811001     	orr	r1, r1, #1
;     B       armR5PmuEnableAllCntrs_00
700a1f8c: ea000000     	b	0x700a1f94 <armR5PmuEnableAllCntrs_00> @ imm = #0x0

700a1f90 <armR5PmuEnableAllCntrs_disable>:
;     BIC     r1, r1, #0x1                    /* Clr E bit to disable all counters */
700a1f90: e3c11001     	bic	r1, r1, #1

700a1f94 <armR5PmuEnableAllCntrs_00>:
;     MCR     p15, #0, r1, c9, c12, #0        /* Write modified PMCR */
700a1f94: ee091f1c     	mcr	p15, #0x0, r1, c9, c12, #0x0
;     BX      lr
700a1f98: e12fff1e     	bx	lr

700a1f9c <CSL_armR5PmuGetNumCntrs>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR (Performance Monitor Control Register) */
700a1f9c: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     LSR     r0, r0, #11                     /* Shift and */
700a1fa0: e1a005a0     	lsr	r0, r0, #11
;     AND     r0, r0, #0x1F                   /*   mask to get N */
700a1fa4: e200001f     	and	r0, r0, #31
;     BX      lr
700a1fa8: e12fff1e     	bx	lr

700a1fac <CSL_armR5PmuCfgCntr>:
;     PUSH    {lr}
700a1fac: e52de004     	str	lr, [sp, #-0x4]!
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a1fb0: ebffffdf     	bl	0x700a1f34 <CSL_armR5PmuSelectCntr> @ imm = #-0x84
;     AND     r1, r1, #0xFF
700a1fb4: e20110ff     	and	r1, r1, #255
;     MCR     p15, #0, r1, c9, c13, #1        /* Write PMXEVTYPERx Register */
700a1fb8: ee091f3d     	mcr	p15, #0x0, r1, c9, c13, #0x1
;     POP     {lr}
700a1fbc: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a1fc0: e12fff1e     	bx	lr

700a1fc4 <CSL_armR5PmuEnableCntrOverflowIntr>:
;     AND     r0, r0, #0x1F                   /* cntrNum must be <= 31 */
700a1fc4: e200001f     	and	r0, r0, #31
;     MOV     r2, #1
700a1fc8: e3a02001     	mov	r2, #1
;     LSL     r0, r2, r0                      /* r0 is bit-mask corresponding to cntrNum */
700a1fcc: e1a00012     	lsl	r0, r2, r0
;     CMP     r1, #0
700a1fd0: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuEnableCntrOverflowIntr_clear
700a1fd4: 0a000001     	beq	0x700a1fe0 <armR5PmuEnableCntrOverflowIntr_clear> @ imm = #0x4
;     MCR     p15, #0, r0, c9, c14, #1        /* Write PMINTENSET Register (writes of 0 have no effect) */
700a1fd8: ee090f3e     	mcr	p15, #0x0, r0, c9, c14, #0x1
;     B       armR5PmuEnableCntrOverflowIntr_00
700a1fdc: ea000000     	b	0x700a1fe4 <armR5PmuEnableCntrOverflowIntr_00> @ imm = #0x0

700a1fe0 <armR5PmuEnableCntrOverflowIntr_clear>:
;     MCR     p15, #0, r0, c9, c14, #2        /* Write PMINTENCLR Register (writes of 0 have no effect) */
700a1fe0: ee090f5e     	mcr	p15, #0x0, r0, c9, c14, #0x2

700a1fe4 <armR5PmuEnableCntrOverflowIntr_00>:
;     BX      lr
700a1fe4: e12fff1e     	bx	lr

700a1fe8 <CSL_armR5PmuEnableCntr>:
;     AND     r0, r0, #0x1F                   /* cntrNum must be <= 31 */
700a1fe8: e200001f     	and	r0, r0, #31
;     MOV     r2, #1
700a1fec: e3a02001     	mov	r2, #1
;     LSL     r0, r2, r0                      /* r0 is bit-mask corresponding to cntrNum */
700a1ff0: e1a00012     	lsl	r0, r2, r0
;     CMP     r1, #0
700a1ff4: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuEnableCntrs_clear
700a1ff8: 0a000001     	beq	0x700a2004 <armR5PmuEnableCntrs_clear> @ imm = #0x4
;     MCR     p15, #0, r0, c9, c12, #1        /* Write PMCNTENSET Register (writes of 0 have no effect) */
700a1ffc: ee090f3c     	mcr	p15, #0x0, r0, c9, c12, #0x1
;     B       armR5PmuEnableCntrs_00
700a2000: ea000000     	b	0x700a2008 <armR5PmuEnableCntrs_00> @ imm = #0x0

700a2004 <armR5PmuEnableCntrs_clear>:
;     MCR     p15, #0, r0, c9, c12, #2        /* Write PMCNTENCLR Register (writes of 0 have no effect) */
700a2004: ee090f5c     	mcr	p15, #0x0, r0, c9, c12, #0x2

700a2008 <armR5PmuEnableCntrs_00>:
;     BX      lr
700a2008: e12fff1e     	bx	lr

700a200c <CSL_armR5PmuReadCntr>:
;     PUSH    {lr}
700a200c: e52de004     	str	lr, [sp, #-0x4]!
;     CMP     r0, #CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM
700a2010: e350001f     	cmp	r0, #31
;     BEQ     armR5PmuReadCntr_cycles
700a2014: 0a000002     	beq	0x700a2024 <armR5PmuReadCntr_cycles> @ imm = #0x8
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a2018: ebffffc5     	bl	0x700a1f34 <CSL_armR5PmuSelectCntr> @ imm = #-0xec
;     MRC     p15, #0, r0, c9, c13, #2        /* Read current PMNx Register */
700a201c: ee190f5d     	mrc	p15, #0x0, r0, c9, c13, #0x2
;     B       armR5PmuReadCntr_00
700a2020: ea000000     	b	0x700a2028 <armR5PmuReadCntr_00> @ imm = #0x0

700a2024 <armR5PmuReadCntr_cycles>:
;     MRC     p15, #0, r0, c9, c13, #0        /* Read PMCCNTR Register */
700a2024: ee190f1d     	mrc	p15, #0x0, r0, c9, c13, #0x0

700a2028 <armR5PmuReadCntr_00>:
;     POP     {lr}
700a2028: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a202c: e12fff1e     	bx	lr

700a2030 <CSL_armR5PmuSetCntr>:
;     PUSH    {lr}
700a2030: e52de004     	str	lr, [sp, #-0x4]!
;     CMP     r0, #CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM
700a2034: e350001f     	cmp	r0, #31
;     BEQ     armR5PmuSetCntr_cycles
700a2038: 0a000002     	beq	0x700a2048 <armR5PmuSetCntr_cycles> @ imm = #0x8
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a203c: ebffffbc     	bl	0x700a1f34 <CSL_armR5PmuSelectCntr> @ imm = #-0x110
;     MCR     p15, #0, r1, c9, c13, #2        /* Write current PMNx Register */
700a2040: ee091f5d     	mcr	p15, #0x0, r1, c9, c13, #0x2
;     B       armR5PmuSetCntr_00
700a2044: ea000000     	b	0x700a204c <armR5PmuSetCntr_00> @ imm = #0x0

700a2048 <armR5PmuSetCntr_cycles>:
;     MCR     p15, #0, r1, c9, c13, #0        /* Write PMCCNTR Register */
700a2048: ee091f1d     	mcr	p15, #0x0, r1, c9, c13, #0x0

700a204c <armR5PmuSetCntr_00>:
;     POP     {lr}
700a204c: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a2050: e12fff1e     	bx	lr

700a2054 <CSL_armR5PmuReadCntrOverflowStatus>:
;     MRC     p15, #0, r0, c9, c12, #3        /* Read PMOVSR Register */
700a2054: ee190f7c     	mrc	p15, #0x0, r0, c9, c12, #0x3
;     BX      lr
700a2058: e12fff1e     	bx	lr

700a205c <CSL_armR5PmuClearCntrOverflowStatus>:
;     MCR     p15, #0, r0, c9, c12, #3        /* Write PMOVSR Register */
700a205c: ee090f7c     	mcr	p15, #0x0, r0, c9, c12, #0x3
;     BX      lr
700a2060: e12fff1e     	bx	lr

700a2064 <CSL_armR5PmuResetCycleCnt>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR */
700a2064: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     ORR     r0, r0, #(1<<2)                 /* Set C bit to reset the cycle counter, PMCCNTR, to zero */
700a2068: e3800004     	orr	r0, r0, #4
;     MCR     p15, #0, r0, c9, c12, #0        /* Write modified PMCR*/
700a206c: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;     BX      lr
700a2070: e12fff1e     	bx	lr

700a2074 <CSL_armR5PmuResetCntrs>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR */
700a2074: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     ORR     r0, r0, #(1<<1)                 /* Set P bit to reset all event counters to zero */
700a2078: e3800002     	orr	r0, r0, #2
;     MCR     p15, #0, r0, c9, c12, #0        /* Write modified PMCR */
700a207c: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;     BX      lr
700a2080: e12fff1e     	bx	lr
		...

700a2090 <xTaskResumeAll>:
; BaseType_t xTaskResumeAll(void) {
700a2090: b580         	push	{r7, lr}
700a2092: b084         	sub	sp, #0x10
700a2094: 2000         	movs	r0, #0x0
;   TCB_t *pxTCB = NULL;
700a2096: 9003         	str	r0, [sp, #0xc]
;   BaseType_t xAlreadyYielded = pdFALSE;
700a2098: 9002         	str	r0, [sp, #0x8]
;   taskENTER_CRITICAL();
700a209a: f00c fa19    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0xc432
;     --uxSchedulerSuspended;
700a209e: f242 60e4    	movw	r0, #0x26e4
700a20a2: f2c7 000b    	movt	r0, #0x700b
700a20a6: 6801         	ldr	r1, [r0]
700a20a8: 3901         	subs	r1, #0x1
700a20aa: 6001         	str	r1, [r0]
;     if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a20ac: 6800         	ldr	r0, [r0]
700a20ae: 2800         	cmp	r0, #0x0
700a20b0: f040 808f    	bne.w	0x700a21d2 <xTaskResumeAll+0x142> @ imm = #0x11e
700a20b4: e7ff         	b	0x700a20b6 <xTaskResumeAll+0x26> @ imm = #-0x2
;       if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
700a20b6: f242 60dc    	movw	r0, #0x26dc
700a20ba: f2c7 000b    	movt	r0, #0x700b
700a20be: 6800         	ldr	r0, [r0]
700a20c0: 2800         	cmp	r0, #0x0
700a20c2: f000 8085    	beq.w	0x700a21d0 <xTaskResumeAll+0x140> @ imm = #0x10a
700a20c6: e7ff         	b	0x700a20c8 <xTaskResumeAll+0x38> @ imm = #-0x2
;         while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
700a20c8: e7ff         	b	0x700a20ca <xTaskResumeAll+0x3a> @ imm = #-0x2
700a20ca: f245 10e0    	movw	r0, #0x51e0
700a20ce: f2c7 0008    	movt	r0, #0x7008
700a20d2: 6800         	ldr	r0, [r0]
700a20d4: 2800         	cmp	r0, #0x0
700a20d6: d042         	beq	0x700a215e <xTaskResumeAll+0xce> @ imm = #0x84
700a20d8: e7ff         	b	0x700a20da <xTaskResumeAll+0x4a> @ imm = #-0x2
;           pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a20da: f245 10e0    	movw	r0, #0x51e0
700a20de: f2c7 0008    	movt	r0, #0x7008
700a20e2: 68c0         	ldr	r0, [r0, #0xc]
700a20e4: 68c0         	ldr	r0, [r0, #0xc]
700a20e6: 9003         	str	r0, [sp, #0xc]
;           (void)uxListRemove(&(pxTCB->xEventListItem));
700a20e8: 9803         	ldr	r0, [sp, #0xc]
700a20ea: 3018         	adds	r0, #0x18
700a20ec: f00b f9c0    	bl	0x700ad470 <uxListRemove> @ imm = #0xb380
;           (void)uxListRemove(&(pxTCB->xStateListItem));
700a20f0: 9803         	ldr	r0, [sp, #0xc]
700a20f2: 3004         	adds	r0, #0x4
700a20f4: f00b f9bc    	bl	0x700ad470 <uxListRemove> @ imm = #0xb378
;           prvAddTaskToReadyList(pxTCB);
700a20f8: 9803         	ldr	r0, [sp, #0xc]
700a20fa: 6ac0         	ldr	r0, [r0, #0x2c]
700a20fc: f242 61ec    	movw	r1, #0x26ec
700a2100: f2c7 010b    	movt	r1, #0x700b
700a2104: 6809         	ldr	r1, [r1]
700a2106: 4288         	cmp	r0, r1
700a2108: d908         	bls	0x700a211c <xTaskResumeAll+0x8c> @ imm = #0x10
700a210a: e7ff         	b	0x700a210c <xTaskResumeAll+0x7c> @ imm = #-0x2
700a210c: 9803         	ldr	r0, [sp, #0xc]
700a210e: 6ac0         	ldr	r0, [r0, #0x2c]
700a2110: f242 61ec    	movw	r1, #0x26ec
700a2114: f2c7 010b    	movt	r1, #0x700b
700a2118: 6008         	str	r0, [r1]
700a211a: e7ff         	b	0x700a211c <xTaskResumeAll+0x8c> @ imm = #-0x2
700a211c: 9903         	ldr	r1, [sp, #0xc]
700a211e: 6ac8         	ldr	r0, [r1, #0x2c]
700a2120: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a2124: f244 40f8    	movw	r0, #0x44f8
700a2128: f2c7 0008    	movt	r0, #0x7008
700a212c: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a2130: 3104         	adds	r1, #0x4
700a2132: f00b ff55    	bl	0x700adfe0 <vListInsertEnd> @ imm = #0xbeaa
;           if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a2136: 9803         	ldr	r0, [sp, #0xc]
700a2138: 6ac0         	ldr	r0, [r0, #0x2c]
700a213a: f242 61bc    	movw	r1, #0x26bc
700a213e: f2c7 010b    	movt	r1, #0x700b
700a2142: 6809         	ldr	r1, [r1]
700a2144: 6ac9         	ldr	r1, [r1, #0x2c]
700a2146: 4288         	cmp	r0, r1
700a2148: d307         	blo	0x700a215a <xTaskResumeAll+0xca> @ imm = #0xe
700a214a: e7ff         	b	0x700a214c <xTaskResumeAll+0xbc> @ imm = #-0x2
;             xYieldPending = pdTRUE;
700a214c: f242 7110    	movw	r1, #0x2710
700a2150: f2c7 010b    	movt	r1, #0x700b
700a2154: 2001         	movs	r0, #0x1
700a2156: 6008         	str	r0, [r1]
;           } else {
700a2158: e000         	b	0x700a215c <xTaskResumeAll+0xcc> @ imm = #0x0
700a215a: e7ff         	b	0x700a215c <xTaskResumeAll+0xcc> @ imm = #-0x2
;         while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
700a215c: e7b5         	b	0x700a20ca <xTaskResumeAll+0x3a> @ imm = #-0x96
;         if (pxTCB != NULL) {
700a215e: 9803         	ldr	r0, [sp, #0xc]
700a2160: b118         	cbz	r0, 0x700a216a <xTaskResumeAll+0xda> @ imm = #0x6
700a2162: e7ff         	b	0x700a2164 <xTaskResumeAll+0xd4> @ imm = #-0x2
;           prvResetNextTaskUnblockTime();
700a2164: f00b febc    	bl	0x700adee0 <prvResetNextTaskUnblockTime> @ imm = #0xbd78
;         }
700a2168: e7ff         	b	0x700a216a <xTaskResumeAll+0xda> @ imm = #-0x2
;           TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
700a216a: f242 60fc    	movw	r0, #0x26fc
700a216e: f2c7 000b    	movt	r0, #0x700b
700a2172: 6800         	ldr	r0, [r0]
700a2174: 9001         	str	r0, [sp, #0x4]
;           if (xPendedCounts > (TickType_t)0U) {
700a2176: 9801         	ldr	r0, [sp, #0x4]
700a2178: b1e0         	cbz	r0, 0x700a21b4 <xTaskResumeAll+0x124> @ imm = #0x38
700a217a: e7ff         	b	0x700a217c <xTaskResumeAll+0xec> @ imm = #-0x2
;             do {
700a217c: e7ff         	b	0x700a217e <xTaskResumeAll+0xee> @ imm = #-0x2
;               if (xTaskIncrementTick() != pdFALSE) {
700a217e: f7ff f937    	bl	0x700a13f0 <xTaskIncrementTick> @ imm = #-0xd92
700a2182: b138         	cbz	r0, 0x700a2194 <xTaskResumeAll+0x104> @ imm = #0xe
700a2184: e7ff         	b	0x700a2186 <xTaskResumeAll+0xf6> @ imm = #-0x2
;                 xYieldPending = pdTRUE;
700a2186: f242 7110    	movw	r1, #0x2710
700a218a: f2c7 010b    	movt	r1, #0x700b
700a218e: 2001         	movs	r0, #0x1
700a2190: 6008         	str	r0, [r1]
;               } else {
700a2192: e000         	b	0x700a2196 <xTaskResumeAll+0x106> @ imm = #0x0
700a2194: e7ff         	b	0x700a2196 <xTaskResumeAll+0x106> @ imm = #-0x2
;               --xPendedCounts;
700a2196: 9801         	ldr	r0, [sp, #0x4]
700a2198: 3801         	subs	r0, #0x1
700a219a: 9001         	str	r0, [sp, #0x4]
;             } while (xPendedCounts > (TickType_t)0U);
700a219c: e7ff         	b	0x700a219e <xTaskResumeAll+0x10e> @ imm = #-0x2
700a219e: 9801         	ldr	r0, [sp, #0x4]
700a21a0: 2800         	cmp	r0, #0x0
700a21a2: d1ec         	bne	0x700a217e <xTaskResumeAll+0xee> @ imm = #-0x28
700a21a4: e7ff         	b	0x700a21a6 <xTaskResumeAll+0x116> @ imm = #-0x2
;             xPendedTicks = 0;
700a21a6: f242 61fc    	movw	r1, #0x26fc
700a21aa: f2c7 010b    	movt	r1, #0x700b
700a21ae: 2000         	movs	r0, #0x0
700a21b0: 6008         	str	r0, [r1]
;           } else {
700a21b2: e000         	b	0x700a21b6 <xTaskResumeAll+0x126> @ imm = #0x0
700a21b4: e7ff         	b	0x700a21b6 <xTaskResumeAll+0x126> @ imm = #-0x2
;         if (xYieldPending != pdFALSE) {
700a21b6: f242 7010    	movw	r0, #0x2710
700a21ba: f2c7 000b    	movt	r0, #0x700b
700a21be: 6800         	ldr	r0, [r0]
700a21c0: b120         	cbz	r0, 0x700a21cc <xTaskResumeAll+0x13c> @ imm = #0x8
700a21c2: e7ff         	b	0x700a21c4 <xTaskResumeAll+0x134> @ imm = #-0x2
700a21c4: 2001         	movs	r0, #0x1
;             xAlreadyYielded = pdTRUE;
700a21c6: 9002         	str	r0, [sp, #0x8]
;           taskYIELD_IF_USING_PREEMPTION();
700a21c8: df00         	svc	#0x0
;         } else {
700a21ca: e000         	b	0x700a21ce <xTaskResumeAll+0x13e> @ imm = #0x0
700a21cc: e7ff         	b	0x700a21ce <xTaskResumeAll+0x13e> @ imm = #-0x2
;       }
700a21ce: e7ff         	b	0x700a21d0 <xTaskResumeAll+0x140> @ imm = #-0x2
;     } else {
700a21d0: e000         	b	0x700a21d4 <xTaskResumeAll+0x144> @ imm = #0x0
700a21d2: e7ff         	b	0x700a21d4 <xTaskResumeAll+0x144> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a21d4: f00b fa3c    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xb478
;   return xAlreadyYielded;
700a21d8: 9802         	ldr	r0, [sp, #0x8]
700a21da: b004         	add	sp, #0x10
700a21dc: bd80         	pop	{r7, pc}
700a21de: 0000         	movs	r0, r0

700a21e0 <Udma_chAssignRegOverlay>:
; {
700a21e0: b082         	sub	sp, #0x8
700a21e2: 9001         	str	r0, [sp, #0x4]
700a21e4: 9100         	str	r1, [sp]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a21e6: 9801         	ldr	r0, [sp, #0x4]
700a21e8: 6800         	ldr	r0, [r0]
700a21ea: 2801         	cmp	r0, #0x1
700a21ec: d147         	bne	0x700a227e <Udma_chAssignRegOverlay+0x9e> @ imm = #0x8e
700a21ee: e7ff         	b	0x700a21f0 <Udma_chAssignRegOverlay+0x10> @ imm = #-0x2
;         if(chHandle->txChNum != UDMA_DMA_CH_INVALID)
700a21f0: 9800         	ldr	r0, [sp]
700a21f2: 6ec0         	ldr	r0, [r0, #0x6c]
700a21f4: f510 3f80    	cmn.w	r0, #0x10000
700a21f8: d029         	beq	0x700a224e <Udma_chAssignRegOverlay+0x6e> @ imm = #0x52
700a21fa: e7ff         	b	0x700a21fc <Udma_chAssignRegOverlay+0x1c> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a21fc: 9800         	ldr	r0, [sp]
700a21fe: 7800         	ldrb	r0, [r0]
700a2200: 0740         	lsls	r0, r0, #0x1d
700a2202: 2800         	cmp	r0, #0x0
700a2204: d511         	bpl	0x700a222a <Udma_chAssignRegOverlay+0x4a> @ imm = #0x22
700a2206: e7ff         	b	0x700a2208 <Udma_chAssignRegOverlay+0x28> @ imm = #-0x2
;                     &drvHandle->bcdmaRegs.pBcChanCfgRegs->CHAN[chHandle->txChNum];
700a2208: 9801         	ldr	r0, [sp, #0x4]
700a220a: 68c0         	ldr	r0, [r0, #0xc]
700a220c: 9900         	ldr	r1, [sp]
700a220e: 6eca         	ldr	r2, [r1, #0x6c]
700a2210: eb00 2002    	add.w	r0, r0, r2, lsl #8
;                 chHandle->pBcdmaBcCfgRegs =
700a2214: f8c1 0214    	str.w	r0, [r1, #0x214]
;                     &drvHandle->bcdmaRegs.pBcChanRtRegs->CHAN[chHandle->txChNum];
700a2218: 9801         	ldr	r0, [sp, #0x4]
700a221a: 6900         	ldr	r0, [r0, #0x10]
700a221c: 9900         	ldr	r1, [sp]
700a221e: 6eca         	ldr	r2, [r1, #0x6c]
700a2220: eb00 3002    	add.w	r0, r0, r2, lsl #12
;                 chHandle->pBcdmaBcRtRegs  =
700a2224: f8c1 0218    	str.w	r0, [r1, #0x218]
;             }
700a2228: e010         	b	0x700a224c <Udma_chAssignRegOverlay+0x6c> @ imm = #0x20
;                     &drvHandle->bcdmaRegs.pTxChanCfgRegs->CHAN[chHandle->txChNum];
700a222a: 9801         	ldr	r0, [sp, #0x4]
700a222c: 6940         	ldr	r0, [r0, #0x14]
700a222e: 9900         	ldr	r1, [sp]
700a2230: 6eca         	ldr	r2, [r1, #0x6c]
700a2232: eb00 2002    	add.w	r0, r0, r2, lsl #8
;                 chHandle->pBcdmaTxCfgRegs =
700a2236: f8c1 021c    	str.w	r0, [r1, #0x21c]
;                     &drvHandle->bcdmaRegs.pTxChanRtRegs->CHAN[chHandle->txChNum];
700a223a: 9801         	ldr	r0, [sp, #0x4]
700a223c: 6980         	ldr	r0, [r0, #0x18]
700a223e: 9900         	ldr	r1, [sp]
700a2240: 6eca         	ldr	r2, [r1, #0x6c]
700a2242: eb00 3002    	add.w	r0, r0, r2, lsl #12
;                 chHandle->pBcdmaTxRtRegs  =
700a2246: f8c1 0220    	str.w	r0, [r1, #0x220]
700a224a: e7ff         	b	0x700a224c <Udma_chAssignRegOverlay+0x6c> @ imm = #-0x2
;         }
700a224c: e7ff         	b	0x700a224e <Udma_chAssignRegOverlay+0x6e> @ imm = #-0x2
;         if(chHandle->rxChNum != UDMA_DMA_CH_INVALID)
700a224e: 9800         	ldr	r0, [sp]
700a2250: 6f00         	ldr	r0, [r0, #0x70]
700a2252: f510 3f80    	cmn.w	r0, #0x10000
700a2256: d011         	beq	0x700a227c <Udma_chAssignRegOverlay+0x9c> @ imm = #0x22
700a2258: e7ff         	b	0x700a225a <Udma_chAssignRegOverlay+0x7a> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs.pRxChanCfgRegs->CHAN[chHandle->rxChNum];
700a225a: 9801         	ldr	r0, [sp, #0x4]
700a225c: 69c0         	ldr	r0, [r0, #0x1c]
700a225e: 9900         	ldr	r1, [sp]
700a2260: 6f0a         	ldr	r2, [r1, #0x70]
700a2262: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pBcdmaRxCfgRegs =
700a2266: f8c1 0224    	str.w	r0, [r1, #0x224]
;                 &drvHandle->bcdmaRegs.pRxChanRtRegs->CHAN[chHandle->rxChNum];
700a226a: 9801         	ldr	r0, [sp, #0x4]
700a226c: 6a00         	ldr	r0, [r0, #0x20]
700a226e: 9900         	ldr	r1, [sp]
700a2270: 6f0a         	ldr	r2, [r1, #0x70]
700a2272: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pBcdmaRxRtRegs  =
700a2276: f8c1 0228    	str.w	r0, [r1, #0x228]
;         }
700a227a: e7ff         	b	0x700a227c <Udma_chAssignRegOverlay+0x9c> @ imm = #-0x2
;     }
700a227c: e051         	b	0x700a2322 <Udma_chAssignRegOverlay+0x142> @ imm = #0xa2
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a227e: 9801         	ldr	r0, [sp, #0x4]
700a2280: 6800         	ldr	r0, [r0]
700a2282: 2802         	cmp	r0, #0x2
700a2284: d14c         	bne	0x700a2320 <Udma_chAssignRegOverlay+0x140> @ imm = #0x98
700a2286: e7ff         	b	0x700a2288 <Udma_chAssignRegOverlay+0xa8> @ imm = #-0x2
;         if(chHandle->txChNum != UDMA_DMA_CH_INVALID)
700a2288: 9800         	ldr	r0, [sp]
700a228a: 6ec0         	ldr	r0, [r0, #0x6c]
700a228c: f510 3f80    	cmn.w	r0, #0x10000
700a2290: d011         	beq	0x700a22b6 <Udma_chAssignRegOverlay+0xd6> @ imm = #0x22
700a2292: e7ff         	b	0x700a2294 <Udma_chAssignRegOverlay+0xb4> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[chHandle->txChNum];
700a2294: 9801         	ldr	r0, [sp, #0x4]
700a2296: 6dc0         	ldr	r0, [r0, #0x5c]
700a2298: 9900         	ldr	r1, [sp]
700a229a: 6eca         	ldr	r2, [r1, #0x6c]
700a229c: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaTxCfgRegs =
700a22a0: f8c1 022c    	str.w	r0, [r1, #0x22c]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[chHandle->txChNum];
700a22a4: 9801         	ldr	r0, [sp, #0x4]
700a22a6: 6e40         	ldr	r0, [r0, #0x64]
700a22a8: 9900         	ldr	r1, [sp]
700a22aa: 6eca         	ldr	r2, [r1, #0x6c]
700a22ac: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaTxRtRegs  =
700a22b0: f8c1 0230    	str.w	r0, [r1, #0x230]
;         }
700a22b4: e7ff         	b	0x700a22b6 <Udma_chAssignRegOverlay+0xd6> @ imm = #-0x2
;         if(chHandle->rxChNum != UDMA_DMA_CH_INVALID)
700a22b6: 9800         	ldr	r0, [sp]
700a22b8: 6f00         	ldr	r0, [r0, #0x70]
700a22ba: f510 3f80    	cmn.w	r0, #0x10000
700a22be: d011         	beq	0x700a22e4 <Udma_chAssignRegOverlay+0x104> @ imm = #0x22
700a22c0: e7ff         	b	0x700a22c2 <Udma_chAssignRegOverlay+0xe2> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pRxChanCfgRegs->CHAN[chHandle->rxChNum];
700a22c2: 9801         	ldr	r0, [sp, #0x4]
700a22c4: 6e00         	ldr	r0, [r0, #0x60]
700a22c6: 9900         	ldr	r1, [sp]
700a22c8: 6f0a         	ldr	r2, [r1, #0x70]
700a22ca: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaRxCfgRegs =
700a22ce: f8c1 0234    	str.w	r0, [r1, #0x234]
;                 &drvHandle->pktdmaRegs.pRxChanRtRegs->CHAN[chHandle->rxChNum];
700a22d2: 9801         	ldr	r0, [sp, #0x4]
700a22d4: 6e80         	ldr	r0, [r0, #0x68]
700a22d6: 9900         	ldr	r1, [sp]
700a22d8: 6f0a         	ldr	r2, [r1, #0x70]
700a22da: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaRxRtRegs  =
700a22de: f8c1 0238    	str.w	r0, [r1, #0x238]
;         }
700a22e2: e7ff         	b	0x700a22e4 <Udma_chAssignRegOverlay+0x104> @ imm = #-0x2
;         if(chHandle->extChNum != UDMA_DMA_CH_INVALID)
700a22e4: 9800         	ldr	r0, [sp]
700a22e6: 6f40         	ldr	r0, [r0, #0x74]
700a22e8: f510 3f80    	cmn.w	r0, #0x10000
700a22ec: d017         	beq	0x700a231e <Udma_chAssignRegOverlay+0x13e> @ imm = #0x2e
700a22ee: e7ff         	b	0x700a22f0 <Udma_chAssignRegOverlay+0x110> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a22f0: 9b01         	ldr	r3, [sp, #0x4]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a22f2: 9900         	ldr	r1, [sp]
700a22f4: 6f4a         	ldr	r2, [r1, #0x74]
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a22f6: 6dd8         	ldr	r0, [r3, #0x5c]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a22f8: f8d3 3110    	ldr.w	r3, [r3, #0x110]
700a22fc: 441a         	add	r2, r3
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a22fe: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaExtCfgRegs =
700a2302: f8c1 023c    	str.w	r0, [r1, #0x23c]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a2306: 9b01         	ldr	r3, [sp, #0x4]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a2308: 9900         	ldr	r1, [sp]
700a230a: 6f4a         	ldr	r2, [r1, #0x74]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a230c: 6e58         	ldr	r0, [r3, #0x64]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a230e: f8d3 3110    	ldr.w	r3, [r3, #0x110]
700a2312: 441a         	add	r2, r3
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a2314: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaExtRtRegs  =
700a2318: f8c1 0240    	str.w	r0, [r1, #0x240]
;         }
700a231c: e7ff         	b	0x700a231e <Udma_chAssignRegOverlay+0x13e> @ imm = #-0x2
;     }
700a231e: e7ff         	b	0x700a2320 <Udma_chAssignRegOverlay+0x140> @ imm = #-0x2
700a2320: e7ff         	b	0x700a2322 <Udma_chAssignRegOverlay+0x142> @ imm = #-0x2
; }
700a2322: b002         	add	sp, #0x8
700a2324: 4770         	bx	lr
		...
700a232e: 0000         	movs	r0, r0

700a2330 <DebugP_memLogWriterPutChar>:
; {
700a2330: b580         	push	{r7, lr}
700a2332: b088         	sub	sp, #0x20
700a2334: f88d 001f    	strb.w	r0, [sp, #0x1f]
;     if(lineBufIndex==0U)
700a2338: f242 507c    	movw	r0, #0x257c
700a233c: f2c7 000b    	movt	r0, #0x700b
700a2340: 6800         	ldr	r0, [r0]
700a2342: bb40         	cbnz	r0, 0x700a2396 <DebugP_memLogWriterPutChar+0x66> @ imm = #0x50
700a2344: e7ff         	b	0x700a2346 <DebugP_memLogWriterPutChar+0x16> @ imm = #-0x2
;         uint64_t curTime = ClockP_getTimeUsec();
700a2346: f008 faf3    	bl	0x700aa930 <ClockP_getTimeUsec> @ imm = #0x85e6
700a234a: 9105         	str	r1, [sp, #0x14]
700a234c: 9004         	str	r0, [sp, #0x10]
;                             gDebugP_memTraceLogWriterSelfCoreName,
700a234e: f242 60a0    	movw	r0, #0x26a0
700a2352: f2c7 000b    	movt	r0, #0x700b
700a2356: 6800         	ldr	r0, [r0]
;                             (uint32_t)(curTime/TIME_IN_MICRO_SECONDS),
700a2358: 9003         	str	r0, [sp, #0xc]
700a235a: 9804         	ldr	r0, [sp, #0x10]
700a235c: 9905         	ldr	r1, [sp, #0x14]
700a235e: f244 2240    	movw	r2, #0x4240
700a2362: f2c0 020f    	movt	r2, #0xf
700a2366: 2300         	movs	r3, #0x0
;                             (uint32_t)(curTime%TIME_IN_MICRO_SECONDS)
700a2368: f00c ede4    	blx	0x700aef34 <__aeabi_uldivmod> @ imm = #0xcbc8
700a236c: 9b03         	ldr	r3, [sp, #0xc]
;         lineBufIndex = (uint32_t)snprintf_((char*)lineBuf, DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE, "[%6s] %5d.%06ds : ",
700a236e: 4669         	mov	r1, sp
700a2370: 604a         	str	r2, [r1, #0x4]
700a2372: 6008         	str	r0, [r1]
700a2374: f245 0040    	movw	r0, #0x5040
700a2378: f2c7 0008    	movt	r0, #0x7008
700a237c: f641 428c    	movw	r2, #0x1c8c
700a2380: f2c7 020b    	movt	r2, #0x700b
700a2384: 2178         	movs	r1, #0x78
700a2386: f00b fe0b    	bl	0x700adfa0 <snprintf_>  @ imm = #0xbc16
700a238a: f242 517c    	movw	r1, #0x257c
700a238e: f2c7 010b    	movt	r1, #0x700b
700a2392: 6008         	str	r0, [r1]
;     }
700a2394: e7ff         	b	0x700a2396 <DebugP_memLogWriterPutChar+0x66> @ imm = #-0x2
;     lineBuf[lineBufIndex]=(uint8_t)character;
700a2396: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700a239a: f242 517c    	movw	r1, #0x257c
700a239e: f2c7 010b    	movt	r1, #0x700b
700a23a2: 680b         	ldr	r3, [r1]
700a23a4: f245 0240    	movw	r2, #0x5040
700a23a8: f2c7 0208    	movt	r2, #0x7008
700a23ac: 54d0         	strb	r0, [r2, r3]
; 	lineBufIndex = lineBufIndex + 1U;
700a23ae: 6808         	ldr	r0, [r1]
700a23b0: 3001         	adds	r0, #0x1
700a23b2: 6008         	str	r0, [r1]
;     if( (character == '\n') ||
700a23b4: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700a23b8: 280a         	cmp	r0, #0xa
700a23ba: d008         	beq	0x700a23ce <DebugP_memLogWriterPutChar+0x9e> @ imm = #0x10
700a23bc: e7ff         	b	0x700a23be <DebugP_memLogWriterPutChar+0x8e> @ imm = #-0x2
;         (lineBufIndex >= (DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE)))
700a23be: f242 507c    	movw	r0, #0x257c
700a23c2: f2c7 000b    	movt	r0, #0x700b
700a23c6: 6800         	ldr	r0, [r0]
;     if( (character == '\n') ||
700a23c8: 2878         	cmp	r0, #0x78
700a23ca: d350         	blo	0x700a246e <DebugP_memLogWriterPutChar+0x13e> @ imm = #0xa0
700a23cc: e7ff         	b	0x700a23ce <DebugP_memLogWriterPutChar+0x9e> @ imm = #-0x2
;         if(lineBufIndex >= (DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE))
700a23ce: f242 507c    	movw	r0, #0x257c
700a23d2: f2c7 000b    	movt	r0, #0x700b
700a23d6: 6800         	ldr	r0, [r0]
700a23d8: 2878         	cmp	r0, #0x78
700a23da: d315         	blo	0x700a2408 <DebugP_memLogWriterPutChar+0xd8> @ imm = #0x2a
700a23dc: e7ff         	b	0x700a23de <DebugP_memLogWriterPutChar+0xae> @ imm = #-0x2
;             lineBuf[lineBufIndex]=(uint8_t)'\r';
700a23de: f242 517c    	movw	r1, #0x257c
700a23e2: f2c7 010b    	movt	r1, #0x700b
700a23e6: 680b         	ldr	r3, [r1]
700a23e8: f245 0240    	movw	r2, #0x5040
700a23ec: f2c7 0208    	movt	r2, #0x7008
700a23f0: 200d         	movs	r0, #0xd
700a23f2: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a23f4: 6808         	ldr	r0, [r1]
700a23f6: 3001         	adds	r0, #0x1
700a23f8: 6008         	str	r0, [r1]
;             lineBuf[lineBufIndex]=(uint8_t)'\n';
700a23fa: 680b         	ldr	r3, [r1]
700a23fc: 200a         	movs	r0, #0xa
700a23fe: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a2400: 6808         	ldr	r0, [r1]
700a2402: 3001         	adds	r0, #0x1
700a2404: 6008         	str	r0, [r1]
;         }
700a2406: e7ff         	b	0x700a2408 <DebugP_memLogWriterPutChar+0xd8> @ imm = #-0x2
;         if(lineBuf[lineBufIndex-UNSIGNED_INTEGERVAL_TWO]!=(uint8_t)'\r')
700a2408: f242 507c    	movw	r0, #0x257c
700a240c: f2c7 000b    	movt	r0, #0x700b
700a2410: 6800         	ldr	r0, [r0]
700a2412: f245 0140    	movw	r1, #0x5040
700a2416: f2c7 0108    	movt	r1, #0x7008
700a241a: 4408         	add	r0, r1
700a241c: f810 0c02    	ldrb	r0, [r0, #-2]
700a2420: 280d         	cmp	r0, #0xd
700a2422: d014         	beq	0x700a244e <DebugP_memLogWriterPutChar+0x11e> @ imm = #0x28
700a2424: e7ff         	b	0x700a2426 <DebugP_memLogWriterPutChar+0xf6> @ imm = #-0x2
;             lineBuf[lineBufIndex-1U]=(uint8_t)'\r';
700a2426: f242 517c    	movw	r1, #0x257c
700a242a: f2c7 010b    	movt	r1, #0x700b
700a242e: 6808         	ldr	r0, [r1]
700a2430: f245 0240    	movw	r2, #0x5040
700a2434: f2c7 0208    	movt	r2, #0x7008
700a2438: 1883         	adds	r3, r0, r2
700a243a: 200d         	movs	r0, #0xd
700a243c: f803 0c01    	strb	r0, [r3, #-1]
;             lineBuf[lineBufIndex]=(uint8_t)'\n';
700a2440: 680b         	ldr	r3, [r1]
700a2442: 200a         	movs	r0, #0xa
700a2444: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a2446: 6808         	ldr	r0, [r1]
700a2448: 3001         	adds	r0, #0x1
700a244a: 6008         	str	r0, [r1]
;         }
700a244c: e7ff         	b	0x700a244e <DebugP_memLogWriterPutChar+0x11e> @ imm = #-0x2
;         DebugP_memTraceLogWriterPutLine(lineBuf, (uint16_t)lineBufIndex);
700a244e: f242 507c    	movw	r0, #0x257c
700a2452: f2c7 000b    	movt	r0, #0x700b
700a2456: 9002         	str	r0, [sp, #0x8]
700a2458: 8801         	ldrh	r1, [r0]
700a245a: f245 0040    	movw	r0, #0x5040
700a245e: f2c7 0008    	movt	r0, #0x7008
700a2462: f003 fb3d    	bl	0x700a5ae0 <DebugP_memTraceLogWriterPutLine> @ imm = #0x367a
700a2466: 9902         	ldr	r1, [sp, #0x8]
700a2468: 2000         	movs	r0, #0x0
;         lineBufIndex = 0;
700a246a: 6008         	str	r0, [r1]
;     }
700a246c: e7ff         	b	0x700a246e <DebugP_memLogWriterPutChar+0x13e> @ imm = #-0x2
; }
700a246e: b008         	add	sp, #0x20
700a2470: bd80         	pop	{r7, pc}
		...
700a247e: 0000         	movs	r0, r0

700a2480 <Sciclient_sendMessage>:
; {
700a2480: b580         	push	{r7, lr}
700a2482: b08a         	sub	sp, #0x28
700a2484: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a2488: 9009         	str	r0, [sp, #0x24]
700a248a: 9108         	str	r1, [sp, #0x20]
700a248c: 9207         	str	r2, [sp, #0x1c]
700a248e: 9306         	str	r3, [sp, #0x18]
700a2490: 2200         	movs	r2, #0x0
;     uint32_t        i   = 0U;
700a2492: 9205         	str	r2, [sp, #0x14]
;     const uint8_t *msg = pSecHeader;
700a2494: 9808         	ldr	r0, [sp, #0x20]
700a2496: 9004         	str	r0, [sp, #0x10]
;     uint32_t numWords   = 0U;
700a2498: 9203         	str	r2, [sp, #0xc]
;     uint32_t test = 0U;
700a249a: 9202         	str	r2, [sp, #0x8]
;     uintptr_t threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U);
700a249c: 9909         	ldr	r1, [sp, #0x24]
700a249e: f242 5080    	movw	r0, #0x2580
700a24a2: f2c7 000b    	movt	r0, #0x700b
700a24a6: f00c fee3    	bl	0x700af270 <CSL_secProxyGetDataAddr> @ imm = #0xcdc6
700a24aa: 9001         	str	r0, [sp, #0x4]
;     if(pSecHeader != NULL)
700a24ac: 9808         	ldr	r0, [sp, #0x20]
700a24ae: b1f8         	cbz	r0, 0x700a24f0 <Sciclient_sendMessage+0x70> @ imm = #0x3e
700a24b0: e7ff         	b	0x700a24b2 <Sciclient_sendMessage+0x32> @ imm = #-0x2
700a24b2: 2000         	movs	r0, #0x0
;         for (i = 0U; i < gSecHeaderSizeWords; i++)
700a24b4: 9005         	str	r0, [sp, #0x14]
700a24b6: e7ff         	b	0x700a24b8 <Sciclient_sendMessage+0x38> @ imm = #-0x2
700a24b8: 9805         	ldr	r0, [sp, #0x14]
700a24ba: f242 7114    	movw	r1, #0x2714
700a24be: f2c7 010b    	movt	r1, #0x700b
700a24c2: 7809         	ldrb	r1, [r1]
700a24c4: 4288         	cmp	r0, r1
700a24c6: d212         	bhs	0x700a24ee <Sciclient_sendMessage+0x6e> @ imm = #0x24
700a24c8: e7ff         	b	0x700a24ca <Sciclient_sendMessage+0x4a> @ imm = #-0x2
;             (void) memcpy((void *)&test, (const void *)msg, 4);
700a24ca: 9804         	ldr	r0, [sp, #0x10]
700a24cc: 6800         	ldr	r0, [r0]
700a24ce: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(threadAddr, test);
700a24d0: 9801         	ldr	r0, [sp, #0x4]
700a24d2: 9902         	ldr	r1, [sp, #0x8]
700a24d4: f00d f984    	bl	0x700af7e0 <CSL_REG32_WR_RAW> @ imm = #0xd308
;             msg += 4;
700a24d8: 9804         	ldr	r0, [sp, #0x10]
700a24da: 3004         	adds	r0, #0x4
700a24dc: 9004         	str	r0, [sp, #0x10]
;             threadAddr+=sizeof(uint32_t);
700a24de: 9801         	ldr	r0, [sp, #0x4]
700a24e0: 3004         	adds	r0, #0x4
700a24e2: 9001         	str	r0, [sp, #0x4]
;         }
700a24e4: e7ff         	b	0x700a24e6 <Sciclient_sendMessage+0x66> @ imm = #-0x2
;         for (i = 0U; i < gSecHeaderSizeWords; i++)
700a24e6: 9805         	ldr	r0, [sp, #0x14]
700a24e8: 3001         	adds	r0, #0x1
700a24ea: 9005         	str	r0, [sp, #0x14]
700a24ec: e7e4         	b	0x700a24b8 <Sciclient_sendMessage+0x38> @ imm = #-0x38
;     }
700a24ee: e7ff         	b	0x700a24f0 <Sciclient_sendMessage+0x70> @ imm = #-0x2
;     msg = pHeader;
700a24f0: 9807         	ldr	r0, [sp, #0x1c]
700a24f2: 9004         	str	r0, [sp, #0x10]
700a24f4: 2000         	movs	r0, #0x0
;     for (i = 0U; i < SCICLIENT_HEADER_SIZE_IN_WORDS; i++)
700a24f6: 9005         	str	r0, [sp, #0x14]
700a24f8: e7ff         	b	0x700a24fa <Sciclient_sendMessage+0x7a> @ imm = #-0x2
700a24fa: 9805         	ldr	r0, [sp, #0x14]
700a24fc: 2801         	cmp	r0, #0x1
700a24fe: d812         	bhi	0x700a2526 <Sciclient_sendMessage+0xa6> @ imm = #0x24
700a2500: e7ff         	b	0x700a2502 <Sciclient_sendMessage+0x82> @ imm = #-0x2
;         (void) memcpy((void *)&test, (const void *)msg, 4);
700a2502: 9804         	ldr	r0, [sp, #0x10]
700a2504: 6800         	ldr	r0, [r0]
700a2506: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(threadAddr, test);
700a2508: 9801         	ldr	r0, [sp, #0x4]
700a250a: 9902         	ldr	r1, [sp, #0x8]
700a250c: f00d f968    	bl	0x700af7e0 <CSL_REG32_WR_RAW> @ imm = #0xd2d0
;         msg += 4;
700a2510: 9804         	ldr	r0, [sp, #0x10]
700a2512: 3004         	adds	r0, #0x4
700a2514: 9004         	str	r0, [sp, #0x10]
;         threadAddr+=sizeof(uint32_t);
700a2516: 9801         	ldr	r0, [sp, #0x4]
700a2518: 3004         	adds	r0, #0x4
700a251a: 9001         	str	r0, [sp, #0x4]
;     }
700a251c: e7ff         	b	0x700a251e <Sciclient_sendMessage+0x9e> @ imm = #-0x2
;     for (i = 0U; i < SCICLIENT_HEADER_SIZE_IN_WORDS; i++)
700a251e: 9805         	ldr	r0, [sp, #0x14]
700a2520: 3001         	adds	r0, #0x1
700a2522: 9005         	str	r0, [sp, #0x14]
700a2524: e7e9         	b	0x700a24fa <Sciclient_sendMessage+0x7a> @ imm = #-0x2e
;     if (payloadSize > 0U)
700a2526: 980c         	ldr	r0, [sp, #0x30]
700a2528: b300         	cbz	r0, 0x700a256c <Sciclient_sendMessage+0xec> @ imm = #0x40
700a252a: e7ff         	b	0x700a252c <Sciclient_sendMessage+0xac> @ imm = #-0x2
;         numWords   = (payloadSize+3U)/4U;
700a252c: 980c         	ldr	r0, [sp, #0x30]
700a252e: 3003         	adds	r0, #0x3
700a2530: 0880         	lsrs	r0, r0, #0x2
700a2532: 9003         	str	r0, [sp, #0xc]
;         msg = pPayload;
700a2534: 9806         	ldr	r0, [sp, #0x18]
700a2536: 9004         	str	r0, [sp, #0x10]
;         for (; i < (SCICLIENT_HEADER_SIZE_IN_WORDS + numWords); i++)
700a2538: e7ff         	b	0x700a253a <Sciclient_sendMessage+0xba> @ imm = #-0x2
700a253a: 9805         	ldr	r0, [sp, #0x14]
700a253c: 9903         	ldr	r1, [sp, #0xc]
700a253e: 3102         	adds	r1, #0x2
700a2540: 4288         	cmp	r0, r1
700a2542: d212         	bhs	0x700a256a <Sciclient_sendMessage+0xea> @ imm = #0x24
700a2544: e7ff         	b	0x700a2546 <Sciclient_sendMessage+0xc6> @ imm = #-0x2
;             (void) memcpy((void *)&test, (const void *)msg, 4);
700a2546: 9804         	ldr	r0, [sp, #0x10]
700a2548: 6800         	ldr	r0, [r0]
700a254a: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(threadAddr, test);
700a254c: 9801         	ldr	r0, [sp, #0x4]
700a254e: 9902         	ldr	r1, [sp, #0x8]
700a2550: f00d f946    	bl	0x700af7e0 <CSL_REG32_WR_RAW> @ imm = #0xd28c
;             msg += 4;
700a2554: 9804         	ldr	r0, [sp, #0x10]
700a2556: 3004         	adds	r0, #0x4
700a2558: 9004         	str	r0, [sp, #0x10]
;             threadAddr+=sizeof(uint32_t);
700a255a: 9801         	ldr	r0, [sp, #0x4]
700a255c: 3004         	adds	r0, #0x4
700a255e: 9001         	str	r0, [sp, #0x4]
;         }
700a2560: e7ff         	b	0x700a2562 <Sciclient_sendMessage+0xe2> @ imm = #-0x2
;         for (; i < (SCICLIENT_HEADER_SIZE_IN_WORDS + numWords); i++)
700a2562: 9805         	ldr	r0, [sp, #0x14]
700a2564: 3001         	adds	r0, #0x1
700a2566: 9005         	str	r0, [sp, #0x14]
700a2568: e7e7         	b	0x700a253a <Sciclient_sendMessage+0xba> @ imm = #-0x32
;     }
700a256a: e7ff         	b	0x700a256c <Sciclient_sendMessage+0xec> @ imm = #-0x2
;     if ((((uint32_t) gSecHeaderSizeWords*4U)+(SCICLIENT_HEADER_SIZE_IN_WORDS*4U)+payloadSize) <=
700a256c: f242 7014    	movw	r0, #0x2714
700a2570: f2c7 000b    	movt	r0, #0x700b
700a2574: 7801         	ldrb	r1, [r0]
700a2576: 980c         	ldr	r0, [sp, #0x30]
700a2578: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a257c: 3008         	adds	r0, #0x8
;         (gSciclientHandle.maxMsgSizeBytes - 4U))
700a257e: f242 6108    	movw	r1, #0x2608
700a2582: f2c7 010b    	movt	r1, #0x700b
700a2586: 6949         	ldr	r1, [r1, #0x14]
700a2588: 3904         	subs	r1, #0x4
;     if ((((uint32_t) gSecHeaderSizeWords*4U)+(SCICLIENT_HEADER_SIZE_IN_WORDS*4U)+payloadSize) <=
700a258a: 4288         	cmp	r0, r1
700a258c: d817         	bhi	0x700a25be <Sciclient_sendMessage+0x13e> @ imm = #0x2e
700a258e: e7ff         	b	0x700a2590 <Sciclient_sendMessage+0x110> @ imm = #-0x2
;         threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U) +
700a2590: 9909         	ldr	r1, [sp, #0x24]
700a2592: f242 5080    	movw	r0, #0x2580
700a2596: f2c7 000b    	movt	r0, #0x700b
700a259a: 2200         	movs	r2, #0x0
700a259c: 9200         	str	r2, [sp]
700a259e: f00c fe67    	bl	0x700af270 <CSL_secProxyGetDataAddr> @ imm = #0xccce
700a25a2: 9900         	ldr	r1, [sp]
700a25a4: 4602         	mov	r2, r0
;         ((uintptr_t) gSciclientHandle.maxMsgSizeBytes  - (uintptr_t) 4U) ;
700a25a6: f242 6008    	movw	r0, #0x2608
700a25aa: f2c7 000b    	movt	r0, #0x700b
700a25ae: 6940         	ldr	r0, [r0, #0x14]
;         threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U) +
700a25b0: 4410         	add	r0, r2
700a25b2: 3804         	subs	r0, #0x4
700a25b4: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(threadAddr,0U);
700a25b6: 9801         	ldr	r0, [sp, #0x4]
700a25b8: f00d f912    	bl	0x700af7e0 <CSL_REG32_WR_RAW> @ imm = #0xd224
;     }
700a25bc: e7ff         	b	0x700a25be <Sciclient_sendMessage+0x13e> @ imm = #-0x2
; }
700a25be: b00a         	add	sp, #0x28
700a25c0: bd80         	pop	{r7, pc}
		...
700a25ce: 0000         	movs	r0, r0

700a25d0 <Sciclient_rmIaValidateMapping>:
; {
700a25d0: b580         	push	{r7, lr}
700a25d2: b088         	sub	sp, #0x20
700a25d4: 4684         	mov	r12, r0
700a25d6: 980a         	ldr	r0, [sp, #0x28]
700a25d8: f88d c01f    	strb.w	r12, [sp, #0x1f]
700a25dc: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a25e0: f8ad 201a    	strh.w	r2, [sp, #0x1a]
700a25e4: f8ad 3018    	strh.w	r3, [sp, #0x18]
700a25e8: f88d 0017    	strb.w	r0, [sp, #0x17]
700a25ec: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a25ee: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIaInst *inst = NULL;
700a25f0: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIaGetInst(id);
700a25f2: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a25f6: f009 fe7b    	bl	0x700ac2f0 <Sciclient_rmIaGetInst> @ imm = #0x9cf6
700a25fa: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a25fc: 9803         	ldr	r0, [sp, #0xc]
700a25fe: b920         	cbnz	r0, 0x700a260a <Sciclient_rmIaValidateMapping+0x3a> @ imm = #0x8
700a2600: e7ff         	b	0x700a2602 <Sciclient_rmIaValidateMapping+0x32> @ imm = #-0x2
700a2602: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a2606: 9004         	str	r0, [sp, #0x10]
;     } else {
700a2608: e00b         	b	0x700a2622 <Sciclient_rmIaValidateMapping+0x52> @ imm = #0x16
;         if (vint >= inst->n_vint) {
700a260a: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a260e: 9903         	ldr	r1, [sp, #0xc]
700a2610: 8989         	ldrh	r1, [r1, #0xc]
700a2612: 4288         	cmp	r0, r1
700a2614: db04         	blt	0x700a2620 <Sciclient_rmIaValidateMapping+0x50> @ imm = #0x8
700a2616: e7ff         	b	0x700a2618 <Sciclient_rmIaValidateMapping+0x48> @ imm = #-0x2
700a2618: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a261c: 9004         	str	r0, [sp, #0x10]
;         }
700a261e: e7ff         	b	0x700a2620 <Sciclient_rmIaValidateMapping+0x50> @ imm = #-0x2
700a2620: e7ff         	b	0x700a2622 <Sciclient_rmIaValidateMapping+0x52> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (vint_sb_index >= SCICLIENT_IA_VINT_MAX_BITS)) {
700a2622: 9804         	ldr	r0, [sp, #0x10]
700a2624: b948         	cbnz	r0, 0x700a263a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #0x12
700a2626: e7ff         	b	0x700a2628 <Sciclient_rmIaValidateMapping+0x58> @ imm = #-0x2
700a2628: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a262c: 2840         	cmp	r0, #0x40
700a262e: d304         	blo	0x700a263a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #0x8
700a2630: e7ff         	b	0x700a2632 <Sciclient_rmIaValidateMapping+0x62> @ imm = #-0x2
700a2632: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a2636: 9004         	str	r0, [sp, #0x10]
;     }
700a2638: e7ff         	b	0x700a263a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a263a: 9804         	ldr	r0, [sp, #0x10]
700a263c: b998         	cbnz	r0, 0x700a2666 <Sciclient_rmIaValidateMapping+0x96> @ imm = #0x26
700a263e: e7ff         	b	0x700a2640 <Sciclient_rmIaValidateMapping+0x70> @ imm = #-0x2
;         evt = global_evt - inst->sevt_offset;
700a2640: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a2644: 9903         	ldr	r1, [sp, #0xc]
700a2646: 8909         	ldrh	r1, [r1, #0x8]
700a2648: 1a40         	subs	r0, r0, r1
700a264a: f8ad 000a    	strh.w	r0, [sp, #0xa]
;         if (evt >= inst->n_sevt) {
700a264e: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a2652: 9903         	ldr	r1, [sp, #0xc]
700a2654: 8949         	ldrh	r1, [r1, #0xa]
700a2656: 4288         	cmp	r0, r1
700a2658: db04         	blt	0x700a2664 <Sciclient_rmIaValidateMapping+0x94> @ imm = #0x8
700a265a: e7ff         	b	0x700a265c <Sciclient_rmIaValidateMapping+0x8c> @ imm = #-0x2
700a265c: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a2660: 9004         	str	r0, [sp, #0x10]
;         }
700a2662: e7ff         	b	0x700a2664 <Sciclient_rmIaValidateMapping+0x94> @ imm = #-0x2
;     }
700a2664: e7ff         	b	0x700a2666 <Sciclient_rmIaValidateMapping+0x96> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a2666: 9804         	ldr	r0, [sp, #0x10]
700a2668: 2800         	cmp	r0, #0x0
700a266a: d14e         	bne	0x700a270a <Sciclient_rmIaValidateMapping+0x13a> @ imm = #0x9c
700a266c: e7ff         	b	0x700a266e <Sciclient_rmIaValidateMapping+0x9e> @ imm = #-0x2
;         entry_int_map_lo = (volatile uint32_t *)(inst->imap + SCICLIENT_IA_ENTRY_INTMAP_LO(evt));
700a266e: 9803         	ldr	r0, [sp, #0xc]
700a2670: 6840         	ldr	r0, [r0, #0x4]
700a2672: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700a2676: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a267a: 9001         	str	r0, [sp, #0x4]
;         reg_vint = CSL_REG32_FEXT(entry_int_map_lo,
700a267c: 9801         	ldr	r0, [sp, #0x4]
700a267e: f64f 7100    	movw	r1, #0xff00
700a2682: f2c0 0101    	movt	r1, #0x1
700a2686: 2208         	movs	r2, #0x8
700a2688: f00c fc12    	bl	0x700aeeb0 <CSL_REG32_FEXT_RAW> @ imm = #0xc824
700a268c: f8ad 0002    	strh.w	r0, [sp, #0x2]
;         reg_sb = CSL_REG32_FEXT(entry_int_map_lo,
700a2690: 9801         	ldr	r0, [sp, #0x4]
700a2692: 213f         	movs	r1, #0x3f
700a2694: 2200         	movs	r2, #0x0
700a2696: f00c fc0b    	bl	0x700aeeb0 <CSL_REG32_FEXT_RAW> @ imm = #0xc816
700a269a: f8ad 0000    	strh.w	r0, [sp]
;         if ((reg_vint == 0u) && (reg_sb == 0u)) {
700a269e: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a26a2: b9f0         	cbnz	r0, 0x700a26e2 <Sciclient_rmIaValidateMapping+0x112> @ imm = #0x3c
700a26a4: e7ff         	b	0x700a26a6 <Sciclient_rmIaValidateMapping+0xd6> @ imm = #-0x2
700a26a6: f8bd 0000    	ldrh.w	r0, [sp]
700a26aa: b9d0         	cbnz	r0, 0x700a26e2 <Sciclient_rmIaValidateMapping+0x112> @ imm = #0x34
700a26ac: e7ff         	b	0x700a26ae <Sciclient_rmIaValidateMapping+0xde> @ imm = #-0x2
;             if ((vint != reg_vint) &&
700a26ae: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a26b2: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a26b6: 4288         	cmp	r0, r1
700a26b8: d012         	beq	0x700a26e0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x24
700a26ba: e7ff         	b	0x700a26bc <Sciclient_rmIaValidateMapping+0xec> @ imm = #-0x2
;                 (vint_sb_index != reg_sb) &&
700a26bc: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a26c0: f8bd 1000    	ldrh.w	r1, [sp]
700a26c4: 4288         	cmp	r0, r1
700a26c6: d00b         	beq	0x700a26e0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x16
700a26c8: e7ff         	b	0x700a26ca <Sciclient_rmIaValidateMapping+0xfa> @ imm = #-0x2
;                 (evt != inst->v0_b0_evt)) {
700a26ca: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a26ce: 9903         	ldr	r1, [sp, #0xc]
700a26d0: 8a89         	ldrh	r1, [r1, #0x14]
;             if ((vint != reg_vint) &&
700a26d2: 4288         	cmp	r0, r1
700a26d4: d004         	beq	0x700a26e0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x8
700a26d6: e7ff         	b	0x700a26d8 <Sciclient_rmIaValidateMapping+0x108> @ imm = #-0x2
700a26d8: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a26dc: 9004         	str	r0, [sp, #0x10]
;             }
700a26de: e7ff         	b	0x700a26e0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #-0x2
;         } else {
700a26e0: e012         	b	0x700a2708 <Sciclient_rmIaValidateMapping+0x138> @ imm = #0x24
;             if ((vint != reg_vint) &&
700a26e2: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a26e6: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a26ea: 4288         	cmp	r0, r1
700a26ec: d00b         	beq	0x700a2706 <Sciclient_rmIaValidateMapping+0x136> @ imm = #0x16
700a26ee: e7ff         	b	0x700a26f0 <Sciclient_rmIaValidateMapping+0x120> @ imm = #-0x2
;                 (vint_sb_index != reg_sb)) {
700a26f0: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a26f4: f8bd 1000    	ldrh.w	r1, [sp]
;             if ((vint != reg_vint) &&
700a26f8: 4288         	cmp	r0, r1
700a26fa: d004         	beq	0x700a2706 <Sciclient_rmIaValidateMapping+0x136> @ imm = #0x8
700a26fc: e7ff         	b	0x700a26fe <Sciclient_rmIaValidateMapping+0x12e> @ imm = #-0x2
700a26fe: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a2702: 9004         	str	r0, [sp, #0x10]
;             }
700a2704: e7ff         	b	0x700a2706 <Sciclient_rmIaValidateMapping+0x136> @ imm = #-0x2
700a2706: e7ff         	b	0x700a2708 <Sciclient_rmIaValidateMapping+0x138> @ imm = #-0x2
;     }
700a2708: e7ff         	b	0x700a270a <Sciclient_rmIaValidateMapping+0x13a> @ imm = #-0x2
;     return r;
700a270a: 9804         	ldr	r0, [sp, #0x10]
700a270c: b008         	add	sp, #0x20
700a270e: bd80         	pop	{r7, pc}

700a2710 <Udma_rmAllocMappedRing>:
; {
700a2710: b580         	push	{r7, lr}
700a2712: b090         	sub	sp, #0x40
700a2714: 900f         	str	r0, [sp, #0x3c]
700a2716: 910e         	str	r1, [sp, #0x38]
700a2718: 920d         	str	r2, [sp, #0x34]
700a271a: f64f 70ff    	movw	r0, #0xffff
;     uint32_t    ringNum = UDMA_RING_INVALID;
700a271e: 900c         	str	r0, [sp, #0x30]
700a2720: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a2722: 9005         	str	r0, [sp, #0x14]
;     Udma_RmInitPrms             *rmInitPrms = &drvHandle->rmInitPrms;
700a2724: 980f         	ldr	r0, [sp, #0x3c]
700a2726: f500 70ea    	add.w	r0, r0, #0x1d4
700a272a: 9004         	str	r0, [sp, #0x10]
;     retVal = Udma_getMappedChRingAttributes(drvHandle, mappedRingGrp, mappedChNum, &chAttr);
700a272c: 980f         	ldr	r0, [sp, #0x3c]
700a272e: 990e         	ldr	r1, [sp, #0x38]
700a2730: 9a0d         	ldr	r2, [sp, #0x34]
700a2732: ab01         	add	r3, sp, #0x4
700a2734: f005 fa2c    	bl	0x700a7b90 <Udma_getMappedChRingAttributes> @ imm = #0x5458
700a2738: 9005         	str	r0, [sp, #0x14]
;     if(UDMA_SOK == retVal)
700a273a: 9805         	ldr	r0, [sp, #0x14]
700a273c: 2800         	cmp	r0, #0x0
700a273e: f040 8084    	bne.w	0x700a284a <Udma_rmAllocMappedRing+0x13a> @ imm = #0x108
700a2742: e7ff         	b	0x700a2744 <Udma_rmAllocMappedRing+0x34> @ imm = #-0x2
700a2744: 2000         	movs	r0, #0x0
;         loopStart = 0;
700a2746: 9007         	str	r0, [sp, #0x1c]
;         loopMax   = rmInitPrms->numMappedRing[mappedRingGrp];
700a2748: 9804         	ldr	r0, [sp, #0x10]
700a274a: 990e         	ldr	r1, [sp, #0x38]
700a274c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2750: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
700a2754: 9006         	str	r0, [sp, #0x18]
;         if(chAttr.startFreeRing > rmInitPrms->startMappedRing[mappedRingGrp])
700a2756: 9802         	ldr	r0, [sp, #0x8]
700a2758: 9904         	ldr	r1, [sp, #0x10]
700a275a: 9a0e         	ldr	r2, [sp, #0x38]
700a275c: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a2760: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a2764: 4288         	cmp	r0, r1
700a2766: d90a         	bls	0x700a277e <Udma_rmAllocMappedRing+0x6e> @ imm = #0x14
700a2768: e7ff         	b	0x700a276a <Udma_rmAllocMappedRing+0x5a> @ imm = #-0x2
;             loopStart = chAttr.startFreeRing - rmInitPrms->startMappedRing[mappedRingGrp];
700a276a: 9802         	ldr	r0, [sp, #0x8]
700a276c: 9904         	ldr	r1, [sp, #0x10]
700a276e: 9a0e         	ldr	r2, [sp, #0x38]
700a2770: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a2774: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a2778: 1a40         	subs	r0, r0, r1
700a277a: 9007         	str	r0, [sp, #0x1c]
;         }
700a277c: e7ff         	b	0x700a277e <Udma_rmAllocMappedRing+0x6e> @ imm = #-0x2
;         if((chAttr.startFreeRing + chAttr.numFreeRing) < (rmInitPrms->startMappedRing[mappedRingGrp] + rmInitPrms->numMappedRing[mappedRingGrp]))
700a277e: 9802         	ldr	r0, [sp, #0x8]
700a2780: 9903         	ldr	r1, [sp, #0xc]
700a2782: 4408         	add	r0, r1
700a2784: 9904         	ldr	r1, [sp, #0x10]
700a2786: 9a0e         	ldr	r2, [sp, #0x38]
700a2788: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a278c: f8d2 1088    	ldr.w	r1, [r2, #0x88]
700a2790: f8d2 20a8    	ldr.w	r2, [r2, #0xa8]
700a2794: 4411         	add	r1, r2
700a2796: 4288         	cmp	r0, r1
700a2798: d20c         	bhs	0x700a27b4 <Udma_rmAllocMappedRing+0xa4> @ imm = #0x18
700a279a: e7ff         	b	0x700a279c <Udma_rmAllocMappedRing+0x8c> @ imm = #-0x2
;             loopMax = (chAttr.startFreeRing + chAttr.numFreeRing) - rmInitPrms->startMappedRing[mappedRingGrp];
700a279c: 9802         	ldr	r0, [sp, #0x8]
700a279e: 9903         	ldr	r1, [sp, #0xc]
700a27a0: 4408         	add	r0, r1
700a27a2: 9904         	ldr	r1, [sp, #0x10]
700a27a4: 9a0e         	ldr	r2, [sp, #0x38]
700a27a6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a27aa: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a27ae: 1a40         	subs	r0, r0, r1
700a27b0: 9006         	str	r0, [sp, #0x18]
;         }
700a27b2: e7ff         	b	0x700a27b4 <Udma_rmAllocMappedRing+0xa4> @ imm = #-0x2
;         SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a27b4: 980f         	ldr	r0, [sp, #0x3c]
700a27b6: f500 609f    	add.w	r0, r0, #0x4f8
700a27ba: f04f 31ff    	mov.w	r1, #0xffffffff
700a27be: f007 fedf    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x7dbe
;         for(i = loopStart; i < loopMax; i++)
700a27c2: 9807         	ldr	r0, [sp, #0x1c]
700a27c4: 900b         	str	r0, [sp, #0x2c]
700a27c6: e7ff         	b	0x700a27c8 <Udma_rmAllocMappedRing+0xb8> @ imm = #-0x2
700a27c8: 980b         	ldr	r0, [sp, #0x2c]
700a27ca: 9906         	ldr	r1, [sp, #0x18]
700a27cc: 4288         	cmp	r0, r1
700a27ce: d236         	bhs	0x700a283e <Udma_rmAllocMappedRing+0x12e> @ imm = #0x6c
700a27d0: e7ff         	b	0x700a27d2 <Udma_rmAllocMappedRing+0xc2> @ imm = #-0x2
;             offset = i >> 5U;
700a27d2: 980b         	ldr	r0, [sp, #0x2c]
700a27d4: 0940         	lsrs	r0, r0, #0x5
700a27d6: 900a         	str	r0, [sp, #0x28]
;             bitPos = i - (offset << 5U);
700a27d8: 980b         	ldr	r0, [sp, #0x2c]
700a27da: 990a         	ldr	r1, [sp, #0x28]
700a27dc: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a27e0: 9009         	str	r0, [sp, #0x24]
;             bitMask = (uint32_t) 1U << bitPos;
700a27e2: 9909         	ldr	r1, [sp, #0x24]
700a27e4: 2001         	movs	r0, #0x1
700a27e6: 4088         	lsls	r0, r1
700a27e8: 9008         	str	r0, [sp, #0x20]
;             if((drvHandle->mappedRingFlag[mappedRingGrp][offset] & bitMask) == bitMask)
700a27ea: 980f         	ldr	r0, [sp, #0x3c]
700a27ec: 990e         	ldr	r1, [sp, #0x38]
700a27ee: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a27f2: 990a         	ldr	r1, [sp, #0x28]
700a27f4: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a27f8: f8d0 0344    	ldr.w	r0, [r0, #0x344]
700a27fc: 9908         	ldr	r1, [sp, #0x20]
700a27fe: 4008         	ands	r0, r1
700a2800: 4288         	cmp	r0, r1
700a2802: d117         	bne	0x700a2834 <Udma_rmAllocMappedRing+0x124> @ imm = #0x2e
700a2804: e7ff         	b	0x700a2806 <Udma_rmAllocMappedRing+0xf6> @ imm = #-0x2
;                 drvHandle->mappedRingFlag[mappedRingGrp][offset] &= ~bitMask;
700a2806: 9a08         	ldr	r2, [sp, #0x20]
700a2808: 980f         	ldr	r0, [sp, #0x3c]
700a280a: 990e         	ldr	r1, [sp, #0x38]
700a280c: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a2810: 990a         	ldr	r1, [sp, #0x28]
700a2812: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a2816: f8d1 0344    	ldr.w	r0, [r1, #0x344]
700a281a: 4390         	bics	r0, r2
700a281c: f8c1 0344    	str.w	r0, [r1, #0x344]
;                 ringNum = i + rmInitPrms->startMappedRing[mappedRingGrp];  /* Add start offset */
700a2820: 980b         	ldr	r0, [sp, #0x2c]
700a2822: 9904         	ldr	r1, [sp, #0x10]
700a2824: 9a0e         	ldr	r2, [sp, #0x38]
700a2826: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a282a: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a282e: 4408         	add	r0, r1
700a2830: 900c         	str	r0, [sp, #0x30]
;                 break;
700a2832: e004         	b	0x700a283e <Udma_rmAllocMappedRing+0x12e> @ imm = #0x8
;         }
700a2834: e7ff         	b	0x700a2836 <Udma_rmAllocMappedRing+0x126> @ imm = #-0x2
;         for(i = loopStart; i < loopMax; i++)
700a2836: 980b         	ldr	r0, [sp, #0x2c]
700a2838: 3001         	adds	r0, #0x1
700a283a: 900b         	str	r0, [sp, #0x2c]
700a283c: e7c4         	b	0x700a27c8 <Udma_rmAllocMappedRing+0xb8> @ imm = #-0x78
;         SemaphoreP_post(&drvHandle->rmLockObj);
700a283e: 980f         	ldr	r0, [sp, #0x3c]
700a2840: f500 609f    	add.w	r0, r0, #0x4f8
700a2844: f009 fa2c    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x9458
;     }
700a2848: e7ff         	b	0x700a284a <Udma_rmAllocMappedRing+0x13a> @ imm = #-0x2
;     return (ringNum);
700a284a: 980c         	ldr	r0, [sp, #0x30]
700a284c: b010         	add	sp, #0x40
700a284e: bd80         	pop	{r7, pc}

700a2850 <UART_procLineStatusErr>:
; {
700a2850: b580         	push	{r7, lr}
700a2852: b086         	sub	sp, #0x18
700a2854: 9005         	str	r0, [sp, #0x14]
700a2856: 2000         	movs	r0, #0x0
;     int32_t            status = UART_STATUS_SUCCESS;
700a2858: 9004         	str	r0, [sp, #0x10]
;     uint32_t           lineStatus, iteration = 0U;
700a285a: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == hUart)
700a285c: 9805         	ldr	r0, [sp, #0x14]
700a285e: b920         	cbnz	r0, 0x700a286a <UART_procLineStatusErr+0x1a> @ imm = #0x8
700a2860: e7ff         	b	0x700a2862 <UART_procLineStatusErr+0x12> @ imm = #-0x2
700a2862: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a2866: 9004         	str	r0, [sp, #0x10]
;     }
700a2868: e7ff         	b	0x700a286a <UART_procLineStatusErr+0x1a> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a286a: 9804         	ldr	r0, [sp, #0x10]
700a286c: 2800         	cmp	r0, #0x0
700a286e: f040 808b    	bne.w	0x700a2988 <UART_procLineStatusErr+0x138> @ imm = #0x116
700a2872: e7ff         	b	0x700a2874 <UART_procLineStatusErr+0x24> @ imm = #-0x2
;         lineStatus = UART_readLineStatus(hUart->baseAddr);
700a2874: 9805         	ldr	r0, [sp, #0x14]
700a2876: 6800         	ldr	r0, [r0]
700a2878: f00a fec2    	bl	0x700ad600 <UART_readLineStatus> @ imm = #0xad84
700a287c: 9003         	str	r0, [sp, #0xc]
;         if(((lineStatus & UART_FIFO_PE_FE_BI_DETECTED) == UART_FIFO_PE_FE_BI_DETECTED)
700a287e: 9803         	ldr	r0, [sp, #0xc]
700a2880: f000 0080    	and	r0, r0, #0x80
;                 || ((lineStatus & UART_OVERRUN_ERROR) == UART_OVERRUN_ERROR))
700a2884: 2880         	cmp	r0, #0x80
700a2886: d006         	beq	0x700a2896 <UART_procLineStatusErr+0x46> @ imm = #0xc
700a2888: e7ff         	b	0x700a288a <UART_procLineStatusErr+0x3a> @ imm = #-0x2
;         if(((lineStatus & UART_FIFO_PE_FE_BI_DETECTED) == UART_FIFO_PE_FE_BI_DETECTED)
700a288a: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a288e: 0780         	lsls	r0, r0, #0x1e
700a2890: 2800         	cmp	r0, #0x0
700a2892: d578         	bpl	0x700a2986 <UART_procLineStatusErr+0x136> @ imm = #0xf0
700a2894: e7ff         	b	0x700a2896 <UART_procLineStatusErr+0x46> @ imm = #-0x2
;             if (hUart->readTrans.buf != NULL)
700a2896: 9805         	ldr	r0, [sp, #0x14]
700a2898: 6a80         	ldr	r0, [r0, #0x28]
700a289a: b120         	cbz	r0, 0x700a28a6 <UART_procLineStatusErr+0x56> @ imm = #0x8
700a289c: e7ff         	b	0x700a289e <UART_procLineStatusErr+0x4e> @ imm = #-0x2
;                 hUart->readTrans.count = (uint32_t)(hUart->readCount);
700a289e: 9905         	ldr	r1, [sp, #0x14]
700a28a0: 6988         	ldr	r0, [r1, #0x18]
700a28a2: 62c8         	str	r0, [r1, #0x2c]
;             }
700a28a4: e7ff         	b	0x700a28a6 <UART_procLineStatusErr+0x56> @ imm = #-0x2
700a28a6: 2040         	movs	r0, #0x40
;             iteration = UART_FIFO_SIZE;
700a28a8: 9002         	str	r0, [sp, #0x8]
;             do
700a28aa: e7ff         	b	0x700a28ac <UART_procLineStatusErr+0x5c> @ imm = #-0x2
;                 (void)UART_fifoCharGet(hUart->baseAddr);
700a28ac: 9805         	ldr	r0, [sp, #0x14]
700a28ae: 6800         	ldr	r0, [r0]
700a28b0: f00c fd4e    	bl	0x700af350 <UART_fifoCharGet> @ imm = #0xca9c
;                 iteration--;
700a28b4: 9802         	ldr	r0, [sp, #0x8]
700a28b6: 3801         	subs	r0, #0x1
700a28b8: 9002         	str	r0, [sp, #0x8]
;                 lineStatus = (uint32_t) UART_readLineStatus(hUart->baseAddr);
700a28ba: 9805         	ldr	r0, [sp, #0x14]
700a28bc: 6800         	ldr	r0, [r0]
700a28be: f00a fe9f    	bl	0x700ad600 <UART_readLineStatus> @ imm = #0xad3e
700a28c2: 9003         	str	r0, [sp, #0xc]
;                 lineStatus &= (UART_LSR_RX_FIFO_STS_MASK |
700a28c4: 9803         	ldr	r0, [sp, #0xc]
700a28c6: f000 009f    	and	r0, r0, #0x9f
700a28ca: 9003         	str	r0, [sp, #0xc]
;             }
700a28cc: e7ff         	b	0x700a28ce <UART_procLineStatusErr+0x7e> @ imm = #-0x2
;             while ((lineStatus != 0U) && (iteration != 0U));
700a28ce: 9903         	ldr	r1, [sp, #0xc]
700a28d0: 2000         	movs	r0, #0x0
700a28d2: 9001         	str	r0, [sp, #0x4]
700a28d4: b131         	cbz	r1, 0x700a28e4 <UART_procLineStatusErr+0x94> @ imm = #0xc
700a28d6: e7ff         	b	0x700a28d8 <UART_procLineStatusErr+0x88> @ imm = #-0x2
700a28d8: 9802         	ldr	r0, [sp, #0x8]
700a28da: 2800         	cmp	r0, #0x0
700a28dc: bf18         	it	ne
700a28de: 2001         	movne	r0, #0x1
700a28e0: 9001         	str	r0, [sp, #0x4]
700a28e2: e7ff         	b	0x700a28e4 <UART_procLineStatusErr+0x94> @ imm = #-0x2
700a28e4: 9801         	ldr	r0, [sp, #0x4]
;             }
700a28e6: 07c0         	lsls	r0, r0, #0x1f
700a28e8: 2800         	cmp	r0, #0x0
700a28ea: d1df         	bne	0x700a28ac <UART_procLineStatusErr+0x5c> @ imm = #-0x42
700a28ec: e7ff         	b	0x700a28ee <UART_procLineStatusErr+0x9e> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a28ee: 9805         	ldr	r0, [sp, #0x14]
700a28f0: 6800         	ldr	r0, [r0]
700a28f2: 2105         	movs	r1, #0x5
700a28f4: f003 fba4    	bl	0x700a6040 <UART_intrDisable> @ imm = #0x3748
;             hUart->readBuf = (void *)((uint8_t *)hUart->readBuf - hUart->readCount);
700a28f8: 9905         	ldr	r1, [sp, #0x14]
700a28fa: 6948         	ldr	r0, [r1, #0x14]
700a28fc: 698a         	ldr	r2, [r1, #0x18]
700a28fe: 1a80         	subs	r0, r0, r2
700a2900: 6148         	str	r0, [r1, #0x14]
;             if (hUart->readTrans.buf != NULL)
700a2902: 9805         	ldr	r0, [sp, #0x14]
700a2904: 6a80         	ldr	r0, [r0, #0x28]
700a2906: b3a8         	cbz	r0, 0x700a2974 <UART_procLineStatusErr+0x124> @ imm = #0x6a
700a2908: e7ff         	b	0x700a290a <UART_procLineStatusErr+0xba> @ imm = #-0x2
;                 if ((lineStatus & UART_BREAK_DETECTED_ERROR) != 0U)
700a290a: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a290e: 06c0         	lsls	r0, r0, #0x1b
700a2910: 2800         	cmp	r0, #0x0
700a2912: d508         	bpl	0x700a2926 <UART_procLineStatusErr+0xd6> @ imm = #0x10
700a2914: e7ff         	b	0x700a2916 <UART_procLineStatusErr+0xc6> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_BI;
700a2916: 9905         	ldr	r1, [sp, #0x14]
700a2918: 2002         	movs	r0, #0x2
700a291a: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a291c: 9905         	ldr	r1, [sp, #0x14]
700a291e: 6a48         	ldr	r0, [r1, #0x24]
700a2920: 3001         	adds	r0, #0x1
700a2922: 6248         	str	r0, [r1, #0x24]
;                 }
700a2924: e025         	b	0x700a2972 <UART_procLineStatusErr+0x122> @ imm = #0x4a
;                 else if ((lineStatus & UART_FRAMING_ERROR) != 0U)
700a2926: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a292a: 0700         	lsls	r0, r0, #0x1c
700a292c: 2800         	cmp	r0, #0x0
700a292e: d508         	bpl	0x700a2942 <UART_procLineStatusErr+0xf2> @ imm = #0x10
700a2930: e7ff         	b	0x700a2932 <UART_procLineStatusErr+0xe2> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_FE;
700a2932: 9905         	ldr	r1, [sp, #0x14]
700a2934: 2003         	movs	r0, #0x3
700a2936: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a2938: 9905         	ldr	r1, [sp, #0x14]
700a293a: 6a48         	ldr	r0, [r1, #0x24]
700a293c: 3001         	adds	r0, #0x1
700a293e: 6248         	str	r0, [r1, #0x24]
;                 }
700a2940: e016         	b	0x700a2970 <UART_procLineStatusErr+0x120> @ imm = #0x2c
;                 else if ((lineStatus & UART_PARITY_ERROR) != 0U)
700a2942: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a2946: 0740         	lsls	r0, r0, #0x1d
700a2948: 2800         	cmp	r0, #0x0
700a294a: d508         	bpl	0x700a295e <UART_procLineStatusErr+0x10e> @ imm = #0x10
700a294c: e7ff         	b	0x700a294e <UART_procLineStatusErr+0xfe> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_PE;
700a294e: 9905         	ldr	r1, [sp, #0x14]
700a2950: 2004         	movs	r0, #0x4
700a2952: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a2954: 9905         	ldr	r1, [sp, #0x14]
700a2956: 6a48         	ldr	r0, [r1, #0x24]
700a2958: 3001         	adds	r0, #0x1
700a295a: 6248         	str	r0, [r1, #0x24]
;                 }
700a295c: e007         	b	0x700a296e <UART_procLineStatusErr+0x11e> @ imm = #0xe
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_OE;
700a295e: 9905         	ldr	r1, [sp, #0x14]
700a2960: 2005         	movs	r0, #0x5
700a2962: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a2964: 9905         	ldr	r1, [sp, #0x14]
700a2966: 6a48         	ldr	r0, [r1, #0x24]
700a2968: 3001         	adds	r0, #0x1
700a296a: 6248         	str	r0, [r1, #0x24]
700a296c: e7ff         	b	0x700a296e <UART_procLineStatusErr+0x11e> @ imm = #-0x2
700a296e: e7ff         	b	0x700a2970 <UART_procLineStatusErr+0x120> @ imm = #-0x2
700a2970: e7ff         	b	0x700a2972 <UART_procLineStatusErr+0x122> @ imm = #-0x2
;             }
700a2972: e7ff         	b	0x700a2974 <UART_procLineStatusErr+0x124> @ imm = #-0x2
;             hUart->hUartInit->errorCallbackFxn(hUart);
700a2974: 9805         	ldr	r0, [sp, #0x14]
700a2976: 6841         	ldr	r1, [r0, #0x4]
700a2978: 6e49         	ldr	r1, [r1, #0x64]
700a297a: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->readTrans);
700a297c: 9805         	ldr	r0, [sp, #0x14]
700a297e: 3028         	adds	r0, #0x28
700a2980: f00c fc16    	bl	0x700af1b0 <UART_lld_Transaction_deInit> @ imm = #0xc82c
;         }
700a2984: e7ff         	b	0x700a2986 <UART_procLineStatusErr+0x136> @ imm = #-0x2
;     }
700a2986: e7ff         	b	0x700a2988 <UART_procLineStatusErr+0x138> @ imm = #-0x2
;     return status;
700a2988: 9804         	ldr	r0, [sp, #0x10]
700a298a: b006         	add	sp, #0x18
700a298c: bd80         	pop	{r7, pc}
700a298e: 0000         	movs	r0, r0

700a2990 <prvProcessReceivedCommands>:
;     {
700a2990: b580         	push	{r7, lr}
700a2992: b08c         	sub	sp, #0x30
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
700a2994: e7ff         	b	0x700a2996 <prvProcessReceivedCommands+0x6> @ imm = #-0x2
700a2996: f242 7008    	movw	r0, #0x2708
700a299a: f2c7 000b    	movt	r0, #0x700b
700a299e: 6800         	ldr	r0, [r0]
700a29a0: a908         	add	r1, sp, #0x20
700a29a2: 2200         	movs	r2, #0x0
700a29a4: f000 fd6c    	bl	0x700a3480 <xQueueReceive> @ imm = #0xad8
700a29a8: 2800         	cmp	r0, #0x0
700a29aa: f000 808c    	beq.w	0x700a2ac6 <prvProcessReceivedCommands+0x136> @ imm = #0x118
700a29ae: e7ff         	b	0x700a29b0 <prvProcessReceivedCommands+0x20> @ imm = #-0x2
;                     if( xMessage.xMessageID < ( BaseType_t ) 0 )
700a29b0: 9808         	ldr	r0, [sp, #0x20]
700a29b2: f1b0 3fff    	cmp.w	r0, #0xffffffff
700a29b6: dc09         	bgt	0x700a29cc <prvProcessReceivedCommands+0x3c> @ imm = #0x12
700a29b8: e7ff         	b	0x700a29ba <prvProcessReceivedCommands+0x2a> @ imm = #-0x2
700a29ba: a808         	add	r0, sp, #0x20
;                         const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
700a29bc: 3004         	adds	r0, #0x4
700a29be: 9003         	str	r0, [sp, #0xc]
;                         pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
700a29c0: 9903         	ldr	r1, [sp, #0xc]
700a29c2: 680a         	ldr	r2, [r1]
700a29c4: 6848         	ldr	r0, [r1, #0x4]
700a29c6: 6889         	ldr	r1, [r1, #0x8]
700a29c8: 4790         	blx	r2
;                     }
700a29ca: e000         	b	0x700a29ce <prvProcessReceivedCommands+0x3e> @ imm = #0x0
700a29cc: e7ff         	b	0x700a29ce <prvProcessReceivedCommands+0x3e> @ imm = #-0x2
;             if( xMessage.xMessageID >= ( BaseType_t ) 0 )
700a29ce: 9808         	ldr	r0, [sp, #0x20]
700a29d0: 2800         	cmp	r0, #0x0
700a29d2: f100 8077    	bmi.w	0x700a2ac4 <prvProcessReceivedCommands+0x134> @ imm = #0xee
700a29d6: e7ff         	b	0x700a29d8 <prvProcessReceivedCommands+0x48> @ imm = #-0x2
;                 pxTimer = xMessage.u.xTimerParameters.pxTimer;
700a29d8: 980a         	ldr	r0, [sp, #0x28]
700a29da: 9007         	str	r0, [sp, #0x1c]
;                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
700a29dc: 9807         	ldr	r0, [sp, #0x1c]
700a29de: 6940         	ldr	r0, [r0, #0x14]
700a29e0: b128         	cbz	r0, 0x700a29ee <prvProcessReceivedCommands+0x5e> @ imm = #0xa
700a29e2: e7ff         	b	0x700a29e4 <prvProcessReceivedCommands+0x54> @ imm = #-0x2
;                     ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a29e4: 9807         	ldr	r0, [sp, #0x1c]
700a29e6: 3004         	adds	r0, #0x4
700a29e8: f00a fd42    	bl	0x700ad470 <uxListRemove> @ imm = #0xaa84
;                 }
700a29ec: e000         	b	0x700a29f0 <prvProcessReceivedCommands+0x60> @ imm = #0x0
700a29ee: e7ff         	b	0x700a29f0 <prvProcessReceivedCommands+0x60> @ imm = #-0x2
700a29f0: a806         	add	r0, sp, #0x18
;                 xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
700a29f2: f00a fea5    	bl	0x700ad740 <prvSampleTimeNow> @ imm = #0xad4a
700a29f6: 9004         	str	r0, [sp, #0x10]
;                 switch( xMessage.xMessageID )
700a29f8: 9808         	ldr	r0, [sp, #0x20]
700a29fa: 9002         	str	r0, [sp, #0x8]
700a29fc: 2809         	cmp	r0, #0x9
700a29fe: d85f         	bhi	0x700a2ac0 <prvProcessReceivedCommands+0x130> @ imm = #0xbe
700a2a00: 9902         	ldr	r1, [sp, #0x8]
700a2a02: e8df f001    	tbb	[pc, r1]
700a2a06: 05 05 05 2f  	.word	0x2f050505
700a2a0a: 37 49 05 05  	.word	0x05054937
700a2a0e: 2f 37        	.short	0x372f
;                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
700a2a10: 9907         	ldr	r1, [sp, #0x1c]
700a2a12: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2a16: f040 0001    	orr	r0, r0, #0x1
700a2a1a: f881 0028    	strb.w	r0, [r1, #0x28]
;                         if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
700a2a1e: 9807         	ldr	r0, [sp, #0x1c]
700a2a20: 9b09         	ldr	r3, [sp, #0x24]
700a2a22: 6981         	ldr	r1, [r0, #0x18]
700a2a24: 4419         	add	r1, r3
700a2a26: 9a04         	ldr	r2, [sp, #0x10]
700a2a28: f007 fc8a    	bl	0x700aa340 <prvInsertTimerInActiveList> @ imm = #0x7914
700a2a2c: b1c0         	cbz	r0, 0x700a2a60 <prvProcessReceivedCommands+0xd0> @ imm = #0x30
700a2a2e: e7ff         	b	0x700a2a30 <prvProcessReceivedCommands+0xa0> @ imm = #-0x2
;                             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a2a30: 9807         	ldr	r0, [sp, #0x1c]
700a2a32: 6a01         	ldr	r1, [r0, #0x20]
700a2a34: 4788         	blx	r1
;                             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a2a36: 9807         	ldr	r0, [sp, #0x1c]
700a2a38: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a2a3c: 0740         	lsls	r0, r0, #0x1d
700a2a3e: 2800         	cmp	r0, #0x0
700a2a40: d50c         	bpl	0x700a2a5c <prvProcessReceivedCommands+0xcc> @ imm = #0x18
700a2a42: e7ff         	b	0x700a2a44 <prvProcessReceivedCommands+0xb4> @ imm = #-0x2
;                                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
700a2a44: 9807         	ldr	r0, [sp, #0x1c]
700a2a46: 9909         	ldr	r1, [sp, #0x24]
700a2a48: 6982         	ldr	r2, [r0, #0x18]
700a2a4a: 440a         	add	r2, r1
700a2a4c: 4669         	mov	r1, sp
700a2a4e: 2300         	movs	r3, #0x0
700a2a50: 600b         	str	r3, [r1]
700a2a52: 4619         	mov	r1, r3
700a2a54: f006 ff44    	bl	0x700a98e0 <xTimerGenericCommand> @ imm = #0x6e88
700a2a58: 9005         	str	r0, [sp, #0x14]
;                             }
700a2a5a: e000         	b	0x700a2a5e <prvProcessReceivedCommands+0xce> @ imm = #0x0
700a2a5c: e7ff         	b	0x700a2a5e <prvProcessReceivedCommands+0xce> @ imm = #-0x2
;                         }
700a2a5e: e000         	b	0x700a2a62 <prvProcessReceivedCommands+0xd2> @ imm = #0x0
700a2a60: e7ff         	b	0x700a2a62 <prvProcessReceivedCommands+0xd2> @ imm = #-0x2
;                         break;
700a2a62: e02e         	b	0x700a2ac2 <prvProcessReceivedCommands+0x132> @ imm = #0x5c
;                         pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a2a64: 9907         	ldr	r1, [sp, #0x1c]
700a2a66: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2a6a: f000 00fe    	and	r0, r0, #0xfe
700a2a6e: f881 0028    	strb.w	r0, [r1, #0x28]
;                         break;
700a2a72: e026         	b	0x700a2ac2 <prvProcessReceivedCommands+0x132> @ imm = #0x4c
;                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
700a2a74: 9907         	ldr	r1, [sp, #0x1c]
700a2a76: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2a7a: f040 0001    	orr	r0, r0, #0x1
700a2a7e: f881 0028    	strb.w	r0, [r1, #0x28]
;                         pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
700a2a82: 9809         	ldr	r0, [sp, #0x24]
700a2a84: 9907         	ldr	r1, [sp, #0x1c]
700a2a86: 6188         	str	r0, [r1, #0x18]
;                         ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
700a2a88: 9807         	ldr	r0, [sp, #0x1c]
700a2a8a: 9b04         	ldr	r3, [sp, #0x10]
700a2a8c: 6981         	ldr	r1, [r0, #0x18]
700a2a8e: 4419         	add	r1, r3
700a2a90: 461a         	mov	r2, r3
700a2a92: f007 fc55    	bl	0x700aa340 <prvInsertTimerInActiveList> @ imm = #0x78aa
;                         break;
700a2a96: e014         	b	0x700a2ac2 <prvProcessReceivedCommands+0x132> @ imm = #0x28
;                                 if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
700a2a98: 9807         	ldr	r0, [sp, #0x1c]
700a2a9a: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a2a9e: 0780         	lsls	r0, r0, #0x1e
700a2aa0: 2800         	cmp	r0, #0x0
700a2aa2: d404         	bmi	0x700a2aae <prvProcessReceivedCommands+0x11e> @ imm = #0x8
700a2aa4: e7ff         	b	0x700a2aa6 <prvProcessReceivedCommands+0x116> @ imm = #-0x2
;                                     vPortFree( pxTimer );
700a2aa6: 9807         	ldr	r0, [sp, #0x1c]
700a2aa8: f00c fb12    	bl	0x700af0d0 <vPortFree>  @ imm = #0xc624
;                                 }
700a2aac: e007         	b	0x700a2abe <prvProcessReceivedCommands+0x12e> @ imm = #0xe
;                                     pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a2aae: 9907         	ldr	r1, [sp, #0x1c]
700a2ab0: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2ab4: f000 00fe    	and	r0, r0, #0xfe
700a2ab8: f881 0028    	strb.w	r0, [r1, #0x28]
700a2abc: e7ff         	b	0x700a2abe <prvProcessReceivedCommands+0x12e> @ imm = #-0x2
;                         break;
700a2abe: e000         	b	0x700a2ac2 <prvProcessReceivedCommands+0x132> @ imm = #0x0
;                         break;
700a2ac0: e7ff         	b	0x700a2ac2 <prvProcessReceivedCommands+0x132> @ imm = #-0x2
;             }
700a2ac2: e7ff         	b	0x700a2ac4 <prvProcessReceivedCommands+0x134> @ imm = #-0x2
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
700a2ac4: e767         	b	0x700a2996 <prvProcessReceivedCommands+0x6> @ imm = #-0x132
;     }
700a2ac6: b00c         	add	sp, #0x30
700a2ac8: bd80         	pop	{r7, pc}
700a2aca: 0000         	movs	r0, r0
700a2acc: 0000         	movs	r0, r0
700a2ace: 0000         	movs	r0, r0

700a2ad0 <_ntoa_long_long>:
; {
700a2ad0: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
700a2ad4: b09e         	sub	sp, #0x78
700a2ad6: 469e         	mov	lr, r3
700a2ad8: 4614         	mov	r4, r2
700a2ada: 460d         	mov	r5, r1
700a2adc: 4606         	mov	r6, r0
700a2ade: 9929         	ldr	r1, [sp, #0xa4]
700a2ae0: 9828         	ldr	r0, [sp, #0xa0]
700a2ae2: f8dd c094    	ldr.w	r12, [sp, #0x94]
700a2ae6: 9b24         	ldr	r3, [sp, #0x90]
700a2ae8: 9a2c         	ldr	r2, [sp, #0xb0]
700a2aea: 9a2b         	ldr	r2, [sp, #0xac]
700a2aec: 9a2a         	ldr	r2, [sp, #0xa8]
700a2aee: 9a26         	ldr	r2, [sp, #0x98]
700a2af0: 961d         	str	r6, [sp, #0x74]
700a2af2: 951c         	str	r5, [sp, #0x70]
700a2af4: 941b         	str	r4, [sp, #0x6c]
700a2af6: f8cd e068    	str.w	lr, [sp, #0x68]
700a2afa: f8cd c064    	str.w	r12, [sp, #0x64]
700a2afe: 9318         	str	r3, [sp, #0x60]
700a2b00: f88d 205f    	strb.w	r2, [sp, #0x5f]
700a2b04: 9115         	str	r1, [sp, #0x54]
700a2b06: 9014         	str	r0, [sp, #0x50]
700a2b08: 2000         	movs	r0, #0x0
;   size_t len = 0U;
700a2b0a: 900b         	str	r0, [sp, #0x2c]
;   if (!value) {
700a2b0c: 9818         	ldr	r0, [sp, #0x60]
700a2b0e: 9919         	ldr	r1, [sp, #0x64]
700a2b10: 4308         	orrs	r0, r1
700a2b12: b928         	cbnz	r0, 0x700a2b20 <_ntoa_long_long+0x50> @ imm = #0xa
700a2b14: e7ff         	b	0x700a2b16 <_ntoa_long_long+0x46> @ imm = #-0x2
;     flags &= ~FLAGS_HASH;
700a2b16: 982c         	ldr	r0, [sp, #0xb0]
700a2b18: f020 0010    	bic	r0, r0, #0x10
700a2b1c: 902c         	str	r0, [sp, #0xb0]
;   }
700a2b1e: e7ff         	b	0x700a2b20 <_ntoa_long_long+0x50> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION) || value) {
700a2b20: f89d 00b1    	ldrb.w	r0, [sp, #0xb1]
700a2b24: 0740         	lsls	r0, r0, #0x1d
700a2b26: 2800         	cmp	r0, #0x0
700a2b28: d506         	bpl	0x700a2b38 <_ntoa_long_long+0x68> @ imm = #0xc
700a2b2a: e7ff         	b	0x700a2b2c <_ntoa_long_long+0x5c> @ imm = #-0x2
700a2b2c: 9818         	ldr	r0, [sp, #0x60]
700a2b2e: 9919         	ldr	r1, [sp, #0x64]
700a2b30: 4308         	orrs	r0, r1
700a2b32: 2800         	cmp	r0, #0x0
700a2b34: d043         	beq	0x700a2bbe <_ntoa_long_long+0xee> @ imm = #0x86
700a2b36: e7ff         	b	0x700a2b38 <_ntoa_long_long+0x68> @ imm = #-0x2
;     do {
700a2b38: e7ff         	b	0x700a2b3a <_ntoa_long_long+0x6a> @ imm = #-0x2
;       const char digit = (char)(value % base);
700a2b3a: 9818         	ldr	r0, [sp, #0x60]
700a2b3c: 9919         	ldr	r1, [sp, #0x64]
700a2b3e: 9a14         	ldr	r2, [sp, #0x50]
700a2b40: 9b15         	ldr	r3, [sp, #0x54]
700a2b42: f00c e9f8    	blx	0x700aef34 <__aeabi_uldivmod> @ imm = #0xc3f0
700a2b46: f88d 202b    	strb.w	r2, [sp, #0x2b]
;       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
700a2b4a: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
700a2b4e: 2809         	cmp	r0, #0x9
700a2b50: dc05         	bgt	0x700a2b5e <_ntoa_long_long+0x8e> @ imm = #0xa
700a2b52: e7ff         	b	0x700a2b54 <_ntoa_long_long+0x84> @ imm = #-0x2
700a2b54: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
700a2b58: 3030         	adds	r0, #0x30
700a2b5a: 9009         	str	r0, [sp, #0x24]
700a2b5c: e00c         	b	0x700a2b78 <_ntoa_long_long+0xa8> @ imm = #0x18
700a2b5e: f89d 00b0    	ldrb.w	r0, [sp, #0xb0]
700a2b62: 0681         	lsls	r1, r0, #0x1a
700a2b64: 2061         	movs	r0, #0x61
700a2b66: 2900         	cmp	r1, #0x0
700a2b68: bf48         	it	mi
700a2b6a: 2041         	movmi	r0, #0x41
700a2b6c: f89d 102b    	ldrb.w	r1, [sp, #0x2b]
700a2b70: 4408         	add	r0, r1
700a2b72: 380a         	subs	r0, #0xa
700a2b74: 9009         	str	r0, [sp, #0x24]
700a2b76: e7ff         	b	0x700a2b78 <_ntoa_long_long+0xa8> @ imm = #-0x2
700a2b78: 9809         	ldr	r0, [sp, #0x24]
700a2b7a: 9a0b         	ldr	r2, [sp, #0x2c]
700a2b7c: 1c51         	adds	r1, r2, #0x1
700a2b7e: 910b         	str	r1, [sp, #0x2c]
700a2b80: a90c         	add	r1, sp, #0x30
700a2b82: 5488         	strb	r0, [r1, r2]
;       value /= base;
700a2b84: 9a14         	ldr	r2, [sp, #0x50]
700a2b86: 9b15         	ldr	r3, [sp, #0x54]
700a2b88: 9818         	ldr	r0, [sp, #0x60]
700a2b8a: 9919         	ldr	r1, [sp, #0x64]
700a2b8c: f00c e9d2    	blx	0x700aef34 <__aeabi_uldivmod> @ imm = #0xc3a4
700a2b90: 9119         	str	r1, [sp, #0x64]
700a2b92: 9018         	str	r0, [sp, #0x60]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a2b94: e7ff         	b	0x700a2b96 <_ntoa_long_long+0xc6> @ imm = #-0x2
700a2b96: 9818         	ldr	r0, [sp, #0x60]
700a2b98: 9919         	ldr	r1, [sp, #0x64]
700a2b9a: 4301         	orrs	r1, r0
700a2b9c: 2000         	movs	r0, #0x0
700a2b9e: 9008         	str	r0, [sp, #0x20]
700a2ba0: b139         	cbz	r1, 0x700a2bb2 <_ntoa_long_long+0xe2> @ imm = #0xe
700a2ba2: e7ff         	b	0x700a2ba4 <_ntoa_long_long+0xd4> @ imm = #-0x2
700a2ba4: 990b         	ldr	r1, [sp, #0x2c]
700a2ba6: 2000         	movs	r0, #0x0
700a2ba8: 2920         	cmp	r1, #0x20
700a2baa: bf38         	it	lo
700a2bac: 2001         	movlo	r0, #0x1
700a2bae: 9008         	str	r0, [sp, #0x20]
700a2bb0: e7ff         	b	0x700a2bb2 <_ntoa_long_long+0xe2> @ imm = #-0x2
700a2bb2: 9808         	ldr	r0, [sp, #0x20]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a2bb4: 07c0         	lsls	r0, r0, #0x1f
700a2bb6: 2800         	cmp	r0, #0x0
700a2bb8: d1bf         	bne	0x700a2b3a <_ntoa_long_long+0x6a> @ imm = #-0x82
700a2bba: e7ff         	b	0x700a2bbc <_ntoa_long_long+0xec> @ imm = #-0x2
;   }
700a2bbc: e7ff         	b	0x700a2bbe <_ntoa_long_long+0xee> @ imm = #-0x2
;   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
700a2bbe: 981d         	ldr	r0, [sp, #0x74]
700a2bc0: 991c         	ldr	r1, [sp, #0x70]
700a2bc2: 9a1b         	ldr	r2, [sp, #0x6c]
700a2bc4: 9b1a         	ldr	r3, [sp, #0x68]
700a2bc6: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a2bca: 9d14         	ldr	r5, [sp, #0x50]
700a2bcc: 9e2a         	ldr	r6, [sp, #0xa8]
700a2bce: 9f2b         	ldr	r7, [sp, #0xac]
700a2bd0: f8dd 80b0    	ldr.w	r8, [sp, #0xb0]
700a2bd4: f89d 405f    	ldrb.w	r4, [sp, #0x5f]
700a2bd8: 46ee         	mov	lr, sp
700a2bda: f8ce 8018    	str.w	r8, [lr, #0x18]
700a2bde: f8ce 7014    	str.w	r7, [lr, #0x14]
700a2be2: f8ce 6010    	str.w	r6, [lr, #0x10]
700a2be6: f8ce 500c    	str.w	r5, [lr, #0xc]
700a2bea: f004 0401    	and	r4, r4, #0x1
700a2bee: f8ce 4008    	str.w	r4, [lr, #0x8]
700a2bf2: f8ce c004    	str.w	r12, [lr, #0x4]
700a2bf6: f10d 0c30    	add.w	r12, sp, #0x30
700a2bfa: f8ce c000    	str.w	r12, [lr]
700a2bfe: f7fb fc1f    	bl	0x7009e440 <_ntoa_format> @ imm = #-0x47c2
700a2c02: b01e         	add	sp, #0x78
700a2c04: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
		...

700a2c10 <Sciclient_rmIrqVintDelete>:
; {
700a2c10: b580         	push	{r7, lr}
700a2c12: b08c         	sub	sp, #0x30
700a2c14: 900b         	str	r0, [sp, #0x2c]
700a2c16: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a2c18: 900a         	str	r0, [sp, #0x28]
;     bool del_mapping = false;
700a2c1a: f88d 0026    	strb.w	r0, [sp, #0x26]
;     bool del_whole_route = false;
700a2c1e: f88d 0025    	strb.w	r0, [sp, #0x25]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a2c22: 9008         	str	r0, [sp, #0x20]
;     if (r == SystemP_SUCCESS) {
700a2c24: 980a         	ldr	r0, [sp, #0x28]
700a2c26: b948         	cbnz	r0, 0x700a2c3c <Sciclient_rmIrqVintDelete+0x2c> @ imm = #0x12
700a2c28: e7ff         	b	0x700a2c2a <Sciclient_rmIrqVintDelete+0x1a> @ imm = #-0x2
;         r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700a2c2a: 990b         	ldr	r1, [sp, #0x2c]
700a2c2c: 8a08         	ldrh	r0, [r1, #0x10]
700a2c2e: 8a49         	ldrh	r1, [r1, #0x12]
700a2c30: f10d 0227    	add.w	r2, sp, #0x27
700a2c34: f008 fb9c    	bl	0x700ab370 <Sciclient_rmIaVintGetInfo> @ imm = #0x8738
700a2c38: 900a         	str	r0, [sp, #0x28]
;     }
700a2c3a: e7ff         	b	0x700a2c3c <Sciclient_rmIrqVintDelete+0x2c> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a2c3c: 980a         	ldr	r0, [sp, #0x28]
700a2c3e: b9e8         	cbnz	r0, 0x700a2c7c <Sciclient_rmIrqVintDelete+0x6c> @ imm = #0x3a
700a2c40: e7ff         	b	0x700a2c42 <Sciclient_rmIrqVintDelete+0x32> @ imm = #-0x2
;         if (num_evts == 0u) {
700a2c42: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a2c46: b920         	cbnz	r0, 0x700a2c52 <Sciclient_rmIrqVintDelete+0x42> @ imm = #0x8
700a2c48: e7ff         	b	0x700a2c4a <Sciclient_rmIrqVintDelete+0x3a> @ imm = #-0x2
700a2c4a: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a2c4e: 900a         	str	r0, [sp, #0x28]
;         } else if ((num_evts > 1u) ||
700a2c50: e013         	b	0x700a2c7a <Sciclient_rmIrqVintDelete+0x6a> @ imm = #0x26
700a2c52: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a2c56: 2801         	cmp	r0, #0x1
700a2c58: d806         	bhi	0x700a2c68 <Sciclient_rmIrqVintDelete+0x58> @ imm = #0xc
700a2c5a: e7ff         	b	0x700a2c5c <Sciclient_rmIrqVintDelete+0x4c> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg->valid_params) ==
700a2c5c: 980b         	ldr	r0, [sp, #0x2c]
700a2c5e: 6800         	ldr	r0, [r0]
700a2c60: f008 fd46    	bl	0x700ab6f0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0x8a8c
;         } else if ((num_evts > 1u) ||
700a2c64: b120         	cbz	r0, 0x700a2c70 <Sciclient_rmIrqVintDelete+0x60> @ imm = #0x8
700a2c66: e7ff         	b	0x700a2c68 <Sciclient_rmIrqVintDelete+0x58> @ imm = #-0x2
700a2c68: 2001         	movs	r0, #0x1
;             del_mapping = true;
700a2c6a: f88d 0026    	strb.w	r0, [sp, #0x26]
;         } else {
700a2c6e: e003         	b	0x700a2c78 <Sciclient_rmIrqVintDelete+0x68> @ imm = #0x6
700a2c70: 2001         	movs	r0, #0x1
;             del_whole_route = true;
700a2c72: f88d 0025    	strb.w	r0, [sp, #0x25]
700a2c76: e7ff         	b	0x700a2c78 <Sciclient_rmIrqVintDelete+0x68> @ imm = #-0x2
700a2c78: e7ff         	b	0x700a2c7a <Sciclient_rmIrqVintDelete+0x6a> @ imm = #-0x2
;     }
700a2c7a: e7ff         	b	0x700a2c7c <Sciclient_rmIrqVintDelete+0x6c> @ imm = #-0x2
;     if (del_mapping == true) {
700a2c7c: f89d 0026    	ldrb.w	r0, [sp, #0x26]
700a2c80: 07c0         	lsls	r0, r0, #0x1f
700a2c82: 2800         	cmp	r0, #0x0
700a2c84: d049         	beq	0x700a2d1a <Sciclient_rmIrqVintDelete+0x10a> @ imm = #0x92
700a2c86: e7ff         	b	0x700a2c88 <Sciclient_rmIrqVintDelete+0x78> @ imm = #-0x2
700a2c88: 203c         	movs	r0, #0x3c
700a2c8a: f2c8 0000    	movt	r0, #0x8000
;         req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a2c8e: 9003         	str	r0, [sp, #0xc]
;         req.secondary_host = cfg->host;
700a2c90: 980b         	ldr	r0, [sp, #0x2c]
700a2c92: 7900         	ldrb	r0, [r0, #0x4]
700a2c94: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         req.src_id = cfg->s_id;
700a2c98: 980b         	ldr	r0, [sp, #0x2c]
700a2c9a: 88c0         	ldrh	r0, [r0, #0x6]
700a2c9c: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         req.src_index = cfg->s_idx;
700a2ca0: 980b         	ldr	r0, [sp, #0x2c]
700a2ca2: 8900         	ldrh	r0, [r0, #0x8]
700a2ca4: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         req.ia_id = cfg->s_ia;
700a2ca8: 980b         	ldr	r0, [sp, #0x2c]
700a2caa: 8a00         	ldrh	r0, [r0, #0x10]
700a2cac: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         req.vint = cfg->vint;
700a2cb0: 980b         	ldr	r0, [sp, #0x2c]
700a2cb2: 8a40         	ldrh	r0, [r0, #0x12]
700a2cb4: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         req.global_event = cfg->global_evt;
700a2cb8: 980b         	ldr	r0, [sp, #0x2c]
700a2cba: 89c0         	ldrh	r0, [r0, #0xe]
700a2cbc: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         req.vint_status_bit_index = cfg->vint_sb;
700a2cc0: 980b         	ldr	r0, [sp, #0x2c]
700a2cc2: 7d00         	ldrb	r0, [r0, #0x14]
700a2cc4: f88d 001e    	strb.w	r0, [sp, #0x1e]
700a2cc8: a801         	add	r0, sp, #0x4
700a2cca: f04f 31ff    	mov.w	r1, #0xffffffff
;         r = Sciclient_rmIrqReleaseRaw(&req,
700a2cce: f009 fe37    	bl	0x700ac940 <Sciclient_rmIrqReleaseRaw> @ imm = #0x9c6e
700a2cd2: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a2cd4: 980a         	ldr	r0, [sp, #0x28]
700a2cd6: b9f8         	cbnz	r0, 0x700a2d18 <Sciclient_rmIrqVintDelete+0x108> @ imm = #0x3e
700a2cd8: e7ff         	b	0x700a2cda <Sciclient_rmIrqVintDelete+0xca> @ imm = #-0x2
;             ia_inst = Sciclient_rmIaGetInst(cfg->s_ia);
700a2cda: 980b         	ldr	r0, [sp, #0x2c]
700a2cdc: 8a00         	ldrh	r0, [r0, #0x10]
700a2cde: f009 fb07    	bl	0x700ac2f0 <Sciclient_rmIaGetInst> @ imm = #0x960e
700a2ce2: 9008         	str	r0, [sp, #0x20]
;             if (ia_inst != NULL) {
700a2ce4: 9808         	ldr	r0, [sp, #0x20]
700a2ce6: b1b0         	cbz	r0, 0x700a2d16 <Sciclient_rmIrqVintDelete+0x106> @ imm = #0x2c
700a2ce8: e7ff         	b	0x700a2cea <Sciclient_rmIrqVintDelete+0xda> @ imm = #-0x2
;                 ia_inst->vint_usage_count[cfg->vint]--;
700a2cea: 9808         	ldr	r0, [sp, #0x20]
700a2cec: 6901         	ldr	r1, [r0, #0x10]
700a2cee: 980b         	ldr	r0, [sp, #0x2c]
700a2cf0: 8a42         	ldrh	r2, [r0, #0x12]
700a2cf2: 5c88         	ldrb	r0, [r1, r2]
700a2cf4: 3801         	subs	r0, #0x1
700a2cf6: 5488         	strb	r0, [r1, r2]
;                 if (ia_inst->v0_b0_evt == cfg->global_evt - ia_inst->sevt_offset) {
700a2cf8: 9a08         	ldr	r2, [sp, #0x20]
700a2cfa: 8a90         	ldrh	r0, [r2, #0x14]
700a2cfc: 990b         	ldr	r1, [sp, #0x2c]
700a2cfe: 89c9         	ldrh	r1, [r1, #0xe]
700a2d00: 8912         	ldrh	r2, [r2, #0x8]
700a2d02: 1a89         	subs	r1, r1, r2
700a2d04: 4288         	cmp	r0, r1
700a2d06: d105         	bne	0x700a2d14 <Sciclient_rmIrqVintDelete+0x104> @ imm = #0xa
700a2d08: e7ff         	b	0x700a2d0a <Sciclient_rmIrqVintDelete+0xfa> @ imm = #-0x2
;                     ia_inst->v0_b0_evt = SCICLIENT_RM_IA_GENERIC_EVT_RESETVAL;
700a2d0a: 9908         	ldr	r1, [sp, #0x20]
700a2d0c: f64f 70ff    	movw	r0, #0xffff
700a2d10: 8288         	strh	r0, [r1, #0x14]
;                 }
700a2d12: e7ff         	b	0x700a2d14 <Sciclient_rmIrqVintDelete+0x104> @ imm = #-0x2
;             }
700a2d14: e7ff         	b	0x700a2d16 <Sciclient_rmIrqVintDelete+0x106> @ imm = #-0x2
;         }
700a2d16: e7ff         	b	0x700a2d18 <Sciclient_rmIrqVintDelete+0x108> @ imm = #-0x2
;     }
700a2d18: e7ff         	b	0x700a2d1a <Sciclient_rmIrqVintDelete+0x10a> @ imm = #-0x2
;     if (del_whole_route == true) {
700a2d1a: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a2d1e: 07c0         	lsls	r0, r0, #0x1f
700a2d20: b170         	cbz	r0, 0x700a2d40 <Sciclient_rmIrqVintDelete+0x130> @ imm = #0x1c
700a2d22: e7ff         	b	0x700a2d24 <Sciclient_rmIrqVintDelete+0x114> @ imm = #-0x2
;         r = Sciclient_rmIrqGetRoute(cfg);
700a2d24: 980b         	ldr	r0, [sp, #0x2c]
700a2d26: f7f9 ffa3    	bl	0x7009cc70 <Sciclient_rmIrqGetRoute> @ imm = #-0x60ba
700a2d2a: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a2d2c: 980a         	ldr	r0, [sp, #0x28]
700a2d2e: b930         	cbnz	r0, 0x700a2d3e <Sciclient_rmIrqVintDelete+0x12e> @ imm = #0xc
700a2d30: e7ff         	b	0x700a2d32 <Sciclient_rmIrqVintDelete+0x122> @ imm = #-0x2
;             r = Sciclient_rmIrqDeleteRoute(cfg, true);
700a2d32: 980b         	ldr	r0, [sp, #0x2c]
700a2d34: 2101         	movs	r1, #0x1
700a2d36: f7fd fdf3    	bl	0x700a0920 <Sciclient_rmIrqDeleteRoute> @ imm = #-0x241a
700a2d3a: 900a         	str	r0, [sp, #0x28]
;         }
700a2d3c: e7ff         	b	0x700a2d3e <Sciclient_rmIrqVintDelete+0x12e> @ imm = #-0x2
;     }
700a2d3e: e7ff         	b	0x700a2d40 <Sciclient_rmIrqVintDelete+0x130> @ imm = #-0x2
;     return r;
700a2d40: 980a         	ldr	r0, [sp, #0x28]
700a2d42: b00c         	add	sp, #0x30
700a2d44: bd80         	pop	{r7, pc}
		...
700a2d4e: 0000         	movs	r0, r0

700a2d50 <UART_writePolling>:
; {
700a2d50: b580         	push	{r7, lr}
700a2d52: b08c         	sub	sp, #0x30
700a2d54: 900b         	str	r0, [sp, #0x2c]
700a2d56: 910a         	str	r1, [sp, #0x28]
700a2d58: 2000         	movs	r0, #0x0
;     int32_t             retVal          = UART_TRANSFER_STATUS_SUCCESS;
700a2d5a: 9007         	str	r0, [sp, #0x1c]
;     uint32_t            timeoutElapsed  = FALSE;
700a2d5c: 9006         	str	r0, [sp, #0x18]
;     uint32_t            baseAddr        = hUart->baseAddr;
700a2d5e: 990b         	ldr	r1, [sp, #0x2c]
700a2d60: 6809         	ldr	r1, [r1]
700a2d62: 9105         	str	r1, [sp, #0x14]
;     uint32_t            lineStatus      = 0U;
700a2d64: 9004         	str	r0, [sp, #0x10]
;     hUartInit = hUart->hUartInit;
700a2d66: 980b         	ldr	r0, [sp, #0x2c]
700a2d68: 6840         	ldr	r0, [r0, #0x4]
700a2d6a: 9003         	str	r0, [sp, #0xc]
;     hUart->writeSizeRemaining = trans->count;
700a2d6c: 980a         	ldr	r0, [sp, #0x28]
700a2d6e: 6840         	ldr	r0, [r0, #0x4]
700a2d70: 990b         	ldr	r1, [sp, #0x2c]
700a2d72: 6108         	str	r0, [r1, #0x10]
;     startTicks = hUartInit->clockP_get();
700a2d74: 9803         	ldr	r0, [sp, #0xc]
700a2d76: 6d40         	ldr	r0, [r0, #0x54]
700a2d78: 4780         	blx	r0
700a2d7a: 9009         	str	r0, [sp, #0x24]
;     while ((FALSE == timeoutElapsed)
700a2d7c: e7ff         	b	0x700a2d7e <UART_writePolling+0x2e> @ imm = #-0x2
700a2d7e: 9906         	ldr	r1, [sp, #0x18]
700a2d80: 2000         	movs	r0, #0x0
;            && (0U != hUart->writeSizeRemaining))
700a2d82: 9002         	str	r0, [sp, #0x8]
700a2d84: b939         	cbnz	r1, 0x700a2d96 <UART_writePolling+0x46> @ imm = #0xe
700a2d86: e7ff         	b	0x700a2d88 <UART_writePolling+0x38> @ imm = #-0x2
700a2d88: 980b         	ldr	r0, [sp, #0x2c]
700a2d8a: 6900         	ldr	r0, [r0, #0x10]
700a2d8c: 2800         	cmp	r0, #0x0
700a2d8e: bf18         	it	ne
700a2d90: 2001         	movne	r0, #0x1
700a2d92: 9002         	str	r0, [sp, #0x8]
700a2d94: e7ff         	b	0x700a2d96 <UART_writePolling+0x46> @ imm = #-0x2
700a2d96: 9802         	ldr	r0, [sp, #0x8]
;     while ((FALSE == timeoutElapsed)
700a2d98: 07c0         	lsls	r0, r0, #0x1f
700a2d9a: b198         	cbz	r0, 0x700a2dc4 <UART_writePolling+0x74> @ imm = #0x26
700a2d9c: e7ff         	b	0x700a2d9e <UART_writePolling+0x4e> @ imm = #-0x2
;         UART_writeDataPolling(hUart);
700a2d9e: 980b         	ldr	r0, [sp, #0x2c]
700a2da0: f00b f99e    	bl	0x700ae0e0 <UART_writeDataPolling> @ imm = #0xb33c
;         elapsedTicks = hUartInit->clockP_get() - startTicks;
700a2da4: 9803         	ldr	r0, [sp, #0xc]
700a2da6: 6d40         	ldr	r0, [r0, #0x54]
700a2da8: 4780         	blx	r0
700a2daa: 9909         	ldr	r1, [sp, #0x24]
700a2dac: 1a40         	subs	r0, r0, r1
700a2dae: 9008         	str	r0, [sp, #0x20]
;         if (elapsedTicks >= trans->timeout)
700a2db0: 9808         	ldr	r0, [sp, #0x20]
700a2db2: 990a         	ldr	r1, [sp, #0x28]
700a2db4: 6889         	ldr	r1, [r1, #0x8]
700a2db6: 4288         	cmp	r0, r1
700a2db8: d303         	blo	0x700a2dc2 <UART_writePolling+0x72> @ imm = #0x6
700a2dba: e7ff         	b	0x700a2dbc <UART_writePolling+0x6c> @ imm = #-0x2
700a2dbc: 2001         	movs	r0, #0x1
;             timeoutElapsed = TRUE;
700a2dbe: 9006         	str	r0, [sp, #0x18]
;         }
700a2dc0: e7ff         	b	0x700a2dc2 <UART_writePolling+0x72> @ imm = #-0x2
;     while ((FALSE == timeoutElapsed)
700a2dc2: e7dc         	b	0x700a2d7e <UART_writePolling+0x2e> @ imm = #-0x48
;     if (0U == hUart->writeSizeRemaining)
700a2dc4: 980b         	ldr	r0, [sp, #0x2c]
700a2dc6: 6900         	ldr	r0, [r0, #0x10]
700a2dc8: 2800         	cmp	r0, #0x0
700a2dca: d149         	bne	0x700a2e60 <UART_writePolling+0x110> @ imm = #0x92
700a2dcc: e7ff         	b	0x700a2dce <UART_writePolling+0x7e> @ imm = #-0x2
;         do
700a2dce: e7ff         	b	0x700a2dd0 <UART_writePolling+0x80> @ imm = #-0x2
;             lineStatus = UART_readLineStatus(baseAddr);
700a2dd0: 9805         	ldr	r0, [sp, #0x14]
700a2dd2: f00a fc15    	bl	0x700ad600 <UART_readLineStatus> @ imm = #0xa82a
700a2dd6: 9004         	str	r0, [sp, #0x10]
;             elapsedTicks = hUartInit->clockP_get() - startTicks;
700a2dd8: 9803         	ldr	r0, [sp, #0xc]
700a2dda: 6d40         	ldr	r0, [r0, #0x54]
700a2ddc: 4780         	blx	r0
700a2dde: 9909         	ldr	r1, [sp, #0x24]
700a2de0: 1a40         	subs	r0, r0, r1
700a2de2: 9008         	str	r0, [sp, #0x20]
;         }
700a2de4: e7ff         	b	0x700a2de6 <UART_writePolling+0x96> @ imm = #-0x2
;                (lineStatus & (uint32_t) (UART_LSR_TX_FIFO_E_MASK |
700a2de6: 9804         	ldr	r0, [sp, #0x10]
700a2de8: f000 0160    	and	r1, r0, #0x60
700a2dec: 2000         	movs	r0, #0x0
;                 && (elapsedTicks < hUart->lineStatusTimeout));
700a2dee: 2960         	cmp	r1, #0x60
700a2df0: 9001         	str	r0, [sp, #0x4]
700a2df2: d00d         	beq	0x700a2e10 <UART_writePolling+0xc0> @ imm = #0x1a
700a2df4: e7ff         	b	0x700a2df6 <UART_writePolling+0xa6> @ imm = #-0x2
700a2df6: 9808         	ldr	r0, [sp, #0x20]
700a2df8: 990b         	ldr	r1, [sp, #0x2c]
700a2dfa: 6e8a         	ldr	r2, [r1, #0x68]
700a2dfc: 6ec9         	ldr	r1, [r1, #0x6c]
700a2dfe: 1a80         	subs	r0, r0, r2
700a2e00: f04f 0000    	mov.w	r0, #0x0
700a2e04: eb70 0101    	sbcs.w	r1, r0, r1
700a2e08: bf38         	it	lo
700a2e0a: 2001         	movlo	r0, #0x1
700a2e0c: 9001         	str	r0, [sp, #0x4]
700a2e0e: e7ff         	b	0x700a2e10 <UART_writePolling+0xc0> @ imm = #-0x2
700a2e10: 9801         	ldr	r0, [sp, #0x4]
;         }
700a2e12: 07c0         	lsls	r0, r0, #0x1f
700a2e14: 2800         	cmp	r0, #0x0
700a2e16: d1db         	bne	0x700a2dd0 <UART_writePolling+0x80> @ imm = #-0x4a
700a2e18: e7ff         	b	0x700a2e1a <UART_writePolling+0xca> @ imm = #-0x2
;         if(elapsedTicks >= hUart->lineStatusTimeout)
700a2e1a: 9808         	ldr	r0, [sp, #0x20]
700a2e1c: 990b         	ldr	r1, [sp, #0x2c]
700a2e1e: 6e8a         	ldr	r2, [r1, #0x68]
700a2e20: 6ec9         	ldr	r1, [r1, #0x6c]
700a2e22: 1a80         	subs	r0, r0, r2
700a2e24: f04f 0000    	mov.w	r0, #0x0
700a2e28: 4188         	sbcs	r0, r1
700a2e2a: d30f         	blo	0x700a2e4c <UART_writePolling+0xfc> @ imm = #0x1e
700a2e2c: e7ff         	b	0x700a2e2e <UART_writePolling+0xde> @ imm = #-0x2
700a2e2e: f06f 0001    	mvn	r0, #0x1
;             retVal             = UART_TRANSFER_TIMEOUT;
700a2e32: 9007         	str	r0, [sp, #0x1c]
;             trans->status      = UART_TRANSFER_STATUS_TIMEOUT;
700a2e34: 990a         	ldr	r1, [sp, #0x28]
700a2e36: 2001         	movs	r0, #0x1
700a2e38: 60c8         	str	r0, [r1, #0xc]
;             trans->count       = hUart->writeCount;
700a2e3a: 980b         	ldr	r0, [sp, #0x2c]
700a2e3c: 68c0         	ldr	r0, [r0, #0xc]
700a2e3e: 990a         	ldr	r1, [sp, #0x28]
700a2e40: 6048         	str	r0, [r1, #0x4]
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a2e42: 980b         	ldr	r0, [sp, #0x2c]
700a2e44: 303c         	adds	r0, #0x3c
700a2e46: f00c f9b3    	bl	0x700af1b0 <UART_lld_Transaction_deInit> @ imm = #0xc366
;         }
700a2e4a: e008         	b	0x700a2e5e <UART_writePolling+0x10e> @ imm = #0x10
700a2e4c: 2000         	movs	r0, #0x0
;             retVal             = UART_TRANSFER_STATUS_SUCCESS;
700a2e4e: 9007         	str	r0, [sp, #0x1c]
;             trans->status      = UART_TRANSFER_STATUS_SUCCESS;
700a2e50: 990a         	ldr	r1, [sp, #0x28]
700a2e52: 60c8         	str	r0, [r1, #0xc]
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a2e54: 980b         	ldr	r0, [sp, #0x2c]
700a2e56: 303c         	adds	r0, #0x3c
700a2e58: f00c f9aa    	bl	0x700af1b0 <UART_lld_Transaction_deInit> @ imm = #0xc354
700a2e5c: e7ff         	b	0x700a2e5e <UART_writePolling+0x10e> @ imm = #-0x2
;     }
700a2e5e: e00e         	b	0x700a2e7e <UART_writePolling+0x12e> @ imm = #0x1c
700a2e60: f06f 0001    	mvn	r0, #0x1
;         retVal             = UART_TRANSFER_TIMEOUT;
700a2e64: 9007         	str	r0, [sp, #0x1c]
;         trans->status      = UART_TRANSFER_STATUS_TIMEOUT;
700a2e66: 990a         	ldr	r1, [sp, #0x28]
700a2e68: 2001         	movs	r0, #0x1
700a2e6a: 60c8         	str	r0, [r1, #0xc]
;         trans->count       = hUart->writeCount;
700a2e6c: 980b         	ldr	r0, [sp, #0x2c]
700a2e6e: 68c0         	ldr	r0, [r0, #0xc]
700a2e70: 990a         	ldr	r1, [sp, #0x28]
700a2e72: 6048         	str	r0, [r1, #0x4]
;         UART_lld_Transaction_deInit(&hUart->writeTrans);
700a2e74: 980b         	ldr	r0, [sp, #0x2c]
700a2e76: 303c         	adds	r0, #0x3c
700a2e78: f00c f99a    	bl	0x700af1b0 <UART_lld_Transaction_deInit> @ imm = #0xc334
700a2e7c: e7ff         	b	0x700a2e7e <UART_writePolling+0x12e> @ imm = #-0x2
;     return (retVal);
700a2e7e: 9807         	ldr	r0, [sp, #0x1c]
700a2e80: b00c         	add	sp, #0x30
700a2e82: bd80         	pop	{r7, pc}
		...

700a2e90 <Sciclient_recvMessage>:
; {
700a2e90: b580         	push	{r7, lr}
700a2e92: b08e         	sub	sp, #0x38
700a2e94: 900d         	str	r0, [sp, #0x34]
700a2e96: 910c         	str	r1, [sp, #0x30]
700a2e98: 920b         	str	r2, [sp, #0x2c]
700a2e9a: 2000         	movs	r0, #0x0
;     uint8_t  trailBytes = 0U;
700a2e9c: f88d 0023    	strb.w	r0, [sp, #0x23]
;     numWords   = (uint32_t) (rxPayloadSize / 4U);
700a2ea0: 990b         	ldr	r1, [sp, #0x2c]
700a2ea2: ea4f 0191    	lsr.w	r1, r1, #0x2
700a2ea6: 910a         	str	r1, [sp, #0x28]
;     trailBytes = (uint8_t) (rxPayloadSize - (numWords * 4U));
700a2ea8: 990b         	ldr	r1, [sp, #0x2c]
700a2eaa: 9a0a         	ldr	r2, [sp, #0x28]
700a2eac: eba1 0182    	sub.w	r1, r1, r2, lsl #2
700a2eb0: f88d 1023    	strb.w	r1, [sp, #0x23]
;     for (i = 0; i < numWords; i++)
700a2eb4: 9009         	str	r0, [sp, #0x24]
700a2eb6: e7ff         	b	0x700a2eb8 <Sciclient_recvMessage+0x28> @ imm = #-0x2
700a2eb8: 9809         	ldr	r0, [sp, #0x24]
700a2eba: 990a         	ldr	r1, [sp, #0x28]
700a2ebc: 4288         	cmp	r0, r1
700a2ebe: d22c         	bhs	0x700a2f1a <Sciclient_recvMessage+0x8a> @ imm = #0x58
700a2ec0: e7ff         	b	0x700a2ec2 <Sciclient_recvMessage+0x32> @ imm = #-0x2
;             rxThread,
700a2ec2: 980d         	ldr	r0, [sp, #0x34]
;             ((uint8_t) i +
700a2ec4: 9909         	ldr	r1, [sp, #0x24]
;                 SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a2ec6: f242 7214    	movw	r2, #0x2714
700a2eca: f2c7 020b    	movt	r2, #0x700b
700a2ece: 7812         	ldrb	r2, [r2]
;             ((uint8_t) i +
700a2ed0: 4411         	add	r1, r2
;                 SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a2ed2: 3102         	adds	r1, #0x2
;         uint32_t tempWord = Sciclient_secProxyReadThread32(
700a2ed4: b2c9         	uxtb	r1, r1
700a2ed6: f00b fbfb    	bl	0x700ae6d0 <Sciclient_secProxyReadThread32> @ imm = #0xb7f6
700a2eda: 9007         	str	r0, [sp, #0x1c]
700a2edc: a807         	add	r0, sp, #0x1c
;         uint8_t * tempWordPtr = (uint8_t*) & tempWord;
700a2ede: 9006         	str	r0, [sp, #0x18]
700a2ee0: 2000         	movs	r0, #0x0
;         uint32_t j = 0U;
700a2ee2: 9005         	str	r0, [sp, #0x14]
;         for (j = 0U; j < 4U; j++)
700a2ee4: 9005         	str	r0, [sp, #0x14]
700a2ee6: e7ff         	b	0x700a2ee8 <Sciclient_recvMessage+0x58> @ imm = #-0x2
700a2ee8: 9805         	ldr	r0, [sp, #0x14]
700a2eea: 2803         	cmp	r0, #0x3
700a2eec: d810         	bhi	0x700a2f10 <Sciclient_recvMessage+0x80> @ imm = #0x20
700a2eee: e7ff         	b	0x700a2ef0 <Sciclient_recvMessage+0x60> @ imm = #-0x2
;             *(pLocalRespPayload + i * 4 + j) = *tempWordPtr;
700a2ef0: 9806         	ldr	r0, [sp, #0x18]
700a2ef2: 7800         	ldrb	r0, [r0]
700a2ef4: 990c         	ldr	r1, [sp, #0x30]
700a2ef6: 9a09         	ldr	r2, [sp, #0x24]
700a2ef8: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a2efc: 9a05         	ldr	r2, [sp, #0x14]
700a2efe: 5488         	strb	r0, [r1, r2]
;             tempWordPtr++;
700a2f00: 9806         	ldr	r0, [sp, #0x18]
700a2f02: 3001         	adds	r0, #0x1
700a2f04: 9006         	str	r0, [sp, #0x18]
;         }
700a2f06: e7ff         	b	0x700a2f08 <Sciclient_recvMessage+0x78> @ imm = #-0x2
;         for (j = 0U; j < 4U; j++)
700a2f08: 9805         	ldr	r0, [sp, #0x14]
700a2f0a: 3001         	adds	r0, #0x1
700a2f0c: 9005         	str	r0, [sp, #0x14]
700a2f0e: e7eb         	b	0x700a2ee8 <Sciclient_recvMessage+0x58> @ imm = #-0x2a
;     }
700a2f10: e7ff         	b	0x700a2f12 <Sciclient_recvMessage+0x82> @ imm = #-0x2
;     for (i = 0; i < numWords; i++)
700a2f12: 9809         	ldr	r0, [sp, #0x24]
700a2f14: 3001         	adds	r0, #0x1
700a2f16: 9009         	str	r0, [sp, #0x24]
700a2f18: e7ce         	b	0x700a2eb8 <Sciclient_recvMessage+0x28> @ imm = #-0x64
;     if (trailBytes > 0U)
700a2f1a: f89d 0023    	ldrb.w	r0, [sp, #0x23]
700a2f1e: b368         	cbz	r0, 0x700a2f7c <Sciclient_recvMessage+0xec> @ imm = #0x5a
700a2f20: e7ff         	b	0x700a2f22 <Sciclient_recvMessage+0x92> @ imm = #-0x2
;                 rxThread,
700a2f22: 980d         	ldr	r0, [sp, #0x34]
;                 ((uint8_t)i +
700a2f24: 9909         	ldr	r1, [sp, #0x24]
;                     SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a2f26: f242 7214    	movw	r2, #0x2714
700a2f2a: f2c7 020b    	movt	r2, #0x700b
700a2f2e: 7812         	ldrb	r2, [r2]
;                 ((uint8_t)i +
700a2f30: 4411         	add	r1, r2
;                     SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a2f32: 3102         	adds	r1, #0x2
;         uint32_t tempWord = Sciclient_secProxyReadThread32(
700a2f34: b2c9         	uxtb	r1, r1
700a2f36: f00b fbcb    	bl	0x700ae6d0 <Sciclient_secProxyReadThread32> @ imm = #0xb796
700a2f3a: 9004         	str	r0, [sp, #0x10]
700a2f3c: a804         	add	r0, sp, #0x10
;         uint8_t * pTempWord = (uint8_t*) &tempWord;
700a2f3e: 9003         	str	r0, [sp, #0xc]
700a2f40: 2000         	movs	r0, #0x0
;         for (bytes = 0U; bytes < trailBytes; bytes++)
700a2f42: 9002         	str	r0, [sp, #0x8]
700a2f44: e7ff         	b	0x700a2f46 <Sciclient_recvMessage+0xb6> @ imm = #-0x2
700a2f46: 9802         	ldr	r0, [sp, #0x8]
700a2f48: f89d 1023    	ldrb.w	r1, [sp, #0x23]
700a2f4c: 4288         	cmp	r0, r1
700a2f4e: d214         	bhs	0x700a2f7a <Sciclient_recvMessage+0xea> @ imm = #0x28
700a2f50: e7ff         	b	0x700a2f52 <Sciclient_recvMessage+0xc2> @ imm = #-0x2
;             uint8_t * address = (uint8_t*)pLocalRespPayload;
700a2f52: 980c         	ldr	r0, [sp, #0x30]
700a2f54: 9001         	str	r0, [sp, #0x4]
;             uint8_t value = *(uint8_t*)(pTempWord + bytes);
700a2f56: 9803         	ldr	r0, [sp, #0xc]
700a2f58: 9902         	ldr	r1, [sp, #0x8]
700a2f5a: 5c40         	ldrb	r0, [r0, r1]
700a2f5c: f88d 0003    	strb.w	r0, [sp, #0x3]
;             *(uint8_t*)(address + i*4 + bytes) = value;
700a2f60: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a2f64: 9901         	ldr	r1, [sp, #0x4]
700a2f66: 9a09         	ldr	r2, [sp, #0x24]
700a2f68: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a2f6c: 9a02         	ldr	r2, [sp, #0x8]
700a2f6e: 5488         	strb	r0, [r1, r2]
;         }
700a2f70: e7ff         	b	0x700a2f72 <Sciclient_recvMessage+0xe2> @ imm = #-0x2
;         for (bytes = 0U; bytes < trailBytes; bytes++)
700a2f72: 9802         	ldr	r0, [sp, #0x8]
700a2f74: 3001         	adds	r0, #0x1
700a2f76: 9002         	str	r0, [sp, #0x8]
700a2f78: e7e5         	b	0x700a2f46 <Sciclient_recvMessage+0xb6> @ imm = #-0x36
;     }
700a2f7a: e7ff         	b	0x700a2f7c <Sciclient_recvMessage+0xec> @ imm = #-0x2
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a2f7c: f242 7014    	movw	r0, #0x2714
700a2f80: f2c7 000b    	movt	r0, #0x700b
700a2f84: 7801         	ldrb	r1, [r0]
;         rxPayloadSize) <=
700a2f86: 980b         	ldr	r0, [sp, #0x2c]
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a2f88: eb00 0081    	add.w	r0, r0, r1, lsl #2
;         (SCICLIENT_HEADER_SIZE_IN_WORDS*4U) +
700a2f8c: 3008         	adds	r0, #0x8
;         (gSciclientHandle.maxMsgSizeBytes - 4U))
700a2f8e: f242 6108    	movw	r1, #0x2608
700a2f92: f2c7 010b    	movt	r1, #0x700b
700a2f96: 6949         	ldr	r1, [r1, #0x14]
700a2f98: 3904         	subs	r1, #0x4
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a2f9a: 4288         	cmp	r0, r1
700a2f9c: d80e         	bhi	0x700a2fbc <Sciclient_recvMessage+0x12c> @ imm = #0x1c
700a2f9e: e7ff         	b	0x700a2fa0 <Sciclient_recvMessage+0x110> @ imm = #-0x2
;         (void) Sciclient_secProxyReadThread32(rxThread,
700a2fa0: 980d         	ldr	r0, [sp, #0x34]
;                         (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U) - 1U));
700a2fa2: f242 6108    	movw	r1, #0x2608
700a2fa6: f2c7 010b    	movt	r1, #0x700b
700a2faa: 694a         	ldr	r2, [r1, #0x14]
700a2fac: f04f 31ff    	mov.w	r1, #0xffffffff
700a2fb0: eb01 0192    	add.w	r1, r1, r2, lsr #2
;         (void) Sciclient_secProxyReadThread32(rxThread,
700a2fb4: b2c9         	uxtb	r1, r1
700a2fb6: f00b fb8b    	bl	0x700ae6d0 <Sciclient_secProxyReadThread32> @ imm = #0xb716
;     }
700a2fba: e7ff         	b	0x700a2fbc <Sciclient_recvMessage+0x12c> @ imm = #-0x2
; }
700a2fbc: b00e         	add	sp, #0x38
700a2fbe: bd80         	pop	{r7, pc}

700a2fc0 <Udma_rmAllocIrIntr>:
; {
700a2fc0: b580         	push	{r7, lr}
700a2fc2: b088         	sub	sp, #0x20
700a2fc4: 9007         	str	r0, [sp, #0x1c]
700a2fc6: 9106         	str	r1, [sp, #0x18]
700a2fc8: 2000         	movs	r0, #0x0
700a2fca: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            irIntrNum = UDMA_INTR_INVALID;
700a2fce: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a2fd0: 9806         	ldr	r0, [sp, #0x18]
700a2fd2: f500 70ea    	add.w	r0, r0, #0x1d4
700a2fd6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2fd8: 9806         	ldr	r0, [sp, #0x18]
700a2fda: f500 609f    	add.w	r0, r0, #0x4f8
700a2fde: f04f 31ff    	mov.w	r1, #0xffffffff
700a2fe2: f007 facd    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x759a
;     if(UDMA_CORE_INTR_ANY == preferredIrIntrNum)
700a2fe6: 9807         	ldr	r0, [sp, #0x1c]
700a2fe8: 2101         	movs	r1, #0x1
700a2fea: f6cf 71ff    	movt	r1, #0xffff
700a2fee: 4288         	cmp	r0, r1
700a2ff0: d138         	bne	0x700a3064 <Udma_rmAllocIrIntr+0xa4> @ imm = #0x70
700a2ff2: e7ff         	b	0x700a2ff4 <Udma_rmAllocIrIntr+0x34> @ imm = #-0x2
700a2ff4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numIrIntr; i++)
700a2ff6: 9005         	str	r0, [sp, #0x14]
700a2ff8: e7ff         	b	0x700a2ffa <Udma_rmAllocIrIntr+0x3a> @ imm = #-0x2
700a2ffa: 9805         	ldr	r0, [sp, #0x14]
700a2ffc: 9900         	ldr	r1, [sp]
700a2ffe: f8d1 10ec    	ldr.w	r1, [r1, #0xec]
700a3002: 4288         	cmp	r0, r1
700a3004: d22d         	bhs	0x700a3062 <Udma_rmAllocIrIntr+0xa2> @ imm = #0x5a
700a3006: e7ff         	b	0x700a3008 <Udma_rmAllocIrIntr+0x48> @ imm = #-0x2
;             offset = i >> 5U;
700a3008: 9805         	ldr	r0, [sp, #0x14]
700a300a: 0940         	lsrs	r0, r0, #0x5
700a300c: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a300e: 9805         	ldr	r0, [sp, #0x14]
700a3010: 9904         	ldr	r1, [sp, #0x10]
700a3012: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3016: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3018: 9903         	ldr	r1, [sp, #0xc]
700a301a: 2001         	movs	r0, #0x1
700a301c: 4088         	lsls	r0, r1
700a301e: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->irIntrFlag[offset] & bitMask) == bitMask)
700a3020: 9806         	ldr	r0, [sp, #0x18]
700a3022: 9904         	ldr	r1, [sp, #0x10]
700a3024: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3028: f8d0 04e4    	ldr.w	r0, [r0, #0x4e4]
700a302c: 9902         	ldr	r1, [sp, #0x8]
700a302e: 4008         	ands	r0, r1
700a3030: 4288         	cmp	r0, r1
700a3032: d111         	bne	0x700a3058 <Udma_rmAllocIrIntr+0x98> @ imm = #0x22
700a3034: e7ff         	b	0x700a3036 <Udma_rmAllocIrIntr+0x76> @ imm = #-0x2
;                 drvHandle->irIntrFlag[offset] &= ~bitMask;
700a3036: 9a02         	ldr	r2, [sp, #0x8]
700a3038: 9806         	ldr	r0, [sp, #0x18]
700a303a: 9904         	ldr	r1, [sp, #0x10]
700a303c: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3040: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a3044: 4390         	bics	r0, r2
700a3046: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;                 irIntrNum = i + rmInitPrms->startIrIntr;    /* Add start offset */
700a304a: 9805         	ldr	r0, [sp, #0x14]
700a304c: 9900         	ldr	r1, [sp]
700a304e: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a3052: 4408         	add	r0, r1
700a3054: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3056: e004         	b	0x700a3062 <Udma_rmAllocIrIntr+0xa2> @ imm = #0x8
;         }
700a3058: e7ff         	b	0x700a305a <Udma_rmAllocIrIntr+0x9a> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numIrIntr; i++)
700a305a: 9805         	ldr	r0, [sp, #0x14]
700a305c: 3001         	adds	r0, #0x1
700a305e: 9005         	str	r0, [sp, #0x14]
700a3060: e7cb         	b	0x700a2ffa <Udma_rmAllocIrIntr+0x3a> @ imm = #-0x6a
;     }
700a3062: e03c         	b	0x700a30de <Udma_rmAllocIrIntr+0x11e> @ imm = #0x78
;         if((preferredIrIntrNum >= rmInitPrms->startIrIntr) &&
700a3064: 9807         	ldr	r0, [sp, #0x1c]
700a3066: 9900         	ldr	r1, [sp]
700a3068: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a306c: 4288         	cmp	r0, r1
700a306e: d335         	blo	0x700a30dc <Udma_rmAllocIrIntr+0x11c> @ imm = #0x6a
700a3070: e7ff         	b	0x700a3072 <Udma_rmAllocIrIntr+0xb2> @ imm = #-0x2
;            (preferredIrIntrNum < (rmInitPrms->startIrIntr + rmInitPrms->numIrIntr)))
700a3072: 9807         	ldr	r0, [sp, #0x1c]
700a3074: 9a00         	ldr	r2, [sp]
700a3076: f8d2 10e8    	ldr.w	r1, [r2, #0xe8]
700a307a: f8d2 20ec    	ldr.w	r2, [r2, #0xec]
700a307e: 4411         	add	r1, r2
;         if((preferredIrIntrNum >= rmInitPrms->startIrIntr) &&
700a3080: 4288         	cmp	r0, r1
700a3082: d22b         	bhs	0x700a30dc <Udma_rmAllocIrIntr+0x11c> @ imm = #0x56
700a3084: e7ff         	b	0x700a3086 <Udma_rmAllocIrIntr+0xc6> @ imm = #-0x2
;             i = preferredIrIntrNum - rmInitPrms->startIrIntr;
700a3086: 9807         	ldr	r0, [sp, #0x1c]
700a3088: 9900         	ldr	r1, [sp]
700a308a: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a308e: 1a40         	subs	r0, r0, r1
700a3090: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3092: 9805         	ldr	r0, [sp, #0x14]
700a3094: 0940         	lsrs	r0, r0, #0x5
700a3096: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3098: 9805         	ldr	r0, [sp, #0x14]
700a309a: 9904         	ldr	r1, [sp, #0x10]
700a309c: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a30a0: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a30a2: 9903         	ldr	r1, [sp, #0xc]
700a30a4: 2001         	movs	r0, #0x1
700a30a6: 4088         	lsls	r0, r1
700a30a8: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->irIntrFlag[offset] & bitMask) == bitMask)
700a30aa: 9806         	ldr	r0, [sp, #0x18]
700a30ac: 9904         	ldr	r1, [sp, #0x10]
700a30ae: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a30b2: f8d0 04e4    	ldr.w	r0, [r0, #0x4e4]
700a30b6: 9902         	ldr	r1, [sp, #0x8]
700a30b8: 4008         	ands	r0, r1
700a30ba: 4288         	cmp	r0, r1
700a30bc: d10d         	bne	0x700a30da <Udma_rmAllocIrIntr+0x11a> @ imm = #0x1a
700a30be: e7ff         	b	0x700a30c0 <Udma_rmAllocIrIntr+0x100> @ imm = #-0x2
;                 drvHandle->irIntrFlag[offset] &= ~bitMask;
700a30c0: 9a02         	ldr	r2, [sp, #0x8]
700a30c2: 9806         	ldr	r0, [sp, #0x18]
700a30c4: 9904         	ldr	r1, [sp, #0x10]
700a30c6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a30ca: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a30ce: 4390         	bics	r0, r2
700a30d0: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;                 irIntrNum = preferredIrIntrNum;
700a30d4: 9807         	ldr	r0, [sp, #0x1c]
700a30d6: 9001         	str	r0, [sp, #0x4]
;             }
700a30d8: e7ff         	b	0x700a30da <Udma_rmAllocIrIntr+0x11a> @ imm = #-0x2
;         }
700a30da: e7ff         	b	0x700a30dc <Udma_rmAllocIrIntr+0x11c> @ imm = #-0x2
700a30dc: e7ff         	b	0x700a30de <Udma_rmAllocIrIntr+0x11e> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a30de: 9806         	ldr	r0, [sp, #0x18]
700a30e0: f500 609f    	add.w	r0, r0, #0x4f8
700a30e4: f008 fddc    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x8bb8
;     return (irIntrNum);
700a30e8: 9801         	ldr	r0, [sp, #0x4]
700a30ea: b008         	add	sp, #0x20
700a30ec: bd80         	pop	{r7, pc}
700a30ee: 0000         	movs	r0, r0

700a30f0 <xQueueGenericSend>:
; {
700a30f0: b580         	push	{r7, lr}
700a30f2: b08a         	sub	sp, #0x28
700a30f4: 9008         	str	r0, [sp, #0x20]
700a30f6: 9107         	str	r1, [sp, #0x1c]
700a30f8: 9206         	str	r2, [sp, #0x18]
700a30fa: 9305         	str	r3, [sp, #0x14]
700a30fc: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
700a30fe: 9004         	str	r0, [sp, #0x10]
;     Queue_t * const pxQueue = xQueue;
700a3100: 9808         	ldr	r0, [sp, #0x20]
700a3102: 9000         	str	r0, [sp]
;     for( ; ; )
700a3104: e7ff         	b	0x700a3106 <xQueueGenericSend+0x16> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a3106: f00b f9e3    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0xb3c6
;             if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
700a310a: 9800         	ldr	r0, [sp]
700a310c: 6b80         	ldr	r0, [r0, #0x38]
700a310e: 9900         	ldr	r1, [sp]
700a3110: 6bc9         	ldr	r1, [r1, #0x3c]
700a3112: 4288         	cmp	r0, r1
700a3114: d304         	blo	0x700a3120 <xQueueGenericSend+0x30> @ imm = #0x8
700a3116: e7ff         	b	0x700a3118 <xQueueGenericSend+0x28> @ imm = #-0x2
700a3118: 9805         	ldr	r0, [sp, #0x14]
700a311a: 2802         	cmp	r0, #0x2
700a311c: d120         	bne	0x700a3160 <xQueueGenericSend+0x70> @ imm = #0x40
700a311e: e7ff         	b	0x700a3120 <xQueueGenericSend+0x30> @ imm = #-0x2
;                         xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
700a3120: 9800         	ldr	r0, [sp]
700a3122: 9907         	ldr	r1, [sp, #0x1c]
700a3124: 9a05         	ldr	r2, [sp, #0x14]
700a3126: f003 fbe3    	bl	0x700a68f0 <prvCopyDataToQueue> @ imm = #0x37c6
700a312a: 9003         	str	r0, [sp, #0xc]
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a312c: 9800         	ldr	r0, [sp]
700a312e: 6a40         	ldr	r0, [r0, #0x24]
700a3130: b150         	cbz	r0, 0x700a3148 <xQueueGenericSend+0x58> @ imm = #0x14
700a3132: e7ff         	b	0x700a3134 <xQueueGenericSend+0x44> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a3134: 9800         	ldr	r0, [sp]
700a3136: 3024         	adds	r0, #0x24
700a3138: f004 fb5a    	bl	0x700a77f0 <xTaskRemoveFromEventList> @ imm = #0x46b4
700a313c: b110         	cbz	r0, 0x700a3144 <xQueueGenericSend+0x54> @ imm = #0x4
700a313e: e7ff         	b	0x700a3140 <xQueueGenericSend+0x50> @ imm = #-0x2
;                                 queueYIELD_IF_USING_PREEMPTION();
700a3140: df00         	svc	#0x0
;                             }
700a3142: e000         	b	0x700a3146 <xQueueGenericSend+0x56> @ imm = #0x0
700a3144: e7ff         	b	0x700a3146 <xQueueGenericSend+0x56> @ imm = #-0x2
;                         }
700a3146: e006         	b	0x700a3156 <xQueueGenericSend+0x66> @ imm = #0xc
;                         else if( xYieldRequired != pdFALSE )
700a3148: 9803         	ldr	r0, [sp, #0xc]
700a314a: b110         	cbz	r0, 0x700a3152 <xQueueGenericSend+0x62> @ imm = #0x4
700a314c: e7ff         	b	0x700a314e <xQueueGenericSend+0x5e> @ imm = #-0x2
;                             queueYIELD_IF_USING_PREEMPTION();
700a314e: df00         	svc	#0x0
;                         }
700a3150: e000         	b	0x700a3154 <xQueueGenericSend+0x64> @ imm = #0x0
700a3152: e7ff         	b	0x700a3154 <xQueueGenericSend+0x64> @ imm = #-0x2
700a3154: e7ff         	b	0x700a3156 <xQueueGenericSend+0x66> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a3156: f00a fa7b    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xa4f6
700a315a: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a315c: 9009         	str	r0, [sp, #0x24]
700a315e: e05b         	b	0x700a3218 <xQueueGenericSend+0x128> @ imm = #0xb6
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a3160: 9806         	ldr	r0, [sp, #0x18]
700a3162: b928         	cbnz	r0, 0x700a3170 <xQueueGenericSend+0x80> @ imm = #0xa
700a3164: e7ff         	b	0x700a3166 <xQueueGenericSend+0x76> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a3166: f00a fa73    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xa4e6
700a316a: 2000         	movs	r0, #0x0
;                     return errQUEUE_FULL;
700a316c: 9009         	str	r0, [sp, #0x24]
700a316e: e053         	b	0x700a3218 <xQueueGenericSend+0x128> @ imm = #0xa6
;                 else if( xEntryTimeSet == pdFALSE )
700a3170: 9804         	ldr	r0, [sp, #0x10]
700a3172: b930         	cbnz	r0, 0x700a3182 <xQueueGenericSend+0x92> @ imm = #0xc
700a3174: e7ff         	b	0x700a3176 <xQueueGenericSend+0x86> @ imm = #-0x2
700a3176: a801         	add	r0, sp, #0x4
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a3178: f00b ff0a    	bl	0x700aef90 <vTaskInternalSetTimeOutState> @ imm = #0xbe14
700a317c: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a317e: 9004         	str	r0, [sp, #0x10]
;                 }
700a3180: e000         	b	0x700a3184 <xQueueGenericSend+0x94> @ imm = #0x0
700a3182: e7ff         	b	0x700a3184 <xQueueGenericSend+0x94> @ imm = #-0x2
700a3184: e7ff         	b	0x700a3186 <xQueueGenericSend+0x96> @ imm = #-0x2
700a3186: e7ff         	b	0x700a3188 <xQueueGenericSend+0x98> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a3188: f00a fa62    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xa4c4
;         vTaskSuspendAll();
700a318c: f00c fb90    	bl	0x700af8b0 <vTaskSuspendAll> @ imm = #0xc720
;         prvLockQueue( pxQueue );
700a3190: f00b f99e    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0xb33c
700a3194: 9800         	ldr	r0, [sp]
700a3196: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a319a: 3001         	adds	r0, #0x1
700a319c: b928         	cbnz	r0, 0x700a31aa <xQueueGenericSend+0xba> @ imm = #0xa
700a319e: e7ff         	b	0x700a31a0 <xQueueGenericSend+0xb0> @ imm = #-0x2
700a31a0: 9900         	ldr	r1, [sp]
700a31a2: 2000         	movs	r0, #0x0
700a31a4: f881 0044    	strb.w	r0, [r1, #0x44]
700a31a8: e7ff         	b	0x700a31aa <xQueueGenericSend+0xba> @ imm = #-0x2
700a31aa: 9800         	ldr	r0, [sp]
700a31ac: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a31b0: 3001         	adds	r0, #0x1
700a31b2: b928         	cbnz	r0, 0x700a31c0 <xQueueGenericSend+0xd0> @ imm = #0xa
700a31b4: e7ff         	b	0x700a31b6 <xQueueGenericSend+0xc6> @ imm = #-0x2
700a31b6: 9900         	ldr	r1, [sp]
700a31b8: 2000         	movs	r0, #0x0
700a31ba: f881 0045    	strb.w	r0, [r1, #0x45]
700a31be: e7ff         	b	0x700a31c0 <xQueueGenericSend+0xd0> @ imm = #-0x2
700a31c0: f00a fa46    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xa48c
700a31c4: a801         	add	r0, sp, #0x4
700a31c6: a906         	add	r1, sp, #0x18
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a31c8: f005 ff2a    	bl	0x700a9020 <xTaskCheckForTimeOut> @ imm = #0x5e54
700a31cc: b9d8         	cbnz	r0, 0x700a3206 <xQueueGenericSend+0x116> @ imm = #0x36
700a31ce: e7ff         	b	0x700a31d0 <xQueueGenericSend+0xe0> @ imm = #-0x2
;             if( prvIsQueueFull( pxQueue ) != pdFALSE )
700a31d0: 9800         	ldr	r0, [sp]
700a31d2: f00b fac5    	bl	0x700ae760 <prvIsQueueFull> @ imm = #0xb58a
700a31d6: b178         	cbz	r0, 0x700a31f8 <xQueueGenericSend+0x108> @ imm = #0x1e
700a31d8: e7ff         	b	0x700a31da <xQueueGenericSend+0xea> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
700a31da: 9800         	ldr	r0, [sp]
700a31dc: 3010         	adds	r0, #0x10
700a31de: 9906         	ldr	r1, [sp, #0x18]
700a31e0: f00b fdee    	bl	0x700aedc0 <vTaskPlaceOnEventList> @ imm = #0xbbdc
;                 prvUnlockQueue( pxQueue );
700a31e4: 9800         	ldr	r0, [sp]
700a31e6: f004 fd2b    	bl	0x700a7c40 <prvUnlockQueue> @ imm = #0x4a56
;                 if( xTaskResumeAll() == pdFALSE )
700a31ea: f7fe ff51    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0x115e
700a31ee: b910         	cbnz	r0, 0x700a31f6 <xQueueGenericSend+0x106> @ imm = #0x4
700a31f0: e7ff         	b	0x700a31f2 <xQueueGenericSend+0x102> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a31f2: df00         	svc	#0x0
;                 }
700a31f4: e7ff         	b	0x700a31f6 <xQueueGenericSend+0x106> @ imm = #-0x2
;             }
700a31f6: e005         	b	0x700a3204 <xQueueGenericSend+0x114> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a31f8: 9800         	ldr	r0, [sp]
700a31fa: f004 fd21    	bl	0x700a7c40 <prvUnlockQueue> @ imm = #0x4a42
;                 ( void ) xTaskResumeAll();
700a31fe: f7fe ff47    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0x1172
700a3202: e7ff         	b	0x700a3204 <xQueueGenericSend+0x114> @ imm = #-0x2
;         }
700a3204: e007         	b	0x700a3216 <xQueueGenericSend+0x126> @ imm = #0xe
;             prvUnlockQueue( pxQueue );
700a3206: 9800         	ldr	r0, [sp]
700a3208: f004 fd1a    	bl	0x700a7c40 <prvUnlockQueue> @ imm = #0x4a34
;             ( void ) xTaskResumeAll();
700a320c: f7fe ff40    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0x1180
700a3210: 2000         	movs	r0, #0x0
;             return errQUEUE_FULL;
700a3212: 9009         	str	r0, [sp, #0x24]
700a3214: e000         	b	0x700a3218 <xQueueGenericSend+0x128> @ imm = #0x0
;     for( ; ; )
700a3216: e776         	b	0x700a3106 <xQueueGenericSend+0x16> @ imm = #-0x114
; }
700a3218: 9809         	ldr	r0, [sp, #0x24]
700a321a: b00a         	add	sp, #0x28
700a321c: bd80         	pop	{r7, pc}
700a321e: 0000         	movs	r0, r0

700a3220 <UART_lld_init>:
; {
700a3220: b580         	push	{r7, lr}
700a3222: b084         	sub	sp, #0x10
700a3224: 9003         	str	r0, [sp, #0xc]
700a3226: 2000         	movs	r0, #0x0
;     int32_t                status = UART_STATUS_SUCCESS;
700a3228: 9002         	str	r0, [sp, #0x8]
;     if((hUart != NULL_PTR) && (hUart->hUartInit != NULL_PTR))
700a322a: 9803         	ldr	r0, [sp, #0xc]
700a322c: b168         	cbz	r0, 0x700a324a <UART_lld_init+0x2a> @ imm = #0x1a
700a322e: e7ff         	b	0x700a3230 <UART_lld_init+0x10> @ imm = #-0x2
700a3230: 9803         	ldr	r0, [sp, #0xc]
700a3232: 6840         	ldr	r0, [r0, #0x4]
700a3234: b148         	cbz	r0, 0x700a324a <UART_lld_init+0x2a> @ imm = #0x12
700a3236: e7ff         	b	0x700a3238 <UART_lld_init+0x18> @ imm = #-0x2
;         if(hUart->state != UART_STATE_RESET)
700a3238: 9803         	ldr	r0, [sp, #0xc]
700a323a: 6d40         	ldr	r0, [r0, #0x54]
700a323c: b120         	cbz	r0, 0x700a3248 <UART_lld_init+0x28> @ imm = #0x8
700a323e: e7ff         	b	0x700a3240 <UART_lld_init+0x20> @ imm = #-0x2
700a3240: f06f 0004    	mvn	r0, #0x4
;             status = UART_TRANSFER_INVALID_STATE;
700a3244: 9002         	str	r0, [sp, #0x8]
;         }
700a3246: e7ff         	b	0x700a3248 <UART_lld_init+0x28> @ imm = #-0x2
;     }
700a3248: e003         	b	0x700a3252 <UART_lld_init+0x32> @ imm = #0x6
700a324a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a324e: 9002         	str	r0, [sp, #0x8]
700a3250: e7ff         	b	0x700a3252 <UART_lld_init+0x32> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a3252: 9802         	ldr	r0, [sp, #0x8]
700a3254: 2800         	cmp	r0, #0x0
700a3256: d176         	bne	0x700a3346 <UART_lld_init+0x126> @ imm = #0xec
700a3258: e7ff         	b	0x700a325a <UART_lld_init+0x3a> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a325a: 9903         	ldr	r1, [sp, #0xc]
700a325c: 2002         	movs	r0, #0x2
700a325e: 6548         	str	r0, [r1, #0x54]
;         hUartInit = hUart->hUartInit;
700a3260: 9803         	ldr	r0, [sp, #0xc]
700a3262: 6840         	ldr	r0, [r0, #0x4]
700a3264: 9001         	str	r0, [sp, #0x4]
;         hUart->lineStatusTimeout = hUartInit->clockP_usecToTick(UART_READ_LINE_STATUS_TIMEOUT_IN_US);
700a3266: 9801         	ldr	r0, [sp, #0x4]
700a3268: 6d82         	ldr	r2, [r0, #0x58]
700a326a: f244 2040    	movw	r0, #0x4240
700a326e: f2c0 000f    	movt	r0, #0xf
700a3272: 2100         	movs	r1, #0x0
700a3274: 9100         	str	r1, [sp]
700a3276: 4790         	blx	r2
700a3278: 9a00         	ldr	r2, [sp]
700a327a: 9903         	ldr	r1, [sp, #0xc]
700a327c: 66ca         	str	r2, [r1, #0x6c]
700a327e: 6688         	str	r0, [r1, #0x68]
;         status += UART_IsBaseAddrValid(hUart->baseAddr);
700a3280: 9803         	ldr	r0, [sp, #0xc]
700a3282: 6800         	ldr	r0, [r0]
700a3284: f005 f9ac    	bl	0x700a85e0 <UART_IsBaseAddrValid> @ imm = #0x5358
700a3288: 4601         	mov	r1, r0
700a328a: 9802         	ldr	r0, [sp, #0x8]
700a328c: 4408         	add	r0, r1
700a328e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->inputClkFreq);
700a3290: 9801         	ldr	r0, [sp, #0x4]
700a3292: 6800         	ldr	r0, [r0]
700a3294: f00b fffc    	bl	0x700af290 <UART_IsParameter> @ imm = #0xbff8
700a3298: 4601         	mov	r1, r0
700a329a: 9802         	ldr	r0, [sp, #0x8]
700a329c: 4408         	add	r0, r1
700a329e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->baudRate);
700a32a0: 9801         	ldr	r0, [sp, #0x4]
700a32a2: 6840         	ldr	r0, [r0, #0x4]
700a32a4: f00b fff4    	bl	0x700af290 <UART_IsParameter> @ imm = #0xbfe8
700a32a8: 4601         	mov	r1, r0
700a32aa: 9802         	ldr	r0, [sp, #0x8]
700a32ac: 4408         	add	r0, r1
700a32ae: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsDataLengthValid(hUartInit->dataLength);
700a32b0: 9801         	ldr	r0, [sp, #0x4]
700a32b2: 6880         	ldr	r0, [r0, #0x8]
700a32b4: f00b f814    	bl	0x700ae2e0 <UART_IsDataLengthValid> @ imm = #0xb028
700a32b8: 4601         	mov	r1, r0
700a32ba: 9802         	ldr	r0, [sp, #0x8]
700a32bc: 4408         	add	r0, r1
700a32be: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsStopBitsValid(hUartInit->stopBits);
700a32c0: 9801         	ldr	r0, [sp, #0x4]
700a32c2: 68c0         	ldr	r0, [r0, #0xc]
700a32c4: f00b fe24    	bl	0x700aef10 <UART_IsStopBitsValid> @ imm = #0xbc48
700a32c8: 4601         	mov	r1, r0
700a32ca: 9802         	ldr	r0, [sp, #0x8]
700a32cc: 4408         	add	r0, r1
700a32ce: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParityTypeValid(hUartInit->parityType);
700a32d0: 9801         	ldr	r0, [sp, #0x4]
700a32d2: 6900         	ldr	r0, [r0, #0x10]
700a32d4: f00a fd64    	bl	0x700adda0 <UART_IsParityTypeValid> @ imm = #0xaac8
700a32d8: 4601         	mov	r1, r0
700a32da: 9802         	ldr	r0, [sp, #0x8]
700a32dc: 4408         	add	r0, r1
700a32de: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsHWFlowCtrlValid(hUartInit->hwFlowControlThr);
700a32e0: 9801         	ldr	r0, [sp, #0x4]
700a32e2: 69c0         	ldr	r0, [r0, #0x1c]
700a32e4: f00a fc1c    	bl	0x700adb20 <UART_IsHWFlowCtrlValid> @ imm = #0xa838
700a32e8: 4601         	mov	r1, r0
700a32ea: 9802         	ldr	r0, [sp, #0x8]
700a32ec: 4408         	add	r0, r1
700a32ee: 9002         	str	r0, [sp, #0x8]
;         status += UART_OperModeValid(hUartInit->operMode);
700a32f0: 9801         	ldr	r0, [sp, #0x4]
700a32f2: 6ac0         	ldr	r0, [r0, #0x2c]
700a32f4: f009 fc74    	bl	0x700acbe0 <UART_OperModeValid> @ imm = #0x98e8
700a32f8: 4601         	mov	r1, r0
700a32fa: 9802         	ldr	r0, [sp, #0x8]
700a32fc: 4408         	add	r0, r1
700a32fe: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsRxTrigLvlValid(hUartInit->rxTrigLvl);
700a3300: 9801         	ldr	r0, [sp, #0x4]
700a3302: 6b80         	ldr	r0, [r0, #0x38]
700a3304: f00a fc2c    	bl	0x700adb60 <UART_IsRxTrigLvlValid> @ imm = #0xa858
700a3308: 4601         	mov	r1, r0
700a330a: 9802         	ldr	r0, [sp, #0x8]
700a330c: 4408         	add	r0, r1
700a330e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsTxTrigLvlValid(hUartInit->txTrigLvl);
700a3310: 9801         	ldr	r0, [sp, #0x4]
700a3312: 6bc0         	ldr	r0, [r0, #0x3c]
700a3314: f00a fc44    	bl	0x700adba0 <UART_IsTxTrigLvlValid> @ imm = #0xa888
700a3318: 4601         	mov	r1, r0
700a331a: 9802         	ldr	r0, [sp, #0x8]
700a331c: 4408         	add	r0, r1
700a331e: 9002         	str	r0, [sp, #0x8]
;         if(UART_STATUS_SUCCESS == status)
700a3320: 9802         	ldr	r0, [sp, #0x8]
700a3322: b938         	cbnz	r0, 0x700a3334 <UART_lld_init+0x114> @ imm = #0xe
700a3324: e7ff         	b	0x700a3326 <UART_lld_init+0x106> @ imm = #-0x2
;             UART_configInstance(hUart);
700a3326: 9803         	ldr	r0, [sp, #0xc]
700a3328: f001 fffa    	bl	0x700a5320 <UART_configInstance> @ imm = #0x1ff4
;             hUart->state = UART_STATE_READY;
700a332c: 9903         	ldr	r1, [sp, #0xc]
700a332e: 2001         	movs	r0, #0x1
700a3330: 6548         	str	r0, [r1, #0x54]
;         }
700a3332: e007         	b	0x700a3344 <UART_lld_init+0x124> @ imm = #0xe
;             status += UART_lld_deInit(hUart);
700a3334: 9803         	ldr	r0, [sp, #0xc]
700a3336: f009 f83b    	bl	0x700ac3b0 <UART_lld_deInit> @ imm = #0x9076
700a333a: 4601         	mov	r1, r0
700a333c: 9802         	ldr	r0, [sp, #0x8]
700a333e: 4408         	add	r0, r1
700a3340: 9002         	str	r0, [sp, #0x8]
700a3342: e7ff         	b	0x700a3344 <UART_lld_init+0x124> @ imm = #-0x2
;     }
700a3344: e7ff         	b	0x700a3346 <UART_lld_init+0x126> @ imm = #-0x2
;     return status;
700a3346: 9802         	ldr	r0, [sp, #0x8]
700a3348: b004         	add	sp, #0x10
700a334a: bd80         	pop	{r7, pc}
700a334c: 0000         	movs	r0, r0
700a334e: 0000         	movs	r0, r0

700a3350 <Sciclient_pmQueryModuleClkFreq>:
; {
700a3350: b580         	push	{r7, lr}
700a3352: b09e         	sub	sp, #0x78
700a3354: f8dd c084    	ldr.w	r12, [sp, #0x84]
700a3358: f8dd c080    	ldr.w	r12, [sp, #0x80]
700a335c: 901d         	str	r0, [sp, #0x74]
700a335e: 911c         	str	r1, [sp, #0x70]
700a3360: 931b         	str	r3, [sp, #0x6c]
700a3362: 921a         	str	r2, [sp, #0x68]
700a3364: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a3366: 9019         	str	r0, [sp, #0x64]
;     request.device         = (uint32_t) moduleId;
700a3368: 981d         	ldr	r0, [sp, #0x74]
700a336a: 9010         	str	r0, [sp, #0x40]
;     request.min_freq_hz    = (uint64_t) reqFreqHz;
700a336c: 981a         	ldr	r0, [sp, #0x68]
700a336e: 991b         	ldr	r1, [sp, #0x6c]
700a3370: 9112         	str	r1, [sp, #0x48]
700a3372: 9011         	str	r0, [sp, #0x44]
;     request.target_freq_hz = (uint64_t) reqFreqHz;
700a3374: 981a         	ldr	r0, [sp, #0x68]
700a3376: 991b         	ldr	r1, [sp, #0x6c]
700a3378: 9114         	str	r1, [sp, #0x50]
700a337a: 9013         	str	r0, [sp, #0x4c]
;     request.max_freq_hz    = (uint64_t) reqFreqHz;
700a337c: 981a         	ldr	r0, [sp, #0x68]
700a337e: 991b         	ldr	r1, [sp, #0x6c]
700a3380: 9116         	str	r1, [sp, #0x58]
700a3382: 9015         	str	r0, [sp, #0x54]
;     if((reqFreqHz%10U) != 0U)
700a3384: 9b1a         	ldr	r3, [sp, #0x68]
700a3386: 981b         	ldr	r0, [sp, #0x6c]
700a3388: f64c 41cd    	movw	r1, #0xcccd
700a338c: f6cc 41cc    	movt	r1, #0xcccc
700a3390: fba3 2e01    	umull	r2, lr, r3, r1
700a3394: f04f 3ccc    	mov.w	r12, #0xcccccccc
700a3398: fb03 e30c    	mla	r3, r3, r12, lr
700a339c: fb00 3101    	mla	r1, r0, r1, r3
700a33a0: ea4f 70c2    	lsl.w	r0, r2, #0x1f
700a33a4: ea40 0051    	orr.w	r0, r0, r1, lsr #1
700a33a8: ea4f 71c1    	lsl.w	r1, r1, #0x1f
700a33ac: ea41 0152    	orr.w	r1, r1, r2, lsr #1
700a33b0: f649 129a    	movw	r2, #0x999a
700a33b4: f6c9 1299    	movt	r2, #0x9999
700a33b8: 1a89         	subs	r1, r1, r2
700a33ba: f649 1199    	movw	r1, #0x9999
700a33be: f6c1 1199    	movt	r1, #0x1999
700a33c2: 4188         	sbcs	r0, r1
700a33c4: d316         	blo	0x700a33f4 <Sciclient_pmQueryModuleClkFreq+0xa4> @ imm = #0x2c
700a33c6: e7ff         	b	0x700a33c8 <Sciclient_pmQueryModuleClkFreq+0x78> @ imm = #-0x2
;         request.min_freq_hz = (uint64_t)(reqFreqHz-(reqFreqHz%10U));
700a33c8: 981a         	ldr	r0, [sp, #0x68]
700a33ca: 9001         	str	r0, [sp, #0x4]
700a33cc: 991b         	ldr	r1, [sp, #0x6c]
700a33ce: 9100         	str	r1, [sp]
700a33d0: 220a         	movs	r2, #0xa
700a33d2: 2300         	movs	r3, #0x0
700a33d4: f00b edae    	blx	0x700aef34 <__aeabi_uldivmod> @ imm = #0xbb5c
700a33d8: 9800         	ldr	r0, [sp]
700a33da: 9901         	ldr	r1, [sp, #0x4]
700a33dc: 1a89         	subs	r1, r1, r2
700a33de: 4198         	sbcs	r0, r3
700a33e0: 9111         	str	r1, [sp, #0x44]
700a33e2: 9012         	str	r0, [sp, #0x48]
;         request.max_freq_hz = (uint64_t)(request.min_freq_hz + 10UL);
700a33e4: 9911         	ldr	r1, [sp, #0x44]
700a33e6: 9812         	ldr	r0, [sp, #0x48]
700a33e8: 310a         	adds	r1, #0xa
700a33ea: f140 0000    	adc	r0, r0, #0x0
700a33ee: 9115         	str	r1, [sp, #0x54]
700a33f0: 9016         	str	r0, [sp, #0x58]
;     }
700a33f2: e7ff         	b	0x700a33f4 <Sciclient_pmQueryModuleClkFreq+0xa4> @ imm = #-0x2
;     if (clockId >= 255U)
700a33f4: 981c         	ldr	r0, [sp, #0x70]
700a33f6: 28ff         	cmp	r0, #0xff
700a33f8: d307         	blo	0x700a340a <Sciclient_pmQueryModuleClkFreq+0xba> @ imm = #0xe
700a33fa: e7ff         	b	0x700a33fc <Sciclient_pmQueryModuleClkFreq+0xac> @ imm = #-0x2
;         request.clk32 = clockId;
700a33fc: 981c         	ldr	r0, [sp, #0x70]
700a33fe: f8cd 005d    	str.w	r0, [sp, #0x5d]
700a3402: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a3404: f88d 005c    	strb.w	r0, [sp, #0x5c]
;     }
700a3408: e003         	b	0x700a3412 <Sciclient_pmQueryModuleClkFreq+0xc2> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a340a: 981c         	ldr	r0, [sp, #0x70]
700a340c: f88d 005c    	strb.w	r0, [sp, #0x5c]
700a3410: e7ff         	b	0x700a3412 <Sciclient_pmQueryModuleClkFreq+0xc2> @ imm = #-0x2
700a3412: 2000         	movs	r0, #0x0
;     struct tisci_msg_query_freq_resp response = {{0}};
700a3414: 900d         	str	r0, [sp, #0x34]
700a3416: 900c         	str	r0, [sp, #0x30]
700a3418: 900b         	str	r0, [sp, #0x2c]
700a341a: 900a         	str	r0, [sp, #0x28]
700a341c: f240 110d    	movw	r1, #0x10d
;     reqParam.messageType    = (uint16_t) TISCI_MSG_QUERY_FREQ;
700a3420: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a3424: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a3426: 9106         	str	r1, [sp, #0x18]
700a3428: a90e         	add	r1, sp, #0x38
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a342a: 9107         	str	r1, [sp, #0x1c]
700a342c: 2129         	movs	r1, #0x29
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a342e: 9108         	str	r1, [sp, #0x20]
;     reqParam.timeout        = (uint32_t) timeout;
700a3430: 9921         	ldr	r1, [sp, #0x84]
700a3432: 9109         	str	r1, [sp, #0x24]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a3434: 9002         	str	r0, [sp, #0x8]
700a3436: a80a         	add	r0, sp, #0x28
;     respParam.pRespPayload    = (uint8_t *) &response;
700a3438: 9003         	str	r0, [sp, #0xc]
700a343a: 2010         	movs	r0, #0x10
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a343c: 9004         	str	r0, [sp, #0x10]
700a343e: a805         	add	r0, sp, #0x14
700a3440: a902         	add	r1, sp, #0x8
;     retVal = Sciclient_service(&reqParam, &respParam);
700a3442: f7f9 ff1d    	bl	0x7009d280 <Sciclient_service> @ imm = #-0x61c6
700a3446: 9019         	str	r0, [sp, #0x64]
;     if((retVal != SystemP_SUCCESS) ||
700a3448: 9819         	ldr	r0, [sp, #0x64]
700a344a: b930         	cbnz	r0, 0x700a345a <Sciclient_pmQueryModuleClkFreq+0x10a> @ imm = #0xc
700a344c: e7ff         	b	0x700a344e <Sciclient_pmQueryModuleClkFreq+0xfe> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a344e: 9802         	ldr	r0, [sp, #0x8]
700a3450: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a3454: 2802         	cmp	r0, #0x2
700a3456: d004         	beq	0x700a3462 <Sciclient_pmQueryModuleClkFreq+0x112> @ imm = #0x8
700a3458: e7ff         	b	0x700a345a <Sciclient_pmQueryModuleClkFreq+0x10a> @ imm = #-0x2
700a345a: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a345e: 9019         	str	r0, [sp, #0x64]
;     }
700a3460: e7ff         	b	0x700a3462 <Sciclient_pmQueryModuleClkFreq+0x112> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a3462: 9819         	ldr	r0, [sp, #0x64]
700a3464: b930         	cbnz	r0, 0x700a3474 <Sciclient_pmQueryModuleClkFreq+0x124> @ imm = #0xc
700a3466: e7ff         	b	0x700a3468 <Sciclient_pmQueryModuleClkFreq+0x118> @ imm = #-0x2
;         *respFreqHz = (uint64_t) response.freq_hz;
700a3468: 980c         	ldr	r0, [sp, #0x30]
700a346a: 9a0d         	ldr	r2, [sp, #0x34]
700a346c: 9920         	ldr	r1, [sp, #0x80]
700a346e: 604a         	str	r2, [r1, #0x4]
700a3470: 6008         	str	r0, [r1]
;     }
700a3472: e7ff         	b	0x700a3474 <Sciclient_pmQueryModuleClkFreq+0x124> @ imm = #-0x2
;     return retVal;
700a3474: 9819         	ldr	r0, [sp, #0x64]
700a3476: b01e         	add	sp, #0x78
700a3478: bd80         	pop	{r7, pc}
700a347a: 0000         	movs	r0, r0
700a347c: 0000         	movs	r0, r0
700a347e: 0000         	movs	r0, r0

700a3480 <xQueueReceive>:
; {
700a3480: b580         	push	{r7, lr}
700a3482: b08a         	sub	sp, #0x28
700a3484: 9008         	str	r0, [sp, #0x20]
700a3486: 9107         	str	r1, [sp, #0x1c]
700a3488: 9206         	str	r2, [sp, #0x18]
700a348a: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
700a348c: 9005         	str	r0, [sp, #0x14]
;     Queue_t * const pxQueue = xQueue;
700a348e: 9808         	ldr	r0, [sp, #0x20]
700a3490: 9002         	str	r0, [sp, #0x8]
;     for( ; ; )
700a3492: e7ff         	b	0x700a3494 <xQueueReceive+0x14> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a3494: f00b f81c    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0xb038
;             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a3498: 9802         	ldr	r0, [sp, #0x8]
700a349a: 6b80         	ldr	r0, [r0, #0x38]
700a349c: 9001         	str	r0, [sp, #0x4]
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a349e: 9801         	ldr	r0, [sp, #0x4]
700a34a0: b1e0         	cbz	r0, 0x700a34dc <xQueueReceive+0x5c> @ imm = #0x38
700a34a2: e7ff         	b	0x700a34a4 <xQueueReceive+0x24> @ imm = #-0x2
;                 prvCopyDataFromQueue( pxQueue, pvBuffer );
700a34a4: 9802         	ldr	r0, [sp, #0x8]
700a34a6: 9907         	ldr	r1, [sp, #0x1c]
700a34a8: f00a fa12    	bl	0x700ad8d0 <prvCopyDataFromQueue> @ imm = #0xa424
;                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
700a34ac: 9801         	ldr	r0, [sp, #0x4]
700a34ae: 3801         	subs	r0, #0x1
700a34b0: 9902         	ldr	r1, [sp, #0x8]
700a34b2: 6388         	str	r0, [r1, #0x38]
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a34b4: 9802         	ldr	r0, [sp, #0x8]
700a34b6: 6900         	ldr	r0, [r0, #0x10]
700a34b8: b150         	cbz	r0, 0x700a34d0 <xQueueReceive+0x50> @ imm = #0x14
700a34ba: e7ff         	b	0x700a34bc <xQueueReceive+0x3c> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a34bc: 9802         	ldr	r0, [sp, #0x8]
700a34be: 3010         	adds	r0, #0x10
700a34c0: f004 f996    	bl	0x700a77f0 <xTaskRemoveFromEventList> @ imm = #0x432c
700a34c4: b110         	cbz	r0, 0x700a34cc <xQueueReceive+0x4c> @ imm = #0x4
700a34c6: e7ff         	b	0x700a34c8 <xQueueReceive+0x48> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
700a34c8: df00         	svc	#0x0
;                     }
700a34ca: e000         	b	0x700a34ce <xQueueReceive+0x4e> @ imm = #0x0
700a34cc: e7ff         	b	0x700a34ce <xQueueReceive+0x4e> @ imm = #-0x2
;                 }
700a34ce: e000         	b	0x700a34d2 <xQueueReceive+0x52> @ imm = #0x0
700a34d0: e7ff         	b	0x700a34d2 <xQueueReceive+0x52> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a34d2: f00a f8bd    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xa17a
700a34d6: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a34d8: 9009         	str	r0, [sp, #0x24]
700a34da: e063         	b	0x700a35a4 <xQueueReceive+0x124> @ imm = #0xc6
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a34dc: 9806         	ldr	r0, [sp, #0x18]
700a34de: b928         	cbnz	r0, 0x700a34ec <xQueueReceive+0x6c> @ imm = #0xa
700a34e0: e7ff         	b	0x700a34e2 <xQueueReceive+0x62> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a34e2: f00a f8b5    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xa16a
700a34e6: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
700a34e8: 9009         	str	r0, [sp, #0x24]
700a34ea: e05b         	b	0x700a35a4 <xQueueReceive+0x124> @ imm = #0xb6
;                 else if( xEntryTimeSet == pdFALSE )
700a34ec: 9805         	ldr	r0, [sp, #0x14]
700a34ee: b930         	cbnz	r0, 0x700a34fe <xQueueReceive+0x7e> @ imm = #0xc
700a34f0: e7ff         	b	0x700a34f2 <xQueueReceive+0x72> @ imm = #-0x2
700a34f2: a803         	add	r0, sp, #0xc
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a34f4: f00b fd4c    	bl	0x700aef90 <vTaskInternalSetTimeOutState> @ imm = #0xba98
700a34f8: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a34fa: 9005         	str	r0, [sp, #0x14]
;                 }
700a34fc: e000         	b	0x700a3500 <xQueueReceive+0x80> @ imm = #0x0
700a34fe: e7ff         	b	0x700a3500 <xQueueReceive+0x80> @ imm = #-0x2
700a3500: e7ff         	b	0x700a3502 <xQueueReceive+0x82> @ imm = #-0x2
700a3502: e7ff         	b	0x700a3504 <xQueueReceive+0x84> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a3504: f00a f8a4    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xa148
;         vTaskSuspendAll();
700a3508: f00c f9d2    	bl	0x700af8b0 <vTaskSuspendAll> @ imm = #0xc3a4
;         prvLockQueue( pxQueue );
700a350c: f00a ffe0    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0xafc0
700a3510: 9802         	ldr	r0, [sp, #0x8]
700a3512: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a3516: 3001         	adds	r0, #0x1
700a3518: b928         	cbnz	r0, 0x700a3526 <xQueueReceive+0xa6> @ imm = #0xa
700a351a: e7ff         	b	0x700a351c <xQueueReceive+0x9c> @ imm = #-0x2
700a351c: 9902         	ldr	r1, [sp, #0x8]
700a351e: 2000         	movs	r0, #0x0
700a3520: f881 0044    	strb.w	r0, [r1, #0x44]
700a3524: e7ff         	b	0x700a3526 <xQueueReceive+0xa6> @ imm = #-0x2
700a3526: 9802         	ldr	r0, [sp, #0x8]
700a3528: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a352c: 3001         	adds	r0, #0x1
700a352e: b928         	cbnz	r0, 0x700a353c <xQueueReceive+0xbc> @ imm = #0xa
700a3530: e7ff         	b	0x700a3532 <xQueueReceive+0xb2> @ imm = #-0x2
700a3532: 9902         	ldr	r1, [sp, #0x8]
700a3534: 2000         	movs	r0, #0x0
700a3536: f881 0045    	strb.w	r0, [r1, #0x45]
700a353a: e7ff         	b	0x700a353c <xQueueReceive+0xbc> @ imm = #-0x2
700a353c: f00a f888    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0xa110
700a3540: a803         	add	r0, sp, #0xc
700a3542: a906         	add	r1, sp, #0x18
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a3544: f005 fd6c    	bl	0x700a9020 <xTaskCheckForTimeOut> @ imm = #0x5ad8
700a3548: b9e0         	cbnz	r0, 0x700a3584 <xQueueReceive+0x104> @ imm = #0x38
700a354a: e7ff         	b	0x700a354c <xQueueReceive+0xcc> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a354c: 9802         	ldr	r0, [sp, #0x8]
700a354e: f00b fb77    	bl	0x700aec40 <prvIsQueueEmpty> @ imm = #0xb6ee
700a3552: b180         	cbz	r0, 0x700a3576 <xQueueReceive+0xf6> @ imm = #0x20
700a3554: e7ff         	b	0x700a3556 <xQueueReceive+0xd6> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
700a3556: 9802         	ldr	r0, [sp, #0x8]
700a3558: 3024         	adds	r0, #0x24
700a355a: 9906         	ldr	r1, [sp, #0x18]
700a355c: f00b fc30    	bl	0x700aedc0 <vTaskPlaceOnEventList> @ imm = #0xb860
;                 prvUnlockQueue( pxQueue );
700a3560: 9802         	ldr	r0, [sp, #0x8]
700a3562: f004 fb6d    	bl	0x700a7c40 <prvUnlockQueue> @ imm = #0x46da
;                 if( xTaskResumeAll() == pdFALSE )
700a3566: f7fe fd93    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0x14da
700a356a: b910         	cbnz	r0, 0x700a3572 <xQueueReceive+0xf2> @ imm = #0x4
700a356c: e7ff         	b	0x700a356e <xQueueReceive+0xee> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a356e: df00         	svc	#0x0
;                 }
700a3570: e000         	b	0x700a3574 <xQueueReceive+0xf4> @ imm = #0x0
700a3572: e7ff         	b	0x700a3574 <xQueueReceive+0xf4> @ imm = #-0x2
;             }
700a3574: e005         	b	0x700a3582 <xQueueReceive+0x102> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a3576: 9802         	ldr	r0, [sp, #0x8]
700a3578: f004 fb62    	bl	0x700a7c40 <prvUnlockQueue> @ imm = #0x46c4
;                 ( void ) xTaskResumeAll();
700a357c: f7fe fd88    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0x14f0
700a3580: e7ff         	b	0x700a3582 <xQueueReceive+0x102> @ imm = #-0x2
;         }
700a3582: e00e         	b	0x700a35a2 <xQueueReceive+0x122> @ imm = #0x1c
;             prvUnlockQueue( pxQueue );
700a3584: 9802         	ldr	r0, [sp, #0x8]
700a3586: f004 fb5b    	bl	0x700a7c40 <prvUnlockQueue> @ imm = #0x46b6
;             ( void ) xTaskResumeAll();
700a358a: f7fe fd81    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0x14fe
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a358e: 9802         	ldr	r0, [sp, #0x8]
700a3590: f00b fb56    	bl	0x700aec40 <prvIsQueueEmpty> @ imm = #0xb6ac
700a3594: b118         	cbz	r0, 0x700a359e <xQueueReceive+0x11e> @ imm = #0x6
700a3596: e7ff         	b	0x700a3598 <xQueueReceive+0x118> @ imm = #-0x2
700a3598: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
700a359a: 9009         	str	r0, [sp, #0x24]
700a359c: e002         	b	0x700a35a4 <xQueueReceive+0x124> @ imm = #0x4
700a359e: e7ff         	b	0x700a35a0 <xQueueReceive+0x120> @ imm = #-0x2
700a35a0: e7ff         	b	0x700a35a2 <xQueueReceive+0x122> @ imm = #-0x2
;     for( ; ; )
700a35a2: e777         	b	0x700a3494 <xQueueReceive+0x14> @ imm = #-0x112
; }
700a35a4: 9809         	ldr	r0, [sp, #0x24]
700a35a6: b00a         	add	sp, #0x28
700a35a8: bd80         	pop	{r7, pc}
700a35aa: 0000         	movs	r0, r0
700a35ac: 0000         	movs	r0, r0
700a35ae: 0000         	movs	r0, r0

700a35b0 <pxPortInitialiseStack>:
;                                    TaskFunction_t pxCode, void *pvParameters) {
700a35b0: b083         	sub	sp, #0xc
700a35b2: 9002         	str	r0, [sp, #0x8]
700a35b4: 9101         	str	r1, [sp, #0x4]
700a35b6: 9200         	str	r2, [sp]
;   *pxTopOfStack = (StackType_t)NULL;
700a35b8: 9902         	ldr	r1, [sp, #0x8]
700a35ba: 2000         	movs	r0, #0x0
700a35bc: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a35be: 9902         	ldr	r1, [sp, #0x8]
700a35c0: 3904         	subs	r1, #0x4
700a35c2: 9102         	str	r1, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)NULL;
700a35c4: 9902         	ldr	r1, [sp, #0x8]
700a35c6: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a35c8: 9902         	ldr	r1, [sp, #0x8]
700a35ca: 3904         	subs	r1, #0x4
700a35cc: 9102         	str	r1, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)NULL;
700a35ce: 9902         	ldr	r1, [sp, #0x8]
700a35d0: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a35d2: 9802         	ldr	r0, [sp, #0x8]
700a35d4: 3804         	subs	r0, #0x4
700a35d6: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)portINITIAL_SPSR;
700a35d8: 9902         	ldr	r1, [sp, #0x8]
700a35da: 201f         	movs	r0, #0x1f
700a35dc: 6008         	str	r0, [r1]
;   if (((uint32_t)pxCode & portTHUMB_MODE_ADDRESS) != 0x00UL) {
700a35de: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a35e2: 07c0         	lsls	r0, r0, #0x1f
700a35e4: b130         	cbz	r0, 0x700a35f4 <pxPortInitialiseStack+0x44> @ imm = #0xc
700a35e6: e7ff         	b	0x700a35e8 <pxPortInitialiseStack+0x38> @ imm = #-0x2
;     *pxTopOfStack |= portTHUMB_MODE_BIT;
700a35e8: 9902         	ldr	r1, [sp, #0x8]
700a35ea: 6808         	ldr	r0, [r1]
700a35ec: f040 0020    	orr	r0, r0, #0x20
700a35f0: 6008         	str	r0, [r1]
;   }
700a35f2: e7ff         	b	0x700a35f4 <pxPortInitialiseStack+0x44> @ imm = #-0x2
;   pxTopOfStack--;
700a35f4: 9802         	ldr	r0, [sp, #0x8]
700a35f6: 3804         	subs	r0, #0x4
700a35f8: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)pxCode;
700a35fa: 9801         	ldr	r0, [sp, #0x4]
700a35fc: 9902         	ldr	r1, [sp, #0x8]
700a35fe: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3600: 9802         	ldr	r0, [sp, #0x8]
700a3602: 3804         	subs	r0, #0x4
700a3604: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* R14 */
700a3606: 9902         	ldr	r1, [sp, #0x8]
700a3608: f64f 10c1    	movw	r0, #0xf9c1
700a360c: f2c7 000a    	movt	r0, #0x700a
700a3610: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3612: 9802         	ldr	r0, [sp, #0x8]
700a3614: 3804         	subs	r0, #0x4
700a3616: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x12121212; /* R12 */
700a3618: 9902         	ldr	r1, [sp, #0x8]
700a361a: f04f 3012    	mov.w	r0, #0x12121212
700a361e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3620: 9802         	ldr	r0, [sp, #0x8]
700a3622: 3804         	subs	r0, #0x4
700a3624: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x11111111; /* R11 */
700a3626: 9902         	ldr	r1, [sp, #0x8]
700a3628: f04f 3011    	mov.w	r0, #0x11111111
700a362c: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a362e: 9802         	ldr	r0, [sp, #0x8]
700a3630: 3804         	subs	r0, #0x4
700a3632: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x10101010; /* R10 */
700a3634: 9902         	ldr	r1, [sp, #0x8]
700a3636: f04f 3010    	mov.w	r0, #0x10101010
700a363a: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a363c: 9802         	ldr	r0, [sp, #0x8]
700a363e: 3804         	subs	r0, #0x4
700a3640: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x09090909; /* R9 */
700a3642: 9902         	ldr	r1, [sp, #0x8]
700a3644: f04f 3009    	mov.w	r0, #0x9090909
700a3648: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a364a: 9802         	ldr	r0, [sp, #0x8]
700a364c: 3804         	subs	r0, #0x4
700a364e: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x08080808; /* R8 */
700a3650: 9902         	ldr	r1, [sp, #0x8]
700a3652: f04f 3008    	mov.w	r0, #0x8080808
700a3656: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3658: 9802         	ldr	r0, [sp, #0x8]
700a365a: 3804         	subs	r0, #0x4
700a365c: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x07070707; /* R7 */
700a365e: 9902         	ldr	r1, [sp, #0x8]
700a3660: f04f 3007    	mov.w	r0, #0x7070707
700a3664: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3666: 9802         	ldr	r0, [sp, #0x8]
700a3668: 3804         	subs	r0, #0x4
700a366a: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x06060606; /* R6 */
700a366c: 9902         	ldr	r1, [sp, #0x8]
700a366e: f04f 3006    	mov.w	r0, #0x6060606
700a3672: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3674: 9802         	ldr	r0, [sp, #0x8]
700a3676: 3804         	subs	r0, #0x4
700a3678: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x05050505; /* R5 */
700a367a: 9902         	ldr	r1, [sp, #0x8]
700a367c: f04f 3005    	mov.w	r0, #0x5050505
700a3680: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3682: 9802         	ldr	r0, [sp, #0x8]
700a3684: 3804         	subs	r0, #0x4
700a3686: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x04040404; /* R4 */
700a3688: 9902         	ldr	r1, [sp, #0x8]
700a368a: f04f 3004    	mov.w	r0, #0x4040404
700a368e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3690: 9802         	ldr	r0, [sp, #0x8]
700a3692: 3804         	subs	r0, #0x4
700a3694: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x03030303; /* R3 */
700a3696: 9902         	ldr	r1, [sp, #0x8]
700a3698: f04f 3003    	mov.w	r0, #0x3030303
700a369c: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a369e: 9802         	ldr	r0, [sp, #0x8]
700a36a0: 3804         	subs	r0, #0x4
700a36a2: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x02020202; /* R2 */
700a36a4: 9902         	ldr	r1, [sp, #0x8]
700a36a6: f04f 3002    	mov.w	r0, #0x2020202
700a36aa: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a36ac: 9802         	ldr	r0, [sp, #0x8]
700a36ae: 3804         	subs	r0, #0x4
700a36b0: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x01010101; /* R1 */
700a36b2: 9902         	ldr	r1, [sp, #0x8]
700a36b4: f04f 3001    	mov.w	r0, #0x1010101
700a36b8: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a36ba: 9802         	ldr	r0, [sp, #0x8]
700a36bc: 3804         	subs	r0, #0x4
700a36be: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)pvParameters; /* R0 */
700a36c0: 9800         	ldr	r0, [sp]
700a36c2: 9902         	ldr	r1, [sp, #0x8]
700a36c4: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a36c6: 9802         	ldr	r0, [sp, #0x8]
700a36c8: 3804         	subs	r0, #0x4
700a36ca: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = portNO_FLOATING_POINT_CONTEXT;
700a36cc: 9902         	ldr	r1, [sp, #0x8]
700a36ce: 2000         	movs	r0, #0x0
700a36d0: 6008         	str	r0, [r1]
;   return pxTopOfStack;
700a36d2: 9802         	ldr	r0, [sp, #0x8]
700a36d4: b003         	add	sp, #0xc
700a36d6: 4770         	bx	lr
		...

700a36e0 <Udma_rmAllocBlkCopyCh>:
; {
700a36e0: b580         	push	{r7, lr}
700a36e2: b088         	sub	sp, #0x20
700a36e4: 9007         	str	r0, [sp, #0x1c]
700a36e6: 9106         	str	r1, [sp, #0x18]
700a36e8: 2000         	movs	r0, #0x0
700a36ea: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a36ee: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a36f0: 9806         	ldr	r0, [sp, #0x18]
700a36f2: f500 70ea    	add.w	r0, r0, #0x1d4
700a36f6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a36f8: 9806         	ldr	r0, [sp, #0x18]
700a36fa: f500 609f    	add.w	r0, r0, #0x4f8
700a36fe: f04f 31ff    	mov.w	r1, #0xffffffff
700a3702: f006 ff3d    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x6e7a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3706: 9807         	ldr	r0, [sp, #0x1c]
700a3708: 2101         	movs	r1, #0x1
700a370a: f6cf 71ff    	movt	r1, #0xffff
700a370e: 4288         	cmp	r0, r1
700a3710: d136         	bne	0x700a3780 <Udma_rmAllocBlkCopyCh+0xa0> @ imm = #0x6c
700a3712: e7ff         	b	0x700a3714 <Udma_rmAllocBlkCopyCh+0x34> @ imm = #-0x2
700a3714: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyCh; i++)
700a3716: 9005         	str	r0, [sp, #0x14]
700a3718: e7ff         	b	0x700a371a <Udma_rmAllocBlkCopyCh+0x3a> @ imm = #-0x2
700a371a: 9805         	ldr	r0, [sp, #0x14]
700a371c: 9900         	ldr	r1, [sp]
700a371e: 6949         	ldr	r1, [r1, #0x14]
700a3720: 4288         	cmp	r0, r1
700a3722: d22c         	bhs	0x700a377e <Udma_rmAllocBlkCopyCh+0x9e> @ imm = #0x58
700a3724: e7ff         	b	0x700a3726 <Udma_rmAllocBlkCopyCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3726: 9805         	ldr	r0, [sp, #0x14]
700a3728: 0940         	lsrs	r0, r0, #0x5
700a372a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a372c: 9805         	ldr	r0, [sp, #0x14]
700a372e: 9904         	ldr	r1, [sp, #0x10]
700a3730: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3734: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3736: 9903         	ldr	r1, [sp, #0xc]
700a3738: 2001         	movs	r0, #0x1
700a373a: 4088         	lsls	r0, r1
700a373c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyChFlag[offset] & bitMask) == bitMask)
700a373e: 9806         	ldr	r0, [sp, #0x18]
700a3740: 9904         	ldr	r1, [sp, #0x10]
700a3742: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3746: f8d0 02c8    	ldr.w	r0, [r0, #0x2c8]
700a374a: 9902         	ldr	r1, [sp, #0x8]
700a374c: 4008         	ands	r0, r1
700a374e: 4288         	cmp	r0, r1
700a3750: d110         	bne	0x700a3774 <Udma_rmAllocBlkCopyCh+0x94> @ imm = #0x20
700a3752: e7ff         	b	0x700a3754 <Udma_rmAllocBlkCopyCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyChFlag[offset] &= ~bitMask;
700a3754: 9a02         	ldr	r2, [sp, #0x8]
700a3756: 9806         	ldr	r0, [sp, #0x18]
700a3758: 9904         	ldr	r1, [sp, #0x10]
700a375a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a375e: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a3762: 4390         	bics	r0, r2
700a3764: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;                 chNum = i + rmInitPrms->startBlkCopyCh;  /* Add start offset */
700a3768: 9805         	ldr	r0, [sp, #0x14]
700a376a: 9900         	ldr	r1, [sp]
700a376c: 6909         	ldr	r1, [r1, #0x10]
700a376e: 4408         	add	r0, r1
700a3770: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3772: e004         	b	0x700a377e <Udma_rmAllocBlkCopyCh+0x9e> @ imm = #0x8
;         }
700a3774: e7ff         	b	0x700a3776 <Udma_rmAllocBlkCopyCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyCh; i++)
700a3776: 9805         	ldr	r0, [sp, #0x14]
700a3778: 3001         	adds	r0, #0x1
700a377a: 9005         	str	r0, [sp, #0x14]
700a377c: e7cd         	b	0x700a371a <Udma_rmAllocBlkCopyCh+0x3a> @ imm = #-0x66
;     }
700a377e: e038         	b	0x700a37f2 <Udma_rmAllocBlkCopyCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyCh) &&
700a3780: 9807         	ldr	r0, [sp, #0x1c]
700a3782: 9900         	ldr	r1, [sp]
700a3784: 6909         	ldr	r1, [r1, #0x10]
700a3786: 4288         	cmp	r0, r1
700a3788: d332         	blo	0x700a37f0 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #0x64
700a378a: e7ff         	b	0x700a378c <Udma_rmAllocBlkCopyCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyCh + rmInitPrms->numBlkCopyCh)))
700a378c: 9807         	ldr	r0, [sp, #0x1c]
700a378e: 9a00         	ldr	r2, [sp]
700a3790: 6911         	ldr	r1, [r2, #0x10]
700a3792: 6952         	ldr	r2, [r2, #0x14]
700a3794: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyCh) &&
700a3796: 4288         	cmp	r0, r1
700a3798: d22a         	bhs	0x700a37f0 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #0x54
700a379a: e7ff         	b	0x700a379c <Udma_rmAllocBlkCopyCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyCh;
700a379c: 9807         	ldr	r0, [sp, #0x1c]
700a379e: 9900         	ldr	r1, [sp]
700a37a0: 6909         	ldr	r1, [r1, #0x10]
700a37a2: 1a40         	subs	r0, r0, r1
700a37a4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a37a6: 9805         	ldr	r0, [sp, #0x14]
700a37a8: 0940         	lsrs	r0, r0, #0x5
700a37aa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a37ac: 9805         	ldr	r0, [sp, #0x14]
700a37ae: 9904         	ldr	r1, [sp, #0x10]
700a37b0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a37b4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a37b6: 9903         	ldr	r1, [sp, #0xc]
700a37b8: 2001         	movs	r0, #0x1
700a37ba: 4088         	lsls	r0, r1
700a37bc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyChFlag[offset] & bitMask) == bitMask)
700a37be: 9806         	ldr	r0, [sp, #0x18]
700a37c0: 9904         	ldr	r1, [sp, #0x10]
700a37c2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a37c6: f8d0 02c8    	ldr.w	r0, [r0, #0x2c8]
700a37ca: 9902         	ldr	r1, [sp, #0x8]
700a37cc: 4008         	ands	r0, r1
700a37ce: 4288         	cmp	r0, r1
700a37d0: d10d         	bne	0x700a37ee <Udma_rmAllocBlkCopyCh+0x10e> @ imm = #0x1a
700a37d2: e7ff         	b	0x700a37d4 <Udma_rmAllocBlkCopyCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyChFlag[offset] &= ~bitMask;
700a37d4: 9a02         	ldr	r2, [sp, #0x8]
700a37d6: 9806         	ldr	r0, [sp, #0x18]
700a37d8: 9904         	ldr	r1, [sp, #0x10]
700a37da: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a37de: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a37e2: 4390         	bics	r0, r2
700a37e4: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;                 chNum = preferredChNum;
700a37e8: 9807         	ldr	r0, [sp, #0x1c]
700a37ea: 9001         	str	r0, [sp, #0x4]
;             }
700a37ec: e7ff         	b	0x700a37ee <Udma_rmAllocBlkCopyCh+0x10e> @ imm = #-0x2
;         }
700a37ee: e7ff         	b	0x700a37f0 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #-0x2
700a37f0: e7ff         	b	0x700a37f2 <Udma_rmAllocBlkCopyCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a37f2: 9806         	ldr	r0, [sp, #0x18]
700a37f4: f500 609f    	add.w	r0, r0, #0x4f8
700a37f8: f008 fa52    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x84a4
;     return (chNum);
700a37fc: 9801         	ldr	r0, [sp, #0x4]
700a37fe: b008         	add	sp, #0x20
700a3800: bd80         	pop	{r7, pc}
		...
700a380e: 0000         	movs	r0, r0

700a3810 <Udma_rmAllocBlkCopyHcCh>:
; {
700a3810: b580         	push	{r7, lr}
700a3812: b088         	sub	sp, #0x20
700a3814: 9007         	str	r0, [sp, #0x1c]
700a3816: 9106         	str	r1, [sp, #0x18]
700a3818: 2000         	movs	r0, #0x0
700a381a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a381e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3820: 9806         	ldr	r0, [sp, #0x18]
700a3822: f500 70ea    	add.w	r0, r0, #0x1d4
700a3826: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3828: 9806         	ldr	r0, [sp, #0x18]
700a382a: f500 609f    	add.w	r0, r0, #0x4f8
700a382e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3832: f006 fea5    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x6d4a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3836: 9807         	ldr	r0, [sp, #0x1c]
700a3838: 2101         	movs	r1, #0x1
700a383a: f6cf 71ff    	movt	r1, #0xffff
700a383e: 4288         	cmp	r0, r1
700a3840: d136         	bne	0x700a38b0 <Udma_rmAllocBlkCopyHcCh+0xa0> @ imm = #0x6c
700a3842: e7ff         	b	0x700a3844 <Udma_rmAllocBlkCopyHcCh+0x34> @ imm = #-0x2
700a3844: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyHcCh; i++)
700a3846: 9005         	str	r0, [sp, #0x14]
700a3848: e7ff         	b	0x700a384a <Udma_rmAllocBlkCopyHcCh+0x3a> @ imm = #-0x2
700a384a: 9805         	ldr	r0, [sp, #0x14]
700a384c: 9900         	ldr	r1, [sp]
700a384e: 68c9         	ldr	r1, [r1, #0xc]
700a3850: 4288         	cmp	r0, r1
700a3852: d22c         	bhs	0x700a38ae <Udma_rmAllocBlkCopyHcCh+0x9e> @ imm = #0x58
700a3854: e7ff         	b	0x700a3856 <Udma_rmAllocBlkCopyHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3856: 9805         	ldr	r0, [sp, #0x14]
700a3858: 0940         	lsrs	r0, r0, #0x5
700a385a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a385c: 9805         	ldr	r0, [sp, #0x14]
700a385e: 9904         	ldr	r1, [sp, #0x10]
700a3860: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3864: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3866: 9903         	ldr	r1, [sp, #0xc]
700a3868: 2001         	movs	r0, #0x1
700a386a: 4088         	lsls	r0, r1
700a386c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyHcChFlag[offset] & bitMask) == bitMask)
700a386e: 9806         	ldr	r0, [sp, #0x18]
700a3870: 9904         	ldr	r1, [sp, #0x10]
700a3872: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3876: f8d0 02cc    	ldr.w	r0, [r0, #0x2cc]
700a387a: 9902         	ldr	r1, [sp, #0x8]
700a387c: 4008         	ands	r0, r1
700a387e: 4288         	cmp	r0, r1
700a3880: d110         	bne	0x700a38a4 <Udma_rmAllocBlkCopyHcCh+0x94> @ imm = #0x20
700a3882: e7ff         	b	0x700a3884 <Udma_rmAllocBlkCopyHcCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyHcChFlag[offset] &= ~bitMask;
700a3884: 9a02         	ldr	r2, [sp, #0x8]
700a3886: 9806         	ldr	r0, [sp, #0x18]
700a3888: 9904         	ldr	r1, [sp, #0x10]
700a388a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a388e: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a3892: 4390         	bics	r0, r2
700a3894: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;                 chNum = i + rmInitPrms->startBlkCopyHcCh;  /* Add start offset */
700a3898: 9805         	ldr	r0, [sp, #0x14]
700a389a: 9900         	ldr	r1, [sp]
700a389c: 6889         	ldr	r1, [r1, #0x8]
700a389e: 4408         	add	r0, r1
700a38a0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a38a2: e004         	b	0x700a38ae <Udma_rmAllocBlkCopyHcCh+0x9e> @ imm = #0x8
;         }
700a38a4: e7ff         	b	0x700a38a6 <Udma_rmAllocBlkCopyHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyHcCh; i++)
700a38a6: 9805         	ldr	r0, [sp, #0x14]
700a38a8: 3001         	adds	r0, #0x1
700a38aa: 9005         	str	r0, [sp, #0x14]
700a38ac: e7cd         	b	0x700a384a <Udma_rmAllocBlkCopyHcCh+0x3a> @ imm = #-0x66
;     }
700a38ae: e038         	b	0x700a3922 <Udma_rmAllocBlkCopyHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyHcCh) &&
700a38b0: 9807         	ldr	r0, [sp, #0x1c]
700a38b2: 9900         	ldr	r1, [sp]
700a38b4: 6889         	ldr	r1, [r1, #0x8]
700a38b6: 4288         	cmp	r0, r1
700a38b8: d332         	blo	0x700a3920 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #0x64
700a38ba: e7ff         	b	0x700a38bc <Udma_rmAllocBlkCopyHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyHcCh + rmInitPrms->numBlkCopyHcCh)))
700a38bc: 9807         	ldr	r0, [sp, #0x1c]
700a38be: 9a00         	ldr	r2, [sp]
700a38c0: 6891         	ldr	r1, [r2, #0x8]
700a38c2: 68d2         	ldr	r2, [r2, #0xc]
700a38c4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyHcCh) &&
700a38c6: 4288         	cmp	r0, r1
700a38c8: d22a         	bhs	0x700a3920 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #0x54
700a38ca: e7ff         	b	0x700a38cc <Udma_rmAllocBlkCopyHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyHcCh;
700a38cc: 9807         	ldr	r0, [sp, #0x1c]
700a38ce: 9900         	ldr	r1, [sp]
700a38d0: 6889         	ldr	r1, [r1, #0x8]
700a38d2: 1a40         	subs	r0, r0, r1
700a38d4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a38d6: 9805         	ldr	r0, [sp, #0x14]
700a38d8: 0940         	lsrs	r0, r0, #0x5
700a38da: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a38dc: 9805         	ldr	r0, [sp, #0x14]
700a38de: 9904         	ldr	r1, [sp, #0x10]
700a38e0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a38e4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a38e6: 9903         	ldr	r1, [sp, #0xc]
700a38e8: 2001         	movs	r0, #0x1
700a38ea: 4088         	lsls	r0, r1
700a38ec: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyHcChFlag[offset] & bitMask) == bitMask)
700a38ee: 9806         	ldr	r0, [sp, #0x18]
700a38f0: 9904         	ldr	r1, [sp, #0x10]
700a38f2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a38f6: f8d0 02cc    	ldr.w	r0, [r0, #0x2cc]
700a38fa: 9902         	ldr	r1, [sp, #0x8]
700a38fc: 4008         	ands	r0, r1
700a38fe: 4288         	cmp	r0, r1
700a3900: d10d         	bne	0x700a391e <Udma_rmAllocBlkCopyHcCh+0x10e> @ imm = #0x1a
700a3902: e7ff         	b	0x700a3904 <Udma_rmAllocBlkCopyHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyHcChFlag[offset] &= ~bitMask;
700a3904: 9a02         	ldr	r2, [sp, #0x8]
700a3906: 9806         	ldr	r0, [sp, #0x18]
700a3908: 9904         	ldr	r1, [sp, #0x10]
700a390a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a390e: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a3912: 4390         	bics	r0, r2
700a3914: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;                 chNum = preferredChNum;
700a3918: 9807         	ldr	r0, [sp, #0x1c]
700a391a: 9001         	str	r0, [sp, #0x4]
;             }
700a391c: e7ff         	b	0x700a391e <Udma_rmAllocBlkCopyHcCh+0x10e> @ imm = #-0x2
;         }
700a391e: e7ff         	b	0x700a3920 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #-0x2
700a3920: e7ff         	b	0x700a3922 <Udma_rmAllocBlkCopyHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3922: 9806         	ldr	r0, [sp, #0x18]
700a3924: f500 609f    	add.w	r0, r0, #0x4f8
700a3928: f008 f9ba    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x8374
;     return (chNum);
700a392c: 9801         	ldr	r0, [sp, #0x4]
700a392e: b008         	add	sp, #0x20
700a3930: bd80         	pop	{r7, pc}
		...
700a393e: 0000         	movs	r0, r0

700a3940 <Udma_rmAllocBlkCopyUhcCh>:
; {
700a3940: b580         	push	{r7, lr}
700a3942: b088         	sub	sp, #0x20
700a3944: 9007         	str	r0, [sp, #0x1c]
700a3946: 9106         	str	r1, [sp, #0x18]
700a3948: 2000         	movs	r0, #0x0
700a394a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a394e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3950: 9806         	ldr	r0, [sp, #0x18]
700a3952: f500 70ea    	add.w	r0, r0, #0x1d4
700a3956: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3958: 9806         	ldr	r0, [sp, #0x18]
700a395a: f500 609f    	add.w	r0, r0, #0x4f8
700a395e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3962: f006 fe0d    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x6c1a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3966: 9807         	ldr	r0, [sp, #0x1c]
700a3968: 2101         	movs	r1, #0x1
700a396a: f6cf 71ff    	movt	r1, #0xffff
700a396e: 4288         	cmp	r0, r1
700a3970: d136         	bne	0x700a39e0 <Udma_rmAllocBlkCopyUhcCh+0xa0> @ imm = #0x6c
700a3972: e7ff         	b	0x700a3974 <Udma_rmAllocBlkCopyUhcCh+0x34> @ imm = #-0x2
700a3974: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyUhcCh; i++)
700a3976: 9005         	str	r0, [sp, #0x14]
700a3978: e7ff         	b	0x700a397a <Udma_rmAllocBlkCopyUhcCh+0x3a> @ imm = #-0x2
700a397a: 9805         	ldr	r0, [sp, #0x14]
700a397c: 9900         	ldr	r1, [sp]
700a397e: 6849         	ldr	r1, [r1, #0x4]
700a3980: 4288         	cmp	r0, r1
700a3982: d22c         	bhs	0x700a39de <Udma_rmAllocBlkCopyUhcCh+0x9e> @ imm = #0x58
700a3984: e7ff         	b	0x700a3986 <Udma_rmAllocBlkCopyUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3986: 9805         	ldr	r0, [sp, #0x14]
700a3988: 0940         	lsrs	r0, r0, #0x5
700a398a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a398c: 9805         	ldr	r0, [sp, #0x14]
700a398e: 9904         	ldr	r1, [sp, #0x10]
700a3990: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3994: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3996: 9903         	ldr	r1, [sp, #0xc]
700a3998: 2001         	movs	r0, #0x1
700a399a: 4088         	lsls	r0, r1
700a399c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyUhcChFlag[offset] & bitMask) == bitMask)
700a399e: 9806         	ldr	r0, [sp, #0x18]
700a39a0: 9904         	ldr	r1, [sp, #0x10]
700a39a2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a39a6: f8d0 02d0    	ldr.w	r0, [r0, #0x2d0]
700a39aa: 9902         	ldr	r1, [sp, #0x8]
700a39ac: 4008         	ands	r0, r1
700a39ae: 4288         	cmp	r0, r1
700a39b0: d110         	bne	0x700a39d4 <Udma_rmAllocBlkCopyUhcCh+0x94> @ imm = #0x20
700a39b2: e7ff         	b	0x700a39b4 <Udma_rmAllocBlkCopyUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyUhcChFlag[offset] &= ~bitMask;
700a39b4: 9a02         	ldr	r2, [sp, #0x8]
700a39b6: 9806         	ldr	r0, [sp, #0x18]
700a39b8: 9904         	ldr	r1, [sp, #0x10]
700a39ba: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a39be: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a39c2: 4390         	bics	r0, r2
700a39c4: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;                 chNum = i + rmInitPrms->startBlkCopyUhcCh;  /* Add start offset */
700a39c8: 9805         	ldr	r0, [sp, #0x14]
700a39ca: 9900         	ldr	r1, [sp]
700a39cc: 6809         	ldr	r1, [r1]
700a39ce: 4408         	add	r0, r1
700a39d0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a39d2: e004         	b	0x700a39de <Udma_rmAllocBlkCopyUhcCh+0x9e> @ imm = #0x8
;         }
700a39d4: e7ff         	b	0x700a39d6 <Udma_rmAllocBlkCopyUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyUhcCh; i++)
700a39d6: 9805         	ldr	r0, [sp, #0x14]
700a39d8: 3001         	adds	r0, #0x1
700a39da: 9005         	str	r0, [sp, #0x14]
700a39dc: e7cd         	b	0x700a397a <Udma_rmAllocBlkCopyUhcCh+0x3a> @ imm = #-0x66
;     }
700a39de: e038         	b	0x700a3a52 <Udma_rmAllocBlkCopyUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyUhcCh) &&
700a39e0: 9807         	ldr	r0, [sp, #0x1c]
700a39e2: 9900         	ldr	r1, [sp]
700a39e4: 6809         	ldr	r1, [r1]
700a39e6: 4288         	cmp	r0, r1
700a39e8: d332         	blo	0x700a3a50 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #0x64
700a39ea: e7ff         	b	0x700a39ec <Udma_rmAllocBlkCopyUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyUhcCh + rmInitPrms->numBlkCopyUhcCh)))
700a39ec: 9807         	ldr	r0, [sp, #0x1c]
700a39ee: 9a00         	ldr	r2, [sp]
700a39f0: 6811         	ldr	r1, [r2]
700a39f2: 6852         	ldr	r2, [r2, #0x4]
700a39f4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyUhcCh) &&
700a39f6: 4288         	cmp	r0, r1
700a39f8: d22a         	bhs	0x700a3a50 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #0x54
700a39fa: e7ff         	b	0x700a39fc <Udma_rmAllocBlkCopyUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyUhcCh;
700a39fc: 9807         	ldr	r0, [sp, #0x1c]
700a39fe: 9900         	ldr	r1, [sp]
700a3a00: 6809         	ldr	r1, [r1]
700a3a02: 1a40         	subs	r0, r0, r1
700a3a04: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3a06: 9805         	ldr	r0, [sp, #0x14]
700a3a08: 0940         	lsrs	r0, r0, #0x5
700a3a0a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3a0c: 9805         	ldr	r0, [sp, #0x14]
700a3a0e: 9904         	ldr	r1, [sp, #0x10]
700a3a10: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3a14: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3a16: 9903         	ldr	r1, [sp, #0xc]
700a3a18: 2001         	movs	r0, #0x1
700a3a1a: 4088         	lsls	r0, r1
700a3a1c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyUhcChFlag[offset] & bitMask) == bitMask)
700a3a1e: 9806         	ldr	r0, [sp, #0x18]
700a3a20: 9904         	ldr	r1, [sp, #0x10]
700a3a22: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3a26: f8d0 02d0    	ldr.w	r0, [r0, #0x2d0]
700a3a2a: 9902         	ldr	r1, [sp, #0x8]
700a3a2c: 4008         	ands	r0, r1
700a3a2e: 4288         	cmp	r0, r1
700a3a30: d10d         	bne	0x700a3a4e <Udma_rmAllocBlkCopyUhcCh+0x10e> @ imm = #0x1a
700a3a32: e7ff         	b	0x700a3a34 <Udma_rmAllocBlkCopyUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyUhcChFlag[offset] &= ~bitMask;
700a3a34: 9a02         	ldr	r2, [sp, #0x8]
700a3a36: 9806         	ldr	r0, [sp, #0x18]
700a3a38: 9904         	ldr	r1, [sp, #0x10]
700a3a3a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3a3e: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a3a42: 4390         	bics	r0, r2
700a3a44: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;                 chNum = preferredChNum;
700a3a48: 9807         	ldr	r0, [sp, #0x1c]
700a3a4a: 9001         	str	r0, [sp, #0x4]
;             }
700a3a4c: e7ff         	b	0x700a3a4e <Udma_rmAllocBlkCopyUhcCh+0x10e> @ imm = #-0x2
;         }
700a3a4e: e7ff         	b	0x700a3a50 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #-0x2
700a3a50: e7ff         	b	0x700a3a52 <Udma_rmAllocBlkCopyUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3a52: 9806         	ldr	r0, [sp, #0x18]
700a3a54: f500 609f    	add.w	r0, r0, #0x4f8
700a3a58: f008 f922    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x8244
;     return (chNum);
700a3a5c: 9801         	ldr	r0, [sp, #0x4]
700a3a5e: b008         	add	sp, #0x20
700a3a60: bd80         	pop	{r7, pc}
		...
700a3a6e: 0000         	movs	r0, r0

700a3a70 <Udma_rmAllocRxCh>:
; {
700a3a70: b580         	push	{r7, lr}
700a3a72: b088         	sub	sp, #0x20
700a3a74: 9007         	str	r0, [sp, #0x1c]
700a3a76: 9106         	str	r1, [sp, #0x18]
700a3a78: 2000         	movs	r0, #0x0
700a3a7a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3a7e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3a80: 9806         	ldr	r0, [sp, #0x18]
700a3a82: f500 70ea    	add.w	r0, r0, #0x1d4
700a3a86: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3a88: 9806         	ldr	r0, [sp, #0x18]
700a3a8a: f500 609f    	add.w	r0, r0, #0x4f8
700a3a8e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3a92: f006 fd75    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x6aea
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3a96: 9807         	ldr	r0, [sp, #0x1c]
700a3a98: 2101         	movs	r1, #0x1
700a3a9a: f6cf 71ff    	movt	r1, #0xffff
700a3a9e: 4288         	cmp	r0, r1
700a3aa0: d136         	bne	0x700a3b10 <Udma_rmAllocRxCh+0xa0> @ imm = #0x6c
700a3aa2: e7ff         	b	0x700a3aa4 <Udma_rmAllocRxCh+0x34> @ imm = #-0x2
700a3aa4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxCh; i++)
700a3aa6: 9005         	str	r0, [sp, #0x14]
700a3aa8: e7ff         	b	0x700a3aaa <Udma_rmAllocRxCh+0x3a> @ imm = #-0x2
700a3aaa: 9805         	ldr	r0, [sp, #0x14]
700a3aac: 9900         	ldr	r1, [sp]
700a3aae: 6c49         	ldr	r1, [r1, #0x44]
700a3ab0: 4288         	cmp	r0, r1
700a3ab2: d22c         	bhs	0x700a3b0e <Udma_rmAllocRxCh+0x9e> @ imm = #0x58
700a3ab4: e7ff         	b	0x700a3ab6 <Udma_rmAllocRxCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3ab6: 9805         	ldr	r0, [sp, #0x14]
700a3ab8: 0940         	lsrs	r0, r0, #0x5
700a3aba: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3abc: 9805         	ldr	r0, [sp, #0x14]
700a3abe: 9904         	ldr	r1, [sp, #0x10]
700a3ac0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3ac4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3ac6: 9903         	ldr	r1, [sp, #0xc]
700a3ac8: 2001         	movs	r0, #0x1
700a3aca: 4088         	lsls	r0, r1
700a3acc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxChFlag[offset] & bitMask) == bitMask)
700a3ace: 9806         	ldr	r0, [sp, #0x18]
700a3ad0: 9904         	ldr	r1, [sp, #0x10]
700a3ad2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3ad6: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
700a3ada: 9902         	ldr	r1, [sp, #0x8]
700a3adc: 4008         	ands	r0, r1
700a3ade: 4288         	cmp	r0, r1
700a3ae0: d110         	bne	0x700a3b04 <Udma_rmAllocRxCh+0x94> @ imm = #0x20
700a3ae2: e7ff         	b	0x700a3ae4 <Udma_rmAllocRxCh+0x74> @ imm = #-0x2
;                 drvHandle->rxChFlag[offset] &= ~bitMask;
700a3ae4: 9a02         	ldr	r2, [sp, #0x8]
700a3ae6: 9806         	ldr	r0, [sp, #0x18]
700a3ae8: 9904         	ldr	r1, [sp, #0x10]
700a3aea: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3aee: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700a3af2: 4390         	bics	r0, r2
700a3af4: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;                 chNum = i + rmInitPrms->startRxCh;  /* Add start offset */
700a3af8: 9805         	ldr	r0, [sp, #0x14]
700a3afa: 9900         	ldr	r1, [sp]
700a3afc: 6c09         	ldr	r1, [r1, #0x40]
700a3afe: 4408         	add	r0, r1
700a3b00: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3b02: e004         	b	0x700a3b0e <Udma_rmAllocRxCh+0x9e> @ imm = #0x8
;         }
700a3b04: e7ff         	b	0x700a3b06 <Udma_rmAllocRxCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxCh; i++)
700a3b06: 9805         	ldr	r0, [sp, #0x14]
700a3b08: 3001         	adds	r0, #0x1
700a3b0a: 9005         	str	r0, [sp, #0x14]
700a3b0c: e7cd         	b	0x700a3aaa <Udma_rmAllocRxCh+0x3a> @ imm = #-0x66
;     }
700a3b0e: e038         	b	0x700a3b82 <Udma_rmAllocRxCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxCh) &&
700a3b10: 9807         	ldr	r0, [sp, #0x1c]
700a3b12: 9900         	ldr	r1, [sp]
700a3b14: 6c09         	ldr	r1, [r1, #0x40]
700a3b16: 4288         	cmp	r0, r1
700a3b18: d332         	blo	0x700a3b80 <Udma_rmAllocRxCh+0x110> @ imm = #0x64
700a3b1a: e7ff         	b	0x700a3b1c <Udma_rmAllocRxCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxCh + rmInitPrms->numRxCh)))
700a3b1c: 9807         	ldr	r0, [sp, #0x1c]
700a3b1e: 9a00         	ldr	r2, [sp]
700a3b20: 6c11         	ldr	r1, [r2, #0x40]
700a3b22: 6c52         	ldr	r2, [r2, #0x44]
700a3b24: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxCh) &&
700a3b26: 4288         	cmp	r0, r1
700a3b28: d22a         	bhs	0x700a3b80 <Udma_rmAllocRxCh+0x110> @ imm = #0x54
700a3b2a: e7ff         	b	0x700a3b2c <Udma_rmAllocRxCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxCh;
700a3b2c: 9807         	ldr	r0, [sp, #0x1c]
700a3b2e: 9900         	ldr	r1, [sp]
700a3b30: 6c09         	ldr	r1, [r1, #0x40]
700a3b32: 1a40         	subs	r0, r0, r1
700a3b34: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3b36: 9805         	ldr	r0, [sp, #0x14]
700a3b38: 0940         	lsrs	r0, r0, #0x5
700a3b3a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3b3c: 9805         	ldr	r0, [sp, #0x14]
700a3b3e: 9904         	ldr	r1, [sp, #0x10]
700a3b40: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3b44: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3b46: 9903         	ldr	r1, [sp, #0xc]
700a3b48: 2001         	movs	r0, #0x1
700a3b4a: 4088         	lsls	r0, r1
700a3b4c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxChFlag[offset] & bitMask) == bitMask)
700a3b4e: 9806         	ldr	r0, [sp, #0x18]
700a3b50: 9904         	ldr	r1, [sp, #0x10]
700a3b52: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3b56: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
700a3b5a: 9902         	ldr	r1, [sp, #0x8]
700a3b5c: 4008         	ands	r0, r1
700a3b5e: 4288         	cmp	r0, r1
700a3b60: d10d         	bne	0x700a3b7e <Udma_rmAllocRxCh+0x10e> @ imm = #0x1a
700a3b62: e7ff         	b	0x700a3b64 <Udma_rmAllocRxCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxChFlag[offset] &= ~bitMask;
700a3b64: 9a02         	ldr	r2, [sp, #0x8]
700a3b66: 9806         	ldr	r0, [sp, #0x18]
700a3b68: 9904         	ldr	r1, [sp, #0x10]
700a3b6a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3b6e: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700a3b72: 4390         	bics	r0, r2
700a3b74: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;                 chNum = preferredChNum;
700a3b78: 9807         	ldr	r0, [sp, #0x1c]
700a3b7a: 9001         	str	r0, [sp, #0x4]
;             }
700a3b7c: e7ff         	b	0x700a3b7e <Udma_rmAllocRxCh+0x10e> @ imm = #-0x2
;         }
700a3b7e: e7ff         	b	0x700a3b80 <Udma_rmAllocRxCh+0x110> @ imm = #-0x2
700a3b80: e7ff         	b	0x700a3b82 <Udma_rmAllocRxCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3b82: 9806         	ldr	r0, [sp, #0x18]
700a3b84: f500 609f    	add.w	r0, r0, #0x4f8
700a3b88: f008 f88a    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x8114
;     return (chNum);
700a3b8c: 9801         	ldr	r0, [sp, #0x4]
700a3b8e: b008         	add	sp, #0x20
700a3b90: bd80         	pop	{r7, pc}
		...
700a3b9e: 0000         	movs	r0, r0

700a3ba0 <Udma_rmAllocRxHcCh>:
; {
700a3ba0: b580         	push	{r7, lr}
700a3ba2: b088         	sub	sp, #0x20
700a3ba4: 9007         	str	r0, [sp, #0x1c]
700a3ba6: 9106         	str	r1, [sp, #0x18]
700a3ba8: 2000         	movs	r0, #0x0
700a3baa: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3bae: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3bb0: 9806         	ldr	r0, [sp, #0x18]
700a3bb2: f500 70ea    	add.w	r0, r0, #0x1d4
700a3bb6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3bb8: 9806         	ldr	r0, [sp, #0x18]
700a3bba: f500 609f    	add.w	r0, r0, #0x4f8
700a3bbe: f04f 31ff    	mov.w	r1, #0xffffffff
700a3bc2: f006 fcdd    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x69ba
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3bc6: 9807         	ldr	r0, [sp, #0x1c]
700a3bc8: 2101         	movs	r1, #0x1
700a3bca: f6cf 71ff    	movt	r1, #0xffff
700a3bce: 4288         	cmp	r0, r1
700a3bd0: d136         	bne	0x700a3c40 <Udma_rmAllocRxHcCh+0xa0> @ imm = #0x6c
700a3bd2: e7ff         	b	0x700a3bd4 <Udma_rmAllocRxHcCh+0x34> @ imm = #-0x2
700a3bd4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxHcCh; i++)
700a3bd6: 9005         	str	r0, [sp, #0x14]
700a3bd8: e7ff         	b	0x700a3bda <Udma_rmAllocRxHcCh+0x3a> @ imm = #-0x2
700a3bda: 9805         	ldr	r0, [sp, #0x14]
700a3bdc: 9900         	ldr	r1, [sp]
700a3bde: 6bc9         	ldr	r1, [r1, #0x3c]
700a3be0: 4288         	cmp	r0, r1
700a3be2: d22c         	bhs	0x700a3c3e <Udma_rmAllocRxHcCh+0x9e> @ imm = #0x58
700a3be4: e7ff         	b	0x700a3be6 <Udma_rmAllocRxHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3be6: 9805         	ldr	r0, [sp, #0x14]
700a3be8: 0940         	lsrs	r0, r0, #0x5
700a3bea: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3bec: 9805         	ldr	r0, [sp, #0x14]
700a3bee: 9904         	ldr	r1, [sp, #0x10]
700a3bf0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3bf4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3bf6: 9903         	ldr	r1, [sp, #0xc]
700a3bf8: 2001         	movs	r0, #0x1
700a3bfa: 4088         	lsls	r0, r1
700a3bfc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxHcChFlag[offset] & bitMask) == bitMask)
700a3bfe: 9806         	ldr	r0, [sp, #0x18]
700a3c00: 9904         	ldr	r1, [sp, #0x10]
700a3c02: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3c06: f8d0 031c    	ldr.w	r0, [r0, #0x31c]
700a3c0a: 9902         	ldr	r1, [sp, #0x8]
700a3c0c: 4008         	ands	r0, r1
700a3c0e: 4288         	cmp	r0, r1
700a3c10: d110         	bne	0x700a3c34 <Udma_rmAllocRxHcCh+0x94> @ imm = #0x20
700a3c12: e7ff         	b	0x700a3c14 <Udma_rmAllocRxHcCh+0x74> @ imm = #-0x2
;                 drvHandle->rxHcChFlag[offset] &= ~bitMask;
700a3c14: 9a02         	ldr	r2, [sp, #0x8]
700a3c16: 9806         	ldr	r0, [sp, #0x18]
700a3c18: 9904         	ldr	r1, [sp, #0x10]
700a3c1a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3c1e: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700a3c22: 4390         	bics	r0, r2
700a3c24: f8c1 031c    	str.w	r0, [r1, #0x31c]
;                 chNum = i + rmInitPrms->startRxHcCh;  /* Add start offset */
700a3c28: 9805         	ldr	r0, [sp, #0x14]
700a3c2a: 9900         	ldr	r1, [sp]
700a3c2c: 6b89         	ldr	r1, [r1, #0x38]
700a3c2e: 4408         	add	r0, r1
700a3c30: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3c32: e004         	b	0x700a3c3e <Udma_rmAllocRxHcCh+0x9e> @ imm = #0x8
;         }
700a3c34: e7ff         	b	0x700a3c36 <Udma_rmAllocRxHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxHcCh; i++)
700a3c36: 9805         	ldr	r0, [sp, #0x14]
700a3c38: 3001         	adds	r0, #0x1
700a3c3a: 9005         	str	r0, [sp, #0x14]
700a3c3c: e7cd         	b	0x700a3bda <Udma_rmAllocRxHcCh+0x3a> @ imm = #-0x66
;     }
700a3c3e: e038         	b	0x700a3cb2 <Udma_rmAllocRxHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxHcCh) &&
700a3c40: 9807         	ldr	r0, [sp, #0x1c]
700a3c42: 9900         	ldr	r1, [sp]
700a3c44: 6b89         	ldr	r1, [r1, #0x38]
700a3c46: 4288         	cmp	r0, r1
700a3c48: d332         	blo	0x700a3cb0 <Udma_rmAllocRxHcCh+0x110> @ imm = #0x64
700a3c4a: e7ff         	b	0x700a3c4c <Udma_rmAllocRxHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxHcCh + rmInitPrms->numRxHcCh)))
700a3c4c: 9807         	ldr	r0, [sp, #0x1c]
700a3c4e: 9a00         	ldr	r2, [sp]
700a3c50: 6b91         	ldr	r1, [r2, #0x38]
700a3c52: 6bd2         	ldr	r2, [r2, #0x3c]
700a3c54: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxHcCh) &&
700a3c56: 4288         	cmp	r0, r1
700a3c58: d22a         	bhs	0x700a3cb0 <Udma_rmAllocRxHcCh+0x110> @ imm = #0x54
700a3c5a: e7ff         	b	0x700a3c5c <Udma_rmAllocRxHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxHcCh;
700a3c5c: 9807         	ldr	r0, [sp, #0x1c]
700a3c5e: 9900         	ldr	r1, [sp]
700a3c60: 6b89         	ldr	r1, [r1, #0x38]
700a3c62: 1a40         	subs	r0, r0, r1
700a3c64: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3c66: 9805         	ldr	r0, [sp, #0x14]
700a3c68: 0940         	lsrs	r0, r0, #0x5
700a3c6a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3c6c: 9805         	ldr	r0, [sp, #0x14]
700a3c6e: 9904         	ldr	r1, [sp, #0x10]
700a3c70: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3c74: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3c76: 9903         	ldr	r1, [sp, #0xc]
700a3c78: 2001         	movs	r0, #0x1
700a3c7a: 4088         	lsls	r0, r1
700a3c7c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxHcChFlag[offset] & bitMask) == bitMask)
700a3c7e: 9806         	ldr	r0, [sp, #0x18]
700a3c80: 9904         	ldr	r1, [sp, #0x10]
700a3c82: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3c86: f8d0 031c    	ldr.w	r0, [r0, #0x31c]
700a3c8a: 9902         	ldr	r1, [sp, #0x8]
700a3c8c: 4008         	ands	r0, r1
700a3c8e: 4288         	cmp	r0, r1
700a3c90: d10d         	bne	0x700a3cae <Udma_rmAllocRxHcCh+0x10e> @ imm = #0x1a
700a3c92: e7ff         	b	0x700a3c94 <Udma_rmAllocRxHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxHcChFlag[offset] &= ~bitMask;
700a3c94: 9a02         	ldr	r2, [sp, #0x8]
700a3c96: 9806         	ldr	r0, [sp, #0x18]
700a3c98: 9904         	ldr	r1, [sp, #0x10]
700a3c9a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3c9e: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700a3ca2: 4390         	bics	r0, r2
700a3ca4: f8c1 031c    	str.w	r0, [r1, #0x31c]
;                 chNum = preferredChNum;
700a3ca8: 9807         	ldr	r0, [sp, #0x1c]
700a3caa: 9001         	str	r0, [sp, #0x4]
;             }
700a3cac: e7ff         	b	0x700a3cae <Udma_rmAllocRxHcCh+0x10e> @ imm = #-0x2
;         }
700a3cae: e7ff         	b	0x700a3cb0 <Udma_rmAllocRxHcCh+0x110> @ imm = #-0x2
700a3cb0: e7ff         	b	0x700a3cb2 <Udma_rmAllocRxHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3cb2: 9806         	ldr	r0, [sp, #0x18]
700a3cb4: f500 609f    	add.w	r0, r0, #0x4f8
700a3cb8: f007 fff2    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x7fe4
;     return (chNum);
700a3cbc: 9801         	ldr	r0, [sp, #0x4]
700a3cbe: b008         	add	sp, #0x20
700a3cc0: bd80         	pop	{r7, pc}
		...
700a3cce: 0000         	movs	r0, r0

700a3cd0 <Udma_rmAllocRxUhcCh>:
; {
700a3cd0: b580         	push	{r7, lr}
700a3cd2: b088         	sub	sp, #0x20
700a3cd4: 9007         	str	r0, [sp, #0x1c]
700a3cd6: 9106         	str	r1, [sp, #0x18]
700a3cd8: 2000         	movs	r0, #0x0
700a3cda: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3cde: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3ce0: 9806         	ldr	r0, [sp, #0x18]
700a3ce2: f500 70ea    	add.w	r0, r0, #0x1d4
700a3ce6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3ce8: 9806         	ldr	r0, [sp, #0x18]
700a3cea: f500 609f    	add.w	r0, r0, #0x4f8
700a3cee: f04f 31ff    	mov.w	r1, #0xffffffff
700a3cf2: f006 fc45    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x688a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3cf6: 9807         	ldr	r0, [sp, #0x1c]
700a3cf8: 2101         	movs	r1, #0x1
700a3cfa: f6cf 71ff    	movt	r1, #0xffff
700a3cfe: 4288         	cmp	r0, r1
700a3d00: d136         	bne	0x700a3d70 <Udma_rmAllocRxUhcCh+0xa0> @ imm = #0x6c
700a3d02: e7ff         	b	0x700a3d04 <Udma_rmAllocRxUhcCh+0x34> @ imm = #-0x2
700a3d04: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxUhcCh; i++)
700a3d06: 9005         	str	r0, [sp, #0x14]
700a3d08: e7ff         	b	0x700a3d0a <Udma_rmAllocRxUhcCh+0x3a> @ imm = #-0x2
700a3d0a: 9805         	ldr	r0, [sp, #0x14]
700a3d0c: 9900         	ldr	r1, [sp]
700a3d0e: 6b49         	ldr	r1, [r1, #0x34]
700a3d10: 4288         	cmp	r0, r1
700a3d12: d22c         	bhs	0x700a3d6e <Udma_rmAllocRxUhcCh+0x9e> @ imm = #0x58
700a3d14: e7ff         	b	0x700a3d16 <Udma_rmAllocRxUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3d16: 9805         	ldr	r0, [sp, #0x14]
700a3d18: 0940         	lsrs	r0, r0, #0x5
700a3d1a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3d1c: 9805         	ldr	r0, [sp, #0x14]
700a3d1e: 9904         	ldr	r1, [sp, #0x10]
700a3d20: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3d24: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3d26: 9903         	ldr	r1, [sp, #0xc]
700a3d28: 2001         	movs	r0, #0x1
700a3d2a: 4088         	lsls	r0, r1
700a3d2c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxUhcChFlag[offset] & bitMask) == bitMask)
700a3d2e: 9806         	ldr	r0, [sp, #0x18]
700a3d30: 9904         	ldr	r1, [sp, #0x10]
700a3d32: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3d36: f8d0 0320    	ldr.w	r0, [r0, #0x320]
700a3d3a: 9902         	ldr	r1, [sp, #0x8]
700a3d3c: 4008         	ands	r0, r1
700a3d3e: 4288         	cmp	r0, r1
700a3d40: d110         	bne	0x700a3d64 <Udma_rmAllocRxUhcCh+0x94> @ imm = #0x20
700a3d42: e7ff         	b	0x700a3d44 <Udma_rmAllocRxUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->rxUhcChFlag[offset] &= ~bitMask;
700a3d44: 9a02         	ldr	r2, [sp, #0x8]
700a3d46: 9806         	ldr	r0, [sp, #0x18]
700a3d48: 9904         	ldr	r1, [sp, #0x10]
700a3d4a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3d4e: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700a3d52: 4390         	bics	r0, r2
700a3d54: f8c1 0320    	str.w	r0, [r1, #0x320]
;                 chNum = i + rmInitPrms->startRxUhcCh;  /* Add start offset */
700a3d58: 9805         	ldr	r0, [sp, #0x14]
700a3d5a: 9900         	ldr	r1, [sp]
700a3d5c: 6b09         	ldr	r1, [r1, #0x30]
700a3d5e: 4408         	add	r0, r1
700a3d60: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3d62: e004         	b	0x700a3d6e <Udma_rmAllocRxUhcCh+0x9e> @ imm = #0x8
;         }
700a3d64: e7ff         	b	0x700a3d66 <Udma_rmAllocRxUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxUhcCh; i++)
700a3d66: 9805         	ldr	r0, [sp, #0x14]
700a3d68: 3001         	adds	r0, #0x1
700a3d6a: 9005         	str	r0, [sp, #0x14]
700a3d6c: e7cd         	b	0x700a3d0a <Udma_rmAllocRxUhcCh+0x3a> @ imm = #-0x66
;     }
700a3d6e: e038         	b	0x700a3de2 <Udma_rmAllocRxUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxUhcCh) &&
700a3d70: 9807         	ldr	r0, [sp, #0x1c]
700a3d72: 9900         	ldr	r1, [sp]
700a3d74: 6b09         	ldr	r1, [r1, #0x30]
700a3d76: 4288         	cmp	r0, r1
700a3d78: d332         	blo	0x700a3de0 <Udma_rmAllocRxUhcCh+0x110> @ imm = #0x64
700a3d7a: e7ff         	b	0x700a3d7c <Udma_rmAllocRxUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxUhcCh + rmInitPrms->numRxUhcCh)))
700a3d7c: 9807         	ldr	r0, [sp, #0x1c]
700a3d7e: 9a00         	ldr	r2, [sp]
700a3d80: 6b11         	ldr	r1, [r2, #0x30]
700a3d82: 6b52         	ldr	r2, [r2, #0x34]
700a3d84: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxUhcCh) &&
700a3d86: 4288         	cmp	r0, r1
700a3d88: d22a         	bhs	0x700a3de0 <Udma_rmAllocRxUhcCh+0x110> @ imm = #0x54
700a3d8a: e7ff         	b	0x700a3d8c <Udma_rmAllocRxUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxUhcCh;
700a3d8c: 9807         	ldr	r0, [sp, #0x1c]
700a3d8e: 9900         	ldr	r1, [sp]
700a3d90: 6b09         	ldr	r1, [r1, #0x30]
700a3d92: 1a40         	subs	r0, r0, r1
700a3d94: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3d96: 9805         	ldr	r0, [sp, #0x14]
700a3d98: 0940         	lsrs	r0, r0, #0x5
700a3d9a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3d9c: 9805         	ldr	r0, [sp, #0x14]
700a3d9e: 9904         	ldr	r1, [sp, #0x10]
700a3da0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3da4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3da6: 9903         	ldr	r1, [sp, #0xc]
700a3da8: 2001         	movs	r0, #0x1
700a3daa: 4088         	lsls	r0, r1
700a3dac: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxUhcChFlag[offset] & bitMask) == bitMask)
700a3dae: 9806         	ldr	r0, [sp, #0x18]
700a3db0: 9904         	ldr	r1, [sp, #0x10]
700a3db2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3db6: f8d0 0320    	ldr.w	r0, [r0, #0x320]
700a3dba: 9902         	ldr	r1, [sp, #0x8]
700a3dbc: 4008         	ands	r0, r1
700a3dbe: 4288         	cmp	r0, r1
700a3dc0: d10d         	bne	0x700a3dde <Udma_rmAllocRxUhcCh+0x10e> @ imm = #0x1a
700a3dc2: e7ff         	b	0x700a3dc4 <Udma_rmAllocRxUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxUhcChFlag[offset] &= ~bitMask;
700a3dc4: 9a02         	ldr	r2, [sp, #0x8]
700a3dc6: 9806         	ldr	r0, [sp, #0x18]
700a3dc8: 9904         	ldr	r1, [sp, #0x10]
700a3dca: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3dce: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700a3dd2: 4390         	bics	r0, r2
700a3dd4: f8c1 0320    	str.w	r0, [r1, #0x320]
;                 chNum = preferredChNum;
700a3dd8: 9807         	ldr	r0, [sp, #0x1c]
700a3dda: 9001         	str	r0, [sp, #0x4]
;             }
700a3ddc: e7ff         	b	0x700a3dde <Udma_rmAllocRxUhcCh+0x10e> @ imm = #-0x2
;         }
700a3dde: e7ff         	b	0x700a3de0 <Udma_rmAllocRxUhcCh+0x110> @ imm = #-0x2
700a3de0: e7ff         	b	0x700a3de2 <Udma_rmAllocRxUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3de2: 9806         	ldr	r0, [sp, #0x18]
700a3de4: f500 609f    	add.w	r0, r0, #0x4f8
700a3de8: f007 ff5a    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x7eb4
;     return (chNum);
700a3dec: 9801         	ldr	r0, [sp, #0x4]
700a3dee: b008         	add	sp, #0x20
700a3df0: bd80         	pop	{r7, pc}
		...
700a3dfe: 0000         	movs	r0, r0

700a3e00 <Udma_rmAllocTxCh>:
; {
700a3e00: b580         	push	{r7, lr}
700a3e02: b088         	sub	sp, #0x20
700a3e04: 9007         	str	r0, [sp, #0x1c]
700a3e06: 9106         	str	r1, [sp, #0x18]
700a3e08: 2000         	movs	r0, #0x0
700a3e0a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3e0e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3e10: 9806         	ldr	r0, [sp, #0x18]
700a3e12: f500 70ea    	add.w	r0, r0, #0x1d4
700a3e16: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3e18: 9806         	ldr	r0, [sp, #0x18]
700a3e1a: f500 609f    	add.w	r0, r0, #0x4f8
700a3e1e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3e22: f006 fbad    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x675a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3e26: 9807         	ldr	r0, [sp, #0x1c]
700a3e28: 2101         	movs	r1, #0x1
700a3e2a: f6cf 71ff    	movt	r1, #0xffff
700a3e2e: 4288         	cmp	r0, r1
700a3e30: d136         	bne	0x700a3ea0 <Udma_rmAllocTxCh+0xa0> @ imm = #0x6c
700a3e32: e7ff         	b	0x700a3e34 <Udma_rmAllocTxCh+0x34> @ imm = #-0x2
700a3e34: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxCh; i++)
700a3e36: 9005         	str	r0, [sp, #0x14]
700a3e38: e7ff         	b	0x700a3e3a <Udma_rmAllocTxCh+0x3a> @ imm = #-0x2
700a3e3a: 9805         	ldr	r0, [sp, #0x14]
700a3e3c: 9900         	ldr	r1, [sp]
700a3e3e: 6ac9         	ldr	r1, [r1, #0x2c]
700a3e40: 4288         	cmp	r0, r1
700a3e42: d22c         	bhs	0x700a3e9e <Udma_rmAllocTxCh+0x9e> @ imm = #0x58
700a3e44: e7ff         	b	0x700a3e46 <Udma_rmAllocTxCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3e46: 9805         	ldr	r0, [sp, #0x14]
700a3e48: 0940         	lsrs	r0, r0, #0x5
700a3e4a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3e4c: 9805         	ldr	r0, [sp, #0x14]
700a3e4e: 9904         	ldr	r1, [sp, #0x10]
700a3e50: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3e54: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3e56: 9903         	ldr	r1, [sp, #0xc]
700a3e58: 2001         	movs	r0, #0x1
700a3e5a: 4088         	lsls	r0, r1
700a3e5c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txChFlag[offset] & bitMask) == bitMask)
700a3e5e: 9806         	ldr	r0, [sp, #0x18]
700a3e60: 9904         	ldr	r1, [sp, #0x10]
700a3e62: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3e66: f8d0 02d4    	ldr.w	r0, [r0, #0x2d4]
700a3e6a: 9902         	ldr	r1, [sp, #0x8]
700a3e6c: 4008         	ands	r0, r1
700a3e6e: 4288         	cmp	r0, r1
700a3e70: d110         	bne	0x700a3e94 <Udma_rmAllocTxCh+0x94> @ imm = #0x20
700a3e72: e7ff         	b	0x700a3e74 <Udma_rmAllocTxCh+0x74> @ imm = #-0x2
;                 drvHandle->txChFlag[offset] &= ~bitMask;
700a3e74: 9a02         	ldr	r2, [sp, #0x8]
700a3e76: 9806         	ldr	r0, [sp, #0x18]
700a3e78: 9904         	ldr	r1, [sp, #0x10]
700a3e7a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3e7e: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700a3e82: 4390         	bics	r0, r2
700a3e84: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;                 chNum = i + rmInitPrms->startTxCh;  /* Add start offset */
700a3e88: 9805         	ldr	r0, [sp, #0x14]
700a3e8a: 9900         	ldr	r1, [sp]
700a3e8c: 6a89         	ldr	r1, [r1, #0x28]
700a3e8e: 4408         	add	r0, r1
700a3e90: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3e92: e004         	b	0x700a3e9e <Udma_rmAllocTxCh+0x9e> @ imm = #0x8
;         }
700a3e94: e7ff         	b	0x700a3e96 <Udma_rmAllocTxCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxCh; i++)
700a3e96: 9805         	ldr	r0, [sp, #0x14]
700a3e98: 3001         	adds	r0, #0x1
700a3e9a: 9005         	str	r0, [sp, #0x14]
700a3e9c: e7cd         	b	0x700a3e3a <Udma_rmAllocTxCh+0x3a> @ imm = #-0x66
;     }
700a3e9e: e038         	b	0x700a3f12 <Udma_rmAllocTxCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxCh) &&
700a3ea0: 9807         	ldr	r0, [sp, #0x1c]
700a3ea2: 9900         	ldr	r1, [sp]
700a3ea4: 6a89         	ldr	r1, [r1, #0x28]
700a3ea6: 4288         	cmp	r0, r1
700a3ea8: d332         	blo	0x700a3f10 <Udma_rmAllocTxCh+0x110> @ imm = #0x64
700a3eaa: e7ff         	b	0x700a3eac <Udma_rmAllocTxCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxCh + rmInitPrms->numTxCh)))
700a3eac: 9807         	ldr	r0, [sp, #0x1c]
700a3eae: 9a00         	ldr	r2, [sp]
700a3eb0: 6a91         	ldr	r1, [r2, #0x28]
700a3eb2: 6ad2         	ldr	r2, [r2, #0x2c]
700a3eb4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxCh) &&
700a3eb6: 4288         	cmp	r0, r1
700a3eb8: d22a         	bhs	0x700a3f10 <Udma_rmAllocTxCh+0x110> @ imm = #0x54
700a3eba: e7ff         	b	0x700a3ebc <Udma_rmAllocTxCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxCh;
700a3ebc: 9807         	ldr	r0, [sp, #0x1c]
700a3ebe: 9900         	ldr	r1, [sp]
700a3ec0: 6a89         	ldr	r1, [r1, #0x28]
700a3ec2: 1a40         	subs	r0, r0, r1
700a3ec4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3ec6: 9805         	ldr	r0, [sp, #0x14]
700a3ec8: 0940         	lsrs	r0, r0, #0x5
700a3eca: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3ecc: 9805         	ldr	r0, [sp, #0x14]
700a3ece: 9904         	ldr	r1, [sp, #0x10]
700a3ed0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3ed4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3ed6: 9903         	ldr	r1, [sp, #0xc]
700a3ed8: 2001         	movs	r0, #0x1
700a3eda: 4088         	lsls	r0, r1
700a3edc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txChFlag[offset] & bitMask) == bitMask)
700a3ede: 9806         	ldr	r0, [sp, #0x18]
700a3ee0: 9904         	ldr	r1, [sp, #0x10]
700a3ee2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3ee6: f8d0 02d4    	ldr.w	r0, [r0, #0x2d4]
700a3eea: 9902         	ldr	r1, [sp, #0x8]
700a3eec: 4008         	ands	r0, r1
700a3eee: 4288         	cmp	r0, r1
700a3ef0: d10d         	bne	0x700a3f0e <Udma_rmAllocTxCh+0x10e> @ imm = #0x1a
700a3ef2: e7ff         	b	0x700a3ef4 <Udma_rmAllocTxCh+0xf4> @ imm = #-0x2
;                 drvHandle->txChFlag[offset] &= ~bitMask;
700a3ef4: 9a02         	ldr	r2, [sp, #0x8]
700a3ef6: 9806         	ldr	r0, [sp, #0x18]
700a3ef8: 9904         	ldr	r1, [sp, #0x10]
700a3efa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3efe: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700a3f02: 4390         	bics	r0, r2
700a3f04: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;                 chNum = preferredChNum;
700a3f08: 9807         	ldr	r0, [sp, #0x1c]
700a3f0a: 9001         	str	r0, [sp, #0x4]
;             }
700a3f0c: e7ff         	b	0x700a3f0e <Udma_rmAllocTxCh+0x10e> @ imm = #-0x2
;         }
700a3f0e: e7ff         	b	0x700a3f10 <Udma_rmAllocTxCh+0x110> @ imm = #-0x2
700a3f10: e7ff         	b	0x700a3f12 <Udma_rmAllocTxCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3f12: 9806         	ldr	r0, [sp, #0x18]
700a3f14: f500 609f    	add.w	r0, r0, #0x4f8
700a3f18: f007 fec2    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x7d84
;     return (chNum);
700a3f1c: 9801         	ldr	r0, [sp, #0x4]
700a3f1e: b008         	add	sp, #0x20
700a3f20: bd80         	pop	{r7, pc}
		...
700a3f2e: 0000         	movs	r0, r0

700a3f30 <Udma_rmAllocTxHcCh>:
; {
700a3f30: b580         	push	{r7, lr}
700a3f32: b088         	sub	sp, #0x20
700a3f34: 9007         	str	r0, [sp, #0x1c]
700a3f36: 9106         	str	r1, [sp, #0x18]
700a3f38: 2000         	movs	r0, #0x0
700a3f3a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3f3e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3f40: 9806         	ldr	r0, [sp, #0x18]
700a3f42: f500 70ea    	add.w	r0, r0, #0x1d4
700a3f46: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3f48: 9806         	ldr	r0, [sp, #0x18]
700a3f4a: f500 609f    	add.w	r0, r0, #0x4f8
700a3f4e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3f52: f006 fb15    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x662a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3f56: 9807         	ldr	r0, [sp, #0x1c]
700a3f58: 2101         	movs	r1, #0x1
700a3f5a: f6cf 71ff    	movt	r1, #0xffff
700a3f5e: 4288         	cmp	r0, r1
700a3f60: d136         	bne	0x700a3fd0 <Udma_rmAllocTxHcCh+0xa0> @ imm = #0x6c
700a3f62: e7ff         	b	0x700a3f64 <Udma_rmAllocTxHcCh+0x34> @ imm = #-0x2
700a3f64: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxHcCh; i++)
700a3f66: 9005         	str	r0, [sp, #0x14]
700a3f68: e7ff         	b	0x700a3f6a <Udma_rmAllocTxHcCh+0x3a> @ imm = #-0x2
700a3f6a: 9805         	ldr	r0, [sp, #0x14]
700a3f6c: 9900         	ldr	r1, [sp]
700a3f6e: 6a49         	ldr	r1, [r1, #0x24]
700a3f70: 4288         	cmp	r0, r1
700a3f72: d22c         	bhs	0x700a3fce <Udma_rmAllocTxHcCh+0x9e> @ imm = #0x58
700a3f74: e7ff         	b	0x700a3f76 <Udma_rmAllocTxHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3f76: 9805         	ldr	r0, [sp, #0x14]
700a3f78: 0940         	lsrs	r0, r0, #0x5
700a3f7a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3f7c: 9805         	ldr	r0, [sp, #0x14]
700a3f7e: 9904         	ldr	r1, [sp, #0x10]
700a3f80: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3f84: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3f86: 9903         	ldr	r1, [sp, #0xc]
700a3f88: 2001         	movs	r0, #0x1
700a3f8a: 4088         	lsls	r0, r1
700a3f8c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txHcChFlag[offset] & bitMask) == bitMask)
700a3f8e: 9806         	ldr	r0, [sp, #0x18]
700a3f90: 9904         	ldr	r1, [sp, #0x10]
700a3f92: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3f96: f8d0 02f4    	ldr.w	r0, [r0, #0x2f4]
700a3f9a: 9902         	ldr	r1, [sp, #0x8]
700a3f9c: 4008         	ands	r0, r1
700a3f9e: 4288         	cmp	r0, r1
700a3fa0: d110         	bne	0x700a3fc4 <Udma_rmAllocTxHcCh+0x94> @ imm = #0x20
700a3fa2: e7ff         	b	0x700a3fa4 <Udma_rmAllocTxHcCh+0x74> @ imm = #-0x2
;                 drvHandle->txHcChFlag[offset] &= ~bitMask;
700a3fa4: 9a02         	ldr	r2, [sp, #0x8]
700a3fa6: 9806         	ldr	r0, [sp, #0x18]
700a3fa8: 9904         	ldr	r1, [sp, #0x10]
700a3faa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3fae: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700a3fb2: 4390         	bics	r0, r2
700a3fb4: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;                 chNum = i + rmInitPrms->startTxHcCh;  /* Add start offset */
700a3fb8: 9805         	ldr	r0, [sp, #0x14]
700a3fba: 9900         	ldr	r1, [sp]
700a3fbc: 6a09         	ldr	r1, [r1, #0x20]
700a3fbe: 4408         	add	r0, r1
700a3fc0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3fc2: e004         	b	0x700a3fce <Udma_rmAllocTxHcCh+0x9e> @ imm = #0x8
;         }
700a3fc4: e7ff         	b	0x700a3fc6 <Udma_rmAllocTxHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxHcCh; i++)
700a3fc6: 9805         	ldr	r0, [sp, #0x14]
700a3fc8: 3001         	adds	r0, #0x1
700a3fca: 9005         	str	r0, [sp, #0x14]
700a3fcc: e7cd         	b	0x700a3f6a <Udma_rmAllocTxHcCh+0x3a> @ imm = #-0x66
;     }
700a3fce: e038         	b	0x700a4042 <Udma_rmAllocTxHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxHcCh) &&
700a3fd0: 9807         	ldr	r0, [sp, #0x1c]
700a3fd2: 9900         	ldr	r1, [sp]
700a3fd4: 6a09         	ldr	r1, [r1, #0x20]
700a3fd6: 4288         	cmp	r0, r1
700a3fd8: d332         	blo	0x700a4040 <Udma_rmAllocTxHcCh+0x110> @ imm = #0x64
700a3fda: e7ff         	b	0x700a3fdc <Udma_rmAllocTxHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxHcCh + rmInitPrms->numTxHcCh)))
700a3fdc: 9807         	ldr	r0, [sp, #0x1c]
700a3fde: 9a00         	ldr	r2, [sp]
700a3fe0: 6a11         	ldr	r1, [r2, #0x20]
700a3fe2: 6a52         	ldr	r2, [r2, #0x24]
700a3fe4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxHcCh) &&
700a3fe6: 4288         	cmp	r0, r1
700a3fe8: d22a         	bhs	0x700a4040 <Udma_rmAllocTxHcCh+0x110> @ imm = #0x54
700a3fea: e7ff         	b	0x700a3fec <Udma_rmAllocTxHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxHcCh;
700a3fec: 9807         	ldr	r0, [sp, #0x1c]
700a3fee: 9900         	ldr	r1, [sp]
700a3ff0: 6a09         	ldr	r1, [r1, #0x20]
700a3ff2: 1a40         	subs	r0, r0, r1
700a3ff4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3ff6: 9805         	ldr	r0, [sp, #0x14]
700a3ff8: 0940         	lsrs	r0, r0, #0x5
700a3ffa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3ffc: 9805         	ldr	r0, [sp, #0x14]
700a3ffe: 9904         	ldr	r1, [sp, #0x10]
700a4000: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a4004: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a4006: 9903         	ldr	r1, [sp, #0xc]
700a4008: 2001         	movs	r0, #0x1
700a400a: 4088         	lsls	r0, r1
700a400c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txHcChFlag[offset] & bitMask) == bitMask)
700a400e: 9806         	ldr	r0, [sp, #0x18]
700a4010: 9904         	ldr	r1, [sp, #0x10]
700a4012: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4016: f8d0 02f4    	ldr.w	r0, [r0, #0x2f4]
700a401a: 9902         	ldr	r1, [sp, #0x8]
700a401c: 4008         	ands	r0, r1
700a401e: 4288         	cmp	r0, r1
700a4020: d10d         	bne	0x700a403e <Udma_rmAllocTxHcCh+0x10e> @ imm = #0x1a
700a4022: e7ff         	b	0x700a4024 <Udma_rmAllocTxHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->txHcChFlag[offset] &= ~bitMask;
700a4024: 9a02         	ldr	r2, [sp, #0x8]
700a4026: 9806         	ldr	r0, [sp, #0x18]
700a4028: 9904         	ldr	r1, [sp, #0x10]
700a402a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a402e: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700a4032: 4390         	bics	r0, r2
700a4034: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;                 chNum = preferredChNum;
700a4038: 9807         	ldr	r0, [sp, #0x1c]
700a403a: 9001         	str	r0, [sp, #0x4]
;             }
700a403c: e7ff         	b	0x700a403e <Udma_rmAllocTxHcCh+0x10e> @ imm = #-0x2
;         }
700a403e: e7ff         	b	0x700a4040 <Udma_rmAllocTxHcCh+0x110> @ imm = #-0x2
700a4040: e7ff         	b	0x700a4042 <Udma_rmAllocTxHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a4042: 9806         	ldr	r0, [sp, #0x18]
700a4044: f500 609f    	add.w	r0, r0, #0x4f8
700a4048: f007 fe2a    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x7c54
;     return (chNum);
700a404c: 9801         	ldr	r0, [sp, #0x4]
700a404e: b008         	add	sp, #0x20
700a4050: bd80         	pop	{r7, pc}
		...
700a405e: 0000         	movs	r0, r0

700a4060 <Udma_rmAllocTxUhcCh>:
; {
700a4060: b580         	push	{r7, lr}
700a4062: b088         	sub	sp, #0x20
700a4064: 9007         	str	r0, [sp, #0x1c]
700a4066: 9106         	str	r1, [sp, #0x18]
700a4068: 2000         	movs	r0, #0x0
700a406a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a406e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a4070: 9806         	ldr	r0, [sp, #0x18]
700a4072: f500 70ea    	add.w	r0, r0, #0x1d4
700a4076: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a4078: 9806         	ldr	r0, [sp, #0x18]
700a407a: f500 609f    	add.w	r0, r0, #0x4f8
700a407e: f04f 31ff    	mov.w	r1, #0xffffffff
700a4082: f006 fa7d    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x64fa
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a4086: 9807         	ldr	r0, [sp, #0x1c]
700a4088: 2101         	movs	r1, #0x1
700a408a: f6cf 71ff    	movt	r1, #0xffff
700a408e: 4288         	cmp	r0, r1
700a4090: d136         	bne	0x700a4100 <Udma_rmAllocTxUhcCh+0xa0> @ imm = #0x6c
700a4092: e7ff         	b	0x700a4094 <Udma_rmAllocTxUhcCh+0x34> @ imm = #-0x2
700a4094: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxUhcCh; i++)
700a4096: 9005         	str	r0, [sp, #0x14]
700a4098: e7ff         	b	0x700a409a <Udma_rmAllocTxUhcCh+0x3a> @ imm = #-0x2
700a409a: 9805         	ldr	r0, [sp, #0x14]
700a409c: 9900         	ldr	r1, [sp]
700a409e: 69c9         	ldr	r1, [r1, #0x1c]
700a40a0: 4288         	cmp	r0, r1
700a40a2: d22c         	bhs	0x700a40fe <Udma_rmAllocTxUhcCh+0x9e> @ imm = #0x58
700a40a4: e7ff         	b	0x700a40a6 <Udma_rmAllocTxUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a40a6: 9805         	ldr	r0, [sp, #0x14]
700a40a8: 0940         	lsrs	r0, r0, #0x5
700a40aa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a40ac: 9805         	ldr	r0, [sp, #0x14]
700a40ae: 9904         	ldr	r1, [sp, #0x10]
700a40b0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a40b4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a40b6: 9903         	ldr	r1, [sp, #0xc]
700a40b8: 2001         	movs	r0, #0x1
700a40ba: 4088         	lsls	r0, r1
700a40bc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txUhcChFlag[offset] & bitMask) == bitMask)
700a40be: 9806         	ldr	r0, [sp, #0x18]
700a40c0: 9904         	ldr	r1, [sp, #0x10]
700a40c2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a40c6: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a40ca: 9902         	ldr	r1, [sp, #0x8]
700a40cc: 4008         	ands	r0, r1
700a40ce: 4288         	cmp	r0, r1
700a40d0: d110         	bne	0x700a40f4 <Udma_rmAllocTxUhcCh+0x94> @ imm = #0x20
700a40d2: e7ff         	b	0x700a40d4 <Udma_rmAllocTxUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->txUhcChFlag[offset] &= ~bitMask;
700a40d4: 9a02         	ldr	r2, [sp, #0x8]
700a40d6: 9806         	ldr	r0, [sp, #0x18]
700a40d8: 9904         	ldr	r1, [sp, #0x10]
700a40da: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a40de: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700a40e2: 4390         	bics	r0, r2
700a40e4: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;                 chNum = i + rmInitPrms->startTxUhcCh;  /* Add start offset */
700a40e8: 9805         	ldr	r0, [sp, #0x14]
700a40ea: 9900         	ldr	r1, [sp]
700a40ec: 6989         	ldr	r1, [r1, #0x18]
700a40ee: 4408         	add	r0, r1
700a40f0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a40f2: e004         	b	0x700a40fe <Udma_rmAllocTxUhcCh+0x9e> @ imm = #0x8
;         }
700a40f4: e7ff         	b	0x700a40f6 <Udma_rmAllocTxUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxUhcCh; i++)
700a40f6: 9805         	ldr	r0, [sp, #0x14]
700a40f8: 3001         	adds	r0, #0x1
700a40fa: 9005         	str	r0, [sp, #0x14]
700a40fc: e7cd         	b	0x700a409a <Udma_rmAllocTxUhcCh+0x3a> @ imm = #-0x66
;     }
700a40fe: e038         	b	0x700a4172 <Udma_rmAllocTxUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxUhcCh) &&
700a4100: 9807         	ldr	r0, [sp, #0x1c]
700a4102: 9900         	ldr	r1, [sp]
700a4104: 6989         	ldr	r1, [r1, #0x18]
700a4106: 4288         	cmp	r0, r1
700a4108: d332         	blo	0x700a4170 <Udma_rmAllocTxUhcCh+0x110> @ imm = #0x64
700a410a: e7ff         	b	0x700a410c <Udma_rmAllocTxUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxUhcCh + rmInitPrms->numTxUhcCh)))
700a410c: 9807         	ldr	r0, [sp, #0x1c]
700a410e: 9a00         	ldr	r2, [sp]
700a4110: 6991         	ldr	r1, [r2, #0x18]
700a4112: 69d2         	ldr	r2, [r2, #0x1c]
700a4114: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxUhcCh) &&
700a4116: 4288         	cmp	r0, r1
700a4118: d22a         	bhs	0x700a4170 <Udma_rmAllocTxUhcCh+0x110> @ imm = #0x54
700a411a: e7ff         	b	0x700a411c <Udma_rmAllocTxUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxUhcCh;
700a411c: 9807         	ldr	r0, [sp, #0x1c]
700a411e: 9900         	ldr	r1, [sp]
700a4120: 6989         	ldr	r1, [r1, #0x18]
700a4122: 1a40         	subs	r0, r0, r1
700a4124: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a4126: 9805         	ldr	r0, [sp, #0x14]
700a4128: 0940         	lsrs	r0, r0, #0x5
700a412a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a412c: 9805         	ldr	r0, [sp, #0x14]
700a412e: 9904         	ldr	r1, [sp, #0x10]
700a4130: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a4134: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a4136: 9903         	ldr	r1, [sp, #0xc]
700a4138: 2001         	movs	r0, #0x1
700a413a: 4088         	lsls	r0, r1
700a413c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txUhcChFlag[offset] & bitMask) == bitMask)
700a413e: 9806         	ldr	r0, [sp, #0x18]
700a4140: 9904         	ldr	r1, [sp, #0x10]
700a4142: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4146: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a414a: 9902         	ldr	r1, [sp, #0x8]
700a414c: 4008         	ands	r0, r1
700a414e: 4288         	cmp	r0, r1
700a4150: d10d         	bne	0x700a416e <Udma_rmAllocTxUhcCh+0x10e> @ imm = #0x1a
700a4152: e7ff         	b	0x700a4154 <Udma_rmAllocTxUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->txUhcChFlag[offset] &= ~bitMask;
700a4154: 9a02         	ldr	r2, [sp, #0x8]
700a4156: 9806         	ldr	r0, [sp, #0x18]
700a4158: 9904         	ldr	r1, [sp, #0x10]
700a415a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a415e: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700a4162: 4390         	bics	r0, r2
700a4164: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;                 chNum = preferredChNum;
700a4168: 9807         	ldr	r0, [sp, #0x1c]
700a416a: 9001         	str	r0, [sp, #0x4]
;             }
700a416c: e7ff         	b	0x700a416e <Udma_rmAllocTxUhcCh+0x10e> @ imm = #-0x2
;         }
700a416e: e7ff         	b	0x700a4170 <Udma_rmAllocTxUhcCh+0x110> @ imm = #-0x2
700a4170: e7ff         	b	0x700a4172 <Udma_rmAllocTxUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a4172: 9806         	ldr	r0, [sp, #0x18]
700a4174: f500 609f    	add.w	r0, r0, #0x4f8
700a4178: f007 fd92    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x7b24
;     return (chNum);
700a417c: 9801         	ldr	r0, [sp, #0x4]
700a417e: b008         	add	sp, #0x20
700a4180: bd80         	pop	{r7, pc}
		...
700a418e: 0000         	movs	r0, r0

700a4190 <UART_udmaInitRxCh>:
; {
700a4190: b580         	push	{r7, lr}
700a4192: b0be         	sub	sp, #0xf8
700a4194: 903d         	str	r0, [sp, #0xf4]
700a4196: 913c         	str	r1, [sp, #0xf0]
700a4198: 200a         	movs	r0, #0xa
;     chType = UDMA_CH_TYPE_PDMA_RX;
700a419a: 903a         	str	r0, [sp, #0xe8]
;     UdmaChPrms_init(&chPrms, chType);
700a419c: 993a         	ldr	r1, [sp, #0xe8]
700a419e: a821         	add	r0, sp, #0x84
700a41a0: f007 f956    	bl	0x700ab450 <UdmaChPrms_init> @ imm = #0x72ac
;     chPrms.peerChNum                = hUart->hUartInit->rxEvtNum;
700a41a4: 983d         	ldr	r0, [sp, #0xf4]
700a41a6: 6840         	ldr	r0, [r0, #0x4]
700a41a8: 6c00         	ldr	r0, [r0, #0x40]
700a41aa: 9022         	str	r0, [sp, #0x88]
;     chPrms.fqRingPrms.ringMem       = udmaChCfg->rxRingMem;
700a41ac: 983c         	ldr	r0, [sp, #0xf0]
700a41ae: 6a80         	ldr	r0, [r0, #0x28]
700a41b0: 9025         	str	r0, [sp, #0x94]
;     chPrms.fqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a41b2: 983c         	ldr	r0, [sp, #0xf0]
700a41b4: 6b00         	ldr	r0, [r0, #0x30]
700a41b6: 9026         	str	r0, [sp, #0x98]
;     chPrms.fqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a41b8: 983c         	ldr	r0, [sp, #0xf0]
700a41ba: 6b40         	ldr	r0, [r0, #0x34]
700a41bc: 9028         	str	r0, [sp, #0xa0]
;     if(udmaChCfg->isCqRingMem == UDMA_COMP_QUEUE_RING_MEM_ENABLED){
700a41be: 983c         	ldr	r0, [sp, #0xf0]
700a41c0: 6bc0         	ldr	r0, [r0, #0x3c]
700a41c2: 2801         	cmp	r0, #0x1
700a41c4: d10a         	bne	0x700a41dc <UART_udmaInitRxCh+0x4c> @ imm = #0x14
700a41c6: e7ff         	b	0x700a41c8 <UART_udmaInitRxCh+0x38> @ imm = #-0x2
;         chPrms.cqRingPrms.ringMem       = udmaChCfg->cqRxRingMem;
700a41c8: 983c         	ldr	r0, [sp, #0xf0]
700a41ca: 6ac0         	ldr	r0, [r0, #0x2c]
700a41cc: 902c         	str	r0, [sp, #0xb0]
;         chPrms.cqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a41ce: 983c         	ldr	r0, [sp, #0xf0]
700a41d0: 6b00         	ldr	r0, [r0, #0x30]
700a41d2: 902d         	str	r0, [sp, #0xb4]
;         chPrms.cqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a41d4: 983c         	ldr	r0, [sp, #0xf0]
700a41d6: 6b40         	ldr	r0, [r0, #0x34]
700a41d8: 902f         	str	r0, [sp, #0xbc]
;     }
700a41da: e7ff         	b	0x700a41dc <UART_udmaInitRxCh+0x4c> @ imm = #-0x2
;     rxChHandle                      = udmaChCfg->rxChHandle;
700a41dc: 983c         	ldr	r0, [sp, #0xf0]
700a41de: 6880         	ldr	r0, [r0, #0x8]
700a41e0: 9006         	str	r0, [sp, #0x18]
;     drvHandle                       = udmaChCfg->drvHandle;
700a41e2: 983c         	ldr	r0, [sp, #0xf0]
700a41e4: 6800         	ldr	r0, [r0]
700a41e6: 9007         	str	r0, [sp, #0x1c]
;     retVal = Udma_chOpen(drvHandle, rxChHandle, chType, &chPrms);
700a41e8: 9807         	ldr	r0, [sp, #0x1c]
700a41ea: 9906         	ldr	r1, [sp, #0x18]
700a41ec: 9a3a         	ldr	r2, [sp, #0xe8]
700a41ee: ab21         	add	r3, sp, #0x84
700a41f0: f7fd fb2e    	bl	0x700a1850 <Udma_chOpen> @ imm = #-0x29a4
700a41f4: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a41f6: 983b         	ldr	r0, [sp, #0xec]
700a41f8: fab0 f080    	clz	r0, r0
700a41fc: 0940         	lsrs	r0, r0, #0x5
700a41fe: f641 4153    	movw	r1, #0x1c53
700a4202: f2c7 010b    	movt	r1, #0x700b
700a4206: 9103         	str	r1, [sp, #0xc]
700a4208: 466a         	mov	r2, sp
700a420a: 6011         	str	r1, [r2]
700a420c: f641 016d    	movw	r1, #0x186d
700a4210: f2c7 010b    	movt	r1, #0x700b
700a4214: 9104         	str	r1, [sp, #0x10]
700a4216: f641 42d7    	movw	r2, #0x1cd7
700a421a: f2c7 020b    	movt	r2, #0x700b
700a421e: 9205         	str	r2, [sp, #0x14]
700a4220: 2366         	movs	r3, #0x66
700a4222: f006 fc05    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x680a
;     UdmaChRxPrms_init(&rxPrms, chType);
700a4226: 993a         	ldr	r1, [sp, #0xe8]
700a4228: a81a         	add	r0, sp, #0x68
700a422a: 9001         	str	r0, [sp, #0x4]
700a422c: f003 fdb8    	bl	0x700a7da0 <UdmaChRxPrms_init> @ imm = #0x3b70
700a4230: 9901         	ldr	r1, [sp, #0x4]
;     retVal = Udma_chConfigRx(rxChHandle, &rxPrms);
700a4232: 9806         	ldr	r0, [sp, #0x18]
700a4234: f7f9 fd84    	bl	0x7009dd40 <Udma_chConfigRx> @ imm = #-0x64f8
700a4238: 9b03         	ldr	r3, [sp, #0xc]
700a423a: 9904         	ldr	r1, [sp, #0x10]
700a423c: 9a05         	ldr	r2, [sp, #0x14]
700a423e: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a4240: 983b         	ldr	r0, [sp, #0xec]
700a4242: fab0 f080    	clz	r0, r0
700a4246: 0940         	lsrs	r0, r0, #0x5
700a4248: 46ec         	mov	r12, sp
700a424a: f8cc 3000    	str.w	r3, [r12]
700a424e: 236b         	movs	r3, #0x6b
700a4250: f006 fbee    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x67dc
;     eventHandle = udmaChCfg->cqRxEvtHandle;
700a4254: 983c         	ldr	r0, [sp, #0xf0]
700a4256: 6900         	ldr	r0, [r0, #0x10]
700a4258: 9019         	str	r0, [sp, #0x64]
700a425a: a808         	add	r0, sp, #0x20
;     UdmaEventPrms_init(&eventPrms);
700a425c: 9002         	str	r0, [sp, #0x8]
700a425e: f007 fd57    	bl	0x700abd10 <UdmaEventPrms_init> @ imm = #0x7aae
700a4262: 2001         	movs	r0, #0x1
;     eventPrms.eventType         = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a4264: 9008         	str	r0, [sp, #0x20]
700a4266: 2002         	movs	r0, #0x2
;     eventPrms.eventMode         = UDMA_EVENT_MODE_SHARED;
700a4268: 9009         	str	r0, [sp, #0x24]
;     eventPrms.chHandle          = rxChHandle;
700a426a: 9806         	ldr	r0, [sp, #0x18]
700a426c: 900a         	str	r0, [sp, #0x28]
;     eventPrms.controllerEventHandle = Udma_eventGetGlobalHandle(drvHandle);
700a426e: 9807         	ldr	r0, [sp, #0x1c]
700a4270: f008 fc26    	bl	0x700acac0 <Udma_eventGetGlobalHandle> @ imm = #0x884c
700a4274: 9a02         	ldr	r2, [sp, #0x8]
700a4276: 900c         	str	r0, [sp, #0x30]
;     eventPrms.eventCb           = &UART_udmaIsrRx;
700a4278: f249 5021    	movw	r0, #0x9521
700a427c: f2c7 000a    	movt	r0, #0x700a
700a4280: 900d         	str	r0, [sp, #0x34]
;     eventPrms.appData           = (void *) hUart;
700a4282: 983d         	ldr	r0, [sp, #0xf4]
700a4284: 900f         	str	r0, [sp, #0x3c]
;     retVal = Udma_eventRegister(drvHandle, eventHandle, &eventPrms);
700a4286: 9807         	ldr	r0, [sp, #0x1c]
700a4288: 9919         	ldr	r1, [sp, #0x64]
700a428a: f7fa f9f9    	bl	0x7009e680 <Udma_eventRegister> @ imm = #-0x5c0e
700a428e: 9b03         	ldr	r3, [sp, #0xc]
700a4290: 9904         	ldr	r1, [sp, #0x10]
700a4292: 9a05         	ldr	r2, [sp, #0x14]
700a4294: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a4296: 983b         	ldr	r0, [sp, #0xec]
700a4298: fab0 f080    	clz	r0, r0
700a429c: 0940         	lsrs	r0, r0, #0x5
700a429e: 46ec         	mov	r12, sp
700a42a0: f8cc 3000    	str.w	r3, [r12]
700a42a4: 2377         	movs	r3, #0x77
700a42a6: f006 fbc3    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x6786
;     return retVal;
700a42aa: 983b         	ldr	r0, [sp, #0xec]
700a42ac: b03e         	add	sp, #0xf8
700a42ae: bd80         	pop	{r7, pc}

700a42b0 <UART_udmaInitTxCh>:
; {
700a42b0: b580         	push	{r7, lr}
700a42b2: b0bc         	sub	sp, #0xf0
700a42b4: 903b         	str	r0, [sp, #0xec]
700a42b6: 913a         	str	r1, [sp, #0xe8]
700a42b8: 2009         	movs	r0, #0x9
;     chType = UDMA_CH_TYPE_PDMA_TX;
700a42ba: 9038         	str	r0, [sp, #0xe0]
;     UdmaChPrms_init(&chPrms, chType);
700a42bc: 9938         	ldr	r1, [sp, #0xe0]
700a42be: a81f         	add	r0, sp, #0x7c
700a42c0: f007 f8c6    	bl	0x700ab450 <UdmaChPrms_init> @ imm = #0x718c
;     chPrms.peerChNum                = hUart->hUartInit->txEvtNum;
700a42c4: 983b         	ldr	r0, [sp, #0xec]
700a42c6: 6840         	ldr	r0, [r0, #0x4]
700a42c8: 6c40         	ldr	r0, [r0, #0x44]
700a42ca: 9020         	str	r0, [sp, #0x80]
;     chPrms.fqRingPrms.ringMem       = udmaChCfg->txRingMem;
700a42cc: 983a         	ldr	r0, [sp, #0xe8]
700a42ce: 6a00         	ldr	r0, [r0, #0x20]
700a42d0: 9023         	str	r0, [sp, #0x8c]
;     chPrms.fqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a42d2: 983a         	ldr	r0, [sp, #0xe8]
700a42d4: 6b00         	ldr	r0, [r0, #0x30]
700a42d6: 9024         	str	r0, [sp, #0x90]
;     chPrms.fqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a42d8: 983a         	ldr	r0, [sp, #0xe8]
700a42da: 6b40         	ldr	r0, [r0, #0x34]
700a42dc: 9026         	str	r0, [sp, #0x98]
;     if(udmaChCfg->isCqRingMem == UDMA_COMP_QUEUE_RING_MEM_ENABLED){
700a42de: 983a         	ldr	r0, [sp, #0xe8]
700a42e0: 6bc0         	ldr	r0, [r0, #0x3c]
700a42e2: 2801         	cmp	r0, #0x1
700a42e4: d10a         	bne	0x700a42fc <UART_udmaInitTxCh+0x4c> @ imm = #0x14
700a42e6: e7ff         	b	0x700a42e8 <UART_udmaInitTxCh+0x38> @ imm = #-0x2
;         chPrms.cqRingPrms.ringMem       = udmaChCfg->cqTxRingMem;
700a42e8: 983a         	ldr	r0, [sp, #0xe8]
700a42ea: 6a40         	ldr	r0, [r0, #0x24]
700a42ec: 902a         	str	r0, [sp, #0xa8]
;         chPrms.cqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a42ee: 983a         	ldr	r0, [sp, #0xe8]
700a42f0: 6b00         	ldr	r0, [r0, #0x30]
700a42f2: 902b         	str	r0, [sp, #0xac]
;         chPrms.cqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a42f4: 983a         	ldr	r0, [sp, #0xe8]
700a42f6: 6b40         	ldr	r0, [r0, #0x34]
700a42f8: 902d         	str	r0, [sp, #0xb4]
;     }
700a42fa: e7ff         	b	0x700a42fc <UART_udmaInitTxCh+0x4c> @ imm = #-0x2
;     txChHandle                      = udmaChCfg->txChHandle;
700a42fc: 983a         	ldr	r0, [sp, #0xe8]
700a42fe: 6840         	ldr	r0, [r0, #0x4]
700a4300: 9006         	str	r0, [sp, #0x18]
;     drvHandle                       = udmaChCfg->drvHandle;
700a4302: 983a         	ldr	r0, [sp, #0xe8]
700a4304: 6800         	ldr	r0, [r0]
700a4306: 9007         	str	r0, [sp, #0x1c]
;     retVal = Udma_chOpen(drvHandle, txChHandle, chType, &chPrms);
700a4308: 9807         	ldr	r0, [sp, #0x1c]
700a430a: 9906         	ldr	r1, [sp, #0x18]
700a430c: 9a38         	ldr	r2, [sp, #0xe0]
700a430e: ab1f         	add	r3, sp, #0x7c
700a4310: f7fd fa9e    	bl	0x700a1850 <Udma_chOpen> @ imm = #-0x2ac4
700a4314: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a4316: 9839         	ldr	r0, [sp, #0xe4]
700a4318: fab0 f080    	clz	r0, r0
700a431c: 0940         	lsrs	r0, r0, #0x5
700a431e: f641 4153    	movw	r1, #0x1c53
700a4322: f2c7 010b    	movt	r1, #0x700b
700a4326: 9103         	str	r1, [sp, #0xc]
700a4328: 466a         	mov	r2, sp
700a432a: 6011         	str	r1, [r2]
700a432c: f641 016d    	movw	r1, #0x186d
700a4330: f2c7 010b    	movt	r1, #0x700b
700a4334: 9104         	str	r1, [sp, #0x10]
700a4336: f641 520d    	movw	r2, #0x1d0d
700a433a: f2c7 020b    	movt	r2, #0x700b
700a433e: 9205         	str	r2, [sp, #0x14]
700a4340: 2398         	movs	r3, #0x98
700a4342: f006 fb75    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x66ea
;     UdmaChTxPrms_init(&txPrms, chType);
700a4346: 9938         	ldr	r1, [sp, #0xe0]
700a4348: a81a         	add	r0, sp, #0x68
700a434a: 9001         	str	r0, [sp, #0x4]
700a434c: f003 fd80    	bl	0x700a7e50 <UdmaChTxPrms_init> @ imm = #0x3b00
700a4350: 9901         	ldr	r1, [sp, #0x4]
;     retVal = Udma_chConfigTx(txChHandle, &txPrms);
700a4352: 9806         	ldr	r0, [sp, #0x18]
700a4354: f7fc f94c    	bl	0x700a05f0 <Udma_chConfigTx> @ imm = #-0x3d68
700a4358: 9b03         	ldr	r3, [sp, #0xc]
700a435a: 9904         	ldr	r1, [sp, #0x10]
700a435c: 9a05         	ldr	r2, [sp, #0x14]
700a435e: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a4360: 9839         	ldr	r0, [sp, #0xe4]
700a4362: fab0 f080    	clz	r0, r0
700a4366: 0940         	lsrs	r0, r0, #0x5
700a4368: 46ec         	mov	r12, sp
700a436a: f8cc 3000    	str.w	r3, [r12]
700a436e: 239d         	movs	r3, #0x9d
700a4370: f006 fb5e    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x66bc
;     eventHandle = udmaChCfg->cqTxEvtHandle;
700a4374: 983a         	ldr	r0, [sp, #0xe8]
700a4376: 68c0         	ldr	r0, [r0, #0xc]
700a4378: 9019         	str	r0, [sp, #0x64]
700a437a: a808         	add	r0, sp, #0x20
;     UdmaEventPrms_init(&eventPrms);
700a437c: 9002         	str	r0, [sp, #0x8]
700a437e: f007 fcc7    	bl	0x700abd10 <UdmaEventPrms_init> @ imm = #0x798e
700a4382: 2001         	movs	r0, #0x1
;     eventPrms.eventType         = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a4384: 9008         	str	r0, [sp, #0x20]
700a4386: 2002         	movs	r0, #0x2
;     eventPrms.eventMode         = UDMA_EVENT_MODE_SHARED;
700a4388: 9009         	str	r0, [sp, #0x24]
;     eventPrms.chHandle          = txChHandle;
700a438a: 9806         	ldr	r0, [sp, #0x18]
700a438c: 900a         	str	r0, [sp, #0x28]
;     eventPrms.controllerEventHandle = Udma_eventGetGlobalHandle(drvHandle);
700a438e: 9807         	ldr	r0, [sp, #0x1c]
700a4390: f008 fb96    	bl	0x700acac0 <Udma_eventGetGlobalHandle> @ imm = #0x872c
700a4394: 9a02         	ldr	r2, [sp, #0x8]
700a4396: 900c         	str	r0, [sp, #0x30]
;     eventPrms.eventCb           = &UART_udmaIsrTx;
700a4398: f249 50c1    	movw	r0, #0x95c1
700a439c: f2c7 000a    	movt	r0, #0x700a
700a43a0: 900d         	str	r0, [sp, #0x34]
;     eventPrms.appData           = (void *) hUart;
700a43a2: 983b         	ldr	r0, [sp, #0xec]
700a43a4: 900f         	str	r0, [sp, #0x3c]
;     retVal = Udma_eventRegister(drvHandle, eventHandle, &eventPrms);
700a43a6: 9807         	ldr	r0, [sp, #0x1c]
700a43a8: 9919         	ldr	r1, [sp, #0x64]
700a43aa: f7fa f969    	bl	0x7009e680 <Udma_eventRegister> @ imm = #-0x5d2e
700a43ae: 9b03         	ldr	r3, [sp, #0xc]
700a43b0: 9904         	ldr	r1, [sp, #0x10]
700a43b2: 9a05         	ldr	r2, [sp, #0x14]
700a43b4: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a43b6: 9839         	ldr	r0, [sp, #0xe4]
700a43b8: fab0 f080    	clz	r0, r0
700a43bc: 0940         	lsrs	r0, r0, #0x5
700a43be: 46ec         	mov	r12, sp
700a43c0: f8cc 3000    	str.w	r3, [r12]
700a43c4: 23a9         	movs	r3, #0xa9
700a43c6: f006 fb33    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x6666
;     return retVal;
700a43ca: 9839         	ldr	r0, [sp, #0xe4]
700a43cc: b03c         	add	sp, #0xf0
700a43ce: bd80         	pop	{r7, pc}

700a43d0 <Sciclient_rmIaValidateEvt>:
; {
700a43d0: b580         	push	{r7, lr}
700a43d2: b086         	sub	sp, #0x18
700a43d4: 4684         	mov	r12, r0
700a43d6: 9808         	ldr	r0, [sp, #0x20]
700a43d8: f8cd c014    	str.w	r12, [sp, #0x14]
700a43dc: f8ad 1012    	strh.w	r1, [sp, #0x12]
700a43e0: f8ad 2010    	strh.w	r2, [sp, #0x10]
700a43e4: f88d 300f    	strb.w	r3, [sp, #0xf]
700a43e8: f88d 000e    	strb.w	r0, [sp, #0xe]
700a43ec: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a43ee: 9002         	str	r0, [sp, #0x8]
;     if (evt >= inst->n_sevt) {
700a43f0: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a43f4: 9905         	ldr	r1, [sp, #0x14]
700a43f6: 8949         	ldrh	r1, [r1, #0xa]
700a43f8: 4288         	cmp	r0, r1
700a43fa: db04         	blt	0x700a4406 <Sciclient_rmIaValidateEvt+0x36> @ imm = #0x8
700a43fc: e7ff         	b	0x700a43fe <Sciclient_rmIaValidateEvt+0x2e> @ imm = #-0x2
700a43fe: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a4402: 9002         	str	r0, [sp, #0x8]
;     }
700a4404: e7ff         	b	0x700a4406 <Sciclient_rmIaValidateEvt+0x36> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a4406: 9802         	ldr	r0, [sp, #0x8]
700a4408: 2800         	cmp	r0, #0x0
700a440a: d16d         	bne	0x700a44e8 <Sciclient_rmIaValidateEvt+0x118> @ imm = #0xda
700a440c: e7ff         	b	0x700a440e <Sciclient_rmIaValidateEvt+0x3e> @ imm = #-0x2
;         entry_int_map_lo = (volatile uint32_t *)(inst->imap + SCICLIENT_IA_ENTRY_INTMAP_LO(evt));
700a440e: 9805         	ldr	r0, [sp, #0x14]
700a4410: 6840         	ldr	r0, [r0, #0x4]
700a4412: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a4416: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a441a: 9001         	str	r0, [sp, #0x4]
;         if (in_use == true) {
700a441c: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700a4420: 07c0         	lsls	r0, r0, #0x1f
700a4422: 2800         	cmp	r0, #0x0
700a4424: d047         	beq	0x700a44b6 <Sciclient_rmIaValidateEvt+0xe6> @ imm = #0x8e
700a4426: e7ff         	b	0x700a4428 <Sciclient_rmIaValidateEvt+0x58> @ imm = #-0x2
;             reg_vint = CSL_REG32_FEXT(entry_int_map_lo,
700a4428: 9801         	ldr	r0, [sp, #0x4]
700a442a: f64f 7100    	movw	r1, #0xff00
700a442e: f2c0 0101    	movt	r1, #0x1
700a4432: 2208         	movs	r2, #0x8
700a4434: f00a fd3c    	bl	0x700aeeb0 <CSL_REG32_FEXT_RAW> @ imm = #0xaa78
700a4438: f8ad 0002    	strh.w	r0, [sp, #0x2]
;             reg_sb = CSL_REG32_FEXT(entry_int_map_lo,
700a443c: 9801         	ldr	r0, [sp, #0x4]
700a443e: 213f         	movs	r1, #0x3f
700a4440: 2200         	movs	r2, #0x0
700a4442: f00a fd35    	bl	0x700aeeb0 <CSL_REG32_FEXT_RAW> @ imm = #0xaa6a
700a4446: f8ad 0000    	strh.w	r0, [sp]
;             if ((reg_vint == 0u) && (reg_sb == 0u)) {
700a444a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a444e: b9f0         	cbnz	r0, 0x700a448e <Sciclient_rmIaValidateEvt+0xbe> @ imm = #0x3c
700a4450: e7ff         	b	0x700a4452 <Sciclient_rmIaValidateEvt+0x82> @ imm = #-0x2
700a4452: f8bd 0000    	ldrh.w	r0, [sp]
700a4456: b9d0         	cbnz	r0, 0x700a448e <Sciclient_rmIaValidateEvt+0xbe> @ imm = #0x34
700a4458: e7ff         	b	0x700a445a <Sciclient_rmIaValidateEvt+0x8a> @ imm = #-0x2
;                 if ((vint != reg_vint) &&
700a445a: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a445e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a4462: 4288         	cmp	r0, r1
700a4464: d012         	beq	0x700a448c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x24
700a4466: e7ff         	b	0x700a4468 <Sciclient_rmIaValidateEvt+0x98> @ imm = #-0x2
;                     (vint_sb_index != reg_sb) &&
700a4468: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a446c: f8bd 1000    	ldrh.w	r1, [sp]
700a4470: 4288         	cmp	r0, r1
700a4472: d00b         	beq	0x700a448c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x16
700a4474: e7ff         	b	0x700a4476 <Sciclient_rmIaValidateEvt+0xa6> @ imm = #-0x2
;                     (evt != inst->v0_b0_evt)) {
700a4476: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a447a: 9905         	ldr	r1, [sp, #0x14]
700a447c: 8a89         	ldrh	r1, [r1, #0x14]
;                 if ((vint != reg_vint) &&
700a447e: 4288         	cmp	r0, r1
700a4480: d004         	beq	0x700a448c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x8
700a4482: e7ff         	b	0x700a4484 <Sciclient_rmIaValidateEvt+0xb4> @ imm = #-0x2
700a4484: f06f 0001    	mvn	r0, #0x1
;                     r = CSL_EBADARGS;
700a4488: 9002         	str	r0, [sp, #0x8]
;                 }
700a448a: e7ff         	b	0x700a448c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #-0x2
;             } else {
700a448c: e012         	b	0x700a44b4 <Sciclient_rmIaValidateEvt+0xe4> @ imm = #0x24
;                 if ((vint != reg_vint) &&
700a448e: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a4492: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a4496: 4288         	cmp	r0, r1
700a4498: d00b         	beq	0x700a44b2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #0x16
700a449a: e7ff         	b	0x700a449c <Sciclient_rmIaValidateEvt+0xcc> @ imm = #-0x2
;                     (vint_sb_index != reg_sb)) {
700a449c: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a44a0: f8bd 1000    	ldrh.w	r1, [sp]
;                 if ((vint != reg_vint) &&
700a44a4: 4288         	cmp	r0, r1
700a44a6: d004         	beq	0x700a44b2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #0x8
700a44a8: e7ff         	b	0x700a44aa <Sciclient_rmIaValidateEvt+0xda> @ imm = #-0x2
700a44aa: f06f 0001    	mvn	r0, #0x1
;                     r = CSL_EBADARGS;
700a44ae: 9002         	str	r0, [sp, #0x8]
;                 }
700a44b0: e7ff         	b	0x700a44b2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #-0x2
700a44b2: e7ff         	b	0x700a44b4 <Sciclient_rmIaValidateEvt+0xe4> @ imm = #-0x2
;         } else {
700a44b4: e017         	b	0x700a44e6 <Sciclient_rmIaValidateEvt+0x116> @ imm = #0x2e
;             if (((CSL_REG32_RD(entry_int_map_lo) != 0u) &&
700a44b6: 9801         	ldr	r0, [sp, #0x4]
700a44b8: f00b fa3a    	bl	0x700af930 <CSL_REG32_RD_RAW> @ imm = #0xb474
700a44bc: b138         	cbz	r0, 0x700a44ce <Sciclient_rmIaValidateEvt+0xfe> @ imm = #0xe
700a44be: e7ff         	b	0x700a44c0 <Sciclient_rmIaValidateEvt+0xf0> @ imm = #-0x2
;                  (Sciclient_rmIaEvtRomMapped(inst, evt) == false)) ||
700a44c0: 9805         	ldr	r0, [sp, #0x14]
700a44c2: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a44c6: f005 fcb3    	bl	0x700a9e30 <Sciclient_rmIaEvtRomMapped> @ imm = #0x5966
700a44ca: b138         	cbz	r0, 0x700a44dc <Sciclient_rmIaValidateEvt+0x10c> @ imm = #0xe
700a44cc: e7ff         	b	0x700a44ce <Sciclient_rmIaValidateEvt+0xfe> @ imm = #-0x2
;                 (evt == inst->v0_b0_evt)) {
700a44ce: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a44d2: 9905         	ldr	r1, [sp, #0x14]
700a44d4: 8a89         	ldrh	r1, [r1, #0x14]
;             if (((CSL_REG32_RD(entry_int_map_lo) != 0u) &&
700a44d6: 4288         	cmp	r0, r1
700a44d8: d104         	bne	0x700a44e4 <Sciclient_rmIaValidateEvt+0x114> @ imm = #0x8
700a44da: e7ff         	b	0x700a44dc <Sciclient_rmIaValidateEvt+0x10c> @ imm = #-0x2
700a44dc: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a44e0: 9002         	str	r0, [sp, #0x8]
;             }
700a44e2: e7ff         	b	0x700a44e4 <Sciclient_rmIaValidateEvt+0x114> @ imm = #-0x2
700a44e4: e7ff         	b	0x700a44e6 <Sciclient_rmIaValidateEvt+0x116> @ imm = #-0x2
;     }
700a44e6: e7ff         	b	0x700a44e8 <Sciclient_rmIaValidateEvt+0x118> @ imm = #-0x2
;     return r;
700a44e8: 9802         	ldr	r0, [sp, #0x8]
700a44ea: b006         	add	sp, #0x18
700a44ec: bd80         	pop	{r7, pc}
700a44ee: 0000         	movs	r0, r0

700a44f0 <Sciclient_rmIrqVintAdd>:
; {
700a44f0: b580         	push	{r7, lr}
700a44f2: b08c         	sub	sp, #0x30
700a44f4: 900b         	str	r0, [sp, #0x2c]
700a44f6: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a44f8: 900a         	str	r0, [sp, #0x28]
;     bool cfg_new_mapping = false;
700a44fa: f88d 0026    	strb.w	r0, [sp, #0x26]
;     bool cfg_whole_route = false;
700a44fe: f88d 0025    	strb.w	r0, [sp, #0x25]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a4502: 9008         	str	r0, [sp, #0x20]
;     r = Sciclient_rmIrqIsVintRouteSet(cfg, &vint_used);
700a4504: 980b         	ldr	r0, [sp, #0x2c]
700a4506: f10d 0127    	add.w	r1, sp, #0x27
700a450a: f002 fd99    	bl	0x700a7040 <Sciclient_rmIrqIsVintRouteSet> @ imm = #0x2b32
700a450e: 900a         	str	r0, [sp, #0x28]
;     if (r == SystemP_SUCCESS) {
700a4510: 980a         	ldr	r0, [sp, #0x28]
700a4512: b9a0         	cbnz	r0, 0x700a453e <Sciclient_rmIrqVintAdd+0x4e> @ imm = #0x28
700a4514: e7ff         	b	0x700a4516 <Sciclient_rmIrqVintAdd+0x26> @ imm = #-0x2
;         if ((vint_used == true) ||
700a4516: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a451a: 07c0         	lsls	r0, r0, #0x1f
700a451c: b930         	cbnz	r0, 0x700a452c <Sciclient_rmIrqVintAdd+0x3c> @ imm = #0xc
700a451e: e7ff         	b	0x700a4520 <Sciclient_rmIrqVintAdd+0x30> @ imm = #-0x2
;             (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg->valid_params) ==
700a4520: 980b         	ldr	r0, [sp, #0x2c]
700a4522: 6800         	ldr	r0, [r0]
700a4524: f007 f8e4    	bl	0x700ab6f0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0x71c8
;         if ((vint_used == true) ||
700a4528: b120         	cbz	r0, 0x700a4534 <Sciclient_rmIrqVintAdd+0x44> @ imm = #0x8
700a452a: e7ff         	b	0x700a452c <Sciclient_rmIrqVintAdd+0x3c> @ imm = #-0x2
700a452c: 2001         	movs	r0, #0x1
;             cfg_new_mapping = true;
700a452e: f88d 0026    	strb.w	r0, [sp, #0x26]
;         } else {
700a4532: e003         	b	0x700a453c <Sciclient_rmIrqVintAdd+0x4c> @ imm = #0x6
700a4534: 2001         	movs	r0, #0x1
;             cfg_whole_route = true;
700a4536: f88d 0025    	strb.w	r0, [sp, #0x25]
700a453a: e7ff         	b	0x700a453c <Sciclient_rmIrqVintAdd+0x4c> @ imm = #-0x2
;     }
700a453c: e7ff         	b	0x700a453e <Sciclient_rmIrqVintAdd+0x4e> @ imm = #-0x2
;     if (cfg_new_mapping == true) {
700a453e: f89d 0026    	ldrb.w	r0, [sp, #0x26]
700a4542: 07c0         	lsls	r0, r0, #0x1f
700a4544: 2800         	cmp	r0, #0x0
700a4546: d04c         	beq	0x700a45e2 <Sciclient_rmIrqVintAdd+0xf2> @ imm = #0x98
700a4548: e7ff         	b	0x700a454a <Sciclient_rmIrqVintAdd+0x5a> @ imm = #-0x2
700a454a: 203c         	movs	r0, #0x3c
700a454c: f2c8 0000    	movt	r0, #0x8000
;         req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a4550: 9003         	str	r0, [sp, #0xc]
;         req.secondary_host = cfg->host;
700a4552: 980b         	ldr	r0, [sp, #0x2c]
700a4554: 7900         	ldrb	r0, [r0, #0x4]
700a4556: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         req.src_id = cfg->s_id;
700a455a: 980b         	ldr	r0, [sp, #0x2c]
700a455c: 88c0         	ldrh	r0, [r0, #0x6]
700a455e: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         req.src_index = cfg->s_idx;
700a4562: 980b         	ldr	r0, [sp, #0x2c]
700a4564: 8900         	ldrh	r0, [r0, #0x8]
700a4566: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         req.ia_id = cfg->s_ia;
700a456a: 980b         	ldr	r0, [sp, #0x2c]
700a456c: 8a00         	ldrh	r0, [r0, #0x10]
700a456e: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         req.vint = cfg->vint;
700a4572: 980b         	ldr	r0, [sp, #0x2c]
700a4574: 8a40         	ldrh	r0, [r0, #0x12]
700a4576: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         req.global_event = cfg->global_evt;
700a457a: 980b         	ldr	r0, [sp, #0x2c]
700a457c: 89c0         	ldrh	r0, [r0, #0xe]
700a457e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         req.vint_status_bit_index = cfg->vint_sb;
700a4582: 980b         	ldr	r0, [sp, #0x2c]
700a4584: 7d00         	ldrb	r0, [r0, #0x14]
700a4586: f88d 001e    	strb.w	r0, [sp, #0x1e]
;                                   cfg->set_resp,
700a458a: 980b         	ldr	r0, [sp, #0x2c]
700a458c: 6981         	ldr	r1, [r0, #0x18]
700a458e: a801         	add	r0, sp, #0x4
700a4590: f04f 32ff    	mov.w	r2, #0xffffffff
;         r = Sciclient_rmIrqSetRaw(&req,
700a4594: f008 f82c    	bl	0x700ac5f0 <Sciclient_rmIrqSetRaw> @ imm = #0x8058
700a4598: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a459a: 980a         	ldr	r0, [sp, #0x28]
700a459c: bb00         	cbnz	r0, 0x700a45e0 <Sciclient_rmIrqVintAdd+0xf0> @ imm = #0x40
700a459e: e7ff         	b	0x700a45a0 <Sciclient_rmIrqVintAdd+0xb0> @ imm = #-0x2
;             ia_inst = Sciclient_rmIaGetInst(cfg->s_ia);
700a45a0: 980b         	ldr	r0, [sp, #0x2c]
700a45a2: 8a00         	ldrh	r0, [r0, #0x10]
700a45a4: f007 fea4    	bl	0x700ac2f0 <Sciclient_rmIaGetInst> @ imm = #0x7d48
700a45a8: 9008         	str	r0, [sp, #0x20]
;             if (ia_inst != NULL) {
700a45aa: 9808         	ldr	r0, [sp, #0x20]
700a45ac: b1b8         	cbz	r0, 0x700a45de <Sciclient_rmIrqVintAdd+0xee> @ imm = #0x2e
700a45ae: e7ff         	b	0x700a45b0 <Sciclient_rmIrqVintAdd+0xc0> @ imm = #-0x2
;                 ia_inst->vint_usage_count[cfg->vint]++;
700a45b0: 9808         	ldr	r0, [sp, #0x20]
700a45b2: 6901         	ldr	r1, [r0, #0x10]
700a45b4: 980b         	ldr	r0, [sp, #0x2c]
700a45b6: 8a42         	ldrh	r2, [r0, #0x12]
700a45b8: 5c88         	ldrb	r0, [r1, r2]
700a45ba: 3001         	adds	r0, #0x1
700a45bc: 5488         	strb	r0, [r1, r2]
;                 if ((cfg->vint == 0) && (cfg->vint_sb == 0)) {
700a45be: 980b         	ldr	r0, [sp, #0x2c]
700a45c0: 8a40         	ldrh	r0, [r0, #0x12]
700a45c2: b958         	cbnz	r0, 0x700a45dc <Sciclient_rmIrqVintAdd+0xec> @ imm = #0x16
700a45c4: e7ff         	b	0x700a45c6 <Sciclient_rmIrqVintAdd+0xd6> @ imm = #-0x2
700a45c6: 980b         	ldr	r0, [sp, #0x2c]
700a45c8: 7d00         	ldrb	r0, [r0, #0x14]
700a45ca: b938         	cbnz	r0, 0x700a45dc <Sciclient_rmIrqVintAdd+0xec> @ imm = #0xe
700a45cc: e7ff         	b	0x700a45ce <Sciclient_rmIrqVintAdd+0xde> @ imm = #-0x2
;                     ia_inst->v0_b0_evt = cfg->global_evt - ia_inst->sevt_offset;
700a45ce: 980b         	ldr	r0, [sp, #0x2c]
700a45d0: 89c0         	ldrh	r0, [r0, #0xe]
700a45d2: 9908         	ldr	r1, [sp, #0x20]
700a45d4: 890a         	ldrh	r2, [r1, #0x8]
700a45d6: 1a80         	subs	r0, r0, r2
700a45d8: 8288         	strh	r0, [r1, #0x14]
;                 }
700a45da: e7ff         	b	0x700a45dc <Sciclient_rmIrqVintAdd+0xec> @ imm = #-0x2
;             }
700a45dc: e7ff         	b	0x700a45de <Sciclient_rmIrqVintAdd+0xee> @ imm = #-0x2
;         }
700a45de: e7ff         	b	0x700a45e0 <Sciclient_rmIrqVintAdd+0xf0> @ imm = #-0x2
;     }
700a45e0: e7ff         	b	0x700a45e2 <Sciclient_rmIrqVintAdd+0xf2> @ imm = #-0x2
;     if (cfg_whole_route == true) {
700a45e2: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a45e6: 07c0         	lsls	r0, r0, #0x1f
700a45e8: b170         	cbz	r0, 0x700a4608 <Sciclient_rmIrqVintAdd+0x118> @ imm = #0x1c
700a45ea: e7ff         	b	0x700a45ec <Sciclient_rmIrqVintAdd+0xfc> @ imm = #-0x2
;         r = Sciclient_rmIrqFindRoute(cfg);
700a45ec: 980b         	ldr	r0, [sp, #0x2c]
700a45ee: f7f9 fcd7    	bl	0x7009dfa0 <Sciclient_rmIrqFindRoute> @ imm = #-0x6652
700a45f2: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a45f4: 980a         	ldr	r0, [sp, #0x28]
700a45f6: b930         	cbnz	r0, 0x700a4606 <Sciclient_rmIrqVintAdd+0x116> @ imm = #0xc
700a45f8: e7ff         	b	0x700a45fa <Sciclient_rmIrqVintAdd+0x10a> @ imm = #-0x2
;             r = Sciclient_rmIrqProgramRoute(cfg, true);
700a45fa: 980b         	ldr	r0, [sp, #0x2c]
700a45fc: 2101         	movs	r1, #0x1
700a45fe: f7fc fbe7    	bl	0x700a0dd0 <Sciclient_rmIrqProgramRoute> @ imm = #-0x3832
700a4602: 900a         	str	r0, [sp, #0x28]
;         }
700a4604: e7ff         	b	0x700a4606 <Sciclient_rmIrqVintAdd+0x116> @ imm = #-0x2
;     }
700a4606: e7ff         	b	0x700a4608 <Sciclient_rmIrqVintAdd+0x118> @ imm = #-0x2
;     return r;
700a4608: 980a         	ldr	r0, [sp, #0x28]
700a460a: b00c         	add	sp, #0x30
700a460c: bd80         	pop	{r7, pc}
700a460e: 0000         	movs	r0, r0

700a4610 <TaskP_loadUpdateAll>:
; {
700a4610: b580         	push	{r7, lr}
700a4612: b090         	sub	sp, #0x40
;     vTaskSuspendAll();
700a4614: f00b f94c    	bl	0x700af8b0 <vTaskSuspendAll> @ imm = #0xb298
700a4618: 2000         	movs	r0, #0x0
;     for(i=0; i<TaskP_REGISTRY_MAX_ENTRIES; i++)
700a461a: 9005         	str	r0, [sp, #0x14]
700a461c: e7ff         	b	0x700a461e <TaskP_loadUpdateAll+0xe> @ imm = #-0x2
700a461e: 9805         	ldr	r0, [sp, #0x14]
700a4620: 281f         	cmp	r0, #0x1f
700a4622: d837         	bhi	0x700a4694 <TaskP_loadUpdateAll+0x84> @ imm = #0x6e
700a4624: e7ff         	b	0x700a4626 <TaskP_loadUpdateAll+0x16> @ imm = #-0x2
;         if(gTaskP_ctrl.taskRegistry[i]!=NULL)
700a4626: 9905         	ldr	r1, [sp, #0x14]
700a4628: f644 5078    	movw	r0, #0x4d78
700a462c: f2c7 0008    	movt	r0, #0x7008
700a4630: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a4634: b348         	cbz	r0, 0x700a468a <TaskP_loadUpdateAll+0x7a> @ imm = #0x52
700a4636: e7ff         	b	0x700a4638 <TaskP_loadUpdateAll+0x28> @ imm = #-0x2
;             taskObj = gTaskP_ctrl.taskRegistry[i];
700a4638: 9905         	ldr	r1, [sp, #0x14]
700a463a: f644 5078    	movw	r0, #0x4d78
700a463e: f2c7 0008    	movt	r0, #0x7008
700a4642: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a4646: 900f         	str	r0, [sp, #0x3c]
;             vTaskGetInfo(taskObj->taskHndl, &taskStatus, pdFALSE, eReady);
700a4648: 980f         	ldr	r0, [sp, #0x3c]
700a464a: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a464e: a906         	add	r1, sp, #0x18
700a4650: 2200         	movs	r2, #0x0
700a4652: 2301         	movs	r3, #0x1
700a4654: f001 fb34    	bl	0x700a5cc0 <vTaskGetInfo> @ imm = #0x1668
;             delta = TaskP_calcCounterDiff(taskStatus.ulRunTimeCounter, taskObj->lastRunTime);
700a4658: 980c         	ldr	r0, [sp, #0x30]
700a465a: 990f         	ldr	r1, [sp, #0x3c]
700a465c: f8d1 108c    	ldr.w	r1, [r1, #0x8c]
700a4660: f00a f96e    	bl	0x700ae940 <TaskP_calcCounterDiff> @ imm = #0xa2dc
700a4664: 9004         	str	r0, [sp, #0x10]
;             taskObj->accRunTime += delta;
700a4666: 9b04         	ldr	r3, [sp, #0x10]
700a4668: 990f         	ldr	r1, [sp, #0x3c]
700a466a: f8d1 2090    	ldr.w	r2, [r1, #0x90]
700a466e: f8d1 0094    	ldr.w	r0, [r1, #0x94]
700a4672: 18d2         	adds	r2, r2, r3
700a4674: f140 0000    	adc	r0, r0, #0x0
700a4678: f8c1 2090    	str.w	r2, [r1, #0x90]
700a467c: f8c1 0094    	str.w	r0, [r1, #0x94]
;             taskObj->lastRunTime = taskStatus.ulRunTimeCounter;
700a4680: 980c         	ldr	r0, [sp, #0x30]
700a4682: 990f         	ldr	r1, [sp, #0x3c]
700a4684: f8c1 008c    	str.w	r0, [r1, #0x8c]
;         }
700a4688: e7ff         	b	0x700a468a <TaskP_loadUpdateAll+0x7a> @ imm = #-0x2
;     }
700a468a: e7ff         	b	0x700a468c <TaskP_loadUpdateAll+0x7c> @ imm = #-0x2
;     for(i=0; i<TaskP_REGISTRY_MAX_ENTRIES; i++)
700a468c: 9805         	ldr	r0, [sp, #0x14]
700a468e: 3001         	adds	r0, #0x1
700a4690: 9005         	str	r0, [sp, #0x14]
700a4692: e7c4         	b	0x700a461e <TaskP_loadUpdateAll+0xe> @ imm = #-0x78
;     idleTskHndl = xTaskGetIdleTaskHandle();
700a4694: f00b f97c    	bl	0x700af990 <xTaskGetIdleTaskHandle> @ imm = #0xb2f8
700a4698: 9002         	str	r0, [sp, #0x8]
;     if(idleTskHndl != NULL)
700a469a: 9802         	ldr	r0, [sp, #0x8]
700a469c: b310         	cbz	r0, 0x700a46e4 <TaskP_loadUpdateAll+0xd4> @ imm = #0x44
700a469e: e7ff         	b	0x700a46a0 <TaskP_loadUpdateAll+0x90> @ imm = #-0x2
;         vTaskGetInfo(idleTskHndl, &taskStatus, pdFALSE, eReady);
700a46a0: 9802         	ldr	r0, [sp, #0x8]
700a46a2: a906         	add	r1, sp, #0x18
700a46a4: 2200         	movs	r2, #0x0
700a46a6: 2301         	movs	r3, #0x1
700a46a8: f001 fb0a    	bl	0x700a5cc0 <vTaskGetInfo> @ imm = #0x1614
;         delta = TaskP_calcCounterDiff(taskStatus.ulRunTimeCounter, gTaskP_ctrl.idleTskLastRunTime);
700a46ac: 980c         	ldr	r0, [sp, #0x30]
700a46ae: f644 5178    	movw	r1, #0x4d78
700a46b2: f2c7 0108    	movt	r1, #0x7008
700a46b6: 9101         	str	r1, [sp, #0x4]
700a46b8: f8d1 1090    	ldr.w	r1, [r1, #0x90]
700a46bc: f00a f940    	bl	0x700ae940 <TaskP_calcCounterDiff> @ imm = #0xa280
700a46c0: 9901         	ldr	r1, [sp, #0x4]
700a46c2: 9004         	str	r0, [sp, #0x10]
;         gTaskP_ctrl.idleTskAccRunTime += delta;
700a46c4: 9b04         	ldr	r3, [sp, #0x10]
700a46c6: f8d1 2098    	ldr.w	r2, [r1, #0x98]
700a46ca: f8d1 009c    	ldr.w	r0, [r1, #0x9c]
700a46ce: 18d2         	adds	r2, r2, r3
700a46d0: f140 0000    	adc	r0, r0, #0x0
700a46d4: f8c1 2098    	str.w	r2, [r1, #0x98]
700a46d8: f8c1 009c    	str.w	r0, [r1, #0x9c]
;         gTaskP_ctrl.idleTskLastRunTime = taskStatus.ulRunTimeCounter;
700a46dc: 980c         	ldr	r0, [sp, #0x30]
700a46de: f8c1 0090    	str.w	r0, [r1, #0x90]
;     }
700a46e2: e7ff         	b	0x700a46e4 <TaskP_loadUpdateAll+0xd4> @ imm = #-0x2
;     curTotalTime = portGET_RUN_TIME_COUNTER_VALUE();
700a46e4: f00b f85c    	bl	0x700af7a0 <uiPortGetRunTimeCounterValue> @ imm = #0xb0b8
700a46e8: 9003         	str	r0, [sp, #0xc]
;     delta = TaskP_calcCounterDiff(curTotalTime, gTaskP_ctrl.lastTotalTime);
700a46ea: 9803         	ldr	r0, [sp, #0xc]
700a46ec: f644 5178    	movw	r1, #0x4d78
700a46f0: f2c7 0108    	movt	r1, #0x7008
700a46f4: 9100         	str	r1, [sp]
700a46f6: f8d1 1080    	ldr.w	r1, [r1, #0x80]
700a46fa: f00a f921    	bl	0x700ae940 <TaskP_calcCounterDiff> @ imm = #0xa242
700a46fe: 9900         	ldr	r1, [sp]
700a4700: 9004         	str	r0, [sp, #0x10]
;     gTaskP_ctrl.accTotalTime += delta;
700a4702: 9b04         	ldr	r3, [sp, #0x10]
700a4704: f8d1 2088    	ldr.w	r2, [r1, #0x88]
700a4708: f8d1 008c    	ldr.w	r0, [r1, #0x8c]
700a470c: 18d2         	adds	r2, r2, r3
700a470e: f140 0000    	adc	r0, r0, #0x0
700a4712: f8c1 2088    	str.w	r2, [r1, #0x88]
700a4716: f8c1 008c    	str.w	r0, [r1, #0x8c]
;     gTaskP_ctrl.lastTotalTime = curTotalTime;
700a471a: 9803         	ldr	r0, [sp, #0xc]
700a471c: f8c1 0080    	str.w	r0, [r1, #0x80]
;     (void)xTaskResumeAll();
700a4720: f7fd fcb6    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0x2694
; }
700a4724: b010         	add	sp, #0x40
700a4726: bd80         	pop	{r7, pc}

700a4728 <__udivmoddi4>:
700a4728: e1530001     	cmp	r3, r1
700a472c: 01520000     	cmpeq	r2, r0
700a4730: 9a000007     	bls	0x700a4754 <__udivmoddi4+0x2c> @ imm = #0x1c
700a4734: e59d2000     	ldr	r2, [sp]
700a4738: e3520000     	cmp	r2, #0
700a473c: 0a000001     	beq	0x700a4748 <__udivmoddi4+0x20> @ imm = #0x4
700a4740: e5820000     	str	r0, [r2]
700a4744: e5821004     	str	r1, [r2, #0x4]
700a4748: e3b01000     	movs	r1, #0
700a474c: e3b00000     	movs	r0, #0
700a4750: e12fff1e     	bx	lr
700a4754: e3530000     	cmp	r3, #0
700a4758: 03520000     	cmpeq	r2, #0
700a475c: 1a00000d     	bne	0x700a4798 <__udivmoddi4+0x70> @ imm = #0x34
700a4760: e59d2000     	ldr	r2, [sp]
700a4764: e3520000     	cmp	r2, #0
700a4768: 0a000001     	beq	0x700a4774 <__udivmoddi4+0x4c> @ imm = #0x4
700a476c: e5820000     	str	r0, [r2]
700a4770: e5821004     	str	r1, [r2, #0x4]
700a4774: e1b02000     	movs	r2, r0
700a4778: e1b03001     	movs	r3, r1
700a477c: e3b01000     	movs	r1, #0
700a4780: e3b00000     	movs	r0, #0
700a4784: e3530000     	cmp	r3, #0
700a4788: 03520000     	cmpeq	r2, #0
700a478c: 11e01001     	mvnne	r1, r1
700a4790: 11e00000     	mvnne	r0, r0
700a4794: ea002cb1     	b	0x700afa60 <__aeabi_ldiv0> @ imm = #0xb2c4
700a4798: e92d40f0     	push	{r4, r5, r6, r7, lr}
700a479c: e1a04003     	mov	r4, r3
700a47a0: e1a05002     	mov	r5, r2
700a47a4: e1a03001     	mov	r3, r1
700a47a8: e1a02000     	mov	r2, r0
700a47ac: e3b00000     	movs	r0, #0
700a47b0: e3b01000     	movs	r1, #0
700a47b4: e16f6f14     	clz	r6, r4
700a47b8: e3560020     	cmp	r6, #32
700a47bc: 016f6f15     	clzeq	r6, r5
700a47c0: 02866020     	addeq	r6, r6, #32
700a47c4: e16f7f13     	clz	r7, r3
700a47c8: e3570020     	cmp	r7, #32
700a47cc: 016f7f12     	clzeq	r7, r2
700a47d0: 02877020     	addeq	r7, r7, #32
700a47d4: e0566007     	subs	r6, r6, r7
700a47d8: e2567020     	subs	r7, r6, #32
700a47dc: 21a04715     	lslhs	r4, r5, r7
700a47e0: 23a05000     	movhs	r5, #0
700a47e4: 32677000     	rsblo	r7, r7, #0
700a47e8: 31a04614     	lsllo	r4, r4, r6
700a47ec: 31a07735     	lsrlo	r7, r5, r7
700a47f0: 31844007     	orrlo	r4, r4, r7
700a47f4: 31a05615     	lsllo	r5, r5, r6
700a47f8: e1530004     	cmp	r3, r4
700a47fc: 01520005     	cmpeq	r2, r5
700a4800: 3a000001     	blo	0x700a480c <__udivmoddi4+0xe4> @ imm = #0x4
700a4804: e0522005     	subs	r2, r2, r5
700a4808: e0d33004     	sbcs	r3, r3, r4
700a480c: e0b00000     	adcs	r0, r0, r0
700a4810: e0b11001     	adcs	r1, r1, r1
700a4814: e1b050a5     	lsrs	r5, r5, #1
700a4818: e1855f84     	orr	r5, r5, r4, lsl #31
700a481c: e1b040a4     	lsrs	r4, r4, #1
700a4820: e2566001     	subs	r6, r6, #1
700a4824: 5afffff3     	bpl	0x700a47f8 <__udivmoddi4+0xd0> @ imm = #-0x34
700a4828: e59d7014     	ldr	r7, [sp, #0x14]
700a482c: e3570000     	cmp	r7, #0
700a4830: 0a000001     	beq	0x700a483c <__udivmoddi4+0x114> @ imm = #0x4
700a4834: e5872000     	str	r2, [r7]
700a4838: e5873004     	str	r3, [r7, #0x4]
700a483c: e8bd80f0     	pop	{r4, r5, r6, r7, pc}

700a4840 <CSL_bcdmaChanOpDecChanStats>:
; {
700a4840: b580         	push	{r7, lr}
700a4842: b088         	sub	sp, #0x20
700a4844: 9007         	str	r0, [sp, #0x1c]
700a4846: 9106         	str	r1, [sp, #0x18]
700a4848: 9205         	str	r2, [sp, #0x14]
700a484a: 9304         	str	r3, [sp, #0x10]
700a484c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a484e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a4850: 9804         	ldr	r0, [sp, #0x10]
700a4852: b920         	cbnz	r0, 0x700a485e <CSL_bcdmaChanOpDecChanStats+0x1e> @ imm = #0x8
700a4854: e7ff         	b	0x700a4856 <CSL_bcdmaChanOpDecChanStats+0x16> @ imm = #-0x2
700a4856: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a485a: 9003         	str	r0, [sp, #0xc]
;     }
700a485c: e078         	b	0x700a4950 <CSL_bcdmaChanOpDecChanStats+0x110> @ imm = #0xf0
;         CSL_BcdmaChanStats *pChanStats = (CSL_BcdmaChanStats *)pOpData;
700a485e: 9804         	ldr	r0, [sp, #0x10]
700a4860: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a4862: 9806         	ldr	r0, [sp, #0x18]
700a4864: 9001         	str	r0, [sp, #0x4]
700a4866: b140         	cbz	r0, 0x700a487a <CSL_bcdmaChanOpDecChanStats+0x3a> @ imm = #0x10
700a4868: e7ff         	b	0x700a486a <CSL_bcdmaChanOpDecChanStats+0x2a> @ imm = #-0x2
700a486a: 9801         	ldr	r0, [sp, #0x4]
700a486c: 2801         	cmp	r0, #0x1
700a486e: d026         	beq	0x700a48be <CSL_bcdmaChanOpDecChanStats+0x7e> @ imm = #0x4c
700a4870: e7ff         	b	0x700a4872 <CSL_bcdmaChanOpDecChanStats+0x32> @ imm = #-0x2
700a4872: 9801         	ldr	r0, [sp, #0x4]
700a4874: 2802         	cmp	r0, #0x2
700a4876: d044         	beq	0x700a4902 <CSL_bcdmaChanOpDecChanStats+0xc2> @ imm = #0x88
700a4878: e065         	b	0x700a4946 <CSL_bcdmaChanOpDecChanStats+0x106> @ imm = #0xca
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a487a: 9807         	ldr	r0, [sp, #0x1c]
700a487c: 6880         	ldr	r0, [r0, #0x8]
700a487e: 9905         	ldr	r1, [sp, #0x14]
700a4880: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4884: f500 6080    	add.w	r0, r0, #0x400
700a4888: 9902         	ldr	r1, [sp, #0x8]
700a488a: 6809         	ldr	r1, [r1]
700a488c: f7f7 fcc0    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x8680
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->txPayloadByteCnt );
700a4890: 9807         	ldr	r0, [sp, #0x1c]
700a4892: 6880         	ldr	r0, [r0, #0x8]
700a4894: 9905         	ldr	r1, [sp, #0x14]
700a4896: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a489a: f500 6081    	add.w	r0, r0, #0x408
700a489e: 9902         	ldr	r1, [sp, #0x8]
700a48a0: 6849         	ldr	r1, [r1, #0x4]
700a48a2: f7f7 fcb5    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x8696
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->txStartedByteCnt );
700a48a6: 9807         	ldr	r0, [sp, #0x1c]
700a48a8: 6880         	ldr	r0, [r0, #0x8]
700a48aa: 9905         	ldr	r1, [sp, #0x14]
700a48ac: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a48b0: f500 6082    	add.w	r0, r0, #0x410
700a48b4: 9902         	ldr	r1, [sp, #0x8]
700a48b6: 6889         	ldr	r1, [r1, #0x8]
700a48b8: f7f7 fcaa    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x86ac
;                 break;
700a48bc: e047         	b	0x700a494e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x8e
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a48be: 9807         	ldr	r0, [sp, #0x1c]
700a48c0: 6900         	ldr	r0, [r0, #0x10]
700a48c2: 9905         	ldr	r1, [sp, #0x14]
700a48c4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a48c8: f500 6080    	add.w	r0, r0, #0x400
700a48cc: 9902         	ldr	r1, [sp, #0x8]
700a48ce: 6809         	ldr	r1, [r1]
700a48d0: f7f7 fc9e    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x86c4
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->txPayloadByteCnt );
700a48d4: 9807         	ldr	r0, [sp, #0x1c]
700a48d6: 6900         	ldr	r0, [r0, #0x10]
700a48d8: 9905         	ldr	r1, [sp, #0x14]
700a48da: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a48de: f500 6081    	add.w	r0, r0, #0x408
700a48e2: 9902         	ldr	r1, [sp, #0x8]
700a48e4: 6849         	ldr	r1, [r1, #0x4]
700a48e6: f7f7 fc93    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x86da
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->txStartedByteCnt );
700a48ea: 9807         	ldr	r0, [sp, #0x1c]
700a48ec: 6900         	ldr	r0, [r0, #0x10]
700a48ee: 9905         	ldr	r1, [sp, #0x14]
700a48f0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a48f4: f500 6082    	add.w	r0, r0, #0x410
700a48f8: 9902         	ldr	r1, [sp, #0x8]
700a48fa: 6889         	ldr	r1, [r1, #0x8]
700a48fc: f7f7 fc88    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x86f0
;                 break;
700a4900: e025         	b	0x700a494e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x4a
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a4902: 9807         	ldr	r0, [sp, #0x1c]
700a4904: 6980         	ldr	r0, [r0, #0x18]
700a4906: 9905         	ldr	r1, [sp, #0x14]
700a4908: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a490c: f500 6080    	add.w	r0, r0, #0x400
700a4910: 9902         	ldr	r1, [sp, #0x8]
700a4912: 6809         	ldr	r1, [r1]
700a4914: f7f7 fc7c    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x8708
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->rxPayloadByteCnt );
700a4918: 9807         	ldr	r0, [sp, #0x1c]
700a491a: 6980         	ldr	r0, [r0, #0x18]
700a491c: 9905         	ldr	r1, [sp, #0x14]
700a491e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4922: f500 6081    	add.w	r0, r0, #0x408
700a4926: 9902         	ldr	r1, [sp, #0x8]
700a4928: 68c9         	ldr	r1, [r1, #0xc]
700a492a: f7f7 fc71    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x871e
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->rxStartedByteCnt );
700a492e: 9807         	ldr	r0, [sp, #0x1c]
700a4930: 6980         	ldr	r0, [r0, #0x18]
700a4932: 9905         	ldr	r1, [sp, #0x14]
700a4934: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4938: f500 6082    	add.w	r0, r0, #0x410
700a493c: 9902         	ldr	r1, [sp, #0x8]
700a493e: 6909         	ldr	r1, [r1, #0x10]
700a4940: f7f7 fc66    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x8734
;                 break;
700a4944: e003         	b	0x700a494e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x6
700a4946: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a494a: 9003         	str	r0, [sp, #0xc]
;                 break;
700a494c: e7ff         	b	0x700a494e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #-0x2
700a494e: e7ff         	b	0x700a4950 <CSL_bcdmaChanOpDecChanStats+0x110> @ imm = #-0x2
;     return retVal;
700a4950: 9803         	ldr	r0, [sp, #0xc]
700a4952: b008         	add	sp, #0x20
700a4954: bd80         	pop	{r7, pc}
		...
700a495e: 0000         	movs	r0, r0

700a4960 <UART_divisorLatchWrite>:
; {
700a4960: b580         	push	{r7, lr}
700a4962: b08c         	sub	sp, #0x30
700a4964: 900b         	str	r0, [sp, #0x2c]
700a4966: 910a         	str	r1, [sp, #0x28]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a4968: 980b         	ldr	r0, [sp, #0x2c]
700a496a: 21bf         	movs	r1, #0xbf
700a496c: 9102         	str	r1, [sp, #0x8]
700a496e: f007 fddf    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #0x7bbe
700a4972: 9007         	str	r0, [sp, #0x1c]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a4974: 980b         	ldr	r0, [sp, #0x2c]
700a4976: 3008         	adds	r0, #0x8
700a4978: 2110         	movs	r1, #0x10
700a497a: 9103         	str	r1, [sp, #0xc]
700a497c: 2204         	movs	r2, #0x4
700a497e: 9204         	str	r2, [sp, #0x10]
700a4980: f00a fb76    	bl	0x700af070 <HW_RD_FIELD32_RAW> @ imm = #0xa6ec
700a4984: 9903         	ldr	r1, [sp, #0xc]
700a4986: 9a04         	ldr	r2, [sp, #0x10]
700a4988: 9009         	str	r0, [sp, #0x24]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a498a: 980b         	ldr	r0, [sp, #0x2c]
700a498c: 3008         	adds	r0, #0x8
700a498e: 2301         	movs	r3, #0x1
700a4990: f009 fd3e    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x9a7c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4994: 980b         	ldr	r0, [sp, #0x2c]
700a4996: 300c         	adds	r0, #0xc
700a4998: 9907         	ldr	r1, [sp, #0x1c]
700a499a: f00a ff69    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0xaed2
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700a499e: 980b         	ldr	r0, [sp, #0x2c]
700a49a0: 217f         	movs	r1, #0x7f
700a49a2: 9101         	str	r1, [sp, #0x4]
700a49a4: f007 fdc4    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #0x7b88
700a49a8: 9903         	ldr	r1, [sp, #0xc]
700a49aa: 9a04         	ldr	r2, [sp, #0x10]
700a49ac: 9007         	str	r0, [sp, #0x1c]
;     sleepMdBitVal = HW_RD_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE);
700a49ae: 980b         	ldr	r0, [sp, #0x2c]
700a49b0: 3004         	adds	r0, #0x4
700a49b2: f00a fb5d    	bl	0x700af070 <HW_RD_FIELD32_RAW> @ imm = #0xa6ba
700a49b6: 9903         	ldr	r1, [sp, #0xc]
700a49b8: 9a04         	ldr	r2, [sp, #0x10]
700a49ba: 9008         	str	r0, [sp, #0x20]
;     HW_WR_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE, 0U);
700a49bc: 980b         	ldr	r0, [sp, #0x2c]
700a49be: 3004         	adds	r0, #0x4
700a49c0: 2300         	movs	r3, #0x0
700a49c2: f009 fd25    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x9a4a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a49c6: 980b         	ldr	r0, [sp, #0x2c]
700a49c8: 300c         	adds	r0, #0xc
700a49ca: 9907         	ldr	r1, [sp, #0x1c]
700a49cc: f00a ff50    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0xaea0
700a49d0: 9902         	ldr	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a49d2: 980b         	ldr	r0, [sp, #0x2c]
700a49d4: f007 fdac    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #0x7b58
700a49d8: 9007         	str	r0, [sp, #0x1c]
;     divRegVal  = HW_RD_REG32(baseAddr + UART_DLL) & 0xFFU;
700a49da: 980b         	ldr	r0, [sp, #0x2c]
700a49dc: f00a ff40    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0xae80
700a49e0: b2c0         	uxtb	r0, r0
700a49e2: 9005         	str	r0, [sp, #0x14]
;     divRegVal |= (HW_RD_REG32(baseAddr + UART_DLH) & 0x3FU) << 8;
700a49e4: 980b         	ldr	r0, [sp, #0x2c]
700a49e6: 3004         	adds	r0, #0x4
700a49e8: f00a ff3a    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0xae74
700a49ec: f000 013f    	and	r1, r0, #0x3f
700a49f0: 9805         	ldr	r0, [sp, #0x14]
700a49f2: ea40 2001    	orr.w	r0, r0, r1, lsl #8
700a49f6: 9005         	str	r0, [sp, #0x14]
;     operMode = UART_operatingModeSelect(baseAddr,
700a49f8: 980b         	ldr	r0, [sp, #0x2c]
700a49fa: 2107         	movs	r1, #0x7
700a49fc: f00a f8c0    	bl	0x700aeb80 <UART_operatingModeSelect> @ imm = #0xa180
700a4a00: 9006         	str	r0, [sp, #0x18]
;     HW_WR_REG32(baseAddr + UART_DLL, divisorValue & 0x00FFU);
700a4a02: 980b         	ldr	r0, [sp, #0x2c]
700a4a04: f89d 1028    	ldrb.w	r1, [sp, #0x28]
700a4a08: f00a ff32    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0xae64
;     HW_WR_REG32(baseAddr + UART_DLH, (divisorValue & 0x3F00U) >> 8);
700a4a0c: 980b         	ldr	r0, [sp, #0x2c]
700a4a0e: 3004         	adds	r0, #0x4
700a4a10: 990a         	ldr	r1, [sp, #0x28]
700a4a12: f3c1 2105    	ubfx	r1, r1, #0x8, #0x6
700a4a16: f00a ff2b    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0xae56
;     (void) UART_operatingModeSelect(baseAddr, operMode);
700a4a1a: 980b         	ldr	r0, [sp, #0x2c]
700a4a1c: 9906         	ldr	r1, [sp, #0x18]
700a4a1e: f00a f8af    	bl	0x700aeb80 <UART_operatingModeSelect> @ imm = #0xa15e
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4a22: 980b         	ldr	r0, [sp, #0x2c]
700a4a24: 300c         	adds	r0, #0xc
700a4a26: 9907         	ldr	r1, [sp, #0x1c]
700a4a28: f00a ff22    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0xae44
700a4a2c: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700a4a2e: 980b         	ldr	r0, [sp, #0x2c]
700a4a30: f007 fd7e    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #0x7afc
700a4a34: 9903         	ldr	r1, [sp, #0xc]
700a4a36: 9a04         	ldr	r2, [sp, #0x10]
700a4a38: 9007         	str	r0, [sp, #0x1c]
;     HW_WR_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE, sleepMdBitVal);
700a4a3a: 980b         	ldr	r0, [sp, #0x2c]
700a4a3c: 3004         	adds	r0, #0x4
700a4a3e: 9b08         	ldr	r3, [sp, #0x20]
700a4a40: f009 fce6    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x99cc
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4a44: 980b         	ldr	r0, [sp, #0x2c]
700a4a46: 300c         	adds	r0, #0xc
700a4a48: 9907         	ldr	r1, [sp, #0x1c]
700a4a4a: f00a ff11    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0xae22
700a4a4e: 9902         	ldr	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a4a50: 980b         	ldr	r0, [sp, #0x2c]
700a4a52: f007 fd6d    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #0x7ada
700a4a56: 9903         	ldr	r1, [sp, #0xc]
700a4a58: 9a04         	ldr	r2, [sp, #0x10]
700a4a5a: 9007         	str	r0, [sp, #0x1c]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a4a5c: 980b         	ldr	r0, [sp, #0x2c]
700a4a5e: 3008         	adds	r0, #0x8
700a4a60: 9b09         	ldr	r3, [sp, #0x24]
700a4a62: f009 fcd5    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x99aa
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4a66: 980b         	ldr	r0, [sp, #0x2c]
700a4a68: 300c         	adds	r0, #0xc
700a4a6a: 9907         	ldr	r1, [sp, #0x1c]
700a4a6c: f00a ff00    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0xae00
;     return divRegVal;
700a4a70: 9805         	ldr	r0, [sp, #0x14]
700a4a72: b00c         	add	sp, #0x30
700a4a74: bd80         	pop	{r7, pc}
		...
700a4a7e: 0000         	movs	r0, r0

700a4a80 <_ntoa_long>:
; {
700a4a80: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
700a4a84: b098         	sub	sp, #0x60
700a4a86: 4684         	mov	r12, r0
700a4a88: 9823         	ldr	r0, [sp, #0x8c]
700a4a8a: 9822         	ldr	r0, [sp, #0x88]
700a4a8c: 9821         	ldr	r0, [sp, #0x84]
700a4a8e: 9820         	ldr	r0, [sp, #0x80]
700a4a90: 981f         	ldr	r0, [sp, #0x7c]
700a4a92: f8dd e078    	ldr.w	lr, [sp, #0x78]
700a4a96: f8cd c05c    	str.w	r12, [sp, #0x5c]
700a4a9a: 9116         	str	r1, [sp, #0x58]
700a4a9c: 9215         	str	r2, [sp, #0x54]
700a4a9e: 9314         	str	r3, [sp, #0x50]
700a4aa0: f88d 004f    	strb.w	r0, [sp, #0x4f]
700a4aa4: 2000         	movs	r0, #0x0
;   size_t len = 0U;
700a4aa6: 900a         	str	r0, [sp, #0x28]
;   if (!value) {
700a4aa8: 981e         	ldr	r0, [sp, #0x78]
700a4aaa: b928         	cbnz	r0, 0x700a4ab8 <_ntoa_long+0x38> @ imm = #0xa
700a4aac: e7ff         	b	0x700a4aae <_ntoa_long+0x2e> @ imm = #-0x2
;     flags &= ~FLAGS_HASH;
700a4aae: 9823         	ldr	r0, [sp, #0x8c]
700a4ab0: f020 0010    	bic	r0, r0, #0x10
700a4ab4: 9023         	str	r0, [sp, #0x8c]
;   }
700a4ab6: e7ff         	b	0x700a4ab8 <_ntoa_long+0x38> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION) || value) {
700a4ab8: f89d 008d    	ldrb.w	r0, [sp, #0x8d]
700a4abc: 0740         	lsls	r0, r0, #0x1d
700a4abe: 2800         	cmp	r0, #0x0
700a4ac0: d504         	bpl	0x700a4acc <_ntoa_long+0x4c> @ imm = #0x8
700a4ac2: e7ff         	b	0x700a4ac4 <_ntoa_long+0x44> @ imm = #-0x2
700a4ac4: 981e         	ldr	r0, [sp, #0x78]
700a4ac6: 2800         	cmp	r0, #0x0
700a4ac8: d03f         	beq	0x700a4b4a <_ntoa_long+0xca> @ imm = #0x7e
700a4aca: e7ff         	b	0x700a4acc <_ntoa_long+0x4c> @ imm = #-0x2
;     do {
700a4acc: e7ff         	b	0x700a4ace <_ntoa_long+0x4e> @ imm = #-0x2
;       const char digit = (char)(value % base);
700a4ace: 9a1e         	ldr	r2, [sp, #0x78]
700a4ad0: 9920         	ldr	r1, [sp, #0x80]
700a4ad2: fbb2 f0f1    	udiv	r0, r2, r1
700a4ad6: fb00 2011    	mls	r0, r0, r1, r2
700a4ada: f88d 0027    	strb.w	r0, [sp, #0x27]
;       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
700a4ade: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a4ae2: 2809         	cmp	r0, #0x9
700a4ae4: dc05         	bgt	0x700a4af2 <_ntoa_long+0x72> @ imm = #0xa
700a4ae6: e7ff         	b	0x700a4ae8 <_ntoa_long+0x68> @ imm = #-0x2
700a4ae8: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a4aec: 3030         	adds	r0, #0x30
700a4aee: 9008         	str	r0, [sp, #0x20]
700a4af0: e00c         	b	0x700a4b0c <_ntoa_long+0x8c> @ imm = #0x18
700a4af2: f89d 008c    	ldrb.w	r0, [sp, #0x8c]
700a4af6: 0681         	lsls	r1, r0, #0x1a
700a4af8: 2061         	movs	r0, #0x61
700a4afa: 2900         	cmp	r1, #0x0
700a4afc: bf48         	it	mi
700a4afe: 2041         	movmi	r0, #0x41
700a4b00: f89d 1027    	ldrb.w	r1, [sp, #0x27]
700a4b04: 4408         	add	r0, r1
700a4b06: 380a         	subs	r0, #0xa
700a4b08: 9008         	str	r0, [sp, #0x20]
700a4b0a: e7ff         	b	0x700a4b0c <_ntoa_long+0x8c> @ imm = #-0x2
700a4b0c: 9808         	ldr	r0, [sp, #0x20]
700a4b0e: 9a0a         	ldr	r2, [sp, #0x28]
700a4b10: 1c51         	adds	r1, r2, #0x1
700a4b12: 910a         	str	r1, [sp, #0x28]
700a4b14: f10d 012f    	add.w	r1, sp, #0x2f
700a4b18: 5488         	strb	r0, [r1, r2]
;       value /= base;
700a4b1a: 9920         	ldr	r1, [sp, #0x80]
700a4b1c: 981e         	ldr	r0, [sp, #0x78]
700a4b1e: fbb0 f0f1    	udiv	r0, r0, r1
700a4b22: 901e         	str	r0, [sp, #0x78]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a4b24: e7ff         	b	0x700a4b26 <_ntoa_long+0xa6> @ imm = #-0x2
700a4b26: 991e         	ldr	r1, [sp, #0x78]
700a4b28: 2000         	movs	r0, #0x0
700a4b2a: 9007         	str	r0, [sp, #0x1c]
700a4b2c: b139         	cbz	r1, 0x700a4b3e <_ntoa_long+0xbe> @ imm = #0xe
700a4b2e: e7ff         	b	0x700a4b30 <_ntoa_long+0xb0> @ imm = #-0x2
700a4b30: 990a         	ldr	r1, [sp, #0x28]
700a4b32: 2000         	movs	r0, #0x0
700a4b34: 2920         	cmp	r1, #0x20
700a4b36: bf38         	it	lo
700a4b38: 2001         	movlo	r0, #0x1
700a4b3a: 9007         	str	r0, [sp, #0x1c]
700a4b3c: e7ff         	b	0x700a4b3e <_ntoa_long+0xbe> @ imm = #-0x2
700a4b3e: 9807         	ldr	r0, [sp, #0x1c]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a4b40: 07c0         	lsls	r0, r0, #0x1f
700a4b42: 2800         	cmp	r0, #0x0
700a4b44: d1c3         	bne	0x700a4ace <_ntoa_long+0x4e> @ imm = #-0x7a
700a4b46: e7ff         	b	0x700a4b48 <_ntoa_long+0xc8> @ imm = #-0x2
;   }
700a4b48: e7ff         	b	0x700a4b4a <_ntoa_long+0xca> @ imm = #-0x2
;   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
700a4b4a: 9817         	ldr	r0, [sp, #0x5c]
700a4b4c: 9916         	ldr	r1, [sp, #0x58]
700a4b4e: 9a15         	ldr	r2, [sp, #0x54]
700a4b50: 9b14         	ldr	r3, [sp, #0x50]
700a4b52: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a4b56: 9d20         	ldr	r5, [sp, #0x80]
700a4b58: 9e21         	ldr	r6, [sp, #0x84]
700a4b5a: 9f22         	ldr	r7, [sp, #0x88]
700a4b5c: f8dd 808c    	ldr.w	r8, [sp, #0x8c]
700a4b60: f89d 404f    	ldrb.w	r4, [sp, #0x4f]
700a4b64: 46ee         	mov	lr, sp
700a4b66: f8ce 8018    	str.w	r8, [lr, #0x18]
700a4b6a: f8ce 7014    	str.w	r7, [lr, #0x14]
700a4b6e: f8ce 6010    	str.w	r6, [lr, #0x10]
700a4b72: f8ce 500c    	str.w	r5, [lr, #0xc]
700a4b76: f004 0401    	and	r4, r4, #0x1
700a4b7a: f8ce 4008    	str.w	r4, [lr, #0x8]
700a4b7e: f8ce c004    	str.w	r12, [lr, #0x4]
700a4b82: f10d 0c2f    	add.w	r12, sp, #0x2f
700a4b86: f8ce c000    	str.w	r12, [lr]
700a4b8a: f7f9 fc59    	bl	0x7009e440 <_ntoa_format> @ imm = #-0x674e
700a4b8e: b018         	add	sp, #0x60
700a4b90: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
		...

700a4ba0 <prvInitialiseNewTask>:
;     const MemoryRegion_t *const xRegions) {
700a4ba0: b580         	push	{r7, lr}
700a4ba2: b088         	sub	sp, #0x20
700a4ba4: f8dd c034    	ldr.w	r12, [sp, #0x34]
700a4ba8: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a4bac: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a4bb0: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a4bb4: 9007         	str	r0, [sp, #0x1c]
700a4bb6: 9106         	str	r1, [sp, #0x18]
700a4bb8: 9205         	str	r2, [sp, #0x14]
700a4bba: 9304         	str	r3, [sp, #0x10]
;     (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE,
700a4bbc: 980c         	ldr	r0, [sp, #0x30]
700a4bbe: 6b00         	ldr	r0, [r0, #0x30]
;                  (size_t)ulStackDepth * sizeof(StackType_t));
700a4bc0: 9905         	ldr	r1, [sp, #0x14]
700a4bc2: 0089         	lsls	r1, r1, #0x2
700a4bc4: 22a5         	movs	r2, #0xa5
;     (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE,
700a4bc6: f00a ee64    	blx	0x700af890 <__aeabi_memset8> @ imm = #0xacc8
;     pxTopOfStack = &(pxNewTCB->pxStack[ulStackDepth - (uint32_t)1]);
700a4bca: 980c         	ldr	r0, [sp, #0x30]
700a4bcc: 6b00         	ldr	r0, [r0, #0x30]
700a4bce: 9905         	ldr	r1, [sp, #0x14]
700a4bd0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4bd4: 3804         	subs	r0, #0x4
700a4bd6: 9003         	str	r0, [sp, #0xc]
;              *)(((portPOINTER_SIZE_TYPE)pxTopOfStack) &
700a4bd8: 9803         	ldr	r0, [sp, #0xc]
700a4bda: f020 0007    	bic	r0, r0, #0x7
;     pxTopOfStack =
700a4bde: 9003         	str	r0, [sp, #0xc]
;   if (pcName != NULL) {
700a4be0: 9806         	ldr	r0, [sp, #0x18]
700a4be2: b1f8         	cbz	r0, 0x700a4c24 <prvInitialiseNewTask+0x84> @ imm = #0x3e
700a4be4: e7ff         	b	0x700a4be6 <prvInitialiseNewTask+0x46> @ imm = #-0x2
700a4be6: 2000         	movs	r0, #0x0
;     for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
700a4be8: 9002         	str	r0, [sp, #0x8]
700a4bea: e7ff         	b	0x700a4bec <prvInitialiseNewTask+0x4c> @ imm = #-0x2
700a4bec: 9802         	ldr	r0, [sp, #0x8]
700a4bee: 281f         	cmp	r0, #0x1f
700a4bf0: d813         	bhi	0x700a4c1a <prvInitialiseNewTask+0x7a> @ imm = #0x26
700a4bf2: e7ff         	b	0x700a4bf4 <prvInitialiseNewTask+0x54> @ imm = #-0x2
;       pxNewTCB->pcTaskName[x] = pcName[x];
700a4bf4: 9806         	ldr	r0, [sp, #0x18]
700a4bf6: 9a02         	ldr	r2, [sp, #0x8]
700a4bf8: 5c80         	ldrb	r0, [r0, r2]
700a4bfa: 990c         	ldr	r1, [sp, #0x30]
700a4bfc: 4411         	add	r1, r2
700a4bfe: f881 0034    	strb.w	r0, [r1, #0x34]
;       if (pcName[x] == (char)0x00) {
700a4c02: 9806         	ldr	r0, [sp, #0x18]
700a4c04: 9902         	ldr	r1, [sp, #0x8]
700a4c06: 5c40         	ldrb	r0, [r0, r1]
700a4c08: b908         	cbnz	r0, 0x700a4c0e <prvInitialiseNewTask+0x6e> @ imm = #0x2
700a4c0a: e7ff         	b	0x700a4c0c <prvInitialiseNewTask+0x6c> @ imm = #-0x2
;         break;
700a4c0c: e005         	b	0x700a4c1a <prvInitialiseNewTask+0x7a> @ imm = #0xa
700a4c0e: e7ff         	b	0x700a4c10 <prvInitialiseNewTask+0x70> @ imm = #-0x2
;     }
700a4c10: e7ff         	b	0x700a4c12 <prvInitialiseNewTask+0x72> @ imm = #-0x2
;     for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
700a4c12: 9802         	ldr	r0, [sp, #0x8]
700a4c14: 3001         	adds	r0, #0x1
700a4c16: 9002         	str	r0, [sp, #0x8]
700a4c18: e7e8         	b	0x700a4bec <prvInitialiseNewTask+0x4c> @ imm = #-0x30
;     pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
700a4c1a: 990c         	ldr	r1, [sp, #0x30]
700a4c1c: 2000         	movs	r0, #0x0
700a4c1e: f881 0053    	strb.w	r0, [r1, #0x53]
;   } else {
700a4c22: e004         	b	0x700a4c2e <prvInitialiseNewTask+0x8e> @ imm = #0x8
;     pxNewTCB->pcTaskName[0] = 0x00;
700a4c24: 990c         	ldr	r1, [sp, #0x30]
700a4c26: 2000         	movs	r0, #0x0
700a4c28: f881 0034    	strb.w	r0, [r1, #0x34]
700a4c2c: e7ff         	b	0x700a4c2e <prvInitialiseNewTask+0x8e> @ imm = #-0x2
;   if (uxPriority >= (UBaseType_t)configMAX_PRIORITIES) {
700a4c2e: 980a         	ldr	r0, [sp, #0x28]
700a4c30: 2820         	cmp	r0, #0x20
700a4c32: d303         	blo	0x700a4c3c <prvInitialiseNewTask+0x9c> @ imm = #0x6
700a4c34: e7ff         	b	0x700a4c36 <prvInitialiseNewTask+0x96> @ imm = #-0x2
700a4c36: 201f         	movs	r0, #0x1f
;     uxPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
700a4c38: 900a         	str	r0, [sp, #0x28]
;   } else {
700a4c3a: e000         	b	0x700a4c3e <prvInitialiseNewTask+0x9e> @ imm = #0x0
700a4c3c: e7ff         	b	0x700a4c3e <prvInitialiseNewTask+0x9e> @ imm = #-0x2
;   pxNewTCB->uxPriority = uxPriority;
700a4c3e: 980a         	ldr	r0, [sp, #0x28]
700a4c40: 990c         	ldr	r1, [sp, #0x30]
700a4c42: 62c8         	str	r0, [r1, #0x2c]
;     pxNewTCB->uxBasePriority = uxPriority;
700a4c44: 980a         	ldr	r0, [sp, #0x28]
700a4c46: 990c         	ldr	r1, [sp, #0x30]
700a4c48: 6608         	str	r0, [r1, #0x60]
;     pxNewTCB->uxMutexesHeld = 0;
700a4c4a: 990c         	ldr	r1, [sp, #0x30]
700a4c4c: 2000         	movs	r0, #0x0
700a4c4e: 9001         	str	r0, [sp, #0x4]
700a4c50: 6648         	str	r0, [r1, #0x64]
;   vListInitialiseItem(&(pxNewTCB->xStateListItem));
700a4c52: 980c         	ldr	r0, [sp, #0x30]
700a4c54: 3004         	adds	r0, #0x4
700a4c56: f00a fe3b    	bl	0x700af8d0 <vListInitialiseItem> @ imm = #0xac76
;   vListInitialiseItem(&(pxNewTCB->xEventListItem));
700a4c5a: 980c         	ldr	r0, [sp, #0x30]
700a4c5c: 3018         	adds	r0, #0x18
700a4c5e: f00a fe37    	bl	0x700af8d0 <vListInitialiseItem> @ imm = #0xac6e
700a4c62: 9801         	ldr	r0, [sp, #0x4]
;   listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
700a4c64: 990c         	ldr	r1, [sp, #0x30]
700a4c66: 6109         	str	r1, [r1, #0x10]
;   listSET_LIST_ITEM_VALUE(
700a4c68: 990a         	ldr	r1, [sp, #0x28]
700a4c6a: f1c1 0120    	rsb.w	r1, r1, #0x20
700a4c6e: 9a0c         	ldr	r2, [sp, #0x30]
700a4c70: 6191         	str	r1, [r2, #0x18]
;   listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
700a4c72: 990c         	ldr	r1, [sp, #0x30]
700a4c74: 6249         	str	r1, [r1, #0x24]
;     pxNewTCB->uxCriticalNesting = (UBaseType_t)0U;
700a4c76: 990c         	ldr	r1, [sp, #0x30]
700a4c78: 6548         	str	r0, [r1, #0x54]
;     pxNewTCB->pxTaskTag = NULL;
700a4c7a: 990c         	ldr	r1, [sp, #0x30]
700a4c7c: 6688         	str	r0, [r1, #0x68]
;     memset((void *)&(pxNewTCB->pvThreadLocalStoragePointers[0]), 0x00,
700a4c7e: 990c         	ldr	r1, [sp, #0x30]
700a4c80: 6788         	str	r0, [r1, #0x78]
700a4c82: 6748         	str	r0, [r1, #0x74]
700a4c84: 6708         	str	r0, [r1, #0x70]
700a4c86: 66c8         	str	r0, [r1, #0x6c]
;     memset((void *)&(pxNewTCB->ulNotifiedValue[0]), 0x00,
700a4c88: 990c         	ldr	r1, [sp, #0x30]
700a4c8a: 67c8         	str	r0, [r1, #0x7c]
;     memset((void *)&(pxNewTCB->ucNotifyState[0]), 0x00,
700a4c8c: 990c         	ldr	r1, [sp, #0x30]
700a4c8e: f881 0080    	strb.w	r0, [r1, #0x80]
;           pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
700a4c92: 9803         	ldr	r0, [sp, #0xc]
700a4c94: 9907         	ldr	r1, [sp, #0x1c]
700a4c96: 9a04         	ldr	r2, [sp, #0x10]
700a4c98: f7fe fc8a    	bl	0x700a35b0 <pxPortInitialiseStack> @ imm = #-0x16ec
;       pxNewTCB->pxTopOfStack =
700a4c9c: 990c         	ldr	r1, [sp, #0x30]
700a4c9e: 6008         	str	r0, [r1]
;   if (pxCreatedTask != NULL) {
700a4ca0: 980b         	ldr	r0, [sp, #0x2c]
700a4ca2: b120         	cbz	r0, 0x700a4cae <prvInitialiseNewTask+0x10e> @ imm = #0x8
700a4ca4: e7ff         	b	0x700a4ca6 <prvInitialiseNewTask+0x106> @ imm = #-0x2
;     *pxCreatedTask = (TaskHandle_t)pxNewTCB;
700a4ca6: 980c         	ldr	r0, [sp, #0x30]
700a4ca8: 990b         	ldr	r1, [sp, #0x2c]
700a4caa: 6008         	str	r0, [r1]
;   } else {
700a4cac: e000         	b	0x700a4cb0 <prvInitialiseNewTask+0x110> @ imm = #0x0
700a4cae: e7ff         	b	0x700a4cb0 <prvInitialiseNewTask+0x110> @ imm = #-0x2
; }
700a4cb0: b008         	add	sp, #0x20
700a4cb2: bd80         	pop	{r7, pc}
		...

700a4cc0 <Sciclient_pmSetModuleClkFreq>:
; {
700a4cc0: b580         	push	{r7, lr}
700a4cc2: b09a         	sub	sp, #0x68
700a4cc4: f8dd c074    	ldr.w	r12, [sp, #0x74]
700a4cc8: f8dd c070    	ldr.w	r12, [sp, #0x70]
700a4ccc: 9019         	str	r0, [sp, #0x64]
700a4cce: 9118         	str	r1, [sp, #0x60]
700a4cd0: 9317         	str	r3, [sp, #0x5c]
700a4cd2: 9216         	str	r2, [sp, #0x58]
700a4cd4: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a4cd6: 9015         	str	r0, [sp, #0x54]
;     request.device         = (uint32_t) moduleId;
700a4cd8: 9819         	ldr	r0, [sp, #0x64]
700a4cda: 900c         	str	r0, [sp, #0x30]
;     request.min_freq_hz    = (uint64_t) freqHz;
700a4cdc: 9816         	ldr	r0, [sp, #0x58]
700a4cde: 9917         	ldr	r1, [sp, #0x5c]
700a4ce0: 910e         	str	r1, [sp, #0x38]
700a4ce2: 900d         	str	r0, [sp, #0x34]
;     request.target_freq_hz = (uint64_t) freqHz;
700a4ce4: 9816         	ldr	r0, [sp, #0x58]
700a4ce6: 9917         	ldr	r1, [sp, #0x5c]
700a4ce8: 9110         	str	r1, [sp, #0x40]
700a4cea: 900f         	str	r0, [sp, #0x3c]
;     request.max_freq_hz    = (uint64_t) freqHz;
700a4cec: 9816         	ldr	r0, [sp, #0x58]
700a4cee: 9917         	ldr	r1, [sp, #0x5c]
700a4cf0: 9112         	str	r1, [sp, #0x48]
700a4cf2: 9011         	str	r0, [sp, #0x44]
;     if((freqHz%10U) != 0U)
700a4cf4: 9b16         	ldr	r3, [sp, #0x58]
700a4cf6: 9817         	ldr	r0, [sp, #0x5c]
700a4cf8: f64c 41cd    	movw	r1, #0xcccd
700a4cfc: f6cc 41cc    	movt	r1, #0xcccc
700a4d00: fba3 2e01    	umull	r2, lr, r3, r1
700a4d04: f04f 3ccc    	mov.w	r12, #0xcccccccc
700a4d08: fb03 e30c    	mla	r3, r3, r12, lr
700a4d0c: fb00 3101    	mla	r1, r0, r1, r3
700a4d10: ea4f 70c2    	lsl.w	r0, r2, #0x1f
700a4d14: ea40 0051    	orr.w	r0, r0, r1, lsr #1
700a4d18: ea4f 71c1    	lsl.w	r1, r1, #0x1f
700a4d1c: ea41 0152    	orr.w	r1, r1, r2, lsr #1
700a4d20: f649 129a    	movw	r2, #0x999a
700a4d24: f6c9 1299    	movt	r2, #0x9999
700a4d28: 1a89         	subs	r1, r1, r2
700a4d2a: f649 1199    	movw	r1, #0x9999
700a4d2e: f6c1 1199    	movt	r1, #0x1999
700a4d32: 4188         	sbcs	r0, r1
700a4d34: d316         	blo	0x700a4d64 <Sciclient_pmSetModuleClkFreq+0xa4> @ imm = #0x2c
700a4d36: e7ff         	b	0x700a4d38 <Sciclient_pmSetModuleClkFreq+0x78> @ imm = #-0x2
;         request.min_freq_hz = (uint64_t)(freqHz-(freqHz%10U));
700a4d38: 9816         	ldr	r0, [sp, #0x58]
700a4d3a: 9001         	str	r0, [sp, #0x4]
700a4d3c: 9917         	ldr	r1, [sp, #0x5c]
700a4d3e: 9100         	str	r1, [sp]
700a4d40: 220a         	movs	r2, #0xa
700a4d42: 2300         	movs	r3, #0x0
700a4d44: f00a e8f6    	blx	0x700aef34 <__aeabi_uldivmod> @ imm = #0xa1ec
700a4d48: 9800         	ldr	r0, [sp]
700a4d4a: 9901         	ldr	r1, [sp, #0x4]
700a4d4c: 1a89         	subs	r1, r1, r2
700a4d4e: 4198         	sbcs	r0, r3
700a4d50: 910d         	str	r1, [sp, #0x34]
700a4d52: 900e         	str	r0, [sp, #0x38]
;         request.max_freq_hz = (uint64_t)(request.min_freq_hz + 10UL);
700a4d54: 990d         	ldr	r1, [sp, #0x34]
700a4d56: 980e         	ldr	r0, [sp, #0x38]
700a4d58: 310a         	adds	r1, #0xa
700a4d5a: f140 0000    	adc	r0, r0, #0x0
700a4d5e: 9111         	str	r1, [sp, #0x44]
700a4d60: 9012         	str	r0, [sp, #0x48]
;     }
700a4d62: e7ff         	b	0x700a4d64 <Sciclient_pmSetModuleClkFreq+0xa4> @ imm = #-0x2
;     if (clockId >= 255U)
700a4d64: 9818         	ldr	r0, [sp, #0x60]
700a4d66: 28ff         	cmp	r0, #0xff
700a4d68: d307         	blo	0x700a4d7a <Sciclient_pmSetModuleClkFreq+0xba> @ imm = #0xe
700a4d6a: e7ff         	b	0x700a4d6c <Sciclient_pmSetModuleClkFreq+0xac> @ imm = #-0x2
;         request.clk32 = clockId;
700a4d6c: 9818         	ldr	r0, [sp, #0x60]
700a4d6e: f8cd 004d    	str.w	r0, [sp, #0x4d]
700a4d72: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a4d74: f88d 004c    	strb.w	r0, [sp, #0x4c]
;     }
700a4d78: e003         	b	0x700a4d82 <Sciclient_pmSetModuleClkFreq+0xc2> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a4d7a: 9818         	ldr	r0, [sp, #0x60]
700a4d7c: f88d 004c    	strb.w	r0, [sp, #0x4c]
700a4d80: e7ff         	b	0x700a4d82 <Sciclient_pmSetModuleClkFreq+0xc2> @ imm = #-0x2
700a4d82: f44f 7086    	mov.w	r0, #0x10c
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_FREQ;
700a4d86: f8ad 0014    	strh.w	r0, [sp, #0x14]
;     reqParam.flags          = (uint32_t)(TISCI_MSG_FLAG_AOP | additionalFlag);
700a4d8a: 981c         	ldr	r0, [sp, #0x70]
700a4d8c: f040 0002    	orr	r0, r0, #0x2
700a4d90: 9006         	str	r0, [sp, #0x18]
700a4d92: a80a         	add	r0, sp, #0x28
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a4d94: 9007         	str	r0, [sp, #0x1c]
700a4d96: 2029         	movs	r0, #0x29
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a4d98: 9008         	str	r0, [sp, #0x20]
;     reqParam.timeout        = (uint32_t) timeout;
700a4d9a: 981d         	ldr	r0, [sp, #0x74]
700a4d9c: 9009         	str	r0, [sp, #0x24]
700a4d9e: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a4da0: 9002         	str	r0, [sp, #0x8]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a4da2: 9003         	str	r0, [sp, #0xc]
;     respParam.respPayloadSize = (uint32_t) 0;
700a4da4: 9004         	str	r0, [sp, #0x10]
700a4da6: a805         	add	r0, sp, #0x14
700a4da8: a902         	add	r1, sp, #0x8
;     retVal = Sciclient_service(&reqParam, &respParam);
700a4daa: f7f8 fa69    	bl	0x7009d280 <Sciclient_service> @ imm = #-0x7b2e
700a4dae: 9015         	str	r0, [sp, #0x54]
;     if((retVal != SystemP_SUCCESS) ||
700a4db0: 9815         	ldr	r0, [sp, #0x54]
700a4db2: b930         	cbnz	r0, 0x700a4dc2 <Sciclient_pmSetModuleClkFreq+0x102> @ imm = #0xc
700a4db4: e7ff         	b	0x700a4db6 <Sciclient_pmSetModuleClkFreq+0xf6> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a4db6: 9802         	ldr	r0, [sp, #0x8]
700a4db8: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a4dbc: 2802         	cmp	r0, #0x2
700a4dbe: d004         	beq	0x700a4dca <Sciclient_pmSetModuleClkFreq+0x10a> @ imm = #0x8
700a4dc0: e7ff         	b	0x700a4dc2 <Sciclient_pmSetModuleClkFreq+0x102> @ imm = #-0x2
700a4dc2: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a4dc6: 9015         	str	r0, [sp, #0x54]
;     }
700a4dc8: e7ff         	b	0x700a4dca <Sciclient_pmSetModuleClkFreq+0x10a> @ imm = #-0x2
;     return retVal;
700a4dca: 9815         	ldr	r0, [sp, #0x54]
700a4dcc: b01a         	add	sp, #0x68
700a4dce: bd80         	pop	{r7, pc}

700a4dd0 <prvAddNewTaskToReadyList>:
; static void prvAddNewTaskToReadyList(TCB_t *pxNewTCB) {
700a4dd0: b580         	push	{r7, lr}
700a4dd2: b082         	sub	sp, #0x8
700a4dd4: 9001         	str	r0, [sp, #0x4]
;   taskENTER_CRITICAL();
700a4dd6: f009 fb7b    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0x96f6
;     uxCurrentNumberOfTasks++;
700a4dda: f242 61dc    	movw	r1, #0x26dc
700a4dde: f2c7 010b    	movt	r1, #0x700b
700a4de2: 6808         	ldr	r0, [r1]
700a4de4: 3001         	adds	r0, #0x1
700a4de6: 6008         	str	r0, [r1]
;     if (pxCurrentTCB == NULL) {
700a4de8: f242 60bc    	movw	r0, #0x26bc
700a4dec: f2c7 000b    	movt	r0, #0x700b
700a4df0: 6800         	ldr	r0, [r0]
700a4df2: b998         	cbnz	r0, 0x700a4e1c <prvAddNewTaskToReadyList+0x4c> @ imm = #0x26
700a4df4: e7ff         	b	0x700a4df6 <prvAddNewTaskToReadyList+0x26> @ imm = #-0x2
;       pxCurrentTCB = pxNewTCB;
700a4df6: 9801         	ldr	r0, [sp, #0x4]
700a4df8: f242 61bc    	movw	r1, #0x26bc
700a4dfc: f2c7 010b    	movt	r1, #0x700b
700a4e00: 6008         	str	r0, [r1]
;       if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
700a4e02: f242 60dc    	movw	r0, #0x26dc
700a4e06: f2c7 000b    	movt	r0, #0x700b
700a4e0a: 6800         	ldr	r0, [r0]
700a4e0c: 2801         	cmp	r0, #0x1
700a4e0e: d103         	bne	0x700a4e18 <prvAddNewTaskToReadyList+0x48> @ imm = #0x6
700a4e10: e7ff         	b	0x700a4e12 <prvAddNewTaskToReadyList+0x42> @ imm = #-0x2
;         prvInitialiseTaskLists();
700a4e12: f004 feed    	bl	0x700a9bf0 <prvInitialiseTaskLists> @ imm = #0x4dda
;       } else {
700a4e16: e000         	b	0x700a4e1a <prvAddNewTaskToReadyList+0x4a> @ imm = #0x0
700a4e18: e7ff         	b	0x700a4e1a <prvAddNewTaskToReadyList+0x4a> @ imm = #-0x2
;     } else {
700a4e1a: e01c         	b	0x700a4e56 <prvAddNewTaskToReadyList+0x86> @ imm = #0x38
;       if (xSchedulerRunning == pdFALSE) {
700a4e1c: f242 7000    	movw	r0, #0x2700
700a4e20: f2c7 000b    	movt	r0, #0x700b
700a4e24: 6800         	ldr	r0, [r0]
700a4e26: b9a0         	cbnz	r0, 0x700a4e52 <prvAddNewTaskToReadyList+0x82> @ imm = #0x28
700a4e28: e7ff         	b	0x700a4e2a <prvAddNewTaskToReadyList+0x5a> @ imm = #-0x2
;         if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
700a4e2a: f242 60bc    	movw	r0, #0x26bc
700a4e2e: f2c7 000b    	movt	r0, #0x700b
700a4e32: 6800         	ldr	r0, [r0]
700a4e34: 6ac0         	ldr	r0, [r0, #0x2c]
700a4e36: 9901         	ldr	r1, [sp, #0x4]
700a4e38: 6ac9         	ldr	r1, [r1, #0x2c]
700a4e3a: 4288         	cmp	r0, r1
700a4e3c: d807         	bhi	0x700a4e4e <prvAddNewTaskToReadyList+0x7e> @ imm = #0xe
700a4e3e: e7ff         	b	0x700a4e40 <prvAddNewTaskToReadyList+0x70> @ imm = #-0x2
;           pxCurrentTCB = pxNewTCB;
700a4e40: 9801         	ldr	r0, [sp, #0x4]
700a4e42: f242 61bc    	movw	r1, #0x26bc
700a4e46: f2c7 010b    	movt	r1, #0x700b
700a4e4a: 6008         	str	r0, [r1]
;         } else {
700a4e4c: e000         	b	0x700a4e50 <prvAddNewTaskToReadyList+0x80> @ imm = #0x0
700a4e4e: e7ff         	b	0x700a4e50 <prvAddNewTaskToReadyList+0x80> @ imm = #-0x2
;       } else {
700a4e50: e000         	b	0x700a4e54 <prvAddNewTaskToReadyList+0x84> @ imm = #0x0
700a4e52: e7ff         	b	0x700a4e54 <prvAddNewTaskToReadyList+0x84> @ imm = #-0x2
700a4e54: e7ff         	b	0x700a4e56 <prvAddNewTaskToReadyList+0x86> @ imm = #-0x2
;     uxTaskNumber++;
700a4e56: f242 60e8    	movw	r0, #0x26e8
700a4e5a: f2c7 000b    	movt	r0, #0x700b
700a4e5e: 6801         	ldr	r1, [r0]
700a4e60: 3101         	adds	r1, #0x1
700a4e62: 6001         	str	r1, [r0]
;       pxNewTCB->uxTCBNumber = uxTaskNumber;
700a4e64: 6800         	ldr	r0, [r0]
700a4e66: 9901         	ldr	r1, [sp, #0x4]
700a4e68: 6588         	str	r0, [r1, #0x58]
;     prvAddTaskToReadyList(pxNewTCB);
700a4e6a: 9801         	ldr	r0, [sp, #0x4]
700a4e6c: 6ac0         	ldr	r0, [r0, #0x2c]
700a4e6e: f242 61ec    	movw	r1, #0x26ec
700a4e72: f2c7 010b    	movt	r1, #0x700b
700a4e76: 6809         	ldr	r1, [r1]
700a4e78: 4288         	cmp	r0, r1
700a4e7a: d908         	bls	0x700a4e8e <prvAddNewTaskToReadyList+0xbe> @ imm = #0x10
700a4e7c: e7ff         	b	0x700a4e7e <prvAddNewTaskToReadyList+0xae> @ imm = #-0x2
700a4e7e: 9801         	ldr	r0, [sp, #0x4]
700a4e80: 6ac0         	ldr	r0, [r0, #0x2c]
700a4e82: f242 61ec    	movw	r1, #0x26ec
700a4e86: f2c7 010b    	movt	r1, #0x700b
700a4e8a: 6008         	str	r0, [r1]
700a4e8c: e7ff         	b	0x700a4e8e <prvAddNewTaskToReadyList+0xbe> @ imm = #-0x2
700a4e8e: 9901         	ldr	r1, [sp, #0x4]
700a4e90: 6ac8         	ldr	r0, [r1, #0x2c]
700a4e92: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a4e96: f244 40f8    	movw	r0, #0x44f8
700a4e9a: f2c7 0008    	movt	r0, #0x7008
700a4e9e: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a4ea2: 3104         	adds	r1, #0x4
700a4ea4: f009 f89c    	bl	0x700adfe0 <vListInsertEnd> @ imm = #0x9138
;   taskEXIT_CRITICAL();
700a4ea8: f008 fbd2    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0x87a4
;   if (xSchedulerRunning != pdFALSE) {
700a4eac: f242 7000    	movw	r0, #0x2700
700a4eb0: f2c7 000b    	movt	r0, #0x700b
700a4eb4: 6800         	ldr	r0, [r0]
700a4eb6: b178         	cbz	r0, 0x700a4ed8 <prvAddNewTaskToReadyList+0x108> @ imm = #0x1e
700a4eb8: e7ff         	b	0x700a4eba <prvAddNewTaskToReadyList+0xea> @ imm = #-0x2
;     if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
700a4eba: f242 60bc    	movw	r0, #0x26bc
700a4ebe: f2c7 000b    	movt	r0, #0x700b
700a4ec2: 6800         	ldr	r0, [r0]
700a4ec4: 6ac0         	ldr	r0, [r0, #0x2c]
700a4ec6: 9901         	ldr	r1, [sp, #0x4]
700a4ec8: 6ac9         	ldr	r1, [r1, #0x2c]
700a4eca: 4288         	cmp	r0, r1
700a4ecc: d202         	bhs	0x700a4ed4 <prvAddNewTaskToReadyList+0x104> @ imm = #0x4
700a4ece: e7ff         	b	0x700a4ed0 <prvAddNewTaskToReadyList+0x100> @ imm = #-0x2
;       taskYIELD_IF_USING_PREEMPTION();
700a4ed0: df00         	svc	#0x0
;     } else {
700a4ed2: e000         	b	0x700a4ed6 <prvAddNewTaskToReadyList+0x106> @ imm = #0x0
700a4ed4: e7ff         	b	0x700a4ed6 <prvAddNewTaskToReadyList+0x106> @ imm = #-0x2
;   } else {
700a4ed6: e000         	b	0x700a4eda <prvAddNewTaskToReadyList+0x10a> @ imm = #0x0
700a4ed8: e7ff         	b	0x700a4eda <prvAddNewTaskToReadyList+0x10a> @ imm = #-0x2
; }
700a4eda: b002         	add	sp, #0x8
700a4edc: bd80         	pop	{r7, pc}
700a4ede: 0000         	movs	r0, r0

700a4ee0 <xTaskPriorityInherit>:
; BaseType_t xTaskPriorityInherit(TaskHandle_t const pxMutexHolder) {
700a4ee0: b580         	push	{r7, lr}
700a4ee2: b084         	sub	sp, #0x10
700a4ee4: 9003         	str	r0, [sp, #0xc]
;   TCB_t *const pxMutexHolderTCB = pxMutexHolder;
700a4ee6: 9803         	ldr	r0, [sp, #0xc]
700a4ee8: 9002         	str	r0, [sp, #0x8]
700a4eea: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700a4eec: 9001         	str	r0, [sp, #0x4]
;   if (pxMutexHolder != NULL) {
700a4eee: 9803         	ldr	r0, [sp, #0xc]
700a4ef0: 2800         	cmp	r0, #0x0
700a4ef2: d078         	beq	0x700a4fe6 <xTaskPriorityInherit+0x106> @ imm = #0xf0
700a4ef4: e7ff         	b	0x700a4ef6 <xTaskPriorityInherit+0x16> @ imm = #-0x2
;     if (pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority) {
700a4ef6: 9802         	ldr	r0, [sp, #0x8]
700a4ef8: 6ac0         	ldr	r0, [r0, #0x2c]
700a4efa: f242 61bc    	movw	r1, #0x26bc
700a4efe: f2c7 010b    	movt	r1, #0x700b
700a4f02: 6809         	ldr	r1, [r1]
700a4f04: 6ac9         	ldr	r1, [r1, #0x2c]
700a4f06: 4288         	cmp	r0, r1
700a4f08: d25c         	bhs	0x700a4fc4 <xTaskPriorityInherit+0xe4> @ imm = #0xb8
700a4f0a: e7ff         	b	0x700a4f0c <xTaskPriorityInherit+0x2c> @ imm = #-0x2
;       if ((listGET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem)) &
700a4f0c: 9802         	ldr	r0, [sp, #0x8]
700a4f0e: 7ec0         	ldrb	r0, [r0, #0x1b]
700a4f10: 0600         	lsls	r0, r0, #0x18
700a4f12: 2800         	cmp	r0, #0x0
700a4f14: d40b         	bmi	0x700a4f2e <xTaskPriorityInherit+0x4e> @ imm = #0x16
700a4f16: e7ff         	b	0x700a4f18 <xTaskPriorityInherit+0x38> @ imm = #-0x2
;         listSET_LIST_ITEM_VALUE(
700a4f18: f242 60bc    	movw	r0, #0x26bc
700a4f1c: f2c7 000b    	movt	r0, #0x700b
700a4f20: 6800         	ldr	r0, [r0]
700a4f22: 6ac0         	ldr	r0, [r0, #0x2c]
700a4f24: f1c0 0020    	rsb.w	r0, r0, #0x20
700a4f28: 9902         	ldr	r1, [sp, #0x8]
700a4f2a: 6188         	str	r0, [r1, #0x18]
;       } else {
700a4f2c: e000         	b	0x700a4f30 <xTaskPriorityInherit+0x50> @ imm = #0x0
700a4f2e: e7ff         	b	0x700a4f30 <xTaskPriorityInherit+0x50> @ imm = #-0x2
;       if (listIS_CONTAINED_WITHIN(
700a4f30: 9902         	ldr	r1, [sp, #0x8]
700a4f32: 6948         	ldr	r0, [r1, #0x14]
700a4f34: 6ac9         	ldr	r1, [r1, #0x2c]
700a4f36: eb01 0281    	add.w	r2, r1, r1, lsl #2
700a4f3a: f244 41f8    	movw	r1, #0x44f8
700a4f3e: f2c7 0108    	movt	r1, #0x7008
700a4f42: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a4f46: 4288         	cmp	r0, r1
700a4f48: d130         	bne	0x700a4fac <xTaskPriorityInherit+0xcc> @ imm = #0x60
700a4f4a: e7ff         	b	0x700a4f4c <xTaskPriorityInherit+0x6c> @ imm = #-0x2
;         if (uxListRemove(&(pxMutexHolderTCB->xStateListItem)) ==
700a4f4c: 9802         	ldr	r0, [sp, #0x8]
700a4f4e: 3004         	adds	r0, #0x4
700a4f50: f008 fa8e    	bl	0x700ad470 <uxListRemove> @ imm = #0x851c
700a4f54: b908         	cbnz	r0, 0x700a4f5a <xTaskPriorityInherit+0x7a> @ imm = #0x2
700a4f56: e7ff         	b	0x700a4f58 <xTaskPriorityInherit+0x78> @ imm = #-0x2
;         } else {
700a4f58: e000         	b	0x700a4f5c <xTaskPriorityInherit+0x7c> @ imm = #0x0
700a4f5a: e7ff         	b	0x700a4f5c <xTaskPriorityInherit+0x7c> @ imm = #-0x2
;         pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
700a4f5c: f242 60bc    	movw	r0, #0x26bc
700a4f60: f2c7 000b    	movt	r0, #0x700b
700a4f64: 6800         	ldr	r0, [r0]
700a4f66: 6ac0         	ldr	r0, [r0, #0x2c]
700a4f68: 9902         	ldr	r1, [sp, #0x8]
700a4f6a: 62c8         	str	r0, [r1, #0x2c]
;         prvAddTaskToReadyList(pxMutexHolderTCB);
700a4f6c: 9802         	ldr	r0, [sp, #0x8]
700a4f6e: 6ac0         	ldr	r0, [r0, #0x2c]
700a4f70: f242 61ec    	movw	r1, #0x26ec
700a4f74: f2c7 010b    	movt	r1, #0x700b
700a4f78: 6809         	ldr	r1, [r1]
700a4f7a: 4288         	cmp	r0, r1
700a4f7c: d908         	bls	0x700a4f90 <xTaskPriorityInherit+0xb0> @ imm = #0x10
700a4f7e: e7ff         	b	0x700a4f80 <xTaskPriorityInherit+0xa0> @ imm = #-0x2
700a4f80: 9802         	ldr	r0, [sp, #0x8]
700a4f82: 6ac0         	ldr	r0, [r0, #0x2c]
700a4f84: f242 61ec    	movw	r1, #0x26ec
700a4f88: f2c7 010b    	movt	r1, #0x700b
700a4f8c: 6008         	str	r0, [r1]
700a4f8e: e7ff         	b	0x700a4f90 <xTaskPriorityInherit+0xb0> @ imm = #-0x2
700a4f90: 9902         	ldr	r1, [sp, #0x8]
700a4f92: 6ac8         	ldr	r0, [r1, #0x2c]
700a4f94: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a4f98: f244 40f8    	movw	r0, #0x44f8
700a4f9c: f2c7 0008    	movt	r0, #0x7008
700a4fa0: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a4fa4: 3104         	adds	r1, #0x4
700a4fa6: f009 f81b    	bl	0x700adfe0 <vListInsertEnd> @ imm = #0x9036
;       } else {
700a4faa: e008         	b	0x700a4fbe <xTaskPriorityInherit+0xde> @ imm = #0x10
;         pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
700a4fac: f242 60bc    	movw	r0, #0x26bc
700a4fb0: f2c7 000b    	movt	r0, #0x700b
700a4fb4: 6800         	ldr	r0, [r0]
700a4fb6: 6ac0         	ldr	r0, [r0, #0x2c]
700a4fb8: 9902         	ldr	r1, [sp, #0x8]
700a4fba: 62c8         	str	r0, [r1, #0x2c]
700a4fbc: e7ff         	b	0x700a4fbe <xTaskPriorityInherit+0xde> @ imm = #-0x2
700a4fbe: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a4fc0: 9001         	str	r0, [sp, #0x4]
;     } else {
700a4fc2: e00f         	b	0x700a4fe4 <xTaskPriorityInherit+0x104> @ imm = #0x1e
;       if (pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority) {
700a4fc4: 9802         	ldr	r0, [sp, #0x8]
700a4fc6: 6e00         	ldr	r0, [r0, #0x60]
700a4fc8: f242 61bc    	movw	r1, #0x26bc
700a4fcc: f2c7 010b    	movt	r1, #0x700b
700a4fd0: 6809         	ldr	r1, [r1]
700a4fd2: 6ac9         	ldr	r1, [r1, #0x2c]
700a4fd4: 4288         	cmp	r0, r1
700a4fd6: d203         	bhs	0x700a4fe0 <xTaskPriorityInherit+0x100> @ imm = #0x6
700a4fd8: e7ff         	b	0x700a4fda <xTaskPriorityInherit+0xfa> @ imm = #-0x2
700a4fda: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700a4fdc: 9001         	str	r0, [sp, #0x4]
;       } else {
700a4fde: e000         	b	0x700a4fe2 <xTaskPriorityInherit+0x102> @ imm = #0x0
700a4fe0: e7ff         	b	0x700a4fe2 <xTaskPriorityInherit+0x102> @ imm = #-0x2
700a4fe2: e7ff         	b	0x700a4fe4 <xTaskPriorityInherit+0x104> @ imm = #-0x2
;   } else {
700a4fe4: e000         	b	0x700a4fe8 <xTaskPriorityInherit+0x108> @ imm = #0x0
700a4fe6: e7ff         	b	0x700a4fe8 <xTaskPriorityInherit+0x108> @ imm = #-0x2
;   return xReturn;
700a4fe8: 9801         	ldr	r0, [sp, #0x4]
700a4fea: b004         	add	sp, #0x10
700a4fec: bd80         	pop	{r7, pc}
700a4fee: 0000         	movs	r0, r0

700a4ff0 <tm_isr_message_handler>:
; {
700a4ff0: b570         	push	{r4, r5, r6, lr}
;    tm_isr_counter++;
700a4ff2: f242 60c8    	movw	r0, #0x26c8
;    message[1] = isr_message_counter;
700a4ff6: f242 65b4    	movw	r5, #0x26b4
;    tm_isr_counter++;
700a4ffa: f2c7 000b    	movt	r0, #0x700b
;    message[1] = isr_message_counter;
700a4ffe: f2c7 050b    	movt	r5, #0x700b
;    message[0] = 1;
700a5002: f644 76c0    	movw	r6, #0x4fc0
700a5006: f2c7 0608    	movt	r6, #0x7008
;    tm_isr_counter++;
700a500a: 6801         	ldr	r1, [r0]
700a500c: 3101         	adds	r1, #0x1
700a500e: 6001         	str	r1, [r0]
700a5010: 2001         	movs	r0, #0x1
;    message[1] = isr_message_counter;
700a5012: 6829         	ldr	r1, [r5]
;    message[0] = 1;
700a5014: 6030         	str	r0, [r6]
700a5016: 2000         	movs	r0, #0x0
;    message[1] = isr_message_counter;
700a5018: 6071         	str	r1, [r6, #0x4]
700a501a: bf00         	nop
700a501c: bf00         	nop
700a501e: bf00         	nop
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700a5020: 6829         	ldr	r1, [r5]
700a5022: f200 33eb    	addw	r3, r0, #0x3eb
700a5026: 682a         	ldr	r2, [r5]
;    for (i = 2; i < MESSAGE_SIZE - 1; i++)
700a5028: 281b         	cmp	r0, #0x1b
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700a502a: eb01 0181    	add.w	r1, r1, r1, lsl #2
700a502e: eb02 0282    	add.w	r2, r2, r2, lsl #2
700a5032: eb03 0141    	add.w	r1, r3, r1, lsl #1
700a5036: f1a1 0401    	sub.w	r4, r1, #0x1
700a503a: eb06 0180    	add.w	r1, r6, r0, lsl #2
700a503e: eb03 0242    	add.w	r2, r3, r2, lsl #1
700a5042: e9c1 4202    	strd	r4, r2, [r1, #8]
;    for (i = 2; i < MESSAGE_SIZE - 1; i++)
700a5046: d009         	beq	0x700a505c <tm_isr_message_handler+0x6c> @ imm = #0x12
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700a5048: 682a         	ldr	r2, [r5]
700a504a: eb02 0282    	add.w	r2, r2, r2, lsl #2
700a504e: eb00 0242    	add.w	r2, r0, r2, lsl #1
700a5052: 3003         	adds	r0, #0x3
700a5054: f502 727b    	add.w	r2, r2, #0x3ec
700a5058: 610a         	str	r2, [r1, #0x10]
700a505a: e7e1         	b	0x700a5020 <tm_isr_message_handler+0x30> @ imm = #-0x3e
;       checksum += msg[i];
700a505c: e896 0007    	ldm.w	r6, {r0, r1, r2}
700a5060: 4408         	add	r0, r1
700a5062: 68f1         	ldr	r1, [r6, #0xc]
700a5064: 4410         	add	r0, r2
700a5066: 6932         	ldr	r2, [r6, #0x10]
700a5068: 4408         	add	r0, r1
700a506a: 6971         	ldr	r1, [r6, #0x14]
700a506c: 4410         	add	r0, r2
700a506e: 69b2         	ldr	r2, [r6, #0x18]
700a5070: 4408         	add	r0, r1
700a5072: 69f1         	ldr	r1, [r6, #0x1c]
700a5074: 4410         	add	r0, r2
700a5076: 6a32         	ldr	r2, [r6, #0x20]
700a5078: 4408         	add	r0, r1
700a507a: 6a71         	ldr	r1, [r6, #0x24]
700a507c: 4410         	add	r0, r2
700a507e: 6ab2         	ldr	r2, [r6, #0x28]
700a5080: 4408         	add	r0, r1
700a5082: 6af1         	ldr	r1, [r6, #0x2c]
700a5084: 4410         	add	r0, r2
700a5086: 6b32         	ldr	r2, [r6, #0x30]
700a5088: 4408         	add	r0, r1
700a508a: 6b71         	ldr	r1, [r6, #0x34]
700a508c: 4410         	add	r0, r2
700a508e: 6bb2         	ldr	r2, [r6, #0x38]
700a5090: 4408         	add	r0, r1
700a5092: 6bf1         	ldr	r1, [r6, #0x3c]
700a5094: 4410         	add	r0, r2
700a5096: 6c32         	ldr	r2, [r6, #0x40]
700a5098: 4408         	add	r0, r1
700a509a: 6c71         	ldr	r1, [r6, #0x44]
700a509c: 4410         	add	r0, r2
700a509e: 6cb2         	ldr	r2, [r6, #0x48]
700a50a0: 4408         	add	r0, r1
700a50a2: 6cf1         	ldr	r1, [r6, #0x4c]
700a50a4: 4410         	add	r0, r2
700a50a6: 6d32         	ldr	r2, [r6, #0x50]
700a50a8: 4408         	add	r0, r1
700a50aa: 6d71         	ldr	r1, [r6, #0x54]
700a50ac: 4410         	add	r0, r2
700a50ae: 6db2         	ldr	r2, [r6, #0x58]
700a50b0: 4408         	add	r0, r1
700a50b2: 6df1         	ldr	r1, [r6, #0x5c]
700a50b4: 4410         	add	r0, r2
700a50b6: 6e32         	ldr	r2, [r6, #0x60]
700a50b8: 4408         	add	r0, r1
700a50ba: 6e71         	ldr	r1, [r6, #0x64]
700a50bc: 4410         	add	r0, r2
700a50be: 6eb2         	ldr	r2, [r6, #0x68]
700a50c0: 4408         	add	r0, r1
700a50c2: 6ef1         	ldr	r1, [r6, #0x6c]
700a50c4: 4410         	add	r0, r2
700a50c6: 6f32         	ldr	r2, [r6, #0x70]
700a50c8: 4408         	add	r0, r1
700a50ca: 6f71         	ldr	r1, [r6, #0x74]
700a50cc: 4410         	add	r0, r2
700a50ce: 6fb2         	ldr	r2, [r6, #0x78]
700a50d0: 4408         	add	r0, r1
;    tm_pmu_profile_start(pmu_send_names[isr_message_counter]);
700a50d2: f644 1178    	movw	r1, #0x4978
700a50d6: f2c7 0108    	movt	r1, #0x7008
;       checksum += msg[i];
700a50da: 4410         	add	r0, r2
;    message[MESSAGE_SIZE - 1] = compute_checksum(message, MESSAGE_SIZE - 1);
700a50dc: 67f0         	str	r0, [r6, #0x7c]
;    tm_pmu_profile_start(pmu_send_names[isr_message_counter]);
700a50de: 6828         	ldr	r0, [r5]
700a50e0: eb01 1000    	add.w	r0, r1, r0, lsl #4
700a50e4: f00a fcdc    	bl	0x700afaa0 <tm_pmu_profile_start> @ imm = #0xa9b8
;    tm_queue_send_from_isr(0, message);
700a50e8: 4631         	mov	r1, r6
700a50ea: 2000         	movs	r0, #0x0
700a50ec: f009 fb68    	bl	0x700ae7c0 <tm_queue_send_from_isr> @ imm = #0x96d0
;    isr_message_counter++; /* Prepare for next iteration */
700a50f0: 6828         	ldr	r0, [r5]
700a50f2: 3001         	adds	r0, #0x1
700a50f4: 6028         	str	r0, [r5]
; }
700a50f6: bd70         	pop	{r4, r5, r6, pc}
		...

700a5100 <Udma_eventCheckParams>:
; {
700a5100: b084         	sub	sp, #0x10
700a5102: 9003         	str	r0, [sp, #0xc]
700a5104: 9102         	str	r1, [sp, #0x8]
700a5106: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a5108: 9001         	str	r0, [sp, #0x4]
;     if(UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode)
700a510a: 9802         	ldr	r0, [sp, #0x8]
700a510c: 6840         	ldr	r0, [r0, #0x4]
700a510e: 2801         	cmp	r0, #0x1
700a5110: d109         	bne	0x700a5126 <Udma_eventCheckParams+0x26> @ imm = #0x12
700a5112: e7ff         	b	0x700a5114 <Udma_eventCheckParams+0x14> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a5114: 9802         	ldr	r0, [sp, #0x8]
700a5116: 6900         	ldr	r0, [r0, #0x10]
700a5118: b120         	cbz	r0, 0x700a5124 <Udma_eventCheckParams+0x24> @ imm = #0x8
700a511a: e7ff         	b	0x700a511c <Udma_eventCheckParams+0x1c> @ imm = #-0x2
700a511c: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a5120: 9001         	str	r0, [sp, #0x4]
;         }
700a5122: e7ff         	b	0x700a5124 <Udma_eventCheckParams+0x24> @ imm = #-0x2
;     }
700a5124: e7ff         	b	0x700a5126 <Udma_eventCheckParams+0x26> @ imm = #-0x2
;     if(UDMA_EVENT_MODE_SHARED == eventPrms->eventMode)
700a5126: 9802         	ldr	r0, [sp, #0x8]
700a5128: 6840         	ldr	r0, [r0, #0x4]
700a512a: 2802         	cmp	r0, #0x2
700a512c: d126         	bne	0x700a517c <Udma_eventCheckParams+0x7c> @ imm = #0x4c
700a512e: e7ff         	b	0x700a5130 <Udma_eventCheckParams+0x30> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a5130: 9802         	ldr	r0, [sp, #0x8]
700a5132: 6900         	ldr	r0, [r0, #0x10]
700a5134: b308         	cbz	r0, 0x700a517a <Udma_eventCheckParams+0x7a> @ imm = #0x42
700a5136: e7ff         	b	0x700a5138 <Udma_eventCheckParams+0x38> @ imm = #-0x2
;             controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a5138: 9802         	ldr	r0, [sp, #0x8]
700a513a: 6900         	ldr	r0, [r0, #0x10]
700a513c: 9000         	str	r0, [sp]
;             if(((Udma_EventCallback) NULL_PTR != controllerEventHandle->eventPrms.eventCb) &&
700a513e: 9800         	ldr	r0, [sp]
700a5140: 69c0         	ldr	r0, [r0, #0x1c]
700a5142: b140         	cbz	r0, 0x700a5156 <Udma_eventCheckParams+0x56> @ imm = #0x10
700a5144: e7ff         	b	0x700a5146 <Udma_eventCheckParams+0x46> @ imm = #-0x2
;                ((Udma_EventCallback) NULL_PTR == eventPrms->eventCb))
700a5146: 9802         	ldr	r0, [sp, #0x8]
700a5148: 6940         	ldr	r0, [r0, #0x14]
;             if(((Udma_EventCallback) NULL_PTR != controllerEventHandle->eventPrms.eventCb) &&
700a514a: b920         	cbnz	r0, 0x700a5156 <Udma_eventCheckParams+0x56> @ imm = #0x8
700a514c: e7ff         	b	0x700a514e <Udma_eventCheckParams+0x4e> @ imm = #-0x2
700a514e: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a5152: 9001         	str	r0, [sp, #0x4]
;             }
700a5154: e7ff         	b	0x700a5156 <Udma_eventCheckParams+0x56> @ imm = #-0x2
;             if(((Udma_EventCallback) NULL_PTR == controllerEventHandle->eventPrms.eventCb) &&
700a5156: 9800         	ldr	r0, [sp]
700a5158: 69c0         	ldr	r0, [r0, #0x1c]
700a515a: b968         	cbnz	r0, 0x700a5178 <Udma_eventCheckParams+0x78> @ imm = #0x1a
700a515c: e7ff         	b	0x700a515e <Udma_eventCheckParams+0x5e> @ imm = #-0x2
;                ((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
700a515e: 9802         	ldr	r0, [sp, #0x8]
700a5160: 6940         	ldr	r0, [r0, #0x14]
700a5162: b148         	cbz	r0, 0x700a5178 <Udma_eventCheckParams+0x78> @ imm = #0x12
700a5164: e7ff         	b	0x700a5166 <Udma_eventCheckParams+0x66> @ imm = #-0x2
;                (UDMA_EVENT_TYPE_MASTER != controllerEventHandle->eventPrms.eventType))
700a5166: 9800         	ldr	r0, [sp]
700a5168: 6880         	ldr	r0, [r0, #0x8]
;             if(((Udma_EventCallback) NULL_PTR == controllerEventHandle->eventPrms.eventCb) &&
700a516a: 2805         	cmp	r0, #0x5
700a516c: d004         	beq	0x700a5178 <Udma_eventCheckParams+0x78> @ imm = #0x8
700a516e: e7ff         	b	0x700a5170 <Udma_eventCheckParams+0x70> @ imm = #-0x2
700a5170: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a5174: 9001         	str	r0, [sp, #0x4]
;             }
700a5176: e7ff         	b	0x700a5178 <Udma_eventCheckParams+0x78> @ imm = #-0x2
;         }
700a5178: e7ff         	b	0x700a517a <Udma_eventCheckParams+0x7a> @ imm = #-0x2
;     }
700a517a: e7ff         	b	0x700a517c <Udma_eventCheckParams+0x7c> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a517c: 9802         	ldr	r0, [sp, #0x8]
700a517e: 6800         	ldr	r0, [r0]
700a5180: 2801         	cmp	r0, #0x1
700a5182: d00f         	beq	0x700a51a4 <Udma_eventCheckParams+0xa4> @ imm = #0x1e
700a5184: e7ff         	b	0x700a5186 <Udma_eventCheckParams+0x86> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType) ||
700a5186: 9802         	ldr	r0, [sp, #0x8]
700a5188: 6800         	ldr	r0, [r0]
700a518a: 2806         	cmp	r0, #0x6
700a518c: d00a         	beq	0x700a51a4 <Udma_eventCheckParams+0xa4> @ imm = #0x14
700a518e: e7ff         	b	0x700a5190 <Udma_eventCheckParams+0x90> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType) ||
700a5190: 9802         	ldr	r0, [sp, #0x8]
700a5192: 6800         	ldr	r0, [r0]
700a5194: 2802         	cmp	r0, #0x2
700a5196: d005         	beq	0x700a51a4 <Udma_eventCheckParams+0xa4> @ imm = #0xa
700a5198: e7ff         	b	0x700a519a <Udma_eventCheckParams+0x9a> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TR == eventPrms->eventType))
700a519a: 9802         	ldr	r0, [sp, #0x8]
700a519c: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a519e: 2803         	cmp	r0, #0x3
700a51a0: d109         	bne	0x700a51b6 <Udma_eventCheckParams+0xb6> @ imm = #0x12
700a51a2: e7ff         	b	0x700a51a4 <Udma_eventCheckParams+0xa4> @ imm = #-0x2
;         if(NULL_PTR == eventPrms->chHandle)
700a51a4: 9802         	ldr	r0, [sp, #0x8]
700a51a6: 6880         	ldr	r0, [r0, #0x8]
700a51a8: b920         	cbnz	r0, 0x700a51b4 <Udma_eventCheckParams+0xb4> @ imm = #0x8
700a51aa: e7ff         	b	0x700a51ac <Udma_eventCheckParams+0xac> @ imm = #-0x2
700a51ac: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a51b0: 9001         	str	r0, [sp, #0x4]
;         }
700a51b2: e7ff         	b	0x700a51b4 <Udma_eventCheckParams+0xb4> @ imm = #-0x2
;     }
700a51b4: e7ff         	b	0x700a51b6 <Udma_eventCheckParams+0xb6> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
700a51b6: 9802         	ldr	r0, [sp, #0x8]
700a51b8: 6800         	ldr	r0, [r0]
700a51ba: 2804         	cmp	r0, #0x4
700a51bc: d109         	bne	0x700a51d2 <Udma_eventCheckParams+0xd2> @ imm = #0x12
700a51be: e7ff         	b	0x700a51c0 <Udma_eventCheckParams+0xc0> @ imm = #-0x2
;         if(NULL_PTR == eventPrms->ringHandle)
700a51c0: 9802         	ldr	r0, [sp, #0x8]
700a51c2: 68c0         	ldr	r0, [r0, #0xc]
700a51c4: b920         	cbnz	r0, 0x700a51d0 <Udma_eventCheckParams+0xd0> @ imm = #0x8
700a51c6: e7ff         	b	0x700a51c8 <Udma_eventCheckParams+0xc8> @ imm = #-0x2
700a51c8: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a51cc: 9001         	str	r0, [sp, #0x4]
;         }
700a51ce: e7ff         	b	0x700a51d0 <Udma_eventCheckParams+0xd0> @ imm = #-0x2
;     }
700a51d0: e7ff         	b	0x700a51d2 <Udma_eventCheckParams+0xd2> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_MASTER == eventPrms->eventType)
700a51d2: 9802         	ldr	r0, [sp, #0x8]
700a51d4: 6800         	ldr	r0, [r0]
700a51d6: 2805         	cmp	r0, #0x5
700a51d8: d112         	bne	0x700a5200 <Udma_eventCheckParams+0x100> @ imm = #0x24
700a51da: e7ff         	b	0x700a51dc <Udma_eventCheckParams+0xdc> @ imm = #-0x2
;         if(UDMA_EVENT_MODE_SHARED != eventPrms->eventMode)
700a51dc: 9802         	ldr	r0, [sp, #0x8]
700a51de: 6840         	ldr	r0, [r0, #0x4]
700a51e0: 2802         	cmp	r0, #0x2
700a51e2: d004         	beq	0x700a51ee <Udma_eventCheckParams+0xee> @ imm = #0x8
700a51e4: e7ff         	b	0x700a51e6 <Udma_eventCheckParams+0xe6> @ imm = #-0x2
700a51e6: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a51ea: 9001         	str	r0, [sp, #0x4]
;         }
700a51ec: e7ff         	b	0x700a51ee <Udma_eventCheckParams+0xee> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a51ee: 9802         	ldr	r0, [sp, #0x8]
700a51f0: 6900         	ldr	r0, [r0, #0x10]
700a51f2: b120         	cbz	r0, 0x700a51fe <Udma_eventCheckParams+0xfe> @ imm = #0x8
700a51f4: e7ff         	b	0x700a51f6 <Udma_eventCheckParams+0xf6> @ imm = #-0x2
700a51f6: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a51fa: 9001         	str	r0, [sp, #0x4]
;         }
700a51fc: e7ff         	b	0x700a51fe <Udma_eventCheckParams+0xfe> @ imm = #-0x2
;     }
700a51fe: e7ff         	b	0x700a5200 <Udma_eventCheckParams+0x100> @ imm = #-0x2
;     return (retVal);
700a5200: 9801         	ldr	r0, [sp, #0x4]
700a5202: b004         	add	sp, #0x10
700a5204: 4770         	bx	lr
		...
700a520e: 0000         	movs	r0, r0

700a5210 <CSL_pktdmaTeardownChan>:
; {
700a5210: b580         	push	{r7, lr}
700a5212: b088         	sub	sp, #0x20
700a5214: 4684         	mov	r12, r0
700a5216: 980a         	ldr	r0, [sp, #0x28]
700a5218: f8cd c01c    	str.w	r12, [sp, #0x1c]
700a521c: 9106         	str	r1, [sp, #0x18]
700a521e: 9205         	str	r2, [sp, #0x14]
700a5220: f88d 3013    	strb.w	r3, [sp, #0x13]
700a5224: f88d 0012    	strb.w	r0, [sp, #0x12]
700a5228: 2000         	movs	r0, #0x0
;     int32_t  retVal = CSL_PASS;
700a522a: 9003         	str	r0, [sp, #0xc]
;     if( (pCfg == NULL) || (CSL_pktdmaIsValidChanIdx( pCfg, chanIdx, chanDir) == (bool)false) )
700a522c: 9807         	ldr	r0, [sp, #0x1c]
700a522e: b138         	cbz	r0, 0x700a5240 <CSL_pktdmaTeardownChan+0x30> @ imm = #0xe
700a5230: e7ff         	b	0x700a5232 <CSL_pktdmaTeardownChan+0x22> @ imm = #-0x2
700a5232: 9807         	ldr	r0, [sp, #0x1c]
700a5234: 9906         	ldr	r1, [sp, #0x18]
700a5236: 9a05         	ldr	r2, [sp, #0x14]
700a5238: f007 fc72    	bl	0x700acb20 <CSL_pktdmaIsValidChanIdx> @ imm = #0x78e4
700a523c: b920         	cbnz	r0, 0x700a5248 <CSL_pktdmaTeardownChan+0x38> @ imm = #0x8
700a523e: e7ff         	b	0x700a5240 <CSL_pktdmaTeardownChan+0x30> @ imm = #-0x2
700a5240: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a5244: 9003         	str	r0, [sp, #0xc]
;     }
700a5246: e062         	b	0x700a530e <CSL_pktdmaTeardownChan+0xfe> @ imm = #0xc4
;         if( CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true )
700a5248: 9807         	ldr	r0, [sp, #0x1c]
700a524a: 9906         	ldr	r1, [sp, #0x18]
700a524c: 9a05         	ldr	r2, [sp, #0x14]
700a524e: f007 fe97    	bl	0x700acf80 <CSL_pktdmaIsChanEnabled> @ imm = #0x7d2e
700a5252: 2800         	cmp	r0, #0x0
700a5254: d056         	beq	0x700a5304 <CSL_pktdmaTeardownChan+0xf4> @ imm = #0xac
700a5256: e7ff         	b	0x700a5258 <CSL_pktdmaTeardownChan+0x48> @ imm = #-0x2
;             if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700a5258: 9805         	ldr	r0, [sp, #0x14]
700a525a: b9a8         	cbnz	r0, 0x700a5288 <CSL_pktdmaTeardownChan+0x78> @ imm = #0x2a
700a525c: e7ff         	b	0x700a525e <CSL_pktdmaTeardownChan+0x4e> @ imm = #-0x2
;                 regVal = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a525e: 9807         	ldr	r0, [sp, #0x1c]
700a5260: 6900         	ldr	r0, [r0, #0x10]
700a5262: 9906         	ldr	r1, [sp, #0x18]
700a5264: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a5268: f00a fb52    	bl	0x700af910 <CSL_REG32_RD_RAW> @ imm = #0xa6a4
700a526c: 9002         	str	r0, [sp, #0x8]
;                 CSL_FINS( regVal, PKTDMA_TXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a526e: 9802         	ldr	r0, [sp, #0x8]
700a5270: f040 4080    	orr	r0, r0, #0x40000000
700a5274: 9002         	str	r0, [sp, #0x8]
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a5276: 9807         	ldr	r0, [sp, #0x1c]
700a5278: 6900         	ldr	r0, [r0, #0x10]
700a527a: 9906         	ldr	r1, [sp, #0x18]
700a527c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a5280: 9902         	ldr	r1, [sp, #0x8]
700a5282: f00a fa9d    	bl	0x700af7c0 <CSL_REG32_WR_RAW> @ imm = #0xa53a
;             }
700a5286: e014         	b	0x700a52b2 <CSL_pktdmaTeardownChan+0xa2> @ imm = #0x28
;                 regVal = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a5288: 9807         	ldr	r0, [sp, #0x1c]
700a528a: 6940         	ldr	r0, [r0, #0x14]
700a528c: 9906         	ldr	r1, [sp, #0x18]
700a528e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a5292: f00a fb3d    	bl	0x700af910 <CSL_REG32_RD_RAW> @ imm = #0xa67a
700a5296: 9002         	str	r0, [sp, #0x8]
;                 CSL_FINS( regVal, PKTDMA_RXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a5298: 9802         	ldr	r0, [sp, #0x8]
700a529a: f040 4080    	orr	r0, r0, #0x40000000
700a529e: 9002         	str	r0, [sp, #0x8]
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a52a0: 9807         	ldr	r0, [sp, #0x1c]
700a52a2: 6940         	ldr	r0, [r0, #0x14]
700a52a4: 9906         	ldr	r1, [sp, #0x18]
700a52a6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a52aa: 9902         	ldr	r1, [sp, #0x8]
700a52ac: f00a fa88    	bl	0x700af7c0 <CSL_REG32_WR_RAW> @ imm = #0xa510
700a52b0: e7ff         	b	0x700a52b2 <CSL_pktdmaTeardownChan+0xa2> @ imm = #-0x2
;             if( bWait == (bool)true )
700a52b2: f89d 0012    	ldrb.w	r0, [sp, #0x12]
700a52b6: 07c0         	lsls	r0, r0, #0x1f
700a52b8: b318         	cbz	r0, 0x700a5302 <CSL_pktdmaTeardownChan+0xf2> @ imm = #0x46
700a52ba: e7ff         	b	0x700a52bc <CSL_pktdmaTeardownChan+0xac> @ imm = #-0x2
700a52bc: 2080         	movs	r0, #0x80
;                 uint32_t retryCnt = CSL_PKTDMA_TEARDOWN_COMPLETE_WAIT_MAX_CNT;
700a52be: 9001         	str	r0, [sp, #0x4]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a52c0: e7ff         	b	0x700a52c2 <CSL_pktdmaTeardownChan+0xb2> @ imm = #-0x2
700a52c2: 9807         	ldr	r0, [sp, #0x1c]
700a52c4: 9906         	ldr	r1, [sp, #0x18]
700a52c6: 9a05         	ldr	r2, [sp, #0x14]
700a52c8: f007 fe5a    	bl	0x700acf80 <CSL_pktdmaIsChanEnabled> @ imm = #0x7cb4
700a52cc: 4601         	mov	r1, r0
700a52ce: 2000         	movs	r0, #0x0
700a52d0: 9000         	str	r0, [sp]
700a52d2: b131         	cbz	r1, 0x700a52e2 <CSL_pktdmaTeardownChan+0xd2> @ imm = #0xc
700a52d4: e7ff         	b	0x700a52d6 <CSL_pktdmaTeardownChan+0xc6> @ imm = #-0x2
700a52d6: 9801         	ldr	r0, [sp, #0x4]
700a52d8: 2800         	cmp	r0, #0x0
700a52da: bf18         	it	ne
700a52dc: 2001         	movne	r0, #0x1
700a52de: 9000         	str	r0, [sp]
700a52e0: e7ff         	b	0x700a52e2 <CSL_pktdmaTeardownChan+0xd2> @ imm = #-0x2
700a52e2: 9800         	ldr	r0, [sp]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a52e4: 07c0         	lsls	r0, r0, #0x1f
700a52e6: b120         	cbz	r0, 0x700a52f2 <CSL_pktdmaTeardownChan+0xe2> @ imm = #0x8
700a52e8: e7ff         	b	0x700a52ea <CSL_pktdmaTeardownChan+0xda> @ imm = #-0x2
;                     retryCnt--;
700a52ea: 9801         	ldr	r0, [sp, #0x4]
700a52ec: 3801         	subs	r0, #0x1
700a52ee: 9001         	str	r0, [sp, #0x4]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a52f0: e7e7         	b	0x700a52c2 <CSL_pktdmaTeardownChan+0xb2> @ imm = #-0x32
;                 if( retryCnt == (uint32_t)0U ) {
700a52f2: 9801         	ldr	r0, [sp, #0x4]
700a52f4: b920         	cbnz	r0, 0x700a5300 <CSL_pktdmaTeardownChan+0xf0> @ imm = #0x8
700a52f6: e7ff         	b	0x700a52f8 <CSL_pktdmaTeardownChan+0xe8> @ imm = #-0x2
700a52f8: f04f 30ff    	mov.w	r0, #0xffffffff
;                     retVal = CSL_EFAIL;
700a52fc: 9003         	str	r0, [sp, #0xc]
;                 }
700a52fe: e7ff         	b	0x700a5300 <CSL_pktdmaTeardownChan+0xf0> @ imm = #-0x2
;             }
700a5300: e7ff         	b	0x700a5302 <CSL_pktdmaTeardownChan+0xf2> @ imm = #-0x2
;         }
700a5302: e003         	b	0x700a530c <CSL_pktdmaTeardownChan+0xfc> @ imm = #0x6
700a5304: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = CSL_EFAIL;
700a5308: 9003         	str	r0, [sp, #0xc]
700a530a: e7ff         	b	0x700a530c <CSL_pktdmaTeardownChan+0xfc> @ imm = #-0x2
700a530c: e7ff         	b	0x700a530e <CSL_pktdmaTeardownChan+0xfe> @ imm = #-0x2
;     return retVal;
700a530e: 9803         	ldr	r0, [sp, #0xc]
700a5310: b008         	add	sp, #0x20
700a5312: bd80         	pop	{r7, pc}
		...

700a5320 <UART_configInstance>:
; {
700a5320: b580         	push	{r7, lr}
700a5322: b088         	sub	sp, #0x20
700a5324: 9007         	str	r0, [sp, #0x1c]
;     baseAddr = hUart->baseAddr;
700a5326: 9807         	ldr	r0, [sp, #0x1c]
700a5328: 6800         	ldr	r0, [r0]
700a532a: 9006         	str	r0, [sp, #0x18]
;     hUartInit = hUart->hUartInit;
700a532c: 9807         	ldr	r0, [sp, #0x1c]
700a532e: 6840         	ldr	r0, [r0, #0x4]
700a5330: 9001         	str	r0, [sp, #0x4]
;     UART_resetModule(hUart);
700a5332: 9807         	ldr	r0, [sp, #0x1c]
700a5334: f008 f82c    	bl	0x700ad390 <UART_resetModule> @ imm = #0x8058
;     if(UART_CONFIG_MODE_DMA == hUartInit->transferMode)
700a5338: 9801         	ldr	r0, [sp, #0x4]
700a533a: 6a00         	ldr	r0, [r0, #0x20]
700a533c: 2803         	cmp	r0, #0x3
700a533e: d10e         	bne	0x700a535e <UART_configInstance+0x3e> @ imm = #0x1c
700a5340: e7ff         	b	0x700a5342 <UART_configInstance+0x22> @ imm = #-0x2
;         regVal = UART_FIFO_CONFIG(UART_TRIG_LVL_GRANULARITY_1,
700a5342: 9801         	ldr	r0, [sp, #0x4]
700a5344: f890 1038    	ldrb.w	r1, [r0, #0x38]
700a5348: f890 003c    	ldrb.w	r0, [r0, #0x3c]
700a534c: 0380         	lsls	r0, r0, #0xe
700a534e: ea40 1081    	orr.w	r0, r0, r1, lsl #6
700a5352: 2131         	movs	r1, #0x31
700a5354: f2c0 4140    	movt	r1, #0x440
700a5358: 4308         	orrs	r0, r1
700a535a: 9005         	str	r0, [sp, #0x14]
;     }
700a535c: e00d         	b	0x700a537a <UART_configInstance+0x5a> @ imm = #0x1a
;         regVal = UART_FIFO_CONFIG(UART_TRIG_LVL_GRANULARITY_1,
700a535e: 9801         	ldr	r0, [sp, #0x4]
700a5360: f890 1038    	ldrb.w	r1, [r0, #0x38]
700a5364: f890 003c    	ldrb.w	r0, [r0, #0x3c]
700a5368: 0380         	lsls	r0, r0, #0xe
700a536a: ea40 1081    	orr.w	r0, r0, r1, lsl #6
700a536e: 2130         	movs	r1, #0x30
700a5370: f2c0 4140    	movt	r1, #0x440
700a5374: 4308         	orrs	r0, r1
700a5376: 9005         	str	r0, [sp, #0x14]
700a5378: e7ff         	b	0x700a537a <UART_configInstance+0x5a> @ imm = #-0x2
;     (void)UART_fifoConfig(baseAddr, regVal);
700a537a: 9806         	ldr	r0, [sp, #0x18]
700a537c: 9905         	ldr	r1, [sp, #0x14]
700a537e: f7f8 ff37    	bl	0x7009e1f0 <UART_fifoConfig> @ imm = #-0x7192
;     UART_timeGuardConfig(baseAddr, hUartInit->timeGuardVal);
700a5382: 9806         	ldr	r0, [sp, #0x18]
700a5384: 9901         	ldr	r1, [sp, #0x4]
700a5386: 6d09         	ldr	r1, [r1, #0x50]
700a5388: f009 fff2    	bl	0x700af370 <UART_timeGuardConfig> @ imm = #0x9fe4
;     divisorVal = UART_divisorValCompute(hUartInit->inputClkFreq,
700a538c: 9a01         	ldr	r2, [sp, #0x4]
700a538e: 6810         	ldr	r0, [r2]
;                                     hUartInit->baudRate,
700a5390: 6851         	ldr	r1, [r2, #0x4]
;                                     hUartInit->operMode,
700a5392: 6ad2         	ldr	r2, [r2, #0x2c]
700a5394: 232a         	movs	r3, #0x2a
;     divisorVal = UART_divisorValCompute(hUartInit->inputClkFreq,
700a5396: f006 fa53    	bl	0x700ab840 <UART_divisorValCompute> @ imm = #0x64a6
700a539a: 9004         	str	r0, [sp, #0x10]
;     (void)UART_divisorLatchWrite(baseAddr, divisorVal);
700a539c: 9806         	ldr	r0, [sp, #0x18]
700a539e: 9904         	ldr	r1, [sp, #0x10]
700a53a0: f7ff fade    	bl	0x700a4960 <UART_divisorLatchWrite> @ imm = #-0xa44
;     (void)UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a53a4: 9806         	ldr	r0, [sp, #0x18]
700a53a6: 21bf         	movs	r1, #0xbf
700a53a8: f007 f8c2    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #0x7184
;     wLenStbFlag = (hUartInit->dataLength << UART_LCR_CHAR_LENGTH_SHIFT);
700a53ac: 9801         	ldr	r0, [sp, #0x4]
700a53ae: 6880         	ldr	r0, [r0, #0x8]
700a53b0: 9003         	str	r0, [sp, #0xc]
;     wLenStbFlag |= (hUartInit->stopBits << UART_LCR_NB_STOP_SHIFT);
700a53b2: 9801         	ldr	r0, [sp, #0x4]
700a53b4: 68c1         	ldr	r1, [r0, #0xc]
700a53b6: 9803         	ldr	r0, [sp, #0xc]
700a53b8: ea40 0081    	orr.w	r0, r0, r1, lsl #2
700a53bc: 9003         	str	r0, [sp, #0xc]
;     parityFlag = (hUartInit->parityType << UART_LCR_PARITY_EN_SHIFT);
700a53be: 9801         	ldr	r0, [sp, #0x4]
700a53c0: 6900         	ldr	r0, [r0, #0x10]
700a53c2: 00c0         	lsls	r0, r0, #0x3
700a53c4: 9002         	str	r0, [sp, #0x8]
;     UART_lineCharConfig(baseAddr, wLenStbFlag, parityFlag);
700a53c6: 9806         	ldr	r0, [sp, #0x18]
700a53c8: 9903         	ldr	r1, [sp, #0xc]
700a53ca: 9a02         	ldr	r2, [sp, #0x8]
700a53cc: f007 ff68    	bl	0x700ad2a0 <UART_lineCharConfig> @ imm = #0x7ed0
;     UART_divisorLatchDisable(baseAddr);
700a53d0: 9806         	ldr	r0, [sp, #0x18]
700a53d2: f00a f82d    	bl	0x700af430 <UART_divisorLatchDisable> @ imm = #0xa05a
;     UART_breakCtl(baseAddr, UART_BREAK_COND_DISABLE);
700a53d6: 9806         	ldr	r0, [sp, #0x18]
700a53d8: 2100         	movs	r1, #0x0
700a53da: f009 fed9    	bl	0x700af190 <UART_breakCtl> @ imm = #0x9db2
;     (void)UART_operatingModeSelect(baseAddr, hUartInit->operMode);
700a53de: 9806         	ldr	r0, [sp, #0x18]
700a53e0: 9901         	ldr	r1, [sp, #0x4]
700a53e2: 6ac9         	ldr	r1, [r1, #0x2c]
700a53e4: f009 fbcc    	bl	0x700aeb80 <UART_operatingModeSelect> @ imm = #0x9798
;     if (hUartInit->hwFlowControl == (uint32_t)TRUE)
700a53e8: 9801         	ldr	r0, [sp, #0x4]
700a53ea: 6980         	ldr	r0, [r0, #0x18]
700a53ec: 2801         	cmp	r0, #0x1
700a53ee: d112         	bne	0x700a5416 <UART_configInstance+0xf6> @ imm = #0x24
700a53f0: e7ff         	b	0x700a53f2 <UART_configInstance+0xd2> @ imm = #-0x2
;         UART_hardwareFlowCtrlOptSet(baseAddr, UART_RTS_CTS_ENABLE);
700a53f2: 9806         	ldr	r0, [sp, #0x18]
700a53f4: 2103         	movs	r1, #0x3
700a53f6: f009 f84b    	bl	0x700ae490 <UART_hardwareFlowCtrlOptSet> @ imm = #0x9096
;         if (hUartInit->hwFlowControlThr >= hUartInit->rxTrigLvl)
700a53fa: 9901         	ldr	r1, [sp, #0x4]
700a53fc: 69c8         	ldr	r0, [r1, #0x1c]
700a53fe: 6b89         	ldr	r1, [r1, #0x38]
700a5400: 4288         	cmp	r0, r1
700a5402: d307         	blo	0x700a5414 <UART_configInstance+0xf4> @ imm = #0xe
700a5404: e7ff         	b	0x700a5406 <UART_configInstance+0xe6> @ imm = #-0x2
;             UART_flowCtrlTrigLvlConfig(baseAddr,
700a5406: 9806         	ldr	r0, [sp, #0x18]
;                                     hUartInit->hwFlowControlThr,
700a5408: 9a01         	ldr	r2, [sp, #0x4]
700a540a: 69d1         	ldr	r1, [r2, #0x1c]
;                                     hUartInit->rxTrigLvl);
700a540c: 6b92         	ldr	r2, [r2, #0x38]
;             UART_flowCtrlTrigLvlConfig(baseAddr,
700a540e: f009 f8cf    	bl	0x700ae5b0 <UART_flowCtrlTrigLvlConfig> @ imm = #0x919e
;         }
700a5412: e7ff         	b	0x700a5414 <UART_configInstance+0xf4> @ imm = #-0x2
;     }
700a5414: e004         	b	0x700a5420 <UART_configInstance+0x100> @ imm = #0x8
;         UART_hardwareFlowCtrlOptSet(baseAddr, UART_NO_HARDWARE_FLOW_CONTROL);
700a5416: 9806         	ldr	r0, [sp, #0x18]
700a5418: 2100         	movs	r1, #0x0
700a541a: f009 f839    	bl	0x700ae490 <UART_hardwareFlowCtrlOptSet> @ imm = #0x9072
700a541e: e7ff         	b	0x700a5420 <UART_configInstance+0x100> @ imm = #-0x2
;     return;
700a5420: b008         	add	sp, #0x20
700a5422: bd80         	pop	{r7, pc}
		...

700a5430 <Sciclient_rmIrGetOutp>:
; {
700a5430: b580         	push	{r7, lr}
700a5432: b088         	sub	sp, #0x20
700a5434: f8ad 001e    	strh.w	r0, [sp, #0x1e]
700a5438: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a543c: 9206         	str	r2, [sp, #0x18]
700a543e: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a5440: 9005         	str	r0, [sp, #0x14]
;     const struct Sciclient_rmIrInst *inst = NULL;
700a5442: 9004         	str	r0, [sp, #0x10]
;     if (outp == NULL) {
700a5444: 9806         	ldr	r0, [sp, #0x18]
700a5446: b920         	cbnz	r0, 0x700a5452 <Sciclient_rmIrGetOutp+0x22> @ imm = #0x8
700a5448: e7ff         	b	0x700a544a <Sciclient_rmIrGetOutp+0x1a> @ imm = #-0x2
700a544a: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a544e: 9005         	str	r0, [sp, #0x14]
;     } else {
700a5450: e018         	b	0x700a5484 <Sciclient_rmIrGetOutp+0x54> @ imm = #0x30
;         inst = Sciclient_rmIrGetInst(id);
700a5452: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
700a5456: f006 fa63    	bl	0x700ab920 <Sciclient_rmIrGetInst> @ imm = #0x64c6
700a545a: 9004         	str	r0, [sp, #0x10]
;         if (inst == NULL) {
700a545c: 9804         	ldr	r0, [sp, #0x10]
700a545e: b920         	cbnz	r0, 0x700a546a <Sciclient_rmIrGetOutp+0x3a> @ imm = #0x8
700a5460: e7ff         	b	0x700a5462 <Sciclient_rmIrGetOutp+0x32> @ imm = #-0x2
700a5462: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a5466: 9005         	str	r0, [sp, #0x14]
;         } else {
700a5468: e00b         	b	0x700a5482 <Sciclient_rmIrGetOutp+0x52> @ imm = #0x16
;             if (inp >= inst->n_inp) {
700a546a: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a546e: 9904         	ldr	r1, [sp, #0x10]
700a5470: 8909         	ldrh	r1, [r1, #0x8]
700a5472: 4288         	cmp	r0, r1
700a5474: db04         	blt	0x700a5480 <Sciclient_rmIrGetOutp+0x50> @ imm = #0x8
700a5476: e7ff         	b	0x700a5478 <Sciclient_rmIrGetOutp+0x48> @ imm = #-0x2
700a5478: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a547c: 9005         	str	r0, [sp, #0x14]
;             }
700a547e: e7ff         	b	0x700a5480 <Sciclient_rmIrGetOutp+0x50> @ imm = #-0x2
700a5480: e7ff         	b	0x700a5482 <Sciclient_rmIrGetOutp+0x52> @ imm = #-0x2
700a5482: e7ff         	b	0x700a5484 <Sciclient_rmIrGetOutp+0x54> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (inp == 0u)) {
700a5484: 9805         	ldr	r0, [sp, #0x14]
700a5486: b9a8         	cbnz	r0, 0x700a54b4 <Sciclient_rmIrGetOutp+0x84> @ imm = #0x2a
700a5488: e7ff         	b	0x700a548a <Sciclient_rmIrGetOutp+0x5a> @ imm = #-0x2
700a548a: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a548e: b988         	cbnz	r0, 0x700a54b4 <Sciclient_rmIrGetOutp+0x84> @ imm = #0x22
700a5490: e7ff         	b	0x700a5492 <Sciclient_rmIrGetOutp+0x62> @ imm = #-0x2
;         if (inst->inp0_mapping != SCICLIENT_RM_IR_MAPPING_FREE) {
700a5492: 9804         	ldr	r0, [sp, #0x10]
700a5494: 8980         	ldrh	r0, [r0, #0xc]
700a5496: f64f 71ff    	movw	r1, #0xffff
700a549a: 4288         	cmp	r0, r1
700a549c: d005         	beq	0x700a54aa <Sciclient_rmIrGetOutp+0x7a> @ imm = #0xa
700a549e: e7ff         	b	0x700a54a0 <Sciclient_rmIrGetOutp+0x70> @ imm = #-0x2
;             *outp = inst->inp0_mapping;
700a54a0: 9804         	ldr	r0, [sp, #0x10]
700a54a2: 8980         	ldrh	r0, [r0, #0xc]
700a54a4: 9906         	ldr	r1, [sp, #0x18]
700a54a6: 8008         	strh	r0, [r1]
;         } else {
700a54a8: e003         	b	0x700a54b2 <Sciclient_rmIrGetOutp+0x82> @ imm = #0x6
700a54aa: f04f 30ff    	mov.w	r0, #0xffffffff
;             r = SystemP_FAILURE;
700a54ae: 9005         	str	r0, [sp, #0x14]
700a54b0: e7ff         	b	0x700a54b2 <Sciclient_rmIrGetOutp+0x82> @ imm = #-0x2
;     }
700a54b2: e7ff         	b	0x700a54b4 <Sciclient_rmIrGetOutp+0x84> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (inp != 0u)) {
700a54b4: 9805         	ldr	r0, [sp, #0x14]
700a54b6: bbb8         	cbnz	r0, 0x700a5528 <Sciclient_rmIrGetOutp+0xf8> @ imm = #0x6e
700a54b8: e7ff         	b	0x700a54ba <Sciclient_rmIrGetOutp+0x8a> @ imm = #-0x2
700a54ba: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a54be: b398         	cbz	r0, 0x700a5528 <Sciclient_rmIrGetOutp+0xf8> @ imm = #0x66
700a54c0: e7ff         	b	0x700a54c2 <Sciclient_rmIrGetOutp+0x92> @ imm = #-0x2
700a54c2: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a54c6: 9005         	str	r0, [sp, #0x14]
700a54c8: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_outp; i++) {
700a54ca: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a54ce: e7ff         	b	0x700a54d0 <Sciclient_rmIrGetOutp+0xa0> @ imm = #-0x2
700a54d0: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a54d4: 9904         	ldr	r1, [sp, #0x10]
700a54d6: 8949         	ldrh	r1, [r1, #0xa]
700a54d8: 4288         	cmp	r0, r1
700a54da: da24         	bge	0x700a5526 <Sciclient_rmIrGetOutp+0xf6> @ imm = #0x48
700a54dc: e7ff         	b	0x700a54de <Sciclient_rmIrGetOutp+0xae> @ imm = #-0x2
;             int_ctrl_reg = (volatile uint32_t *) Sciclient_getIrAddr (inst->cfg, i);
700a54de: 9804         	ldr	r0, [sp, #0x10]
700a54e0: 6840         	ldr	r0, [r0, #0x4]
700a54e2: f8bd 100e    	ldrh.w	r1, [sp, #0xe]
700a54e6: f009 fa13    	bl	0x700ae910 <Sciclient_getIrAddr> @ imm = #0x9426
700a54ea: 9002         	str	r0, [sp, #0x8]
;             extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a54ec: 9802         	ldr	r0, [sp, #0x8]
700a54ee: f240 31ff    	movw	r1, #0x3ff
700a54f2: 2200         	movs	r2, #0x0
700a54f4: f009 fcdc    	bl	0x700aeeb0 <CSL_REG32_FEXT_RAW> @ imm = #0x99b8
700a54f8: f8ad 0006    	strh.w	r0, [sp, #0x6]
;             if (inp == extracted_inp) {
700a54fc: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a5500: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700a5504: 4288         	cmp	r0, r1
700a5506: d107         	bne	0x700a5518 <Sciclient_rmIrGetOutp+0xe8> @ imm = #0xe
700a5508: e7ff         	b	0x700a550a <Sciclient_rmIrGetOutp+0xda> @ imm = #-0x2
;                 *outp = i;
700a550a: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a550e: 9906         	ldr	r1, [sp, #0x18]
700a5510: 8008         	strh	r0, [r1]
700a5512: 2000         	movs	r0, #0x0
;                 r = SystemP_SUCCESS;
700a5514: 9005         	str	r0, [sp, #0x14]
;                 break;
700a5516: e006         	b	0x700a5526 <Sciclient_rmIrGetOutp+0xf6> @ imm = #0xc
;         }
700a5518: e7ff         	b	0x700a551a <Sciclient_rmIrGetOutp+0xea> @ imm = #-0x2
;         for (i = 0u; i < inst->n_outp; i++) {
700a551a: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a551e: 3001         	adds	r0, #0x1
700a5520: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a5524: e7d4         	b	0x700a54d0 <Sciclient_rmIrGetOutp+0xa0> @ imm = #-0x58
;     }
700a5526: e7ff         	b	0x700a5528 <Sciclient_rmIrGetOutp+0xf8> @ imm = #-0x2
;     return r;
700a5528: 9805         	ldr	r0, [sp, #0x14]
700a552a: b008         	add	sp, #0x20
700a552c: bd80         	pop	{r7, pc}
700a552e: 0000         	movs	r0, r0

700a5530 <eTaskGetState>:
; eTaskState eTaskGetState(TaskHandle_t xTask) {
700a5530: b580         	push	{r7, lr}
700a5532: b088         	sub	sp, #0x20
700a5534: 9007         	str	r0, [sp, #0x1c]
;   const TCB_t *const pxTCB = xTask;
700a5536: 9807         	ldr	r0, [sp, #0x1c]
700a5538: 9002         	str	r0, [sp, #0x8]
;   if (pxTCB == pxCurrentTCB) {
700a553a: 9802         	ldr	r0, [sp, #0x8]
700a553c: f242 61bc    	movw	r1, #0x26bc
700a5540: f2c7 010b    	movt	r1, #0x700b
700a5544: 6809         	ldr	r1, [r1]
700a5546: 4288         	cmp	r0, r1
700a5548: d104         	bne	0x700a5554 <eTaskGetState+0x24> @ imm = #0x8
700a554a: e7ff         	b	0x700a554c <eTaskGetState+0x1c> @ imm = #-0x2
700a554c: 2000         	movs	r0, #0x0
;     eReturn = eRunning;
700a554e: f88d 001b    	strb.w	r0, [sp, #0x1b]
;   } else {
700a5552: e063         	b	0x700a561c <eTaskGetState+0xec> @ imm = #0xc6
;     taskENTER_CRITICAL();
700a5554: f008 ffbc    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0x8f78
;       pxStateList = listLIST_ITEM_CONTAINER(&(pxTCB->xStateListItem));
700a5558: 9802         	ldr	r0, [sp, #0x8]
700a555a: 6940         	ldr	r0, [r0, #0x14]
700a555c: 9005         	str	r0, [sp, #0x14]
;       pxDelayedList = pxDelayedTaskList;
700a555e: f245 2020    	movw	r0, #0x5220
700a5562: f2c7 0008    	movt	r0, #0x7008
700a5566: 6800         	ldr	r0, [r0]
700a5568: 9004         	str	r0, [sp, #0x10]
;       pxOverflowedDelayedList = pxOverflowDelayedTaskList;
700a556a: f245 2024    	movw	r0, #0x5224
700a556e: f2c7 0008    	movt	r0, #0x7008
700a5572: 6800         	ldr	r0, [r0]
700a5574: 9003         	str	r0, [sp, #0xc]
;     taskEXIT_CRITICAL();
700a5576: f008 f86b    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0x80d6
;     if ((pxStateList == pxDelayedList) ||
700a557a: 9805         	ldr	r0, [sp, #0x14]
700a557c: 9904         	ldr	r1, [sp, #0x10]
700a557e: 4288         	cmp	r0, r1
700a5580: d005         	beq	0x700a558e <eTaskGetState+0x5e> @ imm = #0xa
700a5582: e7ff         	b	0x700a5584 <eTaskGetState+0x54> @ imm = #-0x2
;         (pxStateList == pxOverflowedDelayedList)) {
700a5584: 9805         	ldr	r0, [sp, #0x14]
700a5586: 9903         	ldr	r1, [sp, #0xc]
;     if ((pxStateList == pxDelayedList) ||
700a5588: 4288         	cmp	r0, r1
700a558a: d104         	bne	0x700a5596 <eTaskGetState+0x66> @ imm = #0x8
700a558c: e7ff         	b	0x700a558e <eTaskGetState+0x5e> @ imm = #-0x2
700a558e: 2002         	movs	r0, #0x2
;       eReturn = eBlocked;
700a5590: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     }
700a5594: e041         	b	0x700a561a <eTaskGetState+0xea> @ imm = #0x82
;     else if (pxStateList == &xSuspendedTaskList) {
700a5596: 9805         	ldr	r0, [sp, #0x14]
700a5598: f245 11f4    	movw	r1, #0x51f4
700a559c: f2c7 0108    	movt	r1, #0x7008
700a55a0: 4288         	cmp	r0, r1
700a55a2: d125         	bne	0x700a55f0 <eTaskGetState+0xc0> @ imm = #0x4a
700a55a4: e7ff         	b	0x700a55a6 <eTaskGetState+0x76> @ imm = #-0x2
;       if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL) {
700a55a6: 9802         	ldr	r0, [sp, #0x8]
700a55a8: 6a80         	ldr	r0, [r0, #0x28]
700a55aa: b9e0         	cbnz	r0, 0x700a55e6 <eTaskGetState+0xb6> @ imm = #0x38
700a55ac: e7ff         	b	0x700a55ae <eTaskGetState+0x7e> @ imm = #-0x2
700a55ae: 2003         	movs	r0, #0x3
;           eReturn = eSuspended;
700a55b0: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a55b4: 2000         	movs	r0, #0x0
;           for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a55b6: 9001         	str	r0, [sp, #0x4]
700a55b8: e7ff         	b	0x700a55ba <eTaskGetState+0x8a> @ imm = #-0x2
700a55ba: 9801         	ldr	r0, [sp, #0x4]
700a55bc: 2800         	cmp	r0, #0x0
700a55be: dc11         	bgt	0x700a55e4 <eTaskGetState+0xb4> @ imm = #0x22
700a55c0: e7ff         	b	0x700a55c2 <eTaskGetState+0x92> @ imm = #-0x2
;             if (pxTCB->ucNotifyState[x] == taskWAITING_NOTIFICATION) {
700a55c2: 9802         	ldr	r0, [sp, #0x8]
700a55c4: 9901         	ldr	r1, [sp, #0x4]
700a55c6: 4408         	add	r0, r1
700a55c8: f890 0080    	ldrb.w	r0, [r0, #0x80]
700a55cc: 2801         	cmp	r0, #0x1
700a55ce: d104         	bne	0x700a55da <eTaskGetState+0xaa> @ imm = #0x8
700a55d0: e7ff         	b	0x700a55d2 <eTaskGetState+0xa2> @ imm = #-0x2
700a55d2: 2002         	movs	r0, #0x2
;               eReturn = eBlocked;
700a55d4: f88d 001b    	strb.w	r0, [sp, #0x1b]
;               break;
700a55d8: e004         	b	0x700a55e4 <eTaskGetState+0xb4> @ imm = #0x8
;           }
700a55da: e7ff         	b	0x700a55dc <eTaskGetState+0xac> @ imm = #-0x2
;           for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a55dc: 9801         	ldr	r0, [sp, #0x4]
700a55de: 3001         	adds	r0, #0x1
700a55e0: 9001         	str	r0, [sp, #0x4]
700a55e2: e7ea         	b	0x700a55ba <eTaskGetState+0x8a> @ imm = #-0x2c
;       } else {
700a55e4: e003         	b	0x700a55ee <eTaskGetState+0xbe> @ imm = #0x6
700a55e6: 2002         	movs	r0, #0x2
;         eReturn = eBlocked;
700a55e8: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a55ec: e7ff         	b	0x700a55ee <eTaskGetState+0xbe> @ imm = #-0x2
;     }
700a55ee: e013         	b	0x700a5618 <eTaskGetState+0xe8> @ imm = #0x26
;     else if ((pxStateList == &xTasksWaitingTermination) ||
700a55f0: 9805         	ldr	r0, [sp, #0x14]
700a55f2: f245 2108    	movw	r1, #0x5208
700a55f6: f2c7 0108    	movt	r1, #0x7008
700a55fa: 4288         	cmp	r0, r1
700a55fc: d003         	beq	0x700a5606 <eTaskGetState+0xd6> @ imm = #0x6
700a55fe: e7ff         	b	0x700a5600 <eTaskGetState+0xd0> @ imm = #-0x2
;              (pxStateList == NULL)) {
700a5600: 9805         	ldr	r0, [sp, #0x14]
;     else if ((pxStateList == &xTasksWaitingTermination) ||
700a5602: b920         	cbnz	r0, 0x700a560e <eTaskGetState+0xde> @ imm = #0x8
700a5604: e7ff         	b	0x700a5606 <eTaskGetState+0xd6> @ imm = #-0x2
700a5606: 2004         	movs	r0, #0x4
;       eReturn = eDeleted;
700a5608: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     }
700a560c: e003         	b	0x700a5616 <eTaskGetState+0xe6> @ imm = #0x6
700a560e: 2001         	movs	r0, #0x1
;       eReturn = eReady;
700a5610: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a5614: e7ff         	b	0x700a5616 <eTaskGetState+0xe6> @ imm = #-0x2
700a5616: e7ff         	b	0x700a5618 <eTaskGetState+0xe8> @ imm = #-0x2
700a5618: e7ff         	b	0x700a561a <eTaskGetState+0xea> @ imm = #-0x2
700a561a: e7ff         	b	0x700a561c <eTaskGetState+0xec> @ imm = #-0x2
;   return eReturn;
700a561c: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a5620: b008         	add	sp, #0x20
700a5622: bd80         	pop	{r7, pc}
		...

700a5630 <PMU_profileEnd>:
; int32_t PMU_profileEnd(const char *name) {
700a5630: b580         	push	{r7, lr}
700a5632: b090         	sub	sp, #0x40
700a5634: 900e         	str	r0, [sp, #0x38]
;   if (gProfileObject.logIndex >= PMU_MAX_LOG_ENTRIES) {
700a5636: f243 0080    	movw	r0, #0x3080
700a563a: f2c7 0008    	movt	r0, #0x7008
700a563e: 6800         	ldr	r0, [r0]
700a5640: 2840         	cmp	r0, #0x40
700a5642: d304         	blo	0x700a564e <PMU_profileEnd+0x1e> @ imm = #0x8
700a5644: e7ff         	b	0x700a5646 <PMU_profileEnd+0x16> @ imm = #-0x2
700a5646: f04f 30ff    	mov.w	r0, #0xffffffff
;     return SystemP_FAILURE; /* Log is full */
700a564a: 900f         	str	r0, [sp, #0x3c]
700a564c: e065         	b	0x700a571a <PMU_profileEnd+0xea> @ imm = #0xca
700a564e: 2000         	movs	r0, #0x0
;   int32_t status = SystemP_SUCCESS;
700a5650: 9000         	str	r0, [sp]
700a5652: 900d         	str	r0, [sp, #0x34]
700a5654: 201f         	movs	r0, #0x1f
;   uint32_t ccount = CSL_armR5PmuReadCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM);
700a5656: f7fc ecda    	blx	0x700a200c <CSL_armR5PmuReadCntr> @ imm = #-0x364c
700a565a: 4601         	mov	r1, r0
700a565c: 9800         	ldr	r0, [sp]
700a565e: 910c         	str	r1, [sp, #0x30]
;   uint32_t count0 = CSL_armR5PmuReadCntr(0);
700a5660: f7fc ecd4    	blx	0x700a200c <CSL_armR5PmuReadCntr> @ imm = #-0x3658
700a5664: 900b         	str	r0, [sp, #0x2c]
700a5666: 2001         	movs	r0, #0x1
;   uint32_t count1 = CSL_armR5PmuReadCntr(1);
700a5668: f7fc ecd0    	blx	0x700a200c <CSL_armR5PmuReadCntr> @ imm = #-0x3660
700a566c: 900a         	str	r0, [sp, #0x28]
700a566e: 2002         	movs	r0, #0x2
;   uint32_t count2 = CSL_armR5PmuReadCntr(2);
700a5670: f7fc eccc    	blx	0x700a200c <CSL_armR5PmuReadCntr> @ imm = #-0x3668
700a5674: 9009         	str	r0, [sp, #0x24]
;   uint32_t counts[3] = {count0, count1, count2};
700a5676: 980b         	ldr	r0, [sp, #0x2c]
700a5678: 9006         	str	r0, [sp, #0x18]
700a567a: 980a         	ldr	r0, [sp, #0x28]
700a567c: 9007         	str	r0, [sp, #0x1c]
700a567e: 9809         	ldr	r0, [sp, #0x24]
700a5680: 9008         	str	r0, [sp, #0x20]
;   uint32_t i = gProfileObject.logIndex;
700a5682: f243 0280    	movw	r2, #0x3080
700a5686: f2c7 0208    	movt	r2, #0x7008
700a568a: 6810         	ldr	r0, [r2]
700a568c: 9005         	str	r0, [sp, #0x14]
;   uint32_t numEvents = gProfileObject.numEvents;
700a568e: 6890         	ldr	r0, [r2, #0x8]
700a5690: 9003         	str	r0, [sp, #0xc]
;   uint32_t bCCnt = gProfileObject.bCycleCounter;
700a5692: 6850         	ldr	r0, [r2, #0x4]
700a5694: 9002         	str	r0, [sp, #0x8]
;   PMU_ProfilePoint *p = &gProfileObject.point[i];
700a5696: 9805         	ldr	r0, [sp, #0x14]
700a5698: 2134         	movs	r1, #0x34
700a569a: fb00 2001    	mla	r0, r0, r1, r2
700a569e: 300c         	adds	r0, #0xc
700a56a0: 9001         	str	r0, [sp, #0x4]
;   if (strcmp(name, p->name) != 0) {
700a56a2: 980e         	ldr	r0, [sp, #0x38]
700a56a4: 9901         	ldr	r1, [sp, #0x4]
700a56a6: 6b09         	ldr	r1, [r1, #0x30]
700a56a8: f7f6 edba    	blx	0x7009c220 <strcmp>     @ imm = #-0x948c
700a56ac: b120         	cbz	r0, 0x700a56b8 <PMU_profileEnd+0x88> @ imm = #0x8
700a56ae: e7ff         	b	0x700a56b0 <PMU_profileEnd+0x80> @ imm = #-0x2
700a56b0: f04f 30ff    	mov.w	r0, #0xffffffff
;     status = SystemP_FAILURE;
700a56b4: 900d         	str	r0, [sp, #0x34]
;   }
700a56b6: e7ff         	b	0x700a56b8 <PMU_profileEnd+0x88> @ imm = #-0x2
;   if (status == SystemP_SUCCESS) {
700a56b8: 980d         	ldr	r0, [sp, #0x34]
700a56ba: bb58         	cbnz	r0, 0x700a5714 <PMU_profileEnd+0xe4> @ imm = #0x56
700a56bc: e7ff         	b	0x700a56be <PMU_profileEnd+0x8e> @ imm = #-0x2
;     if (bCCnt == TRUE) {
700a56be: 9802         	ldr	r0, [sp, #0x8]
700a56c0: 2801         	cmp	r0, #0x1
700a56c2: d106         	bne	0x700a56d2 <PMU_profileEnd+0xa2> @ imm = #0xc
700a56c4: e7ff         	b	0x700a56c6 <PMU_profileEnd+0x96> @ imm = #-0x2
;       p->cycleCount.value = ccount - p->cycleCount.value;
700a56c6: 980c         	ldr	r0, [sp, #0x30]
700a56c8: 9901         	ldr	r1, [sp, #0x4]
700a56ca: 6aca         	ldr	r2, [r1, #0x2c]
700a56cc: 1a80         	subs	r0, r0, r2
700a56ce: 62c8         	str	r0, [r1, #0x2c]
;     }
700a56d0: e7ff         	b	0x700a56d2 <PMU_profileEnd+0xa2> @ imm = #-0x2
700a56d2: 2000         	movs	r0, #0x0
;     for (j = 0; j < numEvents; j++) {
700a56d4: 9004         	str	r0, [sp, #0x10]
700a56d6: e7ff         	b	0x700a56d8 <PMU_profileEnd+0xa8> @ imm = #-0x2
700a56d8: 9804         	ldr	r0, [sp, #0x10]
700a56da: 9903         	ldr	r1, [sp, #0xc]
700a56dc: 4288         	cmp	r0, r1
700a56de: d211         	bhs	0x700a5704 <PMU_profileEnd+0xd4> @ imm = #0x22
700a56e0: e7ff         	b	0x700a56e2 <PMU_profileEnd+0xb2> @ imm = #-0x2
;       p->events[j].value = counts[j] - p->events[j].value;
700a56e2: 9a04         	ldr	r2, [sp, #0x10]
700a56e4: a806         	add	r0, sp, #0x18
700a56e6: f850 0022    	ldr.w	r0, [r0, r2, lsl #2]
700a56ea: 9901         	ldr	r1, [sp, #0x4]
700a56ec: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a56f0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a56f4: 688a         	ldr	r2, [r1, #0x8]
700a56f6: 1a80         	subs	r0, r0, r2
700a56f8: 6088         	str	r0, [r1, #0x8]
;     }
700a56fa: e7ff         	b	0x700a56fc <PMU_profileEnd+0xcc> @ imm = #-0x2
;     for (j = 0; j < numEvents; j++) {
700a56fc: 9804         	ldr	r0, [sp, #0x10]
700a56fe: 3001         	adds	r0, #0x1
700a5700: 9004         	str	r0, [sp, #0x10]
700a5702: e7e9         	b	0x700a56d8 <PMU_profileEnd+0xa8> @ imm = #-0x2e
;     gProfileObject.logIndex++;
700a5704: f243 0180    	movw	r1, #0x3080
700a5708: f2c7 0108    	movt	r1, #0x7008
700a570c: 6808         	ldr	r0, [r1]
700a570e: 3001         	adds	r0, #0x1
700a5710: 6008         	str	r0, [r1]
;   }
700a5712: e7ff         	b	0x700a5714 <PMU_profileEnd+0xe4> @ imm = #-0x2
;   return status;
700a5714: 980d         	ldr	r0, [sp, #0x34]
700a5716: 900f         	str	r0, [sp, #0x3c]
700a5718: e7ff         	b	0x700a571a <PMU_profileEnd+0xea> @ imm = #-0x2
; }
700a571a: 980f         	ldr	r0, [sp, #0x3c]
700a571c: b010         	add	sp, #0x40
700a571e: bd80         	pop	{r7, pc}

700a5720 <Udma_eventIsrFxn>:
; {
700a5720: b580         	push	{r7, lr}
700a5722: b088         	sub	sp, #0x20
700a5724: 9007         	str	r0, [sp, #0x1c]
;     Udma_EventHandleInt eventHandle = (Udma_EventHandleInt) args;
700a5726: 9807         	ldr	r0, [sp, #0x1c]
700a5728: 9003         	str	r0, [sp, #0xc]
700a572a: 2001         	movs	r0, #0x1
;     teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_NA;
700a572c: 9004         	str	r0, [sp, #0x10]
700a572e: 2000         	movs	r0, #0x0
;     ringHandle = NULL;
700a5730: 9000         	str	r0, [sp]
;     drvHandle = eventHandle->drvHandle;
700a5732: 9803         	ldr	r0, [sp, #0xc]
700a5734: 6800         	ldr	r0, [r0]
700a5736: 9002         	str	r0, [sp, #0x8]
;     vintrNum = eventHandle->vintrNum;
700a5738: 9803         	ldr	r0, [sp, #0xc]
700a573a: 6cc0         	ldr	r0, [r0, #0x4c]
700a573c: 9005         	str	r0, [sp, #0x14]
;     while(eventHandle != NULL_PTR)
700a573e: e7ff         	b	0x700a5740 <Udma_eventIsrFxn+0x20> @ imm = #-0x2
700a5740: 9803         	ldr	r0, [sp, #0xc]
700a5742: 2800         	cmp	r0, #0x0
700a5744: d060         	beq	0x700a5808 <Udma_eventIsrFxn+0xe8> @ imm = #0xc0
700a5746: e7ff         	b	0x700a5748 <Udma_eventIsrFxn+0x28> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_MASTER != eventHandle->eventPrms.eventType)
700a5748: 9803         	ldr	r0, [sp, #0xc]
700a574a: 6880         	ldr	r0, [r0, #0x8]
700a574c: 2805         	cmp	r0, #0x5
700a574e: d057         	beq	0x700a5800 <Udma_eventIsrFxn+0xe0> @ imm = #0xae
700a5750: e7ff         	b	0x700a5752 <Udma_eventIsrFxn+0x32> @ imm = #-0x2
;             vintrBitNum = vintrNum * UDMA_MAX_EVENTS_PER_VINTR;
700a5752: 9805         	ldr	r0, [sp, #0x14]
700a5754: 0180         	lsls	r0, r0, #0x6
700a5756: 9006         	str	r0, [sp, #0x18]
;             vintrBitNum += eventHandle->vintrBitNum;
700a5758: 9803         	ldr	r0, [sp, #0xc]
700a575a: 6d01         	ldr	r1, [r0, #0x50]
700a575c: 9806         	ldr	r0, [sp, #0x18]
700a575e: 4408         	add	r0, r1
700a5760: 9006         	str	r0, [sp, #0x18]
;             if((bool)true == CSL_intaggrIsIntrPending(&drvHandle->iaRegs, vintrBitNum, (bool)true))
700a5762: 9802         	ldr	r0, [sp, #0x8]
700a5764: 309c         	adds	r0, #0x9c
700a5766: 9906         	ldr	r1, [sp, #0x18]
700a5768: 2201         	movs	r2, #0x1
700a576a: f002 fe89    	bl	0x700a8480 <CSL_intaggrIsIntrPending> @ imm = #0x2d12
700a576e: 2800         	cmp	r0, #0x0
700a5770: d045         	beq	0x700a57fe <Udma_eventIsrFxn+0xde> @ imm = #0x8a
700a5772: e7ff         	b	0x700a5774 <Udma_eventIsrFxn+0x54> @ imm = #-0x2
;                 (void) CSL_intaggrClrIntr(&drvHandle->iaRegs, vintrBitNum);
700a5774: 9802         	ldr	r0, [sp, #0x8]
700a5776: 309c         	adds	r0, #0x9c
700a5778: 9906         	ldr	r1, [sp, #0x18]
700a577a: f005 fd19    	bl	0x700ab1b0 <CSL_intaggrClrIntr> @ imm = #0x5a32
;                 eventPrms = &eventHandle->eventPrms;
700a577e: 9803         	ldr	r0, [sp, #0xc]
700a5780: 3008         	adds	r0, #0x8
700a5782: 9001         	str	r0, [sp, #0x4]
;                 if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a5784: 9801         	ldr	r0, [sp, #0x4]
700a5786: 6800         	ldr	r0, [r0]
700a5788: 2801         	cmp	r0, #0x1
700a578a: d005         	beq	0x700a5798 <Udma_eventIsrFxn+0x78> @ imm = #0xa
700a578c: e7ff         	b	0x700a578e <Udma_eventIsrFxn+0x6e> @ imm = #-0x2
;                    (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
700a578e: 9801         	ldr	r0, [sp, #0x4]
700a5790: 6800         	ldr	r0, [r0]
;                 if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a5792: 2806         	cmp	r0, #0x6
700a5794: d114         	bne	0x700a57c0 <Udma_eventIsrFxn+0xa0> @ imm = #0x28
700a5796: e7ff         	b	0x700a5798 <Udma_eventIsrFxn+0x78> @ imm = #-0x2
;                     ringHandle = ((Udma_ChHandleInt) (eventPrms->chHandle))->cqRing;
700a5798: 9801         	ldr	r0, [sp, #0x4]
700a579a: 6880         	ldr	r0, [r0, #0x8]
700a579c: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a57a0: 9000         	str	r0, [sp]
;                     if( CSL_lcdma_ringaccIsTeardownComplete(&ringHandle->drvHandle->lcdmaRaRegs, ringHandle->ringNum) == TRUE )
700a57a2: 9900         	ldr	r1, [sp]
700a57a4: 6808         	ldr	r0, [r1]
700a57a6: 308c         	adds	r0, #0x8c
700a57a8: 8889         	ldrh	r1, [r1, #0x4]
700a57aa: f008 f8b9    	bl	0x700ad920 <CSL_lcdma_ringaccIsTeardownComplete> @ imm = #0x8172
700a57ae: b118         	cbz	r0, 0x700a57b8 <Udma_eventIsrFxn+0x98> @ imm = #0x6
700a57b0: e7ff         	b	0x700a57b2 <Udma_eventIsrFxn+0x92> @ imm = #-0x2
700a57b2: 2002         	movs	r0, #0x2
;                         teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE;
700a57b4: 9004         	str	r0, [sp, #0x10]
;                     }
700a57b6: e002         	b	0x700a57be <Udma_eventIsrFxn+0x9e> @ imm = #0x4
700a57b8: 2003         	movs	r0, #0x3
;                         teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_INCOMPLETE;
700a57ba: 9004         	str	r0, [sp, #0x10]
700a57bc: e7ff         	b	0x700a57be <Udma_eventIsrFxn+0x9e> @ imm = #-0x2
;                 }
700a57be: e7ff         	b	0x700a57c0 <Udma_eventIsrFxn+0xa0> @ imm = #-0x2
;                 if(!(((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_DMA_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE)) ||
700a57c0: 9803         	ldr	r0, [sp, #0xc]
700a57c2: 6880         	ldr	r0, [r0, #0x8]
700a57c4: 2801         	cmp	r0, #0x1
700a57c6: d104         	bne	0x700a57d2 <Udma_eventIsrFxn+0xb2> @ imm = #0x8
700a57c8: e7ff         	b	0x700a57ca <Udma_eventIsrFxn+0xaa> @ imm = #-0x2
700a57ca: 9804         	ldr	r0, [sp, #0x10]
700a57cc: 2802         	cmp	r0, #0x2
700a57ce: d015         	beq	0x700a57fc <Udma_eventIsrFxn+0xdc> @ imm = #0x2a
700a57d0: e7ff         	b	0x700a57d2 <Udma_eventIsrFxn+0xb2> @ imm = #-0x2
;                  ((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_TEARDOWN_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_INCOMPLETE))))
700a57d2: 9803         	ldr	r0, [sp, #0xc]
700a57d4: 6880         	ldr	r0, [r0, #0x8]
700a57d6: 2806         	cmp	r0, #0x6
700a57d8: d104         	bne	0x700a57e4 <Udma_eventIsrFxn+0xc4> @ imm = #0x8
700a57da: e7ff         	b	0x700a57dc <Udma_eventIsrFxn+0xbc> @ imm = #-0x2
700a57dc: 9804         	ldr	r0, [sp, #0x10]
;                 if(!(((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_DMA_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE)) ||
700a57de: 2803         	cmp	r0, #0x3
700a57e0: d00c         	beq	0x700a57fc <Udma_eventIsrFxn+0xdc> @ imm = #0x18
700a57e2: e7ff         	b	0x700a57e4 <Udma_eventIsrFxn+0xc4> @ imm = #-0x2
;                     if((Udma_EventCallback) NULL_PTR != eventPrms->eventCb)
700a57e4: 9801         	ldr	r0, [sp, #0x4]
700a57e6: 6940         	ldr	r0, [r0, #0x14]
700a57e8: b138         	cbz	r0, 0x700a57fa <Udma_eventIsrFxn+0xda> @ imm = #0xe
700a57ea: e7ff         	b	0x700a57ec <Udma_eventIsrFxn+0xcc> @ imm = #-0x2
;                         eventPrms->eventCb(
700a57ec: 9a01         	ldr	r2, [sp, #0x4]
;                             eventHandle, eventPrms->eventType, eventPrms->appData);
700a57ee: 9803         	ldr	r0, [sp, #0xc]
700a57f0: 6811         	ldr	r1, [r2]
;                         eventPrms->eventCb(
700a57f2: 6953         	ldr	r3, [r2, #0x14]
;                             eventHandle, eventPrms->eventType, eventPrms->appData);
700a57f4: 69d2         	ldr	r2, [r2, #0x1c]
;                         eventPrms->eventCb(
700a57f6: 4798         	blx	r3
;                     }
700a57f8: e7ff         	b	0x700a57fa <Udma_eventIsrFxn+0xda> @ imm = #-0x2
;                 }
700a57fa: e7ff         	b	0x700a57fc <Udma_eventIsrFxn+0xdc> @ imm = #-0x2
;             }
700a57fc: e7ff         	b	0x700a57fe <Udma_eventIsrFxn+0xde> @ imm = #-0x2
;         }
700a57fe: e7ff         	b	0x700a5800 <Udma_eventIsrFxn+0xe0> @ imm = #-0x2
;         eventHandle = eventHandle->nextEvent;
700a5800: 9803         	ldr	r0, [sp, #0xc]
700a5802: 6dc0         	ldr	r0, [r0, #0x5c]
700a5804: 9003         	str	r0, [sp, #0xc]
;     while(eventHandle != NULL_PTR)
700a5806: e79b         	b	0x700a5740 <Udma_eventIsrFxn+0x20> @ imm = #-0xca
;     return;
700a5808: b008         	add	sp, #0x20
700a580a: bd80         	pop	{r7, pc}
700a580c: 0000         	movs	r0, r0
700a580e: 0000         	movs	r0, r0

700a5810 <vTaskPriorityDisinheritAfterTimeout>:
;     UBaseType_t uxHighestPriorityWaitingTask) {
700a5810: b580         	push	{r7, lr}
700a5812: b086         	sub	sp, #0x18
700a5814: 9005         	str	r0, [sp, #0x14]
700a5816: 9104         	str	r1, [sp, #0x10]
;   TCB_t *const pxTCB = pxMutexHolder;
700a5818: 9805         	ldr	r0, [sp, #0x14]
700a581a: 9003         	str	r0, [sp, #0xc]
700a581c: 2001         	movs	r0, #0x1
;   const UBaseType_t uxOnlyOneMutexHeld = (UBaseType_t)1;
700a581e: 9000         	str	r0, [sp]
;   if (pxMutexHolder != NULL) {
700a5820: 9805         	ldr	r0, [sp, #0x14]
700a5822: 2800         	cmp	r0, #0x0
700a5824: d067         	beq	0x700a58f6 <vTaskPriorityDisinheritAfterTimeout+0xe6> @ imm = #0xce
700a5826: e7ff         	b	0x700a5828 <vTaskPriorityDisinheritAfterTimeout+0x18> @ imm = #-0x2
;     if (pxTCB->uxBasePriority < uxHighestPriorityWaitingTask) {
700a5828: 9803         	ldr	r0, [sp, #0xc]
700a582a: 6e00         	ldr	r0, [r0, #0x60]
700a582c: 9904         	ldr	r1, [sp, #0x10]
700a582e: 4288         	cmp	r0, r1
700a5830: d203         	bhs	0x700a583a <vTaskPriorityDisinheritAfterTimeout+0x2a> @ imm = #0x6
700a5832: e7ff         	b	0x700a5834 <vTaskPriorityDisinheritAfterTimeout+0x24> @ imm = #-0x2
;       uxPriorityToUse = uxHighestPriorityWaitingTask;
700a5834: 9804         	ldr	r0, [sp, #0x10]
700a5836: 9001         	str	r0, [sp, #0x4]
;     } else {
700a5838: e003         	b	0x700a5842 <vTaskPriorityDisinheritAfterTimeout+0x32> @ imm = #0x6
;       uxPriorityToUse = pxTCB->uxBasePriority;
700a583a: 9803         	ldr	r0, [sp, #0xc]
700a583c: 6e00         	ldr	r0, [r0, #0x60]
700a583e: 9001         	str	r0, [sp, #0x4]
700a5840: e7ff         	b	0x700a5842 <vTaskPriorityDisinheritAfterTimeout+0x32> @ imm = #-0x2
;     if (pxTCB->uxPriority != uxPriorityToUse) {
700a5842: 9803         	ldr	r0, [sp, #0xc]
700a5844: 6ac0         	ldr	r0, [r0, #0x2c]
700a5846: 9901         	ldr	r1, [sp, #0x4]
700a5848: 4288         	cmp	r0, r1
700a584a: d052         	beq	0x700a58f2 <vTaskPriorityDisinheritAfterTimeout+0xe2> @ imm = #0xa4
700a584c: e7ff         	b	0x700a584e <vTaskPriorityDisinheritAfterTimeout+0x3e> @ imm = #-0x2
;       if (pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld) {
700a584e: 9803         	ldr	r0, [sp, #0xc]
700a5850: 6e40         	ldr	r0, [r0, #0x64]
700a5852: 2801         	cmp	r0, #0x1
700a5854: d14b         	bne	0x700a58ee <vTaskPriorityDisinheritAfterTimeout+0xde> @ imm = #0x96
700a5856: e7ff         	b	0x700a5858 <vTaskPriorityDisinheritAfterTimeout+0x48> @ imm = #-0x2
;         uxPriorityUsedOnEntry = pxTCB->uxPriority;
700a5858: 9803         	ldr	r0, [sp, #0xc]
700a585a: 6ac0         	ldr	r0, [r0, #0x2c]
700a585c: 9002         	str	r0, [sp, #0x8]
;         pxTCB->uxPriority = uxPriorityToUse;
700a585e: 9801         	ldr	r0, [sp, #0x4]
700a5860: 9903         	ldr	r1, [sp, #0xc]
700a5862: 62c8         	str	r0, [r1, #0x2c]
;         if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) &
700a5864: 9803         	ldr	r0, [sp, #0xc]
700a5866: 7ec0         	ldrb	r0, [r0, #0x1b]
700a5868: 0600         	lsls	r0, r0, #0x18
700a586a: 2800         	cmp	r0, #0x0
700a586c: d406         	bmi	0x700a587c <vTaskPriorityDisinheritAfterTimeout+0x6c> @ imm = #0xc
700a586e: e7ff         	b	0x700a5870 <vTaskPriorityDisinheritAfterTimeout+0x60> @ imm = #-0x2
;           listSET_LIST_ITEM_VALUE(
700a5870: 9801         	ldr	r0, [sp, #0x4]
700a5872: f1c0 0020    	rsb.w	r0, r0, #0x20
700a5876: 9903         	ldr	r1, [sp, #0xc]
700a5878: 6188         	str	r0, [r1, #0x18]
;         } else {
700a587a: e000         	b	0x700a587e <vTaskPriorityDisinheritAfterTimeout+0x6e> @ imm = #0x0
700a587c: e7ff         	b	0x700a587e <vTaskPriorityDisinheritAfterTimeout+0x6e> @ imm = #-0x2
;         if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]),
700a587e: 9803         	ldr	r0, [sp, #0xc]
700a5880: 6940         	ldr	r0, [r0, #0x14]
700a5882: 9902         	ldr	r1, [sp, #0x8]
700a5884: eb01 0281    	add.w	r2, r1, r1, lsl #2
700a5888: f244 41f8    	movw	r1, #0x44f8
700a588c: f2c7 0108    	movt	r1, #0x7008
700a5890: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a5894: 4288         	cmp	r0, r1
700a5896: d128         	bne	0x700a58ea <vTaskPriorityDisinheritAfterTimeout+0xda> @ imm = #0x50
700a5898: e7ff         	b	0x700a589a <vTaskPriorityDisinheritAfterTimeout+0x8a> @ imm = #-0x2
;           if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a589a: 9803         	ldr	r0, [sp, #0xc]
700a589c: 3004         	adds	r0, #0x4
700a589e: f007 fde7    	bl	0x700ad470 <uxListRemove> @ imm = #0x7bce
700a58a2: b908         	cbnz	r0, 0x700a58a8 <vTaskPriorityDisinheritAfterTimeout+0x98> @ imm = #0x2
700a58a4: e7ff         	b	0x700a58a6 <vTaskPriorityDisinheritAfterTimeout+0x96> @ imm = #-0x2
;           } else {
700a58a6: e000         	b	0x700a58aa <vTaskPriorityDisinheritAfterTimeout+0x9a> @ imm = #0x0
700a58a8: e7ff         	b	0x700a58aa <vTaskPriorityDisinheritAfterTimeout+0x9a> @ imm = #-0x2
;           prvAddTaskToReadyList(pxTCB);
700a58aa: 9803         	ldr	r0, [sp, #0xc]
700a58ac: 6ac0         	ldr	r0, [r0, #0x2c]
700a58ae: f242 61ec    	movw	r1, #0x26ec
700a58b2: f2c7 010b    	movt	r1, #0x700b
700a58b6: 6809         	ldr	r1, [r1]
700a58b8: 4288         	cmp	r0, r1
700a58ba: d908         	bls	0x700a58ce <vTaskPriorityDisinheritAfterTimeout+0xbe> @ imm = #0x10
700a58bc: e7ff         	b	0x700a58be <vTaskPriorityDisinheritAfterTimeout+0xae> @ imm = #-0x2
700a58be: 9803         	ldr	r0, [sp, #0xc]
700a58c0: 6ac0         	ldr	r0, [r0, #0x2c]
700a58c2: f242 61ec    	movw	r1, #0x26ec
700a58c6: f2c7 010b    	movt	r1, #0x700b
700a58ca: 6008         	str	r0, [r1]
700a58cc: e7ff         	b	0x700a58ce <vTaskPriorityDisinheritAfterTimeout+0xbe> @ imm = #-0x2
700a58ce: 9903         	ldr	r1, [sp, #0xc]
700a58d0: 6ac8         	ldr	r0, [r1, #0x2c]
700a58d2: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a58d6: f244 40f8    	movw	r0, #0x44f8
700a58da: f2c7 0008    	movt	r0, #0x7008
700a58de: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a58e2: 3104         	adds	r1, #0x4
700a58e4: f008 fb7c    	bl	0x700adfe0 <vListInsertEnd> @ imm = #0x86f8
;         } else {
700a58e8: e000         	b	0x700a58ec <vTaskPriorityDisinheritAfterTimeout+0xdc> @ imm = #0x0
700a58ea: e7ff         	b	0x700a58ec <vTaskPriorityDisinheritAfterTimeout+0xdc> @ imm = #-0x2
;       } else {
700a58ec: e000         	b	0x700a58f0 <vTaskPriorityDisinheritAfterTimeout+0xe0> @ imm = #0x0
700a58ee: e7ff         	b	0x700a58f0 <vTaskPriorityDisinheritAfterTimeout+0xe0> @ imm = #-0x2
;     } else {
700a58f0: e000         	b	0x700a58f4 <vTaskPriorityDisinheritAfterTimeout+0xe4> @ imm = #0x0
700a58f2: e7ff         	b	0x700a58f4 <vTaskPriorityDisinheritAfterTimeout+0xe4> @ imm = #-0x2
;   } else {
700a58f4: e000         	b	0x700a58f8 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #0x0
700a58f6: e7ff         	b	0x700a58f8 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #-0x2
; }
700a58f8: b006         	add	sp, #0x18
700a58fa: bd80         	pop	{r7, pc}
700a58fc: 0000         	movs	r0, r0
700a58fe: 0000         	movs	r0, r0

700a5900 <AddrTranslateP_getLocalAddr>:
; {
700a5900: b580         	push	{r7, lr}
700a5902: b08e         	sub	sp, #0x38
700a5904: 910d         	str	r1, [sp, #0x34]
700a5906: 900c         	str	r0, [sp, #0x30]
;     DebugP_assertNoLog(gAddrTranslateConfig.numRegions<AddrTranslateP_MAX_REGIONS);
700a5908: f242 6034    	movw	r0, #0x2634
700a590c: f2c7 000b    	movt	r0, #0x700b
700a5910: 6801         	ldr	r1, [r0]
700a5912: 2000         	movs	r0, #0x0
700a5914: 9001         	str	r0, [sp, #0x4]
700a5916: 2910         	cmp	r1, #0x10
700a5918: bf38         	it	lo
700a591a: 2001         	movlo	r0, #0x1
700a591c: f00b fb60    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0xb6c0
700a5920: 9801         	ldr	r0, [sp, #0x4]
;     found = 0;
700a5922: 900b         	str	r0, [sp, #0x2c]
;     for(regionId=0; regionId<gAddrTranslateConfig.numRegions; regionId++)
700a5924: 900a         	str	r0, [sp, #0x28]
700a5926: e7ff         	b	0x700a5928 <AddrTranslateP_getLocalAddr+0x28> @ imm = #-0x2
700a5928: 980a         	ldr	r0, [sp, #0x28]
700a592a: f242 6134    	movw	r1, #0x2634
700a592e: f2c7 010b    	movt	r1, #0x700b
700a5932: 6809         	ldr	r1, [r1]
700a5934: 4288         	cmp	r0, r1
700a5936: d23b         	bhs	0x700a59b0 <AddrTranslateP_getLocalAddr+0xb0> @ imm = #0x76
700a5938: e7ff         	b	0x700a593a <AddrTranslateP_getLocalAddr+0x3a> @ imm = #-0x2
;         sizeMask = ( (uint32_t)( ((uint64_t)1U << gAddrTranslateConfig.regionConfig[regionId].size) - 1U) );
700a593a: f242 6034    	movw	r0, #0x2634
700a593e: f2c7 000b    	movt	r0, #0x700b
700a5942: 6881         	ldr	r1, [r0, #0x8]
700a5944: 9a0a         	ldr	r2, [sp, #0x28]
700a5946: eb01 1102    	add.w	r1, r1, r2, lsl #4
700a594a: 68ca         	ldr	r2, [r1, #0xc]
700a594c: 2101         	movs	r1, #0x1
700a594e: 4091         	lsls	r1, r2
700a5950: 3a20         	subs	r2, #0x20
700a5952: 2a00         	cmp	r2, #0x0
700a5954: bf58         	it	pl
700a5956: 2100         	movpl	r1, #0x0
700a5958: 3901         	subs	r1, #0x1
700a595a: 9103         	str	r1, [sp, #0xc]
;         startAddr = gAddrTranslateConfig.regionConfig[regionId].systemAddr;
700a595c: 6880         	ldr	r0, [r0, #0x8]
700a595e: 9a0a         	ldr	r2, [sp, #0x28]
700a5960: eb00 1102    	add.w	r1, r0, r2, lsl #4
700a5964: ea4f 1202    	lsl.w	r2, r2, #0x4
700a5968: 5880         	ldr	r0, [r0, r2]
700a596a: 6849         	ldr	r1, [r1, #0x4]
700a596c: 9107         	str	r1, [sp, #0x1c]
700a596e: 9006         	str	r0, [sp, #0x18]
;         endAddr = startAddr + sizeMask;
700a5970: 9906         	ldr	r1, [sp, #0x18]
700a5972: 9807         	ldr	r0, [sp, #0x1c]
700a5974: 9a03         	ldr	r2, [sp, #0xc]
700a5976: 1889         	adds	r1, r1, r2
700a5978: f140 0000    	adc	r0, r0, #0x0
700a597c: 9104         	str	r1, [sp, #0x10]
700a597e: 9005         	str	r0, [sp, #0x14]
;         if((systemAddr >= startAddr) && (systemAddr <= endAddr))
700a5980: 9a0c         	ldr	r2, [sp, #0x30]
700a5982: 980d         	ldr	r0, [sp, #0x34]
700a5984: 9b06         	ldr	r3, [sp, #0x18]
700a5986: 9907         	ldr	r1, [sp, #0x1c]
700a5988: 1ad2         	subs	r2, r2, r3
700a598a: 4188         	sbcs	r0, r1
700a598c: d30b         	blo	0x700a59a6 <AddrTranslateP_getLocalAddr+0xa6> @ imm = #0x16
700a598e: e7ff         	b	0x700a5990 <AddrTranslateP_getLocalAddr+0x90> @ imm = #-0x2
700a5990: 9b0c         	ldr	r3, [sp, #0x30]
700a5992: 990d         	ldr	r1, [sp, #0x34]
700a5994: 9a04         	ldr	r2, [sp, #0x10]
700a5996: 9805         	ldr	r0, [sp, #0x14]
700a5998: 1ad2         	subs	r2, r2, r3
700a599a: 4188         	sbcs	r0, r1
700a599c: d303         	blo	0x700a59a6 <AddrTranslateP_getLocalAddr+0xa6> @ imm = #0x6
700a599e: e7ff         	b	0x700a59a0 <AddrTranslateP_getLocalAddr+0xa0> @ imm = #-0x2
700a59a0: 2001         	movs	r0, #0x1
;             found = 1;
700a59a2: 900b         	str	r0, [sp, #0x2c]
;             break;
700a59a4: e004         	b	0x700a59b0 <AddrTranslateP_getLocalAddr+0xb0> @ imm = #0x8
;     }
700a59a6: e7ff         	b	0x700a59a8 <AddrTranslateP_getLocalAddr+0xa8> @ imm = #-0x2
;     for(regionId=0; regionId<gAddrTranslateConfig.numRegions; regionId++)
700a59a8: 980a         	ldr	r0, [sp, #0x28]
700a59aa: 3001         	adds	r0, #0x1
700a59ac: 900a         	str	r0, [sp, #0x28]
700a59ae: e7bb         	b	0x700a5928 <AddrTranslateP_getLocalAddr+0x28> @ imm = #-0x8a
;     if(found != 0U)
700a59b0: 980b         	ldr	r0, [sp, #0x2c]
700a59b2: b1a0         	cbz	r0, 0x700a59de <AddrTranslateP_getLocalAddr+0xde> @ imm = #0x28
700a59b4: e7ff         	b	0x700a59b6 <AddrTranslateP_getLocalAddr+0xb6> @ imm = #-0x2
;         uint32_t offset = systemAddr - gAddrTranslateConfig.regionConfig[regionId].systemAddr;
700a59b6: 990c         	ldr	r1, [sp, #0x30]
700a59b8: f242 6034    	movw	r0, #0x2634
700a59bc: f2c7 000b    	movt	r0, #0x700b
700a59c0: 6882         	ldr	r2, [r0, #0x8]
700a59c2: 9b0a         	ldr	r3, [sp, #0x28]
700a59c4: 011b         	lsls	r3, r3, #0x4
700a59c6: 58d2         	ldr	r2, [r2, r3]
700a59c8: 1a89         	subs	r1, r1, r2
700a59ca: 9102         	str	r1, [sp, #0x8]
;         localAddr = (void *) (gAddrTranslateConfig.regionConfig[regionId].localAddr + offset);
700a59cc: 6880         	ldr	r0, [r0, #0x8]
700a59ce: 990a         	ldr	r1, [sp, #0x28]
700a59d0: eb00 1001    	add.w	r0, r0, r1, lsl #4
700a59d4: 6880         	ldr	r0, [r0, #0x8]
700a59d6: 9902         	ldr	r1, [sp, #0x8]
700a59d8: 4408         	add	r0, r1
700a59da: 9009         	str	r0, [sp, #0x24]
;     }
700a59dc: e002         	b	0x700a59e4 <AddrTranslateP_getLocalAddr+0xe4> @ imm = #0x4
;         localAddr = (void *) systemAddr;
700a59de: 980c         	ldr	r0, [sp, #0x30]
700a59e0: 9009         	str	r0, [sp, #0x24]
700a59e2: e7ff         	b	0x700a59e4 <AddrTranslateP_getLocalAddr+0xe4> @ imm = #-0x2
;     return localAddr;
700a59e4: 9809         	ldr	r0, [sp, #0x24]
700a59e6: b00e         	add	sp, #0x38
700a59e8: bd80         	pop	{r7, pc}
700a59ea: 0000         	movs	r0, r0
700a59ec: 0000         	movs	r0, r0
700a59ee: 0000         	movs	r0, r0

700a59f0 <Udma_eventFreeResource>:
; {
700a59f0: b580         	push	{r7, lr}
700a59f2: b084         	sub	sp, #0x10
700a59f4: 9003         	str	r0, [sp, #0xc]
700a59f6: 9102         	str	r1, [sp, #0x8]
;     cookie = HwiP_disable();
700a59f8: f00a ee32    	blx	0x700b0660 <HwiP_disable> @ imm = #0xac64
700a59fc: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != eventHandle->prevEvent)
700a59fe: 9802         	ldr	r0, [sp, #0x8]
700a5a00: 6e00         	ldr	r0, [r0, #0x60]
700a5a02: b128         	cbz	r0, 0x700a5a10 <Udma_eventFreeResource+0x20> @ imm = #0xa
700a5a04: e7ff         	b	0x700a5a06 <Udma_eventFreeResource+0x16> @ imm = #-0x2
;         eventHandle->prevEvent->nextEvent = eventHandle->nextEvent;
700a5a06: 9902         	ldr	r1, [sp, #0x8]
700a5a08: 6dc8         	ldr	r0, [r1, #0x5c]
700a5a0a: 6e09         	ldr	r1, [r1, #0x60]
700a5a0c: 65c8         	str	r0, [r1, #0x5c]
;     }
700a5a0e: e7ff         	b	0x700a5a10 <Udma_eventFreeResource+0x20> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->nextEvent)
700a5a10: 9802         	ldr	r0, [sp, #0x8]
700a5a12: 6dc0         	ldr	r0, [r0, #0x5c]
700a5a14: b128         	cbz	r0, 0x700a5a22 <Udma_eventFreeResource+0x32> @ imm = #0xa
700a5a16: e7ff         	b	0x700a5a18 <Udma_eventFreeResource+0x28> @ imm = #-0x2
;         eventHandle->nextEvent->prevEvent = eventHandle->prevEvent;
700a5a18: 9802         	ldr	r0, [sp, #0x8]
700a5a1a: 6dc1         	ldr	r1, [r0, #0x5c]
700a5a1c: 6e00         	ldr	r0, [r0, #0x60]
700a5a1e: 6608         	str	r0, [r1, #0x60]
;     }
700a5a20: e7ff         	b	0x700a5a22 <Udma_eventFreeResource+0x32> @ imm = #-0x2
;     HwiP_restore(cookie);
700a5a22: 9801         	ldr	r0, [sp, #0x4]
700a5a24: f00a ee3c    	blx	0x700b06a0 <HwiP_restore> @ imm = #0xac78
;     if(NULL_PTR != eventHandle->hwiHandle)
700a5a28: 9802         	ldr	r0, [sp, #0x8]
700a5a2a: 6e40         	ldr	r0, [r0, #0x64]
700a5a2c: b140         	cbz	r0, 0x700a5a40 <Udma_eventFreeResource+0x50> @ imm = #0x10
700a5a2e: e7ff         	b	0x700a5a30 <Udma_eventFreeResource+0x40> @ imm = #-0x2
;         HwiP_destruct(&eventHandle->hwiObject);
700a5a30: 9802         	ldr	r0, [sp, #0x8]
700a5a32: 3068         	adds	r0, #0x68
700a5a34: f00a fa24    	bl	0x700afe80 <HwiP_destruct> @ imm = #0xa448
;         eventHandle->hwiHandle = NULL_PTR;
700a5a38: 9902         	ldr	r1, [sp, #0x8]
700a5a3a: 2000         	movs	r0, #0x0
700a5a3c: 6648         	str	r0, [r1, #0x64]
;     }
700a5a3e: e7ff         	b	0x700a5a40 <Udma_eventFreeResource+0x50> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->irIntrNum)
700a5a40: 9802         	ldr	r0, [sp, #0x8]
700a5a42: 6d40         	ldr	r0, [r0, #0x54]
700a5a44: f510 3f80    	cmn.w	r0, #0x10000
700a5a48: d00d         	beq	0x700a5a66 <Udma_eventFreeResource+0x76> @ imm = #0x1a
700a5a4a: e7ff         	b	0x700a5a4c <Udma_eventFreeResource+0x5c> @ imm = #-0x2
;         Udma_rmFreeIrIntr(eventHandle->irIntrNum, drvHandle);
700a5a4c: 9802         	ldr	r0, [sp, #0x8]
700a5a4e: 6d40         	ldr	r0, [r0, #0x54]
700a5a50: 9903         	ldr	r1, [sp, #0xc]
700a5a52: f006 f845    	bl	0x700abae0 <Udma_rmFreeIrIntr> @ imm = #0x608a
;         eventHandle->irIntrNum = UDMA_INTR_INVALID;
700a5a56: 9902         	ldr	r1, [sp, #0x8]
700a5a58: 2000         	movs	r0, #0x0
700a5a5a: f6cf 70ff    	movt	r0, #0xffff
700a5a5e: 6548         	str	r0, [r1, #0x54]
;         eventHandle->coreIntrNum = UDMA_INTR_INVALID;
700a5a60: 9902         	ldr	r1, [sp, #0x8]
700a5a62: 6588         	str	r0, [r1, #0x58]
;     }
700a5a64: e7ff         	b	0x700a5a66 <Udma_eventFreeResource+0x76> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->globalEvent)
700a5a66: 9802         	ldr	r0, [sp, #0x8]
700a5a68: 6c80         	ldr	r0, [r0, #0x48]
700a5a6a: f64f 71ff    	movw	r1, #0xffff
700a5a6e: 4288         	cmp	r0, r1
700a5a70: d00e         	beq	0x700a5a90 <Udma_eventFreeResource+0xa0> @ imm = #0x1c
700a5a72: e7ff         	b	0x700a5a74 <Udma_eventFreeResource+0x84> @ imm = #-0x2
;         Udma_eventResetSteering(drvHandle, eventHandle);
700a5a74: 9803         	ldr	r0, [sp, #0xc]
700a5a76: 9902         	ldr	r1, [sp, #0x8]
700a5a78: f009 f8b2    	bl	0x700aebe0 <Udma_eventResetSteering> @ imm = #0x9164
;         Udma_rmFreeEvent(eventHandle->globalEvent, drvHandle);
700a5a7c: 9802         	ldr	r0, [sp, #0x8]
700a5a7e: 6c80         	ldr	r0, [r0, #0x48]
700a5a80: 9903         	ldr	r1, [sp, #0xc]
700a5a82: f005 fff5    	bl	0x700aba70 <Udma_rmFreeEvent> @ imm = #0x5fea
;         eventHandle->globalEvent = UDMA_EVENT_INVALID;
700a5a86: 9902         	ldr	r1, [sp, #0x8]
700a5a88: f64f 70ff    	movw	r0, #0xffff
700a5a8c: 6488         	str	r0, [r1, #0x48]
;     }
700a5a8e: e7ff         	b	0x700a5a90 <Udma_eventFreeResource+0xa0> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
700a5a90: 9802         	ldr	r0, [sp, #0x8]
700a5a92: 6d00         	ldr	r0, [r0, #0x50]
700a5a94: f64f 71ff    	movw	r1, #0xffff
700a5a98: 4288         	cmp	r0, r1
700a5a9a: d00a         	beq	0x700a5ab2 <Udma_eventFreeResource+0xc2> @ imm = #0x14
700a5a9c: e7ff         	b	0x700a5a9e <Udma_eventFreeResource+0xae> @ imm = #-0x2
;         Udma_rmFreeVintrBit(eventHandle->vintrBitNum, drvHandle, eventHandle);
700a5a9e: 9a02         	ldr	r2, [sp, #0x8]
700a5aa0: 6d10         	ldr	r0, [r2, #0x50]
700a5aa2: 9903         	ldr	r1, [sp, #0xc]
700a5aa4: f004 fb2c    	bl	0x700aa100 <Udma_rmFreeVintrBit> @ imm = #0x4658
;         eventHandle->vintrBitNum = UDMA_EVENT_INVALID;
700a5aa8: 9902         	ldr	r1, [sp, #0x8]
700a5aaa: f64f 70ff    	movw	r0, #0xffff
700a5aae: 6508         	str	r0, [r1, #0x50]
;     }
700a5ab0: e7ff         	b	0x700a5ab2 <Udma_eventFreeResource+0xc2> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->vintrNum)
700a5ab2: 9802         	ldr	r0, [sp, #0x8]
700a5ab4: 6cc0         	ldr	r0, [r0, #0x4c]
700a5ab6: f64f 71ff    	movw	r1, #0xffff
700a5aba: 4288         	cmp	r0, r1
700a5abc: d00a         	beq	0x700a5ad4 <Udma_eventFreeResource+0xe4> @ imm = #0x14
700a5abe: e7ff         	b	0x700a5ac0 <Udma_eventFreeResource+0xd0> @ imm = #-0x2
;         Udma_rmFreeVintr(eventHandle->vintrNum, drvHandle);
700a5ac0: 9802         	ldr	r0, [sp, #0x8]
700a5ac2: 6cc0         	ldr	r0, [r0, #0x4c]
700a5ac4: 9903         	ldr	r1, [sp, #0xc]
700a5ac6: f006 f843    	bl	0x700abb50 <Udma_rmFreeVintr> @ imm = #0x6086
;         eventHandle->vintrNum = UDMA_EVENT_INVALID;
700a5aca: 9902         	ldr	r1, [sp, #0x8]
700a5acc: f64f 70ff    	movw	r0, #0xffff
700a5ad0: 64c8         	str	r0, [r1, #0x4c]
;     }
700a5ad2: e7ff         	b	0x700a5ad4 <Udma_eventFreeResource+0xe4> @ imm = #-0x2
;     return;
700a5ad4: b004         	add	sp, #0x10
700a5ad6: bd80         	pop	{r7, pc}
		...

700a5ae0 <DebugP_memTraceLogWriterPutLine>:
; {
700a5ae0: b580         	push	{r7, lr}
700a5ae2: b08a         	sub	sp, #0x28
700a5ae4: 9009         	str	r0, [sp, #0x24]
700a5ae6: f8ad 1022    	strh.w	r1, [sp, #0x22]
700a5aea: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700a5aec: 9007         	str	r0, [sp, #0x1c]
;     if (gDebugMemLogSize == 0U)
700a5aee: f242 6098    	movw	r0, #0x2698
700a5af2: f2c7 000b    	movt	r0, #0x700b
700a5af6: 6800         	ldr	r0, [r0]
700a5af8: b920         	cbnz	r0, 0x700a5b04 <DebugP_memTraceLogWriterPutLine+0x24> @ imm = #0x8
700a5afa: e7ff         	b	0x700a5afc <DebugP_memTraceLogWriterPutLine+0x1c> @ imm = #-0x2
700a5afc: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700a5b00: 9007         	str	r0, [sp, #0x1c]
;     }
700a5b02: e7ff         	b	0x700a5b04 <DebugP_memTraceLogWriterPutLine+0x24> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
700a5b04: 9807         	ldr	r0, [sp, #0x1c]
700a5b06: 2800         	cmp	r0, #0x0
700a5b08: d15a         	bne	0x700a5bc0 <DebugP_memTraceLogWriterPutLine+0xe0> @ imm = #0xb4
700a5b0a: e7ff         	b	0x700a5b0c <DebugP_memTraceLogWriterPutLine+0x2c> @ imm = #-0x2
;         wr_idx = gDebugMemLogWriteIndex;
700a5b0c: f242 609c    	movw	r0, #0x269c
700a5b10: f2c7 000b    	movt	r0, #0x700b
700a5b14: 6800         	ldr	r0, [r0]
700a5b16: 9006         	str	r0, [sp, #0x18]
;         dst = (uint8_t*)&gDebugMemLog[0];
700a5b18: f241 0080    	movw	r0, #0x1080
700a5b1c: f2c7 0008    	movt	r0, #0x7008
700a5b20: 9003         	str	r0, [sp, #0xc]
700a5b22: 2000         	movs	r0, #0x0
;         idx = 0;
700a5b24: 9004         	str	r0, [sp, #0x10]
;         for (copy_bytes = 0; copy_bytes < num_bytes; copy_bytes++)
700a5b26: 9005         	str	r0, [sp, #0x14]
700a5b28: e7ff         	b	0x700a5b2a <DebugP_memTraceLogWriterPutLine+0x4a> @ imm = #-0x2
700a5b2a: 9805         	ldr	r0, [sp, #0x14]
700a5b2c: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a5b30: 4288         	cmp	r0, r1
700a5b32: d233         	bhs	0x700a5b9c <DebugP_memTraceLogWriterPutLine+0xbc> @ imm = #0x66
700a5b34: e7ff         	b	0x700a5b36 <DebugP_memTraceLogWriterPutLine+0x56> @ imm = #-0x2
;             dst[wr_idx] = buf[idx];
700a5b36: 9809         	ldr	r0, [sp, #0x24]
700a5b38: 9904         	ldr	r1, [sp, #0x10]
700a5b3a: 5c40         	ldrb	r0, [r0, r1]
700a5b3c: 9903         	ldr	r1, [sp, #0xc]
700a5b3e: 9a06         	ldr	r2, [sp, #0x18]
700a5b40: 5488         	strb	r0, [r1, r2]
;             wr_idx = wr_idx + 1U;
700a5b42: 9806         	ldr	r0, [sp, #0x18]
700a5b44: 3001         	adds	r0, #0x1
700a5b46: 9006         	str	r0, [sp, #0x18]
;             if (wr_idx >= gDebugMemLogSize)
700a5b48: 9806         	ldr	r0, [sp, #0x18]
700a5b4a: f242 6198    	movw	r1, #0x2698
700a5b4e: f2c7 010b    	movt	r1, #0x700b
700a5b52: 6809         	ldr	r1, [r1]
700a5b54: 4288         	cmp	r0, r1
700a5b56: d319         	blo	0x700a5b8c <DebugP_memTraceLogWriterPutLine+0xac> @ imm = #0x32
700a5b58: e7ff         	b	0x700a5b5a <DebugP_memTraceLogWriterPutLine+0x7a> @ imm = #-0x2
;                         &dst[gDebugMemLogWriteIndex],
700a5b5a: 9803         	ldr	r0, [sp, #0xc]
700a5b5c: f242 629c    	movw	r2, #0x269c
700a5b60: f2c7 020b    	movt	r2, #0x700b
700a5b64: 9202         	str	r2, [sp, #0x8]
700a5b66: 6811         	ldr	r1, [r2]
700a5b68: 4408         	add	r0, r1
;                         (wr_idx - gDebugMemLogWriteIndex),
700a5b6a: 9906         	ldr	r1, [sp, #0x18]
700a5b6c: 6812         	ldr	r2, [r2]
700a5b6e: 1a89         	subs	r1, r1, r2
700a5b70: 220f         	movs	r2, #0xf
;                 CacheP_wbInv(
700a5b72: f00a ee6e    	blx	0x700b0850 <CacheP_wbInv> @ imm = #0xacdc
700a5b76: 9902         	ldr	r1, [sp, #0x8]
700a5b78: 2000         	movs	r0, #0x0
;                 wr_idx = 0;
700a5b7a: 9006         	str	r0, [sp, #0x18]
;                 gDebugMemLogWriteIndex = 0;
700a5b7c: 6008         	str	r0, [r1]
;                 gDebugMemLogIsWrapAround = 1;
700a5b7e: f242 6194    	movw	r1, #0x2694
700a5b82: f2c7 010b    	movt	r1, #0x700b
700a5b86: 2001         	movs	r0, #0x1
700a5b88: 6008         	str	r0, [r1]
;             }
700a5b8a: e7ff         	b	0x700a5b8c <DebugP_memTraceLogWriterPutLine+0xac> @ imm = #-0x2
;             idx ++;
700a5b8c: 9804         	ldr	r0, [sp, #0x10]
700a5b8e: 3001         	adds	r0, #0x1
700a5b90: 9004         	str	r0, [sp, #0x10]
;         }
700a5b92: e7ff         	b	0x700a5b94 <DebugP_memTraceLogWriterPutLine+0xb4> @ imm = #-0x2
;         for (copy_bytes = 0; copy_bytes < num_bytes; copy_bytes++)
700a5b94: 9805         	ldr	r0, [sp, #0x14]
700a5b96: 3001         	adds	r0, #0x1
700a5b98: 9005         	str	r0, [sp, #0x14]
700a5b9a: e7c6         	b	0x700a5b2a <DebugP_memTraceLogWriterPutLine+0x4a> @ imm = #-0x74
;                 &dst[gDebugMemLogWriteIndex],
700a5b9c: 9803         	ldr	r0, [sp, #0xc]
700a5b9e: f242 629c    	movw	r2, #0x269c
700a5ba2: f2c7 020b    	movt	r2, #0x700b
700a5ba6: 9201         	str	r2, [sp, #0x4]
700a5ba8: 6811         	ldr	r1, [r2]
700a5baa: 4408         	add	r0, r1
;                 (wr_idx - gDebugMemLogWriteIndex),
700a5bac: 9906         	ldr	r1, [sp, #0x18]
700a5bae: 6812         	ldr	r2, [r2]
700a5bb0: 1a89         	subs	r1, r1, r2
700a5bb2: 220f         	movs	r2, #0xf
;         CacheP_wbInv(
700a5bb4: f00a ee4c    	blx	0x700b0850 <CacheP_wbInv> @ imm = #0xac98
700a5bb8: 9901         	ldr	r1, [sp, #0x4]
;         gDebugMemLogWriteIndex = wr_idx;
700a5bba: 9806         	ldr	r0, [sp, #0x18]
700a5bbc: 6008         	str	r0, [r1]
;     }
700a5bbe: e7ff         	b	0x700a5bc0 <DebugP_memTraceLogWriterPutLine+0xe0> @ imm = #-0x2
; }
700a5bc0: b00a         	add	sp, #0x28
700a5bc2: bd80         	pop	{r7, pc}
		...

700a5bd0 <Sciclient_rmIrqGetNode>:
; {
700a5bd0: b089         	sub	sp, #0x24
700a5bd2: f8ad 0022    	strh.w	r0, [sp, #0x22]
700a5bd6: 9107         	str	r1, [sp, #0x1c]
700a5bd8: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700a5bdc: 9006         	str	r0, [sp, #0x18]
700a5bde: 2000         	movs	r0, #0x0
;     lower = 0u;
700a5be0: 9004         	str	r0, [sp, #0x10]
;     upper = gRmIrqTreeCount - 1u;
700a5be2: f242 21fc    	movw	r1, #0x22fc
700a5be6: f2c7 010b    	movt	r1, #0x700b
700a5bea: 680a         	ldr	r2, [r1]
700a5bec: 3a01         	subs	r2, #0x1
700a5bee: 9203         	str	r2, [sp, #0xc]
;     count = gRmIrqTreeCount;
700a5bf0: 6809         	ldr	r1, [r1]
700a5bf2: f8ad 1006    	strh.w	r1, [sp, #0x6]
;     *found_n = NULL;
700a5bf6: 9907         	ldr	r1, [sp, #0x1c]
700a5bf8: 6008         	str	r0, [r1]
;     while ((lower <= upper) &&
700a5bfa: e7ff         	b	0x700a5bfc <Sciclient_rmIrqGetNode+0x2c> @ imm = #-0x2
700a5bfc: 9904         	ldr	r1, [sp, #0x10]
700a5bfe: 9a03         	ldr	r2, [sp, #0xc]
700a5c00: 2000         	movs	r0, #0x0
700a5c02: 4291         	cmp	r1, r2
700a5c04: 9000         	str	r0, [sp]
700a5c06: d81d         	bhi	0x700a5c44 <Sciclient_rmIrqGetNode+0x74> @ imm = #0x3a
700a5c08: e7ff         	b	0x700a5c0a <Sciclient_rmIrqGetNode+0x3a> @ imm = #-0x2
;            (lower < gRmIrqTreeCount) &&
700a5c0a: 9904         	ldr	r1, [sp, #0x10]
700a5c0c: f242 20fc    	movw	r0, #0x22fc
700a5c10: f2c7 000b    	movt	r0, #0x700b
700a5c14: 6802         	ldr	r2, [r0]
700a5c16: 2000         	movs	r0, #0x0
700a5c18: 4291         	cmp	r1, r2
700a5c1a: 9000         	str	r0, [sp]
700a5c1c: d212         	bhs	0x700a5c44 <Sciclient_rmIrqGetNode+0x74> @ imm = #0x24
700a5c1e: e7ff         	b	0x700a5c20 <Sciclient_rmIrqGetNode+0x50> @ imm = #-0x2
;            (upper < gRmIrqTreeCount) &&
700a5c20: 9903         	ldr	r1, [sp, #0xc]
700a5c22: f242 20fc    	movw	r0, #0x22fc
700a5c26: f2c7 000b    	movt	r0, #0x700b
700a5c2a: 6802         	ldr	r2, [r0]
700a5c2c: 2000         	movs	r0, #0x0
700a5c2e: 4291         	cmp	r1, r2
700a5c30: 9000         	str	r0, [sp]
700a5c32: d207         	bhs	0x700a5c44 <Sciclient_rmIrqGetNode+0x74> @ imm = #0xe
700a5c34: e7ff         	b	0x700a5c36 <Sciclient_rmIrqGetNode+0x66> @ imm = #-0x2
;            (count > 0u)) {
700a5c36: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5c3a: 2800         	cmp	r0, #0x0
700a5c3c: bf18         	it	ne
700a5c3e: 2001         	movne	r0, #0x1
700a5c40: 9000         	str	r0, [sp]
700a5c42: e7ff         	b	0x700a5c44 <Sciclient_rmIrqGetNode+0x74> @ imm = #-0x2
700a5c44: 9800         	ldr	r0, [sp]
;     while ((lower <= upper) &&
700a5c46: 07c0         	lsls	r0, r0, #0x1f
700a5c48: b380         	cbz	r0, 0x700a5cac <Sciclient_rmIrqGetNode+0xdc> @ imm = #0x60
700a5c4a: e7ff         	b	0x700a5c4c <Sciclient_rmIrqGetNode+0x7c> @ imm = #-0x2
;         current = (lower + upper) / (2u);
700a5c4c: 9804         	ldr	r0, [sp, #0x10]
700a5c4e: 9903         	ldr	r1, [sp, #0xc]
700a5c50: 4408         	add	r0, r1
700a5c52: 0840         	lsrs	r0, r0, #0x1
700a5c54: 9002         	str	r0, [sp, #0x8]
;         cur_n = (const struct Sciclient_rmIrqNode *) gRmIrqTree[current];
700a5c56: 9902         	ldr	r1, [sp, #0x8]
700a5c58: f241 50c8    	movw	r0, #0x15c8
700a5c5c: f2c7 000b    	movt	r0, #0x700b
700a5c60: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a5c64: 9005         	str	r0, [sp, #0x14]
;         if (cur_n->id == id) {
700a5c66: 9805         	ldr	r0, [sp, #0x14]
700a5c68: 8800         	ldrh	r0, [r0]
700a5c6a: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a5c6e: 4288         	cmp	r0, r1
700a5c70: d106         	bne	0x700a5c80 <Sciclient_rmIrqGetNode+0xb0> @ imm = #0xc
700a5c72: e7ff         	b	0x700a5c74 <Sciclient_rmIrqGetNode+0xa4> @ imm = #-0x2
;             *found_n = cur_n;
700a5c74: 9805         	ldr	r0, [sp, #0x14]
700a5c76: 9907         	ldr	r1, [sp, #0x1c]
700a5c78: 6008         	str	r0, [r1]
700a5c7a: 2000         	movs	r0, #0x0
;             r = SystemP_SUCCESS;
700a5c7c: 9006         	str	r0, [sp, #0x18]
;             break;
700a5c7e: e015         	b	0x700a5cac <Sciclient_rmIrqGetNode+0xdc> @ imm = #0x2a
;             if (cur_n->id < id) {
700a5c80: 9805         	ldr	r0, [sp, #0x14]
700a5c82: 8800         	ldrh	r0, [r0]
700a5c84: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a5c88: 4288         	cmp	r0, r1
700a5c8a: da04         	bge	0x700a5c96 <Sciclient_rmIrqGetNode+0xc6> @ imm = #0x8
700a5c8c: e7ff         	b	0x700a5c8e <Sciclient_rmIrqGetNode+0xbe> @ imm = #-0x2
;                 lower = current + (1u);
700a5c8e: 9802         	ldr	r0, [sp, #0x8]
700a5c90: 3001         	adds	r0, #0x1
700a5c92: 9004         	str	r0, [sp, #0x10]
;             } else {
700a5c94: e003         	b	0x700a5c9e <Sciclient_rmIrqGetNode+0xce> @ imm = #0x6
;                 upper = current - (1u);
700a5c96: 9802         	ldr	r0, [sp, #0x8]
700a5c98: 3801         	subs	r0, #0x1
700a5c9a: 9003         	str	r0, [sp, #0xc]
700a5c9c: e7ff         	b	0x700a5c9e <Sciclient_rmIrqGetNode+0xce> @ imm = #-0x2
700a5c9e: e7ff         	b	0x700a5ca0 <Sciclient_rmIrqGetNode+0xd0> @ imm = #-0x2
;         count--;
700a5ca0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5ca4: 3801         	subs	r0, #0x1
700a5ca6: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     while ((lower <= upper) &&
700a5caa: e7a7         	b	0x700a5bfc <Sciclient_rmIrqGetNode+0x2c> @ imm = #-0xb2
;     return r;
700a5cac: 9806         	ldr	r0, [sp, #0x18]
700a5cae: b009         	add	sp, #0x24
700a5cb0: 4770         	bx	lr
		...
700a5cbe: 0000         	movs	r0, r0

700a5cc0 <vTaskGetInfo>:
;                   BaseType_t xGetFreeStackSpace, eTaskState eState) {
700a5cc0: b580         	push	{r7, lr}
700a5cc2: b086         	sub	sp, #0x18
700a5cc4: 9005         	str	r0, [sp, #0x14]
700a5cc6: 9104         	str	r1, [sp, #0x10]
700a5cc8: 9203         	str	r2, [sp, #0xc]
700a5cca: f88d 300b    	strb.w	r3, [sp, #0xb]
;   pxTCB = prvGetTCBFromHandle(xTask);
700a5cce: 9805         	ldr	r0, [sp, #0x14]
700a5cd0: b938         	cbnz	r0, 0x700a5ce2 <vTaskGetInfo+0x22> @ imm = #0xe
700a5cd2: e7ff         	b	0x700a5cd4 <vTaskGetInfo+0x14> @ imm = #-0x2
700a5cd4: f242 60bc    	movw	r0, #0x26bc
700a5cd8: f2c7 000b    	movt	r0, #0x700b
700a5cdc: 6800         	ldr	r0, [r0]
700a5cde: 9000         	str	r0, [sp]
700a5ce0: e002         	b	0x700a5ce8 <vTaskGetInfo+0x28> @ imm = #0x4
700a5ce2: 9805         	ldr	r0, [sp, #0x14]
700a5ce4: 9000         	str	r0, [sp]
700a5ce6: e7ff         	b	0x700a5ce8 <vTaskGetInfo+0x28> @ imm = #-0x2
700a5ce8: 9800         	ldr	r0, [sp]
700a5cea: 9001         	str	r0, [sp, #0x4]
;   pxTaskStatus->xHandle = (TaskHandle_t)pxTCB;
700a5cec: 9801         	ldr	r0, [sp, #0x4]
700a5cee: 9904         	ldr	r1, [sp, #0x10]
700a5cf0: 6008         	str	r0, [r1]
;   pxTaskStatus->pcTaskName = (const char *)&(pxTCB->pcTaskName[0]);
700a5cf2: 9801         	ldr	r0, [sp, #0x4]
700a5cf4: 3034         	adds	r0, #0x34
700a5cf6: 9904         	ldr	r1, [sp, #0x10]
700a5cf8: 6048         	str	r0, [r1, #0x4]
;   pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
700a5cfa: 9801         	ldr	r0, [sp, #0x4]
700a5cfc: 6ac0         	ldr	r0, [r0, #0x2c]
700a5cfe: 9904         	ldr	r1, [sp, #0x10]
700a5d00: 6108         	str	r0, [r1, #0x10]
;   pxTaskStatus->pxStackBase = pxTCB->pxStack;
700a5d02: 9801         	ldr	r0, [sp, #0x4]
700a5d04: 6b00         	ldr	r0, [r0, #0x30]
700a5d06: 9904         	ldr	r1, [sp, #0x10]
700a5d08: 61c8         	str	r0, [r1, #0x1c]
;   pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
700a5d0a: 9801         	ldr	r0, [sp, #0x4]
700a5d0c: 6d80         	ldr	r0, [r0, #0x58]
700a5d0e: 9904         	ldr	r1, [sp, #0x10]
700a5d10: 6088         	str	r0, [r1, #0x8]
;     pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
700a5d12: 9801         	ldr	r0, [sp, #0x4]
700a5d14: 6e00         	ldr	r0, [r0, #0x60]
700a5d16: 9904         	ldr	r1, [sp, #0x10]
700a5d18: 6148         	str	r0, [r1, #0x14]
;     pxTaskStatus->ulRunTimeCounter = 0;
700a5d1a: 9904         	ldr	r1, [sp, #0x10]
700a5d1c: 2000         	movs	r0, #0x0
700a5d1e: 6188         	str	r0, [r1, #0x18]
;   if (eState != eInvalid) {
700a5d20: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a5d24: 2805         	cmp	r0, #0x5
700a5d26: d025         	beq	0x700a5d74 <vTaskGetInfo+0xb4> @ imm = #0x4a
700a5d28: e7ff         	b	0x700a5d2a <vTaskGetInfo+0x6a> @ imm = #-0x2
;     if (pxTCB == pxCurrentTCB) {
700a5d2a: 9801         	ldr	r0, [sp, #0x4]
700a5d2c: f242 61bc    	movw	r1, #0x26bc
700a5d30: f2c7 010b    	movt	r1, #0x700b
700a5d34: 6809         	ldr	r1, [r1]
700a5d36: 4288         	cmp	r0, r1
700a5d38: d104         	bne	0x700a5d44 <vTaskGetInfo+0x84> @ imm = #0x8
700a5d3a: e7ff         	b	0x700a5d3c <vTaskGetInfo+0x7c> @ imm = #-0x2
;       pxTaskStatus->eCurrentState = eRunning;
700a5d3c: 9904         	ldr	r1, [sp, #0x10]
700a5d3e: 2000         	movs	r0, #0x0
700a5d40: 7308         	strb	r0, [r1, #0xc]
;     } else {
700a5d42: e016         	b	0x700a5d72 <vTaskGetInfo+0xb2> @ imm = #0x2c
;       pxTaskStatus->eCurrentState = eState;
700a5d44: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a5d48: 9904         	ldr	r1, [sp, #0x10]
700a5d4a: 7308         	strb	r0, [r1, #0xc]
;         if (eState == eSuspended) {
700a5d4c: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a5d50: 2803         	cmp	r0, #0x3
700a5d52: d10d         	bne	0x700a5d70 <vTaskGetInfo+0xb0> @ imm = #0x1a
700a5d54: e7ff         	b	0x700a5d56 <vTaskGetInfo+0x96> @ imm = #-0x2
;           vTaskSuspendAll();
700a5d56: f009 fdab    	bl	0x700af8b0 <vTaskSuspendAll> @ imm = #0x9b56
;             if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a5d5a: 9801         	ldr	r0, [sp, #0x4]
700a5d5c: 6a80         	ldr	r0, [r0, #0x28]
700a5d5e: b120         	cbz	r0, 0x700a5d6a <vTaskGetInfo+0xaa> @ imm = #0x8
700a5d60: e7ff         	b	0x700a5d62 <vTaskGetInfo+0xa2> @ imm = #-0x2
;               pxTaskStatus->eCurrentState = eBlocked;
700a5d62: 9904         	ldr	r1, [sp, #0x10]
700a5d64: 2002         	movs	r0, #0x2
700a5d66: 7308         	strb	r0, [r1, #0xc]
;             }
700a5d68: e7ff         	b	0x700a5d6a <vTaskGetInfo+0xaa> @ imm = #-0x2
;           (void)xTaskResumeAll();
700a5d6a: f7fc f991    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0x3cde
;         }
700a5d6e: e7ff         	b	0x700a5d70 <vTaskGetInfo+0xb0> @ imm = #-0x2
700a5d70: e7ff         	b	0x700a5d72 <vTaskGetInfo+0xb2> @ imm = #-0x2
;   } else {
700a5d72: e005         	b	0x700a5d80 <vTaskGetInfo+0xc0> @ imm = #0xa
;     pxTaskStatus->eCurrentState = eTaskGetState(pxTCB);
700a5d74: 9801         	ldr	r0, [sp, #0x4]
700a5d76: f7ff fbdb    	bl	0x700a5530 <eTaskGetState> @ imm = #-0x84a
700a5d7a: 9904         	ldr	r1, [sp, #0x10]
700a5d7c: 7308         	strb	r0, [r1, #0xc]
700a5d7e: e7ff         	b	0x700a5d80 <vTaskGetInfo+0xc0> @ imm = #-0x2
;   if (xGetFreeStackSpace != pdFALSE) {
700a5d80: 9803         	ldr	r0, [sp, #0xc]
700a5d82: b138         	cbz	r0, 0x700a5d94 <vTaskGetInfo+0xd4> @ imm = #0xe
700a5d84: e7ff         	b	0x700a5d86 <vTaskGetInfo+0xc6> @ imm = #-0x2
;           prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxStack);
700a5d86: 9801         	ldr	r0, [sp, #0x4]
700a5d88: 6b00         	ldr	r0, [r0, #0x30]
700a5d8a: f008 fd01    	bl	0x700ae790 <prvTaskCheckFreeStackSpace> @ imm = #0x8a02
;       pxTaskStatus->usStackHighWaterMark =
700a5d8e: 9904         	ldr	r1, [sp, #0x10]
700a5d90: 6208         	str	r0, [r1, #0x20]
;   } else {
700a5d92: e003         	b	0x700a5d9c <vTaskGetInfo+0xdc> @ imm = #0x6
;     pxTaskStatus->usStackHighWaterMark = 0;
700a5d94: 9904         	ldr	r1, [sp, #0x10]
700a5d96: 2000         	movs	r0, #0x0
700a5d98: 6208         	str	r0, [r1, #0x20]
700a5d9a: e7ff         	b	0x700a5d9c <vTaskGetInfo+0xdc> @ imm = #-0x2
; }
700a5d9c: b006         	add	sp, #0x18
700a5d9e: bd80         	pop	{r7, pc}

700a5da0 <Sciclient_waitForMessage>:
; {
700a5da0: b580         	push	{r7, lr}
700a5da2: b088         	sub	sp, #0x20
700a5da4: 9007         	str	r0, [sp, #0x1c]
700a5da6: 9106         	str	r1, [sp, #0x18]
700a5da8: 9205         	str	r2, [sp, #0x14]
700a5daa: f88d 3013    	strb.w	r3, [sp, #0x13]
;     uint32_t timeToWait = timeout;
700a5dae: 9806         	ldr	r0, [sp, #0x18]
700a5db0: 9002         	str	r0, [sp, #0x8]
700a5db2: 2200         	movs	r2, #0x0
;     int32_t status = SystemP_SUCCESS;
700a5db4: 9201         	str	r2, [sp, #0x4]
;                                         &gSciclientSecProxyCfg, rxThread, 0U)
700a5db6: 9907         	ldr	r1, [sp, #0x1c]
;         (struct tisci_header *)(CSL_secProxyGetDataAddr(
700a5db8: f242 5080    	movw	r0, #0x2580
700a5dbc: f2c7 000b    	movt	r0, #0x700b
700a5dc0: f009 fa56    	bl	0x700af270 <CSL_secProxyGetDataAddr> @ imm = #0x94ac
;                                 + ((uintptr_t) gSecHeaderSizeWords * (uintptr_t) 4U));
700a5dc4: f242 7114    	movw	r1, #0x2714
700a5dc8: f2c7 010b    	movt	r1, #0x700b
700a5dcc: 7809         	ldrb	r1, [r1]
700a5dce: eb00 0081    	add.w	r0, r0, r1, lsl #2
;     pLocalRespHdr =
700a5dd2: 9003         	str	r0, [sp, #0xc]
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a5dd4: e7ff         	b	0x700a5dd6 <Sciclient_waitForMessage+0x36> @ imm = #-0x2
700a5dd6: 9807         	ldr	r0, [sp, #0x1c]
700a5dd8: f009 fafa    	bl	0x700af3d0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x95f4
700a5ddc: f009 fda0    	bl	0x700af920 <CSL_REG32_RD_RAW> @ imm = #0x9b40
700a5de0: b2c0         	uxtb	r0, r0
;             CSL_SEC_PROXY_RT_THREAD_STATUS_CUR_CNT_MASK) - initialCount) <= 0U)
700a5de2: 9905         	ldr	r1, [sp, #0x14]
700a5de4: 1a40         	subs	r0, r0, r1
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a5de6: b960         	cbnz	r0, 0x700a5e02 <Sciclient_waitForMessage+0x62> @ imm = #0x18
700a5de8: e7ff         	b	0x700a5dea <Sciclient_waitForMessage+0x4a> @ imm = #-0x2
;         if (timeToWait != 0U)
700a5dea: 9802         	ldr	r0, [sp, #0x8]
700a5dec: b120         	cbz	r0, 0x700a5df8 <Sciclient_waitForMessage+0x58> @ imm = #0x8
700a5dee: e7ff         	b	0x700a5df0 <Sciclient_waitForMessage+0x50> @ imm = #-0x2
;             timeToWait--;
700a5df0: 9802         	ldr	r0, [sp, #0x8]
700a5df2: 3801         	subs	r0, #0x1
700a5df4: 9002         	str	r0, [sp, #0x8]
;         }
700a5df6: e003         	b	0x700a5e00 <Sciclient_waitForMessage+0x60> @ imm = #0x6
700a5df8: f06f 0001    	mvn	r0, #0x1
;             status = SystemP_TIMEOUT;
700a5dfc: 9001         	str	r0, [sp, #0x4]
;             break;
700a5dfe: e000         	b	0x700a5e02 <Sciclient_waitForMessage+0x62> @ imm = #0x0
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a5e00: e7e9         	b	0x700a5dd6 <Sciclient_waitForMessage+0x36> @ imm = #-0x2e
;     if (status == SystemP_SUCCESS)
700a5e02: 9801         	ldr	r0, [sp, #0x4]
700a5e04: bbc0         	cbnz	r0, 0x700a5e78 <Sciclient_waitForMessage+0xd8> @ imm = #0x70
700a5e06: e7ff         	b	0x700a5e08 <Sciclient_waitForMessage+0x68> @ imm = #-0x2
700a5e08: f06f 0001    	mvn	r0, #0x1
;         status = SystemP_TIMEOUT;
700a5e0c: 9001         	str	r0, [sp, #0x4]
;         timeToWait =  timeout;
700a5e0e: 9806         	ldr	r0, [sp, #0x18]
700a5e10: 9002         	str	r0, [sp, #0x8]
;         while(1)
700a5e12: e7ff         	b	0x700a5e14 <Sciclient_waitForMessage+0x74> @ imm = #-0x2
;             uint32_t numCurrentMsgs = (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a5e14: 9807         	ldr	r0, [sp, #0x1c]
700a5e16: f009 fadb    	bl	0x700af3d0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x95b6
700a5e1a: f009 fd81    	bl	0x700af920 <CSL_REG32_RD_RAW> @ imm = #0x9b02
700a5e1e: b2c0         	uxtb	r0, r0
;                     CSL_SEC_PROXY_RT_THREAD_STATUS_CUR_CNT_MASK) - initialCount;
700a5e20: 9905         	ldr	r1, [sp, #0x14]
700a5e22: 1a40         	subs	r0, r0, r1
;             uint32_t numCurrentMsgs = (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a5e24: 9000         	str	r0, [sp]
;             if (pLocalRespHdr->seq == (uint32_t)localSeqId)
700a5e26: 9803         	ldr	r0, [sp, #0xc]
700a5e28: 78c0         	ldrb	r0, [r0, #0x3]
700a5e2a: f89d 1013    	ldrb.w	r1, [sp, #0x13]
700a5e2e: 4288         	cmp	r0, r1
700a5e30: d103         	bne	0x700a5e3a <Sciclient_waitForMessage+0x9a> @ imm = #0x6
700a5e32: e7ff         	b	0x700a5e34 <Sciclient_waitForMessage+0x94> @ imm = #-0x2
700a5e34: 2000         	movs	r0, #0x0
;                 status = SystemP_SUCCESS;
700a5e36: 9001         	str	r0, [sp, #0x4]
;                 break;
700a5e38: e01d         	b	0x700a5e76 <Sciclient_waitForMessage+0xd6> @ imm = #0x3a
;             if (numCurrentMsgs > 1U)
700a5e3a: 9800         	ldr	r0, [sp]
700a5e3c: 2802         	cmp	r0, #0x2
700a5e3e: d30e         	blo	0x700a5e5e <Sciclient_waitForMessage+0xbe> @ imm = #0x1c
700a5e40: e7ff         	b	0x700a5e42 <Sciclient_waitForMessage+0xa2> @ imm = #-0x2
;                 (void) Sciclient_secProxyReadThread32(rxThread,
700a5e42: 9807         	ldr	r0, [sp, #0x1c]
;                                             (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U) - 1U));
700a5e44: f242 6108    	movw	r1, #0x2608
700a5e48: f2c7 010b    	movt	r1, #0x700b
700a5e4c: 694a         	ldr	r2, [r1, #0x14]
700a5e4e: f04f 31ff    	mov.w	r1, #0xffffffff
700a5e52: eb01 0192    	add.w	r1, r1, r2, lsr #2
;                 (void) Sciclient_secProxyReadThread32(rxThread,
700a5e56: b2c9         	uxtb	r1, r1
700a5e58: f008 fc3a    	bl	0x700ae6d0 <Sciclient_secProxyReadThread32> @ imm = #0x8874
;             }
700a5e5c: e7ff         	b	0x700a5e5e <Sciclient_waitForMessage+0xbe> @ imm = #-0x2
;             if (timeToWait != 0U)
700a5e5e: 9802         	ldr	r0, [sp, #0x8]
700a5e60: b120         	cbz	r0, 0x700a5e6c <Sciclient_waitForMessage+0xcc> @ imm = #0x8
700a5e62: e7ff         	b	0x700a5e64 <Sciclient_waitForMessage+0xc4> @ imm = #-0x2
;                 timeToWait--;
700a5e64: 9802         	ldr	r0, [sp, #0x8]
700a5e66: 3801         	subs	r0, #0x1
700a5e68: 9002         	str	r0, [sp, #0x8]
;             }
700a5e6a: e003         	b	0x700a5e74 <Sciclient_waitForMessage+0xd4> @ imm = #0x6
700a5e6c: f06f 0001    	mvn	r0, #0x1
;                 status = SystemP_TIMEOUT;
700a5e70: 9001         	str	r0, [sp, #0x4]
;                 break;
700a5e72: e000         	b	0x700a5e76 <Sciclient_waitForMessage+0xd6> @ imm = #0x0
;         while(1)
700a5e74: e7ce         	b	0x700a5e14 <Sciclient_waitForMessage+0x74> @ imm = #-0x64
;     }
700a5e76: e7ff         	b	0x700a5e78 <Sciclient_waitForMessage+0xd8> @ imm = #-0x2
;     return status;
700a5e78: 9801         	ldr	r0, [sp, #0x4]
700a5e7a: b008         	add	sp, #0x20
700a5e7c: bd80         	pop	{r7, pc}
700a5e7e: 0000         	movs	r0, r0

700a5e80 <UART_intrEnable>:
; {
700a5e80: b580         	push	{r7, lr}
700a5e82: b08a         	sub	sp, #0x28
700a5e84: 9009         	str	r0, [sp, #0x24]
700a5e86: 9108         	str	r1, [sp, #0x20]
700a5e88: 2000         	movs	r0, #0x0
;     uint32_t enhanFnBitVal = 0U;
700a5e8a: 9007         	str	r0, [sp, #0x1c]
;     uint32_t lcrRegValue   = 0U;
700a5e8c: 9006         	str	r0, [sp, #0x18]
;     if ((intrFlag & 0xF0U) > 0U)
700a5e8e: f89d 0020    	ldrb.w	r0, [sp, #0x20]
700a5e92: f010 0ff0    	tst.w	r0, #0xf0
700a5e96: d053         	beq	0x700a5f40 <UART_intrEnable+0xc0> @ imm = #0xa6
700a5e98: e7ff         	b	0x700a5e9a <UART_intrEnable+0x1a> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a5e9a: 9809         	ldr	r0, [sp, #0x24]
700a5e9c: 300c         	adds	r0, #0xc
700a5e9e: f009 fcdf    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x99be
700a5ea2: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a5ea4: 9809         	ldr	r0, [sp, #0x24]
700a5ea6: 300c         	adds	r0, #0xc
700a5ea8: 21bf         	movs	r1, #0xbf
700a5eaa: 9103         	str	r1, [sp, #0xc]
700a5eac: f009 fce0    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x99c0
;         enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a5eb0: 9809         	ldr	r0, [sp, #0x24]
700a5eb2: 3008         	adds	r0, #0x8
700a5eb4: 2110         	movs	r1, #0x10
700a5eb6: 9104         	str	r1, [sp, #0x10]
700a5eb8: 2204         	movs	r2, #0x4
700a5eba: 9205         	str	r2, [sp, #0x14]
700a5ebc: f009 f8d8    	bl	0x700af070 <HW_RD_FIELD32_RAW> @ imm = #0x91b0
700a5ec0: 9904         	ldr	r1, [sp, #0x10]
700a5ec2: 9a05         	ldr	r2, [sp, #0x14]
700a5ec4: 9007         	str	r0, [sp, #0x1c]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a5ec6: 9809         	ldr	r0, [sp, #0x24]
700a5ec8: 3008         	adds	r0, #0x8
700a5eca: 2301         	movs	r3, #0x1
700a5ecc: f008 faa0    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x8540
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a5ed0: 9809         	ldr	r0, [sp, #0x24]
700a5ed2: 300c         	adds	r0, #0xc
700a5ed4: 9906         	ldr	r1, [sp, #0x18]
700a5ed6: f009 fccb    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x9996
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a5eda: 9809         	ldr	r0, [sp, #0x24]
700a5edc: 300c         	adds	r0, #0xc
700a5ede: f009 fcbf    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x997e
700a5ee2: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700a5ee4: 9809         	ldr	r0, [sp, #0x24]
700a5ee6: 300c         	adds	r0, #0xc
700a5ee8: 9002         	str	r0, [sp, #0x8]
700a5eea: f009 fcb9    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x9972
700a5eee: 4601         	mov	r1, r0
700a5ef0: 9802         	ldr	r0, [sp, #0x8]
700a5ef2: f001 017f    	and	r1, r1, #0x7f
700a5ef6: f009 fcbb    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x9976
;         HW_WR_REG32(baseAddr + UART_IER, intrFlag & 0xF0U);
700a5efa: 9809         	ldr	r0, [sp, #0x24]
700a5efc: 3004         	adds	r0, #0x4
700a5efe: 9908         	ldr	r1, [sp, #0x20]
700a5f00: f001 01f0    	and	r1, r1, #0xf0
700a5f04: f009 fcb4    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x9968
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a5f08: 9809         	ldr	r0, [sp, #0x24]
700a5f0a: 300c         	adds	r0, #0xc
700a5f0c: 9906         	ldr	r1, [sp, #0x18]
700a5f0e: f009 fcaf    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x995e
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a5f12: 9809         	ldr	r0, [sp, #0x24]
700a5f14: 300c         	adds	r0, #0xc
700a5f16: f009 fca3    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x9946
700a5f1a: 9903         	ldr	r1, [sp, #0xc]
700a5f1c: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a5f1e: 9809         	ldr	r0, [sp, #0x24]
700a5f20: 300c         	adds	r0, #0xc
700a5f22: f009 fca5    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x994a
700a5f26: 9904         	ldr	r1, [sp, #0x10]
700a5f28: 9a05         	ldr	r2, [sp, #0x14]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a5f2a: 9809         	ldr	r0, [sp, #0x24]
700a5f2c: 3008         	adds	r0, #0x8
700a5f2e: 9b07         	ldr	r3, [sp, #0x1c]
700a5f30: f008 fa6e    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x84dc
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a5f34: 9809         	ldr	r0, [sp, #0x24]
700a5f36: 300c         	adds	r0, #0xc
700a5f38: 9906         	ldr	r1, [sp, #0x18]
700a5f3a: f009 fc99    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x9932
;     }
700a5f3e: e7ff         	b	0x700a5f40 <UART_intrEnable+0xc0> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_IER, HW_RD_REG32(baseAddr + UART_IER) |
700a5f40: 9809         	ldr	r0, [sp, #0x24]
700a5f42: 3004         	adds	r0, #0x4
700a5f44: 9001         	str	r0, [sp, #0x4]
700a5f46: f009 fc8b    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x9916
700a5f4a: 4601         	mov	r1, r0
700a5f4c: 9801         	ldr	r0, [sp, #0x4]
700a5f4e: 9a08         	ldr	r2, [sp, #0x20]
700a5f50: f002 020f    	and	r2, r2, #0xf
700a5f54: 4311         	orrs	r1, r2
700a5f56: f009 fc8b    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x9916
; }
700a5f5a: b00a         	add	sp, #0x28
700a5f5c: bd80         	pop	{r7, pc}
700a5f5e: 0000         	movs	r0, r0

700a5f60 <Sciclient_rmIrInpIsFree>:
; {
700a5f60: b580         	push	{r7, lr}
700a5f62: b086         	sub	sp, #0x18
700a5f64: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a5f68: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a5f6c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a5f6e: 9004         	str	r0, [sp, #0x10]
;     const struct Sciclient_rmIrInst *inst = NULL;
700a5f70: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIrGetInst(id);
700a5f72: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a5f76: f005 fcd3    	bl	0x700ab920 <Sciclient_rmIrGetInst> @ imm = #0x59a6
700a5f7a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a5f7c: 9803         	ldr	r0, [sp, #0xc]
700a5f7e: b920         	cbnz	r0, 0x700a5f8a <Sciclient_rmIrInpIsFree+0x2a> @ imm = #0x8
700a5f80: e7ff         	b	0x700a5f82 <Sciclient_rmIrInpIsFree+0x22> @ imm = #-0x2
700a5f82: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a5f86: 9004         	str	r0, [sp, #0x10]
;     } else {
700a5f88: e00b         	b	0x700a5fa2 <Sciclient_rmIrInpIsFree+0x42> @ imm = #0x16
;         if (inp >= inst->n_inp) {
700a5f8a: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a5f8e: 9903         	ldr	r1, [sp, #0xc]
700a5f90: 8909         	ldrh	r1, [r1, #0x8]
700a5f92: 4288         	cmp	r0, r1
700a5f94: db04         	blt	0x700a5fa0 <Sciclient_rmIrInpIsFree+0x40> @ imm = #0x8
700a5f96: e7ff         	b	0x700a5f98 <Sciclient_rmIrInpIsFree+0x38> @ imm = #-0x2
700a5f98: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a5f9c: 9004         	str	r0, [sp, #0x10]
;         }
700a5f9e: e7ff         	b	0x700a5fa0 <Sciclient_rmIrInpIsFree+0x40> @ imm = #-0x2
700a5fa0: e7ff         	b	0x700a5fa2 <Sciclient_rmIrInpIsFree+0x42> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a5fa2: 9804         	ldr	r0, [sp, #0x10]
700a5fa4: 2800         	cmp	r0, #0x0
700a5fa6: d145         	bne	0x700a6034 <Sciclient_rmIrInpIsFree+0xd4> @ imm = #0x8a
700a5fa8: e7ff         	b	0x700a5faa <Sciclient_rmIrInpIsFree+0x4a> @ imm = #-0x2
;         if (inp == 0u) {
700a5faa: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a5fae: b960         	cbnz	r0, 0x700a5fca <Sciclient_rmIrInpIsFree+0x6a> @ imm = #0x18
700a5fb0: e7ff         	b	0x700a5fb2 <Sciclient_rmIrInpIsFree+0x52> @ imm = #-0x2
;             if (inst->inp0_mapping != SCICLIENT_RM_IR_MAPPING_FREE) {
700a5fb2: 9803         	ldr	r0, [sp, #0xc]
700a5fb4: 8980         	ldrh	r0, [r0, #0xc]
700a5fb6: f64f 71ff    	movw	r1, #0xffff
700a5fba: 4288         	cmp	r0, r1
700a5fbc: d004         	beq	0x700a5fc8 <Sciclient_rmIrInpIsFree+0x68> @ imm = #0x8
700a5fbe: e7ff         	b	0x700a5fc0 <Sciclient_rmIrInpIsFree+0x60> @ imm = #-0x2
700a5fc0: f04f 30ff    	mov.w	r0, #0xffffffff
;                 r = SystemP_FAILURE;
700a5fc4: 9004         	str	r0, [sp, #0x10]
;             }
700a5fc6: e7ff         	b	0x700a5fc8 <Sciclient_rmIrInpIsFree+0x68> @ imm = #-0x2
;         } else {
700a5fc8: e033         	b	0x700a6032 <Sciclient_rmIrInpIsFree+0xd2> @ imm = #0x66
700a5fca: 2000         	movs	r0, #0x0
;             for (i = 0u; i < inst->n_outp; i++) {
700a5fcc: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a5fd0: e7ff         	b	0x700a5fd2 <Sciclient_rmIrInpIsFree+0x72> @ imm = #-0x2
700a5fd2: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a5fd6: 9903         	ldr	r1, [sp, #0xc]
700a5fd8: 8949         	ldrh	r1, [r1, #0xa]
700a5fda: 4288         	cmp	r0, r1
700a5fdc: da28         	bge	0x700a6030 <Sciclient_rmIrInpIsFree+0xd0> @ imm = #0x50
700a5fde: e7ff         	b	0x700a5fe0 <Sciclient_rmIrInpIsFree+0x80> @ imm = #-0x2
;                 int_ctrl_reg = (volatile uint32_t *)Sciclient_getIrAddr(inst->cfg, i);
700a5fe0: 9803         	ldr	r0, [sp, #0xc]
700a5fe2: 6840         	ldr	r0, [r0, #0x4]
700a5fe4: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700a5fe8: f008 fc92    	bl	0x700ae910 <Sciclient_getIrAddr> @ imm = #0x8924
700a5fec: 9001         	str	r0, [sp, #0x4]
;                 extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a5fee: 9801         	ldr	r0, [sp, #0x4]
700a5ff0: f240 31ff    	movw	r1, #0x3ff
700a5ff4: 2200         	movs	r2, #0x0
700a5ff6: f008 ff5b    	bl	0x700aeeb0 <CSL_REG32_FEXT_RAW> @ imm = #0x8eb6
700a5ffa: f8ad 0002    	strh.w	r0, [sp, #0x2]
;                 if ((extracted_inp == inp) &&
700a5ffe: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a6002: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a6006: 4288         	cmp	r0, r1
700a6008: d10b         	bne	0x700a6022 <Sciclient_rmIrInpIsFree+0xc2> @ imm = #0x16
700a600a: e7ff         	b	0x700a600c <Sciclient_rmIrInpIsFree+0xac> @ imm = #-0x2
;                     (Sciclient_rmIrInpRomMapped(inst, inp) == false)) {
700a600c: 9803         	ldr	r0, [sp, #0xc]
700a600e: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a6012: f002 f87d    	bl	0x700a8110 <Sciclient_rmIrInpRomMapped> @ imm = #0x20fa
;                 if ((extracted_inp == inp) &&
700a6016: b920         	cbnz	r0, 0x700a6022 <Sciclient_rmIrInpIsFree+0xc2> @ imm = #0x8
700a6018: e7ff         	b	0x700a601a <Sciclient_rmIrInpIsFree+0xba> @ imm = #-0x2
700a601a: f04f 30ff    	mov.w	r0, #0xffffffff
;                     r = SystemP_FAILURE;
700a601e: 9004         	str	r0, [sp, #0x10]
;                     break;
700a6020: e006         	b	0x700a6030 <Sciclient_rmIrInpIsFree+0xd0> @ imm = #0xc
;             }
700a6022: e7ff         	b	0x700a6024 <Sciclient_rmIrInpIsFree+0xc4> @ imm = #-0x2
;             for (i = 0u; i < inst->n_outp; i++) {
700a6024: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a6028: 3001         	adds	r0, #0x1
700a602a: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a602e: e7d0         	b	0x700a5fd2 <Sciclient_rmIrInpIsFree+0x72> @ imm = #-0x60
700a6030: e7ff         	b	0x700a6032 <Sciclient_rmIrInpIsFree+0xd2> @ imm = #-0x2
;     }
700a6032: e7ff         	b	0x700a6034 <Sciclient_rmIrInpIsFree+0xd4> @ imm = #-0x2
;     return r;
700a6034: 9804         	ldr	r0, [sp, #0x10]
700a6036: b006         	add	sp, #0x18
700a6038: bd80         	pop	{r7, pc}
700a603a: 0000         	movs	r0, r0
700a603c: 0000         	movs	r0, r0
700a603e: 0000         	movs	r0, r0

700a6040 <UART_intrDisable>:
; {
700a6040: b580         	push	{r7, lr}
700a6042: b088         	sub	sp, #0x20
700a6044: 9007         	str	r0, [sp, #0x1c]
700a6046: 9106         	str	r1, [sp, #0x18]
;     if((intrFlag & 0xF0U) > 0U)
700a6048: f89d 0018    	ldrb.w	r0, [sp, #0x18]
700a604c: f010 0ff0    	tst.w	r0, #0xf0
700a6050: d020         	beq	0x700a6094 <UART_intrDisable+0x54> @ imm = #0x40
700a6052: e7ff         	b	0x700a6054 <UART_intrDisable+0x14> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a6054: 9807         	ldr	r0, [sp, #0x1c]
700a6056: 300c         	adds	r0, #0xc
700a6058: f009 fc02    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x9804
700a605c: 9004         	str	r0, [sp, #0x10]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a605e: 9807         	ldr	r0, [sp, #0x1c]
700a6060: 300c         	adds	r0, #0xc
700a6062: 21bf         	movs	r1, #0xbf
700a6064: f009 fc04    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x9808
;         enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a6068: 9807         	ldr	r0, [sp, #0x1c]
700a606a: 3008         	adds	r0, #0x8
700a606c: 2110         	movs	r1, #0x10
700a606e: 9102         	str	r1, [sp, #0x8]
700a6070: 2204         	movs	r2, #0x4
700a6072: 9203         	str	r2, [sp, #0xc]
700a6074: f008 fffc    	bl	0x700af070 <HW_RD_FIELD32_RAW> @ imm = #0x8ff8
700a6078: 9902         	ldr	r1, [sp, #0x8]
700a607a: 9a03         	ldr	r2, [sp, #0xc]
700a607c: 9005         	str	r0, [sp, #0x14]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a607e: 9807         	ldr	r0, [sp, #0x1c]
700a6080: 3008         	adds	r0, #0x8
700a6082: 2301         	movs	r3, #0x1
700a6084: f008 f9c4    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x8388
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a6088: 9807         	ldr	r0, [sp, #0x1c]
700a608a: 300c         	adds	r0, #0xc
700a608c: 9904         	ldr	r1, [sp, #0x10]
700a608e: f009 fbef    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x97de
;     }
700a6092: e7ff         	b	0x700a6094 <UART_intrDisable+0x54> @ imm = #-0x2
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a6094: 9807         	ldr	r0, [sp, #0x1c]
700a6096: 300c         	adds	r0, #0xc
700a6098: f009 fbe2    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x97c4
700a609c: 9004         	str	r0, [sp, #0x10]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700a609e: 9807         	ldr	r0, [sp, #0x1c]
700a60a0: 300c         	adds	r0, #0xc
700a60a2: 9000         	str	r0, [sp]
700a60a4: f009 fbdc    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x97b8
700a60a8: 4601         	mov	r1, r0
700a60aa: 9800         	ldr	r0, [sp]
700a60ac: f001 017f    	and	r1, r1, #0x7f
700a60b0: f009 fbde    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x97bc
;     HW_WR_REG32(baseAddr + UART_IER, HW_RD_REG32(baseAddr + UART_IER) &
700a60b4: 9807         	ldr	r0, [sp, #0x1c]
700a60b6: 3004         	adds	r0, #0x4
700a60b8: 9001         	str	r0, [sp, #0x4]
700a60ba: f009 fbd1    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x97a2
700a60be: 4601         	mov	r1, r0
700a60c0: 9801         	ldr	r0, [sp, #0x4]
700a60c2: 9b06         	ldr	r3, [sp, #0x18]
700a60c4: f06f 02ff    	mvn	r2, #0xff
700a60c8: ea62 0203    	orn	r2, r2, r3
700a60cc: 4011         	ands	r1, r2
700a60ce: f009 fbcf    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x979e
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a60d2: 9807         	ldr	r0, [sp, #0x1c]
700a60d4: 300c         	adds	r0, #0xc
700a60d6: 9904         	ldr	r1, [sp, #0x10]
700a60d8: f009 fbca    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x9794
;     if((intrFlag & 0xF0U) > 0U)
700a60dc: f89d 0018    	ldrb.w	r0, [sp, #0x18]
700a60e0: f010 0ff0    	tst.w	r0, #0xf0
700a60e4: d017         	beq	0x700a6116 <UART_intrDisable+0xd6> @ imm = #0x2e
700a60e6: e7ff         	b	0x700a60e8 <UART_intrDisable+0xa8> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a60e8: 9807         	ldr	r0, [sp, #0x1c]
700a60ea: 300c         	adds	r0, #0xc
700a60ec: f009 fbb8    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x9770
700a60f0: 9004         	str	r0, [sp, #0x10]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a60f2: 9807         	ldr	r0, [sp, #0x1c]
700a60f4: 300c         	adds	r0, #0xc
700a60f6: 21bf         	movs	r1, #0xbf
700a60f8: f009 fbba    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x9774
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a60fc: 9807         	ldr	r0, [sp, #0x1c]
700a60fe: 3008         	adds	r0, #0x8
700a6100: 9b05         	ldr	r3, [sp, #0x14]
700a6102: 2110         	movs	r1, #0x10
700a6104: 2204         	movs	r2, #0x4
700a6106: f008 f983    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x8306
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a610a: 9807         	ldr	r0, [sp, #0x1c]
700a610c: 300c         	adds	r0, #0xc
700a610e: 9904         	ldr	r1, [sp, #0x10]
700a6110: f009 fbae    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x975c
;     }
700a6114: e7ff         	b	0x700a6116 <UART_intrDisable+0xd6> @ imm = #-0x2
; }
700a6116: b008         	add	sp, #0x20
700a6118: bd80         	pop	{r7, pc}
700a611a: 0000         	movs	r0, r0
700a611c: 0000         	movs	r0, r0
700a611e: 0000         	movs	r0, r0

700a6120 <UART_udmaConfigPdmaTx>:
; {
700a6120: b580         	push	{r7, lr}
700a6122: b090         	sub	sp, #0x40
700a6124: 900f         	str	r0, [sp, #0x3c]
700a6126: 910e         	str	r1, [sp, #0x38]
;     udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a6128: 980f         	ldr	r0, [sp, #0x3c]
700a612a: 6840         	ldr	r0, [r0, #0x4]
700a612c: 6cc0         	ldr	r0, [r0, #0x4c]
700a612e: 9008         	str	r0, [sp, #0x20]
;     txChHandle  = udmaChCfg->txChHandle;
700a6130: 9808         	ldr	r0, [sp, #0x20]
700a6132: 6840         	ldr	r0, [r0, #0x4]
700a6134: 9009         	str	r0, [sp, #0x24]
700a6136: a80a         	add	r0, sp, #0x28
;     UdmaChPdmaPrms_init(&pdmaPrms);
700a6138: 9002         	str	r0, [sp, #0x8]
700a613a: f009 f859    	bl	0x700af1f0 <UdmaChPdmaPrms_init> @ imm = #0x90b2
700a613e: 9902         	ldr	r1, [sp, #0x8]
700a6140: 2000         	movs	r0, #0x0
;     pdmaPrms.elemSize = UDMA_PDMA_ES_8BITS;
700a6142: 9003         	str	r0, [sp, #0xc]
700a6144: 900a         	str	r0, [sp, #0x28]
700a6146: 2201         	movs	r2, #0x1
;     pdmaPrms.elemCnt  = 1U;
700a6148: 920b         	str	r2, [sp, #0x2c]
;     pdmaPrms.fifoCnt  = 0U;
700a614a: 900c         	str	r0, [sp, #0x30]
;     retVal = Udma_chConfigPdma(txChHandle, &pdmaPrms);
700a614c: 9809         	ldr	r0, [sp, #0x24]
700a614e: f7fa ffcf    	bl	0x700a10f0 <Udma_chConfigPdma> @ imm = #-0x5062
700a6152: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a6154: 980d         	ldr	r0, [sp, #0x34]
700a6156: fab0 f080    	clz	r0, r0
700a615a: 0940         	lsrs	r0, r0, #0x5
700a615c: f641 4153    	movw	r1, #0x1c53
700a6160: f2c7 010b    	movt	r1, #0x700b
700a6164: 9105         	str	r1, [sp, #0x14]
700a6166: 466a         	mov	r2, sp
700a6168: 6011         	str	r1, [r2]
700a616a: f641 016d    	movw	r1, #0x186d
700a616e: f2c7 010b    	movt	r1, #0x700b
700a6172: 9106         	str	r1, [sp, #0x18]
700a6174: f641 4216    	movw	r2, #0x1c16
700a6178: f2c7 020b    	movt	r2, #0x700b
700a617c: 9207         	str	r2, [sp, #0x1c]
700a617e: 23ee         	movs	r3, #0xee
700a6180: f004 fc56    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x48ac
;     retVal = Udma_chEnable(txChHandle);
700a6184: 9809         	ldr	r0, [sp, #0x24]
700a6186: f004 ff13    	bl	0x700aafb0 <Udma_chEnable> @ imm = #0x4e26
700a618a: 9b05         	ldr	r3, [sp, #0x14]
700a618c: 9906         	ldr	r1, [sp, #0x18]
700a618e: 9a07         	ldr	r2, [sp, #0x1c]
700a6190: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a6192: 980d         	ldr	r0, [sp, #0x34]
700a6194: fab0 f080    	clz	r0, r0
700a6198: 0940         	lsrs	r0, r0, #0x5
700a619a: 46ec         	mov	r12, sp
700a619c: f8cc 3000    	str.w	r3, [r12]
700a61a0: 23f1         	movs	r3, #0xf1
700a61a2: f004 fc45    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x488a
;     UART_udmaHpdInit(txChHandle, (uint8_t *) udmaChCfg->txHpdMem, hUart->writeBuf, transaction->count);
700a61a6: 9809         	ldr	r0, [sp, #0x24]
700a61a8: 9908         	ldr	r1, [sp, #0x20]
700a61aa: 6949         	ldr	r1, [r1, #0x14]
700a61ac: 9a0f         	ldr	r2, [sp, #0x3c]
700a61ae: 6892         	ldr	r2, [r2, #0x8]
700a61b0: 9b0e         	ldr	r3, [sp, #0x38]
700a61b2: 685b         	ldr	r3, [r3, #0x4]
700a61b4: f000 fd3c    	bl	0x700a6c30 <UART_udmaHpdInit> @ imm = #0xa78
;                  Udma_chGetFqRingHandle(txChHandle),
700a61b8: 9809         	ldr	r0, [sp, #0x24]
700a61ba: f004 fe39    	bl	0x700aae30 <Udma_chGetFqRingHandle> @ imm = #0x4c72
700a61be: 9a03         	ldr	r2, [sp, #0xc]
;                  (uint64_t) Udma_defaultVirtToPhyFxn(udmaChCfg->txHpdMem, 0U, NULL));
700a61c0: 9004         	str	r0, [sp, #0x10]
700a61c2: 9808         	ldr	r0, [sp, #0x20]
700a61c4: 6940         	ldr	r0, [r0, #0x14]
700a61c6: 4611         	mov	r1, r2
700a61c8: f009 fb5a    	bl	0x700af880 <Udma_defaultVirtToPhyFxn> @ imm = #0x96b4
700a61cc: 4602         	mov	r2, r0
700a61ce: 9804         	ldr	r0, [sp, #0x10]
700a61d0: 460b         	mov	r3, r1
;     retVal = Udma_ringQueueRaw(
700a61d2: f002 fed5    	bl	0x700a8f80 <Udma_ringQueueRaw> @ imm = #0x2daa
700a61d6: 9b05         	ldr	r3, [sp, #0x14]
700a61d8: 9906         	ldr	r1, [sp, #0x18]
700a61da: 9a07         	ldr	r2, [sp, #0x1c]
700a61dc: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a61de: 980d         	ldr	r0, [sp, #0x34]
700a61e0: fab0 f080    	clz	r0, r0
700a61e4: 0940         	lsrs	r0, r0, #0x5
700a61e6: 46ec         	mov	r12, sp
700a61e8: f8cc 3000    	str.w	r3, [r12]
700a61ec: 23f9         	movs	r3, #0xf9
700a61ee: f004 fc1f    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x483e
;     return (retVal);
700a61f2: 980d         	ldr	r0, [sp, #0x34]
700a61f4: b010         	add	sp, #0x40
700a61f6: bd80         	pop	{r7, pc}
		...

700a6200 <vTaskDelete>:
; void vTaskDelete(TaskHandle_t xTaskToDelete) {
700a6200: b580         	push	{r7, lr}
700a6202: b084         	sub	sp, #0x10
700a6204: 9003         	str	r0, [sp, #0xc]
;   taskENTER_CRITICAL();
700a6206: f008 f963    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0x82c6
;     pxTCB = prvGetTCBFromHandle(xTaskToDelete);
700a620a: 9803         	ldr	r0, [sp, #0xc]
700a620c: b938         	cbnz	r0, 0x700a621e <vTaskDelete+0x1e> @ imm = #0xe
700a620e: e7ff         	b	0x700a6210 <vTaskDelete+0x10> @ imm = #-0x2
700a6210: f242 60bc    	movw	r0, #0x26bc
700a6214: f2c7 000b    	movt	r0, #0x700b
700a6218: 6800         	ldr	r0, [r0]
700a621a: 9001         	str	r0, [sp, #0x4]
700a621c: e002         	b	0x700a6224 <vTaskDelete+0x24> @ imm = #0x4
700a621e: 9803         	ldr	r0, [sp, #0xc]
700a6220: 9001         	str	r0, [sp, #0x4]
700a6222: e7ff         	b	0x700a6224 <vTaskDelete+0x24> @ imm = #-0x2
700a6224: 9801         	ldr	r0, [sp, #0x4]
700a6226: 9002         	str	r0, [sp, #0x8]
;     if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a6228: 9802         	ldr	r0, [sp, #0x8]
700a622a: 3004         	adds	r0, #0x4
700a622c: f007 f920    	bl	0x700ad470 <uxListRemove> @ imm = #0x7240
700a6230: b908         	cbnz	r0, 0x700a6236 <vTaskDelete+0x36> @ imm = #0x2
700a6232: e7ff         	b	0x700a6234 <vTaskDelete+0x34> @ imm = #-0x2
;     } else {
700a6234: e000         	b	0x700a6238 <vTaskDelete+0x38> @ imm = #0x0
700a6236: e7ff         	b	0x700a6238 <vTaskDelete+0x38> @ imm = #-0x2
;     if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a6238: 9802         	ldr	r0, [sp, #0x8]
700a623a: 6a80         	ldr	r0, [r0, #0x28]
700a623c: b128         	cbz	r0, 0x700a624a <vTaskDelete+0x4a> @ imm = #0xa
700a623e: e7ff         	b	0x700a6240 <vTaskDelete+0x40> @ imm = #-0x2
;       (void)uxListRemove(&(pxTCB->xEventListItem));
700a6240: 9802         	ldr	r0, [sp, #0x8]
700a6242: 3018         	adds	r0, #0x18
700a6244: f007 f914    	bl	0x700ad470 <uxListRemove> @ imm = #0x7228
;     } else {
700a6248: e000         	b	0x700a624c <vTaskDelete+0x4c> @ imm = #0x0
700a624a: e7ff         	b	0x700a624c <vTaskDelete+0x4c> @ imm = #-0x2
;     uxTaskNumber++;
700a624c: f242 61e8    	movw	r1, #0x26e8
700a6250: f2c7 010b    	movt	r1, #0x700b
700a6254: 6808         	ldr	r0, [r1]
700a6256: 3001         	adds	r0, #0x1
700a6258: 6008         	str	r0, [r1]
;     if (pxTCB == pxCurrentTCB) {
700a625a: 9802         	ldr	r0, [sp, #0x8]
700a625c: f242 61bc    	movw	r1, #0x26bc
700a6260: f2c7 010b    	movt	r1, #0x700b
700a6264: 6809         	ldr	r1, [r1]
700a6266: 4288         	cmp	r0, r1
700a6268: d110         	bne	0x700a628c <vTaskDelete+0x8c> @ imm = #0x20
700a626a: e7ff         	b	0x700a626c <vTaskDelete+0x6c> @ imm = #-0x2
;       vListInsertEnd(&xTasksWaitingTermination, &(pxTCB->xStateListItem));
700a626c: 9802         	ldr	r0, [sp, #0x8]
700a626e: 1d01         	adds	r1, r0, #0x4
700a6270: f245 2008    	movw	r0, #0x5208
700a6274: f2c7 0008    	movt	r0, #0x7008
700a6278: f007 feb2    	bl	0x700adfe0 <vListInsertEnd> @ imm = #0x7d64
;       ++uxDeletedTasksWaitingCleanUp;
700a627c: f242 61e0    	movw	r1, #0x26e0
700a6280: f2c7 010b    	movt	r1, #0x700b
700a6284: 6808         	ldr	r0, [r1]
700a6286: 3001         	adds	r0, #0x1
700a6288: 6008         	str	r0, [r1]
;     } else {
700a628a: e00c         	b	0x700a62a6 <vTaskDelete+0xa6> @ imm = #0x18
;       --uxCurrentNumberOfTasks;
700a628c: f242 61dc    	movw	r1, #0x26dc
700a6290: f2c7 010b    	movt	r1, #0x700b
700a6294: 6808         	ldr	r0, [r1]
700a6296: 3801         	subs	r0, #0x1
700a6298: 6008         	str	r0, [r1]
;       prvDeleteTCB(pxTCB);
700a629a: 9802         	ldr	r0, [sp, #0x8]
700a629c: f007 fe00    	bl	0x700adea0 <prvDeleteTCB> @ imm = #0x7c00
;       prvResetNextTaskUnblockTime();
700a62a0: f007 fe1e    	bl	0x700adee0 <prvResetNextTaskUnblockTime> @ imm = #0x7c3c
700a62a4: e7ff         	b	0x700a62a6 <vTaskDelete+0xa6> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a62a6: f007 f9d3    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0x73a6
;   if (xSchedulerRunning != pdFALSE) {
700a62aa: f242 7000    	movw	r0, #0x2700
700a62ae: f2c7 000b    	movt	r0, #0x700b
700a62b2: 6800         	ldr	r0, [r0]
700a62b4: b168         	cbz	r0, 0x700a62d2 <vTaskDelete+0xd2> @ imm = #0x1a
700a62b6: e7ff         	b	0x700a62b8 <vTaskDelete+0xb8> @ imm = #-0x2
;     if (pxTCB == pxCurrentTCB) {
700a62b8: 9802         	ldr	r0, [sp, #0x8]
700a62ba: f242 61bc    	movw	r1, #0x26bc
700a62be: f2c7 010b    	movt	r1, #0x700b
700a62c2: 6809         	ldr	r1, [r1]
700a62c4: 4288         	cmp	r0, r1
700a62c6: d102         	bne	0x700a62ce <vTaskDelete+0xce> @ imm = #0x4
700a62c8: e7ff         	b	0x700a62ca <vTaskDelete+0xca> @ imm = #-0x2
;       portYIELD_WITHIN_API();
700a62ca: df00         	svc	#0x0
;     } else {
700a62cc: e000         	b	0x700a62d0 <vTaskDelete+0xd0> @ imm = #0x0
700a62ce: e7ff         	b	0x700a62d0 <vTaskDelete+0xd0> @ imm = #-0x2
;   }
700a62d0: e7ff         	b	0x700a62d2 <vTaskDelete+0xd2> @ imm = #-0x2
; }
700a62d2: b004         	add	sp, #0x10
700a62d4: bd80         	pop	{r7, pc}
		...
700a62de: 0000         	movs	r0, r0

700a62e0 <CSL_bcdmaChanOpGetChanRT>:
; {
700a62e0: b580         	push	{r7, lr}
700a62e2: b088         	sub	sp, #0x20
700a62e4: 9007         	str	r0, [sp, #0x1c]
700a62e6: 9106         	str	r1, [sp, #0x18]
700a62e8: 9205         	str	r2, [sp, #0x14]
700a62ea: 9304         	str	r3, [sp, #0x10]
700a62ec: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a62ee: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a62f0: 9804         	ldr	r0, [sp, #0x10]
700a62f2: b920         	cbnz	r0, 0x700a62fe <CSL_bcdmaChanOpGetChanRT+0x1e> @ imm = #0x8
700a62f4: e7ff         	b	0x700a62f6 <CSL_bcdmaChanOpGetChanRT+0x16> @ imm = #-0x2
700a62f6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a62fa: 9003         	str	r0, [sp, #0xc]
;     }
700a62fc: e057         	b	0x700a63ae <CSL_bcdmaChanOpGetChanRT+0xce> @ imm = #0xae
;         switch( chanType )
700a62fe: 9806         	ldr	r0, [sp, #0x18]
700a6300: 9000         	str	r0, [sp]
700a6302: b140         	cbz	r0, 0x700a6316 <CSL_bcdmaChanOpGetChanRT+0x36> @ imm = #0x10
700a6304: e7ff         	b	0x700a6306 <CSL_bcdmaChanOpGetChanRT+0x26> @ imm = #-0x2
700a6306: 9800         	ldr	r0, [sp]
700a6308: 2801         	cmp	r0, #0x1
700a630a: d00d         	beq	0x700a6328 <CSL_bcdmaChanOpGetChanRT+0x48> @ imm = #0x1a
700a630c: e7ff         	b	0x700a630e <CSL_bcdmaChanOpGetChanRT+0x2e> @ imm = #-0x2
700a630e: 9800         	ldr	r0, [sp]
700a6310: 2802         	cmp	r0, #0x2
700a6312: d012         	beq	0x700a633a <CSL_bcdmaChanOpGetChanRT+0x5a> @ imm = #0x24
700a6314: e01a         	b	0x700a634c <CSL_bcdmaChanOpGetChanRT+0x6c> @ imm = #0x34
;                 val = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL );
700a6316: 9807         	ldr	r0, [sp, #0x1c]
700a6318: 6880         	ldr	r0, [r0, #0x8]
700a631a: 9905         	ldr	r1, [sp, #0x14]
700a631c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6320: f009 fae6    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0x95cc
700a6324: 9002         	str	r0, [sp, #0x8]
;                 break;
700a6326: e015         	b	0x700a6354 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x2a
;                 val = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a6328: 9807         	ldr	r0, [sp, #0x1c]
700a632a: 6900         	ldr	r0, [r0, #0x10]
700a632c: 9905         	ldr	r1, [sp, #0x14]
700a632e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6332: f009 fadd    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0x95ba
700a6336: 9002         	str	r0, [sp, #0x8]
;                 break;
700a6338: e00c         	b	0x700a6354 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x18
;                 val = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a633a: 9807         	ldr	r0, [sp, #0x1c]
700a633c: 6980         	ldr	r0, [r0, #0x18]
700a633e: 9905         	ldr	r1, [sp, #0x14]
700a6340: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6344: f009 fad4    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0x95a8
700a6348: 9002         	str	r0, [sp, #0x8]
;                 break;
700a634a: e003         	b	0x700a6354 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x6
700a634c: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a6350: 9003         	str	r0, [sp, #0xc]
;                 break;
700a6352: e7ff         	b	0x700a6354 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #-0x2
;         if( retVal == CSL_PASS )
700a6354: 9803         	ldr	r0, [sp, #0xc]
700a6356: bb48         	cbnz	r0, 0x700a63ac <CSL_bcdmaChanOpGetChanRT+0xcc> @ imm = #0x52
700a6358: e7ff         	b	0x700a635a <CSL_bcdmaChanOpGetChanRT+0x7a> @ imm = #-0x2
;             CSL_BcdmaRT *pRT = (CSL_BcdmaRT *)pOpData;
700a635a: 9804         	ldr	r0, [sp, #0x10]
700a635c: 9001         	str	r0, [sp, #0x4]
;             pRT->enable         = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_EN );
700a635e: 9802         	ldr	r0, [sp, #0x8]
700a6360: 0fc0         	lsrs	r0, r0, #0x1f
700a6362: 9901         	ldr	r1, [sp, #0x4]
700a6364: 6008         	str	r0, [r1]
;             pRT->teardown       = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_TDOWN );
700a6366: 9802         	ldr	r0, [sp, #0x8]
700a6368: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700a636c: 9901         	ldr	r1, [sp, #0x4]
700a636e: 6048         	str	r0, [r1, #0x4]
;             pRT->forcedTeardown = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_FTDOWN );
700a6370: 9802         	ldr	r0, [sp, #0x8]
700a6372: f3c0 7000    	ubfx	r0, r0, #0x1c, #0x1
700a6376: 9901         	ldr	r1, [sp, #0x4]
700a6378: 6108         	str	r0, [r1, #0x10]
;             pRT->pause          = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_PAUSE );
700a637a: 9802         	ldr	r0, [sp, #0x8]
700a637c: f3c0 7040    	ubfx	r0, r0, #0x1d, #0x1
700a6380: 9901         	ldr	r1, [sp, #0x4]
700a6382: 6088         	str	r0, [r1, #0x8]
;             pRT->error          = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_ERROR );
700a6384: 9802         	ldr	r0, [sp, #0x8]
700a6386: f000 0001    	and	r0, r0, #0x1
700a638a: 9901         	ldr	r1, [sp, #0x4]
700a638c: 60c8         	str	r0, [r1, #0xc]
;             if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700a638e: 9806         	ldr	r0, [sp, #0x18]
700a6390: 2802         	cmp	r0, #0x2
700a6392: d106         	bne	0x700a63a2 <CSL_bcdmaChanOpGetChanRT+0xc2> @ imm = #0xc
700a6394: e7ff         	b	0x700a6396 <CSL_bcdmaChanOpGetChanRT+0xb6> @ imm = #-0x2
;                 pRT->starvation = CSL_FEXT( val, BCDMA_RXCRT_CHAN_CTL_STARVATION );
700a6396: 9802         	ldr	r0, [sp, #0x8]
700a6398: f3c0 0040    	ubfx	r0, r0, #0x1, #0x1
700a639c: 9901         	ldr	r1, [sp, #0x4]
700a639e: 6148         	str	r0, [r1, #0x14]
;             }
700a63a0: e003         	b	0x700a63aa <CSL_bcdmaChanOpGetChanRT+0xca> @ imm = #0x6
;                 pRT->starvation = (uint32_t)0U;
700a63a2: 9901         	ldr	r1, [sp, #0x4]
700a63a4: 2000         	movs	r0, #0x0
700a63a6: 6148         	str	r0, [r1, #0x14]
700a63a8: e7ff         	b	0x700a63aa <CSL_bcdmaChanOpGetChanRT+0xca> @ imm = #-0x2
;         }
700a63aa: e7ff         	b	0x700a63ac <CSL_bcdmaChanOpGetChanRT+0xcc> @ imm = #-0x2
700a63ac: e7ff         	b	0x700a63ae <CSL_bcdmaChanOpGetChanRT+0xce> @ imm = #-0x2
;     return retVal;
700a63ae: 9803         	ldr	r0, [sp, #0xc]
700a63b0: b008         	add	sp, #0x20
700a63b2: bd80         	pop	{r7, pc}
		...

700a63c0 <Pinmux_unlockMMR>:
; {
700a63c0: b580         	push	{r7, lr}
700a63c2: b088         	sub	sp, #0x20
700a63c4: 9007         	str	r0, [sp, #0x1c]
;     if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a63c6: 9807         	ldr	r0, [sp, #0x1c]
700a63c8: bb78         	cbnz	r0, 0x700a642a <Pinmux_unlockMMR+0x6a> @ imm = #0x5e
700a63ca: e7ff         	b	0x700a63cc <Pinmux_unlockMMR+0xc> @ imm = #-0x2
700a63cc: f44f 2070    	mov.w	r0, #0xf0000
700a63d0: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_PADCFG_CTRL0_CFG0_BASE);
700a63d2: f7ff fa95    	bl	0x700a5900 <AddrTranslateP_getLocalAddr> @ imm = #-0xad6
700a63d6: 9006         	str	r0, [sp, #0x18]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_PADCONFIG_LOCK0_KICK0_OFFSET);
700a63d8: 9806         	ldr	r0, [sp, #0x18]
700a63da: f241 0108    	movw	r1, #0x1008
700a63de: 4408         	add	r0, r1
700a63e0: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a63e2: 9805         	ldr	r0, [sp, #0x14]
700a63e4: f243 4190    	movw	r1, #0x3490
700a63e8: f6c6 01ef    	movt	r1, #0x68ef
700a63ec: 9103         	str	r1, [sp, #0xc]
700a63ee: f009 f9ef    	bl	0x700af7d0 <CSL_REG32_WR_RAW> @ imm = #0x93de
;         kickAddr++;
700a63f2: 9805         	ldr	r0, [sp, #0x14]
700a63f4: 3004         	adds	r0, #0x4
700a63f6: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a63f8: 9805         	ldr	r0, [sp, #0x14]
700a63fa: f64b 415a    	movw	r1, #0xbc5a
700a63fe: f2cd 1172    	movt	r1, #0xd172
700a6402: 9104         	str	r1, [sp, #0x10]
700a6404: f009 f9e4    	bl	0x700af7d0 <CSL_REG32_WR_RAW> @ imm = #0x93c8
700a6408: 9903         	ldr	r1, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_PADCONFIG_LOCK1_KICK0_OFFSET);
700a640a: 9806         	ldr	r0, [sp, #0x18]
700a640c: f245 0208    	movw	r2, #0x5008
700a6410: 4410         	add	r0, r2
700a6412: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a6414: 9805         	ldr	r0, [sp, #0x14]
700a6416: f009 f9db    	bl	0x700af7d0 <CSL_REG32_WR_RAW> @ imm = #0x93b6
700a641a: 9904         	ldr	r1, [sp, #0x10]
;         kickAddr++;
700a641c: 9805         	ldr	r0, [sp, #0x14]
700a641e: 3004         	adds	r0, #0x4
700a6420: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a6422: 9805         	ldr	r0, [sp, #0x14]
700a6424: f009 f9d4    	bl	0x700af7d0 <CSL_REG32_WR_RAW> @ imm = #0x93a8
;     }
700a6428: e7ff         	b	0x700a642a <Pinmux_unlockMMR+0x6a> @ imm = #-0x2
;     if(PINMUX_DOMAIN_ID_MCU == domainId)
700a642a: 9807         	ldr	r0, [sp, #0x1c]
700a642c: 2801         	cmp	r0, #0x1
700a642e: d12f         	bne	0x700a6490 <Pinmux_unlockMMR+0xd0> @ imm = #0x5e
700a6430: e7ff         	b	0x700a6432 <Pinmux_unlockMMR+0x72> @ imm = #-0x2
700a6432: f04f 6081    	mov.w	r0, #0x4080000
700a6436: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_PADCFG_CTRL0_CFG0_BASE);
700a6438: f7ff fa62    	bl	0x700a5900 <AddrTranslateP_getLocalAddr> @ imm = #-0xb3c
700a643c: 9006         	str	r0, [sp, #0x18]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK0_KICK0_OFFSET);
700a643e: 9806         	ldr	r0, [sp, #0x18]
700a6440: f241 0108    	movw	r1, #0x1008
700a6444: 4408         	add	r0, r1
700a6446: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a6448: 9805         	ldr	r0, [sp, #0x14]
700a644a: f243 4190    	movw	r1, #0x3490
700a644e: f6c6 01ef    	movt	r1, #0x68ef
700a6452: 9101         	str	r1, [sp, #0x4]
700a6454: f009 f9bc    	bl	0x700af7d0 <CSL_REG32_WR_RAW> @ imm = #0x9378
;         kickAddr++;
700a6458: 9805         	ldr	r0, [sp, #0x14]
700a645a: 3004         	adds	r0, #0x4
700a645c: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a645e: 9805         	ldr	r0, [sp, #0x14]
700a6460: f64b 415a    	movw	r1, #0xbc5a
700a6464: f2cd 1172    	movt	r1, #0xd172
700a6468: 9102         	str	r1, [sp, #0x8]
700a646a: f009 f9b1    	bl	0x700af7d0 <CSL_REG32_WR_RAW> @ imm = #0x9362
700a646e: 9901         	ldr	r1, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK1_KICK0_OFFSET);
700a6470: 9806         	ldr	r0, [sp, #0x18]
700a6472: f245 0208    	movw	r2, #0x5008
700a6476: 4410         	add	r0, r2
700a6478: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a647a: 9805         	ldr	r0, [sp, #0x14]
700a647c: f009 f9a8    	bl	0x700af7d0 <CSL_REG32_WR_RAW> @ imm = #0x9350
700a6480: 9902         	ldr	r1, [sp, #0x8]
;         kickAddr++;
700a6482: 9805         	ldr	r0, [sp, #0x14]
700a6484: 3004         	adds	r0, #0x4
700a6486: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a6488: 9805         	ldr	r0, [sp, #0x14]
700a648a: f009 f9a1    	bl	0x700af7d0 <CSL_REG32_WR_RAW> @ imm = #0x9342
;     }
700a648e: e7ff         	b	0x700a6490 <Pinmux_unlockMMR+0xd0> @ imm = #-0x2
;     return;
700a6490: b008         	add	sp, #0x20
700a6492: bd80         	pop	{r7, pc}
		...

700a64a0 <prvAddCurrentTaskToDelayedList>:
;                                const BaseType_t xCanBlockIndefinitely) {
700a64a0: b580         	push	{r7, lr}
700a64a2: b084         	sub	sp, #0x10
700a64a4: 9003         	str	r0, [sp, #0xc]
700a64a6: 9102         	str	r1, [sp, #0x8]
;   const TickType_t xConstTickCount = xTickCount;
700a64a8: f242 7004    	movw	r0, #0x2704
700a64ac: f2c7 000b    	movt	r0, #0x700b
700a64b0: 6800         	ldr	r0, [r0]
700a64b2: 9000         	str	r0, [sp]
;   if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
700a64b4: f242 60bc    	movw	r0, #0x26bc
700a64b8: f2c7 000b    	movt	r0, #0x700b
700a64bc: 6800         	ldr	r0, [r0]
700a64be: 3004         	adds	r0, #0x4
700a64c0: f006 ffd6    	bl	0x700ad470 <uxListRemove> @ imm = #0x6fac
700a64c4: b908         	cbnz	r0, 0x700a64ca <prvAddCurrentTaskToDelayedList+0x2a> @ imm = #0x2
700a64c6: e7ff         	b	0x700a64c8 <prvAddCurrentTaskToDelayedList+0x28> @ imm = #-0x2
;   } else {
700a64c8: e000         	b	0x700a64cc <prvAddCurrentTaskToDelayedList+0x2c> @ imm = #0x0
700a64ca: e7ff         	b	0x700a64cc <prvAddCurrentTaskToDelayedList+0x2c> @ imm = #-0x2
;     if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
700a64cc: 9803         	ldr	r0, [sp, #0xc]
700a64ce: 3001         	adds	r0, #0x1
700a64d0: b980         	cbnz	r0, 0x700a64f4 <prvAddCurrentTaskToDelayedList+0x54> @ imm = #0x20
700a64d2: e7ff         	b	0x700a64d4 <prvAddCurrentTaskToDelayedList+0x34> @ imm = #-0x2
700a64d4: 9802         	ldr	r0, [sp, #0x8]
700a64d6: b168         	cbz	r0, 0x700a64f4 <prvAddCurrentTaskToDelayedList+0x54> @ imm = #0x1a
700a64d8: e7ff         	b	0x700a64da <prvAddCurrentTaskToDelayedList+0x3a> @ imm = #-0x2
;       vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
700a64da: f242 60bc    	movw	r0, #0x26bc
700a64de: f2c7 000b    	movt	r0, #0x700b
700a64e2: 6800         	ldr	r0, [r0]
700a64e4: 1d01         	adds	r1, r0, #0x4
700a64e6: f245 10f4    	movw	r0, #0x51f4
700a64ea: f2c7 0008    	movt	r0, #0x7008
700a64ee: f007 fd77    	bl	0x700adfe0 <vListInsertEnd> @ imm = #0x7aee
;     } else {
700a64f2: e03d         	b	0x700a6570 <prvAddCurrentTaskToDelayedList+0xd0> @ imm = #0x7a
;       xTimeToWake = xConstTickCount + xTicksToWait;
700a64f4: 9800         	ldr	r0, [sp]
700a64f6: 9903         	ldr	r1, [sp, #0xc]
700a64f8: 4408         	add	r0, r1
700a64fa: 9001         	str	r0, [sp, #0x4]
;       listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
700a64fc: 9801         	ldr	r0, [sp, #0x4]
700a64fe: f242 61bc    	movw	r1, #0x26bc
700a6502: f2c7 010b    	movt	r1, #0x700b
700a6506: 6809         	ldr	r1, [r1]
700a6508: 6048         	str	r0, [r1, #0x4]
;       if (xTimeToWake < xConstTickCount) {
700a650a: 9801         	ldr	r0, [sp, #0x4]
700a650c: 9900         	ldr	r1, [sp]
700a650e: 4288         	cmp	r0, r1
700a6510: d20e         	bhs	0x700a6530 <prvAddCurrentTaskToDelayedList+0x90> @ imm = #0x1c
700a6512: e7ff         	b	0x700a6514 <prvAddCurrentTaskToDelayedList+0x74> @ imm = #-0x2
;         vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
700a6514: f245 2024    	movw	r0, #0x5224
700a6518: f2c7 0008    	movt	r0, #0x7008
700a651c: 6800         	ldr	r0, [r0]
700a651e: f242 61bc    	movw	r1, #0x26bc
700a6522: f2c7 010b    	movt	r1, #0x700b
700a6526: 6809         	ldr	r1, [r1]
700a6528: 3104         	adds	r1, #0x4
700a652a: f005 f839    	bl	0x700ab5a0 <vListInsert> @ imm = #0x5072
;       } else {
700a652e: e01e         	b	0x700a656e <prvAddCurrentTaskToDelayedList+0xce> @ imm = #0x3c
;         vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
700a6530: f245 2020    	movw	r0, #0x5220
700a6534: f2c7 0008    	movt	r0, #0x7008
700a6538: 6800         	ldr	r0, [r0]
700a653a: f242 61bc    	movw	r1, #0x26bc
700a653e: f2c7 010b    	movt	r1, #0x700b
700a6542: 6809         	ldr	r1, [r1]
700a6544: 3104         	adds	r1, #0x4
700a6546: f005 f82b    	bl	0x700ab5a0 <vListInsert> @ imm = #0x5056
;         if (xTimeToWake < xNextTaskUnblockTime) {
700a654a: 9801         	ldr	r0, [sp, #0x4]
700a654c: f242 61f4    	movw	r1, #0x26f4
700a6550: f2c7 010b    	movt	r1, #0x700b
700a6554: 6809         	ldr	r1, [r1]
700a6556: 4288         	cmp	r0, r1
700a6558: d207         	bhs	0x700a656a <prvAddCurrentTaskToDelayedList+0xca> @ imm = #0xe
700a655a: e7ff         	b	0x700a655c <prvAddCurrentTaskToDelayedList+0xbc> @ imm = #-0x2
;           xNextTaskUnblockTime = xTimeToWake;
700a655c: 9801         	ldr	r0, [sp, #0x4]
700a655e: f242 61f4    	movw	r1, #0x26f4
700a6562: f2c7 010b    	movt	r1, #0x700b
700a6566: 6008         	str	r0, [r1]
;         } else {
700a6568: e000         	b	0x700a656c <prvAddCurrentTaskToDelayedList+0xcc> @ imm = #0x0
700a656a: e7ff         	b	0x700a656c <prvAddCurrentTaskToDelayedList+0xcc> @ imm = #-0x2
700a656c: e7ff         	b	0x700a656e <prvAddCurrentTaskToDelayedList+0xce> @ imm = #-0x2
700a656e: e7ff         	b	0x700a6570 <prvAddCurrentTaskToDelayedList+0xd0> @ imm = #-0x2
; }
700a6570: b004         	add	sp, #0x10
700a6572: bd80         	pop	{r7, pc}
		...

700a6580 <UART_lld_write>:
; {
700a6580: b580         	push	{r7, lr}
700a6582: b086         	sub	sp, #0x18
700a6584: f8dd c020    	ldr.w	r12, [sp, #0x20]
700a6588: 9005         	str	r0, [sp, #0x14]
700a658a: 9104         	str	r1, [sp, #0x10]
700a658c: 9203         	str	r2, [sp, #0xc]
700a658e: 9302         	str	r3, [sp, #0x8]
700a6590: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a6592: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a6594: 9805         	ldr	r0, [sp, #0x14]
700a6596: 2800         	cmp	r0, #0x0
700a6598: d054         	beq	0x700a6644 <UART_lld_write+0xc4> @ imm = #0xa8
700a659a: e7ff         	b	0x700a659c <UART_lld_write+0x1c> @ imm = #-0x2
;          trans = &hUart->writeTrans;
700a659c: 9805         	ldr	r0, [sp, #0x14]
700a659e: 303c         	adds	r0, #0x3c
700a65a0: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a65a2: 9800         	ldr	r0, [sp]
700a65a4: 6800         	ldr	r0, [r0]
700a65a6: b138         	cbz	r0, 0x700a65b8 <UART_lld_write+0x38> @ imm = #0xe
700a65a8: e7ff         	b	0x700a65aa <UART_lld_write+0x2a> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a65aa: 9900         	ldr	r1, [sp]
700a65ac: 2009         	movs	r0, #0x9
700a65ae: 60c8         	str	r0, [r1, #0xc]
700a65b0: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a65b4: 9001         	str	r0, [sp, #0x4]
;         }
700a65b6: e044         	b	0x700a6642 <UART_lld_write+0xc2> @ imm = #0x88
;             UART_lld_Transaction_init(trans);
700a65b8: 9800         	ldr	r0, [sp]
700a65ba: f008 fab1    	bl	0x700aeb20 <UART_lld_Transaction_init> @ imm = #0x8562
;             if(extendedParams != NULL)
700a65be: 9808         	ldr	r0, [sp, #0x20]
700a65c0: b128         	cbz	r0, 0x700a65ce <UART_lld_write+0x4e> @ imm = #0xa
700a65c2: e7ff         	b	0x700a65c4 <UART_lld_write+0x44> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a65c4: 9808         	ldr	r0, [sp, #0x20]
700a65c6: 6800         	ldr	r0, [r0]
700a65c8: 9900         	ldr	r1, [sp]
700a65ca: 6108         	str	r0, [r1, #0x10]
;             }
700a65cc: e003         	b	0x700a65d6 <UART_lld_write+0x56> @ imm = #0x6
;                 trans->args = NULL;
700a65ce: 9900         	ldr	r1, [sp]
700a65d0: 2000         	movs	r0, #0x0
700a65d2: 6108         	str	r0, [r1, #0x10]
700a65d4: e7ff         	b	0x700a65d6 <UART_lld_write+0x56> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a65d6: 9804         	ldr	r0, [sp, #0x10]
700a65d8: 9900         	ldr	r1, [sp]
700a65da: 6008         	str	r0, [r1]
;             trans->count = size;
700a65dc: 9803         	ldr	r0, [sp, #0xc]
700a65de: 9900         	ldr	r1, [sp]
700a65e0: 6048         	str	r0, [r1, #0x4]
;             trans->timeout = timeout;
700a65e2: 9802         	ldr	r0, [sp, #0x8]
700a65e4: 9900         	ldr	r1, [sp]
700a65e6: 6088         	str	r0, [r1, #0x8]
;             if(hUart->state == UART_STATE_READY)
700a65e8: 9805         	ldr	r0, [sp, #0x14]
700a65ea: 6d40         	ldr	r0, [r0, #0x54]
700a65ec: 2801         	cmp	r0, #0x1
700a65ee: d105         	bne	0x700a65fc <UART_lld_write+0x7c> @ imm = #0xa
700a65f0: e7ff         	b	0x700a65f2 <UART_lld_write+0x72> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a65f2: 9800         	ldr	r0, [sp]
700a65f4: f007 fe94    	bl	0x700ae320 <UART_checkTransaction> @ imm = #0x7d28
700a65f8: 9001         	str	r0, [sp, #0x4]
;             }
700a65fa: e003         	b	0x700a6604 <UART_lld_write+0x84> @ imm = #0x6
700a65fc: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a6600: 9001         	str	r0, [sp, #0x4]
700a6602: e7ff         	b	0x700a6604 <UART_lld_write+0x84> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a6604: 9801         	ldr	r0, [sp, #0x4]
700a6606: b980         	cbnz	r0, 0x700a662a <UART_lld_write+0xaa> @ imm = #0x20
700a6608: e7ff         	b	0x700a660a <UART_lld_write+0x8a> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a660a: 9800         	ldr	r0, [sp]
700a660c: 6800         	ldr	r0, [r0]
700a660e: 9905         	ldr	r1, [sp, #0x14]
700a6610: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a6612: 9800         	ldr	r0, [sp]
700a6614: 6880         	ldr	r0, [r0, #0x8]
700a6616: 9905         	ldr	r1, [sp, #0x14]
700a6618: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a661a: 9905         	ldr	r1, [sp, #0x14]
700a661c: 2000         	movs	r0, #0x0
700a661e: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a6620: 9800         	ldr	r0, [sp]
700a6622: 6840         	ldr	r0, [r0, #0x4]
700a6624: 9905         	ldr	r1, [sp, #0x14]
700a6626: 6108         	str	r0, [r1, #0x10]
;             }
700a6628: e7ff         	b	0x700a662a <UART_lld_write+0xaa> @ imm = #-0x2
;             hUart->state = UART_STATE_BUSY;
700a662a: 9905         	ldr	r1, [sp, #0x14]
700a662c: 2002         	movs	r0, #0x2
700a662e: 6548         	str	r0, [r1, #0x54]
;             status = UART_writePolling(hUart, trans);
700a6630: 9805         	ldr	r0, [sp, #0x14]
700a6632: 9900         	ldr	r1, [sp]
700a6634: f7fc fb8c    	bl	0x700a2d50 <UART_writePolling> @ imm = #-0x38e8
700a6638: 9001         	str	r0, [sp, #0x4]
;             hUart->state = UART_STATE_READY;
700a663a: 9905         	ldr	r1, [sp, #0x14]
700a663c: 2001         	movs	r0, #0x1
700a663e: 6548         	str	r0, [r1, #0x54]
700a6640: e7ff         	b	0x700a6642 <UART_lld_write+0xc2> @ imm = #-0x2
;     }
700a6642: e003         	b	0x700a664c <UART_lld_write+0xcc> @ imm = #0x6
700a6644: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a6648: 9001         	str	r0, [sp, #0x4]
700a664a: e7ff         	b	0x700a664c <UART_lld_write+0xcc> @ imm = #-0x2
;     return status;
700a664c: 9801         	ldr	r0, [sp, #0x4]
700a664e: b006         	add	sp, #0x18
700a6650: bd80         	pop	{r7, pc}
		...
700a665e: 0000         	movs	r0, r0

700a6660 <UART_udmaDeInitCh>:
; {
700a6660: b580         	push	{r7, lr}
700a6662: b08c         	sub	sp, #0x30
700a6664: 900b         	str	r0, [sp, #0x2c]
700a6666: 910a         	str	r1, [sp, #0x28]
700a6668: 2000         	movs	r0, #0x0
;     int32_t status = UDMA_SOK;
700a666a: 9009         	str	r0, [sp, #0x24]
700a666c: 2001         	movs	r0, #0x1
;     uint32_t temp = TRUE;
700a666e: 9008         	str	r0, [sp, #0x20]
;     status = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
700a6670: 980b         	ldr	r0, [sp, #0x2c]
700a6672: 2164         	movs	r1, #0x64
700a6674: f001 fc44    	bl	0x700a7f00 <Udma_chDisable> @ imm = #0x1888
700a6678: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a667a: 9809         	ldr	r0, [sp, #0x24]
700a667c: fab0 f080    	clz	r0, r0
700a6680: 0940         	lsrs	r0, r0, #0x5
700a6682: f641 419f    	movw	r1, #0x1c9f
700a6686: f2c7 010b    	movt	r1, #0x700b
700a668a: 9102         	str	r1, [sp, #0x8]
700a668c: 466a         	mov	r2, sp
700a668e: 6011         	str	r1, [r2]
700a6690: f641 016d    	movw	r1, #0x186d
700a6694: f2c7 010b    	movt	r1, #0x700b
700a6698: 9103         	str	r1, [sp, #0xc]
700a669a: f641 42e9    	movw	r2, #0x1ce9
700a669e: f2c7 020b    	movt	r2, #0x700b
700a66a2: 9204         	str	r2, [sp, #0x10]
700a66a4: f240 134b    	movw	r3, #0x14b
700a66a8: f004 f9c2    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x4384
;     status = Udma_eventUnRegister(eventHandle);
700a66ac: 980a         	ldr	r0, [sp, #0x28]
700a66ae: f000 fc5f    	bl	0x700a6f70 <Udma_eventUnRegister> @ imm = #0x8be
700a66b2: 9b02         	ldr	r3, [sp, #0x8]
700a66b4: 9903         	ldr	r1, [sp, #0xc]
700a66b6: 9a04         	ldr	r2, [sp, #0x10]
700a66b8: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a66ba: 9809         	ldr	r0, [sp, #0x24]
700a66bc: fab0 f080    	clz	r0, r0
700a66c0: 0940         	lsrs	r0, r0, #0x5
700a66c2: 46ec         	mov	r12, sp
700a66c4: f8cc 3000    	str.w	r3, [r12]
700a66c8: f240 134f    	movw	r3, #0x14f
700a66cc: f004 f9b0    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x4360
;     while(temp == TRUE)
700a66d0: e7ff         	b	0x700a66d2 <UART_udmaDeInitCh+0x72> @ imm = #-0x2
700a66d2: 9808         	ldr	r0, [sp, #0x20]
700a66d4: 2801         	cmp	r0, #0x1
700a66d6: d10f         	bne	0x700a66f8 <UART_udmaDeInitCh+0x98> @ imm = #0x1e
700a66d8: e7ff         	b	0x700a66da <UART_udmaDeInitCh+0x7a> @ imm = #-0x2
;                          Udma_chGetFqRingHandle(chHandle), &pDesc);
700a66da: 980b         	ldr	r0, [sp, #0x2c]
700a66dc: f004 fba8    	bl	0x700aae30 <Udma_chGetFqRingHandle> @ imm = #0x4750
700a66e0: a906         	add	r1, sp, #0x18
;         tempRetVal = Udma_ringFlushRaw(
700a66e2: f003 fc35    	bl	0x700a9f50 <Udma_ringFlushRaw> @ imm = #0x386a
700a66e6: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_ETIMEOUT == tempRetVal)
700a66e8: 9805         	ldr	r0, [sp, #0x14]
700a66ea: 3004         	adds	r0, #0x4
700a66ec: b918         	cbnz	r0, 0x700a66f6 <UART_udmaDeInitCh+0x96> @ imm = #0x6
700a66ee: e7ff         	b	0x700a66f0 <UART_udmaDeInitCh+0x90> @ imm = #-0x2
700a66f0: 2000         	movs	r0, #0x0
;             temp = FALSE;
700a66f2: 9008         	str	r0, [sp, #0x20]
;         }
700a66f4: e7ff         	b	0x700a66f6 <UART_udmaDeInitCh+0x96> @ imm = #-0x2
;     while(temp == TRUE)
700a66f6: e7ec         	b	0x700a66d2 <UART_udmaDeInitCh+0x72> @ imm = #-0x28
;     status = Udma_chClose(chHandle);
700a66f8: 980b         	ldr	r0, [sp, #0x2c]
700a66fa: f000 fd71    	bl	0x700a71e0 <Udma_chClose> @ imm = #0xae2
700a66fe: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a6700: 9809         	ldr	r0, [sp, #0x24]
700a6702: fab0 f080    	clz	r0, r0
700a6706: 0940         	lsrs	r0, r0, #0x5
700a6708: f641 419f    	movw	r1, #0x1c9f
700a670c: f2c7 010b    	movt	r1, #0x700b
700a6710: 466a         	mov	r2, sp
700a6712: 6011         	str	r1, [r2]
700a6714: f641 016d    	movw	r1, #0x186d
700a6718: f2c7 010b    	movt	r1, #0x700b
700a671c: f641 42e9    	movw	r2, #0x1ce9
700a6720: f2c7 020b    	movt	r2, #0x700b
700a6724: f240 1361    	movw	r3, #0x161
700a6728: f004 f982    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x4304
;     return status;
700a672c: 9809         	ldr	r0, [sp, #0x24]
700a672e: b00c         	add	sp, #0x30
700a6730: bd80         	pop	{r7, pc}
		...
700a673e: 0000         	movs	r0, r0

700a6740 <vTaskSwitchContext>:
; void vTaskSwitchContext(void) {
700a6740: b082         	sub	sp, #0x8
;   if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
700a6742: f242 60e4    	movw	r0, #0x26e4
700a6746: f2c7 000b    	movt	r0, #0x700b
700a674a: 6800         	ldr	r0, [r0]
700a674c: b138         	cbz	r0, 0x700a675e <vTaskSwitchContext+0x1e> @ imm = #0xe
700a674e: e7ff         	b	0x700a6750 <vTaskSwitchContext+0x10> @ imm = #-0x2
;     xYieldPending = pdTRUE;
700a6750: f242 7110    	movw	r1, #0x2710
700a6754: f2c7 010b    	movt	r1, #0x700b
700a6758: 2001         	movs	r0, #0x1
700a675a: 6008         	str	r0, [r1]
;   } else {
700a675c: e057         	b	0x700a680e <vTaskSwitchContext+0xce> @ imm = #0xae
;     xYieldPending = pdFALSE;
700a675e: f242 7110    	movw	r1, #0x2710
700a6762: f2c7 010b    	movt	r1, #0x700b
700a6766: 2000         	movs	r0, #0x0
700a6768: 6008         	str	r0, [r1]
;       pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
700a676a: f242 606c    	movw	r0, #0x266c
700a676e: f2c7 000b    	movt	r0, #0x700b
700a6772: 6800         	ldr	r0, [r0]
700a6774: f242 61bc    	movw	r1, #0x26bc
700a6778: f2c7 010b    	movt	r1, #0x700b
700a677c: 6809         	ldr	r1, [r1]
700a677e: f8c1 0084    	str.w	r0, [r1, #0x84]
;     taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this
700a6782: f242 60ec    	movw	r0, #0x26ec
700a6786: f2c7 000b    	movt	r0, #0x700b
700a678a: 6800         	ldr	r0, [r0]
700a678c: 9001         	str	r0, [sp, #0x4]
700a678e: e7ff         	b	0x700a6790 <vTaskSwitchContext+0x50> @ imm = #-0x2
700a6790: 9801         	ldr	r0, [sp, #0x4]
700a6792: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a6796: f244 40f8    	movw	r0, #0x44f8
700a679a: f2c7 0008    	movt	r0, #0x7008
700a679e: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a67a2: b920         	cbnz	r0, 0x700a67ae <vTaskSwitchContext+0x6e> @ imm = #0x8
700a67a4: e7ff         	b	0x700a67a6 <vTaskSwitchContext+0x66> @ imm = #-0x2
700a67a6: 9801         	ldr	r0, [sp, #0x4]
700a67a8: 3801         	subs	r0, #0x1
700a67aa: 9001         	str	r0, [sp, #0x4]
700a67ac: e7f0         	b	0x700a6790 <vTaskSwitchContext+0x50> @ imm = #-0x20
700a67ae: 9801         	ldr	r0, [sp, #0x4]
700a67b0: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a67b4: f244 40f8    	movw	r0, #0x44f8
700a67b8: f2c7 0008    	movt	r0, #0x7008
700a67bc: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a67c0: 9000         	str	r0, [sp]
700a67c2: 9900         	ldr	r1, [sp]
700a67c4: 6848         	ldr	r0, [r1, #0x4]
700a67c6: 6840         	ldr	r0, [r0, #0x4]
700a67c8: 6048         	str	r0, [r1, #0x4]
700a67ca: 9900         	ldr	r1, [sp]
700a67cc: 6848         	ldr	r0, [r1, #0x4]
700a67ce: 3108         	adds	r1, #0x8
700a67d0: 4288         	cmp	r0, r1
700a67d2: d105         	bne	0x700a67e0 <vTaskSwitchContext+0xa0> @ imm = #0xa
700a67d4: e7ff         	b	0x700a67d6 <vTaskSwitchContext+0x96> @ imm = #-0x2
700a67d6: 9900         	ldr	r1, [sp]
700a67d8: 6848         	ldr	r0, [r1, #0x4]
700a67da: 6840         	ldr	r0, [r0, #0x4]
700a67dc: 6048         	str	r0, [r1, #0x4]
700a67de: e7ff         	b	0x700a67e0 <vTaskSwitchContext+0xa0> @ imm = #-0x2
700a67e0: 9800         	ldr	r0, [sp]
700a67e2: 6840         	ldr	r0, [r0, #0x4]
700a67e4: 68c1         	ldr	r1, [r0, #0xc]
700a67e6: f242 60bc    	movw	r0, #0x26bc
700a67ea: f2c7 000b    	movt	r0, #0x700b
700a67ee: 6001         	str	r1, [r0]
700a67f0: 9901         	ldr	r1, [sp, #0x4]
700a67f2: f242 62ec    	movw	r2, #0x26ec
700a67f6: f2c7 020b    	movt	r2, #0x700b
700a67fa: 6011         	str	r1, [r2]
;       FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
700a67fc: 6800         	ldr	r0, [r0]
700a67fe: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a6802: f242 616c    	movw	r1, #0x266c
700a6806: f2c7 010b    	movt	r1, #0x700b
700a680a: 6008         	str	r0, [r1]
700a680c: e7ff         	b	0x700a680e <vTaskSwitchContext+0xce> @ imm = #-0x2
; }
700a680e: b002         	add	sp, #0x8
700a6810: 4770         	bx	lr
		...
700a681e: 0000         	movs	r0, r0

700a6820 <Udma_rmAllocVintrBit>:
; {
700a6820: b580         	push	{r7, lr}
700a6822: b08a         	sub	sp, #0x28
700a6824: 9009         	str	r0, [sp, #0x24]
700a6826: f64f 70ff    	movw	r0, #0xffff
;     uint32_t                vintrBitNum = UDMA_EVENT_INVALID;
700a682a: 9007         	str	r0, [sp, #0x1c]
;     Udma_DrvHandleInt       drvHandle = eventHandle->drvHandle;
700a682c: 9809         	ldr	r0, [sp, #0x24]
700a682e: 6800         	ldr	r0, [r0]
700a6830: 9001         	str	r0, [sp, #0x4]
;     controllerEventHandle = eventHandle;
700a6832: 9809         	ldr	r0, [sp, #0x24]
700a6834: 9003         	str	r0, [sp, #0xc]
;     eventPrms = &eventHandle->eventPrms;
700a6836: 9809         	ldr	r0, [sp, #0x24]
700a6838: 3008         	adds	r0, #0x8
700a683a: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != eventPrms->controllerEventHandle)
700a683c: 9802         	ldr	r0, [sp, #0x8]
700a683e: 6900         	ldr	r0, [r0, #0x10]
700a6840: b120         	cbz	r0, 0x700a684c <Udma_rmAllocVintrBit+0x2c> @ imm = #0x8
700a6842: e7ff         	b	0x700a6844 <Udma_rmAllocVintrBit+0x24> @ imm = #-0x2
;         controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a6844: 9802         	ldr	r0, [sp, #0x8]
700a6846: 6900         	ldr	r0, [r0, #0x10]
700a6848: 9003         	str	r0, [sp, #0xc]
;     }
700a684a: e7ff         	b	0x700a684c <Udma_rmAllocVintrBit+0x2c> @ imm = #-0x2
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a684c: 9801         	ldr	r0, [sp, #0x4]
700a684e: f500 609f    	add.w	r0, r0, #0x4f8
700a6852: f04f 31ff    	mov.w	r1, #0xffffffff
700a6856: f003 fe93    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x3d26
700a685a: 2000         	movs	r0, #0x0
;     for(i = 0U; i < UDMA_MAX_EVENTS_PER_VINTR; i++)
700a685c: 9008         	str	r0, [sp, #0x20]
700a685e: e7ff         	b	0x700a6860 <Udma_rmAllocVintrBit+0x40> @ imm = #-0x2
700a6860: 9808         	ldr	r0, [sp, #0x20]
700a6862: 283f         	cmp	r0, #0x3f
700a6864: d83a         	bhi	0x700a68dc <Udma_rmAllocVintrBit+0xbc> @ imm = #0x74
700a6866: e7ff         	b	0x700a6868 <Udma_rmAllocVintrBit+0x48> @ imm = #-0x2
;         bitMask = ((uint64_t) 1U << i);
700a6868: 9b08         	ldr	r3, [sp, #0x20]
700a686a: f1a3 0220    	sub.w	r2, r3, #0x20
700a686e: 2101         	movs	r1, #0x1
700a6870: fa01 fc02    	lsl.w	r12, r1, r2
700a6874: f1c3 0020    	rsb.w	r0, r3, #0x20
700a6878: fa21 f000    	lsr.w	r0, r1, r0
700a687c: 2a00         	cmp	r2, #0x0
700a687e: bf58         	it	pl
700a6880: 4660         	movpl	r0, r12
700a6882: fa01 f103    	lsl.w	r1, r1, r3
700a6886: 2a00         	cmp	r2, #0x0
700a6888: bf58         	it	pl
700a688a: 2100         	movpl	r1, #0x0
700a688c: 9104         	str	r1, [sp, #0x10]
700a688e: 9005         	str	r0, [sp, #0x14]
;         if((controllerEventHandle->vintrBitAllocFlag & bitMask) == 0U)
700a6890: 9903         	ldr	r1, [sp, #0xc]
700a6892: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a6896: f8d1 108c    	ldr.w	r1, [r1, #0x8c]
700a689a: 9a04         	ldr	r2, [sp, #0x10]
700a689c: 9b05         	ldr	r3, [sp, #0x14]
700a689e: ea01 0103    	and.w	r1, r1, r3
700a68a2: ea00 0002    	and.w	r0, r0, r2
700a68a6: ea40 0001    	orr.w	r0, r0, r1
700a68aa: b990         	cbnz	r0, 0x700a68d2 <Udma_rmAllocVintrBit+0xb2> @ imm = #0x24
700a68ac: e7ff         	b	0x700a68ae <Udma_rmAllocVintrBit+0x8e> @ imm = #-0x2
;             controllerEventHandle->vintrBitAllocFlag |= bitMask;
700a68ae: f8dd c010    	ldr.w	r12, [sp, #0x10]
700a68b2: 9b05         	ldr	r3, [sp, #0x14]
700a68b4: 9903         	ldr	r1, [sp, #0xc]
700a68b6: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a68ba: f8d1 208c    	ldr.w	r2, [r1, #0x8c]
700a68be: ea40 000c    	orr.w	r0, r0, r12
700a68c2: 431a         	orrs	r2, r3
700a68c4: f8c1 208c    	str.w	r2, [r1, #0x8c]
700a68c8: f8c1 0088    	str.w	r0, [r1, #0x88]
;             vintrBitNum = i;
700a68cc: 9808         	ldr	r0, [sp, #0x20]
700a68ce: 9007         	str	r0, [sp, #0x1c]
;             break;
700a68d0: e004         	b	0x700a68dc <Udma_rmAllocVintrBit+0xbc> @ imm = #0x8
;     }
700a68d2: e7ff         	b	0x700a68d4 <Udma_rmAllocVintrBit+0xb4> @ imm = #-0x2
;     for(i = 0U; i < UDMA_MAX_EVENTS_PER_VINTR; i++)
700a68d4: 9808         	ldr	r0, [sp, #0x20]
700a68d6: 3001         	adds	r0, #0x1
700a68d8: 9008         	str	r0, [sp, #0x20]
700a68da: e7c1         	b	0x700a6860 <Udma_rmAllocVintrBit+0x40> @ imm = #-0x7e
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a68dc: 9801         	ldr	r0, [sp, #0x4]
700a68de: f500 609f    	add.w	r0, r0, #0x4f8
700a68e2: f005 f9dd    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x53ba
;     return (vintrBitNum);
700a68e6: 9807         	ldr	r0, [sp, #0x1c]
700a68e8: b00a         	add	sp, #0x28
700a68ea: bd80         	pop	{r7, pc}
700a68ec: 0000         	movs	r0, r0
700a68ee: 0000         	movs	r0, r0

700a68f0 <prvCopyDataToQueue>:
; {
700a68f0: b580         	push	{r7, lr}
700a68f2: b086         	sub	sp, #0x18
700a68f4: 9005         	str	r0, [sp, #0x14]
700a68f6: 9104         	str	r1, [sp, #0x10]
700a68f8: 9203         	str	r2, [sp, #0xc]
700a68fa: 2000         	movs	r0, #0x0
;     BaseType_t xReturn = pdFALSE;
700a68fc: 9002         	str	r0, [sp, #0x8]
;     uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a68fe: 9805         	ldr	r0, [sp, #0x14]
700a6900: 6b80         	ldr	r0, [r0, #0x38]
700a6902: 9001         	str	r0, [sp, #0x4]
;     if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
700a6904: 9805         	ldr	r0, [sp, #0x14]
700a6906: 6c00         	ldr	r0, [r0, #0x40]
700a6908: b978         	cbnz	r0, 0x700a692a <prvCopyDataToQueue+0x3a> @ imm = #0x1e
700a690a: e7ff         	b	0x700a690c <prvCopyDataToQueue+0x1c> @ imm = #-0x2
;                 if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a690c: 9805         	ldr	r0, [sp, #0x14]
700a690e: 6800         	ldr	r0, [r0]
700a6910: b948         	cbnz	r0, 0x700a6926 <prvCopyDataToQueue+0x36> @ imm = #0x12
700a6912: e7ff         	b	0x700a6914 <prvCopyDataToQueue+0x24> @ imm = #-0x2
;                     xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
700a6914: 9805         	ldr	r0, [sp, #0x14]
700a6916: 6880         	ldr	r0, [r0, #0x8]
700a6918: f001 fd5a    	bl	0x700a83d0 <xTaskPriorityDisinherit> @ imm = #0x1ab4
700a691c: 9002         	str	r0, [sp, #0x8]
;                     pxQueue->u.xSemaphore.xMutexHolder = NULL;
700a691e: 9905         	ldr	r1, [sp, #0x14]
700a6920: 2000         	movs	r0, #0x0
700a6922: 6088         	str	r0, [r1, #0x8]
;                 }
700a6924: e000         	b	0x700a6928 <prvCopyDataToQueue+0x38> @ imm = #0x0
700a6926: e7ff         	b	0x700a6928 <prvCopyDataToQueue+0x38> @ imm = #-0x2
;     }
700a6928: e041         	b	0x700a69ae <prvCopyDataToQueue+0xbe> @ imm = #0x82
;     else if( xPosition == queueSEND_TO_BACK )
700a692a: 9803         	ldr	r0, [sp, #0xc]
700a692c: b9b8         	cbnz	r0, 0x700a695e <prvCopyDataToQueue+0x6e> @ imm = #0x2e
700a692e: e7ff         	b	0x700a6930 <prvCopyDataToQueue+0x40> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
700a6930: 9a05         	ldr	r2, [sp, #0x14]
700a6932: 9904         	ldr	r1, [sp, #0x10]
700a6934: 6850         	ldr	r0, [r2, #0x4]
700a6936: 6c12         	ldr	r2, [r2, #0x40]
700a6938: f7f3 eb90    	blx	0x7009a05c <__aeabi_memcpy8> @ imm = #-0xc8e0
;         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
700a693c: 9905         	ldr	r1, [sp, #0x14]
700a693e: 6848         	ldr	r0, [r1, #0x4]
700a6940: 6c0a         	ldr	r2, [r1, #0x40]
700a6942: 4410         	add	r0, r2
700a6944: 6048         	str	r0, [r1, #0x4]
;         if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
700a6946: 9905         	ldr	r1, [sp, #0x14]
700a6948: 6848         	ldr	r0, [r1, #0x4]
700a694a: 6889         	ldr	r1, [r1, #0x8]
700a694c: 4288         	cmp	r0, r1
700a694e: d304         	blo	0x700a695a <prvCopyDataToQueue+0x6a> @ imm = #0x8
700a6950: e7ff         	b	0x700a6952 <prvCopyDataToQueue+0x62> @ imm = #-0x2
;             pxQueue->pcWriteTo = pxQueue->pcHead;
700a6952: 9905         	ldr	r1, [sp, #0x14]
700a6954: 6808         	ldr	r0, [r1]
700a6956: 6048         	str	r0, [r1, #0x4]
;         }
700a6958: e000         	b	0x700a695c <prvCopyDataToQueue+0x6c> @ imm = #0x0
700a695a: e7ff         	b	0x700a695c <prvCopyDataToQueue+0x6c> @ imm = #-0x2
;     }
700a695c: e026         	b	0x700a69ac <prvCopyDataToQueue+0xbc> @ imm = #0x4c
;         ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
700a695e: 9a05         	ldr	r2, [sp, #0x14]
700a6960: 9904         	ldr	r1, [sp, #0x10]
700a6962: 68d0         	ldr	r0, [r2, #0xc]
700a6964: 6c12         	ldr	r2, [r2, #0x40]
700a6966: f7f3 eb7a    	blx	0x7009a05c <__aeabi_memcpy8> @ imm = #-0xc90c
;         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
700a696a: 9905         	ldr	r1, [sp, #0x14]
700a696c: 68c8         	ldr	r0, [r1, #0xc]
700a696e: 6c0a         	ldr	r2, [r1, #0x40]
700a6970: 1a80         	subs	r0, r0, r2
700a6972: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
700a6974: 9805         	ldr	r0, [sp, #0x14]
700a6976: 6801         	ldr	r1, [r0]
700a6978: 68c0         	ldr	r0, [r0, #0xc]
700a697a: 4288         	cmp	r0, r1
700a697c: d206         	bhs	0x700a698c <prvCopyDataToQueue+0x9c> @ imm = #0xc
700a697e: e7ff         	b	0x700a6980 <prvCopyDataToQueue+0x90> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
700a6980: 9905         	ldr	r1, [sp, #0x14]
700a6982: 6888         	ldr	r0, [r1, #0x8]
700a6984: 6c0a         	ldr	r2, [r1, #0x40]
700a6986: 1a80         	subs	r0, r0, r2
700a6988: 60c8         	str	r0, [r1, #0xc]
;         }
700a698a: e000         	b	0x700a698e <prvCopyDataToQueue+0x9e> @ imm = #0x0
700a698c: e7ff         	b	0x700a698e <prvCopyDataToQueue+0x9e> @ imm = #-0x2
;         if( xPosition == queueOVERWRITE )
700a698e: 9803         	ldr	r0, [sp, #0xc]
700a6990: 2802         	cmp	r0, #0x2
700a6992: d109         	bne	0x700a69a8 <prvCopyDataToQueue+0xb8> @ imm = #0x12
700a6994: e7ff         	b	0x700a6996 <prvCopyDataToQueue+0xa6> @ imm = #-0x2
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a6996: 9801         	ldr	r0, [sp, #0x4]
700a6998: b120         	cbz	r0, 0x700a69a4 <prvCopyDataToQueue+0xb4> @ imm = #0x8
700a699a: e7ff         	b	0x700a699c <prvCopyDataToQueue+0xac> @ imm = #-0x2
;                 --uxMessagesWaiting;
700a699c: 9801         	ldr	r0, [sp, #0x4]
700a699e: 3801         	subs	r0, #0x1
700a69a0: 9001         	str	r0, [sp, #0x4]
;             }
700a69a2: e000         	b	0x700a69a6 <prvCopyDataToQueue+0xb6> @ imm = #0x0
700a69a4: e7ff         	b	0x700a69a6 <prvCopyDataToQueue+0xb6> @ imm = #-0x2
;         }
700a69a6: e000         	b	0x700a69aa <prvCopyDataToQueue+0xba> @ imm = #0x0
700a69a8: e7ff         	b	0x700a69aa <prvCopyDataToQueue+0xba> @ imm = #-0x2
700a69aa: e7ff         	b	0x700a69ac <prvCopyDataToQueue+0xbc> @ imm = #-0x2
700a69ac: e7ff         	b	0x700a69ae <prvCopyDataToQueue+0xbe> @ imm = #-0x2
;     pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
700a69ae: 9801         	ldr	r0, [sp, #0x4]
700a69b0: 3001         	adds	r0, #0x1
700a69b2: 9905         	ldr	r1, [sp, #0x14]
700a69b4: 6388         	str	r0, [r1, #0x38]
;     return xReturn;
700a69b6: 9802         	ldr	r0, [sp, #0x8]
700a69b8: b006         	add	sp, #0x18
700a69ba: bd80         	pop	{r7, pc}
700a69bc: 0000         	movs	r0, r0
700a69be: 0000         	movs	r0, r0

700a69c0 <CSL_bcdmaChanOpSetBurstSize>:
; {
700a69c0: b580         	push	{r7, lr}
700a69c2: b088         	sub	sp, #0x20
700a69c4: 9007         	str	r0, [sp, #0x1c]
700a69c6: 9106         	str	r1, [sp, #0x18]
700a69c8: 9205         	str	r2, [sp, #0x14]
700a69ca: 9304         	str	r3, [sp, #0x10]
700a69cc: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a69ce: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a69d0: 9804         	ldr	r0, [sp, #0x10]
700a69d2: b920         	cbnz	r0, 0x700a69de <CSL_bcdmaChanOpSetBurstSize+0x1e> @ imm = #0x8
700a69d4: e7ff         	b	0x700a69d6 <CSL_bcdmaChanOpSetBurstSize+0x16> @ imm = #-0x2
700a69d6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a69da: 9003         	str	r0, [sp, #0xc]
;     }
700a69dc: e052         	b	0x700a6a84 <CSL_bcdmaChanOpSetBurstSize+0xc4> @ imm = #0xa4
;         CSL_BcdmaChanBurstSize burstSize = *(CSL_BcdmaChanBurstSize *)pOpData;
700a69de: 9804         	ldr	r0, [sp, #0x10]
700a69e0: 6800         	ldr	r0, [r0]
700a69e2: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a69e4: 9806         	ldr	r0, [sp, #0x18]
700a69e6: 9001         	str	r0, [sp, #0x4]
700a69e8: b140         	cbz	r0, 0x700a69fc <CSL_bcdmaChanOpSetBurstSize+0x3c> @ imm = #0x10
700a69ea: e7ff         	b	0x700a69ec <CSL_bcdmaChanOpSetBurstSize+0x2c> @ imm = #-0x2
700a69ec: 9801         	ldr	r0, [sp, #0x4]
700a69ee: 2801         	cmp	r0, #0x1
700a69f0: d019         	beq	0x700a6a26 <CSL_bcdmaChanOpSetBurstSize+0x66> @ imm = #0x32
700a69f2: e7ff         	b	0x700a69f4 <CSL_bcdmaChanOpSetBurstSize+0x34> @ imm = #-0x2
700a69f4: 9801         	ldr	r0, [sp, #0x4]
700a69f6: 2802         	cmp	r0, #0x2
700a69f8: d02a         	beq	0x700a6a50 <CSL_bcdmaChanOpSetBurstSize+0x90> @ imm = #0x54
700a69fa: e03e         	b	0x700a6a7a <CSL_bcdmaChanOpSetBurstSize+0xba> @ imm = #0x7c
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES )   /* Block-copy supports 32, 64, and 128-byte bursts */
700a69fc: 9802         	ldr	r0, [sp, #0x8]
700a69fe: 2803         	cmp	r0, #0x3
700a6a00: d304         	blo	0x700a6a0c <CSL_bcdmaChanOpSetBurstSize+0x4c> @ imm = #0x8
700a6a02: e7ff         	b	0x700a6a04 <CSL_bcdmaChanOpSetBurstSize+0x44> @ imm = #-0x2
700a6a04: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a6a08: 9003         	str	r0, [sp, #0xc]
;                 }
700a6a0a: e00b         	b	0x700a6a24 <CSL_bcdmaChanOpSetBurstSize+0x64> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG, BCDMA_BCCFG_CHAN_CFG_BURST_SIZE, burstSize );
700a6a0c: 9807         	ldr	r0, [sp, #0x1c]
700a6a0e: 6840         	ldr	r0, [r0, #0x4]
700a6a10: 9905         	ldr	r1, [sp, #0x14]
700a6a12: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a6a16: 9b02         	ldr	r3, [sp, #0x8]
700a6a18: f44f 6140    	mov.w	r1, #0xc00
700a6a1c: 220a         	movs	r2, #0xa
700a6a1e: f007 faff    	bl	0x700ae020 <CSL_REG32_FINS_RAW> @ imm = #0x75fe
700a6a22: e7ff         	b	0x700a6a24 <CSL_bcdmaChanOpSetBurstSize+0x64> @ imm = #-0x2
;                 break;
700a6a24: e02d         	b	0x700a6a82 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x5a
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES )    /* Split-tx supports 32, and 64-byte bursts */
700a6a26: 9802         	ldr	r0, [sp, #0x8]
700a6a28: 2802         	cmp	r0, #0x2
700a6a2a: d304         	blo	0x700a6a36 <CSL_bcdmaChanOpSetBurstSize+0x76> @ imm = #0x8
700a6a2c: e7ff         	b	0x700a6a2e <CSL_bcdmaChanOpSetBurstSize+0x6e> @ imm = #-0x2
700a6a2e: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a6a32: 9003         	str	r0, [sp, #0xc]
;                 }
700a6a34: e00b         	b	0x700a6a4e <CSL_bcdmaChanOpSetBurstSize+0x8e> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG, BCDMA_TXCCFG_CHAN_TCFG_BURST_SIZE, burstSize );
700a6a36: 9807         	ldr	r0, [sp, #0x1c]
700a6a38: 68c0         	ldr	r0, [r0, #0xc]
700a6a3a: 9905         	ldr	r1, [sp, #0x14]
700a6a3c: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a6a40: 9b02         	ldr	r3, [sp, #0x8]
700a6a42: f44f 6140    	mov.w	r1, #0xc00
700a6a46: 220a         	movs	r2, #0xa
700a6a48: f007 faea    	bl	0x700ae020 <CSL_REG32_FINS_RAW> @ imm = #0x75d4
700a6a4c: e7ff         	b	0x700a6a4e <CSL_bcdmaChanOpSetBurstSize+0x8e> @ imm = #-0x2
;                 break;
700a6a4e: e018         	b	0x700a6a82 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x30
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES )    /* Split-rx supports 32, and 64-byte bursts */
700a6a50: 9802         	ldr	r0, [sp, #0x8]
700a6a52: 2802         	cmp	r0, #0x2
700a6a54: d304         	blo	0x700a6a60 <CSL_bcdmaChanOpSetBurstSize+0xa0> @ imm = #0x8
700a6a56: e7ff         	b	0x700a6a58 <CSL_bcdmaChanOpSetBurstSize+0x98> @ imm = #-0x2
700a6a58: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a6a5c: 9003         	str	r0, [sp, #0xc]
;                 }
700a6a5e: e00b         	b	0x700a6a78 <CSL_bcdmaChanOpSetBurstSize+0xb8> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG, BCDMA_RXCCFG_CHAN_RCFG_BURST_SIZE, burstSize );
700a6a60: 9807         	ldr	r0, [sp, #0x1c]
700a6a62: 6940         	ldr	r0, [r0, #0x14]
700a6a64: 9905         	ldr	r1, [sp, #0x14]
700a6a66: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a6a6a: 9b02         	ldr	r3, [sp, #0x8]
700a6a6c: f44f 6140    	mov.w	r1, #0xc00
700a6a70: 220a         	movs	r2, #0xa
700a6a72: f007 fad5    	bl	0x700ae020 <CSL_REG32_FINS_RAW> @ imm = #0x75aa
700a6a76: e7ff         	b	0x700a6a78 <CSL_bcdmaChanOpSetBurstSize+0xb8> @ imm = #-0x2
;                 break;
700a6a78: e003         	b	0x700a6a82 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x6
700a6a7a: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a6a7e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a6a80: e7ff         	b	0x700a6a82 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #-0x2
700a6a82: e7ff         	b	0x700a6a84 <CSL_bcdmaChanOpSetBurstSize+0xc4> @ imm = #-0x2
;     return retVal;
700a6a84: 9803         	ldr	r0, [sp, #0xc]
700a6a86: b008         	add	sp, #0x20
700a6a88: bd80         	pop	{r7, pc}
700a6a8a: 0000         	movs	r0, r0
700a6a8c: 0000         	movs	r0, r0
700a6a8e: 0000         	movs	r0, r0

700a6a90 <Udma_ringCheckParams>:
; {
700a6a90: b580         	push	{r7, lr}
700a6a92: b084         	sub	sp, #0x10
700a6a94: 9003         	str	r0, [sp, #0xc]
700a6a96: 9102         	str	r1, [sp, #0x8]
700a6a98: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a6a9a: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR == ringPrms->ringMem)
700a6a9c: 9802         	ldr	r0, [sp, #0x8]
700a6a9e: 6800         	ldr	r0, [r0]
700a6aa0: b920         	cbnz	r0, 0x700a6aac <Udma_ringCheckParams+0x1c> @ imm = #0x8
700a6aa2: e7ff         	b	0x700a6aa4 <Udma_ringCheckParams+0x14> @ imm = #-0x2
700a6aa4: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6aa8: 9001         	str	r0, [sp, #0x4]
;     }
700a6aaa: e009         	b	0x700a6ac0 <Udma_ringCheckParams+0x30> @ imm = #0x12
;         if(((uintptr_t)ringPrms->ringMem & (UDMA_CACHELINE_ALIGNMENT - 1U)) != 0U)
700a6aac: 9802         	ldr	r0, [sp, #0x8]
700a6aae: 7800         	ldrb	r0, [r0]
700a6ab0: 0640         	lsls	r0, r0, #0x19
700a6ab2: b120         	cbz	r0, 0x700a6abe <Udma_ringCheckParams+0x2e> @ imm = #0x8
700a6ab4: e7ff         	b	0x700a6ab6 <Udma_ringCheckParams+0x26> @ imm = #-0x2
700a6ab6: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a6aba: 9001         	str	r0, [sp, #0x4]
;         }
700a6abc: e7ff         	b	0x700a6abe <Udma_ringCheckParams+0x2e> @ imm = #-0x2
700a6abe: e7ff         	b	0x700a6ac0 <Udma_ringCheckParams+0x30> @ imm = #-0x2
;     if(0U == ringPrms->elemCnt)
700a6ac0: 9802         	ldr	r0, [sp, #0x8]
700a6ac2: 68c0         	ldr	r0, [r0, #0xc]
700a6ac4: b920         	cbnz	r0, 0x700a6ad0 <Udma_ringCheckParams+0x40> @ imm = #0x8
700a6ac6: e7ff         	b	0x700a6ac8 <Udma_ringCheckParams+0x38> @ imm = #-0x2
700a6ac8: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6acc: 9001         	str	r0, [sp, #0x4]
;     }
700a6ace: e7ff         	b	0x700a6ad0 <Udma_ringCheckParams+0x40> @ imm = #-0x2
;     if(UDMA_INST_TYPE_NORMAL != drvHandle->instType)
700a6ad0: 9803         	ldr	r0, [sp, #0xc]
700a6ad2: 6800         	ldr	r0, [r0]
700a6ad4: b148         	cbz	r0, 0x700a6aea <Udma_ringCheckParams+0x5a> @ imm = #0x12
700a6ad6: e7ff         	b	0x700a6ad8 <Udma_ringCheckParams+0x48> @ imm = #-0x2
;         if(TISCI_MSG_VALUE_RM_RING_MODE_RING != ringPrms->mode)
700a6ad8: 9802         	ldr	r0, [sp, #0x8]
700a6ada: 7a00         	ldrb	r0, [r0, #0x8]
700a6adc: b120         	cbz	r0, 0x700a6ae8 <Udma_ringCheckParams+0x58> @ imm = #0x8
700a6ade: e7ff         	b	0x700a6ae0 <Udma_ringCheckParams+0x50> @ imm = #-0x2
700a6ae0: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a6ae4: 9001         	str	r0, [sp, #0x4]
;         }
700a6ae6: e7ff         	b	0x700a6ae8 <Udma_ringCheckParams+0x58> @ imm = #-0x2
;     }
700a6ae8: e7ff         	b	0x700a6aea <Udma_ringCheckParams+0x5a> @ imm = #-0x2
;     if(UDMA_RING_SIZE_CHECK_SKIP != ringPrms->ringMemSize)
700a6aea: 9802         	ldr	r0, [sp, #0x8]
700a6aec: 6840         	ldr	r0, [r0, #0x4]
700a6aee: f64a 31cd    	movw	r1, #0xabcd
700a6af2: f6ca 31dc    	movt	r1, #0xabdc
700a6af6: 4288         	cmp	r0, r1
700a6af8: d012         	beq	0x700a6b20 <Udma_ringCheckParams+0x90> @ imm = #0x24
700a6afa: e7ff         	b	0x700a6afc <Udma_ringCheckParams+0x6c> @ imm = #-0x2
;                           ringPrms->mode,
700a6afc: 9a02         	ldr	r2, [sp, #0x8]
700a6afe: 7a10         	ldrb	r0, [r2, #0x8]
;                           ringPrms->elemCnt,
700a6b00: 68d1         	ldr	r1, [r2, #0xc]
;                           ringPrms->elemSize);
700a6b02: 7c12         	ldrb	r2, [r2, #0x10]
;         ringMemSize = UdmaUtils_getRingMemSize(
700a6b04: f006 febc    	bl	0x700ad880 <UdmaUtils_getRingMemSize> @ imm = #0x6d78
700a6b08: 9000         	str	r0, [sp]
;         if(ringPrms->ringMemSize < ringMemSize)
700a6b0a: 9802         	ldr	r0, [sp, #0x8]
700a6b0c: 6840         	ldr	r0, [r0, #0x4]
700a6b0e: 9900         	ldr	r1, [sp]
700a6b10: 4288         	cmp	r0, r1
700a6b12: d204         	bhs	0x700a6b1e <Udma_ringCheckParams+0x8e> @ imm = #0x8
700a6b14: e7ff         	b	0x700a6b16 <Udma_ringCheckParams+0x86> @ imm = #-0x2
700a6b16: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
700a6b1a: 9001         	str	r0, [sp, #0x4]
;         }
700a6b1c: e7ff         	b	0x700a6b1e <Udma_ringCheckParams+0x8e> @ imm = #-0x2
;     }
700a6b1e: e7ff         	b	0x700a6b20 <Udma_ringCheckParams+0x90> @ imm = #-0x2
;     if (UDMA_RING_ORDERID_MAX < ringPrms->orderId)
700a6b20: 9802         	ldr	r0, [sp, #0x8]
700a6b22: 7c40         	ldrb	r0, [r0, #0x11]
700a6b24: 2810         	cmp	r0, #0x10
700a6b26: d304         	blo	0x700a6b32 <Udma_ringCheckParams+0xa2> @ imm = #0x8
700a6b28: e7ff         	b	0x700a6b2a <Udma_ringCheckParams+0x9a> @ imm = #-0x2
700a6b2a: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6b2e: 9001         	str	r0, [sp, #0x4]
;     }
700a6b30: e7ff         	b	0x700a6b32 <Udma_ringCheckParams+0xa2> @ imm = #-0x2
;     if((UDMA_MAPPED_GROUP_INVALID != ringPrms->mappedRingGrp) &&
700a6b32: 9802         	ldr	r0, [sp, #0x8]
700a6b34: 6940         	ldr	r0, [r0, #0x14]
700a6b36: 2104         	movs	r1, #0x4
700a6b38: f6cf 71ff    	movt	r1, #0xffff
700a6b3c: 4288         	cmp	r0, r1
700a6b3e: d009         	beq	0x700a6b54 <Udma_ringCheckParams+0xc4> @ imm = #0x12
700a6b40: e7ff         	b	0x700a6b42 <Udma_ringCheckParams+0xb2> @ imm = #-0x2
;        (ringPrms->mappedRingGrp >= (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
700a6b42: 9802         	ldr	r0, [sp, #0x8]
700a6b44: 6940         	ldr	r0, [r0, #0x14]
;     if((UDMA_MAPPED_GROUP_INVALID != ringPrms->mappedRingGrp) &&
700a6b46: 2808         	cmp	r0, #0x8
700a6b48: d304         	blo	0x700a6b54 <Udma_ringCheckParams+0xc4> @ imm = #0x8
700a6b4a: e7ff         	b	0x700a6b4c <Udma_ringCheckParams+0xbc> @ imm = #-0x2
700a6b4c: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6b50: 9001         	str	r0, [sp, #0x4]
;     }
700a6b52: e7ff         	b	0x700a6b54 <Udma_ringCheckParams+0xc4> @ imm = #-0x2
;     return (retVal);
700a6b54: 9801         	ldr	r0, [sp, #0x4]
700a6b56: b004         	add	sp, #0x10
700a6b58: bd80         	pop	{r7, pc}
700a6b5a: 0000         	movs	r0, r0
700a6b5c: 0000         	movs	r0, r0
700a6b5e: 0000         	movs	r0, r0

700a6b60 <UART_lld_writeDma>:
; {
700a6b60: b580         	push	{r7, lr}
700a6b62: b086         	sub	sp, #0x18
700a6b64: 9005         	str	r0, [sp, #0x14]
700a6b66: 9104         	str	r1, [sp, #0x10]
700a6b68: 9203         	str	r2, [sp, #0xc]
700a6b6a: 9302         	str	r3, [sp, #0x8]
700a6b6c: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a6b6e: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a6b70: 9805         	ldr	r0, [sp, #0x14]
700a6b72: 2800         	cmp	r0, #0x0
700a6b74: d051         	beq	0x700a6c1a <UART_lld_writeDma+0xba> @ imm = #0xa2
700a6b76: e7ff         	b	0x700a6b78 <UART_lld_writeDma+0x18> @ imm = #-0x2
;         trans = &hUart->writeTrans;
700a6b78: 9805         	ldr	r0, [sp, #0x14]
700a6b7a: 303c         	adds	r0, #0x3c
700a6b7c: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a6b7e: 9800         	ldr	r0, [sp]
700a6b80: 6800         	ldr	r0, [r0]
700a6b82: b138         	cbz	r0, 0x700a6b94 <UART_lld_writeDma+0x34> @ imm = #0xe
700a6b84: e7ff         	b	0x700a6b86 <UART_lld_writeDma+0x26> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a6b86: 9900         	ldr	r1, [sp]
700a6b88: 2009         	movs	r0, #0x9
700a6b8a: 60c8         	str	r0, [r1, #0xc]
700a6b8c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a6b90: 9001         	str	r0, [sp, #0x4]
;         }
700a6b92: e041         	b	0x700a6c18 <UART_lld_writeDma+0xb8> @ imm = #0x82
;             UART_lld_Transaction_init(trans);
700a6b94: 9800         	ldr	r0, [sp]
700a6b96: f007 ffc3    	bl	0x700aeb20 <UART_lld_Transaction_init> @ imm = #0x7f86
;             if(extendedParams != NULL)
700a6b9a: 9802         	ldr	r0, [sp, #0x8]
700a6b9c: b128         	cbz	r0, 0x700a6baa <UART_lld_writeDma+0x4a> @ imm = #0xa
700a6b9e: e7ff         	b	0x700a6ba0 <UART_lld_writeDma+0x40> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a6ba0: 9802         	ldr	r0, [sp, #0x8]
700a6ba2: 6800         	ldr	r0, [r0]
700a6ba4: 9900         	ldr	r1, [sp]
700a6ba6: 6108         	str	r0, [r1, #0x10]
;             }
700a6ba8: e003         	b	0x700a6bb2 <UART_lld_writeDma+0x52> @ imm = #0x6
;                 trans->args = NULL;
700a6baa: 9900         	ldr	r1, [sp]
700a6bac: 2000         	movs	r0, #0x0
700a6bae: 6108         	str	r0, [r1, #0x10]
700a6bb0: e7ff         	b	0x700a6bb2 <UART_lld_writeDma+0x52> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a6bb2: 9804         	ldr	r0, [sp, #0x10]
700a6bb4: 9900         	ldr	r1, [sp]
700a6bb6: 6008         	str	r0, [r1]
;             trans->count = size;
700a6bb8: 9803         	ldr	r0, [sp, #0xc]
700a6bba: 9900         	ldr	r1, [sp]
700a6bbc: 6048         	str	r0, [r1, #0x4]
;             if(hUart->state == UART_STATE_READY)
700a6bbe: 9805         	ldr	r0, [sp, #0x14]
700a6bc0: 6d40         	ldr	r0, [r0, #0x54]
700a6bc2: 2801         	cmp	r0, #0x1
700a6bc4: d105         	bne	0x700a6bd2 <UART_lld_writeDma+0x72> @ imm = #0xa
700a6bc6: e7ff         	b	0x700a6bc8 <UART_lld_writeDma+0x68> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a6bc8: 9800         	ldr	r0, [sp]
700a6bca: f007 fba9    	bl	0x700ae320 <UART_checkTransaction> @ imm = #0x7752
700a6bce: 9001         	str	r0, [sp, #0x4]
;             }
700a6bd0: e003         	b	0x700a6bda <UART_lld_writeDma+0x7a> @ imm = #0x6
700a6bd2: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a6bd6: 9001         	str	r0, [sp, #0x4]
700a6bd8: e7ff         	b	0x700a6bda <UART_lld_writeDma+0x7a> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a6bda: 9801         	ldr	r0, [sp, #0x4]
700a6bdc: b9d8         	cbnz	r0, 0x700a6c16 <UART_lld_writeDma+0xb6> @ imm = #0x36
700a6bde: e7ff         	b	0x700a6be0 <UART_lld_writeDma+0x80> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a6be0: 9800         	ldr	r0, [sp]
700a6be2: 6800         	ldr	r0, [r0]
700a6be4: 9905         	ldr	r1, [sp, #0x14]
700a6be6: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a6be8: 9800         	ldr	r0, [sp]
700a6bea: 6880         	ldr	r0, [r0, #0x8]
700a6bec: 9905         	ldr	r1, [sp, #0x14]
700a6bee: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a6bf0: 9905         	ldr	r1, [sp, #0x14]
700a6bf2: 2000         	movs	r0, #0x0
700a6bf4: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a6bf6: 9800         	ldr	r0, [sp]
700a6bf8: 6840         	ldr	r0, [r0, #0x4]
700a6bfa: 9905         	ldr	r1, [sp, #0x14]
700a6bfc: 6108         	str	r0, [r1, #0x10]
;                 hUart->state = UART_STATE_BUSY;
700a6bfe: 9905         	ldr	r1, [sp, #0x14]
700a6c00: 2002         	movs	r0, #0x2
700a6c02: 6548         	str	r0, [r1, #0x54]
;                 status = UART_lld_dmaWrite(hUart, trans);
700a6c04: 9805         	ldr	r0, [sp, #0x14]
700a6c06: 9900         	ldr	r1, [sp]
700a6c08: f007 ffa2    	bl	0x700aeb50 <UART_lld_dmaWrite> @ imm = #0x7f44
700a6c0c: 9001         	str	r0, [sp, #0x4]
;                 hUart->state = UART_STATE_READY;
700a6c0e: 9905         	ldr	r1, [sp, #0x14]
700a6c10: 2001         	movs	r0, #0x1
700a6c12: 6548         	str	r0, [r1, #0x54]
;             }
700a6c14: e7ff         	b	0x700a6c16 <UART_lld_writeDma+0xb6> @ imm = #-0x2
700a6c16: e7ff         	b	0x700a6c18 <UART_lld_writeDma+0xb8> @ imm = #-0x2
;     }
700a6c18: e003         	b	0x700a6c22 <UART_lld_writeDma+0xc2> @ imm = #0x6
700a6c1a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a6c1e: 9001         	str	r0, [sp, #0x4]
700a6c20: e7ff         	b	0x700a6c22 <UART_lld_writeDma+0xc2> @ imm = #-0x2
;     return status;
700a6c22: 9801         	ldr	r0, [sp, #0x4]
700a6c24: b006         	add	sp, #0x18
700a6c26: bd80         	pop	{r7, pc}
		...

700a6c30 <UART_udmaHpdInit>:
; {
700a6c30: b580         	push	{r7, lr}
700a6c32: b08a         	sub	sp, #0x28
700a6c34: 9009         	str	r0, [sp, #0x24]
700a6c36: 9108         	str	r1, [sp, #0x20]
700a6c38: 9207         	str	r2, [sp, #0x1c]
700a6c3a: 9306         	str	r3, [sp, #0x18]
;     CSL_UdmapCppi5HMPD *pHpd = (CSL_UdmapCppi5HMPD *) pHpdMem;
700a6c3c: 9808         	ldr	r0, [sp, #0x20]
700a6c3e: 9005         	str	r0, [sp, #0x14]
700a6c40: 2001         	movs	r0, #0x1
;     uint32_t descType = (uint32_t)CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST;
700a6c42: 9004         	str	r0, [sp, #0x10]
;     CSL_udmapCppi5SetDescType(pHpd, descType);
700a6c44: 9805         	ldr	r0, [sp, #0x14]
700a6c46: 9904         	ldr	r1, [sp, #0x10]
700a6c48: f008 fb72    	bl	0x700af330 <CSL_udmapCppi5SetDescType> @ imm = #0x86e4
;     CSL_udmapCppi5SetEpiDataPresent(pHpd, FALSE);
700a6c4c: 9805         	ldr	r0, [sp, #0x14]
700a6c4e: 2100         	movs	r1, #0x0
700a6c50: 9102         	str	r1, [sp, #0x8]
700a6c52: f008 fa5d    	bl	0x700af110 <CSL_udmapCppi5SetEpiDataPresent> @ imm = #0x84ba
700a6c56: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsDataLoc(pHpd, 0U);
700a6c58: 9805         	ldr	r0, [sp, #0x14]
700a6c5a: f008 fc71    	bl	0x700af540 <CSL_udmapCppi5SetPsDataLoc> @ imm = #0x88e2
700a6c5e: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsDataLen(pHpd, 0U);
700a6c60: 9805         	ldr	r0, [sp, #0x14]
700a6c62: f008 fb95    	bl	0x700af390 <CSL_udmapCppi5SetPsDataLen> @ imm = #0x872a
;     CSL_udmapCppi5SetPktLen(pHpd, descType, length);
700a6c66: 9805         	ldr	r0, [sp, #0x14]
700a6c68: 9904         	ldr	r1, [sp, #0x10]
700a6c6a: 9a06         	ldr	r2, [sp, #0x18]
700a6c6c: f006 fd90    	bl	0x700ad790 <CSL_udmapCppi5SetPktLen> @ imm = #0x6b20
700a6c70: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsFlags(pHpd, 0U);
700a6c72: 9805         	ldr	r0, [sp, #0x14]
700a6c74: f008 fc74    	bl	0x700af560 <CSL_udmapCppi5SetPsFlags> @ imm = #0x88e8
;     CSL_udmapCppi5SetIds(pHpd, descType, 0x321, UDMA_DEFAULT_FLOW_ID);
700a6c78: 9805         	ldr	r0, [sp, #0x14]
700a6c7a: 9904         	ldr	r1, [sp, #0x10]
700a6c7c: f240 3221    	movw	r2, #0x321
700a6c80: f643 73ff    	movw	r3, #0x3fff
700a6c84: f004 fe14    	bl	0x700ab8b0 <CSL_udmapCppi5SetIds> @ imm = #0x4c28
700a6c88: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetSrcTag(pHpd, 0x0000);     /* Not used */
700a6c8a: 9805         	ldr	r0, [sp, #0x14]
700a6c8c: f008 fd18    	bl	0x700af6c0 <CSL_udmapCppi5SetSrcTag> @ imm = #0x8a30
700a6c90: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetDstTag(pHpd, 0x0000);     /* Not used */
700a6c92: 9805         	ldr	r0, [sp, #0x14]
700a6c94: f008 fdbc    	bl	0x700af810 <CSL_udmapCppi5SetDstTag> @ imm = #0x8b78
;     UART_udmapSetReturnPolicy(chHandle, pHpdMem);
700a6c98: 9809         	ldr	r0, [sp, #0x24]
700a6c9a: 9908         	ldr	r1, [sp, #0x20]
700a6c9c: f008 f818    	bl	0x700aecd0 <UART_udmapSetReturnPolicy> @ imm = #0x8030
700a6ca0: 9b02         	ldr	r3, [sp, #0x8]
;     CSL_udmapCppi5LinkDesc(pHpd, 0U);
700a6ca2: 9805         	ldr	r0, [sp, #0x14]
700a6ca4: 461a         	mov	r2, r3
700a6ca6: f008 fc0b    	bl	0x700af4c0 <CSL_udmapCppi5LinkDesc> @ imm = #0x8816
700a6caa: 9a02         	ldr	r2, [sp, #0x8]
;     CSL_udmapCppi5SetBufferAddr(pHpd, (uint64_t) Udma_defaultVirtToPhyFxn(destBuf, 0U, NULL));
700a6cac: 9805         	ldr	r0, [sp, #0x14]
700a6cae: 9001         	str	r0, [sp, #0x4]
700a6cb0: 9807         	ldr	r0, [sp, #0x1c]
700a6cb2: 4611         	mov	r1, r2
700a6cb4: f008 fde4    	bl	0x700af880 <Udma_defaultVirtToPhyFxn> @ imm = #0x8bc8
700a6cb8: 4602         	mov	r2, r0
700a6cba: 9801         	ldr	r0, [sp, #0x4]
700a6cbc: 460b         	mov	r3, r1
700a6cbe: f008 fc0f    	bl	0x700af4e0 <CSL_udmapCppi5SetBufferAddr> @ imm = #0x881e
;     CSL_udmapCppi5SetBufferLen(pHpd, length);
700a6cc2: 9805         	ldr	r0, [sp, #0x14]
700a6cc4: 9906         	ldr	r1, [sp, #0x18]
700a6cc6: f008 fc1b    	bl	0x700af500 <CSL_udmapCppi5SetBufferLen> @ imm = #0x8836
700a6cca: 9a02         	ldr	r2, [sp, #0x8]
;     CSL_udmapCppi5SetOrgBufferAddr(pHpd, (uint64_t) Udma_defaultVirtToPhyFxn(destBuf, 0U, NULL));
700a6ccc: 9805         	ldr	r0, [sp, #0x14]
700a6cce: 9003         	str	r0, [sp, #0xc]
700a6cd0: 9807         	ldr	r0, [sp, #0x1c]
700a6cd2: 4611         	mov	r1, r2
700a6cd4: f008 fdd4    	bl	0x700af880 <Udma_defaultVirtToPhyFxn> @ imm = #0x8ba8
700a6cd8: 4602         	mov	r2, r0
700a6cda: 9803         	ldr	r0, [sp, #0xc]
700a6cdc: 460b         	mov	r3, r1
700a6cde: f008 fc1f    	bl	0x700af520 <CSL_udmapCppi5SetOrgBufferAddr> @ imm = #0x883e
;     CSL_udmapCppi5SetOrgBufferLen(pHpd, length);
700a6ce2: 9805         	ldr	r0, [sp, #0x14]
700a6ce4: 9906         	ldr	r1, [sp, #0x18]
700a6ce6: f008 fd9b    	bl	0x700af820 <CSL_udmapCppi5SetOrgBufferLen> @ imm = #0x8b36
;     CacheP_wb(pHpdMem, sizeof(CSL_UdmapCppi5HMPD), CacheP_TYPE_ALLD);
700a6cea: 9808         	ldr	r0, [sp, #0x20]
700a6cec: 2130         	movs	r1, #0x30
700a6cee: 220a         	movs	r2, #0xa
700a6cf0: f009 ed90    	blx	0x700b0814 <CacheP_wb>  @ imm = #0x9b20
;     return;
700a6cf4: b00a         	add	sp, #0x28
700a6cf6: bd80         	pop	{r7, pc}
		...

700a6d00 <Udma_eventCheckUnRegister>:
; {
700a6d00: b580         	push	{r7, lr}
700a6d02: b088         	sub	sp, #0x20
700a6d04: 9007         	str	r0, [sp, #0x1c]
700a6d06: 9106         	str	r1, [sp, #0x18]
700a6d08: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a6d0a: 9005         	str	r0, [sp, #0x14]
;     eventPrms = &eventHandle->eventPrms;
700a6d0c: 9806         	ldr	r0, [sp, #0x18]
700a6d0e: 3008         	adds	r0, #0x8
700a6d10: 9004         	str	r0, [sp, #0x10]
;     if(eventHandle->eventInitDone != UDMA_INIT_DONE)
700a6d12: 9806         	ldr	r0, [sp, #0x18]
700a6d14: f8d0 0098    	ldr.w	r0, [r0, #0x98]
700a6d18: f64a 31cd    	movw	r1, #0xabcd
700a6d1c: f6ca 31dc    	movt	r1, #0xabdc
700a6d20: 4288         	cmp	r0, r1
700a6d22: d004         	beq	0x700a6d2e <Udma_eventCheckUnRegister+0x2e> @ imm = #0x8
700a6d24: e7ff         	b	0x700a6d26 <Udma_eventCheckUnRegister+0x26> @ imm = #-0x2
700a6d26: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = UDMA_EFAIL;
700a6d2a: 9005         	str	r0, [sp, #0x14]
;     }
700a6d2c: e7ff         	b	0x700a6d2e <Udma_eventCheckUnRegister+0x2e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a6d2e: 9805         	ldr	r0, [sp, #0x14]
700a6d30: b968         	cbnz	r0, 0x700a6d4e <Udma_eventCheckUnRegister+0x4e> @ imm = #0x1a
700a6d32: e7ff         	b	0x700a6d34 <Udma_eventCheckUnRegister+0x34> @ imm = #-0x2
;         if((NULL_PTR == eventPrms->controllerEventHandle) &&
700a6d34: 9804         	ldr	r0, [sp, #0x10]
700a6d36: 6900         	ldr	r0, [r0, #0x10]
700a6d38: b940         	cbnz	r0, 0x700a6d4c <Udma_eventCheckUnRegister+0x4c> @ imm = #0x10
700a6d3a: e7ff         	b	0x700a6d3c <Udma_eventCheckUnRegister+0x3c> @ imm = #-0x2
;            (NULL_PTR != eventHandle->nextEvent))
700a6d3c: 9806         	ldr	r0, [sp, #0x18]
700a6d3e: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((NULL_PTR == eventPrms->controllerEventHandle) &&
700a6d40: b120         	cbz	r0, 0x700a6d4c <Udma_eventCheckUnRegister+0x4c> @ imm = #0x8
700a6d42: e7ff         	b	0x700a6d44 <Udma_eventCheckUnRegister+0x44> @ imm = #-0x2
700a6d44: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a6d48: 9005         	str	r0, [sp, #0x14]
;         }
700a6d4a: e7ff         	b	0x700a6d4c <Udma_eventCheckUnRegister+0x4c> @ imm = #-0x2
;     }
700a6d4c: e7ff         	b	0x700a6d4e <Udma_eventCheckUnRegister+0x4e> @ imm = #-0x2
;      if(UDMA_SOK == retVal)
700a6d4e: 9805         	ldr	r0, [sp, #0x14]
700a6d50: bbb8         	cbnz	r0, 0x700a6dc2 <Udma_eventCheckUnRegister+0xc2> @ imm = #0x6e
700a6d52: e7ff         	b	0x700a6d54 <Udma_eventCheckUnRegister+0x54> @ imm = #-0x2
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a6d54: 9804         	ldr	r0, [sp, #0x10]
700a6d56: 6800         	ldr	r0, [r0]
700a6d58: 2801         	cmp	r0, #0x1
700a6d5a: d00a         	beq	0x700a6d72 <Udma_eventCheckUnRegister+0x72> @ imm = #0x14
700a6d5c: e7ff         	b	0x700a6d5e <Udma_eventCheckUnRegister+0x5e> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType) ||
700a6d5e: 9804         	ldr	r0, [sp, #0x10]
700a6d60: 6800         	ldr	r0, [r0]
700a6d62: 2806         	cmp	r0, #0x6
700a6d64: d005         	beq	0x700a6d72 <Udma_eventCheckUnRegister+0x72> @ imm = #0xa
700a6d66: e7ff         	b	0x700a6d68 <Udma_eventCheckUnRegister+0x68> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_RING == eventPrms->eventType))
700a6d68: 9804         	ldr	r0, [sp, #0x10]
700a6d6a: 6800         	ldr	r0, [r0]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a6d6c: 2804         	cmp	r0, #0x4
700a6d6e: d127         	bne	0x700a6dc0 <Udma_eventCheckUnRegister+0xc0> @ imm = #0x4e
700a6d70: e7ff         	b	0x700a6d72 <Udma_eventCheckUnRegister+0x72> @ imm = #-0x2
;             if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
700a6d72: 9804         	ldr	r0, [sp, #0x10]
700a6d74: 6800         	ldr	r0, [r0]
700a6d76: 2801         	cmp	r0, #0x1
700a6d78: d005         	beq	0x700a6d86 <Udma_eventCheckUnRegister+0x86> @ imm = #0xa
700a6d7a: e7ff         	b	0x700a6d7c <Udma_eventCheckUnRegister+0x7c> @ imm = #-0x2
700a6d7c: 9804         	ldr	r0, [sp, #0x10]
700a6d7e: 6800         	ldr	r0, [r0]
700a6d80: 2806         	cmp	r0, #0x6
700a6d82: d106         	bne	0x700a6d92 <Udma_eventCheckUnRegister+0x92> @ imm = #0xc
700a6d84: e7ff         	b	0x700a6d86 <Udma_eventCheckUnRegister+0x86> @ imm = #-0x2
;                 ringHandle = ((Udma_ChHandleInt) (eventPrms->chHandle))->cqRing;
700a6d86: 9804         	ldr	r0, [sp, #0x10]
700a6d88: 6880         	ldr	r0, [r0, #0x8]
700a6d8a: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a6d8e: 9003         	str	r0, [sp, #0xc]
;             }
700a6d90: e003         	b	0x700a6d9a <Udma_eventCheckUnRegister+0x9a> @ imm = #0x6
;                 ringHandle = eventPrms->ringHandle;
700a6d92: 9804         	ldr	r0, [sp, #0x10]
700a6d94: 68c0         	ldr	r0, [r0, #0xc]
700a6d96: 9003         	str	r0, [sp, #0xc]
700a6d98: e7ff         	b	0x700a6d9a <Udma_eventCheckUnRegister+0x9a> @ imm = #-0x2
;             fOcc = Udma_ringGetForwardRingOcc(ringHandle);
700a6d9a: 9803         	ldr	r0, [sp, #0xc]
700a6d9c: f007 ffb0    	bl	0x700aed00 <Udma_ringGetForwardRingOcc> @ imm = #0x7f60
700a6da0: 9002         	str	r0, [sp, #0x8]
;             rOcc = Udma_ringGetReverseRingOcc(ringHandle);
700a6da2: 9803         	ldr	r0, [sp, #0xc]
700a6da4: f007 ffc4    	bl	0x700aed30 <Udma_ringGetReverseRingOcc> @ imm = #0x7f88
700a6da8: 9001         	str	r0, [sp, #0x4]
;             if((0U != fOcc) || (0U != rOcc))
700a6daa: 9802         	ldr	r0, [sp, #0x8]
700a6dac: b918         	cbnz	r0, 0x700a6db6 <Udma_eventCheckUnRegister+0xb6> @ imm = #0x6
700a6dae: e7ff         	b	0x700a6db0 <Udma_eventCheckUnRegister+0xb0> @ imm = #-0x2
700a6db0: 9801         	ldr	r0, [sp, #0x4]
700a6db2: b120         	cbz	r0, 0x700a6dbe <Udma_eventCheckUnRegister+0xbe> @ imm = #0x8
700a6db4: e7ff         	b	0x700a6db6 <Udma_eventCheckUnRegister+0xb6> @ imm = #-0x2
700a6db6: f04f 30ff    	mov.w	r0, #0xffffffff
;                 retVal = UDMA_EFAIL;
700a6dba: 9005         	str	r0, [sp, #0x14]
;             }
700a6dbc: e7ff         	b	0x700a6dbe <Udma_eventCheckUnRegister+0xbe> @ imm = #-0x2
;         }
700a6dbe: e7ff         	b	0x700a6dc0 <Udma_eventCheckUnRegister+0xc0> @ imm = #-0x2
;     }
700a6dc0: e7ff         	b	0x700a6dc2 <Udma_eventCheckUnRegister+0xc2> @ imm = #-0x2
;     return (retVal);
700a6dc2: 9805         	ldr	r0, [sp, #0x14]
700a6dc4: b008         	add	sp, #0x20
700a6dc6: bd80         	pop	{r7, pc}
		...

700a6dd0 <Udma_ringFree>:
; {
700a6dd0: b580         	push	{r7, lr}
700a6dd2: b086         	sub	sp, #0x18
700a6dd4: 9005         	str	r0, [sp, #0x14]
700a6dd6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a6dd8: 9004         	str	r0, [sp, #0x10]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a6dda: 9805         	ldr	r0, [sp, #0x14]
700a6ddc: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == ringHandleInt)
700a6dde: 9802         	ldr	r0, [sp, #0x8]
700a6de0: b920         	cbnz	r0, 0x700a6dec <Udma_ringFree+0x1c> @ imm = #0x8
700a6de2: e7ff         	b	0x700a6de4 <Udma_ringFree+0x14> @ imm = #-0x2
700a6de4: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a6de8: 9004         	str	r0, [sp, #0x10]
;     }
700a6dea: e7ff         	b	0x700a6dec <Udma_ringFree+0x1c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a6dec: 9804         	ldr	r0, [sp, #0x10]
700a6dee: b970         	cbnz	r0, 0x700a6e0e <Udma_ringFree+0x3e> @ imm = #0x1c
700a6df0: e7ff         	b	0x700a6df2 <Udma_ringFree+0x22> @ imm = #-0x2
;         if(ringHandleInt->ringInitDone != UDMA_INIT_DONE)
700a6df2: 9802         	ldr	r0, [sp, #0x8]
700a6df4: 6d80         	ldr	r0, [r0, #0x58]
700a6df6: f64a 31cd    	movw	r1, #0xabcd
700a6dfa: f6ca 31dc    	movt	r1, #0xabdc
700a6dfe: 4288         	cmp	r0, r1
700a6e00: d004         	beq	0x700a6e0c <Udma_ringFree+0x3c> @ imm = #0x8
700a6e02: e7ff         	b	0x700a6e04 <Udma_ringFree+0x34> @ imm = #-0x2
700a6e04: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a6e08: 9004         	str	r0, [sp, #0x10]
;         }
700a6e0a: e7ff         	b	0x700a6e0c <Udma_ringFree+0x3c> @ imm = #-0x2
;     }
700a6e0c: e7ff         	b	0x700a6e0e <Udma_ringFree+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a6e0e: 9804         	ldr	r0, [sp, #0x10]
700a6e10: b9a8         	cbnz	r0, 0x700a6e3e <Udma_ringFree+0x6e> @ imm = #0x2a
700a6e12: e7ff         	b	0x700a6e14 <Udma_ringFree+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a6e14: 9802         	ldr	r0, [sp, #0x8]
700a6e16: 6800         	ldr	r0, [r0]
700a6e18: 9003         	str	r0, [sp, #0xc]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a6e1a: 9803         	ldr	r0, [sp, #0xc]
700a6e1c: b150         	cbz	r0, 0x700a6e34 <Udma_ringFree+0x64> @ imm = #0x14
700a6e1e: e7ff         	b	0x700a6e20 <Udma_ringFree+0x50> @ imm = #-0x2
700a6e20: 9803         	ldr	r0, [sp, #0xc]
700a6e22: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a6e26: f64a 31cd    	movw	r1, #0xabcd
700a6e2a: f6ca 31dc    	movt	r1, #0xabdc
700a6e2e: 4288         	cmp	r0, r1
700a6e30: d004         	beq	0x700a6e3c <Udma_ringFree+0x6c> @ imm = #0x8
700a6e32: e7ff         	b	0x700a6e34 <Udma_ringFree+0x64> @ imm = #-0x2
700a6e34: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a6e38: 9004         	str	r0, [sp, #0x10]
;         }
700a6e3a: e7ff         	b	0x700a6e3c <Udma_ringFree+0x6c> @ imm = #-0x2
;     }
700a6e3c: e7ff         	b	0x700a6e3e <Udma_ringFree+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a6e3e: 9804         	ldr	r0, [sp, #0x10]
700a6e40: bb38         	cbnz	r0, 0x700a6e92 <Udma_ringFree+0xc2> @ imm = #0x4e
700a6e42: e7ff         	b	0x700a6e44 <Udma_ringFree+0x74> @ imm = #-0x2
;         if(UDMA_MAPPED_GROUP_INVALID == ringHandleInt->mappedRingGrp)
700a6e44: 9802         	ldr	r0, [sp, #0x8]
700a6e46: 6dc0         	ldr	r0, [r0, #0x5c]
700a6e48: 2104         	movs	r1, #0x4
700a6e4a: f6cf 71ff    	movt	r1, #0xffff
700a6e4e: 4288         	cmp	r0, r1
700a6e50: d106         	bne	0x700a6e60 <Udma_ringFree+0x90> @ imm = #0xc
700a6e52: e7ff         	b	0x700a6e54 <Udma_ringFree+0x84> @ imm = #-0x2
;             Udma_rmFreeFreeRing(ringHandleInt->ringNum, drvHandle);
700a6e54: 9802         	ldr	r0, [sp, #0x8]
700a6e56: 8880         	ldrh	r0, [r0, #0x4]
700a6e58: 9903         	ldr	r1, [sp, #0xc]
700a6e5a: f008 fd91    	bl	0x700af980 <Udma_rmFreeFreeRing> @ imm = #0x8b22
;         }
700a6e5e: e007         	b	0x700a6e70 <Udma_ringFree+0xa0> @ imm = #0xe
;                 ringHandleInt->ringNum,
700a6e60: 9b02         	ldr	r3, [sp, #0x8]
700a6e62: 8898         	ldrh	r0, [r3, #0x4]
;                 drvHandle,
700a6e64: 9903         	ldr	r1, [sp, #0xc]
;                 ringHandleInt->mappedRingGrp,
700a6e66: 6dda         	ldr	r2, [r3, #0x5c]
;                 ringHandleInt->mappedChNum);
700a6e68: 6e1b         	ldr	r3, [r3, #0x60]
;             Udma_rmFreeMappedRing(
700a6e6a: f002 fe79    	bl	0x700a9b60 <Udma_rmFreeMappedRing> @ imm = #0x2cf2
700a6e6e: e7ff         	b	0x700a6e70 <Udma_ringFree+0xa0> @ imm = #-0x2
;         ringHandleInt->ringNum         = UDMA_RING_INVALID;
700a6e70: 9902         	ldr	r1, [sp, #0x8]
700a6e72: f64f 70ff    	movw	r0, #0xffff
700a6e76: 8088         	strh	r0, [r1, #0x4]
;         ringHandleInt->ringInitDone    = UDMA_DEINIT_DONE;
700a6e78: 9902         	ldr	r1, [sp, #0x8]
700a6e7a: 2000         	movs	r0, #0x0
700a6e7c: 9001         	str	r0, [sp, #0x4]
700a6e7e: 6588         	str	r0, [r1, #0x58]
;         drvHandle->ringHandleClearRegs(ringHandleInt);
700a6e80: 9803         	ldr	r0, [sp, #0xc]
700a6e82: f8d0 15c8    	ldr.w	r1, [r0, #0x5c8]
700a6e86: 9802         	ldr	r0, [sp, #0x8]
700a6e88: 4788         	blx	r1
700a6e8a: 9801         	ldr	r0, [sp, #0x4]
;         ringHandleInt->drvHandle       = (Udma_DrvHandleInt) NULL_PTR;
700a6e8c: 9902         	ldr	r1, [sp, #0x8]
700a6e8e: 6008         	str	r0, [r1]
;     }
700a6e90: e7ff         	b	0x700a6e92 <Udma_ringFree+0xc2> @ imm = #-0x2
;     return (retVal);
700a6e92: 9804         	ldr	r0, [sp, #0x10]
700a6e94: b006         	add	sp, #0x18
700a6e96: bd80         	pop	{r7, pc}
		...

700a6ea0 <UART_lld_writeIntr>:
; {
700a6ea0: b580         	push	{r7, lr}
700a6ea2: b086         	sub	sp, #0x18
700a6ea4: 9005         	str	r0, [sp, #0x14]
700a6ea6: 9104         	str	r1, [sp, #0x10]
700a6ea8: 9203         	str	r2, [sp, #0xc]
700a6eaa: 9302         	str	r3, [sp, #0x8]
700a6eac: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a6eae: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a6eb0: 9805         	ldr	r0, [sp, #0x14]
700a6eb2: 2800         	cmp	r0, #0x0
700a6eb4: d050         	beq	0x700a6f58 <UART_lld_writeIntr+0xb8> @ imm = #0xa0
700a6eb6: e7ff         	b	0x700a6eb8 <UART_lld_writeIntr+0x18> @ imm = #-0x2
;         trans = &hUart->writeTrans;
700a6eb8: 9805         	ldr	r0, [sp, #0x14]
700a6eba: 303c         	adds	r0, #0x3c
700a6ebc: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a6ebe: 9800         	ldr	r0, [sp]
700a6ec0: 6800         	ldr	r0, [r0]
700a6ec2: b138         	cbz	r0, 0x700a6ed4 <UART_lld_writeIntr+0x34> @ imm = #0xe
700a6ec4: e7ff         	b	0x700a6ec6 <UART_lld_writeIntr+0x26> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a6ec6: 9900         	ldr	r1, [sp]
700a6ec8: 2009         	movs	r0, #0x9
700a6eca: 60c8         	str	r0, [r1, #0xc]
700a6ecc: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a6ed0: 9001         	str	r0, [sp, #0x4]
;         }
700a6ed2: e040         	b	0x700a6f56 <UART_lld_writeIntr+0xb6> @ imm = #0x80
;             UART_lld_Transaction_init(trans);
700a6ed4: 9800         	ldr	r0, [sp]
700a6ed6: f007 fe23    	bl	0x700aeb20 <UART_lld_Transaction_init> @ imm = #0x7c46
;             if(extendedParams != NULL)
700a6eda: 9802         	ldr	r0, [sp, #0x8]
700a6edc: b128         	cbz	r0, 0x700a6eea <UART_lld_writeIntr+0x4a> @ imm = #0xa
700a6ede: e7ff         	b	0x700a6ee0 <UART_lld_writeIntr+0x40> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a6ee0: 9802         	ldr	r0, [sp, #0x8]
700a6ee2: 6800         	ldr	r0, [r0]
700a6ee4: 9900         	ldr	r1, [sp]
700a6ee6: 6108         	str	r0, [r1, #0x10]
;             }
700a6ee8: e003         	b	0x700a6ef2 <UART_lld_writeIntr+0x52> @ imm = #0x6
;                 trans->args = NULL;
700a6eea: 9900         	ldr	r1, [sp]
700a6eec: 2000         	movs	r0, #0x0
700a6eee: 6108         	str	r0, [r1, #0x10]
700a6ef0: e7ff         	b	0x700a6ef2 <UART_lld_writeIntr+0x52> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a6ef2: 9804         	ldr	r0, [sp, #0x10]
700a6ef4: 9900         	ldr	r1, [sp]
700a6ef6: 6008         	str	r0, [r1]
;             trans->count = size;
700a6ef8: 9803         	ldr	r0, [sp, #0xc]
700a6efa: 9900         	ldr	r1, [sp]
700a6efc: 6048         	str	r0, [r1, #0x4]
;             if(hUart->state == UART_STATE_READY)
700a6efe: 9805         	ldr	r0, [sp, #0x14]
700a6f00: 6d40         	ldr	r0, [r0, #0x54]
700a6f02: 2801         	cmp	r0, #0x1
700a6f04: d105         	bne	0x700a6f12 <UART_lld_writeIntr+0x72> @ imm = #0xa
700a6f06: e7ff         	b	0x700a6f08 <UART_lld_writeIntr+0x68> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a6f08: 9800         	ldr	r0, [sp]
700a6f0a: f007 fa09    	bl	0x700ae320 <UART_checkTransaction> @ imm = #0x7412
700a6f0e: 9001         	str	r0, [sp, #0x4]
;             }
700a6f10: e003         	b	0x700a6f1a <UART_lld_writeIntr+0x7a> @ imm = #0x6
700a6f12: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a6f16: 9001         	str	r0, [sp, #0x4]
700a6f18: e7ff         	b	0x700a6f1a <UART_lld_writeIntr+0x7a> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a6f1a: 9801         	ldr	r0, [sp, #0x4]
700a6f1c: b9d0         	cbnz	r0, 0x700a6f54 <UART_lld_writeIntr+0xb4> @ imm = #0x34
700a6f1e: e7ff         	b	0x700a6f20 <UART_lld_writeIntr+0x80> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a6f20: 9800         	ldr	r0, [sp]
700a6f22: 6800         	ldr	r0, [r0]
700a6f24: 9905         	ldr	r1, [sp, #0x14]
700a6f26: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a6f28: 9800         	ldr	r0, [sp]
700a6f2a: 6880         	ldr	r0, [r0, #0x8]
700a6f2c: 9905         	ldr	r1, [sp, #0x14]
700a6f2e: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a6f30: 9905         	ldr	r1, [sp, #0x14]
700a6f32: 2000         	movs	r0, #0x0
700a6f34: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a6f36: 9800         	ldr	r0, [sp]
700a6f38: 6840         	ldr	r0, [r0, #0x4]
700a6f3a: 9905         	ldr	r1, [sp, #0x14]
700a6f3c: 6108         	str	r0, [r1, #0x10]
;                 hUart->state = UART_STATE_BUSY;
700a6f3e: 9905         	ldr	r1, [sp, #0x14]
700a6f40: 2002         	movs	r0, #0x2
700a6f42: 6548         	str	r0, [r1, #0x54]
;                 status = UART_writeInterrupt(hUart);
700a6f44: 9805         	ldr	r0, [sp, #0x14]
700a6f46: f008 f943    	bl	0x700af1d0 <UART_writeInterrupt> @ imm = #0x8286
700a6f4a: 9001         	str	r0, [sp, #0x4]
;                 hUart->state = UART_STATE_READY;
700a6f4c: 9905         	ldr	r1, [sp, #0x14]
700a6f4e: 2001         	movs	r0, #0x1
700a6f50: 6548         	str	r0, [r1, #0x54]
;             }
700a6f52: e7ff         	b	0x700a6f54 <UART_lld_writeIntr+0xb4> @ imm = #-0x2
700a6f54: e7ff         	b	0x700a6f56 <UART_lld_writeIntr+0xb6> @ imm = #-0x2
;     }
700a6f56: e003         	b	0x700a6f60 <UART_lld_writeIntr+0xc0> @ imm = #0x6
700a6f58: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a6f5c: 9001         	str	r0, [sp, #0x4]
700a6f5e: e7ff         	b	0x700a6f60 <UART_lld_writeIntr+0xc0> @ imm = #-0x2
;     return status;
700a6f60: 9801         	ldr	r0, [sp, #0x4]
700a6f62: b006         	add	sp, #0x18
700a6f64: bd80         	pop	{r7, pc}
		...
700a6f6e: 0000         	movs	r0, r0

700a6f70 <Udma_eventUnRegister>:
; {
700a6f70: b580         	push	{r7, lr}
700a6f72: b084         	sub	sp, #0x10
700a6f74: 9003         	str	r0, [sp, #0xc]
700a6f76: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a6f78: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == eventHandle)
700a6f7a: 9803         	ldr	r0, [sp, #0xc]
700a6f7c: b920         	cbnz	r0, 0x700a6f88 <Udma_eventUnRegister+0x18> @ imm = #0x8
700a6f7e: e7ff         	b	0x700a6f80 <Udma_eventUnRegister+0x10> @ imm = #-0x2
700a6f80: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a6f84: 9002         	str	r0, [sp, #0x8]
;     }
700a6f86: e7ff         	b	0x700a6f88 <Udma_eventUnRegister+0x18> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a6f88: 9802         	ldr	r0, [sp, #0x8]
700a6f8a: b9b8         	cbnz	r0, 0x700a6fbc <Udma_eventUnRegister+0x4c> @ imm = #0x2e
700a6f8c: e7ff         	b	0x700a6f8e <Udma_eventUnRegister+0x1e> @ imm = #-0x2
;         eventHandleInt = (Udma_EventHandleInt) eventHandle;
700a6f8e: 9803         	ldr	r0, [sp, #0xc]
700a6f90: 9000         	str	r0, [sp]
;         drvHandle = eventHandleInt->drvHandle;
700a6f92: 9800         	ldr	r0, [sp]
700a6f94: 6800         	ldr	r0, [r0]
700a6f96: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a6f98: 9801         	ldr	r0, [sp, #0x4]
700a6f9a: b150         	cbz	r0, 0x700a6fb2 <Udma_eventUnRegister+0x42> @ imm = #0x14
700a6f9c: e7ff         	b	0x700a6f9e <Udma_eventUnRegister+0x2e> @ imm = #-0x2
700a6f9e: 9801         	ldr	r0, [sp, #0x4]
700a6fa0: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a6fa4: f64a 31cd    	movw	r1, #0xabcd
700a6fa8: f6ca 31dc    	movt	r1, #0xabdc
700a6fac: 4288         	cmp	r0, r1
700a6fae: d004         	beq	0x700a6fba <Udma_eventUnRegister+0x4a> @ imm = #0x8
700a6fb0: e7ff         	b	0x700a6fb2 <Udma_eventUnRegister+0x42> @ imm = #-0x2
700a6fb2: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a6fb6: 9002         	str	r0, [sp, #0x8]
;         }
700a6fb8: e7ff         	b	0x700a6fba <Udma_eventUnRegister+0x4a> @ imm = #-0x2
;     }
700a6fba: e7ff         	b	0x700a6fbc <Udma_eventUnRegister+0x4c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a6fbc: 9802         	ldr	r0, [sp, #0x8]
700a6fbe: bbb8         	cbnz	r0, 0x700a7030 <Udma_eventUnRegister+0xc0> @ imm = #0x6e
700a6fc0: e7ff         	b	0x700a6fc2 <Udma_eventUnRegister+0x52> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandle->instType) &&
700a6fc2: 9801         	ldr	r0, [sp, #0x4]
700a6fc4: 6800         	ldr	r0, [r0]
700a6fc6: b130         	cbz	r0, 0x700a6fd6 <Udma_eventUnRegister+0x66> @ imm = #0xc
700a6fc8: e7ff         	b	0x700a6fca <Udma_eventUnRegister+0x5a> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventHandleInt->eventPrms.eventType))
700a6fca: 9800         	ldr	r0, [sp]
700a6fcc: 6880         	ldr	r0, [r0, #0x8]
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandle->instType) &&
700a6fce: 2802         	cmp	r0, #0x2
700a6fd0: d101         	bne	0x700a6fd6 <Udma_eventUnRegister+0x66> @ imm = #0x2
700a6fd2: e7ff         	b	0x700a6fd4 <Udma_eventUnRegister+0x64> @ imm = #-0x2
;         }
700a6fd4: e02b         	b	0x700a702e <Udma_eventUnRegister+0xbe> @ imm = #0x56
;             retVal = Udma_eventCheckUnRegister(drvHandle, eventHandleInt);
700a6fd6: 9801         	ldr	r0, [sp, #0x4]
700a6fd8: 9900         	ldr	r1, [sp]
700a6fda: f7ff fe91    	bl	0x700a6d00 <Udma_eventCheckUnRegister> @ imm = #-0x2de
700a6fde: 9002         	str	r0, [sp, #0x8]
;             if(UDMA_SOK == retVal)
700a6fe0: 9802         	ldr	r0, [sp, #0x8]
700a6fe2: bb18         	cbnz	r0, 0x700a702c <Udma_eventUnRegister+0xbc> @ imm = #0x46
700a6fe4: e7ff         	b	0x700a6fe6 <Udma_eventUnRegister+0x76> @ imm = #-0x2
;                 if(NULL_PTR != eventHandleInt->hwiHandle)
700a6fe6: 9800         	ldr	r0, [sp]
700a6fe8: 6e40         	ldr	r0, [r0, #0x64]
700a6fea: b128         	cbz	r0, 0x700a6ff8 <Udma_eventUnRegister+0x88> @ imm = #0xa
700a6fec: e7ff         	b	0x700a6fee <Udma_eventUnRegister+0x7e> @ imm = #-0x2
;                     HwiP_disableInt(eventHandleInt->coreIntrNum);
700a6fee: 9800         	ldr	r0, [sp]
700a6ff0: 6d80         	ldr	r0, [r0, #0x58]
700a6ff2: f008 fda5    	bl	0x700afb40 <HwiP_disableInt> @ imm = #0x8b4a
;                 }
700a6ff6: e7ff         	b	0x700a6ff8 <Udma_eventUnRegister+0x88> @ imm = #-0x2
;                 retVal = Udma_eventReset(drvHandle, eventHandleInt);
700a6ff8: 9801         	ldr	r0, [sp, #0x4]
700a6ffa: 9900         	ldr	r1, [sp]
700a6ffc: f7f5 ffc0    	bl	0x7009cf80 <Udma_eventReset> @ imm = #-0xa080
700a7000: 9002         	str	r0, [sp, #0x8]
;                 if(UDMA_SOK != retVal)
700a7002: 9802         	ldr	r0, [sp, #0x8]
700a7004: b108         	cbz	r0, 0x700a700a <Udma_eventUnRegister+0x9a> @ imm = #0x2
700a7006: e7ff         	b	0x700a7008 <Udma_eventUnRegister+0x98> @ imm = #-0x2
;                 }
700a7008: e7ff         	b	0x700a700a <Udma_eventUnRegister+0x9a> @ imm = #-0x2
;                 Udma_eventFreeResource(drvHandle, eventHandleInt);
700a700a: 9801         	ldr	r0, [sp, #0x4]
700a700c: 9900         	ldr	r1, [sp]
700a700e: f7fe fcef    	bl	0x700a59f0 <Udma_eventFreeResource> @ imm = #-0x1622
;                 eventHandleInt->eventInitDone  = UDMA_DEINIT_DONE;
700a7012: 9900         	ldr	r1, [sp]
700a7014: 2000         	movs	r0, #0x0
700a7016: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 eventHandleInt->pIaGeviRegs    = (volatile CSL_intaggr_imapRegs_gevi *) NULL_PTR;
700a701a: 9900         	ldr	r1, [sp]
700a701c: f8c1 0090    	str.w	r0, [r1, #0x90]
;                 eventHandleInt->pIaVintrRegs   = (volatile CSL_intaggr_intrRegs_vint *) NULL_PTR;
700a7020: 9900         	ldr	r1, [sp]
700a7022: f8c1 0094    	str.w	r0, [r1, #0x94]
;                 eventHandleInt->drvHandle      = (Udma_DrvHandleInt) NULL_PTR;
700a7026: 9900         	ldr	r1, [sp]
700a7028: 6008         	str	r0, [r1]
;             }
700a702a: e7ff         	b	0x700a702c <Udma_eventUnRegister+0xbc> @ imm = #-0x2
700a702c: e7ff         	b	0x700a702e <Udma_eventUnRegister+0xbe> @ imm = #-0x2
;     }
700a702e: e7ff         	b	0x700a7030 <Udma_eventUnRegister+0xc0> @ imm = #-0x2
;     return (retVal);
700a7030: 9802         	ldr	r0, [sp, #0x8]
700a7032: b004         	add	sp, #0x10
700a7034: bd80         	pop	{r7, pc}
		...
700a703e: 0000         	movs	r0, r0

700a7040 <Sciclient_rmIrqIsVintRouteSet>:
; {
700a7040: b580         	push	{r7, lr}
700a7042: b088         	sub	sp, #0x20
700a7044: 9007         	str	r0, [sp, #0x1c]
700a7046: 9106         	str	r1, [sp, #0x18]
700a7048: 2000         	movs	r0, #0x0
;     bool found_iface = false;
700a704a: f88d 0007    	strb.w	r0, [sp, #0x7]
;     *vint_used = false;
700a704e: 9906         	ldr	r1, [sp, #0x18]
700a7050: 7008         	strb	r0, [r1]
;     r = Sciclient_rmIrqGetNode(cfg->s_ia, &ia_node);
700a7052: 9807         	ldr	r0, [sp, #0x1c]
700a7054: 8a00         	ldrh	r0, [r0, #0x10]
700a7056: a903         	add	r1, sp, #0xc
700a7058: f7fe fdba    	bl	0x700a5bd0 <Sciclient_rmIrqGetNode> @ imm = #-0x148c
700a705c: 9005         	str	r0, [sp, #0x14]
;     if (r == SystemP_SUCCESS) {
700a705e: 9805         	ldr	r0, [sp, #0x14]
700a7060: bb90         	cbnz	r0, 0x700a70c8 <Sciclient_rmIrqIsVintRouteSet+0x88> @ imm = #0x64
700a7062: e7ff         	b	0x700a7064 <Sciclient_rmIrqIsVintRouteSet+0x24> @ imm = #-0x2
700a7064: 2000         	movs	r0, #0x0
;         for (i = 0U; i < ia_node->n_if; i++) {
700a7066: f8ad 0012    	strh.w	r0, [sp, #0x12]
700a706a: e7ff         	b	0x700a706c <Sciclient_rmIrqIsVintRouteSet+0x2c> @ imm = #-0x2
700a706c: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a7070: 9903         	ldr	r1, [sp, #0xc]
700a7072: 8849         	ldrh	r1, [r1, #0x2]
700a7074: 4288         	cmp	r0, r1
700a7076: da26         	bge	0x700a70c6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0x4c
700a7078: e7ff         	b	0x700a707a <Sciclient_rmIrqIsVintRouteSet+0x3a> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(ia_node, i, &iface);
700a707a: 9803         	ldr	r0, [sp, #0xc]
700a707c: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a7080: aa02         	add	r2, sp, #0x8
700a7082: f006 fbad    	bl	0x700ad7e0 <Sciclient_rmIrqGetNodeItf> @ imm = #0x675a
700a7086: 9005         	str	r0, [sp, #0x14]
;             if (r != SystemP_SUCCESS) {
700a7088: 9805         	ldr	r0, [sp, #0x14]
700a708a: b108         	cbz	r0, 0x700a7090 <Sciclient_rmIrqIsVintRouteSet+0x50> @ imm = #0x2
700a708c: e7ff         	b	0x700a708e <Sciclient_rmIrqIsVintRouteSet+0x4e> @ imm = #-0x2
;                 break;
700a708e: e01a         	b	0x700a70c6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0x34
;             if ((cfg->vint >= iface->lbase) &&
700a7090: 9807         	ldr	r0, [sp, #0x1c]
700a7092: 8a40         	ldrh	r0, [r0, #0x12]
700a7094: 9902         	ldr	r1, [sp, #0x8]
700a7096: 8809         	ldrh	r1, [r1]
700a7098: 4288         	cmp	r0, r1
700a709a: db0d         	blt	0x700a70b8 <Sciclient_rmIrqIsVintRouteSet+0x78> @ imm = #0x1a
700a709c: e7ff         	b	0x700a709e <Sciclient_rmIrqIsVintRouteSet+0x5e> @ imm = #-0x2
;                 (cfg->vint < (iface->lbase + iface->len))) {
700a709e: 9807         	ldr	r0, [sp, #0x1c]
700a70a0: 8a40         	ldrh	r0, [r0, #0x12]
700a70a2: 9a02         	ldr	r2, [sp, #0x8]
700a70a4: 8811         	ldrh	r1, [r2]
700a70a6: 8892         	ldrh	r2, [r2, #0x4]
700a70a8: 4411         	add	r1, r2
;             if ((cfg->vint >= iface->lbase) &&
700a70aa: 4288         	cmp	r0, r1
700a70ac: da04         	bge	0x700a70b8 <Sciclient_rmIrqIsVintRouteSet+0x78> @ imm = #0x8
700a70ae: e7ff         	b	0x700a70b0 <Sciclient_rmIrqIsVintRouteSet+0x70> @ imm = #-0x2
700a70b0: 2001         	movs	r0, #0x1
;                 found_iface = true;
700a70b2: f88d 0007    	strb.w	r0, [sp, #0x7]
;                 break;
700a70b6: e006         	b	0x700a70c6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0xc
;         }
700a70b8: e7ff         	b	0x700a70ba <Sciclient_rmIrqIsVintRouteSet+0x7a> @ imm = #-0x2
;         for (i = 0U; i < ia_node->n_if; i++) {
700a70ba: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a70be: 3001         	adds	r0, #0x1
700a70c0: f8ad 0012    	strh.w	r0, [sp, #0x12]
700a70c4: e7d2         	b	0x700a706c <Sciclient_rmIrqIsVintRouteSet+0x2c> @ imm = #-0x5c
;     }
700a70c6: e7ff         	b	0x700a70c8 <Sciclient_rmIrqIsVintRouteSet+0x88> @ imm = #-0x2
;     if (found_iface) {
700a70c8: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700a70cc: 07c0         	lsls	r0, r0, #0x1f
700a70ce: b1b0         	cbz	r0, 0x700a70fe <Sciclient_rmIrqIsVintRouteSet+0xbe> @ imm = #0x2c
700a70d0: e7ff         	b	0x700a70d2 <Sciclient_rmIrqIsVintRouteSet+0x92> @ imm = #-0x2
;         ir_inp = SCICLIENT_OUTP_TO_INP(cfg->vint, iface->lbase, iface->rbase);
700a70d2: 9a02         	ldr	r2, [sp, #0x8]
700a70d4: 8850         	ldrh	r0, [r2, #0x2]
700a70d6: 9907         	ldr	r1, [sp, #0x1c]
700a70d8: 8a49         	ldrh	r1, [r1, #0x12]
700a70da: 8812         	ldrh	r2, [r2]
700a70dc: 1a89         	subs	r1, r1, r2
700a70de: 4408         	add	r0, r1
700a70e0: f8ad 0004    	strh.w	r0, [sp, #0x4]
;         if (Sciclient_rmIrInpIsFree(iface->rid, ir_inp) != SystemP_SUCCESS) {
700a70e4: 9802         	ldr	r0, [sp, #0x8]
700a70e6: 88c0         	ldrh	r0, [r0, #0x6]
700a70e8: f8bd 1004    	ldrh.w	r1, [sp, #0x4]
700a70ec: f7fe ff38    	bl	0x700a5f60 <Sciclient_rmIrInpIsFree> @ imm = #-0x1190
700a70f0: b120         	cbz	r0, 0x700a70fc <Sciclient_rmIrqIsVintRouteSet+0xbc> @ imm = #0x8
700a70f2: e7ff         	b	0x700a70f4 <Sciclient_rmIrqIsVintRouteSet+0xb4> @ imm = #-0x2
;             *vint_used = true;
700a70f4: 9906         	ldr	r1, [sp, #0x18]
700a70f6: 2001         	movs	r0, #0x1
700a70f8: 7008         	strb	r0, [r1]
;         }
700a70fa: e7ff         	b	0x700a70fc <Sciclient_rmIrqIsVintRouteSet+0xbc> @ imm = #-0x2
;     }
700a70fc: e7ff         	b	0x700a70fe <Sciclient_rmIrqIsVintRouteSet+0xbe> @ imm = #-0x2
;     return r;
700a70fe: 9805         	ldr	r0, [sp, #0x14]
700a7100: b008         	add	sp, #0x20
700a7102: bd80         	pop	{r7, pc}
		...

700a7110 <UART_flushTxFifo>:
; {
700a7110: b580         	push	{r7, lr}
700a7112: b08a         	sub	sp, #0x28
700a7114: 9009         	str	r0, [sp, #0x24]
700a7116: f640 30b8    	movw	r0, #0xbb8
;     uint32_t            timeout = UART_TRANSMITEMPTY_TRIALCOUNT;
700a711a: 9003         	str	r0, [sp, #0xc]
700a711c: 2000         	movs	r0, #0x0
;     uint32_t            timeoutElapsed  = FALSE;
700a711e: 9002         	str	r0, [sp, #0x8]
;     config = (UART_Config *) handle;
700a7120: 9809         	ldr	r0, [sp, #0x24]
700a7122: 9008         	str	r0, [sp, #0x20]
;     if (NULL != config)
700a7124: 9808         	ldr	r0, [sp, #0x20]
700a7126: 2800         	cmp	r0, #0x0
700a7128: d052         	beq	0x700a71d0 <UART_flushTxFifo+0xc0> @ imm = #0xa4
700a712a: e7ff         	b	0x700a712c <UART_flushTxFifo+0x1c> @ imm = #-0x2
;         attrs = config->attrs;
700a712c: 9808         	ldr	r0, [sp, #0x20]
700a712e: 6800         	ldr	r0, [r0]
700a7130: 9007         	str	r0, [sp, #0x1c]
;         DebugP_assert(NULL_PTR != attrs);
700a7132: 9807         	ldr	r0, [sp, #0x1c]
700a7134: 2800         	cmp	r0, #0x0
700a7136: bf18         	it	ne
700a7138: 2001         	movne	r0, #0x1
700a713a: f641 41fb    	movw	r1, #0x1cfb
700a713e: f2c7 010b    	movt	r1, #0x700b
700a7142: 466a         	mov	r2, sp
700a7144: 6011         	str	r1, [r2]
700a7146: f641 41c5    	movw	r1, #0x1cc5
700a714a: f2c7 010b    	movt	r1, #0x700b
700a714e: f641 5252    	movw	r2, #0x1d52
700a7152: f2c7 020b    	movt	r2, #0x700b
700a7156: f240 3355    	movw	r3, #0x355
700a715a: f003 fc69    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x38d2
;         startTicks = ClockP_getTicks();
700a715e: f008 fc3f    	bl	0x700af9e0 <ClockP_getTicks> @ imm = #0x887e
700a7162: 9005         	str	r0, [sp, #0x14]
;         while (FALSE == timeoutElapsed)
700a7164: e7ff         	b	0x700a7166 <UART_flushTxFifo+0x56> @ imm = #-0x2
700a7166: 9802         	ldr	r0, [sp, #0x8]
700a7168: b9d8         	cbnz	r0, 0x700a71a2 <UART_flushTxFifo+0x92> @ imm = #0x36
700a716a: e7ff         	b	0x700a716c <UART_flushTxFifo+0x5c> @ imm = #-0x2
;             isTxFifoEmpty = UART_spaceAvail(attrs->baseAddr);
700a716c: 9807         	ldr	r0, [sp, #0x1c]
700a716e: 6800         	ldr	r0, [r0]
700a7170: f006 fd56    	bl	0x700adc20 <UART_spaceAvail> @ imm = #0x6aac
700a7174: 9006         	str	r0, [sp, #0x18]
;             if (TRUE == isTxFifoEmpty)
700a7176: 9806         	ldr	r0, [sp, #0x18]
700a7178: 2801         	cmp	r0, #0x1
700a717a: d101         	bne	0x700a7180 <UART_flushTxFifo+0x70> @ imm = #0x2
700a717c: e7ff         	b	0x700a717e <UART_flushTxFifo+0x6e> @ imm = #-0x2
;                 break;
700a717e: e010         	b	0x700a71a2 <UART_flushTxFifo+0x92> @ imm = #0x20
;             elapsedTicks = ClockP_getTicks() - startTicks;
700a7180: f008 fc2e    	bl	0x700af9e0 <ClockP_getTicks> @ imm = #0x885c
700a7184: 9905         	ldr	r1, [sp, #0x14]
700a7186: 1a40         	subs	r0, r0, r1
700a7188: 9004         	str	r0, [sp, #0x10]
;             if (elapsedTicks >= timeout)
700a718a: 9804         	ldr	r0, [sp, #0x10]
700a718c: 9903         	ldr	r1, [sp, #0xc]
700a718e: 4288         	cmp	r0, r1
700a7190: d303         	blo	0x700a719a <UART_flushTxFifo+0x8a> @ imm = #0x6
700a7192: e7ff         	b	0x700a7194 <UART_flushTxFifo+0x84> @ imm = #-0x2
700a7194: 2001         	movs	r0, #0x1
;                 timeoutElapsed = TRUE;
700a7196: 9002         	str	r0, [sp, #0x8]
;             }
700a7198: e002         	b	0x700a71a0 <UART_flushTxFifo+0x90> @ imm = #0x4
;                 TaskP_yield();
700a719a: f008 fc51    	bl	0x700afa40 <TaskP_yield> @ imm = #0x88a2
700a719e: e7ff         	b	0x700a71a0 <UART_flushTxFifo+0x90> @ imm = #-0x2
;         while (FALSE == timeoutElapsed)
700a71a0: e7e1         	b	0x700a7166 <UART_flushTxFifo+0x56> @ imm = #-0x3e
;         DebugP_assert(FALSE == timeoutElapsed);
700a71a2: 9802         	ldr	r0, [sp, #0x8]
700a71a4: fab0 f080    	clz	r0, r0
700a71a8: 0940         	lsrs	r0, r0, #0x5
700a71aa: f641 31b7    	movw	r1, #0x1bb7
700a71ae: f2c7 010b    	movt	r1, #0x700b
700a71b2: 466a         	mov	r2, sp
700a71b4: 6011         	str	r1, [r2]
700a71b6: f641 41c5    	movw	r1, #0x1cc5
700a71ba: f2c7 010b    	movt	r1, #0x700b
700a71be: f641 5252    	movw	r2, #0x1d52
700a71c2: f2c7 020b    	movt	r2, #0x700b
700a71c6: f240 336f    	movw	r3, #0x36f
700a71ca: f003 fc31    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x3862
;     }
700a71ce: e7ff         	b	0x700a71d0 <UART_flushTxFifo+0xc0> @ imm = #-0x2
;     return;
700a71d0: b00a         	add	sp, #0x28
700a71d2: bd80         	pop	{r7, pc}
		...

700a71e0 <Udma_chClose>:
; {
700a71e0: b580         	push	{r7, lr}
700a71e2: b084         	sub	sp, #0x10
700a71e4: 9003         	str	r0, [sp, #0xc]
700a71e6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a71e8: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a71ea: 9803         	ldr	r0, [sp, #0xc]
700a71ec: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a71ee: 9800         	ldr	r0, [sp]
700a71f0: b150         	cbz	r0, 0x700a7208 <Udma_chClose+0x28> @ imm = #0x14
700a71f2: e7ff         	b	0x700a71f4 <Udma_chClose+0x14> @ imm = #-0x2
700a71f4: 9800         	ldr	r0, [sp]
700a71f6: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a71fa: f64a 31cd    	movw	r1, #0xabcd
700a71fe: f6ca 31dc    	movt	r1, #0xabdc
700a7202: 4288         	cmp	r0, r1
700a7204: d004         	beq	0x700a7210 <Udma_chClose+0x30> @ imm = #0x8
700a7206: e7ff         	b	0x700a7208 <Udma_chClose+0x28> @ imm = #-0x2
700a7208: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a720c: 9002         	str	r0, [sp, #0x8]
;     }
700a720e: e7ff         	b	0x700a7210 <Udma_chClose+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7210: 9802         	ldr	r0, [sp, #0x8]
700a7212: b9a8         	cbnz	r0, 0x700a7240 <Udma_chClose+0x60> @ imm = #0x2a
700a7214: e7ff         	b	0x700a7216 <Udma_chClose+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a7216: 9800         	ldr	r0, [sp]
700a7218: 6e80         	ldr	r0, [r0, #0x68]
700a721a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a721c: 9801         	ldr	r0, [sp, #0x4]
700a721e: b150         	cbz	r0, 0x700a7236 <Udma_chClose+0x56> @ imm = #0x14
700a7220: e7ff         	b	0x700a7222 <Udma_chClose+0x42> @ imm = #-0x2
700a7222: 9801         	ldr	r0, [sp, #0x4]
700a7224: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a7228: f64a 31cd    	movw	r1, #0xabcd
700a722c: f6ca 31dc    	movt	r1, #0xabdc
700a7230: 4288         	cmp	r0, r1
700a7232: d004         	beq	0x700a723e <Udma_chClose+0x5e> @ imm = #0x8
700a7234: e7ff         	b	0x700a7236 <Udma_chClose+0x56> @ imm = #-0x2
700a7236: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a723a: 9002         	str	r0, [sp, #0x8]
;         }
700a723c: e7ff         	b	0x700a723e <Udma_chClose+0x5e> @ imm = #-0x2
;     }
700a723e: e7ff         	b	0x700a7240 <Udma_chClose+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7240: 9802         	ldr	r0, [sp, #0x8]
700a7242: b958         	cbnz	r0, 0x700a725c <Udma_chClose+0x7c> @ imm = #0x16
700a7244: e7ff         	b	0x700a7246 <Udma_chClose+0x66> @ imm = #-0x2
;         if(TRUE == chHandleInt->chOesAllocDone)
700a7246: 9800         	ldr	r0, [sp]
700a7248: f8d0 0248    	ldr.w	r0, [r0, #0x248]
700a724c: 2801         	cmp	r0, #0x1
700a724e: d104         	bne	0x700a725a <Udma_chClose+0x7a> @ imm = #0x8
700a7250: e7ff         	b	0x700a7252 <Udma_chClose+0x72> @ imm = #-0x2
700a7252: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7256: 9002         	str	r0, [sp, #0x8]
;         }
700a7258: e7ff         	b	0x700a725a <Udma_chClose+0x7a> @ imm = #-0x2
;     }
700a725a: e7ff         	b	0x700a725c <Udma_chClose+0x7c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a725c: 9802         	ldr	r0, [sp, #0x8]
700a725e: b9e8         	cbnz	r0, 0x700a729c <Udma_chClose+0xbc> @ imm = #0x3a
700a7260: e7ff         	b	0x700a7262 <Udma_chClose+0x82> @ imm = #-0x2
;         retVal = Udma_chUnpair(chHandleInt);
700a7262: 9800         	ldr	r0, [sp]
700a7264: f003 fa1c    	bl	0x700aa6a0 <Udma_chUnpair> @ imm = #0x3438
700a7268: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
700a726a: 9802         	ldr	r0, [sp, #0x8]
700a726c: b108         	cbz	r0, 0x700a7272 <Udma_chClose+0x92> @ imm = #0x2
700a726e: e7ff         	b	0x700a7270 <Udma_chClose+0x90> @ imm = #-0x2
;         }
700a7270: e7ff         	b	0x700a7272 <Udma_chClose+0x92> @ imm = #-0x2
;         retVal += Udma_chFreeResource(chHandleInt);
700a7272: 9800         	ldr	r0, [sp]
700a7274: f7f7 fc2c    	bl	0x7009ead0 <Udma_chFreeResource> @ imm = #-0x87a8
700a7278: 4601         	mov	r1, r0
700a727a: 9802         	ldr	r0, [sp, #0x8]
700a727c: 4408         	add	r0, r1
700a727e: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
700a7280: 9802         	ldr	r0, [sp, #0x8]
700a7282: b108         	cbz	r0, 0x700a7288 <Udma_chClose+0xa8> @ imm = #0x2
700a7284: e7ff         	b	0x700a7286 <Udma_chClose+0xa6> @ imm = #-0x2
;         }
700a7286: e7ff         	b	0x700a7288 <Udma_chClose+0xa8> @ imm = #-0x2
;         (void) memset(chHandleInt, 0, sizeof(*chHandleInt));
700a7288: 9800         	ldr	r0, [sp]
700a728a: f44f 7114    	mov.w	r1, #0x250
700a728e: f7f3 ef02    	blx	0x7009b094 <__aeabi_memclr8> @ imm = #-0xc1fc
;         chHandleInt->chInitDone = UDMA_DEINIT_DONE;
700a7292: 9900         	ldr	r1, [sp]
700a7294: 2000         	movs	r0, #0x0
700a7296: f8c1 0244    	str.w	r0, [r1, #0x244]
;     }
700a729a: e7ff         	b	0x700a729c <Udma_chClose+0xbc> @ imm = #-0x2
;     return (retVal);
700a729c: 9802         	ldr	r0, [sp, #0x8]
700a729e: b004         	add	sp, #0x10
700a72a0: bd80         	pop	{r7, pc}
		...
700a72ae: 0000         	movs	r0, r0

700a72b0 <CSL_bcdmaChanOpAccessRemotePeerReg>:
; {
700a72b0: b580         	push	{r7, lr}
700a72b2: b08a         	sub	sp, #0x28
700a72b4: 4684         	mov	r12, r0
700a72b6: 980c         	ldr	r0, [sp, #0x30]
700a72b8: f8cd c024    	str.w	r12, [sp, #0x24]
700a72bc: 9108         	str	r1, [sp, #0x20]
700a72be: 9207         	str	r2, [sp, #0x1c]
700a72c0: 9306         	str	r3, [sp, #0x18]
700a72c2: f88d 0017    	strb.w	r0, [sp, #0x17]
700a72c6: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a72c8: 9004         	str	r0, [sp, #0x10]
;     if( pOpData == NULL )
700a72ca: 9806         	ldr	r0, [sp, #0x18]
700a72cc: b920         	cbnz	r0, 0x700a72d8 <CSL_bcdmaChanOpAccessRemotePeerReg+0x28> @ imm = #0x8
700a72ce: e7ff         	b	0x700a72d0 <CSL_bcdmaChanOpAccessRemotePeerReg+0x20> @ imm = #-0x2
700a72d0: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a72d4: 9004         	str	r0, [sp, #0x10]
;     }
700a72d6: e048         	b	0x700a736a <CSL_bcdmaChanOpAccessRemotePeerReg+0xba> @ imm = #0x90
700a72d8: 2000         	movs	r0, #0x0
;         uint32_t *pRemotePeerReg = NULL;
700a72da: 9003         	str	r0, [sp, #0xc]
;         switch( chanType )
700a72dc: 9808         	ldr	r0, [sp, #0x20]
700a72de: 9001         	str	r0, [sp, #0x4]
700a72e0: 2801         	cmp	r0, #0x1
700a72e2: d004         	beq	0x700a72ee <CSL_bcdmaChanOpAccessRemotePeerReg+0x3e> @ imm = #0x8
700a72e4: e7ff         	b	0x700a72e6 <CSL_bcdmaChanOpAccessRemotePeerReg+0x36> @ imm = #-0x2
700a72e6: 9801         	ldr	r0, [sp, #0x4]
700a72e8: 2802         	cmp	r0, #0x2
700a72ea: d009         	beq	0x700a7300 <CSL_bcdmaChanOpAccessRemotePeerReg+0x50> @ imm = #0x12
700a72ec: e011         	b	0x700a7312 <CSL_bcdmaChanOpAccessRemotePeerReg+0x62> @ imm = #0x22
;                 pRemotePeerReg = (uint32_t *)&pCfg->pTxChanRtRegs->CHAN[chanIdx].PEER0;
700a72ee: 9809         	ldr	r0, [sp, #0x24]
700a72f0: 6900         	ldr	r0, [r0, #0x10]
700a72f2: 9907         	ldr	r1, [sp, #0x1c]
700a72f4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a72f8: f500 7000    	add.w	r0, r0, #0x200
700a72fc: 9003         	str	r0, [sp, #0xc]
;                 break;
700a72fe: e00c         	b	0x700a731a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #0x18
;                 pRemotePeerReg = (uint32_t *)&pCfg->pRxChanRtRegs->CHAN[chanIdx].PEER0;
700a7300: 9809         	ldr	r0, [sp, #0x24]
700a7302: 6980         	ldr	r0, [r0, #0x18]
700a7304: 9907         	ldr	r1, [sp, #0x1c]
700a7306: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a730a: f500 7000    	add.w	r0, r0, #0x200
700a730e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a7310: e003         	b	0x700a731a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #0x6
700a7312: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a7316: 9004         	str	r0, [sp, #0x10]
;                 break;
700a7318: e7ff         	b	0x700a731a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #-0x2
;         if( pRemotePeerReg != NULL )
700a731a: 9803         	ldr	r0, [sp, #0xc]
700a731c: b320         	cbz	r0, 0x700a7368 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb8> @ imm = #0x48
700a731e: e7ff         	b	0x700a7320 <CSL_bcdmaChanOpAccessRemotePeerReg+0x70> @ imm = #-0x2
;             CSL_BcdmaRemotePeerOpts *pPeerOpts = (CSL_BcdmaRemotePeerOpts *)pOpData;
700a7320: 9806         	ldr	r0, [sp, #0x18]
700a7322: 9002         	str	r0, [sp, #0x8]
;             if( pPeerOpts->regIdx >= (uint32_t)16u )
700a7324: 9802         	ldr	r0, [sp, #0x8]
700a7326: 6800         	ldr	r0, [r0]
700a7328: 2810         	cmp	r0, #0x10
700a732a: d304         	blo	0x700a7336 <CSL_bcdmaChanOpAccessRemotePeerReg+0x86> @ imm = #0x8
700a732c: e7ff         	b	0x700a732e <CSL_bcdmaChanOpAccessRemotePeerReg+0x7e> @ imm = #-0x2
700a732e: f06f 0002    	mvn	r0, #0x2
;                 retVal = CSL_EINVALID_PARAMS;
700a7332: 9004         	str	r0, [sp, #0x10]
;             }
700a7334: e017         	b	0x700a7366 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb6> @ imm = #0x2e
;                 pRemotePeerReg += pPeerOpts->regIdx;    /* Increment to specified peer register */
700a7336: 9802         	ldr	r0, [sp, #0x8]
700a7338: 6801         	ldr	r1, [r0]
700a733a: 9803         	ldr	r0, [sp, #0xc]
700a733c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7340: 9003         	str	r0, [sp, #0xc]
;                 if( bRead == (bool)true )
700a7342: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a7346: 07c0         	lsls	r0, r0, #0x1f
700a7348: b130         	cbz	r0, 0x700a7358 <CSL_bcdmaChanOpAccessRemotePeerReg+0xa8> @ imm = #0xc
700a734a: e7ff         	b	0x700a734c <CSL_bcdmaChanOpAccessRemotePeerReg+0x9c> @ imm = #-0x2
;                     pPeerOpts->regVal = CSL_REG32_RD( pRemotePeerReg );
700a734c: 9803         	ldr	r0, [sp, #0xc]
700a734e: f008 facf    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0x859e
700a7352: 9902         	ldr	r1, [sp, #0x8]
700a7354: 6048         	str	r0, [r1, #0x4]
;                 }
700a7356: e005         	b	0x700a7364 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb4> @ imm = #0xa
;                     CSL_REG32_WR( pRemotePeerReg, pPeerOpts->regVal );
700a7358: 9803         	ldr	r0, [sp, #0xc]
700a735a: 9902         	ldr	r1, [sp, #0x8]
700a735c: 6849         	ldr	r1, [r1, #0x4]
700a735e: f7f4 ff57    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0xb152
700a7362: e7ff         	b	0x700a7364 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb4> @ imm = #-0x2
700a7364: e7ff         	b	0x700a7366 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb6> @ imm = #-0x2
;         }
700a7366: e7ff         	b	0x700a7368 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb8> @ imm = #-0x2
700a7368: e7ff         	b	0x700a736a <CSL_bcdmaChanOpAccessRemotePeerReg+0xba> @ imm = #-0x2
;     return retVal;
700a736a: 9804         	ldr	r0, [sp, #0x10]
700a736c: b00a         	add	sp, #0x28
700a736e: bd80         	pop	{r7, pc}

700a7370 <_out_rev>:
; {
700a7370: b580         	push	{r7, lr}
700a7372: b086         	sub	sp, #0x18
700a7374: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a7378: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a737c: f8dd c024    	ldr.w	r12, [sp, #0x24]
700a7380: f8dd c020    	ldr.w	r12, [sp, #0x20]
700a7384: 9005         	str	r0, [sp, #0x14]
700a7386: 9104         	str	r1, [sp, #0x10]
700a7388: 9203         	str	r2, [sp, #0xc]
700a738a: 9302         	str	r3, [sp, #0x8]
;   const size_t start_idx = idx;
700a738c: 9803         	ldr	r0, [sp, #0xc]
700a738e: 9001         	str	r0, [sp, #0x4]
;   if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
700a7390: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a7394: 0780         	lsls	r0, r0, #0x1e
700a7396: 2800         	cmp	r0, #0x0
700a7398: d41c         	bmi	0x700a73d4 <_out_rev+0x64> @ imm = #0x38
700a739a: e7ff         	b	0x700a739c <_out_rev+0x2c> @ imm = #-0x2
700a739c: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a73a0: 07c0         	lsls	r0, r0, #0x1f
700a73a2: b9b8         	cbnz	r0, 0x700a73d4 <_out_rev+0x64> @ imm = #0x2e
700a73a4: e7ff         	b	0x700a73a6 <_out_rev+0x36> @ imm = #-0x2
;     for (i = len; i < width; i++) {
700a73a6: 9809         	ldr	r0, [sp, #0x24]
700a73a8: 9000         	str	r0, [sp]
700a73aa: e7ff         	b	0x700a73ac <_out_rev+0x3c> @ imm = #-0x2
700a73ac: 9800         	ldr	r0, [sp]
700a73ae: 990a         	ldr	r1, [sp, #0x28]
700a73b0: 4288         	cmp	r0, r1
700a73b2: d20e         	bhs	0x700a73d2 <_out_rev+0x62> @ imm = #0x1c
700a73b4: e7ff         	b	0x700a73b6 <_out_rev+0x46> @ imm = #-0x2
;       out(' ', buffer, idx++, maxlen);
700a73b6: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a73ba: 9904         	ldr	r1, [sp, #0x10]
700a73bc: 9a03         	ldr	r2, [sp, #0xc]
700a73be: 1c50         	adds	r0, r2, #0x1
700a73c0: 9003         	str	r0, [sp, #0xc]
700a73c2: 9b02         	ldr	r3, [sp, #0x8]
700a73c4: 2020         	movs	r0, #0x20
700a73c6: 47e0         	blx	r12
;     }
700a73c8: e7ff         	b	0x700a73ca <_out_rev+0x5a> @ imm = #-0x2
;     for (i = len; i < width; i++) {
700a73ca: 9800         	ldr	r0, [sp]
700a73cc: 3001         	adds	r0, #0x1
700a73ce: 9000         	str	r0, [sp]
700a73d0: e7ec         	b	0x700a73ac <_out_rev+0x3c> @ imm = #-0x28
;   }
700a73d2: e7ff         	b	0x700a73d4 <_out_rev+0x64> @ imm = #-0x2
;   while (len) {
700a73d4: e7ff         	b	0x700a73d6 <_out_rev+0x66> @ imm = #-0x2
700a73d6: 9809         	ldr	r0, [sp, #0x24]
700a73d8: b170         	cbz	r0, 0x700a73f8 <_out_rev+0x88> @ imm = #0x1c
700a73da: e7ff         	b	0x700a73dc <_out_rev+0x6c> @ imm = #-0x2
;     out(buf[--len], buffer, idx++, maxlen);
700a73dc: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a73e0: 9808         	ldr	r0, [sp, #0x20]
700a73e2: 9909         	ldr	r1, [sp, #0x24]
700a73e4: 3901         	subs	r1, #0x1
700a73e6: 9109         	str	r1, [sp, #0x24]
700a73e8: 5c40         	ldrb	r0, [r0, r1]
700a73ea: 9904         	ldr	r1, [sp, #0x10]
700a73ec: 9a03         	ldr	r2, [sp, #0xc]
700a73ee: 1c53         	adds	r3, r2, #0x1
700a73f0: 9303         	str	r3, [sp, #0xc]
700a73f2: 9b02         	ldr	r3, [sp, #0x8]
700a73f4: 47e0         	blx	r12
;   while (len) {
700a73f6: e7ee         	b	0x700a73d6 <_out_rev+0x66> @ imm = #-0x24
;   if (flags & FLAGS_LEFT) {
700a73f8: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a73fc: 0780         	lsls	r0, r0, #0x1e
700a73fe: 2800         	cmp	r0, #0x0
700a7400: d513         	bpl	0x700a742a <_out_rev+0xba> @ imm = #0x26
700a7402: e7ff         	b	0x700a7404 <_out_rev+0x94> @ imm = #-0x2
;     while (idx - start_idx < width) {
700a7404: e7ff         	b	0x700a7406 <_out_rev+0x96> @ imm = #-0x2
700a7406: 9803         	ldr	r0, [sp, #0xc]
700a7408: 9901         	ldr	r1, [sp, #0x4]
700a740a: 1a40         	subs	r0, r0, r1
700a740c: 990a         	ldr	r1, [sp, #0x28]
700a740e: 4288         	cmp	r0, r1
700a7410: d20a         	bhs	0x700a7428 <_out_rev+0xb8> @ imm = #0x14
700a7412: e7ff         	b	0x700a7414 <_out_rev+0xa4> @ imm = #-0x2
;       out(' ', buffer, idx++, maxlen);
700a7414: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a7418: 9904         	ldr	r1, [sp, #0x10]
700a741a: 9a03         	ldr	r2, [sp, #0xc]
700a741c: 1c50         	adds	r0, r2, #0x1
700a741e: 9003         	str	r0, [sp, #0xc]
700a7420: 9b02         	ldr	r3, [sp, #0x8]
700a7422: 2020         	movs	r0, #0x20
700a7424: 47e0         	blx	r12
;     while (idx - start_idx < width) {
700a7426: e7ee         	b	0x700a7406 <_out_rev+0x96> @ imm = #-0x24
;   }
700a7428: e7ff         	b	0x700a742a <_out_rev+0xba> @ imm = #-0x2
;   return idx;
700a742a: 9803         	ldr	r0, [sp, #0xc]
700a742c: b006         	add	sp, #0x18
700a742e: bd80         	pop	{r7, pc}

700a7430 <vTaskStartScheduler>:
; void vTaskStartScheduler(void) {
700a7430: b580         	push	{r7, lr}
700a7432: b088         	sub	sp, #0x20
700a7434: 2000         	movs	r0, #0x0
;     StaticTask_t *pxIdleTaskTCBBuffer = NULL;
700a7436: 9003         	str	r0, [sp, #0xc]
700a7438: 9006         	str	r0, [sp, #0x18]
;     StackType_t *pxIdleTaskStackBuffer = NULL;
700a743a: 9005         	str	r0, [sp, #0x14]
700a743c: a806         	add	r0, sp, #0x18
700a743e: a905         	add	r1, sp, #0x14
700a7440: aa04         	add	r2, sp, #0x10
;     vApplicationGetIdleTaskMemory(&pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer,
700a7442: f007 fadd    	bl	0x700aea00 <vApplicationGetIdleTaskMemory> @ imm = #0x75ba
700a7446: 9b03         	ldr	r3, [sp, #0xc]
;         prvIdleTask, configIDLE_TASK_NAME, ulIdleTaskStackSize,
700a7448: 9a04         	ldr	r2, [sp, #0x10]
;         pxIdleTaskStackBuffer,
700a744a: 9905         	ldr	r1, [sp, #0x14]
;         pxIdleTaskTCBBuffer); /*lint !e961 MISRA exception, justified as it is
700a744c: f8dd c018    	ldr.w	r12, [sp, #0x18]
;     xIdleTaskHandle = xTaskCreateStatic(
700a7450: 4668         	mov	r0, sp
700a7452: f8c0 c008    	str.w	r12, [r0, #0x8]
700a7456: 6041         	str	r1, [r0, #0x4]
700a7458: 6003         	str	r3, [r0]
700a745a: f64c 40a1    	movw	r0, #0xcca1
700a745e: f2c7 000a    	movt	r0, #0x700a
700a7462: f242 21ee    	movw	r1, #0x22ee
700a7466: f2c7 010b    	movt	r1, #0x700b
700a746a: f003 fe61    	bl	0x700ab130 <xTaskCreateStatic> @ imm = #0x3cc2
700a746e: 4601         	mov	r1, r0
700a7470: f242 60f0    	movw	r0, #0x26f0
700a7474: f2c7 000b    	movt	r0, #0x700b
700a7478: 6001         	str	r1, [r0]
;     if (xIdleTaskHandle != NULL) {
700a747a: 6800         	ldr	r0, [r0]
700a747c: b118         	cbz	r0, 0x700a7486 <vTaskStartScheduler+0x56> @ imm = #0x6
700a747e: e7ff         	b	0x700a7480 <vTaskStartScheduler+0x50> @ imm = #-0x2
700a7480: 2001         	movs	r0, #0x1
;       xReturn = pdPASS;
700a7482: 9007         	str	r0, [sp, #0x1c]
;     } else {
700a7484: e002         	b	0x700a748c <vTaskStartScheduler+0x5c> @ imm = #0x4
700a7486: 2000         	movs	r0, #0x0
;       xReturn = pdFAIL;
700a7488: 9007         	str	r0, [sp, #0x1c]
700a748a: e7ff         	b	0x700a748c <vTaskStartScheduler+0x5c> @ imm = #-0x2
;     if (xReturn == pdPASS) {
700a748c: 9807         	ldr	r0, [sp, #0x1c]
700a748e: 2801         	cmp	r0, #0x1
700a7490: d104         	bne	0x700a749c <vTaskStartScheduler+0x6c> @ imm = #0x8
700a7492: e7ff         	b	0x700a7494 <vTaskStartScheduler+0x64> @ imm = #-0x2
;       xReturn = xTimerCreateTimerTask();
700a7494: f003 fbcc    	bl	0x700aac30 <xTimerCreateTimerTask> @ imm = #0x3798
700a7498: 9007         	str	r0, [sp, #0x1c]
;     } else {
700a749a: e000         	b	0x700a749e <vTaskStartScheduler+0x6e> @ imm = #0x0
700a749c: e7ff         	b	0x700a749e <vTaskStartScheduler+0x6e> @ imm = #-0x2
;   if (xReturn == pdPASS) {
700a749e: 9807         	ldr	r0, [sp, #0x1c]
700a74a0: 2801         	cmp	r0, #0x1
700a74a2: d11d         	bne	0x700a74e0 <vTaskStartScheduler+0xb0> @ imm = #0x3a
700a74a4: e7ff         	b	0x700a74a6 <vTaskStartScheduler+0x76> @ imm = #-0x2
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700a74a6: b672         	cpsid i
;     xNextTaskUnblockTime = portMAX_DELAY;
700a74a8: f242 61f4    	movw	r1, #0x26f4
700a74ac: f2c7 010b    	movt	r1, #0x700b
700a74b0: f04f 30ff    	mov.w	r0, #0xffffffff
700a74b4: 6008         	str	r0, [r1]
;     xSchedulerRunning = pdTRUE;
700a74b6: f242 7100    	movw	r1, #0x2700
700a74ba: f2c7 010b    	movt	r1, #0x700b
700a74be: 2001         	movs	r0, #0x1
700a74c0: 6008         	str	r0, [r1]
;     xTickCount = (TickType_t)configINITIAL_TICK_COUNT;
700a74c2: f242 7104    	movw	r1, #0x2704
700a74c6: f2c7 010b    	movt	r1, #0x700b
700a74ca: 2000         	movs	r0, #0x0
700a74cc: 6008         	str	r0, [r1]
;     portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
700a74ce: f008 fb0f    	bl	0x700afaf0 <vPortConfigTimerForRunTimeStats> @ imm = #0x861e
;     if (xPortStartScheduler() != pdFALSE) {
700a74d2: f007 fead    	bl	0x700af230 <xPortStartScheduler> @ imm = #0x7d5a
700a74d6: b108         	cbz	r0, 0x700a74dc <vTaskStartScheduler+0xac> @ imm = #0x2
700a74d8: e7ff         	b	0x700a74da <vTaskStartScheduler+0xaa> @ imm = #-0x2
;     } else {
700a74da: e000         	b	0x700a74de <vTaskStartScheduler+0xae> @ imm = #0x0
700a74dc: e7ff         	b	0x700a74de <vTaskStartScheduler+0xae> @ imm = #-0x2
;   } else {
700a74de: e000         	b	0x700a74e2 <vTaskStartScheduler+0xb2> @ imm = #0x0
700a74e0: e7ff         	b	0x700a74e2 <vTaskStartScheduler+0xb2> @ imm = #-0x2
;   (void)uxTopUsedPriority;
700a74e2: f242 302c    	movw	r0, #0x232c
700a74e6: f2c7 000b    	movt	r0, #0x700b
700a74ea: 6800         	ldr	r0, [r0]
; }
700a74ec: b008         	add	sp, #0x20
700a74ee: bd80         	pop	{r7, pc}

700a74f0 <PMU_profilePrintEntry>:
; void PMU_profilePrintEntry(const char *name) {
700a74f0: b580         	push	{r7, lr}
700a74f2: b086         	sub	sp, #0x18
700a74f4: 9005         	str	r0, [sp, #0x14]
700a74f6: 2000         	movs	r0, #0x0
;   for (i = 0; i < gProfileObject.logIndex; i++) {
700a74f8: 9004         	str	r0, [sp, #0x10]
700a74fa: e7ff         	b	0x700a74fc <PMU_profilePrintEntry+0xc> @ imm = #-0x2
700a74fc: 9804         	ldr	r0, [sp, #0x10]
700a74fe: f243 0180    	movw	r1, #0x3080
700a7502: f2c7 0108    	movt	r1, #0x7008
700a7506: 6809         	ldr	r1, [r1]
700a7508: 4288         	cmp	r0, r1
700a750a: d24d         	bhs	0x700a75a8 <PMU_profilePrintEntry+0xb8> @ imm = #0x9a
700a750c: e7ff         	b	0x700a750e <PMU_profilePrintEntry+0x1e> @ imm = #-0x2
;     PMU_ProfilePoint *p = &gProfileObject.point[i];
700a750e: 9804         	ldr	r0, [sp, #0x10]
700a7510: f243 0280    	movw	r2, #0x3080
700a7514: f2c7 0208    	movt	r2, #0x7008
700a7518: 2134         	movs	r1, #0x34
700a751a: fb00 2001    	mla	r0, r0, r1, r2
700a751e: 300c         	adds	r0, #0xc
700a7520: 9002         	str	r0, [sp, #0x8]
;     if (strcmp(name, p->name) == 0) {
700a7522: 9805         	ldr	r0, [sp, #0x14]
700a7524: 9902         	ldr	r1, [sp, #0x8]
700a7526: 6b09         	ldr	r1, [r1, #0x30]
700a7528: f7f4 ee7a    	blx	0x7009c220 <strcmp>     @ imm = #-0xb30c
700a752c: bbb8         	cbnz	r0, 0x700a759e <PMU_profilePrintEntry+0xae> @ imm = #0x6e
700a752e: e7ff         	b	0x700a7530 <PMU_profilePrintEntry+0x40> @ imm = #-0x2
;       DebugP_log("Profile Point: %-32s\r\n", p->name);
700a7530: 9802         	ldr	r0, [sp, #0x8]
700a7532: 6b02         	ldr	r2, [r0, #0x30]
700a7534: f641 31ff    	movw	r1, #0x1bff
700a7538: f2c7 010b    	movt	r1, #0x700b
700a753c: 2001         	movs	r0, #0x1
700a753e: 9001         	str	r0, [sp, #0x4]
700a7540: f002 fabe    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #0x257c
700a7544: 9801         	ldr	r0, [sp, #0x4]
;       DebugP_log("Cycle Count: %lu\r\n", p->cycleCount.value);
700a7546: 9902         	ldr	r1, [sp, #0x8]
700a7548: 6aca         	ldr	r2, [r1, #0x2c]
700a754a: f641 4179    	movw	r1, #0x1c79
700a754e: f2c7 010b    	movt	r1, #0x700b
700a7552: f002 fab5    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #0x256a
700a7556: 2000         	movs	r0, #0x0
;       for (j = 0; j < PMU_MAX_EVENT_COUNTERS; j++) {
700a7558: 9003         	str	r0, [sp, #0xc]
700a755a: e7ff         	b	0x700a755c <PMU_profilePrintEntry+0x6c> @ imm = #-0x2
700a755c: 9803         	ldr	r0, [sp, #0xc]
700a755e: 2802         	cmp	r0, #0x2
700a7560: d815         	bhi	0x700a758e <PMU_profilePrintEntry+0x9e> @ imm = #0x2a
700a7562: e7ff         	b	0x700a7564 <PMU_profilePrintEntry+0x74> @ imm = #-0x2
;         DebugP_log("%s Count: %lu\r\n", p->events[j].name, p->events[j].value);
700a7564: 9902         	ldr	r1, [sp, #0x8]
700a7566: 9803         	ldr	r0, [sp, #0xc]
700a7568: eb00 0240    	add.w	r2, r0, r0, lsl #1
700a756c: eb01 0082    	add.w	r0, r1, r2, lsl #2
700a7570: f851 2022    	ldr.w	r2, [r1, r2, lsl #2]
700a7574: 6883         	ldr	r3, [r0, #0x8]
700a7576: f641 5185    	movw	r1, #0x1d85
700a757a: f2c7 010b    	movt	r1, #0x700b
700a757e: 2001         	movs	r0, #0x1
700a7580: f002 fa9e    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #0x253c
;       }
700a7584: e7ff         	b	0x700a7586 <PMU_profilePrintEntry+0x96> @ imm = #-0x2
;       for (j = 0; j < PMU_MAX_EVENT_COUNTERS; j++) {
700a7586: 9803         	ldr	r0, [sp, #0xc]
700a7588: 3001         	adds	r0, #0x1
700a758a: 9003         	str	r0, [sp, #0xc]
700a758c: e7e6         	b	0x700a755c <PMU_profilePrintEntry+0x6c> @ imm = #-0x34
;       DebugP_log("\r\n");
700a758e: f241 4101    	movw	r1, #0x1401
700a7592: f2c7 010b    	movt	r1, #0x700b
700a7596: 2001         	movs	r0, #0x1
700a7598: f002 fa92    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #0x2524
;       break;
700a759c: e004         	b	0x700a75a8 <PMU_profilePrintEntry+0xb8> @ imm = #0x8
;   }
700a759e: e7ff         	b	0x700a75a0 <PMU_profilePrintEntry+0xb0> @ imm = #-0x2
;   for (i = 0; i < gProfileObject.logIndex; i++) {
700a75a0: 9804         	ldr	r0, [sp, #0x10]
700a75a2: 3001         	adds	r0, #0x1
700a75a4: 9004         	str	r0, [sp, #0x10]
700a75a6: e7a9         	b	0x700a74fc <PMU_profilePrintEntry+0xc> @ imm = #-0xae
; }
700a75a8: b006         	add	sp, #0x18
700a75aa: bd80         	pop	{r7, pc}
700a75ac: 0000         	movs	r0, r0
700a75ae: 0000         	movs	r0, r0

700a75b0 <prvSwitchTimerLists>:
;     {
700a75b0: b580         	push	{r7, lr}
700a75b2: b086         	sub	sp, #0x18
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
700a75b4: e7ff         	b	0x700a75b6 <prvSwitchTimerLists+0x6> @ imm = #-0x2
700a75b6: f245 201c    	movw	r0, #0x521c
700a75ba: f2c7 0008    	movt	r0, #0x7008
700a75be: 6800         	ldr	r0, [r0]
700a75c0: 6800         	ldr	r0, [r0]
700a75c2: 2800         	cmp	r0, #0x0
700a75c4: d040         	beq	0x700a7648 <prvSwitchTimerLists+0x98> @ imm = #0x80
700a75c6: e7ff         	b	0x700a75c8 <prvSwitchTimerLists+0x18> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
700a75c8: f245 201c    	movw	r0, #0x521c
700a75cc: f2c7 0008    	movt	r0, #0x7008
700a75d0: 6801         	ldr	r1, [r0]
700a75d2: 68c9         	ldr	r1, [r1, #0xc]
700a75d4: 6809         	ldr	r1, [r1]
700a75d6: 9105         	str	r1, [sp, #0x14]
;             pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
700a75d8: 6800         	ldr	r0, [r0]
700a75da: 68c0         	ldr	r0, [r0, #0xc]
700a75dc: 68c0         	ldr	r0, [r0, #0xc]
700a75de: 9002         	str	r0, [sp, #0x8]
;             ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a75e0: 9802         	ldr	r0, [sp, #0x8]
700a75e2: 3004         	adds	r0, #0x4
700a75e4: f005 ff44    	bl	0x700ad470 <uxListRemove> @ imm = #0x5e88
;             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a75e8: 9802         	ldr	r0, [sp, #0x8]
700a75ea: 6a01         	ldr	r1, [r0, #0x20]
700a75ec: 4788         	blx	r1
;             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a75ee: 9802         	ldr	r0, [sp, #0x8]
700a75f0: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a75f4: 0740         	lsls	r0, r0, #0x1d
700a75f6: 2800         	cmp	r0, #0x0
700a75f8: d524         	bpl	0x700a7644 <prvSwitchTimerLists+0x94> @ imm = #0x48
700a75fa: e7ff         	b	0x700a75fc <prvSwitchTimerLists+0x4c> @ imm = #-0x2
;                 xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
700a75fc: 9805         	ldr	r0, [sp, #0x14]
700a75fe: 9902         	ldr	r1, [sp, #0x8]
700a7600: 6989         	ldr	r1, [r1, #0x18]
700a7602: 4408         	add	r0, r1
700a7604: 9004         	str	r0, [sp, #0x10]
;                 if( xReloadTime > xNextExpireTime )
700a7606: 9804         	ldr	r0, [sp, #0x10]
700a7608: 9905         	ldr	r1, [sp, #0x14]
700a760a: 4288         	cmp	r0, r1
700a760c: d90f         	bls	0x700a762e <prvSwitchTimerLists+0x7e> @ imm = #0x1e
700a760e: e7ff         	b	0x700a7610 <prvSwitchTimerLists+0x60> @ imm = #-0x2
;                     listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
700a7610: 9804         	ldr	r0, [sp, #0x10]
700a7612: 9902         	ldr	r1, [sp, #0x8]
700a7614: 6048         	str	r0, [r1, #0x4]
;                     listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
700a7616: 9802         	ldr	r0, [sp, #0x8]
700a7618: 6100         	str	r0, [r0, #0x10]
;                     vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
700a761a: f245 201c    	movw	r0, #0x521c
700a761e: f2c7 0008    	movt	r0, #0x7008
700a7622: 6800         	ldr	r0, [r0]
700a7624: 9902         	ldr	r1, [sp, #0x8]
700a7626: 3104         	adds	r1, #0x4
700a7628: f003 ffba    	bl	0x700ab5a0 <vListInsert> @ imm = #0x3f74
;                 }
700a762c: e009         	b	0x700a7642 <prvSwitchTimerLists+0x92> @ imm = #0x12
;                     xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
700a762e: 9802         	ldr	r0, [sp, #0x8]
700a7630: 9a05         	ldr	r2, [sp, #0x14]
700a7632: 4669         	mov	r1, sp
700a7634: 2300         	movs	r3, #0x0
700a7636: 600b         	str	r3, [r1]
700a7638: 4619         	mov	r1, r3
700a763a: f002 f951    	bl	0x700a98e0 <xTimerGenericCommand> @ imm = #0x22a2
700a763e: 9001         	str	r0, [sp, #0x4]
700a7640: e7ff         	b	0x700a7642 <prvSwitchTimerLists+0x92> @ imm = #-0x2
;             }
700a7642: e000         	b	0x700a7646 <prvSwitchTimerLists+0x96> @ imm = #0x0
700a7644: e7ff         	b	0x700a7646 <prvSwitchTimerLists+0x96> @ imm = #-0x2
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
700a7646: e7b6         	b	0x700a75b6 <prvSwitchTimerLists+0x6> @ imm = #-0x94
;         pxTemp = pxCurrentTimerList;
700a7648: f245 221c    	movw	r2, #0x521c
700a764c: f2c7 0208    	movt	r2, #0x7008
700a7650: 6810         	ldr	r0, [r2]
700a7652: 9003         	str	r0, [sp, #0xc]
;         pxCurrentTimerList = pxOverflowTimerList;
700a7654: f245 2128    	movw	r1, #0x5228
700a7658: f2c7 0108    	movt	r1, #0x7008
700a765c: 6808         	ldr	r0, [r1]
700a765e: 6010         	str	r0, [r2]
;         pxOverflowTimerList = pxTemp;
700a7660: 9803         	ldr	r0, [sp, #0xc]
700a7662: 6008         	str	r0, [r1]
;     }
700a7664: b006         	add	sp, #0x18
700a7666: bd80         	pop	{r7, pc}
		...

700a7670 <CSL_pktdmaAccessChanPeerReg>:
; {
700a7670: b580         	push	{r7, lr}
700a7672: b088         	sub	sp, #0x20
700a7674: 4684         	mov	r12, r0
700a7676: 980b         	ldr	r0, [sp, #0x2c]
700a7678: f8dd e028    	ldr.w	lr, [sp, #0x28]
700a767c: f8cd c01c    	str.w	r12, [sp, #0x1c]
700a7680: 9106         	str	r1, [sp, #0x18]
700a7682: 9205         	str	r2, [sp, #0x14]
700a7684: 9304         	str	r3, [sp, #0x10]
700a7686: f88d 000f    	strb.w	r0, [sp, #0xf]
700a768a: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a768c: 9002         	str	r0, [sp, #0x8]
;     if( (pCfg == NULL) || (pVal == NULL) || (CSL_pktdmaIsValidChanIdx( pCfg, chanIdx, chanDir) == (bool)false) )
700a768e: 9807         	ldr	r0, [sp, #0x1c]
700a7690: b150         	cbz	r0, 0x700a76a8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #0x14
700a7692: e7ff         	b	0x700a7694 <CSL_pktdmaAccessChanPeerReg+0x24> @ imm = #-0x2
700a7694: 9804         	ldr	r0, [sp, #0x10]
700a7696: b138         	cbz	r0, 0x700a76a8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #0xe
700a7698: e7ff         	b	0x700a769a <CSL_pktdmaAccessChanPeerReg+0x2a> @ imm = #-0x2
700a769a: 9807         	ldr	r0, [sp, #0x1c]
700a769c: 9906         	ldr	r1, [sp, #0x18]
700a769e: 9a0a         	ldr	r2, [sp, #0x28]
700a76a0: f005 fa3e    	bl	0x700acb20 <CSL_pktdmaIsValidChanIdx> @ imm = #0x547c
700a76a4: b920         	cbnz	r0, 0x700a76b0 <CSL_pktdmaAccessChanPeerReg+0x40> @ imm = #0x8
700a76a6: e7ff         	b	0x700a76a8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #-0x2
700a76a8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a76ac: 9002         	str	r0, [sp, #0x8]
;     }
700a76ae: e037         	b	0x700a7720 <CSL_pktdmaAccessChanPeerReg+0xb0> @ imm = #0x6e
;         if( regIdx < CSL_PKTDMA_NUM_PEER_REGS )
700a76b0: 9805         	ldr	r0, [sp, #0x14]
700a76b2: 280f         	cmp	r0, #0xf
700a76b4: d82f         	bhi	0x700a7716 <CSL_pktdmaAccessChanPeerReg+0xa6> @ imm = #0x5e
700a76b6: e7ff         	b	0x700a76b8 <CSL_pktdmaAccessChanPeerReg+0x48> @ imm = #-0x2
;             if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700a76b8: 980a         	ldr	r0, [sp, #0x28]
700a76ba: b960         	cbnz	r0, 0x700a76d6 <CSL_pktdmaAccessChanPeerReg+0x66> @ imm = #0x18
700a76bc: e7ff         	b	0x700a76be <CSL_pktdmaAccessChanPeerReg+0x4e> @ imm = #-0x2
;                 pPeerReg = (uint32_t *)(((uintptr_t)pCfg->pTxChanRtRegs) + (uintptr_t)CSL_PKTDMA_TXCRT_CHAN_PEER0(chanIdx) + ((uintptr_t)regIdx * 0x4U));
700a76be: 9807         	ldr	r0, [sp, #0x1c]
700a76c0: 6900         	ldr	r0, [r0, #0x10]
700a76c2: 9906         	ldr	r1, [sp, #0x18]
700a76c4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a76c8: 9905         	ldr	r1, [sp, #0x14]
700a76ca: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a76ce: f500 7000    	add.w	r0, r0, #0x200
700a76d2: 9001         	str	r0, [sp, #0x4]
;             }
700a76d4: e00b         	b	0x700a76ee <CSL_pktdmaAccessChanPeerReg+0x7e> @ imm = #0x16
;                 pPeerReg = (uint32_t *)(((uintptr_t)pCfg->pRxChanRtRegs) + (uintptr_t)CSL_PKTDMA_RXCRT_CHAN_PEER0(chanIdx) + ((uintptr_t)regIdx * 0x4U));
700a76d6: 9807         	ldr	r0, [sp, #0x1c]
700a76d8: 6940         	ldr	r0, [r0, #0x14]
700a76da: 9906         	ldr	r1, [sp, #0x18]
700a76dc: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a76e0: 9905         	ldr	r1, [sp, #0x14]
700a76e2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a76e6: f500 7000    	add.w	r0, r0, #0x200
700a76ea: 9001         	str	r0, [sp, #0x4]
700a76ec: e7ff         	b	0x700a76ee <CSL_pktdmaAccessChanPeerReg+0x7e> @ imm = #-0x2
;             if( bRdAccess == (bool)true )
700a76ee: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a76f2: 07c0         	lsls	r0, r0, #0x1f
700a76f4: b130         	cbz	r0, 0x700a7704 <CSL_pktdmaAccessChanPeerReg+0x94> @ imm = #0xc
700a76f6: e7ff         	b	0x700a76f8 <CSL_pktdmaAccessChanPeerReg+0x88> @ imm = #-0x2
;                 *pVal = CSL_REG32_RD( pPeerReg );
700a76f8: 9801         	ldr	r0, [sp, #0x4]
700a76fa: f008 f909    	bl	0x700af910 <CSL_REG32_RD_RAW> @ imm = #0x8212
700a76fe: 9904         	ldr	r1, [sp, #0x10]
700a7700: 6008         	str	r0, [r1]
;             }
700a7702: e005         	b	0x700a7710 <CSL_pktdmaAccessChanPeerReg+0xa0> @ imm = #0xa
;                 CSL_REG32_WR( pPeerReg, *pVal );
700a7704: 9801         	ldr	r0, [sp, #0x4]
700a7706: 9904         	ldr	r1, [sp, #0x10]
700a7708: 6809         	ldr	r1, [r1]
700a770a: f008 f859    	bl	0x700af7c0 <CSL_REG32_WR_RAW> @ imm = #0x80b2
700a770e: e7ff         	b	0x700a7710 <CSL_pktdmaAccessChanPeerReg+0xa0> @ imm = #-0x2
700a7710: 2000         	movs	r0, #0x0
;             retVal = CSL_PASS;
700a7712: 9002         	str	r0, [sp, #0x8]
;         }
700a7714: e003         	b	0x700a771e <CSL_pktdmaAccessChanPeerReg+0xae> @ imm = #0x6
700a7716: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = CSL_EFAIL;
700a771a: 9002         	str	r0, [sp, #0x8]
700a771c: e7ff         	b	0x700a771e <CSL_pktdmaAccessChanPeerReg+0xae> @ imm = #-0x2
700a771e: e7ff         	b	0x700a7720 <CSL_pktdmaAccessChanPeerReg+0xb0> @ imm = #-0x2
;     return retVal;
700a7720: 9802         	ldr	r0, [sp, #0x8]
700a7722: b008         	add	sp, #0x20
700a7724: bd80         	pop	{r7, pc}
		...
700a772e: 0000         	movs	r0, r0

700a7730 <UART_fifoWrite>:
; {
700a7730: b580         	push	{r7, lr}
700a7732: b08c         	sub	sp, #0x30
700a7734: 900b         	str	r0, [sp, #0x2c]
700a7736: 910a         	str	r1, [sp, #0x28]
700a7738: 9209         	str	r2, [sp, #0x24]
;     uint32_t tempWriteSizeRemaining = writeSizeRemaining;
700a773a: 9809         	ldr	r0, [sp, #0x24]
700a773c: 9008         	str	r0, [sp, #0x20]
;     uint32_t size                  = tempWriteSizeRemaining;
700a773e: 9808         	ldr	r0, [sp, #0x20]
700a7740: 9007         	str	r0, [sp, #0x1c]
;     const uint8_t *tempBuffer = buffer;
700a7742: 980a         	ldr	r0, [sp, #0x28]
700a7744: 9006         	str	r0, [sp, #0x18]
700a7746: 2000         	movs	r0, #0x0
;     uint32_t lineStatus            = 0U;
700a7748: 9005         	str	r0, [sp, #0x14]
;     uint32_t tempChunksize         = 0U;
700a774a: 9004         	str	r0, [sp, #0x10]
700a774c: f640 30b8    	movw	r0, #0xbb8
;     int32_t  maxTrialCount         = (int32_t) UART_TRANSMITEMPTY_TRIALCOUNT;
700a7750: 9003         	str	r0, [sp, #0xc]
700a7752: 2040         	movs	r0, #0x40
;     tempChunksize = UART_FIFO_SIZE;
700a7754: 9004         	str	r0, [sp, #0x10]
;     do
700a7756: e7ff         	b	0x700a7758 <UART_fifoWrite+0x28> @ imm = #-0x2
;         lineStatus = (uint32_t) UART_readLineStatus(hUart->baseAddr);
700a7758: 980b         	ldr	r0, [sp, #0x2c]
700a775a: 6800         	ldr	r0, [r0]
700a775c: f005 ff50    	bl	0x700ad600 <UART_readLineStatus> @ imm = #0x5ea0
700a7760: 9005         	str	r0, [sp, #0x14]
;         maxTrialCount--;
700a7762: 9803         	ldr	r0, [sp, #0xc]
700a7764: 3801         	subs	r0, #0x1
700a7766: 9003         	str	r0, [sp, #0xc]
;     }
700a7768: e7ff         	b	0x700a776a <UART_fifoWrite+0x3a> @ imm = #-0x2
;                        UART_LSR_TX_FIFO_E_MASK) & lineStatus))
700a776a: 9805         	ldr	r0, [sp, #0x14]
700a776c: f000 0160    	and	r1, r0, #0x60
700a7770: 2000         	movs	r0, #0x0
;            && (0 < maxTrialCount));
700a7772: 2960         	cmp	r1, #0x60
700a7774: 9002         	str	r0, [sp, #0x8]
700a7776: d007         	beq	0x700a7788 <UART_fifoWrite+0x58> @ imm = #0xe
700a7778: e7ff         	b	0x700a777a <UART_fifoWrite+0x4a> @ imm = #-0x2
700a777a: 9903         	ldr	r1, [sp, #0xc]
700a777c: 2000         	movs	r0, #0x0
700a777e: 2900         	cmp	r1, #0x0
700a7780: bfc8         	it	gt
700a7782: 2001         	movgt	r0, #0x1
700a7784: 9002         	str	r0, [sp, #0x8]
700a7786: e7ff         	b	0x700a7788 <UART_fifoWrite+0x58> @ imm = #-0x2
700a7788: 9802         	ldr	r0, [sp, #0x8]
;     }
700a778a: 07c0         	lsls	r0, r0, #0x1f
700a778c: 2800         	cmp	r0, #0x0
700a778e: d1e3         	bne	0x700a7758 <UART_fifoWrite+0x28> @ imm = #-0x3a
700a7790: e7ff         	b	0x700a7792 <UART_fifoWrite+0x62> @ imm = #-0x2
;     if (maxTrialCount > 0)
700a7792: 9803         	ldr	r0, [sp, #0xc]
700a7794: 2801         	cmp	r0, #0x1
700a7796: db21         	blt	0x700a77dc <UART_fifoWrite+0xac> @ imm = #0x42
700a7798: e7ff         	b	0x700a779a <UART_fifoWrite+0x6a> @ imm = #-0x2
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a779a: e7ff         	b	0x700a779c <UART_fifoWrite+0x6c> @ imm = #-0x2
700a779c: 9904         	ldr	r1, [sp, #0x10]
700a779e: 2000         	movs	r0, #0x0
700a77a0: 9001         	str	r0, [sp, #0x4]
700a77a2: b131         	cbz	r1, 0x700a77b2 <UART_fifoWrite+0x82> @ imm = #0xc
700a77a4: e7ff         	b	0x700a77a6 <UART_fifoWrite+0x76> @ imm = #-0x2
700a77a6: 9808         	ldr	r0, [sp, #0x20]
700a77a8: 2800         	cmp	r0, #0x0
700a77aa: bf18         	it	ne
700a77ac: 2001         	movne	r0, #0x1
700a77ae: 9001         	str	r0, [sp, #0x4]
700a77b0: e7ff         	b	0x700a77b2 <UART_fifoWrite+0x82> @ imm = #-0x2
700a77b2: 9801         	ldr	r0, [sp, #0x4]
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a77b4: 07c0         	lsls	r0, r0, #0x1f
700a77b6: b180         	cbz	r0, 0x700a77da <UART_fifoWrite+0xaa> @ imm = #0x20
700a77b8: e7ff         	b	0x700a77ba <UART_fifoWrite+0x8a> @ imm = #-0x2
;             UART_putChar(hUart->baseAddr, (*tempBuffer));
700a77ba: 980b         	ldr	r0, [sp, #0x2c]
700a77bc: 6800         	ldr	r0, [r0]
700a77be: 9906         	ldr	r1, [sp, #0x18]
700a77c0: 7809         	ldrb	r1, [r1]
700a77c2: f007 fe55    	bl	0x700af470 <UART_putChar> @ imm = #0x7caa
;             tempBuffer++;
700a77c6: 9806         	ldr	r0, [sp, #0x18]
700a77c8: 3001         	adds	r0, #0x1
700a77ca: 9006         	str	r0, [sp, #0x18]
;             tempWriteSizeRemaining--;
700a77cc: 9808         	ldr	r0, [sp, #0x20]
700a77ce: 3801         	subs	r0, #0x1
700a77d0: 9008         	str	r0, [sp, #0x20]
;             tempChunksize--;
700a77d2: 9804         	ldr	r0, [sp, #0x10]
700a77d4: 3801         	subs	r0, #0x1
700a77d6: 9004         	str	r0, [sp, #0x10]
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a77d8: e7e0         	b	0x700a779c <UART_fifoWrite+0x6c> @ imm = #-0x40
;     }
700a77da: e7ff         	b	0x700a77dc <UART_fifoWrite+0xac> @ imm = #-0x2
;     return (size - tempWriteSizeRemaining);
700a77dc: 9807         	ldr	r0, [sp, #0x1c]
700a77de: 9908         	ldr	r1, [sp, #0x20]
700a77e0: 1a40         	subs	r0, r0, r1
700a77e2: b00c         	add	sp, #0x30
700a77e4: bd80         	pop	{r7, pc}
		...
700a77ee: 0000         	movs	r0, r0

700a77f0 <xTaskRemoveFromEventList>:
; BaseType_t xTaskRemoveFromEventList(const List_t *const pxEventList) {
700a77f0: b580         	push	{r7, lr}
700a77f2: b084         	sub	sp, #0x10
700a77f4: 9003         	str	r0, [sp, #0xc]
;   pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a77f6: 9803         	ldr	r0, [sp, #0xc]
700a77f8: 68c0         	ldr	r0, [r0, #0xc]
700a77fa: 68c0         	ldr	r0, [r0, #0xc]
700a77fc: 9002         	str	r0, [sp, #0x8]
;   (void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
700a77fe: 9802         	ldr	r0, [sp, #0x8]
700a7800: 3018         	adds	r0, #0x18
700a7802: f005 fe35    	bl	0x700ad470 <uxListRemove> @ imm = #0x5c6a
;   if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a7806: f242 60e4    	movw	r0, #0x26e4
700a780a: f2c7 000b    	movt	r0, #0x700b
700a780e: 6800         	ldr	r0, [r0]
700a7810: bb30         	cbnz	r0, 0x700a7860 <xTaskRemoveFromEventList+0x70> @ imm = #0x4c
700a7812: e7ff         	b	0x700a7814 <xTaskRemoveFromEventList+0x24> @ imm = #-0x2
;     (void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
700a7814: 9802         	ldr	r0, [sp, #0x8]
700a7816: 3004         	adds	r0, #0x4
700a7818: f005 fe2a    	bl	0x700ad470 <uxListRemove> @ imm = #0x5c54
;     prvAddTaskToReadyList(pxUnblockedTCB);
700a781c: 9802         	ldr	r0, [sp, #0x8]
700a781e: 6ac0         	ldr	r0, [r0, #0x2c]
700a7820: f242 61ec    	movw	r1, #0x26ec
700a7824: f2c7 010b    	movt	r1, #0x700b
700a7828: 6809         	ldr	r1, [r1]
700a782a: 4288         	cmp	r0, r1
700a782c: d908         	bls	0x700a7840 <xTaskRemoveFromEventList+0x50> @ imm = #0x10
700a782e: e7ff         	b	0x700a7830 <xTaskRemoveFromEventList+0x40> @ imm = #-0x2
700a7830: 9802         	ldr	r0, [sp, #0x8]
700a7832: 6ac0         	ldr	r0, [r0, #0x2c]
700a7834: f242 61ec    	movw	r1, #0x26ec
700a7838: f2c7 010b    	movt	r1, #0x700b
700a783c: 6008         	str	r0, [r1]
700a783e: e7ff         	b	0x700a7840 <xTaskRemoveFromEventList+0x50> @ imm = #-0x2
700a7840: 9902         	ldr	r1, [sp, #0x8]
700a7842: 6ac8         	ldr	r0, [r1, #0x2c]
700a7844: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a7848: f244 40f8    	movw	r0, #0x44f8
700a784c: f2c7 0008    	movt	r0, #0x7008
700a7850: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a7854: 3104         	adds	r1, #0x4
700a7856: f006 fbc3    	bl	0x700adfe0 <vListInsertEnd> @ imm = #0x6786
;       prvResetNextTaskUnblockTime();
700a785a: f006 fb41    	bl	0x700adee0 <prvResetNextTaskUnblockTime> @ imm = #0x6682
;   } else {
700a785e: e009         	b	0x700a7874 <xTaskRemoveFromEventList+0x84> @ imm = #0x12
;     vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
700a7860: 9802         	ldr	r0, [sp, #0x8]
700a7862: f100 0118    	add.w	r1, r0, #0x18
700a7866: f245 10e0    	movw	r0, #0x51e0
700a786a: f2c7 0008    	movt	r0, #0x7008
700a786e: f006 fbb7    	bl	0x700adfe0 <vListInsertEnd> @ imm = #0x676e
700a7872: e7ff         	b	0x700a7874 <xTaskRemoveFromEventList+0x84> @ imm = #-0x2
;   if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
700a7874: 9802         	ldr	r0, [sp, #0x8]
700a7876: 6ac0         	ldr	r0, [r0, #0x2c]
700a7878: f242 61bc    	movw	r1, #0x26bc
700a787c: f2c7 010b    	movt	r1, #0x700b
700a7880: 6809         	ldr	r1, [r1]
700a7882: 6ac9         	ldr	r1, [r1, #0x2c]
700a7884: 4288         	cmp	r0, r1
700a7886: d908         	bls	0x700a789a <xTaskRemoveFromEventList+0xaa> @ imm = #0x10
700a7888: e7ff         	b	0x700a788a <xTaskRemoveFromEventList+0x9a> @ imm = #-0x2
700a788a: 2001         	movs	r0, #0x1
;     xReturn = pdTRUE;
700a788c: 9001         	str	r0, [sp, #0x4]
;     xYieldPending = pdTRUE;
700a788e: f242 7110    	movw	r1, #0x2710
700a7892: f2c7 010b    	movt	r1, #0x700b
700a7896: 6008         	str	r0, [r1]
;   } else {
700a7898: e002         	b	0x700a78a0 <xTaskRemoveFromEventList+0xb0> @ imm = #0x4
700a789a: 2000         	movs	r0, #0x0
;     xReturn = pdFALSE;
700a789c: 9001         	str	r0, [sp, #0x4]
700a789e: e7ff         	b	0x700a78a0 <xTaskRemoveFromEventList+0xb0> @ imm = #-0x2
;   return xReturn;
700a78a0: 9801         	ldr	r0, [sp, #0x4]
700a78a2: b004         	add	sp, #0x10
700a78a4: bd80         	pop	{r7, pc}
		...
700a78ae: 0000         	movs	r0, r0

700a78b0 <tm_thread_locking_benchmark_thread>:
; {
700a78b0: f242 64c4    	movw	r4, #0x26c4
700a78b4: f244 7578    	movw	r5, #0x4778
700a78b8: f2c7 040b    	movt	r4, #0x700b
700a78bc: f2c7 0508    	movt	r5, #0x7008
;       if (thread_locking_counter < ITERATION_COUNT)
700a78c0: 6820         	ldr	r0, [r4]
700a78c2: 281f         	cmp	r0, #0x1f
700a78c4: d804         	bhi	0x700a78d0 <tm_thread_locking_benchmark_thread+0x20> @ imm = #0x8
;          tm_pmu_profile_start(pmu_lock_numbers[thread_locking_counter]);
700a78c6: 6820         	ldr	r0, [r4]
700a78c8: eb05 1000    	add.w	r0, r5, r0, lsl #4
700a78cc: f008 f8e8    	bl	0x700afaa0 <tm_pmu_profile_start> @ imm = #0x81d0
;       tm_suspend_scheduler();
700a78d0: f008 f8f6    	bl	0x700afac0 <tm_suspend_scheduler> @ imm = #0x81ec
;       thread_locking_counter++;
700a78d4: 6820         	ldr	r0, [r4]
700a78d6: 1c41         	adds	r1, r0, #0x1
700a78d8: f44f 707a    	mov.w	r0, #0x3e8
700a78dc: 6021         	str	r1, [r4]
700a78de: bf00         	nop
;       for (int i = 0; i < 1000; i++)
700a78e0: 3832         	subs	r0, #0x32
;          __asm__ volatile("nop");
700a78e2: bf00         	nop
700a78e4: bf00         	nop
700a78e6: bf00         	nop
700a78e8: bf00         	nop
700a78ea: bf00         	nop
700a78ec: bf00         	nop
700a78ee: bf00         	nop
700a78f0: bf00         	nop
700a78f2: bf00         	nop
700a78f4: bf00         	nop
700a78f6: bf00         	nop
700a78f8: bf00         	nop
700a78fa: bf00         	nop
700a78fc: bf00         	nop
700a78fe: bf00         	nop
700a7900: bf00         	nop
700a7902: bf00         	nop
700a7904: bf00         	nop
700a7906: bf00         	nop
700a7908: bf00         	nop
700a790a: bf00         	nop
700a790c: bf00         	nop
700a790e: bf00         	nop
700a7910: bf00         	nop
700a7912: bf00         	nop
700a7914: bf00         	nop
700a7916: bf00         	nop
700a7918: bf00         	nop
700a791a: bf00         	nop
700a791c: bf00         	nop
700a791e: bf00         	nop
700a7920: bf00         	nop
700a7922: bf00         	nop
700a7924: bf00         	nop
700a7926: bf00         	nop
700a7928: bf00         	nop
700a792a: bf00         	nop
700a792c: bf00         	nop
700a792e: bf00         	nop
700a7930: bf00         	nop
700a7932: bf00         	nop
700a7934: bf00         	nop
700a7936: bf00         	nop
700a7938: bf00         	nop
700a793a: bf00         	nop
700a793c: bf00         	nop
700a793e: bf00         	nop
700a7940: bf00         	nop
700a7942: bf00         	nop
700a7944: bf00         	nop
;       for (int i = 0; i < 1000; i++)
700a7946: f47f afcb    	bne.w	0x700a78e0 <tm_thread_locking_benchmark_thread+0x30> @ imm = #-0x6a
;       tm_resume_scheduler();
700a794a: f008 f8b1    	bl	0x700afab0 <tm_resume_scheduler> @ imm = #0x8162
;       if (thread_locking_counter < ITERATION_COUNT + 1)
700a794e: 6820         	ldr	r0, [r4]
700a7950: 2821         	cmp	r0, #0x21
700a7952: f4bf afb5    	bhs.w	0x700a78c0 <tm_thread_locking_benchmark_thread+0x10> @ imm = #-0x96
;          tm_pmu_profile_end(pmu_lock_numbers[thread_locking_counter - 1]);
700a7956: 6820         	ldr	r0, [r4]
700a7958: eb05 1000    	add.w	r0, r5, r0, lsl #4
700a795c: 3810         	subs	r0, #0x10
700a795e: f008 f88f    	bl	0x700afa80 <tm_pmu_profile_end> @ imm = #0x811e
700a7962: e7ad         	b	0x700a78c0 <tm_thread_locking_benchmark_thread+0x10> @ imm = #-0xa6
		...

700a7970 <Sciclient_getCurrentContext>:
; {
700a7970: b082         	sub	sp, #0x8
700a7972: f8ad 0006    	strh.w	r0, [sp, #0x6]
700a7976: 200f         	movs	r0, #0xf
;     uint32_t retVal = SCICLIENT_CONTEXT_MAX_NUM;
700a7978: 9000         	str	r0, [sp]
;     if((TISCI_MSG_BOOT_NOTIFICATION == messageType) ||
700a797a: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a797e: 280a         	cmp	r0, #0xa
700a7980: d03e         	beq	0x700a7a00 <Sciclient_getCurrentContext+0x90> @ imm = #0x7c
700a7982: e7ff         	b	0x700a7984 <Sciclient_getCurrentContext+0x14> @ imm = #-0x2
;        (TISCI_MSG_SEC_HANDOVER == messageType) ||
700a7984: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7988: f249 0130    	movw	r1, #0x9030
700a798c: 4288         	cmp	r0, r1
700a798e: d037         	beq	0x700a7a00 <Sciclient_getCurrentContext+0x90> @ imm = #0x6e
700a7990: e7ff         	b	0x700a7992 <Sciclient_getCurrentContext+0x22> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG == messageType) ||
700a7992: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7996: 280b         	cmp	r0, #0xb
700a7998: d032         	beq	0x700a7a00 <Sciclient_getCurrentContext+0x90> @ imm = #0x64
700a799a: e7ff         	b	0x700a799c <Sciclient_getCurrentContext+0x2c> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_RM == messageType) ||
700a799c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a79a0: 280c         	cmp	r0, #0xc
700a79a2: d02d         	beq	0x700a7a00 <Sciclient_getCurrentContext+0x90> @ imm = #0x5a
700a79a4: e7ff         	b	0x700a79a6 <Sciclient_getCurrentContext+0x36> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_SECURITY == messageType) ||
700a79a6: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a79aa: 280d         	cmp	r0, #0xd
700a79ac: d028         	beq	0x700a7a00 <Sciclient_getCurrentContext+0x90> @ imm = #0x50
700a79ae: e7ff         	b	0x700a79b0 <Sciclient_getCurrentContext+0x40> @ imm = #-0x2
;        (TISCI_MSG_KEY_WRITER == messageType) ||
700a79b0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a79b4: f249 0131    	movw	r1, #0x9031
700a79b8: 4288         	cmp	r0, r1
700a79ba: d021         	beq	0x700a7a00 <Sciclient_getCurrentContext+0x90> @ imm = #0x42
700a79bc: e7ff         	b	0x700a79be <Sciclient_getCurrentContext+0x4e> @ imm = #-0x2
;        (TISCI_MSG_READ_OTP_MMR == messageType) ||
700a79be: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a79c2: f249 0122    	movw	r1, #0x9022
700a79c6: 4288         	cmp	r0, r1
700a79c8: d01a         	beq	0x700a7a00 <Sciclient_getCurrentContext+0x90> @ imm = #0x34
700a79ca: e7ff         	b	0x700a79cc <Sciclient_getCurrentContext+0x5c> @ imm = #-0x2
;        (TISCI_MSG_WRITE_OTP_ROW == messageType) ||
700a79cc: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a79d0: f249 0123    	movw	r1, #0x9023
700a79d4: 4288         	cmp	r0, r1
700a79d6: d013         	beq	0x700a7a00 <Sciclient_getCurrentContext+0x90> @ imm = #0x26
700a79d8: e7ff         	b	0x700a79da <Sciclient_getCurrentContext+0x6a> @ imm = #-0x2
;        (TISCI_MSG_READ_SWREV == messageType) ||
700a79da: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a79de: f249 0133    	movw	r1, #0x9033
700a79e2: 4288         	cmp	r0, r1
700a79e4: d00c         	beq	0x700a7a00 <Sciclient_getCurrentContext+0x90> @ imm = #0x18
700a79e6: e7ff         	b	0x700a79e8 <Sciclient_getCurrentContext+0x78> @ imm = #-0x2
;        (TISCI_MSG_WRITE_SWREV == messageType) ||
700a79e8: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a79ec: f249 0132    	movw	r1, #0x9032
700a79f0: 4288         	cmp	r0, r1
700a79f2: d005         	beq	0x700a7a00 <Sciclient_getCurrentContext+0x90> @ imm = #0xa
700a79f4: e7ff         	b	0x700a79f6 <Sciclient_getCurrentContext+0x86> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_PM == messageType))
700a79f6: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
;     if((TISCI_MSG_BOOT_NOTIFICATION == messageType) ||
700a79fa: 280e         	cmp	r0, #0xe
700a79fc: d107         	bne	0x700a7a0e <Sciclient_getCurrentContext+0x9e> @ imm = #0xe
700a79fe: e7ff         	b	0x700a7a00 <Sciclient_getCurrentContext+0x90> @ imm = #-0x2
;         retVal = gSciclientHandle.secureContextId;
700a7a00: f242 6008    	movw	r0, #0x2608
700a7a04: f2c7 000b    	movt	r0, #0x700b
700a7a08: 68c0         	ldr	r0, [r0, #0xc]
700a7a0a: 9000         	str	r0, [sp]
;     }
700a7a0c: e006         	b	0x700a7a1c <Sciclient_getCurrentContext+0xac> @ imm = #0xc
;         retVal = gSciclientHandle.nonSecureContextId;
700a7a0e: f242 6008    	movw	r0, #0x2608
700a7a12: f2c7 000b    	movt	r0, #0x700b
700a7a16: 6900         	ldr	r0, [r0, #0x10]
700a7a18: 9000         	str	r0, [sp]
700a7a1a: e7ff         	b	0x700a7a1c <Sciclient_getCurrentContext+0xac> @ imm = #-0x2
;     return retVal;
700a7a1c: 9800         	ldr	r0, [sp]
700a7a1e: b002         	add	sp, #0x8
700a7a20: 4770         	bx	lr
		...
700a7a2e: 0000         	movs	r0, r0

700a7a30 <UART_init>:
; {
700a7a30: b580         	push	{r7, lr}
700a7a32: b086         	sub	sp, #0x18
700a7a34: 2000         	movs	r0, #0x0
;     for (cnt = 0U; cnt < gUartConfigNum; cnt++)
700a7a36: 9004         	str	r0, [sp, #0x10]
700a7a38: e7ff         	b	0x700a7a3a <UART_init+0xa> @ imm = #-0x2
700a7a3a: 9804         	ldr	r0, [sp, #0x10]
700a7a3c: f242 61ac    	movw	r1, #0x26ac
700a7a40: f2c7 010b    	movt	r1, #0x700b
700a7a44: 6809         	ldr	r1, [r1]
700a7a46: 4288         	cmp	r0, r1
700a7a48: d236         	bhs	0x700a7ab8 <UART_init+0x88> @ imm = #0x6c
700a7a4a: e7ff         	b	0x700a7a4c <UART_init+0x1c> @ imm = #-0x2
;         object = gUartConfig[cnt].object;
700a7a4c: 9904         	ldr	r1, [sp, #0x10]
700a7a4e: f242 6064    	movw	r0, #0x2664
700a7a52: f2c7 000b    	movt	r0, #0x700b
700a7a56: 9002         	str	r0, [sp, #0x8]
700a7a58: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a7a5c: 6840         	ldr	r0, [r0, #0x4]
700a7a5e: 9003         	str	r0, [sp, #0xc]
;         DebugP_assert(NULL_PTR != object);
700a7a60: 9803         	ldr	r0, [sp, #0xc]
700a7a62: 2800         	cmp	r0, #0x0
700a7a64: bf18         	it	ne
700a7a66: 2001         	movne	r0, #0x1
700a7a68: f641 41b2    	movw	r1, #0x1cb2
700a7a6c: f2c7 010b    	movt	r1, #0x700b
700a7a70: 466a         	mov	r2, sp
700a7a72: 6011         	str	r1, [r2]
700a7a74: f641 41c5    	movw	r1, #0x1cc5
700a7a78: f2c7 010b    	movt	r1, #0x700b
700a7a7c: f641 6216    	movw	r2, #0x1e16
700a7a80: f2c7 020b    	movt	r2, #0x700b
700a7a84: 23bf         	movs	r3, #0xbf
700a7a86: f002 ffd3    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x2fa6
;         (void)memset(object, 0, sizeof(UART_Object));
700a7a8a: 9803         	ldr	r0, [sp, #0xc]
700a7a8c: f44f 715a    	mov.w	r1, #0x368
700a7a90: f7f3 eb00    	blx	0x7009b094 <__aeabi_memclr8> @ imm = #-0xca00
700a7a94: 9802         	ldr	r0, [sp, #0x8]
;         gUartConfig[cnt].attrs->baseAddr = (uint32_t) AddrTranslateP_getLocalAddr((uint64_t)gUartConfig[cnt].attrs->baseAddr);
700a7a96: 9904         	ldr	r1, [sp, #0x10]
700a7a98: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
700a7a9c: 6800         	ldr	r0, [r0]
700a7a9e: 2100         	movs	r1, #0x0
700a7aa0: f7fd ff2e    	bl	0x700a5900 <AddrTranslateP_getLocalAddr> @ imm = #-0x21a4
700a7aa4: 9902         	ldr	r1, [sp, #0x8]
700a7aa6: 9a04         	ldr	r2, [sp, #0x10]
700a7aa8: f851 1032    	ldr.w	r1, [r1, r2, lsl #3]
700a7aac: 6008         	str	r0, [r1]
;     }
700a7aae: e7ff         	b	0x700a7ab0 <UART_init+0x80> @ imm = #-0x2
;     for (cnt = 0U; cnt < gUartConfigNum; cnt++)
700a7ab0: 9804         	ldr	r0, [sp, #0x10]
700a7ab2: 3001         	adds	r0, #0x1
700a7ab4: 9004         	str	r0, [sp, #0x10]
700a7ab6: e7c0         	b	0x700a7a3a <UART_init+0xa> @ imm = #-0x80
;     status = SemaphoreP_constructMutex(&gUartDrvObj.lockObj);
700a7ab8: f242 30e8    	movw	r0, #0x23e8
700a7abc: f2c7 000b    	movt	r0, #0x700b
700a7ac0: 3004         	adds	r0, #0x4
700a7ac2: f003 fc8d    	bl	0x700ab3e0 <SemaphoreP_constructMutex> @ imm = #0x391a
700a7ac6: 9005         	str	r0, [sp, #0x14]
;     if(SystemP_SUCCESS == status)
700a7ac8: 9805         	ldr	r0, [sp, #0x14]
700a7aca: b938         	cbnz	r0, 0x700a7adc <UART_init+0xac> @ imm = #0xe
700a7acc: e7ff         	b	0x700a7ace <UART_init+0x9e> @ imm = #-0x2
;         gUartDrvObj.lock = &gUartDrvObj.lockObj;
700a7ace: f242 31e8    	movw	r1, #0x23e8
700a7ad2: f2c7 010b    	movt	r1, #0x700b
700a7ad6: 1d08         	adds	r0, r1, #0x4
700a7ad8: 6008         	str	r0, [r1]
;     }
700a7ada: e7ff         	b	0x700a7adc <UART_init+0xac> @ imm = #-0x2
;     return;
700a7adc: b006         	add	sp, #0x18
700a7ade: bd80         	pop	{r7, pc}

700a7ae0 <Udma_chCheckParams>:
; {
700a7ae0: b084         	sub	sp, #0x10
700a7ae2: 9003         	str	r0, [sp, #0xc]
700a7ae4: 9102         	str	r1, [sp, #0x8]
700a7ae6: 9201         	str	r2, [sp, #0x4]
700a7ae8: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a7aea: 9000         	str	r0, [sp]
;     if((chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA)
700a7aec: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a7af0: 0700         	lsls	r0, r0, #0x1c
700a7af2: 2800         	cmp	r0, #0x0
700a7af4: d513         	bpl	0x700a7b1e <Udma_chCheckParams+0x3e> @ imm = #0x26
700a7af6: e7ff         	b	0x700a7af8 <Udma_chCheckParams+0x18> @ imm = #-0x2
;         if((UDMA_DMA_CH_INVALID == chPrms->peerChNum) ||
700a7af8: 9801         	ldr	r0, [sp, #0x4]
700a7afa: 6840         	ldr	r0, [r0, #0x4]
700a7afc: f510 3f80    	cmn.w	r0, #0x10000
700a7b00: d008         	beq	0x700a7b14 <Udma_chCheckParams+0x34> @ imm = #0x10
700a7b02: e7ff         	b	0x700a7b04 <Udma_chCheckParams+0x24> @ imm = #-0x2
;            (UDMA_DMA_CH_NA == chPrms->peerChNum))
700a7b04: 9801         	ldr	r0, [sp, #0x4]
700a7b06: 6840         	ldr	r0, [r0, #0x4]
700a7b08: 2102         	movs	r1, #0x2
700a7b0a: f6cf 71ff    	movt	r1, #0xffff
;         if((UDMA_DMA_CH_INVALID == chPrms->peerChNum) ||
700a7b0e: 4288         	cmp	r0, r1
700a7b10: d104         	bne	0x700a7b1c <Udma_chCheckParams+0x3c> @ imm = #0x8
700a7b12: e7ff         	b	0x700a7b14 <Udma_chCheckParams+0x34> @ imm = #-0x2
700a7b14: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7b18: 9000         	str	r0, [sp]
;         }
700a7b1a: e7ff         	b	0x700a7b1c <Udma_chCheckParams+0x3c> @ imm = #-0x2
;     }
700a7b1c: e7ff         	b	0x700a7b1e <Udma_chCheckParams+0x3e> @ imm = #-0x2
;     if((chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
700a7b1e: f89d 0009    	ldrb.w	r0, [sp, #0x9]
700a7b22: 07c0         	lsls	r0, r0, #0x1f
700a7b24: b388         	cbz	r0, 0x700a7b8a <Udma_chCheckParams+0xaa> @ imm = #0x62
700a7b26: e7ff         	b	0x700a7b28 <Udma_chCheckParams+0x48> @ imm = #-0x2
;         if(UDMA_MAPPED_GROUP_INVALID == chPrms->mappedChGrp)
700a7b28: 9801         	ldr	r0, [sp, #0x4]
700a7b2a: 6880         	ldr	r0, [r0, #0x8]
700a7b2c: 2104         	movs	r1, #0x4
700a7b2e: f6cf 71ff    	movt	r1, #0xffff
700a7b32: 4288         	cmp	r0, r1
700a7b34: d104         	bne	0x700a7b40 <Udma_chCheckParams+0x60> @ imm = #0x8
700a7b36: e7ff         	b	0x700a7b38 <Udma_chCheckParams+0x58> @ imm = #-0x2
700a7b38: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7b3c: 9000         	str	r0, [sp]
;         }
700a7b3e: e7ff         	b	0x700a7b40 <Udma_chCheckParams+0x60> @ imm = #-0x2
;         if((chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a7b40: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a7b44: 07c0         	lsls	r0, r0, #0x1f
700a7b46: b150         	cbz	r0, 0x700a7b5e <Udma_chCheckParams+0x7e> @ imm = #0x14
700a7b48: e7ff         	b	0x700a7b4a <Udma_chCheckParams+0x6a> @ imm = #-0x2
;             if(chPrms->mappedChGrp >= UDMA_NUM_MAPPED_TX_GROUP)
700a7b4a: 9801         	ldr	r0, [sp, #0x4]
700a7b4c: 6880         	ldr	r0, [r0, #0x8]
700a7b4e: 2804         	cmp	r0, #0x4
700a7b50: d304         	blo	0x700a7b5c <Udma_chCheckParams+0x7c> @ imm = #0x8
700a7b52: e7ff         	b	0x700a7b54 <Udma_chCheckParams+0x74> @ imm = #-0x2
700a7b54: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a7b58: 9000         	str	r0, [sp]
;             }
700a7b5a: e7ff         	b	0x700a7b5c <Udma_chCheckParams+0x7c> @ imm = #-0x2
;         }
700a7b5c: e7ff         	b	0x700a7b5e <Udma_chCheckParams+0x7e> @ imm = #-0x2
;         if((chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a7b5e: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a7b62: 0780         	lsls	r0, r0, #0x1e
700a7b64: 2800         	cmp	r0, #0x0
700a7b66: d50f         	bpl	0x700a7b88 <Udma_chCheckParams+0xa8> @ imm = #0x1e
700a7b68: e7ff         	b	0x700a7b6a <Udma_chCheckParams+0x8a> @ imm = #-0x2
;             if((chPrms->mappedChGrp < UDMA_NUM_MAPPED_TX_GROUP) ||
700a7b6a: 9801         	ldr	r0, [sp, #0x4]
700a7b6c: 6880         	ldr	r0, [r0, #0x8]
700a7b6e: 2804         	cmp	r0, #0x4
700a7b70: d305         	blo	0x700a7b7e <Udma_chCheckParams+0x9e> @ imm = #0xa
700a7b72: e7ff         	b	0x700a7b74 <Udma_chCheckParams+0x94> @ imm = #-0x2
;                (chPrms->mappedChGrp >= (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
700a7b74: 9801         	ldr	r0, [sp, #0x4]
700a7b76: 6880         	ldr	r0, [r0, #0x8]
;             if((chPrms->mappedChGrp < UDMA_NUM_MAPPED_TX_GROUP) ||
700a7b78: 2808         	cmp	r0, #0x8
700a7b7a: d304         	blo	0x700a7b86 <Udma_chCheckParams+0xa6> @ imm = #0x8
700a7b7c: e7ff         	b	0x700a7b7e <Udma_chCheckParams+0x9e> @ imm = #-0x2
700a7b7e: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a7b82: 9000         	str	r0, [sp]
;             }
700a7b84: e7ff         	b	0x700a7b86 <Udma_chCheckParams+0xa6> @ imm = #-0x2
;         }
700a7b86: e7ff         	b	0x700a7b88 <Udma_chCheckParams+0xa8> @ imm = #-0x2
;     }
700a7b88: e7ff         	b	0x700a7b8a <Udma_chCheckParams+0xaa> @ imm = #-0x2
;     return (retVal);
700a7b8a: 9800         	ldr	r0, [sp]
700a7b8c: b004         	add	sp, #0x10
700a7b8e: 4770         	bx	lr

700a7b90 <Udma_getMappedChRingAttributes>:
; {
700a7b90: b087         	sub	sp, #0x1c
700a7b92: 9006         	str	r0, [sp, #0x18]
700a7b94: 9105         	str	r1, [sp, #0x14]
700a7b96: 9204         	str	r2, [sp, #0x10]
700a7b98: 9303         	str	r3, [sp, #0xc]
700a7b9a: 2000         	movs	r0, #0x0
;     uint32_t index = 0U;
700a7b9c: 9001         	str	r0, [sp, #0x4]
;     int32_t retVal = UDMA_SOK;
700a7b9e: 9000         	str	r0, [sp]
;     if(mappedGrp < UDMA_NUM_MAPPED_TX_GROUP) /* Mapped TX Channel */
700a7ba0: 9805         	ldr	r0, [sp, #0x14]
700a7ba2: 2803         	cmp	r0, #0x3
700a7ba4: d81e         	bhi	0x700a7be4 <Udma_getMappedChRingAttributes+0x54> @ imm = #0x3c
700a7ba6: e7ff         	b	0x700a7ba8 <Udma_getMappedChRingAttributes+0x18> @ imm = #-0x2
;         if((chNum < CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START) ||
700a7ba8: 9804         	ldr	r0, [sp, #0x10]
700a7baa: 2810         	cmp	r0, #0x10
700a7bac: d304         	blo	0x700a7bb8 <Udma_getMappedChRingAttributes+0x28> @ imm = #0x8
700a7bae: e7ff         	b	0x700a7bb0 <Udma_getMappedChRingAttributes+0x20> @ imm = #-0x2
;            (chNum >= CSL_DMSS_PKTDMA_NUM_TX_CHANS))
700a7bb0: 9804         	ldr	r0, [sp, #0x10]
;         if((chNum < CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START) ||
700a7bb2: 282a         	cmp	r0, #0x2a
700a7bb4: d304         	blo	0x700a7bc0 <Udma_getMappedChRingAttributes+0x30> @ imm = #0x8
700a7bb6: e7ff         	b	0x700a7bb8 <Udma_getMappedChRingAttributes+0x28> @ imm = #-0x2
700a7bb8: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7bbc: 9000         	str	r0, [sp]
;         }
700a7bbe: e7ff         	b	0x700a7bc0 <Udma_getMappedChRingAttributes+0x30> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
700a7bc0: 9800         	ldr	r0, [sp]
700a7bc2: b970         	cbnz	r0, 0x700a7be2 <Udma_getMappedChRingAttributes+0x52> @ imm = #0x1c
700a7bc4: e7ff         	b	0x700a7bc6 <Udma_getMappedChRingAttributes+0x36> @ imm = #-0x2
;             index = chNum - CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START;
700a7bc6: 9804         	ldr	r0, [sp, #0x10]
700a7bc8: 3810         	subs	r0, #0x10
700a7bca: 9001         	str	r0, [sp, #0x4]
;             mappedChRingAttributes = &gUdmaTxMappedChRingAttributes[index];
700a7bcc: 9801         	ldr	r0, [sp, #0x4]
700a7bce: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a7bd2: f241 10c8    	movw	r0, #0x11c8
700a7bd6: f2c7 000b    	movt	r0, #0x700b
700a7bda: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7bde: 9002         	str	r0, [sp, #0x8]
;         }
700a7be0: e7ff         	b	0x700a7be2 <Udma_getMappedChRingAttributes+0x52> @ imm = #-0x2
;     }
700a7be2: e01d         	b	0x700a7c20 <Udma_getMappedChRingAttributes+0x90> @ imm = #0x3a
;         if((chNum < CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START) ||
700a7be4: 9804         	ldr	r0, [sp, #0x10]
700a7be6: 2810         	cmp	r0, #0x10
700a7be8: d304         	blo	0x700a7bf4 <Udma_getMappedChRingAttributes+0x64> @ imm = #0x8
700a7bea: e7ff         	b	0x700a7bec <Udma_getMappedChRingAttributes+0x5c> @ imm = #-0x2
;            (chNum >= CSL_DMSS_PKTDMA_NUM_RX_CHANS))
700a7bec: 9804         	ldr	r0, [sp, #0x10]
;         if((chNum < CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START) ||
700a7bee: 281d         	cmp	r0, #0x1d
700a7bf0: d304         	blo	0x700a7bfc <Udma_getMappedChRingAttributes+0x6c> @ imm = #0x8
700a7bf2: e7ff         	b	0x700a7bf4 <Udma_getMappedChRingAttributes+0x64> @ imm = #-0x2
700a7bf4: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7bf8: 9000         	str	r0, [sp]
;         }
700a7bfa: e7ff         	b	0x700a7bfc <Udma_getMappedChRingAttributes+0x6c> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
700a7bfc: 9800         	ldr	r0, [sp]
700a7bfe: b970         	cbnz	r0, 0x700a7c1e <Udma_getMappedChRingAttributes+0x8e> @ imm = #0x1c
700a7c00: e7ff         	b	0x700a7c02 <Udma_getMappedChRingAttributes+0x72> @ imm = #-0x2
;             index = chNum - CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START;
700a7c02: 9804         	ldr	r0, [sp, #0x10]
700a7c04: 3810         	subs	r0, #0x10
700a7c06: 9001         	str	r0, [sp, #0x4]
;             mappedChRingAttributes = &gUdmaRxMappedChRingAttributes[index];
700a7c08: 9801         	ldr	r0, [sp, #0x4]
700a7c0a: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a7c0e: f241 4004    	movw	r0, #0x1404
700a7c12: f2c7 000b    	movt	r0, #0x700b
700a7c16: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7c1a: 9002         	str	r0, [sp, #0x8]
;         }
700a7c1c: e7ff         	b	0x700a7c1e <Udma_getMappedChRingAttributes+0x8e> @ imm = #-0x2
700a7c1e: e7ff         	b	0x700a7c20 <Udma_getMappedChRingAttributes+0x90> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7c20: 9800         	ldr	r0, [sp]
700a7c22: b948         	cbnz	r0, 0x700a7c38 <Udma_getMappedChRingAttributes+0xa8> @ imm = #0x12
700a7c24: e7ff         	b	0x700a7c26 <Udma_getMappedChRingAttributes+0x96> @ imm = #-0x2
;         (void) memcpy(chAttr, mappedChRingAttributes, sizeof (Udma_MappedChRingAttributes));
700a7c26: 9903         	ldr	r1, [sp, #0xc]
700a7c28: 9b02         	ldr	r3, [sp, #0x8]
700a7c2a: 6818         	ldr	r0, [r3]
700a7c2c: 685a         	ldr	r2, [r3, #0x4]
700a7c2e: 689b         	ldr	r3, [r3, #0x8]
700a7c30: 608b         	str	r3, [r1, #0x8]
700a7c32: 604a         	str	r2, [r1, #0x4]
700a7c34: 6008         	str	r0, [r1]
;     }
700a7c36: e7ff         	b	0x700a7c38 <Udma_getMappedChRingAttributes+0xa8> @ imm = #-0x2
;     return(retVal);
700a7c38: 9800         	ldr	r0, [sp]
700a7c3a: b007         	add	sp, #0x1c
700a7c3c: 4770         	bx	lr
700a7c3e: 0000         	movs	r0, r0

700a7c40 <prvUnlockQueue>:
; {
700a7c40: b580         	push	{r7, lr}
700a7c42: b082         	sub	sp, #0x8
700a7c44: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700a7c46: f006 fc43    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0x6886
;         int8_t cTxLock = pxQueue->cTxLock;
700a7c4a: 9801         	ldr	r0, [sp, #0x4]
700a7c4c: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a7c50: f88d 0003    	strb.w	r0, [sp, #0x3]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
700a7c54: e7ff         	b	0x700a7c56 <prvUnlockQueue+0x16> @ imm = #-0x2
700a7c56: f99d 0003    	ldrsb.w	r0, [sp, #0x3]
700a7c5a: 2801         	cmp	r0, #0x1
700a7c5c: db16         	blt	0x700a7c8c <prvUnlockQueue+0x4c> @ imm = #0x2c
700a7c5e: e7ff         	b	0x700a7c60 <prvUnlockQueue+0x20> @ imm = #-0x2
;                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a7c60: 9801         	ldr	r0, [sp, #0x4]
700a7c62: 6a40         	ldr	r0, [r0, #0x24]
700a7c64: b158         	cbz	r0, 0x700a7c7e <prvUnlockQueue+0x3e> @ imm = #0x16
700a7c66: e7ff         	b	0x700a7c68 <prvUnlockQueue+0x28> @ imm = #-0x2
;                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a7c68: 9801         	ldr	r0, [sp, #0x4]
700a7c6a: 3024         	adds	r0, #0x24
700a7c6c: f7ff fdc0    	bl	0x700a77f0 <xTaskRemoveFromEventList> @ imm = #-0x480
700a7c70: b118         	cbz	r0, 0x700a7c7a <prvUnlockQueue+0x3a> @ imm = #0x6
700a7c72: e7ff         	b	0x700a7c74 <prvUnlockQueue+0x34> @ imm = #-0x2
;                             vTaskMissedYield();
700a7c74: f007 fe34    	bl	0x700af8e0 <vTaskMissedYield> @ imm = #0x7c68
;                         }
700a7c78: e000         	b	0x700a7c7c <prvUnlockQueue+0x3c> @ imm = #0x0
700a7c7a: e7ff         	b	0x700a7c7c <prvUnlockQueue+0x3c> @ imm = #-0x2
;                     }
700a7c7c: e000         	b	0x700a7c80 <prvUnlockQueue+0x40> @ imm = #0x0
;                         break;
700a7c7e: e005         	b	0x700a7c8c <prvUnlockQueue+0x4c> @ imm = #0xa
;             --cTxLock;
700a7c80: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a7c84: 3801         	subs	r0, #0x1
700a7c86: f88d 0003    	strb.w	r0, [sp, #0x3]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
700a7c8a: e7e4         	b	0x700a7c56 <prvUnlockQueue+0x16> @ imm = #-0x38
;         pxQueue->cTxLock = queueUNLOCKED;
700a7c8c: 9901         	ldr	r1, [sp, #0x4]
700a7c8e: 20ff         	movs	r0, #0xff
700a7c90: f881 0045    	strb.w	r0, [r1, #0x45]
;     taskEXIT_CRITICAL();
700a7c94: f005 fcdc    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0x59b8
;     taskENTER_CRITICAL();
700a7c98: f006 fc1a    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0x6834
;         int8_t cRxLock = pxQueue->cRxLock;
700a7c9c: 9801         	ldr	r0, [sp, #0x4]
700a7c9e: f890 0044    	ldrb.w	r0, [r0, #0x44]
700a7ca2: f88d 0002    	strb.w	r0, [sp, #0x2]
;         while( cRxLock > queueLOCKED_UNMODIFIED )
700a7ca6: e7ff         	b	0x700a7ca8 <prvUnlockQueue+0x68> @ imm = #-0x2
700a7ca8: f99d 0002    	ldrsb.w	r0, [sp, #0x2]
700a7cac: 2801         	cmp	r0, #0x1
700a7cae: db16         	blt	0x700a7cde <prvUnlockQueue+0x9e> @ imm = #0x2c
700a7cb0: e7ff         	b	0x700a7cb2 <prvUnlockQueue+0x72> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a7cb2: 9801         	ldr	r0, [sp, #0x4]
700a7cb4: 6900         	ldr	r0, [r0, #0x10]
700a7cb6: b180         	cbz	r0, 0x700a7cda <prvUnlockQueue+0x9a> @ imm = #0x20
700a7cb8: e7ff         	b	0x700a7cba <prvUnlockQueue+0x7a> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a7cba: 9801         	ldr	r0, [sp, #0x4]
700a7cbc: 3010         	adds	r0, #0x10
700a7cbe: f7ff fd97    	bl	0x700a77f0 <xTaskRemoveFromEventList> @ imm = #-0x4d2
700a7cc2: b118         	cbz	r0, 0x700a7ccc <prvUnlockQueue+0x8c> @ imm = #0x6
700a7cc4: e7ff         	b	0x700a7cc6 <prvUnlockQueue+0x86> @ imm = #-0x2
;                     vTaskMissedYield();
700a7cc6: f007 fe0b    	bl	0x700af8e0 <vTaskMissedYield> @ imm = #0x7c16
;                 }
700a7cca: e000         	b	0x700a7cce <prvUnlockQueue+0x8e> @ imm = #0x0
700a7ccc: e7ff         	b	0x700a7cce <prvUnlockQueue+0x8e> @ imm = #-0x2
;                 --cRxLock;
700a7cce: f89d 0002    	ldrb.w	r0, [sp, #0x2]
700a7cd2: 3801         	subs	r0, #0x1
700a7cd4: f88d 0002    	strb.w	r0, [sp, #0x2]
;             }
700a7cd8: e000         	b	0x700a7cdc <prvUnlockQueue+0x9c> @ imm = #0x0
;                 break;
700a7cda: e000         	b	0x700a7cde <prvUnlockQueue+0x9e> @ imm = #0x0
;         while( cRxLock > queueLOCKED_UNMODIFIED )
700a7cdc: e7e4         	b	0x700a7ca8 <prvUnlockQueue+0x68> @ imm = #-0x38
;         pxQueue->cRxLock = queueUNLOCKED;
700a7cde: 9901         	ldr	r1, [sp, #0x4]
700a7ce0: 20ff         	movs	r0, #0xff
700a7ce2: f881 0044    	strb.w	r0, [r1, #0x44]
;     taskEXIT_CRITICAL();
700a7ce6: f005 fcb3    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0x5966
; }
700a7cea: b002         	add	sp, #0x8
700a7cec: bd80         	pop	{r7, pc}
700a7cee: 0000         	movs	r0, r0

700a7cf0 <SemaphoreP_constructBinary>:
; {
700a7cf0: b580         	push	{r7, lr}
700a7cf2: b086         	sub	sp, #0x18
700a7cf4: 9005         	str	r0, [sp, #0x14]
700a7cf6: 9104         	str	r1, [sp, #0x10]
700a7cf8: 2000         	movs	r0, #0x0
;     SemaphoreP_Struct *pSemaphore = NULL;
700a7cfa: 9003         	str	r0, [sp, #0xc]
700a7cfc: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700a7d00: 9002         	str	r0, [sp, #0x8]
;     DebugP_assert(sizeof(SemaphoreP_Struct) <= sizeof(SemaphoreP_Object) );
700a7d02: f241 60e6    	movw	r0, #0x16e6
700a7d06: f2c7 000b    	movt	r0, #0x700b
700a7d0a: 4669         	mov	r1, sp
700a7d0c: 6008         	str	r0, [r1]
700a7d0e: f641 11a8    	movw	r1, #0x19a8
700a7d12: f2c7 010b    	movt	r1, #0x700b
700a7d16: f641 3234    	movw	r2, #0x1b34
700a7d1a: f2c7 020b    	movt	r2, #0x700b
700a7d1e: 2001         	movs	r0, #0x1
700a7d20: 2332         	movs	r3, #0x32
700a7d22: f002 fe85    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x2d0a
;     if(obj != NULL)
700a7d26: 9805         	ldr	r0, [sp, #0x14]
700a7d28: b128         	cbz	r0, 0x700a7d36 <SemaphoreP_constructBinary+0x46> @ imm = #0xa
700a7d2a: e7ff         	b	0x700a7d2c <SemaphoreP_constructBinary+0x3c> @ imm = #-0x2
;         pSemaphore = (SemaphoreP_Struct *)obj;
700a7d2c: 9805         	ldr	r0, [sp, #0x14]
700a7d2e: 9003         	str	r0, [sp, #0xc]
700a7d30: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700a7d32: 9002         	str	r0, [sp, #0x8]
;     }
700a7d34: e7ff         	b	0x700a7d36 <SemaphoreP_constructBinary+0x46> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
700a7d36: 9802         	ldr	r0, [sp, #0x8]
700a7d38: bb68         	cbnz	r0, 0x700a7d96 <SemaphoreP_constructBinary+0xa6> @ imm = #0x5a
700a7d3a: e7ff         	b	0x700a7d3c <SemaphoreP_constructBinary+0x4c> @ imm = #-0x2
;         pSemaphore->isRecursiveMutex = 0;
700a7d3c: 9803         	ldr	r0, [sp, #0xc]
700a7d3e: 2200         	movs	r2, #0x0
700a7d40: 6542         	str	r2, [r0, #0x54]
;         pSemaphore->semHndl = xSemaphoreCreateBinaryStatic(&pSemaphore->semObj);
700a7d42: 9b03         	ldr	r3, [sp, #0xc]
700a7d44: 4669         	mov	r1, sp
700a7d46: 2003         	movs	r0, #0x3
700a7d48: 6008         	str	r0, [r1]
700a7d4a: 2001         	movs	r0, #0x1
700a7d4c: 4611         	mov	r1, r2
700a7d4e: f005 faf7    	bl	0x700ad340 <xQueueGenericCreateStatic> @ imm = #0x55ee
700a7d52: 9903         	ldr	r1, [sp, #0xc]
700a7d54: 6508         	str	r0, [r1, #0x50]
;         if( pSemaphore->semHndl == NULL )
700a7d56: 9803         	ldr	r0, [sp, #0xc]
700a7d58: 6d00         	ldr	r0, [r0, #0x50]
700a7d5a: b920         	cbnz	r0, 0x700a7d66 <SemaphoreP_constructBinary+0x76> @ imm = #0x8
700a7d5c: e7ff         	b	0x700a7d5e <SemaphoreP_constructBinary+0x6e> @ imm = #-0x2
700a7d5e: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
700a7d62: 9002         	str	r0, [sp, #0x8]
;         }
700a7d64: e016         	b	0x700a7d94 <SemaphoreP_constructBinary+0xa4> @ imm = #0x2c
;             vQueueAddToRegistry(pSemaphore->semHndl, "Binary Sem (DPL)");
700a7d66: 9803         	ldr	r0, [sp, #0xc]
700a7d68: 6d00         	ldr	r0, [r0, #0x50]
700a7d6a: f641 5174    	movw	r1, #0x1d74
700a7d6e: f2c7 010b    	movt	r1, #0x700b
700a7d72: f005 f855    	bl	0x700ace20 <vQueueAddToRegistry> @ imm = #0x50aa
;             if(initCount == 1U)
700a7d76: 9804         	ldr	r0, [sp, #0x10]
700a7d78: 2801         	cmp	r0, #0x1
700a7d7a: d108         	bne	0x700a7d8e <SemaphoreP_constructBinary+0x9e> @ imm = #0x10
700a7d7c: e7ff         	b	0x700a7d7e <SemaphoreP_constructBinary+0x8e> @ imm = #-0x2
;                 (void)xSemaphoreGive(pSemaphore->semHndl);
700a7d7e: 9803         	ldr	r0, [sp, #0xc]
700a7d80: 6d00         	ldr	r0, [r0, #0x50]
700a7d82: 2300         	movs	r3, #0x0
700a7d84: 4619         	mov	r1, r3
700a7d86: 461a         	mov	r2, r3
700a7d88: f7fb f9b2    	bl	0x700a30f0 <xQueueGenericSend> @ imm = #-0x4c9c
;             }
700a7d8c: e7ff         	b	0x700a7d8e <SemaphoreP_constructBinary+0x9e> @ imm = #-0x2
700a7d8e: 2000         	movs	r0, #0x0
;             status = SystemP_SUCCESS;
700a7d90: 9002         	str	r0, [sp, #0x8]
700a7d92: e7ff         	b	0x700a7d94 <SemaphoreP_constructBinary+0xa4> @ imm = #-0x2
;     }
700a7d94: e7ff         	b	0x700a7d96 <SemaphoreP_constructBinary+0xa6> @ imm = #-0x2
;     return status;
700a7d96: 9802         	ldr	r0, [sp, #0x8]
700a7d98: b006         	add	sp, #0x18
700a7d9a: bd80         	pop	{r7, pc}
700a7d9c: 0000         	movs	r0, r0
700a7d9e: 0000         	movs	r0, r0

700a7da0 <UdmaChRxPrms_init>:
; {
700a7da0: b083         	sub	sp, #0xc
700a7da2: 9002         	str	r0, [sp, #0x8]
700a7da4: 9101         	str	r1, [sp, #0x4]
;     if(NULL_PTR != rxPrms)
700a7da6: 9802         	ldr	r0, [sp, #0x8]
700a7da8: 2800         	cmp	r0, #0x0
700a7daa: d04d         	beq	0x700a7e48 <UdmaChRxPrms_init+0xa8> @ imm = #0x9a
700a7dac: e7ff         	b	0x700a7dae <UdmaChRxPrms_init+0xe> @ imm = #-0x2
;         rxPrms->pauseOnError        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERROR_DISABLED;
700a7dae: 9902         	ldr	r1, [sp, #0x8]
700a7db0: 2000         	movs	r0, #0x0
700a7db2: 7008         	strb	r0, [r1]
;         rxPrms->addrType            = TISCI_MSG_VALUE_RM_UDMAP_CH_ATYPE_PHYS;
700a7db4: 9902         	ldr	r1, [sp, #0x8]
700a7db6: 7048         	strb	r0, [r1, #0x1]
;         rxPrms->chanType            = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_PACKET;
700a7db8: 9902         	ldr	r1, [sp, #0x8]
700a7dba: 2002         	movs	r0, #0x2
700a7dbc: 7088         	strb	r0, [r1, #0x2]
;         if((chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a7dbe: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a7dc2: 0740         	lsls	r0, r0, #0x1d
700a7dc4: 2800         	cmp	r0, #0x0
700a7dc6: d504         	bpl	0x700a7dd2 <UdmaChRxPrms_init+0x32> @ imm = #0x8
700a7dc8: e7ff         	b	0x700a7dca <UdmaChRxPrms_init+0x2a> @ imm = #-0x2
;             rxPrms->chanType        = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_3P_BLOCK_REF;
700a7dca: 9902         	ldr	r1, [sp, #0x8]
700a7dcc: 200c         	movs	r0, #0xc
700a7dce: 7088         	strb	r0, [r1, #0x2]
;         }
700a7dd0: e7ff         	b	0x700a7dd2 <UdmaChRxPrms_init+0x32> @ imm = #-0x2
;         rxPrms->fetchWordSize       = 16U;  /* sizeof(CSL_UdmapTR15) / sizeof(uint32_t) */
700a7dd2: 9902         	ldr	r1, [sp, #0x8]
700a7dd4: 2010         	movs	r0, #0x10
700a7dd6: 8088         	strh	r0, [r1, #0x4]
;         rxPrms->busPriority         = UDMA_DEFAULT_RX_CH_BUS_PRIORITY;
700a7dd8: 9902         	ldr	r1, [sp, #0x8]
700a7dda: 2004         	movs	r0, #0x4
700a7ddc: 7188         	strb	r0, [r1, #0x6]
;         rxPrms->busQos              = UDMA_DEFAULT_RX_CH_BUS_QOS;
700a7dde: 9902         	ldr	r1, [sp, #0x8]
700a7de0: 71c8         	strb	r0, [r1, #0x7]
;         rxPrms->busOrderId          = UDMA_DEFAULT_RX_CH_BUS_ORDERID;
700a7de2: 9802         	ldr	r0, [sp, #0x8]
700a7de4: 2100         	movs	r1, #0x0
700a7de6: 9100         	str	r1, [sp]
700a7de8: 7201         	strb	r1, [r0, #0x8]
;         rxPrms->dmaPriority         = UDMA_DEFAULT_RX_CH_DMA_PRIORITY;
700a7dea: 9a02         	ldr	r2, [sp, #0x8]
700a7dec: 2001         	movs	r0, #0x1
700a7dee: 7250         	strb	r0, [r2, #0x9]
;         rxPrms->flowIdFwRangeStart  = 0U;       /* Reset value - to use default flow */
700a7df0: 9a02         	ldr	r2, [sp, #0x8]
700a7df2: 8151         	strh	r1, [r2, #0xa]
;         rxPrms->flowIdFwRangeCnt    = 0U;       /* Reset value - to use default flow */
700a7df4: 9a02         	ldr	r2, [sp, #0x8]
700a7df6: 8191         	strh	r1, [r2, #0xc]
;         rxPrms->flowEInfoPresent    = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_EINFO_NOT_PRESENT;       /* Default no EINFO */
700a7df8: 9a02         	ldr	r2, [sp, #0x8]
700a7dfa: 7391         	strb	r1, [r2, #0xe]
;         rxPrms->flowPsInfoPresent   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PSINFO_NOT_PRESENT;      /* Default no PSINFO */
700a7dfc: 9a02         	ldr	r2, [sp, #0x8]
700a7dfe: 73d1         	strb	r1, [r2, #0xf]
;         rxPrms->flowErrorHandling   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_ERR_RETRY;       /* Default Re-try descriptor allocation operation on starvation error */
700a7e00: 9a02         	ldr	r2, [sp, #0x8]
700a7e02: 7410         	strb	r0, [r2, #0x10]
;         rxPrms->flowSopOffset       = 0U;      /* Default SOP offset is 0 */
700a7e04: 9a02         	ldr	r2, [sp, #0x8]
700a7e06: 7451         	strb	r1, [r2, #0x11]
;         rxPrms->ignoreShortPkts     = TISCI_MSG_VALUE_RM_UDMAP_RX_CH_PACKET_EXCEPTION;
700a7e08: 9a02         	ldr	r2, [sp, #0x8]
700a7e0a: 7491         	strb	r1, [r2, #0x12]
;         rxPrms->ignoreLongPkts      = TISCI_MSG_VALUE_RM_UDMAP_RX_CH_PACKET_EXCEPTION;
700a7e0c: 9a02         	ldr	r2, [sp, #0x8]
700a7e0e: 74d1         	strb	r1, [r2, #0x13]
;         rxPrms->configDefaultFlow   = TRUE;
700a7e10: 9902         	ldr	r1, [sp, #0x8]
700a7e12: 6148         	str	r0, [r1, #0x14]
;         if((chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
700a7e14: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a7e18: 0600         	lsls	r0, r0, #0x18
700a7e1a: 2800         	cmp	r0, #0x0
700a7e1c: d504         	bpl	0x700a7e28 <UdmaChRxPrms_init+0x88> @ imm = #0x8
700a7e1e: e7ff         	b	0x700a7e20 <UdmaChRxPrms_init+0x80> @ imm = #-0x2
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a7e20: 9902         	ldr	r1, [sp, #0x8]
700a7e22: 2003         	movs	r0, #0x3
700a7e24: 7608         	strb	r0, [r1, #0x18]
;         }
700a7e26: e00e         	b	0x700a7e46 <UdmaChRxPrms_init+0xa6> @ imm = #0x1c
;         else if((chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
700a7e28: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a7e2c: 0640         	lsls	r0, r0, #0x19
700a7e2e: 2800         	cmp	r0, #0x0
700a7e30: d504         	bpl	0x700a7e3c <UdmaChRxPrms_init+0x9c> @ imm = #0x8
700a7e32: e7ff         	b	0x700a7e34 <UdmaChRxPrms_init+0x94> @ imm = #-0x2
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a7e34: 9902         	ldr	r1, [sp, #0x8]
700a7e36: 2003         	movs	r0, #0x3
700a7e38: 7608         	strb	r0, [r1, #0x18]
;         }
700a7e3a: e003         	b	0x700a7e44 <UdmaChRxPrms_init+0xa4> @ imm = #0x6
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_64_BYTES;
700a7e3c: 9902         	ldr	r1, [sp, #0x8]
700a7e3e: 2001         	movs	r0, #0x1
700a7e40: 7608         	strb	r0, [r1, #0x18]
700a7e42: e7ff         	b	0x700a7e44 <UdmaChRxPrms_init+0xa4> @ imm = #-0x2
700a7e44: e7ff         	b	0x700a7e46 <UdmaChRxPrms_init+0xa6> @ imm = #-0x2
;     }
700a7e46: e7ff         	b	0x700a7e48 <UdmaChRxPrms_init+0xa8> @ imm = #-0x2
;     return;
700a7e48: b003         	add	sp, #0xc
700a7e4a: 4770         	bx	lr
700a7e4c: 0000         	movs	r0, r0
700a7e4e: 0000         	movs	r0, r0

700a7e50 <UdmaChTxPrms_init>:
; {
700a7e50: b082         	sub	sp, #0x8
700a7e52: 9001         	str	r0, [sp, #0x4]
700a7e54: 9100         	str	r1, [sp]
;     if(NULL_PTR != txPrms)
700a7e56: 9801         	ldr	r0, [sp, #0x4]
700a7e58: 2800         	cmp	r0, #0x0
700a7e5a: d04d         	beq	0x700a7ef8 <UdmaChTxPrms_init+0xa8> @ imm = #0x9a
700a7e5c: e7ff         	b	0x700a7e5e <UdmaChTxPrms_init+0xe> @ imm = #-0x2
;         txPrms->pauseOnError    = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERROR_DISABLED;
700a7e5e: 9901         	ldr	r1, [sp, #0x4]
700a7e60: 2000         	movs	r0, #0x0
700a7e62: 7008         	strb	r0, [r1]
;         txPrms->filterEinfo     = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_FILT_EINFO_DISABLED;
700a7e64: 9901         	ldr	r1, [sp, #0x4]
700a7e66: 7048         	strb	r0, [r1, #0x1]
;         txPrms->filterPsWords   = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_FILT_PSWORDS_DISABLED;
700a7e68: 9901         	ldr	r1, [sp, #0x4]
700a7e6a: 7088         	strb	r0, [r1, #0x2]
;         txPrms->addrType        = TISCI_MSG_VALUE_RM_UDMAP_CH_ATYPE_PHYS;
700a7e6c: 9901         	ldr	r1, [sp, #0x4]
700a7e6e: 70c8         	strb	r0, [r1, #0x3]
;         txPrms->chanType        = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_PACKET;
700a7e70: 9901         	ldr	r1, [sp, #0x4]
700a7e72: 2002         	movs	r0, #0x2
700a7e74: 7108         	strb	r0, [r1, #0x4]
;         if((chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a7e76: f89d 0000    	ldrb.w	r0, [sp]
700a7e7a: 0740         	lsls	r0, r0, #0x1d
700a7e7c: 2800         	cmp	r0, #0x0
700a7e7e: d504         	bpl	0x700a7e8a <UdmaChTxPrms_init+0x3a> @ imm = #0x8
700a7e80: e7ff         	b	0x700a7e82 <UdmaChTxPrms_init+0x32> @ imm = #-0x2
;             txPrms->chanType    = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_3P_BLOCK_REF;
700a7e82: 9901         	ldr	r1, [sp, #0x4]
700a7e84: 200c         	movs	r0, #0xc
700a7e86: 7108         	strb	r0, [r1, #0x4]
;         }
700a7e88: e7ff         	b	0x700a7e8a <UdmaChTxPrms_init+0x3a> @ imm = #-0x2
;         txPrms->fetchWordSize   = 16U;  /* sizeof(CSL_UdmapTR15) / sizeof(uint32_t) */
700a7e8a: 9901         	ldr	r1, [sp, #0x4]
700a7e8c: 2010         	movs	r0, #0x10
700a7e8e: 80c8         	strh	r0, [r1, #0x6]
;         txPrms->busPriority     = UDMA_DEFAULT_TX_CH_BUS_PRIORITY;
700a7e90: 9901         	ldr	r1, [sp, #0x4]
700a7e92: 2004         	movs	r0, #0x4
700a7e94: 7208         	strb	r0, [r1, #0x8]
;         txPrms->busQos          = UDMA_DEFAULT_TX_CH_BUS_QOS;
700a7e96: 9901         	ldr	r1, [sp, #0x4]
700a7e98: 7248         	strb	r0, [r1, #0x9]
;         txPrms->busOrderId      = UDMA_DEFAULT_TX_CH_BUS_ORDERID;
700a7e9a: 9901         	ldr	r1, [sp, #0x4]
700a7e9c: 2000         	movs	r0, #0x0
700a7e9e: 7288         	strb	r0, [r1, #0xa]
;         txPrms->dmaPriority     = UDMA_DEFAULT_TX_CH_DMA_PRIORITY;
700a7ea0: 9a01         	ldr	r2, [sp, #0x4]
700a7ea2: 2101         	movs	r1, #0x1
700a7ea4: 72d1         	strb	r1, [r2, #0xb]
;         txPrms->txCredit        = 0U;
700a7ea6: 9901         	ldr	r1, [sp, #0x4]
700a7ea8: 7308         	strb	r0, [r1, #0xc]
;         if((chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
700a7eaa: f89d 0000    	ldrb.w	r0, [sp]
700a7eae: ea4f 6000    	lsl.w	r0, r0, #0x18
700a7eb2: 2800         	cmp	r0, #0x0
700a7eb4: d507         	bpl	0x700a7ec6 <UdmaChTxPrms_init+0x76> @ imm = #0xe
700a7eb6: e7ff         	b	0x700a7eb8 <UdmaChTxPrms_init+0x68> @ imm = #-0x2
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_UHC_CHANS_FDEPTH;
700a7eb8: 9901         	ldr	r1, [sp, #0x4]
700a7eba: 2000         	movs	r0, #0x0
700a7ebc: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a7ebe: 9901         	ldr	r1, [sp, #0x4]
700a7ec0: 2003         	movs	r0, #0x3
700a7ec2: 7408         	strb	r0, [r1, #0x10]
;         }
700a7ec4: e014         	b	0x700a7ef0 <UdmaChTxPrms_init+0xa0> @ imm = #0x28
;         else if((chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
700a7ec6: f89d 0000    	ldrb.w	r0, [sp]
700a7eca: 0640         	lsls	r0, r0, #0x19
700a7ecc: 2800         	cmp	r0, #0x0
700a7ece: d507         	bpl	0x700a7ee0 <UdmaChTxPrms_init+0x90> @ imm = #0xe
700a7ed0: e7ff         	b	0x700a7ed2 <UdmaChTxPrms_init+0x82> @ imm = #-0x2
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_HC_CHANS_FDEPTH;
700a7ed2: 9901         	ldr	r1, [sp, #0x4]
700a7ed4: 2000         	movs	r0, #0x0
700a7ed6: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a7ed8: 9901         	ldr	r1, [sp, #0x4]
700a7eda: 2003         	movs	r0, #0x3
700a7edc: 7408         	strb	r0, [r1, #0x10]
;         }
700a7ede: e006         	b	0x700a7eee <UdmaChTxPrms_init+0x9e> @ imm = #0xc
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_CHANS_FDEPTH;
700a7ee0: 9901         	ldr	r1, [sp, #0x4]
700a7ee2: 20c0         	movs	r0, #0xc0
700a7ee4: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_64_BYTES;
700a7ee6: 9901         	ldr	r1, [sp, #0x4]
700a7ee8: 2001         	movs	r0, #0x1
700a7eea: 7408         	strb	r0, [r1, #0x10]
700a7eec: e7ff         	b	0x700a7eee <UdmaChTxPrms_init+0x9e> @ imm = #-0x2
700a7eee: e7ff         	b	0x700a7ef0 <UdmaChTxPrms_init+0xa0> @ imm = #-0x2
;         txPrms->supressTdCqPkt  = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_SUPPRESS_TD_DISABLED;
700a7ef0: 9901         	ldr	r1, [sp, #0x4]
700a7ef2: 2000         	movs	r0, #0x0
700a7ef4: 7448         	strb	r0, [r1, #0x11]
;     }
700a7ef6: e7ff         	b	0x700a7ef8 <UdmaChTxPrms_init+0xa8> @ imm = #-0x2
;     return;
700a7ef8: b002         	add	sp, #0x8
700a7efa: 4770         	bx	lr
700a7efc: 0000         	movs	r0, r0
700a7efe: 0000         	movs	r0, r0

700a7f00 <Udma_chDisable>:
; {
700a7f00: b580         	push	{r7, lr}
700a7f02: b086         	sub	sp, #0x18
700a7f04: 9005         	str	r0, [sp, #0x14]
700a7f06: 9104         	str	r1, [sp, #0x10]
700a7f08: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a7f0a: 9003         	str	r0, [sp, #0xc]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a7f0c: 9805         	ldr	r0, [sp, #0x14]
700a7f0e: 9001         	str	r0, [sp, #0x4]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a7f10: 9801         	ldr	r0, [sp, #0x4]
700a7f12: b150         	cbz	r0, 0x700a7f2a <Udma_chDisable+0x2a> @ imm = #0x14
700a7f14: e7ff         	b	0x700a7f16 <Udma_chDisable+0x16> @ imm = #-0x2
700a7f16: 9801         	ldr	r0, [sp, #0x4]
700a7f18: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a7f1c: f64a 31cd    	movw	r1, #0xabcd
700a7f20: f6ca 31dc    	movt	r1, #0xabdc
700a7f24: 4288         	cmp	r0, r1
700a7f26: d004         	beq	0x700a7f32 <Udma_chDisable+0x32> @ imm = #0x8
700a7f28: e7ff         	b	0x700a7f2a <Udma_chDisable+0x2a> @ imm = #-0x2
700a7f2a: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a7f2e: 9003         	str	r0, [sp, #0xc]
;     }
700a7f30: e7ff         	b	0x700a7f32 <Udma_chDisable+0x32> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7f32: 9803         	ldr	r0, [sp, #0xc]
700a7f34: b9a8         	cbnz	r0, 0x700a7f62 <Udma_chDisable+0x62> @ imm = #0x2a
700a7f36: e7ff         	b	0x700a7f38 <Udma_chDisable+0x38> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a7f38: 9801         	ldr	r0, [sp, #0x4]
700a7f3a: 6e80         	ldr	r0, [r0, #0x68]
700a7f3c: 9002         	str	r0, [sp, #0x8]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a7f3e: 9802         	ldr	r0, [sp, #0x8]
700a7f40: b150         	cbz	r0, 0x700a7f58 <Udma_chDisable+0x58> @ imm = #0x14
700a7f42: e7ff         	b	0x700a7f44 <Udma_chDisable+0x44> @ imm = #-0x2
700a7f44: 9802         	ldr	r0, [sp, #0x8]
700a7f46: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a7f4a: f64a 31cd    	movw	r1, #0xabcd
700a7f4e: f6ca 31dc    	movt	r1, #0xabdc
700a7f52: 4288         	cmp	r0, r1
700a7f54: d004         	beq	0x700a7f60 <Udma_chDisable+0x60> @ imm = #0x8
700a7f56: e7ff         	b	0x700a7f58 <Udma_chDisable+0x58> @ imm = #-0x2
700a7f58: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7f5c: 9003         	str	r0, [sp, #0xc]
;         }
700a7f5e: e7ff         	b	0x700a7f60 <Udma_chDisable+0x60> @ imm = #-0x2
;     }
700a7f60: e7ff         	b	0x700a7f62 <Udma_chDisable+0x62> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7f62: 9803         	ldr	r0, [sp, #0xc]
700a7f64: b9f8         	cbnz	r0, 0x700a7fa6 <Udma_chDisable+0xa6> @ imm = #0x3e
700a7f66: e7ff         	b	0x700a7f68 <Udma_chDisable+0x68> @ imm = #-0x2
;         if((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a7f68: 9801         	ldr	r0, [sp, #0x4]
700a7f6a: 7800         	ldrb	r0, [r0]
700a7f6c: 0740         	lsls	r0, r0, #0x1d
700a7f6e: 2800         	cmp	r0, #0x0
700a7f70: d506         	bpl	0x700a7f80 <Udma_chDisable+0x80> @ imm = #0xc
700a7f72: e7ff         	b	0x700a7f74 <Udma_chDisable+0x74> @ imm = #-0x2
;             retVal = Udma_chDisableBlkCpyChan(chHandleInt, timeout);
700a7f74: 9801         	ldr	r0, [sp, #0x4]
700a7f76: 9904         	ldr	r1, [sp, #0x10]
700a7f78: f7f7 f8c2    	bl	0x7009f100 <Udma_chDisableBlkCpyChan> @ imm = #-0x8e7c
700a7f7c: 9003         	str	r0, [sp, #0xc]
;         }
700a7f7e: e011         	b	0x700a7fa4 <Udma_chDisable+0xa4> @ imm = #0x22
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a7f80: 9801         	ldr	r0, [sp, #0x4]
700a7f82: 7800         	ldrb	r0, [r0]
700a7f84: 07c0         	lsls	r0, r0, #0x1f
700a7f86: b130         	cbz	r0, 0x700a7f96 <Udma_chDisable+0x96> @ imm = #0xc
700a7f88: e7ff         	b	0x700a7f8a <Udma_chDisable+0x8a> @ imm = #-0x2
;                 retVal = Udma_chDisableTxChan(chHandleInt, timeout);
700a7f8a: 9801         	ldr	r0, [sp, #0x4]
700a7f8c: 9904         	ldr	r1, [sp, #0x10]
700a7f8e: f7f4 fb0f    	bl	0x7009c5b0 <Udma_chDisableTxChan> @ imm = #-0xb9e2
700a7f92: 9003         	str	r0, [sp, #0xc]
;             }
700a7f94: e005         	b	0x700a7fa2 <Udma_chDisable+0xa2> @ imm = #0xa
;                 retVal = Udma_chDisableRxChan(chHandleInt, timeout);
700a7f96: 9801         	ldr	r0, [sp, #0x4]
700a7f98: 9904         	ldr	r1, [sp, #0x10]
700a7f9a: f7f5 fad9    	bl	0x7009d550 <Udma_chDisableRxChan> @ imm = #-0xaa4e
700a7f9e: 9003         	str	r0, [sp, #0xc]
700a7fa0: e7ff         	b	0x700a7fa2 <Udma_chDisable+0xa2> @ imm = #-0x2
700a7fa2: e7ff         	b	0x700a7fa4 <Udma_chDisable+0xa4> @ imm = #-0x2
;     }
700a7fa4: e7ff         	b	0x700a7fa6 <Udma_chDisable+0xa6> @ imm = #-0x2
;     return (retVal);
700a7fa6: 9803         	ldr	r0, [sp, #0xc]
700a7fa8: b006         	add	sp, #0x18
700a7faa: bd80         	pop	{r7, pc}
700a7fac: 0000         	movs	r0, r0
700a7fae: 0000         	movs	r0, r0

700a7fb0 <CSL_bcdmaChanOpSetChanPause>:
; {
700a7fb0: b580         	push	{r7, lr}
700a7fb2: b086         	sub	sp, #0x18
700a7fb4: 9005         	str	r0, [sp, #0x14]
700a7fb6: 9104         	str	r1, [sp, #0x10]
700a7fb8: 9203         	str	r2, [sp, #0xc]
700a7fba: f88d 300b    	strb.w	r3, [sp, #0xb]
700a7fbe: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a7fc0: 9001         	str	r0, [sp, #0x4]
;     if( CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)false )
700a7fc2: 9805         	ldr	r0, [sp, #0x14]
700a7fc4: 9904         	ldr	r1, [sp, #0x10]
700a7fc6: 9a03         	ldr	r2, [sp, #0xc]
700a7fc8: f002 fbf2    	bl	0x700aa7b0 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x27e4
700a7fcc: b920         	cbnz	r0, 0x700a7fd8 <CSL_bcdmaChanOpSetChanPause+0x28> @ imm = #0x8
700a7fce: e7ff         	b	0x700a7fd0 <CSL_bcdmaChanOpSetChanPause+0x20> @ imm = #-0x2
700a7fd0: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a7fd4: 9001         	str	r0, [sp, #0x4]
;     }
700a7fd6: e03d         	b	0x700a8054 <CSL_bcdmaChanOpSetChanPause+0xa4> @ imm = #0x7a
;         switch( chanType )
700a7fd8: 9804         	ldr	r0, [sp, #0x10]
700a7fda: 9000         	str	r0, [sp]
700a7fdc: b140         	cbz	r0, 0x700a7ff0 <CSL_bcdmaChanOpSetChanPause+0x40> @ imm = #0x10
700a7fde: e7ff         	b	0x700a7fe0 <CSL_bcdmaChanOpSetChanPause+0x30> @ imm = #-0x2
700a7fe0: 9800         	ldr	r0, [sp]
700a7fe2: 2801         	cmp	r0, #0x1
700a7fe4: d013         	beq	0x700a800e <CSL_bcdmaChanOpSetChanPause+0x5e> @ imm = #0x26
700a7fe6: e7ff         	b	0x700a7fe8 <CSL_bcdmaChanOpSetChanPause+0x38> @ imm = #-0x2
700a7fe8: 9800         	ldr	r0, [sp]
700a7fea: 2802         	cmp	r0, #0x2
700a7fec: d01e         	beq	0x700a802c <CSL_bcdmaChanOpSetChanPause+0x7c> @ imm = #0x3c
700a7fee: e02c         	b	0x700a804a <CSL_bcdmaChanOpSetChanPause+0x9a> @ imm = #0x58
;                 CSL_REG32_FINS( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a7ff0: 9805         	ldr	r0, [sp, #0x14]
700a7ff2: 6880         	ldr	r0, [r0, #0x8]
700a7ff4: 9903         	ldr	r1, [sp, #0xc]
700a7ff6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a7ffa: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a7ffe: f001 0301    	and	r3, r1, #0x1
700a8002: f04f 5100    	mov.w	r1, #0x20000000
700a8006: 221d         	movs	r2, #0x1d
700a8008: f006 f80a    	bl	0x700ae020 <CSL_REG32_FINS_RAW> @ imm = #0x6014
;                 break;
700a800c: e021         	b	0x700a8052 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x42
;                 CSL_REG32_FINS( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a800e: 9805         	ldr	r0, [sp, #0x14]
700a8010: 6900         	ldr	r0, [r0, #0x10]
700a8012: 9903         	ldr	r1, [sp, #0xc]
700a8014: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8018: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a801c: f001 0301    	and	r3, r1, #0x1
700a8020: f04f 5100    	mov.w	r1, #0x20000000
700a8024: 221d         	movs	r2, #0x1d
700a8026: f005 fffb    	bl	0x700ae020 <CSL_REG32_FINS_RAW> @ imm = #0x5ff6
;                 break;
700a802a: e012         	b	0x700a8052 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x24
;                 CSL_REG32_FINS( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a802c: 9805         	ldr	r0, [sp, #0x14]
700a802e: 6980         	ldr	r0, [r0, #0x18]
700a8030: 9903         	ldr	r1, [sp, #0xc]
700a8032: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8036: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a803a: f001 0301    	and	r3, r1, #0x1
700a803e: f04f 5100    	mov.w	r1, #0x20000000
700a8042: 221d         	movs	r2, #0x1d
700a8044: f005 ffec    	bl	0x700ae020 <CSL_REG32_FINS_RAW> @ imm = #0x5fd8
;                 break;
700a8048: e003         	b	0x700a8052 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x6
700a804a: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a804e: 9001         	str	r0, [sp, #0x4]
;                 break;
700a8050: e7ff         	b	0x700a8052 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #-0x2
700a8052: e7ff         	b	0x700a8054 <CSL_bcdmaChanOpSetChanPause+0xa4> @ imm = #-0x2
;     return retVal;
700a8054: 9801         	ldr	r0, [sp, #0x4]
700a8056: b006         	add	sp, #0x18
700a8058: bd80         	pop	{r7, pc}
700a805a: 0000         	movs	r0, r0
700a805c: 0000         	movs	r0, r0
700a805e: 0000         	movs	r0, r0

700a8060 <CSL_bcdmaChanOpSetChanRT>:
; {
700a8060: b580         	push	{r7, lr}
700a8062: b088         	sub	sp, #0x20
700a8064: 9007         	str	r0, [sp, #0x1c]
700a8066: 9106         	str	r1, [sp, #0x18]
700a8068: 9205         	str	r2, [sp, #0x14]
700a806a: 9304         	str	r3, [sp, #0x10]
700a806c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a806e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a8070: 9804         	ldr	r0, [sp, #0x10]
700a8072: b920         	cbnz	r0, 0x700a807e <CSL_bcdmaChanOpSetChanRT+0x1e> @ imm = #0x8
700a8074: e7ff         	b	0x700a8076 <CSL_bcdmaChanOpSetChanRT+0x16> @ imm = #-0x2
700a8076: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a807a: 9003         	str	r0, [sp, #0xc]
;     }
700a807c: e042         	b	0x700a8104 <CSL_bcdmaChanOpSetChanRT+0xa4> @ imm = #0x84
;         CSL_BcdmaRT *pRT = (CSL_BcdmaRT *)pOpData;
700a807e: 9804         	ldr	r0, [sp, #0x10]
700a8080: 9001         	str	r0, [sp, #0x4]
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a8082: 9801         	ldr	r0, [sp, #0x4]
700a8084: 6803         	ldr	r3, [r0]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a8086: f8d0 c004    	ldr.w	r12, [r0, #0x4]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_PAUSE,        pRT->pause);
700a808a: 6881         	ldr	r1, [r0, #0x8]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a808c: 6902         	ldr	r2, [r0, #0x10]
700a808e: f04f 4080    	mov.w	r0, #0x40000000
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a8092: ea00 708c    	and.w	r0, r0, r12, lsl #30
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a8096: ea40 70c3    	orr.w	r0, r0, r3, lsl #31
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a809a: f002 0201    	and	r2, r2, #0x1
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a809e: ea40 7002    	orr.w	r0, r0, r2, lsl #28
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_PAUSE,        pRT->pause);
700a80a2: f001 0101    	and	r1, r1, #0x1
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a80a6: ea40 7041    	orr.w	r0, r0, r1, lsl #29
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a80aa: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a80ac: 9806         	ldr	r0, [sp, #0x18]
700a80ae: 9000         	str	r0, [sp]
700a80b0: b140         	cbz	r0, 0x700a80c4 <CSL_bcdmaChanOpSetChanRT+0x64> @ imm = #0x10
700a80b2: e7ff         	b	0x700a80b4 <CSL_bcdmaChanOpSetChanRT+0x54> @ imm = #-0x2
700a80b4: 9800         	ldr	r0, [sp]
700a80b6: 2801         	cmp	r0, #0x1
700a80b8: d00d         	beq	0x700a80d6 <CSL_bcdmaChanOpSetChanRT+0x76> @ imm = #0x1a
700a80ba: e7ff         	b	0x700a80bc <CSL_bcdmaChanOpSetChanRT+0x5c> @ imm = #-0x2
700a80bc: 9800         	ldr	r0, [sp]
700a80be: 2802         	cmp	r0, #0x2
700a80c0: d012         	beq	0x700a80e8 <CSL_bcdmaChanOpSetChanRT+0x88> @ imm = #0x24
700a80c2: e01a         	b	0x700a80fa <CSL_bcdmaChanOpSetChanRT+0x9a> @ imm = #0x34
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, val );
700a80c4: 9807         	ldr	r0, [sp, #0x1c]
700a80c6: 6880         	ldr	r0, [r0, #0x8]
700a80c8: 9905         	ldr	r1, [sp, #0x14]
700a80ca: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a80ce: 9902         	ldr	r1, [sp, #0x8]
700a80d0: f7f4 f89e    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0xbec4
;                 break;
700a80d4: e015         	b	0x700a8102 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x2a
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, val );
700a80d6: 9807         	ldr	r0, [sp, #0x1c]
700a80d8: 6900         	ldr	r0, [r0, #0x10]
700a80da: 9905         	ldr	r1, [sp, #0x14]
700a80dc: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a80e0: 9902         	ldr	r1, [sp, #0x8]
700a80e2: f7f4 f895    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0xbed6
;                 break;
700a80e6: e00c         	b	0x700a8102 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x18
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, val );
700a80e8: 9807         	ldr	r0, [sp, #0x1c]
700a80ea: 6980         	ldr	r0, [r0, #0x18]
700a80ec: 9905         	ldr	r1, [sp, #0x14]
700a80ee: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a80f2: 9902         	ldr	r1, [sp, #0x8]
700a80f4: f7f4 f88c    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0xbee8
;                 break;
700a80f8: e003         	b	0x700a8102 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x6
700a80fa: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a80fe: 9003         	str	r0, [sp, #0xc]
;                 break;
700a8100: e7ff         	b	0x700a8102 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #-0x2
700a8102: e7ff         	b	0x700a8104 <CSL_bcdmaChanOpSetChanRT+0xa4> @ imm = #-0x2
;     return retVal;
700a8104: 9803         	ldr	r0, [sp, #0xc]
700a8106: b008         	add	sp, #0x20
700a8108: bd80         	pop	{r7, pc}
700a810a: 0000         	movs	r0, r0
700a810c: 0000         	movs	r0, r0
700a810e: 0000         	movs	r0, r0

700a8110 <Sciclient_rmIrInpRomMapped>:
; {
700a8110: b082         	sub	sp, #0x8
700a8112: 9001         	str	r0, [sp, #0x4]
700a8114: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a8118: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a811a: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a811e: 9801         	ldr	r0, [sp, #0x4]
700a8120: 6900         	ldr	r0, [r0, #0x10]
700a8122: 2800         	cmp	r0, #0x0
700a8124: d042         	beq	0x700a81ac <Sciclient_rmIrInpRomMapped+0x9c> @ imm = #0x84
700a8126: e7ff         	b	0x700a8128 <Sciclient_rmIrInpRomMapped+0x18> @ imm = #-0x2
700a8128: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a812a: f88d 0000    	strb.w	r0, [sp]
700a812e: e7ff         	b	0x700a8130 <Sciclient_rmIrInpRomMapped+0x20> @ imm = #-0x2
700a8130: f89d 0000    	ldrb.w	r0, [sp]
700a8134: 9901         	ldr	r1, [sp, #0x4]
700a8136: 7d09         	ldrb	r1, [r1, #0x14]
700a8138: 4288         	cmp	r0, r1
700a813a: da36         	bge	0x700a81aa <Sciclient_rmIrInpRomMapped+0x9a> @ imm = #0x6c
700a813c: e7ff         	b	0x700a813e <Sciclient_rmIrInpRomMapped+0x2e> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a813e: 9801         	ldr	r0, [sp, #0x4]
700a8140: 6900         	ldr	r0, [r0, #0x10]
700a8142: f89d 1000    	ldrb.w	r1, [sp]
700a8146: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a814a: 7980         	ldrb	r0, [r0, #0x6]
700a814c: 07c0         	lsls	r0, r0, #0x1f
700a814e: bb28         	cbnz	r0, 0x700a819c <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x4a
700a8150: e7ff         	b	0x700a8152 <Sciclient_rmIrInpRomMapped+0x42> @ imm = #-0x2
;                 (inp >= inst->rom_usage[i].inp_start) &&
700a8152: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a8156: 9901         	ldr	r1, [sp, #0x4]
700a8158: 6909         	ldr	r1, [r1, #0x10]
700a815a: f89d 2000    	ldrb.w	r2, [sp]
700a815e: f831 1032    	ldrh.w	r1, [r1, r2, lsl #3]
700a8162: 4288         	cmp	r0, r1
700a8164: db1a         	blt	0x700a819c <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x34
700a8166: e7ff         	b	0x700a8168 <Sciclient_rmIrInpRomMapped+0x58> @ imm = #-0x2
;                 (inp < (inst->rom_usage[i].inp_start +
700a8168: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a816c: 9901         	ldr	r1, [sp, #0x4]
700a816e: 6909         	ldr	r1, [r1, #0x10]
700a8170: f89d 3000    	ldrb.w	r3, [sp]
700a8174: eb01 02c3    	add.w	r2, r1, r3, lsl #3
700a8178: f831 1033    	ldrh.w	r1, [r1, r3, lsl #3]
;                         inst->rom_usage[i].length))) {
700a817c: 8892         	ldrh	r2, [r2, #0x4]
;                 (inp < (inst->rom_usage[i].inp_start +
700a817e: 4411         	add	r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a8180: 4288         	cmp	r0, r1
700a8182: da0b         	bge	0x700a819c <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x16
700a8184: e7ff         	b	0x700a8186 <Sciclient_rmIrInpRomMapped+0x76> @ imm = #-0x2
700a8186: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a8188: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a818c: 9901         	ldr	r1, [sp, #0x4]
700a818e: 6909         	ldr	r1, [r1, #0x10]
700a8190: f89d 2000    	ldrb.w	r2, [sp]
700a8194: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a8198: 7188         	strb	r0, [r1, #0x6]
;                 break;
700a819a: e006         	b	0x700a81aa <Sciclient_rmIrInpRomMapped+0x9a> @ imm = #0xc
;         }
700a819c: e7ff         	b	0x700a819e <Sciclient_rmIrInpRomMapped+0x8e> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a819e: f89d 0000    	ldrb.w	r0, [sp]
700a81a2: 3001         	adds	r0, #0x1
700a81a4: f88d 0000    	strb.w	r0, [sp]
700a81a8: e7c2         	b	0x700a8130 <Sciclient_rmIrInpRomMapped+0x20> @ imm = #-0x7c
;     }
700a81aa: e7ff         	b	0x700a81ac <Sciclient_rmIrInpRomMapped+0x9c> @ imm = #-0x2
;     return rom_mapped;
700a81ac: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a81b0: f000 0001    	and	r0, r0, #0x1
700a81b4: b002         	add	sp, #0x8
700a81b6: 4770         	bx	lr
		...

700a81c0 <Sciclient_rmIrOutpRomMapped>:
; {
700a81c0: b082         	sub	sp, #0x8
700a81c2: 9001         	str	r0, [sp, #0x4]
700a81c4: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a81c8: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a81ca: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a81ce: 9801         	ldr	r0, [sp, #0x4]
700a81d0: 6900         	ldr	r0, [r0, #0x10]
700a81d2: 2800         	cmp	r0, #0x0
700a81d4: d042         	beq	0x700a825c <Sciclient_rmIrOutpRomMapped+0x9c> @ imm = #0x84
700a81d6: e7ff         	b	0x700a81d8 <Sciclient_rmIrOutpRomMapped+0x18> @ imm = #-0x2
700a81d8: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a81da: f88d 0000    	strb.w	r0, [sp]
700a81de: e7ff         	b	0x700a81e0 <Sciclient_rmIrOutpRomMapped+0x20> @ imm = #-0x2
700a81e0: f89d 0000    	ldrb.w	r0, [sp]
700a81e4: 9901         	ldr	r1, [sp, #0x4]
700a81e6: 7d09         	ldrb	r1, [r1, #0x14]
700a81e8: 4288         	cmp	r0, r1
700a81ea: da36         	bge	0x700a825a <Sciclient_rmIrOutpRomMapped+0x9a> @ imm = #0x6c
700a81ec: e7ff         	b	0x700a81ee <Sciclient_rmIrOutpRomMapped+0x2e> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a81ee: 9801         	ldr	r0, [sp, #0x4]
700a81f0: 6900         	ldr	r0, [r0, #0x10]
700a81f2: f89d 1000    	ldrb.w	r1, [sp]
700a81f6: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a81fa: 7980         	ldrb	r0, [r0, #0x6]
700a81fc: 07c0         	lsls	r0, r0, #0x1f
700a81fe: bb28         	cbnz	r0, 0x700a824c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x4a
700a8200: e7ff         	b	0x700a8202 <Sciclient_rmIrOutpRomMapped+0x42> @ imm = #-0x2
;                 (outp >= inst->rom_usage[i].outp_start) &&
700a8202: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a8206: 9901         	ldr	r1, [sp, #0x4]
700a8208: 6909         	ldr	r1, [r1, #0x10]
700a820a: f89d 2000    	ldrb.w	r2, [sp]
700a820e: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a8212: 8849         	ldrh	r1, [r1, #0x2]
700a8214: 4288         	cmp	r0, r1
700a8216: db19         	blt	0x700a824c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x32
700a8218: e7ff         	b	0x700a821a <Sciclient_rmIrOutpRomMapped+0x5a> @ imm = #-0x2
;                 (outp < (inst->rom_usage[i].outp_start +
700a821a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a821e: 9901         	ldr	r1, [sp, #0x4]
700a8220: 6909         	ldr	r1, [r1, #0x10]
700a8222: f89d 2000    	ldrb.w	r2, [sp]
700a8226: eb01 02c2    	add.w	r2, r1, r2, lsl #3
700a822a: 8851         	ldrh	r1, [r2, #0x2]
;                         inst->rom_usage[i].length))) {
700a822c: 8892         	ldrh	r2, [r2, #0x4]
;                 (outp < (inst->rom_usage[i].outp_start +
700a822e: 4411         	add	r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a8230: 4288         	cmp	r0, r1
700a8232: da0b         	bge	0x700a824c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x16
700a8234: e7ff         	b	0x700a8236 <Sciclient_rmIrOutpRomMapped+0x76> @ imm = #-0x2
700a8236: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a8238: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a823c: 9901         	ldr	r1, [sp, #0x4]
700a823e: 6909         	ldr	r1, [r1, #0x10]
700a8240: f89d 2000    	ldrb.w	r2, [sp]
700a8244: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a8248: 7188         	strb	r0, [r1, #0x6]
;                 break;
700a824a: e006         	b	0x700a825a <Sciclient_rmIrOutpRomMapped+0x9a> @ imm = #0xc
;         }
700a824c: e7ff         	b	0x700a824e <Sciclient_rmIrOutpRomMapped+0x8e> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a824e: f89d 0000    	ldrb.w	r0, [sp]
700a8252: 3001         	adds	r0, #0x1
700a8254: f88d 0000    	strb.w	r0, [sp]
700a8258: e7c2         	b	0x700a81e0 <Sciclient_rmIrOutpRomMapped+0x20> @ imm = #-0x7c
;     }
700a825a: e7ff         	b	0x700a825c <Sciclient_rmIrOutpRomMapped+0x9c> @ imm = #-0x2
;     return rom_mapped;
700a825c: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a8260: f000 0001    	and	r0, r0, #0x1
700a8264: b002         	add	sp, #0x8
700a8266: 4770         	bx	lr
		...

700a8270 <CycleCounterP_init>:
; {
700a8270: b580         	push	{r7, lr}
700a8272: b082         	sub	sp, #0x8
700a8274: 9101         	str	r1, [sp, #0x4]
700a8276: 9000         	str	r0, [sp]
;     gCounterFreqHz = cpuFreqHz/PmuP_SETUP_COUNTER_DIVIDER_VAL;
700a8278: 9800         	ldr	r0, [sp]
700a827a: 9a01         	ldr	r2, [sp, #0x4]
700a827c: f242 6170    	movw	r1, #0x2670
700a8280: f2c7 010b    	movt	r1, #0x700b
700a8284: 604a         	str	r2, [r1, #0x4]
700a8286: 6008         	str	r0, [r1]
;     CycleCounterP_reset();
700a8288: f000 f802    	bl	0x700a8290 <CycleCounterP_reset> @ imm = #0x4
; }
700a828c: b002         	add	sp, #0x8
700a828e: bd80         	pop	{r7, pc}

700a8290 <CycleCounterP_reset>:
; {
700a8290: b580         	push	{r7, lr}
700a8292: b082         	sub	sp, #0x8
700a8294: 2000         	movs	r0, #0x0
;     uint32_t setupFlags = 0;
700a8296: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_CYCLE_COUNTER_RESET;
700a8298: 9801         	ldr	r0, [sp, #0x4]
700a829a: f040 0004    	orr	r0, r0, #0x4
700a829e: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_EVENT_COUNTER_RESET;
700a82a0: 9801         	ldr	r0, [sp, #0x4]
700a82a2: f040 0002    	orr	r0, r0, #0x2
700a82a6: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_ENABLE_ALL_COUNTERS;
700a82a8: 9801         	ldr	r0, [sp, #0x4]
700a82aa: f040 0001    	orr	r0, r0, #0x1
700a82ae: 9001         	str	r0, [sp, #0x4]
700a82b0: f04f 30ff    	mov.w	r0, #0xffffffff
;     PmuP_disableCounters(PmuP_COUNTER_MASK_ALL_COUNTERS); /* disable all counters */
700a82b4: 9000         	str	r0, [sp]
700a82b6: f006 e9b8    	blx	0x700ae628 <PmuP_disableCounters> @ imm = #0x6370
700a82ba: 9800         	ldr	r0, [sp]
;     PmuP_clearOverflowStatus(PmuP_COUNTER_MASK_ALL_COUNTERS); /* clear all overflow flags */
700a82bc: f006 e9bc    	blx	0x700ae638 <PmuP_clearOverflowStatus> @ imm = #0x6378
;     PmuP_setup(setupFlags); /* setup counters */
700a82c0: 9801         	ldr	r0, [sp, #0x4]
700a82c2: f006 e9aa    	blx	0x700ae618 <PmuP_setup> @ imm = #0x6354
700a82c6: f04f 4000    	mov.w	r0, #0x80000000
;     PmuP_enableCounters(PmuP_COUNTER_MASK_CYCLE_COUNTER); /* enable cycle counter only */
700a82ca: f006 e9aa    	blx	0x700ae620 <PmuP_enableCounters> @ imm = #0x6354
; }
700a82ce: b002         	add	sp, #0x8
700a82d0: bd80         	pop	{r7, pc}
700a82d2: bf00         	nop
700a82d4: bf00         	nop
700a82d6: bf00         	nop
700a82d8: bf00         	nop
700a82da: bf00         	nop
700a82dc: bf00         	nop
700a82de: bf00         	nop

700a82e0 <CycleCounterP_nsToTicks>:
; {
700a82e0: b580         	push	{r7, lr}
700a82e2: b082         	sub	sp, #0x8
700a82e4: 9101         	str	r1, [sp, #0x4]
700a82e6: 9000         	str	r0, [sp]
;     return (((uint64_t)nanosecs*gCounterFreqHz)/PmuP_SEC_TO_NANOSEC);
700a82e8: 9b00         	ldr	r3, [sp]
700a82ea: 9901         	ldr	r1, [sp, #0x4]
700a82ec: f242 6070    	movw	r0, #0x2670
700a82f0: f2c7 000b    	movt	r0, #0x700b
700a82f4: 6802         	ldr	r2, [r0]
700a82f6: f8d0 c004    	ldr.w	r12, [r0, #0x4]
700a82fa: fba3 0e02    	umull	r0, lr, r3, r2
700a82fe: fb03 e30c    	mla	r3, r3, r12, lr
700a8302: fb01 3102    	mla	r1, r1, r2, r3
700a8306: f64c 2200    	movw	r2, #0xca00
700a830a: f6c3 329a    	movt	r2, #0x3b9a
700a830e: 2300         	movs	r3, #0x0
700a8310: f006 ee10    	blx	0x700aef34 <__aeabi_uldivmod> @ imm = #0x6c20
700a8314: b002         	add	sp, #0x8
700a8316: bd80         	pop	{r7, pc}
		...

700a8320 <Sciclient_pmGetModuleClkNumParent>:
; {
700a8320: b580         	push	{r7, lr}
700a8322: b096         	sub	sp, #0x58
700a8324: 9015         	str	r0, [sp, #0x54]
700a8326: 9114         	str	r1, [sp, #0x50]
700a8328: 9213         	str	r2, [sp, #0x4c]
700a832a: 9312         	str	r3, [sp, #0x48]
700a832c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a832e: 9011         	str	r0, [sp, #0x44]
;     struct tisci_msg_get_num_clock_parents_req request = {{0}};
700a8330: f88d 0040    	strb.w	r0, [sp, #0x40]
700a8334: 900f         	str	r0, [sp, #0x3c]
700a8336: 900e         	str	r0, [sp, #0x38]
700a8338: 900d         	str	r0, [sp, #0x34]
700a833a: 900c         	str	r0, [sp, #0x30]
;     request.device = (uint32_t) moduleId;
700a833c: 9815         	ldr	r0, [sp, #0x54]
700a833e: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a8340: 9814         	ldr	r0, [sp, #0x50]
700a8342: 28ff         	cmp	r0, #0xff
700a8344: d307         	blo	0x700a8356 <Sciclient_pmGetModuleClkNumParent+0x36> @ imm = #0xe
700a8346: e7ff         	b	0x700a8348 <Sciclient_pmGetModuleClkNumParent+0x28> @ imm = #-0x2
;         request.clk32 = clockId;
700a8348: 9814         	ldr	r0, [sp, #0x50]
700a834a: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a834e: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a8350: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a8354: e003         	b	0x700a835e <Sciclient_pmGetModuleClkNumParent+0x3e> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a8356: 9814         	ldr	r0, [sp, #0x50]
700a8358: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a835c: e7ff         	b	0x700a835e <Sciclient_pmGetModuleClkNumParent+0x3e> @ imm = #-0x2
700a835e: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_num_clock_parents_resp response = {{0}};
700a8360: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a8364: 900a         	str	r0, [sp, #0x28]
700a8366: 9009         	str	r0, [sp, #0x24]
700a8368: 9008         	str	r0, [sp, #0x20]
700a836a: f44f 7182    	mov.w	r1, #0x104
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_NUM_CLOCK_PARENTS;
700a836e: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a8372: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a8374: 9104         	str	r1, [sp, #0x10]
700a8376: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a8378: 9105         	str	r1, [sp, #0x14]
700a837a: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a837c: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a837e: 9912         	ldr	r1, [sp, #0x48]
700a8380: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a8382: 9000         	str	r0, [sp]
700a8384: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a8386: 9001         	str	r0, [sp, #0x4]
700a8388: 200d         	movs	r0, #0xd
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a838a: 9002         	str	r0, [sp, #0x8]
700a838c: a803         	add	r0, sp, #0xc
700a838e: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a8390: f7f4 ff76    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xb114
700a8394: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a8396: 9811         	ldr	r0, [sp, #0x44]
700a8398: b930         	cbnz	r0, 0x700a83a8 <Sciclient_pmGetModuleClkNumParent+0x88> @ imm = #0xc
700a839a: e7ff         	b	0x700a839c <Sciclient_pmGetModuleClkNumParent+0x7c> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a839c: 9800         	ldr	r0, [sp]
700a839e: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a83a2: 2802         	cmp	r0, #0x2
700a83a4: d004         	beq	0x700a83b0 <Sciclient_pmGetModuleClkNumParent+0x90> @ imm = #0x8
700a83a6: e7ff         	b	0x700a83a8 <Sciclient_pmGetModuleClkNumParent+0x88> @ imm = #-0x2
700a83a8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a83ac: 9011         	str	r0, [sp, #0x44]
;     }
700a83ae: e7ff         	b	0x700a83b0 <Sciclient_pmGetModuleClkNumParent+0x90> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a83b0: 9811         	ldr	r0, [sp, #0x44]
700a83b2: b928         	cbnz	r0, 0x700a83c0 <Sciclient_pmGetModuleClkNumParent+0xa0> @ imm = #0xa
700a83b4: e7ff         	b	0x700a83b6 <Sciclient_pmGetModuleClkNumParent+0x96> @ imm = #-0x2
;         *numParent = (uint32_t) response.num_parents;
700a83b6: f89d 0028    	ldrb.w	r0, [sp, #0x28]
700a83ba: 9913         	ldr	r1, [sp, #0x4c]
700a83bc: 6008         	str	r0, [r1]
;     }
700a83be: e7ff         	b	0x700a83c0 <Sciclient_pmGetModuleClkNumParent+0xa0> @ imm = #-0x2
;     return retVal;
700a83c0: 9811         	ldr	r0, [sp, #0x44]
700a83c2: b016         	add	sp, #0x58
700a83c4: bd80         	pop	{r7, pc}
		...
700a83ce: 0000         	movs	r0, r0

700a83d0 <xTaskPriorityDisinherit>:
; BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder) {
700a83d0: b580         	push	{r7, lr}
700a83d2: b084         	sub	sp, #0x10
700a83d4: 9003         	str	r0, [sp, #0xc]
;   TCB_t *const pxTCB = pxMutexHolder;
700a83d6: 9803         	ldr	r0, [sp, #0xc]
700a83d8: 9002         	str	r0, [sp, #0x8]
700a83da: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700a83dc: 9001         	str	r0, [sp, #0x4]
;   if (pxMutexHolder != NULL) {
700a83de: 9803         	ldr	r0, [sp, #0xc]
700a83e0: 2800         	cmp	r0, #0x0
700a83e2: d044         	beq	0x700a846e <xTaskPriorityDisinherit+0x9e> @ imm = #0x88
700a83e4: e7ff         	b	0x700a83e6 <xTaskPriorityDisinherit+0x16> @ imm = #-0x2
;     (pxTCB->uxMutexesHeld)--;
700a83e6: 9902         	ldr	r1, [sp, #0x8]
700a83e8: 6e48         	ldr	r0, [r1, #0x64]
700a83ea: 3801         	subs	r0, #0x1
700a83ec: 6648         	str	r0, [r1, #0x64]
;     if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
700a83ee: 9902         	ldr	r1, [sp, #0x8]
700a83f0: 6ac8         	ldr	r0, [r1, #0x2c]
700a83f2: 6e09         	ldr	r1, [r1, #0x60]
700a83f4: 4288         	cmp	r0, r1
700a83f6: d038         	beq	0x700a846a <xTaskPriorityDisinherit+0x9a> @ imm = #0x70
700a83f8: e7ff         	b	0x700a83fa <xTaskPriorityDisinherit+0x2a> @ imm = #-0x2
;       if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
700a83fa: 9802         	ldr	r0, [sp, #0x8]
700a83fc: 6e40         	ldr	r0, [r0, #0x64]
700a83fe: bb90         	cbnz	r0, 0x700a8466 <xTaskPriorityDisinherit+0x96> @ imm = #0x64
700a8400: e7ff         	b	0x700a8402 <xTaskPriorityDisinherit+0x32> @ imm = #-0x2
;         if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a8402: 9802         	ldr	r0, [sp, #0x8]
700a8404: 3004         	adds	r0, #0x4
700a8406: f005 f833    	bl	0x700ad470 <uxListRemove> @ imm = #0x5066
700a840a: b908         	cbnz	r0, 0x700a8410 <xTaskPriorityDisinherit+0x40> @ imm = #0x2
700a840c: e7ff         	b	0x700a840e <xTaskPriorityDisinherit+0x3e> @ imm = #-0x2
;         } else {
700a840e: e000         	b	0x700a8412 <xTaskPriorityDisinherit+0x42> @ imm = #0x0
700a8410: e7ff         	b	0x700a8412 <xTaskPriorityDisinherit+0x42> @ imm = #-0x2
;         pxTCB->uxPriority = pxTCB->uxBasePriority;
700a8412: 9902         	ldr	r1, [sp, #0x8]
700a8414: 6e08         	ldr	r0, [r1, #0x60]
700a8416: 62c8         	str	r0, [r1, #0x2c]
;         listSET_LIST_ITEM_VALUE(
700a8418: 9902         	ldr	r1, [sp, #0x8]
700a841a: 6ac8         	ldr	r0, [r1, #0x2c]
700a841c: f1c0 0020    	rsb.w	r0, r0, #0x20
700a8420: 6188         	str	r0, [r1, #0x18]
;         prvAddTaskToReadyList(pxTCB);
700a8422: 9802         	ldr	r0, [sp, #0x8]
700a8424: 6ac0         	ldr	r0, [r0, #0x2c]
700a8426: f242 61ec    	movw	r1, #0x26ec
700a842a: f2c7 010b    	movt	r1, #0x700b
700a842e: 6809         	ldr	r1, [r1]
700a8430: 4288         	cmp	r0, r1
700a8432: d908         	bls	0x700a8446 <xTaskPriorityDisinherit+0x76> @ imm = #0x10
700a8434: e7ff         	b	0x700a8436 <xTaskPriorityDisinherit+0x66> @ imm = #-0x2
700a8436: 9802         	ldr	r0, [sp, #0x8]
700a8438: 6ac0         	ldr	r0, [r0, #0x2c]
700a843a: f242 61ec    	movw	r1, #0x26ec
700a843e: f2c7 010b    	movt	r1, #0x700b
700a8442: 6008         	str	r0, [r1]
700a8444: e7ff         	b	0x700a8446 <xTaskPriorityDisinherit+0x76> @ imm = #-0x2
700a8446: 9902         	ldr	r1, [sp, #0x8]
700a8448: 6ac8         	ldr	r0, [r1, #0x2c]
700a844a: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a844e: f244 40f8    	movw	r0, #0x44f8
700a8452: f2c7 0008    	movt	r0, #0x7008
700a8456: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a845a: 3104         	adds	r1, #0x4
700a845c: f005 fdc0    	bl	0x700adfe0 <vListInsertEnd> @ imm = #0x5b80
700a8460: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700a8462: 9001         	str	r0, [sp, #0x4]
;       } else {
700a8464: e000         	b	0x700a8468 <xTaskPriorityDisinherit+0x98> @ imm = #0x0
700a8466: e7ff         	b	0x700a8468 <xTaskPriorityDisinherit+0x98> @ imm = #-0x2
;     } else {
700a8468: e000         	b	0x700a846c <xTaskPriorityDisinherit+0x9c> @ imm = #0x0
700a846a: e7ff         	b	0x700a846c <xTaskPriorityDisinherit+0x9c> @ imm = #-0x2
;   } else {
700a846c: e000         	b	0x700a8470 <xTaskPriorityDisinherit+0xa0> @ imm = #0x0
700a846e: e7ff         	b	0x700a8470 <xTaskPriorityDisinherit+0xa0> @ imm = #-0x2
;   return xReturn;
700a8470: 9801         	ldr	r0, [sp, #0x4]
700a8472: b004         	add	sp, #0x10
700a8474: bd80         	pop	{r7, pc}
		...
700a847e: 0000         	movs	r0, r0

700a8480 <CSL_intaggrIsIntrPending>:
; {
700a8480: b580         	push	{r7, lr}
700a8482: b088         	sub	sp, #0x20
700a8484: 9007         	str	r0, [sp, #0x1c]
700a8486: 9106         	str	r1, [sp, #0x18]
700a8488: f88d 2017    	strb.w	r2, [sp, #0x17]
700a848c: 2000         	movs	r0, #0x0
;     bool     retVal = (bool)false;
700a848e: f88d 0016    	strb.w	r0, [sp, #0x16]
;     if( CSL_intaggrIsValidStatusBitNum(pCfg, statusBitNum) )
700a8492: 9807         	ldr	r0, [sp, #0x1c]
700a8494: 9906         	ldr	r1, [sp, #0x18]
700a8496: f005 fc03    	bl	0x700adca0 <CSL_intaggrIsValidStatusBitNum> @ imm = #0x5806
700a849a: b3e8         	cbz	r0, 0x700a8518 <CSL_intaggrIsIntrPending+0x98> @ imm = #0x7a
700a849c: e7ff         	b	0x700a849e <CSL_intaggrIsIntrPending+0x1e> @ imm = #-0x2
;         regNum = statusBitNum >> 6U;
700a849e: 9806         	ldr	r0, [sp, #0x18]
700a84a0: 0980         	lsrs	r0, r0, #0x6
700a84a2: 9001         	str	r0, [sp, #0x4]
;         bitNum = statusBitNum & (uint32_t)0x003FU;
700a84a4: 9806         	ldr	r0, [sp, #0x18]
700a84a6: f000 003f    	and	r0, r0, #0x3f
700a84aa: 9000         	str	r0, [sp]
;         if( bMaskedStatus == (bool)true )
700a84ac: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a84b0: 07c0         	lsls	r0, r0, #0x1f
700a84b2: b158         	cbz	r0, 0x700a84cc <CSL_intaggrIsIntrPending+0x4c> @ imm = #0x16
700a84b4: e7ff         	b	0x700a84b6 <CSL_intaggrIsIntrPending+0x36> @ imm = #-0x2
;             regVal = CSL_REG64_RD( &pCfg->pIntrRegs->VINT[regNum].STATUSM );
700a84b6: 9807         	ldr	r0, [sp, #0x1c]
700a84b8: 6880         	ldr	r0, [r0, #0x8]
700a84ba: 9901         	ldr	r1, [sp, #0x4]
700a84bc: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a84c0: 3020         	adds	r0, #0x20
700a84c2: f007 f9fd    	bl	0x700af8c0 <CSL_REG64_RD_RAW> @ imm = #0x73fa
700a84c6: 9103         	str	r1, [sp, #0xc]
700a84c8: 9002         	str	r0, [sp, #0x8]
;         }
700a84ca: e00a         	b	0x700a84e2 <CSL_intaggrIsIntrPending+0x62> @ imm = #0x14
;             regVal = CSL_REG64_RD( &pCfg->pIntrRegs->VINT[regNum].STATUS_SET );
700a84cc: 9807         	ldr	r0, [sp, #0x1c]
700a84ce: 6880         	ldr	r0, [r0, #0x8]
700a84d0: 9901         	ldr	r1, [sp, #0x4]
700a84d2: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a84d6: 3010         	adds	r0, #0x10
700a84d8: f007 f9f2    	bl	0x700af8c0 <CSL_REG64_RD_RAW> @ imm = #0x73e4
700a84dc: 9103         	str	r1, [sp, #0xc]
700a84de: 9002         	str	r0, [sp, #0x8]
700a84e0: e7ff         	b	0x700a84e2 <CSL_intaggrIsIntrPending+0x62> @ imm = #-0x2
;         if( (regVal & (((uint64_t)1U) << bitNum)) == 0U )
700a84e2: 9802         	ldr	r0, [sp, #0x8]
700a84e4: 9903         	ldr	r1, [sp, #0xc]
700a84e6: 9a00         	ldr	r2, [sp]
700a84e8: 40d0         	lsrs	r0, r2
700a84ea: f1c2 0320    	rsb.w	r3, r2, #0x20
700a84ee: fa01 f303    	lsl.w	r3, r1, r3
700a84f2: 4318         	orrs	r0, r3
700a84f4: 3a20         	subs	r2, #0x20
700a84f6: 40d1         	lsrs	r1, r2
700a84f8: 2a00         	cmp	r2, #0x0
700a84fa: bf58         	it	pl
700a84fc: 4608         	movpl	r0, r1
700a84fe: ea4f 70c0    	lsl.w	r0, r0, #0x1f
700a8502: b920         	cbnz	r0, 0x700a850e <CSL_intaggrIsIntrPending+0x8e> @ imm = #0x8
700a8504: e7ff         	b	0x700a8506 <CSL_intaggrIsIntrPending+0x86> @ imm = #-0x2
700a8506: 2000         	movs	r0, #0x0
;             retVal = (bool)false; /* Interrupt is not pending */
700a8508: f88d 0016    	strb.w	r0, [sp, #0x16]
;         }
700a850c: e003         	b	0x700a8516 <CSL_intaggrIsIntrPending+0x96> @ imm = #0x6
700a850e: 2001         	movs	r0, #0x1
;             retVal = (bool)true;  /* Interrupt is pending */
700a8510: f88d 0016    	strb.w	r0, [sp, #0x16]
700a8514: e7ff         	b	0x700a8516 <CSL_intaggrIsIntrPending+0x96> @ imm = #-0x2
;     }
700a8516: e7ff         	b	0x700a8518 <CSL_intaggrIsIntrPending+0x98> @ imm = #-0x2
;     return retVal;
700a8518: f89d 0016    	ldrb.w	r0, [sp, #0x16]
700a851c: f000 0001    	and	r0, r0, #0x1
700a8520: b008         	add	sp, #0x20
700a8522: bd80         	pop	{r7, pc}
		...

700a8530 <Sciclient_rmIrqCheckLoop>:
; {
700a8530: b580         	push	{r7, lr}
700a8532: b088         	sub	sp, #0x20
700a8534: 9007         	str	r0, [sp, #0x1c]
700a8536: 2000         	movs	r0, #0x0
;     bool loop = false;
700a8538: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a853c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a8540: e7ff         	b	0x700a8542 <Sciclient_rmIrqCheckLoop+0x12> @ imm = #-0x2
700a8542: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a8546: 9002         	str	r0, [sp, #0x8]
700a8548: f007 fa12    	bl	0x700af970 <Sciclient_rmPsGetPsp> @ imm = #0x7424
700a854c: 4601         	mov	r1, r0
700a854e: 9802         	ldr	r0, [sp, #0x8]
700a8550: 4288         	cmp	r0, r1
700a8552: da39         	bge	0x700a85c8 <Sciclient_rmIrqCheckLoop+0x98> @ imm = #0x72
700a8554: e7ff         	b	0x700a8556 <Sciclient_rmIrqCheckLoop+0x26> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a8556: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a855a: f006 fdf9    	bl	0x700af150 <Sciclient_rmPsGetIrqNode> @ imm = #0x6bf2
700a855e: 9004         	str	r0, [sp, #0x10]
;         for (j = i + 1u; j < Sciclient_rmPsGetPsp(); j++) {
700a8560: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a8564: 3001         	adds	r0, #0x1
700a8566: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a856a: e7ff         	b	0x700a856c <Sciclient_rmIrqCheckLoop+0x3c> @ imm = #-0x2
700a856c: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a8570: 9001         	str	r0, [sp, #0x4]
700a8572: f007 f9fd    	bl	0x700af970 <Sciclient_rmPsGetPsp> @ imm = #0x73fa
700a8576: 4601         	mov	r1, r0
700a8578: 9801         	ldr	r0, [sp, #0x4]
700a857a: 4288         	cmp	r0, r1
700a857c: da17         	bge	0x700a85ae <Sciclient_rmIrqCheckLoop+0x7e> @ imm = #0x2e
700a857e: e7ff         	b	0x700a8580 <Sciclient_rmIrqCheckLoop+0x50> @ imm = #-0x2
;             future_n = Sciclient_rmPsGetIrqNode(j);
700a8580: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a8584: f006 fde4    	bl	0x700af150 <Sciclient_rmPsGetIrqNode> @ imm = #0x6bc8
700a8588: 9003         	str	r0, [sp, #0xc]
;             if (cur_n->id == future_n->id) {
700a858a: 9804         	ldr	r0, [sp, #0x10]
700a858c: 8800         	ldrh	r0, [r0]
700a858e: 9903         	ldr	r1, [sp, #0xc]
700a8590: 8809         	ldrh	r1, [r1]
700a8592: 4288         	cmp	r0, r1
700a8594: d104         	bne	0x700a85a0 <Sciclient_rmIrqCheckLoop+0x70> @ imm = #0x8
700a8596: e7ff         	b	0x700a8598 <Sciclient_rmIrqCheckLoop+0x68> @ imm = #-0x2
700a8598: 2001         	movs	r0, #0x1
;                 loop = true;
700a859a: f88d 001b    	strb.w	r0, [sp, #0x1b]
;                 break;
700a859e: e006         	b	0x700a85ae <Sciclient_rmIrqCheckLoop+0x7e> @ imm = #0xc
;         }
700a85a0: e7ff         	b	0x700a85a2 <Sciclient_rmIrqCheckLoop+0x72> @ imm = #-0x2
;         for (j = i + 1u; j < Sciclient_rmPsGetPsp(); j++) {
700a85a2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a85a6: 3001         	adds	r0, #0x1
700a85a8: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a85ac: e7de         	b	0x700a856c <Sciclient_rmIrqCheckLoop+0x3c> @ imm = #-0x44
;         if (loop == true) {
700a85ae: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a85b2: 07c0         	lsls	r0, r0, #0x1f
700a85b4: b108         	cbz	r0, 0x700a85ba <Sciclient_rmIrqCheckLoop+0x8a> @ imm = #0x2
700a85b6: e7ff         	b	0x700a85b8 <Sciclient_rmIrqCheckLoop+0x88> @ imm = #-0x2
;             break;
700a85b8: e006         	b	0x700a85c8 <Sciclient_rmIrqCheckLoop+0x98> @ imm = #0xc
;     }
700a85ba: e7ff         	b	0x700a85bc <Sciclient_rmIrqCheckLoop+0x8c> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a85bc: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a85c0: 3001         	adds	r0, #0x1
700a85c2: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a85c6: e7bc         	b	0x700a8542 <Sciclient_rmIrqCheckLoop+0x12> @ imm = #-0x88
;     return loop;
700a85c8: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a85cc: f000 0001    	and	r0, r0, #0x1
700a85d0: b008         	add	sp, #0x20
700a85d2: bd80         	pop	{r7, pc}
		...

700a85e0 <UART_IsBaseAddrValid>:
; {
700a85e0: b082         	sub	sp, #0x8
700a85e2: 9001         	str	r0, [sp, #0x4]
700a85e4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = (int32_t)-3;
700a85e8: 9000         	str	r0, [sp]
;     if ((baseAddr == CSL_UART0_BASE) ||
700a85ea: 9801         	ldr	r0, [sp, #0x4]
700a85ec: f1b0 7f20    	cmp.w	r0, #0x2800000
700a85f0: d042         	beq	0x700a8678 <UART_IsBaseAddrValid+0x98> @ imm = #0x84
700a85f2: e7ff         	b	0x700a85f4 <UART_IsBaseAddrValid+0x14> @ imm = #-0x2
;         (baseAddr == CSL_UART1_BASE) ||
700a85f4: 9801         	ldr	r0, [sp, #0x4]
700a85f6: 2100         	movs	r1, #0x0
700a85f8: f2c0 2181    	movt	r1, #0x281
700a85fc: 4288         	cmp	r0, r1
700a85fe: d03b         	beq	0x700a8678 <UART_IsBaseAddrValid+0x98> @ imm = #0x76
700a8600: e7ff         	b	0x700a8602 <UART_IsBaseAddrValid+0x22> @ imm = #-0x2
;         (baseAddr == CSL_UART2_BASE) ||
700a8602: 9801         	ldr	r0, [sp, #0x4]
700a8604: 2100         	movs	r1, #0x0
700a8606: f2c0 2182    	movt	r1, #0x282
700a860a: 4288         	cmp	r0, r1
700a860c: d034         	beq	0x700a8678 <UART_IsBaseAddrValid+0x98> @ imm = #0x68
700a860e: e7ff         	b	0x700a8610 <UART_IsBaseAddrValid+0x30> @ imm = #-0x2
;         (baseAddr == CSL_UART3_BASE) ||
700a8610: 9801         	ldr	r0, [sp, #0x4]
700a8612: 2100         	movs	r1, #0x0
700a8614: f2c0 2183    	movt	r1, #0x283
700a8618: 4288         	cmp	r0, r1
700a861a: d02d         	beq	0x700a8678 <UART_IsBaseAddrValid+0x98> @ imm = #0x5a
700a861c: e7ff         	b	0x700a861e <UART_IsBaseAddrValid+0x3e> @ imm = #-0x2
;         (baseAddr == CSL_UART4_BASE) ||
700a861e: 9801         	ldr	r0, [sp, #0x4]
700a8620: f1b0 7f21    	cmp.w	r0, #0x2840000
700a8624: d028         	beq	0x700a8678 <UART_IsBaseAddrValid+0x98> @ imm = #0x50
700a8626: e7ff         	b	0x700a8628 <UART_IsBaseAddrValid+0x48> @ imm = #-0x2
;         (baseAddr == CSL_UART5_BASE) ||
700a8628: 9801         	ldr	r0, [sp, #0x4]
700a862a: 2100         	movs	r1, #0x0
700a862c: f2c0 2185    	movt	r1, #0x285
700a8630: 4288         	cmp	r0, r1
700a8632: d021         	beq	0x700a8678 <UART_IsBaseAddrValid+0x98> @ imm = #0x42
700a8634: e7ff         	b	0x700a8636 <UART_IsBaseAddrValid+0x56> @ imm = #-0x2
;         (baseAddr == CSL_UART6_BASE) ||
700a8636: 9801         	ldr	r0, [sp, #0x4]
700a8638: 2100         	movs	r1, #0x0
700a863a: f2c0 2186    	movt	r1, #0x286
700a863e: 4288         	cmp	r0, r1
700a8640: d01a         	beq	0x700a8678 <UART_IsBaseAddrValid+0x98> @ imm = #0x34
700a8642: e7ff         	b	0x700a8644 <UART_IsBaseAddrValid+0x64> @ imm = #-0x2
;         (baseAddr == CSL_MCU_UART0_BASE) ||
700a8644: 9801         	ldr	r0, [sp, #0x4]
700a8646: f1b0 6f94    	cmp.w	r0, #0x4a00000
700a864a: d015         	beq	0x700a8678 <UART_IsBaseAddrValid+0x98> @ imm = #0x2a
700a864c: e7ff         	b	0x700a864e <UART_IsBaseAddrValid+0x6e> @ imm = #-0x2
;         (baseAddr == CSL_MCU_UART1_BASE) ||
700a864e: 9801         	ldr	r0, [sp, #0x4]
700a8650: 2100         	movs	r1, #0x0
700a8652: f2c0 41a1    	movt	r1, #0x4a1
700a8656: 4288         	cmp	r0, r1
700a8658: d00e         	beq	0x700a8678 <UART_IsBaseAddrValid+0x98> @ imm = #0x1c
700a865a: e7ff         	b	0x700a865c <UART_IsBaseAddrValid+0x7c> @ imm = #-0x2
;         (baseAddr == MCU_UART0_BASE_AFTER_ADDR_TRANSLATE) ||
700a865c: 9801         	ldr	r0, [sp, #0x4]
700a865e: 2100         	movs	r1, #0x0
700a8660: f2c8 41a0    	movt	r1, #0x84a0
700a8664: 4288         	cmp	r0, r1
700a8666: d007         	beq	0x700a8678 <UART_IsBaseAddrValid+0x98> @ imm = #0xe
700a8668: e7ff         	b	0x700a866a <UART_IsBaseAddrValid+0x8a> @ imm = #-0x2
;         (baseAddr == MCU_UART1_BASE_AFTER_ADDR_TRANSLATE))
700a866a: 9801         	ldr	r0, [sp, #0x4]
700a866c: 2100         	movs	r1, #0x0
700a866e: f2c8 41a1    	movt	r1, #0x84a1
;     if ((baseAddr == CSL_UART0_BASE) ||
700a8672: 4288         	cmp	r0, r1
700a8674: d103         	bne	0x700a867e <UART_IsBaseAddrValid+0x9e> @ imm = #0x6
700a8676: e7ff         	b	0x700a8678 <UART_IsBaseAddrValid+0x98> @ imm = #-0x2
700a8678: 2000         	movs	r0, #0x0
;         status = 0;
700a867a: 9000         	str	r0, [sp]
;     }
700a867c: e7ff         	b	0x700a867e <UART_IsBaseAddrValid+0x9e> @ imm = #-0x2
;     return status;
700a867e: 9800         	ldr	r0, [sp]
700a8680: b002         	add	sp, #0x8
700a8682: 4770         	bx	lr

700a8684 <split>:
700a8684: e92d48f0     	push	{r4, r5, r6, r7, r11, lr}
700a8688: e1a04000     	mov	r4, r0
700a868c: e5900000     	ldr	r0, [r0]
700a8690: e1a05001     	mov	r5, r1
700a8694: e3c01001     	bic	r1, r0, #1
700a8698: e0411005     	sub	r1, r1, r5
700a869c: e3510010     	cmp	r1, #16
700a86a0: 3a00001b     	blo	0x700a8714 <split+0x90> @ imm = #0x6c
700a86a4: e2410008     	sub	r0, r1, #8
700a86a8: e0846005     	add	r6, r4, r5
700a86ac: e59f106c     	ldr	r1, [pc, #0x6c]         @ 0x700a8720 <split+0x9c>
700a86b0: e59f206c     	ldr	r2, [pc, #0x6c]         @ 0x700a8724 <split+0xa0>
700a86b4: e5a60008     	str	r0, [r6, #0x8]!
700a86b8: e3c00001     	bic	r0, r0, #1
700a86bc: e3520007     	cmp	r2, #7
700a86c0: e0860000     	add	r0, r6, r0
700a86c4: e2807008     	add	r7, r0, #8
700a86c8: e0820001     	add	r0, r2, r1
700a86cc: 82401008     	subhi	r1, r0, #8
700a86d0: e1570001     	cmp	r7, r1
700a86d4: 2a00000b     	bhs	0x700a8708 <split+0x84> @ imm = #0x2c
700a86d8: e5d70000     	ldrb	r0, [r7]
700a86dc: e3100001     	tst	r0, #1
700a86e0: 1a000008     	bne	0x700a8708 <split+0x84> @ imm = #0x20
700a86e4: e1a00007     	mov	r0, r7
700a86e8: eb001719     	bl	0x700ae354 <free_list_remove> @ imm = #0x5c64
700a86ec: e5960000     	ldr	r0, [r6]
700a86f0: e5971000     	ldr	r1, [r7]
700a86f4: e2800008     	add	r0, r0, #8
700a86f8: e3c11001     	bic	r1, r1, #1
700a86fc: e3c00001     	bic	r0, r0, #1
700a8700: e0800001     	add	r0, r0, r1
700a8704: e5860000     	str	r0, [r6]
700a8708: e1a00006     	mov	r0, r6
700a870c: eb0014d3     	bl	0x700ada60 <free_list_insert> @ imm = #0x534c
700a8710: e1a00005     	mov	r0, r5
700a8714: e3800001     	orr	r0, r0, #1
700a8718: e5840000     	str	r0, [r4]
700a871c: e8bd88f0     	pop	{r4, r5, r6, r7, r11, pc}
700a8720: 80 52 08 70  	.word	0x70085280
700a8724: 00 00 01 00  	.word	0x00010000
700a8728: 00 00 00 00  	.word	0x00000000
700a872c: 00 00 00 00  	.word	0x00000000

700a8730 <vTaskResume>:
; void vTaskResume(TaskHandle_t xTaskToResume) {
700a8730: b580         	push	{r7, lr}
700a8732: b082         	sub	sp, #0x8
700a8734: 9001         	str	r0, [sp, #0x4]
;   TCB_t *const pxTCB = xTaskToResume;
700a8736: 9801         	ldr	r0, [sp, #0x4]
700a8738: 9000         	str	r0, [sp]
;   if ((pxTCB != pxCurrentTCB) && (pxTCB != NULL)) {
700a873a: 9800         	ldr	r0, [sp]
700a873c: f242 61bc    	movw	r1, #0x26bc
700a8740: f2c7 010b    	movt	r1, #0x700b
700a8744: 6809         	ldr	r1, [r1]
700a8746: 4288         	cmp	r0, r1
700a8748: d041         	beq	0x700a87ce <vTaskResume+0x9e> @ imm = #0x82
700a874a: e7ff         	b	0x700a874c <vTaskResume+0x1c> @ imm = #-0x2
700a874c: 9800         	ldr	r0, [sp]
700a874e: 2800         	cmp	r0, #0x0
700a8750: d03d         	beq	0x700a87ce <vTaskResume+0x9e> @ imm = #0x7a
700a8752: e7ff         	b	0x700a8754 <vTaskResume+0x24> @ imm = #-0x2
;     taskENTER_CRITICAL();
700a8754: f005 febc    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0x5d78
;       if (prvTaskIsTaskSuspended(pxTCB) != pdFALSE) {
700a8758: 9800         	ldr	r0, [sp]
700a875a: f004 fc61    	bl	0x700ad020 <prvTaskIsTaskSuspended> @ imm = #0x48c2
700a875e: b390         	cbz	r0, 0x700a87c6 <vTaskResume+0x96> @ imm = #0x64
700a8760: e7ff         	b	0x700a8762 <vTaskResume+0x32> @ imm = #-0x2
;         (void)uxListRemove(&(pxTCB->xStateListItem));
700a8762: 9800         	ldr	r0, [sp]
700a8764: 3004         	adds	r0, #0x4
700a8766: f004 fe83    	bl	0x700ad470 <uxListRemove> @ imm = #0x4d06
;         prvAddTaskToReadyList(pxTCB);
700a876a: 9800         	ldr	r0, [sp]
700a876c: 6ac0         	ldr	r0, [r0, #0x2c]
700a876e: f242 61ec    	movw	r1, #0x26ec
700a8772: f2c7 010b    	movt	r1, #0x700b
700a8776: 6809         	ldr	r1, [r1]
700a8778: 4288         	cmp	r0, r1
700a877a: d908         	bls	0x700a878e <vTaskResume+0x5e> @ imm = #0x10
700a877c: e7ff         	b	0x700a877e <vTaskResume+0x4e> @ imm = #-0x2
700a877e: 9800         	ldr	r0, [sp]
700a8780: 6ac0         	ldr	r0, [r0, #0x2c]
700a8782: f242 61ec    	movw	r1, #0x26ec
700a8786: f2c7 010b    	movt	r1, #0x700b
700a878a: 6008         	str	r0, [r1]
700a878c: e7ff         	b	0x700a878e <vTaskResume+0x5e> @ imm = #-0x2
700a878e: 9900         	ldr	r1, [sp]
700a8790: 6ac8         	ldr	r0, [r1, #0x2c]
700a8792: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a8796: f244 40f8    	movw	r0, #0x44f8
700a879a: f2c7 0008    	movt	r0, #0x7008
700a879e: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a87a2: 3104         	adds	r1, #0x4
700a87a4: f005 fc1c    	bl	0x700adfe0 <vListInsertEnd> @ imm = #0x5838
;         if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a87a8: 9800         	ldr	r0, [sp]
700a87aa: 6ac0         	ldr	r0, [r0, #0x2c]
700a87ac: f242 61bc    	movw	r1, #0x26bc
700a87b0: f2c7 010b    	movt	r1, #0x700b
700a87b4: 6809         	ldr	r1, [r1]
700a87b6: 6ac9         	ldr	r1, [r1, #0x2c]
700a87b8: 4288         	cmp	r0, r1
700a87ba: d302         	blo	0x700a87c2 <vTaskResume+0x92> @ imm = #0x4
700a87bc: e7ff         	b	0x700a87be <vTaskResume+0x8e> @ imm = #-0x2
;           taskYIELD_IF_USING_PREEMPTION();
700a87be: df00         	svc	#0x0
;         } else {
700a87c0: e000         	b	0x700a87c4 <vTaskResume+0x94> @ imm = #0x0
700a87c2: e7ff         	b	0x700a87c4 <vTaskResume+0x94> @ imm = #-0x2
;       } else {
700a87c4: e000         	b	0x700a87c8 <vTaskResume+0x98> @ imm = #0x0
700a87c6: e7ff         	b	0x700a87c8 <vTaskResume+0x98> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700a87c8: f004 ff42    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0x4e84
;   } else {
700a87cc: e000         	b	0x700a87d0 <vTaskResume+0xa0> @ imm = #0x0
700a87ce: e7ff         	b	0x700a87d0 <vTaskResume+0xa0> @ imm = #-0x2
; }
700a87d0: b002         	add	sp, #0x8
700a87d2: bd80         	pop	{r7, pc}
		...

700a87e0 <xQueueGenericSendFromISR>:
; {
700a87e0: b580         	push	{r7, lr}
700a87e2: b08a         	sub	sp, #0x28
700a87e4: 9009         	str	r0, [sp, #0x24]
700a87e6: 9108         	str	r1, [sp, #0x20]
700a87e8: 9207         	str	r2, [sp, #0x1c]
700a87ea: 9306         	str	r3, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a87ec: 9809         	ldr	r0, [sp, #0x24]
700a87ee: 9003         	str	r0, [sp, #0xc]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a87f0: f007 ef36    	blx	0x700b0660 <HwiP_disable> @ imm = #0x7e6c
700a87f4: 9004         	str	r0, [sp, #0x10]
;         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
700a87f6: 9803         	ldr	r0, [sp, #0xc]
700a87f8: 6b80         	ldr	r0, [r0, #0x38]
700a87fa: 9903         	ldr	r1, [sp, #0xc]
700a87fc: 6bc9         	ldr	r1, [r1, #0x3c]
700a87fe: 4288         	cmp	r0, r1
700a8800: d304         	blo	0x700a880c <xQueueGenericSendFromISR+0x2c> @ imm = #0x8
700a8802: e7ff         	b	0x700a8804 <xQueueGenericSendFromISR+0x24> @ imm = #-0x2
700a8804: 9806         	ldr	r0, [sp, #0x18]
700a8806: 2802         	cmp	r0, #0x2
700a8808: d133         	bne	0x700a8872 <xQueueGenericSendFromISR+0x92> @ imm = #0x66
700a880a: e7ff         	b	0x700a880c <xQueueGenericSendFromISR+0x2c> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
700a880c: 9803         	ldr	r0, [sp, #0xc]
700a880e: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a8812: f88d 000b    	strb.w	r0, [sp, #0xb]
;             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
700a8816: 9803         	ldr	r0, [sp, #0xc]
700a8818: 6b80         	ldr	r0, [r0, #0x38]
700a881a: 9001         	str	r0, [sp, #0x4]
;             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
700a881c: 9803         	ldr	r0, [sp, #0xc]
700a881e: 9908         	ldr	r1, [sp, #0x20]
700a8820: 9a06         	ldr	r2, [sp, #0x18]
700a8822: f7fe f865    	bl	0x700a68f0 <prvCopyDataToQueue> @ imm = #-0x1f36
;             if( cTxLock == queueUNLOCKED )
700a8826: f99d 000b    	ldrsb.w	r0, [sp, #0xb]
700a882a: 3001         	adds	r0, #0x1
700a882c: b9b8         	cbnz	r0, 0x700a885e <xQueueGenericSendFromISR+0x7e> @ imm = #0x2e
700a882e: e7ff         	b	0x700a8830 <xQueueGenericSendFromISR+0x50> @ imm = #-0x2
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a8830: 9803         	ldr	r0, [sp, #0xc]
700a8832: 6a40         	ldr	r0, [r0, #0x24]
700a8834: b188         	cbz	r0, 0x700a885a <xQueueGenericSendFromISR+0x7a> @ imm = #0x22
700a8836: e7ff         	b	0x700a8838 <xQueueGenericSendFromISR+0x58> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a8838: 9803         	ldr	r0, [sp, #0xc]
700a883a: 3024         	adds	r0, #0x24
700a883c: f7fe ffd8    	bl	0x700a77f0 <xTaskRemoveFromEventList> @ imm = #-0x1050
700a8840: b148         	cbz	r0, 0x700a8856 <xQueueGenericSendFromISR+0x76> @ imm = #0x12
700a8842: e7ff         	b	0x700a8844 <xQueueGenericSendFromISR+0x64> @ imm = #-0x2
;                                 if( pxHigherPriorityTaskWoken != NULL )
700a8844: 9807         	ldr	r0, [sp, #0x1c]
700a8846: b120         	cbz	r0, 0x700a8852 <xQueueGenericSendFromISR+0x72> @ imm = #0x8
700a8848: e7ff         	b	0x700a884a <xQueueGenericSendFromISR+0x6a> @ imm = #-0x2
;                                     *pxHigherPriorityTaskWoken = pdTRUE;
700a884a: 9907         	ldr	r1, [sp, #0x1c]
700a884c: 2001         	movs	r0, #0x1
700a884e: 6008         	str	r0, [r1]
;                                 }
700a8850: e000         	b	0x700a8854 <xQueueGenericSendFromISR+0x74> @ imm = #0x0
700a8852: e7ff         	b	0x700a8854 <xQueueGenericSendFromISR+0x74> @ imm = #-0x2
;                             }
700a8854: e000         	b	0x700a8858 <xQueueGenericSendFromISR+0x78> @ imm = #0x0
700a8856: e7ff         	b	0x700a8858 <xQueueGenericSendFromISR+0x78> @ imm = #-0x2
;                         }
700a8858: e000         	b	0x700a885c <xQueueGenericSendFromISR+0x7c> @ imm = #0x0
700a885a: e7ff         	b	0x700a885c <xQueueGenericSendFromISR+0x7c> @ imm = #-0x2
;             }
700a885c: e006         	b	0x700a886c <xQueueGenericSendFromISR+0x8c> @ imm = #0xc
;                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
700a885e: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a8862: 3001         	adds	r0, #0x1
700a8864: 9903         	ldr	r1, [sp, #0xc]
700a8866: f881 0045    	strb.w	r0, [r1, #0x45]
700a886a: e7ff         	b	0x700a886c <xQueueGenericSendFromISR+0x8c> @ imm = #-0x2
700a886c: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a886e: 9005         	str	r0, [sp, #0x14]
;         }
700a8870: e002         	b	0x700a8878 <xQueueGenericSendFromISR+0x98> @ imm = #0x4
700a8872: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
700a8874: 9005         	str	r0, [sp, #0x14]
700a8876: e7ff         	b	0x700a8878 <xQueueGenericSendFromISR+0x98> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a8878: 9804         	ldr	r0, [sp, #0x10]
700a887a: f007 ef12    	blx	0x700b06a0 <HwiP_restore> @ imm = #0x7e24
;     return xReturn;
700a887e: 9805         	ldr	r0, [sp, #0x14]
700a8880: b00a         	add	sp, #0x28
700a8882: bd80         	pop	{r7, pc}
		...

700a8890 <prvCheckForValidListAndQueue>:
;     {
700a8890: b580         	push	{r7, lr}
700a8892: b084         	sub	sp, #0x10
;         taskENTER_CRITICAL();
700a8894: f005 fe1c    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0x5c38
;             if( xTimerQueue == NULL )
700a8898: f242 7008    	movw	r0, #0x2708
700a889c: f2c7 000b    	movt	r0, #0x700b
700a88a0: 6800         	ldr	r0, [r0]
700a88a2: 2800         	cmp	r0, #0x0
700a88a4: d140         	bne	0x700a8928 <prvCheckForValidListAndQueue+0x98> @ imm = #0x80
700a88a6: e7ff         	b	0x700a88a8 <prvCheckForValidListAndQueue+0x18> @ imm = #-0x2
;                 vListInitialise( &xActiveTimerList1 );
700a88a8: f245 1090    	movw	r0, #0x5190
700a88ac: f2c7 0008    	movt	r0, #0x7008
700a88b0: 9002         	str	r0, [sp, #0x8]
700a88b2: f005 ff9d    	bl	0x700ae7f0 <vListInitialise> @ imm = #0x5f3a
;                 vListInitialise( &xActiveTimerList2 );
700a88b6: f245 10a4    	movw	r0, #0x51a4
700a88ba: f2c7 0008    	movt	r0, #0x7008
700a88be: 9003         	str	r0, [sp, #0xc]
700a88c0: f005 ff96    	bl	0x700ae7f0 <vListInitialise> @ imm = #0x5f2c
700a88c4: 9902         	ldr	r1, [sp, #0x8]
700a88c6: 9803         	ldr	r0, [sp, #0xc]
;                 pxCurrentTimerList = &xActiveTimerList1;
700a88c8: f245 221c    	movw	r2, #0x521c
700a88cc: f2c7 0208    	movt	r2, #0x7008
700a88d0: 6011         	str	r1, [r2]
;                 pxOverflowTimerList = &xActiveTimerList2;
700a88d2: f245 2128    	movw	r1, #0x5228
700a88d6: f2c7 0108    	movt	r1, #0x7008
700a88da: 6008         	str	r0, [r1]
;                         xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
700a88dc: 4669         	mov	r1, sp
700a88de: 2000         	movs	r0, #0x0
700a88e0: 6008         	str	r0, [r1]
700a88e2: f644 3278    	movw	r2, #0x4b78
700a88e6: f2c7 0208    	movt	r2, #0x7008
700a88ea: f241 0308    	movw	r3, #0x1008
700a88ee: f2c7 0308    	movt	r3, #0x7008
700a88f2: 2110         	movs	r1, #0x10
700a88f4: 4608         	mov	r0, r1
700a88f6: f004 fd23    	bl	0x700ad340 <xQueueGenericCreateStatic> @ imm = #0x4a46
700a88fa: 4601         	mov	r1, r0
700a88fc: f242 7008    	movw	r0, #0x2708
700a8900: f2c7 000b    	movt	r0, #0x700b
700a8904: 6001         	str	r1, [r0]
;                         if( xTimerQueue != NULL )
700a8906: 6800         	ldr	r0, [r0]
700a8908: b160         	cbz	r0, 0x700a8924 <prvCheckForValidListAndQueue+0x94> @ imm = #0x18
700a890a: e7ff         	b	0x700a890c <prvCheckForValidListAndQueue+0x7c> @ imm = #-0x2
;                             vQueueAddToRegistry( xTimerQueue, "TmrQ" );
700a890c: f242 7008    	movw	r0, #0x2708
700a8910: f2c7 000b    	movt	r0, #0x700b
700a8914: 6800         	ldr	r0, [r0]
700a8916: f242 21e4    	movw	r1, #0x22e4
700a891a: f2c7 010b    	movt	r1, #0x700b
700a891e: f004 fa7f    	bl	0x700ace20 <vQueueAddToRegistry> @ imm = #0x44fe
;                         }
700a8922: e000         	b	0x700a8926 <prvCheckForValidListAndQueue+0x96> @ imm = #0x0
700a8924: e7ff         	b	0x700a8926 <prvCheckForValidListAndQueue+0x96> @ imm = #-0x2
;             }
700a8926: e000         	b	0x700a892a <prvCheckForValidListAndQueue+0x9a> @ imm = #0x0
700a8928: e7ff         	b	0x700a892a <prvCheckForValidListAndQueue+0x9a> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a892a: f004 fe91    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0x4d22
;     }
700a892e: b004         	add	sp, #0x10
700a8930: bd80         	pop	{r7, pc}
		...
700a893e: 0000         	movs	r0, r0

700a8940 <Udma_rmAllocEvent>:
; {
700a8940: b580         	push	{r7, lr}
700a8942: b088         	sub	sp, #0x20
700a8944: 9007         	str	r0, [sp, #0x1c]
700a8946: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            globalEvent = UDMA_EVENT_INVALID;
700a894a: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a894c: 9807         	ldr	r0, [sp, #0x1c]
700a894e: f500 70ea    	add.w	r0, r0, #0x1d4
700a8952: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a8954: 9807         	ldr	r0, [sp, #0x1c]
700a8956: f500 609f    	add.w	r0, r0, #0x4f8
700a895a: f04f 31ff    	mov.w	r1, #0xffffffff
700a895e: f001 fe0f    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x1c1e
700a8962: 2000         	movs	r0, #0x0
;     for(i = 0U; i < rmInitPrms->numGlobalEvent; i++)
700a8964: 9005         	str	r0, [sp, #0x14]
700a8966: e7ff         	b	0x700a8968 <Udma_rmAllocEvent+0x28> @ imm = #-0x2
700a8968: 9805         	ldr	r0, [sp, #0x14]
700a896a: 9901         	ldr	r1, [sp, #0x4]
700a896c: f8d1 10dc    	ldr.w	r1, [r1, #0xdc]
700a8970: 4288         	cmp	r0, r1
700a8972: d22d         	bhs	0x700a89d0 <Udma_rmAllocEvent+0x90> @ imm = #0x5a
700a8974: e7ff         	b	0x700a8976 <Udma_rmAllocEvent+0x36> @ imm = #-0x2
;         offset = i >> 5U;
700a8976: 9805         	ldr	r0, [sp, #0x14]
700a8978: 0940         	lsrs	r0, r0, #0x5
700a897a: 9004         	str	r0, [sp, #0x10]
;         bitPos = i - (offset << 5U);
700a897c: 9805         	ldr	r0, [sp, #0x14]
700a897e: 9904         	ldr	r1, [sp, #0x10]
700a8980: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a8984: 9003         	str	r0, [sp, #0xc]
;         bitMask = (uint32_t) 1U << bitPos;
700a8986: 9903         	ldr	r1, [sp, #0xc]
700a8988: 2001         	movs	r0, #0x1
700a898a: 4088         	lsls	r0, r1
700a898c: 9002         	str	r0, [sp, #0x8]
;         if((drvHandle->globalEventFlag[offset] & bitMask) == bitMask)
700a898e: 9807         	ldr	r0, [sp, #0x1c]
700a8990: 9904         	ldr	r1, [sp, #0x10]
700a8992: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a8996: f8d0 0424    	ldr.w	r0, [r0, #0x424]
700a899a: 9902         	ldr	r1, [sp, #0x8]
700a899c: 4008         	ands	r0, r1
700a899e: 4288         	cmp	r0, r1
700a89a0: d111         	bne	0x700a89c6 <Udma_rmAllocEvent+0x86> @ imm = #0x22
700a89a2: e7ff         	b	0x700a89a4 <Udma_rmAllocEvent+0x64> @ imm = #-0x2
;             drvHandle->globalEventFlag[offset] &= ~bitMask;
700a89a4: 9a02         	ldr	r2, [sp, #0x8]
700a89a6: 9807         	ldr	r0, [sp, #0x1c]
700a89a8: 9904         	ldr	r1, [sp, #0x10]
700a89aa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a89ae: f8d1 0424    	ldr.w	r0, [r1, #0x424]
700a89b2: 4390         	bics	r0, r2
700a89b4: f8c1 0424    	str.w	r0, [r1, #0x424]
;             globalEvent = i + rmInitPrms->startGlobalEvent;  /* Add start offset */
700a89b8: 9805         	ldr	r0, [sp, #0x14]
700a89ba: 9901         	ldr	r1, [sp, #0x4]
700a89bc: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a89c0: 4408         	add	r0, r1
700a89c2: 9006         	str	r0, [sp, #0x18]
;             break;
700a89c4: e004         	b	0x700a89d0 <Udma_rmAllocEvent+0x90> @ imm = #0x8
;     }
700a89c6: e7ff         	b	0x700a89c8 <Udma_rmAllocEvent+0x88> @ imm = #-0x2
;     for(i = 0U; i < rmInitPrms->numGlobalEvent; i++)
700a89c8: 9805         	ldr	r0, [sp, #0x14]
700a89ca: 3001         	adds	r0, #0x1
700a89cc: 9005         	str	r0, [sp, #0x14]
700a89ce: e7cb         	b	0x700a8968 <Udma_rmAllocEvent+0x28> @ imm = #-0x6a
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a89d0: 9807         	ldr	r0, [sp, #0x1c]
700a89d2: f500 609f    	add.w	r0, r0, #0x4f8
700a89d6: f003 f963    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x32c6
;     return (globalEvent);
700a89da: 9806         	ldr	r0, [sp, #0x18]
700a89dc: b008         	add	sp, #0x20
700a89de: bd80         	pop	{r7, pc}

700a89e0 <Udma_rmAllocVintr>:
; {
700a89e0: b580         	push	{r7, lr}
700a89e2: b088         	sub	sp, #0x20
700a89e4: 9007         	str	r0, [sp, #0x1c]
700a89e6: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            vintrNum = UDMA_EVENT_INVALID;
700a89ea: 9002         	str	r0, [sp, #0x8]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a89ec: 9807         	ldr	r0, [sp, #0x1c]
700a89ee: f500 70ea    	add.w	r0, r0, #0x1d4
700a89f2: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a89f4: 9807         	ldr	r0, [sp, #0x1c]
700a89f6: f500 609f    	add.w	r0, r0, #0x4f8
700a89fa: f04f 31ff    	mov.w	r1, #0xffffffff
700a89fe: f001 fdbf    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x1b7e
700a8a02: 2000         	movs	r0, #0x0
;     for(i = 0U; i < rmInitPrms->numVintr; i++)
700a8a04: 9006         	str	r0, [sp, #0x18]
700a8a06: e7ff         	b	0x700a8a08 <Udma_rmAllocVintr+0x28> @ imm = #-0x2
700a8a08: 9806         	ldr	r0, [sp, #0x18]
700a8a0a: 9901         	ldr	r1, [sp, #0x4]
700a8a0c: f8d1 10e4    	ldr.w	r1, [r1, #0xe4]
700a8a10: 4288         	cmp	r0, r1
700a8a12: d22d         	bhs	0x700a8a70 <Udma_rmAllocVintr+0x90> @ imm = #0x5a
700a8a14: e7ff         	b	0x700a8a16 <Udma_rmAllocVintr+0x36> @ imm = #-0x2
;         offset = i >> 5U;
700a8a16: 9806         	ldr	r0, [sp, #0x18]
700a8a18: 0940         	lsrs	r0, r0, #0x5
700a8a1a: 9005         	str	r0, [sp, #0x14]
;         bitPos = i - (offset << 5U);
700a8a1c: 9806         	ldr	r0, [sp, #0x18]
700a8a1e: 9905         	ldr	r1, [sp, #0x14]
700a8a20: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a8a24: 9004         	str	r0, [sp, #0x10]
;         bitMask = (uint32_t) 1U << bitPos;
700a8a26: 9904         	ldr	r1, [sp, #0x10]
700a8a28: 2001         	movs	r0, #0x1
700a8a2a: 4088         	lsls	r0, r1
700a8a2c: 9003         	str	r0, [sp, #0xc]
;         if((drvHandle->vintrFlag[offset] & bitMask) == bitMask)
700a8a2e: 9807         	ldr	r0, [sp, #0x1c]
700a8a30: 9905         	ldr	r1, [sp, #0x14]
700a8a32: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a8a36: f8d0 04a4    	ldr.w	r0, [r0, #0x4a4]
700a8a3a: 9903         	ldr	r1, [sp, #0xc]
700a8a3c: 4008         	ands	r0, r1
700a8a3e: 4288         	cmp	r0, r1
700a8a40: d111         	bne	0x700a8a66 <Udma_rmAllocVintr+0x86> @ imm = #0x22
700a8a42: e7ff         	b	0x700a8a44 <Udma_rmAllocVintr+0x64> @ imm = #-0x2
;             drvHandle->vintrFlag[offset] &= ~bitMask;
700a8a44: 9a03         	ldr	r2, [sp, #0xc]
700a8a46: 9807         	ldr	r0, [sp, #0x1c]
700a8a48: 9905         	ldr	r1, [sp, #0x14]
700a8a4a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a8a4e: f8d1 04a4    	ldr.w	r0, [r1, #0x4a4]
700a8a52: 4390         	bics	r0, r2
700a8a54: f8c1 04a4    	str.w	r0, [r1, #0x4a4]
;             vintrNum = i + rmInitPrms->startVintr;  /* Add start offset */
700a8a58: 9806         	ldr	r0, [sp, #0x18]
700a8a5a: 9901         	ldr	r1, [sp, #0x4]
700a8a5c: f8d1 10e0    	ldr.w	r1, [r1, #0xe0]
700a8a60: 4408         	add	r0, r1
700a8a62: 9002         	str	r0, [sp, #0x8]
;             break;
700a8a64: e004         	b	0x700a8a70 <Udma_rmAllocVintr+0x90> @ imm = #0x8
;     }
700a8a66: e7ff         	b	0x700a8a68 <Udma_rmAllocVintr+0x88> @ imm = #-0x2
;     for(i = 0U; i < rmInitPrms->numVintr; i++)
700a8a68: 9806         	ldr	r0, [sp, #0x18]
700a8a6a: 3001         	adds	r0, #0x1
700a8a6c: 9006         	str	r0, [sp, #0x18]
700a8a6e: e7cb         	b	0x700a8a08 <Udma_rmAllocVintr+0x28> @ imm = #-0x6a
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a8a70: 9807         	ldr	r0, [sp, #0x1c]
700a8a72: f500 609f    	add.w	r0, r0, #0x4f8
700a8a76: f003 f913    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x3226
;     return (vintrNum);
700a8a7a: 9802         	ldr	r0, [sp, #0x8]
700a8a7c: b008         	add	sp, #0x20
700a8a7e: bd80         	pop	{r7, pc}

700a8a80 <Sciclient_getContext>:
; {
700a8a80: b084         	sub	sp, #0x10
700a8a82: 9003         	str	r0, [sp, #0xc]
700a8a84: 9102         	str	r1, [sp, #0x8]
700a8a86: 200f         	movs	r0, #0xf
;     uint32_t retVal = SCICLIENT_CONTEXT_MAX_NUM;
700a8a88: 9001         	str	r0, [sp, #0x4]
;     switch (coreId)
700a8a8a: 9802         	ldr	r0, [sp, #0x8]
700a8a8c: 9000         	str	r0, [sp]
700a8a8e: 2805         	cmp	r0, #0x5
700a8a90: d841         	bhi	0x700a8b16 <Sciclient_getContext+0x96> @ imm = #0x82
700a8a92: 9900         	ldr	r1, [sp]
700a8a94: e8df f001    	tbb	[pc, r1]
700a8a98: 03 0d 17 21  	.word	0x21170d03
700a8a9c: 2b 35        	.short	0x352b
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8a9e: 9803         	ldr	r0, [sp, #0xc]
700a8aa0: b918         	cbnz	r0, 0x700a8aaa <Sciclient_getContext+0x2a> @ imm = #0x6
700a8aa2: e7ff         	b	0x700a8aa4 <Sciclient_getContext+0x24> @ imm = #-0x2
700a8aa4: 200e         	movs	r0, #0xe
;             retVal = SCICLIENT_CONTEXT_M4_SEC_0;
700a8aa6: 9001         	str	r0, [sp, #0x4]
;         }
700a8aa8: e002         	b	0x700a8ab0 <Sciclient_getContext+0x30> @ imm = #0x4
700a8aaa: 2008         	movs	r0, #0x8
;             retVal = SCICLIENT_CONTEXT_M4_NONSEC_0;
700a8aac: 9001         	str	r0, [sp, #0x4]
700a8aae: e7ff         	b	0x700a8ab0 <Sciclient_getContext+0x30> @ imm = #-0x2
;         break;
700a8ab0: e032         	b	0x700a8b18 <Sciclient_getContext+0x98> @ imm = #0x64
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8ab2: 9803         	ldr	r0, [sp, #0xc]
700a8ab4: b918         	cbnz	r0, 0x700a8abe <Sciclient_getContext+0x3e> @ imm = #0x6
700a8ab6: e7ff         	b	0x700a8ab8 <Sciclient_getContext+0x38> @ imm = #-0x2
700a8ab8: 2000         	movs	r0, #0x0
;             retVal = SCICLIENT_CONTEXT_R5_0_SEC_0;
700a8aba: 9001         	str	r0, [sp, #0x4]
;         }
700a8abc: e002         	b	0x700a8ac4 <Sciclient_getContext+0x44> @ imm = #0x4
700a8abe: 2001         	movs	r0, #0x1
;             retVal = SCICLIENT_CONTEXT_R5_0_NONSEC_0;
700a8ac0: 9001         	str	r0, [sp, #0x4]
700a8ac2: e7ff         	b	0x700a8ac4 <Sciclient_getContext+0x44> @ imm = #-0x2
;         break;
700a8ac4: e028         	b	0x700a8b18 <Sciclient_getContext+0x98> @ imm = #0x50
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8ac6: 9803         	ldr	r0, [sp, #0xc]
700a8ac8: b918         	cbnz	r0, 0x700a8ad2 <Sciclient_getContext+0x52> @ imm = #0x6
700a8aca: e7ff         	b	0x700a8acc <Sciclient_getContext+0x4c> @ imm = #-0x2
700a8acc: 2002         	movs	r0, #0x2
;             retVal = SCICLIENT_CONTEXT_R5_0_SEC_1;
700a8ace: 9001         	str	r0, [sp, #0x4]
;         }
700a8ad0: e002         	b	0x700a8ad8 <Sciclient_getContext+0x58> @ imm = #0x4
700a8ad2: 2003         	movs	r0, #0x3
;             retVal = SCICLIENT_CONTEXT_R5_0_NONSEC_1;
700a8ad4: 9001         	str	r0, [sp, #0x4]
700a8ad6: e7ff         	b	0x700a8ad8 <Sciclient_getContext+0x58> @ imm = #-0x2
;         break;
700a8ad8: e01e         	b	0x700a8b18 <Sciclient_getContext+0x98> @ imm = #0x3c
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8ada: 9803         	ldr	r0, [sp, #0xc]
700a8adc: b918         	cbnz	r0, 0x700a8ae6 <Sciclient_getContext+0x66> @ imm = #0x6
700a8ade: e7ff         	b	0x700a8ae0 <Sciclient_getContext+0x60> @ imm = #-0x2
700a8ae0: 2009         	movs	r0, #0x9
;             retVal = SCICLIENT_CONTEXT_R5_1_SEC_0;
700a8ae2: 9001         	str	r0, [sp, #0x4]
;         }
700a8ae4: e002         	b	0x700a8aec <Sciclient_getContext+0x6c> @ imm = #0x4
700a8ae6: 200a         	movs	r0, #0xa
;             retVal = SCICLIENT_CONTEXT_R5_1_NONSEC_0;
700a8ae8: 9001         	str	r0, [sp, #0x4]
700a8aea: e7ff         	b	0x700a8aec <Sciclient_getContext+0x6c> @ imm = #-0x2
;         break;
700a8aec: e014         	b	0x700a8b18 <Sciclient_getContext+0x98> @ imm = #0x28
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8aee: 9803         	ldr	r0, [sp, #0xc]
700a8af0: b918         	cbnz	r0, 0x700a8afa <Sciclient_getContext+0x7a> @ imm = #0x6
700a8af2: e7ff         	b	0x700a8af4 <Sciclient_getContext+0x74> @ imm = #-0x2
700a8af4: 200b         	movs	r0, #0xb
;             retVal = SCICLIENT_CONTEXT_R5_1_SEC_1;
700a8af6: 9001         	str	r0, [sp, #0x4]
;         }
700a8af8: e002         	b	0x700a8b00 <Sciclient_getContext+0x80> @ imm = #0x4
700a8afa: 200c         	movs	r0, #0xc
;             retVal = SCICLIENT_CONTEXT_R5_1_NONSEC_1;
700a8afc: 9001         	str	r0, [sp, #0x4]
700a8afe: e7ff         	b	0x700a8b00 <Sciclient_getContext+0x80> @ imm = #-0x2
;         break;
700a8b00: e00a         	b	0x700a8b18 <Sciclient_getContext+0x98> @ imm = #0x14
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8b02: 9803         	ldr	r0, [sp, #0xc]
700a8b04: b918         	cbnz	r0, 0x700a8b0e <Sciclient_getContext+0x8e> @ imm = #0x6
700a8b06: e7ff         	b	0x700a8b08 <Sciclient_getContext+0x88> @ imm = #-0x2
700a8b08: 2004         	movs	r0, #0x4
;             retVal = SCICLIENT_CONTEXT_A53_SEC_0;
700a8b0a: 9001         	str	r0, [sp, #0x4]
;         }
700a8b0c: e002         	b	0x700a8b14 <Sciclient_getContext+0x94> @ imm = #0x4
700a8b0e: 2006         	movs	r0, #0x6
;             retVal = SCICLIENT_CONTEXT_A53_NONSEC_1;
700a8b10: 9001         	str	r0, [sp, #0x4]
700a8b12: e7ff         	b	0x700a8b14 <Sciclient_getContext+0x94> @ imm = #-0x2
;         break;
700a8b14: e000         	b	0x700a8b18 <Sciclient_getContext+0x98> @ imm = #0x0
;         break;
700a8b16: e7ff         	b	0x700a8b18 <Sciclient_getContext+0x98> @ imm = #-0x2
;     return retVal;
700a8b18: 9801         	ldr	r0, [sp, #0x4]
700a8b1a: b004         	add	sp, #0x10
700a8b1c: 4770         	bx	lr
700a8b1e: 0000         	movs	r0, r0

700a8b20 <Pinmux_config>:
; {
700a8b20: b580         	push	{r7, lr}
700a8b22: b086         	sub	sp, #0x18
700a8b24: 9005         	str	r0, [sp, #0x14]
700a8b26: 9104         	str	r1, [sp, #0x10]
700a8b28: 2000         	movs	r0, #0x0
;     uint32_t            isUnlocked = 0;
700a8b2a: 9001         	str	r0, [sp, #0x4]
;     if((NULL != pinmuxCfg) && (pinmuxCfg->offset != PINMUX_END))
700a8b2c: 9805         	ldr	r0, [sp, #0x14]
700a8b2e: 2800         	cmp	r0, #0x0
700a8b30: d042         	beq	0x700a8bb8 <Pinmux_config+0x98> @ imm = #0x84
700a8b32: e7ff         	b	0x700a8b34 <Pinmux_config+0x14> @ imm = #-0x2
700a8b34: 9805         	ldr	r0, [sp, #0x14]
700a8b36: f9b0 0000    	ldrsh.w	r0, [r0]
700a8b3a: 3001         	adds	r0, #0x1
700a8b3c: b3e0         	cbz	r0, 0x700a8bb8 <Pinmux_config+0x98> @ imm = #0x78
700a8b3e: e7ff         	b	0x700a8b40 <Pinmux_config+0x20> @ imm = #-0x2
;         if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a8b40: 9804         	ldr	r0, [sp, #0x10]
700a8b42: b920         	cbnz	r0, 0x700a8b4e <Pinmux_config+0x2e> @ imm = #0x8
700a8b44: e7ff         	b	0x700a8b46 <Pinmux_config+0x26> @ imm = #-0x2
700a8b46: f44f 2074    	mov.w	r0, #0xf4000
;             baseAddr = CSL_PADCFG_CTRL0_CFG0_BASE + PADCFG_PMUX_OFFSET;
700a8b4a: 9003         	str	r0, [sp, #0xc]
;         }
700a8b4c: e005         	b	0x700a8b5a <Pinmux_config+0x3a> @ imm = #0xa
700a8b4e: f244 0000    	movw	r0, #0x4000
700a8b52: f2c0 4008    	movt	r0, #0x408
;             baseAddr = CSL_MCU_PADCFG_CTRL0_CFG0_BASE + PADCFG_PMUX_OFFSET;
700a8b56: 9003         	str	r0, [sp, #0xc]
700a8b58: e7ff         	b	0x700a8b5a <Pinmux_config+0x3a> @ imm = #-0x2
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(baseAddr);
700a8b5a: 9803         	ldr	r0, [sp, #0xc]
700a8b5c: 2100         	movs	r1, #0x0
700a8b5e: f7fc fecf    	bl	0x700a5900 <AddrTranslateP_getLocalAddr> @ imm = #-0x3262
700a8b62: 9003         	str	r0, [sp, #0xc]
;         if (pinmuxCfg->offset != PINMUX_END)
700a8b64: 9805         	ldr	r0, [sp, #0x14]
700a8b66: f9b0 0000    	ldrsh.w	r0, [r0]
700a8b6a: 3001         	adds	r0, #0x1
700a8b6c: b130         	cbz	r0, 0x700a8b7c <Pinmux_config+0x5c> @ imm = #0xc
700a8b6e: e7ff         	b	0x700a8b70 <Pinmux_config+0x50> @ imm = #-0x2
700a8b70: 2001         	movs	r0, #0x1
;             isUnlocked = 1;
700a8b72: 9001         	str	r0, [sp, #0x4]
;             Pinmux_unlockMMR(domainId);
700a8b74: 9804         	ldr	r0, [sp, #0x10]
700a8b76: f7fd fc23    	bl	0x700a63c0 <Pinmux_unlockMMR> @ imm = #-0x27ba
;         }
700a8b7a: e7ff         	b	0x700a8b7c <Pinmux_config+0x5c> @ imm = #-0x2
;         while( pinmuxCfg->offset != PINMUX_END )
700a8b7c: e7ff         	b	0x700a8b7e <Pinmux_config+0x5e> @ imm = #-0x2
700a8b7e: 9805         	ldr	r0, [sp, #0x14]
700a8b80: f9b0 0000    	ldrsh.w	r0, [r0]
700a8b84: 3001         	adds	r0, #0x1
700a8b86: b178         	cbz	r0, 0x700a8ba8 <Pinmux_config+0x88> @ imm = #0x1e
700a8b88: e7ff         	b	0x700a8b8a <Pinmux_config+0x6a> @ imm = #-0x2
;             regAddr = (volatile uint32_t *)(baseAddr + pinmuxCfg->offset);
700a8b8a: 9803         	ldr	r0, [sp, #0xc]
700a8b8c: 9905         	ldr	r1, [sp, #0x14]
700a8b8e: f9b1 1000    	ldrsh.w	r1, [r1]
700a8b92: 4408         	add	r0, r1
700a8b94: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(regAddr, pinmuxCfg->settings);
700a8b96: 9802         	ldr	r0, [sp, #0x8]
700a8b98: 9905         	ldr	r1, [sp, #0x14]
700a8b9a: 6849         	ldr	r1, [r1, #0x4]
700a8b9c: f006 fe18    	bl	0x700af7d0 <CSL_REG32_WR_RAW> @ imm = #0x6c30
;             pinmuxCfg++;
700a8ba0: 9805         	ldr	r0, [sp, #0x14]
700a8ba2: 3008         	adds	r0, #0x8
700a8ba4: 9005         	str	r0, [sp, #0x14]
;         while( pinmuxCfg->offset != PINMUX_END )
700a8ba6: e7ea         	b	0x700a8b7e <Pinmux_config+0x5e> @ imm = #-0x2c
;         if (isUnlocked)
700a8ba8: 9801         	ldr	r0, [sp, #0x4]
700a8baa: b120         	cbz	r0, 0x700a8bb6 <Pinmux_config+0x96> @ imm = #0x8
700a8bac: e7ff         	b	0x700a8bae <Pinmux_config+0x8e> @ imm = #-0x2
;             Pinmux_lockMMR(domainId);
700a8bae: 9804         	ldr	r0, [sp, #0x10]
700a8bb0: f002 fcbe    	bl	0x700ab530 <Pinmux_lockMMR> @ imm = #0x297c
;         }
700a8bb4: e7ff         	b	0x700a8bb6 <Pinmux_config+0x96> @ imm = #-0x2
;     }
700a8bb6: e7ff         	b	0x700a8bb8 <Pinmux_config+0x98> @ imm = #-0x2
;     return;
700a8bb8: b006         	add	sp, #0x18
700a8bba: bd80         	pop	{r7, pc}
700a8bbc: 0000         	movs	r0, r0
700a8bbe: 0000         	movs	r0, r0

700a8bc0 <rtos_main_freertos>:
; {
700a8bc0: b082         	sub	sp, #0x8
;    System_init();
700a8bc2: f005 fd9d    	bl	0x700ae700 <System_init> @ imm = #0x5b3a
;    Board_init();
700a8bc6: f006 ff83    	bl	0x700afad0 <Board_init> @ imm = #0x6f06
;    Drivers_open();
700a8bca: f004 f8c9    	bl	0x700acd60 <Drivers_open> @ imm = #0x4192
;    Board_driversOpen();
700a8bce: f006 ff27    	bl	0x700afa20 <Board_driversOpen> @ imm = #0x6e4e
;    printf("Initializing FreeRTOS system...\r\n");
700a8bd2: f641 1165    	movw	r1, #0x1965
700a8bd6: 2001         	movs	r0, #0x1
700a8bd8: f2c7 010b    	movt	r1, #0x700b
700a8bdc: f000 ff70    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #0xee0
;    BaseType_t status = xTaskCreate(main_task, "MainTask", MAIN_TASK_STACK_SIZE, NULL, MAIN_TASK_PRI, NULL);
700a8be0: f64a 3031    	movw	r0, #0xab31
700a8be4: f641 613d    	movw	r1, #0x1e3d
700a8be8: f2c7 000a    	movt	r0, #0x700a
700a8bec: f2c7 010b    	movt	r1, #0x700b
700a8bf0: 241e         	movs	r4, #0x1e
700a8bf2: f44f 5200    	mov.w	r2, #0x2000
700a8bf6: 2300         	movs	r3, #0x0
700a8bf8: f04f 0c00    	mov.w	r12, #0x0
700a8bfc: e9cd 4c00    	strd	r4, r12, [sp]
700a8c00: f000 fb4e    	bl	0x700a92a0 <xTaskCreate> @ imm = #0x69c
;    if (status != pdPASS)
700a8c04: 2801         	cmp	r0, #0x1
700a8c06: d010         	beq	0x700a8c2a <rtos_main_freertos+0x6a> @ imm = #0x20
;       DebugP_assert(status == pdPASS);
700a8c08: f641 31e8    	movw	r1, #0x1be8
700a8c0c: f641 4240    	movw	r2, #0x1c40
700a8c10: f641 5441    	movw	r4, #0x1d41
700a8c14: f2c7 010b    	movt	r1, #0x700b
700a8c18: f2c7 020b    	movt	r2, #0x700b
700a8c1c: f2c7 040b    	movt	r4, #0x700b
700a8c20: 2000         	movs	r0, #0x0
700a8c22: 2381         	movs	r3, #0x81
700a8c24: 9400         	str	r4, [sp]
700a8c26: f001 ff03    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x1e06
;    vTaskStartScheduler();
700a8c2a: f7fe fc01    	bl	0x700a7430 <vTaskStartScheduler> @ imm = #-0x17fe
700a8c2e: f641 1421    	movw	r4, #0x1921
700a8c32: f2c7 040b    	movt	r4, #0x700b
700a8c36: bf00         	nop
700a8c38: bf00         	nop
700a8c3a: bf00         	nop
700a8c3c: bf00         	nop
700a8c3e: bf00         	nop
;       printf("Scheduler returned unexpectedly\r\n");
700a8c40: 4621         	mov	r1, r4
700a8c42: f04f 0001    	mov.w	r0, #0x1
700a8c46: f000 ff3b    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #0xe76
700a8c4a: 4621         	mov	r1, r4
700a8c4c: 2001         	movs	r0, #0x1
700a8c4e: f000 ff37    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #0xe6e
700a8c52: 4621         	mov	r1, r4
700a8c54: 2001         	movs	r0, #0x1
700a8c56: f000 ff33    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #0xe66
;    for (;;)
700a8c5a: e7f1         	b	0x700a8c40 <rtos_main_freertos+0x80> @ imm = #-0x1e
700a8c5c: 0000         	movs	r0, r0
700a8c5e: 0000         	movs	r0, r0

700a8c60 <SOC_controlModuleUnlockMMR>:
; {
700a8c60: b580         	push	{r7, lr}
700a8c62: b084         	sub	sp, #0x10
700a8c64: 9003         	str	r0, [sp, #0xc]
700a8c66: 9102         	str	r1, [sp, #0x8]
;     if(SOC_DOMAIN_ID_MAIN == domainId)
700a8c68: 9803         	ldr	r0, [sp, #0xc]
700a8c6a: bb00         	cbnz	r0, 0x700a8cae <SOC_controlModuleUnlockMMR+0x4e> @ imm = #0x40
700a8c6c: e7ff         	b	0x700a8c6e <SOC_controlModuleUnlockMMR+0xe> @ imm = #-0x2
700a8c6e: f04f 4086    	mov.w	r0, #0x43000000
700a8c72: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_CTRL_MMR0_CFG0_BASE);
700a8c74: f7fc fe44    	bl	0x700a5900 <AddrTranslateP_getLocalAddr> @ imm = #-0x3378
700a8c78: 9001         	str	r0, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a8c7a: 9801         	ldr	r0, [sp, #0x4]
700a8c7c: 9902         	ldr	r1, [sp, #0x8]
700a8c7e: eb00 3081    	add.w	r0, r0, r1, lsl #14
700a8c82: f241 0108    	movw	r1, #0x1008
700a8c86: 4408         	add	r0, r1
700a8c88: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a8c8a: 9800         	ldr	r0, [sp]
700a8c8c: f243 4190    	movw	r1, #0x3490
700a8c90: f6c6 01ef    	movt	r1, #0x68ef
700a8c94: f006 fdac    	bl	0x700af7f0 <CSL_REG32_WR_RAW> @ imm = #0x6b58
;         kickAddr++;
700a8c98: 9800         	ldr	r0, [sp]
700a8c9a: 3004         	adds	r0, #0x4
700a8c9c: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a8c9e: 9800         	ldr	r0, [sp]
700a8ca0: f64b 415a    	movw	r1, #0xbc5a
700a8ca4: f2cd 1172    	movt	r1, #0xd172
700a8ca8: f006 fda2    	bl	0x700af7f0 <CSL_REG32_WR_RAW> @ imm = #0x6b44
;     }
700a8cac: e7ff         	b	0x700a8cae <SOC_controlModuleUnlockMMR+0x4e> @ imm = #-0x2
;     if(SOC_DOMAIN_ID_MCU == domainId)
700a8cae: 9803         	ldr	r0, [sp, #0xc]
700a8cb0: 2801         	cmp	r0, #0x1
700a8cb2: d120         	bne	0x700a8cf6 <SOC_controlModuleUnlockMMR+0x96> @ imm = #0x40
700a8cb4: e7ff         	b	0x700a8cb6 <SOC_controlModuleUnlockMMR+0x56> @ imm = #-0x2
700a8cb6: f04f 608a    	mov.w	r0, #0x4500000
700a8cba: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_CTRL_MMR0_CFG0_BASE);
700a8cbc: f7fc fe20    	bl	0x700a5900 <AddrTranslateP_getLocalAddr> @ imm = #-0x33c0
700a8cc0: 9001         	str	r0, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a8cc2: 9801         	ldr	r0, [sp, #0x4]
700a8cc4: 9902         	ldr	r1, [sp, #0x8]
700a8cc6: eb00 3081    	add.w	r0, r0, r1, lsl #14
700a8cca: f241 0108    	movw	r1, #0x1008
700a8cce: 4408         	add	r0, r1
700a8cd0: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a8cd2: 9800         	ldr	r0, [sp]
700a8cd4: f243 4190    	movw	r1, #0x3490
700a8cd8: f6c6 01ef    	movt	r1, #0x68ef
700a8cdc: f006 fd88    	bl	0x700af7f0 <CSL_REG32_WR_RAW> @ imm = #0x6b10
;         kickAddr++;
700a8ce0: 9800         	ldr	r0, [sp]
700a8ce2: 3004         	adds	r0, #0x4
700a8ce4: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a8ce6: 9800         	ldr	r0, [sp]
700a8ce8: f64b 415a    	movw	r1, #0xbc5a
700a8cec: f2cd 1172    	movt	r1, #0xd172
700a8cf0: f006 fd7e    	bl	0x700af7f0 <CSL_REG32_WR_RAW> @ imm = #0x6afc
;     }
700a8cf4: e7ff         	b	0x700a8cf6 <SOC_controlModuleUnlockMMR+0x96> @ imm = #-0x2
;     return;
700a8cf6: b004         	add	sp, #0x10
700a8cf8: bd80         	pop	{r7, pc}
700a8cfa: 0000         	movs	r0, r0
700a8cfc: 0000         	movs	r0, r0
700a8cfe: 0000         	movs	r0, r0

700a8d00 <Sciclient_pmGetModuleClkFreq>:
; {
700a8d00: b580         	push	{r7, lr}
700a8d02: b096         	sub	sp, #0x58
700a8d04: 9015         	str	r0, [sp, #0x54]
700a8d06: 9114         	str	r1, [sp, #0x50]
700a8d08: 9213         	str	r2, [sp, #0x4c]
700a8d0a: 9312         	str	r3, [sp, #0x48]
700a8d0c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a8d0e: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a8d10: 9815         	ldr	r0, [sp, #0x54]
700a8d12: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a8d14: 9814         	ldr	r0, [sp, #0x50]
700a8d16: 28ff         	cmp	r0, #0xff
700a8d18: d307         	blo	0x700a8d2a <Sciclient_pmGetModuleClkFreq+0x2a> @ imm = #0xe
700a8d1a: e7ff         	b	0x700a8d1c <Sciclient_pmGetModuleClkFreq+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a8d1c: 9814         	ldr	r0, [sp, #0x50]
700a8d1e: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a8d22: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a8d24: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a8d28: e003         	b	0x700a8d32 <Sciclient_pmGetModuleClkFreq+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a8d2a: 9814         	ldr	r0, [sp, #0x50]
700a8d2c: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a8d30: e7ff         	b	0x700a8d32 <Sciclient_pmGetModuleClkFreq+0x32> @ imm = #-0x2
700a8d32: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_freq_resp response = {{0}};
700a8d34: 900b         	str	r0, [sp, #0x2c]
700a8d36: 900a         	str	r0, [sp, #0x28]
700a8d38: 9009         	str	r0, [sp, #0x24]
700a8d3a: 9008         	str	r0, [sp, #0x20]
700a8d3c: f44f 7187    	mov.w	r1, #0x10e
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_FREQ;
700a8d40: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a8d44: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a8d46: 9104         	str	r1, [sp, #0x10]
700a8d48: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a8d4a: 9105         	str	r1, [sp, #0x14]
700a8d4c: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a8d4e: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a8d50: 9912         	ldr	r1, [sp, #0x48]
700a8d52: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a8d54: 9000         	str	r0, [sp]
700a8d56: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a8d58: 9001         	str	r0, [sp, #0x4]
700a8d5a: 2010         	movs	r0, #0x10
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a8d5c: 9002         	str	r0, [sp, #0x8]
700a8d5e: a803         	add	r0, sp, #0xc
700a8d60: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a8d62: f7f4 fa8d    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xbae6
700a8d66: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a8d68: 9811         	ldr	r0, [sp, #0x44]
700a8d6a: b930         	cbnz	r0, 0x700a8d7a <Sciclient_pmGetModuleClkFreq+0x7a> @ imm = #0xc
700a8d6c: e7ff         	b	0x700a8d6e <Sciclient_pmGetModuleClkFreq+0x6e> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a8d6e: 9800         	ldr	r0, [sp]
700a8d70: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a8d74: 2802         	cmp	r0, #0x2
700a8d76: d004         	beq	0x700a8d82 <Sciclient_pmGetModuleClkFreq+0x82> @ imm = #0x8
700a8d78: e7ff         	b	0x700a8d7a <Sciclient_pmGetModuleClkFreq+0x7a> @ imm = #-0x2
700a8d7a: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a8d7e: 9011         	str	r0, [sp, #0x44]
;     }
700a8d80: e7ff         	b	0x700a8d82 <Sciclient_pmGetModuleClkFreq+0x82> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a8d82: 9811         	ldr	r0, [sp, #0x44]
700a8d84: b930         	cbnz	r0, 0x700a8d94 <Sciclient_pmGetModuleClkFreq+0x94> @ imm = #0xc
700a8d86: e7ff         	b	0x700a8d88 <Sciclient_pmGetModuleClkFreq+0x88> @ imm = #-0x2
;         *freqHz = (uint64_t) response.freq_hz;
700a8d88: 980a         	ldr	r0, [sp, #0x28]
700a8d8a: 9a0b         	ldr	r2, [sp, #0x2c]
700a8d8c: 9913         	ldr	r1, [sp, #0x4c]
700a8d8e: 604a         	str	r2, [r1, #0x4]
700a8d90: 6008         	str	r0, [r1]
;     }
700a8d92: e7ff         	b	0x700a8d94 <Sciclient_pmGetModuleClkFreq+0x94> @ imm = #-0x2
;     return retVal;
700a8d94: 9811         	ldr	r0, [sp, #0x44]
700a8d96: b016         	add	sp, #0x58
700a8d98: bd80         	pop	{r7, pc}
700a8d9a: 0000         	movs	r0, r0
700a8d9c: 0000         	movs	r0, r0
700a8d9e: 0000         	movs	r0, r0

700a8da0 <Sciclient_pmGetModuleClkParent>:
; {
700a8da0: b580         	push	{r7, lr}
700a8da2: b096         	sub	sp, #0x58
700a8da4: 9015         	str	r0, [sp, #0x54]
700a8da6: 9114         	str	r1, [sp, #0x50]
700a8da8: 9213         	str	r2, [sp, #0x4c]
700a8daa: 9312         	str	r3, [sp, #0x48]
700a8dac: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a8dae: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a8db0: 9815         	ldr	r0, [sp, #0x54]
700a8db2: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a8db4: 9814         	ldr	r0, [sp, #0x50]
700a8db6: 28ff         	cmp	r0, #0xff
700a8db8: d307         	blo	0x700a8dca <Sciclient_pmGetModuleClkParent+0x2a> @ imm = #0xe
700a8dba: e7ff         	b	0x700a8dbc <Sciclient_pmGetModuleClkParent+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a8dbc: 9814         	ldr	r0, [sp, #0x50]
700a8dbe: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a8dc2: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a8dc4: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a8dc8: e003         	b	0x700a8dd2 <Sciclient_pmGetModuleClkParent+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a8dca: 9814         	ldr	r0, [sp, #0x50]
700a8dcc: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a8dd0: e7ff         	b	0x700a8dd2 <Sciclient_pmGetModuleClkParent+0x32> @ imm = #-0x2
700a8dd2: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_clock_parent_resp response = {{0}};
700a8dd4: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a8dd8: 900a         	str	r0, [sp, #0x28]
700a8dda: 9009         	str	r0, [sp, #0x24]
700a8ddc: 9008         	str	r0, [sp, #0x20]
700a8dde: f240 1103    	movw	r1, #0x103
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_CLOCK_PARENT;
700a8de2: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a8de6: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a8de8: 9104         	str	r1, [sp, #0x10]
700a8dea: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a8dec: 9105         	str	r1, [sp, #0x14]
700a8dee: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a8df0: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a8df2: 9912         	ldr	r1, [sp, #0x48]
700a8df4: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a8df6: 9000         	str	r0, [sp]
700a8df8: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a8dfa: 9001         	str	r0, [sp, #0x4]
700a8dfc: 200d         	movs	r0, #0xd
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a8dfe: 9002         	str	r0, [sp, #0x8]
700a8e00: a803         	add	r0, sp, #0xc
700a8e02: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a8e04: f7f4 fa3c    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xbb88
700a8e08: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a8e0a: 9811         	ldr	r0, [sp, #0x44]
700a8e0c: b930         	cbnz	r0, 0x700a8e1c <Sciclient_pmGetModuleClkParent+0x7c> @ imm = #0xc
700a8e0e: e7ff         	b	0x700a8e10 <Sciclient_pmGetModuleClkParent+0x70> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a8e10: 9800         	ldr	r0, [sp]
700a8e12: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a8e16: 2802         	cmp	r0, #0x2
700a8e18: d004         	beq	0x700a8e24 <Sciclient_pmGetModuleClkParent+0x84> @ imm = #0x8
700a8e1a: e7ff         	b	0x700a8e1c <Sciclient_pmGetModuleClkParent+0x7c> @ imm = #-0x2
700a8e1c: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a8e20: 9011         	str	r0, [sp, #0x44]
;     }
700a8e22: e7ff         	b	0x700a8e24 <Sciclient_pmGetModuleClkParent+0x84> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a8e24: 9811         	ldr	r0, [sp, #0x44]
700a8e26: b928         	cbnz	r0, 0x700a8e34 <Sciclient_pmGetModuleClkParent+0x94> @ imm = #0xa
700a8e28: e7ff         	b	0x700a8e2a <Sciclient_pmGetModuleClkParent+0x8a> @ imm = #-0x2
;         *parent = (uint32_t) response.parent;
700a8e2a: f89d 0028    	ldrb.w	r0, [sp, #0x28]
700a8e2e: 9913         	ldr	r1, [sp, #0x4c]
700a8e30: 6008         	str	r0, [r1]
;     }
700a8e32: e7ff         	b	0x700a8e34 <Sciclient_pmGetModuleClkParent+0x94> @ imm = #-0x2
;     return retVal;
700a8e34: 9811         	ldr	r0, [sp, #0x44]
700a8e36: b016         	add	sp, #0x58
700a8e38: bd80         	pop	{r7, pc}
700a8e3a: 0000         	movs	r0, r0
700a8e3c: 0000         	movs	r0, r0
700a8e3e: 0000         	movs	r0, r0

700a8e40 <Sciclient_pmSetModuleClkParent>:
; {
700a8e40: b580         	push	{r7, lr}
700a8e42: b094         	sub	sp, #0x50
700a8e44: 9013         	str	r0, [sp, #0x4c]
700a8e46: 9112         	str	r1, [sp, #0x48]
700a8e48: 9211         	str	r2, [sp, #0x44]
700a8e4a: 9310         	str	r3, [sp, #0x40]
700a8e4c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a8e4e: 900f         	str	r0, [sp, #0x3c]
;     request.device = (uint32_t) moduleId;
700a8e50: 9813         	ldr	r0, [sp, #0x4c]
700a8e52: 900b         	str	r0, [sp, #0x2c]
;     if (clockId >= 255U)
700a8e54: 9812         	ldr	r0, [sp, #0x48]
700a8e56: 28ff         	cmp	r0, #0xff
700a8e58: d307         	blo	0x700a8e6a <Sciclient_pmSetModuleClkParent+0x2a> @ imm = #0xe
700a8e5a: e7ff         	b	0x700a8e5c <Sciclient_pmSetModuleClkParent+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a8e5c: 9812         	ldr	r0, [sp, #0x48]
700a8e5e: f8cd 0032    	str.w	r0, [sp, #0x32]
700a8e62: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a8e64: f88d 0030    	strb.w	r0, [sp, #0x30]
;     }
700a8e68: e003         	b	0x700a8e72 <Sciclient_pmSetModuleClkParent+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a8e6a: 9812         	ldr	r0, [sp, #0x48]
700a8e6c: f88d 0030    	strb.w	r0, [sp, #0x30]
700a8e70: e7ff         	b	0x700a8e72 <Sciclient_pmSetModuleClkParent+0x32> @ imm = #-0x2
;     if (parent >= 255U)
700a8e72: 9811         	ldr	r0, [sp, #0x44]
700a8e74: 28ff         	cmp	r0, #0xff
700a8e76: d307         	blo	0x700a8e88 <Sciclient_pmSetModuleClkParent+0x48> @ imm = #0xe
700a8e78: e7ff         	b	0x700a8e7a <Sciclient_pmSetModuleClkParent+0x3a> @ imm = #-0x2
;         request.parent32 = parent;
700a8e7a: 9811         	ldr	r0, [sp, #0x44]
700a8e7c: f8cd 0036    	str.w	r0, [sp, #0x36]
700a8e80: 20ff         	movs	r0, #0xff
;         request.parent   = (uint8_t) 255U;
700a8e82: f88d 0031    	strb.w	r0, [sp, #0x31]
;     }
700a8e86: e003         	b	0x700a8e90 <Sciclient_pmSetModuleClkParent+0x50> @ imm = #0x6
;         request.parent = (uint8_t) parent;
700a8e88: 9811         	ldr	r0, [sp, #0x44]
700a8e8a: f88d 0031    	strb.w	r0, [sp, #0x31]
700a8e8e: e7ff         	b	0x700a8e90 <Sciclient_pmSetModuleClkParent+0x50> @ imm = #-0x2
700a8e90: f44f 7081    	mov.w	r0, #0x102
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_CLOCK_PARENT;
700a8e94: f8ad 0010    	strh.w	r0, [sp, #0x10]
700a8e98: 2002         	movs	r0, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a8e9a: 9005         	str	r0, [sp, #0x14]
700a8e9c: a809         	add	r0, sp, #0x24
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a8e9e: 9006         	str	r0, [sp, #0x18]
700a8ea0: 2016         	movs	r0, #0x16
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a8ea2: 9007         	str	r0, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a8ea4: 9810         	ldr	r0, [sp, #0x40]
700a8ea6: 9008         	str	r0, [sp, #0x20]
700a8ea8: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a8eaa: 9001         	str	r0, [sp, #0x4]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a8eac: 9002         	str	r0, [sp, #0x8]
;     respParam.respPayloadSize = (uint32_t) 0;
700a8eae: 9003         	str	r0, [sp, #0xc]
700a8eb0: a804         	add	r0, sp, #0x10
700a8eb2: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a8eb4: f7f4 f9e4    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xbc38
700a8eb8: 900f         	str	r0, [sp, #0x3c]
;     if((retVal != SystemP_SUCCESS) ||
700a8eba: 980f         	ldr	r0, [sp, #0x3c]
700a8ebc: b930         	cbnz	r0, 0x700a8ecc <Sciclient_pmSetModuleClkParent+0x8c> @ imm = #0xc
700a8ebe: e7ff         	b	0x700a8ec0 <Sciclient_pmSetModuleClkParent+0x80> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a8ec0: 9801         	ldr	r0, [sp, #0x4]
700a8ec2: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a8ec6: 2802         	cmp	r0, #0x2
700a8ec8: d004         	beq	0x700a8ed4 <Sciclient_pmSetModuleClkParent+0x94> @ imm = #0x8
700a8eca: e7ff         	b	0x700a8ecc <Sciclient_pmSetModuleClkParent+0x8c> @ imm = #-0x2
700a8ecc: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a8ed0: 900f         	str	r0, [sp, #0x3c]
;     }
700a8ed2: e7ff         	b	0x700a8ed4 <Sciclient_pmSetModuleClkParent+0x94> @ imm = #-0x2
;     return retVal;
700a8ed4: 980f         	ldr	r0, [sp, #0x3c]
700a8ed6: b014         	add	sp, #0x50
700a8ed8: bd80         	pop	{r7, pc}
700a8eda: 0000         	movs	r0, r0
700a8edc: 0000         	movs	r0, r0
700a8ede: 0000         	movs	r0, r0

700a8ee0 <Sciclient_rmIrOutpIsFree>:
; {
700a8ee0: b580         	push	{r7, lr}
700a8ee2: b086         	sub	sp, #0x18
700a8ee4: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a8ee8: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a8eec: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a8eee: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIrInst *inst = NULL;
700a8ef0: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIrGetInst(id);
700a8ef2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a8ef6: f002 fd13    	bl	0x700ab920 <Sciclient_rmIrGetInst> @ imm = #0x2a26
700a8efa: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a8efc: 9803         	ldr	r0, [sp, #0xc]
700a8efe: b920         	cbnz	r0, 0x700a8f0a <Sciclient_rmIrOutpIsFree+0x2a> @ imm = #0x8
700a8f00: e7ff         	b	0x700a8f02 <Sciclient_rmIrOutpIsFree+0x22> @ imm = #-0x2
700a8f02: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a8f06: 9004         	str	r0, [sp, #0x10]
;     } else {
700a8f08: e00b         	b	0x700a8f22 <Sciclient_rmIrOutpIsFree+0x42> @ imm = #0x16
;         if (outp >= inst->n_outp) {
700a8f0a: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a8f0e: 9903         	ldr	r1, [sp, #0xc]
700a8f10: 8949         	ldrh	r1, [r1, #0xa]
700a8f12: 4288         	cmp	r0, r1
700a8f14: db04         	blt	0x700a8f20 <Sciclient_rmIrOutpIsFree+0x40> @ imm = #0x8
700a8f16: e7ff         	b	0x700a8f18 <Sciclient_rmIrOutpIsFree+0x38> @ imm = #-0x2
700a8f18: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a8f1c: 9004         	str	r0, [sp, #0x10]
;         }
700a8f1e: e7ff         	b	0x700a8f20 <Sciclient_rmIrOutpIsFree+0x40> @ imm = #-0x2
700a8f20: e7ff         	b	0x700a8f22 <Sciclient_rmIrOutpIsFree+0x42> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a8f22: 9804         	ldr	r0, [sp, #0x10]
700a8f24: bb30         	cbnz	r0, 0x700a8f74 <Sciclient_rmIrOutpIsFree+0x94> @ imm = #0x4c
700a8f26: e7ff         	b	0x700a8f28 <Sciclient_rmIrOutpIsFree+0x48> @ imm = #-0x2
;         int_ctrl_reg = (volatile uint32_t *) Sciclient_getIrAddr (inst->cfg, outp);
700a8f28: 9803         	ldr	r0, [sp, #0xc]
700a8f2a: 6840         	ldr	r0, [r0, #0x4]
700a8f2c: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a8f30: f005 fcee    	bl	0x700ae910 <Sciclient_getIrAddr> @ imm = #0x59dc
700a8f34: 9002         	str	r0, [sp, #0x8]
;         extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a8f36: 9802         	ldr	r0, [sp, #0x8]
700a8f38: f240 31ff    	movw	r1, #0x3ff
700a8f3c: 2200         	movs	r2, #0x0
700a8f3e: f005 ffb7    	bl	0x700aeeb0 <CSL_REG32_FEXT_RAW> @ imm = #0x5f6e
700a8f42: f8ad 0006    	strh.w	r0, [sp, #0x6]
;         if (((extracted_inp != 0u) &&
700a8f46: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a8f4a: b138         	cbz	r0, 0x700a8f5c <Sciclient_rmIrOutpIsFree+0x7c> @ imm = #0xe
700a8f4c: e7ff         	b	0x700a8f4e <Sciclient_rmIrOutpIsFree+0x6e> @ imm = #-0x2
;              (Sciclient_rmIrOutpRomMapped(inst, outp) == false)) ||
700a8f4e: 9803         	ldr	r0, [sp, #0xc]
700a8f50: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a8f54: f7ff f934    	bl	0x700a81c0 <Sciclient_rmIrOutpRomMapped> @ imm = #-0xd98
700a8f58: b138         	cbz	r0, 0x700a8f6a <Sciclient_rmIrOutpIsFree+0x8a> @ imm = #0xe
700a8f5a: e7ff         	b	0x700a8f5c <Sciclient_rmIrOutpIsFree+0x7c> @ imm = #-0x2
;             (outp == inst->inp0_mapping)) {
700a8f5c: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a8f60: 9903         	ldr	r1, [sp, #0xc]
700a8f62: 8989         	ldrh	r1, [r1, #0xc]
;         if (((extracted_inp != 0u) &&
700a8f64: 4288         	cmp	r0, r1
700a8f66: d104         	bne	0x700a8f72 <Sciclient_rmIrOutpIsFree+0x92> @ imm = #0x8
700a8f68: e7ff         	b	0x700a8f6a <Sciclient_rmIrOutpIsFree+0x8a> @ imm = #-0x2
700a8f6a: f04f 30ff    	mov.w	r0, #0xffffffff
;             r = SystemP_FAILURE;
700a8f6e: 9004         	str	r0, [sp, #0x10]
;         }
700a8f70: e7ff         	b	0x700a8f72 <Sciclient_rmIrOutpIsFree+0x92> @ imm = #-0x2
;     }
700a8f72: e7ff         	b	0x700a8f74 <Sciclient_rmIrOutpIsFree+0x94> @ imm = #-0x2
;     return r;
700a8f74: 9804         	ldr	r0, [sp, #0x10]
700a8f76: b006         	add	sp, #0x18
700a8f78: bd80         	pop	{r7, pc}
700a8f7a: 0000         	movs	r0, r0
700a8f7c: 0000         	movs	r0, r0
700a8f7e: 0000         	movs	r0, r0

700a8f80 <Udma_ringQueueRaw>:
; {
700a8f80: b580         	push	{r7, lr}
700a8f82: b088         	sub	sp, #0x20
700a8f84: 9007         	str	r0, [sp, #0x1c]
700a8f86: 9305         	str	r3, [sp, #0x14]
700a8f88: 9204         	str	r2, [sp, #0x10]
700a8f8a: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a8f8c: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a8f8e: 9807         	ldr	r0, [sp, #0x1c]
700a8f90: 9000         	str	r0, [sp]
;     if((NULL_PTR == ringHandleInt) ||
700a8f92: 9800         	ldr	r0, [sp]
700a8f94: b180         	cbz	r0, 0x700a8fb8 <Udma_ringQueueRaw+0x38> @ imm = #0x20
700a8f96: e7ff         	b	0x700a8f98 <Udma_ringQueueRaw+0x18> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a8f98: 9800         	ldr	r0, [sp]
700a8f9a: 6d80         	ldr	r0, [r0, #0x58]
700a8f9c: f64a 31cd    	movw	r1, #0xabcd
700a8fa0: f6ca 31dc    	movt	r1, #0xabdc
700a8fa4: 4288         	cmp	r0, r1
700a8fa6: d107         	bne	0x700a8fb8 <Udma_ringQueueRaw+0x38> @ imm = #0xe
700a8fa8: e7ff         	b	0x700a8faa <Udma_ringQueueRaw+0x2a> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a8faa: 9800         	ldr	r0, [sp]
700a8fac: 8880         	ldrh	r0, [r0, #0x4]
700a8fae: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a8fb2: 4288         	cmp	r0, r1
700a8fb4: d104         	bne	0x700a8fc0 <Udma_ringQueueRaw+0x40> @ imm = #0x8
700a8fb6: e7ff         	b	0x700a8fb8 <Udma_ringQueueRaw+0x38> @ imm = #-0x2
700a8fb8: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a8fbc: 9003         	str	r0, [sp, #0xc]
;     }
700a8fbe: e7ff         	b	0x700a8fc0 <Udma_ringQueueRaw+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a8fc0: 9803         	ldr	r0, [sp, #0xc]
700a8fc2: b9a8         	cbnz	r0, 0x700a8ff0 <Udma_ringQueueRaw+0x70> @ imm = #0x2a
700a8fc4: e7ff         	b	0x700a8fc6 <Udma_ringQueueRaw+0x46> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a8fc6: 9800         	ldr	r0, [sp]
700a8fc8: 6800         	ldr	r0, [r0]
700a8fca: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) ||
700a8fcc: 9801         	ldr	r0, [sp, #0x4]
700a8fce: b150         	cbz	r0, 0x700a8fe6 <Udma_ringQueueRaw+0x66> @ imm = #0x14
700a8fd0: e7ff         	b	0x700a8fd2 <Udma_ringQueueRaw+0x52> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a8fd2: 9801         	ldr	r0, [sp, #0x4]
700a8fd4: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a8fd8: f64a 31cd    	movw	r1, #0xabcd
700a8fdc: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a8fe0: 4288         	cmp	r0, r1
700a8fe2: d004         	beq	0x700a8fee <Udma_ringQueueRaw+0x6e> @ imm = #0x8
700a8fe4: e7ff         	b	0x700a8fe6 <Udma_ringQueueRaw+0x66> @ imm = #-0x2
700a8fe6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a8fea: 9003         	str	r0, [sp, #0xc]
;         }
700a8fec: e7ff         	b	0x700a8fee <Udma_ringQueueRaw+0x6e> @ imm = #-0x2
;     }
700a8fee: e7ff         	b	0x700a8ff0 <Udma_ringQueueRaw+0x70> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a8ff0: 9803         	ldr	r0, [sp, #0xc]
700a8ff2: b978         	cbnz	r0, 0x700a9014 <Udma_ringQueueRaw+0x94> @ imm = #0x1e
700a8ff4: e7ff         	b	0x700a8ff6 <Udma_ringQueueRaw+0x76> @ imm = #-0x2
;         cookie = HwiP_disable();
700a8ff6: f007 eb34    	blx	0x700b0660 <HwiP_disable> @ imm = #0x7668
700a8ffa: 9002         	str	r0, [sp, #0x8]
;         retVal = drvHandle->ringQueueRaw(drvHandle, ringHandleInt, phyDescMem);
700a8ffc: 9801         	ldr	r0, [sp, #0x4]
700a8ffe: f8d0 c594    	ldr.w	r12, [r0, #0x594]
700a9002: 9900         	ldr	r1, [sp]
700a9004: 9a04         	ldr	r2, [sp, #0x10]
700a9006: 9b05         	ldr	r3, [sp, #0x14]
700a9008: 47e0         	blx	r12
700a900a: 9003         	str	r0, [sp, #0xc]
;         HwiP_restore(cookie);
700a900c: 9802         	ldr	r0, [sp, #0x8]
700a900e: f007 eb48    	blx	0x700b06a0 <HwiP_restore> @ imm = #0x7690
;     }
700a9012: e7ff         	b	0x700a9014 <Udma_ringQueueRaw+0x94> @ imm = #-0x2
;     return (retVal);
700a9014: 9803         	ldr	r0, [sp, #0xc]
700a9016: b008         	add	sp, #0x20
700a9018: bd80         	pop	{r7, pc}
700a901a: 0000         	movs	r0, r0
700a901c: 0000         	movs	r0, r0
700a901e: 0000         	movs	r0, r0

700a9020 <xTaskCheckForTimeOut>:
;                                 TickType_t *const pxTicksToWait) {
700a9020: b580         	push	{r7, lr}
700a9022: b086         	sub	sp, #0x18
700a9024: 9005         	str	r0, [sp, #0x14]
700a9026: 9104         	str	r1, [sp, #0x10]
;   taskENTER_CRITICAL();
700a9028: f005 fa52    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0x54a4
;     const TickType_t xConstTickCount = xTickCount;
700a902c: f242 7004    	movw	r0, #0x2704
700a9030: f2c7 000b    	movt	r0, #0x700b
700a9034: 6800         	ldr	r0, [r0]
700a9036: 9002         	str	r0, [sp, #0x8]
;         xConstTickCount - pxTimeOut->xTimeOnEntering;
700a9038: 9802         	ldr	r0, [sp, #0x8]
700a903a: 9905         	ldr	r1, [sp, #0x14]
700a903c: 6849         	ldr	r1, [r1, #0x4]
700a903e: 1a40         	subs	r0, r0, r1
;     const TickType_t xElapsedTime =
700a9040: 9001         	str	r0, [sp, #0x4]
;         if (*pxTicksToWait == portMAX_DELAY) {
700a9042: 9804         	ldr	r0, [sp, #0x10]
700a9044: 6800         	ldr	r0, [r0]
700a9046: 3001         	adds	r0, #0x1
700a9048: b918         	cbnz	r0, 0x700a9052 <xTaskCheckForTimeOut+0x32> @ imm = #0x6
700a904a: e7ff         	b	0x700a904c <xTaskCheckForTimeOut+0x2c> @ imm = #-0x2
700a904c: 2000         	movs	r0, #0x0
;       xReturn = pdFALSE;
700a904e: 9003         	str	r0, [sp, #0xc]
;     } else
700a9050: e02e         	b	0x700a90b0 <xTaskCheckForTimeOut+0x90> @ imm = #0x5c
;         if ((xNumOfOverflows != pxTimeOut->xOverflowCount) &&
700a9052: f242 60f8    	movw	r0, #0x26f8
700a9056: f2c7 000b    	movt	r0, #0x700b
700a905a: 6800         	ldr	r0, [r0]
700a905c: 9905         	ldr	r1, [sp, #0x14]
700a905e: 6809         	ldr	r1, [r1]
700a9060: 4288         	cmp	r0, r1
700a9062: d00c         	beq	0x700a907e <xTaskCheckForTimeOut+0x5e> @ imm = #0x18
700a9064: e7ff         	b	0x700a9066 <xTaskCheckForTimeOut+0x46> @ imm = #-0x2
;             (xConstTickCount >=
700a9066: 9802         	ldr	r0, [sp, #0x8]
;              pxTimeOut
700a9068: 9905         	ldr	r1, [sp, #0x14]
;                  ->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to
700a906a: 6849         	ldr	r1, [r1, #0x4]
;         if ((xNumOfOverflows != pxTimeOut->xOverflowCount) &&
700a906c: 4288         	cmp	r0, r1
700a906e: d306         	blo	0x700a907e <xTaskCheckForTimeOut+0x5e> @ imm = #0xc
700a9070: e7ff         	b	0x700a9072 <xTaskCheckForTimeOut+0x52> @ imm = #-0x2
700a9072: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a9074: 9003         	str	r0, [sp, #0xc]
;       *pxTicksToWait = (TickType_t)0;
700a9076: 9904         	ldr	r1, [sp, #0x10]
700a9078: 2000         	movs	r0, #0x0
700a907a: 6008         	str	r0, [r1]
;     } else if (xElapsedTime <
700a907c: e017         	b	0x700a90ae <xTaskCheckForTimeOut+0x8e> @ imm = #0x2e
700a907e: 9801         	ldr	r0, [sp, #0x4]
;                *pxTicksToWait) /*lint !e961 Explicit casting is only redundant
700a9080: 9904         	ldr	r1, [sp, #0x10]
700a9082: 6809         	ldr	r1, [r1]
;     } else if (xElapsedTime <
700a9084: 4288         	cmp	r0, r1
700a9086: d20b         	bhs	0x700a90a0 <xTaskCheckForTimeOut+0x80> @ imm = #0x16
700a9088: e7ff         	b	0x700a908a <xTaskCheckForTimeOut+0x6a> @ imm = #-0x2
;       *pxTicksToWait -= xElapsedTime;
700a908a: 9a01         	ldr	r2, [sp, #0x4]
700a908c: 9904         	ldr	r1, [sp, #0x10]
700a908e: 6808         	ldr	r0, [r1]
700a9090: 1a80         	subs	r0, r0, r2
700a9092: 6008         	str	r0, [r1]
;       vTaskInternalSetTimeOutState(pxTimeOut);
700a9094: 9805         	ldr	r0, [sp, #0x14]
700a9096: f005 ff7b    	bl	0x700aef90 <vTaskInternalSetTimeOutState> @ imm = #0x5ef6
700a909a: 2000         	movs	r0, #0x0
;       xReturn = pdFALSE;
700a909c: 9003         	str	r0, [sp, #0xc]
;     } else {
700a909e: e005         	b	0x700a90ac <xTaskCheckForTimeOut+0x8c> @ imm = #0xa
;       *pxTicksToWait = (TickType_t)0;
700a90a0: 9904         	ldr	r1, [sp, #0x10]
700a90a2: 2000         	movs	r0, #0x0
700a90a4: 6008         	str	r0, [r1]
700a90a6: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a90a8: 9003         	str	r0, [sp, #0xc]
700a90aa: e7ff         	b	0x700a90ac <xTaskCheckForTimeOut+0x8c> @ imm = #-0x2
700a90ac: e7ff         	b	0x700a90ae <xTaskCheckForTimeOut+0x8e> @ imm = #-0x2
700a90ae: e7ff         	b	0x700a90b0 <xTaskCheckForTimeOut+0x90> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a90b0: f004 face    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0x459c
;   return xReturn;
700a90b4: 9803         	ldr	r0, [sp, #0xc]
700a90b6: b006         	add	sp, #0x18
700a90b8: bd80         	pop	{r7, pc}
700a90ba: 0000         	movs	r0, r0
700a90bc: 0000         	movs	r0, r0
700a90be: 0000         	movs	r0, r0

700a90c0 <CSL_bcdmaChanOpSetChanEnable>:
; {
700a90c0: b580         	push	{r7, lr}
700a90c2: b086         	sub	sp, #0x18
700a90c4: 9005         	str	r0, [sp, #0x14]
700a90c6: 9104         	str	r1, [sp, #0x10]
700a90c8: 9203         	str	r2, [sp, #0xc]
700a90ca: f88d 300b    	strb.w	r3, [sp, #0xb]
700a90ce: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a90d0: 9001         	str	r0, [sp, #0x4]
;     switch( chanType )
700a90d2: 9804         	ldr	r0, [sp, #0x10]
700a90d4: 9000         	str	r0, [sp]
700a90d6: b140         	cbz	r0, 0x700a90ea <CSL_bcdmaChanOpSetChanEnable+0x2a> @ imm = #0x10
700a90d8: e7ff         	b	0x700a90da <CSL_bcdmaChanOpSetChanEnable+0x1a> @ imm = #-0x2
700a90da: 9800         	ldr	r0, [sp]
700a90dc: 2801         	cmp	r0, #0x1
700a90de: d014         	beq	0x700a910a <CSL_bcdmaChanOpSetChanEnable+0x4a> @ imm = #0x28
700a90e0: e7ff         	b	0x700a90e2 <CSL_bcdmaChanOpSetChanEnable+0x22> @ imm = #-0x2
700a90e2: 9800         	ldr	r0, [sp]
700a90e4: 2802         	cmp	r0, #0x2
700a90e6: d020         	beq	0x700a912a <CSL_bcdmaChanOpSetChanEnable+0x6a> @ imm = #0x40
700a90e8: e02f         	b	0x700a914a <CSL_bcdmaChanOpSetChanEnable+0x8a> @ imm = #0x5e
;             CSL_REG32_WR(&pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_BCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a90ea: 9805         	ldr	r0, [sp, #0x14]
700a90ec: 6880         	ldr	r0, [r0, #0x8]
700a90ee: 9903         	ldr	r1, [sp, #0xc]
700a90f0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a90f4: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a90f8: f001 0101    	and	r1, r1, #0x1
700a90fc: 2900         	cmp	r1, #0x0
700a90fe: bf18         	it	ne
700a9100: f04f 4100    	movne.w	r1, #0x80000000
700a9104: f7f3 f884    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0xcef8
;             break;
700a9108: e023         	b	0x700a9152 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x46
;             CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a910a: 9805         	ldr	r0, [sp, #0x14]
700a910c: 6900         	ldr	r0, [r0, #0x10]
700a910e: 9903         	ldr	r1, [sp, #0xc]
700a9110: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a9114: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a9118: f001 0101    	and	r1, r1, #0x1
700a911c: 2900         	cmp	r1, #0x0
700a911e: bf18         	it	ne
700a9120: f04f 4100    	movne.w	r1, #0x80000000
700a9124: f7f3 f874    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0xcf18
;             break;
700a9128: e013         	b	0x700a9152 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x26
;             CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_RXCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a912a: 9805         	ldr	r0, [sp, #0x14]
700a912c: 6980         	ldr	r0, [r0, #0x18]
700a912e: 9903         	ldr	r1, [sp, #0xc]
700a9130: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a9134: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a9138: f001 0101    	and	r1, r1, #0x1
700a913c: 2900         	cmp	r1, #0x0
700a913e: bf18         	it	ne
700a9140: f04f 4100    	movne.w	r1, #0x80000000
700a9144: f7f3 f864    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0xcf38
;             break;
700a9148: e003         	b	0x700a9152 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x6
700a914a: f06f 0001    	mvn	r0, #0x1
;             retVal = CSL_EBADARGS;
700a914e: 9001         	str	r0, [sp, #0x4]
;             break;
700a9150: e7ff         	b	0x700a9152 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #-0x2
;     return retVal;
700a9152: 9801         	ldr	r0, [sp, #0x4]
700a9154: b006         	add	sp, #0x18
700a9156: bd80         	pop	{r7, pc}
		...

700a9160 <Sciclient_pmModuleGetClkStatus>:
; {
700a9160: b580         	push	{r7, lr}
700a9162: b096         	sub	sp, #0x58
700a9164: 9015         	str	r0, [sp, #0x54]
700a9166: 9114         	str	r1, [sp, #0x50]
700a9168: 9213         	str	r2, [sp, #0x4c]
700a916a: 9312         	str	r3, [sp, #0x48]
700a916c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a916e: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a9170: 9815         	ldr	r0, [sp, #0x54]
700a9172: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a9174: 9814         	ldr	r0, [sp, #0x50]
700a9176: 28ff         	cmp	r0, #0xff
700a9178: d307         	blo	0x700a918a <Sciclient_pmModuleGetClkStatus+0x2a> @ imm = #0xe
700a917a: e7ff         	b	0x700a917c <Sciclient_pmModuleGetClkStatus+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a917c: 9814         	ldr	r0, [sp, #0x50]
700a917e: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a9182: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a9184: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a9188: e003         	b	0x700a9192 <Sciclient_pmModuleGetClkStatus+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a918a: 9814         	ldr	r0, [sp, #0x50]
700a918c: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a9190: e7ff         	b	0x700a9192 <Sciclient_pmModuleGetClkStatus+0x32> @ imm = #-0x2
700a9192: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_clock_resp response = {{0}};
700a9194: f8ad 002c    	strh.w	r0, [sp, #0x2c]
700a9198: 900a         	str	r0, [sp, #0x28]
700a919a: 9009         	str	r0, [sp, #0x24]
700a919c: f240 1101    	movw	r1, #0x101
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_CLOCK;
700a91a0: f8ad 1010    	strh.w	r1, [sp, #0x10]
700a91a4: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a91a6: 9105         	str	r1, [sp, #0x14]
700a91a8: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a91aa: 9106         	str	r1, [sp, #0x18]
700a91ac: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a91ae: 9107         	str	r1, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a91b0: 9912         	ldr	r1, [sp, #0x48]
700a91b2: 9108         	str	r1, [sp, #0x20]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a91b4: 9001         	str	r0, [sp, #0x4]
700a91b6: a809         	add	r0, sp, #0x24
;     respParam.pRespPayload    = (uint8_t *) &response;
700a91b8: 9002         	str	r0, [sp, #0x8]
700a91ba: 200a         	movs	r0, #0xa
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a91bc: 9003         	str	r0, [sp, #0xc]
700a91be: a804         	add	r0, sp, #0x10
700a91c0: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a91c2: f7f4 f85d    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xbf46
700a91c6: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a91c8: 9811         	ldr	r0, [sp, #0x44]
700a91ca: b930         	cbnz	r0, 0x700a91da <Sciclient_pmModuleGetClkStatus+0x7a> @ imm = #0xc
700a91cc: e7ff         	b	0x700a91ce <Sciclient_pmModuleGetClkStatus+0x6e> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a91ce: 9801         	ldr	r0, [sp, #0x4]
700a91d0: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a91d4: 2802         	cmp	r0, #0x2
700a91d6: d004         	beq	0x700a91e2 <Sciclient_pmModuleGetClkStatus+0x82> @ imm = #0x8
700a91d8: e7ff         	b	0x700a91da <Sciclient_pmModuleGetClkStatus+0x7a> @ imm = #-0x2
700a91da: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a91de: 9011         	str	r0, [sp, #0x44]
;     }
700a91e0: e7ff         	b	0x700a91e2 <Sciclient_pmModuleGetClkStatus+0x82> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a91e2: 9811         	ldr	r0, [sp, #0x44]
700a91e4: b928         	cbnz	r0, 0x700a91f2 <Sciclient_pmModuleGetClkStatus+0x92> @ imm = #0xa
700a91e6: e7ff         	b	0x700a91e8 <Sciclient_pmModuleGetClkStatus+0x88> @ imm = #-0x2
;         *state = (uint32_t) response.current_state;
700a91e8: f89d 002d    	ldrb.w	r0, [sp, #0x2d]
700a91ec: 9913         	ldr	r1, [sp, #0x4c]
700a91ee: 6008         	str	r0, [r1]
;     }
700a91f0: e7ff         	b	0x700a91f2 <Sciclient_pmModuleGetClkStatus+0x92> @ imm = #-0x2
;     return retVal;
700a91f2: 9811         	ldr	r0, [sp, #0x44]
700a91f4: b016         	add	sp, #0x58
700a91f6: bd80         	pop	{r7, pc}
		...

700a9200 <xQueueReceiveFromISR>:
; {
700a9200: b580         	push	{r7, lr}
700a9202: b088         	sub	sp, #0x20
700a9204: 9007         	str	r0, [sp, #0x1c]
700a9206: 9106         	str	r1, [sp, #0x18]
700a9208: 9205         	str	r2, [sp, #0x14]
;     Queue_t * const pxQueue = xQueue;
700a920a: 9807         	ldr	r0, [sp, #0x1c]
700a920c: 9002         	str	r0, [sp, #0x8]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a920e: f007 ea28    	blx	0x700b0660 <HwiP_disable> @ imm = #0x7450
700a9212: 9003         	str	r0, [sp, #0xc]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a9214: 9802         	ldr	r0, [sp, #0x8]
700a9216: 6b80         	ldr	r0, [r0, #0x38]
700a9218: 9001         	str	r0, [sp, #0x4]
;         if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a921a: 9801         	ldr	r0, [sp, #0x4]
700a921c: b398         	cbz	r0, 0x700a9286 <xQueueReceiveFromISR+0x86> @ imm = #0x66
700a921e: e7ff         	b	0x700a9220 <xQueueReceiveFromISR+0x20> @ imm = #-0x2
;             const int8_t cRxLock = pxQueue->cRxLock;
700a9220: 9802         	ldr	r0, [sp, #0x8]
700a9222: f890 0044    	ldrb.w	r0, [r0, #0x44]
700a9226: f88d 0003    	strb.w	r0, [sp, #0x3]
;             prvCopyDataFromQueue( pxQueue, pvBuffer );
700a922a: 9802         	ldr	r0, [sp, #0x8]
700a922c: 9906         	ldr	r1, [sp, #0x18]
700a922e: f004 fb4f    	bl	0x700ad8d0 <prvCopyDataFromQueue> @ imm = #0x469e
;             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
700a9232: 9801         	ldr	r0, [sp, #0x4]
700a9234: 3801         	subs	r0, #0x1
700a9236: 9902         	ldr	r1, [sp, #0x8]
700a9238: 6388         	str	r0, [r1, #0x38]
;             if( cRxLock == queueUNLOCKED )
700a923a: f99d 0003    	ldrsb.w	r0, [sp, #0x3]
700a923e: 3001         	adds	r0, #0x1
700a9240: b9b8         	cbnz	r0, 0x700a9272 <xQueueReceiveFromISR+0x72> @ imm = #0x2e
700a9242: e7ff         	b	0x700a9244 <xQueueReceiveFromISR+0x44> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a9244: 9802         	ldr	r0, [sp, #0x8]
700a9246: 6900         	ldr	r0, [r0, #0x10]
700a9248: b188         	cbz	r0, 0x700a926e <xQueueReceiveFromISR+0x6e> @ imm = #0x22
700a924a: e7ff         	b	0x700a924c <xQueueReceiveFromISR+0x4c> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a924c: 9802         	ldr	r0, [sp, #0x8]
700a924e: 3010         	adds	r0, #0x10
700a9250: f7fe face    	bl	0x700a77f0 <xTaskRemoveFromEventList> @ imm = #-0x1a64
700a9254: b148         	cbz	r0, 0x700a926a <xQueueReceiveFromISR+0x6a> @ imm = #0x12
700a9256: e7ff         	b	0x700a9258 <xQueueReceiveFromISR+0x58> @ imm = #-0x2
;                         if( pxHigherPriorityTaskWoken != NULL )
700a9258: 9805         	ldr	r0, [sp, #0x14]
700a925a: b120         	cbz	r0, 0x700a9266 <xQueueReceiveFromISR+0x66> @ imm = #0x8
700a925c: e7ff         	b	0x700a925e <xQueueReceiveFromISR+0x5e> @ imm = #-0x2
;                             *pxHigherPriorityTaskWoken = pdTRUE;
700a925e: 9905         	ldr	r1, [sp, #0x14]
700a9260: 2001         	movs	r0, #0x1
700a9262: 6008         	str	r0, [r1]
;                         }
700a9264: e000         	b	0x700a9268 <xQueueReceiveFromISR+0x68> @ imm = #0x0
700a9266: e7ff         	b	0x700a9268 <xQueueReceiveFromISR+0x68> @ imm = #-0x2
;                     }
700a9268: e000         	b	0x700a926c <xQueueReceiveFromISR+0x6c> @ imm = #0x0
700a926a: e7ff         	b	0x700a926c <xQueueReceiveFromISR+0x6c> @ imm = #-0x2
;                 }
700a926c: e000         	b	0x700a9270 <xQueueReceiveFromISR+0x70> @ imm = #0x0
700a926e: e7ff         	b	0x700a9270 <xQueueReceiveFromISR+0x70> @ imm = #-0x2
;             }
700a9270: e006         	b	0x700a9280 <xQueueReceiveFromISR+0x80> @ imm = #0xc
;                 pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
700a9272: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9276: 3001         	adds	r0, #0x1
700a9278: 9902         	ldr	r1, [sp, #0x8]
700a927a: f881 0044    	strb.w	r0, [r1, #0x44]
700a927e: e7ff         	b	0x700a9280 <xQueueReceiveFromISR+0x80> @ imm = #-0x2
700a9280: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a9282: 9004         	str	r0, [sp, #0x10]
;         }
700a9284: e002         	b	0x700a928c <xQueueReceiveFromISR+0x8c> @ imm = #0x4
700a9286: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
700a9288: 9004         	str	r0, [sp, #0x10]
700a928a: e7ff         	b	0x700a928c <xQueueReceiveFromISR+0x8c> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a928c: 9803         	ldr	r0, [sp, #0xc]
700a928e: f007 ea08    	blx	0x700b06a0 <HwiP_restore> @ imm = #0x7410
;     return xReturn;
700a9292: 9804         	ldr	r0, [sp, #0x10]
700a9294: b008         	add	sp, #0x20
700a9296: bd80         	pop	{r7, pc}
		...

700a92a0 <xTaskCreate>:
;     UBaseType_t uxPriority, TaskHandle_t *const pxCreatedTask) {
700a92a0: b570         	push	{r4, r5, r6, lr}
700a92a2: b08c         	sub	sp, #0x30
700a92a4: f8dd c044    	ldr.w	r12, [sp, #0x44]
700a92a8: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a92ac: 900b         	str	r0, [sp, #0x2c]
700a92ae: 910a         	str	r1, [sp, #0x28]
700a92b0: 9209         	str	r2, [sp, #0x24]
700a92b2: 9308         	str	r3, [sp, #0x20]
;         (((size_t)usStackDepth) *
700a92b4: 9809         	ldr	r0, [sp, #0x24]
700a92b6: 0080         	lsls	r0, r0, #0x2
;     pxStack = (StackType_t *)pvPortMalloc(
700a92b8: f005 fffa    	bl	0x700af2b0 <pvPortMalloc> @ imm = #0x5ff4
700a92bc: 9005         	str	r0, [sp, #0x14]
;     if (pxStack != NULL) {
700a92be: 9805         	ldr	r0, [sp, #0x14]
700a92c0: b180         	cbz	r0, 0x700a92e4 <xTaskCreate+0x44> @ imm = #0x20
700a92c2: e7ff         	b	0x700a92c4 <xTaskCreate+0x24> @ imm = #-0x2
700a92c4: 2088         	movs	r0, #0x88
;       pxNewTCB = (TCB_t *)pvPortMalloc(
700a92c6: f005 fff3    	bl	0x700af2b0 <pvPortMalloc> @ imm = #0x5fe6
700a92ca: 9007         	str	r0, [sp, #0x1c]
;       if (pxNewTCB != NULL) {
700a92cc: 9807         	ldr	r0, [sp, #0x1c]
700a92ce: b120         	cbz	r0, 0x700a92da <xTaskCreate+0x3a> @ imm = #0x8
700a92d0: e7ff         	b	0x700a92d2 <xTaskCreate+0x32> @ imm = #-0x2
;         pxNewTCB->pxStack = pxStack;
700a92d2: 9805         	ldr	r0, [sp, #0x14]
700a92d4: 9907         	ldr	r1, [sp, #0x1c]
700a92d6: 6308         	str	r0, [r1, #0x30]
;       } else {
700a92d8: e003         	b	0x700a92e2 <xTaskCreate+0x42> @ imm = #0x6
;         vPortFree(pxStack);
700a92da: 9805         	ldr	r0, [sp, #0x14]
700a92dc: f005 fef8    	bl	0x700af0d0 <vPortFree>  @ imm = #0x5df0
700a92e0: e7ff         	b	0x700a92e2 <xTaskCreate+0x42> @ imm = #-0x2
;     } else {
700a92e2: e002         	b	0x700a92ea <xTaskCreate+0x4a> @ imm = #0x4
700a92e4: 2000         	movs	r0, #0x0
;       pxNewTCB = NULL;
700a92e6: 9007         	str	r0, [sp, #0x1c]
700a92e8: e7ff         	b	0x700a92ea <xTaskCreate+0x4a> @ imm = #-0x2
;   if (pxNewTCB != NULL) {
700a92ea: 9807         	ldr	r0, [sp, #0x1c]
700a92ec: b1e8         	cbz	r0, 0x700a932a <xTaskCreate+0x8a> @ imm = #0x3a
700a92ee: e7ff         	b	0x700a92f0 <xTaskCreate+0x50> @ imm = #-0x2
;       pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
700a92f0: 9807         	ldr	r0, [sp, #0x1c]
700a92f2: 2600         	movs	r6, #0x0
700a92f4: f880 6081    	strb.w	r6, [r0, #0x81]
;     prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth,
700a92f8: 980b         	ldr	r0, [sp, #0x2c]
700a92fa: 990a         	ldr	r1, [sp, #0x28]
700a92fc: 9a09         	ldr	r2, [sp, #0x24]
;                          pvParameters, uxPriority, pxCreatedTask, pxNewTCB,
700a92fe: 9b08         	ldr	r3, [sp, #0x20]
700a9300: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a9304: 9c11         	ldr	r4, [sp, #0x44]
700a9306: 9d07         	ldr	r5, [sp, #0x1c]
;     prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth,
700a9308: 46ee         	mov	lr, sp
700a930a: f8ce 600c    	str.w	r6, [lr, #0xc]
700a930e: f8ce 5008    	str.w	r5, [lr, #0x8]
700a9312: f8ce 4004    	str.w	r4, [lr, #0x4]
700a9316: f8ce c000    	str.w	r12, [lr]
700a931a: f7fb fc41    	bl	0x700a4ba0 <prvInitialiseNewTask> @ imm = #-0x477e
;     prvAddNewTaskToReadyList(pxNewTCB);
700a931e: 9807         	ldr	r0, [sp, #0x1c]
700a9320: f7fb fd56    	bl	0x700a4dd0 <prvAddNewTaskToReadyList> @ imm = #-0x4554
700a9324: 2001         	movs	r0, #0x1
;     xReturn = pdPASS;
700a9326: 9006         	str	r0, [sp, #0x18]
;   } else {
700a9328: e003         	b	0x700a9332 <xTaskCreate+0x92> @ imm = #0x6
700a932a: f04f 30ff    	mov.w	r0, #0xffffffff
;     xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
700a932e: 9006         	str	r0, [sp, #0x18]
700a9330: e7ff         	b	0x700a9332 <xTaskCreate+0x92> @ imm = #-0x2
;   return xReturn;
700a9332: 9806         	ldr	r0, [sp, #0x18]
700a9334: b00c         	add	sp, #0x30
700a9336: bd70         	pop	{r4, r5, r6, pc}
		...

700a9340 <PMU_profileStart>:
; int32_t PMU_profileStart(const char *name) {
700a9340: b580         	push	{r7, lr}
700a9342: b088         	sub	sp, #0x20
700a9344: 9006         	str	r0, [sp, #0x18]
;   if (gProfileObject.logIndex >= PMU_MAX_LOG_ENTRIES) {
700a9346: f243 0080    	movw	r0, #0x3080
700a934a: f2c7 0008    	movt	r0, #0x7008
700a934e: 6800         	ldr	r0, [r0]
700a9350: 2840         	cmp	r0, #0x40
700a9352: d304         	blo	0x700a935e <PMU_profileStart+0x1e> @ imm = #0x8
700a9354: e7ff         	b	0x700a9356 <PMU_profileStart+0x16> @ imm = #-0x2
700a9356: f04f 30ff    	mov.w	r0, #0xffffffff
;     return SystemP_FAILURE; /* Log is full */
700a935a: 9007         	str	r0, [sp, #0x1c]
700a935c: e038         	b	0x700a93d0 <PMU_profileStart+0x90> @ imm = #0x70
;   uint32_t i = gProfileObject.logIndex;
700a935e: f243 0280    	movw	r2, #0x3080
700a9362: f2c7 0208    	movt	r2, #0x7008
700a9366: 6810         	ldr	r0, [r2]
700a9368: 9005         	str	r0, [sp, #0x14]
;   uint32_t numEvents = gProfileObject.numEvents;
700a936a: 6890         	ldr	r0, [r2, #0x8]
700a936c: 9003         	str	r0, [sp, #0xc]
;   uint32_t bCCnt = gProfileObject.bCycleCounter;
700a936e: 6850         	ldr	r0, [r2, #0x4]
700a9370: 9002         	str	r0, [sp, #0x8]
;   PMU_ProfilePoint *p = &gProfileObject.point[i];
700a9372: 9805         	ldr	r0, [sp, #0x14]
700a9374: 2134         	movs	r1, #0x34
700a9376: fb00 2001    	mla	r0, r0, r1, r2
700a937a: 300c         	adds	r0, #0xc
700a937c: 9001         	str	r0, [sp, #0x4]
;   p->name = name;
700a937e: 9806         	ldr	r0, [sp, #0x18]
700a9380: 9901         	ldr	r1, [sp, #0x4]
700a9382: 6308         	str	r0, [r1, #0x30]
;   PMU_resetCounters();
700a9384: f006 fae4    	bl	0x700af950 <PMU_resetCounters> @ imm = #0x65c8
;   if (bCCnt == TRUE) {
700a9388: 9802         	ldr	r0, [sp, #0x8]
700a938a: 2801         	cmp	r0, #0x1
700a938c: d106         	bne	0x700a939c <PMU_profileStart+0x5c> @ imm = #0xc
700a938e: e7ff         	b	0x700a9390 <PMU_profileStart+0x50> @ imm = #-0x2
700a9390: 201f         	movs	r0, #0x1f
;         CSL_armR5PmuReadCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM);
700a9392: f7f8 ee3c    	blx	0x700a200c <CSL_armR5PmuReadCntr> @ imm = #-0x7388
;     p->cycleCount.value =
700a9396: 9901         	ldr	r1, [sp, #0x4]
700a9398: 62c8         	str	r0, [r1, #0x2c]
;   }
700a939a: e7ff         	b	0x700a939c <PMU_profileStart+0x5c> @ imm = #-0x2
700a939c: 2000         	movs	r0, #0x0
;   for (j = 0; j < numEvents; j++) {
700a939e: 9004         	str	r0, [sp, #0x10]
700a93a0: e7ff         	b	0x700a93a2 <PMU_profileStart+0x62> @ imm = #-0x2
700a93a2: 9804         	ldr	r0, [sp, #0x10]
700a93a4: 9903         	ldr	r1, [sp, #0xc]
700a93a6: 4288         	cmp	r0, r1
700a93a8: d20f         	bhs	0x700a93ca <PMU_profileStart+0x8a> @ imm = #0x1e
700a93aa: e7ff         	b	0x700a93ac <PMU_profileStart+0x6c> @ imm = #-0x2
;     p->events[j].value = CSL_armR5PmuReadCntr(j);
700a93ac: 9804         	ldr	r0, [sp, #0x10]
700a93ae: f7f8 ee2e    	blx	0x700a200c <CSL_armR5PmuReadCntr> @ imm = #-0x73a4
700a93b2: 9901         	ldr	r1, [sp, #0x4]
700a93b4: 9a04         	ldr	r2, [sp, #0x10]
700a93b6: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a93ba: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a93be: 6088         	str	r0, [r1, #0x8]
;   }
700a93c0: e7ff         	b	0x700a93c2 <PMU_profileStart+0x82> @ imm = #-0x2
;   for (j = 0; j < numEvents; j++) {
700a93c2: 9804         	ldr	r0, [sp, #0x10]
700a93c4: 3001         	adds	r0, #0x1
700a93c6: 9004         	str	r0, [sp, #0x10]
700a93c8: e7eb         	b	0x700a93a2 <PMU_profileStart+0x62> @ imm = #-0x2a
700a93ca: 2000         	movs	r0, #0x0
;   return SystemP_SUCCESS;
700a93cc: 9007         	str	r0, [sp, #0x1c]
700a93ce: e7ff         	b	0x700a93d0 <PMU_profileStart+0x90> @ imm = #-0x2
; }
700a93d0: 9807         	ldr	r0, [sp, #0x1c]
700a93d2: b008         	add	sp, #0x20
700a93d4: bd80         	pop	{r7, pc}
		...
700a93de: 0000         	movs	r0, r0

700a93e0 <Sciclient_init>:
; {
700a93e0: b580         	push	{r7, lr}
700a93e2: b086         	sub	sp, #0x18
700a93e4: 9005         	str	r0, [sp, #0x14]
700a93e6: 2100         	movs	r1, #0x0
;     int32_t   status = SystemP_SUCCESS;
700a93e8: 9101         	str	r1, [sp, #0x4]
700a93ea: 9104         	str	r1, [sp, #0x10]
;         = (CSL_sec_proxyRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyRegs);
700a93ec: f242 5080    	movw	r0, #0x2580
700a93f0: f2c7 000b    	movt	r0, #0x700b
700a93f4: 9002         	str	r0, [sp, #0x8]
700a93f6: 6800         	ldr	r0, [r0]
700a93f8: f7fc fa82    	bl	0x700a5900 <AddrTranslateP_getLocalAddr> @ imm = #-0x3afc
700a93fc: 9901         	ldr	r1, [sp, #0x4]
700a93fe: 4602         	mov	r2, r0
700a9400: 9802         	ldr	r0, [sp, #0x8]
700a9402: 6002         	str	r2, [r0]
;         = (CSL_sec_proxy_scfgRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyScfgRegs);
700a9404: 6840         	ldr	r0, [r0, #0x4]
700a9406: f7fc fa7b    	bl	0x700a5900 <AddrTranslateP_getLocalAddr> @ imm = #-0x3b0a
700a940a: 9901         	ldr	r1, [sp, #0x4]
700a940c: 4602         	mov	r2, r0
700a940e: 9802         	ldr	r0, [sp, #0x8]
700a9410: 6042         	str	r2, [r0, #0x4]
;         = (CSL_sec_proxy_rtRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyRtRegs);
700a9412: 6880         	ldr	r0, [r0, #0x8]
700a9414: f7fc fa74    	bl	0x700a5900 <AddrTranslateP_getLocalAddr> @ imm = #-0x3b18
700a9418: 9902         	ldr	r1, [sp, #0x8]
700a941a: 6088         	str	r0, [r1, #0x8]
;         = (uint64_t)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.proxyTargetAddr);
700a941c: 6908         	ldr	r0, [r1, #0x10]
700a941e: 6949         	ldr	r1, [r1, #0x14]
700a9420: f7fc fa6e    	bl	0x700a5900 <AddrTranslateP_getLocalAddr> @ imm = #-0x3b24
700a9424: 9a02         	ldr	r2, [sp, #0x8]
700a9426: 4601         	mov	r1, r0
700a9428: 9801         	ldr	r0, [sp, #0x4]
700a942a: 6150         	str	r0, [r2, #0x14]
700a942c: 6111         	str	r1, [r2, #0x10]
;     gSciclientHandle.currSeqId = 0;
700a942e: f242 6108    	movw	r1, #0x2608
700a9432: f2c7 010b    	movt	r1, #0x700b
700a9436: 9103         	str	r1, [sp, #0xc]
700a9438: 6008         	str	r0, [r1]
;     gSciclientHandle.coreId = coreId;
700a943a: 9805         	ldr	r0, [sp, #0x14]
700a943c: 6048         	str	r0, [r1, #0x4]
;     gSciclientHandle.devIdCore = Sciclient_getDevId(coreId);
700a943e: 9805         	ldr	r0, [sp, #0x14]
700a9440: f003 fede    	bl	0x700ad200 <Sciclient_getDevId> @ imm = #0x3dbc
700a9444: 9a03         	ldr	r2, [sp, #0xc]
700a9446: 4601         	mov	r1, r0
700a9448: 9801         	ldr	r0, [sp, #0x4]
700a944a: 6091         	str	r1, [r2, #0x8]
;     gSciclientHandle.secureContextId = Sciclient_getContext(SCICLIENT_SECURE_CONTEXT, coreId);
700a944c: 9905         	ldr	r1, [sp, #0x14]
700a944e: f7ff fb17    	bl	0x700a8a80 <Sciclient_getContext> @ imm = #-0x9d2
700a9452: 9903         	ldr	r1, [sp, #0xc]
700a9454: 60c8         	str	r0, [r1, #0xc]
;     gSciclientHandle.nonSecureContextId = Sciclient_getContext(SCICLIENT_NON_SECURE_CONTEXT, coreId);
700a9456: 9905         	ldr	r1, [sp, #0x14]
700a9458: 2001         	movs	r0, #0x1
700a945a: f7ff fb11    	bl	0x700a8a80 <Sciclient_getContext> @ imm = #-0x9de
700a945e: 9a03         	ldr	r2, [sp, #0xc]
700a9460: 4601         	mov	r1, r0
700a9462: 9802         	ldr	r0, [sp, #0x8]
700a9464: 6111         	str	r1, [r2, #0x10]
;     gSciclientHandle.maxMsgSizeBytes = CSL_secProxyGetMaxMsgSize(&gSciclientSecProxyCfg) -
700a9466: f005 f8eb    	bl	0x700ae640 <CSL_secProxyGetMaxMsgSize> @ imm = #0x51d6
700a946a: 9903         	ldr	r1, [sp, #0xc]
700a946c: 3804         	subs	r0, #0x4
700a946e: 6148         	str	r0, [r1, #0x14]
;     return status;
700a9470: 9804         	ldr	r0, [sp, #0x10]
700a9472: b006         	add	sp, #0x18
700a9474: bd80         	pop	{r7, pc}
		...
700a947e: 0000         	movs	r0, r0

700a9480 <UART_subConfigTCRTLRModeEn>:
; {
700a9480: b580         	push	{r7, lr}
700a9482: b088         	sub	sp, #0x20
700a9484: 9007         	str	r0, [sp, #0x1c]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a9486: 9807         	ldr	r0, [sp, #0x1c]
700a9488: 21bf         	movs	r1, #0xbf
700a948a: 9101         	str	r1, [sp, #0x4]
700a948c: f003 f850    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #0x30a0
700a9490: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a9492: 9807         	ldr	r0, [sp, #0x1c]
700a9494: 3008         	adds	r0, #0x8
700a9496: 2110         	movs	r1, #0x10
700a9498: 9102         	str	r1, [sp, #0x8]
700a949a: 2204         	movs	r2, #0x4
700a949c: 9203         	str	r2, [sp, #0xc]
700a949e: f005 fde7    	bl	0x700af070 <HW_RD_FIELD32_RAW> @ imm = #0x5bce
700a94a2: 9902         	ldr	r1, [sp, #0x8]
700a94a4: 9a03         	ldr	r2, [sp, #0xc]
700a94a6: 9006         	str	r0, [sp, #0x18]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a94a8: 9807         	ldr	r0, [sp, #0x1c]
700a94aa: 3008         	adds	r0, #0x8
700a94ac: 2301         	movs	r3, #0x1
700a94ae: 9300         	str	r3, [sp]
700a94b0: f004 ffae    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x4f5c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a94b4: 9807         	ldr	r0, [sp, #0x1c]
700a94b6: 300c         	adds	r0, #0xc
700a94b8: 9904         	ldr	r1, [sp, #0x10]
700a94ba: f006 f9d9    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x63b2
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700a94be: 9807         	ldr	r0, [sp, #0x1c]
700a94c0: 2180         	movs	r1, #0x80
700a94c2: f003 f835    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #0x306a
700a94c6: 9004         	str	r0, [sp, #0x10]
;     tcrTlrValue = HW_RD_REG32(baseAddr + UART_MCR) & UART_MCR_TCR_TLR_MASK;
700a94c8: 9807         	ldr	r0, [sp, #0x1c]
700a94ca: 3010         	adds	r0, #0x10
700a94cc: f006 f9c8    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x6390
700a94d0: 9b00         	ldr	r3, [sp]
700a94d2: f000 0040    	and	r0, r0, #0x40
700a94d6: 9005         	str	r0, [sp, #0x14]
;     HW_WR_FIELD32(baseAddr + UART_MCR, UART_MCR_TCR_TLR,
700a94d8: 9807         	ldr	r0, [sp, #0x1c]
700a94da: 3010         	adds	r0, #0x10
700a94dc: 2140         	movs	r1, #0x40
700a94de: 2206         	movs	r2, #0x6
700a94e0: f004 ff96    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x4f2c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a94e4: 9807         	ldr	r0, [sp, #0x1c]
700a94e6: 300c         	adds	r0, #0xc
700a94e8: 9904         	ldr	r1, [sp, #0x10]
700a94ea: f006 f9c1    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x6382
700a94ee: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a94f0: 9807         	ldr	r0, [sp, #0x1c]
700a94f2: f003 f81d    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #0x303a
700a94f6: 9902         	ldr	r1, [sp, #0x8]
700a94f8: 9a03         	ldr	r2, [sp, #0xc]
700a94fa: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a94fc: 9807         	ldr	r0, [sp, #0x1c]
700a94fe: 3008         	adds	r0, #0x8
700a9500: 9b06         	ldr	r3, [sp, #0x18]
700a9502: f004 ff85    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x4f0a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a9506: 9807         	ldr	r0, [sp, #0x1c]
700a9508: 300c         	adds	r0, #0xc
700a950a: 9904         	ldr	r1, [sp, #0x10]
700a950c: f006 f9b0    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x6360
;     return tcrTlrValue;
700a9510: 9805         	ldr	r0, [sp, #0x14]
700a9512: b008         	add	sp, #0x20
700a9514: bd80         	pop	{r7, pc}
		...
700a951e: 0000         	movs	r0, r0

700a9520 <UART_udmaIsrRx>:
; {
700a9520: b580         	push	{r7, lr}
700a9522: b08a         	sub	sp, #0x28
700a9524: 9009         	str	r0, [sp, #0x24]
700a9526: 9108         	str	r1, [sp, #0x20]
700a9528: 9207         	str	r2, [sp, #0x1c]
;     if(NULL != args)
700a952a: 9807         	ldr	r0, [sp, #0x1c]
700a952c: 2800         	cmp	r0, #0x0
700a952e: d040         	beq	0x700a95b2 <UART_udmaIsrRx+0x92> @ imm = #0x80
700a9530: e7ff         	b	0x700a9532 <UART_udmaIsrRx+0x12> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a9532: 9807         	ldr	r0, [sp, #0x1c]
700a9534: 9000         	str	r0, [sp]
;         udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a9536: 9800         	ldr	r0, [sp]
700a9538: 6840         	ldr	r0, [r0, #0x4]
700a953a: 6cc0         	ldr	r0, [r0, #0x4c]
700a953c: 9001         	str	r0, [sp, #0x4]
;         rxChHandle  = udmaChCfg->rxChHandle;
700a953e: 9801         	ldr	r0, [sp, #0x4]
700a9540: 6880         	ldr	r0, [r0, #0x8]
700a9542: 9002         	str	r0, [sp, #0x8]
;         if (eventType == UDMA_EVENT_TYPE_DMA_COMPLETION)
700a9544: 9808         	ldr	r0, [sp, #0x20]
700a9546: 2801         	cmp	r0, #0x1
700a9548: d12e         	bne	0x700a95a8 <UART_udmaIsrRx+0x88> @ imm = #0x5c
700a954a: e7ff         	b	0x700a954c <UART_udmaIsrRx+0x2c> @ imm = #-0x2
;             CacheP_inv(udmaChCfg->rxHpdMem, udmaChCfg->hpdMemSize, CacheP_TYPE_ALLD);
700a954c: 9901         	ldr	r1, [sp, #0x4]
700a954e: 6988         	ldr	r0, [r1, #0x18]
700a9550: 69c9         	ldr	r1, [r1, #0x1c]
700a9552: 220a         	movs	r2, #0xa
700a9554: f007 fb14    	bl	0x700b0b80 <CacheP_inv> @ imm = #0x7628
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(rxChHandle), &pDesc);
700a9558: 9802         	ldr	r0, [sp, #0x8]
700a955a: f001 fc29    	bl	0x700aadb0 <Udma_chGetCqRingHandle> @ imm = #0x1852
700a955e: a904         	add	r1, sp, #0x10
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(rxChHandle), &pDesc);
700a9560: f000 f8ce    	bl	0x700a9700 <Udma_ringDequeueRaw> @ imm = #0x19c
700a9564: 9006         	str	r0, [sp, #0x18]
;             if ((retVal == UDMA_SOK) && (pDesc != 0UL))
700a9566: 9806         	ldr	r0, [sp, #0x18]
700a9568: b988         	cbnz	r0, 0x700a958e <UART_udmaIsrRx+0x6e> @ imm = #0x22
700a956a: e7ff         	b	0x700a956c <UART_udmaIsrRx+0x4c> @ imm = #-0x2
700a956c: 9804         	ldr	r0, [sp, #0x10]
700a956e: 9905         	ldr	r1, [sp, #0x14]
700a9570: 4308         	orrs	r0, r1
700a9572: b160         	cbz	r0, 0x700a958e <UART_udmaIsrRx+0x6e> @ imm = #0x18
700a9574: e7ff         	b	0x700a9576 <UART_udmaIsrRx+0x56> @ imm = #-0x2
;                 pHpd = (CSL_UdmapCppi5HMPD *)(uintptr_t)pDesc;
700a9576: 9804         	ldr	r0, [sp, #0x10]
700a9578: 9003         	str	r0, [sp, #0xc]
;                 hUart->readTrans.count = (pHpd->descInfo & CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_MASK) >> CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_SHIFT;
700a957a: 9803         	ldr	r0, [sp, #0xc]
700a957c: 6800         	ldr	r0, [r0]
700a957e: f36f 509f    	bfc	r0, #22, #10
700a9582: 9900         	ldr	r1, [sp]
700a9584: 62c8         	str	r0, [r1, #0x2c]
;                 hUart->readTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a9586: 9900         	ldr	r1, [sp]
700a9588: 2000         	movs	r0, #0x0
700a958a: 6348         	str	r0, [r1, #0x34]
;             }
700a958c: e003         	b	0x700a9596 <UART_udmaIsrRx+0x76> @ imm = #0x6
;                 hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a958e: 9900         	ldr	r1, [sp]
700a9590: 200a         	movs	r0, #0xa
700a9592: 6348         	str	r0, [r1, #0x34]
700a9594: e7ff         	b	0x700a9596 <UART_udmaIsrRx+0x76> @ imm = #-0x2
;             hUart->hUartInit->readCompleteCallbackFxn(hUart);
700a9596: 9800         	ldr	r0, [sp]
700a9598: 6841         	ldr	r1, [r0, #0x4]
700a959a: 6dc9         	ldr	r1, [r1, #0x5c]
700a959c: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->readTrans);
700a959e: 9800         	ldr	r0, [sp]
700a95a0: 3028         	adds	r0, #0x28
700a95a2: f005 fe05    	bl	0x700af1b0 <UART_lld_Transaction_deInit> @ imm = #0x5c0a
;         }
700a95a6: e003         	b	0x700a95b0 <UART_udmaIsrRx+0x90> @ imm = #0x6
;             hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a95a8: 9900         	ldr	r1, [sp]
700a95aa: 200a         	movs	r0, #0xa
700a95ac: 6488         	str	r0, [r1, #0x48]
700a95ae: e7ff         	b	0x700a95b0 <UART_udmaIsrRx+0x90> @ imm = #-0x2
;     }
700a95b0: e7ff         	b	0x700a95b2 <UART_udmaIsrRx+0x92> @ imm = #-0x2
;     return;
700a95b2: b00a         	add	sp, #0x28
700a95b4: bd80         	pop	{r7, pc}
		...
700a95be: 0000         	movs	r0, r0

700a95c0 <UART_udmaIsrTx>:
; {
700a95c0: b580         	push	{r7, lr}
700a95c2: b08a         	sub	sp, #0x28
700a95c4: 9009         	str	r0, [sp, #0x24]
700a95c6: 9108         	str	r1, [sp, #0x20]
700a95c8: 9207         	str	r2, [sp, #0x1c]
;     if(NULL != args)
700a95ca: 9807         	ldr	r0, [sp, #0x1c]
700a95cc: 2800         	cmp	r0, #0x0
700a95ce: d040         	beq	0x700a9652 <UART_udmaIsrTx+0x92> @ imm = #0x80
700a95d0: e7ff         	b	0x700a95d2 <UART_udmaIsrTx+0x12> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a95d2: 9807         	ldr	r0, [sp, #0x1c]
700a95d4: 9000         	str	r0, [sp]
;         udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a95d6: 9800         	ldr	r0, [sp]
700a95d8: 6840         	ldr	r0, [r0, #0x4]
700a95da: 6cc0         	ldr	r0, [r0, #0x4c]
700a95dc: 9001         	str	r0, [sp, #0x4]
;         txChHandle  = udmaChCfg->txChHandle;
700a95de: 9801         	ldr	r0, [sp, #0x4]
700a95e0: 6840         	ldr	r0, [r0, #0x4]
700a95e2: 9002         	str	r0, [sp, #0x8]
;         if (eventType == UDMA_EVENT_TYPE_DMA_COMPLETION)
700a95e4: 9808         	ldr	r0, [sp, #0x20]
700a95e6: 2801         	cmp	r0, #0x1
700a95e8: d12e         	bne	0x700a9648 <UART_udmaIsrTx+0x88> @ imm = #0x5c
700a95ea: e7ff         	b	0x700a95ec <UART_udmaIsrTx+0x2c> @ imm = #-0x2
;             CacheP_inv(udmaChCfg->txHpdMem, udmaChCfg->hpdMemSize, CacheP_TYPE_ALLD);
700a95ec: 9901         	ldr	r1, [sp, #0x4]
700a95ee: 6948         	ldr	r0, [r1, #0x14]
700a95f0: 69c9         	ldr	r1, [r1, #0x1c]
700a95f2: 220a         	movs	r2, #0xa
700a95f4: f007 fac4    	bl	0x700b0b80 <CacheP_inv> @ imm = #0x7588
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(txChHandle), &pDesc);
700a95f8: 9802         	ldr	r0, [sp, #0x8]
700a95fa: f001 fbd9    	bl	0x700aadb0 <Udma_chGetCqRingHandle> @ imm = #0x17b2
700a95fe: a904         	add	r1, sp, #0x10
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(txChHandle), &pDesc);
700a9600: f000 f87e    	bl	0x700a9700 <Udma_ringDequeueRaw> @ imm = #0xfc
700a9604: 9006         	str	r0, [sp, #0x18]
;             if ((retVal == UDMA_SOK) && (pDesc != 0UL))
700a9606: 9806         	ldr	r0, [sp, #0x18]
700a9608: b988         	cbnz	r0, 0x700a962e <UART_udmaIsrTx+0x6e> @ imm = #0x22
700a960a: e7ff         	b	0x700a960c <UART_udmaIsrTx+0x4c> @ imm = #-0x2
700a960c: 9804         	ldr	r0, [sp, #0x10]
700a960e: 9905         	ldr	r1, [sp, #0x14]
700a9610: 4308         	orrs	r0, r1
700a9612: b160         	cbz	r0, 0x700a962e <UART_udmaIsrTx+0x6e> @ imm = #0x18
700a9614: e7ff         	b	0x700a9616 <UART_udmaIsrTx+0x56> @ imm = #-0x2
;                 pHpd = (CSL_UdmapCppi5HMPD *)(uintptr_t)pDesc;
700a9616: 9804         	ldr	r0, [sp, #0x10]
700a9618: 9003         	str	r0, [sp, #0xc]
;                 hUart->writeTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a961a: 9900         	ldr	r1, [sp]
700a961c: 2000         	movs	r0, #0x0
700a961e: 6488         	str	r0, [r1, #0x48]
;                 hUart->writeTrans.count = (pHpd->descInfo & CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_MASK) >> CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_SHIFT;
700a9620: 9803         	ldr	r0, [sp, #0xc]
700a9622: 6800         	ldr	r0, [r0]
700a9624: f36f 509f    	bfc	r0, #22, #10
700a9628: 9900         	ldr	r1, [sp]
700a962a: 6408         	str	r0, [r1, #0x40]
;             }
700a962c: e003         	b	0x700a9636 <UART_udmaIsrTx+0x76> @ imm = #0x6
;                 hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a962e: 9900         	ldr	r1, [sp]
700a9630: 200a         	movs	r0, #0xa
700a9632: 6488         	str	r0, [r1, #0x48]
700a9634: e7ff         	b	0x700a9636 <UART_udmaIsrTx+0x76> @ imm = #-0x2
;             hUart->hUartInit->writeCompleteCallbackFxn(hUart);
700a9636: 9800         	ldr	r0, [sp]
700a9638: 6841         	ldr	r1, [r0, #0x4]
700a963a: 6e09         	ldr	r1, [r1, #0x60]
700a963c: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a963e: 9800         	ldr	r0, [sp]
700a9640: 303c         	adds	r0, #0x3c
700a9642: f005 fdb5    	bl	0x700af1b0 <UART_lld_Transaction_deInit> @ imm = #0x5b6a
;         }
700a9646: e003         	b	0x700a9650 <UART_udmaIsrTx+0x90> @ imm = #0x6
;             hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a9648: 9900         	ldr	r1, [sp]
700a964a: 200a         	movs	r0, #0xa
700a964c: 6488         	str	r0, [r1, #0x48]
700a964e: e7ff         	b	0x700a9650 <UART_udmaIsrTx+0x90> @ imm = #-0x2
;     }
700a9650: e7ff         	b	0x700a9652 <UART_udmaIsrTx+0x92> @ imm = #-0x2
;     return;
700a9652: b00a         	add	sp, #0x28
700a9654: bd80         	pop	{r7, pc}
		...
700a965e: 0000         	movs	r0, r0

700a9660 <UdmaFlowPrms_init>:
; {
700a9660: b084         	sub	sp, #0x10
700a9662: 9003         	str	r0, [sp, #0xc]
700a9664: 9102         	str	r1, [sp, #0x8]
;     if(NULL_PTR != flowPrms)
700a9666: 9803         	ldr	r0, [sp, #0xc]
700a9668: 2800         	cmp	r0, #0x0
700a966a: d042         	beq	0x700a96f2 <UdmaFlowPrms_init+0x92> @ imm = #0x84
700a966c: e7ff         	b	0x700a966e <UdmaFlowPrms_init+0xe> @ imm = #-0x2
;         flowPrms->rxChHandle    = (Udma_ChHandle) NULL_PTR;
700a966e: 9803         	ldr	r0, [sp, #0xc]
700a9670: 2100         	movs	r1, #0x0
700a9672: 9100         	str	r1, [sp]
700a9674: 6001         	str	r1, [r0]
;         flowPrms->einfoPresent  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_EINFO_NOT_PRESENT;
700a9676: 9803         	ldr	r0, [sp, #0xc]
700a9678: 7101         	strb	r1, [r0, #0x4]
;         flowPrms->psInfoPresent = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PSINFO_NOT_PRESENT;
700a967a: 9803         	ldr	r0, [sp, #0xc]
700a967c: 7141         	strb	r1, [r0, #0x5]
;         flowPrms->errorHandling = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_ERR_RETRY;
700a967e: 9a03         	ldr	r2, [sp, #0xc]
700a9680: 2001         	movs	r0, #0x1
700a9682: 7190         	strb	r0, [r2, #0x6]
;         flowPrms->descType      = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DESC_HOST;
700a9684: 9803         	ldr	r0, [sp, #0xc]
700a9686: 71c1         	strb	r1, [r0, #0x7]
;         flowPrms->psLocation    = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PS_END_PD;
700a9688: 9803         	ldr	r0, [sp, #0xc]
700a968a: 7201         	strb	r1, [r0, #0x8]
;         flowPrms->sopOffset     = 0U;
700a968c: 9803         	ldr	r0, [sp, #0xc]
700a968e: 8141         	strh	r1, [r0, #0xa]
;         flowPrms->defaultRxCQ   = UDMA_RING_INVALID;
700a9690: 9a03         	ldr	r2, [sp, #0xc]
700a9692: f64f 70ff    	movw	r0, #0xffff
700a9696: 9001         	str	r0, [sp, #0x4]
700a9698: 8190         	strh	r0, [r2, #0xc]
;         flowPrms->srcTagLo      = 0U;
700a969a: 9a03         	ldr	r2, [sp, #0xc]
700a969c: 73d1         	strb	r1, [r2, #0xf]
;         flowPrms->srcTagLoSel   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_SRC_SELECT_SRC_TAG;
700a969e: 9b03         	ldr	r3, [sp, #0xc]
700a96a0: 2204         	movs	r2, #0x4
700a96a2: 745a         	strb	r2, [r3, #0x11]
;         flowPrms->srcTagHi      = 0U;
700a96a4: 9b03         	ldr	r3, [sp, #0xc]
700a96a6: 7399         	strb	r1, [r3, #0xe]
;         flowPrms->srcTagHiSel   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_SRC_SELECT_FLOW_ID;
700a96a8: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700a96ac: 2302         	movs	r3, #0x2
700a96ae: f88c 3010    	strb.w	r3, [r12, #0x10]
;         flowPrms->destTagLo     = 0U;
700a96b2: 9b03         	ldr	r3, [sp, #0xc]
700a96b4: 74d9         	strb	r1, [r3, #0x13]
;         flowPrms->destTagLoSel  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DEST_SELECT_DEST_TAG_LO;
700a96b6: 9b03         	ldr	r3, [sp, #0xc]
700a96b8: 755a         	strb	r2, [r3, #0x15]
;         flowPrms->destTagHi     = 0U;
700a96ba: 9a03         	ldr	r2, [sp, #0xc]
700a96bc: 7491         	strb	r1, [r2, #0x12]
;         flowPrms->destTagHiSel  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DEST_SELECT_DEST_TAG_HI;
700a96be: 9b03         	ldr	r3, [sp, #0xc]
700a96c0: 2205         	movs	r2, #0x5
700a96c2: 751a         	strb	r2, [r3, #0x14]
;         flowPrms->sizeThreshEn  = 0U;
700a96c4: 9a03         	ldr	r2, [sp, #0xc]
700a96c6: 7591         	strb	r1, [r2, #0x16]
;         flowPrms->fdq0Sz0Qnum   = UDMA_RING_INVALID;
700a96c8: 9a03         	ldr	r2, [sp, #0xc]
700a96ca: 8310         	strh	r0, [r2, #0x18]
;         flowPrms->fdq1Qnum      = UDMA_RING_INVALID;
700a96cc: 9a03         	ldr	r2, [sp, #0xc]
700a96ce: 8350         	strh	r0, [r2, #0x1a]
;         flowPrms->fdq2Qnum      = UDMA_RING_INVALID;
700a96d0: 9a03         	ldr	r2, [sp, #0xc]
700a96d2: 8390         	strh	r0, [r2, #0x1c]
;         flowPrms->fdq3Qnum      = UDMA_RING_INVALID;
700a96d4: 9a03         	ldr	r2, [sp, #0xc]
700a96d6: 83d0         	strh	r0, [r2, #0x1e]
;         flowPrms->sizeThresh0   = 0U;
700a96d8: 9a03         	ldr	r2, [sp, #0xc]
700a96da: 8411         	strh	r1, [r2, #0x20]
;         flowPrms->sizeThresh1   = 0U;
700a96dc: 9a03         	ldr	r2, [sp, #0xc]
700a96de: 8451         	strh	r1, [r2, #0x22]
;         flowPrms->sizeThresh2   = 0U;
700a96e0: 9a03         	ldr	r2, [sp, #0xc]
700a96e2: 8491         	strh	r1, [r2, #0x24]
;         flowPrms->fdq0Sz1Qnum   = UDMA_RING_INVALID;
700a96e4: 9903         	ldr	r1, [sp, #0xc]
700a96e6: 84c8         	strh	r0, [r1, #0x26]
;         flowPrms->fdq0Sz2Qnum   = UDMA_RING_INVALID;
700a96e8: 9903         	ldr	r1, [sp, #0xc]
700a96ea: 8508         	strh	r0, [r1, #0x28]
;         flowPrms->fdq0Sz3Qnum   = UDMA_RING_INVALID;
700a96ec: 9903         	ldr	r1, [sp, #0xc]
700a96ee: 8548         	strh	r0, [r1, #0x2a]
;     }
700a96f0: e7ff         	b	0x700a96f2 <UdmaFlowPrms_init+0x92> @ imm = #-0x2
;     return;
700a96f2: b004         	add	sp, #0x10
700a96f4: 4770         	bx	lr
		...
700a96fe: 0000         	movs	r0, r0

700a9700 <Udma_ringDequeueRaw>:
; {
700a9700: b580         	push	{r7, lr}
700a9702: b086         	sub	sp, #0x18
700a9704: 9005         	str	r0, [sp, #0x14]
700a9706: 9104         	str	r1, [sp, #0x10]
700a9708: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a970a: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a970c: 9805         	ldr	r0, [sp, #0x14]
700a970e: 9000         	str	r0, [sp]
;     if((NULL_PTR == ringHandleInt) ||
700a9710: 9800         	ldr	r0, [sp]
700a9712: b180         	cbz	r0, 0x700a9736 <Udma_ringDequeueRaw+0x36> @ imm = #0x20
700a9714: e7ff         	b	0x700a9716 <Udma_ringDequeueRaw+0x16> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a9716: 9800         	ldr	r0, [sp]
700a9718: 6d80         	ldr	r0, [r0, #0x58]
700a971a: f64a 31cd    	movw	r1, #0xabcd
700a971e: f6ca 31dc    	movt	r1, #0xabdc
700a9722: 4288         	cmp	r0, r1
700a9724: d107         	bne	0x700a9736 <Udma_ringDequeueRaw+0x36> @ imm = #0xe
700a9726: e7ff         	b	0x700a9728 <Udma_ringDequeueRaw+0x28> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a9728: 9800         	ldr	r0, [sp]
700a972a: 8880         	ldrh	r0, [r0, #0x4]
700a972c: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a9730: 4288         	cmp	r0, r1
700a9732: d104         	bne	0x700a973e <Udma_ringDequeueRaw+0x3e> @ imm = #0x8
700a9734: e7ff         	b	0x700a9736 <Udma_ringDequeueRaw+0x36> @ imm = #-0x2
700a9736: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a973a: 9003         	str	r0, [sp, #0xc]
;     }
700a973c: e7ff         	b	0x700a973e <Udma_ringDequeueRaw+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a973e: 9803         	ldr	r0, [sp, #0xc]
700a9740: b9a8         	cbnz	r0, 0x700a976e <Udma_ringDequeueRaw+0x6e> @ imm = #0x2a
700a9742: e7ff         	b	0x700a9744 <Udma_ringDequeueRaw+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a9744: 9800         	ldr	r0, [sp]
700a9746: 6800         	ldr	r0, [r0]
700a9748: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) ||
700a974a: 9801         	ldr	r0, [sp, #0x4]
700a974c: b150         	cbz	r0, 0x700a9764 <Udma_ringDequeueRaw+0x64> @ imm = #0x14
700a974e: e7ff         	b	0x700a9750 <Udma_ringDequeueRaw+0x50> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a9750: 9801         	ldr	r0, [sp, #0x4]
700a9752: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a9756: f64a 31cd    	movw	r1, #0xabcd
700a975a: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a975e: 4288         	cmp	r0, r1
700a9760: d004         	beq	0x700a976c <Udma_ringDequeueRaw+0x6c> @ imm = #0x8
700a9762: e7ff         	b	0x700a9764 <Udma_ringDequeueRaw+0x64> @ imm = #-0x2
700a9764: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a9768: 9003         	str	r0, [sp, #0xc]
;         }
700a976a: e7ff         	b	0x700a976c <Udma_ringDequeueRaw+0x6c> @ imm = #-0x2
;     }
700a976c: e7ff         	b	0x700a976e <Udma_ringDequeueRaw+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a976e: 9803         	ldr	r0, [sp, #0xc]
700a9770: b970         	cbnz	r0, 0x700a9790 <Udma_ringDequeueRaw+0x90> @ imm = #0x1c
700a9772: e7ff         	b	0x700a9774 <Udma_ringDequeueRaw+0x74> @ imm = #-0x2
;         cookie = HwiP_disable();
700a9774: f006 ef74    	blx	0x700b0660 <HwiP_disable> @ imm = #0x6ee8
700a9778: 9002         	str	r0, [sp, #0x8]
;         retVal = drvHandle->ringDequeueRaw(drvHandle, ringHandleInt, phyDescMem);
700a977a: 9801         	ldr	r0, [sp, #0x4]
700a977c: f8d0 3590    	ldr.w	r3, [r0, #0x590]
700a9780: 9900         	ldr	r1, [sp]
700a9782: 9a04         	ldr	r2, [sp, #0x10]
700a9784: 4798         	blx	r3
700a9786: 9003         	str	r0, [sp, #0xc]
;         HwiP_restore(cookie);
700a9788: 9802         	ldr	r0, [sp, #0x8]
700a978a: f006 ef8a    	blx	0x700b06a0 <HwiP_restore> @ imm = #0x6f14
;     }
700a978e: e7ff         	b	0x700a9790 <Udma_ringDequeueRaw+0x90> @ imm = #-0x2
;     return (retVal);
700a9790: 9803         	ldr	r0, [sp, #0xc]
700a9792: b006         	add	sp, #0x18
700a9794: bd80         	pop	{r7, pc}
		...
700a979e: 0000         	movs	r0, r0

700a97a0 <UART_lld_dmaDisableChannel>:
; {
700a97a0: b580         	push	{r7, lr}
700a97a2: b08a         	sub	sp, #0x28
700a97a4: 9009         	str	r0, [sp, #0x24]
700a97a6: 9108         	str	r1, [sp, #0x20]
700a97a8: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a97aa: 9007         	str	r0, [sp, #0x1c]
700a97ac: 2001         	movs	r0, #0x1
;     uint32_t temp = TRUE;
700a97ae: 9006         	str	r0, [sp, #0x18]
;     udmaChCfg   = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a97b0: 9809         	ldr	r0, [sp, #0x24]
700a97b2: 6840         	ldr	r0, [r0, #0x4]
700a97b4: 6cc0         	ldr	r0, [r0, #0x4c]
700a97b6: 9005         	str	r0, [sp, #0x14]
;     if (isChannelTx == TRUE)
700a97b8: 9808         	ldr	r0, [sp, #0x20]
700a97ba: 2801         	cmp	r0, #0x1
700a97bc: d104         	bne	0x700a97c8 <UART_lld_dmaDisableChannel+0x28> @ imm = #0x8
700a97be: e7ff         	b	0x700a97c0 <UART_lld_dmaDisableChannel+0x20> @ imm = #-0x2
;         chHandle = udmaChCfg->txChHandle;
700a97c0: 9805         	ldr	r0, [sp, #0x14]
700a97c2: 6840         	ldr	r0, [r0, #0x4]
700a97c4: 9004         	str	r0, [sp, #0x10]
;     }
700a97c6: e003         	b	0x700a97d0 <UART_lld_dmaDisableChannel+0x30> @ imm = #0x6
;         chHandle = udmaChCfg->rxChHandle;
700a97c8: 9805         	ldr	r0, [sp, #0x14]
700a97ca: 6880         	ldr	r0, [r0, #0x8]
700a97cc: 9004         	str	r0, [sp, #0x10]
700a97ce: e7ff         	b	0x700a97d0 <UART_lld_dmaDisableChannel+0x30> @ imm = #-0x2
;     status = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
700a97d0: 9804         	ldr	r0, [sp, #0x10]
700a97d2: 2164         	movs	r1, #0x64
700a97d4: f7fe fb94    	bl	0x700a7f00 <Udma_chDisable> @ imm = #-0x18d8
700a97d8: 9007         	str	r0, [sp, #0x1c]
;     DebugP_assert(UDMA_SOK == status);
700a97da: 9807         	ldr	r0, [sp, #0x1c]
700a97dc: fab0 f080    	clz	r0, r0
700a97e0: 0940         	lsrs	r0, r0, #0x5
700a97e2: f641 419f    	movw	r1, #0x1c9f
700a97e6: f2c7 010b    	movt	r1, #0x700b
700a97ea: 466a         	mov	r2, sp
700a97ec: 6011         	str	r1, [r2]
700a97ee: f641 016d    	movw	r1, #0x186d
700a97f2: f2c7 010b    	movt	r1, #0x700b
700a97f6: f641 324f    	movw	r2, #0x1b4f
700a97fa: f2c7 020b    	movt	r2, #0x700b
700a97fe: f240 137b    	movw	r3, #0x17b
700a9802: f001 f915    	bl	0x700aaa30 <_DebugP_assert> @ imm = #0x122a
;     while(temp == TRUE)
700a9806: e7ff         	b	0x700a9808 <UART_lld_dmaDisableChannel+0x68> @ imm = #-0x2
700a9808: 9806         	ldr	r0, [sp, #0x18]
700a980a: 2801         	cmp	r0, #0x1
700a980c: d10f         	bne	0x700a982e <UART_lld_dmaDisableChannel+0x8e> @ imm = #0x1e
700a980e: e7ff         	b	0x700a9810 <UART_lld_dmaDisableChannel+0x70> @ imm = #-0x2
;                          Udma_chGetFqRingHandle(chHandle), &pDesc);
700a9810: 9804         	ldr	r0, [sp, #0x10]
700a9812: f001 fb0d    	bl	0x700aae30 <Udma_chGetFqRingHandle> @ imm = #0x161a
700a9816: a902         	add	r1, sp, #0x8
;         tempRetVal = Udma_ringFlushRaw(
700a9818: f000 fb9a    	bl	0x700a9f50 <Udma_ringFlushRaw> @ imm = #0x734
700a981c: 9001         	str	r0, [sp, #0x4]
;         if(UDMA_ETIMEOUT == tempRetVal)
700a981e: 9801         	ldr	r0, [sp, #0x4]
700a9820: 3004         	adds	r0, #0x4
700a9822: b918         	cbnz	r0, 0x700a982c <UART_lld_dmaDisableChannel+0x8c> @ imm = #0x6
700a9824: e7ff         	b	0x700a9826 <UART_lld_dmaDisableChannel+0x86> @ imm = #-0x2
700a9826: 2000         	movs	r0, #0x0
;             temp = FALSE;
700a9828: 9006         	str	r0, [sp, #0x18]
;         }
700a982a: e7ff         	b	0x700a982c <UART_lld_dmaDisableChannel+0x8c> @ imm = #-0x2
;     while(temp == TRUE)
700a982c: e7ec         	b	0x700a9808 <UART_lld_dmaDisableChannel+0x68> @ imm = #-0x28
;     return status;
700a982e: 9807         	ldr	r0, [sp, #0x1c]
700a9830: b00a         	add	sp, #0x28
700a9832: bd80         	pop	{r7, pc}
		...

700a9840 <xQueueGiveFromISR>:
; {
700a9840: b580         	push	{r7, lr}
700a9842: b088         	sub	sp, #0x20
700a9844: 9007         	str	r0, [sp, #0x1c]
700a9846: 9106         	str	r1, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a9848: 9807         	ldr	r0, [sp, #0x1c]
700a984a: 9003         	str	r0, [sp, #0xc]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a984c: f006 ef08    	blx	0x700b0660 <HwiP_disable> @ imm = #0x6e10
700a9850: 9004         	str	r0, [sp, #0x10]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a9852: 9803         	ldr	r0, [sp, #0xc]
700a9854: 6b80         	ldr	r0, [r0, #0x38]
700a9856: 9002         	str	r0, [sp, #0x8]
;         if( uxMessagesWaiting < pxQueue->uxLength )
700a9858: 9802         	ldr	r0, [sp, #0x8]
700a985a: 9903         	ldr	r1, [sp, #0xc]
700a985c: 6bc9         	ldr	r1, [r1, #0x3c]
700a985e: 4288         	cmp	r0, r1
700a9860: d22f         	bhs	0x700a98c2 <xQueueGiveFromISR+0x82> @ imm = #0x5e
700a9862: e7ff         	b	0x700a9864 <xQueueGiveFromISR+0x24> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
700a9864: 9803         	ldr	r0, [sp, #0xc]
700a9866: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a986a: f88d 0007    	strb.w	r0, [sp, #0x7]
;             pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
700a986e: 9802         	ldr	r0, [sp, #0x8]
700a9870: 3001         	adds	r0, #0x1
700a9872: 9903         	ldr	r1, [sp, #0xc]
700a9874: 6388         	str	r0, [r1, #0x38]
;             if( cTxLock == queueUNLOCKED )
700a9876: f99d 0007    	ldrsb.w	r0, [sp, #0x7]
700a987a: 3001         	adds	r0, #0x1
700a987c: b9b8         	cbnz	r0, 0x700a98ae <xQueueGiveFromISR+0x6e> @ imm = #0x2e
700a987e: e7ff         	b	0x700a9880 <xQueueGiveFromISR+0x40> @ imm = #-0x2
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a9880: 9803         	ldr	r0, [sp, #0xc]
700a9882: 6a40         	ldr	r0, [r0, #0x24]
700a9884: b188         	cbz	r0, 0x700a98aa <xQueueGiveFromISR+0x6a> @ imm = #0x22
700a9886: e7ff         	b	0x700a9888 <xQueueGiveFromISR+0x48> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a9888: 9803         	ldr	r0, [sp, #0xc]
700a988a: 3024         	adds	r0, #0x24
700a988c: f7fd ffb0    	bl	0x700a77f0 <xTaskRemoveFromEventList> @ imm = #-0x20a0
700a9890: b148         	cbz	r0, 0x700a98a6 <xQueueGiveFromISR+0x66> @ imm = #0x12
700a9892: e7ff         	b	0x700a9894 <xQueueGiveFromISR+0x54> @ imm = #-0x2
;                                 if( pxHigherPriorityTaskWoken != NULL )
700a9894: 9806         	ldr	r0, [sp, #0x18]
700a9896: b120         	cbz	r0, 0x700a98a2 <xQueueGiveFromISR+0x62> @ imm = #0x8
700a9898: e7ff         	b	0x700a989a <xQueueGiveFromISR+0x5a> @ imm = #-0x2
;                                     *pxHigherPriorityTaskWoken = pdTRUE;
700a989a: 9906         	ldr	r1, [sp, #0x18]
700a989c: 2001         	movs	r0, #0x1
700a989e: 6008         	str	r0, [r1]
;                                 }
700a98a0: e000         	b	0x700a98a4 <xQueueGiveFromISR+0x64> @ imm = #0x0
700a98a2: e7ff         	b	0x700a98a4 <xQueueGiveFromISR+0x64> @ imm = #-0x2
;                             }
700a98a4: e000         	b	0x700a98a8 <xQueueGiveFromISR+0x68> @ imm = #0x0
700a98a6: e7ff         	b	0x700a98a8 <xQueueGiveFromISR+0x68> @ imm = #-0x2
;                         }
700a98a8: e000         	b	0x700a98ac <xQueueGiveFromISR+0x6c> @ imm = #0x0
700a98aa: e7ff         	b	0x700a98ac <xQueueGiveFromISR+0x6c> @ imm = #-0x2
;             }
700a98ac: e006         	b	0x700a98bc <xQueueGiveFromISR+0x7c> @ imm = #0xc
;                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
700a98ae: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700a98b2: 3001         	adds	r0, #0x1
700a98b4: 9903         	ldr	r1, [sp, #0xc]
700a98b6: f881 0045    	strb.w	r0, [r1, #0x45]
700a98ba: e7ff         	b	0x700a98bc <xQueueGiveFromISR+0x7c> @ imm = #-0x2
700a98bc: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a98be: 9005         	str	r0, [sp, #0x14]
;         }
700a98c0: e002         	b	0x700a98c8 <xQueueGiveFromISR+0x88> @ imm = #0x4
700a98c2: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
700a98c4: 9005         	str	r0, [sp, #0x14]
700a98c6: e7ff         	b	0x700a98c8 <xQueueGiveFromISR+0x88> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a98c8: 9804         	ldr	r0, [sp, #0x10]
700a98ca: f006 eeea    	blx	0x700b06a0 <HwiP_restore> @ imm = #0x6dd4
;     return xReturn;
700a98ce: 9805         	ldr	r0, [sp, #0x14]
700a98d0: b008         	add	sp, #0x20
700a98d2: bd80         	pop	{r7, pc}
		...

700a98e0 <xTimerGenericCommand>:
;     {
700a98e0: b580         	push	{r7, lr}
700a98e2: b08a         	sub	sp, #0x28
700a98e4: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a98e8: 9009         	str	r0, [sp, #0x24]
700a98ea: 9108         	str	r1, [sp, #0x20]
700a98ec: 9207         	str	r2, [sp, #0x1c]
700a98ee: 9306         	str	r3, [sp, #0x18]
700a98f0: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
700a98f2: 9005         	str	r0, [sp, #0x14]
;         if( xTimerQueue != NULL )
700a98f4: f242 7008    	movw	r0, #0x2708
700a98f8: f2c7 000b    	movt	r0, #0x700b
700a98fc: 6800         	ldr	r0, [r0]
700a98fe: b3a8         	cbz	r0, 0x700a996c <xTimerGenericCommand+0x8c> @ imm = #0x6a
700a9900: e7ff         	b	0x700a9902 <xTimerGenericCommand+0x22> @ imm = #-0x2
;             xMessage.xMessageID = xCommandID;
700a9902: 9808         	ldr	r0, [sp, #0x20]
700a9904: 9001         	str	r0, [sp, #0x4]
;             xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
700a9906: 9807         	ldr	r0, [sp, #0x1c]
700a9908: 9002         	str	r0, [sp, #0x8]
;             xMessage.u.xTimerParameters.pxTimer = xTimer;
700a990a: 9809         	ldr	r0, [sp, #0x24]
700a990c: 9003         	str	r0, [sp, #0xc]
;             if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
700a990e: 9808         	ldr	r0, [sp, #0x20]
700a9910: 2805         	cmp	r0, #0x5
700a9912: dc1e         	bgt	0x700a9952 <xTimerGenericCommand+0x72> @ imm = #0x3c
700a9914: e7ff         	b	0x700a9916 <xTimerGenericCommand+0x36> @ imm = #-0x2
;                 if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
700a9916: f004 fc03    	bl	0x700ae120 <xTaskGetSchedulerState> @ imm = #0x4806
700a991a: 2802         	cmp	r0, #0x2
700a991c: d10c         	bne	0x700a9938 <xTimerGenericCommand+0x58> @ imm = #0x18
700a991e: e7ff         	b	0x700a9920 <xTimerGenericCommand+0x40> @ imm = #-0x2
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
700a9920: f242 7008    	movw	r0, #0x2708
700a9924: f2c7 000b    	movt	r0, #0x700b
700a9928: 6800         	ldr	r0, [r0]
700a992a: 9a0c         	ldr	r2, [sp, #0x30]
700a992c: a901         	add	r1, sp, #0x4
700a992e: 2300         	movs	r3, #0x0
700a9930: f7f9 fbde    	bl	0x700a30f0 <xQueueGenericSend> @ imm = #-0x6844
700a9934: 9005         	str	r0, [sp, #0x14]
;                 }
700a9936: e00b         	b	0x700a9950 <xTimerGenericCommand+0x70> @ imm = #0x16
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
700a9938: f242 7008    	movw	r0, #0x2708
700a993c: f2c7 000b    	movt	r0, #0x700b
700a9940: 6800         	ldr	r0, [r0]
700a9942: a901         	add	r1, sp, #0x4
700a9944: 2300         	movs	r3, #0x0
700a9946: 461a         	mov	r2, r3
700a9948: f7f9 fbd2    	bl	0x700a30f0 <xQueueGenericSend> @ imm = #-0x685c
700a994c: 9005         	str	r0, [sp, #0x14]
700a994e: e7ff         	b	0x700a9950 <xTimerGenericCommand+0x70> @ imm = #-0x2
;             }
700a9950: e00b         	b	0x700a996a <xTimerGenericCommand+0x8a> @ imm = #0x16
;                 xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
700a9952: f242 7008    	movw	r0, #0x2708
700a9956: f2c7 000b    	movt	r0, #0x700b
700a995a: 6800         	ldr	r0, [r0]
700a995c: 9a06         	ldr	r2, [sp, #0x18]
700a995e: a901         	add	r1, sp, #0x4
700a9960: 2300         	movs	r3, #0x0
700a9962: f7fe ff3d    	bl	0x700a87e0 <xQueueGenericSendFromISR> @ imm = #-0x1186
700a9966: 9005         	str	r0, [sp, #0x14]
700a9968: e7ff         	b	0x700a996a <xTimerGenericCommand+0x8a> @ imm = #-0x2
;         }
700a996a: e000         	b	0x700a996e <xTimerGenericCommand+0x8e> @ imm = #0x0
700a996c: e7ff         	b	0x700a996e <xTimerGenericCommand+0x8e> @ imm = #-0x2
;         return xReturn;
700a996e: 9805         	ldr	r0, [sp, #0x14]
700a9970: b00a         	add	sp, #0x28
700a9972: bd80         	pop	{r7, pc}
		...

700a9980 <SOC_moduleClockEnable>:
; {
700a9980: b580         	push	{r7, lr}
700a9982: b088         	sub	sp, #0x20
700a9984: 9007         	str	r0, [sp, #0x1c]
700a9986: 9106         	str	r1, [sp, #0x18]
700a9988: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700a998a: 9005         	str	r0, [sp, #0x14]
700a998c: 2102         	movs	r1, #0x2
;     uint32_t moduleState = TISCI_MSG_VALUE_DEVICE_HW_STATE_TRANS;
700a998e: 9104         	str	r1, [sp, #0x10]
;     uint32_t resetState = 0U;
700a9990: 9003         	str	r0, [sp, #0xc]
;     uint32_t contextLossState = 0U;
700a9992: 9002         	str	r0, [sp, #0x8]
;     status = Sciclient_pmGetModuleState(moduleId,
700a9994: 9807         	ldr	r0, [sp, #0x1c]
700a9996: 466a         	mov	r2, sp
700a9998: f04f 31ff    	mov.w	r1, #0xffffffff
700a999c: 6011         	str	r1, [r2]
700a999e: a904         	add	r1, sp, #0x10
700a99a0: aa03         	add	r2, sp, #0xc
700a99a2: ab02         	add	r3, sp, #0x8
700a99a4: f000 f96c    	bl	0x700a9c80 <Sciclient_pmGetModuleState> @ imm = #0x2d8
700a99a8: 9005         	str	r0, [sp, #0x14]
;     if(status == SystemP_SUCCESS)
700a99aa: 9805         	ldr	r0, [sp, #0x14]
700a99ac: bb70         	cbnz	r0, 0x700a9a0c <SOC_moduleClockEnable+0x8c> @ imm = #0x5c
700a99ae: e7ff         	b	0x700a99b0 <SOC_moduleClockEnable+0x30> @ imm = #-0x2
;         if(moduleState == TISCI_MSG_VALUE_DEVICE_HW_STATE_OFF && (enable == 1))
700a99b0: 9804         	ldr	r0, [sp, #0x10]
700a99b2: b9c8         	cbnz	r0, 0x700a99e8 <SOC_moduleClockEnable+0x68> @ imm = #0x32
700a99b4: e7ff         	b	0x700a99b6 <SOC_moduleClockEnable+0x36> @ imm = #-0x2
700a99b6: 9806         	ldr	r0, [sp, #0x18]
700a99b8: 2801         	cmp	r0, #0x1
700a99ba: d115         	bne	0x700a99e8 <SOC_moduleClockEnable+0x68> @ imm = #0x2a
700a99bc: e7ff         	b	0x700a99be <SOC_moduleClockEnable+0x3e> @ imm = #-0x2
;             status = Sciclient_pmSetModuleState(moduleId,
700a99be: 9807         	ldr	r0, [sp, #0x1c]
700a99c0: 2102         	movs	r1, #0x2
700a99c2: f240 2202    	movw	r2, #0x202
700a99c6: f04f 33ff    	mov.w	r3, #0xffffffff
700a99ca: f000 f9e9    	bl	0x700a9da0 <Sciclient_pmSetModuleState> @ imm = #0x3d2
700a99ce: 9005         	str	r0, [sp, #0x14]
;             if (status == SystemP_SUCCESS)
700a99d0: 9805         	ldr	r0, [sp, #0x14]
700a99d2: b940         	cbnz	r0, 0x700a99e6 <SOC_moduleClockEnable+0x66> @ imm = #0x10
700a99d4: e7ff         	b	0x700a99d6 <SOC_moduleClockEnable+0x56> @ imm = #-0x2
;                 status = Sciclient_pmSetModuleRst(moduleId,
700a99d6: 9807         	ldr	r0, [sp, #0x1c]
700a99d8: 2100         	movs	r1, #0x0
700a99da: f04f 32ff    	mov.w	r2, #0xffffffff
700a99de: f002 fc57    	bl	0x700ac290 <Sciclient_pmSetModuleRst> @ imm = #0x28ae
700a99e2: 9005         	str	r0, [sp, #0x14]
;             }
700a99e4: e7ff         	b	0x700a99e6 <SOC_moduleClockEnable+0x66> @ imm = #-0x2
;         }
700a99e6: e010         	b	0x700a9a0a <SOC_moduleClockEnable+0x8a> @ imm = #0x20
;         if(moduleState == TISCI_MSG_VALUE_DEVICE_HW_STATE_ON && (enable == 0))
700a99e8: 9804         	ldr	r0, [sp, #0x10]
700a99ea: 2801         	cmp	r0, #0x1
700a99ec: d10c         	bne	0x700a9a08 <SOC_moduleClockEnable+0x88> @ imm = #0x18
700a99ee: e7ff         	b	0x700a99f0 <SOC_moduleClockEnable+0x70> @ imm = #-0x2
700a99f0: 9806         	ldr	r0, [sp, #0x18]
700a99f2: b948         	cbnz	r0, 0x700a9a08 <SOC_moduleClockEnable+0x88> @ imm = #0x12
700a99f4: e7ff         	b	0x700a99f6 <SOC_moduleClockEnable+0x76> @ imm = #-0x2
;             status = Sciclient_pmSetModuleState(moduleId,
700a99f6: 9807         	ldr	r0, [sp, #0x1c]
700a99f8: 2100         	movs	r1, #0x0
700a99fa: 2202         	movs	r2, #0x2
700a99fc: f04f 33ff    	mov.w	r3, #0xffffffff
700a9a00: f000 f9ce    	bl	0x700a9da0 <Sciclient_pmSetModuleState> @ imm = #0x39c
700a9a04: 9005         	str	r0, [sp, #0x14]
;         }
700a9a06: e7ff         	b	0x700a9a08 <SOC_moduleClockEnable+0x88> @ imm = #-0x2
700a9a08: e7ff         	b	0x700a9a0a <SOC_moduleClockEnable+0x8a> @ imm = #-0x2
;     }
700a9a0a: e7ff         	b	0x700a9a0c <SOC_moduleClockEnable+0x8c> @ imm = #-0x2
;     return status;
700a9a0c: 9805         	ldr	r0, [sp, #0x14]
700a9a0e: b008         	add	sp, #0x20
700a9a10: bd80         	pop	{r7, pc}
		...
700a9a1e: 0000         	movs	r0, r0

700a9a20 <Sciclient_rmPsPop>:
; {
700a9a20: b084         	sub	sp, #0x10
700a9a22: 9003         	str	r0, [sp, #0xc]
700a9a24: 9102         	str	r1, [sp, #0x8]
700a9a26: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a9a28: 9001         	str	r0, [sp, #0x4]
;     if ((gPstack.psp > (0u)) && (n != NULL) && (if_idx != NULL)) {
700a9a2a: f241 0058    	movw	r0, #0x1058
700a9a2e: f2c7 0008    	movt	r0, #0x7008
700a9a32: 8c80         	ldrh	r0, [r0, #0x24]
700a9a34: b3b0         	cbz	r0, 0x700a9aa4 <Sciclient_rmPsPop+0x84> @ imm = #0x6c
700a9a36: e7ff         	b	0x700a9a38 <Sciclient_rmPsPop+0x18> @ imm = #-0x2
700a9a38: 9803         	ldr	r0, [sp, #0xc]
700a9a3a: b398         	cbz	r0, 0x700a9aa4 <Sciclient_rmPsPop+0x84> @ imm = #0x66
700a9a3c: e7ff         	b	0x700a9a3e <Sciclient_rmPsPop+0x1e> @ imm = #-0x2
700a9a3e: 9802         	ldr	r0, [sp, #0x8]
700a9a40: b380         	cbz	r0, 0x700a9aa4 <Sciclient_rmPsPop+0x84> @ imm = #0x60
700a9a42: e7ff         	b	0x700a9a44 <Sciclient_rmPsPop+0x24> @ imm = #-0x2
;         gPstack.psp--;
700a9a44: f241 0158    	movw	r1, #0x1058
700a9a48: f2c7 0108    	movt	r1, #0x7008
700a9a4c: 9100         	str	r1, [sp]
700a9a4e: 8c88         	ldrh	r0, [r1, #0x24]
700a9a50: 3801         	subs	r0, #0x1
700a9a52: 8488         	strh	r0, [r1, #0x24]
;         *n = gPstack.ps[gPstack.psp].p_n;
700a9a54: 8c88         	ldrh	r0, [r1, #0x24]
700a9a56: eb00 0040    	add.w	r0, r0, r0, lsl #1
700a9a5a: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700a9a5e: 9a03         	ldr	r2, [sp, #0xc]
700a9a60: 6010         	str	r0, [r2]
;         *if_idx = gPstack.ps[gPstack.psp].if_idx;
700a9a62: 8c88         	ldrh	r0, [r1, #0x24]
700a9a64: eb00 0040    	add.w	r0, r0, r0, lsl #1
700a9a68: eb01 0080    	add.w	r0, r1, r0, lsl #2
700a9a6c: 8880         	ldrh	r0, [r0, #0x4]
700a9a6e: 9a02         	ldr	r2, [sp, #0x8]
700a9a70: 8010         	strh	r0, [r2]
;         gPstack.ps[gPstack.psp].p_n = NULL;
700a9a72: 8c88         	ldrh	r0, [r1, #0x24]
700a9a74: eb00 0240    	add.w	r2, r0, r0, lsl #1
700a9a78: 2000         	movs	r0, #0x0
700a9a7a: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gPstack.ps[gPstack.psp].if_idx = 0;
700a9a7e: 8c8a         	ldrh	r2, [r1, #0x24]
700a9a80: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a9a84: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a9a88: 8090         	strh	r0, [r2, #0x4]
;         gPstack.ps[gPstack.psp].inp = 0;
700a9a8a: 8c8a         	ldrh	r2, [r1, #0x24]
700a9a8c: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a9a90: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a9a94: 80d0         	strh	r0, [r2, #0x6]
;         gPstack.ps[gPstack.psp].outp = 0;
700a9a96: 8c8a         	ldrh	r2, [r1, #0x24]
700a9a98: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a9a9c: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a9aa0: 8108         	strh	r0, [r1, #0x8]
;     } else {
700a9aa2: e003         	b	0x700a9aac <Sciclient_rmPsPop+0x8c> @ imm = #0x6
700a9aa4: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a9aa8: 9001         	str	r0, [sp, #0x4]
700a9aaa: e7ff         	b	0x700a9aac <Sciclient_rmPsPop+0x8c> @ imm = #-0x2
;     return r;
700a9aac: 9801         	ldr	r0, [sp, #0x4]
700a9aae: b004         	add	sp, #0x10
700a9ab0: 4770         	bx	lr
		...
700a9abe: 0000         	movs	r0, r0

700a9ac0 <_DebugP_logZone>:
; {
700a9ac0: b082         	sub	sp, #0x8
700a9ac2: b580         	push	{r7, lr}
700a9ac4: b086         	sub	sp, #0x18
700a9ac6: 9309         	str	r3, [sp, #0x24]
700a9ac8: 9208         	str	r2, [sp, #0x20]
700a9aca: 9005         	str	r0, [sp, #0x14]
700a9acc: 9104         	str	r1, [sp, #0x10]
;     if((HwiP_inISR()) == 0U )
700a9ace: f006 fae7    	bl	0x700b00a0 <HwiP_inISR> @ imm = #0x65ce
700a9ad2: bbc8         	cbnz	r0, 0x700a9b48 <_DebugP_logZone+0x88> @ imm = #0x72
700a9ad4: e7ff         	b	0x700a9ad6 <_DebugP_logZone+0x16> @ imm = #-0x2
;         if(gDebugLogIsInitDone == 0U)
700a9ad6: f242 608c    	movw	r0, #0x268c
700a9ada: f2c7 000b    	movt	r0, #0x700b
700a9ade: 6800         	ldr	r0, [r0]
700a9ae0: b9a0         	cbnz	r0, 0x700a9b0c <_DebugP_logZone+0x4c> @ imm = #0x28
700a9ae2: e7ff         	b	0x700a9ae4 <_DebugP_logZone+0x24> @ imm = #-0x2
;             status = SemaphoreP_constructMutex(&gDebugLogLockObj);
700a9ae4: f644 6018    	movw	r0, #0x4e18
700a9ae8: f2c7 0008    	movt	r0, #0x7008
700a9aec: f001 fc78    	bl	0x700ab3e0 <SemaphoreP_constructMutex> @ imm = #0x18f0
700a9af0: 9003         	str	r0, [sp, #0xc]
;             DebugP_assertNoLog(status == SystemP_SUCCESS);
700a9af2: 9803         	ldr	r0, [sp, #0xc]
700a9af4: fab0 f080    	clz	r0, r0
700a9af8: 0940         	lsrs	r0, r0, #0x5
700a9afa: f007 fa71    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x74e2
;             gDebugLogIsInitDone = 1;
700a9afe: f242 618c    	movw	r1, #0x268c
700a9b02: f2c7 010b    	movt	r1, #0x700b
700a9b06: 2001         	movs	r0, #0x1
700a9b08: 6008         	str	r0, [r1]
;         }
700a9b0a: e7ff         	b	0x700a9b0c <_DebugP_logZone+0x4c> @ imm = #-0x2
;         if( ( gDebugLogZone & logZone ) == logZone )
700a9b0c: f242 6090    	movw	r0, #0x2690
700a9b10: f2c7 000b    	movt	r0, #0x700b
700a9b14: 6800         	ldr	r0, [r0]
700a9b16: 9905         	ldr	r1, [sp, #0x14]
700a9b18: 4008         	ands	r0, r1
700a9b1a: 4288         	cmp	r0, r1
700a9b1c: d113         	bne	0x700a9b46 <_DebugP_logZone+0x86> @ imm = #0x26
700a9b1e: e7ff         	b	0x700a9b20 <_DebugP_logZone+0x60> @ imm = #-0x2
;             SemaphoreP_pend(&gDebugLogLockObj, SystemP_WAIT_FOREVER);
700a9b20: f644 6018    	movw	r0, #0x4e18
700a9b24: f2c7 0008    	movt	r0, #0x7008
700a9b28: 9001         	str	r0, [sp, #0x4]
700a9b2a: f04f 31ff    	mov.w	r1, #0xffffffff
700a9b2e: f000 fd27    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0xa4e
700a9b32: a808         	add	r0, sp, #0x20
;             va_start(va, format);
700a9b34: 9002         	str	r0, [sp, #0x8]
;             vprintf_(format, va);
700a9b36: 9804         	ldr	r0, [sp, #0x10]
700a9b38: 9902         	ldr	r1, [sp, #0x8]
700a9b3a: f005 f8b1    	bl	0x700aeca0 <vprintf_>   @ imm = #0x5162
;             SemaphoreP_post(&gDebugLogLockObj);
700a9b3e: 9801         	ldr	r0, [sp, #0x4]
700a9b40: f002 f8ae    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x215c
;         }
700a9b44: e7ff         	b	0x700a9b46 <_DebugP_logZone+0x86> @ imm = #-0x2
;     }
700a9b46: e7ff         	b	0x700a9b48 <_DebugP_logZone+0x88> @ imm = #-0x2
; }
700a9b48: b006         	add	sp, #0x18
700a9b4a: e8bd 4080    	pop.w	{r7, lr}
700a9b4e: b002         	add	sp, #0x8
700a9b50: 4770         	bx	lr
		...
700a9b5e: 0000         	movs	r0, r0

700a9b60 <Udma_rmFreeMappedRing>:
; {
700a9b60: b580         	push	{r7, lr}
700a9b62: b08e         	sub	sp, #0x38
700a9b64: 900d         	str	r0, [sp, #0x34]
700a9b66: 910c         	str	r1, [sp, #0x30]
700a9b68: 920b         	str	r2, [sp, #0x2c]
700a9b6a: 930a         	str	r3, [sp, #0x28]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9b6c: 980c         	ldr	r0, [sp, #0x30]
700a9b6e: f500 70ea    	add.w	r0, r0, #0x1d4
700a9b72: 9005         	str	r0, [sp, #0x14]
;     retVal = Udma_getMappedChRingAttributes(drvHandle, mappedRingGrp, mappedChNum, &chAttr);
700a9b74: 980c         	ldr	r0, [sp, #0x30]
700a9b76: 990b         	ldr	r1, [sp, #0x2c]
700a9b78: 9a0a         	ldr	r2, [sp, #0x28]
700a9b7a: ab02         	add	r3, sp, #0x8
700a9b7c: f7fe f808    	bl	0x700a7b90 <Udma_getMappedChRingAttributes> @ imm = #-0x1ff0
700a9b80: 9001         	str	r0, [sp, #0x4]
;     if(ringNum != chAttr.defaultRing)
700a9b82: 980d         	ldr	r0, [sp, #0x34]
700a9b84: 9902         	ldr	r1, [sp, #0x8]
700a9b86: 4288         	cmp	r0, r1
700a9b88: d02f         	beq	0x700a9bea <Udma_rmFreeMappedRing+0x8a> @ imm = #0x5e
700a9b8a: e7ff         	b	0x700a9b8c <Udma_rmFreeMappedRing+0x2c> @ imm = #-0x2
;         SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9b8c: 980c         	ldr	r0, [sp, #0x30]
700a9b8e: f500 609f    	add.w	r0, r0, #0x4f8
700a9b92: f04f 31ff    	mov.w	r1, #0xffffffff
700a9b96: f000 fcf3    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x9e6
;         i = ringNum - rmInitPrms->startMappedRing[mappedRingGrp];
700a9b9a: 980d         	ldr	r0, [sp, #0x34]
700a9b9c: 9905         	ldr	r1, [sp, #0x14]
700a9b9e: 9a0b         	ldr	r2, [sp, #0x2c]
700a9ba0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a9ba4: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a9ba8: 1a40         	subs	r0, r0, r1
700a9baa: 9009         	str	r0, [sp, #0x24]
;         offset = i >> 5U;
700a9bac: 9809         	ldr	r0, [sp, #0x24]
700a9bae: 0940         	lsrs	r0, r0, #0x5
700a9bb0: 9008         	str	r0, [sp, #0x20]
;         bitPos = i - (offset << 5U);
700a9bb2: 9809         	ldr	r0, [sp, #0x24]
700a9bb4: 9908         	ldr	r1, [sp, #0x20]
700a9bb6: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9bba: 9007         	str	r0, [sp, #0x1c]
;         bitMask = (uint32_t) 1U << bitPos;
700a9bbc: 9907         	ldr	r1, [sp, #0x1c]
700a9bbe: 2001         	movs	r0, #0x1
700a9bc0: 4088         	lsls	r0, r1
700a9bc2: 9006         	str	r0, [sp, #0x18]
;         drvHandle->mappedRingFlag[mappedRingGrp][offset] |= bitMask;
700a9bc4: 9a06         	ldr	r2, [sp, #0x18]
700a9bc6: 980c         	ldr	r0, [sp, #0x30]
700a9bc8: 990b         	ldr	r1, [sp, #0x2c]
700a9bca: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a9bce: 9908         	ldr	r1, [sp, #0x20]
700a9bd0: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9bd4: f8d1 0344    	ldr.w	r0, [r1, #0x344]
700a9bd8: 4310         	orrs	r0, r2
700a9bda: f8c1 0344    	str.w	r0, [r1, #0x344]
;         SemaphoreP_post(&drvHandle->rmLockObj);
700a9bde: 980c         	ldr	r0, [sp, #0x30]
700a9be0: f500 609f    	add.w	r0, r0, #0x4f8
700a9be4: f002 f85c    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x20b8
;     }
700a9be8: e7ff         	b	0x700a9bea <Udma_rmFreeMappedRing+0x8a> @ imm = #-0x2
;     return;
700a9bea: b00e         	add	sp, #0x38
700a9bec: bd80         	pop	{r7, pc}
700a9bee: 0000         	movs	r0, r0

700a9bf0 <prvInitialiseTaskLists>:
; static void prvInitialiseTaskLists(void) {
700a9bf0: b580         	push	{r7, lr}
700a9bf2: b084         	sub	sp, #0x10
700a9bf4: 2000         	movs	r0, #0x0
;   for (uxPriority = (UBaseType_t)0U;
700a9bf6: 9003         	str	r0, [sp, #0xc]
700a9bf8: e7ff         	b	0x700a9bfa <prvInitialiseTaskLists+0xa> @ imm = #-0x2
;        uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
700a9bfa: 9803         	ldr	r0, [sp, #0xc]
;   for (uxPriority = (UBaseType_t)0U;
700a9bfc: 281f         	cmp	r0, #0x1f
700a9bfe: d810         	bhi	0x700a9c22 <prvInitialiseTaskLists+0x32> @ imm = #0x20
700a9c00: e7ff         	b	0x700a9c02 <prvInitialiseTaskLists+0x12> @ imm = #-0x2
;     vListInitialise(&(pxReadyTasksLists[uxPriority]));
700a9c02: 9803         	ldr	r0, [sp, #0xc]
700a9c04: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a9c08: f244 40f8    	movw	r0, #0x44f8
700a9c0c: f2c7 0008    	movt	r0, #0x7008
700a9c10: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a9c14: f004 fdec    	bl	0x700ae7f0 <vListInitialise> @ imm = #0x4bd8
;   }
700a9c18: e7ff         	b	0x700a9c1a <prvInitialiseTaskLists+0x2a> @ imm = #-0x2
;        uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
700a9c1a: 9803         	ldr	r0, [sp, #0xc]
700a9c1c: 3001         	adds	r0, #0x1
700a9c1e: 9003         	str	r0, [sp, #0xc]
;   for (uxPriority = (UBaseType_t)0U;
700a9c20: e7eb         	b	0x700a9bfa <prvInitialiseTaskLists+0xa> @ imm = #-0x2a
;   vListInitialise(&xDelayedTaskList1);
700a9c22: f245 10b8    	movw	r0, #0x51b8
700a9c26: f2c7 0008    	movt	r0, #0x7008
700a9c2a: 9001         	str	r0, [sp, #0x4]
700a9c2c: f004 fde0    	bl	0x700ae7f0 <vListInitialise> @ imm = #0x4bc0
;   vListInitialise(&xDelayedTaskList2);
700a9c30: f245 10cc    	movw	r0, #0x51cc
700a9c34: f2c7 0008    	movt	r0, #0x7008
700a9c38: 9002         	str	r0, [sp, #0x8]
700a9c3a: f004 fdd9    	bl	0x700ae7f0 <vListInitialise> @ imm = #0x4bb2
;   vListInitialise(&xPendingReadyList);
700a9c3e: f245 10e0    	movw	r0, #0x51e0
700a9c42: f2c7 0008    	movt	r0, #0x7008
700a9c46: f004 fdd3    	bl	0x700ae7f0 <vListInitialise> @ imm = #0x4ba6
;     vListInitialise(&xTasksWaitingTermination);
700a9c4a: f245 2008    	movw	r0, #0x5208
700a9c4e: f2c7 0008    	movt	r0, #0x7008
700a9c52: f004 fdcd    	bl	0x700ae7f0 <vListInitialise> @ imm = #0x4b9a
;     vListInitialise(&xSuspendedTaskList);
700a9c56: f245 10f4    	movw	r0, #0x51f4
700a9c5a: f2c7 0008    	movt	r0, #0x7008
700a9c5e: f004 fdc7    	bl	0x700ae7f0 <vListInitialise> @ imm = #0x4b8e
700a9c62: 9901         	ldr	r1, [sp, #0x4]
700a9c64: 9802         	ldr	r0, [sp, #0x8]
;   pxDelayedTaskList = &xDelayedTaskList1;
700a9c66: f245 2220    	movw	r2, #0x5220
700a9c6a: f2c7 0208    	movt	r2, #0x7008
700a9c6e: 6011         	str	r1, [r2]
;   pxOverflowDelayedTaskList = &xDelayedTaskList2;
700a9c70: f245 2124    	movw	r1, #0x5224
700a9c74: f2c7 0108    	movt	r1, #0x7008
700a9c78: 6008         	str	r0, [r1]
; }
700a9c7a: b004         	add	sp, #0x10
700a9c7c: bd80         	pop	{r7, pc}
700a9c7e: 0000         	movs	r0, r0

700a9c80 <Sciclient_pmGetModuleState>:
; {
700a9c80: b580         	push	{r7, lr}
700a9c82: b096         	sub	sp, #0x58
700a9c84: f8dd c060    	ldr.w	r12, [sp, #0x60]
700a9c88: 9015         	str	r0, [sp, #0x54]
700a9c8a: 9114         	str	r1, [sp, #0x50]
700a9c8c: 9213         	str	r2, [sp, #0x4c]
700a9c8e: 9312         	str	r3, [sp, #0x48]
700a9c90: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a9c92: 9011         	str	r0, [sp, #0x44]
;     struct tisci_msg_get_device_resp response = {{0}};
700a9c94: f8ad 0034    	strh.w	r0, [sp, #0x34]
700a9c98: 900c         	str	r0, [sp, #0x30]
700a9c9a: 900b         	str	r0, [sp, #0x2c]
700a9c9c: 900a         	str	r0, [sp, #0x28]
700a9c9e: 9009         	str	r0, [sp, #0x24]
;     request.id = (uint32_t) moduleId;
700a9ca0: 9915         	ldr	r1, [sp, #0x54]
700a9ca2: 9110         	str	r1, [sp, #0x40]
700a9ca4: f240 2101    	movw	r1, #0x201
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_DEVICE;
700a9ca8: f8ad 1010    	strh.w	r1, [sp, #0x10]
700a9cac: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a9cae: 9105         	str	r1, [sp, #0x14]
700a9cb0: a90e         	add	r1, sp, #0x38
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a9cb2: 9106         	str	r1, [sp, #0x18]
700a9cb4: 210c         	movs	r1, #0xc
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a9cb6: 9107         	str	r1, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a9cb8: 9918         	ldr	r1, [sp, #0x60]
700a9cba: 9108         	str	r1, [sp, #0x20]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9cbc: 9001         	str	r0, [sp, #0x4]
700a9cbe: a809         	add	r0, sp, #0x24
;     respParam.pRespPayload    = (uint8_t *) &response;
700a9cc0: 9002         	str	r0, [sp, #0x8]
700a9cc2: 2012         	movs	r0, #0x12
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a9cc4: 9003         	str	r0, [sp, #0xc]
700a9cc6: a804         	add	r0, sp, #0x10
700a9cc8: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9cca: f7f3 fad9    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xca4e
700a9cce: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a9cd0: 9811         	ldr	r0, [sp, #0x44]
700a9cd2: b930         	cbnz	r0, 0x700a9ce2 <Sciclient_pmGetModuleState+0x62> @ imm = #0xc
700a9cd4: e7ff         	b	0x700a9cd6 <Sciclient_pmGetModuleState+0x56> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a9cd6: 9801         	ldr	r0, [sp, #0x4]
700a9cd8: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9cdc: 2802         	cmp	r0, #0x2
700a9cde: d004         	beq	0x700a9cea <Sciclient_pmGetModuleState+0x6a> @ imm = #0x8
700a9ce0: e7ff         	b	0x700a9ce2 <Sciclient_pmGetModuleState+0x62> @ imm = #-0x2
700a9ce2: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9ce6: 9011         	str	r0, [sp, #0x44]
;     }
700a9ce8: e7ff         	b	0x700a9cea <Sciclient_pmGetModuleState+0x6a> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a9cea: 9811         	ldr	r0, [sp, #0x44]
700a9cec: b958         	cbnz	r0, 0x700a9d06 <Sciclient_pmGetModuleState+0x86> @ imm = #0x16
700a9cee: e7ff         	b	0x700a9cf0 <Sciclient_pmGetModuleState+0x70> @ imm = #-0x2
;         *moduleState = (uint32_t) response.current_state;
700a9cf0: f89d 0035    	ldrb.w	r0, [sp, #0x35]
700a9cf4: 9914         	ldr	r1, [sp, #0x50]
700a9cf6: 6008         	str	r0, [r1]
;         *resetState = (uint32_t) response.resets;
700a9cf8: 980c         	ldr	r0, [sp, #0x30]
700a9cfa: 9913         	ldr	r1, [sp, #0x4c]
700a9cfc: 6008         	str	r0, [r1]
;         *contextLossState = (uint32_t) response.context_loss_count;
700a9cfe: 980b         	ldr	r0, [sp, #0x2c]
700a9d00: 9912         	ldr	r1, [sp, #0x48]
700a9d02: 6008         	str	r0, [r1]
;     }
700a9d04: e7ff         	b	0x700a9d06 <Sciclient_pmGetModuleState+0x86> @ imm = #-0x2
;     return retVal;
700a9d06: 9811         	ldr	r0, [sp, #0x44]
700a9d08: b016         	add	sp, #0x58
700a9d0a: bd80         	pop	{r7, pc}
700a9d0c: 0000         	movs	r0, r0
700a9d0e: 0000         	movs	r0, r0

700a9d10 <Sciclient_pmModuleClkRequest>:
; {
700a9d10: b580         	push	{r7, lr}
700a9d12: b092         	sub	sp, #0x48
700a9d14: f8dd c050    	ldr.w	r12, [sp, #0x50]
700a9d18: 9011         	str	r0, [sp, #0x44]
700a9d1a: 9110         	str	r1, [sp, #0x40]
700a9d1c: 920f         	str	r2, [sp, #0x3c]
700a9d1e: 930e         	str	r3, [sp, #0x38]
700a9d20: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a9d22: 900d         	str	r0, [sp, #0x34]
;     request.device = (uint32_t) moduleId;
700a9d24: 9811         	ldr	r0, [sp, #0x44]
700a9d26: 900a         	str	r0, [sp, #0x28]
;     if(clockId > (uint32_t)(255U))
700a9d28: 9810         	ldr	r0, [sp, #0x40]
700a9d2a: f5b0 7f80    	cmp.w	r0, #0x100
700a9d2e: d307         	blo	0x700a9d40 <Sciclient_pmModuleClkRequest+0x30> @ imm = #0xe
700a9d30: e7ff         	b	0x700a9d32 <Sciclient_pmModuleClkRequest+0x22> @ imm = #-0x2
700a9d32: 20ff         	movs	r0, #0xff
;         request.clk = (uint8_t)(255U);
700a9d34: f88d 002c    	strb.w	r0, [sp, #0x2c]
;         request.clk32 = clockId;
700a9d38: 9810         	ldr	r0, [sp, #0x40]
700a9d3a: f8cd 002e    	str.w	r0, [sp, #0x2e]
;     }
700a9d3e: e003         	b	0x700a9d48 <Sciclient_pmModuleClkRequest+0x38> @ imm = #0x6
;         request.clk    = (uint8_t)clockId;
700a9d40: 9810         	ldr	r0, [sp, #0x40]
700a9d42: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a9d46: e7ff         	b	0x700a9d48 <Sciclient_pmModuleClkRequest+0x38> @ imm = #-0x2
;     request.state  = (uint8_t) state;
700a9d48: 980f         	ldr	r0, [sp, #0x3c]
700a9d4a: f88d 002d    	strb.w	r0, [sp, #0x2d]
700a9d4e: f44f 7080    	mov.w	r0, #0x100
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_CLOCK;
700a9d52: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP | additionalFlag;
700a9d56: 980e         	ldr	r0, [sp, #0x38]
700a9d58: f040 0002    	orr	r0, r0, #0x2
700a9d5c: 9004         	str	r0, [sp, #0x10]
700a9d5e: a808         	add	r0, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a9d60: 9005         	str	r0, [sp, #0x14]
700a9d62: 2012         	movs	r0, #0x12
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a9d64: 9006         	str	r0, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a9d66: 9814         	ldr	r0, [sp, #0x50]
700a9d68: 9007         	str	r0, [sp, #0x1c]
700a9d6a: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9d6c: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a9d6e: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700a9d70: 9002         	str	r0, [sp, #0x8]
700a9d72: a803         	add	r0, sp, #0xc
700a9d74: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9d76: f7f3 fa83    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xcafa
700a9d7a: 900d         	str	r0, [sp, #0x34]
;     if((retVal != SystemP_SUCCESS) ||
700a9d7c: 980d         	ldr	r0, [sp, #0x34]
700a9d7e: b930         	cbnz	r0, 0x700a9d8e <Sciclient_pmModuleClkRequest+0x7e> @ imm = #0xc
700a9d80: e7ff         	b	0x700a9d82 <Sciclient_pmModuleClkRequest+0x72> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a9d82: 9800         	ldr	r0, [sp]
700a9d84: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9d88: 2802         	cmp	r0, #0x2
700a9d8a: d004         	beq	0x700a9d96 <Sciclient_pmModuleClkRequest+0x86> @ imm = #0x8
700a9d8c: e7ff         	b	0x700a9d8e <Sciclient_pmModuleClkRequest+0x7e> @ imm = #-0x2
700a9d8e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9d92: 900d         	str	r0, [sp, #0x34]
;     }
700a9d94: e7ff         	b	0x700a9d96 <Sciclient_pmModuleClkRequest+0x86> @ imm = #-0x2
;     return retVal;
700a9d96: 980d         	ldr	r0, [sp, #0x34]
700a9d98: b012         	add	sp, #0x48
700a9d9a: bd80         	pop	{r7, pc}
700a9d9c: 0000         	movs	r0, r0
700a9d9e: 0000         	movs	r0, r0

700a9da0 <Sciclient_pmSetModuleState>:
; {
700a9da0: b580         	push	{r7, lr}
700a9da2: b092         	sub	sp, #0x48
700a9da4: 9011         	str	r0, [sp, #0x44]
700a9da6: 9110         	str	r1, [sp, #0x40]
700a9da8: 920f         	str	r2, [sp, #0x3c]
700a9daa: 930e         	str	r3, [sp, #0x38]
700a9dac: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a9dae: 900d         	str	r0, [sp, #0x34]
;     request.id       = (uint32_t) moduleId;
700a9db0: 9911         	ldr	r1, [sp, #0x44]
700a9db2: 910a         	str	r1, [sp, #0x28]
;     request.reserved = (uint32_t) 0;
700a9db4: 900b         	str	r0, [sp, #0x2c]
;     request.state    = (uint8_t) state;
700a9db6: 9910         	ldr	r1, [sp, #0x40]
700a9db8: f88d 1030    	strb.w	r1, [sp, #0x30]
700a9dbc: f44f 7100    	mov.w	r1, #0x200
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_DEVICE;
700a9dc0: f8ad 100c    	strh.w	r1, [sp, #0xc]
;     reqParam.flags          = (uint32_t) reqFlag;
700a9dc4: 990f         	ldr	r1, [sp, #0x3c]
700a9dc6: 9104         	str	r1, [sp, #0x10]
700a9dc8: a908         	add	r1, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a9dca: 9105         	str	r1, [sp, #0x14]
700a9dcc: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a9dce: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a9dd0: 990e         	ldr	r1, [sp, #0x38]
700a9dd2: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9dd4: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a9dd6: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700a9dd8: 9002         	str	r0, [sp, #0x8]
;     if (((reqFlag & TISCI_MSG_FLAG_AOP) != TISCI_MSG_FLAG_AOP)&&
700a9dda: 980f         	ldr	r0, [sp, #0x3c]
700a9ddc: f000 0002    	and	r0, r0, #0x2
700a9de0: 2802         	cmp	r0, #0x2
700a9de2: d007         	beq	0x700a9df4 <Sciclient_pmSetModuleState+0x54> @ imm = #0xe
700a9de4: e7ff         	b	0x700a9de6 <Sciclient_pmSetModuleState+0x46> @ imm = #-0x2
;         (reqFlag != 0U))
700a9de6: 980f         	ldr	r0, [sp, #0x3c]
;     if (((reqFlag & TISCI_MSG_FLAG_AOP) != TISCI_MSG_FLAG_AOP)&&
700a9de8: b120         	cbz	r0, 0x700a9df4 <Sciclient_pmSetModuleState+0x54> @ imm = #0x8
700a9dea: e7ff         	b	0x700a9dec <Sciclient_pmSetModuleState+0x4c> @ imm = #-0x2
700a9dec: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9df0: 900d         	str	r0, [sp, #0x34]
;     }
700a9df2: e7ff         	b	0x700a9df4 <Sciclient_pmSetModuleState+0x54> @ imm = #-0x2
;     if(retVal == SystemP_SUCCESS)
700a9df4: 980d         	ldr	r0, [sp, #0x34]
700a9df6: b930         	cbnz	r0, 0x700a9e06 <Sciclient_pmSetModuleState+0x66> @ imm = #0xc
700a9df8: e7ff         	b	0x700a9dfa <Sciclient_pmSetModuleState+0x5a> @ imm = #-0x2
700a9dfa: a803         	add	r0, sp, #0xc
700a9dfc: 4669         	mov	r1, sp
;         retVal = Sciclient_service(&reqParam, &respParam);
700a9dfe: f7f3 fa3f    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xcb82
700a9e02: 900d         	str	r0, [sp, #0x34]
;     }
700a9e04: e7ff         	b	0x700a9e06 <Sciclient_pmSetModuleState+0x66> @ imm = #-0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9e06: 980d         	ldr	r0, [sp, #0x34]
700a9e08: b948         	cbnz	r0, 0x700a9e1e <Sciclient_pmSetModuleState+0x7e> @ imm = #0x12
700a9e0a: e7ff         	b	0x700a9e0c <Sciclient_pmSetModuleState+0x6c> @ imm = #-0x2
;         ((reqFlag != 0U) &&
700a9e0c: 980f         	ldr	r0, [sp, #0x3c]
700a9e0e: b150         	cbz	r0, 0x700a9e26 <Sciclient_pmSetModuleState+0x86> @ imm = #0x14
700a9e10: e7ff         	b	0x700a9e12 <Sciclient_pmSetModuleState+0x72> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)))
700a9e12: 9800         	ldr	r0, [sp]
700a9e14: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9e18: 2802         	cmp	r0, #0x2
700a9e1a: d004         	beq	0x700a9e26 <Sciclient_pmSetModuleState+0x86> @ imm = #0x8
700a9e1c: e7ff         	b	0x700a9e1e <Sciclient_pmSetModuleState+0x7e> @ imm = #-0x2
700a9e1e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9e22: 900d         	str	r0, [sp, #0x34]
;     }
700a9e24: e7ff         	b	0x700a9e26 <Sciclient_pmSetModuleState+0x86> @ imm = #-0x2
;     return retVal;
700a9e26: 980d         	ldr	r0, [sp, #0x34]
700a9e28: b012         	add	sp, #0x48
700a9e2a: bd80         	pop	{r7, pc}
700a9e2c: 0000         	movs	r0, r0
700a9e2e: 0000         	movs	r0, r0

700a9e30 <Sciclient_rmIaEvtRomMapped>:
; {
700a9e30: b082         	sub	sp, #0x8
700a9e32: 9001         	str	r0, [sp, #0x4]
700a9e34: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a9e38: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a9e3a: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a9e3e: 9801         	ldr	r0, [sp, #0x4]
700a9e40: 6980         	ldr	r0, [r0, #0x18]
700a9e42: b3a8         	cbz	r0, 0x700a9eb0 <Sciclient_rmIaEvtRomMapped+0x80> @ imm = #0x6a
700a9e44: e7ff         	b	0x700a9e46 <Sciclient_rmIaEvtRomMapped+0x16> @ imm = #-0x2
700a9e46: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a9e48: f88d 0000    	strb.w	r0, [sp]
700a9e4c: e7ff         	b	0x700a9e4e <Sciclient_rmIaEvtRomMapped+0x1e> @ imm = #-0x2
700a9e4e: f89d 0000    	ldrb.w	r0, [sp]
700a9e52: 9901         	ldr	r1, [sp, #0x4]
700a9e54: 7f09         	ldrb	r1, [r1, #0x1c]
700a9e56: 4288         	cmp	r0, r1
700a9e58: da29         	bge	0x700a9eae <Sciclient_rmIaEvtRomMapped+0x7e> @ imm = #0x52
700a9e5a: e7ff         	b	0x700a9e5c <Sciclient_rmIaEvtRomMapped+0x2c> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a9e5c: 9801         	ldr	r0, [sp, #0x4]
700a9e5e: 6980         	ldr	r0, [r0, #0x18]
700a9e60: f89d 1000    	ldrb.w	r1, [sp]
700a9e64: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a9e68: 7880         	ldrb	r0, [r0, #0x2]
700a9e6a: 07c0         	lsls	r0, r0, #0x1f
700a9e6c: b9c0         	cbnz	r0, 0x700a9ea0 <Sciclient_rmIaEvtRomMapped+0x70> @ imm = #0x30
700a9e6e: e7ff         	b	0x700a9e70 <Sciclient_rmIaEvtRomMapped+0x40> @ imm = #-0x2
;                 (evt == (inst->rom_usage[i].event - inst->sevt_offset))) {
700a9e70: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a9e74: 9a01         	ldr	r2, [sp, #0x4]
700a9e76: 6991         	ldr	r1, [r2, #0x18]
700a9e78: f89d 3000    	ldrb.w	r3, [sp]
700a9e7c: f831 1023    	ldrh.w	r1, [r1, r3, lsl #2]
700a9e80: 8912         	ldrh	r2, [r2, #0x8]
700a9e82: 1a89         	subs	r1, r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a9e84: 4288         	cmp	r0, r1
700a9e86: d10b         	bne	0x700a9ea0 <Sciclient_rmIaEvtRomMapped+0x70> @ imm = #0x16
700a9e88: e7ff         	b	0x700a9e8a <Sciclient_rmIaEvtRomMapped+0x5a> @ imm = #-0x2
700a9e8a: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a9e8c: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a9e90: 9901         	ldr	r1, [sp, #0x4]
700a9e92: 6989         	ldr	r1, [r1, #0x18]
700a9e94: f89d 2000    	ldrb.w	r2, [sp]
700a9e98: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a9e9c: 7088         	strb	r0, [r1, #0x2]
;                 break;
700a9e9e: e006         	b	0x700a9eae <Sciclient_rmIaEvtRomMapped+0x7e> @ imm = #0xc
;         }
700a9ea0: e7ff         	b	0x700a9ea2 <Sciclient_rmIaEvtRomMapped+0x72> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a9ea2: f89d 0000    	ldrb.w	r0, [sp]
700a9ea6: 3001         	adds	r0, #0x1
700a9ea8: f88d 0000    	strb.w	r0, [sp]
700a9eac: e7cf         	b	0x700a9e4e <Sciclient_rmIaEvtRomMapped+0x1e> @ imm = #-0x62
;     }
700a9eae: e7ff         	b	0x700a9eb0 <Sciclient_rmIaEvtRomMapped+0x80> @ imm = #-0x2
;     return rom_mapped;
700a9eb0: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a9eb4: f000 0001    	and	r0, r0, #0x1
700a9eb8: b002         	add	sp, #0x8
700a9eba: 4770         	bx	lr
700a9ebc: 0000         	movs	r0, r0
700a9ebe: 0000         	movs	r0, r0

700a9ec0 <UART_writeCancelNoCB>:
; {
700a9ec0: b580         	push	{r7, lr}
700a9ec2: b084         	sub	sp, #0x10
700a9ec4: 9003         	str	r0, [sp, #0xc]
700a9ec6: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a9ec8: 9001         	str	r0, [sp, #0x4]
;     hUartInit = hUart->hUartInit;
700a9eca: 9803         	ldr	r0, [sp, #0xc]
700a9ecc: 6840         	ldr	r0, [r0, #0x4]
700a9ece: 9000         	str	r0, [sp]
;     UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
700a9ed0: 9803         	ldr	r0, [sp, #0xc]
700a9ed2: 6800         	ldr	r0, [r0]
700a9ed4: 2102         	movs	r1, #0x2
700a9ed6: f7fc f8b3    	bl	0x700a6040 <UART_intrDisable> @ imm = #-0x3e9a
;     key = HwiP_disable();
700a9eda: f006 ebc2    	blx	0x700b0660 <HwiP_disable> @ imm = #0x6784
700a9ede: 9002         	str	r0, [sp, #0x8]
;     if ((hUart->writeSizeRemaining) == 0U)
700a9ee0: 9803         	ldr	r0, [sp, #0xc]
700a9ee2: 6900         	ldr	r0, [r0, #0x10]
700a9ee4: b920         	cbnz	r0, 0x700a9ef0 <UART_writeCancelNoCB+0x30> @ imm = #0x8
700a9ee6: e7ff         	b	0x700a9ee8 <UART_writeCancelNoCB+0x28> @ imm = #-0x2
700a9ee8: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700a9eec: 9001         	str	r0, [sp, #0x4]
;     }
700a9eee: e027         	b	0x700a9f40 <UART_writeCancelNoCB+0x80> @ imm = #0x4e
;         if (hUartInit->transferMode == UART_CONFIG_MODE_DMA)
700a9ef0: 9800         	ldr	r0, [sp]
700a9ef2: 6a00         	ldr	r0, [r0, #0x20]
700a9ef4: 2803         	cmp	r0, #0x3
700a9ef6: d111         	bne	0x700a9f1c <UART_writeCancelNoCB+0x5c> @ imm = #0x22
700a9ef8: e7ff         	b	0x700a9efa <UART_writeCancelNoCB+0x3a> @ imm = #-0x2
;             UART_lld_dmaDisableChannel(hUart, (Bool)TRUE);
700a9efa: 9803         	ldr	r0, [sp, #0xc]
700a9efc: 2101         	movs	r1, #0x1
700a9efe: f7ff fc4f    	bl	0x700a97a0 <UART_lld_dmaDisableChannel> @ imm = #-0x762
;             if (hUart->writeTrans.buf != NULL)
700a9f02: 9803         	ldr	r0, [sp, #0xc]
700a9f04: 6bc0         	ldr	r0, [r0, #0x3c]
700a9f06: b120         	cbz	r0, 0x700a9f12 <UART_writeCancelNoCB+0x52> @ imm = #0x8
700a9f08: e7ff         	b	0x700a9f0a <UART_writeCancelNoCB+0x4a> @ imm = #-0x2
;                 hUart->writeTrans.count = 0;
700a9f0a: 9903         	ldr	r1, [sp, #0xc]
700a9f0c: 2000         	movs	r0, #0x0
700a9f0e: 6408         	str	r0, [r1, #0x40]
;             }
700a9f10: e003         	b	0x700a9f1a <UART_writeCancelNoCB+0x5a> @ imm = #0x6
;                 hUart->writeCount = 0;
700a9f12: 9903         	ldr	r1, [sp, #0xc]
700a9f14: 2000         	movs	r0, #0x0
700a9f16: 60c8         	str	r0, [r1, #0xc]
700a9f18: e7ff         	b	0x700a9f1a <UART_writeCancelNoCB+0x5a> @ imm = #-0x2
;         }
700a9f1a: e010         	b	0x700a9f3e <UART_writeCancelNoCB+0x7e> @ imm = #0x20
;             hUart->writeBuf = (const uint8_t *)hUart->writeBuf - hUart->writeCount;
700a9f1c: 9903         	ldr	r1, [sp, #0xc]
700a9f1e: 6888         	ldr	r0, [r1, #0x8]
700a9f20: 68ca         	ldr	r2, [r1, #0xc]
700a9f22: 1a80         	subs	r0, r0, r2
700a9f24: 6088         	str	r0, [r1, #0x8]
;             if (hUart->writeTrans.buf != NULL)
700a9f26: 9803         	ldr	r0, [sp, #0xc]
700a9f28: 6bc0         	ldr	r0, [r0, #0x3c]
700a9f2a: b120         	cbz	r0, 0x700a9f36 <UART_writeCancelNoCB+0x76> @ imm = #0x8
700a9f2c: e7ff         	b	0x700a9f2e <UART_writeCancelNoCB+0x6e> @ imm = #-0x2
;                 hUart->writeTrans.count = (uint32_t)(hUart->writeCount);
700a9f2e: 9903         	ldr	r1, [sp, #0xc]
700a9f30: 68c8         	ldr	r0, [r1, #0xc]
700a9f32: 6408         	str	r0, [r1, #0x40]
;             }
700a9f34: e7ff         	b	0x700a9f36 <UART_writeCancelNoCB+0x76> @ imm = #-0x2
;             hUart->writeSizeRemaining = 0;
700a9f36: 9903         	ldr	r1, [sp, #0xc]
700a9f38: 2000         	movs	r0, #0x0
700a9f3a: 6108         	str	r0, [r1, #0x10]
700a9f3c: e7ff         	b	0x700a9f3e <UART_writeCancelNoCB+0x7e> @ imm = #-0x2
700a9f3e: e7ff         	b	0x700a9f40 <UART_writeCancelNoCB+0x80> @ imm = #-0x2
;     HwiP_restore(key);
700a9f40: 9802         	ldr	r0, [sp, #0x8]
700a9f42: f006 ebae    	blx	0x700b06a0 <HwiP_restore> @ imm = #0x675c
;     return (status);
700a9f46: 9801         	ldr	r0, [sp, #0x4]
700a9f48: b004         	add	sp, #0x10
700a9f4a: bd80         	pop	{r7, pc}
700a9f4c: 0000         	movs	r0, r0
700a9f4e: 0000         	movs	r0, r0

700a9f50 <Udma_ringFlushRaw>:
; {
700a9f50: b580         	push	{r7, lr}
700a9f52: b086         	sub	sp, #0x18
700a9f54: 9005         	str	r0, [sp, #0x14]
700a9f56: 9104         	str	r1, [sp, #0x10]
700a9f58: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a9f5a: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a9f5c: 9805         	ldr	r0, [sp, #0x14]
700a9f5e: 9001         	str	r0, [sp, #0x4]
;     if((NULL_PTR == ringHandleInt) ||
700a9f60: 9801         	ldr	r0, [sp, #0x4]
700a9f62: b180         	cbz	r0, 0x700a9f86 <Udma_ringFlushRaw+0x36> @ imm = #0x20
700a9f64: e7ff         	b	0x700a9f66 <Udma_ringFlushRaw+0x16> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a9f66: 9801         	ldr	r0, [sp, #0x4]
700a9f68: 6d80         	ldr	r0, [r0, #0x58]
700a9f6a: f64a 31cd    	movw	r1, #0xabcd
700a9f6e: f6ca 31dc    	movt	r1, #0xabdc
700a9f72: 4288         	cmp	r0, r1
700a9f74: d107         	bne	0x700a9f86 <Udma_ringFlushRaw+0x36> @ imm = #0xe
700a9f76: e7ff         	b	0x700a9f78 <Udma_ringFlushRaw+0x28> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a9f78: 9801         	ldr	r0, [sp, #0x4]
700a9f7a: 8880         	ldrh	r0, [r0, #0x4]
700a9f7c: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a9f80: 4288         	cmp	r0, r1
700a9f82: d104         	bne	0x700a9f8e <Udma_ringFlushRaw+0x3e> @ imm = #0x8
700a9f84: e7ff         	b	0x700a9f86 <Udma_ringFlushRaw+0x36> @ imm = #-0x2
700a9f86: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a9f8a: 9003         	str	r0, [sp, #0xc]
;     }
700a9f8c: e7ff         	b	0x700a9f8e <Udma_ringFlushRaw+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9f8e: 9803         	ldr	r0, [sp, #0xc]
700a9f90: b9a8         	cbnz	r0, 0x700a9fbe <Udma_ringFlushRaw+0x6e> @ imm = #0x2a
700a9f92: e7ff         	b	0x700a9f94 <Udma_ringFlushRaw+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a9f94: 9801         	ldr	r0, [sp, #0x4]
700a9f96: 6800         	ldr	r0, [r0]
700a9f98: 9002         	str	r0, [sp, #0x8]
;         if((NULL_PTR == drvHandle) ||
700a9f9a: 9802         	ldr	r0, [sp, #0x8]
700a9f9c: b150         	cbz	r0, 0x700a9fb4 <Udma_ringFlushRaw+0x64> @ imm = #0x14
700a9f9e: e7ff         	b	0x700a9fa0 <Udma_ringFlushRaw+0x50> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a9fa0: 9802         	ldr	r0, [sp, #0x8]
700a9fa2: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a9fa6: f64a 31cd    	movw	r1, #0xabcd
700a9faa: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a9fae: 4288         	cmp	r0, r1
700a9fb0: d004         	beq	0x700a9fbc <Udma_ringFlushRaw+0x6c> @ imm = #0x8
700a9fb2: e7ff         	b	0x700a9fb4 <Udma_ringFlushRaw+0x64> @ imm = #-0x2
700a9fb4: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a9fb8: 9003         	str	r0, [sp, #0xc]
;         }
700a9fba: e7ff         	b	0x700a9fbc <Udma_ringFlushRaw+0x6c> @ imm = #-0x2
;     }
700a9fbc: e7ff         	b	0x700a9fbe <Udma_ringFlushRaw+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9fbe: 9803         	ldr	r0, [sp, #0xc]
700a9fc0: b940         	cbnz	r0, 0x700a9fd4 <Udma_ringFlushRaw+0x84> @ imm = #0x10
700a9fc2: e7ff         	b	0x700a9fc4 <Udma_ringFlushRaw+0x74> @ imm = #-0x2
;         retVal = drvHandle->ringFlushRaw(drvHandle, ringHandleInt, phyDescMem);
700a9fc4: 9802         	ldr	r0, [sp, #0x8]
700a9fc6: f8d0 3598    	ldr.w	r3, [r0, #0x598]
700a9fca: 9901         	ldr	r1, [sp, #0x4]
700a9fcc: 9a04         	ldr	r2, [sp, #0x10]
700a9fce: 4798         	blx	r3
700a9fd0: 9003         	str	r0, [sp, #0xc]
;     }
700a9fd2: e7ff         	b	0x700a9fd4 <Udma_ringFlushRaw+0x84> @ imm = #-0x2
;     return (retVal);
700a9fd4: 9803         	ldr	r0, [sp, #0xc]
700a9fd6: b006         	add	sp, #0x18
700a9fd8: bd80         	pop	{r7, pc}
700a9fda: 0000         	movs	r0, r0
700a9fdc: 0000         	movs	r0, r0
700a9fde: 0000         	movs	r0, r0

700a9fe0 <xQueueGenericReset>:
; {
700a9fe0: b580         	push	{r7, lr}
700a9fe2: b084         	sub	sp, #0x10
700a9fe4: 9003         	str	r0, [sp, #0xc]
700a9fe6: 9102         	str	r1, [sp, #0x8]
;     Queue_t * const pxQueue = xQueue;
700a9fe8: 9803         	ldr	r0, [sp, #0xc]
700a9fea: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700a9fec: f004 fa70    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0x44e0
;         pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700a9ff0: 9901         	ldr	r1, [sp, #0x4]
700a9ff2: 680b         	ldr	r3, [r1]
700a9ff4: 6bc8         	ldr	r0, [r1, #0x3c]
700a9ff6: 6c0a         	ldr	r2, [r1, #0x40]
700a9ff8: fb00 3002    	mla	r0, r0, r2, r3
700a9ffc: 6088         	str	r0, [r1, #0x8]
;         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
700a9ffe: 9901         	ldr	r1, [sp, #0x4]
700aa000: 2000         	movs	r0, #0x0
700aa002: 6388         	str	r0, [r1, #0x38]
;         pxQueue->pcWriteTo = pxQueue->pcHead;
700aa004: 9901         	ldr	r1, [sp, #0x4]
700aa006: 6808         	ldr	r0, [r1]
700aa008: 6048         	str	r0, [r1, #0x4]
;         pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700aa00a: 9901         	ldr	r1, [sp, #0x4]
700aa00c: 680b         	ldr	r3, [r1]
700aa00e: 6bc8         	ldr	r0, [r1, #0x3c]
700aa010: 6c0a         	ldr	r2, [r1, #0x40]
700aa012: 3801         	subs	r0, #0x1
700aa014: fb00 3002    	mla	r0, r0, r2, r3
700aa018: 60c8         	str	r0, [r1, #0xc]
;         pxQueue->cRxLock = queueUNLOCKED;
700aa01a: 9901         	ldr	r1, [sp, #0x4]
700aa01c: 20ff         	movs	r0, #0xff
700aa01e: f881 0044    	strb.w	r0, [r1, #0x44]
;         pxQueue->cTxLock = queueUNLOCKED;
700aa022: 9901         	ldr	r1, [sp, #0x4]
700aa024: f881 0045    	strb.w	r0, [r1, #0x45]
;         if( xNewQueue == pdFALSE )
700aa028: 9802         	ldr	r0, [sp, #0x8]
700aa02a: b980         	cbnz	r0, 0x700aa04e <xQueueGenericReset+0x6e> @ imm = #0x20
700aa02c: e7ff         	b	0x700aa02e <xQueueGenericReset+0x4e> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700aa02e: 9801         	ldr	r0, [sp, #0x4]
700aa030: 6900         	ldr	r0, [r0, #0x10]
700aa032: b150         	cbz	r0, 0x700aa04a <xQueueGenericReset+0x6a> @ imm = #0x14
700aa034: e7ff         	b	0x700aa036 <xQueueGenericReset+0x56> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700aa036: 9801         	ldr	r0, [sp, #0x4]
700aa038: 3010         	adds	r0, #0x10
700aa03a: f7fd fbd9    	bl	0x700a77f0 <xTaskRemoveFromEventList> @ imm = #-0x284e
700aa03e: b110         	cbz	r0, 0x700aa046 <xQueueGenericReset+0x66> @ imm = #0x4
700aa040: e7ff         	b	0x700aa042 <xQueueGenericReset+0x62> @ imm = #-0x2
;                     queueYIELD_IF_USING_PREEMPTION();
700aa042: df00         	svc	#0x0
;                 }
700aa044: e000         	b	0x700aa048 <xQueueGenericReset+0x68> @ imm = #0x0
700aa046: e7ff         	b	0x700aa048 <xQueueGenericReset+0x68> @ imm = #-0x2
;             }
700aa048: e000         	b	0x700aa04c <xQueueGenericReset+0x6c> @ imm = #0x0
700aa04a: e7ff         	b	0x700aa04c <xQueueGenericReset+0x6c> @ imm = #-0x2
;         }
700aa04c: e008         	b	0x700aa060 <xQueueGenericReset+0x80> @ imm = #0x10
;             vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
700aa04e: 9801         	ldr	r0, [sp, #0x4]
700aa050: 3010         	adds	r0, #0x10
700aa052: f004 fbcd    	bl	0x700ae7f0 <vListInitialise> @ imm = #0x479a
;             vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
700aa056: 9801         	ldr	r0, [sp, #0x4]
700aa058: 3024         	adds	r0, #0x24
700aa05a: f004 fbc9    	bl	0x700ae7f0 <vListInitialise> @ imm = #0x4792
700aa05e: e7ff         	b	0x700aa060 <xQueueGenericReset+0x80> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700aa060: f003 faf6    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0x35ec
700aa064: 2001         	movs	r0, #0x1
;     return pdPASS;
700aa066: b004         	add	sp, #0x10
700aa068: bd80         	pop	{r7, pc}
700aa06a: 0000         	movs	r0, r0
700aa06c: 0000         	movs	r0, r0
700aa06e: 0000         	movs	r0, r0

700aa070 <CSL_bcdmaGetCfg>:
; {
700aa070: b580         	push	{r7, lr}
700aa072: b082         	sub	sp, #0x8
700aa074: 9001         	str	r0, [sp, #0x4]
;     if( ! ((pCfg == NULL) || (pCfg->pGenCfgRegs == NULL)) )
700aa076: 9801         	ldr	r0, [sp, #0x4]
700aa078: b3e0         	cbz	r0, 0x700aa0f4 <CSL_bcdmaGetCfg+0x84> @ imm = #0x78
700aa07a: e7ff         	b	0x700aa07c <CSL_bcdmaGetCfg+0xc> @ imm = #-0x2
700aa07c: 9801         	ldr	r0, [sp, #0x4]
700aa07e: 6800         	ldr	r0, [r0]
700aa080: b3c0         	cbz	r0, 0x700aa0f4 <CSL_bcdmaGetCfg+0x84> @ imm = #0x70
700aa082: e7ff         	b	0x700aa084 <CSL_bcdmaGetCfg+0x14> @ imm = #-0x2
;         pCfg->cap0 = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP0 );
700aa084: 9801         	ldr	r0, [sp, #0x4]
700aa086: 6800         	ldr	r0, [r0]
700aa088: 3020         	adds	r0, #0x20
700aa08a: f005 fc31    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0x5862
700aa08e: 9901         	ldr	r1, [sp, #0x4]
700aa090: 61c8         	str	r0, [r1, #0x1c]
;         pCfg->cap1 = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP1 );
700aa092: 9801         	ldr	r0, [sp, #0x4]
700aa094: 6800         	ldr	r0, [r0]
700aa096: 3024         	adds	r0, #0x24
700aa098: f005 fc2a    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0x5854
700aa09c: 9901         	ldr	r1, [sp, #0x4]
700aa09e: 6208         	str	r0, [r1, #0x20]
;         regVal = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP2 );
700aa0a0: 9801         	ldr	r0, [sp, #0x4]
700aa0a2: 6800         	ldr	r0, [r0]
700aa0a4: 3028         	adds	r0, #0x28
700aa0a6: f005 fc23    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0x5846
700aa0aa: 9000         	str	r0, [sp]
;         pCfg->bcChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_CHAN_CNT );
700aa0ac: 9800         	ldr	r0, [sp]
700aa0ae: f36f 205f    	bfc	r0, #9, #23
700aa0b2: 9901         	ldr	r1, [sp, #0x4]
700aa0b4: 6248         	str	r0, [r1, #0x24]
;         pCfg->splitTxChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_TCHAN_CNT );
700aa0b6: 9800         	ldr	r0, [sp]
700aa0b8: f3c0 2048    	ubfx	r0, r0, #0x9, #0x9
700aa0bc: 9901         	ldr	r1, [sp, #0x4]
700aa0be: 62c8         	str	r0, [r1, #0x2c]
;         pCfg->splitRxChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_RCHAN_CNT );
700aa0c0: 9800         	ldr	r0, [sp]
700aa0c2: f3c0 4088    	ubfx	r0, r0, #0x12, #0x9
700aa0c6: 9901         	ldr	r1, [sp, #0x4]
700aa0c8: 6288         	str	r0, [r1, #0x28]
;         pCfg->flowCnt = (uint32_t)0U;
700aa0ca: 9901         	ldr	r1, [sp, #0x4]
700aa0cc: 2000         	movs	r0, #0x0
700aa0ce: 6308         	str	r0, [r1, #0x30]
;         pCfg->txChanCnt                     = pCfg->bcChanCnt + pCfg->splitTxChanCnt;
700aa0d0: 9a01         	ldr	r2, [sp, #0x4]
700aa0d2: 6a51         	ldr	r1, [r2, #0x24]
700aa0d4: 6ad3         	ldr	r3, [r2, #0x2c]
700aa0d6: 4419         	add	r1, r3
700aa0d8: 6351         	str	r1, [r2, #0x34]
;         pCfg->rxChanCnt                     = pCfg->splitRxChanCnt;
700aa0da: 9a01         	ldr	r2, [sp, #0x4]
700aa0dc: 6a91         	ldr	r1, [r2, #0x28]
700aa0de: 6391         	str	r1, [r2, #0x38]
;         pCfg->rxFlowCnt                     = pCfg->flowCnt;
700aa0e0: 9a01         	ldr	r2, [sp, #0x4]
700aa0e2: 6b11         	ldr	r1, [r2, #0x30]
700aa0e4: 63d1         	str	r1, [r2, #0x3c]
;         pCfg->txExtUtcChanCnt               = (uint32_t)0U;
700aa0e6: 9901         	ldr	r1, [sp, #0x4]
700aa0e8: 6408         	str	r0, [r1, #0x40]
;         pCfg->txHighCapacityChanCnt         = (uint32_t)0U;
700aa0ea: 9901         	ldr	r1, [sp, #0x4]
700aa0ec: 6448         	str	r0, [r1, #0x44]
;         pCfg->txUltraHighCapacityChanCnt    = (uint32_t)0U;
700aa0ee: 9901         	ldr	r1, [sp, #0x4]
700aa0f0: 6488         	str	r0, [r1, #0x48]
;     }
700aa0f2: e7ff         	b	0x700aa0f4 <CSL_bcdmaGetCfg+0x84> @ imm = #-0x2
; }
700aa0f4: b002         	add	sp, #0x8
700aa0f6: bd80         	pop	{r7, pc}
		...

700aa100 <Udma_rmFreeVintrBit>:
; {
700aa100: b580         	push	{r7, lr}
700aa102: b088         	sub	sp, #0x20
700aa104: 9007         	str	r0, [sp, #0x1c]
700aa106: 9106         	str	r1, [sp, #0x18]
700aa108: 9205         	str	r2, [sp, #0x14]
;     controllerEventHandle = eventHandle;
700aa10a: 9805         	ldr	r0, [sp, #0x14]
700aa10c: 9001         	str	r0, [sp, #0x4]
;     eventPrms = &eventHandle->eventPrms;
700aa10e: 9805         	ldr	r0, [sp, #0x14]
700aa110: 3008         	adds	r0, #0x8
700aa112: 9000         	str	r0, [sp]
;     if(NULL_PTR != eventPrms->controllerEventHandle)
700aa114: 9800         	ldr	r0, [sp]
700aa116: 6900         	ldr	r0, [r0, #0x10]
700aa118: b120         	cbz	r0, 0x700aa124 <Udma_rmFreeVintrBit+0x24> @ imm = #0x8
700aa11a: e7ff         	b	0x700aa11c <Udma_rmFreeVintrBit+0x1c> @ imm = #-0x2
;         controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700aa11c: 9800         	ldr	r0, [sp]
700aa11e: 6900         	ldr	r0, [r0, #0x10]
700aa120: 9001         	str	r0, [sp, #0x4]
;     }
700aa122: e7ff         	b	0x700aa124 <Udma_rmFreeVintrBit+0x24> @ imm = #-0x2
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa124: 9806         	ldr	r0, [sp, #0x18]
700aa126: f500 609f    	add.w	r0, r0, #0x4f8
700aa12a: f04f 31ff    	mov.w	r1, #0xffffffff
700aa12e: f000 fa27    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #0x44e
;     bitMask = ((uint64_t) 1U << vintrBitNum);
700aa132: 9b07         	ldr	r3, [sp, #0x1c]
700aa134: f1a3 0220    	sub.w	r2, r3, #0x20
700aa138: 2101         	movs	r1, #0x1
700aa13a: fa01 fc02    	lsl.w	r12, r1, r2
700aa13e: f1c3 0020    	rsb.w	r0, r3, #0x20
700aa142: fa21 f000    	lsr.w	r0, r1, r0
700aa146: 2a00         	cmp	r2, #0x0
700aa148: bf58         	it	pl
700aa14a: 4660         	movpl	r0, r12
700aa14c: fa01 f103    	lsl.w	r1, r1, r3
700aa150: 2a00         	cmp	r2, #0x0
700aa152: bf58         	it	pl
700aa154: 2100         	movpl	r1, #0x0
700aa156: 9102         	str	r1, [sp, #0x8]
700aa158: 9003         	str	r0, [sp, #0xc]
;     controllerEventHandle->vintrBitAllocFlag &= ~bitMask;
700aa15a: f8dd c008    	ldr.w	r12, [sp, #0x8]
700aa15e: 9b03         	ldr	r3, [sp, #0xc]
700aa160: 9901         	ldr	r1, [sp, #0x4]
700aa162: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700aa166: f8d1 208c    	ldr.w	r2, [r1, #0x8c]
700aa16a: ea20 000c    	bic.w	r0, r0, r12
700aa16e: ea22 0203    	bic.w	r2, r2, r3
700aa172: f8c1 208c    	str.w	r2, [r1, #0x8c]
700aa176: f8c1 0088    	str.w	r0, [r1, #0x88]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa17a: 9806         	ldr	r0, [sp, #0x18]
700aa17c: f500 609f    	add.w	r0, r0, #0x4f8
700aa180: f001 fd8e    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x1b1c
;     return;
700aa184: b008         	add	sp, #0x20
700aa186: bd80         	pop	{r7, pc}
		...

700aa190 <SOC_controlModuleLockMMR>:
; {
700aa190: b580         	push	{r7, lr}
700aa192: b086         	sub	sp, #0x18
700aa194: 9005         	str	r0, [sp, #0x14]
700aa196: 9104         	str	r1, [sp, #0x10]
;     if(SOC_DOMAIN_ID_MAIN == domainId)
700aa198: 9805         	ldr	r0, [sp, #0x14]
700aa19a: b9d8         	cbnz	r0, 0x700aa1d4 <SOC_controlModuleLockMMR+0x44> @ imm = #0x36
700aa19c: e7ff         	b	0x700aa19e <SOC_controlModuleLockMMR+0xe> @ imm = #-0x2
700aa19e: f04f 4086    	mov.w	r0, #0x43000000
700aa1a2: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_CTRL_MMR0_CFG0_BASE);
700aa1a4: 9101         	str	r1, [sp, #0x4]
700aa1a6: f7fb fbab    	bl	0x700a5900 <AddrTranslateP_getLocalAddr> @ imm = #-0x48aa
700aa1aa: 9901         	ldr	r1, [sp, #0x4]
700aa1ac: 9003         	str	r0, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700aa1ae: 9803         	ldr	r0, [sp, #0xc]
700aa1b0: 9a04         	ldr	r2, [sp, #0x10]
700aa1b2: eb00 3082    	add.w	r0, r0, r2, lsl #14
700aa1b6: f241 0208    	movw	r2, #0x1008
700aa1ba: 4410         	add	r0, r2
700aa1bc: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700aa1be: 9802         	ldr	r0, [sp, #0x8]
700aa1c0: f005 fb16    	bl	0x700af7f0 <CSL_REG32_WR_RAW> @ imm = #0x562c
700aa1c4: 9901         	ldr	r1, [sp, #0x4]
;         kickAddr++;
700aa1c6: 9802         	ldr	r0, [sp, #0x8]
700aa1c8: 3004         	adds	r0, #0x4
700aa1ca: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700aa1cc: 9802         	ldr	r0, [sp, #0x8]
700aa1ce: f005 fb0f    	bl	0x700af7f0 <CSL_REG32_WR_RAW> @ imm = #0x561e
;     }
700aa1d2: e7ff         	b	0x700aa1d4 <SOC_controlModuleLockMMR+0x44> @ imm = #-0x2
;     if(SOC_DOMAIN_ID_MCU == domainId)
700aa1d4: 9805         	ldr	r0, [sp, #0x14]
700aa1d6: 2801         	cmp	r0, #0x1
700aa1d8: d11b         	bne	0x700aa212 <SOC_controlModuleLockMMR+0x82> @ imm = #0x36
700aa1da: e7ff         	b	0x700aa1dc <SOC_controlModuleLockMMR+0x4c> @ imm = #-0x2
700aa1dc: f04f 608a    	mov.w	r0, #0x4500000
700aa1e0: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_CTRL_MMR0_CFG0_BASE);
700aa1e2: 9100         	str	r1, [sp]
700aa1e4: f7fb fb8c    	bl	0x700a5900 <AddrTranslateP_getLocalAddr> @ imm = #-0x48e8
700aa1e8: 9900         	ldr	r1, [sp]
700aa1ea: 9003         	str	r0, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700aa1ec: 9803         	ldr	r0, [sp, #0xc]
700aa1ee: 9a04         	ldr	r2, [sp, #0x10]
700aa1f0: eb00 3082    	add.w	r0, r0, r2, lsl #14
700aa1f4: f241 0208    	movw	r2, #0x1008
700aa1f8: 4410         	add	r0, r2
700aa1fa: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700aa1fc: 9802         	ldr	r0, [sp, #0x8]
700aa1fe: f005 faf7    	bl	0x700af7f0 <CSL_REG32_WR_RAW> @ imm = #0x55ee
700aa202: 9900         	ldr	r1, [sp]
;         kickAddr++;
700aa204: 9802         	ldr	r0, [sp, #0x8]
700aa206: 3004         	adds	r0, #0x4
700aa208: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700aa20a: 9802         	ldr	r0, [sp, #0x8]
700aa20c: f005 faf0    	bl	0x700af7f0 <CSL_REG32_WR_RAW> @ imm = #0x55e0
;     }
700aa210: e7ff         	b	0x700aa212 <SOC_controlModuleLockMMR+0x82> @ imm = #-0x2
;     return;
700aa212: b006         	add	sp, #0x18
700aa214: bd80         	pop	{r7, pc}
		...
700aa21e: 0000         	movs	r0, r0

700aa220 <UART_lld_flushTxFifo>:
; {
700aa220: b580         	push	{r7, lr}
700aa222: b088         	sub	sp, #0x20
700aa224: 9007         	str	r0, [sp, #0x1c]
700aa226: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700aa228: 9006         	str	r0, [sp, #0x18]
700aa22a: f640 31b8    	movw	r1, #0xbb8
;     uint32_t            timeout = UART_TRANSMITEMPTY_TRIALCOUNT;
700aa22e: 9102         	str	r1, [sp, #0x8]
;     uint32_t            timeoutElapsed  = FALSE;
700aa230: 9001         	str	r0, [sp, #0x4]
;     if (NULL_PTR != hUart)
700aa232: 9807         	ldr	r0, [sp, #0x1c]
700aa234: b380         	cbz	r0, 0x700aa298 <UART_lld_flushTxFifo+0x78> @ imm = #0x60
700aa236: e7ff         	b	0x700aa238 <UART_lld_flushTxFifo+0x18> @ imm = #-0x2
;         hUartInit = hUart->hUartInit;
700aa238: 9807         	ldr	r0, [sp, #0x1c]
700aa23a: 6840         	ldr	r0, [r0, #0x4]
700aa23c: 9000         	str	r0, [sp]
;         startTicks = hUartInit->clockP_get();
700aa23e: 9800         	ldr	r0, [sp]
700aa240: 6d40         	ldr	r0, [r0, #0x54]
700aa242: 4780         	blx	r0
700aa244: 9004         	str	r0, [sp, #0x10]
;         while (FALSE == timeoutElapsed)
700aa246: e7ff         	b	0x700aa248 <UART_lld_flushTxFifo+0x28> @ imm = #-0x2
700aa248: 9801         	ldr	r0, [sp, #0x4]
700aa24a: b9e0         	cbnz	r0, 0x700aa286 <UART_lld_flushTxFifo+0x66> @ imm = #0x38
700aa24c: e7ff         	b	0x700aa24e <UART_lld_flushTxFifo+0x2e> @ imm = #-0x2
;             isTxFifoEmpty = UART_spaceAvail(hUart->baseAddr);
700aa24e: 9807         	ldr	r0, [sp, #0x1c]
700aa250: 6800         	ldr	r0, [r0]
700aa252: f003 fce5    	bl	0x700adc20 <UART_spaceAvail> @ imm = #0x39ca
700aa256: 9005         	str	r0, [sp, #0x14]
;             if ((uint32_t) TRUE == isTxFifoEmpty)
700aa258: 9805         	ldr	r0, [sp, #0x14]
700aa25a: 2801         	cmp	r0, #0x1
700aa25c: d101         	bne	0x700aa262 <UART_lld_flushTxFifo+0x42> @ imm = #0x2
700aa25e: e7ff         	b	0x700aa260 <UART_lld_flushTxFifo+0x40> @ imm = #-0x2
;                 break;
700aa260: e011         	b	0x700aa286 <UART_lld_flushTxFifo+0x66> @ imm = #0x22
;             elapsedTicks = hUartInit->clockP_get() - startTicks;
700aa262: 9800         	ldr	r0, [sp]
700aa264: 6d40         	ldr	r0, [r0, #0x54]
700aa266: 4780         	blx	r0
700aa268: 9904         	ldr	r1, [sp, #0x10]
700aa26a: 1a40         	subs	r0, r0, r1
700aa26c: 9003         	str	r0, [sp, #0xc]
;             if (elapsedTicks >= timeout)
700aa26e: 9803         	ldr	r0, [sp, #0xc]
700aa270: 9902         	ldr	r1, [sp, #0x8]
700aa272: 4288         	cmp	r0, r1
700aa274: d303         	blo	0x700aa27e <UART_lld_flushTxFifo+0x5e> @ imm = #0x6
700aa276: e7ff         	b	0x700aa278 <UART_lld_flushTxFifo+0x58> @ imm = #-0x2
700aa278: 2001         	movs	r0, #0x1
;                 timeoutElapsed = TRUE;
700aa27a: 9001         	str	r0, [sp, #0x4]
;             }
700aa27c: e002         	b	0x700aa284 <UART_lld_flushTxFifo+0x64> @ imm = #0x4
;                 TaskP_yield();
700aa27e: f005 fbdf    	bl	0x700afa40 <TaskP_yield> @ imm = #0x57be
700aa282: e7ff         	b	0x700aa284 <UART_lld_flushTxFifo+0x64> @ imm = #-0x2
;         while (FALSE == timeoutElapsed)
700aa284: e7e0         	b	0x700aa248 <UART_lld_flushTxFifo+0x28> @ imm = #-0x40
;         if(TRUE == timeoutElapsed)
700aa286: 9801         	ldr	r0, [sp, #0x4]
700aa288: 2801         	cmp	r0, #0x1
700aa28a: d104         	bne	0x700aa296 <UART_lld_flushTxFifo+0x76> @ imm = #0x8
700aa28c: e7ff         	b	0x700aa28e <UART_lld_flushTxFifo+0x6e> @ imm = #-0x2
700aa28e: f06f 0001    	mvn	r0, #0x1
;             status = UART_TRANSFER_TIMEOUT;
700aa292: 9006         	str	r0, [sp, #0x18]
;         }
700aa294: e7ff         	b	0x700aa296 <UART_lld_flushTxFifo+0x76> @ imm = #-0x2
;     }
700aa296: e003         	b	0x700aa2a0 <UART_lld_flushTxFifo+0x80> @ imm = #0x6
700aa298: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700aa29c: 9006         	str	r0, [sp, #0x18]
700aa29e: e7ff         	b	0x700aa2a0 <UART_lld_flushTxFifo+0x80> @ imm = #-0x2
;     return status;
700aa2a0: 9806         	ldr	r0, [sp, #0x18]
700aa2a2: b008         	add	sp, #0x20
700aa2a4: bd80         	pop	{r7, pc}
		...
700aa2ae: 0000         	movs	r0, r0

700aa2b0 <UART_tcrTlrBitValRestore>:
; {
700aa2b0: b580         	push	{r7, lr}
700aa2b2: b088         	sub	sp, #0x20
700aa2b4: 9007         	str	r0, [sp, #0x1c]
700aa2b6: 9106         	str	r1, [sp, #0x18]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700aa2b8: 9807         	ldr	r0, [sp, #0x1c]
700aa2ba: 21bf         	movs	r1, #0xbf
700aa2bc: 9101         	str	r1, [sp, #0x4]
700aa2be: f002 f937    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #0x226e
700aa2c2: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700aa2c4: 9807         	ldr	r0, [sp, #0x1c]
700aa2c6: 3008         	adds	r0, #0x8
700aa2c8: 2110         	movs	r1, #0x10
700aa2ca: 9102         	str	r1, [sp, #0x8]
700aa2cc: 2204         	movs	r2, #0x4
700aa2ce: 9203         	str	r2, [sp, #0xc]
700aa2d0: f004 fece    	bl	0x700af070 <HW_RD_FIELD32_RAW> @ imm = #0x4d9c
700aa2d4: 9902         	ldr	r1, [sp, #0x8]
700aa2d6: 9a03         	ldr	r2, [sp, #0xc]
700aa2d8: 9005         	str	r0, [sp, #0x14]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700aa2da: 9807         	ldr	r0, [sp, #0x1c]
700aa2dc: 3008         	adds	r0, #0x8
700aa2de: 2301         	movs	r3, #0x1
700aa2e0: f004 f896    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x412c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa2e4: 9807         	ldr	r0, [sp, #0x1c]
700aa2e6: 300c         	adds	r0, #0xc
700aa2e8: 9904         	ldr	r1, [sp, #0x10]
700aa2ea: f005 fac1    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x5582
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700aa2ee: 9807         	ldr	r0, [sp, #0x1c]
700aa2f0: 2180         	movs	r1, #0x80
700aa2f2: f002 f91d    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #0x223a
700aa2f6: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_MCR, UART_MCR_TCR_TLR, tcrTlrBitVal);
700aa2f8: 9807         	ldr	r0, [sp, #0x1c]
700aa2fa: 3010         	adds	r0, #0x10
700aa2fc: 9b06         	ldr	r3, [sp, #0x18]
700aa2fe: 2140         	movs	r1, #0x40
700aa300: 2206         	movs	r2, #0x6
700aa302: f004 f885    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x410a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa306: 9807         	ldr	r0, [sp, #0x1c]
700aa308: 300c         	adds	r0, #0xc
700aa30a: 9904         	ldr	r1, [sp, #0x10]
700aa30c: f005 fab0    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x5560
700aa310: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700aa312: 9807         	ldr	r0, [sp, #0x1c]
700aa314: f002 f90c    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #0x2218
700aa318: 9902         	ldr	r1, [sp, #0x8]
700aa31a: 9a03         	ldr	r2, [sp, #0xc]
700aa31c: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700aa31e: 9807         	ldr	r0, [sp, #0x1c]
700aa320: 3008         	adds	r0, #0x8
700aa322: 9b05         	ldr	r3, [sp, #0x14]
700aa324: f004 f874    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x40e8
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa328: 9807         	ldr	r0, [sp, #0x1c]
700aa32a: 300c         	adds	r0, #0xc
700aa32c: 9904         	ldr	r1, [sp, #0x10]
700aa32e: f005 fa9f    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x553e
; }
700aa332: b008         	add	sp, #0x20
700aa334: bd80         	pop	{r7, pc}
		...
700aa33e: 0000         	movs	r0, r0

700aa340 <prvInsertTimerInActiveList>:
;     {
700aa340: b580         	push	{r7, lr}
700aa342: b086         	sub	sp, #0x18
700aa344: 9005         	str	r0, [sp, #0x14]
700aa346: 9104         	str	r1, [sp, #0x10]
700aa348: 9203         	str	r2, [sp, #0xc]
700aa34a: 9302         	str	r3, [sp, #0x8]
700aa34c: 2000         	movs	r0, #0x0
;         BaseType_t xProcessTimerNow = pdFALSE;
700aa34e: 9001         	str	r0, [sp, #0x4]
;         listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
700aa350: 9804         	ldr	r0, [sp, #0x10]
700aa352: 9905         	ldr	r1, [sp, #0x14]
700aa354: 6048         	str	r0, [r1, #0x4]
;         listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
700aa356: 9805         	ldr	r0, [sp, #0x14]
700aa358: 6100         	str	r0, [r0, #0x10]
;         if( xNextExpiryTime <= xTimeNow )
700aa35a: 9804         	ldr	r0, [sp, #0x10]
700aa35c: 9903         	ldr	r1, [sp, #0xc]
700aa35e: 4288         	cmp	r0, r1
700aa360: d816         	bhi	0x700aa390 <prvInsertTimerInActiveList+0x50> @ imm = #0x2c
700aa362: e7ff         	b	0x700aa364 <prvInsertTimerInActiveList+0x24> @ imm = #-0x2
;             if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
700aa364: 9803         	ldr	r0, [sp, #0xc]
700aa366: 9902         	ldr	r1, [sp, #0x8]
700aa368: 1a40         	subs	r0, r0, r1
700aa36a: 9905         	ldr	r1, [sp, #0x14]
700aa36c: 6989         	ldr	r1, [r1, #0x18]
700aa36e: 4288         	cmp	r0, r1
700aa370: d303         	blo	0x700aa37a <prvInsertTimerInActiveList+0x3a> @ imm = #0x6
700aa372: e7ff         	b	0x700aa374 <prvInsertTimerInActiveList+0x34> @ imm = #-0x2
700aa374: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
700aa376: 9001         	str	r0, [sp, #0x4]
;             }
700aa378: e009         	b	0x700aa38e <prvInsertTimerInActiveList+0x4e> @ imm = #0x12
;                 vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
700aa37a: f245 2028    	movw	r0, #0x5228
700aa37e: f2c7 0008    	movt	r0, #0x7008
700aa382: 6800         	ldr	r0, [r0]
700aa384: 9905         	ldr	r1, [sp, #0x14]
700aa386: 3104         	adds	r1, #0x4
700aa388: f001 f90a    	bl	0x700ab5a0 <vListInsert> @ imm = #0x1214
700aa38c: e7ff         	b	0x700aa38e <prvInsertTimerInActiveList+0x4e> @ imm = #-0x2
;         }
700aa38e: e017         	b	0x700aa3c0 <prvInsertTimerInActiveList+0x80> @ imm = #0x2e
;             if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
700aa390: 9803         	ldr	r0, [sp, #0xc]
700aa392: 9902         	ldr	r1, [sp, #0x8]
700aa394: 4288         	cmp	r0, r1
700aa396: d208         	bhs	0x700aa3aa <prvInsertTimerInActiveList+0x6a> @ imm = #0x10
700aa398: e7ff         	b	0x700aa39a <prvInsertTimerInActiveList+0x5a> @ imm = #-0x2
700aa39a: 9804         	ldr	r0, [sp, #0x10]
700aa39c: 9902         	ldr	r1, [sp, #0x8]
700aa39e: 4288         	cmp	r0, r1
700aa3a0: d303         	blo	0x700aa3aa <prvInsertTimerInActiveList+0x6a> @ imm = #0x6
700aa3a2: e7ff         	b	0x700aa3a4 <prvInsertTimerInActiveList+0x64> @ imm = #-0x2
700aa3a4: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
700aa3a6: 9001         	str	r0, [sp, #0x4]
;             }
700aa3a8: e009         	b	0x700aa3be <prvInsertTimerInActiveList+0x7e> @ imm = #0x12
;                 vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
700aa3aa: f245 201c    	movw	r0, #0x521c
700aa3ae: f2c7 0008    	movt	r0, #0x7008
700aa3b2: 6800         	ldr	r0, [r0]
700aa3b4: 9905         	ldr	r1, [sp, #0x14]
700aa3b6: 3104         	adds	r1, #0x4
700aa3b8: f001 f8f2    	bl	0x700ab5a0 <vListInsert> @ imm = #0x11e4
700aa3bc: e7ff         	b	0x700aa3be <prvInsertTimerInActiveList+0x7e> @ imm = #-0x2
700aa3be: e7ff         	b	0x700aa3c0 <prvInsertTimerInActiveList+0x80> @ imm = #-0x2
;         return xProcessTimerNow;
700aa3c0: 9801         	ldr	r0, [sp, #0x4]
700aa3c2: b006         	add	sp, #0x18
700aa3c4: bd80         	pop	{r7, pc}
		...
700aa3ce: 0000         	movs	r0, r0

700aa3d0 <prvProcessTimerOrBlockTask>:
;     {
700aa3d0: b580         	push	{r7, lr}
700aa3d2: b084         	sub	sp, #0x10
700aa3d4: 9003         	str	r0, [sp, #0xc]
700aa3d6: 9102         	str	r1, [sp, #0x8]
;         vTaskSuspendAll();
700aa3d8: f005 fa6a    	bl	0x700af8b0 <vTaskSuspendAll> @ imm = #0x54d4
700aa3dc: 4668         	mov	r0, sp
;             xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
700aa3de: f003 f9af    	bl	0x700ad740 <prvSampleTimeNow> @ imm = #0x335e
700aa3e2: 9001         	str	r0, [sp, #0x4]
;             if( xTimerListsWereSwitched == pdFALSE )
700aa3e4: 9800         	ldr	r0, [sp]
700aa3e6: bb88         	cbnz	r0, 0x700aa44c <prvProcessTimerOrBlockTask+0x7c> @ imm = #0x62
700aa3e8: e7ff         	b	0x700aa3ea <prvProcessTimerOrBlockTask+0x1a> @ imm = #-0x2
;                 if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
700aa3ea: 9802         	ldr	r0, [sp, #0x8]
700aa3ec: b960         	cbnz	r0, 0x700aa408 <prvProcessTimerOrBlockTask+0x38> @ imm = #0x18
700aa3ee: e7ff         	b	0x700aa3f0 <prvProcessTimerOrBlockTask+0x20> @ imm = #-0x2
700aa3f0: 9803         	ldr	r0, [sp, #0xc]
700aa3f2: 9901         	ldr	r1, [sp, #0x4]
700aa3f4: 4288         	cmp	r0, r1
700aa3f6: d807         	bhi	0x700aa408 <prvProcessTimerOrBlockTask+0x38> @ imm = #0xe
700aa3f8: e7ff         	b	0x700aa3fa <prvProcessTimerOrBlockTask+0x2a> @ imm = #-0x2
;                     ( void ) xTaskResumeAll();
700aa3fa: f7f7 fe49    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0x836e
;                     prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
700aa3fe: 9803         	ldr	r0, [sp, #0xc]
700aa400: 9901         	ldr	r1, [sp, #0x4]
700aa402: f000 fe55    	bl	0x700ab0b0 <prvProcessExpiredTimer> @ imm = #0xcaa
;                 }
700aa406: e020         	b	0x700aa44a <prvProcessTimerOrBlockTask+0x7a> @ imm = #0x40
;                     if( xListWasEmpty != pdFALSE )
700aa408: 9802         	ldr	r0, [sp, #0x8]
700aa40a: b158         	cbz	r0, 0x700aa424 <prvProcessTimerOrBlockTask+0x54> @ imm = #0x16
700aa40c: e7ff         	b	0x700aa40e <prvProcessTimerOrBlockTask+0x3e> @ imm = #-0x2
;                         xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
700aa40e: f245 2028    	movw	r0, #0x5228
700aa412: f2c7 0008    	movt	r0, #0x7008
700aa416: 6800         	ldr	r0, [r0]
700aa418: 6800         	ldr	r0, [r0]
700aa41a: fab0 f080    	clz	r0, r0
700aa41e: 0940         	lsrs	r0, r0, #0x5
700aa420: 9002         	str	r0, [sp, #0x8]
;                     }
700aa422: e7ff         	b	0x700aa424 <prvProcessTimerOrBlockTask+0x54> @ imm = #-0x2
;                     vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
700aa424: f242 7008    	movw	r0, #0x2708
700aa428: f2c7 000b    	movt	r0, #0x700b
700aa42c: 6800         	ldr	r0, [r0]
700aa42e: 9903         	ldr	r1, [sp, #0xc]
700aa430: 9a01         	ldr	r2, [sp, #0x4]
700aa432: 1a89         	subs	r1, r1, r2
700aa434: 9a02         	ldr	r2, [sp, #0x8]
700aa436: f001 fbfb    	bl	0x700abc30 <vQueueWaitForMessageRestricted> @ imm = #0x17f6
;                     if( xTaskResumeAll() == pdFALSE )
700aa43a: f7f7 fe29    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0x83ae
700aa43e: b910         	cbnz	r0, 0x700aa446 <prvProcessTimerOrBlockTask+0x76> @ imm = #0x4
700aa440: e7ff         	b	0x700aa442 <prvProcessTimerOrBlockTask+0x72> @ imm = #-0x2
;                         portYIELD_WITHIN_API();
700aa442: df00         	svc	#0x0
;                     }
700aa444: e000         	b	0x700aa448 <prvProcessTimerOrBlockTask+0x78> @ imm = #0x0
700aa446: e7ff         	b	0x700aa448 <prvProcessTimerOrBlockTask+0x78> @ imm = #-0x2
700aa448: e7ff         	b	0x700aa44a <prvProcessTimerOrBlockTask+0x7a> @ imm = #-0x2
;             }
700aa44a: e002         	b	0x700aa452 <prvProcessTimerOrBlockTask+0x82> @ imm = #0x4
;                 ( void ) xTaskResumeAll();
700aa44c: f7f7 fe20    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0x83c0
700aa450: e7ff         	b	0x700aa452 <prvProcessTimerOrBlockTask+0x82> @ imm = #-0x2
;     }
700aa452: b004         	add	sp, #0x10
700aa454: bd80         	pop	{r7, pc}
		...
700aa45e: 0000         	movs	r0, r0

700aa460 <PowerClock_init>:
; {
700aa460: b570         	push	{r4, r5, r6, lr}
700aa462: b082         	sub	sp, #0x8
;     while(gSocModules[i]!=SOC_MODULES_END)
700aa464: f242 6154    	movw	r1, #0x2654
700aa468: f2c7 010b    	movt	r1, #0x700b
700aa46c: 6808         	ldr	r0, [r1]
700aa46e: 1c42         	adds	r2, r0, #0x1
700aa470: d013         	beq	0x700aa49a <PowerClock_init+0x3a> @ imm = #0x26
700aa472: 1d0c         	adds	r4, r1, #0x4
700aa474: bf00         	nop
700aa476: bf00         	nop
700aa478: bf00         	nop
700aa47a: bf00         	nop
700aa47c: bf00         	nop
700aa47e: bf00         	nop
;         status = SOC_moduleClockEnable(gSocModules[i], 1);
700aa480: f04f 0101    	mov.w	r1, #0x1
700aa484: f7ff fa7c    	bl	0x700a9980 <SOC_moduleClockEnable> @ imm = #-0xb08
;         DebugP_assertNoLog(status == SystemP_SUCCESS);
700aa488: fab0 f080    	clz	r0, r0
700aa48c: 0940         	lsrs	r0, r0, #0x5
700aa48e: f006 fda7    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x6b4e
;     while(gSocModules[i]!=SOC_MODULES_END)
700aa492: f854 0b04    	ldr	r0, [r4], #4
700aa496: 1c41         	adds	r1, r0, #0x1
700aa498: d1f2         	bne	0x700aa480 <PowerClock_init+0x20> @ imm = #-0x1c
;     while(gSocModulesClockFrequency[i].moduleId!=SOC_MODULES_END)
700aa49a: f242 51a0    	movw	r1, #0x25a0
700aa49e: f2c7 010b    	movt	r1, #0x700b
700aa4a2: 6808         	ldr	r0, [r1]
700aa4a4: 1c42         	adds	r2, r0, #0x1
700aa4a6: d01b         	beq	0x700aa4e0 <PowerClock_init+0x80> @ imm = #0x36
700aa4a8: f101 0408    	add.w	r4, r1, #0x8
700aa4ac: 2600         	movs	r6, #0x0
700aa4ae: e00c         	b	0x700aa4ca <PowerClock_init+0x6a> @ imm = #0x18
;             status = SOC_moduleSetClockFrequency(
700aa4b0: 461a         	mov	r2, r3
700aa4b2: 2300         	movs	r3, #0x0
700aa4b4: f7f5 f8f4    	bl	0x7009f6a0 <SOC_moduleSetClockFrequency> @ imm = #-0xae18
;         DebugP_assertNoLog(status == SystemP_SUCCESS);
700aa4b8: fab0 f080    	clz	r0, r0
700aa4bc: 0940         	lsrs	r0, r0, #0x5
700aa4be: f006 fd8f    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x6b1e
;     while(gSocModulesClockFrequency[i].moduleId!=SOC_MODULES_END)
700aa4c2: 68a0         	ldr	r0, [r4, #0x8]
700aa4c4: 3410         	adds	r4, #0x10
700aa4c6: 1c41         	adds	r1, r0, #0x1
700aa4c8: d00a         	beq	0x700aa4e0 <PowerClock_init+0x80> @ imm = #0x14
;         if (gSocModulesClockFrequency[i].clkParentId != -1)
700aa4ca: 6862         	ldr	r2, [r4, #0x4]
700aa4cc: f854 1c04    	ldr	r1, [r4, #-4]
700aa4d0: 6823         	ldr	r3, [r4]
;         if (gSocModulesClockFrequency[i].clkParentId != -1)
700aa4d2: 1c55         	adds	r5, r2, #0x1
700aa4d4: d0ec         	beq	0x700aa4b0 <PowerClock_init+0x50> @ imm = #-0x28
;             status = SOC_moduleSetClockFrequencyWithParent(
700aa4d6: e9cd 3600    	strd	r3, r6, [sp]
700aa4da: f7f5 f9c1    	bl	0x7009f860 <SOC_moduleSetClockFrequencyWithParent> @ imm = #-0xac7e
700aa4de: e7eb         	b	0x700aa4b8 <PowerClock_init+0x58> @ imm = #-0x2a
; }
700aa4e0: b002         	add	sp, #0x8
700aa4e2: bd70         	pop	{r4, r5, r6, pc}
		...

700aa4f0 <CSL_udmapCppi5SetReturnPolicy>:
; {
700aa4f0: b085         	sub	sp, #0x14
700aa4f2: f8dd c018    	ldr.w	r12, [sp, #0x18]
700aa4f6: f8dd c014    	ldr.w	r12, [sp, #0x14]
700aa4fa: 9004         	str	r0, [sp, #0x10]
700aa4fc: 9103         	str	r1, [sp, #0xc]
700aa4fe: 9202         	str	r2, [sp, #0x8]
700aa500: 9301         	str	r3, [sp, #0x4]
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700aa502: 9803         	ldr	r0, [sp, #0xc]
700aa504: 2803         	cmp	r0, #0x3
700aa506: d108         	bne	0x700aa51a <CSL_udmapCppi5SetReturnPolicy+0x2a> @ imm = #0x10
700aa508: e7ff         	b	0x700aa50a <CSL_udmapCppi5SetReturnPolicy+0x1a> @ imm = #-0x2
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETPOLICY, retPushPolicy )    |
700aa50a: 9905         	ldr	r1, [sp, #0x14]
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETQ, retQnum ) ;
700aa50c: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETPOLICY, retPushPolicy )    |
700aa510: f361 4010    	bfi	r0, r1, #16, #1
;         ((CSL_UdmapCppi5TRPD *)pDesc)->retInfo =
700aa514: 9904         	ldr	r1, [sp, #0x10]
700aa516: 6088         	str	r0, [r1, #0x8]
;     }
700aa518: e029         	b	0x700aa56e <CSL_udmapCppi5SetReturnPolicy+0x7e> @ imm = #0x52
;         v = ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo2;
700aa51a: 9804         	ldr	r0, [sp, #0x10]
700aa51c: 6880         	ldr	r0, [r0, #0x8]
700aa51e: 9000         	str	r0, [sp]
;         if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_MONO )
700aa520: 9803         	ldr	r0, [sp, #0xc]
700aa522: 2802         	cmp	r0, #0x2
700aa524: d105         	bne	0x700aa532 <CSL_udmapCppi5SetReturnPolicy+0x42> @ imm = #0xa
700aa526: e7ff         	b	0x700aa528 <CSL_udmapCppi5SetReturnPolicy+0x38> @ imm = #-0x2
;             v &= (CSL_UDMAP_CPPI5_PD_PKTINFO2_PKTTYPE_MASK | CSL_UDMAP_CPPI5_PD_PKTINFO2_DATA_OFFSET_MASK);
700aa528: 9800         	ldr	r0, [sp]
700aa52a: f36f 0011    	bfc	r0, #0, #18
700aa52e: 9000         	str	r0, [sp]
;         }
700aa530: e00b         	b	0x700aa54a <CSL_udmapCppi5SetReturnPolicy+0x5a> @ imm = #0x16
;             v &= CSL_UDMAP_CPPI5_PD_PKTINFO2_PKTTYPE_MASK;
700aa532: 9800         	ldr	r0, [sp]
700aa534: f000 4078    	and	r0, r0, #0xf8000000
700aa538: 9000         	str	r0, [sp]
;             v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPOLICY, retPolicy );
700aa53a: 9802         	ldr	r0, [sp, #0x8]
700aa53c: f000 0101    	and	r1, r0, #0x1
700aa540: 9800         	ldr	r0, [sp]
700aa542: ea40 4081    	orr.w	r0, r0, r1, lsl #18
700aa546: 9000         	str	r0, [sp]
700aa548: e7ff         	b	0x700aa54a <CSL_udmapCppi5SetReturnPolicy+0x5a> @ imm = #-0x2
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700aa54a: 9901         	ldr	r1, [sp, #0x4]
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPUSHPOLICY, retPushPolicy ) |
700aa54c: 9a05         	ldr	r2, [sp, #0x14]
700aa54e: f44f 3080    	mov.w	r0, #0x10000
700aa552: ea00 4002    	and.w	r0, r0, r2, lsl #16
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700aa556: f361 4051    	bfi	r0, r1, #17, #1
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETQ, retQnum );
700aa55a: f8bd 1018    	ldrh.w	r1, [sp, #0x18]
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPUSHPOLICY, retPushPolicy ) |
700aa55e: 4401         	add	r1, r0
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700aa560: 9800         	ldr	r0, [sp]
700aa562: 4308         	orrs	r0, r1
700aa564: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo2 = v;
700aa566: 9800         	ldr	r0, [sp]
700aa568: 9904         	ldr	r1, [sp, #0x10]
700aa56a: 6088         	str	r0, [r1, #0x8]
700aa56c: e7ff         	b	0x700aa56e <CSL_udmapCppi5SetReturnPolicy+0x7e> @ imm = #-0x2
; }
700aa56e: b005         	add	sp, #0x14
700aa570: 4770         	bx	lr
		...
700aa57e: 0000         	movs	r0, r0

700aa580 <SemaphoreP_pend>:
; {
700aa580: b580         	push	{r7, lr}
700aa582: b086         	sub	sp, #0x18
700aa584: 9005         	str	r0, [sp, #0x14]
700aa586: 9104         	str	r1, [sp, #0x10]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700aa588: 9805         	ldr	r0, [sp, #0x14]
700aa58a: 9003         	str	r0, [sp, #0xc]
700aa58c: 2000         	movs	r0, #0x0
;     uint32_t isSemTaken = 0U;
700aa58e: 9002         	str	r0, [sp, #0x8]
;     if(pSemaphore->isRecursiveMutex != 0U)
700aa590: 9803         	ldr	r0, [sp, #0xc]
700aa592: 6d40         	ldr	r0, [r0, #0x54]
700aa594: b180         	cbz	r0, 0x700aa5b8 <SemaphoreP_pend+0x38> @ imm = #0x20
700aa596: e7ff         	b	0x700aa598 <SemaphoreP_pend+0x18> @ imm = #-0x2
;         if(HwiP_inISR() == 0U )
700aa598: f005 fd82    	bl	0x700b00a0 <HwiP_inISR> @ imm = #0x5b04
700aa59c: b938         	cbnz	r0, 0x700aa5ae <SemaphoreP_pend+0x2e> @ imm = #0xe
700aa59e: e7ff         	b	0x700aa5a0 <SemaphoreP_pend+0x20> @ imm = #-0x2
;             isSemTaken =(uint32_t) xSemaphoreTakeRecursive(pSemaphore->semHndl, timeout);
700aa5a0: 9803         	ldr	r0, [sp, #0xc]
700aa5a2: 6d00         	ldr	r0, [r0, #0x50]
700aa5a4: 9904         	ldr	r1, [sp, #0x10]
700aa5a6: f002 fc6b    	bl	0x700ace80 <xQueueTakeMutexRecursive> @ imm = #0x28d6
700aa5aa: 9002         	str	r0, [sp, #0x8]
;         }
700aa5ac: e003         	b	0x700aa5b6 <SemaphoreP_pend+0x36> @ imm = #0x6
700aa5ae: 2000         	movs	r0, #0x0
;             DebugP_assertNoLog(0);
700aa5b0: f006 fd16    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x6a2c
700aa5b4: e7ff         	b	0x700aa5b6 <SemaphoreP_pend+0x36> @ imm = #-0x2
;     }
700aa5b6: e017         	b	0x700aa5e8 <SemaphoreP_pend+0x68> @ imm = #0x2e
;         if( HwiP_inISR() != 0U )
700aa5b8: f005 fd72    	bl	0x700b00a0 <HwiP_inISR> @ imm = #0x5ae4
700aa5bc: b160         	cbz	r0, 0x700aa5d8 <SemaphoreP_pend+0x58> @ imm = #0x18
700aa5be: e7ff         	b	0x700aa5c0 <SemaphoreP_pend+0x40> @ imm = #-0x2
700aa5c0: 2100         	movs	r1, #0x0
;             BaseType_t xHigherPriorityTaskWoken = 0;
700aa5c2: 9100         	str	r1, [sp]
;             isSemTaken = (uint32_t) xSemaphoreTakeFromISR(pSemaphore->semHndl, &xHigherPriorityTaskWoken);
700aa5c4: 9803         	ldr	r0, [sp, #0xc]
700aa5c6: 6d00         	ldr	r0, [r0, #0x50]
700aa5c8: 466a         	mov	r2, sp
700aa5ca: f7fe fe19    	bl	0x700a9200 <xQueueReceiveFromISR> @ imm = #-0x13ce
700aa5ce: 9002         	str	r0, [sp, #0x8]
;             portYIELD_FROM_ISR((uint32_t)xHigherPriorityTaskWoken);
700aa5d0: 9800         	ldr	r0, [sp]
700aa5d2: f004 fe8d    	bl	0x700af2f0 <vPortYeildFromISR> @ imm = #0x4d1a
;         }
700aa5d6: e006         	b	0x700aa5e6 <SemaphoreP_pend+0x66> @ imm = #0xc
;             isSemTaken = (uint32_t) xSemaphoreTake(pSemaphore->semHndl, timeout);
700aa5d8: 9803         	ldr	r0, [sp, #0xc]
700aa5da: 6d00         	ldr	r0, [r0, #0x50]
700aa5dc: 9904         	ldr	r1, [sp, #0x10]
700aa5de: f7f6 fe47    	bl	0x700a1270 <xQueueSemaphoreTake> @ imm = #-0x9372
700aa5e2: 9002         	str	r0, [sp, #0x8]
700aa5e4: e7ff         	b	0x700aa5e6 <SemaphoreP_pend+0x66> @ imm = #-0x2
700aa5e6: e7ff         	b	0x700aa5e8 <SemaphoreP_pend+0x68> @ imm = #-0x2
;     if(isSemTaken != 0U)
700aa5e8: 9802         	ldr	r0, [sp, #0x8]
700aa5ea: b118         	cbz	r0, 0x700aa5f4 <SemaphoreP_pend+0x74> @ imm = #0x6
700aa5ec: e7ff         	b	0x700aa5ee <SemaphoreP_pend+0x6e> @ imm = #-0x2
700aa5ee: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700aa5f0: 9001         	str	r0, [sp, #0x4]
;     }
700aa5f2: e003         	b	0x700aa5fc <SemaphoreP_pend+0x7c> @ imm = #0x6
700aa5f4: f06f 0001    	mvn	r0, #0x1
;         status = SystemP_TIMEOUT;
700aa5f8: 9001         	str	r0, [sp, #0x4]
700aa5fa: e7ff         	b	0x700aa5fc <SemaphoreP_pend+0x7c> @ imm = #-0x2
;     return status;
700aa5fc: 9801         	ldr	r0, [sp, #0x4]
700aa5fe: b006         	add	sp, #0x18
700aa600: bd80         	pop	{r7, pc}
		...
700aa60e: 0000         	movs	r0, r0

700aa610 <Udma_chPair>:
; {
700aa610: b580         	push	{r7, lr}
700aa612: b088         	sub	sp, #0x20
700aa614: 9007         	str	r0, [sp, #0x1c]
700aa616: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
700aa618: 9006         	str	r0, [sp, #0x18]
;     drvHandle = chHandle->drvHandle;
700aa61a: 9807         	ldr	r0, [sp, #0x1c]
700aa61c: 6e80         	ldr	r0, [r0, #0x68]
700aa61e: 9005         	str	r0, [sp, #0x14]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa620: 9805         	ldr	r0, [sp, #0x14]
700aa622: 6800         	ldr	r0, [r0]
700aa624: 2801         	cmp	r0, #0x1
700aa626: d107         	bne	0x700aa638 <Udma_chPair+0x28> @ imm = #0xe
700aa628: e7ff         	b	0x700aa62a <Udma_chPair+0x1a> @ imm = #-0x2
;        ((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
700aa62a: 9807         	ldr	r0, [sp, #0x1c]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa62c: 7800         	ldrb	r0, [r0]
700aa62e: 0740         	lsls	r0, r0, #0x1d
700aa630: 2800         	cmp	r0, #0x0
700aa632: d501         	bpl	0x700aa638 <Udma_chPair+0x28> @ imm = #0x2
700aa634: e7ff         	b	0x700aa636 <Udma_chPair+0x26> @ imm = #-0x2
;     }
700aa636: e029         	b	0x700aa68c <Udma_chPair+0x7c> @ imm = #0x52
;         rmPairReq.nav_id = drvHandle->devIdPsil;
700aa638: 9805         	ldr	r0, [sp, #0x14]
700aa63a: f8b0 00e4    	ldrh.w	r0, [r0, #0xe4]
700aa63e: 9002         	str	r0, [sp, #0x8]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700aa640: 9807         	ldr	r0, [sp, #0x1c]
700aa642: 7800         	ldrb	r0, [r0]
700aa644: 07c0         	lsls	r0, r0, #0x1f
700aa646: b158         	cbz	r0, 0x700aa660 <Udma_chPair+0x50> @ imm = #0x16
700aa648: e7ff         	b	0x700aa64a <Udma_chPair+0x3a> @ imm = #-0x2
;             rmPairReq.src_thread = chHandle->txChNum + drvHandle->udmapSrcThreadOffset;
700aa64a: 9807         	ldr	r0, [sp, #0x1c]
700aa64c: 6ec0         	ldr	r0, [r0, #0x6c]
700aa64e: 9905         	ldr	r1, [sp, #0x14]
700aa650: f8d1 10d4    	ldr.w	r1, [r1, #0xd4]
700aa654: 4408         	add	r0, r1
700aa656: 9003         	str	r0, [sp, #0xc]
;             rmPairReq.dst_thread = chHandle->peerThreadId;
700aa658: 9807         	ldr	r0, [sp, #0x1c]
700aa65a: 6fc0         	ldr	r0, [r0, #0x7c]
700aa65c: 9004         	str	r0, [sp, #0x10]
;         }
700aa65e: e00a         	b	0x700aa676 <Udma_chPair+0x66> @ imm = #0x14
;             rmPairReq.src_thread = chHandle->peerThreadId;
700aa660: 9807         	ldr	r0, [sp, #0x1c]
700aa662: 6fc0         	ldr	r0, [r0, #0x7c]
700aa664: 9003         	str	r0, [sp, #0xc]
;             rmPairReq.dst_thread = chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
700aa666: 9807         	ldr	r0, [sp, #0x1c]
700aa668: 6f00         	ldr	r0, [r0, #0x70]
700aa66a: 9905         	ldr	r1, [sp, #0x14]
700aa66c: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700aa670: 4408         	add	r0, r1
700aa672: 9004         	str	r0, [sp, #0x10]
700aa674: e7ff         	b	0x700aa676 <Udma_chPair+0x66> @ imm = #-0x2
700aa676: 4668         	mov	r0, sp
700aa678: f04f 31ff    	mov.w	r1, #0xffffffff
;         retVal = Sciclient_rmPsilPair(&rmPairReq, UDMA_SCICLIENT_TIMEOUT);
700aa67c: f002 f990    	bl	0x700ac9a0 <Sciclient_rmPsilPair> @ imm = #0x2320
700aa680: 9006         	str	r0, [sp, #0x18]
;         if(CSL_PASS != retVal)
700aa682: 9806         	ldr	r0, [sp, #0x18]
700aa684: b108         	cbz	r0, 0x700aa68a <Udma_chPair+0x7a> @ imm = #0x2
700aa686: e7ff         	b	0x700aa688 <Udma_chPair+0x78> @ imm = #-0x2
;         }
700aa688: e7ff         	b	0x700aa68a <Udma_chPair+0x7a> @ imm = #-0x2
700aa68a: e7ff         	b	0x700aa68c <Udma_chPair+0x7c> @ imm = #-0x2
;     return (retVal);
700aa68c: 9806         	ldr	r0, [sp, #0x18]
700aa68e: b008         	add	sp, #0x20
700aa690: bd80         	pop	{r7, pc}
		...
700aa69e: 0000         	movs	r0, r0

700aa6a0 <Udma_chUnpair>:
; {
700aa6a0: b580         	push	{r7, lr}
700aa6a2: b088         	sub	sp, #0x20
700aa6a4: 9007         	str	r0, [sp, #0x1c]
700aa6a6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700aa6a8: 9006         	str	r0, [sp, #0x18]
;     drvHandle = chHandle->drvHandle;
700aa6aa: 9807         	ldr	r0, [sp, #0x1c]
700aa6ac: 6e80         	ldr	r0, [r0, #0x68]
700aa6ae: 9005         	str	r0, [sp, #0x14]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa6b0: 9805         	ldr	r0, [sp, #0x14]
700aa6b2: 6800         	ldr	r0, [r0]
700aa6b4: 2801         	cmp	r0, #0x1
700aa6b6: d107         	bne	0x700aa6c8 <Udma_chUnpair+0x28> @ imm = #0xe
700aa6b8: e7ff         	b	0x700aa6ba <Udma_chUnpair+0x1a> @ imm = #-0x2
;        ((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
700aa6ba: 9807         	ldr	r0, [sp, #0x1c]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa6bc: 7800         	ldrb	r0, [r0]
700aa6be: 0740         	lsls	r0, r0, #0x1d
700aa6c0: 2800         	cmp	r0, #0x0
700aa6c2: d501         	bpl	0x700aa6c8 <Udma_chUnpair+0x28> @ imm = #0x2
700aa6c4: e7ff         	b	0x700aa6c6 <Udma_chUnpair+0x26> @ imm = #-0x2
;     }
700aa6c6: e029         	b	0x700aa71c <Udma_chUnpair+0x7c> @ imm = #0x52
;         rmUnpairReq.nav_id = drvHandle->devIdPsil;
700aa6c8: 9805         	ldr	r0, [sp, #0x14]
700aa6ca: f8b0 00e4    	ldrh.w	r0, [r0, #0xe4]
700aa6ce: 9002         	str	r0, [sp, #0x8]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700aa6d0: 9807         	ldr	r0, [sp, #0x1c]
700aa6d2: 7800         	ldrb	r0, [r0]
700aa6d4: 07c0         	lsls	r0, r0, #0x1f
700aa6d6: b158         	cbz	r0, 0x700aa6f0 <Udma_chUnpair+0x50> @ imm = #0x16
700aa6d8: e7ff         	b	0x700aa6da <Udma_chUnpair+0x3a> @ imm = #-0x2
;             rmUnpairReq.src_thread = chHandle->txChNum + drvHandle->udmapSrcThreadOffset;
700aa6da: 9807         	ldr	r0, [sp, #0x1c]
700aa6dc: 6ec0         	ldr	r0, [r0, #0x6c]
700aa6de: 9905         	ldr	r1, [sp, #0x14]
700aa6e0: f8d1 10d4    	ldr.w	r1, [r1, #0xd4]
700aa6e4: 4408         	add	r0, r1
700aa6e6: 9003         	str	r0, [sp, #0xc]
;             rmUnpairReq.dst_thread = chHandle->peerThreadId;
700aa6e8: 9807         	ldr	r0, [sp, #0x1c]
700aa6ea: 6fc0         	ldr	r0, [r0, #0x7c]
700aa6ec: 9004         	str	r0, [sp, #0x10]
;         }
700aa6ee: e00a         	b	0x700aa706 <Udma_chUnpair+0x66> @ imm = #0x14
;             rmUnpairReq.src_thread = chHandle->peerThreadId;
700aa6f0: 9807         	ldr	r0, [sp, #0x1c]
700aa6f2: 6fc0         	ldr	r0, [r0, #0x7c]
700aa6f4: 9003         	str	r0, [sp, #0xc]
;             rmUnpairReq.dst_thread = chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
700aa6f6: 9807         	ldr	r0, [sp, #0x1c]
700aa6f8: 6f00         	ldr	r0, [r0, #0x70]
700aa6fa: 9905         	ldr	r1, [sp, #0x14]
700aa6fc: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700aa700: 4408         	add	r0, r1
700aa702: 9004         	str	r0, [sp, #0x10]
700aa704: e7ff         	b	0x700aa706 <Udma_chUnpair+0x66> @ imm = #-0x2
700aa706: 4668         	mov	r0, sp
700aa708: f04f 31ff    	mov.w	r1, #0xffffffff
;         retVal = Sciclient_rmPsilUnpair(&rmUnpairReq, UDMA_SCICLIENT_TIMEOUT);
700aa70c: f002 f978    	bl	0x700aca00 <Sciclient_rmPsilUnpair> @ imm = #0x22f0
700aa710: 9006         	str	r0, [sp, #0x18]
;         if(CSL_PASS != retVal)
700aa712: 9806         	ldr	r0, [sp, #0x18]
700aa714: b108         	cbz	r0, 0x700aa71a <Udma_chUnpair+0x7a> @ imm = #0x2
700aa716: e7ff         	b	0x700aa718 <Udma_chUnpair+0x78> @ imm = #-0x2
;         }
700aa718: e7ff         	b	0x700aa71a <Udma_chUnpair+0x7a> @ imm = #-0x2
700aa71a: e7ff         	b	0x700aa71c <Udma_chUnpair+0x7c> @ imm = #-0x2
;     return (retVal);
700aa71c: 9806         	ldr	r0, [sp, #0x18]
700aa71e: b008         	add	sp, #0x20
700aa720: bd80         	pop	{r7, pc}
		...
700aa72e: 0000         	movs	r0, r0

700aa730 <UART_moduleReset>:
; {
700aa730: b580         	push	{r7, lr}
700aa732: b088         	sub	sp, #0x20
700aa734: 9007         	str	r0, [sp, #0x1c]
700aa736: 2000         	movs	r0, #0x0
;     uint32_t startTicks, elapsedTicks = 0;
700aa738: 9005         	str	r0, [sp, #0x14]
;     hUartInit = hUart->hUartInit;
700aa73a: 9807         	ldr	r0, [sp, #0x1c]
700aa73c: 6840         	ldr	r0, [r0, #0x4]
700aa73e: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(hUart->baseAddr + UART_SYSC, UART_SYSC_SOFTRESET,
700aa740: 9807         	ldr	r0, [sp, #0x1c]
700aa742: 6800         	ldr	r0, [r0]
700aa744: 3054         	adds	r0, #0x54
700aa746: 2102         	movs	r1, #0x2
700aa748: 2301         	movs	r3, #0x1
700aa74a: 461a         	mov	r2, r3
700aa74c: f003 fe60    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x3cc0
;     startTicks = hUartInit->clockP_get();
700aa750: 9804         	ldr	r0, [sp, #0x10]
700aa752: 6d40         	ldr	r0, [r0, #0x54]
700aa754: 4780         	blx	r0
700aa756: 9006         	str	r0, [sp, #0x18]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700aa758: e7ff         	b	0x700aa75a <UART_moduleReset+0x2a> @ imm = #-0x2
700aa75a: 9807         	ldr	r0, [sp, #0x1c]
700aa75c: 6800         	ldr	r0, [r0]
700aa75e: 3058         	adds	r0, #0x58
700aa760: 2101         	movs	r1, #0x1
700aa762: 2200         	movs	r2, #0x0
700aa764: 9202         	str	r2, [sp, #0x8]
700aa766: f004 fc83    	bl	0x700af070 <HW_RD_FIELD32_RAW> @ imm = #0x4906
700aa76a: 4601         	mov	r1, r0
700aa76c: 9802         	ldr	r0, [sp, #0x8]
700aa76e: 9003         	str	r0, [sp, #0xc]
700aa770: b989         	cbnz	r1, 0x700aa796 <UART_moduleReset+0x66> @ imm = #0x22
700aa772: e7ff         	b	0x700aa774 <UART_moduleReset+0x44> @ imm = #-0x2
700aa774: 9805         	ldr	r0, [sp, #0x14]
700aa776: 9000         	str	r0, [sp]
700aa778: 9804         	ldr	r0, [sp, #0x10]
700aa77a: 6d82         	ldr	r2, [r0, #0x58]
700aa77c: f44f 70fa    	mov.w	r0, #0x1f4
700aa780: 2100         	movs	r1, #0x0
700aa782: 9101         	str	r1, [sp, #0x4]
700aa784: 4790         	blx	r2
700aa786: 9900         	ldr	r1, [sp]
700aa788: 4602         	mov	r2, r0
700aa78a: 9801         	ldr	r0, [sp, #0x4]
700aa78c: 4291         	cmp	r1, r2
700aa78e: bf38         	it	lo
700aa790: 2001         	movlo	r0, #0x1
700aa792: 9003         	str	r0, [sp, #0xc]
700aa794: e7ff         	b	0x700aa796 <UART_moduleReset+0x66> @ imm = #-0x2
700aa796: 9803         	ldr	r0, [sp, #0xc]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700aa798: 07c0         	lsls	r0, r0, #0x1f
700aa79a: b138         	cbz	r0, 0x700aa7ac <UART_moduleReset+0x7c> @ imm = #0xe
700aa79c: e7ff         	b	0x700aa79e <UART_moduleReset+0x6e> @ imm = #-0x2
;         elapsedTicks = hUartInit->clockP_get() - startTicks;
700aa79e: 9804         	ldr	r0, [sp, #0x10]
700aa7a0: 6d40         	ldr	r0, [r0, #0x54]
700aa7a2: 4780         	blx	r0
700aa7a4: 9906         	ldr	r1, [sp, #0x18]
700aa7a6: 1a40         	subs	r0, r0, r1
700aa7a8: 9005         	str	r0, [sp, #0x14]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700aa7aa: e7d6         	b	0x700aa75a <UART_moduleReset+0x2a> @ imm = #-0x54
; }
700aa7ac: b008         	add	sp, #0x20
700aa7ae: bd80         	pop	{r7, pc}

700aa7b0 <CSL_bcdmaChanOpIsChanEnabled>:
; {
700aa7b0: b580         	push	{r7, lr}
700aa7b2: b086         	sub	sp, #0x18
700aa7b4: 9005         	str	r0, [sp, #0x14]
700aa7b6: 9104         	str	r1, [sp, #0x10]
700aa7b8: 9203         	str	r2, [sp, #0xc]
;     switch( chanType )
700aa7ba: 9804         	ldr	r0, [sp, #0x10]
700aa7bc: 9001         	str	r0, [sp, #0x4]
700aa7be: b140         	cbz	r0, 0x700aa7d2 <CSL_bcdmaChanOpIsChanEnabled+0x22> @ imm = #0x10
700aa7c0: e7ff         	b	0x700aa7c2 <CSL_bcdmaChanOpIsChanEnabled+0x12> @ imm = #-0x2
700aa7c2: 9801         	ldr	r0, [sp, #0x4]
700aa7c4: 2801         	cmp	r0, #0x1
700aa7c6: d010         	beq	0x700aa7ea <CSL_bcdmaChanOpIsChanEnabled+0x3a> @ imm = #0x20
700aa7c8: e7ff         	b	0x700aa7ca <CSL_bcdmaChanOpIsChanEnabled+0x1a> @ imm = #-0x2
700aa7ca: 9801         	ldr	r0, [sp, #0x4]
700aa7cc: 2802         	cmp	r0, #0x2
700aa7ce: d018         	beq	0x700aa802 <CSL_bcdmaChanOpIsChanEnabled+0x52> @ imm = #0x30
700aa7d0: e023         	b	0x700aa81a <CSL_bcdmaChanOpIsChanEnabled+0x6a> @ imm = #0x46
;             regVal = CSL_REG32_FEXT( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_EN );
700aa7d2: 9805         	ldr	r0, [sp, #0x14]
700aa7d4: 6880         	ldr	r0, [r0, #0x8]
700aa7d6: 9903         	ldr	r1, [sp, #0xc]
700aa7d8: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aa7dc: f04f 4100    	mov.w	r1, #0x80000000
700aa7e0: 221f         	movs	r2, #0x1f
700aa7e2: f004 fb05    	bl	0x700aedf0 <CSL_REG32_FEXT_RAW> @ imm = #0x460a
700aa7e6: 9002         	str	r0, [sp, #0x8]
;             break;
700aa7e8: e01a         	b	0x700aa820 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x34
;             regVal = CSL_REG32_FEXT( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_EN );
700aa7ea: 9805         	ldr	r0, [sp, #0x14]
700aa7ec: 6900         	ldr	r0, [r0, #0x10]
700aa7ee: 9903         	ldr	r1, [sp, #0xc]
700aa7f0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aa7f4: f04f 4100    	mov.w	r1, #0x80000000
700aa7f8: 221f         	movs	r2, #0x1f
700aa7fa: f004 faf9    	bl	0x700aedf0 <CSL_REG32_FEXT_RAW> @ imm = #0x45f2
700aa7fe: 9002         	str	r0, [sp, #0x8]
;             break;
700aa800: e00e         	b	0x700aa820 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x1c
;             regVal = CSL_REG32_FEXT( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_EN );
700aa802: 9805         	ldr	r0, [sp, #0x14]
700aa804: 6980         	ldr	r0, [r0, #0x18]
700aa806: 9903         	ldr	r1, [sp, #0xc]
700aa808: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aa80c: f04f 4100    	mov.w	r1, #0x80000000
700aa810: 221f         	movs	r2, #0x1f
700aa812: f004 faed    	bl	0x700aedf0 <CSL_REG32_FEXT_RAW> @ imm = #0x45da
700aa816: 9002         	str	r0, [sp, #0x8]
;             break;
700aa818: e002         	b	0x700aa820 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x4
700aa81a: 2000         	movs	r0, #0x0
;             regVal = 0U;
700aa81c: 9002         	str	r0, [sp, #0x8]
;             break;
700aa81e: e7ff         	b	0x700aa820 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #-0x2
;     return ((regVal == 1U) ? (bool)true : (bool)false);
700aa820: 9802         	ldr	r0, [sp, #0x8]
700aa822: 3801         	subs	r0, #0x1
700aa824: fab0 f080    	clz	r0, r0
700aa828: 0940         	lsrs	r0, r0, #0x5
700aa82a: b006         	add	sp, #0x18
700aa82c: bd80         	pop	{r7, pc}
700aa82e: 0000         	movs	r0, r0

700aa830 <CSL_bcdmaChanOpIsValidChanIdx>:
; {
700aa830: b084         	sub	sp, #0x10
700aa832: 9003         	str	r0, [sp, #0xc]
700aa834: 9102         	str	r1, [sp, #0x8]
700aa836: 9201         	str	r2, [sp, #0x4]
700aa838: 2001         	movs	r0, #0x1
;     bool retVal = (bool)true;
700aa83a: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if( chanType == CSL_BCDMA_CHAN_TYPE_BLOCK_COPY )
700aa83e: 9802         	ldr	r0, [sp, #0x8]
700aa840: b958         	cbnz	r0, 0x700aa85a <CSL_bcdmaChanOpIsValidChanIdx+0x2a> @ imm = #0x16
700aa842: e7ff         	b	0x700aa844 <CSL_bcdmaChanOpIsValidChanIdx+0x14> @ imm = #-0x2
;         if( chanIdx > pCfg->bcChanCnt )
700aa844: 9801         	ldr	r0, [sp, #0x4]
700aa846: 9903         	ldr	r1, [sp, #0xc]
700aa848: 6a49         	ldr	r1, [r1, #0x24]
700aa84a: 4288         	cmp	r0, r1
700aa84c: d904         	bls	0x700aa858 <CSL_bcdmaChanOpIsValidChanIdx+0x28> @ imm = #0x8
700aa84e: e7ff         	b	0x700aa850 <CSL_bcdmaChanOpIsValidChanIdx+0x20> @ imm = #-0x2
700aa850: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700aa852: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700aa856: e7ff         	b	0x700aa858 <CSL_bcdmaChanOpIsValidChanIdx+0x28> @ imm = #-0x2
;     }
700aa858: e023         	b	0x700aa8a2 <CSL_bcdmaChanOpIsValidChanIdx+0x72> @ imm = #0x46
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700aa85a: 9802         	ldr	r0, [sp, #0x8]
700aa85c: 2802         	cmp	r0, #0x2
700aa85e: d10b         	bne	0x700aa878 <CSL_bcdmaChanOpIsValidChanIdx+0x48> @ imm = #0x16
700aa860: e7ff         	b	0x700aa862 <CSL_bcdmaChanOpIsValidChanIdx+0x32> @ imm = #-0x2
;         if( chanIdx > pCfg->splitRxChanCnt )
700aa862: 9801         	ldr	r0, [sp, #0x4]
700aa864: 9903         	ldr	r1, [sp, #0xc]
700aa866: 6a89         	ldr	r1, [r1, #0x28]
700aa868: 4288         	cmp	r0, r1
700aa86a: d904         	bls	0x700aa876 <CSL_bcdmaChanOpIsValidChanIdx+0x46> @ imm = #0x8
700aa86c: e7ff         	b	0x700aa86e <CSL_bcdmaChanOpIsValidChanIdx+0x3e> @ imm = #-0x2
700aa86e: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700aa870: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700aa874: e7ff         	b	0x700aa876 <CSL_bcdmaChanOpIsValidChanIdx+0x46> @ imm = #-0x2
;     }
700aa876: e013         	b	0x700aa8a0 <CSL_bcdmaChanOpIsValidChanIdx+0x70> @ imm = #0x26
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_TX )
700aa878: 9802         	ldr	r0, [sp, #0x8]
700aa87a: 2801         	cmp	r0, #0x1
700aa87c: d10b         	bne	0x700aa896 <CSL_bcdmaChanOpIsValidChanIdx+0x66> @ imm = #0x16
700aa87e: e7ff         	b	0x700aa880 <CSL_bcdmaChanOpIsValidChanIdx+0x50> @ imm = #-0x2
;         if( chanIdx > pCfg->splitTxChanCnt )
700aa880: 9801         	ldr	r0, [sp, #0x4]
700aa882: 9903         	ldr	r1, [sp, #0xc]
700aa884: 6ac9         	ldr	r1, [r1, #0x2c]
700aa886: 4288         	cmp	r0, r1
700aa888: d904         	bls	0x700aa894 <CSL_bcdmaChanOpIsValidChanIdx+0x64> @ imm = #0x8
700aa88a: e7ff         	b	0x700aa88c <CSL_bcdmaChanOpIsValidChanIdx+0x5c> @ imm = #-0x2
700aa88c: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700aa88e: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700aa892: e7ff         	b	0x700aa894 <CSL_bcdmaChanOpIsValidChanIdx+0x64> @ imm = #-0x2
;     }
700aa894: e003         	b	0x700aa89e <CSL_bcdmaChanOpIsValidChanIdx+0x6e> @ imm = #0x6
700aa896: 2000         	movs	r0, #0x0
;         retVal = (bool)false;
700aa898: f88d 0003    	strb.w	r0, [sp, #0x3]
700aa89c: e7ff         	b	0x700aa89e <CSL_bcdmaChanOpIsValidChanIdx+0x6e> @ imm = #-0x2
700aa89e: e7ff         	b	0x700aa8a0 <CSL_bcdmaChanOpIsValidChanIdx+0x70> @ imm = #-0x2
700aa8a0: e7ff         	b	0x700aa8a2 <CSL_bcdmaChanOpIsValidChanIdx+0x72> @ imm = #-0x2
;     return retVal;
700aa8a2: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aa8a6: f000 0001    	and	r0, r0, #0x1
700aa8aa: b004         	add	sp, #0x10
700aa8ac: 4770         	bx	lr
700aa8ae: 0000         	movs	r0, r0

700aa8b0 <CSL_bcdmaMapChanIdx>:
; {
700aa8b0: b084         	sub	sp, #0x10
700aa8b2: 9003         	str	r0, [sp, #0xc]
700aa8b4: 9102         	str	r1, [sp, #0x8]
700aa8b6: 9201         	str	r2, [sp, #0x4]
;     if( chanIdx < pCfg->bcChanCnt )
700aa8b8: 9802         	ldr	r0, [sp, #0x8]
700aa8ba: 9903         	ldr	r1, [sp, #0xc]
700aa8bc: 6a49         	ldr	r1, [r1, #0x24]
700aa8be: 4288         	cmp	r0, r1
700aa8c0: d206         	bhs	0x700aa8d0 <CSL_bcdmaMapChanIdx+0x20> @ imm = #0xc
700aa8c2: e7ff         	b	0x700aa8c4 <CSL_bcdmaMapChanIdx+0x14> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_BLOCK_COPY;
700aa8c4: 9901         	ldr	r1, [sp, #0x4]
700aa8c6: 2000         	movs	r0, #0x0
700aa8c8: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx;
700aa8ca: 9802         	ldr	r0, [sp, #0x8]
700aa8cc: 9000         	str	r0, [sp]
;     }
700aa8ce: e02b         	b	0x700aa928 <CSL_bcdmaMapChanIdx+0x78> @ imm = #0x56
;     else if( chanIdx < (pCfg->bcChanCnt + pCfg->splitTxChanCnt) )
700aa8d0: 9802         	ldr	r0, [sp, #0x8]
700aa8d2: 9a03         	ldr	r2, [sp, #0xc]
700aa8d4: 6a51         	ldr	r1, [r2, #0x24]
700aa8d6: 6ad2         	ldr	r2, [r2, #0x2c]
700aa8d8: 4411         	add	r1, r2
700aa8da: 4288         	cmp	r0, r1
700aa8dc: d209         	bhs	0x700aa8f2 <CSL_bcdmaMapChanIdx+0x42> @ imm = #0x12
700aa8de: e7ff         	b	0x700aa8e0 <CSL_bcdmaMapChanIdx+0x30> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_SPLIT_TX;
700aa8e0: 9901         	ldr	r1, [sp, #0x4]
700aa8e2: 2001         	movs	r0, #0x1
700aa8e4: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx - pCfg->bcChanCnt;
700aa8e6: 9802         	ldr	r0, [sp, #0x8]
700aa8e8: 9903         	ldr	r1, [sp, #0xc]
700aa8ea: 6a49         	ldr	r1, [r1, #0x24]
700aa8ec: 1a40         	subs	r0, r0, r1
700aa8ee: 9000         	str	r0, [sp]
;     }
700aa8f0: e019         	b	0x700aa926 <CSL_bcdmaMapChanIdx+0x76> @ imm = #0x32
;     else if( chanIdx < (pCfg->bcChanCnt + pCfg->splitTxChanCnt + pCfg->splitRxChanCnt) )
700aa8f2: 9802         	ldr	r0, [sp, #0x8]
700aa8f4: 9b03         	ldr	r3, [sp, #0xc]
700aa8f6: 6a59         	ldr	r1, [r3, #0x24]
700aa8f8: 6a9a         	ldr	r2, [r3, #0x28]
700aa8fa: 6adb         	ldr	r3, [r3, #0x2c]
700aa8fc: 4419         	add	r1, r3
700aa8fe: 4411         	add	r1, r2
700aa900: 4288         	cmp	r0, r1
700aa902: d20b         	bhs	0x700aa91c <CSL_bcdmaMapChanIdx+0x6c> @ imm = #0x16
700aa904: e7ff         	b	0x700aa906 <CSL_bcdmaMapChanIdx+0x56> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_SPLIT_RX;
700aa906: 9901         	ldr	r1, [sp, #0x4]
700aa908: 2002         	movs	r0, #0x2
700aa90a: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx - pCfg->bcChanCnt - pCfg->splitTxChanCnt;
700aa90c: 9802         	ldr	r0, [sp, #0x8]
700aa90e: 9903         	ldr	r1, [sp, #0xc]
700aa910: 6a4a         	ldr	r2, [r1, #0x24]
700aa912: 6ac9         	ldr	r1, [r1, #0x2c]
700aa914: 1a80         	subs	r0, r0, r2
700aa916: 1a40         	subs	r0, r0, r1
700aa918: 9000         	str	r0, [sp]
;     }
700aa91a: e003         	b	0x700aa924 <CSL_bcdmaMapChanIdx+0x74> @ imm = #0x6
700aa91c: f04f 30ff    	mov.w	r0, #0xffffffff
;         base0chanIdx = CSL_BCDMA_INVALID_CHANNEL_INDEX;
700aa920: 9000         	str	r0, [sp]
700aa922: e7ff         	b	0x700aa924 <CSL_bcdmaMapChanIdx+0x74> @ imm = #-0x2
700aa924: e7ff         	b	0x700aa926 <CSL_bcdmaMapChanIdx+0x76> @ imm = #-0x2
700aa926: e7ff         	b	0x700aa928 <CSL_bcdmaMapChanIdx+0x78> @ imm = #-0x2
;     return base0chanIdx;
700aa928: 9800         	ldr	r0, [sp]
700aa92a: b004         	add	sp, #0x10
700aa92c: 4770         	bx	lr
700aa92e: 0000         	movs	r0, r0

700aa930 <ClockP_getTimeUsec>:
; {
700aa930: b580         	push	{r7, lr}
700aa932: b08a         	sub	sp, #0x28
700aa934: 2000         	movs	r0, #0x0
;     uint64_t ts = 0U;
700aa936: 9009         	str	r0, [sp, #0x24]
700aa938: 9008         	str	r0, [sp, #0x20]
;     do {
700aa93a: e7ff         	b	0x700aa93c <ClockP_getTimeUsec+0xc> @ imm = #-0x2
;         ticks1 = gClockCtrl.ticks;
700aa93c: f245 1010    	movw	r0, #0x5110
700aa940: f2c7 0008    	movt	r0, #0x7008
700aa944: 9001         	str	r0, [sp, #0x4]
700aa946: 6801         	ldr	r1, [r0]
700aa948: 6842         	ldr	r2, [r0, #0x4]
700aa94a: 9205         	str	r2, [sp, #0x14]
700aa94c: 9104         	str	r1, [sp, #0x10]
;         timerCount = ClockP_getTimerCount(gClockCtrl.timerBaseAddr);
700aa94e: 6ac0         	ldr	r0, [r0, #0x2c]
700aa950: f004 ff6e    	bl	0x700af830 <ClockP_getTimerCount> @ imm = #0x4edc
700aa954: 9901         	ldr	r1, [sp, #0x4]
700aa956: 9007         	str	r0, [sp, #0x1c]
;         ticks2 = gClockCtrl.ticks;
700aa958: 6808         	ldr	r0, [r1]
700aa95a: 6849         	ldr	r1, [r1, #0x4]
700aa95c: 9103         	str	r1, [sp, #0xc]
700aa95e: 9002         	str	r0, [sp, #0x8]
;     } while (ticks1 != ticks2);
700aa960: e7ff         	b	0x700aa962 <ClockP_getTimeUsec+0x32> @ imm = #-0x2
700aa962: 9804         	ldr	r0, [sp, #0x10]
700aa964: 9905         	ldr	r1, [sp, #0x14]
700aa966: 9a02         	ldr	r2, [sp, #0x8]
700aa968: 9b03         	ldr	r3, [sp, #0xc]
700aa96a: 4059         	eors	r1, r3
700aa96c: ea80 0002    	eor.w	r0, r0, r2
700aa970: 4308         	orrs	r0, r1
700aa972: 2800         	cmp	r0, #0x0
700aa974: d1e2         	bne	0x700aa93c <ClockP_getTimeUsec+0xc> @ imm = #-0x3c
700aa976: e7ff         	b	0x700aa978 <ClockP_getTimeUsec+0x48> @ imm = #-0x2
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700aa978: 9a02         	ldr	r2, [sp, #0x8]
700aa97a: 9803         	ldr	r0, [sp, #0xc]
700aa97c: f245 1110    	movw	r1, #0x5110
700aa980: f2c7 0108    	movt	r1, #0x7008
700aa984: 688b         	ldr	r3, [r1, #0x8]
;                 (uint64_t)(((timerCount - gClockCtrl.timerReloadCount)*gClockCtrl.usecPerTick)/(MAX_TIMER_COUNT_VALUE - gClockCtrl.timerReloadCount))
700aa986: f8d1 c030    	ldr.w	r12, [r1, #0x30]
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700aa98a: fb00 f103    	mul	r1, r0, r3
;                 (uint64_t)(((timerCount - gClockCtrl.timerReloadCount)*gClockCtrl.usecPerTick)/(MAX_TIMER_COUNT_VALUE - gClockCtrl.timerReloadCount))
700aa98e: 9807         	ldr	r0, [sp, #0x1c]
700aa990: eba0 000c    	sub.w	r0, r0, r12
700aa994: 4358         	muls	r0, r3, r0
700aa996: ea6f 0c0c    	mvn.w	r12, r12
700aa99a: fbb0 f0fc    	udiv	r0, r0, r12
;              + (uint64_t) ( /* convert timer count to usecs */
700aa99e: fbe2 0103    	umlal	r0, r1, r2, r3
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700aa9a2: 9109         	str	r1, [sp, #0x24]
700aa9a4: 9008         	str	r0, [sp, #0x20]
;     return (ts);
700aa9a6: 9808         	ldr	r0, [sp, #0x20]
700aa9a8: 9909         	ldr	r1, [sp, #0x24]
700aa9aa: b00a         	add	sp, #0x28
700aa9ac: bd80         	pop	{r7, pc}
700aa9ae: 0000         	movs	r0, r0

700aa9b0 <UART_readData>:
; {
700aa9b0: b580         	push	{r7, lr}
700aa9b2: b086         	sub	sp, #0x18
700aa9b4: 9005         	str	r0, [sp, #0x14]
700aa9b6: 9104         	str	r1, [sp, #0x10]
700aa9b8: 2000         	movs	r0, #0x0
;     uint8_t             readIn = 0;
700aa9ba: f88d 000f    	strb.w	r0, [sp, #0xf]
;     uint32_t             rdSize = size;
700aa9be: 9804         	ldr	r0, [sp, #0x10]
700aa9c0: 9001         	str	r0, [sp, #0x4]
;     readSuccess = UART_getChar(hUart->baseAddr, &readIn);
700aa9c2: 9805         	ldr	r0, [sp, #0x14]
700aa9c4: 6800         	ldr	r0, [r0]
700aa9c6: f10d 010f    	add.w	r1, sp, #0xf
700aa9ca: f001 fbd1    	bl	0x700ac170 <UART_getChar> @ imm = #0x17a2
700aa9ce: 9002         	str	r0, [sp, #0x8]
;     while ((rdSize != 0U) && (readSuccess != 0U))
700aa9d0: e7ff         	b	0x700aa9d2 <UART_readData+0x22> @ imm = #-0x2
700aa9d2: 9901         	ldr	r1, [sp, #0x4]
700aa9d4: 2000         	movs	r0, #0x0
700aa9d6: 9000         	str	r0, [sp]
700aa9d8: b131         	cbz	r1, 0x700aa9e8 <UART_readData+0x38> @ imm = #0xc
700aa9da: e7ff         	b	0x700aa9dc <UART_readData+0x2c> @ imm = #-0x2
700aa9dc: 9802         	ldr	r0, [sp, #0x8]
700aa9de: 2800         	cmp	r0, #0x0
700aa9e0: bf18         	it	ne
700aa9e2: 2001         	movne	r0, #0x1
700aa9e4: 9000         	str	r0, [sp]
700aa9e6: e7ff         	b	0x700aa9e8 <UART_readData+0x38> @ imm = #-0x2
700aa9e8: 9800         	ldr	r0, [sp]
;     while ((rdSize != 0U) && (readSuccess != 0U))
700aa9ea: 07c0         	lsls	r0, r0, #0x1f
700aa9ec: b1e0         	cbz	r0, 0x700aaa28 <UART_readData+0x78> @ imm = #0x38
700aa9ee: e7ff         	b	0x700aa9f0 <UART_readData+0x40> @ imm = #-0x2
;         *(uint8_t *)hUart->readBuf = readIn;
700aa9f0: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700aa9f4: 9905         	ldr	r1, [sp, #0x14]
700aa9f6: 6949         	ldr	r1, [r1, #0x14]
700aa9f8: 7008         	strb	r0, [r1]
;         hUart->readBuf = (uint8_t *)hUart->readBuf + 1U;
700aa9fa: 9905         	ldr	r1, [sp, #0x14]
700aa9fc: 6948         	ldr	r0, [r1, #0x14]
700aa9fe: 3001         	adds	r0, #0x1
700aaa00: 6148         	str	r0, [r1, #0x14]
;         hUart->readCount++;
700aaa02: 9905         	ldr	r1, [sp, #0x14]
700aaa04: 6988         	ldr	r0, [r1, #0x18]
700aaa06: 3001         	adds	r0, #0x1
700aaa08: 6188         	str	r0, [r1, #0x18]
;         rdSize--;
700aaa0a: 9801         	ldr	r0, [sp, #0x4]
700aaa0c: 3801         	subs	r0, #0x1
700aaa0e: 9001         	str	r0, [sp, #0x4]
;         if (rdSize != 0U)
700aaa10: 9801         	ldr	r0, [sp, #0x4]
700aaa12: b140         	cbz	r0, 0x700aaa26 <UART_readData+0x76> @ imm = #0x10
700aaa14: e7ff         	b	0x700aaa16 <UART_readData+0x66> @ imm = #-0x2
;             readSuccess = UART_getChar(hUart->baseAddr, &readIn);
700aaa16: 9805         	ldr	r0, [sp, #0x14]
700aaa18: 6800         	ldr	r0, [r0]
700aaa1a: f10d 010f    	add.w	r1, sp, #0xf
700aaa1e: f001 fba7    	bl	0x700ac170 <UART_getChar> @ imm = #0x174e
700aaa22: 9002         	str	r0, [sp, #0x8]
;         }
700aaa24: e7ff         	b	0x700aaa26 <UART_readData+0x76> @ imm = #-0x2
;     while ((rdSize != 0U) && (readSuccess != 0U))
700aaa26: e7d4         	b	0x700aa9d2 <UART_readData+0x22> @ imm = #-0x58
;     return (rdSize);
700aaa28: 9801         	ldr	r0, [sp, #0x4]
700aaa2a: b006         	add	sp, #0x18
700aaa2c: bd80         	pop	{r7, pc}
700aaa2e: 0000         	movs	r0, r0

700aaa30 <_DebugP_assert>:
; {
700aaa30: b5b0         	push	{r4, r5, r7, lr}
700aaa32: b08e         	sub	sp, #0x38
700aaa34: f8dd c048    	ldr.w	r12, [sp, #0x48]
700aaa38: 900d         	str	r0, [sp, #0x34]
700aaa3a: 910c         	str	r1, [sp, #0x30]
700aaa3c: 920b         	str	r2, [sp, #0x2c]
700aaa3e: 930a         	str	r3, [sp, #0x28]
;     if(expression==0)
700aaa40: 980d         	ldr	r0, [sp, #0x34]
700aaa42: bb88         	cbnz	r0, 0x700aaaa8 <_DebugP_assert+0x78> @ imm = #0x62
700aaa44: e7ff         	b	0x700aaa46 <_DebugP_assert+0x16> @ imm = #-0x2
700aaa46: 2001         	movs	r0, #0x1
;         volatile uint32_t assert_loop = 1;
700aaa48: 9004         	str	r0, [sp, #0x10]
700aaa4a: 9009         	str	r0, [sp, #0x24]
;         uint64_t curTime = ClockP_getTimeUsec();
700aaa4c: f7ff ff70    	bl	0x700aa930 <ClockP_getTimeUsec> @ imm = #-0x120
700aaa50: 9107         	str	r1, [sp, #0x1c]
700aaa52: 9006         	str	r0, [sp, #0x18]
;         DebugP_log("ASSERT: %d.%ds: %s:%s:%d: %s failed !!!\r\n",
700aaa54: 9806         	ldr	r0, [sp, #0x18]
700aaa56: 9907         	ldr	r1, [sp, #0x1c]
700aaa58: f244 2240    	movw	r2, #0x4240
700aaa5c: f2c0 020f    	movt	r2, #0xf
700aaa60: 2300         	movs	r3, #0x0
700aaa62: f004 ea68    	blx	0x700aef34 <__aeabi_uldivmod> @ imm = #0x44d0
700aaa66: 4603         	mov	r3, r0
700aaa68: 9804         	ldr	r0, [sp, #0x10]
700aaa6a: 9305         	str	r3, [sp, #0x14]
700aaa6c: 4613         	mov	r3, r2
700aaa6e: 9a05         	ldr	r2, [sp, #0x14]
700aaa70: 990c         	ldr	r1, [sp, #0x30]
700aaa72: f8dd e02c    	ldr.w	lr, [sp, #0x2c]
700aaa76: 9c0a         	ldr	r4, [sp, #0x28]
700aaa78: 9d12         	ldr	r5, [sp, #0x48]
700aaa7a: 46ec         	mov	r12, sp
700aaa7c: f8cc 500c    	str.w	r5, [r12, #0xc]
700aaa80: f8cc 4008    	str.w	r4, [r12, #0x8]
700aaa84: f8cc e004    	str.w	lr, [r12, #0x4]
700aaa88: f8cc 1000    	str.w	r1, [r12]
700aaa8c: f641 011c    	movw	r1, #0x181c
700aaa90: f2c7 010b    	movt	r1, #0x700b
700aaa94: f7ff f814    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #-0xfd8
;         (void) HwiP_disable();
700aaa98: f005 ede2    	blx	0x700b0660 <HwiP_disable> @ imm = #0x5bc4
;         while(assert_loop!= 0U)
700aaa9c: e7ff         	b	0x700aaa9e <_DebugP_assert+0x6e> @ imm = #-0x2
700aaa9e: 9809         	ldr	r0, [sp, #0x24]
700aaaa0: b108         	cbz	r0, 0x700aaaa6 <_DebugP_assert+0x76> @ imm = #0x2
700aaaa2: e7ff         	b	0x700aaaa4 <_DebugP_assert+0x74> @ imm = #-0x2
700aaaa4: e7fb         	b	0x700aaa9e <_DebugP_assert+0x6e> @ imm = #-0xa
;     }
700aaaa6: e7ff         	b	0x700aaaa8 <_DebugP_assert+0x78> @ imm = #-0x2
; }
700aaaa8: b00e         	add	sp, #0x38
700aaaaa: bdb0         	pop	{r4, r5, r7, pc}
700aaaac: 0000         	movs	r0, r0
700aaaae: 0000         	movs	r0, r0

700aaab0 <UART_Params_init>:
; {
700aaab0: b082         	sub	sp, #0x8
700aaab2: 9001         	str	r0, [sp, #0x4]
;     if(prms != NULL)
700aaab4: 9801         	ldr	r0, [sp, #0x4]
700aaab6: b3b0         	cbz	r0, 0x700aab26 <UART_Params_init+0x76> @ imm = #0x6c
700aaab8: e7ff         	b	0x700aaaba <UART_Params_init+0xa> @ imm = #-0x2
;         prms->baudRate           = 115200U;
700aaaba: 9901         	ldr	r1, [sp, #0x4]
700aaabc: f44f 30e1    	mov.w	r0, #0x1c200
700aaac0: 6008         	str	r0, [r1]
;         prms->dataLength         = UART_LEN_8;
700aaac2: 9901         	ldr	r1, [sp, #0x4]
700aaac4: 2003         	movs	r0, #0x3
700aaac6: 6048         	str	r0, [r1, #0x4]
;         prms->stopBits           = UART_STOPBITS_1;
700aaac8: 9901         	ldr	r1, [sp, #0x4]
700aaaca: 2000         	movs	r0, #0x0
700aaacc: 9000         	str	r0, [sp]
700aaace: 6088         	str	r0, [r1, #0x8]
;         prms->parityType         = UART_PARITY_NONE;
700aaad0: 9901         	ldr	r1, [sp, #0x4]
700aaad2: 60c8         	str	r0, [r1, #0xc]
;         prms->readMode           = UART_TRANSFER_MODE_BLOCKING;
700aaad4: 9901         	ldr	r1, [sp, #0x4]
700aaad6: 6108         	str	r0, [r1, #0x10]
;         prms->readReturnMode     = UART_READ_RETURN_MODE_FULL;
700aaad8: 9901         	ldr	r1, [sp, #0x4]
700aaada: 6148         	str	r0, [r1, #0x14]
;         prms->writeMode          = UART_TRANSFER_MODE_BLOCKING;
700aaadc: 9901         	ldr	r1, [sp, #0x4]
700aaade: 6188         	str	r0, [r1, #0x18]
;         prms->readCallbackFxn    = NULL;
700aaae0: 9901         	ldr	r1, [sp, #0x4]
700aaae2: 61c8         	str	r0, [r1, #0x1c]
;         prms->writeCallbackFxn   = NULL;
700aaae4: 9901         	ldr	r1, [sp, #0x4]
700aaae6: 6208         	str	r0, [r1, #0x20]
;         prms->hwFlowControl      = FALSE;
700aaae8: 9901         	ldr	r1, [sp, #0x4]
700aaaea: 6248         	str	r0, [r1, #0x24]
;         prms->hwFlowControlThr   = UART_RXTRIGLVL_16;
700aaaec: 9a01         	ldr	r2, [sp, #0x4]
700aaaee: 2110         	movs	r1, #0x10
700aaaf0: 6291         	str	r1, [r2, #0x28]
;         prms->intrNum            = 0xFFFF;
700aaaf2: 9a01         	ldr	r2, [sp, #0x4]
700aaaf4: f64f 71ff    	movw	r1, #0xffff
700aaaf8: 6311         	str	r1, [r2, #0x30]
;         prms->transferMode       = UART_CONFIG_MODE_INTERRUPT;
700aaafa: 9a01         	ldr	r2, [sp, #0x4]
700aaafc: 2101         	movs	r1, #0x1
700aaafe: 62d1         	str	r1, [r2, #0x2c]
;         prms->intrPriority       = 4U;
700aab00: 9a01         	ldr	r2, [sp, #0x4]
700aab02: 2104         	movs	r1, #0x4
700aab04: f882 1034    	strb.w	r1, [r2, #0x34]
;         prms->skipIntrReg        = FALSE;
700aab08: 9901         	ldr	r1, [sp, #0x4]
700aab0a: 6388         	str	r0, [r1, #0x38]
;         prms->uartDmaIndex       = -1;
700aab0c: 9a01         	ldr	r2, [sp, #0x4]
700aab0e: f04f 31ff    	mov.w	r1, #0xffffffff
700aab12: 63d1         	str	r1, [r2, #0x3c]
;         prms->operMode           = UART_OPER_MODE_16X;
700aab14: 9901         	ldr	r1, [sp, #0x4]
700aab16: 6408         	str	r0, [r1, #0x40]
;         prms->rxTrigLvl          = UART_RXTRIGLVL_8;
700aab18: 9901         	ldr	r1, [sp, #0x4]
700aab1a: 2008         	movs	r0, #0x8
700aab1c: 6448         	str	r0, [r1, #0x44]
;         prms->txTrigLvl          = UART_TXTRIGLVL_32;
700aab1e: 9901         	ldr	r1, [sp, #0x4]
700aab20: 2020         	movs	r0, #0x20
700aab22: 6488         	str	r0, [r1, #0x48]
;     }
700aab24: e7ff         	b	0x700aab26 <UART_Params_init+0x76> @ imm = #-0x2
; }
700aab26: b002         	add	sp, #0x8
700aab28: 4770         	bx	lr
700aab2a: 0000         	movs	r0, r0
700aab2c: 0000         	movs	r0, r0
700aab2e: 0000         	movs	r0, r0

700aab30 <main_task>:
; {
700aab30: b5b0         	push	{r4, r5, r7, lr}
700aab32: b086         	sub	sp, #0x18
;    printf("Starting Thread-Metric tests...\r\n");
700aab34: f641 1143    	movw	r1, #0x1943
700aab38: 2001         	movs	r0, #0x1
700aab3a: f2c7 010b    	movt	r1, #0x700b
700aab3e: 2501         	movs	r5, #0x1
700aab40: f7fe ffbe    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #-0x1084
;    test_interrupt_handler = tm_isr_message_handler;
700aab44: f644 70f1    	movw	r0, #0x4ff1
700aab48: f242 61c0    	movw	r1, #0x26c0
700aab4c: f2c7 000a    	movt	r0, #0x700a
700aab50: ac01         	add	r4, sp, #0x4
700aab52: f2c7 010b    	movt	r1, #0x700b
700aab56: 6008         	str	r0, [r1]
;    HwiP_Params_init(&hwiParams);
700aab58: 4620         	mov	r0, r4
700aab5a: f005 f879    	bl	0x700afc50 <HwiP_Params_init> @ imm = #0x50f2
;    hwiParams.callback = tm_interrupt_handler; /* Interrupt handler */
700aab5e: f24f 7161    	movw	r1, #0xf761
700aab62: 200a         	movs	r0, #0xa
700aab64: f2c7 010a    	movt	r1, #0x700a
;    hwiParams.priority = 1;                    /* Set a valid priority (lower is higher priority) */
700aab68: f8ad 5012    	strh.w	r5, [sp, #0x12]
;    hwiParams.intNum = SOFTWARE_INTERRUPT_ID;  /* Chosen interrupt ID */
700aab6c: e9cd 0101    	strd	r0, r1, [sp, #4]
;    if (HwiP_construct(&hwiObj, &hwiParams) != SystemP_SUCCESS)
700aab70: f245 1070    	movw	r0, #0x5170
700aab74: f2c7 0008    	movt	r0, #0x7008
700aab78: 4621         	mov	r1, r4
700aab7a: f005 f881    	bl	0x700afc80 <HwiP_construct> @ imm = #0x5102
700aab7e: b140         	cbz	r0, 0x700aab92 <main_task+0x62> @ imm = #0x10
;       printf("Failed to register interrupt\r\n");
700aab80: f641 214a    	movw	r1, #0x1a4a
700aab84: 2001         	movs	r0, #0x1
700aab86: f2c7 010b    	movt	r1, #0x700b
700aab8a: f7fe ff99    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #-0x10ce
700aab8e: bf00         	nop
;       while (1)
700aab90: e7fe         	b	0x700aab90 <main_task+0x60> @ imm = #-0x4
;    HwiP_enableInt(SOFTWARE_INTERRUPT_ID);
700aab92: 200a         	movs	r0, #0xa
700aab94: f004 ffb4    	bl	0x700afb00 <HwiP_enableInt> @ imm = #0x4f68
;    HwiP_enable();
700aab98: f005 ed72    	blx	0x700b0680 <HwiP_enable> @ imm = #0x5ae4
;    main_thread_locking_test();
700aab9c: f004 fdc0    	bl	0x700af720 <main_thread_locking_test> @ imm = #0x4b80
;    vTaskDelete(NULL);
700aaba0: 2000         	movs	r0, #0x0
700aaba2: f7fb fb2d    	bl	0x700a6200 <vTaskDelete> @ imm = #-0x49a6
; }
700aaba6: b006         	add	sp, #0x18
700aaba8: bdb0         	pop	{r4, r5, r7, pc}
700aabaa: 0000         	movs	r0, r0

700aabac <snprintf>:
700aabac: e24dd004     	sub	sp, sp, #4
700aabb0: e92d4070     	push	{r4, r5, r6, lr}
700aabb4: e24dd01c     	sub	sp, sp, #28
700aabb8: e1a04001     	mov	r4, r1
700aabbc: e3510000     	cmp	r1, #0
700aabc0: 12411001     	subne	r1, r1, #1
700aabc4: e58d302c     	str	r3, [sp, #0x2c]
700aabc8: e59f3050     	ldr	r3, [pc, #0x50]         @ 0x700aac20 <snprintf+0x74>
700aabcc: e3a06000     	mov	r6, #0
700aabd0: e59f5044     	ldr	r5, [pc, #0x44]         @ 0x700aac1c <snprintf+0x70>
700aabd4: e58d2014     	str	r2, [sp, #0x14]
700aabd8: e28d2008     	add	r2, sp, #8
700aabdc: e58d100c     	str	r1, [sp, #0xc]
700aabe0: e28d102c     	add	r1, sp, #44
700aabe4: e58d0008     	str	r0, [sp, #0x8]
700aabe8: e28d0014     	add	r0, sp, #20
700aabec: e58d6010     	str	r6, [sp, #0x10]
700aabf0: e58d1018     	str	r1, [sp, #0x18]
700aabf4: e58d5000     	str	r5, [sp]
700aabf8: ebffb9a0     	bl	0x70099280 <__TI_printfi_nofloat> @ imm = #-0x11980
700aabfc: e3540000     	cmp	r4, #0
700aac00: 0a000001     	beq	0x700aac0c <snprintf+0x60> @ imm = #0x4
700aac04: e59d1008     	ldr	r1, [sp, #0x8]
700aac08: e5c16000     	strb	r6, [r1]
700aac0c: e28dd01c     	add	sp, sp, #28
700aac10: e8bd4070     	pop	{r4, r5, r6, lr}
700aac14: e28dd004     	add	sp, sp, #4
700aac18: e12fff1e     	bx	lr
700aac1c: 88 c8 0a 70  	.word	0x700ac888
700aac20: e0 e5 0a 70  	.word	0x700ae5e0
700aac24: 00 00 00 00  	.word	0x00000000
700aac28: 00 00 00 00  	.word	0x00000000
700aac2c: 00 00 00 00  	.word	0x00000000

700aac30 <xTimerCreateTimerTask>:
;     {
700aac30: b580         	push	{r7, lr}
700aac32: b088         	sub	sp, #0x20
700aac34: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
700aac36: 9007         	str	r0, [sp, #0x1c]
;         prvCheckForValidListAndQueue();
700aac38: f7fd fe2a    	bl	0x700a8890 <prvCheckForValidListAndQueue> @ imm = #-0x23ac
;         if( xTimerQueue != NULL )
700aac3c: f242 7008    	movw	r0, #0x2708
700aac40: f2c7 000b    	movt	r0, #0x700b
700aac44: 6800         	ldr	r0, [r0]
700aac46: b358         	cbz	r0, 0x700aaca0 <xTimerCreateTimerTask+0x70> @ imm = #0x56
700aac48: e7ff         	b	0x700aac4a <xTimerCreateTimerTask+0x1a> @ imm = #-0x2
700aac4a: 2000         	movs	r0, #0x0
;                     StaticTask_t * pxTimerTaskTCBBuffer = NULL;
700aac4c: 9003         	str	r0, [sp, #0xc]
700aac4e: 9006         	str	r0, [sp, #0x18]
;                     StackType_t * pxTimerTaskStackBuffer = NULL;
700aac50: 9005         	str	r0, [sp, #0x14]
700aac52: a806         	add	r0, sp, #0x18
700aac54: a905         	add	r1, sp, #0x14
700aac56: aa04         	add	r2, sp, #0x10
;                     vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
700aac58: f003 feea    	bl	0x700aea30 <vApplicationGetTimerTaskMemory> @ imm = #0x3dd4
700aac5c: 9b03         	ldr	r3, [sp, #0xc]
;                                                           ulTimerTaskStackSize,
700aac5e: 9a04         	ldr	r2, [sp, #0x10]
;                                                           pxTimerTaskStackBuffer,
700aac60: 9805         	ldr	r0, [sp, #0x14]
;                                                           pxTimerTaskTCBBuffer );
700aac62: f8dd c018    	ldr.w	r12, [sp, #0x18]
;                     xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,
700aac66: 4669         	mov	r1, sp
700aac68: f8c1 c008    	str.w	r12, [r1, #0x8]
700aac6c: 6048         	str	r0, [r1, #0x4]
700aac6e: 201f         	movs	r0, #0x1f
700aac70: 6008         	str	r0, [r1]
700aac72: f24f 2011    	movw	r0, #0xf211
700aac76: f2c7 000a    	movt	r0, #0x700a
700aac7a: f242 11ce    	movw	r1, #0x21ce
700aac7e: f2c7 010b    	movt	r1, #0x700b
700aac82: f000 fa55    	bl	0x700ab130 <xTaskCreateStatic> @ imm = #0x4aa
700aac86: 4601         	mov	r1, r0
700aac88: f242 700c    	movw	r0, #0x270c
700aac8c: f2c7 000b    	movt	r0, #0x700b
700aac90: 6001         	str	r1, [r0]
;                     if( xTimerTaskHandle != NULL )
700aac92: 6800         	ldr	r0, [r0]
700aac94: b118         	cbz	r0, 0x700aac9e <xTimerCreateTimerTask+0x6e> @ imm = #0x6
700aac96: e7ff         	b	0x700aac98 <xTimerCreateTimerTask+0x68> @ imm = #-0x2
700aac98: 2001         	movs	r0, #0x1
;                         xReturn = pdPASS;
700aac9a: 9007         	str	r0, [sp, #0x1c]
;                     }
700aac9c: e7ff         	b	0x700aac9e <xTimerCreateTimerTask+0x6e> @ imm = #-0x2
;         }
700aac9e: e000         	b	0x700aaca2 <xTimerCreateTimerTask+0x72> @ imm = #0x0
700aaca0: e7ff         	b	0x700aaca2 <xTimerCreateTimerTask+0x72> @ imm = #-0x2
;         return xReturn;
700aaca2: 9807         	ldr	r0, [sp, #0x1c]
700aaca4: b008         	add	sp, #0x20
700aaca6: bd80         	pop	{r7, pc}
		...

700aacb0 <CSL_bcdmaChanOpClearError>:
; {
700aacb0: b580         	push	{r7, lr}
700aacb2: b086         	sub	sp, #0x18
700aacb4: 9005         	str	r0, [sp, #0x14]
700aacb6: 9104         	str	r1, [sp, #0x10]
700aacb8: 9203         	str	r2, [sp, #0xc]
700aacba: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700aacbc: 9002         	str	r0, [sp, #0x8]
;     switch( chanType )
700aacbe: 9804         	ldr	r0, [sp, #0x10]
700aacc0: 9001         	str	r0, [sp, #0x4]
700aacc2: b140         	cbz	r0, 0x700aacd6 <CSL_bcdmaChanOpClearError+0x26> @ imm = #0x10
700aacc4: e7ff         	b	0x700aacc6 <CSL_bcdmaChanOpClearError+0x16> @ imm = #-0x2
700aacc6: 9801         	ldr	r0, [sp, #0x4]
700aacc8: 2801         	cmp	r0, #0x1
700aacca: d00f         	beq	0x700aacec <CSL_bcdmaChanOpClearError+0x3c> @ imm = #0x1e
700aaccc: e7ff         	b	0x700aacce <CSL_bcdmaChanOpClearError+0x1e> @ imm = #-0x2
700aacce: 9801         	ldr	r0, [sp, #0x4]
700aacd0: 2802         	cmp	r0, #0x2
700aacd2: d016         	beq	0x700aad02 <CSL_bcdmaChanOpClearError+0x52> @ imm = #0x2c
700aacd4: e020         	b	0x700aad18 <CSL_bcdmaChanOpClearError+0x68> @ imm = #0x40
;             CSL_REG32_FINS( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700aacd6: 9805         	ldr	r0, [sp, #0x14]
700aacd8: 6880         	ldr	r0, [r0, #0x8]
700aacda: 9903         	ldr	r1, [sp, #0xc]
700aacdc: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aace0: 2101         	movs	r1, #0x1
700aace2: 2300         	movs	r3, #0x0
700aace4: 461a         	mov	r2, r3
700aace6: f003 f99b    	bl	0x700ae020 <CSL_REG32_FINS_RAW> @ imm = #0x3336
;             break;
700aacea: e019         	b	0x700aad20 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x32
;             CSL_REG32_FINS( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700aacec: 9805         	ldr	r0, [sp, #0x14]
700aacee: 6900         	ldr	r0, [r0, #0x10]
700aacf0: 9903         	ldr	r1, [sp, #0xc]
700aacf2: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aacf6: 2101         	movs	r1, #0x1
700aacf8: 2300         	movs	r3, #0x0
700aacfa: 461a         	mov	r2, r3
700aacfc: f003 f990    	bl	0x700ae020 <CSL_REG32_FINS_RAW> @ imm = #0x3320
;             break;
700aad00: e00e         	b	0x700aad20 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x1c
;             CSL_REG32_FINS( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700aad02: 9805         	ldr	r0, [sp, #0x14]
700aad04: 6980         	ldr	r0, [r0, #0x18]
700aad06: 9903         	ldr	r1, [sp, #0xc]
700aad08: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aad0c: 2101         	movs	r1, #0x1
700aad0e: 2300         	movs	r3, #0x0
700aad10: 461a         	mov	r2, r3
700aad12: f003 f985    	bl	0x700ae020 <CSL_REG32_FINS_RAW> @ imm = #0x330a
;             break;
700aad16: e003         	b	0x700aad20 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x6
700aad18: f06f 0001    	mvn	r0, #0x1
;             retVal = CSL_EBADARGS;
700aad1c: 9002         	str	r0, [sp, #0x8]
;             break;
700aad1e: e7ff         	b	0x700aad20 <CSL_bcdmaChanOpClearError+0x70> @ imm = #-0x2
;     return retVal;
700aad20: 9802         	ldr	r0, [sp, #0x8]
700aad22: b006         	add	sp, #0x18
700aad24: bd80         	pop	{r7, pc}
		...
700aad2e: 0000         	movs	r0, r0

700aad30 <CSL_bcdmaDoChanOp>:
; {
700aad30: b580         	push	{r7, lr}
700aad32: b088         	sub	sp, #0x20
700aad34: 9007         	str	r0, [sp, #0x1c]
700aad36: 9106         	str	r1, [sp, #0x18]
700aad38: 9205         	str	r2, [sp, #0x14]
700aad3a: 9304         	str	r3, [sp, #0x10]
700aad3c: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t retVal = CSL_EFAIL;
700aad40: 9003         	str	r0, [sp, #0xc]
;     if( pCfg == NULL )
700aad42: 9807         	ldr	r0, [sp, #0x1c]
700aad44: b920         	cbnz	r0, 0x700aad50 <CSL_bcdmaDoChanOp+0x20> @ imm = #0x8
700aad46: e7ff         	b	0x700aad48 <CSL_bcdmaDoChanOp+0x18> @ imm = #-0x2
700aad48: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700aad4c: 9003         	str	r0, [sp, #0xc]
;     }
700aad4e: e027         	b	0x700aada0 <CSL_bcdmaDoChanOp+0x70> @ imm = #0x4e
;         if( (pCfg->bcChanCnt == (uint32_t)0U) || (pCfg->splitTxChanCnt == (uint32_t)0U) || (pCfg->splitRxChanCnt == (uint32_t)0U) ) {
700aad50: 9807         	ldr	r0, [sp, #0x1c]
700aad52: 6a40         	ldr	r0, [r0, #0x24]
700aad54: b140         	cbz	r0, 0x700aad68 <CSL_bcdmaDoChanOp+0x38> @ imm = #0x10
700aad56: e7ff         	b	0x700aad58 <CSL_bcdmaDoChanOp+0x28> @ imm = #-0x2
700aad58: 9807         	ldr	r0, [sp, #0x1c]
700aad5a: 6ac0         	ldr	r0, [r0, #0x2c]
700aad5c: b120         	cbz	r0, 0x700aad68 <CSL_bcdmaDoChanOp+0x38> @ imm = #0x8
700aad5e: e7ff         	b	0x700aad60 <CSL_bcdmaDoChanOp+0x30> @ imm = #-0x2
700aad60: 9807         	ldr	r0, [sp, #0x1c]
700aad62: 6a80         	ldr	r0, [r0, #0x28]
700aad64: b920         	cbnz	r0, 0x700aad70 <CSL_bcdmaDoChanOp+0x40> @ imm = #0x8
700aad66: e7ff         	b	0x700aad68 <CSL_bcdmaDoChanOp+0x38> @ imm = #-0x2
;             CSL_bcdmaGetCfg( pCfg );
700aad68: 9807         	ldr	r0, [sp, #0x1c]
700aad6a: f7ff f981    	bl	0x700aa070 <CSL_bcdmaGetCfg> @ imm = #-0xcfe
;         }
700aad6e: e7ff         	b	0x700aad70 <CSL_bcdmaDoChanOp+0x40> @ imm = #-0x2
;         base0chanIdx = CSL_bcdmaMapChanIdx( pCfg, chanIdx, &chanType );
700aad70: 9807         	ldr	r0, [sp, #0x1c]
700aad72: 9905         	ldr	r1, [sp, #0x14]
700aad74: aa01         	add	r2, sp, #0x4
700aad76: f7ff fd9b    	bl	0x700aa8b0 <CSL_bcdmaMapChanIdx> @ imm = #-0x4ca
700aad7a: 9002         	str	r0, [sp, #0x8]
;         if( base0chanIdx != CSL_BCDMA_INVALID_CHANNEL_INDEX )
700aad7c: 9802         	ldr	r0, [sp, #0x8]
700aad7e: 3001         	adds	r0, #0x1
700aad80: b168         	cbz	r0, 0x700aad9e <CSL_bcdmaDoChanOp+0x6e> @ imm = #0x1a
700aad82: e7ff         	b	0x700aad84 <CSL_bcdmaDoChanOp+0x54> @ imm = #-0x2
;             retVal = CSL_bcdmaChanOp( pCfg, chanOp, chanType, base0chanIdx, pOpData );
700aad84: 9807         	ldr	r0, [sp, #0x1c]
700aad86: 9906         	ldr	r1, [sp, #0x18]
700aad88: 9a01         	ldr	r2, [sp, #0x4]
700aad8a: 9b02         	ldr	r3, [sp, #0x8]
700aad8c: f8dd c010    	ldr.w	r12, [sp, #0x10]
700aad90: 46ee         	mov	lr, sp
700aad92: f8ce c000    	str.w	r12, [lr]
700aad96: f7f6 fca3    	bl	0x700a16e0 <CSL_bcdmaChanOp> @ imm = #-0x96ba
700aad9a: 9003         	str	r0, [sp, #0xc]
;         }
700aad9c: e7ff         	b	0x700aad9e <CSL_bcdmaDoChanOp+0x6e> @ imm = #-0x2
700aad9e: e7ff         	b	0x700aada0 <CSL_bcdmaDoChanOp+0x70> @ imm = #-0x2
;     return retVal;
700aada0: 9803         	ldr	r0, [sp, #0xc]
700aada2: b008         	add	sp, #0x20
700aada4: bd80         	pop	{r7, pc}
		...
700aadae: 0000         	movs	r0, r0

700aadb0 <Udma_chGetCqRingHandle>:
; {
700aadb0: b085         	sub	sp, #0x14
700aadb2: 9004         	str	r0, [sp, #0x10]
700aadb4: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700aadb6: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandle     cqRing = (Udma_RingHandle) NULL_PTR;
700aadb8: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700aadba: 9804         	ldr	r0, [sp, #0x10]
700aadbc: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700aadbe: 9800         	ldr	r0, [sp]
700aadc0: b150         	cbz	r0, 0x700aadd8 <Udma_chGetCqRingHandle+0x28> @ imm = #0x14
700aadc2: e7ff         	b	0x700aadc4 <Udma_chGetCqRingHandle+0x14> @ imm = #-0x2
700aadc4: 9800         	ldr	r0, [sp]
700aadc6: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700aadca: f64a 31cd    	movw	r1, #0xabcd
700aadce: f6ca 31dc    	movt	r1, #0xabdc
700aadd2: 4288         	cmp	r0, r1
700aadd4: d004         	beq	0x700aade0 <Udma_chGetCqRingHandle+0x30> @ imm = #0x8
700aadd6: e7ff         	b	0x700aadd8 <Udma_chGetCqRingHandle+0x28> @ imm = #-0x2
700aadd8: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700aaddc: 9003         	str	r0, [sp, #0xc]
;     }
700aadde: e7ff         	b	0x700aade0 <Udma_chGetCqRingHandle+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aade0: 9803         	ldr	r0, [sp, #0xc]
700aade2: b9a8         	cbnz	r0, 0x700aae10 <Udma_chGetCqRingHandle+0x60> @ imm = #0x2a
700aade4: e7ff         	b	0x700aade6 <Udma_chGetCqRingHandle+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700aade6: 9800         	ldr	r0, [sp]
700aade8: 6e80         	ldr	r0, [r0, #0x68]
700aadea: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700aadec: 9801         	ldr	r0, [sp, #0x4]
700aadee: b150         	cbz	r0, 0x700aae06 <Udma_chGetCqRingHandle+0x56> @ imm = #0x14
700aadf0: e7ff         	b	0x700aadf2 <Udma_chGetCqRingHandle+0x42> @ imm = #-0x2
700aadf2: 9801         	ldr	r0, [sp, #0x4]
700aadf4: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700aadf8: f64a 31cd    	movw	r1, #0xabcd
700aadfc: f6ca 31dc    	movt	r1, #0xabdc
700aae00: 4288         	cmp	r0, r1
700aae02: d004         	beq	0x700aae0e <Udma_chGetCqRingHandle+0x5e> @ imm = #0x8
700aae04: e7ff         	b	0x700aae06 <Udma_chGetCqRingHandle+0x56> @ imm = #-0x2
700aae06: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700aae0a: 9003         	str	r0, [sp, #0xc]
;         }
700aae0c: e7ff         	b	0x700aae0e <Udma_chGetCqRingHandle+0x5e> @ imm = #-0x2
;     }
700aae0e: e7ff         	b	0x700aae10 <Udma_chGetCqRingHandle+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aae10: 9803         	ldr	r0, [sp, #0xc]
700aae12: b928         	cbnz	r0, 0x700aae20 <Udma_chGetCqRingHandle+0x70> @ imm = #0xa
700aae14: e7ff         	b	0x700aae16 <Udma_chGetCqRingHandle+0x66> @ imm = #-0x2
;         cqRing = (Udma_RingHandle) chHandleInt->cqRing;
700aae16: 9800         	ldr	r0, [sp]
700aae18: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700aae1c: 9002         	str	r0, [sp, #0x8]
;     }
700aae1e: e7ff         	b	0x700aae20 <Udma_chGetCqRingHandle+0x70> @ imm = #-0x2
;     return (cqRing);
700aae20: 9802         	ldr	r0, [sp, #0x8]
700aae22: b005         	add	sp, #0x14
700aae24: 4770         	bx	lr
		...
700aae2e: 0000         	movs	r0, r0

700aae30 <Udma_chGetFqRingHandle>:
; {
700aae30: b085         	sub	sp, #0x14
700aae32: 9004         	str	r0, [sp, #0x10]
700aae34: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700aae36: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandle     fqRing = (Udma_RingHandle) NULL_PTR;
700aae38: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700aae3a: 9804         	ldr	r0, [sp, #0x10]
700aae3c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700aae3e: 9800         	ldr	r0, [sp]
700aae40: b150         	cbz	r0, 0x700aae58 <Udma_chGetFqRingHandle+0x28> @ imm = #0x14
700aae42: e7ff         	b	0x700aae44 <Udma_chGetFqRingHandle+0x14> @ imm = #-0x2
700aae44: 9800         	ldr	r0, [sp]
700aae46: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700aae4a: f64a 31cd    	movw	r1, #0xabcd
700aae4e: f6ca 31dc    	movt	r1, #0xabdc
700aae52: 4288         	cmp	r0, r1
700aae54: d004         	beq	0x700aae60 <Udma_chGetFqRingHandle+0x30> @ imm = #0x8
700aae56: e7ff         	b	0x700aae58 <Udma_chGetFqRingHandle+0x28> @ imm = #-0x2
700aae58: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700aae5c: 9003         	str	r0, [sp, #0xc]
;     }
700aae5e: e7ff         	b	0x700aae60 <Udma_chGetFqRingHandle+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aae60: 9803         	ldr	r0, [sp, #0xc]
700aae62: b9a8         	cbnz	r0, 0x700aae90 <Udma_chGetFqRingHandle+0x60> @ imm = #0x2a
700aae64: e7ff         	b	0x700aae66 <Udma_chGetFqRingHandle+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700aae66: 9800         	ldr	r0, [sp]
700aae68: 6e80         	ldr	r0, [r0, #0x68]
700aae6a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700aae6c: 9801         	ldr	r0, [sp, #0x4]
700aae6e: b150         	cbz	r0, 0x700aae86 <Udma_chGetFqRingHandle+0x56> @ imm = #0x14
700aae70: e7ff         	b	0x700aae72 <Udma_chGetFqRingHandle+0x42> @ imm = #-0x2
700aae72: 9801         	ldr	r0, [sp, #0x4]
700aae74: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700aae78: f64a 31cd    	movw	r1, #0xabcd
700aae7c: f6ca 31dc    	movt	r1, #0xabdc
700aae80: 4288         	cmp	r0, r1
700aae82: d004         	beq	0x700aae8e <Udma_chGetFqRingHandle+0x5e> @ imm = #0x8
700aae84: e7ff         	b	0x700aae86 <Udma_chGetFqRingHandle+0x56> @ imm = #-0x2
700aae86: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700aae8a: 9003         	str	r0, [sp, #0xc]
;         }
700aae8c: e7ff         	b	0x700aae8e <Udma_chGetFqRingHandle+0x5e> @ imm = #-0x2
;     }
700aae8e: e7ff         	b	0x700aae90 <Udma_chGetFqRingHandle+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aae90: 9803         	ldr	r0, [sp, #0xc]
700aae92: b928         	cbnz	r0, 0x700aaea0 <Udma_chGetFqRingHandle+0x70> @ imm = #0xa
700aae94: e7ff         	b	0x700aae96 <Udma_chGetFqRingHandle+0x66> @ imm = #-0x2
;         fqRing = (Udma_RingHandle) chHandleInt->fqRing;
700aae96: 9800         	ldr	r0, [sp]
700aae98: f8d0 0080    	ldr.w	r0, [r0, #0x80]
700aae9c: 9002         	str	r0, [sp, #0x8]
;     }
700aae9e: e7ff         	b	0x700aaea0 <Udma_chGetFqRingHandle+0x70> @ imm = #-0x2
;     return (fqRing);
700aaea0: 9802         	ldr	r0, [sp, #0x8]
700aaea2: b005         	add	sp, #0x14
700aaea4: 4770         	bx	lr
		...
700aaeae: 0000         	movs	r0, r0

700aaeb0 <prvGetExpectedIdleTime>:
; static TickType_t prvGetExpectedIdleTime(void) {
700aaeb0: b082         	sub	sp, #0x8
700aaeb2: 2000         	movs	r0, #0x0
;   UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
700aaeb4: 9000         	str	r0, [sp]
;     if (uxTopReadyPriority > tskIDLE_PRIORITY) {
700aaeb6: f242 60ec    	movw	r0, #0x26ec
700aaeba: f2c7 000b    	movt	r0, #0x700b
700aaebe: 6800         	ldr	r0, [r0]
700aaec0: b118         	cbz	r0, 0x700aaeca <prvGetExpectedIdleTime+0x1a> @ imm = #0x6
700aaec2: e7ff         	b	0x700aaec4 <prvGetExpectedIdleTime+0x14> @ imm = #-0x2
700aaec4: 2001         	movs	r0, #0x1
;       uxHigherPriorityReadyTasks = pdTRUE;
700aaec6: 9000         	str	r0, [sp]
;     }
700aaec8: e7ff         	b	0x700aaeca <prvGetExpectedIdleTime+0x1a> @ imm = #-0x2
;   if (pxCurrentTCB->uxPriority > tskIDLE_PRIORITY) {
700aaeca: f242 60bc    	movw	r0, #0x26bc
700aaece: f2c7 000b    	movt	r0, #0x700b
700aaed2: 6800         	ldr	r0, [r0]
700aaed4: 6ac0         	ldr	r0, [r0, #0x2c]
700aaed6: b118         	cbz	r0, 0x700aaee0 <prvGetExpectedIdleTime+0x30> @ imm = #0x6
700aaed8: e7ff         	b	0x700aaeda <prvGetExpectedIdleTime+0x2a> @ imm = #-0x2
700aaeda: 2000         	movs	r0, #0x0
;     xReturn = 0;
700aaedc: 9001         	str	r0, [sp, #0x4]
;   } else if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) >
700aaede: e01f         	b	0x700aaf20 <prvGetExpectedIdleTime+0x70> @ imm = #0x3e
700aaee0: f244 40f8    	movw	r0, #0x44f8
700aaee4: f2c7 0008    	movt	r0, #0x7008
700aaee8: 6800         	ldr	r0, [r0]
700aaeea: 2802         	cmp	r0, #0x2
700aaeec: d303         	blo	0x700aaef6 <prvGetExpectedIdleTime+0x46> @ imm = #0x6
700aaeee: e7ff         	b	0x700aaef0 <prvGetExpectedIdleTime+0x40> @ imm = #-0x2
700aaef0: 2000         	movs	r0, #0x0
;     xReturn = 0;
700aaef2: 9001         	str	r0, [sp, #0x4]
;   } else if (uxHigherPriorityReadyTasks != pdFALSE) {
700aaef4: e013         	b	0x700aaf1e <prvGetExpectedIdleTime+0x6e> @ imm = #0x26
700aaef6: 9800         	ldr	r0, [sp]
700aaef8: b118         	cbz	r0, 0x700aaf02 <prvGetExpectedIdleTime+0x52> @ imm = #0x6
700aaefa: e7ff         	b	0x700aaefc <prvGetExpectedIdleTime+0x4c> @ imm = #-0x2
700aaefc: 2000         	movs	r0, #0x0
;     xReturn = 0;
700aaefe: 9001         	str	r0, [sp, #0x4]
;   } else {
700aaf00: e00c         	b	0x700aaf1c <prvGetExpectedIdleTime+0x6c> @ imm = #0x18
;     xReturn = xNextTaskUnblockTime - xTickCount;
700aaf02: f242 60f4    	movw	r0, #0x26f4
700aaf06: f2c7 000b    	movt	r0, #0x700b
700aaf0a: 6800         	ldr	r0, [r0]
700aaf0c: f242 7104    	movw	r1, #0x2704
700aaf10: f2c7 010b    	movt	r1, #0x700b
700aaf14: 6809         	ldr	r1, [r1]
700aaf16: 1a40         	subs	r0, r0, r1
700aaf18: 9001         	str	r0, [sp, #0x4]
700aaf1a: e7ff         	b	0x700aaf1c <prvGetExpectedIdleTime+0x6c> @ imm = #-0x2
700aaf1c: e7ff         	b	0x700aaf1e <prvGetExpectedIdleTime+0x6e> @ imm = #-0x2
700aaf1e: e7ff         	b	0x700aaf20 <prvGetExpectedIdleTime+0x70> @ imm = #-0x2
;   return xReturn;
700aaf20: 9801         	ldr	r0, [sp, #0x4]
700aaf22: b002         	add	sp, #0x8
700aaf24: 4770         	bx	lr
		...
700aaf2e: 0000         	movs	r0, r0

700aaf30 <ClockP_usleep>:
; {
700aaf30: b580         	push	{r7, lr}
700aaf32: b088         	sub	sp, #0x20
700aaf34: 9007         	str	r0, [sp, #0x1c]
;     curTime = ClockP_getTimeUsec();
700aaf36: f7ff fcfb    	bl	0x700aa930 <ClockP_getTimeUsec> @ imm = #-0x60a
700aaf3a: 9105         	str	r1, [sp, #0x14]
700aaf3c: 9004         	str	r0, [sp, #0x10]
;     endTime = curTime + usec;
700aaf3e: 9904         	ldr	r1, [sp, #0x10]
700aaf40: 9805         	ldr	r0, [sp, #0x14]
700aaf42: 9a07         	ldr	r2, [sp, #0x1c]
700aaf44: 1889         	adds	r1, r1, r2
700aaf46: f140 0000    	adc	r0, r0, #0x0
700aaf4a: 9102         	str	r1, [sp, #0x8]
700aaf4c: 9003         	str	r0, [sp, #0xc]
;     if (usec >= gClockCtrl.usecPerTick) {
700aaf4e: 9807         	ldr	r0, [sp, #0x1c]
700aaf50: f245 1110    	movw	r1, #0x5110
700aaf54: f2c7 0108    	movt	r1, #0x7008
700aaf58: 6889         	ldr	r1, [r1, #0x8]
700aaf5a: 4288         	cmp	r0, r1
700aaf5c: d30d         	blo	0x700aaf7a <ClockP_usleep+0x4a> @ imm = #0x1a
700aaf5e: e7ff         	b	0x700aaf60 <ClockP_usleep+0x30> @ imm = #-0x2
;         ticksToSleep = usec / gClockCtrl.usecPerTick;
700aaf60: 9807         	ldr	r0, [sp, #0x1c]
700aaf62: f245 1110    	movw	r1, #0x5110
700aaf66: f2c7 0108    	movt	r1, #0x7008
700aaf6a: 6889         	ldr	r1, [r1, #0x8]
700aaf6c: fbb0 f0f1    	udiv	r0, r0, r1
700aaf70: 9001         	str	r0, [sp, #0x4]
;         ClockP_sleepTicks(ticksToSleep);
700aaf72: 9801         	ldr	r0, [sp, #0x4]
700aaf74: f004 fc64    	bl	0x700af840 <ClockP_sleepTicks> @ imm = #0x48c8
;     }
700aaf78: e012         	b	0x700aafa0 <ClockP_usleep+0x70> @ imm = #0x24
;         curTime = ClockP_getTimeUsec();
700aaf7a: f7ff fcd9    	bl	0x700aa930 <ClockP_getTimeUsec> @ imm = #-0x64e
700aaf7e: 9105         	str	r1, [sp, #0x14]
700aaf80: 9004         	str	r0, [sp, #0x10]
;         while (curTime < endTime) {
700aaf82: e7ff         	b	0x700aaf84 <ClockP_usleep+0x54> @ imm = #-0x2
700aaf84: 9a04         	ldr	r2, [sp, #0x10]
700aaf86: 9805         	ldr	r0, [sp, #0x14]
700aaf88: 9b02         	ldr	r3, [sp, #0x8]
700aaf8a: 9903         	ldr	r1, [sp, #0xc]
700aaf8c: 1ad2         	subs	r2, r2, r3
700aaf8e: 4188         	sbcs	r0, r1
700aaf90: d205         	bhs	0x700aaf9e <ClockP_usleep+0x6e> @ imm = #0xa
700aaf92: e7ff         	b	0x700aaf94 <ClockP_usleep+0x64> @ imm = #-0x2
;             curTime = ClockP_getTimeUsec();
700aaf94: f7ff fccc    	bl	0x700aa930 <ClockP_getTimeUsec> @ imm = #-0x668
700aaf98: 9105         	str	r1, [sp, #0x14]
700aaf9a: 9004         	str	r0, [sp, #0x10]
;         while (curTime < endTime) {
700aaf9c: e7f2         	b	0x700aaf84 <ClockP_usleep+0x54> @ imm = #-0x1c
700aaf9e: e7ff         	b	0x700aafa0 <ClockP_usleep+0x70> @ imm = #-0x2
; }
700aafa0: b008         	add	sp, #0x20
700aafa2: bd80         	pop	{r7, pc}
		...

700aafb0 <Udma_chEnable>:
; {
700aafb0: b580         	push	{r7, lr}
700aafb2: b084         	sub	sp, #0x10
700aafb4: 9003         	str	r0, [sp, #0xc]
700aafb6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700aafb8: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700aafba: 9803         	ldr	r0, [sp, #0xc]
700aafbc: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700aafbe: 9800         	ldr	r0, [sp]
700aafc0: b150         	cbz	r0, 0x700aafd8 <Udma_chEnable+0x28> @ imm = #0x14
700aafc2: e7ff         	b	0x700aafc4 <Udma_chEnable+0x14> @ imm = #-0x2
700aafc4: 9800         	ldr	r0, [sp]
700aafc6: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700aafca: f64a 31cd    	movw	r1, #0xabcd
700aafce: f6ca 31dc    	movt	r1, #0xabdc
700aafd2: 4288         	cmp	r0, r1
700aafd4: d004         	beq	0x700aafe0 <Udma_chEnable+0x30> @ imm = #0x8
700aafd6: e7ff         	b	0x700aafd8 <Udma_chEnable+0x28> @ imm = #-0x2
700aafd8: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700aafdc: 9002         	str	r0, [sp, #0x8]
;     }
700aafde: e7ff         	b	0x700aafe0 <Udma_chEnable+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aafe0: 9802         	ldr	r0, [sp, #0x8]
700aafe2: b9a8         	cbnz	r0, 0x700ab010 <Udma_chEnable+0x60> @ imm = #0x2a
700aafe4: e7ff         	b	0x700aafe6 <Udma_chEnable+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700aafe6: 9800         	ldr	r0, [sp]
700aafe8: 6e80         	ldr	r0, [r0, #0x68]
700aafea: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700aafec: 9801         	ldr	r0, [sp, #0x4]
700aafee: b150         	cbz	r0, 0x700ab006 <Udma_chEnable+0x56> @ imm = #0x14
700aaff0: e7ff         	b	0x700aaff2 <Udma_chEnable+0x42> @ imm = #-0x2
700aaff2: 9801         	ldr	r0, [sp, #0x4]
700aaff4: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700aaff8: f64a 31cd    	movw	r1, #0xabcd
700aaffc: f6ca 31dc    	movt	r1, #0xabdc
700ab000: 4288         	cmp	r0, r1
700ab002: d004         	beq	0x700ab00e <Udma_chEnable+0x5e> @ imm = #0x8
700ab004: e7ff         	b	0x700ab006 <Udma_chEnable+0x56> @ imm = #-0x2
700ab006: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700ab00a: 9002         	str	r0, [sp, #0x8]
;         }
700ab00c: e7ff         	b	0x700ab00e <Udma_chEnable+0x5e> @ imm = #-0x2
;     }
700ab00e: e7ff         	b	0x700ab010 <Udma_chEnable+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab010: 9802         	ldr	r0, [sp, #0x8]
700ab012: b920         	cbnz	r0, 0x700ab01e <Udma_chEnable+0x6e> @ imm = #0x8
700ab014: e7ff         	b	0x700ab016 <Udma_chEnable+0x66> @ imm = #-0x2
;         Udma_chEnableLocal(chHandleInt);
700ab016: 9800         	ldr	r0, [sp]
700ab018: f7f5 ffa2    	bl	0x700a0f60 <Udma_chEnableLocal> @ imm = #-0xa0bc
;     }
700ab01c: e7ff         	b	0x700ab01e <Udma_chEnable+0x6e> @ imm = #-0x2
;     return (retVal);
700ab01e: 9802         	ldr	r0, [sp, #0x8]
700ab020: b004         	add	sp, #0x10
700ab022: bd80         	pop	{r7, pc}
		...

700ab030 <CSL_bcdmaChanOpTriggerChan>:
; {
700ab030: b580         	push	{r7, lr}
700ab032: b084         	sub	sp, #0x10
700ab034: 9003         	str	r0, [sp, #0xc]
700ab036: 9102         	str	r1, [sp, #0x8]
700ab038: 9201         	str	r2, [sp, #0x4]
700ab03a: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700ab03c: 9000         	str	r0, [sp]
;     if( chanType == CSL_BCDMA_CHAN_TYPE_BLOCK_COPY )
700ab03e: 9802         	ldr	r0, [sp, #0x8]
700ab040: b950         	cbnz	r0, 0x700ab058 <CSL_bcdmaChanOpTriggerChan+0x28> @ imm = #0x14
700ab042: e7ff         	b	0x700ab044 <CSL_bcdmaChanOpTriggerChan+0x14> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pBcChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_BCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700ab044: 9803         	ldr	r0, [sp, #0xc]
700ab046: 6880         	ldr	r0, [r0, #0x8]
700ab048: 9901         	ldr	r1, [sp, #0x4]
700ab04a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab04e: 3008         	adds	r0, #0x8
700ab050: 2101         	movs	r1, #0x1
700ab052: f7f1 f8dd    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0xee46
;     }
700ab056: e021         	b	0x700ab09c <CSL_bcdmaChanOpTriggerChan+0x6c> @ imm = #0x42
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_TX )
700ab058: 9802         	ldr	r0, [sp, #0x8]
700ab05a: 2801         	cmp	r0, #0x1
700ab05c: d10a         	bne	0x700ab074 <CSL_bcdmaChanOpTriggerChan+0x44> @ imm = #0x14
700ab05e: e7ff         	b	0x700ab060 <CSL_bcdmaChanOpTriggerChan+0x30> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_TXCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700ab060: 9803         	ldr	r0, [sp, #0xc]
700ab062: 6900         	ldr	r0, [r0, #0x10]
700ab064: 9901         	ldr	r1, [sp, #0x4]
700ab066: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab06a: 3008         	adds	r0, #0x8
700ab06c: 2101         	movs	r1, #0x1
700ab06e: f7f1 f8cf    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0xee62
;     }
700ab072: e012         	b	0x700ab09a <CSL_bcdmaChanOpTriggerChan+0x6a> @ imm = #0x24
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700ab074: 9802         	ldr	r0, [sp, #0x8]
700ab076: 2802         	cmp	r0, #0x2
700ab078: d10a         	bne	0x700ab090 <CSL_bcdmaChanOpTriggerChan+0x60> @ imm = #0x14
700ab07a: e7ff         	b	0x700ab07c <CSL_bcdmaChanOpTriggerChan+0x4c> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_RXCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700ab07c: 9803         	ldr	r0, [sp, #0xc]
700ab07e: 6980         	ldr	r0, [r0, #0x18]
700ab080: 9901         	ldr	r1, [sp, #0x4]
700ab082: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab086: 3008         	adds	r0, #0x8
700ab088: 2101         	movs	r1, #0x1
700ab08a: f7f1 f8c1    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0xee7e
;     }
700ab08e: e003         	b	0x700ab098 <CSL_bcdmaChanOpTriggerChan+0x68> @ imm = #0x6
700ab090: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700ab094: 9000         	str	r0, [sp]
700ab096: e7ff         	b	0x700ab098 <CSL_bcdmaChanOpTriggerChan+0x68> @ imm = #-0x2
700ab098: e7ff         	b	0x700ab09a <CSL_bcdmaChanOpTriggerChan+0x6a> @ imm = #-0x2
700ab09a: e7ff         	b	0x700ab09c <CSL_bcdmaChanOpTriggerChan+0x6c> @ imm = #-0x2
;     return retVal;
700ab09c: 9800         	ldr	r0, [sp]
700ab09e: b004         	add	sp, #0x10
700ab0a0: bd80         	pop	{r7, pc}
		...
700ab0ae: 0000         	movs	r0, r0

700ab0b0 <prvProcessExpiredTimer>:
;     {
700ab0b0: b580         	push	{r7, lr}
700ab0b2: b086         	sub	sp, #0x18
700ab0b4: 9005         	str	r0, [sp, #0x14]
700ab0b6: 9104         	str	r1, [sp, #0x10]
;         Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
700ab0b8: f245 201c    	movw	r0, #0x521c
700ab0bc: f2c7 0008    	movt	r0, #0x7008
700ab0c0: 6800         	ldr	r0, [r0]
700ab0c2: 68c0         	ldr	r0, [r0, #0xc]
700ab0c4: 68c0         	ldr	r0, [r0, #0xc]
700ab0c6: 9002         	str	r0, [sp, #0x8]
;         ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700ab0c8: 9802         	ldr	r0, [sp, #0x8]
700ab0ca: 3004         	adds	r0, #0x4
700ab0cc: f002 f9d0    	bl	0x700ad470 <uxListRemove> @ imm = #0x23a0
;         if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700ab0d0: 9802         	ldr	r0, [sp, #0x8]
700ab0d2: f890 0028    	ldrb.w	r0, [r0, #0x28]
700ab0d6: 0740         	lsls	r0, r0, #0x1d
700ab0d8: 2800         	cmp	r0, #0x0
700ab0da: d515         	bpl	0x700ab108 <prvProcessExpiredTimer+0x58> @ imm = #0x2a
700ab0dc: e7ff         	b	0x700ab0de <prvProcessExpiredTimer+0x2e> @ imm = #-0x2
;             if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
700ab0de: 9802         	ldr	r0, [sp, #0x8]
700ab0e0: 9b05         	ldr	r3, [sp, #0x14]
700ab0e2: 6981         	ldr	r1, [r0, #0x18]
700ab0e4: 4419         	add	r1, r3
700ab0e6: 9a04         	ldr	r2, [sp, #0x10]
700ab0e8: f7ff f92a    	bl	0x700aa340 <prvInsertTimerInActiveList> @ imm = #-0xdac
700ab0ec: b150         	cbz	r0, 0x700ab104 <prvProcessExpiredTimer+0x54> @ imm = #0x14
700ab0ee: e7ff         	b	0x700ab0f0 <prvProcessExpiredTimer+0x40> @ imm = #-0x2
;                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
700ab0f0: 9802         	ldr	r0, [sp, #0x8]
700ab0f2: 9a05         	ldr	r2, [sp, #0x14]
700ab0f4: 4669         	mov	r1, sp
700ab0f6: 2300         	movs	r3, #0x0
700ab0f8: 600b         	str	r3, [r1]
700ab0fa: 4619         	mov	r1, r3
700ab0fc: f7fe fbf0    	bl	0x700a98e0 <xTimerGenericCommand> @ imm = #-0x1820
700ab100: 9003         	str	r0, [sp, #0xc]
;             }
700ab102: e000         	b	0x700ab106 <prvProcessExpiredTimer+0x56> @ imm = #0x0
700ab104: e7ff         	b	0x700ab106 <prvProcessExpiredTimer+0x56> @ imm = #-0x2
;         }
700ab106: e007         	b	0x700ab118 <prvProcessExpiredTimer+0x68> @ imm = #0xe
;             pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700ab108: 9902         	ldr	r1, [sp, #0x8]
700ab10a: f891 0028    	ldrb.w	r0, [r1, #0x28]
700ab10e: f000 00fe    	and	r0, r0, #0xfe
700ab112: f881 0028    	strb.w	r0, [r1, #0x28]
700ab116: e7ff         	b	0x700ab118 <prvProcessExpiredTimer+0x68> @ imm = #-0x2
;         pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700ab118: 9802         	ldr	r0, [sp, #0x8]
700ab11a: 6a01         	ldr	r1, [r0, #0x20]
700ab11c: 4788         	blx	r1
;     }
700ab11e: b006         	add	sp, #0x18
700ab120: bd80         	pop	{r7, pc}
		...
700ab12e: 0000         	movs	r0, r0

700ab130 <xTaskCreateStatic>:
;     StaticTask_t *const pxTaskBuffer) {
700ab130: b5b0         	push	{r4, r5, r7, lr}
700ab132: b08a         	sub	sp, #0x28
700ab134: f8dd c040    	ldr.w	r12, [sp, #0x40]
700ab138: f8dd c03c    	ldr.w	r12, [sp, #0x3c]
700ab13c: f8dd c038    	ldr.w	r12, [sp, #0x38]
700ab140: 9009         	str	r0, [sp, #0x24]
700ab142: 9108         	str	r1, [sp, #0x20]
700ab144: 9207         	str	r2, [sp, #0x1c]
700ab146: 9306         	str	r3, [sp, #0x18]
;   if ((pxTaskBuffer != NULL) && (puxStackBuffer != NULL)) {
700ab148: 9810         	ldr	r0, [sp, #0x40]
700ab14a: b320         	cbz	r0, 0x700ab196 <xTaskCreateStatic+0x66> @ imm = #0x48
700ab14c: e7ff         	b	0x700ab14e <xTaskCreateStatic+0x1e> @ imm = #-0x2
700ab14e: 980f         	ldr	r0, [sp, #0x3c]
700ab150: b308         	cbz	r0, 0x700ab196 <xTaskCreateStatic+0x66> @ imm = #0x42
700ab152: e7ff         	b	0x700ab154 <xTaskCreateStatic+0x24> @ imm = #-0x2
;         pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures
700ab154: 9810         	ldr	r0, [sp, #0x40]
;     pxNewTCB = (TCB_t *)
700ab156: 9005         	str	r0, [sp, #0x14]
;     pxNewTCB->pxStack = (StackType_t *)puxStackBuffer;
700ab158: 980f         	ldr	r0, [sp, #0x3c]
700ab15a: 9905         	ldr	r1, [sp, #0x14]
700ab15c: 6308         	str	r0, [r1, #0x30]
;       pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
700ab15e: 9905         	ldr	r1, [sp, #0x14]
700ab160: 2002         	movs	r0, #0x2
700ab162: f881 0081    	strb.w	r0, [r1, #0x81]
;     prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters,
700ab166: 9809         	ldr	r0, [sp, #0x24]
700ab168: 9908         	ldr	r1, [sp, #0x20]
700ab16a: 9a07         	ldr	r2, [sp, #0x1c]
700ab16c: 9b06         	ldr	r3, [sp, #0x18]
;                          uxPriority, &xReturn, pxNewTCB, NULL);
700ab16e: f8dd c038    	ldr.w	r12, [sp, #0x38]
700ab172: 9c05         	ldr	r4, [sp, #0x14]
;     prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters,
700ab174: 46ee         	mov	lr, sp
700ab176: 2500         	movs	r5, #0x0
700ab178: f8ce 500c    	str.w	r5, [lr, #0xc]
700ab17c: f8ce 4008    	str.w	r4, [lr, #0x8]
700ab180: ac04         	add	r4, sp, #0x10
700ab182: f8ce 4004    	str.w	r4, [lr, #0x4]
700ab186: f8ce c000    	str.w	r12, [lr]
700ab18a: f7f9 fd09    	bl	0x700a4ba0 <prvInitialiseNewTask> @ imm = #-0x65ee
;     prvAddNewTaskToReadyList(pxNewTCB);
700ab18e: 9805         	ldr	r0, [sp, #0x14]
700ab190: f7f9 fe1e    	bl	0x700a4dd0 <prvAddNewTaskToReadyList> @ imm = #-0x63c4
;   } else {
700ab194: e002         	b	0x700ab19c <xTaskCreateStatic+0x6c> @ imm = #0x4
700ab196: 2000         	movs	r0, #0x0
;     xReturn = NULL;
700ab198: 9004         	str	r0, [sp, #0x10]
700ab19a: e7ff         	b	0x700ab19c <xTaskCreateStatic+0x6c> @ imm = #-0x2
;   return xReturn;
700ab19c: 9804         	ldr	r0, [sp, #0x10]
700ab19e: b00a         	add	sp, #0x28
700ab1a0: bdb0         	pop	{r4, r5, r7, pc}
		...
700ab1ae: 0000         	movs	r0, r0

700ab1b0 <CSL_intaggrClrIntr>:
; {
700ab1b0: b580         	push	{r7, lr}
700ab1b2: b088         	sub	sp, #0x20
700ab1b4: 9007         	str	r0, [sp, #0x1c]
700ab1b6: 9106         	str	r1, [sp, #0x18]
700ab1b8: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t  retVal = CSL_EFAIL;
700ab1bc: 9005         	str	r0, [sp, #0x14]
;     if( CSL_intaggrIsValidStatusBitNum(pCfg, statusBitNum) )
700ab1be: 9807         	ldr	r0, [sp, #0x1c]
700ab1c0: 9906         	ldr	r1, [sp, #0x18]
700ab1c2: f002 fd6d    	bl	0x700adca0 <CSL_intaggrIsValidStatusBitNum> @ imm = #0x2ada
700ab1c6: b340         	cbz	r0, 0x700ab21a <CSL_intaggrClrIntr+0x6a> @ imm = #0x50
700ab1c8: e7ff         	b	0x700ab1ca <CSL_intaggrClrIntr+0x1a> @ imm = #-0x2
;         regNum = statusBitNum >> 6U;
700ab1ca: 9806         	ldr	r0, [sp, #0x18]
700ab1cc: 0980         	lsrs	r0, r0, #0x6
700ab1ce: 9001         	str	r0, [sp, #0x4]
;         bitNum = statusBitNum & (uint32_t)0x003FU;
700ab1d0: 9806         	ldr	r0, [sp, #0x18]
700ab1d2: f000 003f    	and	r0, r0, #0x3f
700ab1d6: 9000         	str	r0, [sp]
;         regVal = (((uint64_t)1U) << bitNum);
700ab1d8: 9b00         	ldr	r3, [sp]
700ab1da: f1a3 0220    	sub.w	r2, r3, #0x20
700ab1de: 2101         	movs	r1, #0x1
700ab1e0: fa01 fc02    	lsl.w	r12, r1, r2
700ab1e4: f1c3 0020    	rsb.w	r0, r3, #0x20
700ab1e8: fa21 f000    	lsr.w	r0, r1, r0
700ab1ec: 2a00         	cmp	r2, #0x0
700ab1ee: bf58         	it	pl
700ab1f0: 4660         	movpl	r0, r12
700ab1f2: fa01 f103    	lsl.w	r1, r1, r3
700ab1f6: 2a00         	cmp	r2, #0x0
700ab1f8: bf58         	it	pl
700ab1fa: 2100         	movpl	r1, #0x0
700ab1fc: 9102         	str	r1, [sp, #0x8]
700ab1fe: 9003         	str	r0, [sp, #0xc]
;         CSL_REG64_WR( &pCfg->pIntrRegs->VINT[regNum].STATUS_CLEAR, regVal );
700ab200: 9807         	ldr	r0, [sp, #0x1c]
700ab202: 6880         	ldr	r0, [r0, #0x8]
700ab204: 9901         	ldr	r1, [sp, #0x4]
700ab206: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab20a: 3018         	adds	r0, #0x18
700ab20c: 9a02         	ldr	r2, [sp, #0x8]
700ab20e: 9b03         	ldr	r3, [sp, #0xc]
700ab210: f004 f946    	bl	0x700af4a0 <CSL_REG64_WR_RAW> @ imm = #0x428c
700ab214: 2000         	movs	r0, #0x0
;         retVal = CSL_PASS;
700ab216: 9005         	str	r0, [sp, #0x14]
;     }
700ab218: e7ff         	b	0x700ab21a <CSL_intaggrClrIntr+0x6a> @ imm = #-0x2
;     return retVal;
700ab21a: 9805         	ldr	r0, [sp, #0x14]
700ab21c: b008         	add	sp, #0x20
700ab21e: bd80         	pop	{r7, pc}

700ab220 <Sciclient_rmGetResourceRange>:
; {
700ab220: b580         	push	{r7, lr}
700ab222: b090         	sub	sp, #0x40
700ab224: 900f         	str	r0, [sp, #0x3c]
700ab226: 910e         	str	r1, [sp, #0x38]
700ab228: 920d         	str	r2, [sp, #0x34]
700ab22a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab22c: 900c         	str	r0, [sp, #0x30]
700ab22e: f44f 51a8    	mov.w	r1, #0x1500
;     sciReq.messageType    = TISCI_MSG_RM_GET_RESOURCE_RANGE;
700ab232: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700ab236: 2102         	movs	r1, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ab238: 9108         	str	r1, [sp, #0x20]
700ab23a: a904         	add	r1, sp, #0x10
;     sciReq.pReqPayload    = (const uint8_t *) &req_copy;
700ab23c: 9109         	str	r1, [sp, #0x24]
700ab23e: 210c         	movs	r1, #0xc
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ab240: 910a         	str	r1, [sp, #0x28]
;     sciReq.timeout        = timeout;
700ab242: 990d         	ldr	r1, [sp, #0x34]
700ab244: 910b         	str	r1, [sp, #0x2c]
;     sciResp.flags           = 0;
700ab246: 9001         	str	r0, [sp, #0x4]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ab248: 980e         	ldr	r0, [sp, #0x38]
700ab24a: 9002         	str	r0, [sp, #0x8]
700ab24c: 2010         	movs	r0, #0x10
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ab24e: 9003         	str	r0, [sp, #0xc]
;     memcpy(&req_copy, req, sizeof(struct tisci_msg_rm_get_resource_range_req));
700ab250: 9a0f         	ldr	r2, [sp, #0x3c]
700ab252: 6810         	ldr	r0, [r2]
700ab254: 6851         	ldr	r1, [r2, #0x4]
700ab256: 6892         	ldr	r2, [r2, #0x8]
700ab258: 9206         	str	r2, [sp, #0x18]
700ab25a: 9105         	str	r1, [sp, #0x14]
700ab25c: 9004         	str	r0, [sp, #0x10]
;     if (SystemP_SUCCESS == r)
700ab25e: 980c         	ldr	r0, [sp, #0x30]
700ab260: b930         	cbnz	r0, 0x700ab270 <Sciclient_rmGetResourceRange+0x50> @ imm = #0xc
700ab262: e7ff         	b	0x700ab264 <Sciclient_rmGetResourceRange+0x44> @ imm = #-0x2
700ab264: a807         	add	r0, sp, #0x1c
700ab266: a901         	add	r1, sp, #0x4
;         r = Sciclient_service(&sciReq, &sciResp);
700ab268: f7f2 f80a    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xdfec
700ab26c: 900c         	str	r0, [sp, #0x30]
;     }
700ab26e: e7ff         	b	0x700ab270 <Sciclient_rmGetResourceRange+0x50> @ imm = #-0x2
;     if ((r != SystemP_SUCCESS) ||
700ab270: 980c         	ldr	r0, [sp, #0x30]
700ab272: b930         	cbnz	r0, 0x700ab282 <Sciclient_rmGetResourceRange+0x62> @ imm = #0xc
700ab274: e7ff         	b	0x700ab276 <Sciclient_rmGetResourceRange+0x56> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ab276: 9801         	ldr	r0, [sp, #0x4]
700ab278: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ab27c: 2802         	cmp	r0, #0x2
700ab27e: d004         	beq	0x700ab28a <Sciclient_rmGetResourceRange+0x6a> @ imm = #0x8
700ab280: e7ff         	b	0x700ab282 <Sciclient_rmGetResourceRange+0x62> @ imm = #-0x2
700ab282: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ab286: 900c         	str	r0, [sp, #0x30]
;     }
700ab288: e7ff         	b	0x700ab28a <Sciclient_rmGetResourceRange+0x6a> @ imm = #-0x2
;     return r;
700ab28a: 980c         	ldr	r0, [sp, #0x30]
700ab28c: b010         	add	sp, #0x40
700ab28e: bd80         	pop	{r7, pc}

700ab290 <Udma_rmFreeMappedRxCh>:
; {
700ab290: b580         	push	{r7, lr}
700ab292: b088         	sub	sp, #0x20
700ab294: 9007         	str	r0, [sp, #0x1c]
700ab296: 9106         	str	r1, [sp, #0x18]
700ab298: 9205         	str	r2, [sp, #0x14]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ab29a: 9806         	ldr	r0, [sp, #0x18]
700ab29c: f500 70ea    	add.w	r0, r0, #0x1d4
700ab2a0: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ab2a2: 9806         	ldr	r0, [sp, #0x18]
700ab2a4: f500 609f    	add.w	r0, r0, #0x4f8
700ab2a8: f04f 31ff    	mov.w	r1, #0xffffffff
700ab2ac: f7ff f968    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #-0xd30
;     i = chNum - rmInitPrms->startMappedRxCh[mappedChGrp];
700ab2b0: 9807         	ldr	r0, [sp, #0x1c]
700ab2b2: 9900         	ldr	r1, [sp]
700ab2b4: 9a05         	ldr	r2, [sp, #0x14]
700ab2b6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ab2ba: 6e89         	ldr	r1, [r1, #0x68]
700ab2bc: 1a40         	subs	r0, r0, r1
700ab2be: 9004         	str	r0, [sp, #0x10]
;     offset = i >> 5U;
700ab2c0: 9804         	ldr	r0, [sp, #0x10]
700ab2c2: 0940         	lsrs	r0, r0, #0x5
700ab2c4: 9003         	str	r0, [sp, #0xc]
;     bitPos = i - (offset << 5U);
700ab2c6: 9804         	ldr	r0, [sp, #0x10]
700ab2c8: 9903         	ldr	r1, [sp, #0xc]
700ab2ca: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ab2ce: 9002         	str	r0, [sp, #0x8]
;     bitMask = (uint32_t) 1U << bitPos;
700ab2d0: 9902         	ldr	r1, [sp, #0x8]
700ab2d2: 2001         	movs	r0, #0x1
700ab2d4: 4088         	lsls	r0, r1
700ab2d6: 9001         	str	r0, [sp, #0x4]
;     drvHandle->mappedRxChFlag[mappedChGrp][offset] |= bitMask;
700ab2d8: 9a01         	ldr	r2, [sp, #0x4]
700ab2da: 9806         	ldr	r0, [sp, #0x18]
700ab2dc: 9905         	ldr	r1, [sp, #0x14]
700ab2de: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ab2e2: 9903         	ldr	r1, [sp, #0xc]
700ab2e4: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ab2e8: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700ab2ec: 4310         	orrs	r0, r2
700ab2ee: f8c1 0334    	str.w	r0, [r1, #0x334]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ab2f2: 9806         	ldr	r0, [sp, #0x18]
700ab2f4: f500 609f    	add.w	r0, r0, #0x4f8
700ab2f8: f000 fcd2    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x9a4
;     return;
700ab2fc: b008         	add	sp, #0x20
700ab2fe: bd80         	pop	{r7, pc}

700ab300 <Udma_rmFreeMappedTxCh>:
; {
700ab300: b580         	push	{r7, lr}
700ab302: b088         	sub	sp, #0x20
700ab304: 9007         	str	r0, [sp, #0x1c]
700ab306: 9106         	str	r1, [sp, #0x18]
700ab308: 9205         	str	r2, [sp, #0x14]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ab30a: 9806         	ldr	r0, [sp, #0x18]
700ab30c: f500 70ea    	add.w	r0, r0, #0x1d4
700ab310: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ab312: 9806         	ldr	r0, [sp, #0x18]
700ab314: f500 609f    	add.w	r0, r0, #0x4f8
700ab318: f04f 31ff    	mov.w	r1, #0xffffffff
700ab31c: f7ff f930    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #-0xda0
;     i = chNum - rmInitPrms->startMappedTxCh[mappedChGrp];
700ab320: 9807         	ldr	r0, [sp, #0x1c]
700ab322: 9900         	ldr	r1, [sp]
700ab324: 9a05         	ldr	r2, [sp, #0x14]
700ab326: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ab32a: 6c89         	ldr	r1, [r1, #0x48]
700ab32c: 1a40         	subs	r0, r0, r1
700ab32e: 9004         	str	r0, [sp, #0x10]
;     offset = i >> 5U;
700ab330: 9804         	ldr	r0, [sp, #0x10]
700ab332: 0940         	lsrs	r0, r0, #0x5
700ab334: 9003         	str	r0, [sp, #0xc]
;     bitPos = i - (offset << 5U);
700ab336: 9804         	ldr	r0, [sp, #0x10]
700ab338: 9903         	ldr	r1, [sp, #0xc]
700ab33a: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ab33e: 9002         	str	r0, [sp, #0x8]
;     bitMask = (uint32_t) 1U << bitPos;
700ab340: 9902         	ldr	r1, [sp, #0x8]
700ab342: 2001         	movs	r0, #0x1
700ab344: 4088         	lsls	r0, r1
700ab346: 9001         	str	r0, [sp, #0x4]
;     drvHandle->mappedTxChFlag[mappedChGrp][offset] |= bitMask;
700ab348: 9a01         	ldr	r2, [sp, #0x4]
700ab34a: 9806         	ldr	r0, [sp, #0x18]
700ab34c: 9905         	ldr	r1, [sp, #0x14]
700ab34e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ab352: 9903         	ldr	r1, [sp, #0xc]
700ab354: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ab358: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700ab35c: 4310         	orrs	r0, r2
700ab35e: f8c1 0324    	str.w	r0, [r1, #0x324]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ab362: 9806         	ldr	r0, [sp, #0x18]
700ab364: f500 609f    	add.w	r0, r0, #0x4f8
700ab368: f000 fc9a    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x934
;     return;
700ab36c: b008         	add	sp, #0x20
700ab36e: bd80         	pop	{r7, pc}

700ab370 <Sciclient_rmIaVintGetInfo>:
; {
700ab370: b580         	push	{r7, lr}
700ab372: b084         	sub	sp, #0x10
700ab374: f8ad 000e    	strh.w	r0, [sp, #0xe]
700ab378: f8ad 100c    	strh.w	r1, [sp, #0xc]
700ab37c: 9202         	str	r2, [sp, #0x8]
700ab37e: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab380: 9001         	str	r0, [sp, #0x4]
;     if (n_evts == NULL) {
700ab382: 9802         	ldr	r0, [sp, #0x8]
700ab384: b920         	cbnz	r0, 0x700ab390 <Sciclient_rmIaVintGetInfo+0x20> @ imm = #0x8
700ab386: e7ff         	b	0x700ab388 <Sciclient_rmIaVintGetInfo+0x18> @ imm = #-0x2
700ab388: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ab38c: 9001         	str	r0, [sp, #0x4]
;     } else {
700ab38e: e018         	b	0x700ab3c2 <Sciclient_rmIaVintGetInfo+0x52> @ imm = #0x30
;         inst = Sciclient_rmIaGetInst(id);
700ab390: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700ab394: f000 ffac    	bl	0x700ac2f0 <Sciclient_rmIaGetInst> @ imm = #0xf58
700ab398: 9000         	str	r0, [sp]
;         if (inst == NULL) {
700ab39a: 9800         	ldr	r0, [sp]
700ab39c: b920         	cbnz	r0, 0x700ab3a8 <Sciclient_rmIaVintGetInfo+0x38> @ imm = #0x8
700ab39e: e7ff         	b	0x700ab3a0 <Sciclient_rmIaVintGetInfo+0x30> @ imm = #-0x2
700ab3a0: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700ab3a4: 9001         	str	r0, [sp, #0x4]
;         } else {
700ab3a6: e00b         	b	0x700ab3c0 <Sciclient_rmIaVintGetInfo+0x50> @ imm = #0x16
;             if (vint >= inst->n_vint) {
700ab3a8: f8bd 000c    	ldrh.w	r0, [sp, #0xc]
700ab3ac: 9900         	ldr	r1, [sp]
700ab3ae: 8989         	ldrh	r1, [r1, #0xc]
700ab3b0: 4288         	cmp	r0, r1
700ab3b2: db04         	blt	0x700ab3be <Sciclient_rmIaVintGetInfo+0x4e> @ imm = #0x8
700ab3b4: e7ff         	b	0x700ab3b6 <Sciclient_rmIaVintGetInfo+0x46> @ imm = #-0x2
700ab3b6: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700ab3ba: 9001         	str	r0, [sp, #0x4]
;             }
700ab3bc: e7ff         	b	0x700ab3be <Sciclient_rmIaVintGetInfo+0x4e> @ imm = #-0x2
700ab3be: e7ff         	b	0x700ab3c0 <Sciclient_rmIaVintGetInfo+0x50> @ imm = #-0x2
700ab3c0: e7ff         	b	0x700ab3c2 <Sciclient_rmIaVintGetInfo+0x52> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ab3c2: 9801         	ldr	r0, [sp, #0x4]
700ab3c4: b940         	cbnz	r0, 0x700ab3d8 <Sciclient_rmIaVintGetInfo+0x68> @ imm = #0x10
700ab3c6: e7ff         	b	0x700ab3c8 <Sciclient_rmIaVintGetInfo+0x58> @ imm = #-0x2
;         *n_evts = inst->vint_usage_count[vint];
700ab3c8: 9800         	ldr	r0, [sp]
700ab3ca: 6900         	ldr	r0, [r0, #0x10]
700ab3cc: f8bd 100c    	ldrh.w	r1, [sp, #0xc]
700ab3d0: 5c40         	ldrb	r0, [r0, r1]
700ab3d2: 9902         	ldr	r1, [sp, #0x8]
700ab3d4: 7008         	strb	r0, [r1]
;     }
700ab3d6: e7ff         	b	0x700ab3d8 <Sciclient_rmIaVintGetInfo+0x68> @ imm = #-0x2
;     return r;
700ab3d8: 9801         	ldr	r0, [sp, #0x4]
700ab3da: b004         	add	sp, #0x10
700ab3dc: bd80         	pop	{r7, pc}
700ab3de: 0000         	movs	r0, r0

700ab3e0 <SemaphoreP_constructMutex>:
; {
700ab3e0: b580         	push	{r7, lr}
700ab3e2: b086         	sub	sp, #0x18
700ab3e4: 9005         	str	r0, [sp, #0x14]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700ab3e6: 9805         	ldr	r0, [sp, #0x14]
700ab3e8: 9004         	str	r0, [sp, #0x10]
;     DebugP_assert(sizeof(SemaphoreP_Struct) <= sizeof(SemaphoreP_Object) );
700ab3ea: f241 60e6    	movw	r0, #0x16e6
700ab3ee: f2c7 000b    	movt	r0, #0x700b
700ab3f2: 4669         	mov	r1, sp
700ab3f4: 6008         	str	r0, [r1]
700ab3f6: f641 11a8    	movw	r1, #0x19a8
700ab3fa: f2c7 010b    	movt	r1, #0x700b
700ab3fe: f641 326a    	movw	r2, #0x1b6a
700ab402: f2c7 020b    	movt	r2, #0x700b
700ab406: 2001         	movs	r0, #0x1
700ab408: 9002         	str	r0, [sp, #0x8]
700ab40a: 2370         	movs	r3, #0x70
700ab40c: f7ff fb10    	bl	0x700aaa30 <_DebugP_assert> @ imm = #-0x9e0
700ab410: 9802         	ldr	r0, [sp, #0x8]
;     pSemaphore->isRecursiveMutex = 1;
700ab412: 9904         	ldr	r1, [sp, #0x10]
700ab414: 6548         	str	r0, [r1, #0x54]
;     pSemaphore->semHndl = xSemaphoreCreateRecursiveMutexStatic(&pSemaphore->semObj);
700ab416: 9904         	ldr	r1, [sp, #0x10]
700ab418: 2004         	movs	r0, #0x4
700ab41a: f003 f879    	bl	0x700ae510 <xQueueCreateMutexStatic> @ imm = #0x30f2
700ab41e: 9904         	ldr	r1, [sp, #0x10]
700ab420: 6508         	str	r0, [r1, #0x50]
;     if( pSemaphore->semHndl == NULL )
700ab422: 9804         	ldr	r0, [sp, #0x10]
700ab424: 6d00         	ldr	r0, [r0, #0x50]
700ab426: b920         	cbnz	r0, 0x700ab432 <SemaphoreP_constructMutex+0x52> @ imm = #0x8
700ab428: e7ff         	b	0x700ab42a <SemaphoreP_constructMutex+0x4a> @ imm = #-0x2
700ab42a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700ab42e: 9003         	str	r0, [sp, #0xc]
;     }
700ab430: e00a         	b	0x700ab448 <SemaphoreP_constructMutex+0x68> @ imm = #0x14
;         vQueueAddToRegistry(pSemaphore->semHndl, "Mutex (DPL)");
700ab432: 9804         	ldr	r0, [sp, #0x10]
700ab434: 6d00         	ldr	r0, [r0, #0x50]
700ab436: f641 51f4    	movw	r1, #0x1df4
700ab43a: f2c7 010b    	movt	r1, #0x700b
700ab43e: f001 fcef    	bl	0x700ace20 <vQueueAddToRegistry> @ imm = #0x19de
700ab442: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700ab444: 9003         	str	r0, [sp, #0xc]
700ab446: e7ff         	b	0x700ab448 <SemaphoreP_constructMutex+0x68> @ imm = #-0x2
;     return status;
700ab448: 9803         	ldr	r0, [sp, #0xc]
700ab44a: b006         	add	sp, #0x18
700ab44c: bd80         	pop	{r7, pc}
700ab44e: 0000         	movs	r0, r0

700ab450 <UdmaChPrms_init>:
; {
700ab450: b580         	push	{r7, lr}
700ab452: b082         	sub	sp, #0x8
700ab454: 9001         	str	r0, [sp, #0x4]
700ab456: 9100         	str	r1, [sp]
;     if(NULL_PTR != chPrms)
700ab458: 9801         	ldr	r0, [sp, #0x4]
700ab45a: b368         	cbz	r0, 0x700ab4b8 <UdmaChPrms_init+0x68> @ imm = #0x5a
700ab45c: e7ff         	b	0x700ab45e <UdmaChPrms_init+0xe> @ imm = #-0x2
;         chPrms->chNum       = UDMA_DMA_CH_ANY;
700ab45e: 9901         	ldr	r1, [sp, #0x4]
700ab460: 2001         	movs	r0, #0x1
700ab462: f6cf 70ff    	movt	r0, #0xffff
700ab466: 6008         	str	r0, [r1]
;         chPrms->peerChNum   = UDMA_DMA_CH_INVALID;
700ab468: 9901         	ldr	r1, [sp, #0x4]
700ab46a: 2000         	movs	r0, #0x0
700ab46c: f6cf 70ff    	movt	r0, #0xffff
700ab470: 6048         	str	r0, [r1, #0x4]
;         if(UDMA_CH_TYPE_TR_BLK_COPY == chType)
700ab472: 9800         	ldr	r0, [sp]
700ab474: 2807         	cmp	r0, #0x7
700ab476: d106         	bne	0x700ab486 <UdmaChPrms_init+0x36> @ imm = #0xc
700ab478: e7ff         	b	0x700ab47a <UdmaChPrms_init+0x2a> @ imm = #-0x2
;             chPrms->peerChNum   = UDMA_DMA_CH_NA;
700ab47a: 9901         	ldr	r1, [sp, #0x4]
700ab47c: 2002         	movs	r0, #0x2
700ab47e: f6cf 70ff    	movt	r0, #0xffff
700ab482: 6048         	str	r0, [r1, #0x4]
;         }
700ab484: e7ff         	b	0x700ab486 <UdmaChPrms_init+0x36> @ imm = #-0x2
;         chPrms->mappedChGrp = UDMA_MAPPED_GROUP_INVALID;
700ab486: 9901         	ldr	r1, [sp, #0x4]
700ab488: 2004         	movs	r0, #0x4
700ab48a: f6cf 70ff    	movt	r0, #0xffff
700ab48e: 6088         	str	r0, [r1, #0x8]
;         chPrms->appData     = NULL_PTR;
700ab490: 9901         	ldr	r1, [sp, #0x4]
700ab492: 2000         	movs	r0, #0x0
700ab494: 60c8         	str	r0, [r1, #0xc]
;         UdmaRingPrms_init(&chPrms->fqRingPrms);
700ab496: 9801         	ldr	r0, [sp, #0x4]
700ab498: 3010         	adds	r0, #0x10
700ab49a: f001 fbd1    	bl	0x700acc40 <UdmaRingPrms_init> @ imm = #0x17a2
;         UdmaRingPrms_init(&chPrms->cqRingPrms);
700ab49e: 9801         	ldr	r0, [sp, #0x4]
700ab4a0: 302c         	adds	r0, #0x2c
700ab4a2: f001 fbcd    	bl	0x700acc40 <UdmaRingPrms_init> @ imm = #0x179a
;         UdmaRingPrms_init(&chPrms->tdCqRingPrms);
700ab4a6: 9801         	ldr	r0, [sp, #0x4]
700ab4a8: 3048         	adds	r0, #0x48
700ab4aa: f001 fbc9    	bl	0x700acc40 <UdmaRingPrms_init> @ imm = #0x1792
;         chPrms->tdCqRingPrms.elemSize = UDMA_RING_ES_8BYTES;
700ab4ae: 9901         	ldr	r1, [sp, #0x4]
700ab4b0: 2001         	movs	r0, #0x1
700ab4b2: f881 0058    	strb.w	r0, [r1, #0x58]
;     }
700ab4b6: e7ff         	b	0x700ab4b8 <UdmaChPrms_init+0x68> @ imm = #-0x2
;     return;
700ab4b8: b002         	add	sp, #0x8
700ab4ba: bd80         	pop	{r7, pc}

700ab4bc <atoi>:
700ab4bc: e59f1060     	ldr	r1, [pc, #0x60]         @ 0x700ab524 <atoi+0x68>
700ab4c0: e4d02001     	ldrb	r2, [r0], #1
700ab4c4: e0813002     	add	r3, r1, r2
700ab4c8: e5d33001     	ldrb	r3, [r3, #0x1]
700ab4cc: e3130010     	tst	r3, #16
700ab4d0: 1afffffa     	bne	0x700ab4c0 <atoi+0x4>   @ imm = #-0x18
700ab4d4: e3a01000     	mov	r1, #0
700ab4d8: e352002b     	cmp	r2, #43
700ab4dc: 1352002d     	cmpne	r2, #45
700ab4e0: 0a000003     	beq	0x700ab4f4 <atoi+0x38>  @ imm = #0xc
700ab4e4: e2400001     	sub	r0, r0, #1
700ab4e8: e3a01000     	mov	r1, #0
700ab4ec: e1a03002     	mov	r3, r2
700ab4f0: ea000000     	b	0x700ab4f8 <atoi+0x3c>  @ imm = #0x0
700ab4f4: e5d03000     	ldrb	r3, [r0]
700ab4f8: e2433030     	sub	r3, r3, #48
700ab4fc: e3530009     	cmp	r3, #9
700ab500: 8a000003     	bhi	0x700ab514 <atoi+0x58>  @ imm = #0xc
700ab504: e0811101     	add	r1, r1, r1, lsl #2
700ab508: e2800001     	add	r0, r0, #1
700ab50c: e0831081     	add	r1, r3, r1, lsl #1
700ab510: eafffff7     	b	0x700ab4f4 <atoi+0x38>  @ imm = #-0x24
700ab514: e352002d     	cmp	r2, #45
700ab518: 02611000     	rsbeq	r1, r1, #0
700ab51c: e1a00001     	mov	r0, r1
700ab520: e12fff1e     	bx	lr
700ab524: 00 13 0b 70  	.word	0x700b1300
700ab528: 00 00 00 00  	.word	0x00000000
700ab52c: 00 00 00 00  	.word	0x00000000

700ab530 <Pinmux_lockMMR>:
; {
700ab530: b580         	push	{r7, lr}
700ab532: b084         	sub	sp, #0x10
700ab534: 9003         	str	r0, [sp, #0xc]
;     if(PINMUX_DOMAIN_ID_MAIN == domainId)
700ab536: 9803         	ldr	r0, [sp, #0xc]
700ab538: b908         	cbnz	r0, 0x700ab53e <Pinmux_lockMMR+0xe> @ imm = #0x2
700ab53a: e7ff         	b	0x700ab53c <Pinmux_lockMMR+0xc> @ imm = #-0x2
;     }
700ab53c: e7ff         	b	0x700ab53e <Pinmux_lockMMR+0xe> @ imm = #-0x2
;     if(PINMUX_DOMAIN_ID_MCU == domainId)
700ab53e: 9803         	ldr	r0, [sp, #0xc]
700ab540: 2801         	cmp	r0, #0x1
700ab542: d128         	bne	0x700ab596 <Pinmux_lockMMR+0x66> @ imm = #0x50
700ab544: e7ff         	b	0x700ab546 <Pinmux_lockMMR+0x16> @ imm = #-0x2
700ab546: f04f 6081    	mov.w	r0, #0x4080000
700ab54a: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_PADCFG_CTRL0_CFG0_BASE);
700ab54c: 9100         	str	r1, [sp]
700ab54e: f7fa f9d7    	bl	0x700a5900 <AddrTranslateP_getLocalAddr> @ imm = #-0x5c52
700ab552: 9900         	ldr	r1, [sp]
700ab554: 9002         	str	r0, [sp, #0x8]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK0_KICK0_OFFSET);
700ab556: 9802         	ldr	r0, [sp, #0x8]
700ab558: f241 0208    	movw	r2, #0x1008
700ab55c: 4410         	add	r0, r2
700ab55e: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700ab560: 9801         	ldr	r0, [sp, #0x4]
700ab562: f004 f935    	bl	0x700af7d0 <CSL_REG32_WR_RAW> @ imm = #0x426a
700ab566: 9900         	ldr	r1, [sp]
;         kickAddr++;
700ab568: 9801         	ldr	r0, [sp, #0x4]
700ab56a: 3004         	adds	r0, #0x4
700ab56c: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700ab56e: 9801         	ldr	r0, [sp, #0x4]
700ab570: f004 f92e    	bl	0x700af7d0 <CSL_REG32_WR_RAW> @ imm = #0x425c
700ab574: 9900         	ldr	r1, [sp]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK1_KICK0_OFFSET);
700ab576: 9802         	ldr	r0, [sp, #0x8]
700ab578: f245 0208    	movw	r2, #0x5008
700ab57c: 4410         	add	r0, r2
700ab57e: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700ab580: 9801         	ldr	r0, [sp, #0x4]
700ab582: f004 f925    	bl	0x700af7d0 <CSL_REG32_WR_RAW> @ imm = #0x424a
700ab586: 9900         	ldr	r1, [sp]
;         kickAddr++;
700ab588: 9801         	ldr	r0, [sp, #0x4]
700ab58a: 3004         	adds	r0, #0x4
700ab58c: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700ab58e: 9801         	ldr	r0, [sp, #0x4]
700ab590: f004 f91e    	bl	0x700af7d0 <CSL_REG32_WR_RAW> @ imm = #0x423c
;     }
700ab594: e7ff         	b	0x700ab596 <Pinmux_lockMMR+0x66> @ imm = #-0x2
;     return;
700ab596: b004         	add	sp, #0x10
700ab598: bd80         	pop	{r7, pc}
700ab59a: 0000         	movs	r0, r0
700ab59c: 0000         	movs	r0, r0
700ab59e: 0000         	movs	r0, r0

700ab5a0 <vListInsert>:
; {
700ab5a0: b084         	sub	sp, #0x10
700ab5a2: 9003         	str	r0, [sp, #0xc]
700ab5a4: 9102         	str	r1, [sp, #0x8]
;     const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
700ab5a6: 9802         	ldr	r0, [sp, #0x8]
700ab5a8: 6800         	ldr	r0, [r0]
700ab5aa: 9000         	str	r0, [sp]
;     if( xValueOfInsertion == portMAX_DELAY )
700ab5ac: 9800         	ldr	r0, [sp]
700ab5ae: 3001         	adds	r0, #0x1
700ab5b0: b920         	cbnz	r0, 0x700ab5bc <vListInsert+0x1c> @ imm = #0x8
700ab5b2: e7ff         	b	0x700ab5b4 <vListInsert+0x14> @ imm = #-0x2
;         pxIterator = pxList->xListEnd.pxPrevious;
700ab5b4: 9803         	ldr	r0, [sp, #0xc]
700ab5b6: 6900         	ldr	r0, [r0, #0x10]
700ab5b8: 9001         	str	r0, [sp, #0x4]
;     }
700ab5ba: e010         	b	0x700ab5de <vListInsert+0x3e> @ imm = #0x20
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
700ab5bc: 9803         	ldr	r0, [sp, #0xc]
700ab5be: 3008         	adds	r0, #0x8
700ab5c0: 9001         	str	r0, [sp, #0x4]
700ab5c2: e7ff         	b	0x700ab5c4 <vListInsert+0x24> @ imm = #-0x2
700ab5c4: 9801         	ldr	r0, [sp, #0x4]
700ab5c6: 6840         	ldr	r0, [r0, #0x4]
700ab5c8: 6800         	ldr	r0, [r0]
700ab5ca: 9900         	ldr	r1, [sp]
700ab5cc: 4288         	cmp	r0, r1
700ab5ce: d805         	bhi	0x700ab5dc <vListInsert+0x3c> @ imm = #0xa
700ab5d0: e7ff         	b	0x700ab5d2 <vListInsert+0x32> @ imm = #-0x2
;         }
700ab5d2: e7ff         	b	0x700ab5d4 <vListInsert+0x34> @ imm = #-0x2
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
700ab5d4: 9801         	ldr	r0, [sp, #0x4]
700ab5d6: 6840         	ldr	r0, [r0, #0x4]
700ab5d8: 9001         	str	r0, [sp, #0x4]
700ab5da: e7f3         	b	0x700ab5c4 <vListInsert+0x24> @ imm = #-0x1a
700ab5dc: e7ff         	b	0x700ab5de <vListInsert+0x3e> @ imm = #-0x2
;     pxNewListItem->pxNext = pxIterator->pxNext;
700ab5de: 9801         	ldr	r0, [sp, #0x4]
700ab5e0: 6840         	ldr	r0, [r0, #0x4]
700ab5e2: 9902         	ldr	r1, [sp, #0x8]
700ab5e4: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxNext->pxPrevious = pxNewListItem;
700ab5e6: 9802         	ldr	r0, [sp, #0x8]
700ab5e8: 6841         	ldr	r1, [r0, #0x4]
700ab5ea: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxPrevious = pxIterator;
700ab5ec: 9801         	ldr	r0, [sp, #0x4]
700ab5ee: 9902         	ldr	r1, [sp, #0x8]
700ab5f0: 6088         	str	r0, [r1, #0x8]
;     pxIterator->pxNext = pxNewListItem;
700ab5f2: 9802         	ldr	r0, [sp, #0x8]
700ab5f4: 9901         	ldr	r1, [sp, #0x4]
700ab5f6: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxContainer = pxList;
700ab5f8: 9803         	ldr	r0, [sp, #0xc]
700ab5fa: 9902         	ldr	r1, [sp, #0x8]
700ab5fc: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
700ab5fe: 9903         	ldr	r1, [sp, #0xc]
700ab600: 6808         	ldr	r0, [r1]
700ab602: 3001         	adds	r0, #0x1
700ab604: 6008         	str	r0, [r1]
; }
700ab606: b004         	add	sp, #0x10
700ab608: 4770         	bx	lr
700ab60a: 0000         	movs	r0, r0
700ab60c: 0000         	movs	r0, r0
700ab60e: 0000         	movs	r0, r0

700ab610 <Sciclient_rmIrqCfgIsDirectEvent>:
; {
700ab610: b580         	push	{r7, lr}
700ab612: b082         	sub	sp, #0x8
700ab614: 9001         	str	r0, [sp, #0x4]
700ab616: 2000         	movs	r0, #0x0
;     bool r = false;
700ab618: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab61c: 9801         	ldr	r0, [sp, #0x4]
700ab61e: 2101         	movs	r1, #0x1
700ab620: f003 fa1e    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x343c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700ab624: b310         	cbz	r0, 0x700ab66c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x44
700ab626: e7ff         	b	0x700ab628 <Sciclient_rmIrqCfgIsDirectEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab628: 9801         	ldr	r0, [sp, #0x4]
700ab62a: 2102         	movs	r1, #0x2
700ab62c: f003 fa18    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x3430
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700ab630: b1e0         	cbz	r0, 0x700ab66c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x38
700ab632: e7ff         	b	0x700ab634 <Sciclient_rmIrqCfgIsDirectEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab634: 9801         	ldr	r0, [sp, #0x4]
700ab636: 2104         	movs	r1, #0x4
700ab638: f003 fa12    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x3424
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700ab63c: b1b0         	cbz	r0, 0x700ab66c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x2c
700ab63e: e7ff         	b	0x700ab640 <Sciclient_rmIrqCfgIsDirectEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab640: 9801         	ldr	r0, [sp, #0x4]
700ab642: 2108         	movs	r1, #0x8
700ab644: f003 fa0c    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x3418
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700ab648: b180         	cbz	r0, 0x700ab66c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x20
700ab64a: e7ff         	b	0x700ab64c <Sciclient_rmIrqCfgIsDirectEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab64c: 9801         	ldr	r0, [sp, #0x4]
700ab64e: 2110         	movs	r1, #0x10
700ab650: f003 fa06    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x340c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700ab654: b150         	cbz	r0, 0x700ab66c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x14
700ab656: e7ff         	b	0x700ab658 <Sciclient_rmIrqCfgIsDirectEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab658: 9801         	ldr	r0, [sp, #0x4]
700ab65a: 2120         	movs	r1, #0x20
700ab65c: f003 fa00    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x3400
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab660: b120         	cbz	r0, 0x700ab66c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x8
700ab662: e7ff         	b	0x700ab664 <Sciclient_rmIrqCfgIsDirectEvent+0x54> @ imm = #-0x2
700ab664: 2001         	movs	r0, #0x1
;         r = true;
700ab666: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab66a: e7ff         	b	0x700ab66c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #-0x2
;     return r;
700ab66c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab670: f000 0001    	and	r0, r0, #0x1
700ab674: b002         	add	sp, #0x8
700ab676: bd80         	pop	{r7, pc}
		...

700ab680 <Sciclient_rmIrqCfgIsDirectNonEvent>:
; {
700ab680: b580         	push	{r7, lr}
700ab682: b082         	sub	sp, #0x8
700ab684: 9001         	str	r0, [sp, #0x4]
700ab686: 2000         	movs	r0, #0x0
;     bool r = false;
700ab688: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab68c: 9801         	ldr	r0, [sp, #0x4]
700ab68e: 2101         	movs	r1, #0x1
700ab690: f003 f9e6    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x33cc
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700ab694: b310         	cbz	r0, 0x700ab6dc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x44
700ab696: e7ff         	b	0x700ab698 <Sciclient_rmIrqCfgIsDirectNonEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab698: 9801         	ldr	r0, [sp, #0x4]
700ab69a: 2102         	movs	r1, #0x2
700ab69c: f003 f9e0    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x33c0
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700ab6a0: b1e0         	cbz	r0, 0x700ab6dc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x38
700ab6a2: e7ff         	b	0x700ab6a4 <Sciclient_rmIrqCfgIsDirectNonEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab6a4: 9801         	ldr	r0, [sp, #0x4]
700ab6a6: 2104         	movs	r1, #0x4
700ab6a8: f003 f9da    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x33b4
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == false) &&
700ab6ac: b9b0         	cbnz	r0, 0x700ab6dc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x2c
700ab6ae: e7ff         	b	0x700ab6b0 <Sciclient_rmIrqCfgIsDirectNonEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab6b0: 9801         	ldr	r0, [sp, #0x4]
700ab6b2: 2108         	movs	r1, #0x8
700ab6b4: f003 f9d4    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x33a8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == false) &&
700ab6b8: b980         	cbnz	r0, 0x700ab6dc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x20
700ab6ba: e7ff         	b	0x700ab6bc <Sciclient_rmIrqCfgIsDirectNonEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab6bc: 9801         	ldr	r0, [sp, #0x4]
700ab6be: 2110         	movs	r1, #0x10
700ab6c0: f003 f9ce    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x339c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == false) &&
700ab6c4: b950         	cbnz	r0, 0x700ab6dc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x14
700ab6c6: e7ff         	b	0x700ab6c8 <Sciclient_rmIrqCfgIsDirectNonEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab6c8: 9801         	ldr	r0, [sp, #0x4]
700ab6ca: 2120         	movs	r1, #0x20
700ab6cc: f003 f9c8    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x3390
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab6d0: b920         	cbnz	r0, 0x700ab6dc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x8
700ab6d2: e7ff         	b	0x700ab6d4 <Sciclient_rmIrqCfgIsDirectNonEvent+0x54> @ imm = #-0x2
700ab6d4: 2001         	movs	r0, #0x1
;         r = true;
700ab6d6: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab6da: e7ff         	b	0x700ab6dc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #-0x2
;     return r;
700ab6dc: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab6e0: f000 0001    	and	r0, r0, #0x1
700ab6e4: b002         	add	sp, #0x8
700ab6e6: bd80         	pop	{r7, pc}
		...

700ab6f0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly>:
; {
700ab6f0: b580         	push	{r7, lr}
700ab6f2: b082         	sub	sp, #0x8
700ab6f4: 9001         	str	r0, [sp, #0x4]
700ab6f6: 2000         	movs	r0, #0x0
;     bool r = false;
700ab6f8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab6fc: 9801         	ldr	r0, [sp, #0x4]
700ab6fe: 2101         	movs	r1, #0x1
700ab700: f003 f9ae    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x335c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == false) &&
700ab704: bb10         	cbnz	r0, 0x700ab74c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x44
700ab706: e7ff         	b	0x700ab708 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab708: 9801         	ldr	r0, [sp, #0x4]
700ab70a: 2102         	movs	r1, #0x2
700ab70c: f003 f9a8    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x3350
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == false) &&
700ab710: b9e0         	cbnz	r0, 0x700ab74c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x38
700ab712: e7ff         	b	0x700ab714 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab714: 9801         	ldr	r0, [sp, #0x4]
700ab716: 2104         	movs	r1, #0x4
700ab718: f003 f9a2    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x3344
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700ab71c: b1b0         	cbz	r0, 0x700ab74c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x2c
700ab71e: e7ff         	b	0x700ab720 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab720: 9801         	ldr	r0, [sp, #0x4]
700ab722: 2108         	movs	r1, #0x8
700ab724: f003 f99c    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x3338
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700ab728: b180         	cbz	r0, 0x700ab74c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x20
700ab72a: e7ff         	b	0x700ab72c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab72c: 9801         	ldr	r0, [sp, #0x4]
700ab72e: 2110         	movs	r1, #0x10
700ab730: f003 f996    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x332c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700ab734: b150         	cbz	r0, 0x700ab74c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x14
700ab736: e7ff         	b	0x700ab738 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab738: 9801         	ldr	r0, [sp, #0x4]
700ab73a: 2120         	movs	r1, #0x20
700ab73c: f003 f990    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x3320
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab740: b120         	cbz	r0, 0x700ab74c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x8
700ab742: e7ff         	b	0x700ab744 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x54> @ imm = #-0x2
700ab744: 2001         	movs	r0, #0x1
;         r = true;
700ab746: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab74a: e7ff         	b	0x700ab74c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #-0x2
;     return r;
700ab74c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab750: f000 0001    	and	r0, r0, #0x1
700ab754: b002         	add	sp, #0x8
700ab756: bd80         	pop	{r7, pc}
		...

700ab760 <Sciclient_rmIrqCfgIsOesOnly>:
; {
700ab760: b580         	push	{r7, lr}
700ab762: b082         	sub	sp, #0x8
700ab764: 9001         	str	r0, [sp, #0x4]
700ab766: 2000         	movs	r0, #0x0
;     bool r = false;
700ab768: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab76c: 9801         	ldr	r0, [sp, #0x4]
700ab76e: 2101         	movs	r1, #0x1
700ab770: f003 f976    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x32ec
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == false) &&
700ab774: bb10         	cbnz	r0, 0x700ab7bc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x44
700ab776: e7ff         	b	0x700ab778 <Sciclient_rmIrqCfgIsOesOnly+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab778: 9801         	ldr	r0, [sp, #0x4]
700ab77a: 2102         	movs	r1, #0x2
700ab77c: f003 f970    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x32e0
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == false) &&
700ab780: b9e0         	cbnz	r0, 0x700ab7bc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x38
700ab782: e7ff         	b	0x700ab784 <Sciclient_rmIrqCfgIsOesOnly+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab784: 9801         	ldr	r0, [sp, #0x4]
700ab786: 2104         	movs	r1, #0x4
700ab788: f003 f96a    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x32d4
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == false) &&
700ab78c: b9b0         	cbnz	r0, 0x700ab7bc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x2c
700ab78e: e7ff         	b	0x700ab790 <Sciclient_rmIrqCfgIsOesOnly+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab790: 9801         	ldr	r0, [sp, #0x4]
700ab792: 2108         	movs	r1, #0x8
700ab794: f003 f964    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x32c8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == false) &&
700ab798: b980         	cbnz	r0, 0x700ab7bc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x20
700ab79a: e7ff         	b	0x700ab79c <Sciclient_rmIrqCfgIsOesOnly+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab79c: 9801         	ldr	r0, [sp, #0x4]
700ab79e: 2110         	movs	r1, #0x10
700ab7a0: f003 f95e    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x32bc
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700ab7a4: b150         	cbz	r0, 0x700ab7bc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x14
700ab7a6: e7ff         	b	0x700ab7a8 <Sciclient_rmIrqCfgIsOesOnly+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab7a8: 9801         	ldr	r0, [sp, #0x4]
700ab7aa: 2120         	movs	r1, #0x20
700ab7ac: f003 f958    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x32b0
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab7b0: b920         	cbnz	r0, 0x700ab7bc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x8
700ab7b2: e7ff         	b	0x700ab7b4 <Sciclient_rmIrqCfgIsOesOnly+0x54> @ imm = #-0x2
700ab7b4: 2001         	movs	r0, #0x1
;         r = true;
700ab7b6: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab7ba: e7ff         	b	0x700ab7bc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #-0x2
;     return r;
700ab7bc: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab7c0: f000 0001    	and	r0, r0, #0x1
700ab7c4: b002         	add	sp, #0x8
700ab7c6: bd80         	pop	{r7, pc}
		...

700ab7d0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent>:
; {
700ab7d0: b580         	push	{r7, lr}
700ab7d2: b082         	sub	sp, #0x8
700ab7d4: 9001         	str	r0, [sp, #0x4]
700ab7d6: 2000         	movs	r0, #0x0
;     bool r = false;
700ab7d8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab7dc: 9801         	ldr	r0, [sp, #0x4]
700ab7de: 2101         	movs	r1, #0x1
700ab7e0: f003 f93e    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x327c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700ab7e4: b310         	cbz	r0, 0x700ab82c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x44
700ab7e6: e7ff         	b	0x700ab7e8 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab7e8: 9801         	ldr	r0, [sp, #0x4]
700ab7ea: 2102         	movs	r1, #0x2
700ab7ec: f003 f938    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x3270
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700ab7f0: b1e0         	cbz	r0, 0x700ab82c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x38
700ab7f2: e7ff         	b	0x700ab7f4 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab7f4: 9801         	ldr	r0, [sp, #0x4]
700ab7f6: 2104         	movs	r1, #0x4
700ab7f8: f003 f932    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x3264
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700ab7fc: b1b0         	cbz	r0, 0x700ab82c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x2c
700ab7fe: e7ff         	b	0x700ab800 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab800: 9801         	ldr	r0, [sp, #0x4]
700ab802: 2108         	movs	r1, #0x8
700ab804: f003 f92c    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x3258
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700ab808: b180         	cbz	r0, 0x700ab82c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x20
700ab80a: e7ff         	b	0x700ab80c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab80c: 9801         	ldr	r0, [sp, #0x4]
700ab80e: 2110         	movs	r1, #0x10
700ab810: f003 f926    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x324c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == false) &&
700ab814: b950         	cbnz	r0, 0x700ab82c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x14
700ab816: e7ff         	b	0x700ab818 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab818: 9801         	ldr	r0, [sp, #0x4]
700ab81a: 2120         	movs	r1, #0x20
700ab81c: f003 f920    	bl	0x700aea60 <Sciclient_rmParamIsValid> @ imm = #0x3240
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab820: b920         	cbnz	r0, 0x700ab82c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x8
700ab822: e7ff         	b	0x700ab824 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x54> @ imm = #-0x2
700ab824: 2001         	movs	r0, #0x1
;         r = true;
700ab826: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab82a: e7ff         	b	0x700ab82c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #-0x2
;     return r;
700ab82c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab830: f000 0001    	and	r0, r0, #0x1
700ab834: b002         	add	sp, #0x8
700ab836: bd80         	pop	{r7, pc}
		...

700ab840 <UART_divisorValCompute>:
; {
700ab840: b580         	push	{r7, lr}
700ab842: b088         	sub	sp, #0x20
700ab844: 9007         	str	r0, [sp, #0x1c]
700ab846: 9106         	str	r1, [sp, #0x18]
700ab848: 9205         	str	r2, [sp, #0x14]
700ab84a: 9304         	str	r3, [sp, #0x10]
700ab84c: 2000         	movs	r0, #0x0
;     uint32_t divisorValue = 0U;
700ab84e: 9003         	str	r0, [sp, #0xc]
;     uint32_t tempModeFlag = modeFlag & UART_MDR1_MODE_SELECT_MASK;
700ab850: 9805         	ldr	r0, [sp, #0x14]
700ab852: f000 0007    	and	r0, r0, #0x7
700ab856: 9002         	str	r0, [sp, #0x8]
;     switch (tempModeFlag)
700ab858: 9802         	ldr	r0, [sp, #0x8]
700ab85a: 9001         	str	r0, [sp, #0x4]
700ab85c: 2805         	cmp	r0, #0x5
700ab85e: d81f         	bhi	0x700ab8a0 <UART_divisorValCompute+0x60> @ imm = #0x3e
700ab860: 9901         	ldr	r1, [sp, #0x4]
700ab862: e8df f001    	tbb	[pc, r1]
700ab866: 03 03 1d 0a  	.word	0x0a1d0303
700ab86a: 12 1a        	.short	0x1a12
;             divisorValue = UART_divideRoundCloset(moduleClk, 16U * baudRate);
700ab86c: 9807         	ldr	r0, [sp, #0x1c]
700ab86e: 9906         	ldr	r1, [sp, #0x18]
700ab870: 0109         	lsls	r1, r1, #0x4
700ab872: f003 feb5    	bl	0x700af5e0 <UART_divideRoundCloset> @ imm = #0x3d6a
700ab876: 9003         	str	r0, [sp, #0xc]
;             break;
700ab878: e013         	b	0x700ab8a2 <UART_divisorValCompute+0x62> @ imm = #0x26
;             divisorValue = UART_divideRoundCloset(moduleClk, 13U * baudRate);
700ab87a: 9807         	ldr	r0, [sp, #0x1c]
700ab87c: 9906         	ldr	r1, [sp, #0x18]
700ab87e: 220d         	movs	r2, #0xd
700ab880: 4351         	muls	r1, r2, r1
700ab882: f003 fead    	bl	0x700af5e0 <UART_divideRoundCloset> @ imm = #0x3d5a
700ab886: 9003         	str	r0, [sp, #0xc]
;             break;
700ab888: e00b         	b	0x700ab8a2 <UART_divisorValCompute+0x62> @ imm = #0x16
;             divisorValue = UART_divideRoundCloset(moduleClk, mirOverSampRate * baudRate);
700ab88a: 9807         	ldr	r0, [sp, #0x1c]
700ab88c: 9904         	ldr	r1, [sp, #0x10]
700ab88e: 9a06         	ldr	r2, [sp, #0x18]
700ab890: 4351         	muls	r1, r2, r1
700ab892: f003 fea5    	bl	0x700af5e0 <UART_divideRoundCloset> @ imm = #0x3d4a
700ab896: 9003         	str	r0, [sp, #0xc]
;             break;
700ab898: e003         	b	0x700ab8a2 <UART_divisorValCompute+0x62> @ imm = #0x6
700ab89a: 2000         	movs	r0, #0x0
;             divisorValue = 0U;
700ab89c: 9003         	str	r0, [sp, #0xc]
;             break;
700ab89e: e000         	b	0x700ab8a2 <UART_divisorValCompute+0x62> @ imm = #0x0
;             break;
700ab8a0: e7ff         	b	0x700ab8a2 <UART_divisorValCompute+0x62> @ imm = #-0x2
;     return divisorValue;
700ab8a2: 9803         	ldr	r0, [sp, #0xc]
700ab8a4: b008         	add	sp, #0x20
700ab8a6: bd80         	pop	{r7, pc}
		...

700ab8b0 <CSL_udmapCppi5SetIds>:
; {
700ab8b0: b085         	sub	sp, #0x14
700ab8b2: 9004         	str	r0, [sp, #0x10]
700ab8b4: 9103         	str	r1, [sp, #0xc]
700ab8b6: 9202         	str	r2, [sp, #0x8]
700ab8b8: 9301         	str	r3, [sp, #0x4]
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700ab8ba: 9803         	ldr	r0, [sp, #0xc]
700ab8bc: 2803         	cmp	r0, #0x3
700ab8be: d114         	bne	0x700ab8ea <CSL_udmapCppi5SetIds+0x3a> @ imm = #0x28
700ab8c0: e7ff         	b	0x700ab8c2 <CSL_udmapCppi5SetIds+0x12> @ imm = #-0x2
;         v = ((CSL_UdmapCppi5TRPD *)pDesc)->pktInfo;
700ab8c2: 9804         	ldr	r0, [sp, #0x10]
700ab8c4: 6840         	ldr	r0, [r0, #0x4]
700ab8c6: 9000         	str	r0, [sp]
;         v &= ~(CSL_UDMAP_CPPI5_TRPD_PKTINFO_PKTID_MASK | CSL_UDMAP_CPPI5_TRPD_PKTINFO_FLOWID_MASK);
700ab8c8: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab8cc: 0600         	lsls	r0, r0, #0x18
700ab8ce: 9000         	str	r0, [sp]
;         v |= CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_PKTID, pktId )   |
700ab8d0: 9802         	ldr	r0, [sp, #0x8]
;              CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_FLOWID, flowId );
700ab8d2: 9901         	ldr	r1, [sp, #0x4]
700ab8d4: f36f 319f    	bfc	r1, #14, #18
;         v |= CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_PKTID, pktId )   |
700ab8d8: f360 3197    	bfi	r1, r0, #14, #10
700ab8dc: 9800         	ldr	r0, [sp]
700ab8de: 4308         	orrs	r0, r1
700ab8e0: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5TRPD *)pDesc)->pktInfo = v;
700ab8e2: 9800         	ldr	r0, [sp]
700ab8e4: 9904         	ldr	r1, [sp, #0x10]
700ab8e6: 6048         	str	r0, [r1, #0x4]
;     }
700ab8e8: e013         	b	0x700ab912 <CSL_udmapCppi5SetIds+0x62> @ imm = #0x26
;         v = ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1;
700ab8ea: 9804         	ldr	r0, [sp, #0x10]
700ab8ec: 6840         	ldr	r0, [r0, #0x4]
700ab8ee: 9000         	str	r0, [sp]
;         v &= ~(CSL_UDMAP_CPPI5_PD_PKTINFO1_PKTID_MASK | CSL_UDMAP_CPPI5_PD_PKTINFO1_FLOWID_MASK);
700ab8f0: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab8f4: 0600         	lsls	r0, r0, #0x18
700ab8f6: 9000         	str	r0, [sp]
;         v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_PKTID, pktId )   |
700ab8f8: 9802         	ldr	r0, [sp, #0x8]
;              CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_FLOWID, flowId );
700ab8fa: 9901         	ldr	r1, [sp, #0x4]
700ab8fc: f36f 319f    	bfc	r1, #14, #18
;         v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_PKTID, pktId )   |
700ab900: f360 3197    	bfi	r1, r0, #14, #10
700ab904: 9800         	ldr	r0, [sp]
700ab906: 4308         	orrs	r0, r1
700ab908: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1 = v;
700ab90a: 9800         	ldr	r0, [sp]
700ab90c: 9904         	ldr	r1, [sp, #0x10]
700ab90e: 6048         	str	r0, [r1, #0x4]
700ab910: e7ff         	b	0x700ab912 <CSL_udmapCppi5SetIds+0x62> @ imm = #-0x2
; }
700ab912: b005         	add	sp, #0x14
700ab914: 4770         	bx	lr
		...
700ab91e: 0000         	movs	r0, r0

700ab920 <Sciclient_rmIrGetInst>:
; {
700ab920: b083         	sub	sp, #0xc
700ab922: f8ad 000a    	strh.w	r0, [sp, #0xa]
700ab926: 2000         	movs	r0, #0x0
;     struct Sciclient_rmIrInst *inst = NULL;
700ab928: 9001         	str	r0, [sp, #0x4]
;     for (i = 0; i < SCICLIENT_RM_IR_NUM_INST; i++) {
700ab92a: f8ad 0002    	strh.w	r0, [sp, #0x2]
700ab92e: e7ff         	b	0x700ab930 <Sciclient_rmIrGetInst+0x10> @ imm = #-0x2
700ab930: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ab934: 2803         	cmp	r0, #0x3
700ab936: dc22         	bgt	0x700ab97e <Sciclient_rmIrGetInst+0x5e> @ imm = #0x44
700ab938: e7ff         	b	0x700ab93a <Sciclient_rmIrGetInst+0x1a> @ imm = #-0x2
;         if (id == gRmIrInstances[i].dev_id) {
700ab93a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700ab93e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700ab942: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ab946: f242 4184    	movw	r1, #0x2484
700ab94a: f2c7 010b    	movt	r1, #0x700b
700ab94e: f831 1032    	ldrh.w	r1, [r1, r2, lsl #3]
700ab952: 4288         	cmp	r0, r1
700ab954: d10c         	bne	0x700ab970 <Sciclient_rmIrGetInst+0x50> @ imm = #0x18
700ab956: e7ff         	b	0x700ab958 <Sciclient_rmIrGetInst+0x38> @ imm = #-0x2
;             inst = &gRmIrInstances[i];
700ab958: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ab95c: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ab960: f242 4084    	movw	r0, #0x2484
700ab964: f2c7 000b    	movt	r0, #0x700b
700ab968: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700ab96c: 9001         	str	r0, [sp, #0x4]
;             break;
700ab96e: e006         	b	0x700ab97e <Sciclient_rmIrGetInst+0x5e> @ imm = #0xc
;     }
700ab970: e7ff         	b	0x700ab972 <Sciclient_rmIrGetInst+0x52> @ imm = #-0x2
;     for (i = 0; i < SCICLIENT_RM_IR_NUM_INST; i++) {
700ab972: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ab976: 3001         	adds	r0, #0x1
700ab978: f8ad 0002    	strh.w	r0, [sp, #0x2]
700ab97c: e7d8         	b	0x700ab930 <Sciclient_rmIrGetInst+0x10> @ imm = #-0x50
;     return inst;
700ab97e: 9801         	ldr	r0, [sp, #0x4]
700ab980: b003         	add	sp, #0xc
700ab982: 4770         	bx	lr
		...

700ab990 <UART_fifoRegisterWrite>:
; {
700ab990: b580         	push	{r7, lr}
700ab992: b088         	sub	sp, #0x20
700ab994: 9007         	str	r0, [sp, #0x1c]
700ab996: 9106         	str	r1, [sp, #0x18]
700ab998: 2000         	movs	r0, #0x0
;     uint32_t isTxRxFifoEmpty = FALSE;
700ab99a: 9001         	str	r0, [sp, #0x4]
700ab99c: 9002         	str	r0, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700ab99e: 9807         	ldr	r0, [sp, #0x1c]
700ab9a0: 2180         	movs	r1, #0x80
700ab9a2: f000 fdc5    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #0xb8a
700ab9a6: 9901         	ldr	r1, [sp, #0x4]
700ab9a8: 9003         	str	r0, [sp, #0xc]
;     divLatchRegVal = UART_divisorLatchWrite(baseAddr, 0x0000U);
700ab9aa: 9807         	ldr	r0, [sp, #0x1c]
700ab9ac: f7f8 ffd8    	bl	0x700a4960 <UART_divisorLatchWrite> @ imm = #-0x7050
700ab9b0: 9005         	str	r0, [sp, #0x14]
;     enhanFnBitVal = UART_enhanFuncEnable(baseAddr);
700ab9b2: 9807         	ldr	r0, [sp, #0x1c]
700ab9b4: f002 fa34    	bl	0x700ade20 <UART_enhanFuncEnable> @ imm = #0x2468
700ab9b8: 9004         	str	r0, [sp, #0x10]
;     HW_WR_REG32(baseAddr + UART_FCR, fcrValue);
700ab9ba: 9807         	ldr	r0, [sp, #0x1c]
700ab9bc: 3008         	adds	r0, #0x8
700ab9be: 9906         	ldr	r1, [sp, #0x18]
700ab9c0: f003 ff56    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x3eac
;     while(isTxRxFifoEmpty == FALSE)
700ab9c4: e7ff         	b	0x700ab9c6 <UART_fifoRegisterWrite+0x36> @ imm = #-0x2
700ab9c6: 9802         	ldr	r0, [sp, #0x8]
700ab9c8: b928         	cbnz	r0, 0x700ab9d6 <UART_fifoRegisterWrite+0x46> @ imm = #0xa
700ab9ca: e7ff         	b	0x700ab9cc <UART_fifoRegisterWrite+0x3c> @ imm = #-0x2
;         isTxRxFifoEmpty = UART_IsTxRxFifoEmpty(baseAddr);
700ab9cc: 9807         	ldr	r0, [sp, #0x1c]
700ab9ce: f002 fa07    	bl	0x700adde0 <UART_IsTxRxFifoEmpty> @ imm = #0x240e
700ab9d2: 9002         	str	r0, [sp, #0x8]
;     while(isTxRxFifoEmpty == FALSE)
700ab9d4: e7f7         	b	0x700ab9c6 <UART_fifoRegisterWrite+0x36> @ imm = #-0x12
;     UART_enhanFuncBitValRestore(baseAddr, enhanFnBitVal);
700ab9d6: 9807         	ldr	r0, [sp, #0x1c]
700ab9d8: 9904         	ldr	r1, [sp, #0x10]
700ab9da: f002 fd39    	bl	0x700ae450 <UART_enhanFuncBitValRestore> @ imm = #0x2a72
;     (void) UART_divisorLatchWrite(baseAddr, divLatchRegVal);
700ab9de: 9807         	ldr	r0, [sp, #0x1c]
700ab9e0: 9905         	ldr	r1, [sp, #0x14]
700ab9e2: f7f8 ffbd    	bl	0x700a4960 <UART_divisorLatchWrite> @ imm = #-0x7086
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ab9e6: 9807         	ldr	r0, [sp, #0x1c]
700ab9e8: 300c         	adds	r0, #0xc
700ab9ea: 9903         	ldr	r1, [sp, #0xc]
700ab9ec: f003 ff40    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x3e80
; }
700ab9f0: b008         	add	sp, #0x20
700ab9f2: bd80         	pop	{r7, pc}
		...

700aba00 <UART_lld_deInitDma>:
; {
700aba00: b580         	push	{r7, lr}
700aba02: b084         	sub	sp, #0x10
700aba04: 9003         	str	r0, [sp, #0xc]
700aba06: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700aba08: 9002         	str	r0, [sp, #0x8]
;     if (NULL_PTR != hUart)
700aba0a: 9803         	ldr	r0, [sp, #0xc]
700aba0c: b318         	cbz	r0, 0x700aba56 <UART_lld_deInitDma+0x56> @ imm = #0x46
700aba0e: e7ff         	b	0x700aba10 <UART_lld_deInitDma+0x10> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700aba10: 9903         	ldr	r1, [sp, #0xc]
700aba12: 2002         	movs	r0, #0x2
700aba14: 6548         	str	r0, [r1, #0x54]
;        status = UART_lld_flushTxFifo(hUart);
700aba16: 9803         	ldr	r0, [sp, #0xc]
700aba18: f7fe fc02    	bl	0x700aa220 <UART_lld_flushTxFifo> @ imm = #-0x17fc
700aba1c: 9002         	str	r0, [sp, #0x8]
;         if(status == UART_STATUS_SUCCESS)
700aba1e: 9802         	ldr	r0, [sp, #0x8]
700aba20: b9a0         	cbnz	r0, 0x700aba4c <UART_lld_deInitDma+0x4c> @ imm = #0x28
700aba22: e7ff         	b	0x700aba24 <UART_lld_deInitDma+0x24> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr,
700aba24: 9803         	ldr	r0, [sp, #0xc]
700aba26: 6800         	ldr	r0, [r0]
700aba28: 2107         	movs	r1, #0x7
700aba2a: 9101         	str	r1, [sp, #0x4]
700aba2c: f7fa fb08    	bl	0x700a6040 <UART_intrDisable> @ imm = #-0x59f0
;             UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700aba30: 9803         	ldr	r0, [sp, #0xc]
700aba32: 6800         	ldr	r0, [r0]
700aba34: 2102         	movs	r1, #0x2
700aba36: f003 f85b    	bl	0x700aeaf0 <UART_intr2Disable> @ imm = #0x30b6
700aba3a: 9901         	ldr	r1, [sp, #0x4]
;             (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700aba3c: 9803         	ldr	r0, [sp, #0xc]
700aba3e: 6800         	ldr	r0, [r0]
700aba40: f003 f89e    	bl	0x700aeb80 <UART_operatingModeSelect> @ imm = #0x313c
;             hUart->state = UART_STATE_RESET;
700aba44: 9903         	ldr	r1, [sp, #0xc]
700aba46: 2000         	movs	r0, #0x0
700aba48: 6548         	str	r0, [r1, #0x54]
;         }
700aba4a: e7ff         	b	0x700aba4c <UART_lld_deInitDma+0x4c> @ imm = #-0x2
;         status = UART_lld_dmaDeInit(hUart);
700aba4c: 9803         	ldr	r0, [sp, #0xc]
700aba4e: f002 fa07    	bl	0x700ade60 <UART_lld_dmaDeInit> @ imm = #0x240e
700aba52: 9002         	str	r0, [sp, #0x8]
;     }
700aba54: e003         	b	0x700aba5e <UART_lld_deInitDma+0x5e> @ imm = #0x6
700aba56: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700aba5a: 9002         	str	r0, [sp, #0x8]
700aba5c: e7ff         	b	0x700aba5e <UART_lld_deInitDma+0x5e> @ imm = #-0x2
;     return status;
700aba5e: 9802         	ldr	r0, [sp, #0x8]
700aba60: b004         	add	sp, #0x10
700aba62: bd80         	pop	{r7, pc}
		...

700aba70 <Udma_rmFreeEvent>:
; {
700aba70: b580         	push	{r7, lr}
700aba72: b088         	sub	sp, #0x20
700aba74: 9007         	str	r0, [sp, #0x1c]
700aba76: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aba78: 9806         	ldr	r0, [sp, #0x18]
700aba7a: f500 70ea    	add.w	r0, r0, #0x1d4
700aba7e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aba80: 9806         	ldr	r0, [sp, #0x18]
700aba82: f500 609f    	add.w	r0, r0, #0x4f8
700aba86: f04f 31ff    	mov.w	r1, #0xffffffff
700aba8a: f7fe fd79    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #-0x150e
;     i = globalEvent - rmInitPrms->startGlobalEvent;
700aba8e: 9807         	ldr	r0, [sp, #0x1c]
700aba90: 9901         	ldr	r1, [sp, #0x4]
700aba92: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700aba96: 1a40         	subs	r0, r0, r1
700aba98: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aba9a: 9805         	ldr	r0, [sp, #0x14]
700aba9c: 0940         	lsrs	r0, r0, #0x5
700aba9e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abaa0: 9805         	ldr	r0, [sp, #0x14]
700abaa2: 9904         	ldr	r1, [sp, #0x10]
700abaa4: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abaa8: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abaaa: 9903         	ldr	r1, [sp, #0xc]
700abaac: 2001         	movs	r0, #0x1
700abaae: 4088         	lsls	r0, r1
700abab0: 9002         	str	r0, [sp, #0x8]
;     drvHandle->globalEventFlag[offset] |= bitMask;
700abab2: 9a02         	ldr	r2, [sp, #0x8]
700abab4: 9806         	ldr	r0, [sp, #0x18]
700abab6: 9904         	ldr	r1, [sp, #0x10]
700abab8: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ababc: f8d1 0424    	ldr.w	r0, [r1, #0x424]
700abac0: 4310         	orrs	r0, r2
700abac2: f8c1 0424    	str.w	r0, [r1, #0x424]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abac6: 9806         	ldr	r0, [sp, #0x18]
700abac8: f500 609f    	add.w	r0, r0, #0x4f8
700abacc: f000 f8e8    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x1d0
;     return;
700abad0: b008         	add	sp, #0x20
700abad2: bd80         	pop	{r7, pc}
		...

700abae0 <Udma_rmFreeIrIntr>:
; {
700abae0: b580         	push	{r7, lr}
700abae2: b088         	sub	sp, #0x20
700abae4: 9007         	str	r0, [sp, #0x1c]
700abae6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abae8: 9806         	ldr	r0, [sp, #0x18]
700abaea: f500 70ea    	add.w	r0, r0, #0x1d4
700abaee: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abaf0: 9806         	ldr	r0, [sp, #0x18]
700abaf2: f500 609f    	add.w	r0, r0, #0x4f8
700abaf6: f04f 31ff    	mov.w	r1, #0xffffffff
700abafa: f7fe fd41    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #-0x157e
;     i = irIntrNum - rmInitPrms->startIrIntr;
700abafe: 9807         	ldr	r0, [sp, #0x1c]
700abb00: 9901         	ldr	r1, [sp, #0x4]
700abb02: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700abb06: 1a40         	subs	r0, r0, r1
700abb08: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abb0a: 9805         	ldr	r0, [sp, #0x14]
700abb0c: 0940         	lsrs	r0, r0, #0x5
700abb0e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abb10: 9805         	ldr	r0, [sp, #0x14]
700abb12: 9904         	ldr	r1, [sp, #0x10]
700abb14: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abb18: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abb1a: 9903         	ldr	r1, [sp, #0xc]
700abb1c: 2001         	movs	r0, #0x1
700abb1e: 4088         	lsls	r0, r1
700abb20: 9002         	str	r0, [sp, #0x8]
;     drvHandle->irIntrFlag[offset] |= bitMask;
700abb22: 9a02         	ldr	r2, [sp, #0x8]
700abb24: 9806         	ldr	r0, [sp, #0x18]
700abb26: 9904         	ldr	r1, [sp, #0x10]
700abb28: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abb2c: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700abb30: 4310         	orrs	r0, r2
700abb32: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abb36: 9806         	ldr	r0, [sp, #0x18]
700abb38: f500 609f    	add.w	r0, r0, #0x4f8
700abb3c: f000 f8b0    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0x160
;     return;
700abb40: b008         	add	sp, #0x20
700abb42: bd80         	pop	{r7, pc}
		...

700abb50 <Udma_rmFreeVintr>:
; {
700abb50: b580         	push	{r7, lr}
700abb52: b088         	sub	sp, #0x20
700abb54: 9007         	str	r0, [sp, #0x1c]
700abb56: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abb58: 9806         	ldr	r0, [sp, #0x18]
700abb5a: f500 70ea    	add.w	r0, r0, #0x1d4
700abb5e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abb60: 9806         	ldr	r0, [sp, #0x18]
700abb62: f500 609f    	add.w	r0, r0, #0x4f8
700abb66: f04f 31ff    	mov.w	r1, #0xffffffff
700abb6a: f7fe fd09    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #-0x15ee
;     i = vintrNum - rmInitPrms->startVintr;
700abb6e: 9807         	ldr	r0, [sp, #0x1c]
700abb70: 9901         	ldr	r1, [sp, #0x4]
700abb72: f8d1 10e0    	ldr.w	r1, [r1, #0xe0]
700abb76: 1a40         	subs	r0, r0, r1
700abb78: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abb7a: 9805         	ldr	r0, [sp, #0x14]
700abb7c: 0940         	lsrs	r0, r0, #0x5
700abb7e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abb80: 9805         	ldr	r0, [sp, #0x14]
700abb82: 9904         	ldr	r1, [sp, #0x10]
700abb84: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abb88: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abb8a: 9903         	ldr	r1, [sp, #0xc]
700abb8c: 2001         	movs	r0, #0x1
700abb8e: 4088         	lsls	r0, r1
700abb90: 9002         	str	r0, [sp, #0x8]
;     drvHandle->vintrFlag[offset] |= bitMask;
700abb92: 9a02         	ldr	r2, [sp, #0x8]
700abb94: 9806         	ldr	r0, [sp, #0x18]
700abb96: 9904         	ldr	r1, [sp, #0x10]
700abb98: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abb9c: f8d1 04a4    	ldr.w	r0, [r1, #0x4a4]
700abba0: 4310         	orrs	r0, r2
700abba2: f8c1 04a4    	str.w	r0, [r1, #0x4a4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abba6: 9806         	ldr	r0, [sp, #0x18]
700abba8: f500 609f    	add.w	r0, r0, #0x4f8
700abbac: f000 f878    	bl	0x700abca0 <SemaphoreP_post> @ imm = #0xf0
;     return;
700abbb0: b008         	add	sp, #0x20
700abbb2: bd80         	pop	{r7, pc}
		...

700abbc0 <vApplicationLoadHook>:
; {
700abbc0: b580         	push	{r7, lr}
700abbc2: b082         	sub	sp, #0x8
;     uint64_t curUpdateTime = ClockP_getTimeUsec();
700abbc4: f7fe feb4    	bl	0x700aa930 <ClockP_getTimeUsec> @ imm = #-0x1298
700abbc8: 9101         	str	r1, [sp, #0x4]
700abbca: 9000         	str	r0, [sp]
;     if( (curUpdateTime > lastUpdateTime) && ((curUpdateTime - lastUpdateTime) > (TaskP_LOAD_UPDATE_WINDOW_MSEC*1000u )) )
700abbcc: 9b00         	ldr	r3, [sp]
700abbce: 9901         	ldr	r1, [sp, #0x4]
700abbd0: f242 6078    	movw	r0, #0x2678
700abbd4: f2c7 000b    	movt	r0, #0x700b
700abbd8: 6802         	ldr	r2, [r0]
700abbda: 6840         	ldr	r0, [r0, #0x4]
700abbdc: 1ad2         	subs	r2, r2, r3
700abbde: 4188         	sbcs	r0, r1
700abbe0: d21e         	bhs	0x700abc20 <vApplicationLoadHook+0x60> @ imm = #0x3c
700abbe2: e7ff         	b	0x700abbe4 <vApplicationLoadHook+0x24> @ imm = #-0x2
700abbe4: 9900         	ldr	r1, [sp]
700abbe6: 9801         	ldr	r0, [sp, #0x4]
700abbe8: f242 6278    	movw	r2, #0x2678
700abbec: f2c7 020b    	movt	r2, #0x700b
700abbf0: 6813         	ldr	r3, [r2]
700abbf2: 6852         	ldr	r2, [r2, #0x4]
700abbf4: 1ac9         	subs	r1, r1, r3
700abbf6: 4190         	sbcs	r0, r2
700abbf8: f24a 1221    	movw	r2, #0xa121
700abbfc: f2c0 0207    	movt	r2, #0x7
700abc00: 1a89         	subs	r1, r1, r2
700abc02: f170 0000    	sbcs	r0, r0, #0x0
700abc06: d30b         	blo	0x700abc20 <vApplicationLoadHook+0x60> @ imm = #0x16
700abc08: e7ff         	b	0x700abc0a <vApplicationLoadHook+0x4a> @ imm = #-0x2
;         TaskP_loadUpdateAll();
700abc0a: f7f8 fd01    	bl	0x700a4610 <TaskP_loadUpdateAll> @ imm = #-0x75fe
;         lastUpdateTime = curUpdateTime;
700abc0e: 9800         	ldr	r0, [sp]
700abc10: 9a01         	ldr	r2, [sp, #0x4]
700abc12: f242 6178    	movw	r1, #0x2678
700abc16: f2c7 010b    	movt	r1, #0x700b
700abc1a: 604a         	str	r2, [r1, #0x4]
700abc1c: 6008         	str	r0, [r1]
;     }
700abc1e: e7ff         	b	0x700abc20 <vApplicationLoadHook+0x60> @ imm = #-0x2
; }
700abc20: b002         	add	sp, #0x8
700abc22: bd80         	pop	{r7, pc}
		...

700abc30 <vQueueWaitForMessageRestricted>:
;     {
700abc30: b580         	push	{r7, lr}
700abc32: b084         	sub	sp, #0x10
700abc34: 9003         	str	r0, [sp, #0xc]
700abc36: 9102         	str	r1, [sp, #0x8]
700abc38: 9201         	str	r2, [sp, #0x4]
;         Queue_t * const pxQueue = xQueue;
700abc3a: 9803         	ldr	r0, [sp, #0xc]
700abc3c: 9000         	str	r0, [sp]
;         prvLockQueue( pxQueue );
700abc3e: f002 fc47    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0x288e
700abc42: 9800         	ldr	r0, [sp]
700abc44: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700abc48: 3001         	adds	r0, #0x1
700abc4a: b928         	cbnz	r0, 0x700abc58 <vQueueWaitForMessageRestricted+0x28> @ imm = #0xa
700abc4c: e7ff         	b	0x700abc4e <vQueueWaitForMessageRestricted+0x1e> @ imm = #-0x2
700abc4e: 9900         	ldr	r1, [sp]
700abc50: 2000         	movs	r0, #0x0
700abc52: f881 0044    	strb.w	r0, [r1, #0x44]
700abc56: e7ff         	b	0x700abc58 <vQueueWaitForMessageRestricted+0x28> @ imm = #-0x2
700abc58: 9800         	ldr	r0, [sp]
700abc5a: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700abc5e: 3001         	adds	r0, #0x1
700abc60: b928         	cbnz	r0, 0x700abc6e <vQueueWaitForMessageRestricted+0x3e> @ imm = #0xa
700abc62: e7ff         	b	0x700abc64 <vQueueWaitForMessageRestricted+0x34> @ imm = #-0x2
700abc64: 9900         	ldr	r1, [sp]
700abc66: 2000         	movs	r0, #0x0
700abc68: f881 0045    	strb.w	r0, [r1, #0x45]
700abc6c: e7ff         	b	0x700abc6e <vQueueWaitForMessageRestricted+0x3e> @ imm = #-0x2
700abc6e: f001 fcef    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0x19de
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
700abc72: 9800         	ldr	r0, [sp]
700abc74: 6b80         	ldr	r0, [r0, #0x38]
700abc76: b938         	cbnz	r0, 0x700abc88 <vQueueWaitForMessageRestricted+0x58> @ imm = #0xe
700abc78: e7ff         	b	0x700abc7a <vQueueWaitForMessageRestricted+0x4a> @ imm = #-0x2
;             vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
700abc7a: 9800         	ldr	r0, [sp]
700abc7c: 3024         	adds	r0, #0x24
700abc7e: 9902         	ldr	r1, [sp, #0x8]
700abc80: 9a01         	ldr	r2, [sp, #0x4]
700abc82: f002 faad    	bl	0x700ae1e0 <vTaskPlaceOnEventListRestricted> @ imm = #0x255a
;         }
700abc86: e000         	b	0x700abc8a <vQueueWaitForMessageRestricted+0x5a> @ imm = #0x0
700abc88: e7ff         	b	0x700abc8a <vQueueWaitForMessageRestricted+0x5a> @ imm = #-0x2
;         prvUnlockQueue( pxQueue );
700abc8a: 9800         	ldr	r0, [sp]
700abc8c: f7fb ffd8    	bl	0x700a7c40 <prvUnlockQueue> @ imm = #-0x4050
;     }
700abc90: b004         	add	sp, #0x10
700abc92: bd80         	pop	{r7, pc}
		...

700abca0 <SemaphoreP_post>:
; {
700abca0: b580         	push	{r7, lr}
700abca2: b084         	sub	sp, #0x10
700abca4: 9003         	str	r0, [sp, #0xc]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700abca6: 9803         	ldr	r0, [sp, #0xc]
700abca8: 9002         	str	r0, [sp, #0x8]
;     if(pSemaphore->isRecursiveMutex != 0U)
700abcaa: 9802         	ldr	r0, [sp, #0x8]
700abcac: 6d40         	ldr	r0, [r0, #0x54]
700abcae: b170         	cbz	r0, 0x700abcce <SemaphoreP_post+0x2e> @ imm = #0x1c
700abcb0: e7ff         	b	0x700abcb2 <SemaphoreP_post+0x12> @ imm = #-0x2
;         if( HwiP_inISR() == 0U)
700abcb2: f004 f9f5    	bl	0x700b00a0 <HwiP_inISR> @ imm = #0x43ea
700abcb6: b928         	cbnz	r0, 0x700abcc4 <SemaphoreP_post+0x24> @ imm = #0xa
700abcb8: e7ff         	b	0x700abcba <SemaphoreP_post+0x1a> @ imm = #-0x2
;             (void)xSemaphoreGiveRecursive(pSemaphore->semHndl);
700abcba: 9802         	ldr	r0, [sp, #0x8]
700abcbc: 6d00         	ldr	r0, [r0, #0x50]
700abcbe: f001 f937    	bl	0x700acf30 <xQueueGiveMutexRecursive> @ imm = #0x126e
;         }
700abcc2: e003         	b	0x700abccc <SemaphoreP_post+0x2c> @ imm = #0x6
700abcc4: 2000         	movs	r0, #0x0
;             DebugP_assertNoLog(0);
700abcc6: f005 f98b    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x5316
700abcca: e7ff         	b	0x700abccc <SemaphoreP_post+0x2c> @ imm = #-0x2
;     }
700abccc: e017         	b	0x700abcfe <SemaphoreP_post+0x5e> @ imm = #0x2e
;         if( HwiP_inISR() != 0U)
700abcce: f004 f9e7    	bl	0x700b00a0 <HwiP_inISR> @ imm = #0x43ce
700abcd2: b158         	cbz	r0, 0x700abcec <SemaphoreP_post+0x4c> @ imm = #0x16
700abcd4: e7ff         	b	0x700abcd6 <SemaphoreP_post+0x36> @ imm = #-0x2
700abcd6: 2000         	movs	r0, #0x0
;             BaseType_t xHigherPriorityTaskWoken = 0;
700abcd8: 9001         	str	r0, [sp, #0x4]
;             (void)xSemaphoreGiveFromISR(pSemaphore->semHndl, &xHigherPriorityTaskWoken);
700abcda: 9802         	ldr	r0, [sp, #0x8]
700abcdc: 6d00         	ldr	r0, [r0, #0x50]
700abcde: a901         	add	r1, sp, #0x4
700abce0: f7fd fdae    	bl	0x700a9840 <xQueueGiveFromISR> @ imm = #-0x24a4
;             portYIELD_FROM_ISR((uint32_t)xHigherPriorityTaskWoken);
700abce4: 9801         	ldr	r0, [sp, #0x4]
700abce6: f003 fb03    	bl	0x700af2f0 <vPortYeildFromISR> @ imm = #0x3606
;         }
700abcea: e007         	b	0x700abcfc <SemaphoreP_post+0x5c> @ imm = #0xe
;             (void)xSemaphoreGive(pSemaphore->semHndl);
700abcec: 9802         	ldr	r0, [sp, #0x8]
700abcee: 6d00         	ldr	r0, [r0, #0x50]
700abcf0: 2300         	movs	r3, #0x0
700abcf2: 4619         	mov	r1, r3
700abcf4: 461a         	mov	r2, r3
700abcf6: f7f7 f9fb    	bl	0x700a30f0 <xQueueGenericSend> @ imm = #-0x8c0a
700abcfa: e7ff         	b	0x700abcfc <SemaphoreP_post+0x5c> @ imm = #-0x2
700abcfc: e7ff         	b	0x700abcfe <SemaphoreP_post+0x5e> @ imm = #-0x2
; }
700abcfe: b004         	add	sp, #0x10
700abd00: bd80         	pop	{r7, pc}
		...
700abd0e: 0000         	movs	r0, r0

700abd10 <UdmaEventPrms_init>:
; {
700abd10: b082         	sub	sp, #0x8
700abd12: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != eventPrms)
700abd14: 9801         	ldr	r0, [sp, #0x4]
700abd16: b350         	cbz	r0, 0x700abd6e <UdmaEventPrms_init+0x5e> @ imm = #0x54
700abd18: e7ff         	b	0x700abd1a <UdmaEventPrms_init+0xa> @ imm = #-0x2
;         eventPrms->eventType            = UDMA_EVENT_TYPE_DMA_COMPLETION;
700abd1a: 9801         	ldr	r0, [sp, #0x4]
700abd1c: 2101         	movs	r1, #0x1
700abd1e: 6001         	str	r1, [r0]
;         eventPrms->eventMode            = UDMA_EVENT_MODE_SHARED;
700abd20: 9a01         	ldr	r2, [sp, #0x4]
700abd22: 2002         	movs	r0, #0x2
700abd24: 6050         	str	r0, [r2, #0x4]
;         eventPrms->chHandle             = (Udma_ChHandle) NULL_PTR;
700abd26: 9a01         	ldr	r2, [sp, #0x4]
700abd28: 2000         	movs	r0, #0x0
700abd2a: 9000         	str	r0, [sp]
700abd2c: 6090         	str	r0, [r2, #0x8]
;         eventPrms->ringHandle           = (Udma_RingHandle) NULL_PTR;
700abd2e: 9a01         	ldr	r2, [sp, #0x4]
700abd30: 60d0         	str	r0, [r2, #0xc]
;         eventPrms->controllerEventHandle    = (Udma_EventHandle) NULL_PTR;
700abd32: 9a01         	ldr	r2, [sp, #0x4]
700abd34: 6110         	str	r0, [r2, #0x10]
;         eventPrms->eventCb              = (Udma_EventCallback) NULL_PTR;
700abd36: 9a01         	ldr	r2, [sp, #0x4]
700abd38: 6150         	str	r0, [r2, #0x14]
;         eventPrms->intrPriority         = 1U;
700abd3a: 9a01         	ldr	r2, [sp, #0x4]
700abd3c: 6191         	str	r1, [r2, #0x18]
;         eventPrms->appData              = NULL_PTR;
700abd3e: 9901         	ldr	r1, [sp, #0x4]
700abd40: 61c8         	str	r0, [r1, #0x1c]
;         eventPrms->preferredCoreIntrNum = UDMA_CORE_INTR_ANY;
700abd42: 9a01         	ldr	r2, [sp, #0x4]
700abd44: 2101         	movs	r1, #0x1
700abd46: f6cf 71ff    	movt	r1, #0xffff
700abd4a: 6211         	str	r1, [r2, #0x20]
;         eventPrms->intrStatusReg        = (volatile uint64_t *) NULL_PTR;
700abd4c: 9901         	ldr	r1, [sp, #0x4]
700abd4e: 6248         	str	r0, [r1, #0x24]
;         eventPrms->intrClearReg         = (volatile uint64_t *) NULL_PTR;
700abd50: 9901         	ldr	r1, [sp, #0x4]
700abd52: 6288         	str	r0, [r1, #0x28]
;         eventPrms->intrMask             = 0U;
700abd54: 9901         	ldr	r1, [sp, #0x4]
700abd56: 6348         	str	r0, [r1, #0x34]
700abd58: 6308         	str	r0, [r1, #0x30]
;         eventPrms->vintrNum             = UDMA_EVENT_INVALID;
700abd5a: 9901         	ldr	r1, [sp, #0x4]
700abd5c: f64f 70ff    	movw	r0, #0xffff
700abd60: 6388         	str	r0, [r1, #0x38]
;         eventPrms->coreIntrNum          = UDMA_INTR_INVALID;
700abd62: 9901         	ldr	r1, [sp, #0x4]
700abd64: 2000         	movs	r0, #0x0
700abd66: f6cf 70ff    	movt	r0, #0xffff
700abd6a: 63c8         	str	r0, [r1, #0x3c]
;     }
700abd6c: e7ff         	b	0x700abd6e <UdmaEventPrms_init+0x5e> @ imm = #-0x2
;     return;
700abd6e: b002         	add	sp, #0x8
700abd70: 4770         	bx	lr
		...
700abd7e: 0000         	movs	r0, r0

700abd80 <Udma_rmFreeBlkCopyCh>:
; {
700abd80: b580         	push	{r7, lr}
700abd82: b088         	sub	sp, #0x20
700abd84: 9007         	str	r0, [sp, #0x1c]
700abd86: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abd88: 9806         	ldr	r0, [sp, #0x18]
700abd8a: f500 70ea    	add.w	r0, r0, #0x1d4
700abd8e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abd90: 9806         	ldr	r0, [sp, #0x18]
700abd92: f500 609f    	add.w	r0, r0, #0x4f8
700abd96: f04f 31ff    	mov.w	r1, #0xffffffff
700abd9a: f7fe fbf1    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #-0x181e
;     i = chNum - rmInitPrms->startBlkCopyCh;
700abd9e: 9807         	ldr	r0, [sp, #0x1c]
700abda0: 9901         	ldr	r1, [sp, #0x4]
700abda2: 6909         	ldr	r1, [r1, #0x10]
700abda4: 1a40         	subs	r0, r0, r1
700abda6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abda8: 9805         	ldr	r0, [sp, #0x14]
700abdaa: 0940         	lsrs	r0, r0, #0x5
700abdac: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abdae: 9805         	ldr	r0, [sp, #0x14]
700abdb0: 9904         	ldr	r1, [sp, #0x10]
700abdb2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abdb6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abdb8: 9903         	ldr	r1, [sp, #0xc]
700abdba: 2001         	movs	r0, #0x1
700abdbc: 4088         	lsls	r0, r1
700abdbe: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyChFlag[offset] |= bitMask;
700abdc0: 9a02         	ldr	r2, [sp, #0x8]
700abdc2: 9806         	ldr	r0, [sp, #0x18]
700abdc4: 9904         	ldr	r1, [sp, #0x10]
700abdc6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abdca: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700abdce: 4310         	orrs	r0, r2
700abdd0: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abdd4: 9806         	ldr	r0, [sp, #0x18]
700abdd6: f500 609f    	add.w	r0, r0, #0x4f8
700abdda: f7ff ff61    	bl	0x700abca0 <SemaphoreP_post> @ imm = #-0x13e
;     return;
700abdde: b008         	add	sp, #0x20
700abde0: bd80         	pop	{r7, pc}
		...
700abdee: 0000         	movs	r0, r0

700abdf0 <Udma_rmFreeBlkCopyHcCh>:
; {
700abdf0: b580         	push	{r7, lr}
700abdf2: b088         	sub	sp, #0x20
700abdf4: 9007         	str	r0, [sp, #0x1c]
700abdf6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abdf8: 9806         	ldr	r0, [sp, #0x18]
700abdfa: f500 70ea    	add.w	r0, r0, #0x1d4
700abdfe: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abe00: 9806         	ldr	r0, [sp, #0x18]
700abe02: f500 609f    	add.w	r0, r0, #0x4f8
700abe06: f04f 31ff    	mov.w	r1, #0xffffffff
700abe0a: f7fe fbb9    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #-0x188e
;     i = chNum - rmInitPrms->startBlkCopyHcCh;
700abe0e: 9807         	ldr	r0, [sp, #0x1c]
700abe10: 9901         	ldr	r1, [sp, #0x4]
700abe12: 6889         	ldr	r1, [r1, #0x8]
700abe14: 1a40         	subs	r0, r0, r1
700abe16: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abe18: 9805         	ldr	r0, [sp, #0x14]
700abe1a: 0940         	lsrs	r0, r0, #0x5
700abe1c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abe1e: 9805         	ldr	r0, [sp, #0x14]
700abe20: 9904         	ldr	r1, [sp, #0x10]
700abe22: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abe26: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abe28: 9903         	ldr	r1, [sp, #0xc]
700abe2a: 2001         	movs	r0, #0x1
700abe2c: 4088         	lsls	r0, r1
700abe2e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyHcChFlag[offset] |= bitMask;
700abe30: 9a02         	ldr	r2, [sp, #0x8]
700abe32: 9806         	ldr	r0, [sp, #0x18]
700abe34: 9904         	ldr	r1, [sp, #0x10]
700abe36: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abe3a: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700abe3e: 4310         	orrs	r0, r2
700abe40: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abe44: 9806         	ldr	r0, [sp, #0x18]
700abe46: f500 609f    	add.w	r0, r0, #0x4f8
700abe4a: f7ff ff29    	bl	0x700abca0 <SemaphoreP_post> @ imm = #-0x1ae
;     return;
700abe4e: b008         	add	sp, #0x20
700abe50: bd80         	pop	{r7, pc}
		...
700abe5e: 0000         	movs	r0, r0

700abe60 <Udma_rmFreeBlkCopyUhcCh>:
; {
700abe60: b580         	push	{r7, lr}
700abe62: b088         	sub	sp, #0x20
700abe64: 9007         	str	r0, [sp, #0x1c]
700abe66: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abe68: 9806         	ldr	r0, [sp, #0x18]
700abe6a: f500 70ea    	add.w	r0, r0, #0x1d4
700abe6e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abe70: 9806         	ldr	r0, [sp, #0x18]
700abe72: f500 609f    	add.w	r0, r0, #0x4f8
700abe76: f04f 31ff    	mov.w	r1, #0xffffffff
700abe7a: f7fe fb81    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #-0x18fe
;     i = chNum - rmInitPrms->startBlkCopyUhcCh;
700abe7e: 9807         	ldr	r0, [sp, #0x1c]
700abe80: 9901         	ldr	r1, [sp, #0x4]
700abe82: 6809         	ldr	r1, [r1]
700abe84: 1a40         	subs	r0, r0, r1
700abe86: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abe88: 9805         	ldr	r0, [sp, #0x14]
700abe8a: 0940         	lsrs	r0, r0, #0x5
700abe8c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abe8e: 9805         	ldr	r0, [sp, #0x14]
700abe90: 9904         	ldr	r1, [sp, #0x10]
700abe92: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abe96: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abe98: 9903         	ldr	r1, [sp, #0xc]
700abe9a: 2001         	movs	r0, #0x1
700abe9c: 4088         	lsls	r0, r1
700abe9e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyUhcChFlag[offset] |= bitMask;
700abea0: 9a02         	ldr	r2, [sp, #0x8]
700abea2: 9806         	ldr	r0, [sp, #0x18]
700abea4: 9904         	ldr	r1, [sp, #0x10]
700abea6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abeaa: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700abeae: 4310         	orrs	r0, r2
700abeb0: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abeb4: 9806         	ldr	r0, [sp, #0x18]
700abeb6: f500 609f    	add.w	r0, r0, #0x4f8
700abeba: f7ff fef1    	bl	0x700abca0 <SemaphoreP_post> @ imm = #-0x21e
;     return;
700abebe: b008         	add	sp, #0x20
700abec0: bd80         	pop	{r7, pc}
		...
700abece: 0000         	movs	r0, r0

700abed0 <Udma_rmFreeRxCh>:
; {
700abed0: b580         	push	{r7, lr}
700abed2: b088         	sub	sp, #0x20
700abed4: 9007         	str	r0, [sp, #0x1c]
700abed6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abed8: 9806         	ldr	r0, [sp, #0x18]
700abeda: f500 70ea    	add.w	r0, r0, #0x1d4
700abede: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abee0: 9806         	ldr	r0, [sp, #0x18]
700abee2: f500 609f    	add.w	r0, r0, #0x4f8
700abee6: f04f 31ff    	mov.w	r1, #0xffffffff
700abeea: f7fe fb49    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #-0x196e
;     i = chNum - rmInitPrms->startRxCh;
700abeee: 9807         	ldr	r0, [sp, #0x1c]
700abef0: 9901         	ldr	r1, [sp, #0x4]
700abef2: 6c09         	ldr	r1, [r1, #0x40]
700abef4: 1a40         	subs	r0, r0, r1
700abef6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abef8: 9805         	ldr	r0, [sp, #0x14]
700abefa: 0940         	lsrs	r0, r0, #0x5
700abefc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abefe: 9805         	ldr	r0, [sp, #0x14]
700abf00: 9904         	ldr	r1, [sp, #0x10]
700abf02: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abf06: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abf08: 9903         	ldr	r1, [sp, #0xc]
700abf0a: 2001         	movs	r0, #0x1
700abf0c: 4088         	lsls	r0, r1
700abf0e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxChFlag[offset] |= bitMask;
700abf10: 9a02         	ldr	r2, [sp, #0x8]
700abf12: 9806         	ldr	r0, [sp, #0x18]
700abf14: 9904         	ldr	r1, [sp, #0x10]
700abf16: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abf1a: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700abf1e: 4310         	orrs	r0, r2
700abf20: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abf24: 9806         	ldr	r0, [sp, #0x18]
700abf26: f500 609f    	add.w	r0, r0, #0x4f8
700abf2a: f7ff feb9    	bl	0x700abca0 <SemaphoreP_post> @ imm = #-0x28e
;     return;
700abf2e: b008         	add	sp, #0x20
700abf30: bd80         	pop	{r7, pc}
		...
700abf3e: 0000         	movs	r0, r0

700abf40 <Udma_rmFreeRxHcCh>:
; {
700abf40: b580         	push	{r7, lr}
700abf42: b088         	sub	sp, #0x20
700abf44: 9007         	str	r0, [sp, #0x1c]
700abf46: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abf48: 9806         	ldr	r0, [sp, #0x18]
700abf4a: f500 70ea    	add.w	r0, r0, #0x1d4
700abf4e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abf50: 9806         	ldr	r0, [sp, #0x18]
700abf52: f500 609f    	add.w	r0, r0, #0x4f8
700abf56: f04f 31ff    	mov.w	r1, #0xffffffff
700abf5a: f7fe fb11    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #-0x19de
;     i = chNum - rmInitPrms->startRxHcCh;
700abf5e: 9807         	ldr	r0, [sp, #0x1c]
700abf60: 9901         	ldr	r1, [sp, #0x4]
700abf62: 6b89         	ldr	r1, [r1, #0x38]
700abf64: 1a40         	subs	r0, r0, r1
700abf66: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abf68: 9805         	ldr	r0, [sp, #0x14]
700abf6a: 0940         	lsrs	r0, r0, #0x5
700abf6c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abf6e: 9805         	ldr	r0, [sp, #0x14]
700abf70: 9904         	ldr	r1, [sp, #0x10]
700abf72: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abf76: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abf78: 9903         	ldr	r1, [sp, #0xc]
700abf7a: 2001         	movs	r0, #0x1
700abf7c: 4088         	lsls	r0, r1
700abf7e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxHcChFlag[offset] |= bitMask;
700abf80: 9a02         	ldr	r2, [sp, #0x8]
700abf82: 9806         	ldr	r0, [sp, #0x18]
700abf84: 9904         	ldr	r1, [sp, #0x10]
700abf86: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abf8a: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700abf8e: 4310         	orrs	r0, r2
700abf90: f8c1 031c    	str.w	r0, [r1, #0x31c]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abf94: 9806         	ldr	r0, [sp, #0x18]
700abf96: f500 609f    	add.w	r0, r0, #0x4f8
700abf9a: f7ff fe81    	bl	0x700abca0 <SemaphoreP_post> @ imm = #-0x2fe
;     return;
700abf9e: b008         	add	sp, #0x20
700abfa0: bd80         	pop	{r7, pc}
		...
700abfae: 0000         	movs	r0, r0

700abfb0 <Udma_rmFreeRxUhcCh>:
; {
700abfb0: b580         	push	{r7, lr}
700abfb2: b088         	sub	sp, #0x20
700abfb4: 9007         	str	r0, [sp, #0x1c]
700abfb6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abfb8: 9806         	ldr	r0, [sp, #0x18]
700abfba: f500 70ea    	add.w	r0, r0, #0x1d4
700abfbe: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abfc0: 9806         	ldr	r0, [sp, #0x18]
700abfc2: f500 609f    	add.w	r0, r0, #0x4f8
700abfc6: f04f 31ff    	mov.w	r1, #0xffffffff
700abfca: f7fe fad9    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #-0x1a4e
;     i = chNum - rmInitPrms->startRxUhcCh;
700abfce: 9807         	ldr	r0, [sp, #0x1c]
700abfd0: 9901         	ldr	r1, [sp, #0x4]
700abfd2: 6b09         	ldr	r1, [r1, #0x30]
700abfd4: 1a40         	subs	r0, r0, r1
700abfd6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abfd8: 9805         	ldr	r0, [sp, #0x14]
700abfda: 0940         	lsrs	r0, r0, #0x5
700abfdc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abfde: 9805         	ldr	r0, [sp, #0x14]
700abfe0: 9904         	ldr	r1, [sp, #0x10]
700abfe2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abfe6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abfe8: 9903         	ldr	r1, [sp, #0xc]
700abfea: 2001         	movs	r0, #0x1
700abfec: 4088         	lsls	r0, r1
700abfee: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxUhcChFlag[offset] |= bitMask;
700abff0: 9a02         	ldr	r2, [sp, #0x8]
700abff2: 9806         	ldr	r0, [sp, #0x18]
700abff4: 9904         	ldr	r1, [sp, #0x10]
700abff6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abffa: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700abffe: 4310         	orrs	r0, r2
700ac000: f8c1 0320    	str.w	r0, [r1, #0x320]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac004: 9806         	ldr	r0, [sp, #0x18]
700ac006: f500 609f    	add.w	r0, r0, #0x4f8
700ac00a: f7ff fe49    	bl	0x700abca0 <SemaphoreP_post> @ imm = #-0x36e
;     return;
700ac00e: b008         	add	sp, #0x20
700ac010: bd80         	pop	{r7, pc}
		...
700ac01e: 0000         	movs	r0, r0

700ac020 <Udma_rmFreeTxCh>:
; {
700ac020: b580         	push	{r7, lr}
700ac022: b088         	sub	sp, #0x20
700ac024: 9007         	str	r0, [sp, #0x1c]
700ac026: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac028: 9806         	ldr	r0, [sp, #0x18]
700ac02a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac02e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac030: 9806         	ldr	r0, [sp, #0x18]
700ac032: f500 609f    	add.w	r0, r0, #0x4f8
700ac036: f04f 31ff    	mov.w	r1, #0xffffffff
700ac03a: f7fe faa1    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #-0x1abe
;     i = chNum - rmInitPrms->startTxCh;
700ac03e: 9807         	ldr	r0, [sp, #0x1c]
700ac040: 9901         	ldr	r1, [sp, #0x4]
700ac042: 6a89         	ldr	r1, [r1, #0x28]
700ac044: 1a40         	subs	r0, r0, r1
700ac046: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac048: 9805         	ldr	r0, [sp, #0x14]
700ac04a: 0940         	lsrs	r0, r0, #0x5
700ac04c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac04e: 9805         	ldr	r0, [sp, #0x14]
700ac050: 9904         	ldr	r1, [sp, #0x10]
700ac052: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac056: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac058: 9903         	ldr	r1, [sp, #0xc]
700ac05a: 2001         	movs	r0, #0x1
700ac05c: 4088         	lsls	r0, r1
700ac05e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txChFlag[offset] |= bitMask;
700ac060: 9a02         	ldr	r2, [sp, #0x8]
700ac062: 9806         	ldr	r0, [sp, #0x18]
700ac064: 9904         	ldr	r1, [sp, #0x10]
700ac066: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac06a: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700ac06e: 4310         	orrs	r0, r2
700ac070: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac074: 9806         	ldr	r0, [sp, #0x18]
700ac076: f500 609f    	add.w	r0, r0, #0x4f8
700ac07a: f7ff fe11    	bl	0x700abca0 <SemaphoreP_post> @ imm = #-0x3de
;     return;
700ac07e: b008         	add	sp, #0x20
700ac080: bd80         	pop	{r7, pc}
		...
700ac08e: 0000         	movs	r0, r0

700ac090 <Udma_rmFreeTxHcCh>:
; {
700ac090: b580         	push	{r7, lr}
700ac092: b088         	sub	sp, #0x20
700ac094: 9007         	str	r0, [sp, #0x1c]
700ac096: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac098: 9806         	ldr	r0, [sp, #0x18]
700ac09a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac09e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac0a0: 9806         	ldr	r0, [sp, #0x18]
700ac0a2: f500 609f    	add.w	r0, r0, #0x4f8
700ac0a6: f04f 31ff    	mov.w	r1, #0xffffffff
700ac0aa: f7fe fa69    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #-0x1b2e
;     i = chNum - rmInitPrms->startTxHcCh;
700ac0ae: 9807         	ldr	r0, [sp, #0x1c]
700ac0b0: 9901         	ldr	r1, [sp, #0x4]
700ac0b2: 6a09         	ldr	r1, [r1, #0x20]
700ac0b4: 1a40         	subs	r0, r0, r1
700ac0b6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac0b8: 9805         	ldr	r0, [sp, #0x14]
700ac0ba: 0940         	lsrs	r0, r0, #0x5
700ac0bc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac0be: 9805         	ldr	r0, [sp, #0x14]
700ac0c0: 9904         	ldr	r1, [sp, #0x10]
700ac0c2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac0c6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac0c8: 9903         	ldr	r1, [sp, #0xc]
700ac0ca: 2001         	movs	r0, #0x1
700ac0cc: 4088         	lsls	r0, r1
700ac0ce: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txHcChFlag[offset] |= bitMask;
700ac0d0: 9a02         	ldr	r2, [sp, #0x8]
700ac0d2: 9806         	ldr	r0, [sp, #0x18]
700ac0d4: 9904         	ldr	r1, [sp, #0x10]
700ac0d6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac0da: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700ac0de: 4310         	orrs	r0, r2
700ac0e0: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac0e4: 9806         	ldr	r0, [sp, #0x18]
700ac0e6: f500 609f    	add.w	r0, r0, #0x4f8
700ac0ea: f7ff fdd9    	bl	0x700abca0 <SemaphoreP_post> @ imm = #-0x44e
;     return;
700ac0ee: b008         	add	sp, #0x20
700ac0f0: bd80         	pop	{r7, pc}
		...
700ac0fe: 0000         	movs	r0, r0

700ac100 <Udma_rmFreeTxUhcCh>:
; {
700ac100: b580         	push	{r7, lr}
700ac102: b088         	sub	sp, #0x20
700ac104: 9007         	str	r0, [sp, #0x1c]
700ac106: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac108: 9806         	ldr	r0, [sp, #0x18]
700ac10a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac10e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac110: 9806         	ldr	r0, [sp, #0x18]
700ac112: f500 609f    	add.w	r0, r0, #0x4f8
700ac116: f04f 31ff    	mov.w	r1, #0xffffffff
700ac11a: f7fe fa31    	bl	0x700aa580 <SemaphoreP_pend> @ imm = #-0x1b9e
;     i = chNum - rmInitPrms->startTxUhcCh;
700ac11e: 9807         	ldr	r0, [sp, #0x1c]
700ac120: 9901         	ldr	r1, [sp, #0x4]
700ac122: 6989         	ldr	r1, [r1, #0x18]
700ac124: 1a40         	subs	r0, r0, r1
700ac126: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac128: 9805         	ldr	r0, [sp, #0x14]
700ac12a: 0940         	lsrs	r0, r0, #0x5
700ac12c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac12e: 9805         	ldr	r0, [sp, #0x14]
700ac130: 9904         	ldr	r1, [sp, #0x10]
700ac132: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac136: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac138: 9903         	ldr	r1, [sp, #0xc]
700ac13a: 2001         	movs	r0, #0x1
700ac13c: 4088         	lsls	r0, r1
700ac13e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txUhcChFlag[offset] |= bitMask;
700ac140: 9a02         	ldr	r2, [sp, #0x8]
700ac142: 9806         	ldr	r0, [sp, #0x18]
700ac144: 9904         	ldr	r1, [sp, #0x10]
700ac146: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac14a: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700ac14e: 4310         	orrs	r0, r2
700ac150: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac154: 9806         	ldr	r0, [sp, #0x18]
700ac156: f500 609f    	add.w	r0, r0, #0x4f8
700ac15a: f7ff fda1    	bl	0x700abca0 <SemaphoreP_post> @ imm = #-0x4be
;     return;
700ac15e: b008         	add	sp, #0x20
700ac160: bd80         	pop	{r7, pc}
		...
700ac16e: 0000         	movs	r0, r0

700ac170 <UART_getChar>:
; {
700ac170: b580         	push	{r7, lr}
700ac172: b086         	sub	sp, #0x18
700ac174: 9005         	str	r0, [sp, #0x14]
700ac176: 9104         	str	r1, [sp, #0x10]
700ac178: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ac17a: 9003         	str	r0, [sp, #0xc]
;     uint32_t retVal      = FALSE;
700ac17c: 9002         	str	r0, [sp, #0x8]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ac17e: 9805         	ldr	r0, [sp, #0x14]
700ac180: 300c         	adds	r0, #0xc
700ac182: f003 fb6d    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x36da
700ac186: 9003         	str	r0, [sp, #0xc]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ac188: 9805         	ldr	r0, [sp, #0x14]
700ac18a: 300c         	adds	r0, #0xc
700ac18c: 9000         	str	r0, [sp]
700ac18e: f003 fb67    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x36ce
700ac192: 4601         	mov	r1, r0
700ac194: 9800         	ldr	r0, [sp]
700ac196: f001 017f    	and	r1, r1, #0x7f
700ac19a: f003 fb69    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x36d2
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700ac19e: 9805         	ldr	r0, [sp, #0x14]
700ac1a0: 3014         	adds	r0, #0x14
700ac1a2: f003 fb5d    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x36ba
;     if ((uint32_t) UART_LSR_RX_FIFO_E_RX_FIFO_E_VALUE_0 !=
700ac1a6: 07c0         	lsls	r0, r0, #0x1f
700ac1a8: b150         	cbz	r0, 0x700ac1c0 <UART_getChar+0x50> @ imm = #0x14
700ac1aa: e7ff         	b	0x700ac1ac <UART_getChar+0x3c> @ imm = #-0x2
;         uint32_t tempRetVal = HW_RD_REG32(baseAddr + UART_RHR);
700ac1ac: 9805         	ldr	r0, [sp, #0x14]
700ac1ae: f003 fb57    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x36ae
700ac1b2: 9001         	str	r0, [sp, #0x4]
;         *pChar = (uint8_t)tempRetVal;
700ac1b4: 9801         	ldr	r0, [sp, #0x4]
700ac1b6: 9904         	ldr	r1, [sp, #0x10]
700ac1b8: 7008         	strb	r0, [r1]
700ac1ba: 2001         	movs	r0, #0x1
;         retVal = TRUE;
700ac1bc: 9002         	str	r0, [sp, #0x8]
;     }
700ac1be: e7ff         	b	0x700ac1c0 <UART_getChar+0x50> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ac1c0: 9805         	ldr	r0, [sp, #0x14]
700ac1c2: 300c         	adds	r0, #0xc
700ac1c4: 9903         	ldr	r1, [sp, #0xc]
700ac1c6: f003 fb53    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x36a6
;     return retVal;
700ac1ca: 9802         	ldr	r0, [sp, #0x8]
700ac1cc: b006         	add	sp, #0x18
700ac1ce: bd80         	pop	{r7, pc}

700ac1d0 <UART_writeData>:
; {
700ac1d0: b580         	push	{r7, lr}
700ac1d2: b086         	sub	sp, #0x18
700ac1d4: 9005         	str	r0, [sp, #0x14]
700ac1d6: 9104         	str	r1, [sp, #0x10]
;     UARTLLD_InitHandle hUartInit = hUart->hUartInit;
700ac1d8: 9805         	ldr	r0, [sp, #0x14]
700ac1da: 6840         	ldr	r0, [r0, #0x4]
700ac1dc: 9001         	str	r0, [sp, #0x4]
;     numBytesToTransfer = writeSizeRemaining;
700ac1de: 9804         	ldr	r0, [sp, #0x10]
700ac1e0: 9003         	str	r0, [sp, #0xc]
;     if (numBytesToTransfer >= hUartInit->txTrigLvl)
700ac1e2: 9803         	ldr	r0, [sp, #0xc]
700ac1e4: 9901         	ldr	r1, [sp, #0x4]
700ac1e6: 6bc9         	ldr	r1, [r1, #0x3c]
700ac1e8: 4288         	cmp	r0, r1
700ac1ea: d304         	blo	0x700ac1f6 <UART_writeData+0x26> @ imm = #0x8
700ac1ec: e7ff         	b	0x700ac1ee <UART_writeData+0x1e> @ imm = #-0x2
;         numBytesToTransfer = hUartInit->txTrigLvl;
700ac1ee: 9801         	ldr	r0, [sp, #0x4]
700ac1f0: 6bc0         	ldr	r0, [r0, #0x3c]
700ac1f2: 9003         	str	r0, [sp, #0xc]
;     }
700ac1f4: e7ff         	b	0x700ac1f6 <UART_writeData+0x26> @ imm = #-0x2
;     numBytesToTransferred = numBytesToTransfer;
700ac1f6: 9803         	ldr	r0, [sp, #0xc]
700ac1f8: 9002         	str	r0, [sp, #0x8]
;     while (numBytesToTransfer != 0U)
700ac1fa: e7ff         	b	0x700ac1fc <UART_writeData+0x2c> @ imm = #-0x2
700ac1fc: 9803         	ldr	r0, [sp, #0xc]
700ac1fe: b190         	cbz	r0, 0x700ac226 <UART_writeData+0x56> @ imm = #0x24
700ac200: e7ff         	b	0x700ac202 <UART_writeData+0x32> @ imm = #-0x2
;         UART_putChar(hUart->baseAddr, *(const uint8_t *)hUart->writeBuf);
700ac202: 9905         	ldr	r1, [sp, #0x14]
700ac204: 6808         	ldr	r0, [r1]
700ac206: 6889         	ldr	r1, [r1, #0x8]
700ac208: 7809         	ldrb	r1, [r1]
700ac20a: f003 f931    	bl	0x700af470 <UART_putChar> @ imm = #0x3262
;         hUart->writeBuf = (const uint8_t *)hUart->writeBuf + 1U;
700ac20e: 9905         	ldr	r1, [sp, #0x14]
700ac210: 6888         	ldr	r0, [r1, #0x8]
700ac212: 3001         	adds	r0, #0x1
700ac214: 6088         	str	r0, [r1, #0x8]
;         numBytesToTransfer--;
700ac216: 9803         	ldr	r0, [sp, #0xc]
700ac218: 3801         	subs	r0, #0x1
700ac21a: 9003         	str	r0, [sp, #0xc]
;         hUart->writeCount++;
700ac21c: 9905         	ldr	r1, [sp, #0x14]
700ac21e: 68c8         	ldr	r0, [r1, #0xc]
700ac220: 3001         	adds	r0, #0x1
700ac222: 60c8         	str	r0, [r1, #0xc]
;     while (numBytesToTransfer != 0U)
700ac224: e7ea         	b	0x700ac1fc <UART_writeData+0x2c> @ imm = #-0x2c
;     return (writeSizeRemaining - numBytesToTransferred);
700ac226: 9804         	ldr	r0, [sp, #0x10]
700ac228: 9902         	ldr	r1, [sp, #0x8]
700ac22a: 1a40         	subs	r0, r0, r1
700ac22c: b006         	add	sp, #0x18
700ac22e: bd80         	pop	{r7, pc}

700ac230 <Udma_virtToPhyFxn>:
; {
700ac230: b580         	push	{r7, lr}
700ac232: b088         	sub	sp, #0x20
700ac234: 9007         	str	r0, [sp, #0x1c]
700ac236: 9106         	str	r1, [sp, #0x18]
700ac238: 9205         	str	r2, [sp, #0x14]
700ac23a: 2000         	movs	r0, #0x0
700ac23c: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700ac240: 9004         	str	r0, [sp, #0x10]
700ac242: 2000         	movs	r0, #0x0
;     void               *appData = NULL_PTR;
700ac244: 9003         	str	r0, [sp, #0xc]
;     if(NULL_PTR != chHandle)
700ac246: 9805         	ldr	r0, [sp, #0x14]
700ac248: b138         	cbz	r0, 0x700ac25a <Udma_virtToPhyFxn+0x2a> @ imm = #0xe
700ac24a: e7ff         	b	0x700ac24c <Udma_virtToPhyFxn+0x1c> @ imm = #-0x2
;         chNum   = chHandle->chPrms.chNum;
700ac24c: 9805         	ldr	r0, [sp, #0x14]
700ac24e: 6840         	ldr	r0, [r0, #0x4]
700ac250: 9004         	str	r0, [sp, #0x10]
;         appData = chHandle->chPrms.appData;
700ac252: 9805         	ldr	r0, [sp, #0x14]
700ac254: 6900         	ldr	r0, [r0, #0x10]
700ac256: 9003         	str	r0, [sp, #0xc]
;     }
700ac258: e7ff         	b	0x700ac25a <Udma_virtToPhyFxn+0x2a> @ imm = #-0x2
;     if((Udma_VirtToPhyFxn) NULL_PTR != drvHandle->initPrms.virtToPhyFxn)
700ac25a: 9806         	ldr	r0, [sp, #0x18]
700ac25c: f8d0 01cc    	ldr.w	r0, [r0, #0x1cc]
700ac260: b150         	cbz	r0, 0x700ac278 <Udma_virtToPhyFxn+0x48> @ imm = #0x14
700ac262: e7ff         	b	0x700ac264 <Udma_virtToPhyFxn+0x34> @ imm = #-0x2
;         phyAddr = drvHandle->initPrms.virtToPhyFxn(virtAddr, chNum, appData);
700ac264: 9806         	ldr	r0, [sp, #0x18]
700ac266: f8d0 31cc    	ldr.w	r3, [r0, #0x1cc]
700ac26a: 9807         	ldr	r0, [sp, #0x1c]
700ac26c: 9904         	ldr	r1, [sp, #0x10]
700ac26e: 9a03         	ldr	r2, [sp, #0xc]
700ac270: 4798         	blx	r3
700ac272: 9101         	str	r1, [sp, #0x4]
700ac274: 9000         	str	r0, [sp]
;     }
700ac276: e007         	b	0x700ac288 <Udma_virtToPhyFxn+0x58> @ imm = #0xe
;         phyAddr = Udma_defaultVirtToPhyFxn(virtAddr, chNum, appData);
700ac278: 9807         	ldr	r0, [sp, #0x1c]
700ac27a: 9904         	ldr	r1, [sp, #0x10]
700ac27c: 9a03         	ldr	r2, [sp, #0xc]
700ac27e: f003 faff    	bl	0x700af880 <Udma_defaultVirtToPhyFxn> @ imm = #0x35fe
700ac282: 9101         	str	r1, [sp, #0x4]
700ac284: 9000         	str	r0, [sp]
700ac286: e7ff         	b	0x700ac288 <Udma_virtToPhyFxn+0x58> @ imm = #-0x2
;     return (phyAddr);
700ac288: 9800         	ldr	r0, [sp]
700ac28a: 9901         	ldr	r1, [sp, #0x4]
700ac28c: b008         	add	sp, #0x20
700ac28e: bd80         	pop	{r7, pc}

700ac290 <Sciclient_pmSetModuleRst>:
; {
700ac290: b580         	push	{r7, lr}
700ac292: b090         	sub	sp, #0x40
700ac294: 900f         	str	r0, [sp, #0x3c]
700ac296: 910e         	str	r1, [sp, #0x38]
700ac298: 920d         	str	r2, [sp, #0x34]
700ac29a: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700ac29c: 900c         	str	r0, [sp, #0x30]
;     request.id     = (uint32_t) moduleId;
700ac29e: 990f         	ldr	r1, [sp, #0x3c]
700ac2a0: 910a         	str	r1, [sp, #0x28]
;     request.resets = (uint32_t) resetBit;
700ac2a2: 990e         	ldr	r1, [sp, #0x38]
700ac2a4: 910b         	str	r1, [sp, #0x2c]
700ac2a6: f240 2102    	movw	r1, #0x202
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_DEVICE_RESETS;
700ac2aa: f8ad 100c    	strh.w	r1, [sp, #0xc]
700ac2ae: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700ac2b0: 9104         	str	r1, [sp, #0x10]
700ac2b2: a908         	add	r1, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700ac2b4: 9105         	str	r1, [sp, #0x14]
700ac2b6: 2110         	movs	r1, #0x10
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700ac2b8: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700ac2ba: 990d         	ldr	r1, [sp, #0x34]
700ac2bc: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700ac2be: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700ac2c0: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700ac2c2: 9002         	str	r0, [sp, #0x8]
700ac2c4: a803         	add	r0, sp, #0xc
700ac2c6: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700ac2c8: f7f0 ffda    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xf04c
700ac2cc: 900c         	str	r0, [sp, #0x30]
;     if((retVal != SystemP_SUCCESS) ||
700ac2ce: 980c         	ldr	r0, [sp, #0x30]
700ac2d0: b930         	cbnz	r0, 0x700ac2e0 <Sciclient_pmSetModuleRst+0x50> @ imm = #0xc
700ac2d2: e7ff         	b	0x700ac2d4 <Sciclient_pmSetModuleRst+0x44> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700ac2d4: 9800         	ldr	r0, [sp]
700ac2d6: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700ac2da: 2802         	cmp	r0, #0x2
700ac2dc: d004         	beq	0x700ac2e8 <Sciclient_pmSetModuleRst+0x58> @ imm = #0x8
700ac2de: e7ff         	b	0x700ac2e0 <Sciclient_pmSetModuleRst+0x50> @ imm = #-0x2
700ac2e0: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700ac2e4: 900c         	str	r0, [sp, #0x30]
;     }
700ac2e6: e7ff         	b	0x700ac2e8 <Sciclient_pmSetModuleRst+0x58> @ imm = #-0x2
;     return retVal;
700ac2e8: 980c         	ldr	r0, [sp, #0x30]
700ac2ea: b010         	add	sp, #0x40
700ac2ec: bd80         	pop	{r7, pc}
700ac2ee: 0000         	movs	r0, r0

700ac2f0 <Sciclient_rmIaGetInst>:
; {
700ac2f0: b083         	sub	sp, #0xc
700ac2f2: f8ad 000a    	strh.w	r0, [sp, #0xa]
700ac2f6: 2000         	movs	r0, #0x0
;     struct Sciclient_rmIaInst *inst = NULL;
700ac2f8: 9001         	str	r0, [sp, #0x4]
;     for (i = 0; i < SCICLIENT_RM_IA_NUM_INST; i++) {
700ac2fa: f8ad 0002    	strh.w	r0, [sp, #0x2]
700ac2fe: e7ff         	b	0x700ac300 <Sciclient_rmIaGetInst+0x10> @ imm = #-0x2
700ac300: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ac304: 2800         	cmp	r0, #0x0
700ac306: dc1e         	bgt	0x700ac346 <Sciclient_rmIaGetInst+0x56> @ imm = #0x3c
700ac308: e7ff         	b	0x700ac30a <Sciclient_rmIaGetInst+0x1a> @ imm = #-0x2
;         if (id == gRmIaInstances[i].dev_id) {
700ac30a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700ac30e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700ac312: 014a         	lsls	r2, r1, #0x5
700ac314: f242 515c    	movw	r1, #0x255c
700ac318: f2c7 010b    	movt	r1, #0x700b
700ac31c: 5a89         	ldrh	r1, [r1, r2]
700ac31e: 4288         	cmp	r0, r1
700ac320: d10a         	bne	0x700ac338 <Sciclient_rmIaGetInst+0x48> @ imm = #0x14
700ac322: e7ff         	b	0x700ac324 <Sciclient_rmIaGetInst+0x34> @ imm = #-0x2
;             inst = &gRmIaInstances[i];
700ac324: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700ac328: f242 505c    	movw	r0, #0x255c
700ac32c: f2c7 000b    	movt	r0, #0x700b
700ac330: eb00 1041    	add.w	r0, r0, r1, lsl #5
700ac334: 9001         	str	r0, [sp, #0x4]
;             break;
700ac336: e006         	b	0x700ac346 <Sciclient_rmIaGetInst+0x56> @ imm = #0xc
;     }
700ac338: e7ff         	b	0x700ac33a <Sciclient_rmIaGetInst+0x4a> @ imm = #-0x2
;     for (i = 0; i < SCICLIENT_RM_IA_NUM_INST; i++) {
700ac33a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ac33e: 3001         	adds	r0, #0x1
700ac340: f8ad 0002    	strh.w	r0, [sp, #0x2]
700ac344: e7dc         	b	0x700ac300 <Sciclient_rmIaGetInst+0x10> @ imm = #-0x48
;     return inst;
700ac346: 9801         	ldr	r0, [sp, #0x4]
700ac348: b003         	add	sp, #0xc
700ac34a: 4770         	bx	lr
700ac34c: 0000         	movs	r0, r0
700ac34e: 0000         	movs	r0, r0

700ac350 <Sciclient_rmPsPush>:
; {
700ac350: b083         	sub	sp, #0xc
700ac352: 9002         	str	r0, [sp, #0x8]
700ac354: f8ad 1006    	strh.w	r1, [sp, #0x6]
700ac358: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ac35a: 9000         	str	r0, [sp]
;     if ((gPstack.psp < SCICLIENT_PS_MAX_DEPTH) && (n != NULL)) {
700ac35c: f241 0058    	movw	r0, #0x1058
700ac360: f2c7 0008    	movt	r0, #0x7008
700ac364: 8c80         	ldrh	r0, [r0, #0x24]
700ac366: 2802         	cmp	r0, #0x2
700ac368: dc19         	bgt	0x700ac39e <Sciclient_rmPsPush+0x4e> @ imm = #0x32
700ac36a: e7ff         	b	0x700ac36c <Sciclient_rmPsPush+0x1c> @ imm = #-0x2
700ac36c: 9802         	ldr	r0, [sp, #0x8]
700ac36e: b1b0         	cbz	r0, 0x700ac39e <Sciclient_rmPsPush+0x4e> @ imm = #0x2c
700ac370: e7ff         	b	0x700ac372 <Sciclient_rmPsPush+0x22> @ imm = #-0x2
;         gPstack.ps[gPstack.psp].p_n = n;
700ac372: 9802         	ldr	r0, [sp, #0x8]
700ac374: f241 0158    	movw	r1, #0x1058
700ac378: f2c7 0108    	movt	r1, #0x7008
700ac37c: 8c8a         	ldrh	r2, [r1, #0x24]
700ac37e: eb02 0242    	add.w	r2, r2, r2, lsl #1
700ac382: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gPstack.ps[gPstack.psp].if_idx = if_idx;
700ac386: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac38a: 8c8a         	ldrh	r2, [r1, #0x24]
700ac38c: eb02 0242    	add.w	r2, r2, r2, lsl #1
700ac390: eb01 0282    	add.w	r2, r1, r2, lsl #2
700ac394: 8090         	strh	r0, [r2, #0x4]
;         gPstack.psp++;
700ac396: 8c88         	ldrh	r0, [r1, #0x24]
700ac398: 3001         	adds	r0, #0x1
700ac39a: 8488         	strh	r0, [r1, #0x24]
;     } else {
700ac39c: e003         	b	0x700ac3a6 <Sciclient_rmPsPush+0x56> @ imm = #0x6
700ac39e: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac3a2: 9000         	str	r0, [sp]
700ac3a4: e7ff         	b	0x700ac3a6 <Sciclient_rmPsPush+0x56> @ imm = #-0x2
;     return r;
700ac3a6: 9800         	ldr	r0, [sp]
700ac3a8: b003         	add	sp, #0xc
700ac3aa: 4770         	bx	lr
700ac3ac: 0000         	movs	r0, r0
700ac3ae: 0000         	movs	r0, r0

700ac3b0 <UART_lld_deInit>:
; {
700ac3b0: b580         	push	{r7, lr}
700ac3b2: b084         	sub	sp, #0x10
700ac3b4: 9003         	str	r0, [sp, #0xc]
700ac3b6: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700ac3b8: 9002         	str	r0, [sp, #0x8]
;     if (NULL_PTR != hUart)
700ac3ba: 9803         	ldr	r0, [sp, #0xc]
700ac3bc: b1f8         	cbz	r0, 0x700ac3fe <UART_lld_deInit+0x4e> @ imm = #0x3e
700ac3be: e7ff         	b	0x700ac3c0 <UART_lld_deInit+0x10> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700ac3c0: 9903         	ldr	r1, [sp, #0xc]
700ac3c2: 2002         	movs	r0, #0x2
700ac3c4: 6548         	str	r0, [r1, #0x54]
;        status = UART_lld_flushTxFifo(hUart);
700ac3c6: 9803         	ldr	r0, [sp, #0xc]
700ac3c8: f7fd ff2a    	bl	0x700aa220 <UART_lld_flushTxFifo> @ imm = #-0x21ac
700ac3cc: 9002         	str	r0, [sp, #0x8]
;         if(status == UART_STATUS_SUCCESS)
700ac3ce: 9802         	ldr	r0, [sp, #0x8]
700ac3d0: b988         	cbnz	r0, 0x700ac3f6 <UART_lld_deInit+0x46> @ imm = #0x22
700ac3d2: e7ff         	b	0x700ac3d4 <UART_lld_deInit+0x24> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr,
700ac3d4: 9803         	ldr	r0, [sp, #0xc]
700ac3d6: 6800         	ldr	r0, [r0]
700ac3d8: 2107         	movs	r1, #0x7
700ac3da: 9101         	str	r1, [sp, #0x4]
700ac3dc: f7f9 fe30    	bl	0x700a6040 <UART_intrDisable> @ imm = #-0x63a0
;             UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700ac3e0: 9803         	ldr	r0, [sp, #0xc]
700ac3e2: 6800         	ldr	r0, [r0]
700ac3e4: 2102         	movs	r1, #0x2
700ac3e6: f002 fb83    	bl	0x700aeaf0 <UART_intr2Disable> @ imm = #0x2706
700ac3ea: 9901         	ldr	r1, [sp, #0x4]
;             (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700ac3ec: 9803         	ldr	r0, [sp, #0xc]
700ac3ee: 6800         	ldr	r0, [r0]
700ac3f0: f002 fbc6    	bl	0x700aeb80 <UART_operatingModeSelect> @ imm = #0x278c
;         }
700ac3f4: e7ff         	b	0x700ac3f6 <UART_lld_deInit+0x46> @ imm = #-0x2
;         hUart->state = UART_STATE_RESET;
700ac3f6: 9903         	ldr	r1, [sp, #0xc]
700ac3f8: 2000         	movs	r0, #0x0
700ac3fa: 6548         	str	r0, [r1, #0x54]
;     }
700ac3fc: e003         	b	0x700ac406 <UART_lld_deInit+0x56> @ imm = #0x6
700ac3fe: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700ac402: 9002         	str	r0, [sp, #0x8]
700ac404: e7ff         	b	0x700ac406 <UART_lld_deInit+0x56> @ imm = #-0x2
;     return status;
700ac406: 9802         	ldr	r0, [sp, #0x8]
700ac408: b004         	add	sp, #0x10
700ac40a: bd80         	pop	{r7, pc}
700ac40c: 0000         	movs	r0, r0
700ac40e: 0000         	movs	r0, r0

700ac410 <UART_lld_writeCompleteCallback>:
; {
700ac410: b580         	push	{r7, lr}
700ac412: b086         	sub	sp, #0x18
700ac414: 9005         	str	r0, [sp, #0x14]
;     UARTLLD_Handle hUart = (UARTLLD_Handle)args;
700ac416: 9805         	ldr	r0, [sp, #0x14]
700ac418: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != hUart)
700ac41a: 9802         	ldr	r0, [sp, #0x8]
700ac41c: b320         	cbz	r0, 0x700ac468 <UART_lld_writeCompleteCallback+0x58> @ imm = #0x48
700ac41e: e7ff         	b	0x700ac420 <UART_lld_writeCompleteCallback+0x10> @ imm = #-0x2
;         UART_Handle handle = (UART_Handle)hUart->args;
700ac420: 9802         	ldr	r0, [sp, #0x8]
700ac422: 6e00         	ldr	r0, [r0, #0x60]
700ac424: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != handle)
700ac426: 9801         	ldr	r0, [sp, #0x4]
700ac428: b1e8         	cbz	r0, 0x700ac466 <UART_lld_writeCompleteCallback+0x56> @ imm = #0x3a
700ac42a: e7ff         	b	0x700ac42c <UART_lld_writeCompleteCallback+0x1c> @ imm = #-0x2
;             config = (UART_Config *) handle;
700ac42c: 9801         	ldr	r0, [sp, #0x4]
700ac42e: 9004         	str	r0, [sp, #0x10]
;             obj = config->object;
700ac430: 9804         	ldr	r0, [sp, #0x10]
700ac432: 6840         	ldr	r0, [r0, #0x4]
700ac434: 9003         	str	r0, [sp, #0xc]
;             obj->writeTrans->count = hUart->writeTrans.count;
700ac436: 9802         	ldr	r0, [sp, #0x8]
700ac438: 6c00         	ldr	r0, [r0, #0x40]
700ac43a: 9903         	ldr	r1, [sp, #0xc]
700ac43c: f8d1 1080    	ldr.w	r1, [r1, #0x80]
700ac440: 6048         	str	r0, [r1, #0x4]
;             if (obj->prms.writeMode == UART_TRANSFER_MODE_CALLBACK)
700ac442: 9803         	ldr	r0, [sp, #0xc]
700ac444: 69c0         	ldr	r0, [r0, #0x1c]
700ac446: 2801         	cmp	r0, #0x1
700ac448: d107         	bne	0x700ac45a <UART_lld_writeCompleteCallback+0x4a> @ imm = #0xe
700ac44a: e7ff         	b	0x700ac44c <UART_lld_writeCompleteCallback+0x3c> @ imm = #-0x2
;                 obj->prms.writeCallbackFxn(hUart, &hUart->writeTrans);
700ac44c: 9803         	ldr	r0, [sp, #0xc]
700ac44e: 6a42         	ldr	r2, [r0, #0x24]
700ac450: 9802         	ldr	r0, [sp, #0x8]
700ac452: f100 013c    	add.w	r1, r0, #0x3c
700ac456: 4790         	blx	r2
;             }
700ac458: e004         	b	0x700ac464 <UART_lld_writeCompleteCallback+0x54> @ imm = #0x8
;                 SemaphoreP_post((SemaphoreP_Object *)hUart->writeTransferMutex);
700ac45a: 9802         	ldr	r0, [sp, #0x8]
700ac45c: 6dc0         	ldr	r0, [r0, #0x5c]
700ac45e: f7ff fc1f    	bl	0x700abca0 <SemaphoreP_post> @ imm = #-0x7c2
700ac462: e7ff         	b	0x700ac464 <UART_lld_writeCompleteCallback+0x54> @ imm = #-0x2
;         }
700ac464: e7ff         	b	0x700ac466 <UART_lld_writeCompleteCallback+0x56> @ imm = #-0x2
;     }
700ac466: e7ff         	b	0x700ac468 <UART_lld_writeCompleteCallback+0x58> @ imm = #-0x2
; }
700ac468: b006         	add	sp, #0x18
700ac46a: bd80         	pop	{r7, pc}
700ac46c: 0000         	movs	r0, r0
700ac46e: 0000         	movs	r0, r0

700ac470 <Sciclient_rmIaValidateGlobalEvt>:
; {
700ac470: b580         	push	{r7, lr}
700ac472: b086         	sub	sp, #0x18
700ac474: f8ad 0016    	strh.w	r0, [sp, #0x16]
700ac478: f8ad 1014    	strh.w	r1, [sp, #0x14]
700ac47c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ac47e: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIaInst *inst = NULL;
700ac480: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIaGetInst(id);
700ac482: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700ac486: f7ff ff33    	bl	0x700ac2f0 <Sciclient_rmIaGetInst> @ imm = #-0x19a
700ac48a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700ac48c: 9803         	ldr	r0, [sp, #0xc]
700ac48e: b920         	cbnz	r0, 0x700ac49a <Sciclient_rmIaValidateGlobalEvt+0x2a> @ imm = #0x8
700ac490: e7ff         	b	0x700ac492 <Sciclient_rmIaValidateGlobalEvt+0x22> @ imm = #-0x2
700ac492: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ac496: 9004         	str	r0, [sp, #0x10]
;     }
700ac498: e7ff         	b	0x700ac49a <Sciclient_rmIaValidateGlobalEvt+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ac49a: 9804         	ldr	r0, [sp, #0x10]
700ac49c: b990         	cbnz	r0, 0x700ac4c4 <Sciclient_rmIaValidateGlobalEvt+0x54> @ imm = #0x24
700ac49e: e7ff         	b	0x700ac4a0 <Sciclient_rmIaValidateGlobalEvt+0x30> @ imm = #-0x2
;         evt = global_evt - inst->sevt_offset;
700ac4a0: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700ac4a4: 9903         	ldr	r1, [sp, #0xc]
700ac4a6: 8909         	ldrh	r1, [r1, #0x8]
700ac4a8: 1a40         	subs	r0, r0, r1
700ac4aa: f8ad 000a    	strh.w	r0, [sp, #0xa]
;         r = Sciclient_rmIaValidateEvt(inst, evt, 0u, 0u, false);
700ac4ae: 9803         	ldr	r0, [sp, #0xc]
700ac4b0: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700ac4b4: 466a         	mov	r2, sp
700ac4b6: 2300         	movs	r3, #0x0
700ac4b8: 6013         	str	r3, [r2]
700ac4ba: 461a         	mov	r2, r3
700ac4bc: f7f7 ff88    	bl	0x700a43d0 <Sciclient_rmIaValidateEvt> @ imm = #-0x80f0
700ac4c0: 9004         	str	r0, [sp, #0x10]
;     }
700ac4c2: e7ff         	b	0x700ac4c4 <Sciclient_rmIaValidateGlobalEvt+0x54> @ imm = #-0x2
;     return r;
700ac4c4: 9804         	ldr	r0, [sp, #0x10]
700ac4c6: b006         	add	sp, #0x18
700ac4c8: bd80         	pop	{r7, pc}
700ac4ca: 0000         	movs	r0, r0
700ac4cc: 0000         	movs	r0, r0
700ac4ce: 0000         	movs	r0, r0

700ac4d0 <UART_lld_readCompleteCallback>:
; {
700ac4d0: b580         	push	{r7, lr}
700ac4d2: b086         	sub	sp, #0x18
700ac4d4: 9005         	str	r0, [sp, #0x14]
;     UARTLLD_Handle hUart = (UARTLLD_Handle)args;
700ac4d6: 9805         	ldr	r0, [sp, #0x14]
700ac4d8: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != hUart)
700ac4da: 9802         	ldr	r0, [sp, #0x8]
700ac4dc: b318         	cbz	r0, 0x700ac526 <UART_lld_readCompleteCallback+0x56> @ imm = #0x46
700ac4de: e7ff         	b	0x700ac4e0 <UART_lld_readCompleteCallback+0x10> @ imm = #-0x2
;         UART_Handle handle = (UART_Handle)hUart->args;
700ac4e0: 9802         	ldr	r0, [sp, #0x8]
700ac4e2: 6e00         	ldr	r0, [r0, #0x60]
700ac4e4: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != handle)
700ac4e6: 9801         	ldr	r0, [sp, #0x4]
700ac4e8: b1e0         	cbz	r0, 0x700ac524 <UART_lld_readCompleteCallback+0x54> @ imm = #0x38
700ac4ea: e7ff         	b	0x700ac4ec <UART_lld_readCompleteCallback+0x1c> @ imm = #-0x2
;             config = (UART_Config *) handle;
700ac4ec: 9801         	ldr	r0, [sp, #0x4]
700ac4ee: 9004         	str	r0, [sp, #0x10]
;             obj = config->object;
700ac4f0: 9804         	ldr	r0, [sp, #0x10]
700ac4f2: 6840         	ldr	r0, [r0, #0x4]
700ac4f4: 9003         	str	r0, [sp, #0xc]
;             obj->readTrans->count = hUart->readTrans.count;
700ac4f6: 9802         	ldr	r0, [sp, #0x8]
700ac4f8: 6ac0         	ldr	r0, [r0, #0x2c]
700ac4fa: 9903         	ldr	r1, [sp, #0xc]
700ac4fc: 6fc9         	ldr	r1, [r1, #0x7c]
700ac4fe: 6048         	str	r0, [r1, #0x4]
;             if (obj->prms.readMode == UART_TRANSFER_MODE_CALLBACK)
700ac500: 9803         	ldr	r0, [sp, #0xc]
700ac502: 6940         	ldr	r0, [r0, #0x14]
700ac504: 2801         	cmp	r0, #0x1
700ac506: d107         	bne	0x700ac518 <UART_lld_readCompleteCallback+0x48> @ imm = #0xe
700ac508: e7ff         	b	0x700ac50a <UART_lld_readCompleteCallback+0x3a> @ imm = #-0x2
;                 obj->prms.readCallbackFxn(hUart, &hUart->readTrans);
700ac50a: 9803         	ldr	r0, [sp, #0xc]
700ac50c: 6a02         	ldr	r2, [r0, #0x20]
700ac50e: 9802         	ldr	r0, [sp, #0x8]
700ac510: f100 0128    	add.w	r1, r0, #0x28
700ac514: 4790         	blx	r2
;             }
700ac516: e004         	b	0x700ac522 <UART_lld_readCompleteCallback+0x52> @ imm = #0x8
;                 SemaphoreP_post((SemaphoreP_Object *)hUart->readTransferMutex);
700ac518: 9802         	ldr	r0, [sp, #0x8]
700ac51a: 6d80         	ldr	r0, [r0, #0x58]
700ac51c: f7ff fbc0    	bl	0x700abca0 <SemaphoreP_post> @ imm = #-0x880
700ac520: e7ff         	b	0x700ac522 <UART_lld_readCompleteCallback+0x52> @ imm = #-0x2
;         }
700ac522: e7ff         	b	0x700ac524 <UART_lld_readCompleteCallback+0x54> @ imm = #-0x2
;     }
700ac524: e7ff         	b	0x700ac526 <UART_lld_readCompleteCallback+0x56> @ imm = #-0x2
; }
700ac526: b006         	add	sp, #0x18
700ac528: bd80         	pop	{r7, pc}
700ac52a: 0000         	movs	r0, r0
700ac52c: 0000         	movs	r0, r0
700ac52e: 0000         	movs	r0, r0

700ac530 <UART_regConfigModeEnable>:
; {
700ac530: b580         	push	{r7, lr}
700ac532: b086         	sub	sp, #0x18
700ac534: 9005         	str	r0, [sp, #0x14]
700ac536: 9104         	str	r1, [sp, #0x10]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ac538: 9805         	ldr	r0, [sp, #0x14]
700ac53a: 300c         	adds	r0, #0xc
700ac53c: f003 f990    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x3320
700ac540: 9003         	str	r0, [sp, #0xc]
;     switch (modeFlag)
700ac542: 9804         	ldr	r0, [sp, #0x10]
700ac544: 9002         	str	r0, [sp, #0x8]
700ac546: 287f         	cmp	r0, #0x7f
700ac548: d00f         	beq	0x700ac56a <UART_regConfigModeEnable+0x3a> @ imm = #0x1e
700ac54a: e7ff         	b	0x700ac54c <UART_regConfigModeEnable+0x1c> @ imm = #-0x2
700ac54c: 9802         	ldr	r0, [sp, #0x8]
700ac54e: 2880         	cmp	r0, #0x80
700ac550: d004         	beq	0x700ac55c <UART_regConfigModeEnable+0x2c> @ imm = #0x8
700ac552: e7ff         	b	0x700ac554 <UART_regConfigModeEnable+0x24> @ imm = #-0x2
700ac554: 9802         	ldr	r0, [sp, #0x8]
700ac556: 28bf         	cmp	r0, #0xbf
700ac558: d113         	bne	0x700ac582 <UART_regConfigModeEnable+0x52> @ imm = #0x26
700ac55a: e7ff         	b	0x700ac55c <UART_regConfigModeEnable+0x2c> @ imm = #-0x2
;             HW_WR_REG32(baseAddr + UART_LCR, modeFlag & 0xFFU);
700ac55c: 9805         	ldr	r0, [sp, #0x14]
700ac55e: 300c         	adds	r0, #0xc
700ac560: f89d 1010    	ldrb.w	r1, [sp, #0x10]
700ac564: f003 f984    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x3308
;             break;
700ac568: e00c         	b	0x700ac584 <UART_regConfigModeEnable+0x54> @ imm = #0x18
;             HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ac56a: 9805         	ldr	r0, [sp, #0x14]
700ac56c: 300c         	adds	r0, #0xc
700ac56e: 9001         	str	r0, [sp, #0x4]
700ac570: f003 f976    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x32ec
700ac574: 4601         	mov	r1, r0
700ac576: 9801         	ldr	r0, [sp, #0x4]
700ac578: f001 017f    	and	r1, r1, #0x7f
700ac57c: f003 f978    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x32f0
;             break;
700ac580: e000         	b	0x700ac584 <UART_regConfigModeEnable+0x54> @ imm = #0x0
;             break;
700ac582: e7ff         	b	0x700ac584 <UART_regConfigModeEnable+0x54> @ imm = #-0x2
;     return lcrRegValue;
700ac584: 9803         	ldr	r0, [sp, #0xc]
700ac586: b006         	add	sp, #0x18
700ac588: bd80         	pop	{r7, pc}
700ac58a: 0000         	movs	r0, r0
700ac58c: 0000         	movs	r0, r0
700ac58e: 0000         	movs	r0, r0

700ac590 <prvCheckTasksWaitingTermination>:
; static void prvCheckTasksWaitingTermination(void) {
700ac590: b580         	push	{r7, lr}
700ac592: b082         	sub	sp, #0x8
;     while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
700ac594: e7ff         	b	0x700ac596 <prvCheckTasksWaitingTermination+0x6> @ imm = #-0x2
700ac596: f242 60e0    	movw	r0, #0x26e0
700ac59a: f2c7 000b    	movt	r0, #0x700b
700ac59e: 6800         	ldr	r0, [r0]
700ac5a0: b308         	cbz	r0, 0x700ac5e6 <prvCheckTasksWaitingTermination+0x56> @ imm = #0x42
700ac5a2: e7ff         	b	0x700ac5a4 <prvCheckTasksWaitingTermination+0x14> @ imm = #-0x2
;       taskENTER_CRITICAL();
700ac5a4: f001 ff94    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0x1f28
;         pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700ac5a8: f245 2008    	movw	r0, #0x5208
700ac5ac: f2c7 0008    	movt	r0, #0x7008
700ac5b0: 68c0         	ldr	r0, [r0, #0xc]
700ac5b2: 68c0         	ldr	r0, [r0, #0xc]
700ac5b4: 9001         	str	r0, [sp, #0x4]
;         (void)uxListRemove(&(pxTCB->xStateListItem));
700ac5b6: 9801         	ldr	r0, [sp, #0x4]
700ac5b8: 3004         	adds	r0, #0x4
700ac5ba: f000 ff59    	bl	0x700ad470 <uxListRemove> @ imm = #0xeb2
;         --uxCurrentNumberOfTasks;
700ac5be: f242 61dc    	movw	r1, #0x26dc
700ac5c2: f2c7 010b    	movt	r1, #0x700b
700ac5c6: 6808         	ldr	r0, [r1]
700ac5c8: 3801         	subs	r0, #0x1
700ac5ca: 6008         	str	r0, [r1]
;         --uxDeletedTasksWaitingCleanUp;
700ac5cc: f242 61e0    	movw	r1, #0x26e0
700ac5d0: f2c7 010b    	movt	r1, #0x700b
700ac5d4: 6808         	ldr	r0, [r1]
700ac5d6: 3801         	subs	r0, #0x1
700ac5d8: 6008         	str	r0, [r1]
;       taskEXIT_CRITICAL();
700ac5da: f001 f839    	bl	0x700ad650 <vTaskExitCritical> @ imm = #0x1072
;       prvDeleteTCB(pxTCB);
700ac5de: 9801         	ldr	r0, [sp, #0x4]
700ac5e0: f001 fc5e    	bl	0x700adea0 <prvDeleteTCB> @ imm = #0x18bc
;     while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
700ac5e4: e7d7         	b	0x700ac596 <prvCheckTasksWaitingTermination+0x6> @ imm = #-0x52
; }
700ac5e6: b002         	add	sp, #0x8
700ac5e8: bd80         	pop	{r7, pc}
700ac5ea: 0000         	movs	r0, r0
700ac5ec: 0000         	movs	r0, r0
700ac5ee: 0000         	movs	r0, r0

700ac5f0 <Sciclient_rmIrqSetRaw>:
; {
700ac5f0: b580         	push	{r7, lr}
700ac5f2: b08c         	sub	sp, #0x30
700ac5f4: 900b         	str	r0, [sp, #0x2c]
700ac5f6: 910a         	str	r1, [sp, #0x28]
700ac5f8: 9209         	str	r2, [sp, #0x24]
700ac5fa: f44f 5080    	mov.w	r0, #0x1000
;     sciReq.messageType    = TISCI_MSG_RM_IRQ_SET;
700ac5fe: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac602: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac604: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac606: 980b         	ldr	r0, [sp, #0x2c]
700ac608: 9005         	str	r0, [sp, #0x14]
700ac60a: 201c         	movs	r0, #0x1c
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac60c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac60e: 9809         	ldr	r0, [sp, #0x24]
700ac610: 9007         	str	r0, [sp, #0x1c]
700ac612: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac614: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac616: 980a         	ldr	r0, [sp, #0x28]
700ac618: 9001         	str	r0, [sp, #0x4]
700ac61a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac61c: 9002         	str	r0, [sp, #0x8]
700ac61e: a803         	add	r0, sp, #0xc
700ac620: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac622: f7f0 fe2d    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xf3a6
700ac626: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac628: 9808         	ldr	r0, [sp, #0x20]
700ac62a: b930         	cbnz	r0, 0x700ac63a <Sciclient_rmIrqSetRaw+0x4a> @ imm = #0xc
700ac62c: e7ff         	b	0x700ac62e <Sciclient_rmIrqSetRaw+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac62e: 9800         	ldr	r0, [sp]
700ac630: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac634: 2802         	cmp	r0, #0x2
700ac636: d004         	beq	0x700ac642 <Sciclient_rmIrqSetRaw+0x52> @ imm = #0x8
700ac638: e7ff         	b	0x700ac63a <Sciclient_rmIrqSetRaw+0x4a> @ imm = #-0x2
700ac63a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac63e: 9008         	str	r0, [sp, #0x20]
;     }
700ac640: e7ff         	b	0x700ac642 <Sciclient_rmIrqSetRaw+0x52> @ imm = #-0x2
;     return r;
700ac642: 9808         	ldr	r0, [sp, #0x20]
700ac644: b00c         	add	sp, #0x30
700ac646: bd80         	pop	{r7, pc}
		...

700ac650 <Sciclient_rmIrqUnmappedVintRouteDelete>:
; {
700ac650: b580         	push	{r7, lr}
700ac652: b084         	sub	sp, #0x10
700ac654: 9003         	str	r0, [sp, #0xc]
700ac656: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ac658: 9002         	str	r0, [sp, #0x8]
;     r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700ac65a: 9903         	ldr	r1, [sp, #0xc]
700ac65c: 8a08         	ldrh	r0, [r1, #0x10]
700ac65e: 8a49         	ldrh	r1, [r1, #0x12]
700ac660: f10d 0207    	add.w	r2, sp, #0x7
700ac664: f7fe fe84    	bl	0x700ab370 <Sciclient_rmIaVintGetInfo> @ imm = #-0x12f8
700ac668: 9002         	str	r0, [sp, #0x8]
;     if ((r == SystemP_SUCCESS) && (num_evts > 0U)) {
700ac66a: 9802         	ldr	r0, [sp, #0x8]
700ac66c: b940         	cbnz	r0, 0x700ac680 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #0x10
700ac66e: e7ff         	b	0x700ac670 <Sciclient_rmIrqUnmappedVintRouteDelete+0x20> @ imm = #-0x2
700ac670: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ac674: b120         	cbz	r0, 0x700ac680 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #0x8
700ac676: e7ff         	b	0x700ac678 <Sciclient_rmIrqUnmappedVintRouteDelete+0x28> @ imm = #-0x2
700ac678: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ac67c: 9002         	str	r0, [sp, #0x8]
;     }
700ac67e: e7ff         	b	0x700ac680 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ac680: 9802         	ldr	r0, [sp, #0x8]
700ac682: b970         	cbnz	r0, 0x700ac6a2 <Sciclient_rmIrqUnmappedVintRouteDelete+0x52> @ imm = #0x1c
700ac684: e7ff         	b	0x700ac686 <Sciclient_rmIrqUnmappedVintRouteDelete+0x36> @ imm = #-0x2
;         r = Sciclient_rmIrqGetRoute(cfg);
700ac686: 9803         	ldr	r0, [sp, #0xc]
700ac688: f7f0 faf2    	bl	0x7009cc70 <Sciclient_rmIrqGetRoute> @ imm = #-0xfa1c
700ac68c: 9002         	str	r0, [sp, #0x8]
;         if (r == SystemP_SUCCESS) {
700ac68e: 9802         	ldr	r0, [sp, #0x8]
700ac690: b930         	cbnz	r0, 0x700ac6a0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x50> @ imm = #0xc
700ac692: e7ff         	b	0x700ac694 <Sciclient_rmIrqUnmappedVintRouteDelete+0x44> @ imm = #-0x2
;             r = Sciclient_rmIrqDeleteRoute(cfg, false);
700ac694: 9803         	ldr	r0, [sp, #0xc]
700ac696: 2100         	movs	r1, #0x0
700ac698: f7f4 f942    	bl	0x700a0920 <Sciclient_rmIrqDeleteRoute> @ imm = #-0xbd7c
700ac69c: 9002         	str	r0, [sp, #0x8]
;         }
700ac69e: e7ff         	b	0x700ac6a0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x50> @ imm = #-0x2
;     }
700ac6a0: e7ff         	b	0x700ac6a2 <Sciclient_rmIrqUnmappedVintRouteDelete+0x52> @ imm = #-0x2
;     return r;
700ac6a2: 9802         	ldr	r0, [sp, #0x8]
700ac6a4: b004         	add	sp, #0x10
700ac6a6: bd80         	pop	{r7, pc}
		...

700ac6b0 <Sciclient_rmRingCfg>:
; {
700ac6b0: b580         	push	{r7, lr}
700ac6b2: b08c         	sub	sp, #0x30
700ac6b4: 900b         	str	r0, [sp, #0x2c]
700ac6b6: 910a         	str	r1, [sp, #0x28]
700ac6b8: 9209         	str	r2, [sp, #0x24]
700ac6ba: f241 1010    	movw	r0, #0x1110
;     sciReq.messageType    = TISCI_MSG_RM_RING_CFG;
700ac6be: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac6c2: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac6c4: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac6c6: 980b         	ldr	r0, [sp, #0x2c]
700ac6c8: 9005         	str	r0, [sp, #0x14]
700ac6ca: 2022         	movs	r0, #0x22
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac6cc: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac6ce: 9809         	ldr	r0, [sp, #0x24]
700ac6d0: 9007         	str	r0, [sp, #0x1c]
700ac6d2: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac6d4: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac6d6: 980a         	ldr	r0, [sp, #0x28]
700ac6d8: 9001         	str	r0, [sp, #0x4]
700ac6da: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac6dc: 9002         	str	r0, [sp, #0x8]
700ac6de: a803         	add	r0, sp, #0xc
700ac6e0: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac6e2: f7f0 fdcd    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xf466
700ac6e6: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac6e8: 9808         	ldr	r0, [sp, #0x20]
700ac6ea: b930         	cbnz	r0, 0x700ac6fa <Sciclient_rmRingCfg+0x4a> @ imm = #0xc
700ac6ec: e7ff         	b	0x700ac6ee <Sciclient_rmRingCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac6ee: 9800         	ldr	r0, [sp]
700ac6f0: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac6f4: 2802         	cmp	r0, #0x2
700ac6f6: d004         	beq	0x700ac702 <Sciclient_rmRingCfg+0x52> @ imm = #0x8
700ac6f8: e7ff         	b	0x700ac6fa <Sciclient_rmRingCfg+0x4a> @ imm = #-0x2
700ac6fa: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac6fe: 9008         	str	r0, [sp, #0x20]
;     }
700ac700: e7ff         	b	0x700ac702 <Sciclient_rmRingCfg+0x52> @ imm = #-0x2
;     return r;
700ac702: 9808         	ldr	r0, [sp, #0x20]
700ac704: b00c         	add	sp, #0x30
700ac706: bd80         	pop	{r7, pc}
		...

700ac710 <Sciclient_rmUdmapFlowCfg>:
; {
700ac710: b580         	push	{r7, lr}
700ac712: b08c         	sub	sp, #0x30
700ac714: 900b         	str	r0, [sp, #0x2c]
700ac716: 910a         	str	r1, [sp, #0x28]
700ac718: 9209         	str	r2, [sp, #0x24]
700ac71a: f241 2030    	movw	r0, #0x1230
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_FLOW_CFG;
700ac71e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac722: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac724: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac726: 980b         	ldr	r0, [sp, #0x2c]
700ac728: 9005         	str	r0, [sp, #0x14]
700ac72a: 2029         	movs	r0, #0x29
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac72c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac72e: 9809         	ldr	r0, [sp, #0x24]
700ac730: 9007         	str	r0, [sp, #0x1c]
700ac732: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac734: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac736: 980a         	ldr	r0, [sp, #0x28]
700ac738: 9001         	str	r0, [sp, #0x4]
700ac73a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac73c: 9002         	str	r0, [sp, #0x8]
700ac73e: a803         	add	r0, sp, #0xc
700ac740: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac742: f7f0 fd9d    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xf4c6
700ac746: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac748: 9808         	ldr	r0, [sp, #0x20]
700ac74a: b930         	cbnz	r0, 0x700ac75a <Sciclient_rmUdmapFlowCfg+0x4a> @ imm = #0xc
700ac74c: e7ff         	b	0x700ac74e <Sciclient_rmUdmapFlowCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac74e: 9800         	ldr	r0, [sp]
700ac750: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac754: 2802         	cmp	r0, #0x2
700ac756: d004         	beq	0x700ac762 <Sciclient_rmUdmapFlowCfg+0x52> @ imm = #0x8
700ac758: e7ff         	b	0x700ac75a <Sciclient_rmUdmapFlowCfg+0x4a> @ imm = #-0x2
700ac75a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac75e: 9008         	str	r0, [sp, #0x20]
;     }
700ac760: e7ff         	b	0x700ac762 <Sciclient_rmUdmapFlowCfg+0x52> @ imm = #-0x2
;     return r;
700ac762: 9808         	ldr	r0, [sp, #0x20]
700ac764: b00c         	add	sp, #0x30
700ac766: bd80         	pop	{r7, pc}
		...

700ac770 <Sciclient_rmUdmapFlowSizeThreshCfg>:
; {
700ac770: b580         	push	{r7, lr}
700ac772: b08c         	sub	sp, #0x30
700ac774: 900b         	str	r0, [sp, #0x2c]
700ac776: 910a         	str	r1, [sp, #0x28]
700ac778: 9209         	str	r2, [sp, #0x24]
700ac77a: f241 2031    	movw	r0, #0x1231
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_FLOW_SIZE_THRESH_CFG;
700ac77e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac782: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac784: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac786: 980b         	ldr	r0, [sp, #0x2c]
700ac788: 9005         	str	r0, [sp, #0x14]
700ac78a: 201d         	movs	r0, #0x1d
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac78c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac78e: 9809         	ldr	r0, [sp, #0x24]
700ac790: 9007         	str	r0, [sp, #0x1c]
700ac792: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac794: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac796: 980a         	ldr	r0, [sp, #0x28]
700ac798: 9001         	str	r0, [sp, #0x4]
700ac79a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac79c: 9002         	str	r0, [sp, #0x8]
700ac79e: a803         	add	r0, sp, #0xc
700ac7a0: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac7a2: f7f0 fd6d    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xf526
700ac7a6: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac7a8: 9808         	ldr	r0, [sp, #0x20]
700ac7aa: b930         	cbnz	r0, 0x700ac7ba <Sciclient_rmUdmapFlowSizeThreshCfg+0x4a> @ imm = #0xc
700ac7ac: e7ff         	b	0x700ac7ae <Sciclient_rmUdmapFlowSizeThreshCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac7ae: 9800         	ldr	r0, [sp]
700ac7b0: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac7b4: 2802         	cmp	r0, #0x2
700ac7b6: d004         	beq	0x700ac7c2 <Sciclient_rmUdmapFlowSizeThreshCfg+0x52> @ imm = #0x8
700ac7b8: e7ff         	b	0x700ac7ba <Sciclient_rmUdmapFlowSizeThreshCfg+0x4a> @ imm = #-0x2
700ac7ba: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac7be: 9008         	str	r0, [sp, #0x20]
;     }
700ac7c0: e7ff         	b	0x700ac7c2 <Sciclient_rmUdmapFlowSizeThreshCfg+0x52> @ imm = #-0x2
;     return r;
700ac7c2: 9808         	ldr	r0, [sp, #0x20]
700ac7c4: b00c         	add	sp, #0x30
700ac7c6: bd80         	pop	{r7, pc}
		...

700ac7d0 <Sciclient_rmUdmapRxChCfg>:
; {
700ac7d0: b580         	push	{r7, lr}
700ac7d2: b08c         	sub	sp, #0x30
700ac7d4: 900b         	str	r0, [sp, #0x2c]
700ac7d6: 910a         	str	r1, [sp, #0x28]
700ac7d8: 9209         	str	r2, [sp, #0x24]
700ac7da: f241 2015    	movw	r0, #0x1215
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_RX_CH_CFG;
700ac7de: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac7e2: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac7e4: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac7e6: 980b         	ldr	r0, [sp, #0x2c]
700ac7e8: 9005         	str	r0, [sp, #0x14]
700ac7ea: 2022         	movs	r0, #0x22
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac7ec: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac7ee: 9809         	ldr	r0, [sp, #0x24]
700ac7f0: 9007         	str	r0, [sp, #0x1c]
700ac7f2: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac7f4: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac7f6: 980a         	ldr	r0, [sp, #0x28]
700ac7f8: 9001         	str	r0, [sp, #0x4]
700ac7fa: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac7fc: 9002         	str	r0, [sp, #0x8]
700ac7fe: a803         	add	r0, sp, #0xc
700ac800: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac802: f7f0 fd3d    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xf586
700ac806: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac808: 9808         	ldr	r0, [sp, #0x20]
700ac80a: b930         	cbnz	r0, 0x700ac81a <Sciclient_rmUdmapRxChCfg+0x4a> @ imm = #0xc
700ac80c: e7ff         	b	0x700ac80e <Sciclient_rmUdmapRxChCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac80e: 9800         	ldr	r0, [sp]
700ac810: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac814: 2802         	cmp	r0, #0x2
700ac816: d004         	beq	0x700ac822 <Sciclient_rmUdmapRxChCfg+0x52> @ imm = #0x8
700ac818: e7ff         	b	0x700ac81a <Sciclient_rmUdmapRxChCfg+0x4a> @ imm = #-0x2
700ac81a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac81e: 9008         	str	r0, [sp, #0x20]
;     }
700ac820: e7ff         	b	0x700ac822 <Sciclient_rmUdmapRxChCfg+0x52> @ imm = #-0x2
;     return r;
700ac822: 9808         	ldr	r0, [sp, #0x20]
700ac824: b00c         	add	sp, #0x30
700ac826: bd80         	pop	{r7, pc}
		...

700ac830 <Sciclient_rmUdmapTxChCfg>:
; {
700ac830: b580         	push	{r7, lr}
700ac832: b08c         	sub	sp, #0x30
700ac834: 900b         	str	r0, [sp, #0x2c]
700ac836: 910a         	str	r1, [sp, #0x28]
700ac838: 9209         	str	r2, [sp, #0x24]
700ac83a: f241 2005    	movw	r0, #0x1205
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_TX_CH_CFG;
700ac83e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac842: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac844: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac846: 980b         	ldr	r0, [sp, #0x2c]
700ac848: 9005         	str	r0, [sp, #0x14]
700ac84a: 2024         	movs	r0, #0x24
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac84c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac84e: 9809         	ldr	r0, [sp, #0x24]
700ac850: 9007         	str	r0, [sp, #0x1c]
700ac852: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac854: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac856: 980a         	ldr	r0, [sp, #0x28]
700ac858: 9001         	str	r0, [sp, #0x4]
700ac85a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac85c: 9002         	str	r0, [sp, #0x8]
700ac85e: a803         	add	r0, sp, #0xc
700ac860: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac862: f7f0 fd0d    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xf5e6
700ac866: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac868: 9808         	ldr	r0, [sp, #0x20]
700ac86a: b930         	cbnz	r0, 0x700ac87a <Sciclient_rmUdmapTxChCfg+0x4a> @ imm = #0xc
700ac86c: e7ff         	b	0x700ac86e <Sciclient_rmUdmapTxChCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac86e: 9800         	ldr	r0, [sp]
700ac870: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac874: 2802         	cmp	r0, #0x2
700ac876: d004         	beq	0x700ac882 <Sciclient_rmUdmapTxChCfg+0x52> @ imm = #0x8
700ac878: e7ff         	b	0x700ac87a <Sciclient_rmUdmapTxChCfg+0x4a> @ imm = #-0x2
700ac87a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac87e: 9008         	str	r0, [sp, #0x20]
;     }
700ac880: e7ff         	b	0x700ac882 <Sciclient_rmUdmapTxChCfg+0x52> @ imm = #-0x2
;     return r;
700ac882: 9808         	ldr	r0, [sp, #0x20]
700ac884: b00c         	add	sp, #0x30
700ac886: bd80         	pop	{r7, pc}

700ac888 <_outs>:
700ac888: e92d4070     	push	{r4, r5, r6, lr}
700ac88c: e5916004     	ldr	r6, [r1, #0x4]
700ac890: e1a04001     	mov	r4, r1
700ac894: e5913008     	ldr	r3, [r1, #0x8]
700ac898: e1a05002     	mov	r5, r2
700ac89c: e1560003     	cmp	r6, r3
700ac8a0: 9a00000a     	bls	0x700ac8d0 <_outs+0x48> @ imm = #0x28
700ac8a4: e0466003     	sub	r6, r6, r3
700ac8a8: e1a01000     	mov	r1, r0
700ac8ac: e5940000     	ldr	r0, [r4]
700ac8b0: e1560005     	cmp	r6, r5
700ac8b4: 21a06005     	movhs	r6, r5
700ac8b8: e1a02006     	mov	r2, r6
700ac8bc: ebffb5e6     	bl	0x7009a05c <__aeabi_memcpy8> @ imm = #-0x12868
700ac8c0: e5940000     	ldr	r0, [r4]
700ac8c4: e5943008     	ldr	r3, [r4, #0x8]
700ac8c8: e0800006     	add	r0, r0, r6
700ac8cc: e5840000     	str	r0, [r4]
700ac8d0: e0831005     	add	r1, r3, r5
700ac8d4: e1a00005     	mov	r0, r5
700ac8d8: e5841008     	str	r1, [r4, #0x8]
700ac8dc: e8bd8070     	pop	{r4, r5, r6, pc}

700ac8e0 <__TI_auto_init_nobinit_nopinit>:
700ac8e0: e92d4070     	push	{r4, r5, r6, lr}
700ac8e4: e59f4040     	ldr	r4, [pc, #0x40]         @ 0x700ac92c <__TI_auto_init_nobinit_nopinit+0x4c>
700ac8e8: e59f0038     	ldr	r0, [pc, #0x38]         @ 0x700ac928 <__TI_auto_init_nobinit_nopinit+0x48>
700ac8ec: e1540000     	cmp	r4, r0
700ac8f0: 0a00000a     	beq	0x700ac920 <__TI_auto_init_nobinit_nopinit+0x40> @ imm = #0x28
700ac8f4: e59f5034     	ldr	r5, [pc, #0x34]         @ 0x700ac930 <__TI_auto_init_nobinit_nopinit+0x50>
700ac8f8: e59f6034     	ldr	r6, [pc, #0x34]         @ 0x700ac934 <__TI_auto_init_nobinit_nopinit+0x54>
700ac8fc: e1550006     	cmp	r5, r6
700ac900: 0a000006     	beq	0x700ac920 <__TI_auto_init_nobinit_nopinit+0x40> @ imm = #0x18
700ac904: e5950000     	ldr	r0, [r5]
700ac908: e5951004     	ldr	r1, [r5, #0x4]
700ac90c: e4d02001     	ldrb	r2, [r0], #1
700ac910: e7942102     	ldr	r2, [r4, r2, lsl #2]
700ac914: e12fff32     	blx	r2
700ac918: e2855008     	add	r5, r5, #8
700ac91c: eafffff6     	b	0x700ac8fc <__TI_auto_init_nobinit_nopinit+0x1c> @ imm = #-0x28
700ac920: e1a00000     	mov	r0, r0
700ac924: e8bd8070     	pop	{r4, r5, r6, pc}
700ac928: 00 00 00 00  	.word	0x00000000
700ac92c: 00 00 00 00  	.word	0x00000000
700ac930: 00 00 00 00  	.word	0x00000000
700ac934: 00 00 00 00  	.word	0x00000000
700ac938: 00 00 00 00  	.word	0x00000000
700ac93c: 00 00 00 00  	.word	0x00000000

700ac940 <Sciclient_rmIrqReleaseRaw>:
; {
700ac940: b580         	push	{r7, lr}
700ac942: b08e         	sub	sp, #0x38
700ac944: 900d         	str	r0, [sp, #0x34]
700ac946: 910c         	str	r1, [sp, #0x30]
700ac948: f241 0001    	movw	r0, #0x1001
;     sciReq.messageType    = TISCI_MSG_RM_IRQ_RELEASE;
700ac94c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700ac950: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac952: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac954: 980d         	ldr	r0, [sp, #0x34]
700ac956: 9008         	str	r0, [sp, #0x20]
700ac958: 201c         	movs	r0, #0x1c
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac95a: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700ac95c: 980c         	ldr	r0, [sp, #0x30]
700ac95e: 900a         	str	r0, [sp, #0x28]
700ac960: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac962: 9003         	str	r0, [sp, #0xc]
700ac964: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t *)&resp;
700ac966: 9004         	str	r0, [sp, #0x10]
700ac968: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700ac96a: 9005         	str	r0, [sp, #0x14]
700ac96c: a806         	add	r0, sp, #0x18
700ac96e: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700ac970: f7f0 fc86    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xf6f4
700ac974: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700ac976: 980b         	ldr	r0, [sp, #0x2c]
700ac978: b930         	cbnz	r0, 0x700ac988 <Sciclient_rmIrqReleaseRaw+0x48> @ imm = #0xc
700ac97a: e7ff         	b	0x700ac97c <Sciclient_rmIrqReleaseRaw+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac97c: 9803         	ldr	r0, [sp, #0xc]
700ac97e: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac982: 2802         	cmp	r0, #0x2
700ac984: d004         	beq	0x700ac990 <Sciclient_rmIrqReleaseRaw+0x50> @ imm = #0x8
700ac986: e7ff         	b	0x700ac988 <Sciclient_rmIrqReleaseRaw+0x48> @ imm = #-0x2
700ac988: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac98c: 900b         	str	r0, [sp, #0x2c]
;     }
700ac98e: e7ff         	b	0x700ac990 <Sciclient_rmIrqReleaseRaw+0x50> @ imm = #-0x2
;     return r;
700ac990: 980b         	ldr	r0, [sp, #0x2c]
700ac992: b00e         	add	sp, #0x38
700ac994: bd80         	pop	{r7, pc}
		...
700ac99e: 0000         	movs	r0, r0

700ac9a0 <Sciclient_rmPsilPair>:
; {
700ac9a0: b580         	push	{r7, lr}
700ac9a2: b08e         	sub	sp, #0x38
700ac9a4: 900d         	str	r0, [sp, #0x34]
700ac9a6: 910c         	str	r1, [sp, #0x30]
700ac9a8: f44f 5094    	mov.w	r0, #0x1280
;     sciReq.messageType    = TISCI_MSG_RM_PSIL_PAIR;
700ac9ac: f8ad 0018    	strh.w	r0, [sp, #0x18]
700ac9b0: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac9b2: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac9b4: 980d         	ldr	r0, [sp, #0x34]
700ac9b6: 9008         	str	r0, [sp, #0x20]
700ac9b8: 2014         	movs	r0, #0x14
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac9ba: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700ac9bc: 980c         	ldr	r0, [sp, #0x30]
700ac9be: 900a         	str	r0, [sp, #0x28]
700ac9c0: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac9c2: 9003         	str	r0, [sp, #0xc]
700ac9c4: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t*)&resp;
700ac9c6: 9004         	str	r0, [sp, #0x10]
700ac9c8: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700ac9ca: 9005         	str	r0, [sp, #0x14]
700ac9cc: a806         	add	r0, sp, #0x18
700ac9ce: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700ac9d0: f7f0 fc56    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xf754
700ac9d4: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700ac9d6: 980b         	ldr	r0, [sp, #0x2c]
700ac9d8: b930         	cbnz	r0, 0x700ac9e8 <Sciclient_rmPsilPair+0x48> @ imm = #0xc
700ac9da: e7ff         	b	0x700ac9dc <Sciclient_rmPsilPair+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac9dc: 9803         	ldr	r0, [sp, #0xc]
700ac9de: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac9e2: 2802         	cmp	r0, #0x2
700ac9e4: d004         	beq	0x700ac9f0 <Sciclient_rmPsilPair+0x50> @ imm = #0x8
700ac9e6: e7ff         	b	0x700ac9e8 <Sciclient_rmPsilPair+0x48> @ imm = #-0x2
700ac9e8: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac9ec: 900b         	str	r0, [sp, #0x2c]
;     }
700ac9ee: e7ff         	b	0x700ac9f0 <Sciclient_rmPsilPair+0x50> @ imm = #-0x2
;     return r;
700ac9f0: 980b         	ldr	r0, [sp, #0x2c]
700ac9f2: b00e         	add	sp, #0x38
700ac9f4: bd80         	pop	{r7, pc}
		...
700ac9fe: 0000         	movs	r0, r0

700aca00 <Sciclient_rmPsilUnpair>:
; {
700aca00: b580         	push	{r7, lr}
700aca02: b08e         	sub	sp, #0x38
700aca04: 900d         	str	r0, [sp, #0x34]
700aca06: 910c         	str	r1, [sp, #0x30]
700aca08: f241 2081    	movw	r0, #0x1281
;     sciReq.messageType    = TISCI_MSG_RM_PSIL_UNPAIR;
700aca0c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700aca10: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aca12: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aca14: 980d         	ldr	r0, [sp, #0x34]
700aca16: 9008         	str	r0, [sp, #0x20]
700aca18: 2014         	movs	r0, #0x14
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aca1a: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700aca1c: 980c         	ldr	r0, [sp, #0x30]
700aca1e: 900a         	str	r0, [sp, #0x28]
700aca20: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aca22: 9003         	str	r0, [sp, #0xc]
700aca24: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t *)&resp;
700aca26: 9004         	str	r0, [sp, #0x10]
700aca28: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700aca2a: 9005         	str	r0, [sp, #0x14]
700aca2c: a806         	add	r0, sp, #0x18
700aca2e: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700aca30: f7f0 fc26    	bl	0x7009d280 <Sciclient_service> @ imm = #-0xf7b4
700aca34: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700aca36: 980b         	ldr	r0, [sp, #0x2c]
700aca38: b930         	cbnz	r0, 0x700aca48 <Sciclient_rmPsilUnpair+0x48> @ imm = #0xc
700aca3a: e7ff         	b	0x700aca3c <Sciclient_rmPsilUnpair+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aca3c: 9803         	ldr	r0, [sp, #0xc]
700aca3e: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aca42: 2802         	cmp	r0, #0x2
700aca44: d004         	beq	0x700aca50 <Sciclient_rmPsilUnpair+0x50> @ imm = #0x8
700aca46: e7ff         	b	0x700aca48 <Sciclient_rmPsilUnpair+0x48> @ imm = #-0x2
700aca48: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aca4c: 900b         	str	r0, [sp, #0x2c]
;     }
700aca4e: e7ff         	b	0x700aca50 <Sciclient_rmPsilUnpair+0x50> @ imm = #-0x2
;     return r;
700aca50: 980b         	ldr	r0, [sp, #0x2c]
700aca52: b00e         	add	sp, #0x38
700aca54: bd80         	pop	{r7, pc}
		...
700aca5e: 0000         	movs	r0, r0

700aca60 <Udma_chSetPeerReg>:
; {
700aca60: b580         	push	{r7, lr}
700aca62: b086         	sub	sp, #0x18
700aca64: f8dd c020    	ldr.w	r12, [sp, #0x20]
700aca68: 9005         	str	r0, [sp, #0x14]
700aca6a: 9104         	str	r1, [sp, #0x10]
700aca6c: 9203         	str	r2, [sp, #0xc]
700aca6e: 9302         	str	r3, [sp, #0x8]
;     regVal = CSL_REG32_RD(PEER8);
700aca70: 9803         	ldr	r0, [sp, #0xc]
700aca72: f002 ff65    	bl	0x700af940 <CSL_REG32_RD_RAW> @ imm = #0x2eca
700aca76: 9001         	str	r0, [sp, #0x4]
;     CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 0U);
700aca78: 9801         	ldr	r0, [sp, #0x4]
700aca7a: f020 4000    	bic	r0, r0, #0x80000000
700aca7e: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER8, regVal);
700aca80: 9803         	ldr	r0, [sp, #0xc]
700aca82: 9901         	ldr	r1, [sp, #0x4]
700aca84: f002 febc    	bl	0x700af800 <CSL_REG32_WR_RAW> @ imm = #0x2d78
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_X, pdmaPrms->elemSize) |
700aca88: 9804         	ldr	r0, [sp, #0x10]
700aca8a: 6801         	ldr	r1, [r0]
;                 CSL_FMK(PSILCFG_REG_STATIC_TR_Y, pdmaPrms->elemCnt);
700aca8c: 6840         	ldr	r0, [r0, #0x4]
700aca8e: f36f 301f    	bfc	r0, #12, #20
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_X, pdmaPrms->elemSize) |
700aca92: f361 601a    	bfi	r0, r1, #24, #3
700aca96: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER0, regVal);
700aca98: 9808         	ldr	r0, [sp, #0x20]
700aca9a: 9901         	ldr	r1, [sp, #0x4]
700aca9c: f002 feb0    	bl	0x700af800 <CSL_REG32_WR_RAW> @ imm = #0x2d60
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_Z, pdmaPrms->fifoCnt);
700acaa0: 9804         	ldr	r0, [sp, #0x10]
700acaa2: 6880         	ldr	r0, [r0, #0x8]
700acaa4: f36f 301f    	bfc	r0, #12, #20
700acaa8: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER1, regVal);
700acaaa: 9802         	ldr	r0, [sp, #0x8]
700acaac: 9901         	ldr	r1, [sp, #0x4]
700acaae: f002 fea7    	bl	0x700af800 <CSL_REG32_WR_RAW> @ imm = #0x2d4e
; }
700acab2: b006         	add	sp, #0x18
700acab4: bd80         	pop	{r7, pc}
		...
700acabe: 0000         	movs	r0, r0

700acac0 <Udma_eventGetGlobalHandle>:
; {
700acac0: b084         	sub	sp, #0x10
700acac2: 9003         	str	r0, [sp, #0xc]
700acac4: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700acac6: 9002         	str	r0, [sp, #0x8]
;     Udma_EventHandle    eventHandle = (Udma_EventHandle) NULL_PTR;
700acac8: 9000         	str	r0, [sp]
;     if(NULL_PTR == drvHandle)
700acaca: 9803         	ldr	r0, [sp, #0xc]
700acacc: b920         	cbnz	r0, 0x700acad8 <Udma_eventGetGlobalHandle+0x18> @ imm = #0x8
700acace: e7ff         	b	0x700acad0 <Udma_eventGetGlobalHandle+0x10> @ imm = #-0x2
700acad0: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700acad4: 9002         	str	r0, [sp, #0x8]
;     }
700acad6: e7ff         	b	0x700acad8 <Udma_eventGetGlobalHandle+0x18> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700acad8: 9802         	ldr	r0, [sp, #0x8]
700acada: b988         	cbnz	r0, 0x700acb00 <Udma_eventGetGlobalHandle+0x40> @ imm = #0x22
700acadc: e7ff         	b	0x700acade <Udma_eventGetGlobalHandle+0x1e> @ imm = #-0x2
;         drvHandleInt = (Udma_DrvHandleInt) drvHandle;
700acade: 9803         	ldr	r0, [sp, #0xc]
700acae0: 9001         	str	r0, [sp, #0x4]
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
700acae2: 9801         	ldr	r0, [sp, #0x4]
700acae4: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700acae8: f64a 31cd    	movw	r1, #0xabcd
700acaec: f6ca 31dc    	movt	r1, #0xabdc
700acaf0: 4288         	cmp	r0, r1
700acaf2: d004         	beq	0x700acafe <Udma_eventGetGlobalHandle+0x3e> @ imm = #0x8
700acaf4: e7ff         	b	0x700acaf6 <Udma_eventGetGlobalHandle+0x36> @ imm = #-0x2
700acaf6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700acafa: 9002         	str	r0, [sp, #0x8]
;         }
700acafc: e7ff         	b	0x700acafe <Udma_eventGetGlobalHandle+0x3e> @ imm = #-0x2
;     }
700acafe: e7ff         	b	0x700acb00 <Udma_eventGetGlobalHandle+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700acb00: 9802         	ldr	r0, [sp, #0x8]
700acb02: b928         	cbnz	r0, 0x700acb10 <Udma_eventGetGlobalHandle+0x50> @ imm = #0xa
700acb04: e7ff         	b	0x700acb06 <Udma_eventGetGlobalHandle+0x46> @ imm = #-0x2
;         eventHandle = (Udma_EventHandle) drvHandleInt->globalEventHandle;
700acb06: 9801         	ldr	r0, [sp, #0x4]
700acb08: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
700acb0c: 9000         	str	r0, [sp]
;     }
700acb0e: e7ff         	b	0x700acb10 <Udma_eventGetGlobalHandle+0x50> @ imm = #-0x2
;     return (eventHandle);
700acb10: 9800         	ldr	r0, [sp]
700acb12: b004         	add	sp, #0x10
700acb14: 4770         	bx	lr
		...
700acb1e: 0000         	movs	r0, r0

700acb20 <CSL_pktdmaIsValidChanIdx>:
; {
700acb20: b084         	sub	sp, #0x10
700acb22: 9003         	str	r0, [sp, #0xc]
700acb24: 9102         	str	r1, [sp, #0x8]
700acb26: 9201         	str	r2, [sp, #0x4]
;     if( (chanDir == CSL_PKTDMA_CHAN_DIR_TX) && (chanIdx < pCfg->txChanCnt) )
700acb28: 9801         	ldr	r0, [sp, #0x4]
700acb2a: b950         	cbnz	r0, 0x700acb42 <CSL_pktdmaIsValidChanIdx+0x22> @ imm = #0x14
700acb2c: e7ff         	b	0x700acb2e <CSL_pktdmaIsValidChanIdx+0xe> @ imm = #-0x2
700acb2e: 9802         	ldr	r0, [sp, #0x8]
700acb30: 9903         	ldr	r1, [sp, #0xc]
700acb32: 6a09         	ldr	r1, [r1, #0x20]
700acb34: 4288         	cmp	r0, r1
700acb36: d204         	bhs	0x700acb42 <CSL_pktdmaIsValidChanIdx+0x22> @ imm = #0x8
700acb38: e7ff         	b	0x700acb3a <CSL_pktdmaIsValidChanIdx+0x1a> @ imm = #-0x2
700acb3a: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700acb3c: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700acb40: e012         	b	0x700acb68 <CSL_pktdmaIsValidChanIdx+0x48> @ imm = #0x24
;     else if( (chanDir == CSL_PKTDMA_CHAN_DIR_RX) && (chanIdx < pCfg->rxChanCnt) )
700acb42: 9801         	ldr	r0, [sp, #0x4]
700acb44: 2801         	cmp	r0, #0x1
700acb46: d10a         	bne	0x700acb5e <CSL_pktdmaIsValidChanIdx+0x3e> @ imm = #0x14
700acb48: e7ff         	b	0x700acb4a <CSL_pktdmaIsValidChanIdx+0x2a> @ imm = #-0x2
700acb4a: 9802         	ldr	r0, [sp, #0x8]
700acb4c: 9903         	ldr	r1, [sp, #0xc]
700acb4e: 6a49         	ldr	r1, [r1, #0x24]
700acb50: 4288         	cmp	r0, r1
700acb52: d204         	bhs	0x700acb5e <CSL_pktdmaIsValidChanIdx+0x3e> @ imm = #0x8
700acb54: e7ff         	b	0x700acb56 <CSL_pktdmaIsValidChanIdx+0x36> @ imm = #-0x2
700acb56: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700acb58: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700acb5c: e003         	b	0x700acb66 <CSL_pktdmaIsValidChanIdx+0x46> @ imm = #0x6
700acb5e: 2000         	movs	r0, #0x0
;         bRetVal = (bool)false;
700acb60: f88d 0003    	strb.w	r0, [sp, #0x3]
700acb64: e7ff         	b	0x700acb66 <CSL_pktdmaIsValidChanIdx+0x46> @ imm = #-0x2
700acb66: e7ff         	b	0x700acb68 <CSL_pktdmaIsValidChanIdx+0x48> @ imm = #-0x2
;     return bRetVal;
700acb68: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700acb6c: f000 0001    	and	r0, r0, #0x1
700acb70: b004         	add	sp, #0x10
700acb72: 4770         	bx	lr
		...

700acb80 <Sciclient_rmUnmappedVintRouteCreate>:
; {
700acb80: b580         	push	{r7, lr}
700acb82: b084         	sub	sp, #0x10
700acb84: 9003         	str	r0, [sp, #0xc]
;     r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700acb86: 9903         	ldr	r1, [sp, #0xc]
700acb88: 8a08         	ldrh	r0, [r1, #0x10]
700acb8a: 8a49         	ldrh	r1, [r1, #0x12]
700acb8c: f10d 0207    	add.w	r2, sp, #0x7
700acb90: f7fe fbee    	bl	0x700ab370 <Sciclient_rmIaVintGetInfo> @ imm = #-0x1824
700acb94: 9002         	str	r0, [sp, #0x8]
;     if ((r == SystemP_SUCCESS) && (num_evts > 0U)) {
700acb96: 9802         	ldr	r0, [sp, #0x8]
700acb98: b940         	cbnz	r0, 0x700acbac <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #0x10
700acb9a: e7ff         	b	0x700acb9c <Sciclient_rmUnmappedVintRouteCreate+0x1c> @ imm = #-0x2
700acb9c: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700acba0: b120         	cbz	r0, 0x700acbac <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #0x8
700acba2: e7ff         	b	0x700acba4 <Sciclient_rmUnmappedVintRouteCreate+0x24> @ imm = #-0x2
700acba4: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700acba8: 9002         	str	r0, [sp, #0x8]
;     }
700acbaa: e7ff         	b	0x700acbac <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700acbac: 9802         	ldr	r0, [sp, #0x8]
700acbae: b970         	cbnz	r0, 0x700acbce <Sciclient_rmUnmappedVintRouteCreate+0x4e> @ imm = #0x1c
700acbb0: e7ff         	b	0x700acbb2 <Sciclient_rmUnmappedVintRouteCreate+0x32> @ imm = #-0x2
;         r = Sciclient_rmIrqFindRoute(cfg);
700acbb2: 9803         	ldr	r0, [sp, #0xc]
700acbb4: f7f1 f9f4    	bl	0x7009dfa0 <Sciclient_rmIrqFindRoute> @ imm = #-0xec18
700acbb8: 9002         	str	r0, [sp, #0x8]
;         if (r == SystemP_SUCCESS) {
700acbba: 9802         	ldr	r0, [sp, #0x8]
700acbbc: b930         	cbnz	r0, 0x700acbcc <Sciclient_rmUnmappedVintRouteCreate+0x4c> @ imm = #0xc
700acbbe: e7ff         	b	0x700acbc0 <Sciclient_rmUnmappedVintRouteCreate+0x40> @ imm = #-0x2
;             r = Sciclient_rmIrqProgramRoute(cfg, false);
700acbc0: 9803         	ldr	r0, [sp, #0xc]
700acbc2: 2100         	movs	r1, #0x0
700acbc4: f7f4 f904    	bl	0x700a0dd0 <Sciclient_rmIrqProgramRoute> @ imm = #-0xbdf8
700acbc8: 9002         	str	r0, [sp, #0x8]
;         }
700acbca: e7ff         	b	0x700acbcc <Sciclient_rmUnmappedVintRouteCreate+0x4c> @ imm = #-0x2
;     }
700acbcc: e7ff         	b	0x700acbce <Sciclient_rmUnmappedVintRouteCreate+0x4e> @ imm = #-0x2
;     return r;
700acbce: 9802         	ldr	r0, [sp, #0x8]
700acbd0: b004         	add	sp, #0x10
700acbd2: bd80         	pop	{r7, pc}
		...

700acbe0 <UART_OperModeValid>:
; {
700acbe0: b082         	sub	sp, #0x8
700acbe2: 9001         	str	r0, [sp, #0x4]
700acbe4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700acbe8: 9000         	str	r0, [sp]
;     if(((operMode == UART_OPER_MODE_16X) ||
700acbea: 9801         	ldr	r0, [sp, #0x4]
700acbec: b1e0         	cbz	r0, 0x700acc28 <UART_OperModeValid+0x48> @ imm = #0x38
700acbee: e7ff         	b	0x700acbf0 <UART_OperModeValid+0x10> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_SIR) ||
700acbf0: 9801         	ldr	r0, [sp, #0x4]
700acbf2: 2801         	cmp	r0, #0x1
700acbf4: d018         	beq	0x700acc28 <UART_OperModeValid+0x48> @ imm = #0x30
700acbf6: e7ff         	b	0x700acbf8 <UART_OperModeValid+0x18> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_16X_AUTO_BAUD) ||
700acbf8: 9801         	ldr	r0, [sp, #0x4]
700acbfa: 2802         	cmp	r0, #0x2
700acbfc: d014         	beq	0x700acc28 <UART_OperModeValid+0x48> @ imm = #0x28
700acbfe: e7ff         	b	0x700acc00 <UART_OperModeValid+0x20> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_13X) ||
700acc00: 9801         	ldr	r0, [sp, #0x4]
700acc02: 2803         	cmp	r0, #0x3
700acc04: d010         	beq	0x700acc28 <UART_OperModeValid+0x48> @ imm = #0x20
700acc06: e7ff         	b	0x700acc08 <UART_OperModeValid+0x28> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_MIR) ||
700acc08: 9801         	ldr	r0, [sp, #0x4]
700acc0a: 2804         	cmp	r0, #0x4
700acc0c: d00c         	beq	0x700acc28 <UART_OperModeValid+0x48> @ imm = #0x18
700acc0e: e7ff         	b	0x700acc10 <UART_OperModeValid+0x30> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_FIR) ||
700acc10: 9801         	ldr	r0, [sp, #0x4]
700acc12: 2805         	cmp	r0, #0x5
700acc14: d008         	beq	0x700acc28 <UART_OperModeValid+0x48> @ imm = #0x10
700acc16: e7ff         	b	0x700acc18 <UART_OperModeValid+0x38> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_CIR) ||
700acc18: 9801         	ldr	r0, [sp, #0x4]
700acc1a: 2806         	cmp	r0, #0x6
700acc1c: d004         	beq	0x700acc28 <UART_OperModeValid+0x48> @ imm = #0x8
700acc1e: e7ff         	b	0x700acc20 <UART_OperModeValid+0x40> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_DISABLED)))
700acc20: 9801         	ldr	r0, [sp, #0x4]
;     if(((operMode == UART_OPER_MODE_16X) ||
700acc22: 2807         	cmp	r0, #0x7
700acc24: d103         	bne	0x700acc2e <UART_OperModeValid+0x4e> @ imm = #0x6
700acc26: e7ff         	b	0x700acc28 <UART_OperModeValid+0x48> @ imm = #-0x2
700acc28: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700acc2a: 9000         	str	r0, [sp]
;     }
700acc2c: e7ff         	b	0x700acc2e <UART_OperModeValid+0x4e> @ imm = #-0x2
;     return status;
700acc2e: 9800         	ldr	r0, [sp]
700acc30: b002         	add	sp, #0x8
700acc32: 4770         	bx	lr
		...

700acc40 <UdmaRingPrms_init>:
; {
700acc40: b081         	sub	sp, #0x4
700acc42: 9000         	str	r0, [sp]
;     if(NULL_PTR != ringPrms)
700acc44: 9800         	ldr	r0, [sp]
700acc46: b318         	cbz	r0, 0x700acc90 <UdmaRingPrms_init+0x50> @ imm = #0x46
700acc48: e7ff         	b	0x700acc4a <UdmaRingPrms_init+0xa> @ imm = #-0x2
;         ringPrms->ringMem       = NULL_PTR;
700acc4a: 9900         	ldr	r1, [sp]
700acc4c: 2000         	movs	r0, #0x0
700acc4e: 6008         	str	r0, [r1]
;         ringPrms->ringMemSize   = UDMA_RING_SIZE_CHECK_SKIP;
700acc50: 9a00         	ldr	r2, [sp]
700acc52: f64a 31cd    	movw	r1, #0xabcd
700acc56: f6ca 31dc    	movt	r1, #0xabdc
700acc5a: 6051         	str	r1, [r2, #0x4]
;         ringPrms->mode          = TISCI_MSG_VALUE_RM_RING_MODE_RING;
700acc5c: 9900         	ldr	r1, [sp]
700acc5e: 7208         	strb	r0, [r1, #0x8]
;         ringPrms->virtId        = UDMA_RING_VIRTID_INVALID;
700acc60: 9a00         	ldr	r2, [sp]
700acc62: f64f 71ff    	movw	r1, #0xffff
700acc66: 8151         	strh	r1, [r2, #0xa]
;         ringPrms->elemCnt       = 0U;
700acc68: 9900         	ldr	r1, [sp]
700acc6a: 60c8         	str	r0, [r1, #0xc]
;         ringPrms->elemSize      = UDMA_RING_ES_8BYTES;
700acc6c: 9a00         	ldr	r2, [sp]
700acc6e: 2101         	movs	r1, #0x1
700acc70: 7411         	strb	r1, [r2, #0x10]
;         ringPrms->orderId       = UDMA_DEFAULT_RING_ORDER_ID;
700acc72: 9900         	ldr	r1, [sp]
700acc74: 7448         	strb	r0, [r1, #0x11]
;         ringPrms->asel          = UDMA_RINGACC_ASEL_ENDPOINT_PHYSADDR;
700acc76: 9900         	ldr	r1, [sp]
700acc78: 7488         	strb	r0, [r1, #0x12]
;         ringPrms->mappedRingGrp = UDMA_MAPPED_GROUP_INVALID;
700acc7a: 9900         	ldr	r1, [sp]
700acc7c: 2004         	movs	r0, #0x4
700acc7e: f6cf 70ff    	movt	r0, #0xffff
700acc82: 6148         	str	r0, [r1, #0x14]
;         ringPrms->mappedChNum   = UDMA_DMA_CH_INVALID;
700acc84: 9900         	ldr	r1, [sp]
700acc86: 2000         	movs	r0, #0x0
700acc88: f6cf 70ff    	movt	r0, #0xffff
700acc8c: 6188         	str	r0, [r1, #0x18]
;     }
700acc8e: e7ff         	b	0x700acc90 <UdmaRingPrms_init+0x50> @ imm = #-0x2
;     return;
700acc90: b001         	add	sp, #0x4
700acc92: 4770         	bx	lr
		...

700acca0 <prvIdleTask>:
; static portTASK_FUNCTION(prvIdleTask, pvParameters) {
700acca0: b580         	push	{r7, lr}
700acca2: b082         	sub	sp, #0x8
700acca4: 9001         	str	r0, [sp, #0x4]
;   for (;;) {
700acca6: e7ff         	b	0x700acca8 <prvIdleTask+0x8> @ imm = #-0x2
;     prvCheckTasksWaitingTermination();
700acca8: f7ff fc72    	bl	0x700ac590 <prvCheckTasksWaitingTermination> @ imm = #-0x71c
;       if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) >
700accac: f244 40f8    	movw	r0, #0x44f8
700accb0: f2c7 0008    	movt	r0, #0x7008
700accb4: 6800         	ldr	r0, [r0]
700accb6: 2802         	cmp	r0, #0x2
700accb8: d302         	blo	0x700accc0 <prvIdleTask+0x20> @ imm = #0x4
700accba: e7ff         	b	0x700accbc <prvIdleTask+0x1c> @ imm = #-0x2
;         taskYIELD();
700accbc: df00         	svc	#0x0
;       } else {
700accbe: e000         	b	0x700accc2 <prvIdleTask+0x22> @ imm = #0x0
700accc0: e7ff         	b	0x700accc2 <prvIdleTask+0x22> @ imm = #-0x2
;       vApplicationIdleHook();
700accc2: f002 fea5    	bl	0x700afa10 <vApplicationIdleHook> @ imm = #0x2d4a
;       xExpectedIdleTime = prvGetExpectedIdleTime();
700accc6: f7fe f8f3    	bl	0x700aaeb0 <prvGetExpectedIdleTime> @ imm = #-0x1e1a
700accca: 9000         	str	r0, [sp]
;       if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP) {
700acccc: 9800         	ldr	r0, [sp]
700accce: 2802         	cmp	r0, #0x2
700accd0: d30e         	blo	0x700accf0 <prvIdleTask+0x50> @ imm = #0x1c
700accd2: e7ff         	b	0x700accd4 <prvIdleTask+0x34> @ imm = #-0x2
;         vTaskSuspendAll();
700accd4: f002 fdec    	bl	0x700af8b0 <vTaskSuspendAll> @ imm = #0x2bd8
;           xExpectedIdleTime = prvGetExpectedIdleTime();
700accd8: f7fe f8ea    	bl	0x700aaeb0 <prvGetExpectedIdleTime> @ imm = #-0x1e2c
700accdc: 9000         	str	r0, [sp]
;           if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP) {
700accde: 9800         	ldr	r0, [sp]
700acce0: 2802         	cmp	r0, #0x2
700acce2: d301         	blo	0x700acce8 <prvIdleTask+0x48> @ imm = #0x2
700acce4: e7ff         	b	0x700acce6 <prvIdleTask+0x46> @ imm = #-0x2
;           } else {
700acce6: e000         	b	0x700accea <prvIdleTask+0x4a> @ imm = #0x0
700acce8: e7ff         	b	0x700accea <prvIdleTask+0x4a> @ imm = #-0x2
;         (void)xTaskResumeAll();
700accea: f7f5 f9d1    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0xac5e
;       } else {
700accee: e000         	b	0x700accf2 <prvIdleTask+0x52> @ imm = #0x0
700accf0: e7ff         	b	0x700accf2 <prvIdleTask+0x52> @ imm = #-0x2
;   for (;;) {
700accf2: e7d9         	b	0x700acca8 <prvIdleTask+0x8> @ imm = #-0x4e
		...

700acd00 <vQueueUnregisterQueue>:
;     {
700acd00: b082         	sub	sp, #0x8
700acd02: 9001         	str	r0, [sp, #0x4]
700acd04: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700acd06: 9000         	str	r0, [sp]
700acd08: e7ff         	b	0x700acd0a <vQueueUnregisterQueue+0xa> @ imm = #-0x2
700acd0a: 9800         	ldr	r0, [sp]
700acd0c: 281f         	cmp	r0, #0x1f
700acd0e: d81f         	bhi	0x700acd50 <vQueueUnregisterQueue+0x50> @ imm = #0x3e
700acd10: e7ff         	b	0x700acd12 <vQueueUnregisterQueue+0x12> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].xHandle == xQueue )
700acd12: 9900         	ldr	r1, [sp]
700acd14: f644 4078    	movw	r0, #0x4c78
700acd18: f2c7 0008    	movt	r0, #0x7008
700acd1c: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700acd20: 6840         	ldr	r0, [r0, #0x4]
700acd22: 9901         	ldr	r1, [sp, #0x4]
700acd24: 4288         	cmp	r0, r1
700acd26: d10d         	bne	0x700acd44 <vQueueUnregisterQueue+0x44> @ imm = #0x1a
700acd28: e7ff         	b	0x700acd2a <vQueueUnregisterQueue+0x2a> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = NULL;
700acd2a: 9a00         	ldr	r2, [sp]
700acd2c: f644 4178    	movw	r1, #0x4c78
700acd30: f2c7 0108    	movt	r1, #0x7008
700acd34: 2000         	movs	r0, #0x0
700acd36: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
700acd3a: 9a00         	ldr	r2, [sp]
700acd3c: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700acd40: 6048         	str	r0, [r1, #0x4]
;                 break;
700acd42: e005         	b	0x700acd50 <vQueueUnregisterQueue+0x50> @ imm = #0xa
700acd44: e7ff         	b	0x700acd46 <vQueueUnregisterQueue+0x46> @ imm = #-0x2
;         }
700acd46: e7ff         	b	0x700acd48 <vQueueUnregisterQueue+0x48> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700acd48: 9800         	ldr	r0, [sp]
700acd4a: 3001         	adds	r0, #0x1
700acd4c: 9000         	str	r0, [sp]
700acd4e: e7dc         	b	0x700acd0a <vQueueUnregisterQueue+0xa> @ imm = #-0x48
;     } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
700acd50: b002         	add	sp, #0x8
700acd52: 4770         	bx	lr
		...

700acd60 <Drivers_open>:
; {
700acd60: b5b0         	push	{r4, r5, r7, lr}
700acd62: b082         	sub	sp, #0x8
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700acd64: f242 41e4    	movw	r1, #0x24e4
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700acd68: f245 2430    	movw	r4, #0x5230
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700acd6c: f2c7 010b    	movt	r1, #0x700b
700acd70: 2500         	movs	r5, #0x0
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700acd72: f2c7 0408    	movt	r4, #0x7008
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700acd76: 2000         	movs	r0, #0x0
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700acd78: 6025         	str	r5, [r4]
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700acd7a: f7ee fe61    	bl	0x7009ba40 <UART_open>  @ imm = #-0x1133e
700acd7e: 6020         	str	r0, [r4]
;         if(NULL == gUartHandle[instCnt])
700acd80: b108         	cbz	r0, 0x700acd86 <Drivers_open+0x26> @ imm = #0x2
; }
700acd82: b002         	add	sp, #0x8
700acd84: bdb0         	pop	{r4, r5, r7, pc}
;             DebugP_logError("UART open failed for instance %d !!!\r\n", instCnt);
700acd86: f241 711d    	movw	r1, #0x171d
700acd8a: f641 5263    	movw	r2, #0x1d63
700acd8e: f2c7 010b    	movt	r1, #0x700b
700acd92: f2c7 020b    	movt	r2, #0x700b
700acd96: 2002         	movs	r0, #0x2
700acd98: 236e         	movs	r3, #0x6e
700acd9a: 9500         	str	r5, [sp]
700acd9c: f7fc fe90    	bl	0x700a9ac0 <_DebugP_logZone> @ imm = #-0x32e0
;         if(gUartHandle[instCnt] != NULL)
700acda0: 6820         	ldr	r0, [r4]
700acda2: 2800         	cmp	r0, #0x0
700acda4: d0ed         	beq	0x700acd82 <Drivers_open+0x22> @ imm = #-0x26
;             UART_close(gUartHandle[instCnt]);
700acda6: f7f2 ff13    	bl	0x7009fbd0 <UART_close> @ imm = #-0xd1da
700acdaa: 2000         	movs	r0, #0x0
;             gUartHandle[instCnt] = NULL;
700acdac: 6020         	str	r0, [r4]
; }
700acdae: b002         	add	sp, #0x8
700acdb0: bdb0         	pop	{r4, r5, r7, pc}
		...
700acdbe: 0000         	movs	r0, r0

700acdc0 <Udma_chInitRegs>:
; {
700acdc0: b081         	sub	sp, #0x4
700acdc2: 9000         	str	r0, [sp]
;     chHandle->pBcdmaBcCfgRegs    = (volatile CSL_bcdma_bccfgRegs_chan *) NULL_PTR;
700acdc4: 9900         	ldr	r1, [sp]
700acdc6: 2000         	movs	r0, #0x0
700acdc8: f8c1 0214    	str.w	r0, [r1, #0x214]
;     chHandle->pBcdmaBcRtRegs     = (volatile CSL_bcdma_bcrtRegs_chan *) NULL_PTR;
700acdcc: 9900         	ldr	r1, [sp]
700acdce: f8c1 0218    	str.w	r0, [r1, #0x218]
;     chHandle->pBcdmaTxCfgRegs   = (volatile CSL_bcdma_txccfgRegs_chan *) NULL_PTR;
700acdd2: 9900         	ldr	r1, [sp]
700acdd4: f8c1 021c    	str.w	r0, [r1, #0x21c]
;     chHandle->pBcdmaTxRtRegs    = (volatile CSL_bcdma_txcrtRegs_chan *) NULL_PTR;
700acdd8: 9900         	ldr	r1, [sp]
700acdda: f8c1 0220    	str.w	r0, [r1, #0x220]
;     chHandle->pBcdmaRxCfgRegs   = (volatile CSL_bcdma_rxccfgRegs_chan *) NULL_PTR;
700acdde: 9900         	ldr	r1, [sp]
700acde0: f8c1 0224    	str.w	r0, [r1, #0x224]
;     chHandle->pBcdmaRxRtRegs    = (volatile CSL_bcdma_rxcrtRegs_chan *) NULL_PTR;
700acde4: 9900         	ldr	r1, [sp]
700acde6: f8c1 0228    	str.w	r0, [r1, #0x228]
;     chHandle->pPktdmaTxCfgRegs  = (volatile CSL_pktdma_txccfgRegs_chan *) NULL_PTR;
700acdea: 9900         	ldr	r1, [sp]
700acdec: f8c1 022c    	str.w	r0, [r1, #0x22c]
;     chHandle->pPktdmaTxRtRegs   = (volatile CSL_pktdma_txcrtRegs_chan *) NULL_PTR;
700acdf0: 9900         	ldr	r1, [sp]
700acdf2: f8c1 0230    	str.w	r0, [r1, #0x230]
;     chHandle->pPktdmaRxCfgRegs  = (volatile CSL_pktdma_rxccfgRegs_chan *) NULL_PTR;
700acdf6: 9900         	ldr	r1, [sp]
700acdf8: f8c1 0234    	str.w	r0, [r1, #0x234]
;     chHandle->pPktdmaRxRtRegs   = (volatile CSL_pktdma_rxcrtRegs_chan *) NULL_PTR;
700acdfc: 9900         	ldr	r1, [sp]
700acdfe: f8c1 0238    	str.w	r0, [r1, #0x238]
;     chHandle->pPktdmaExtCfgRegs = (volatile CSL_pktdma_txccfgRegs_chan *) NULL_PTR;
700ace02: 9900         	ldr	r1, [sp]
700ace04: f8c1 023c    	str.w	r0, [r1, #0x23c]
;     chHandle->pPktdmaExtRtRegs  = (volatile CSL_pktdma_txcrtRegs_chan *) NULL_PTR;
700ace08: 9900         	ldr	r1, [sp]
700ace0a: f8c1 0240    	str.w	r0, [r1, #0x240]
; }
700ace0e: b001         	add	sp, #0x4
700ace10: 4770         	bx	lr
		...
700ace1e: 0000         	movs	r0, r0

700ace20 <vQueueAddToRegistry>:
;     {
700ace20: b083         	sub	sp, #0xc
700ace22: 9002         	str	r0, [sp, #0x8]
700ace24: 9101         	str	r1, [sp, #0x4]
700ace26: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700ace28: 9000         	str	r0, [sp]
700ace2a: e7ff         	b	0x700ace2c <vQueueAddToRegistry+0xc> @ imm = #-0x2
700ace2c: 9800         	ldr	r0, [sp]
700ace2e: 281f         	cmp	r0, #0x1f
700ace30: d81d         	bhi	0x700ace6e <vQueueAddToRegistry+0x4e> @ imm = #0x3a
700ace32: e7ff         	b	0x700ace34 <vQueueAddToRegistry+0x14> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].pcQueueName == NULL )
700ace34: 9900         	ldr	r1, [sp]
700ace36: f644 4078    	movw	r0, #0x4c78
700ace3a: f2c7 0008    	movt	r0, #0x7008
700ace3e: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
700ace42: b970         	cbnz	r0, 0x700ace62 <vQueueAddToRegistry+0x42> @ imm = #0x1c
700ace44: e7ff         	b	0x700ace46 <vQueueAddToRegistry+0x26> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = pcQueueName;
700ace46: 9801         	ldr	r0, [sp, #0x4]
700ace48: 9a00         	ldr	r2, [sp]
700ace4a: f644 4178    	movw	r1, #0x4c78
700ace4e: f2c7 0108    	movt	r1, #0x7008
700ace52: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = xQueue;
700ace56: 9802         	ldr	r0, [sp, #0x8]
700ace58: 9a00         	ldr	r2, [sp]
700ace5a: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700ace5e: 6048         	str	r0, [r1, #0x4]
;                 break;
700ace60: e005         	b	0x700ace6e <vQueueAddToRegistry+0x4e> @ imm = #0xa
700ace62: e7ff         	b	0x700ace64 <vQueueAddToRegistry+0x44> @ imm = #-0x2
;         }
700ace64: e7ff         	b	0x700ace66 <vQueueAddToRegistry+0x46> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700ace66: 9800         	ldr	r0, [sp]
700ace68: 3001         	adds	r0, #0x1
700ace6a: 9000         	str	r0, [sp]
700ace6c: e7de         	b	0x700ace2c <vQueueAddToRegistry+0xc> @ imm = #-0x44
;     }
700ace6e: b003         	add	sp, #0xc
700ace70: 4770         	bx	lr
		...
700ace7e: 0000         	movs	r0, r0

700ace80 <xQueueTakeMutexRecursive>:
;     {
700ace80: b580         	push	{r7, lr}
700ace82: b086         	sub	sp, #0x18
700ace84: 9005         	str	r0, [sp, #0x14]
700ace86: 9104         	str	r1, [sp, #0x10]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
700ace88: 9805         	ldr	r0, [sp, #0x14]
700ace8a: 9002         	str	r0, [sp, #0x8]
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
700ace8c: 9802         	ldr	r0, [sp, #0x8]
700ace8e: 6880         	ldr	r0, [r0, #0x8]
700ace90: 9001         	str	r0, [sp, #0x4]
700ace92: f002 fc05    	bl	0x700af6a0 <xTaskGetCurrentTaskHandle> @ imm = #0x280a
700ace96: 4601         	mov	r1, r0
700ace98: 9801         	ldr	r0, [sp, #0x4]
700ace9a: 4288         	cmp	r0, r1
700ace9c: d107         	bne	0x700aceae <xQueueTakeMutexRecursive+0x2e> @ imm = #0xe
700ace9e: e7ff         	b	0x700acea0 <xQueueTakeMutexRecursive+0x20> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
700acea0: 9902         	ldr	r1, [sp, #0x8]
700acea2: 68c8         	ldr	r0, [r1, #0xc]
700acea4: 3001         	adds	r0, #0x1
700acea6: 60c8         	str	r0, [r1, #0xc]
700acea8: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700aceaa: 9003         	str	r0, [sp, #0xc]
;         }
700aceac: e00e         	b	0x700acecc <xQueueTakeMutexRecursive+0x4c> @ imm = #0x1c
;             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
700aceae: 9802         	ldr	r0, [sp, #0x8]
700aceb0: 9904         	ldr	r1, [sp, #0x10]
700aceb2: f7f4 f9dd    	bl	0x700a1270 <xQueueSemaphoreTake> @ imm = #-0xbc46
700aceb6: 9003         	str	r0, [sp, #0xc]
;             if( xReturn != pdFAIL )
700aceb8: 9803         	ldr	r0, [sp, #0xc]
700aceba: b128         	cbz	r0, 0x700acec8 <xQueueTakeMutexRecursive+0x48> @ imm = #0xa
700acebc: e7ff         	b	0x700acebe <xQueueTakeMutexRecursive+0x3e> @ imm = #-0x2
;                 ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
700acebe: 9902         	ldr	r1, [sp, #0x8]
700acec0: 68c8         	ldr	r0, [r1, #0xc]
700acec2: 3001         	adds	r0, #0x1
700acec4: 60c8         	str	r0, [r1, #0xc]
;             }
700acec6: e000         	b	0x700aceca <xQueueTakeMutexRecursive+0x4a> @ imm = #0x0
700acec8: e7ff         	b	0x700aceca <xQueueTakeMutexRecursive+0x4a> @ imm = #-0x2
700aceca: e7ff         	b	0x700acecc <xQueueTakeMutexRecursive+0x4c> @ imm = #-0x2
;         return xReturn;
700acecc: 9803         	ldr	r0, [sp, #0xc]
700acece: b006         	add	sp, #0x18
700aced0: bd80         	pop	{r7, pc}
		...
700acede: 0000         	movs	r0, r0

700acee0 <UART_checkCharsAvailInFifo>:
; {
700acee0: b580         	push	{r7, lr}
700acee2: b084         	sub	sp, #0x10
700acee4: 9003         	str	r0, [sp, #0xc]
700acee6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700acee8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700aceea: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700aceec: 9803         	ldr	r0, [sp, #0xc]
700aceee: 300c         	adds	r0, #0xc
700acef0: f002 fcb6    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x296c
700acef4: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700acef6: 9803         	ldr	r0, [sp, #0xc]
700acef8: 300c         	adds	r0, #0xc
700acefa: 9000         	str	r0, [sp]
700acefc: f002 fcb0    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x2960
700acf00: 4601         	mov	r1, r0
700acf02: 9800         	ldr	r0, [sp]
700acf04: f001 017f    	and	r1, r1, #0x7f
700acf08: f002 fcb2    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x2964
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700acf0c: 9803         	ldr	r0, [sp, #0xc]
700acf0e: 3014         	adds	r0, #0x14
700acf10: f002 fca6    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x294c
;     if ((uint32_t) UART_LSR_RX_FIFO_E_RX_FIFO_E_VALUE_0 !=
700acf14: 07c0         	lsls	r0, r0, #0x1f
700acf16: b118         	cbz	r0, 0x700acf20 <UART_checkCharsAvailInFifo+0x40> @ imm = #0x6
700acf18: e7ff         	b	0x700acf1a <UART_checkCharsAvailInFifo+0x3a> @ imm = #-0x2
700acf1a: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700acf1c: 9001         	str	r0, [sp, #0x4]
;     }
700acf1e: e7ff         	b	0x700acf20 <UART_checkCharsAvailInFifo+0x40> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700acf20: 9803         	ldr	r0, [sp, #0xc]
700acf22: 300c         	adds	r0, #0xc
700acf24: 9902         	ldr	r1, [sp, #0x8]
700acf26: f002 fca3    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x2946
;     return retVal;
700acf2a: 9801         	ldr	r0, [sp, #0x4]
700acf2c: b004         	add	sp, #0x10
700acf2e: bd80         	pop	{r7, pc}

700acf30 <xQueueGiveMutexRecursive>:
;     {
700acf30: b580         	push	{r7, lr}
700acf32: b084         	sub	sp, #0x10
700acf34: 9003         	str	r0, [sp, #0xc]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
700acf36: 9803         	ldr	r0, [sp, #0xc]
700acf38: 9001         	str	r0, [sp, #0x4]
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
700acf3a: 9801         	ldr	r0, [sp, #0x4]
700acf3c: 6880         	ldr	r0, [r0, #0x8]
700acf3e: 9000         	str	r0, [sp]
700acf40: f002 fbae    	bl	0x700af6a0 <xTaskGetCurrentTaskHandle> @ imm = #0x275c
700acf44: 4601         	mov	r1, r0
700acf46: 9800         	ldr	r0, [sp]
700acf48: 4288         	cmp	r0, r1
700acf4a: d113         	bne	0x700acf74 <xQueueGiveMutexRecursive+0x44> @ imm = #0x26
700acf4c: e7ff         	b	0x700acf4e <xQueueGiveMutexRecursive+0x1e> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
700acf4e: 9901         	ldr	r1, [sp, #0x4]
700acf50: 68c8         	ldr	r0, [r1, #0xc]
700acf52: 3801         	subs	r0, #0x1
700acf54: 60c8         	str	r0, [r1, #0xc]
;             if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
700acf56: 9801         	ldr	r0, [sp, #0x4]
700acf58: 68c0         	ldr	r0, [r0, #0xc]
700acf5a: b938         	cbnz	r0, 0x700acf6c <xQueueGiveMutexRecursive+0x3c> @ imm = #0xe
700acf5c: e7ff         	b	0x700acf5e <xQueueGiveMutexRecursive+0x2e> @ imm = #-0x2
;                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
700acf5e: 9801         	ldr	r0, [sp, #0x4]
700acf60: 2300         	movs	r3, #0x0
700acf62: 4619         	mov	r1, r3
700acf64: 461a         	mov	r2, r3
700acf66: f7f6 f8c3    	bl	0x700a30f0 <xQueueGenericSend> @ imm = #-0x9e7a
;             }
700acf6a: e000         	b	0x700acf6e <xQueueGiveMutexRecursive+0x3e> @ imm = #0x0
700acf6c: e7ff         	b	0x700acf6e <xQueueGiveMutexRecursive+0x3e> @ imm = #-0x2
700acf6e: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700acf70: 9002         	str	r0, [sp, #0x8]
;         }
700acf72: e002         	b	0x700acf7a <xQueueGiveMutexRecursive+0x4a> @ imm = #0x4
700acf74: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
700acf76: 9002         	str	r0, [sp, #0x8]
700acf78: e7ff         	b	0x700acf7a <xQueueGiveMutexRecursive+0x4a> @ imm = #-0x2
;         return xReturn;
700acf7a: 9802         	ldr	r0, [sp, #0x8]
700acf7c: b004         	add	sp, #0x10
700acf7e: bd80         	pop	{r7, pc}

700acf80 <CSL_pktdmaIsChanEnabled>:
; {
700acf80: b580         	push	{r7, lr}
700acf82: b084         	sub	sp, #0x10
700acf84: 9003         	str	r0, [sp, #0xc]
700acf86: 9102         	str	r1, [sp, #0x8]
700acf88: 9201         	str	r2, [sp, #0x4]
;     if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700acf8a: 9801         	ldr	r0, [sp, #0x4]
700acf8c: b960         	cbnz	r0, 0x700acfa8 <CSL_pktdmaIsChanEnabled+0x28> @ imm = #0x18
700acf8e: e7ff         	b	0x700acf90 <CSL_pktdmaIsChanEnabled+0x10> @ imm = #-0x2
;         regVal = CSL_REG32_FEXT( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, PKTDMA_TXCRT_CHAN_CTL_EN );
700acf90: 9803         	ldr	r0, [sp, #0xc]
700acf92: 6900         	ldr	r0, [r0, #0x10]
700acf94: 9902         	ldr	r1, [sp, #0x8]
700acf96: eb00 3001    	add.w	r0, r0, r1, lsl #12
700acf9a: f04f 4100    	mov.w	r1, #0x80000000
700acf9e: 221f         	movs	r2, #0x1f
700acfa0: f001 ff56    	bl	0x700aee50 <CSL_REG32_FEXT_RAW> @ imm = #0x1eac
700acfa4: 9000         	str	r0, [sp]
;     }
700acfa6: e00b         	b	0x700acfc0 <CSL_pktdmaIsChanEnabled+0x40> @ imm = #0x16
;         regVal = CSL_REG32_FEXT( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, PKTDMA_RXCRT_CHAN_CTL_EN );
700acfa8: 9803         	ldr	r0, [sp, #0xc]
700acfaa: 6940         	ldr	r0, [r0, #0x14]
700acfac: 9902         	ldr	r1, [sp, #0x8]
700acfae: eb00 3001    	add.w	r0, r0, r1, lsl #12
700acfb2: f04f 4100    	mov.w	r1, #0x80000000
700acfb6: 221f         	movs	r2, #0x1f
700acfb8: f001 ff4a    	bl	0x700aee50 <CSL_REG32_FEXT_RAW> @ imm = #0x1e94
700acfbc: 9000         	str	r0, [sp]
700acfbe: e7ff         	b	0x700acfc0 <CSL_pktdmaIsChanEnabled+0x40> @ imm = #-0x2
;     return ((regVal == 1U) ? (bool)true : (bool)false);
700acfc0: 9800         	ldr	r0, [sp]
700acfc2: 3801         	subs	r0, #0x1
700acfc4: fab0 f080    	clz	r0, r0
700acfc8: 0940         	lsrs	r0, r0, #0x5
700acfca: b004         	add	sp, #0x10
700acfcc: bd80         	pop	{r7, pc}
700acfce: 0000         	movs	r0, r0

700acfd0 <UART_getHandle>:
; {
700acfd0: b083         	sub	sp, #0xc
700acfd2: 9002         	str	r0, [sp, #0x8]
700acfd4: 2000         	movs	r0, #0x0
;     UART_Handle         handle = NULL;
700acfd6: 9001         	str	r0, [sp, #0x4]
;     if(index < gUartConfigNum)
700acfd8: 9802         	ldr	r0, [sp, #0x8]
700acfda: f242 61ac    	movw	r1, #0x26ac
700acfde: f2c7 010b    	movt	r1, #0x700b
700acfe2: 6809         	ldr	r1, [r1]
700acfe4: 4288         	cmp	r0, r1
700acfe6: d217         	bhs	0x700ad018 <UART_getHandle+0x48> @ imm = #0x2e
700acfe8: e7ff         	b	0x700acfea <UART_getHandle+0x1a> @ imm = #-0x2
;         object = gUartConfig[index].object;
700acfea: 9902         	ldr	r1, [sp, #0x8]
700acfec: f242 6064    	movw	r0, #0x2664
700acff0: f2c7 000b    	movt	r0, #0x700b
700acff4: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700acff8: 6840         	ldr	r0, [r0, #0x4]
700acffa: 9000         	str	r0, [sp]
;         if(object && (TRUE == object->isOpen))
700acffc: 9800         	ldr	r0, [sp]
700acffe: b150         	cbz	r0, 0x700ad016 <UART_getHandle+0x46> @ imm = #0x14
700ad000: e7ff         	b	0x700ad002 <UART_getHandle+0x32> @ imm = #-0x2
700ad002: 9800         	ldr	r0, [sp]
700ad004: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700ad008: 2801         	cmp	r0, #0x1
700ad00a: d104         	bne	0x700ad016 <UART_getHandle+0x46> @ imm = #0x8
700ad00c: e7ff         	b	0x700ad00e <UART_getHandle+0x3e> @ imm = #-0x2
;             handle = object->handle;
700ad00e: 9800         	ldr	r0, [sp]
700ad010: 6800         	ldr	r0, [r0]
700ad012: 9001         	str	r0, [sp, #0x4]
;         }
700ad014: e7ff         	b	0x700ad016 <UART_getHandle+0x46> @ imm = #-0x2
;     }
700ad016: e7ff         	b	0x700ad018 <UART_getHandle+0x48> @ imm = #-0x2
;     return handle;
700ad018: 9801         	ldr	r0, [sp, #0x4]
700ad01a: b003         	add	sp, #0xc
700ad01c: 4770         	bx	lr
700ad01e: 0000         	movs	r0, r0

700ad020 <prvTaskIsTaskSuspended>:
; static BaseType_t prvTaskIsTaskSuspended(const TaskHandle_t xTask) {
700ad020: b083         	sub	sp, #0xc
700ad022: 9002         	str	r0, [sp, #0x8]
700ad024: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700ad026: 9001         	str	r0, [sp, #0x4]
;   const TCB_t *const pxTCB = xTask;
700ad028: 9802         	ldr	r0, [sp, #0x8]
700ad02a: 9000         	str	r0, [sp]
;   if (listIS_CONTAINED_WITHIN(&xSuspendedTaskList, &(pxTCB->xStateListItem)) !=
700ad02c: 9800         	ldr	r0, [sp]
700ad02e: 6940         	ldr	r0, [r0, #0x14]
700ad030: f245 11f4    	movw	r1, #0x51f4
700ad034: f2c7 0108    	movt	r1, #0x7008
700ad038: 4288         	cmp	r0, r1
700ad03a: d114         	bne	0x700ad066 <prvTaskIsTaskSuspended+0x46> @ imm = #0x28
700ad03c: e7ff         	b	0x700ad03e <prvTaskIsTaskSuspended+0x1e> @ imm = #-0x2
;     if (listIS_CONTAINED_WITHIN(&xPendingReadyList, &(pxTCB->xEventListItem)) ==
700ad03e: 9800         	ldr	r0, [sp]
700ad040: 6a80         	ldr	r0, [r0, #0x28]
700ad042: f245 11e0    	movw	r1, #0x51e0
700ad046: f2c7 0108    	movt	r1, #0x7008
700ad04a: 4288         	cmp	r0, r1
700ad04c: d009         	beq	0x700ad062 <prvTaskIsTaskSuspended+0x42> @ imm = #0x12
700ad04e: e7ff         	b	0x700ad050 <prvTaskIsTaskSuspended+0x30> @ imm = #-0x2
;       if (listIS_CONTAINED_WITHIN(NULL, &(pxTCB->xEventListItem)) !=
700ad050: 9800         	ldr	r0, [sp]
700ad052: 6a80         	ldr	r0, [r0, #0x28]
700ad054: b918         	cbnz	r0, 0x700ad05e <prvTaskIsTaskSuspended+0x3e> @ imm = #0x6
700ad056: e7ff         	b	0x700ad058 <prvTaskIsTaskSuspended+0x38> @ imm = #-0x2
700ad058: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700ad05a: 9001         	str	r0, [sp, #0x4]
;       } else {
700ad05c: e000         	b	0x700ad060 <prvTaskIsTaskSuspended+0x40> @ imm = #0x0
700ad05e: e7ff         	b	0x700ad060 <prvTaskIsTaskSuspended+0x40> @ imm = #-0x2
;     } else {
700ad060: e000         	b	0x700ad064 <prvTaskIsTaskSuspended+0x44> @ imm = #0x0
700ad062: e7ff         	b	0x700ad064 <prvTaskIsTaskSuspended+0x44> @ imm = #-0x2
;   } else {
700ad064: e000         	b	0x700ad068 <prvTaskIsTaskSuspended+0x48> @ imm = #0x0
700ad066: e7ff         	b	0x700ad068 <prvTaskIsTaskSuspended+0x48> @ imm = #-0x2
;   return xReturn;
700ad068: 9801         	ldr	r0, [sp, #0x4]
700ad06a: b003         	add	sp, #0xc
700ad06c: 4770         	bx	lr
700ad06e: 0000         	movs	r0, r0

700ad070 <Sciclient_rmPsSetInp>:
; {
700ad070: b082         	sub	sp, #0x8
700ad072: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ad076: f8ad 1004    	strh.w	r1, [sp, #0x4]
700ad07a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ad07c: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ad07e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ad082: f241 0158    	movw	r1, #0x1058
700ad086: f2c7 0108    	movt	r1, #0x7008
700ad08a: 8c89         	ldrh	r1, [r1, #0x24]
700ad08c: 4288         	cmp	r0, r1
700ad08e: da0e         	bge	0x700ad0ae <Sciclient_rmPsSetInp+0x3e> @ imm = #0x1c
700ad090: e7ff         	b	0x700ad092 <Sciclient_rmPsSetInp+0x22> @ imm = #-0x2
;         gPstack.ps[index].inp = inp;
700ad092: f8bd 0004    	ldrh.w	r0, [sp, #0x4]
700ad096: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ad09a: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ad09e: f241 0158    	movw	r1, #0x1058
700ad0a2: f2c7 0108    	movt	r1, #0x7008
700ad0a6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ad0aa: 80c8         	strh	r0, [r1, #0x6]
;     } else {
700ad0ac: e003         	b	0x700ad0b6 <Sciclient_rmPsSetInp+0x46> @ imm = #0x6
700ad0ae: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ad0b2: 9000         	str	r0, [sp]
700ad0b4: e7ff         	b	0x700ad0b6 <Sciclient_rmPsSetInp+0x46> @ imm = #-0x2
;     return r;
700ad0b6: 9800         	ldr	r0, [sp]
700ad0b8: b002         	add	sp, #0x8
700ad0ba: 4770         	bx	lr
700ad0bc: 0000         	movs	r0, r0
700ad0be: 0000         	movs	r0, r0

700ad0c0 <Sciclient_rmPsSetOutp>:
; {
700ad0c0: b082         	sub	sp, #0x8
700ad0c2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ad0c6: f8ad 1004    	strh.w	r1, [sp, #0x4]
700ad0ca: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ad0cc: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ad0ce: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ad0d2: f241 0158    	movw	r1, #0x1058
700ad0d6: f2c7 0108    	movt	r1, #0x7008
700ad0da: 8c89         	ldrh	r1, [r1, #0x24]
700ad0dc: 4288         	cmp	r0, r1
700ad0de: da0e         	bge	0x700ad0fe <Sciclient_rmPsSetOutp+0x3e> @ imm = #0x1c
700ad0e0: e7ff         	b	0x700ad0e2 <Sciclient_rmPsSetOutp+0x22> @ imm = #-0x2
;         gPstack.ps[index].outp = outp;
700ad0e2: f8bd 0004    	ldrh.w	r0, [sp, #0x4]
700ad0e6: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ad0ea: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ad0ee: f241 0158    	movw	r1, #0x1058
700ad0f2: f2c7 0108    	movt	r1, #0x7008
700ad0f6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ad0fa: 8108         	strh	r0, [r1, #0x8]
;     } else {
700ad0fc: e003         	b	0x700ad106 <Sciclient_rmPsSetOutp+0x46> @ imm = #0x6
700ad0fe: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ad102: 9000         	str	r0, [sp]
700ad104: e7ff         	b	0x700ad106 <Sciclient_rmPsSetOutp+0x46> @ imm = #-0x2
;     return r;
700ad106: 9800         	ldr	r0, [sp]
700ad108: b002         	add	sp, #0x8
700ad10a: 4770         	bx	lr
700ad10c: 0000         	movs	r0, r0
700ad10e: 0000         	movs	r0, r0

700ad110 <Udma_eventGetId>:
; {
700ad110: b084         	sub	sp, #0x10
700ad112: 9003         	str	r0, [sp, #0xc]
700ad114: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            evtNum = UDMA_EVENT_INVALID;
700ad118: 9002         	str	r0, [sp, #0x8]
;     Udma_EventHandleInt eventHandleInt = (Udma_EventHandleInt) eventHandle;
700ad11a: 9803         	ldr	r0, [sp, #0xc]
700ad11c: 9000         	str	r0, [sp]
;     if((NULL_PTR != eventHandleInt) &&
700ad11e: 9800         	ldr	r0, [sp]
700ad120: b1c8         	cbz	r0, 0x700ad156 <Udma_eventGetId+0x46> @ imm = #0x32
700ad122: e7ff         	b	0x700ad124 <Udma_eventGetId+0x14> @ imm = #-0x2
;        (UDMA_INIT_DONE == eventHandleInt->eventInitDone))
700ad124: 9800         	ldr	r0, [sp]
700ad126: f8d0 0098    	ldr.w	r0, [r0, #0x98]
700ad12a: f64a 31cd    	movw	r1, #0xabcd
700ad12e: f6ca 31dc    	movt	r1, #0xabdc
;     if((NULL_PTR != eventHandleInt) &&
700ad132: 4288         	cmp	r0, r1
700ad134: d10f         	bne	0x700ad156 <Udma_eventGetId+0x46> @ imm = #0x1e
700ad136: e7ff         	b	0x700ad138 <Udma_eventGetId+0x28> @ imm = #-0x2
;         drvHandle = eventHandleInt->drvHandle;
700ad138: 9800         	ldr	r0, [sp]
700ad13a: 6800         	ldr	r0, [r0]
700ad13c: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != drvHandle)
700ad13e: 9801         	ldr	r0, [sp, #0x4]
700ad140: b140         	cbz	r0, 0x700ad154 <Udma_eventGetId+0x44> @ imm = #0x10
700ad142: e7ff         	b	0x700ad144 <Udma_eventGetId+0x34> @ imm = #-0x2
;             evtNum = drvHandle->iaGemOffset + eventHandleInt->globalEvent;
700ad144: 9801         	ldr	r0, [sp, #0x4]
700ad146: f8d0 0118    	ldr.w	r0, [r0, #0x118]
700ad14a: 9900         	ldr	r1, [sp]
700ad14c: 6c89         	ldr	r1, [r1, #0x48]
700ad14e: 4408         	add	r0, r1
700ad150: 9002         	str	r0, [sp, #0x8]
;         }
700ad152: e7ff         	b	0x700ad154 <Udma_eventGetId+0x44> @ imm = #-0x2
;     }
700ad154: e7ff         	b	0x700ad156 <Udma_eventGetId+0x46> @ imm = #-0x2
;     return (evtNum);
700ad156: 9802         	ldr	r0, [sp, #0x8]
700ad158: b004         	add	sp, #0x10
700ad15a: 4770         	bx	lr
700ad15c: 0000         	movs	r0, r0
700ad15e: 0000         	movs	r0, r0

700ad160 <CSL_pktdmaGetRxRT>:
; {
700ad160: b580         	push	{r7, lr}
700ad162: b084         	sub	sp, #0x10
700ad164: 9003         	str	r0, [sp, #0xc]
700ad166: 9102         	str	r1, [sp, #0x8]
700ad168: 9201         	str	r2, [sp, #0x4]
;     val = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700ad16a: 9803         	ldr	r0, [sp, #0xc]
700ad16c: 6940         	ldr	r0, [r0, #0x14]
700ad16e: 9902         	ldr	r1, [sp, #0x8]
700ad170: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad174: f002 fbcc    	bl	0x700af910 <CSL_REG32_RD_RAW> @ imm = #0x2798
700ad178: 9000         	str	r0, [sp]
;     pRT->enable         = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_EN );
700ad17a: 9800         	ldr	r0, [sp]
700ad17c: 0fc0         	lsrs	r0, r0, #0x1f
700ad17e: 9901         	ldr	r1, [sp, #0x4]
700ad180: 6008         	str	r0, [r1]
;     pRT->teardown       = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_TDOWN );
700ad182: 9800         	ldr	r0, [sp]
700ad184: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700ad188: 9901         	ldr	r1, [sp, #0x4]
700ad18a: 6048         	str	r0, [r1, #0x4]
;     pRT->forcedTeardown = (uint32_t)0U;
700ad18c: 9901         	ldr	r1, [sp, #0x4]
700ad18e: 2000         	movs	r0, #0x0
700ad190: 6108         	str	r0, [r1, #0x10]
;     pRT->pause          = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_PAUSE );
700ad192: 9900         	ldr	r1, [sp]
700ad194: f3c1 7140    	ubfx	r1, r1, #0x1d, #0x1
700ad198: 9a01         	ldr	r2, [sp, #0x4]
700ad19a: 6091         	str	r1, [r2, #0x8]
;     pRT->error          = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_ERROR );
700ad19c: 9900         	ldr	r1, [sp]
700ad19e: f001 0101    	and	r1, r1, #0x1
700ad1a2: 9a01         	ldr	r2, [sp, #0x4]
700ad1a4: 60d1         	str	r1, [r2, #0xc]
;     return CSL_PASS;
700ad1a6: b004         	add	sp, #0x10
700ad1a8: bd80         	pop	{r7, pc}
700ad1aa: 0000         	movs	r0, r0
700ad1ac: 0000         	movs	r0, r0
700ad1ae: 0000         	movs	r0, r0

700ad1b0 <CSL_pktdmaGetTxRT>:
; {
700ad1b0: b580         	push	{r7, lr}
700ad1b2: b084         	sub	sp, #0x10
700ad1b4: 9003         	str	r0, [sp, #0xc]
700ad1b6: 9102         	str	r1, [sp, #0x8]
700ad1b8: 9201         	str	r2, [sp, #0x4]
;     val = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700ad1ba: 9803         	ldr	r0, [sp, #0xc]
700ad1bc: 6900         	ldr	r0, [r0, #0x10]
700ad1be: 9902         	ldr	r1, [sp, #0x8]
700ad1c0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad1c4: f002 fba4    	bl	0x700af910 <CSL_REG32_RD_RAW> @ imm = #0x2748
700ad1c8: 9000         	str	r0, [sp]
;     pRT->enable         = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_EN );
700ad1ca: 9800         	ldr	r0, [sp]
700ad1cc: 0fc0         	lsrs	r0, r0, #0x1f
700ad1ce: 9901         	ldr	r1, [sp, #0x4]
700ad1d0: 6008         	str	r0, [r1]
;     pRT->teardown       = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_TDOWN );
700ad1d2: 9800         	ldr	r0, [sp]
700ad1d4: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700ad1d8: 9901         	ldr	r1, [sp, #0x4]
700ad1da: 6048         	str	r0, [r1, #0x4]
;     pRT->forcedTeardown = (uint32_t)0U;
700ad1dc: 9901         	ldr	r1, [sp, #0x4]
700ad1de: 2000         	movs	r0, #0x0
700ad1e0: 6108         	str	r0, [r1, #0x10]
;     pRT->pause          = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_PAUSE );
700ad1e2: 9900         	ldr	r1, [sp]
700ad1e4: f3c1 7140    	ubfx	r1, r1, #0x1d, #0x1
700ad1e8: 9a01         	ldr	r2, [sp, #0x4]
700ad1ea: 6091         	str	r1, [r2, #0x8]
;     pRT->error          = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_ERROR );
700ad1ec: 9900         	ldr	r1, [sp]
700ad1ee: f001 0101    	and	r1, r1, #0x1
700ad1f2: 9a01         	ldr	r2, [sp, #0x4]
700ad1f4: 60d1         	str	r1, [r2, #0xc]
;     return CSL_PASS;
700ad1f6: b004         	add	sp, #0x10
700ad1f8: bd80         	pop	{r7, pc}
700ad1fa: 0000         	movs	r0, r0
700ad1fc: 0000         	movs	r0, r0
700ad1fe: 0000         	movs	r0, r0

700ad200 <Sciclient_getDevId>:
; {
700ad200: b083         	sub	sp, #0xc
700ad202: 9002         	str	r0, [sp, #0x8]
700ad204: f04f 30ff    	mov.w	r0, #0xffffffff
;     uint32_t retVal = UINT32_MAX;
700ad208: 9001         	str	r0, [sp, #0x4]
;     switch (coreId)
700ad20a: 9802         	ldr	r0, [sp, #0x8]
700ad20c: 9000         	str	r0, [sp]
700ad20e: 2805         	cmp	r0, #0x5
700ad210: d817         	bhi	0x700ad242 <Sciclient_getDevId+0x42> @ imm = #0x2e
700ad212: 9900         	ldr	r1, [sp]
700ad214: e8df f001    	tbb	[pc, r1]
700ad218: 03 06 09 0c  	.word	0x0c090603
700ad21c: 0f 12        	.short	0x120f
700ad21e: 2009         	movs	r0, #0x9
;         retVal = TISCI_DEV_MCU_M4FSS0_CORE0;
700ad220: 9001         	str	r0, [sp, #0x4]
;         break;
700ad222: e00f         	b	0x700ad244 <Sciclient_getDevId+0x44> @ imm = #0x1e
700ad224: 2079         	movs	r0, #0x79
;         retVal = TISCI_DEV_R5FSS0_CORE0;
700ad226: 9001         	str	r0, [sp, #0x4]
;         break;
700ad228: e00c         	b	0x700ad244 <Sciclient_getDevId+0x44> @ imm = #0x18
700ad22a: 207a         	movs	r0, #0x7a
;         retVal = TISCI_DEV_R5FSS0_CORE1;
700ad22c: 9001         	str	r0, [sp, #0x4]
;         break;
700ad22e: e009         	b	0x700ad244 <Sciclient_getDevId+0x44> @ imm = #0x12
700ad230: 207b         	movs	r0, #0x7b
;         retVal = TISCI_DEV_R5FSS1_CORE0;
700ad232: 9001         	str	r0, [sp, #0x4]
;         break;
700ad234: e006         	b	0x700ad244 <Sciclient_getDevId+0x44> @ imm = #0xc
700ad236: 207c         	movs	r0, #0x7c
;         retVal = TISCI_DEV_R5FSS1_CORE1;
700ad238: 9001         	str	r0, [sp, #0x4]
;         break;
700ad23a: e003         	b	0x700ad244 <Sciclient_getDevId+0x44> @ imm = #0x6
700ad23c: 2087         	movs	r0, #0x87
;         retVal = TISCI_DEV_A53SS0_CORE_0;
700ad23e: 9001         	str	r0, [sp, #0x4]
;         break;
700ad240: e000         	b	0x700ad244 <Sciclient_getDevId+0x44> @ imm = #0x0
;         break;
700ad242: e7ff         	b	0x700ad244 <Sciclient_getDevId+0x44> @ imm = #-0x2
;     return retVal;
700ad244: 9801         	ldr	r0, [sp, #0x4]
700ad246: b003         	add	sp, #0xc
700ad248: 4770         	bx	lr
700ad24a: 0000         	movs	r0, r0
700ad24c: 0000         	movs	r0, r0
700ad24e: 0000         	movs	r0, r0

700ad250 <UART_getIntrIdentityStatus>:
; {
700ad250: b580         	push	{r7, lr}
700ad252: b084         	sub	sp, #0x10
700ad254: 9003         	str	r0, [sp, #0xc]
700ad256: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ad258: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = 0U;
700ad25a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad25c: 9803         	ldr	r0, [sp, #0xc]
700ad25e: 300c         	adds	r0, #0xc
700ad260: f002 fafe    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x25fc
700ad264: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ad266: 9803         	ldr	r0, [sp, #0xc]
700ad268: 300c         	adds	r0, #0xc
700ad26a: 9000         	str	r0, [sp]
700ad26c: f002 faf8    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x25f0
700ad270: 4601         	mov	r1, r0
700ad272: 9800         	ldr	r0, [sp]
700ad274: f001 017f    	and	r1, r1, #0x7f
700ad278: f002 fafa    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x25f4
;     retVal = HW_RD_REG32(baseAddr + UART_IIR) & UART_IIR_IT_TYPE_MASK;
700ad27c: 9803         	ldr	r0, [sp, #0xc]
700ad27e: 3008         	adds	r0, #0x8
700ad280: f002 faee    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x25dc
700ad284: f000 003e    	and	r0, r0, #0x3e
700ad288: 9001         	str	r0, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad28a: 9803         	ldr	r0, [sp, #0xc]
700ad28c: 300c         	adds	r0, #0xc
700ad28e: 9902         	ldr	r1, [sp, #0x8]
700ad290: f002 faee    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x25dc
;     return retVal;
700ad294: 9801         	ldr	r0, [sp, #0x4]
700ad296: b004         	add	sp, #0x10
700ad298: bd80         	pop	{r7, pc}
700ad29a: 0000         	movs	r0, r0
700ad29c: 0000         	movs	r0, r0
700ad29e: 0000         	movs	r0, r0

700ad2a0 <UART_lineCharConfig>:
; {
700ad2a0: b580         	push	{r7, lr}
700ad2a2: b084         	sub	sp, #0x10
700ad2a4: 9003         	str	r0, [sp, #0xc]
700ad2a6: 9102         	str	r1, [sp, #0x8]
700ad2a8: 9201         	str	r2, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad2aa: 9803         	ldr	r0, [sp, #0xc]
700ad2ac: 300c         	adds	r0, #0xc
700ad2ae: f002 fad7    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x25ae
700ad2b2: 9000         	str	r0, [sp]
;     lcrRegValue &= ~((uint32_t) UART_LCR_NB_STOP_MASK | (uint32_t) UART_LCR_CHAR_LENGTH_MASK);
700ad2b4: 9800         	ldr	r0, [sp]
700ad2b6: f020 0007    	bic	r0, r0, #0x7
700ad2ba: 9000         	str	r0, [sp]
;     lcrRegValue |= wLenStbFlag & (UART_LCR_NB_STOP_MASK |
700ad2bc: 9802         	ldr	r0, [sp, #0x8]
700ad2be: f000 0107    	and	r1, r0, #0x7
700ad2c2: 9800         	ldr	r0, [sp]
700ad2c4: 4308         	orrs	r0, r1
700ad2c6: 9000         	str	r0, [sp]
;     lcrRegValue &= ~((uint32_t) UART_LCR_PARITY_TYPE2_MASK |
700ad2c8: 9800         	ldr	r0, [sp]
700ad2ca: f020 0038    	bic	r0, r0, #0x38
700ad2ce: 9000         	str	r0, [sp]
;     lcrRegValue |= parityFlag & (UART_LCR_PARITY_TYPE2_MASK |
700ad2d0: 9801         	ldr	r0, [sp, #0x4]
700ad2d2: f000 0138    	and	r1, r0, #0x38
700ad2d6: 9800         	ldr	r0, [sp]
700ad2d8: 4308         	orrs	r0, r1
700ad2da: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad2dc: 9803         	ldr	r0, [sp, #0xc]
700ad2de: 300c         	adds	r0, #0xc
700ad2e0: 9900         	ldr	r1, [sp]
700ad2e2: f002 fac5    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x258a
; }
700ad2e6: b004         	add	sp, #0x10
700ad2e8: bd80         	pop	{r7, pc}
700ad2ea: 0000         	movs	r0, r0
700ad2ec: 0000         	movs	r0, r0
700ad2ee: 0000         	movs	r0, r0

700ad2f0 <UART_lld_dmaInit>:
; {
700ad2f0: b580         	push	{r7, lr}
700ad2f2: b084         	sub	sp, #0x10
700ad2f4: 9003         	str	r0, [sp, #0xc]
700ad2f6: 9102         	str	r1, [sp, #0x8]
700ad2f8: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700ad2fa: 9001         	str	r0, [sp, #0x4]
;     UART_UdmaChConfig *udmaChCfg = (UART_UdmaChConfig *)dmaChCfg;
700ad2fc: 9802         	ldr	r0, [sp, #0x8]
700ad2fe: 9000         	str	r0, [sp]
;     status  = UART_udmaInitRxCh(hUart, udmaChCfg);
700ad300: 9803         	ldr	r0, [sp, #0xc]
700ad302: 9900         	ldr	r1, [sp]
700ad304: f7f6 ff44    	bl	0x700a4190 <UART_udmaInitRxCh> @ imm = #-0x9178
700ad308: 9001         	str	r0, [sp, #0x4]
;     status += UART_udmaInitTxCh(hUart, udmaChCfg);
700ad30a: 9803         	ldr	r0, [sp, #0xc]
700ad30c: 9900         	ldr	r1, [sp]
700ad30e: f7f6 ffcf    	bl	0x700a42b0 <UART_udmaInitTxCh> @ imm = #-0x9062
700ad312: 4601         	mov	r1, r0
700ad314: 9801         	ldr	r0, [sp, #0x4]
700ad316: 4408         	add	r0, r1
700ad318: 9001         	str	r0, [sp, #0x4]
;     if (status == UDMA_SOK)
700ad31a: 9801         	ldr	r0, [sp, #0x4]
700ad31c: b930         	cbnz	r0, 0x700ad32c <UART_lld_dmaInit+0x3c> @ imm = #0xc
700ad31e: e7ff         	b	0x700ad320 <UART_lld_dmaInit+0x30> @ imm = #-0x2
;         udmaChCfg->isOpen = TRUE;
700ad320: 9900         	ldr	r1, [sp]
700ad322: 2001         	movs	r0, #0x1
700ad324: 6388         	str	r0, [r1, #0x38]
700ad326: 2000         	movs	r0, #0x0
;         status = UART_TRANSFER_STATUS_SUCCESS;
700ad328: 9001         	str	r0, [sp, #0x4]
;     }
700ad32a: e003         	b	0x700ad334 <UART_lld_dmaInit+0x44> @ imm = #0x6
700ad32c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ad330: 9001         	str	r0, [sp, #0x4]
700ad332: e7ff         	b	0x700ad334 <UART_lld_dmaInit+0x44> @ imm = #-0x2
;     return status;
700ad334: 9801         	ldr	r0, [sp, #0x4]
700ad336: b004         	add	sp, #0x10
700ad338: bd80         	pop	{r7, pc}
700ad33a: 0000         	movs	r0, r0
700ad33c: 0000         	movs	r0, r0
700ad33e: 0000         	movs	r0, r0

700ad340 <xQueueGenericCreateStatic>:
;     {
700ad340: b580         	push	{r7, lr}
700ad342: b088         	sub	sp, #0x20
700ad344: 4684         	mov	r12, r0
700ad346: 980a         	ldr	r0, [sp, #0x28]
700ad348: f8cd c01c    	str.w	r12, [sp, #0x1c]
700ad34c: 9106         	str	r1, [sp, #0x18]
700ad34e: 9205         	str	r2, [sp, #0x14]
700ad350: 9304         	str	r3, [sp, #0x10]
700ad352: f88d 000f    	strb.w	r0, [sp, #0xf]
;         pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
700ad356: 9804         	ldr	r0, [sp, #0x10]
700ad358: 9002         	str	r0, [sp, #0x8]
;         if( pxNewQueue != NULL )
700ad35a: 9802         	ldr	r0, [sp, #0x8]
700ad35c: b188         	cbz	r0, 0x700ad382 <xQueueGenericCreateStatic+0x42> @ imm = #0x22
700ad35e: e7ff         	b	0x700ad360 <xQueueGenericCreateStatic+0x20> @ imm = #-0x2
;                     pxNewQueue->ucStaticallyAllocated = pdTRUE;
700ad360: 9902         	ldr	r1, [sp, #0x8]
700ad362: 2001         	movs	r0, #0x1
700ad364: f881 0046    	strb.w	r0, [r1, #0x46]
;             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
700ad368: 9807         	ldr	r0, [sp, #0x1c]
700ad36a: 9906         	ldr	r1, [sp, #0x18]
700ad36c: 9a05         	ldr	r2, [sp, #0x14]
700ad36e: f89d 300f    	ldrb.w	r3, [sp, #0xf]
700ad372: f8dd c008    	ldr.w	r12, [sp, #0x8]
700ad376: 46ee         	mov	lr, sp
700ad378: f8ce c000    	str.w	r12, [lr]
700ad37c: f000 f850    	bl	0x700ad420 <prvInitialiseNewQueue> @ imm = #0xa0
;         }
700ad380: e000         	b	0x700ad384 <xQueueGenericCreateStatic+0x44> @ imm = #0x0
700ad382: e7ff         	b	0x700ad384 <xQueueGenericCreateStatic+0x44> @ imm = #-0x2
;         return pxNewQueue;
700ad384: 9802         	ldr	r0, [sp, #0x8]
700ad386: b008         	add	sp, #0x20
700ad388: bd80         	pop	{r7, pc}
700ad38a: 0000         	movs	r0, r0
700ad38c: 0000         	movs	r0, r0
700ad38e: 0000         	movs	r0, r0

700ad390 <UART_resetModule>:
; {
700ad390: b580         	push	{r7, lr}
700ad392: b082         	sub	sp, #0x8
700ad394: 9001         	str	r0, [sp, #0x4]
;     (void)UART_enhanFuncEnable(hUart->baseAddr);
700ad396: 9801         	ldr	r0, [sp, #0x4]
700ad398: 6800         	ldr	r0, [r0]
700ad39a: f000 fd41    	bl	0x700ade20 <UART_enhanFuncEnable> @ imm = #0xa82
;     UART_regConfModeRestore(hUart->baseAddr, 0x00U);
700ad39e: 9801         	ldr	r0, [sp, #0x4]
700ad3a0: 6800         	ldr	r0, [r0]
700ad3a2: 2100         	movs	r1, #0x0
700ad3a4: f002 f92c    	bl	0x700af600 <UART_regConfModeRestore> @ imm = #0x2258
;     UART_modemControlReset(hUart->baseAddr);
700ad3a8: 9801         	ldr	r0, [sp, #0x4]
700ad3aa: 6800         	ldr	r0, [r0]
700ad3ac: f002 f850    	bl	0x700af450 <UART_modemControlReset> @ imm = #0x20a0
;     UART_intrDisable(hUart->baseAddr, 0xFFU);
700ad3b0: 9801         	ldr	r0, [sp, #0x4]
700ad3b2: 6800         	ldr	r0, [r0]
700ad3b4: 21ff         	movs	r1, #0xff
700ad3b6: f7f8 fe43    	bl	0x700a6040 <UART_intrDisable> @ imm = #-0x737a
;     UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700ad3ba: 9801         	ldr	r0, [sp, #0x4]
700ad3bc: 6800         	ldr	r0, [r0]
700ad3be: 2102         	movs	r1, #0x2
700ad3c0: f001 fb96    	bl	0x700aeaf0 <UART_intr2Disable> @ imm = #0x172c
;     (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700ad3c4: 9801         	ldr	r0, [sp, #0x4]
700ad3c6: 6800         	ldr	r0, [r0]
700ad3c8: 2107         	movs	r1, #0x7
700ad3ca: f001 fbd9    	bl	0x700aeb80 <UART_operatingModeSelect> @ imm = #0x17b2
;     UART_moduleReset(hUart);
700ad3ce: 9801         	ldr	r0, [sp, #0x4]
700ad3d0: f7fd f9ae    	bl	0x700aa730 <UART_moduleReset> @ imm = #-0x2ca4
;     return;
700ad3d4: b002         	add	sp, #0x8
700ad3d6: bd80         	pop	{r7, pc}

700ad3d8 <memccpy>:
700ad3d8: e92d4800     	push	{r11, lr}
700ad3dc: e1a0c000     	mov	r12, r0
700ad3e0: e3a00000     	mov	r0, #0
700ad3e4: e3530000     	cmp	r3, #0
700ad3e8: 0a000009     	beq	0x700ad414 <memccpy+0x3c> @ imm = #0x24
700ad3ec: e28cc001     	add	r12, r12, #1
700ad3f0: e6efe072     	uxtb	lr, r2
700ad3f4: e5d12000     	ldrb	r2, [r1]
700ad3f8: e152000e     	cmp	r2, lr
700ad3fc: e54c2001     	strb	r2, [r12, #-0x1]
700ad400: 0a000004     	beq	0x700ad418 <memccpy+0x40> @ imm = #0x10
700ad404: e2811001     	add	r1, r1, #1
700ad408: e2533001     	subs	r3, r3, #1
700ad40c: e28cc001     	add	r12, r12, #1
700ad410: 1afffff7     	bne	0x700ad3f4 <memccpy+0x1c> @ imm = #-0x24
700ad414: e8bd8800     	pop	{r11, pc}
700ad418: e1a0000c     	mov	r0, r12
700ad41c: e8bd8800     	pop	{r11, pc}

700ad420 <prvInitialiseNewQueue>:
; {
700ad420: b580         	push	{r7, lr}
700ad422: b084         	sub	sp, #0x10
700ad424: f8dd c018    	ldr.w	r12, [sp, #0x18]
700ad428: 9003         	str	r0, [sp, #0xc]
700ad42a: 9102         	str	r1, [sp, #0x8]
700ad42c: 9201         	str	r2, [sp, #0x4]
700ad42e: f88d 3003    	strb.w	r3, [sp, #0x3]
;     if( uxItemSize == ( UBaseType_t ) 0 )
700ad432: 9802         	ldr	r0, [sp, #0x8]
700ad434: b918         	cbnz	r0, 0x700ad43e <prvInitialiseNewQueue+0x1e> @ imm = #0x6
700ad436: e7ff         	b	0x700ad438 <prvInitialiseNewQueue+0x18> @ imm = #-0x2
;         pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
700ad438: 9806         	ldr	r0, [sp, #0x18]
700ad43a: 6000         	str	r0, [r0]
;     }
700ad43c: e003         	b	0x700ad446 <prvInitialiseNewQueue+0x26> @ imm = #0x6
;         pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
700ad43e: 9801         	ldr	r0, [sp, #0x4]
700ad440: 9906         	ldr	r1, [sp, #0x18]
700ad442: 6008         	str	r0, [r1]
700ad444: e7ff         	b	0x700ad446 <prvInitialiseNewQueue+0x26> @ imm = #-0x2
;     pxNewQueue->uxLength = uxQueueLength;
700ad446: 9803         	ldr	r0, [sp, #0xc]
700ad448: 9906         	ldr	r1, [sp, #0x18]
700ad44a: 63c8         	str	r0, [r1, #0x3c]
;     pxNewQueue->uxItemSize = uxItemSize;
700ad44c: 9802         	ldr	r0, [sp, #0x8]
700ad44e: 9906         	ldr	r1, [sp, #0x18]
700ad450: 6408         	str	r0, [r1, #0x40]
;     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
700ad452: 9806         	ldr	r0, [sp, #0x18]
700ad454: 2101         	movs	r1, #0x1
700ad456: f7fc fdc3    	bl	0x700a9fe0 <xQueueGenericReset> @ imm = #-0x347a
;             pxNewQueue->ucQueueType = ucQueueType;
700ad45a: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ad45e: 9906         	ldr	r1, [sp, #0x18]
700ad460: f881 004c    	strb.w	r0, [r1, #0x4c]
; }
700ad464: b004         	add	sp, #0x10
700ad466: bd80         	pop	{r7, pc}
		...

700ad470 <uxListRemove>:
; {
700ad470: b082         	sub	sp, #0x8
700ad472: 9001         	str	r0, [sp, #0x4]
;     List_t * const pxList = pxItemToRemove->pxContainer;
700ad474: 9801         	ldr	r0, [sp, #0x4]
700ad476: 6900         	ldr	r0, [r0, #0x10]
700ad478: 9000         	str	r0, [sp]
;     pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
700ad47a: 9801         	ldr	r0, [sp, #0x4]
700ad47c: 6841         	ldr	r1, [r0, #0x4]
700ad47e: 6880         	ldr	r0, [r0, #0x8]
700ad480: 6088         	str	r0, [r1, #0x8]
;     pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
700ad482: 9901         	ldr	r1, [sp, #0x4]
700ad484: 6848         	ldr	r0, [r1, #0x4]
700ad486: 6889         	ldr	r1, [r1, #0x8]
700ad488: 6048         	str	r0, [r1, #0x4]
;     if( pxList->pxIndex == pxItemToRemove )
700ad48a: 9800         	ldr	r0, [sp]
700ad48c: 6840         	ldr	r0, [r0, #0x4]
700ad48e: 9901         	ldr	r1, [sp, #0x4]
700ad490: 4288         	cmp	r0, r1
700ad492: d105         	bne	0x700ad4a0 <uxListRemove+0x30> @ imm = #0xa
700ad494: e7ff         	b	0x700ad496 <uxListRemove+0x26> @ imm = #-0x2
;         pxList->pxIndex = pxItemToRemove->pxPrevious;
700ad496: 9801         	ldr	r0, [sp, #0x4]
700ad498: 6880         	ldr	r0, [r0, #0x8]
700ad49a: 9900         	ldr	r1, [sp]
700ad49c: 6048         	str	r0, [r1, #0x4]
;     }
700ad49e: e000         	b	0x700ad4a2 <uxListRemove+0x32> @ imm = #0x0
700ad4a0: e7ff         	b	0x700ad4a2 <uxListRemove+0x32> @ imm = #-0x2
;     pxItemToRemove->pxContainer = NULL;
700ad4a2: 9901         	ldr	r1, [sp, #0x4]
700ad4a4: 2000         	movs	r0, #0x0
700ad4a6: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )--;
700ad4a8: 9900         	ldr	r1, [sp]
700ad4aa: 6808         	ldr	r0, [r1]
700ad4ac: 3801         	subs	r0, #0x1
700ad4ae: 6008         	str	r0, [r1]
;     return pxList->uxNumberOfItems;
700ad4b0: 9800         	ldr	r0, [sp]
700ad4b2: 6800         	ldr	r0, [r0]
700ad4b4: b002         	add	sp, #0x8
700ad4b6: 4770         	bx	lr
		...

700ad4c0 <CSL_bcdmaTeardownRxChan>:
; {
700ad4c0: b580         	push	{r7, lr}
700ad4c2: b086         	sub	sp, #0x18
700ad4c4: 9005         	str	r0, [sp, #0x14]
700ad4c6: 9104         	str	r1, [sp, #0x10]
700ad4c8: f88d 200f    	strb.w	r2, [sp, #0xf]
700ad4cc: f88d 300e    	strb.w	r3, [sp, #0xe]
;     teardownOpts.force  = (bForce == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad4d0: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ad4d4: f000 0001    	and	r0, r0, #0x1
700ad4d8: 9000         	str	r0, [sp]
;     teardownOpts.wait   = (bWait  == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad4da: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700ad4de: f000 0001    	and	r0, r0, #0x1
700ad4e2: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_TEARDOWN, chanIdx, (void *)&teardownOpts );
700ad4e4: 9805         	ldr	r0, [sp, #0x14]
700ad4e6: 9a04         	ldr	r2, [sp, #0x10]
700ad4e8: 2105         	movs	r1, #0x5
700ad4ea: 466b         	mov	r3, sp
700ad4ec: f7fd fc20    	bl	0x700aad30 <CSL_bcdmaDoChanOp> @ imm = #-0x27c0
700ad4f0: 9002         	str	r0, [sp, #0x8]
;     if( retVal != CSL_PASS )
700ad4f2: 9802         	ldr	r0, [sp, #0x8]
700ad4f4: b120         	cbz	r0, 0x700ad500 <CSL_bcdmaTeardownRxChan+0x40> @ imm = #0x8
700ad4f6: e7ff         	b	0x700ad4f8 <CSL_bcdmaTeardownRxChan+0x38> @ imm = #-0x2
700ad4f8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ad4fc: 9002         	str	r0, [sp, #0x8]
;     }
700ad4fe: e7ff         	b	0x700ad500 <CSL_bcdmaTeardownRxChan+0x40> @ imm = #-0x2
;     return retVal;
700ad500: 9802         	ldr	r0, [sp, #0x8]
700ad502: b006         	add	sp, #0x18
700ad504: bd80         	pop	{r7, pc}
		...
700ad50e: 0000         	movs	r0, r0

700ad510 <CSL_bcdmaTeardownTxChan>:
; {
700ad510: b580         	push	{r7, lr}
700ad512: b086         	sub	sp, #0x18
700ad514: 9005         	str	r0, [sp, #0x14]
700ad516: 9104         	str	r1, [sp, #0x10]
700ad518: f88d 200f    	strb.w	r2, [sp, #0xf]
700ad51c: f88d 300e    	strb.w	r3, [sp, #0xe]
;     teardownOpts.force  = (bForce == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad520: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ad524: f000 0001    	and	r0, r0, #0x1
700ad528: 9000         	str	r0, [sp]
;     teardownOpts.wait   = (bWait  == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad52a: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700ad52e: f000 0001    	and	r0, r0, #0x1
700ad532: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_TEARDOWN, chanIdx, (void *)&teardownOpts );
700ad534: 9805         	ldr	r0, [sp, #0x14]
700ad536: 9a04         	ldr	r2, [sp, #0x10]
700ad538: 2105         	movs	r1, #0x5
700ad53a: 466b         	mov	r3, sp
700ad53c: f7fd fbf8    	bl	0x700aad30 <CSL_bcdmaDoChanOp> @ imm = #-0x2810
700ad540: 9002         	str	r0, [sp, #0x8]
;     if( retVal != CSL_PASS )
700ad542: 9802         	ldr	r0, [sp, #0x8]
700ad544: b120         	cbz	r0, 0x700ad550 <CSL_bcdmaTeardownTxChan+0x40> @ imm = #0x8
700ad546: e7ff         	b	0x700ad548 <CSL_bcdmaTeardownTxChan+0x38> @ imm = #-0x2
700ad548: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ad54c: 9002         	str	r0, [sp, #0x8]
;     }
700ad54e: e7ff         	b	0x700ad550 <CSL_bcdmaTeardownTxChan+0x40> @ imm = #-0x2
;     return retVal;
700ad550: 9802         	ldr	r0, [sp, #0x8]
700ad552: b006         	add	sp, #0x18
700ad554: bd80         	pop	{r7, pc}
		...
700ad55e: 0000         	movs	r0, r0

700ad560 <DebugP_uartLogWriterPutChar>:
; {
700ad560: b580         	push	{r7, lr}
700ad562: b088         	sub	sp, #0x20
700ad564: f88d 001f    	strb.w	r0, [sp, #0x1f]
;     char value = character;
700ad568: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700ad56c: f88d 001e    	strb.w	r0, [sp, #0x1e]
;     UART_Handle uartHandle = UART_getHandle(gDebugP_uartDrvIndex);
700ad570: f242 60a4    	movw	r0, #0x26a4
700ad574: f2c7 000b    	movt	r0, #0x700b
700ad578: 6800         	ldr	r0, [r0]
700ad57a: f7ff fd29    	bl	0x700acfd0 <UART_getHandle> @ imm = #-0x5ae
700ad57e: 9006         	str	r0, [sp, #0x18]
;     if(uartHandle!=NULL)
700ad580: 9806         	ldr	r0, [sp, #0x18]
700ad582: b170         	cbz	r0, 0x700ad5a2 <DebugP_uartLogWriterPutChar+0x42> @ imm = #0x1c
700ad584: e7ff         	b	0x700ad586 <DebugP_uartLogWriterPutChar+0x26> @ imm = #-0x2
700ad586: a801         	add	r0, sp, #0x4
;         UART_Transaction_init(&trans);
700ad588: 9000         	str	r0, [sp]
700ad58a: f001 fa99    	bl	0x700aeac0 <UART_Transaction_init> @ imm = #0x1532
700ad58e: 9900         	ldr	r1, [sp]
700ad590: f10d 001e    	add.w	r0, sp, #0x1e
;         trans.buf   = &value;
700ad594: 9001         	str	r0, [sp, #0x4]
700ad596: 2001         	movs	r0, #0x1
;         trans.count = 1;
700ad598: 9002         	str	r0, [sp, #0x8]
;         (void) UART_write(uartHandle, &trans);
700ad59a: 9806         	ldr	r0, [sp, #0x18]
700ad59c: f7f2 fe80    	bl	0x700a02a0 <UART_write> @ imm = #-0xd300
;     }
700ad5a0: e7ff         	b	0x700ad5a2 <DebugP_uartLogWriterPutChar+0x42> @ imm = #-0x2
; }
700ad5a2: b008         	add	sp, #0x20
700ad5a4: bd80         	pop	{r7, pc}
		...
700ad5ae: 0000         	movs	r0, r0

700ad5b0 <Dpl_init>:
; {
700ad5b0: b510         	push	{r4, lr}
;     HwiP_init();
700ad5b2: f002 fc9d    	bl	0x700afef0 <HwiP_init>  @ imm = #0x293a
;     DebugP_logZoneEnable(DebugP_LOG_ZONE_ERROR);
700ad5b6: 2002         	movs	r0, #0x2
700ad5b8: f001 f992    	bl	0x700ae8e0 <DebugP_logZoneEnable> @ imm = #0x1324
;     DebugP_logZoneEnable(DebugP_LOG_ZONE_WARN);
700ad5bc: 2004         	movs	r0, #0x4
700ad5be: f001 f98f    	bl	0x700ae8e0 <DebugP_logZoneEnable> @ imm = #0x131e
;     DebugP_memLogWriterInit(CSL_CORE_ID_R5FSS0_0);
700ad5c2: 2001         	movs	r0, #0x1
700ad5c4: f001 fdb4    	bl	0x700af130 <DebugP_memLogWriterInit> @ imm = #0x1b68
;     DebugP_uartSetDrvIndex(CONFIG_UART_CONSOLE);
700ad5c8: 2000         	movs	r0, #0x0
700ad5ca: 2400         	movs	r4, #0x0
700ad5cc: f002 f838    	bl	0x700af640 <DebugP_uartSetDrvIndex> @ imm = #0x2070
;     SOC_controlModuleUnlockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ad5d0: 2000         	movs	r0, #0x0
700ad5d2: 2102         	movs	r1, #0x2
700ad5d4: f7fb fb44    	bl	0x700a8c60 <SOC_controlModuleUnlockMMR> @ imm = #-0x4978
700ad5d8: f248 10d0    	movw	r0, #0x81d0
;     SOC_controlModuleLockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ad5dc: 2102         	movs	r1, #0x2
700ad5de: f2c4 3000    	movt	r0, #0x4300
;     *(volatile uint32_t*)(TIMER8_CLOCK_SRC_MUX_ADDR) = TIMER8_CLOCK_SRC_MCU_HFOSC0;
700ad5e2: 6004         	str	r4, [r0]
;     SOC_controlModuleLockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ad5e4: 2000         	movs	r0, #0x0
700ad5e6: f7fc fdd3    	bl	0x700aa190 <SOC_controlModuleLockMMR> @ imm = #-0x345a
;     ClockP_init();
700ad5ea: f7f3 f8d1    	bl	0x700a0790 <ClockP_init> @ imm = #-0xce5e
;     HwiP_enable();
700ad5ee: e8bd 4010    	pop.w	{r4, lr}
700ad5f2: f7ef bcc1    	b.w	0x7009cf78 <$Ven$TA$L$PI$$HwiP_enable> @ imm = #-0x1067e
		...
700ad5fe: 0000         	movs	r0, r0

700ad600 <UART_readLineStatus>:
; {
700ad600: b580         	push	{r7, lr}
700ad602: b084         	sub	sp, #0x10
700ad604: 9003         	str	r0, [sp, #0xc]
700ad606: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ad608: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = 0U;
700ad60a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad60c: 9803         	ldr	r0, [sp, #0xc]
700ad60e: 300c         	adds	r0, #0xc
700ad610: f002 f926    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x224c
700ad614: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ad616: 9803         	ldr	r0, [sp, #0xc]
700ad618: 300c         	adds	r0, #0xc
700ad61a: 9000         	str	r0, [sp]
700ad61c: f002 f920    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x2240
700ad620: 4601         	mov	r1, r0
700ad622: 9800         	ldr	r0, [sp]
700ad624: f001 017f    	and	r1, r1, #0x7f
700ad628: f002 f922    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x2244
;     retVal = HW_RD_REG32(baseAddr + UART_LSR);
700ad62c: 9803         	ldr	r0, [sp, #0xc]
700ad62e: 3014         	adds	r0, #0x14
700ad630: f002 f916    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x222c
700ad634: 9001         	str	r0, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad636: 9803         	ldr	r0, [sp, #0xc]
700ad638: 300c         	adds	r0, #0xc
700ad63a: 9902         	ldr	r1, [sp, #0x8]
700ad63c: f002 f918    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x2230
;     return retVal;
700ad640: 9801         	ldr	r0, [sp, #0x4]
700ad642: b004         	add	sp, #0x10
700ad644: bd80         	pop	{r7, pc}
		...
700ad64e: 0000         	movs	r0, r0

700ad650 <vTaskExitCritical>:
;   if (xSchedulerRunning != pdFALSE) {
700ad650: f242 7000    	movw	r0, #0x2700
700ad654: f2c7 000b    	movt	r0, #0x700b
700ad658: 6800         	ldr	r0, [r0]
700ad65a: b1d0         	cbz	r0, 0x700ad692 <vTaskExitCritical+0x42> @ imm = #0x34
700ad65c: e7ff         	b	0x700ad65e <vTaskExitCritical+0xe> @ imm = #-0x2
;     if (pxCurrentTCB->uxCriticalNesting > 0U) {
700ad65e: f242 60bc    	movw	r0, #0x26bc
700ad662: f2c7 000b    	movt	r0, #0x700b
700ad666: 6800         	ldr	r0, [r0]
700ad668: 6d40         	ldr	r0, [r0, #0x54]
700ad66a: b180         	cbz	r0, 0x700ad68e <vTaskExitCritical+0x3e> @ imm = #0x20
700ad66c: e7ff         	b	0x700ad66e <vTaskExitCritical+0x1e> @ imm = #-0x2
;       (pxCurrentTCB->uxCriticalNesting)--;
700ad66e: f242 60bc    	movw	r0, #0x26bc
700ad672: f2c7 000b    	movt	r0, #0x700b
700ad676: 6802         	ldr	r2, [r0]
700ad678: 6d51         	ldr	r1, [r2, #0x54]
700ad67a: 3901         	subs	r1, #0x1
700ad67c: 6551         	str	r1, [r2, #0x54]
;       if (pxCurrentTCB->uxCriticalNesting == 0U) {
700ad67e: 6800         	ldr	r0, [r0]
700ad680: 6d40         	ldr	r0, [r0, #0x54]
700ad682: b910         	cbnz	r0, 0x700ad68a <vTaskExitCritical+0x3a> @ imm = #0x4
700ad684: e7ff         	b	0x700ad686 <vTaskExitCritical+0x36> @ imm = #-0x2
;     __asm__ volatile ( "CPSIE	i" ::: "cc" );
700ad686: b662         	cpsie i
;       } else {
700ad688: e000         	b	0x700ad68c <vTaskExitCritical+0x3c> @ imm = #0x0
700ad68a: e7ff         	b	0x700ad68c <vTaskExitCritical+0x3c> @ imm = #-0x2
;     } else {
700ad68c: e000         	b	0x700ad690 <vTaskExitCritical+0x40> @ imm = #0x0
700ad68e: e7ff         	b	0x700ad690 <vTaskExitCritical+0x40> @ imm = #-0x2
;   } else {
700ad690: e000         	b	0x700ad694 <vTaskExitCritical+0x44> @ imm = #0x0
700ad692: e7ff         	b	0x700ad694 <vTaskExitCritical+0x44> @ imm = #-0x2
; }
700ad694: 4770         	bx	lr
		...
700ad69e: 0000         	movs	r0, r0

700ad6a0 <CSL_bcdmaGetChanPeerReg>:
; {
700ad6a0: b580         	push	{r7, lr}
700ad6a2: b088         	sub	sp, #0x20
700ad6a4: f8dd c028    	ldr.w	r12, [sp, #0x28]
700ad6a8: 9007         	str	r0, [sp, #0x1c]
700ad6aa: 9106         	str	r1, [sp, #0x18]
700ad6ac: 9205         	str	r2, [sp, #0x14]
700ad6ae: 9304         	str	r3, [sp, #0x10]
;     remotePeerOpts.regIdx = regIdx;
700ad6b0: 9804         	ldr	r0, [sp, #0x10]
700ad6b2: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_REMOTE_PEER_REG, chanIdx, (void *)&remotePeerOpts );
700ad6b4: 9807         	ldr	r0, [sp, #0x1c]
700ad6b6: 9a06         	ldr	r2, [sp, #0x18]
700ad6b8: 210b         	movs	r1, #0xb
700ad6ba: ab01         	add	r3, sp, #0x4
700ad6bc: f7fd fb38    	bl	0x700aad30 <CSL_bcdmaDoChanOp> @ imm = #-0x2990
700ad6c0: 9003         	str	r0, [sp, #0xc]
;     if( retVal == CSL_PASS )
700ad6c2: 9803         	ldr	r0, [sp, #0xc]
700ad6c4: b920         	cbnz	r0, 0x700ad6d0 <CSL_bcdmaGetChanPeerReg+0x30> @ imm = #0x8
700ad6c6: e7ff         	b	0x700ad6c8 <CSL_bcdmaGetChanPeerReg+0x28> @ imm = #-0x2
;         *pVal = remotePeerOpts.regVal;
700ad6c8: 9802         	ldr	r0, [sp, #0x8]
700ad6ca: 990a         	ldr	r1, [sp, #0x28]
700ad6cc: 6008         	str	r0, [r1]
;     }
700ad6ce: e006         	b	0x700ad6de <CSL_bcdmaGetChanPeerReg+0x3e> @ imm = #0xc
;         *pVal = (uint32_t)0U;
700ad6d0: 990a         	ldr	r1, [sp, #0x28]
700ad6d2: 2000         	movs	r0, #0x0
700ad6d4: 6008         	str	r0, [r1]
700ad6d6: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ad6da: 9003         	str	r0, [sp, #0xc]
700ad6dc: e7ff         	b	0x700ad6de <CSL_bcdmaGetChanPeerReg+0x3e> @ imm = #-0x2
;     return retVal;
700ad6de: 9803         	ldr	r0, [sp, #0xc]
700ad6e0: b008         	add	sp, #0x20
700ad6e2: bd80         	pop	{r7, pc}
		...

700ad6f0 <_strnlen_s>:
; {
700ad6f0: b084         	sub	sp, #0x10
700ad6f2: 9003         	str	r0, [sp, #0xc]
700ad6f4: 9102         	str	r1, [sp, #0x8]
;   for (s = str; *s && maxsize--; ++s);
700ad6f6: 9803         	ldr	r0, [sp, #0xc]
700ad6f8: 9001         	str	r0, [sp, #0x4]
700ad6fa: e7ff         	b	0x700ad6fc <_strnlen_s+0xc> @ imm = #-0x2
700ad6fc: 9801         	ldr	r0, [sp, #0x4]
700ad6fe: 7801         	ldrb	r1, [r0]
700ad700: 2000         	movs	r0, #0x0
700ad702: 9000         	str	r0, [sp]
700ad704: b141         	cbz	r1, 0x700ad718 <_strnlen_s+0x28> @ imm = #0x10
700ad706: e7ff         	b	0x700ad708 <_strnlen_s+0x18> @ imm = #-0x2
700ad708: 9802         	ldr	r0, [sp, #0x8]
700ad70a: 1e41         	subs	r1, r0, #0x1
700ad70c: 9102         	str	r1, [sp, #0x8]
700ad70e: 2800         	cmp	r0, #0x0
700ad710: bf18         	it	ne
700ad712: 2001         	movne	r0, #0x1
700ad714: 9000         	str	r0, [sp]
700ad716: e7ff         	b	0x700ad718 <_strnlen_s+0x28> @ imm = #-0x2
700ad718: 9800         	ldr	r0, [sp]
;   for (s = str; *s && maxsize--; ++s);
700ad71a: 07c0         	lsls	r0, r0, #0x1f
700ad71c: b128         	cbz	r0, 0x700ad72a <_strnlen_s+0x3a> @ imm = #0xa
700ad71e: e7ff         	b	0x700ad720 <_strnlen_s+0x30> @ imm = #-0x2
700ad720: e7ff         	b	0x700ad722 <_strnlen_s+0x32> @ imm = #-0x2
700ad722: 9801         	ldr	r0, [sp, #0x4]
700ad724: 3001         	adds	r0, #0x1
700ad726: 9001         	str	r0, [sp, #0x4]
700ad728: e7e8         	b	0x700ad6fc <_strnlen_s+0xc> @ imm = #-0x30
;   return (unsigned int)(s - str);
700ad72a: 9801         	ldr	r0, [sp, #0x4]
700ad72c: 9903         	ldr	r1, [sp, #0xc]
700ad72e: 1a40         	subs	r0, r0, r1
700ad730: b004         	add	sp, #0x10
700ad732: 4770         	bx	lr
		...

700ad740 <prvSampleTimeNow>:
;     {
700ad740: b580         	push	{r7, lr}
700ad742: b082         	sub	sp, #0x8
700ad744: 9001         	str	r0, [sp, #0x4]
;         xTimeNow = xTaskGetTickCount();
700ad746: f001 fd83    	bl	0x700af250 <xTaskGetTickCount> @ imm = #0x1b06
700ad74a: 9000         	str	r0, [sp]
;         if( xTimeNow < xLastTime )
700ad74c: 9800         	ldr	r0, [sp]
700ad74e: f242 61b8    	movw	r1, #0x26b8
700ad752: f2c7 010b    	movt	r1, #0x700b
700ad756: 6809         	ldr	r1, [r1]
700ad758: 4288         	cmp	r0, r1
700ad75a: d206         	bhs	0x700ad76a <prvSampleTimeNow+0x2a> @ imm = #0xc
700ad75c: e7ff         	b	0x700ad75e <prvSampleTimeNow+0x1e> @ imm = #-0x2
;             prvSwitchTimerLists();
700ad75e: f7f9 ff27    	bl	0x700a75b0 <prvSwitchTimerLists> @ imm = #-0x61b2
;             *pxTimerListsWereSwitched = pdTRUE;
700ad762: 9901         	ldr	r1, [sp, #0x4]
700ad764: 2001         	movs	r0, #0x1
700ad766: 6008         	str	r0, [r1]
;         }
700ad768: e003         	b	0x700ad772 <prvSampleTimeNow+0x32> @ imm = #0x6
;             *pxTimerListsWereSwitched = pdFALSE;
700ad76a: 9901         	ldr	r1, [sp, #0x4]
700ad76c: 2000         	movs	r0, #0x0
700ad76e: 6008         	str	r0, [r1]
700ad770: e7ff         	b	0x700ad772 <prvSampleTimeNow+0x32> @ imm = #-0x2
;         xLastTime = xTimeNow;
700ad772: 9800         	ldr	r0, [sp]
700ad774: f242 61b8    	movw	r1, #0x26b8
700ad778: f2c7 010b    	movt	r1, #0x700b
700ad77c: 6008         	str	r0, [r1]
;         return xTimeNow;
700ad77e: 9800         	ldr	r0, [sp]
700ad780: b002         	add	sp, #0x8
700ad782: bd80         	pop	{r7, pc}
		...

700ad790 <CSL_udmapCppi5SetPktLen>:
; {
700ad790: b083         	sub	sp, #0xc
700ad792: 9002         	str	r0, [sp, #0x8]
700ad794: 9101         	str	r1, [sp, #0x4]
700ad796: 9200         	str	r2, [sp]
;     if( (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST) ||
700ad798: 9801         	ldr	r0, [sp, #0x4]
700ad79a: 2801         	cmp	r0, #0x1
700ad79c: d004         	beq	0x700ad7a8 <CSL_udmapCppi5SetPktLen+0x18> @ imm = #0x8
700ad79e: e7ff         	b	0x700ad7a0 <CSL_udmapCppi5SetPktLen+0x10> @ imm = #-0x2
;         (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_MONO) )
700ad7a0: 9801         	ldr	r0, [sp, #0x4]
;     if( (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST) ||
700ad7a2: 2802         	cmp	r0, #0x2
700ad7a4: d107         	bne	0x700ad7b6 <CSL_udmapCppi5SetPktLen+0x26> @ imm = #0xe
700ad7a6: e7ff         	b	0x700ad7a8 <CSL_udmapCppi5SetPktLen+0x18> @ imm = #-0x2
;         CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PKTLEN, pktLen );
700ad7a8: 9902         	ldr	r1, [sp, #0x8]
700ad7aa: 6808         	ldr	r0, [r1]
700ad7ac: 9a00         	ldr	r2, [sp]
700ad7ae: f362 0015    	bfi	r0, r2, #0, #22
700ad7b2: 6008         	str	r0, [r1]
;     }
700ad7b4: e7ff         	b	0x700ad7b6 <CSL_udmapCppi5SetPktLen+0x26> @ imm = #-0x2
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700ad7b6: 9801         	ldr	r0, [sp, #0x4]
700ad7b8: 2803         	cmp	r0, #0x3
700ad7ba: d108         	bne	0x700ad7ce <CSL_udmapCppi5SetPktLen+0x3e> @ imm = #0x10
700ad7bc: e7ff         	b	0x700ad7be <CSL_udmapCppi5SetPktLen+0x2e> @ imm = #-0x2
;         CSL_FINS( ((CSL_UdmapCppi5TRPD *)pDesc)->descInfo, UDMAP_CPPI5_TRPD_DESCINFO_LASTIDX, pktLen-1U );
700ad7be: 9902         	ldr	r1, [sp, #0x8]
700ad7c0: 6808         	ldr	r0, [r1]
700ad7c2: 9a00         	ldr	r2, [sp]
700ad7c4: 3a01         	subs	r2, #0x1
700ad7c6: f362 000d    	bfi	r0, r2, #0, #14
700ad7ca: 6008         	str	r0, [r1]
;     }
700ad7cc: e7ff         	b	0x700ad7ce <CSL_udmapCppi5SetPktLen+0x3e> @ imm = #-0x2
; }
700ad7ce: b003         	add	sp, #0xc
700ad7d0: 4770         	bx	lr
		...
700ad7de: 0000         	movs	r0, r0

700ad7e0 <Sciclient_rmIrqGetNodeItf>:
; {
700ad7e0: b084         	sub	sp, #0x10
700ad7e2: 9003         	str	r0, [sp, #0xc]
700ad7e4: f8ad 100a    	strh.w	r1, [sp, #0xa]
700ad7e8: 9201         	str	r2, [sp, #0x4]
700ad7ea: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ad7ec: 9000         	str	r0, [sp]
;     if (n_itf < n->n_if) {
700ad7ee: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700ad7f2: 9903         	ldr	r1, [sp, #0xc]
700ad7f4: 8849         	ldrh	r1, [r1, #0x2]
700ad7f6: 4288         	cmp	r0, r1
700ad7f8: da09         	bge	0x700ad80e <Sciclient_rmIrqGetNodeItf+0x2e> @ imm = #0x12
700ad7fa: e7ff         	b	0x700ad7fc <Sciclient_rmIrqGetNodeItf+0x1c> @ imm = #-0x2
;         *itf = n->p_if[n_itf];
700ad7fc: 9803         	ldr	r0, [sp, #0xc]
700ad7fe: 6840         	ldr	r0, [r0, #0x4]
700ad800: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700ad804: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700ad808: 9901         	ldr	r1, [sp, #0x4]
700ad80a: 6008         	str	r0, [r1]
;     } else {
700ad80c: e006         	b	0x700ad81c <Sciclient_rmIrqGetNodeItf+0x3c> @ imm = #0xc
;         *itf = NULL;
700ad80e: 9901         	ldr	r1, [sp, #0x4]
700ad810: 2000         	movs	r0, #0x0
700ad812: 6008         	str	r0, [r1]
700ad814: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ad818: 9000         	str	r0, [sp]
700ad81a: e7ff         	b	0x700ad81c <Sciclient_rmIrqGetNodeItf+0x3c> @ imm = #-0x2
;     return r;
700ad81c: 9800         	ldr	r0, [sp]
700ad81e: b004         	add	sp, #0x10
700ad820: 4770         	bx	lr
		...
700ad82e: 0000         	movs	r0, r0

700ad830 <UART_checkOpenParams>:
; {
700ad830: b082         	sub	sp, #0x8
700ad832: 9001         	str	r0, [sp, #0x4]
700ad834: 2000         	movs	r0, #0x0
;     int32_t     status = SystemP_SUCCESS;
700ad836: 9000         	str	r0, [sp]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->readMode) &&
700ad838: 9801         	ldr	r0, [sp, #0x4]
700ad83a: 6900         	ldr	r0, [r0, #0x10]
700ad83c: 2801         	cmp	r0, #0x1
700ad83e: d108         	bne	0x700ad852 <UART_checkOpenParams+0x22> @ imm = #0x10
700ad840: e7ff         	b	0x700ad842 <UART_checkOpenParams+0x12> @ imm = #-0x2
;        (NULL_PTR == prms->readCallbackFxn))
700ad842: 9801         	ldr	r0, [sp, #0x4]
700ad844: 69c0         	ldr	r0, [r0, #0x1c]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->readMode) &&
700ad846: b920         	cbnz	r0, 0x700ad852 <UART_checkOpenParams+0x22> @ imm = #0x8
700ad848: e7ff         	b	0x700ad84a <UART_checkOpenParams+0x1a> @ imm = #-0x2
700ad84a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700ad84e: 9000         	str	r0, [sp]
;     }
700ad850: e7ff         	b	0x700ad852 <UART_checkOpenParams+0x22> @ imm = #-0x2
;     if((UART_TRANSFER_MODE_CALLBACK == prms->writeMode) &&
700ad852: 9801         	ldr	r0, [sp, #0x4]
700ad854: 6980         	ldr	r0, [r0, #0x18]
700ad856: 2801         	cmp	r0, #0x1
700ad858: d108         	bne	0x700ad86c <UART_checkOpenParams+0x3c> @ imm = #0x10
700ad85a: e7ff         	b	0x700ad85c <UART_checkOpenParams+0x2c> @ imm = #-0x2
;        (NULL_PTR == prms->writeCallbackFxn))
700ad85c: 9801         	ldr	r0, [sp, #0x4]
700ad85e: 6a00         	ldr	r0, [r0, #0x20]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->writeMode) &&
700ad860: b920         	cbnz	r0, 0x700ad86c <UART_checkOpenParams+0x3c> @ imm = #0x8
700ad862: e7ff         	b	0x700ad864 <UART_checkOpenParams+0x34> @ imm = #-0x2
700ad864: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700ad868: 9000         	str	r0, [sp]
;     }
700ad86a: e7ff         	b	0x700ad86c <UART_checkOpenParams+0x3c> @ imm = #-0x2
;     return (status);
700ad86c: 9800         	ldr	r0, [sp]
700ad86e: b002         	add	sp, #0x8
700ad870: 4770         	bx	lr
		...
700ad87e: 0000         	movs	r0, r0

700ad880 <UdmaUtils_getRingMemSize>:
; {
700ad880: b084         	sub	sp, #0x10
700ad882: f88d 000f    	strb.w	r0, [sp, #0xf]
700ad886: 9102         	str	r1, [sp, #0x8]
700ad888: f88d 2007    	strb.w	r2, [sp, #0x7]
;     ringMemSize = ((uint32_t) 1U << (elemSize + 2U));   /* Element size in bytes */
700ad88c: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ad890: 1c81         	adds	r1, r0, #0x2
700ad892: 2001         	movs	r0, #0x1
700ad894: 4088         	lsls	r0, r1
700ad896: 9000         	str	r0, [sp]
;     ringMemSize *= elemCnt;
700ad898: 9902         	ldr	r1, [sp, #0x8]
700ad89a: 9800         	ldr	r0, [sp]
700ad89c: 4348         	muls	r0, r1, r0
700ad89e: 9000         	str	r0, [sp]
;     if((TISCI_MSG_VALUE_RM_RING_MODE_CREDENTIALS == mode) ||
700ad8a0: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ad8a4: 2802         	cmp	r0, #0x2
700ad8a6: d005         	beq	0x700ad8b4 <UdmaUtils_getRingMemSize+0x34> @ imm = #0xa
700ad8a8: e7ff         	b	0x700ad8aa <UdmaUtils_getRingMemSize+0x2a> @ imm = #-0x2
;        (TISCI_MSG_VALUE_RM_RING_MODE_QM == mode))
700ad8aa: f89d 000f    	ldrb.w	r0, [sp, #0xf]
;     if((TISCI_MSG_VALUE_RM_RING_MODE_CREDENTIALS == mode) ||
700ad8ae: 2803         	cmp	r0, #0x3
700ad8b0: d104         	bne	0x700ad8bc <UdmaUtils_getRingMemSize+0x3c> @ imm = #0x8
700ad8b2: e7ff         	b	0x700ad8b4 <UdmaUtils_getRingMemSize+0x34> @ imm = #-0x2
;         ringMemSize <<= 1U;
700ad8b4: 9800         	ldr	r0, [sp]
700ad8b6: 0040         	lsls	r0, r0, #0x1
700ad8b8: 9000         	str	r0, [sp]
;     }
700ad8ba: e7ff         	b	0x700ad8bc <UdmaUtils_getRingMemSize+0x3c> @ imm = #-0x2
;     return (ringMemSize);
700ad8bc: 9800         	ldr	r0, [sp]
700ad8be: b004         	add	sp, #0x10
700ad8c0: 4770         	bx	lr
		...
700ad8ce: 0000         	movs	r0, r0

700ad8d0 <prvCopyDataFromQueue>:
; {
700ad8d0: b580         	push	{r7, lr}
700ad8d2: b082         	sub	sp, #0x8
700ad8d4: 9001         	str	r0, [sp, #0x4]
700ad8d6: 9100         	str	r1, [sp]
;     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
700ad8d8: 9801         	ldr	r0, [sp, #0x4]
700ad8da: 6c00         	ldr	r0, [r0, #0x40]
700ad8dc: b1b8         	cbz	r0, 0x700ad90e <prvCopyDataFromQueue+0x3e> @ imm = #0x2e
700ad8de: e7ff         	b	0x700ad8e0 <prvCopyDataFromQueue+0x10> @ imm = #-0x2
;         pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
700ad8e0: 9901         	ldr	r1, [sp, #0x4]
700ad8e2: 68c8         	ldr	r0, [r1, #0xc]
700ad8e4: 6c0a         	ldr	r2, [r1, #0x40]
700ad8e6: 4410         	add	r0, r2
700ad8e8: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
700ad8ea: 9801         	ldr	r0, [sp, #0x4]
700ad8ec: 6881         	ldr	r1, [r0, #0x8]
700ad8ee: 68c0         	ldr	r0, [r0, #0xc]
700ad8f0: 4288         	cmp	r0, r1
700ad8f2: d304         	blo	0x700ad8fe <prvCopyDataFromQueue+0x2e> @ imm = #0x8
700ad8f4: e7ff         	b	0x700ad8f6 <prvCopyDataFromQueue+0x26> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
700ad8f6: 9901         	ldr	r1, [sp, #0x4]
700ad8f8: 6808         	ldr	r0, [r1]
700ad8fa: 60c8         	str	r0, [r1, #0xc]
;         }
700ad8fc: e000         	b	0x700ad900 <prvCopyDataFromQueue+0x30> @ imm = #0x0
700ad8fe: e7ff         	b	0x700ad900 <prvCopyDataFromQueue+0x30> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
700ad900: 9800         	ldr	r0, [sp]
700ad902: 9a01         	ldr	r2, [sp, #0x4]
700ad904: 68d1         	ldr	r1, [r2, #0xc]
700ad906: 6c12         	ldr	r2, [r2, #0x40]
700ad908: f7ec eba8    	blx	0x7009a05c <__aeabi_memcpy8> @ imm = #-0x138b0
;     }
700ad90c: e7ff         	b	0x700ad90e <prvCopyDataFromQueue+0x3e> @ imm = #-0x2
; }
700ad90e: b002         	add	sp, #0x8
700ad910: bd80         	pop	{r7, pc}
		...
700ad91e: 0000         	movs	r0, r0

700ad920 <CSL_lcdma_ringaccIsTeardownComplete>:
; {
700ad920: b580         	push	{r7, lr}
700ad922: b084         	sub	sp, #0x10
700ad924: 9003         	str	r0, [sp, #0xc]
700ad926: 9102         	str	r1, [sp, #0x8]
700ad928: 2000         	movs	r0, #0x0
;     bool bRetVal = (bool)false;
700ad92a: f88d 0007    	strb.w	r0, [sp, #0x7]
;     if( CSL_REG32_FEXT( &pCfg->pRingRtRegs->RING[ringNum].ROCC, LCDMA_RINGACC_RINGRT_RING_ROCC_COMP ) != (uint32_t)0U )
700ad92e: 9803         	ldr	r0, [sp, #0xc]
700ad930: 6840         	ldr	r0, [r0, #0x4]
700ad932: 9902         	ldr	r1, [sp, #0x8]
700ad934: eb00 3041    	add.w	r0, r0, r1, lsl #13
700ad938: f241 0118    	movw	r1, #0x1018
700ad93c: 4408         	add	r0, r1
700ad93e: f04f 4100    	mov.w	r1, #0x80000000
700ad942: 221f         	movs	r2, #0x1f
700ad944: f001 fa6c    	bl	0x700aee20 <CSL_REG32_FEXT_RAW> @ imm = #0x14d8
700ad948: b120         	cbz	r0, 0x700ad954 <CSL_lcdma_ringaccIsTeardownComplete+0x34> @ imm = #0x8
700ad94a: e7ff         	b	0x700ad94c <CSL_lcdma_ringaccIsTeardownComplete+0x2c> @ imm = #-0x2
700ad94c: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700ad94e: f88d 0007    	strb.w	r0, [sp, #0x7]
;     }
700ad952: e7ff         	b	0x700ad954 <CSL_lcdma_ringaccIsTeardownComplete+0x34> @ imm = #-0x2
;     return bRetVal;
700ad954: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ad958: f000 0001    	and	r0, r0, #0x1
700ad95c: b004         	add	sp, #0x10
700ad95e: bd80         	pop	{r7, pc}

700ad960 <Sciclient_rmIrqProgramOesRegister>:
; {
700ad960: b580         	push	{r7, lr}
700ad962: b088         	sub	sp, #0x20
700ad964: 9007         	str	r0, [sp, #0x1c]
700ad966: 2010         	movs	r0, #0x10
700ad968: f2c8 0000    	movt	r0, #0x8000
;     req.valid_params = (TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID |
700ad96c: 9002         	str	r0, [sp, #0x8]
;     req.secondary_host = cfg->host;
700ad96e: 9807         	ldr	r0, [sp, #0x1c]
700ad970: 7900         	ldrb	r0, [r0, #0x4]
700ad972: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     req.src_id = cfg->s_id;
700ad976: 9807         	ldr	r0, [sp, #0x1c]
700ad978: 88c0         	ldrh	r0, [r0, #0x6]
700ad97a: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     req.src_index = cfg->s_idx;
700ad97e: 9807         	ldr	r0, [sp, #0x1c]
700ad980: 8900         	ldrh	r0, [r0, #0x8]
700ad982: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     req.global_event = cfg->global_evt;
700ad986: 9807         	ldr	r0, [sp, #0x1c]
700ad988: 89c0         	ldrh	r0, [r0, #0xe]
700ad98a: f8ad 0018    	strh.w	r0, [sp, #0x18]
;                                  cfg->set_resp,
700ad98e: 9807         	ldr	r0, [sp, #0x1c]
700ad990: 6981         	ldr	r1, [r0, #0x18]
700ad992: 4668         	mov	r0, sp
700ad994: f04f 32ff    	mov.w	r2, #0xffffffff
;     return Sciclient_rmIrqSetRaw(&req,
700ad998: f7fe fe2a    	bl	0x700ac5f0 <Sciclient_rmIrqSetRaw> @ imm = #-0x13ac
700ad99c: b008         	add	sp, #0x20
700ad99e: bd80         	pop	{r7, pc}

700ad9a0 <Sciclient_rmPsGetIfIdx>:
; {
700ad9a0: b082         	sub	sp, #0x8
700ad9a2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ad9a6: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700ad9aa: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ad9ac: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ad9b0: f241 0158    	movw	r1, #0x1058
700ad9b4: f2c7 0108    	movt	r1, #0x7008
700ad9b8: 8c89         	ldrh	r1, [r1, #0x24]
700ad9ba: 4288         	cmp	r0, r1
700ad9bc: da0d         	bge	0x700ad9da <Sciclient_rmPsGetIfIdx+0x3a> @ imm = #0x1a
700ad9be: e7ff         	b	0x700ad9c0 <Sciclient_rmPsGetIfIdx+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].if_idx;
700ad9c0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ad9c4: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ad9c8: f241 0058    	movw	r0, #0x1058
700ad9cc: f2c7 0008    	movt	r0, #0x7008
700ad9d0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ad9d4: 8880         	ldrh	r0, [r0, #0x4]
700ad9d6: 9000         	str	r0, [sp]
;     }
700ad9d8: e7ff         	b	0x700ad9da <Sciclient_rmPsGetIfIdx+0x3a> @ imm = #-0x2
;     return r;
700ad9da: 9800         	ldr	r0, [sp]
700ad9dc: b002         	add	sp, #0x8
700ad9de: 4770         	bx	lr

700ad9e0 <Sciclient_rmPsGetInp>:
; {
700ad9e0: b082         	sub	sp, #0x8
700ad9e2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ad9e6: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700ad9ea: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ad9ec: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ad9f0: f241 0158    	movw	r1, #0x1058
700ad9f4: f2c7 0108    	movt	r1, #0x7008
700ad9f8: 8c89         	ldrh	r1, [r1, #0x24]
700ad9fa: 4288         	cmp	r0, r1
700ad9fc: da0d         	bge	0x700ada1a <Sciclient_rmPsGetInp+0x3a> @ imm = #0x1a
700ad9fe: e7ff         	b	0x700ada00 <Sciclient_rmPsGetInp+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].inp;
700ada00: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ada04: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ada08: f241 0058    	movw	r0, #0x1058
700ada0c: f2c7 0008    	movt	r0, #0x7008
700ada10: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ada14: 88c0         	ldrh	r0, [r0, #0x6]
700ada16: 9000         	str	r0, [sp]
;     }
700ada18: e7ff         	b	0x700ada1a <Sciclient_rmPsGetInp+0x3a> @ imm = #-0x2
;     return r;
700ada1a: 9800         	ldr	r0, [sp]
700ada1c: b002         	add	sp, #0x8
700ada1e: 4770         	bx	lr

700ada20 <Sciclient_rmPsGetOutp>:
; {
700ada20: b082         	sub	sp, #0x8
700ada22: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ada26: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700ada2a: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ada2c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ada30: f241 0158    	movw	r1, #0x1058
700ada34: f2c7 0108    	movt	r1, #0x7008
700ada38: 8c89         	ldrh	r1, [r1, #0x24]
700ada3a: 4288         	cmp	r0, r1
700ada3c: da0d         	bge	0x700ada5a <Sciclient_rmPsGetOutp+0x3a> @ imm = #0x1a
700ada3e: e7ff         	b	0x700ada40 <Sciclient_rmPsGetOutp+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].outp;
700ada40: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ada44: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ada48: f241 0058    	movw	r0, #0x1058
700ada4c: f2c7 0008    	movt	r0, #0x7008
700ada50: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ada54: 8900         	ldrh	r0, [r0, #0x8]
700ada56: 9000         	str	r0, [sp]
;     }
700ada58: e7ff         	b	0x700ada5a <Sciclient_rmPsGetOutp+0x3a> @ imm = #-0x2
;     return r;
700ada5a: 9800         	ldr	r0, [sp]
700ada5c: b002         	add	sp, #0x8
700ada5e: 4770         	bx	lr

700ada60 <free_list_insert>:
700ada60: e5902000     	ldr	r2, [r0]
700ada64: e59f1030     	ldr	r1, [pc, #0x30]         @ 0x700ada9c <free_list_insert+0x3c>
700ada68: e3c2c001     	bic	r12, r2, #1
700ada6c: e5913000     	ldr	r3, [r1]
700ada70: e3530000     	cmp	r3, #0
700ada74: 0a000005     	beq	0x700ada90 <free_list_insert+0x30> @ imm = #0x14
700ada78: e5932000     	ldr	r2, [r3]
700ada7c: e3c22001     	bic	r2, r2, #1
700ada80: e152000c     	cmp	r2, r12
700ada84: 2a000001     	bhs	0x700ada90 <free_list_insert+0x30> @ imm = #0x4
700ada88: e2831008     	add	r1, r3, #8
700ada8c: eafffff6     	b	0x700ada6c <free_list_insert+0xc> @ imm = #-0x28
700ada90: e5803008     	str	r3, [r0, #0x8]
700ada94: e5810000     	str	r0, [r1]
700ada98: e12fff1e     	bx	lr
700ada9c: 2c 52 08 70  	.word	0x7008522c

700adaa0 <prvGetNextExpireTime>:
;     {
700adaa0: b082         	sub	sp, #0x8
700adaa2: 9001         	str	r0, [sp, #0x4]
;         *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
700adaa4: f245 201c    	movw	r0, #0x521c
700adaa8: f2c7 0008    	movt	r0, #0x7008
700adaac: 6800         	ldr	r0, [r0]
700adaae: 6800         	ldr	r0, [r0]
700adab0: fab0 f080    	clz	r0, r0
700adab4: 0940         	lsrs	r0, r0, #0x5
700adab6: 9901         	ldr	r1, [sp, #0x4]
700adab8: 6008         	str	r0, [r1]
;         if( *pxListWasEmpty == pdFALSE )
700adaba: 9801         	ldr	r0, [sp, #0x4]
700adabc: 6800         	ldr	r0, [r0]
700adabe: b948         	cbnz	r0, 0x700adad4 <prvGetNextExpireTime+0x34> @ imm = #0x12
700adac0: e7ff         	b	0x700adac2 <prvGetNextExpireTime+0x22> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
700adac2: f245 201c    	movw	r0, #0x521c
700adac6: f2c7 0008    	movt	r0, #0x7008
700adaca: 6800         	ldr	r0, [r0]
700adacc: 68c0         	ldr	r0, [r0, #0xc]
700adace: 6800         	ldr	r0, [r0]
700adad0: 9000         	str	r0, [sp]
;         }
700adad2: e002         	b	0x700adada <prvGetNextExpireTime+0x3a> @ imm = #0x4
700adad4: 2000         	movs	r0, #0x0
;             xNextExpireTime = ( TickType_t ) 0U;
700adad6: 9000         	str	r0, [sp]
700adad8: e7ff         	b	0x700adada <prvGetNextExpireTime+0x3a> @ imm = #-0x2
;         return xNextExpireTime;
700adada: 9800         	ldr	r0, [sp]
700adadc: b002         	add	sp, #0x8
700adade: 4770         	bx	lr

700adae0 <Sciclient_secProxyWaitThread>:
; {
700adae0: b580         	push	{r7, lr}
700adae2: b084         	sub	sp, #0x10
700adae4: 9003         	str	r0, [sp, #0xc]
700adae6: 9102         	str	r1, [sp, #0x8]
700adae8: f06f 0003    	mvn	r0, #0x3
;     int32_t  status     = CSL_ETIMEOUT;
700adaec: 9001         	str	r0, [sp, #0x4]
;     uint32_t timeToWait = timeout;
700adaee: 9802         	ldr	r0, [sp, #0x8]
700adaf0: 9000         	str	r0, [sp]
;     while (timeToWait > 0U)
700adaf2: e7ff         	b	0x700adaf4 <Sciclient_secProxyWaitThread+0x14> @ imm = #-0x2
700adaf4: 9800         	ldr	r0, [sp]
700adaf6: b178         	cbz	r0, 0x700adb18 <Sciclient_secProxyWaitThread+0x38> @ imm = #0x1e
700adaf8: e7ff         	b	0x700adafa <Sciclient_secProxyWaitThread+0x1a> @ imm = #-0x2
;         if ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700adafa: 9803         	ldr	r0, [sp, #0xc]
700adafc: f001 fc68    	bl	0x700af3d0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x18d0
700adb00: f001 ff0e    	bl	0x700af920 <CSL_REG32_RD_RAW> @ imm = #0x1e1c
700adb04: 0600         	lsls	r0, r0, #0x18
700adb06: b118         	cbz	r0, 0x700adb10 <Sciclient_secProxyWaitThread+0x30> @ imm = #0x6
700adb08: e7ff         	b	0x700adb0a <Sciclient_secProxyWaitThread+0x2a> @ imm = #-0x2
700adb0a: 2000         	movs	r0, #0x0
;             status = SystemP_SUCCESS;
700adb0c: 9001         	str	r0, [sp, #0x4]
;             break;
700adb0e: e003         	b	0x700adb18 <Sciclient_secProxyWaitThread+0x38> @ imm = #0x6
;         timeToWait--;
700adb10: 9800         	ldr	r0, [sp]
700adb12: 3801         	subs	r0, #0x1
700adb14: 9000         	str	r0, [sp]
;     while (timeToWait > 0U)
700adb16: e7ed         	b	0x700adaf4 <Sciclient_secProxyWaitThread+0x14> @ imm = #-0x26
;     return status;
700adb18: 9801         	ldr	r0, [sp, #0x4]
700adb1a: b004         	add	sp, #0x10
700adb1c: bd80         	pop	{r7, pc}
700adb1e: 0000         	movs	r0, r0

700adb20 <UART_IsHWFlowCtrlValid>:
; {
700adb20: b082         	sub	sp, #0x8
700adb22: 9001         	str	r0, [sp, #0x4]
700adb24: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700adb28: 9000         	str	r0, [sp]
;     if(((hwFlowControlThr == UART_RXTRIGLVL_1)  ||
700adb2a: 9801         	ldr	r0, [sp, #0x4]
700adb2c: 2801         	cmp	r0, #0x1
700adb2e: d010         	beq	0x700adb52 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x20
700adb30: e7ff         	b	0x700adb32 <UART_IsHWFlowCtrlValid+0x12> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_8)  ||
700adb32: 9801         	ldr	r0, [sp, #0x4]
700adb34: 2808         	cmp	r0, #0x8
700adb36: d00c         	beq	0x700adb52 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x18
700adb38: e7ff         	b	0x700adb3a <UART_IsHWFlowCtrlValid+0x1a> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_16) ||
700adb3a: 9801         	ldr	r0, [sp, #0x4]
700adb3c: 2810         	cmp	r0, #0x10
700adb3e: d008         	beq	0x700adb52 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x10
700adb40: e7ff         	b	0x700adb42 <UART_IsHWFlowCtrlValid+0x22> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_56) ||
700adb42: 9801         	ldr	r0, [sp, #0x4]
700adb44: 2838         	cmp	r0, #0x38
700adb46: d004         	beq	0x700adb52 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x8
700adb48: e7ff         	b	0x700adb4a <UART_IsHWFlowCtrlValid+0x2a> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_60)))
700adb4a: 9801         	ldr	r0, [sp, #0x4]
;     if(((hwFlowControlThr == UART_RXTRIGLVL_1)  ||
700adb4c: 283c         	cmp	r0, #0x3c
700adb4e: d103         	bne	0x700adb58 <UART_IsHWFlowCtrlValid+0x38> @ imm = #0x6
700adb50: e7ff         	b	0x700adb52 <UART_IsHWFlowCtrlValid+0x32> @ imm = #-0x2
700adb52: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700adb54: 9000         	str	r0, [sp]
;     }
700adb56: e7ff         	b	0x700adb58 <UART_IsHWFlowCtrlValid+0x38> @ imm = #-0x2
;     return status;
700adb58: 9800         	ldr	r0, [sp]
700adb5a: b002         	add	sp, #0x8
700adb5c: 4770         	bx	lr
700adb5e: 0000         	movs	r0, r0

700adb60 <UART_IsRxTrigLvlValid>:
; {
700adb60: b082         	sub	sp, #0x8
700adb62: 9001         	str	r0, [sp, #0x4]
700adb64: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700adb68: 9000         	str	r0, [sp]
;     if(((rxTrigLvl == UART_RXTRIGLVL_1)  ||
700adb6a: 9801         	ldr	r0, [sp, #0x4]
700adb6c: 2801         	cmp	r0, #0x1
700adb6e: d010         	beq	0x700adb92 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x20
700adb70: e7ff         	b	0x700adb72 <UART_IsRxTrigLvlValid+0x12> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_8)  ||
700adb72: 9801         	ldr	r0, [sp, #0x4]
700adb74: 2808         	cmp	r0, #0x8
700adb76: d00c         	beq	0x700adb92 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x18
700adb78: e7ff         	b	0x700adb7a <UART_IsRxTrigLvlValid+0x1a> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_16) ||
700adb7a: 9801         	ldr	r0, [sp, #0x4]
700adb7c: 2810         	cmp	r0, #0x10
700adb7e: d008         	beq	0x700adb92 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x10
700adb80: e7ff         	b	0x700adb82 <UART_IsRxTrigLvlValid+0x22> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_56) ||
700adb82: 9801         	ldr	r0, [sp, #0x4]
700adb84: 2838         	cmp	r0, #0x38
700adb86: d004         	beq	0x700adb92 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x8
700adb88: e7ff         	b	0x700adb8a <UART_IsRxTrigLvlValid+0x2a> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_60)))
700adb8a: 9801         	ldr	r0, [sp, #0x4]
;     if(((rxTrigLvl == UART_RXTRIGLVL_1)  ||
700adb8c: 283c         	cmp	r0, #0x3c
700adb8e: d103         	bne	0x700adb98 <UART_IsRxTrigLvlValid+0x38> @ imm = #0x6
700adb90: e7ff         	b	0x700adb92 <UART_IsRxTrigLvlValid+0x32> @ imm = #-0x2
700adb92: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700adb94: 9000         	str	r0, [sp]
;     }
700adb96: e7ff         	b	0x700adb98 <UART_IsRxTrigLvlValid+0x38> @ imm = #-0x2
;     return status;
700adb98: 9800         	ldr	r0, [sp]
700adb9a: b002         	add	sp, #0x8
700adb9c: 4770         	bx	lr
700adb9e: 0000         	movs	r0, r0

700adba0 <UART_IsTxTrigLvlValid>:
; {
700adba0: b082         	sub	sp, #0x8
700adba2: 9001         	str	r0, [sp, #0x4]
700adba4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700adba8: 9000         	str	r0, [sp]
;     if(((txTrigLvl == UART_TXTRIGLVL_1)  ||
700adbaa: 9801         	ldr	r0, [sp, #0x4]
700adbac: 2801         	cmp	r0, #0x1
700adbae: d010         	beq	0x700adbd2 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x20
700adbb0: e7ff         	b	0x700adbb2 <UART_IsTxTrigLvlValid+0x12> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_8)  ||
700adbb2: 9801         	ldr	r0, [sp, #0x4]
700adbb4: 2808         	cmp	r0, #0x8
700adbb6: d00c         	beq	0x700adbd2 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x18
700adbb8: e7ff         	b	0x700adbba <UART_IsTxTrigLvlValid+0x1a> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_16) ||
700adbba: 9801         	ldr	r0, [sp, #0x4]
700adbbc: 2810         	cmp	r0, #0x10
700adbbe: d008         	beq	0x700adbd2 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x10
700adbc0: e7ff         	b	0x700adbc2 <UART_IsTxTrigLvlValid+0x22> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_32) ||
700adbc2: 9801         	ldr	r0, [sp, #0x4]
700adbc4: 2820         	cmp	r0, #0x20
700adbc6: d004         	beq	0x700adbd2 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x8
700adbc8: e7ff         	b	0x700adbca <UART_IsTxTrigLvlValid+0x2a> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_56)))
700adbca: 9801         	ldr	r0, [sp, #0x4]
;     if(((txTrigLvl == UART_TXTRIGLVL_1)  ||
700adbcc: 2838         	cmp	r0, #0x38
700adbce: d103         	bne	0x700adbd8 <UART_IsTxTrigLvlValid+0x38> @ imm = #0x6
700adbd0: e7ff         	b	0x700adbd2 <UART_IsTxTrigLvlValid+0x32> @ imm = #-0x2
700adbd2: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700adbd4: 9000         	str	r0, [sp]
;     }
700adbd6: e7ff         	b	0x700adbd8 <UART_IsTxTrigLvlValid+0x38> @ imm = #-0x2
;     return status;
700adbd8: 9800         	ldr	r0, [sp]
700adbda: b002         	add	sp, #0x8
700adbdc: 4770         	bx	lr
700adbde: 0000         	movs	r0, r0

700adbe0 <UART_i2310WA>:
; {
700adbe0: b580         	push	{r7, lr}
700adbe2: b084         	sub	sp, #0x10
700adbe4: 9003         	str	r0, [sp, #0xc]
;     HW_WR_REG32(baseAddr + UART_TIMEOUTL, 0xFF);
700adbe6: 9803         	ldr	r0, [sp, #0xc]
700adbe8: 3098         	adds	r0, #0x98
700adbea: 21ff         	movs	r1, #0xff
700adbec: 9101         	str	r1, [sp, #0x4]
700adbee: f001 fe3f    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x1c7e
700adbf2: 9901         	ldr	r1, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_TIMEOUTH, 0xFF);
700adbf4: 9803         	ldr	r0, [sp, #0xc]
700adbf6: 309c         	adds	r0, #0x9c
700adbf8: f001 fe3a    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x1c74
;     HW_WR_FIELD32(baseAddr + UART_EFR2, UART_EFR2_TIMEOUT_BEHAVE, 1);
700adbfc: 9803         	ldr	r0, [sp, #0xc]
700adbfe: 308c         	adds	r0, #0x8c
700adc00: 2206         	movs	r2, #0x6
700adc02: 9202         	str	r2, [sp, #0x8]
700adc04: 2301         	movs	r3, #0x1
700adc06: 4611         	mov	r1, r2
700adc08: f000 fc02    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x804
700adc0c: 9a02         	ldr	r2, [sp, #0x8]
;     HW_WR_FIELD32(baseAddr + UART_EFR2, UART_EFR2_TIMEOUT_BEHAVE, 0);
700adc0e: 9803         	ldr	r0, [sp, #0xc]
700adc10: 308c         	adds	r0, #0x8c
700adc12: 2300         	movs	r3, #0x0
700adc14: 4611         	mov	r1, r2
700adc16: f000 fbfb    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x7f6
; }
700adc1a: b004         	add	sp, #0x10
700adc1c: bd80         	pop	{r7, pc}
700adc1e: 0000         	movs	r0, r0

700adc20 <UART_spaceAvail>:
; {
700adc20: b580         	push	{r7, lr}
700adc22: b084         	sub	sp, #0x10
700adc24: 9003         	str	r0, [sp, #0xc]
700adc26: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700adc28: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700adc2a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700adc2c: 9803         	ldr	r0, [sp, #0xc]
700adc2e: 217f         	movs	r1, #0x7f
700adc30: f7fe fc7e    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #-0x1704
700adc34: 9002         	str	r0, [sp, #0x8]
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700adc36: 9803         	ldr	r0, [sp, #0xc]
700adc38: 3014         	adds	r0, #0x14
700adc3a: f001 fe11    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x1c22
700adc3e: f000 0060    	and	r0, r0, #0x60
;     if ((UART_LSR_TX_SR_E_MASK | UART_LSR_TX_FIFO_E_MASK) ==
700adc42: 2860         	cmp	r0, #0x60
700adc44: d103         	bne	0x700adc4e <UART_spaceAvail+0x2e> @ imm = #0x6
700adc46: e7ff         	b	0x700adc48 <UART_spaceAvail+0x28> @ imm = #-0x2
700adc48: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700adc4a: 9001         	str	r0, [sp, #0x4]
;     }
700adc4c: e7ff         	b	0x700adc4e <UART_spaceAvail+0x2e> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700adc4e: 9803         	ldr	r0, [sp, #0xc]
700adc50: 300c         	adds	r0, #0xc
700adc52: 9902         	ldr	r1, [sp, #0x8]
700adc54: f001 fe0c    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x1c18
;     return retVal;
700adc58: 9801         	ldr	r0, [sp, #0x4]
700adc5a: b004         	add	sp, #0x10
700adc5c: bd80         	pop	{r7, pc}
700adc5e: 0000         	movs	r0, r0

700adc60 <CSL_bcdmaSetChanPeerReg>:
; {
700adc60: b580         	push	{r7, lr}
700adc62: b088         	sub	sp, #0x20
700adc64: f8dd c028    	ldr.w	r12, [sp, #0x28]
700adc68: 9007         	str	r0, [sp, #0x1c]
700adc6a: 9106         	str	r1, [sp, #0x18]
700adc6c: 9205         	str	r2, [sp, #0x14]
700adc6e: 9304         	str	r3, [sp, #0x10]
;     remotePeerOpts.regIdx = regIdx;
700adc70: 9804         	ldr	r0, [sp, #0x10]
700adc72: 9001         	str	r0, [sp, #0x4]
;     remotePeerOpts.regVal = *pVal;
700adc74: 980a         	ldr	r0, [sp, #0x28]
700adc76: 6800         	ldr	r0, [r0]
700adc78: 9002         	str	r0, [sp, #0x8]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_REMOTE_PEER_REG, chanIdx, (void *)&remotePeerOpts );
700adc7a: 9807         	ldr	r0, [sp, #0x1c]
700adc7c: 9a06         	ldr	r2, [sp, #0x18]
700adc7e: 210c         	movs	r1, #0xc
700adc80: ab01         	add	r3, sp, #0x4
700adc82: f7fd f855    	bl	0x700aad30 <CSL_bcdmaDoChanOp> @ imm = #-0x2f56
700adc86: 9003         	str	r0, [sp, #0xc]
;     if( retVal != CSL_PASS )
700adc88: 9803         	ldr	r0, [sp, #0xc]
700adc8a: b120         	cbz	r0, 0x700adc96 <CSL_bcdmaSetChanPeerReg+0x36> @ imm = #0x8
700adc8c: e7ff         	b	0x700adc8e <CSL_bcdmaSetChanPeerReg+0x2e> @ imm = #-0x2
700adc8e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700adc92: 9003         	str	r0, [sp, #0xc]
;     }
700adc94: e7ff         	b	0x700adc96 <CSL_bcdmaSetChanPeerReg+0x36> @ imm = #-0x2
;     return retVal;
700adc96: 9803         	ldr	r0, [sp, #0xc]
700adc98: b008         	add	sp, #0x20
700adc9a: bd80         	pop	{r7, pc}
700adc9c: 0000         	movs	r0, r0
700adc9e: 0000         	movs	r0, r0

700adca0 <CSL_intaggrIsValidStatusBitNum>:
; {
700adca0: b084         	sub	sp, #0x10
700adca2: 9003         	str	r0, [sp, #0xc]
700adca4: 9102         	str	r1, [sp, #0x8]
;     uint32_t localStatusBitNum = statusBitNum;
700adca6: 9802         	ldr	r0, [sp, #0x8]
700adca8: 9000         	str	r0, [sp]
;     localStatusBitNum &= ~CSL_INTAGGR_INTR_MODE_FLAG;   /* Remove intr mode flag */
700adcaa: 9800         	ldr	r0, [sp]
700adcac: f020 4000    	bic	r0, r0, #0x80000000
700adcb0: 9000         	str	r0, [sp]
;     if( localStatusBitNum < (pCfg->virtIntrCnt << 6U) )
700adcb2: 9800         	ldr	r0, [sp]
700adcb4: 9903         	ldr	r1, [sp, #0xc]
700adcb6: 6a49         	ldr	r1, [r1, #0x24]
700adcb8: ebb0 1f81    	cmp.w	r0, r1, lsl #6
700adcbc: d204         	bhs	0x700adcc8 <CSL_intaggrIsValidStatusBitNum+0x28> @ imm = #0x8
700adcbe: e7ff         	b	0x700adcc0 <CSL_intaggrIsValidStatusBitNum+0x20> @ imm = #-0x2
700adcc0: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700adcc2: f88d 0007    	strb.w	r0, [sp, #0x7]
;     }
700adcc6: e003         	b	0x700adcd0 <CSL_intaggrIsValidStatusBitNum+0x30> @ imm = #0x6
700adcc8: 2000         	movs	r0, #0x0
;         bRetVal = (bool)false;
700adcca: f88d 0007    	strb.w	r0, [sp, #0x7]
700adcce: e7ff         	b	0x700adcd0 <CSL_intaggrIsValidStatusBitNum+0x30> @ imm = #-0x2
;     return bRetVal;
700adcd0: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700adcd4: f000 0001    	and	r0, r0, #0x1
700adcd8: b004         	add	sp, #0x10
700adcda: 4770         	bx	lr
700adcdc: 0000         	movs	r0, r0
700adcde: 0000         	movs	r0, r0

700adce0 <CSL_pktdmaSetRxRT>:
; {
700adce0: b580         	push	{r7, lr}
700adce2: b084         	sub	sp, #0x10
700adce4: 9003         	str	r0, [sp, #0xc]
700adce6: 9102         	str	r1, [sp, #0x8]
700adce8: 9201         	str	r2, [sp, #0x4]
;     CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL,
700adcea: 9803         	ldr	r0, [sp, #0xc]
700adcec: 6940         	ldr	r0, [r0, #0x14]
700adcee: 9902         	ldr	r1, [sp, #0x8]
700adcf0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700adcf4: 9901         	ldr	r1, [sp, #0x4]
700adcf6: 680b         	ldr	r3, [r1]
700adcf8: f8d1 c004    	ldr.w	r12, [r1, #0x4]
700adcfc: 688a         	ldr	r2, [r1, #0x8]
700adcfe: f04f 4180    	mov.w	r1, #0x40000000
700add02: ea01 718c    	and.w	r1, r1, r12, lsl #30
700add06: ea41 71c3    	orr.w	r1, r1, r3, lsl #31
700add0a: f002 0201    	and	r2, r2, #0x1
700add0e: ea41 7142    	orr.w	r1, r1, r2, lsl #29
700add12: f001 fd55    	bl	0x700af7c0 <CSL_REG32_WR_RAW> @ imm = #0x1aaa
700add16: 2000         	movs	r0, #0x0
;     return CSL_PASS;
700add18: b004         	add	sp, #0x10
700add1a: bd80         	pop	{r7, pc}
700add1c: 0000         	movs	r0, r0
700add1e: 0000         	movs	r0, r0

700add20 <CSL_pktdmaSetTxRT>:
; {
700add20: b580         	push	{r7, lr}
700add22: b084         	sub	sp, #0x10
700add24: 9003         	str	r0, [sp, #0xc]
700add26: 9102         	str	r1, [sp, #0x8]
700add28: 9201         	str	r2, [sp, #0x4]
;     CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL,
700add2a: 9803         	ldr	r0, [sp, #0xc]
700add2c: 6900         	ldr	r0, [r0, #0x10]
700add2e: 9902         	ldr	r1, [sp, #0x8]
700add30: eb00 3001    	add.w	r0, r0, r1, lsl #12
700add34: 9901         	ldr	r1, [sp, #0x4]
700add36: 680b         	ldr	r3, [r1]
700add38: f8d1 c004    	ldr.w	r12, [r1, #0x4]
700add3c: 688a         	ldr	r2, [r1, #0x8]
700add3e: f04f 4180    	mov.w	r1, #0x40000000
700add42: ea01 718c    	and.w	r1, r1, r12, lsl #30
700add46: ea41 71c3    	orr.w	r1, r1, r3, lsl #31
700add4a: f002 0201    	and	r2, r2, #0x1
700add4e: ea41 7142    	orr.w	r1, r1, r2, lsl #29
700add52: f001 fd35    	bl	0x700af7c0 <CSL_REG32_WR_RAW> @ imm = #0x1a6a
700add56: 2000         	movs	r0, #0x0
;     return CSL_PASS;
700add58: b004         	add	sp, #0x10
700add5a: bd80         	pop	{r7, pc}
700add5c: 0000         	movs	r0, r0
700add5e: 0000         	movs	r0, r0

700add60 <Sciclient_rmIrqClearOesRegister>:
; {
700add60: b580         	push	{r7, lr}
700add62: b088         	sub	sp, #0x20
700add64: 9007         	str	r0, [sp, #0x1c]
700add66: 2010         	movs	r0, #0x10
700add68: f2c8 0000    	movt	r0, #0x8000
;     req.valid_params = (TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID |
700add6c: 9002         	str	r0, [sp, #0x8]
;     req.secondary_host = cfg->host;
700add6e: 9807         	ldr	r0, [sp, #0x1c]
700add70: 7900         	ldrb	r0, [r0, #0x4]
700add72: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     req.src_id = cfg->s_id;
700add76: 9807         	ldr	r0, [sp, #0x1c]
700add78: 88c0         	ldrh	r0, [r0, #0x6]
700add7a: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     req.src_index = cfg->s_idx;
700add7e: 9807         	ldr	r0, [sp, #0x1c]
700add80: 8900         	ldrh	r0, [r0, #0x8]
700add82: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     req.global_event = cfg->global_evt;
700add86: 9807         	ldr	r0, [sp, #0x1c]
700add88: 89c0         	ldrh	r0, [r0, #0xe]
700add8a: f8ad 0018    	strh.w	r0, [sp, #0x18]
700add8e: 4668         	mov	r0, sp
700add90: f04f 31ff    	mov.w	r1, #0xffffffff
;     return Sciclient_rmIrqReleaseRaw(&req,
700add94: f7fe fdd4    	bl	0x700ac940 <Sciclient_rmIrqReleaseRaw> @ imm = #-0x1458
700add98: b008         	add	sp, #0x20
700add9a: bd80         	pop	{r7, pc}
700add9c: 0000         	movs	r0, r0
700add9e: 0000         	movs	r0, r0

700adda0 <UART_IsParityTypeValid>:
; {
700adda0: b082         	sub	sp, #0x8
700adda2: 9001         	str	r0, [sp, #0x4]
700adda4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700adda8: 9000         	str	r0, [sp]
;     if(((parityType == UART_PARITY_NONE)    ||
700addaa: 9801         	ldr	r0, [sp, #0x4]
700addac: b180         	cbz	r0, 0x700addd0 <UART_IsParityTypeValid+0x30> @ imm = #0x20
700addae: e7ff         	b	0x700addb0 <UART_IsParityTypeValid+0x10> @ imm = #-0x2
;         (parityType == UART_PARITY_ODD)     ||
700addb0: 9801         	ldr	r0, [sp, #0x4]
700addb2: 2801         	cmp	r0, #0x1
700addb4: d00c         	beq	0x700addd0 <UART_IsParityTypeValid+0x30> @ imm = #0x18
700addb6: e7ff         	b	0x700addb8 <UART_IsParityTypeValid+0x18> @ imm = #-0x2
;         (parityType == UART_PARITY_EVEN)    ||
700addb8: 9801         	ldr	r0, [sp, #0x4]
700addba: 2803         	cmp	r0, #0x3
700addbc: d008         	beq	0x700addd0 <UART_IsParityTypeValid+0x30> @ imm = #0x10
700addbe: e7ff         	b	0x700addc0 <UART_IsParityTypeValid+0x20> @ imm = #-0x2
;         (parityType == UART_PARITY_FORCED0) ||
700addc0: 9801         	ldr	r0, [sp, #0x4]
700addc2: 2807         	cmp	r0, #0x7
700addc4: d004         	beq	0x700addd0 <UART_IsParityTypeValid+0x30> @ imm = #0x8
700addc6: e7ff         	b	0x700addc8 <UART_IsParityTypeValid+0x28> @ imm = #-0x2
;         (parityType == UART_PARITY_FORCED1)))
700addc8: 9801         	ldr	r0, [sp, #0x4]
;     if(((parityType == UART_PARITY_NONE)    ||
700addca: 2805         	cmp	r0, #0x5
700addcc: d103         	bne	0x700addd6 <UART_IsParityTypeValid+0x36> @ imm = #0x6
700addce: e7ff         	b	0x700addd0 <UART_IsParityTypeValid+0x30> @ imm = #-0x2
700addd0: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700addd2: 9000         	str	r0, [sp]
;     }
700addd4: e7ff         	b	0x700addd6 <UART_IsParityTypeValid+0x36> @ imm = #-0x2
;     return status;
700addd6: 9800         	ldr	r0, [sp]
700addd8: b002         	add	sp, #0x8
700addda: 4770         	bx	lr
700adddc: 0000         	movs	r0, r0
700addde: 0000         	movs	r0, r0

700adde0 <UART_IsTxRxFifoEmpty>:
; {
700adde0: b580         	push	{r7, lr}
700adde2: b084         	sub	sp, #0x10
700adde4: 9003         	str	r0, [sp, #0xc]
700adde6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700adde8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700addea: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700addec: 9803         	ldr	r0, [sp, #0xc]
700addee: 217f         	movs	r1, #0x7f
700addf0: f7fe fb9e    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #-0x18c4
700addf4: 9002         	str	r0, [sp, #0x8]
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700addf6: 9803         	ldr	r0, [sp, #0xc]
700addf8: 3014         	adds	r0, #0x14
700addfa: f001 fd31    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x1a62
;     if (((UART_LSR_TX_FIFO_E_TX_FIFO_E_VALUE_1 << UART_LSR_TX_FIFO_E_SHIFT) |
700addfe: 0680         	lsls	r0, r0, #0x1a
700ade00: 2800         	cmp	r0, #0x0
700ade02: d503         	bpl	0x700ade0c <UART_IsTxRxFifoEmpty+0x2c> @ imm = #0x6
700ade04: e7ff         	b	0x700ade06 <UART_IsTxRxFifoEmpty+0x26> @ imm = #-0x2
700ade06: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700ade08: 9001         	str	r0, [sp, #0x4]
;     }
700ade0a: e7ff         	b	0x700ade0c <UART_IsTxRxFifoEmpty+0x2c> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ade0c: 9803         	ldr	r0, [sp, #0xc]
700ade0e: 300c         	adds	r0, #0xc
700ade10: 9902         	ldr	r1, [sp, #0x8]
700ade12: f001 fd2d    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x1a5a
;     return retVal;
700ade16: 9801         	ldr	r0, [sp, #0x4]
700ade18: b004         	add	sp, #0x10
700ade1a: bd80         	pop	{r7, pc}
700ade1c: 0000         	movs	r0, r0
700ade1e: 0000         	movs	r0, r0

700ade20 <UART_enhanFuncEnable>:
; {
700ade20: b580         	push	{r7, lr}
700ade22: b084         	sub	sp, #0x10
700ade24: 9003         	str	r0, [sp, #0xc]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ade26: 9803         	ldr	r0, [sp, #0xc]
700ade28: 21bf         	movs	r1, #0xbf
700ade2a: f7fe fb81    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #-0x18fe
700ade2e: 9001         	str	r0, [sp, #0x4]
;     enhanFnBitVal = HW_RD_REG32(baseAddr + UART_EFR) & UART_EFR_ENHANCED_EN_MASK;
700ade30: 9803         	ldr	r0, [sp, #0xc]
700ade32: 3008         	adds	r0, #0x8
700ade34: f001 fd14    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x1a28
700ade38: f000 0010    	and	r0, r0, #0x10
700ade3c: 9002         	str	r0, [sp, #0x8]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700ade3e: 9803         	ldr	r0, [sp, #0xc]
700ade40: 3008         	adds	r0, #0x8
700ade42: 2110         	movs	r1, #0x10
700ade44: 2204         	movs	r2, #0x4
700ade46: 2301         	movs	r3, #0x1
700ade48: f000 fae2    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #0x5c4
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ade4c: 9803         	ldr	r0, [sp, #0xc]
700ade4e: 300c         	adds	r0, #0xc
700ade50: 9901         	ldr	r1, [sp, #0x4]
700ade52: f001 fd0d    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x1a1a
;     return enhanFnBitVal;
700ade56: 9802         	ldr	r0, [sp, #0x8]
700ade58: b004         	add	sp, #0x10
700ade5a: bd80         	pop	{r7, pc}
700ade5c: 0000         	movs	r0, r0
700ade5e: 0000         	movs	r0, r0

700ade60 <UART_lld_dmaDeInit>:
; {
700ade60: b580         	push	{r7, lr}
700ade62: b084         	sub	sp, #0x10
700ade64: 9003         	str	r0, [sp, #0xc]
700ade66: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700ade68: 9002         	str	r0, [sp, #0x8]
;     udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700ade6a: 9803         	ldr	r0, [sp, #0xc]
700ade6c: 6840         	ldr	r0, [r0, #0x4]
700ade6e: 6cc0         	ldr	r0, [r0, #0x4c]
700ade70: 9001         	str	r0, [sp, #0x4]
;     if (udmaChCfg->isOpen != FALSE)
700ade72: 9801         	ldr	r0, [sp, #0x4]
700ade74: 6b80         	ldr	r0, [r0, #0x38]
700ade76: b170         	cbz	r0, 0x700ade96 <UART_lld_dmaDeInit+0x36> @ imm = #0x1c
700ade78: e7ff         	b	0x700ade7a <UART_lld_dmaDeInit+0x1a> @ imm = #-0x2
;         (void)UART_udmaDeInitCh(udmaChCfg->rxChHandle,
700ade7a: 9901         	ldr	r1, [sp, #0x4]
700ade7c: 6888         	ldr	r0, [r1, #0x8]
;                           udmaChCfg->cqRxEvtHandle);
700ade7e: 6909         	ldr	r1, [r1, #0x10]
;         (void)UART_udmaDeInitCh(udmaChCfg->rxChHandle,
700ade80: f7f8 fbee    	bl	0x700a6660 <UART_udmaDeInitCh> @ imm = #-0x7824
;         (void)UART_udmaDeInitCh(udmaChCfg->txChHandle,
700ade84: 9901         	ldr	r1, [sp, #0x4]
700ade86: 6848         	ldr	r0, [r1, #0x4]
;                           udmaChCfg->cqTxEvtHandle);
700ade88: 68c9         	ldr	r1, [r1, #0xc]
;         (void)UART_udmaDeInitCh(udmaChCfg->txChHandle,
700ade8a: f7f8 fbe9    	bl	0x700a6660 <UART_udmaDeInitCh> @ imm = #-0x782e
;         udmaChCfg->isOpen = FALSE;
700ade8e: 9901         	ldr	r1, [sp, #0x4]
700ade90: 2000         	movs	r0, #0x0
700ade92: 6388         	str	r0, [r1, #0x38]
;     }
700ade94: e7ff         	b	0x700ade96 <UART_lld_dmaDeInit+0x36> @ imm = #-0x2
;     return status;
700ade96: 9802         	ldr	r0, [sp, #0x8]
700ade98: b004         	add	sp, #0x10
700ade9a: bd80         	pop	{r7, pc}
700ade9c: 0000         	movs	r0, r0
700ade9e: 0000         	movs	r0, r0

700adea0 <prvDeleteTCB>:
; static void prvDeleteTCB(TCB_t *pxTCB) {
700adea0: b580         	push	{r7, lr}
700adea2: b082         	sub	sp, #0x8
700adea4: 9001         	str	r0, [sp, #0x4]
;   portCLEAN_UP_TCB(pxTCB);
700adea6: 9801         	ldr	r0, [sp, #0x4]
;     if (pxTCB->ucStaticallyAllocated ==
700adea8: f890 0081    	ldrb.w	r0, [r0, #0x81]
700adeac: b940         	cbnz	r0, 0x700adec0 <prvDeleteTCB+0x20> @ imm = #0x10
700adeae: e7ff         	b	0x700adeb0 <prvDeleteTCB+0x10> @ imm = #-0x2
;       vPortFree(pxTCB->pxStack);
700adeb0: 9801         	ldr	r0, [sp, #0x4]
700adeb2: 6b00         	ldr	r0, [r0, #0x30]
700adeb4: f001 f90c    	bl	0x700af0d0 <vPortFree>  @ imm = #0x1218
;       vPortFree(pxTCB);
700adeb8: 9801         	ldr	r0, [sp, #0x4]
700adeba: f001 f909    	bl	0x700af0d0 <vPortFree>  @ imm = #0x1212
;     } else if (pxTCB->ucStaticallyAllocated ==
700adebe: e00b         	b	0x700aded8 <prvDeleteTCB+0x38> @ imm = #0x16
700adec0: 9801         	ldr	r0, [sp, #0x4]
700adec2: f890 0081    	ldrb.w	r0, [r0, #0x81]
700adec6: 2801         	cmp	r0, #0x1
700adec8: d104         	bne	0x700aded4 <prvDeleteTCB+0x34> @ imm = #0x8
700adeca: e7ff         	b	0x700adecc <prvDeleteTCB+0x2c> @ imm = #-0x2
;       vPortFree(pxTCB);
700adecc: 9801         	ldr	r0, [sp, #0x4]
700adece: f001 f8ff    	bl	0x700af0d0 <vPortFree>  @ imm = #0x11fe
;     } else {
700aded2: e000         	b	0x700aded6 <prvDeleteTCB+0x36> @ imm = #0x0
700aded4: e7ff         	b	0x700aded6 <prvDeleteTCB+0x36> @ imm = #-0x2
700aded6: e7ff         	b	0x700aded8 <prvDeleteTCB+0x38> @ imm = #-0x2
; }
700aded8: b002         	add	sp, #0x8
700adeda: bd80         	pop	{r7, pc}
700adedc: 0000         	movs	r0, r0
700adede: 0000         	movs	r0, r0

700adee0 <prvResetNextTaskUnblockTime>:
;   if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
700adee0: f245 2020    	movw	r0, #0x5220
700adee4: f2c7 0008    	movt	r0, #0x7008
700adee8: 6800         	ldr	r0, [r0]
700adeea: 6800         	ldr	r0, [r0]
700adeec: b940         	cbnz	r0, 0x700adf00 <prvResetNextTaskUnblockTime+0x20> @ imm = #0x10
700adeee: e7ff         	b	0x700adef0 <prvResetNextTaskUnblockTime+0x10> @ imm = #-0x2
;     xNextTaskUnblockTime = portMAX_DELAY;
700adef0: f242 61f4    	movw	r1, #0x26f4
700adef4: f2c7 010b    	movt	r1, #0x700b
700adef8: f04f 30ff    	mov.w	r0, #0xffffffff
700adefc: 6008         	str	r0, [r1]
;   } else {
700adefe: e00c         	b	0x700adf1a <prvResetNextTaskUnblockTime+0x3a> @ imm = #0x18
;     xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxDelayedTaskList);
700adf00: f245 2020    	movw	r0, #0x5220
700adf04: f2c7 0008    	movt	r0, #0x7008
700adf08: 6800         	ldr	r0, [r0]
700adf0a: 68c0         	ldr	r0, [r0, #0xc]
700adf0c: 6800         	ldr	r0, [r0]
700adf0e: f242 61f4    	movw	r1, #0x26f4
700adf12: f2c7 010b    	movt	r1, #0x700b
700adf16: 6008         	str	r0, [r1]
700adf18: e7ff         	b	0x700adf1a <prvResetNextTaskUnblockTime+0x3a> @ imm = #-0x2
; }
700adf1a: 4770         	bx	lr
700adf1c: 0000         	movs	r0, r0
700adf1e: 0000         	movs	r0, r0

700adf20 <PMU_enableAllCounters>:
; static void PMU_enableAllCounters(uint32_t numCounters) {
700adf20: b580         	push	{r7, lr}
700adf22: b082         	sub	sp, #0x8
700adf24: 9001         	str	r0, [sp, #0x4]
700adf26: 2001         	movs	r0, #0x1
;   CSL_armR5PmuEnableAllCntrs(1);
700adf28: f7f4 e828    	blx	0x700a1f7c <CSL_armR5PmuEnableAllCntrs> @ imm = #-0xbfb0
700adf2c: 2000         	movs	r0, #0x0
;   for (i = 0; i < numCounters; i++) {
700adf2e: 9000         	str	r0, [sp]
700adf30: e7ff         	b	0x700adf32 <PMU_enableAllCounters+0x12> @ imm = #-0x2
700adf32: 9800         	ldr	r0, [sp]
700adf34: 9901         	ldr	r1, [sp, #0x4]
700adf36: 4288         	cmp	r0, r1
700adf38: d209         	bhs	0x700adf4e <PMU_enableAllCounters+0x2e> @ imm = #0x12
700adf3a: e7ff         	b	0x700adf3c <PMU_enableAllCounters+0x1c> @ imm = #-0x2
;     CSL_armR5PmuEnableCntr(i, 1);
700adf3c: 9800         	ldr	r0, [sp]
700adf3e: 2101         	movs	r1, #0x1
700adf40: f7f4 e852    	blx	0x700a1fe8 <CSL_armR5PmuEnableCntr> @ imm = #-0xbf5c
;   }
700adf44: e7ff         	b	0x700adf46 <PMU_enableAllCounters+0x26> @ imm = #-0x2
;   for (i = 0; i < numCounters; i++) {
700adf46: 9800         	ldr	r0, [sp]
700adf48: 3001         	adds	r0, #0x1
700adf4a: 9000         	str	r0, [sp]
700adf4c: e7f1         	b	0x700adf32 <PMU_enableAllCounters+0x12> @ imm = #-0x1e
700adf4e: 201f         	movs	r0, #0x1f
700adf50: 2101         	movs	r1, #0x1
;   CSL_armR5PmuEnableCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM, 1);
700adf52: f7f4 e84a    	blx	0x700a1fe8 <CSL_armR5PmuEnableCntr> @ imm = #-0xbf6c
; }
700adf56: b002         	add	sp, #0x8
700adf58: bd80         	pop	{r7, pc}
700adf5a: 0000         	movs	r0, r0
700adf5c: 0000         	movs	r0, r0
700adf5e: 0000         	movs	r0, r0

700adf60 <_atoi>:
; {
700adf60: b580         	push	{r7, lr}
700adf62: b082         	sub	sp, #0x8
700adf64: 9001         	str	r0, [sp, #0x4]
700adf66: 2000         	movs	r0, #0x0
;   unsigned int i = 0U;
700adf68: 9000         	str	r0, [sp]
;   while (_is_digit(**str)) {
700adf6a: e7ff         	b	0x700adf6c <_atoi+0xc>  @ imm = #-0x2
700adf6c: 9801         	ldr	r0, [sp, #0x4]
700adf6e: 6800         	ldr	r0, [r0]
700adf70: 7800         	ldrb	r0, [r0]
700adf72: f000 fbdd    	bl	0x700ae730 <_is_digit>  @ imm = #0x7ba
700adf76: b168         	cbz	r0, 0x700adf94 <_atoi+0x34> @ imm = #0x1a
700adf78: e7ff         	b	0x700adf7a <_atoi+0x1a> @ imm = #-0x2
;     i = i * 10U + (unsigned int)(*((*str)++) - '0');
700adf7a: 9800         	ldr	r0, [sp]
700adf7c: eb00 0180    	add.w	r1, r0, r0, lsl #2
700adf80: 9b01         	ldr	r3, [sp, #0x4]
700adf82: 6818         	ldr	r0, [r3]
700adf84: 1c42         	adds	r2, r0, #0x1
700adf86: 601a         	str	r2, [r3]
700adf88: 7800         	ldrb	r0, [r0]
700adf8a: eb00 0041    	add.w	r0, r0, r1, lsl #1
700adf8e: 3830         	subs	r0, #0x30
700adf90: 9000         	str	r0, [sp]
;   while (_is_digit(**str)) {
700adf92: e7eb         	b	0x700adf6c <_atoi+0xc>  @ imm = #-0x2a
;   return i;
700adf94: 9800         	ldr	r0, [sp]
700adf96: b002         	add	sp, #0x8
700adf98: bd80         	pop	{r7, pc}
700adf9a: 0000         	movs	r0, r0
700adf9c: 0000         	movs	r0, r0
700adf9e: 0000         	movs	r0, r0

700adfa0 <snprintf_>:
; {
700adfa0: b081         	sub	sp, #0x4
700adfa2: b580         	push	{r7, lr}
700adfa4: b087         	sub	sp, #0x1c
700adfa6: 9309         	str	r3, [sp, #0x24]
700adfa8: 9006         	str	r0, [sp, #0x18]
700adfaa: 9105         	str	r1, [sp, #0x14]
700adfac: 9204         	str	r2, [sp, #0x10]
700adfae: a809         	add	r0, sp, #0x24
;   va_start(va, format);
700adfb0: 9003         	str	r0, [sp, #0xc]
;   const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
700adfb2: 9906         	ldr	r1, [sp, #0x18]
700adfb4: 9a05         	ldr	r2, [sp, #0x14]
700adfb6: 9b04         	ldr	r3, [sp, #0x10]
700adfb8: 9803         	ldr	r0, [sp, #0xc]
700adfba: 46ec         	mov	r12, sp
700adfbc: f8cc 0000    	str.w	r0, [r12]
700adfc0: f64e 5061    	movw	r0, #0xed61
700adfc4: f2c7 000a    	movt	r0, #0x700a
700adfc8: f7ec f84a    	bl	0x7009a060 <_vsnprintf> @ imm = #-0x13f6c
700adfcc: 9002         	str	r0, [sp, #0x8]
;   return ret;
700adfce: 9802         	ldr	r0, [sp, #0x8]
700adfd0: b007         	add	sp, #0x1c
700adfd2: e8bd 4080    	pop.w	{r7, lr}
700adfd6: b001         	add	sp, #0x4
700adfd8: 4770         	bx	lr
700adfda: 0000         	movs	r0, r0
700adfdc: 0000         	movs	r0, r0
700adfde: 0000         	movs	r0, r0

700adfe0 <vListInsertEnd>:
; {
700adfe0: b083         	sub	sp, #0xc
700adfe2: 9002         	str	r0, [sp, #0x8]
700adfe4: 9101         	str	r1, [sp, #0x4]
;     ListItem_t * const pxIndex = pxList->pxIndex;
700adfe6: 9802         	ldr	r0, [sp, #0x8]
700adfe8: 6840         	ldr	r0, [r0, #0x4]
700adfea: 9000         	str	r0, [sp]
;     pxNewListItem->pxNext = pxIndex;
700adfec: 9800         	ldr	r0, [sp]
700adfee: 9901         	ldr	r1, [sp, #0x4]
700adff0: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxPrevious = pxIndex->pxPrevious;
700adff2: 9800         	ldr	r0, [sp]
700adff4: 6880         	ldr	r0, [r0, #0x8]
700adff6: 9901         	ldr	r1, [sp, #0x4]
700adff8: 6088         	str	r0, [r1, #0x8]
;     pxIndex->pxPrevious->pxNext = pxNewListItem;
700adffa: 9801         	ldr	r0, [sp, #0x4]
700adffc: 9900         	ldr	r1, [sp]
700adffe: 6889         	ldr	r1, [r1, #0x8]
700ae000: 6048         	str	r0, [r1, #0x4]
;     pxIndex->pxPrevious = pxNewListItem;
700ae002: 9801         	ldr	r0, [sp, #0x4]
700ae004: 9900         	ldr	r1, [sp]
700ae006: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxContainer = pxList;
700ae008: 9802         	ldr	r0, [sp, #0x8]
700ae00a: 9901         	ldr	r1, [sp, #0x4]
700ae00c: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
700ae00e: 9902         	ldr	r1, [sp, #0x8]
700ae010: 6808         	ldr	r0, [r1]
700ae012: 3001         	adds	r0, #0x1
700ae014: 6008         	str	r0, [r1]
; }
700ae016: b003         	add	sp, #0xc
700ae018: 4770         	bx	lr
700ae01a: 0000         	movs	r0, r0
700ae01c: 0000         	movs	r0, r0
700ae01e: 0000         	movs	r0, r0

700ae020 <CSL_REG32_FINS_RAW>:
; {
700ae020: b580         	push	{r7, lr}
700ae022: b086         	sub	sp, #0x18
700ae024: 9005         	str	r0, [sp, #0x14]
700ae026: 9104         	str	r1, [sp, #0x10]
700ae028: 9203         	str	r2, [sp, #0xc]
700ae02a: 9302         	str	r3, [sp, #0x8]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700ae02c: 9805         	ldr	r0, [sp, #0x14]
700ae02e: f001 fc5f    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0x18be
700ae032: 9001         	str	r0, [sp, #0x4]
;     regVal = (regVal & ~(mask));
700ae034: 9801         	ldr	r0, [sp, #0x4]
700ae036: 9904         	ldr	r1, [sp, #0x10]
700ae038: 4388         	bics	r0, r1
700ae03a: 9001         	str	r0, [sp, #0x4]
;     regVal |= (v << shift) & mask;
700ae03c: 9802         	ldr	r0, [sp, #0x8]
700ae03e: 9903         	ldr	r1, [sp, #0xc]
700ae040: 4088         	lsls	r0, r1
700ae042: 9904         	ldr	r1, [sp, #0x10]
700ae044: 4001         	ands	r1, r0
700ae046: 9801         	ldr	r0, [sp, #0x4]
700ae048: 4308         	orrs	r0, r1
700ae04a: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR_RAW(p, regVal);
700ae04c: 9805         	ldr	r0, [sp, #0x14]
700ae04e: 9901         	ldr	r1, [sp, #0x4]
700ae050: f7ee f8de    	bl	0x7009c210 <CSL_REG32_WR_RAW> @ imm = #-0x11e44
;     return;
700ae054: b006         	add	sp, #0x18
700ae056: bd80         	pop	{r7, pc}
		...

700ae060 <SOC_getCoreName>:
; {
700ae060: b082         	sub	sp, #0x8
700ae062: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     if(coreId < CSL_CORE_ID_MAX)
700ae066: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ae06a: 2806         	cmp	r0, #0x6
700ae06c: d80a         	bhi	0x700ae084 <SOC_getCoreName+0x24> @ imm = #0x14
700ae06e: e7ff         	b	0x700ae070 <SOC_getCoreName+0x10> @ imm = #-0x2
;         name = coreIdNames[coreId];
700ae070: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ae074: f242 503c    	movw	r0, #0x253c
700ae078: f2c7 000b    	movt	r0, #0x700b
700ae07c: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700ae080: 9000         	str	r0, [sp]
;     }
700ae082: e006         	b	0x700ae092 <SOC_getCoreName+0x32> @ imm = #0xc
;         name = coreIdNames[CSL_CORE_ID_MAX];
700ae084: f242 503c    	movw	r0, #0x253c
700ae088: f2c7 000b    	movt	r0, #0x700b
700ae08c: 69c0         	ldr	r0, [r0, #0x1c]
700ae08e: 9000         	str	r0, [sp]
700ae090: e7ff         	b	0x700ae092 <SOC_getCoreName+0x32> @ imm = #-0x2
;     return name;
700ae092: 9800         	ldr	r0, [sp]
700ae094: b002         	add	sp, #0x8
700ae096: 4770         	bx	lr
		...

700ae0a0 <Sciclient_secProxyFlush>:
; {
700ae0a0: b580         	push	{r7, lr}
700ae0a2: b082         	sub	sp, #0x8
700ae0a4: 9001         	str	r0, [sp, #0x4]
;     while ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ae0a6: e7ff         	b	0x700ae0a8 <Sciclient_secProxyFlush+0x8> @ imm = #-0x2
700ae0a8: 9801         	ldr	r0, [sp, #0x4]
700ae0aa: f001 f991    	bl	0x700af3d0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x1322
700ae0ae: f001 fc37    	bl	0x700af920 <CSL_REG32_RD_RAW> @ imm = #0x186e
700ae0b2: 0600         	lsls	r0, r0, #0x18
700ae0b4: b170         	cbz	r0, 0x700ae0d4 <Sciclient_secProxyFlush+0x34> @ imm = #0x1c
700ae0b6: e7ff         	b	0x700ae0b8 <Sciclient_secProxyFlush+0x18> @ imm = #-0x2
;         (void) Sciclient_secProxyReadThread32(thread,
700ae0b8: 9801         	ldr	r0, [sp, #0x4]
;                         (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U)-1U));
700ae0ba: f242 6108    	movw	r1, #0x2608
700ae0be: f2c7 010b    	movt	r1, #0x700b
700ae0c2: 694a         	ldr	r2, [r1, #0x14]
700ae0c4: f04f 31ff    	mov.w	r1, #0xffffffff
700ae0c8: eb01 0192    	add.w	r1, r1, r2, lsr #2
;         (void) Sciclient_secProxyReadThread32(thread,
700ae0cc: b2c9         	uxtb	r1, r1
700ae0ce: f000 faff    	bl	0x700ae6d0 <Sciclient_secProxyReadThread32> @ imm = #0x5fe
;     while ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ae0d2: e7e9         	b	0x700ae0a8 <Sciclient_secProxyFlush+0x8> @ imm = #-0x2e
;     return ;
700ae0d4: b002         	add	sp, #0x8
700ae0d6: bd80         	pop	{r7, pc}
		...

700ae0e0 <UART_writeDataPolling>:
; {
700ae0e0: b580         	push	{r7, lr}
700ae0e2: b082         	sub	sp, #0x8
700ae0e4: 9001         	str	r0, [sp, #0x4]
700ae0e6: 2000         	movs	r0, #0x0
;     uint32_t numBytesWritten = 0U;
700ae0e8: 9000         	str	r0, [sp]
;     numBytesWritten = UART_fifoWrite(hUart,
700ae0ea: 9801         	ldr	r0, [sp, #0x4]
;                                      (const uint8_t *) hUart->writeBuf,
700ae0ec: 6881         	ldr	r1, [r0, #0x8]
;                                      hUart->writeSizeRemaining);
700ae0ee: 6902         	ldr	r2, [r0, #0x10]
;     numBytesWritten = UART_fifoWrite(hUart,
700ae0f0: f7f9 fb1e    	bl	0x700a7730 <UART_fifoWrite> @ imm = #-0x69c4
700ae0f4: 9000         	str	r0, [sp]
;     hUart->writeSizeRemaining -= numBytesWritten;
700ae0f6: 9a00         	ldr	r2, [sp]
700ae0f8: 9901         	ldr	r1, [sp, #0x4]
700ae0fa: 6908         	ldr	r0, [r1, #0x10]
700ae0fc: 1a80         	subs	r0, r0, r2
700ae0fe: 6108         	str	r0, [r1, #0x10]
;     hUart->writeBuf           = (const void *)((uint8_t *)hUart->writeBuf + numBytesWritten);
700ae100: 9901         	ldr	r1, [sp, #0x4]
700ae102: 6888         	ldr	r0, [r1, #0x8]
700ae104: 9a00         	ldr	r2, [sp]
700ae106: 4410         	add	r0, r2
700ae108: 6088         	str	r0, [r1, #0x8]
;     hUart->writeCount         += numBytesWritten;
700ae10a: 9a00         	ldr	r2, [sp]
700ae10c: 9901         	ldr	r1, [sp, #0x4]
700ae10e: 68c8         	ldr	r0, [r1, #0xc]
700ae110: 4410         	add	r0, r2
700ae112: 60c8         	str	r0, [r1, #0xc]
;     return;
700ae114: b002         	add	sp, #0x8
700ae116: bd80         	pop	{r7, pc}
		...

700ae120 <xTaskGetSchedulerState>:
; BaseType_t xTaskGetSchedulerState(void) {
700ae120: b081         	sub	sp, #0x4
;   if (xSchedulerRunning == pdFALSE) {
700ae122: f242 7000    	movw	r0, #0x2700
700ae126: f2c7 000b    	movt	r0, #0x700b
700ae12a: 6800         	ldr	r0, [r0]
700ae12c: b918         	cbnz	r0, 0x700ae136 <xTaskGetSchedulerState+0x16> @ imm = #0x6
700ae12e: e7ff         	b	0x700ae130 <xTaskGetSchedulerState+0x10> @ imm = #-0x2
700ae130: 2001         	movs	r0, #0x1
;     xReturn = taskSCHEDULER_NOT_STARTED;
700ae132: 9000         	str	r0, [sp]
;   } else {
700ae134: e00d         	b	0x700ae152 <xTaskGetSchedulerState+0x32> @ imm = #0x1a
;     if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700ae136: f242 60e4    	movw	r0, #0x26e4
700ae13a: f2c7 000b    	movt	r0, #0x700b
700ae13e: 6800         	ldr	r0, [r0]
700ae140: b918         	cbnz	r0, 0x700ae14a <xTaskGetSchedulerState+0x2a> @ imm = #0x6
700ae142: e7ff         	b	0x700ae144 <xTaskGetSchedulerState+0x24> @ imm = #-0x2
700ae144: 2002         	movs	r0, #0x2
;       xReturn = taskSCHEDULER_RUNNING;
700ae146: 9000         	str	r0, [sp]
;     } else {
700ae148: e002         	b	0x700ae150 <xTaskGetSchedulerState+0x30> @ imm = #0x4
700ae14a: 2000         	movs	r0, #0x0
;       xReturn = taskSCHEDULER_SUSPENDED;
700ae14c: 9000         	str	r0, [sp]
700ae14e: e7ff         	b	0x700ae150 <xTaskGetSchedulerState+0x30> @ imm = #-0x2
700ae150: e7ff         	b	0x700ae152 <xTaskGetSchedulerState+0x32> @ imm = #-0x2
;   return xReturn;
700ae152: 9800         	ldr	r0, [sp]
700ae154: b001         	add	sp, #0x4
700ae156: 4770         	bx	lr
		...

700ae160 <tm_thread_create>:
; {
700ae160: b580         	push	{r7, lr}
700ae162: b082         	sub	sp, #0x8
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ae164: f245 1348    	movw	r3, #0x5148
;    int new_priority = configMAX_PRIORITIES - priority + 1;
700ae168: f1c1 0c21    	rsb.w	r12, r1, #0x21
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ae16c: f2c7 0308    	movt	r3, #0x7008
;    status = xTaskCreate((TaskFunction_t) entry_function, "Thread-Metric test", configMINIMAL_STACK_SIZE, NULL,
700ae170: f641 4166    	movw	r1, #0x1c66
700ae174: f2c7 010b    	movt	r1, #0x700b
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ae178: eb03 0e80    	add.w	lr, r3, r0, lsl #2
;    status = xTaskCreate((TaskFunction_t) entry_function, "Thread-Metric test", configMINIMAL_STACK_SIZE, NULL,
700ae17c: 4610         	mov	r0, r2
700ae17e: f44f 6280    	mov.w	r2, #0x400
700ae182: 2300         	movs	r3, #0x0
700ae184: e9cd ce00    	strd	r12, lr, [sp]
700ae188: f7fb f88a    	bl	0x700a92a0 <xTaskCreate> @ imm = #-0x4eec
;    if (status != pdPASS)
700ae18c: 3801         	subs	r0, #0x1
700ae18e: bf18         	it	ne
700ae190: 2001         	movne	r0, #0x1
; }
700ae192: b002         	add	sp, #0x8
700ae194: bd80         	pop	{r7, pc}
		...
700ae19e: 0000         	movs	r0, r0

700ae1a0 <vTaskDelay>:
; void vTaskDelay(const TickType_t xTicksToDelay) {
700ae1a0: b580         	push	{r7, lr}
700ae1a2: b082         	sub	sp, #0x8
700ae1a4: 9001         	str	r0, [sp, #0x4]
700ae1a6: 2000         	movs	r0, #0x0
;   BaseType_t xAlreadyYielded = pdFALSE;
700ae1a8: 9000         	str	r0, [sp]
;   if (xTicksToDelay > (TickType_t)0U) {
700ae1aa: 9801         	ldr	r0, [sp, #0x4]
700ae1ac: b150         	cbz	r0, 0x700ae1c4 <vTaskDelay+0x24> @ imm = #0x14
700ae1ae: e7ff         	b	0x700ae1b0 <vTaskDelay+0x10> @ imm = #-0x2
;     vTaskSuspendAll();
700ae1b0: f001 fb7e    	bl	0x700af8b0 <vTaskSuspendAll> @ imm = #0x16fc
;       prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
700ae1b4: 9801         	ldr	r0, [sp, #0x4]
700ae1b6: 2100         	movs	r1, #0x0
700ae1b8: f7f8 f972    	bl	0x700a64a0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x7d1c
;     xAlreadyYielded = xTaskResumeAll();
700ae1bc: f7f3 ff68    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0xc130
700ae1c0: 9000         	str	r0, [sp]
;   } else {
700ae1c2: e000         	b	0x700ae1c6 <vTaskDelay+0x26> @ imm = #0x0
700ae1c4: e7ff         	b	0x700ae1c6 <vTaskDelay+0x26> @ imm = #-0x2
;   if (xAlreadyYielded == pdFALSE) {
700ae1c6: 9800         	ldr	r0, [sp]
700ae1c8: b910         	cbnz	r0, 0x700ae1d0 <vTaskDelay+0x30> @ imm = #0x4
700ae1ca: e7ff         	b	0x700ae1cc <vTaskDelay+0x2c> @ imm = #-0x2
;     portYIELD_WITHIN_API();
700ae1cc: df00         	svc	#0x0
;   } else {
700ae1ce: e000         	b	0x700ae1d2 <vTaskDelay+0x32> @ imm = #0x0
700ae1d0: e7ff         	b	0x700ae1d2 <vTaskDelay+0x32> @ imm = #-0x2
; }
700ae1d2: b002         	add	sp, #0x8
700ae1d4: bd80         	pop	{r7, pc}
		...
700ae1de: 0000         	movs	r0, r0

700ae1e0 <vTaskPlaceOnEventListRestricted>:
;                                      const BaseType_t xWaitIndefinitely) {
700ae1e0: b580         	push	{r7, lr}
700ae1e2: b084         	sub	sp, #0x10
700ae1e4: 9003         	str	r0, [sp, #0xc]
700ae1e6: 9102         	str	r1, [sp, #0x8]
700ae1e8: 9201         	str	r2, [sp, #0x4]
;   vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
700ae1ea: 9803         	ldr	r0, [sp, #0xc]
700ae1ec: f242 61bc    	movw	r1, #0x26bc
700ae1f0: f2c7 010b    	movt	r1, #0x700b
700ae1f4: 6809         	ldr	r1, [r1]
700ae1f6: 3118         	adds	r1, #0x18
700ae1f8: f7ff fef2    	bl	0x700adfe0 <vListInsertEnd> @ imm = #-0x21c
;   if (xWaitIndefinitely != pdFALSE) {
700ae1fc: 9801         	ldr	r0, [sp, #0x4]
700ae1fe: b120         	cbz	r0, 0x700ae20a <vTaskPlaceOnEventListRestricted+0x2a> @ imm = #0x8
700ae200: e7ff         	b	0x700ae202 <vTaskPlaceOnEventListRestricted+0x22> @ imm = #-0x2
700ae202: f04f 30ff    	mov.w	r0, #0xffffffff
;     xTicksToWait = portMAX_DELAY;
700ae206: 9002         	str	r0, [sp, #0x8]
;   }
700ae208: e7ff         	b	0x700ae20a <vTaskPlaceOnEventListRestricted+0x2a> @ imm = #-0x2
;   prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
700ae20a: 9802         	ldr	r0, [sp, #0x8]
700ae20c: 9901         	ldr	r1, [sp, #0x4]
700ae20e: f7f8 f947    	bl	0x700a64a0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x7d72
; }
700ae212: b004         	add	sp, #0x10
700ae214: bd80         	pop	{r7, pc}
		...
700ae21e: 0000         	movs	r0, r0

700ae220 <CSL_pktdmaTeardownRxChan>:
; {
700ae220: b580         	push	{r7, lr}
700ae222: b084         	sub	sp, #0x10
700ae224: 9003         	str	r0, [sp, #0xc]
700ae226: 9102         	str	r1, [sp, #0x8]
700ae228: f88d 2007    	strb.w	r2, [sp, #0x7]
700ae22c: f88d 3006    	strb.w	r3, [sp, #0x6]
;     return CSL_pktdmaTeardownChan( pCfg, chanIdx, CSL_PKTDMA_CHAN_DIR_RX, bForce, bWait );
700ae230: 9803         	ldr	r0, [sp, #0xc]
700ae232: 9902         	ldr	r1, [sp, #0x8]
700ae234: f89d 2007    	ldrb.w	r2, [sp, #0x7]
700ae238: f89d 3006    	ldrb.w	r3, [sp, #0x6]
700ae23c: f003 0301    	and	r3, r3, #0x1
700ae240: 46ec         	mov	r12, sp
700ae242: f8cc 3000    	str.w	r3, [r12]
700ae246: f002 0301    	and	r3, r2, #0x1
700ae24a: 2201         	movs	r2, #0x1
700ae24c: f7f6 ffe0    	bl	0x700a5210 <CSL_pktdmaTeardownChan> @ imm = #-0x9040
700ae250: b004         	add	sp, #0x10
700ae252: bd80         	pop	{r7, pc}
		...

700ae260 <CSL_pktdmaTeardownTxChan>:
; {
700ae260: b580         	push	{r7, lr}
700ae262: b084         	sub	sp, #0x10
700ae264: 9003         	str	r0, [sp, #0xc]
700ae266: 9102         	str	r1, [sp, #0x8]
700ae268: f88d 2007    	strb.w	r2, [sp, #0x7]
700ae26c: f88d 3006    	strb.w	r3, [sp, #0x6]
;     return CSL_pktdmaTeardownChan( pCfg, chanIdx, CSL_PKTDMA_CHAN_DIR_TX, bForce, bWait );
700ae270: 9803         	ldr	r0, [sp, #0xc]
700ae272: 9902         	ldr	r1, [sp, #0x8]
700ae274: f89d 2007    	ldrb.w	r2, [sp, #0x7]
700ae278: f89d 3006    	ldrb.w	r3, [sp, #0x6]
700ae27c: f003 0301    	and	r3, r3, #0x1
700ae280: 46ec         	mov	r12, sp
700ae282: f8cc 3000    	str.w	r3, [r12]
700ae286: f002 0301    	and	r3, r2, #0x1
700ae28a: 2200         	movs	r2, #0x0
700ae28c: f7f6 ffc0    	bl	0x700a5210 <CSL_pktdmaTeardownChan> @ imm = #-0x9080
700ae290: b004         	add	sp, #0x10
700ae292: bd80         	pop	{r7, pc}
		...

700ae2a0 <TimerP_Params_init>:
; {
700ae2a0: b081         	sub	sp, #0x4
700ae2a2: 9000         	str	r0, [sp]
;     params->inputPreScaler = 1;
700ae2a4: 9800         	ldr	r0, [sp]
700ae2a6: 2101         	movs	r1, #0x1
700ae2a8: 6001         	str	r1, [r0]
;     params->inputClkHz = 25*1000000;
700ae2aa: 9a00         	ldr	r2, [sp]
700ae2ac: f647 0040    	movw	r0, #0x7840
700ae2b0: f2c0 107d    	movt	r0, #0x17d
700ae2b4: 6050         	str	r0, [r2, #0x4]
;     params->periodInUsec = 1000;
700ae2b6: 9a00         	ldr	r2, [sp]
700ae2b8: f44f 707a    	mov.w	r0, #0x3e8
700ae2bc: 6090         	str	r0, [r2, #0x8]
;     params->periodInNsec = 0; /* periodInUsec is used when periodInNsec is 0 */
700ae2be: 9a00         	ldr	r2, [sp]
700ae2c0: 2000         	movs	r0, #0x0
700ae2c2: 60d0         	str	r0, [r2, #0xc]
;     params->oneshotMode = 0;
700ae2c4: 9a00         	ldr	r2, [sp]
700ae2c6: 6110         	str	r0, [r2, #0x10]
;     params->enableOverflowInt = 1;
700ae2c8: 9a00         	ldr	r2, [sp]
700ae2ca: 6151         	str	r1, [r2, #0x14]
;     params->enableDmaTrigger = 0; /* NOT USED */
700ae2cc: 9900         	ldr	r1, [sp]
700ae2ce: 6188         	str	r0, [r1, #0x18]
; }
700ae2d0: b001         	add	sp, #0x4
700ae2d2: 4770         	bx	lr
		...

700ae2e0 <UART_IsDataLengthValid>:
; {
700ae2e0: b082         	sub	sp, #0x8
700ae2e2: 9001         	str	r0, [sp, #0x4]
700ae2e4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ae2e8: 9000         	str	r0, [sp]
;     if(((dataLength == UART_LEN_5) ||
700ae2ea: 9801         	ldr	r0, [sp, #0x4]
700ae2ec: b160         	cbz	r0, 0x700ae308 <UART_IsDataLengthValid+0x28> @ imm = #0x18
700ae2ee: e7ff         	b	0x700ae2f0 <UART_IsDataLengthValid+0x10> @ imm = #-0x2
;         (dataLength == UART_LEN_6) ||
700ae2f0: 9801         	ldr	r0, [sp, #0x4]
700ae2f2: 2801         	cmp	r0, #0x1
700ae2f4: d008         	beq	0x700ae308 <UART_IsDataLengthValid+0x28> @ imm = #0x10
700ae2f6: e7ff         	b	0x700ae2f8 <UART_IsDataLengthValid+0x18> @ imm = #-0x2
;         (dataLength == UART_LEN_7) ||
700ae2f8: 9801         	ldr	r0, [sp, #0x4]
700ae2fa: 2802         	cmp	r0, #0x2
700ae2fc: d004         	beq	0x700ae308 <UART_IsDataLengthValid+0x28> @ imm = #0x8
700ae2fe: e7ff         	b	0x700ae300 <UART_IsDataLengthValid+0x20> @ imm = #-0x2
;         (dataLength == UART_LEN_8)))
700ae300: 9801         	ldr	r0, [sp, #0x4]
;     if(((dataLength == UART_LEN_5) ||
700ae302: 2803         	cmp	r0, #0x3
700ae304: d103         	bne	0x700ae30e <UART_IsDataLengthValid+0x2e> @ imm = #0x6
700ae306: e7ff         	b	0x700ae308 <UART_IsDataLengthValid+0x28> @ imm = #-0x2
700ae308: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ae30a: 9000         	str	r0, [sp]
;     }
700ae30c: e7ff         	b	0x700ae30e <UART_IsDataLengthValid+0x2e> @ imm = #-0x2
;     return status;
700ae30e: 9800         	ldr	r0, [sp]
700ae310: b002         	add	sp, #0x8
700ae312: 4770         	bx	lr
		...

700ae320 <UART_checkTransaction>:
; {
700ae320: b082         	sub	sp, #0x8
700ae322: 9001         	str	r0, [sp, #0x4]
700ae324: 2000         	movs	r0, #0x0
;     int32_t     status = UART_TRANSFER_STATUS_SUCCESS;
700ae326: 9000         	str	r0, [sp]
;     if(0U == trans->count)
700ae328: 9801         	ldr	r0, [sp, #0x4]
700ae32a: 6840         	ldr	r0, [r0, #0x4]
700ae32c: b938         	cbnz	r0, 0x700ae33e <UART_checkTransaction+0x1e> @ imm = #0xe
700ae32e: e7ff         	b	0x700ae330 <UART_checkTransaction+0x10> @ imm = #-0x2
;         trans->status = UART_TRANSFER_STATUS_ERROR_OTH;
700ae330: 9901         	ldr	r1, [sp, #0x4]
700ae332: 200a         	movs	r0, #0xa
700ae334: 60c8         	str	r0, [r1, #0xc]
700ae336: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ae33a: 9000         	str	r0, [sp]
;     }
700ae33c: e7ff         	b	0x700ae33e <UART_checkTransaction+0x1e> @ imm = #-0x2
;     if(NULL == trans->buf)
700ae33e: 9801         	ldr	r0, [sp, #0x4]
700ae340: 6800         	ldr	r0, [r0]
700ae342: b920         	cbnz	r0, 0x700ae34e <UART_checkTransaction+0x2e> @ imm = #0x8
700ae344: e7ff         	b	0x700ae346 <UART_checkTransaction+0x26> @ imm = #-0x2
700ae346: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ae34a: 9000         	str	r0, [sp]
;     }
700ae34c: e7ff         	b	0x700ae34e <UART_checkTransaction+0x2e> @ imm = #-0x2
;     return (status);
700ae34e: 9800         	ldr	r0, [sp]
700ae350: b002         	add	sp, #0x8
700ae352: 4770         	bx	lr

700ae354 <free_list_remove>:
700ae354: e59f3028     	ldr	r3, [pc, #0x28]         @ 0x700ae384 <free_list_remove+0x30>
700ae358: e5932000     	ldr	r2, [r3]
700ae35c: e1a01003     	mov	r1, r3
700ae360: e3520000     	cmp	r2, #0
700ae364: 12823008     	addne	r3, r2, #8
700ae368: 11520000     	cmpne	r2, r0
700ae36c: 1afffff9     	bne	0x700ae358 <free_list_remove+0x4> @ imm = #-0x1c
700ae370: e3520000     	cmp	r2, #0
700ae374: 012fff1e     	bxeq	lr
700ae378: e5900008     	ldr	r0, [r0, #0x8]
700ae37c: e5810000     	str	r0, [r1]
700ae380: e12fff1e     	bx	lr
700ae384: 2c 52 08 70  	.word	0x7008522c
700ae388: 00 00 00 00  	.word	0x00000000
700ae38c: 00 00 00 00  	.word	0x00000000

700ae390 <vPortTimerTickHandler>:
; void vPortTimerTickHandler() {
700ae390: b580         	push	{r7, lr}
;   portENTER_CRITICAL();
700ae392: f000 f89d    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #0x13a
;   if (ulPortSchedularRunning == pdTRUE) {
700ae396: f242 60d0    	movw	r0, #0x26d0
700ae39a: f2c7 000b    	movt	r0, #0x700b
700ae39e: 6800         	ldr	r0, [r0]
700ae3a0: 2801         	cmp	r0, #0x1
700ae3a2: d10c         	bne	0x700ae3be <vPortTimerTickHandler+0x2e> @ imm = #0x18
700ae3a4: e7ff         	b	0x700ae3a6 <vPortTimerTickHandler+0x16> @ imm = #-0x2
;     if (xTaskIncrementTick() != pdFALSE) {
700ae3a6: f7f3 f823    	bl	0x700a13f0 <xTaskIncrementTick> @ imm = #-0xcfba
700ae3aa: b138         	cbz	r0, 0x700ae3bc <vPortTimerTickHandler+0x2c> @ imm = #0xe
700ae3ac: e7ff         	b	0x700ae3ae <vPortTimerTickHandler+0x1e> @ imm = #-0x2
;       ulPortYieldRequired = pdTRUE;
700ae3ae: f242 61d8    	movw	r1, #0x26d8
700ae3b2: f2c7 010b    	movt	r1, #0x700b
700ae3b6: 2001         	movs	r0, #0x1
700ae3b8: 6008         	str	r0, [r1]
;     }
700ae3ba: e7ff         	b	0x700ae3bc <vPortTimerTickHandler+0x2c> @ imm = #-0x2
;   }
700ae3bc: e7ff         	b	0x700ae3be <vPortTimerTickHandler+0x2e> @ imm = #-0x2
;   portEXIT_CRITICAL();
700ae3be: f7ff f947    	bl	0x700ad650 <vTaskExitCritical> @ imm = #-0xd72
; }
700ae3c2: bd80         	pop	{r7, pc}
		...

700ae3d0 <ClockP_timerTickIsr>:
; {
700ae3d0: b580         	push	{r7, lr}
700ae3d2: b082         	sub	sp, #0x8
700ae3d4: 9001         	str	r0, [sp, #0x4]
;     gClockCtrl.ticks++;
700ae3d6: f245 1110    	movw	r1, #0x5110
700ae3da: f2c7 0108    	movt	r1, #0x7008
700ae3de: 680a         	ldr	r2, [r1]
700ae3e0: 6848         	ldr	r0, [r1, #0x4]
700ae3e2: 3201         	adds	r2, #0x1
700ae3e4: f140 0000    	adc	r0, r0, #0x0
700ae3e8: 600a         	str	r2, [r1]
700ae3ea: 6048         	str	r0, [r1, #0x4]
;     vPortTimerTickHandler();
700ae3ec: f7ff ffd0    	bl	0x700ae390 <vPortTimerTickHandler> @ imm = #-0x60
;     ClockP_timerClearOverflowInt(gClockConfig.timerBaseAddr);
700ae3f0: f242 50c0    	movw	r0, #0x25c0
700ae3f4: f2c7 000b    	movt	r0, #0x700b
700ae3f8: 6800         	ldr	r0, [r0]
700ae3fa: f001 fa29    	bl	0x700af850 <ClockP_timerClearOverflowInt> @ imm = #0x1452
; }
700ae3fe: b002         	add	sp, #0x8
700ae400: bd80         	pop	{r7, pc}
		...
700ae40e: 0000         	movs	r0, r0

700ae410 <HW_WR_FIELD32_RAW>:
; {
700ae410: b085         	sub	sp, #0x14
700ae412: 9004         	str	r0, [sp, #0x10]
700ae414: 9103         	str	r1, [sp, #0xc]
700ae416: 9202         	str	r2, [sp, #0x8]
700ae418: 9301         	str	r3, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700ae41a: 9804         	ldr	r0, [sp, #0x10]
700ae41c: 6800         	ldr	r0, [r0]
700ae41e: 9000         	str	r0, [sp]
;     regVal &= (~mask);
700ae420: 9903         	ldr	r1, [sp, #0xc]
700ae422: 9800         	ldr	r0, [sp]
700ae424: 4388         	bics	r0, r1
700ae426: 9000         	str	r0, [sp]
;     regVal |= (value << shift) & mask;
700ae428: 9801         	ldr	r0, [sp, #0x4]
700ae42a: 9902         	ldr	r1, [sp, #0x8]
700ae42c: 4088         	lsls	r0, r1
700ae42e: 9903         	ldr	r1, [sp, #0xc]
700ae430: 4001         	ands	r1, r0
700ae432: 9800         	ldr	r0, [sp]
700ae434: 4308         	orrs	r0, r1
700ae436: 9000         	str	r0, [sp]
;     *(volatile uint32_t *) ((uintptr_t) addr) = regVal;
700ae438: 9800         	ldr	r0, [sp]
700ae43a: 9904         	ldr	r1, [sp, #0x10]
700ae43c: 6008         	str	r0, [r1]
;     return;
700ae43e: b005         	add	sp, #0x14
700ae440: 4770         	bx	lr
		...
700ae44e: 0000         	movs	r0, r0

700ae450 <UART_enhanFuncBitValRestore>:
; {
700ae450: b580         	push	{r7, lr}
700ae452: b084         	sub	sp, #0x10
700ae454: 9003         	str	r0, [sp, #0xc]
700ae456: 9102         	str	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ae458: 9803         	ldr	r0, [sp, #0xc]
700ae45a: 21bf         	movs	r1, #0xbf
700ae45c: f7fe f868    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #-0x1f30
700ae460: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700ae462: 9803         	ldr	r0, [sp, #0xc]
700ae464: 3008         	adds	r0, #0x8
700ae466: 9902         	ldr	r1, [sp, #0x8]
700ae468: ea4f 1311    	lsr.w	r3, r1, #0x4
700ae46c: 2110         	movs	r1, #0x10
700ae46e: 2204         	movs	r2, #0x4
700ae470: f7ff ffce    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #-0x64
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ae474: 9803         	ldr	r0, [sp, #0xc]
700ae476: 300c         	adds	r0, #0xc
700ae478: 9901         	ldr	r1, [sp, #0x4]
700ae47a: f001 f9f9    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x13f2
; }
700ae47e: b004         	add	sp, #0x10
700ae480: bd80         	pop	{r7, pc}
		...
700ae48e: 0000         	movs	r0, r0

700ae490 <UART_hardwareFlowCtrlOptSet>:
; {
700ae490: b580         	push	{r7, lr}
700ae492: b084         	sub	sp, #0x10
700ae494: 9003         	str	r0, [sp, #0xc]
700ae496: 9102         	str	r1, [sp, #0x8]
700ae498: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700ae49a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ae49c: 9803         	ldr	r0, [sp, #0xc]
700ae49e: 21bf         	movs	r1, #0xbf
700ae4a0: f7fe f846    	bl	0x700ac530 <UART_regConfigModeEnable> @ imm = #-0x1f74
700ae4a4: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_HW_FLOW_CONTROL, hwFlowCtrl);
700ae4a6: 9803         	ldr	r0, [sp, #0xc]
700ae4a8: 3008         	adds	r0, #0x8
700ae4aa: 9b02         	ldr	r3, [sp, #0x8]
700ae4ac: 21c0         	movs	r1, #0xc0
700ae4ae: 2206         	movs	r2, #0x6
700ae4b0: f7ff ffae    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #-0xa4
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ae4b4: 9803         	ldr	r0, [sp, #0xc]
700ae4b6: 300c         	adds	r0, #0xc
700ae4b8: 9901         	ldr	r1, [sp, #0x4]
700ae4ba: f001 f9d9    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x13b2
; }
700ae4be: b004         	add	sp, #0x10
700ae4c0: bd80         	pop	{r7, pc}
		...
700ae4ce: 0000         	movs	r0, r0

700ae4d0 <vTaskEnterCritical>:
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700ae4d0: b672         	cpsid i
;   if (xSchedulerRunning != pdFALSE) {
700ae4d2: f242 7000    	movw	r0, #0x2700
700ae4d6: f2c7 000b    	movt	r0, #0x700b
700ae4da: 6800         	ldr	r0, [r0]
700ae4dc: b178         	cbz	r0, 0x700ae4fe <vTaskEnterCritical+0x2e> @ imm = #0x1e
700ae4de: e7ff         	b	0x700ae4e0 <vTaskEnterCritical+0x10> @ imm = #-0x2
;     (pxCurrentTCB->uxCriticalNesting)++;
700ae4e0: f242 60bc    	movw	r0, #0x26bc
700ae4e4: f2c7 000b    	movt	r0, #0x700b
700ae4e8: 6802         	ldr	r2, [r0]
700ae4ea: 6d51         	ldr	r1, [r2, #0x54]
700ae4ec: 3101         	adds	r1, #0x1
700ae4ee: 6551         	str	r1, [r2, #0x54]
;     if (pxCurrentTCB->uxCriticalNesting == 1) {
700ae4f0: 6800         	ldr	r0, [r0]
700ae4f2: 6d40         	ldr	r0, [r0, #0x54]
700ae4f4: 2801         	cmp	r0, #0x1
700ae4f6: d101         	bne	0x700ae4fc <vTaskEnterCritical+0x2c> @ imm = #0x2
700ae4f8: e7ff         	b	0x700ae4fa <vTaskEnterCritical+0x2a> @ imm = #-0x2
;     }
700ae4fa: e7ff         	b	0x700ae4fc <vTaskEnterCritical+0x2c> @ imm = #-0x2
;   } else {
700ae4fc: e000         	b	0x700ae500 <vTaskEnterCritical+0x30> @ imm = #0x0
700ae4fe: e7ff         	b	0x700ae500 <vTaskEnterCritical+0x30> @ imm = #-0x2
; }
700ae500: 4770         	bx	lr
		...
700ae50e: 0000         	movs	r0, r0

700ae510 <xQueueCreateMutexStatic>:
;     {
700ae510: b580         	push	{r7, lr}
700ae512: b086         	sub	sp, #0x18
700ae514: f88d 0017    	strb.w	r0, [sp, #0x17]
700ae518: 9104         	str	r1, [sp, #0x10]
700ae51a: 2001         	movs	r0, #0x1
;         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
700ae51c: 9002         	str	r0, [sp, #0x8]
700ae51e: 2200         	movs	r2, #0x0
700ae520: 9201         	str	r2, [sp, #0x4]
;         ( void ) ucQueueType;
700ae522: f89d 1017    	ldrb.w	r1, [sp, #0x17]
;         xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
700ae526: 9b04         	ldr	r3, [sp, #0x10]
700ae528: 46ec         	mov	r12, sp
700ae52a: f8cc 1000    	str.w	r1, [r12]
700ae52e: 4611         	mov	r1, r2
700ae530: f7fe ff06    	bl	0x700ad340 <xQueueGenericCreateStatic> @ imm = #-0x11f4
700ae534: 9003         	str	r0, [sp, #0xc]
;         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
700ae536: 9803         	ldr	r0, [sp, #0xc]
700ae538: f000 fa32    	bl	0x700ae9a0 <prvInitialiseMutex> @ imm = #0x464
;         return xNewQueue;
700ae53c: 9803         	ldr	r0, [sp, #0xc]
700ae53e: b006         	add	sp, #0x18
700ae540: bd80         	pop	{r7, pc}
		...
700ae54e: 0000         	movs	r0, r0

700ae550 <CSL_pktdmaGetChanPeerReg>:
; {
700ae550: b510         	push	{r4, lr}
700ae552: b086         	sub	sp, #0x18
700ae554: f8dd c020    	ldr.w	r12, [sp, #0x20]
700ae558: 9005         	str	r0, [sp, #0x14]
700ae55a: 9104         	str	r1, [sp, #0x10]
700ae55c: 9203         	str	r2, [sp, #0xc]
700ae55e: 9302         	str	r3, [sp, #0x8]
;     return CSL_pktdmaAccessChanPeerReg( pCfg, chanIdx, regIdx, pVal, chanDir, (bool)true );
700ae560: 9805         	ldr	r0, [sp, #0x14]
700ae562: 9904         	ldr	r1, [sp, #0x10]
700ae564: 9a02         	ldr	r2, [sp, #0x8]
700ae566: 9b08         	ldr	r3, [sp, #0x20]
700ae568: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700ae56c: 46ee         	mov	lr, sp
700ae56e: 2401         	movs	r4, #0x1
700ae570: f8ce 4004    	str.w	r4, [lr, #0x4]
700ae574: f8ce c000    	str.w	r12, [lr]
700ae578: f7f9 f87a    	bl	0x700a7670 <CSL_pktdmaAccessChanPeerReg> @ imm = #-0x6f0c
700ae57c: b006         	add	sp, #0x18
700ae57e: bd10         	pop	{r4, pc}

700ae580 <CSL_pktdmaSetChanPeerReg>:
; {
700ae580: b510         	push	{r4, lr}
700ae582: b086         	sub	sp, #0x18
700ae584: f8dd c020    	ldr.w	r12, [sp, #0x20]
700ae588: 9005         	str	r0, [sp, #0x14]
700ae58a: 9104         	str	r1, [sp, #0x10]
700ae58c: 9203         	str	r2, [sp, #0xc]
700ae58e: 9302         	str	r3, [sp, #0x8]
;     return CSL_pktdmaAccessChanPeerReg( pCfg, chanIdx, regIdx, pVal, chanDir, (bool)false );
700ae590: 9805         	ldr	r0, [sp, #0x14]
700ae592: 9904         	ldr	r1, [sp, #0x10]
700ae594: 9a02         	ldr	r2, [sp, #0x8]
700ae596: 9b08         	ldr	r3, [sp, #0x20]
700ae598: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700ae59c: 46ee         	mov	lr, sp
700ae59e: 2400         	movs	r4, #0x0
700ae5a0: f8ce 4004    	str.w	r4, [lr, #0x4]
700ae5a4: f8ce c000    	str.w	r12, [lr]
700ae5a8: f7f9 f862    	bl	0x700a7670 <CSL_pktdmaAccessChanPeerReg> @ imm = #-0x6f3c
700ae5ac: b006         	add	sp, #0x18
700ae5ae: bd10         	pop	{r4, pc}

700ae5b0 <UART_flowCtrlTrigLvlConfig>:
; {
700ae5b0: b580         	push	{r7, lr}
700ae5b2: b084         	sub	sp, #0x10
700ae5b4: 9003         	str	r0, [sp, #0xc]
700ae5b6: 9102         	str	r1, [sp, #0x8]
700ae5b8: 9201         	str	r2, [sp, #0x4]
700ae5ba: 2000         	movs	r0, #0x0
;     uint32_t tcrValue = 0;
700ae5bc: 9000         	str	r0, [sp]
;     tcrValue = rtsHaltFlag & UART_TCR_RX_FIFO_TRIG_HALT_MASK;
700ae5be: 9802         	ldr	r0, [sp, #0x8]
700ae5c0: f000 000f    	and	r0, r0, #0xf
700ae5c4: 9000         	str	r0, [sp]
;     tcrValue |= (rtsStartFlag <<
700ae5c6: 9801         	ldr	r0, [sp, #0x4]
700ae5c8: 0100         	lsls	r0, r0, #0x4
;                  UART_TCR_RX_FIFO_TRIG_START_SHIFT) &
700ae5ca: b2c1         	uxtb	r1, r0
;     tcrValue |= (rtsStartFlag <<
700ae5cc: 9800         	ldr	r0, [sp]
700ae5ce: 4308         	orrs	r0, r1
700ae5d0: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_TCR, tcrValue);
700ae5d2: 9803         	ldr	r0, [sp, #0xc]
700ae5d4: 3018         	adds	r0, #0x18
700ae5d6: 9900         	ldr	r1, [sp]
700ae5d8: f001 f94a    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x1294
; }
700ae5dc: b004         	add	sp, #0x10
700ae5de: bd80         	pop	{r7, pc}

700ae5e0 <_outc>:
700ae5e0: e5912008     	ldr	r2, [r1, #0x8]
700ae5e4: e5913004     	ldr	r3, [r1, #0x4]
700ae5e8: e1520003     	cmp	r2, r3
700ae5ec: 2a000004     	bhs	0x700ae604 <_outc+0x24> @ imm = #0x10
700ae5f0: e5912000     	ldr	r2, [r1]
700ae5f4: e2823001     	add	r3, r2, #1
700ae5f8: e5813000     	str	r3, [r1]
700ae5fc: e5c20000     	strb	r0, [r2]
700ae600: e5912008     	ldr	r2, [r1, #0x8]
700ae604: e2822001     	add	r2, r2, #1
700ae608: e5812008     	str	r2, [r1, #0x8]
700ae60c: e12fff1e     	bx	lr

700ae610 <CycleCounterP_getCount32>:
;         MRC     p15, #0, r0, c9, c13, 0  // read PMCCNTR
700ae610: ee190f1d     	mrc	p15, #0x0, r0, c9, c13, #0x0
;         bx      LR
700ae614: e12fff1e     	bx	lr

700ae618 <PmuP_setup>:
;         MCR     p15, #0, r0, c9, c12, 0 // write PMCR
700ae618: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;         bx      LR
700ae61c: e12fff1e     	bx	lr

700ae620 <PmuP_enableCounters>:
;         MCR     p15, #0, r0, c9, c12, 1  // write PMCNTENSET
700ae620: ee090f3c     	mcr	p15, #0x0, r0, c9, c12, #0x1
;         bx      LR
700ae624: e12fff1e     	bx	lr

700ae628 <PmuP_disableCounters>:
;         MCR     p15, #0, r0, c9, c12, 2  // write PMCNTENCLR
700ae628: ee090f5c     	mcr	p15, #0x0, r0, c9, c12, #0x2
;         bx      LR
700ae62c: e12fff1e     	bx	lr

700ae630 <PmuP_getOverflowStatus>:
;         MRC     p15, 0, r0, c9, c12, 3  // read PMOVSR
700ae630: ee190f7c     	mrc	p15, #0x0, r0, c9, c12, #0x3
;         bx      LR
700ae634: e12fff1e     	bx	lr

700ae638 <PmuP_clearOverflowStatus>:
;         MCR     p15, 0, r0, c9, c12, 3  // write PMOVSR
700ae638: ee090f7c     	mcr	p15, #0x0, r0, c9, c12, #0x3
;         bx      LR
700ae63c: e12fff1e     	bx	lr

700ae640 <CSL_secProxyGetMaxMsgSize>:
; {
700ae640: b580         	push	{r7, lr}
700ae642: b082         	sub	sp, #0x8
700ae644: 9001         	str	r0, [sp, #0x4]
;     if( pSecProxyCfg->maxMsgSize == (uint32_t)0U )
700ae646: 9801         	ldr	r0, [sp, #0x4]
700ae648: 6980         	ldr	r0, [r0, #0x18]
700ae64a: b960         	cbnz	r0, 0x700ae666 <CSL_secProxyGetMaxMsgSize+0x26> @ imm = #0x18
700ae64c: e7ff         	b	0x700ae64e <CSL_secProxyGetMaxMsgSize+0xe> @ imm = #-0x2
;         pSecProxyCfg->maxMsgSize = (uint32_t)CSL_REG32_FEXT( &pSecProxyCfg->pSecProxyRegs->CONFIG, SEC_PROXY_CONFIG_MSG_SIZE );
700ae64e: 9801         	ldr	r0, [sp, #0x4]
700ae650: 6800         	ldr	r0, [r0]
700ae652: 3004         	adds	r0, #0x4
700ae654: 2100         	movs	r1, #0x0
700ae656: f6cf 71ff    	movt	r1, #0xffff
700ae65a: 2210         	movs	r2, #0x10
700ae65c: f000 fc10    	bl	0x700aee80 <CSL_REG32_FEXT_RAW> @ imm = #0x820
700ae660: 9901         	ldr	r1, [sp, #0x4]
700ae662: 6188         	str	r0, [r1, #0x18]
;     }
700ae664: e7ff         	b	0x700ae666 <CSL_secProxyGetMaxMsgSize+0x26> @ imm = #-0x2
;     return pSecProxyCfg->maxMsgSize;
700ae666: 9801         	ldr	r0, [sp, #0x4]
700ae668: 6980         	ldr	r0, [r0, #0x18]
700ae66a: b002         	add	sp, #0x8
700ae66c: bd80         	pop	{r7, pc}
700ae66e: 0000         	movs	r0, r0

700ae670 <Sciclient_rmIaIsIa>:
; {
700ae670: b580         	push	{r7, lr}
700ae672: b082         	sub	sp, #0x8
700ae674: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ae678: 2000         	movs	r0, #0x0
;     bool r = false;
700ae67a: f88d 0005    	strb.w	r0, [sp, #0x5]
;     if (Sciclient_rmIaGetInst(id) != NULL) {
700ae67e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ae682: f7fd fe35    	bl	0x700ac2f0 <Sciclient_rmIaGetInst> @ imm = #-0x2396
700ae686: b120         	cbz	r0, 0x700ae692 <Sciclient_rmIaIsIa+0x22> @ imm = #0x8
700ae688: e7ff         	b	0x700ae68a <Sciclient_rmIaIsIa+0x1a> @ imm = #-0x2
700ae68a: 2001         	movs	r0, #0x1
;         r = true;
700ae68c: f88d 0005    	strb.w	r0, [sp, #0x5]
;     }
700ae690: e7ff         	b	0x700ae692 <Sciclient_rmIaIsIa+0x22> @ imm = #-0x2
;     return r;
700ae692: f89d 0005    	ldrb.w	r0, [sp, #0x5]
700ae696: f000 0001    	and	r0, r0, #0x1
700ae69a: b002         	add	sp, #0x8
700ae69c: bd80         	pop	{r7, pc}
700ae69e: 0000         	movs	r0, r0

700ae6a0 <Sciclient_rmIrIsIr>:
; {
700ae6a0: b580         	push	{r7, lr}
700ae6a2: b082         	sub	sp, #0x8
700ae6a4: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ae6a8: 2000         	movs	r0, #0x0
;     bool r = false;
700ae6aa: f88d 0005    	strb.w	r0, [sp, #0x5]
;     if (Sciclient_rmIrGetInst(id) != NULL) {
700ae6ae: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ae6b2: f7fd f935    	bl	0x700ab920 <Sciclient_rmIrGetInst> @ imm = #-0x2d96
700ae6b6: b120         	cbz	r0, 0x700ae6c2 <Sciclient_rmIrIsIr+0x22> @ imm = #0x8
700ae6b8: e7ff         	b	0x700ae6ba <Sciclient_rmIrIsIr+0x1a> @ imm = #-0x2
700ae6ba: 2001         	movs	r0, #0x1
;         r = true;
700ae6bc: f88d 0005    	strb.w	r0, [sp, #0x5]
;     }
700ae6c0: e7ff         	b	0x700ae6c2 <Sciclient_rmIrIsIr+0x22> @ imm = #-0x2
;     return r;
700ae6c2: f89d 0005    	ldrb.w	r0, [sp, #0x5]
700ae6c6: f000 0001    	and	r0, r0, #0x1
700ae6ca: b002         	add	sp, #0x8
700ae6cc: bd80         	pop	{r7, pc}
700ae6ce: 0000         	movs	r0, r0

700ae6d0 <Sciclient_secProxyReadThread32>:
; {
700ae6d0: b580         	push	{r7, lr}
700ae6d2: b084         	sub	sp, #0x10
700ae6d4: 9003         	str	r0, [sp, #0xc]
700ae6d6: f88d 100b    	strb.w	r1, [sp, #0xb]
;     ret = CSL_REG32_RD(CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg,thread,0U) +
700ae6da: 9903         	ldr	r1, [sp, #0xc]
700ae6dc: f242 5080    	movw	r0, #0x2580
700ae6e0: f2c7 000b    	movt	r0, #0x700b
700ae6e4: 2200         	movs	r2, #0x0
700ae6e6: f000 fdc3    	bl	0x700af270 <CSL_secProxyGetDataAddr> @ imm = #0xb86
700ae6ea: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700ae6ee: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ae6f2: f001 f915    	bl	0x700af920 <CSL_REG32_RD_RAW> @ imm = #0x122a
700ae6f6: 9001         	str	r0, [sp, #0x4]
;     return ret;
700ae6f8: 9801         	ldr	r0, [sp, #0x4]
700ae6fa: b004         	add	sp, #0x10
700ae6fc: bd80         	pop	{r7, pc}
700ae6fe: 0000         	movs	r0, r0

700ae700 <System_init>:
; {
700ae700: b580         	push	{r7, lr}
;     Dpl_init();
700ae702: f7fe ff55    	bl	0x700ad5b0 <Dpl_init>   @ imm = #-0x1156
;         retVal = Sciclient_init(CSL_CORE_ID_R5FSS0_0);
700ae706: 2001         	movs	r0, #0x1
700ae708: f7fa fe6a    	bl	0x700a93e0 <Sciclient_init> @ imm = #-0x532c
;         DebugP_assertNoLog(SystemP_SUCCESS == retVal);
700ae70c: fab0 f080    	clz	r0, r0
700ae710: 0940         	lsrs	r0, r0, #0x5
700ae712: f002 fc65    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x28ca
;     CycleCounterP_init(SOC_getSelfCpuClk());
700ae716: f000 fbe3    	bl	0x700aeee0 <SOC_getSelfCpuClk> @ imm = #0x7c6
700ae71a: f7f9 fda9    	bl	0x700a8270 <CycleCounterP_init> @ imm = #-0x64ae
;     PowerClock_init();
700ae71e: f7fb fe9f    	bl	0x700aa460 <PowerClock_init> @ imm = #-0x42c2
;     Pinmux_init();
700ae722: f000 fc4d    	bl	0x700aefc0 <Pinmux_init> @ imm = #0x89a
;     UART_init();
700ae726: e8bd 4080    	pop.w	{r7, lr}
700ae72a: f7f9 b981    	b.w	0x700a7a30 <UART_init>  @ imm = #-0x6cfe
700ae72e: 0000         	movs	r0, r0

700ae730 <_is_digit>:
; {
700ae730: b082         	sub	sp, #0x8
700ae732: f88d 0007    	strb.w	r0, [sp, #0x7]
;   return (ch >= '0') && (ch <= '9');
700ae736: f89d 1007    	ldrb.w	r1, [sp, #0x7]
700ae73a: 2000         	movs	r0, #0x0
700ae73c: 2930         	cmp	r1, #0x30
700ae73e: 9000         	str	r0, [sp]
700ae740: db08         	blt	0x700ae754 <_is_digit+0x24> @ imm = #0x10
700ae742: e7ff         	b	0x700ae744 <_is_digit+0x14> @ imm = #-0x2
700ae744: f89d 1007    	ldrb.w	r1, [sp, #0x7]
700ae748: 2000         	movs	r0, #0x0
700ae74a: 293a         	cmp	r1, #0x3a
700ae74c: bfb8         	it	lt
700ae74e: 2001         	movlt	r0, #0x1
700ae750: 9000         	str	r0, [sp]
700ae752: e7ff         	b	0x700ae754 <_is_digit+0x24> @ imm = #-0x2
700ae754: 9800         	ldr	r0, [sp]
;   return (ch >= '0') && (ch <= '9');
700ae756: f000 0001    	and	r0, r0, #0x1
700ae75a: b002         	add	sp, #0x8
700ae75c: 4770         	bx	lr
700ae75e: 0000         	movs	r0, r0

700ae760 <prvIsQueueFull>:
; {
700ae760: b580         	push	{r7, lr}
700ae762: b082         	sub	sp, #0x8
700ae764: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700ae766: f7ff feb3    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #-0x29a
;         if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
700ae76a: 9801         	ldr	r0, [sp, #0x4]
700ae76c: 6b80         	ldr	r0, [r0, #0x38]
700ae76e: 9901         	ldr	r1, [sp, #0x4]
700ae770: 6bc9         	ldr	r1, [r1, #0x3c]
700ae772: 4288         	cmp	r0, r1
700ae774: d103         	bne	0x700ae77e <prvIsQueueFull+0x1e> @ imm = #0x6
700ae776: e7ff         	b	0x700ae778 <prvIsQueueFull+0x18> @ imm = #-0x2
700ae778: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
700ae77a: 9000         	str	r0, [sp]
;         }
700ae77c: e002         	b	0x700ae784 <prvIsQueueFull+0x24> @ imm = #0x4
700ae77e: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
700ae780: 9000         	str	r0, [sp]
700ae782: e7ff         	b	0x700ae784 <prvIsQueueFull+0x24> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700ae784: f7fe ff64    	bl	0x700ad650 <vTaskExitCritical> @ imm = #-0x1138
;     return xReturn;
700ae788: 9800         	ldr	r0, [sp]
700ae78a: b002         	add	sp, #0x8
700ae78c: bd80         	pop	{r7, pc}
700ae78e: 0000         	movs	r0, r0

700ae790 <prvTaskCheckFreeStackSpace>:
; prvTaskCheckFreeStackSpace(const uint8_t *pucStackByte) {
700ae790: b082         	sub	sp, #0x8
700ae792: 9001         	str	r0, [sp, #0x4]
700ae794: 2000         	movs	r0, #0x0
;   uint32_t ulCount = 0U;
700ae796: 9000         	str	r0, [sp]
;   while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
700ae798: e7ff         	b	0x700ae79a <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x2
700ae79a: 9801         	ldr	r0, [sp, #0x4]
700ae79c: 7800         	ldrb	r0, [r0]
700ae79e: 28a5         	cmp	r0, #0xa5
700ae7a0: d107         	bne	0x700ae7b2 <prvTaskCheckFreeStackSpace+0x22> @ imm = #0xe
700ae7a2: e7ff         	b	0x700ae7a4 <prvTaskCheckFreeStackSpace+0x14> @ imm = #-0x2
;     pucStackByte -= portSTACK_GROWTH;
700ae7a4: 9801         	ldr	r0, [sp, #0x4]
700ae7a6: 3001         	adds	r0, #0x1
700ae7a8: 9001         	str	r0, [sp, #0x4]
;     ulCount++;
700ae7aa: 9800         	ldr	r0, [sp]
700ae7ac: 3001         	adds	r0, #0x1
700ae7ae: 9000         	str	r0, [sp]
;   while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
700ae7b0: e7f3         	b	0x700ae79a <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x1a
;   ulCount /=
700ae7b2: 9800         	ldr	r0, [sp]
700ae7b4: 0880         	lsrs	r0, r0, #0x2
700ae7b6: 9000         	str	r0, [sp]
;   return (configSTACK_DEPTH_TYPE)ulCount;
700ae7b8: 9800         	ldr	r0, [sp]
700ae7ba: b002         	add	sp, #0x8
700ae7bc: 4770         	bx	lr
700ae7be: 0000         	movs	r0, r0

700ae7c0 <tm_queue_send_from_isr>:
; {
700ae7c0: b580         	push	{r7, lr}
700ae7c2: b082         	sub	sp, #0x8
;    status = xQueueSendToBackFromISR(tm_queue_array[queue_id], (const void*) message_ptr, &xHigherPriorityTaskWoken);
700ae7c4: f245 2234    	movw	r2, #0x5234
700ae7c8: 2300         	movs	r3, #0x0
700ae7ca: f2c7 0208    	movt	r2, #0x7008
700ae7ce: f852 0020    	ldr.w	r0, [r2, r0, lsl #2]
700ae7d2: aa01         	add	r2, sp, #0x4
;    status = xQueueSendToBackFromISR(tm_queue_array[queue_id], (const void*) message_ptr, &xHigherPriorityTaskWoken);
700ae7d4: f7fa f804    	bl	0x700a87e0 <xQueueGenericSendFromISR> @ imm = #-0x5ff8
;    if (status != pdTRUE)
700ae7d8: 2801         	cmp	r0, #0x1
700ae7da: d105         	bne	0x700ae7e8 <tm_queue_send_from_isr+0x28> @ imm = #0xa
;    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
700ae7dc: 9801         	ldr	r0, [sp, #0x4]
700ae7de: f000 fd87    	bl	0x700af2f0 <vPortYeildFromISR> @ imm = #0xb0e
700ae7e2: 2000         	movs	r0, #0x0
; }
700ae7e4: b002         	add	sp, #0x8
700ae7e6: bd80         	pop	{r7, pc}
700ae7e8: 2001         	movs	r0, #0x1
; }
700ae7ea: b002         	add	sp, #0x8
700ae7ec: bd80         	pop	{r7, pc}
700ae7ee: 0000         	movs	r0, r0

700ae7f0 <vListInitialise>:
; {
700ae7f0: b081         	sub	sp, #0x4
700ae7f2: 9000         	str	r0, [sp]
;     pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700ae7f4: 9900         	ldr	r1, [sp]
700ae7f6: f101 0008    	add.w	r0, r1, #0x8
700ae7fa: 6048         	str	r0, [r1, #0x4]
;     pxList->xListEnd.xItemValue = portMAX_DELAY;
700ae7fc: 9900         	ldr	r1, [sp]
700ae7fe: f04f 30ff    	mov.w	r0, #0xffffffff
700ae802: 6088         	str	r0, [r1, #0x8]
;     pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700ae804: 9900         	ldr	r1, [sp]
700ae806: f101 0008    	add.w	r0, r1, #0x8
700ae80a: 60c8         	str	r0, [r1, #0xc]
;     pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700ae80c: 9900         	ldr	r1, [sp]
700ae80e: f101 0008    	add.w	r0, r1, #0x8
700ae812: 6108         	str	r0, [r1, #0x10]
;     pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
700ae814: 9900         	ldr	r1, [sp]
700ae816: 2000         	movs	r0, #0x0
700ae818: 6008         	str	r0, [r1]
; }
700ae81a: b001         	add	sp, #0x4
700ae81c: 4770         	bx	lr
700ae81e: 0000         	movs	r0, r0

700ae820 <CSL_bcdmaGetRxRT>:
; {
700ae820: b580         	push	{r7, lr}
700ae822: b084         	sub	sp, #0x10
700ae824: 9003         	str	r0, [sp, #0xc]
700ae826: 9102         	str	r1, [sp, #0x8]
700ae828: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_RT, chanIdx, (void *)pRT );
700ae82a: 9803         	ldr	r0, [sp, #0xc]
700ae82c: 9a02         	ldr	r2, [sp, #0x8]
700ae82e: 9b01         	ldr	r3, [sp, #0x4]
700ae830: 2107         	movs	r1, #0x7
700ae832: f7fc fa7d    	bl	0x700aad30 <CSL_bcdmaDoChanOp> @ imm = #-0x3b06
700ae836: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700ae838: 9800         	ldr	r0, [sp]
700ae83a: b120         	cbz	r0, 0x700ae846 <CSL_bcdmaGetRxRT+0x26> @ imm = #0x8
700ae83c: e7ff         	b	0x700ae83e <CSL_bcdmaGetRxRT+0x1e> @ imm = #-0x2
700ae83e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ae842: 9000         	str	r0, [sp]
;     }
700ae844: e7ff         	b	0x700ae846 <CSL_bcdmaGetRxRT+0x26> @ imm = #-0x2
;     return retVal;
700ae846: 9800         	ldr	r0, [sp]
700ae848: b004         	add	sp, #0x10
700ae84a: bd80         	pop	{r7, pc}
700ae84c: 0000         	movs	r0, r0
700ae84e: 0000         	movs	r0, r0

700ae850 <CSL_bcdmaGetTxRT>:
; {
700ae850: b580         	push	{r7, lr}
700ae852: b084         	sub	sp, #0x10
700ae854: 9003         	str	r0, [sp, #0xc]
700ae856: 9102         	str	r1, [sp, #0x8]
700ae858: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_RT, chanIdx, (void *)pRT );
700ae85a: 9803         	ldr	r0, [sp, #0xc]
700ae85c: 9a02         	ldr	r2, [sp, #0x8]
700ae85e: 9b01         	ldr	r3, [sp, #0x4]
700ae860: 2107         	movs	r1, #0x7
700ae862: f7fc fa65    	bl	0x700aad30 <CSL_bcdmaDoChanOp> @ imm = #-0x3b36
700ae866: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700ae868: 9800         	ldr	r0, [sp]
700ae86a: b120         	cbz	r0, 0x700ae876 <CSL_bcdmaGetTxRT+0x26> @ imm = #0x8
700ae86c: e7ff         	b	0x700ae86e <CSL_bcdmaGetTxRT+0x1e> @ imm = #-0x2
700ae86e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ae872: 9000         	str	r0, [sp]
;     }
700ae874: e7ff         	b	0x700ae876 <CSL_bcdmaGetTxRT+0x26> @ imm = #-0x2
;     return retVal;
700ae876: 9800         	ldr	r0, [sp]
700ae878: b004         	add	sp, #0x10
700ae87a: bd80         	pop	{r7, pc}
700ae87c: 0000         	movs	r0, r0
700ae87e: 0000         	movs	r0, r0

700ae880 <CSL_bcdmaSetRxRT>:
; {
700ae880: b580         	push	{r7, lr}
700ae882: b084         	sub	sp, #0x10
700ae884: 9003         	str	r0, [sp, #0xc]
700ae886: 9102         	str	r1, [sp, #0x8]
700ae888: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_RT, chanIdx, (void *)pRT );
700ae88a: 9803         	ldr	r0, [sp, #0xc]
700ae88c: 9a02         	ldr	r2, [sp, #0x8]
700ae88e: 9b01         	ldr	r3, [sp, #0x4]
700ae890: 2108         	movs	r1, #0x8
700ae892: f7fc fa4d    	bl	0x700aad30 <CSL_bcdmaDoChanOp> @ imm = #-0x3b66
700ae896: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700ae898: 9800         	ldr	r0, [sp]
700ae89a: b120         	cbz	r0, 0x700ae8a6 <CSL_bcdmaSetRxRT+0x26> @ imm = #0x8
700ae89c: e7ff         	b	0x700ae89e <CSL_bcdmaSetRxRT+0x1e> @ imm = #-0x2
700ae89e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ae8a2: 9000         	str	r0, [sp]
;     }
700ae8a4: e7ff         	b	0x700ae8a6 <CSL_bcdmaSetRxRT+0x26> @ imm = #-0x2
;     return retVal;
700ae8a6: 9800         	ldr	r0, [sp]
700ae8a8: b004         	add	sp, #0x10
700ae8aa: bd80         	pop	{r7, pc}
700ae8ac: 0000         	movs	r0, r0
700ae8ae: 0000         	movs	r0, r0

700ae8b0 <CSL_bcdmaSetTxRT>:
; {
700ae8b0: b580         	push	{r7, lr}
700ae8b2: b084         	sub	sp, #0x10
700ae8b4: 9003         	str	r0, [sp, #0xc]
700ae8b6: 9102         	str	r1, [sp, #0x8]
700ae8b8: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_RT, chanIdx, (void *)pRT );
700ae8ba: 9803         	ldr	r0, [sp, #0xc]
700ae8bc: 9a02         	ldr	r2, [sp, #0x8]
700ae8be: 9b01         	ldr	r3, [sp, #0x4]
700ae8c0: 2108         	movs	r1, #0x8
700ae8c2: f7fc fa35    	bl	0x700aad30 <CSL_bcdmaDoChanOp> @ imm = #-0x3b96
700ae8c6: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700ae8c8: 9800         	ldr	r0, [sp]
700ae8ca: b120         	cbz	r0, 0x700ae8d6 <CSL_bcdmaSetTxRT+0x26> @ imm = #0x8
700ae8cc: e7ff         	b	0x700ae8ce <CSL_bcdmaSetTxRT+0x1e> @ imm = #-0x2
700ae8ce: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ae8d2: 9000         	str	r0, [sp]
;     }
700ae8d4: e7ff         	b	0x700ae8d6 <CSL_bcdmaSetTxRT+0x26> @ imm = #-0x2
;     return retVal;
700ae8d6: 9800         	ldr	r0, [sp]
700ae8d8: b004         	add	sp, #0x10
700ae8da: bd80         	pop	{r7, pc}
700ae8dc: 0000         	movs	r0, r0
700ae8de: 0000         	movs	r0, r0

700ae8e0 <DebugP_logZoneEnable>:
; {
700ae8e0: b580         	push	{r7, lr}
700ae8e2: b084         	sub	sp, #0x10
700ae8e4: 9003         	str	r0, [sp, #0xc]
;     oldIntState = HwiP_disable();
700ae8e6: f001 eebc    	blx	0x700b0660 <HwiP_disable> @ imm = #0x1d78
700ae8ea: 9001         	str	r0, [sp, #0x4]
;     oldZoneMask = gDebugLogZone;
700ae8ec: f242 6190    	movw	r1, #0x2690
700ae8f0: f2c7 010b    	movt	r1, #0x700b
700ae8f4: 6808         	ldr	r0, [r1]
700ae8f6: 9002         	str	r0, [sp, #0x8]
;     gDebugLogZone = gDebugLogZone | (logZoneMask);
700ae8f8: 6808         	ldr	r0, [r1]
700ae8fa: 9a03         	ldr	r2, [sp, #0xc]
700ae8fc: 4310         	orrs	r0, r2
700ae8fe: 6008         	str	r0, [r1]
;     HwiP_restore(oldIntState);
700ae900: 9801         	ldr	r0, [sp, #0x4]
700ae902: f001 eece    	blx	0x700b06a0 <HwiP_restore> @ imm = #0x1d9c
;     return oldZoneMask;
700ae906: 9802         	ldr	r0, [sp, #0x8]
700ae908: b004         	add	sp, #0x10
700ae90a: bd80         	pop	{r7, pc}
700ae90c: 0000         	movs	r0, r0
700ae90e: 0000         	movs	r0, r0

700ae910 <Sciclient_getIrAddr>:
; {
700ae910: b580         	push	{r7, lr}
700ae912: b084         	sub	sp, #0x10
700ae914: 9003         	str	r0, [sp, #0xc]
700ae916: 9102         	str	r1, [sp, #0x8]
;     int_ctrl_reg = (uint32_t *)(addr + Sciclient_rmIrIntControlReg(i));
700ae918: 9803         	ldr	r0, [sp, #0xc]
700ae91a: 9000         	str	r0, [sp]
700ae91c: f8bd 0008    	ldrh.w	r0, [sp, #0x8]
700ae920: f000 fe9e    	bl	0x700af660 <Sciclient_rmIrIntControlReg> @ imm = #0xd3c
700ae924: 4601         	mov	r1, r0
700ae926: 9800         	ldr	r0, [sp]
700ae928: 4408         	add	r0, r1
700ae92a: 9001         	str	r0, [sp, #0x4]
;     int_ctrl_reg = (uint32_t *)AddrTranslateP_getLocalAddr( (uint64_t)int_ctrl_reg);
700ae92c: 9801         	ldr	r0, [sp, #0x4]
700ae92e: 2100         	movs	r1, #0x0
700ae930: f7f6 ffe6    	bl	0x700a5900 <AddrTranslateP_getLocalAddr> @ imm = #-0x9034
700ae934: 9001         	str	r0, [sp, #0x4]
;     return int_ctrl_reg;
700ae936: 9801         	ldr	r0, [sp, #0x4]
700ae938: b004         	add	sp, #0x10
700ae93a: bd80         	pop	{r7, pc}
700ae93c: 0000         	movs	r0, r0
700ae93e: 0000         	movs	r0, r0

700ae940 <TaskP_calcCounterDiff>:
; {
700ae940: b083         	sub	sp, #0xc
700ae942: 9002         	str	r0, [sp, #0x8]
700ae944: 9101         	str	r1, [sp, #0x4]
;     if(cur >= last)
700ae946: 9802         	ldr	r0, [sp, #0x8]
700ae948: 9901         	ldr	r1, [sp, #0x4]
700ae94a: 4288         	cmp	r0, r1
700ae94c: d305         	blo	0x700ae95a <TaskP_calcCounterDiff+0x1a> @ imm = #0xa
700ae94e: e7ff         	b	0x700ae950 <TaskP_calcCounterDiff+0x10> @ imm = #-0x2
;         delta = cur - last;
700ae950: 9802         	ldr	r0, [sp, #0x8]
700ae952: 9901         	ldr	r1, [sp, #0x4]
700ae954: 1a40         	subs	r0, r0, r1
700ae956: 9000         	str	r0, [sp]
;     }
700ae958: e005         	b	0x700ae966 <TaskP_calcCounterDiff+0x26> @ imm = #0xa
;         delta = (  0xFFFFFFFFU - last ) + cur;
700ae95a: 9801         	ldr	r0, [sp, #0x4]
700ae95c: 9902         	ldr	r1, [sp, #0x8]
700ae95e: 43c0         	mvns	r0, r0
700ae960: 4408         	add	r0, r1
700ae962: 9000         	str	r0, [sp]
700ae964: e7ff         	b	0x700ae966 <TaskP_calcCounterDiff+0x26> @ imm = #-0x2
;     return delta;
700ae966: 9800         	ldr	r0, [sp]
700ae968: b003         	add	sp, #0xc
700ae96a: 4770         	bx	lr
700ae96c: 0000         	movs	r0, r0
700ae96e: 0000         	movs	r0, r0

700ae970 <TimerP_clearOverflowInt>:
; {
700ae970: b083         	sub	sp, #0xc
700ae972: 9002         	str	r0, [sp, #0x8]
700ae974: 2002         	movs	r0, #0x2
;     uint32_t value = (0x1U << TIMER_OVF_INT_SHIFT);
700ae976: 9000         	str	r0, [sp]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_STATUS);
700ae978: 9802         	ldr	r0, [sp, #0x8]
700ae97a: 3028         	adds	r0, #0x28
700ae97c: 9001         	str	r0, [sp, #0x4]
;     *addr = value;
700ae97e: 9800         	ldr	r0, [sp]
700ae980: 9901         	ldr	r1, [sp, #0x4]
700ae982: 6008         	str	r0, [r1]
;     if((*addr & value) != 0U)
700ae984: 9801         	ldr	r0, [sp, #0x4]
700ae986: 6800         	ldr	r0, [r0]
700ae988: 9900         	ldr	r1, [sp]
700ae98a: 4208         	tst	r0, r1
700ae98c: d004         	beq	0x700ae998 <TimerP_clearOverflowInt+0x28> @ imm = #0x8
700ae98e: e7ff         	b	0x700ae990 <TimerP_clearOverflowInt+0x20> @ imm = #-0x2
;         *addr = value;
700ae990: 9800         	ldr	r0, [sp]
700ae992: 9901         	ldr	r1, [sp, #0x4]
700ae994: 6008         	str	r0, [r1]
;     }
700ae996: e7ff         	b	0x700ae998 <TimerP_clearOverflowInt+0x28> @ imm = #-0x2
; }
700ae998: b003         	add	sp, #0xc
700ae99a: 4770         	bx	lr
700ae99c: 0000         	movs	r0, r0
700ae99e: 0000         	movs	r0, r0

700ae9a0 <prvInitialiseMutex>:
;     {
700ae9a0: b580         	push	{r7, lr}
700ae9a2: b082         	sub	sp, #0x8
700ae9a4: 9001         	str	r0, [sp, #0x4]
;         if( pxNewQueue != NULL )
700ae9a6: 9801         	ldr	r0, [sp, #0x4]
700ae9a8: b168         	cbz	r0, 0x700ae9c6 <prvInitialiseMutex+0x26> @ imm = #0x1a
700ae9aa: e7ff         	b	0x700ae9ac <prvInitialiseMutex+0xc> @ imm = #-0x2
;             pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
700ae9ac: 9801         	ldr	r0, [sp, #0x4]
700ae9ae: 2300         	movs	r3, #0x0
700ae9b0: 6083         	str	r3, [r0, #0x8]
;             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
700ae9b2: 9801         	ldr	r0, [sp, #0x4]
700ae9b4: 6003         	str	r3, [r0]
;             pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
700ae9b6: 9801         	ldr	r0, [sp, #0x4]
700ae9b8: 60c3         	str	r3, [r0, #0xc]
;             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
700ae9ba: 9801         	ldr	r0, [sp, #0x4]
700ae9bc: 4619         	mov	r1, r3
700ae9be: 461a         	mov	r2, r3
700ae9c0: f7f4 fb96    	bl	0x700a30f0 <xQueueGenericSend> @ imm = #-0xb8d4
;         }
700ae9c4: e000         	b	0x700ae9c8 <prvInitialiseMutex+0x28> @ imm = #0x0
700ae9c6: e7ff         	b	0x700ae9c8 <prvInitialiseMutex+0x28> @ imm = #-0x2
;     }
700ae9c8: b002         	add	sp, #0x8
700ae9ca: bd80         	pop	{r7, pc}
700ae9cc: 0000         	movs	r0, r0
700ae9ce: 0000         	movs	r0, r0

700ae9d0 <pvTaskIncrementMutexHeldCount>:
;   if (pxCurrentTCB != NULL) {
700ae9d0: f242 60bc    	movw	r0, #0x26bc
700ae9d4: f2c7 000b    	movt	r0, #0x700b
700ae9d8: 6800         	ldr	r0, [r0]
700ae9da: b148         	cbz	r0, 0x700ae9f0 <pvTaskIncrementMutexHeldCount+0x20> @ imm = #0x12
700ae9dc: e7ff         	b	0x700ae9de <pvTaskIncrementMutexHeldCount+0xe> @ imm = #-0x2
;     (pxCurrentTCB->uxMutexesHeld)++;
700ae9de: f242 60bc    	movw	r0, #0x26bc
700ae9e2: f2c7 000b    	movt	r0, #0x700b
700ae9e6: 6801         	ldr	r1, [r0]
700ae9e8: 6e48         	ldr	r0, [r1, #0x64]
700ae9ea: 3001         	adds	r0, #0x1
700ae9ec: 6648         	str	r0, [r1, #0x64]
;   }
700ae9ee: e7ff         	b	0x700ae9f0 <pvTaskIncrementMutexHeldCount+0x20> @ imm = #-0x2
;   return pxCurrentTCB;
700ae9f0: f242 60bc    	movw	r0, #0x26bc
700ae9f4: f2c7 000b    	movt	r0, #0x700b
700ae9f8: 6800         	ldr	r0, [r0]
700ae9fa: 4770         	bx	lr
700ae9fc: 0000         	movs	r0, r0
700ae9fe: 0000         	movs	r0, r0

700aea00 <vApplicationGetIdleTaskMemory>:
;                                    uint32_t *pulIdleTaskStackSize) {
700aea00: b083         	sub	sp, #0xc
700aea02: 9002         	str	r0, [sp, #0x8]
700aea04: 9101         	str	r1, [sp, #0x4]
700aea06: 9200         	str	r2, [sp]
;   *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
700aea08: 9902         	ldr	r1, [sp, #0x8]
700aea0a: f644 60b0    	movw	r0, #0x4eb0
700aea0e: f2c7 0008    	movt	r0, #0x7008
700aea12: 6008         	str	r0, [r1]
;   *ppxIdleTaskStackBuffer = uxIdleTaskStack;
700aea14: 9901         	ldr	r1, [sp, #0x4]
700aea16: f242 0080    	movw	r0, #0x2080
700aea1a: f2c7 0008    	movt	r0, #0x7008
700aea1e: 6008         	str	r0, [r1]
;   *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
700aea20: 9900         	ldr	r1, [sp]
700aea22: f44f 6080    	mov.w	r0, #0x400
700aea26: 6008         	str	r0, [r1]
; }
700aea28: b003         	add	sp, #0xc
700aea2a: 4770         	bx	lr
700aea2c: 0000         	movs	r0, r0
700aea2e: 0000         	movs	r0, r0

700aea30 <vApplicationGetTimerTaskMemory>:
;                                     uint32_t *pulTimerTaskStackSize) {
700aea30: b083         	sub	sp, #0xc
700aea32: 9002         	str	r0, [sp, #0x8]
700aea34: 9101         	str	r1, [sp, #0x4]
700aea36: 9200         	str	r2, [sp]
;   *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
700aea38: 9902         	ldr	r1, [sp, #0x8]
700aea3a: f644 7038    	movw	r0, #0x4f38
700aea3e: f2c7 0008    	movt	r0, #0x7008
700aea42: 6008         	str	r0, [r1]
;   *ppxTimerTaskStackBuffer = uxTimerTaskStack;
700aea44: 9901         	ldr	r1, [sp, #0x4]
700aea46: f643 508c    	movw	r0, #0x3d8c
700aea4a: f2c7 0008    	movt	r0, #0x7008
700aea4e: 6008         	str	r0, [r1]
;   *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
700aea50: 9900         	ldr	r1, [sp]
700aea52: f44f 7080    	mov.w	r0, #0x100
700aea56: 6008         	str	r0, [r1]
; }
700aea58: b003         	add	sp, #0xc
700aea5a: 4770         	bx	lr
700aea5c: 0000         	movs	r0, r0
700aea5e: 0000         	movs	r0, r0

700aea60 <Sciclient_rmParamIsValid>:
; {
700aea60: b083         	sub	sp, #0xc
700aea62: 9002         	str	r0, [sp, #0x8]
700aea64: 9101         	str	r1, [sp, #0x4]
700aea66: 2000         	movs	r0, #0x0
;     bool r = false;
700aea68: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((valid_params & param_mask) != 0) {
700aea6c: 9802         	ldr	r0, [sp, #0x8]
700aea6e: 9901         	ldr	r1, [sp, #0x4]
700aea70: 4208         	tst	r0, r1
700aea72: d004         	beq	0x700aea7e <Sciclient_rmParamIsValid+0x1e> @ imm = #0x8
700aea74: e7ff         	b	0x700aea76 <Sciclient_rmParamIsValid+0x16> @ imm = #-0x2
700aea76: 2001         	movs	r0, #0x1
;         r = true;
700aea78: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aea7c: e7ff         	b	0x700aea7e <Sciclient_rmParamIsValid+0x1e> @ imm = #-0x2
;     return r;
700aea7e: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aea82: f000 0001    	and	r0, r0, #0x1
700aea86: b003         	add	sp, #0xc
700aea88: 4770         	bx	lr
700aea8a: 0000         	movs	r0, r0
700aea8c: 0000         	movs	r0, r0
700aea8e: 0000         	movs	r0, r0

700aea90 <Sciclient_rmPsIsEmpty>:
; {
700aea90: b081         	sub	sp, #0x4
700aea92: 2001         	movs	r0, #0x1
;     bool e = true;
700aea94: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if (gPstack.psp != 0) {
700aea98: f241 0058    	movw	r0, #0x1058
700aea9c: f2c7 0008    	movt	r0, #0x7008
700aeaa0: 8c80         	ldrh	r0, [r0, #0x24]
700aeaa2: b120         	cbz	r0, 0x700aeaae <Sciclient_rmPsIsEmpty+0x1e> @ imm = #0x8
700aeaa4: e7ff         	b	0x700aeaa6 <Sciclient_rmPsIsEmpty+0x16> @ imm = #-0x2
700aeaa6: 2000         	movs	r0, #0x0
;         e = false;
700aeaa8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aeaac: e7ff         	b	0x700aeaae <Sciclient_rmPsIsEmpty+0x1e> @ imm = #-0x2
;     return e;
700aeaae: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aeab2: f000 0001    	and	r0, r0, #0x1
700aeab6: b001         	add	sp, #0x4
700aeab8: 4770         	bx	lr
700aeaba: 0000         	movs	r0, r0
700aeabc: 0000         	movs	r0, r0
700aeabe: 0000         	movs	r0, r0

700aeac0 <UART_Transaction_init>:
; {
700aeac0: b081         	sub	sp, #0x4
700aeac2: 9000         	str	r0, [sp]
;     if(trans != NULL)
700aeac4: 9800         	ldr	r0, [sp]
700aeac6: b170         	cbz	r0, 0x700aeae6 <UART_Transaction_init+0x26> @ imm = #0x1c
700aeac8: e7ff         	b	0x700aeaca <UART_Transaction_init+0xa> @ imm = #-0x2
;         trans->buf              = NULL;
700aeaca: 9900         	ldr	r1, [sp]
700aeacc: 2000         	movs	r0, #0x0
700aeace: 6008         	str	r0, [r1]
;         trans->count            = 0U;
700aead0: 9900         	ldr	r1, [sp]
700aead2: 6048         	str	r0, [r1, #0x4]
;         trans->timeout          = SystemP_WAIT_FOREVER;
700aead4: 9a00         	ldr	r2, [sp]
700aead6: f04f 31ff    	mov.w	r1, #0xffffffff
700aeada: 6091         	str	r1, [r2, #0x8]
;         trans->status           = UART_STATUS_SUCCESS;
700aeadc: 9900         	ldr	r1, [sp]
700aeade: 60c8         	str	r0, [r1, #0xc]
;         trans->args             = NULL;
700aeae0: 9900         	ldr	r1, [sp]
700aeae2: 6108         	str	r0, [r1, #0x10]
;     }
700aeae4: e7ff         	b	0x700aeae6 <UART_Transaction_init+0x26> @ imm = #-0x2
; }
700aeae6: b001         	add	sp, #0x4
700aeae8: 4770         	bx	lr
700aeaea: 0000         	movs	r0, r0
700aeaec: 0000         	movs	r0, r0
700aeaee: 0000         	movs	r0, r0

700aeaf0 <UART_intr2Disable>:
; {
700aeaf0: b580         	push	{r7, lr}
700aeaf2: b084         	sub	sp, #0x10
700aeaf4: 9003         	str	r0, [sp, #0xc]
700aeaf6: 9102         	str	r1, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_IER2, HW_RD_REG32(baseAddr + UART_IER2) &
700aeaf8: 9803         	ldr	r0, [sp, #0xc]
700aeafa: 306c         	adds	r0, #0x6c
700aeafc: 9001         	str	r0, [sp, #0x4]
700aeafe: f000 feaf    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0xd5e
700aeb02: 4601         	mov	r1, r0
700aeb04: 9801         	ldr	r0, [sp, #0x4]
700aeb06: 9b02         	ldr	r3, [sp, #0x8]
700aeb08: f06f 0203    	mvn	r2, #0x3
700aeb0c: ea62 0203    	orn	r2, r2, r3
700aeb10: 4011         	ands	r1, r2
700aeb12: f000 fead    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0xd5a
; }
700aeb16: b004         	add	sp, #0x10
700aeb18: bd80         	pop	{r7, pc}
700aeb1a: 0000         	movs	r0, r0
700aeb1c: 0000         	movs	r0, r0
700aeb1e: 0000         	movs	r0, r0

700aeb20 <UART_lld_Transaction_init>:
; {
700aeb20: b081         	sub	sp, #0x4
700aeb22: 9000         	str	r0, [sp]
;     if(trans != NULL)
700aeb24: 9800         	ldr	r0, [sp]
700aeb26: b170         	cbz	r0, 0x700aeb46 <UART_lld_Transaction_init+0x26> @ imm = #0x1c
700aeb28: e7ff         	b	0x700aeb2a <UART_lld_Transaction_init+0xa> @ imm = #-0x2
;         trans->buf              = NULL;
700aeb2a: 9900         	ldr	r1, [sp]
700aeb2c: 2000         	movs	r0, #0x0
700aeb2e: 6008         	str	r0, [r1]
;         trans->count            = 0U;
700aeb30: 9900         	ldr	r1, [sp]
700aeb32: 6048         	str	r0, [r1, #0x4]
;         trans->timeout          = UART_WAIT_FOREVER;
700aeb34: 9a00         	ldr	r2, [sp]
700aeb36: f04f 31ff    	mov.w	r1, #0xffffffff
700aeb3a: 6091         	str	r1, [r2, #0x8]
;         trans->status           = UART_STATUS_SUCCESS;
700aeb3c: 9900         	ldr	r1, [sp]
700aeb3e: 60c8         	str	r0, [r1, #0xc]
;         trans->args             = NULL;
700aeb40: 9900         	ldr	r1, [sp]
700aeb42: 6108         	str	r0, [r1, #0x10]
;     }
700aeb44: e7ff         	b	0x700aeb46 <UART_lld_Transaction_init+0x26> @ imm = #-0x2
; }
700aeb46: b001         	add	sp, #0x4
700aeb48: 4770         	bx	lr
700aeb4a: 0000         	movs	r0, r0
700aeb4c: 0000         	movs	r0, r0
700aeb4e: 0000         	movs	r0, r0

700aeb50 <UART_lld_dmaWrite>:
; {
700aeb50: b580         	push	{r7, lr}
700aeb52: b084         	sub	sp, #0x10
700aeb54: 9003         	str	r0, [sp, #0xc]
700aeb56: 9102         	str	r1, [sp, #0x8]
700aeb58: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700aeb5a: 9001         	str	r0, [sp, #0x4]
;     status = UART_udmaConfigPdmaTx(hUart, transaction);
700aeb5c: 9803         	ldr	r0, [sp, #0xc]
700aeb5e: 9902         	ldr	r1, [sp, #0x8]
700aeb60: f7f7 fade    	bl	0x700a6120 <UART_udmaConfigPdmaTx> @ imm = #-0x8a44
700aeb64: 9001         	str	r0, [sp, #0x4]
;     if (status != UDMA_SOK)
700aeb66: 9801         	ldr	r0, [sp, #0x4]
700aeb68: b120         	cbz	r0, 0x700aeb74 <UART_lld_dmaWrite+0x24> @ imm = #0x8
700aeb6a: e7ff         	b	0x700aeb6c <UART_lld_dmaWrite+0x1c> @ imm = #-0x2
700aeb6c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700aeb70: 9001         	str	r0, [sp, #0x4]
;     }
700aeb72: e7ff         	b	0x700aeb74 <UART_lld_dmaWrite+0x24> @ imm = #-0x2
;     return status;
700aeb74: 9801         	ldr	r0, [sp, #0x4]
700aeb76: b004         	add	sp, #0x10
700aeb78: bd80         	pop	{r7, pc}
700aeb7a: 0000         	movs	r0, r0
700aeb7c: 0000         	movs	r0, r0
700aeb7e: 0000         	movs	r0, r0

700aeb80 <UART_operatingModeSelect>:
; {
700aeb80: b580         	push	{r7, lr}
700aeb82: b084         	sub	sp, #0x10
700aeb84: 9003         	str	r0, [sp, #0xc]
700aeb86: 9102         	str	r1, [sp, #0x8]
;     operMode = HW_RD_REG32(baseAddr + UART_MDR1) & UART_MDR1_MODE_SELECT_MASK;
700aeb88: 9803         	ldr	r0, [sp, #0xc]
700aeb8a: 3020         	adds	r0, #0x20
700aeb8c: f000 fe68    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0xcd0
700aeb90: f000 0007    	and	r0, r0, #0x7
700aeb94: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_MDR1, UART_MDR1_MODE_SELECT,
700aeb96: 9803         	ldr	r0, [sp, #0xc]
700aeb98: 3020         	adds	r0, #0x20
700aeb9a: 9b02         	ldr	r3, [sp, #0x8]
700aeb9c: 2107         	movs	r1, #0x7
700aeb9e: 2200         	movs	r2, #0x0
700aeba0: f7ff fc36    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #-0x794
;     return operMode;
700aeba4: 9801         	ldr	r0, [sp, #0x4]
700aeba6: b004         	add	sp, #0x10
700aeba8: bd80         	pop	{r7, pc}
700aebaa: 0000         	movs	r0, r0
700aebac: 0000         	movs	r0, r0
700aebae: 0000         	movs	r0, r0

700aebb0 <Udma_eventProgramSteering>:
; {
700aebb0: b084         	sub	sp, #0x10
700aebb2: 9003         	str	r0, [sp, #0xc]
700aebb4: 9102         	str	r1, [sp, #0x8]
;     eventPrms = &eventHandle->eventPrms;
700aebb6: 9802         	ldr	r0, [sp, #0x8]
700aebb8: 3008         	adds	r0, #0x8
700aebba: 9000         	str	r0, [sp]
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
700aebbc: 9800         	ldr	r0, [sp]
700aebbe: 6800         	ldr	r0, [r0]
700aebc0: 2803         	cmp	r0, #0x3
700aebc2: d108         	bne	0x700aebd6 <Udma_eventProgramSteering+0x26> @ imm = #0x10
700aebc4: e7ff         	b	0x700aebc6 <Udma_eventProgramSteering+0x16> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
700aebc6: 9800         	ldr	r0, [sp]
700aebc8: 6880         	ldr	r0, [r0, #0x8]
700aebca: 9001         	str	r0, [sp, #0x4]
;         chHandle->chOesAllocDone = TRUE;
700aebcc: 9901         	ldr	r1, [sp, #0x4]
700aebce: 2001         	movs	r0, #0x1
700aebd0: f8c1 0248    	str.w	r0, [r1, #0x248]
;     }
700aebd4: e7ff         	b	0x700aebd6 <Udma_eventProgramSteering+0x26> @ imm = #-0x2
;     return;
700aebd6: b004         	add	sp, #0x10
700aebd8: 4770         	bx	lr
700aebda: 0000         	movs	r0, r0
700aebdc: 0000         	movs	r0, r0
700aebde: 0000         	movs	r0, r0

700aebe0 <Udma_eventResetSteering>:
; {
700aebe0: b084         	sub	sp, #0x10
700aebe2: 9003         	str	r0, [sp, #0xc]
700aebe4: 9102         	str	r1, [sp, #0x8]
;     eventPrms = &eventHandle->eventPrms;
700aebe6: 9802         	ldr	r0, [sp, #0x8]
700aebe8: 3008         	adds	r0, #0x8
700aebea: 9000         	str	r0, [sp]
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
700aebec: 9800         	ldr	r0, [sp]
700aebee: 6800         	ldr	r0, [r0]
700aebf0: 2803         	cmp	r0, #0x3
700aebf2: d108         	bne	0x700aec06 <Udma_eventResetSteering+0x26> @ imm = #0x10
700aebf4: e7ff         	b	0x700aebf6 <Udma_eventResetSteering+0x16> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
700aebf6: 9800         	ldr	r0, [sp]
700aebf8: 6880         	ldr	r0, [r0, #0x8]
700aebfa: 9001         	str	r0, [sp, #0x4]
;         chHandle->chOesAllocDone = FALSE;
700aebfc: 9901         	ldr	r1, [sp, #0x4]
700aebfe: 2000         	movs	r0, #0x0
700aec00: f8c1 0248    	str.w	r0, [r1, #0x248]
;     }
700aec04: e7ff         	b	0x700aec06 <Udma_eventResetSteering+0x26> @ imm = #-0x2
;     return;
700aec06: b004         	add	sp, #0x10
700aec08: 4770         	bx	lr
700aec0a: 0000         	movs	r0, r0
700aec0c: 0000         	movs	r0, r0
700aec0e: 0000         	movs	r0, r0

700aec10 <Sciclient_secProxyVerifyThread>:
; {
700aec10: b580         	push	{r7, lr}
700aec12: b082         	sub	sp, #0x8
700aec14: 9001         	str	r0, [sp, #0x4]
700aec16: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700aec18: 9000         	str	r0, [sp]
;     if ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700aec1a: 9801         	ldr	r0, [sp, #0x4]
700aec1c: f000 fbd8    	bl	0x700af3d0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x7b0
700aec20: f000 fe7e    	bl	0x700af920 <CSL_REG32_RD_RAW> @ imm = #0xcfc
700aec24: 0fc0         	lsrs	r0, r0, #0x1f
700aec26: b120         	cbz	r0, 0x700aec32 <Sciclient_secProxyVerifyThread+0x22> @ imm = #0x8
700aec28: e7ff         	b	0x700aec2a <Sciclient_secProxyVerifyThread+0x1a> @ imm = #-0x2
700aec2a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700aec2e: 9000         	str	r0, [sp]
;     }
700aec30: e7ff         	b	0x700aec32 <Sciclient_secProxyVerifyThread+0x22> @ imm = #-0x2
;     return status;
700aec32: 9800         	ldr	r0, [sp]
700aec34: b002         	add	sp, #0x8
700aec36: bd80         	pop	{r7, pc}
		...

700aec40 <prvIsQueueEmpty>:
; {
700aec40: b580         	push	{r7, lr}
700aec42: b082         	sub	sp, #0x8
700aec44: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700aec46: f7ff fc43    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #-0x77a
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
700aec4a: 9801         	ldr	r0, [sp, #0x4]
700aec4c: 6b80         	ldr	r0, [r0, #0x38]
700aec4e: b918         	cbnz	r0, 0x700aec58 <prvIsQueueEmpty+0x18> @ imm = #0x6
700aec50: e7ff         	b	0x700aec52 <prvIsQueueEmpty+0x12> @ imm = #-0x2
700aec52: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
700aec54: 9000         	str	r0, [sp]
;         }
700aec56: e002         	b	0x700aec5e <prvIsQueueEmpty+0x1e> @ imm = #0x4
700aec58: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
700aec5a: 9000         	str	r0, [sp]
700aec5c: e7ff         	b	0x700aec5e <prvIsQueueEmpty+0x1e> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700aec5e: f7fe fcf7    	bl	0x700ad650 <vTaskExitCritical> @ imm = #-0x1612
;     return xReturn;
700aec62: 9800         	ldr	r0, [sp]
700aec64: b002         	add	sp, #0x8
700aec66: bd80         	pop	{r7, pc}
		...

700aec70 <vQueueDelete>:
; {
700aec70: b580         	push	{r7, lr}
700aec72: b082         	sub	sp, #0x8
700aec74: 9001         	str	r0, [sp, #0x4]
;     Queue_t * const pxQueue = xQueue;
700aec76: 9801         	ldr	r0, [sp, #0x4]
700aec78: 9000         	str	r0, [sp]
;             vQueueUnregisterQueue( pxQueue );
700aec7a: 9800         	ldr	r0, [sp]
700aec7c: f7fe f840    	bl	0x700acd00 <vQueueUnregisterQueue> @ imm = #-0x1f80
;             if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
700aec80: 9800         	ldr	r0, [sp]
700aec82: f890 0046    	ldrb.w	r0, [r0, #0x46]
700aec86: b920         	cbnz	r0, 0x700aec92 <vQueueDelete+0x22> @ imm = #0x8
700aec88: e7ff         	b	0x700aec8a <vQueueDelete+0x1a> @ imm = #-0x2
;                 vPortFree( pxQueue );
700aec8a: 9800         	ldr	r0, [sp]
700aec8c: f000 fa20    	bl	0x700af0d0 <vPortFree>  @ imm = #0x440
;             }
700aec90: e000         	b	0x700aec94 <vQueueDelete+0x24> @ imm = #0x0
700aec92: e7ff         	b	0x700aec94 <vQueueDelete+0x24> @ imm = #-0x2
; }
700aec94: b002         	add	sp, #0x8
700aec96: bd80         	pop	{r7, pc}
		...

700aeca0 <vprintf_>:
; {
700aeca0: b580         	push	{r7, lr}
700aeca2: b084         	sub	sp, #0x10
700aeca4: 9103         	str	r1, [sp, #0xc]
700aeca6: 9002         	str	r0, [sp, #0x8]
;   return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
700aeca8: 9b02         	ldr	r3, [sp, #0x8]
700aecaa: 9803         	ldr	r0, [sp, #0xc]
700aecac: 4669         	mov	r1, sp
700aecae: 6008         	str	r0, [r1]
700aecb0: f64e 7061    	movw	r0, #0xef61
700aecb4: f2c7 000a    	movt	r0, #0x700a
700aecb8: f10d 0107    	add.w	r1, sp, #0x7
700aecbc: f04f 32ff    	mov.w	r2, #0xffffffff
700aecc0: f7eb f9ce    	bl	0x7009a060 <_vsnprintf> @ imm = #-0x14c64
700aecc4: b004         	add	sp, #0x10
700aecc6: bd80         	pop	{r7, pc}
		...

700aecd0 <UART_udmapSetReturnPolicy>:
; {
700aecd0: b580         	push	{r7, lr}
700aecd2: b086         	sub	sp, #0x18
700aecd4: 9005         	str	r0, [sp, #0x14]
700aecd6: 9104         	str	r1, [sp, #0x10]
700aecd8: 2001         	movs	r0, #0x1
;         uint32_t descType = (uint32_t)CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST;
700aecda: 9003         	str	r0, [sp, #0xc]
;         CSL_UdmapCppi5HMPD *pHpd = (CSL_UdmapCppi5HMPD *) pHpdMem;
700aecdc: 9804         	ldr	r0, [sp, #0x10]
700aecde: 9002         	str	r0, [sp, #0x8]
;         pHpd,
700aece0: 9802         	ldr	r0, [sp, #0x8]
;         descType,
700aece2: 9903         	ldr	r1, [sp, #0xc]
;         CSL_udmapCppi5SetReturnPolicy(
700aece4: 466a         	mov	r2, sp
700aece6: 2300         	movs	r3, #0x0
700aece8: 6053         	str	r3, [r2, #0x4]
700aecea: 6013         	str	r3, [r2]
700aecec: 461a         	mov	r2, r3
700aecee: f7fb fbff    	bl	0x700aa4f0 <CSL_udmapCppi5SetReturnPolicy> @ imm = #-0x4802
;         return;
700aecf2: b006         	add	sp, #0x18
700aecf4: bd80         	pop	{r7, pc}
		...
700aecfe: 0000         	movs	r0, r0

700aed00 <Udma_ringGetForwardRingOcc>:
; {
700aed00: b580         	push	{r7, lr}
700aed02: b084         	sub	sp, #0x10
700aed04: 9003         	str	r0, [sp, #0xc]
700aed06: 2000         	movs	r0, #0x0
;     uint32_t            occ = 0U;
700aed08: 9002         	str	r0, [sp, #0x8]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700aed0a: 9803         	ldr	r0, [sp, #0xc]
700aed0c: 9001         	str	r0, [sp, #0x4]
;     Udma_DrvHandleInt   drvHandle = ringHandleInt->drvHandle;
700aed0e: 9801         	ldr	r0, [sp, #0x4]
700aed10: 6800         	ldr	r0, [r0]
700aed12: 9000         	str	r0, [sp]
;     occ = drvHandle->ringGetForwardRingOcc(ringHandleInt);
700aed14: 9800         	ldr	r0, [sp]
700aed16: f8d0 15a8    	ldr.w	r1, [r0, #0x5a8]
700aed1a: 9801         	ldr	r0, [sp, #0x4]
700aed1c: 4788         	blx	r1
700aed1e: 9002         	str	r0, [sp, #0x8]
;     return (occ);
700aed20: 9802         	ldr	r0, [sp, #0x8]
700aed22: b004         	add	sp, #0x10
700aed24: bd80         	pop	{r7, pc}
		...
700aed2e: 0000         	movs	r0, r0

700aed30 <Udma_ringGetReverseRingOcc>:
; {
700aed30: b580         	push	{r7, lr}
700aed32: b084         	sub	sp, #0x10
700aed34: 9003         	str	r0, [sp, #0xc]
700aed36: 2000         	movs	r0, #0x0
;     uint32_t            occ = 0U;
700aed38: 9002         	str	r0, [sp, #0x8]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700aed3a: 9803         	ldr	r0, [sp, #0xc]
700aed3c: 9001         	str	r0, [sp, #0x4]
;     Udma_DrvHandleInt   drvHandle = ringHandleInt->drvHandle;
700aed3e: 9801         	ldr	r0, [sp, #0x4]
700aed40: 6800         	ldr	r0, [r0]
700aed42: 9000         	str	r0, [sp]
;     occ = drvHandle->ringGetReverseRingOcc(ringHandleInt);
700aed44: 9800         	ldr	r0, [sp]
700aed46: f8d0 15ac    	ldr.w	r1, [r0, #0x5ac]
700aed4a: 9801         	ldr	r0, [sp, #0x4]
700aed4c: 4788         	blx	r1
700aed4e: 9002         	str	r0, [sp, #0x8]
;     return (occ);
700aed50: 9802         	ldr	r0, [sp, #0x8]
700aed52: b004         	add	sp, #0x10
700aed54: bd80         	pop	{r7, pc}
		...
700aed5e: 0000         	movs	r0, r0

700aed60 <_out_buffer>:
; {
700aed60: b084         	sub	sp, #0x10
700aed62: f88d 000f    	strb.w	r0, [sp, #0xf]
700aed66: 9102         	str	r1, [sp, #0x8]
700aed68: 9201         	str	r2, [sp, #0x4]
700aed6a: 9300         	str	r3, [sp]
;   if (idx < maxlen) {
700aed6c: 9801         	ldr	r0, [sp, #0x4]
700aed6e: 9900         	ldr	r1, [sp]
700aed70: 4288         	cmp	r0, r1
700aed72: d206         	bhs	0x700aed82 <_out_buffer+0x22> @ imm = #0xc
700aed74: e7ff         	b	0x700aed76 <_out_buffer+0x16> @ imm = #-0x2
;     ((char*)buffer)[idx] = character;
700aed76: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700aed7a: 9902         	ldr	r1, [sp, #0x8]
700aed7c: 9a01         	ldr	r2, [sp, #0x4]
700aed7e: 5488         	strb	r0, [r1, r2]
;   }
700aed80: e7ff         	b	0x700aed82 <_out_buffer+0x22> @ imm = #-0x2
; }
700aed82: b004         	add	sp, #0x10
700aed84: 4770         	bx	lr
		...
700aed8e: 0000         	movs	r0, r0

700aed90 <prvGetDisinheritPriorityAfterTimeout>:
;     {
700aed90: b082         	sub	sp, #0x8
700aed92: 9001         	str	r0, [sp, #0x4]
;         if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
700aed94: 9801         	ldr	r0, [sp, #0x4]
700aed96: 6a40         	ldr	r0, [r0, #0x24]
700aed98: b138         	cbz	r0, 0x700aedaa <prvGetDisinheritPriorityAfterTimeout+0x1a> @ imm = #0xe
700aed9a: e7ff         	b	0x700aed9c <prvGetDisinheritPriorityAfterTimeout+0xc> @ imm = #-0x2
;             uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
700aed9c: 9801         	ldr	r0, [sp, #0x4]
700aed9e: 6b00         	ldr	r0, [r0, #0x30]
700aeda0: 6800         	ldr	r0, [r0]
700aeda2: f1c0 0020    	rsb.w	r0, r0, #0x20
700aeda6: 9000         	str	r0, [sp]
;         }
700aeda8: e002         	b	0x700aedb0 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #0x4
700aedaa: 2000         	movs	r0, #0x0
;             uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
700aedac: 9000         	str	r0, [sp]
700aedae: e7ff         	b	0x700aedb0 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #-0x2
;         return uxHighestPriorityOfWaitingTasks;
700aedb0: 9800         	ldr	r0, [sp]
700aedb2: b002         	add	sp, #0x8
700aedb4: 4770         	bx	lr
		...
700aedbe: 0000         	movs	r0, r0

700aedc0 <vTaskPlaceOnEventList>:
;                            const TickType_t xTicksToWait) {
700aedc0: b580         	push	{r7, lr}
700aedc2: b082         	sub	sp, #0x8
700aedc4: 9001         	str	r0, [sp, #0x4]
700aedc6: 9100         	str	r1, [sp]
;   vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
700aedc8: 9801         	ldr	r0, [sp, #0x4]
700aedca: f242 61bc    	movw	r1, #0x26bc
700aedce: f2c7 010b    	movt	r1, #0x700b
700aedd2: 6809         	ldr	r1, [r1]
700aedd4: 3118         	adds	r1, #0x18
700aedd6: f7fc fbe3    	bl	0x700ab5a0 <vListInsert> @ imm = #-0x383a
;   prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
700aedda: 9800         	ldr	r0, [sp]
700aeddc: 2101         	movs	r1, #0x1
700aedde: f7f7 fb5f    	bl	0x700a64a0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x8942
; }
700aede2: b002         	add	sp, #0x8
700aede4: bd80         	pop	{r7, pc}
		...
700aedee: 0000         	movs	r0, r0

700aedf0 <CSL_REG32_FEXT_RAW>:
; {
700aedf0: b580         	push	{r7, lr}
700aedf2: b084         	sub	sp, #0x10
700aedf4: 9003         	str	r0, [sp, #0xc]
700aedf6: 9102         	str	r1, [sp, #0x8]
700aedf8: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700aedfa: 9803         	ldr	r0, [sp, #0xc]
700aedfc: f000 fd78    	bl	0x700af8f0 <CSL_REG32_RD_RAW> @ imm = #0xaf0
700aee00: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700aee02: 9800         	ldr	r0, [sp]
700aee04: 9902         	ldr	r1, [sp, #0x8]
700aee06: 4008         	ands	r0, r1
700aee08: 9901         	ldr	r1, [sp, #0x4]
700aee0a: 40c8         	lsrs	r0, r1
700aee0c: 9000         	str	r0, [sp]
;     return (regVal);
700aee0e: 9800         	ldr	r0, [sp]
700aee10: b004         	add	sp, #0x10
700aee12: bd80         	pop	{r7, pc}
		...

700aee20 <CSL_REG32_FEXT_RAW>:
; {
700aee20: b580         	push	{r7, lr}
700aee22: b084         	sub	sp, #0x10
700aee24: 9003         	str	r0, [sp, #0xc]
700aee26: 9102         	str	r1, [sp, #0x8]
700aee28: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700aee2a: 9803         	ldr	r0, [sp, #0xc]
700aee2c: f000 fd68    	bl	0x700af900 <CSL_REG32_RD_RAW> @ imm = #0xad0
700aee30: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700aee32: 9800         	ldr	r0, [sp]
700aee34: 9902         	ldr	r1, [sp, #0x8]
700aee36: 4008         	ands	r0, r1
700aee38: 9901         	ldr	r1, [sp, #0x4]
700aee3a: 40c8         	lsrs	r0, r1
700aee3c: 9000         	str	r0, [sp]
;     return (regVal);
700aee3e: 9800         	ldr	r0, [sp]
700aee40: b004         	add	sp, #0x10
700aee42: bd80         	pop	{r7, pc}
		...

700aee50 <CSL_REG32_FEXT_RAW>:
; {
700aee50: b580         	push	{r7, lr}
700aee52: b084         	sub	sp, #0x10
700aee54: 9003         	str	r0, [sp, #0xc]
700aee56: 9102         	str	r1, [sp, #0x8]
700aee58: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700aee5a: 9803         	ldr	r0, [sp, #0xc]
700aee5c: f000 fd58    	bl	0x700af910 <CSL_REG32_RD_RAW> @ imm = #0xab0
700aee60: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700aee62: 9800         	ldr	r0, [sp]
700aee64: 9902         	ldr	r1, [sp, #0x8]
700aee66: 4008         	ands	r0, r1
700aee68: 9901         	ldr	r1, [sp, #0x4]
700aee6a: 40c8         	lsrs	r0, r1
700aee6c: 9000         	str	r0, [sp]
;     return (regVal);
700aee6e: 9800         	ldr	r0, [sp]
700aee70: b004         	add	sp, #0x10
700aee72: bd80         	pop	{r7, pc}
		...

700aee80 <CSL_REG32_FEXT_RAW>:
; {
700aee80: b580         	push	{r7, lr}
700aee82: b084         	sub	sp, #0x10
700aee84: 9003         	str	r0, [sp, #0xc]
700aee86: 9102         	str	r1, [sp, #0x8]
700aee88: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700aee8a: 9803         	ldr	r0, [sp, #0xc]
700aee8c: f000 fd48    	bl	0x700af920 <CSL_REG32_RD_RAW> @ imm = #0xa90
700aee90: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700aee92: 9800         	ldr	r0, [sp]
700aee94: 9902         	ldr	r1, [sp, #0x8]
700aee96: 4008         	ands	r0, r1
700aee98: 9901         	ldr	r1, [sp, #0x4]
700aee9a: 40c8         	lsrs	r0, r1
700aee9c: 9000         	str	r0, [sp]
;     return (regVal);
700aee9e: 9800         	ldr	r0, [sp]
700aeea0: b004         	add	sp, #0x10
700aeea2: bd80         	pop	{r7, pc}
		...

700aeeb0 <CSL_REG32_FEXT_RAW>:
; {
700aeeb0: b580         	push	{r7, lr}
700aeeb2: b084         	sub	sp, #0x10
700aeeb4: 9003         	str	r0, [sp, #0xc]
700aeeb6: 9102         	str	r1, [sp, #0x8]
700aeeb8: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700aeeba: 9803         	ldr	r0, [sp, #0xc]
700aeebc: f000 fd38    	bl	0x700af930 <CSL_REG32_RD_RAW> @ imm = #0xa70
700aeec0: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700aeec2: 9800         	ldr	r0, [sp]
700aeec4: 9902         	ldr	r1, [sp, #0x8]
700aeec6: 4008         	ands	r0, r1
700aeec8: 9901         	ldr	r1, [sp, #0x4]
700aeeca: 40c8         	lsrs	r0, r1
700aeecc: 9000         	str	r0, [sp]
;     return (regVal);
700aeece: 9800         	ldr	r0, [sp]
700aeed0: b004         	add	sp, #0x10
700aeed2: bd80         	pop	{r7, pc}
		...

700aeee0 <SOC_getSelfCpuClk>:
; {
700aeee0: b580         	push	{r7, lr}
700aeee2: b084         	sub	sp, #0x10
700aeee4: 2000         	movs	r0, #0x0
;     uint64_t cpuClockRate = 0U;
700aeee6: 9001         	str	r0, [sp, #0x4]
700aeee8: 9003         	str	r0, [sp, #0xc]
700aeeea: 9002         	str	r0, [sp, #0x8]
;                     Sciclient_getSelfDevIdCore(),
700aeeec: f000 fd38    	bl	0x700af960 <Sciclient_getSelfDevIdCore> @ imm = #0xa70
700aeef0: 9901         	ldr	r1, [sp, #0x4]
700aeef2: aa02         	add	r2, sp, #0x8
700aeef4: f04f 33ff    	mov.w	r3, #0xffffffff
;     Sciclient_pmGetModuleClkFreq(
700aeef8: f7f9 ff02    	bl	0x700a8d00 <Sciclient_pmGetModuleClkFreq> @ imm = #-0x61fc
;     return cpuClockRate;
700aeefc: 9802         	ldr	r0, [sp, #0x8]
700aeefe: 9903         	ldr	r1, [sp, #0xc]
700aef00: b004         	add	sp, #0x10
700aef02: bd80         	pop	{r7, pc}
		...

700aef10 <UART_IsStopBitsValid>:
; {
700aef10: b082         	sub	sp, #0x8
700aef12: 9001         	str	r0, [sp, #0x4]
700aef14: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700aef18: 9000         	str	r0, [sp]
;     if((stopBits == UART_STOPBITS_1) ||
700aef1a: 9801         	ldr	r0, [sp, #0x4]
700aef1c: b120         	cbz	r0, 0x700aef28 <UART_IsStopBitsValid+0x18> @ imm = #0x8
700aef1e: e7ff         	b	0x700aef20 <UART_IsStopBitsValid+0x10> @ imm = #-0x2
;         (stopBits == UART_STOPBITS_2))
700aef20: 9801         	ldr	r0, [sp, #0x4]
;     if((stopBits == UART_STOPBITS_1) ||
700aef22: 2801         	cmp	r0, #0x1
700aef24: d103         	bne	0x700aef2e <UART_IsStopBitsValid+0x1e> @ imm = #0x6
700aef26: e7ff         	b	0x700aef28 <UART_IsStopBitsValid+0x18> @ imm = #-0x2
700aef28: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700aef2a: 9000         	str	r0, [sp]
;     }
700aef2c: e7ff         	b	0x700aef2e <UART_IsStopBitsValid+0x1e> @ imm = #-0x2
;     return status;
700aef2e: 9800         	ldr	r0, [sp]
700aef30: b002         	add	sp, #0x8
700aef32: 4770         	bx	lr

700aef34 <__aeabi_uldivmod>:
700aef34: e92d4040     	push	{r6, lr}
700aef38: e24dd010     	sub	sp, sp, #16
700aef3c: e28d6008     	add	r6, sp, #8
700aef40: e58d6000     	str	r6, [sp]
700aef44: ebffd5f7     	bl	0x700a4728 <__udivmoddi4> @ imm = #-0xa824
700aef48: e59d2008     	ldr	r2, [sp, #0x8]
700aef4c: e59d300c     	ldr	r3, [sp, #0xc]
700aef50: e28dd010     	add	sp, sp, #16
700aef54: e8bd8040     	pop	{r6, pc}
		...

700aef60 <_out_char>:
; {
700aef60: b580         	push	{r7, lr}
700aef62: b084         	sub	sp, #0x10
700aef64: f88d 000f    	strb.w	r0, [sp, #0xf]
700aef68: 9102         	str	r1, [sp, #0x8]
700aef6a: 9201         	str	r2, [sp, #0x4]
700aef6c: 9300         	str	r3, [sp]
;   if (character) {
700aef6e: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700aef72: b128         	cbz	r0, 0x700aef80 <_out_char+0x20> @ imm = #0xa
700aef74: e7ff         	b	0x700aef76 <_out_char+0x16> @ imm = #-0x2
;     putchar_(character);
700aef76: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700aef7a: f000 fbe1    	bl	0x700af740 <putchar_>   @ imm = #0x7c2
;   }
700aef7e: e7ff         	b	0x700aef80 <_out_char+0x20> @ imm = #-0x2
; }
700aef80: b004         	add	sp, #0x10
700aef82: bd80         	pop	{r7, pc}
		...

700aef90 <vTaskInternalSetTimeOutState>:
; void vTaskInternalSetTimeOutState(TimeOut_t *const pxTimeOut) {
700aef90: b081         	sub	sp, #0x4
700aef92: 9000         	str	r0, [sp]
;   pxTimeOut->xOverflowCount = xNumOfOverflows;
700aef94: f242 60f8    	movw	r0, #0x26f8
700aef98: f2c7 000b    	movt	r0, #0x700b
700aef9c: 6800         	ldr	r0, [r0]
700aef9e: 9900         	ldr	r1, [sp]
700aefa0: 6008         	str	r0, [r1]
;   pxTimeOut->xTimeOnEntering = xTickCount;
700aefa2: f242 7004    	movw	r0, #0x2704
700aefa6: f2c7 000b    	movt	r0, #0x700b
700aefaa: 6800         	ldr	r0, [r0]
700aefac: 9900         	ldr	r1, [sp]
700aefae: 6048         	str	r0, [r1, #0x4]
; }
700aefb0: b001         	add	sp, #0x4
700aefb2: 4770         	bx	lr
		...

700aefc0 <Pinmux_init>:
; {
700aefc0: b580         	push	{r7, lr}
;     Pinmux_config(gPinMuxMainDomainCfg, PINMUX_DOMAIN_ID_MAIN);
700aefc2: f242 50d8    	movw	r0, #0x25d8
700aefc6: 2100         	movs	r1, #0x0
700aefc8: f2c7 000b    	movt	r0, #0x700b
700aefcc: f7f9 fda8    	bl	0x700a8b20 <Pinmux_config> @ imm = #-0x64b0
;     Pinmux_config(gPinMuxMcuDomainCfg, PINMUX_DOMAIN_ID_MCU);
700aefd0: f242 604c    	movw	r0, #0x264c
700aefd4: 2101         	movs	r1, #0x1
700aefd6: f2c7 000b    	movt	r0, #0x700b
700aefda: e8bd 4080    	pop.w	{r7, lr}
700aefde: f7f9 bd9f    	b.w	0x700a8b20 <Pinmux_config> @ imm = #-0x64c2
		...
700aefee: 0000         	movs	r0, r0

700aeff0 <Udma_rmTranslateCoreIntrInput>:
; {
700aeff0: b083         	sub	sp, #0xc
700aeff2: 9002         	str	r0, [sp, #0x8]
700aeff4: 9101         	str	r1, [sp, #0x4]
700aeff6: 2000         	movs	r0, #0x0
700aeff8: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t    irIntrNum = UDMA_INTR_INVALID;
700aeffc: 9000         	str	r0, [sp]
;     if(drvHandle->instType != UDMA_INST_TYPE_NORMAL)
700aeffe: 9802         	ldr	r0, [sp, #0x8]
700af000: 6800         	ldr	r0, [r0]
700af002: b118         	cbz	r0, 0x700af00c <Udma_rmTranslateCoreIntrInput+0x1c> @ imm = #0x6
700af004: e7ff         	b	0x700af006 <Udma_rmTranslateCoreIntrInput+0x16> @ imm = #-0x2
;         irIntrNum = coreIntrNum;
700af006: 9801         	ldr	r0, [sp, #0x4]
700af008: 9000         	str	r0, [sp]
;     }
700af00a: e7ff         	b	0x700af00c <Udma_rmTranslateCoreIntrInput+0x1c> @ imm = #-0x2
;     return (irIntrNum);
700af00c: 9800         	ldr	r0, [sp]
700af00e: b003         	add	sp, #0xc
700af010: 4770         	bx	lr
		...
700af01e: 0000         	movs	r0, r0

700af020 <Udma_rmTranslateIrOutput>:
; {
700af020: b083         	sub	sp, #0xc
700af022: 9002         	str	r0, [sp, #0x8]
700af024: 9101         	str	r1, [sp, #0x4]
700af026: 2000         	movs	r0, #0x0
700af028: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t    coreIntrNum = UDMA_INTR_INVALID;
700af02c: 9000         	str	r0, [sp]
;     if(drvHandle->instType != UDMA_INST_TYPE_NORMAL)
700af02e: 9802         	ldr	r0, [sp, #0x8]
700af030: 6800         	ldr	r0, [r0]
700af032: b118         	cbz	r0, 0x700af03c <Udma_rmTranslateIrOutput+0x1c> @ imm = #0x6
700af034: e7ff         	b	0x700af036 <Udma_rmTranslateIrOutput+0x16> @ imm = #-0x2
;         coreIntrNum = irIntrNum;
700af036: 9801         	ldr	r0, [sp, #0x4]
700af038: 9000         	str	r0, [sp]
;     }
700af03a: e7ff         	b	0x700af03c <Udma_rmTranslateIrOutput+0x1c> @ imm = #-0x2
;     return (coreIntrNum);
700af03c: 9800         	ldr	r0, [sp]
700af03e: b003         	add	sp, #0xc
700af040: 4770         	bx	lr
		...
700af04e: 0000         	movs	r0, r0

700af050 <ClockP_usecToTicks>:
; {
700af050: b580         	push	{r7, lr}
700af052: b082         	sub	sp, #0x8
700af054: 9101         	str	r1, [sp, #0x4]
700af056: 9000         	str	r0, [sp]
;     return (uint32_t)(usecs / gClockCtrl.usecPerTick);
700af058: 9800         	ldr	r0, [sp]
700af05a: 9901         	ldr	r1, [sp, #0x4]
700af05c: f245 1210    	movw	r2, #0x5110
700af060: f2c7 0208    	movt	r2, #0x7008
700af064: 6892         	ldr	r2, [r2, #0x8]
700af066: 2300         	movs	r3, #0x0
700af068: f7ff ef64    	blx	0x700aef34 <__aeabi_uldivmod> @ imm = #-0x138
700af06c: b002         	add	sp, #0x8
700af06e: bd80         	pop	{r7, pc}

700af070 <HW_RD_FIELD32_RAW>:
; {
700af070: b084         	sub	sp, #0x10
700af072: 9003         	str	r0, [sp, #0xc]
700af074: 9102         	str	r1, [sp, #0x8]
700af076: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700af078: 9803         	ldr	r0, [sp, #0xc]
700af07a: 6800         	ldr	r0, [r0]
700af07c: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af07e: 9800         	ldr	r0, [sp]
700af080: 9902         	ldr	r1, [sp, #0x8]
700af082: 4008         	ands	r0, r1
700af084: 9901         	ldr	r1, [sp, #0x4]
700af086: 40c8         	lsrs	r0, r1
700af088: 9000         	str	r0, [sp]
;     return (regVal);
700af08a: 9800         	ldr	r0, [sp]
700af08c: b004         	add	sp, #0x10
700af08e: 4770         	bx	lr

700af090 <Sciclient_getRxThreadId>:
; {
700af090: b082         	sub	sp, #0x8
700af092: 9001         	str	r0, [sp, #0x4]
;     rxThread = gSciclientMap[contextId].respThreadId;
700af094: 9801         	ldr	r0, [sp, #0x4]
700af096: eb00 0140    	add.w	r1, r0, r0, lsl #1
700af09a: f241 0060    	movw	r0, #0x1060
700af09e: f2c7 000b    	movt	r0, #0x700b
700af0a2: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700af0a6: 68c0         	ldr	r0, [r0, #0xc]
700af0a8: 9000         	str	r0, [sp]
;     return rxThread;
700af0aa: 9800         	ldr	r0, [sp]
700af0ac: b002         	add	sp, #0x8
700af0ae: 4770         	bx	lr

700af0b0 <Sciclient_getTxThreadId>:
; {
700af0b0: b082         	sub	sp, #0x8
700af0b2: 9001         	str	r0, [sp, #0x4]
;     txThread = gSciclientMap[contextId].reqLowPrioThreadId;
700af0b4: 9801         	ldr	r0, [sp, #0x4]
700af0b6: eb00 0140    	add.w	r1, r0, r0, lsl #1
700af0ba: f241 0060    	movw	r0, #0x1060
700af0be: f2c7 000b    	movt	r0, #0x700b
700af0c2: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700af0c6: 6880         	ldr	r0, [r0, #0x8]
700af0c8: 9000         	str	r0, [sp]
;     return txThread;
700af0ca: 9800         	ldr	r0, [sp]
700af0cc: b002         	add	sp, #0x8
700af0ce: 4770         	bx	lr

700af0d0 <vPortFree>:
; {
700af0d0: b580         	push	{r7, lr}
700af0d2: b082         	sub	sp, #0x8
700af0d4: 9001         	str	r0, [sp, #0x4]
;     if( pv )
700af0d6: 9801         	ldr	r0, [sp, #0x4]
700af0d8: b140         	cbz	r0, 0x700af0ec <vPortFree+0x1c> @ imm = #0x10
700af0da: e7ff         	b	0x700af0dc <vPortFree+0xc> @ imm = #-0x2
;         vTaskSuspendAll();
700af0dc: f000 fbe8    	bl	0x700af8b0 <vTaskSuspendAll> @ imm = #0x7d0
;             free( pv );
700af0e0: 9801         	ldr	r0, [sp, #0x4]
700af0e2: f7f0 ee50    	blx	0x7009fd84 <free>       @ imm = #-0xf360
;         ( void ) xTaskResumeAll();
700af0e6: f7f2 ffd3    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0xd05a
;     }
700af0ea: e7ff         	b	0x700af0ec <vPortFree+0x1c> @ imm = #-0x2
; }
700af0ec: b002         	add	sp, #0x8
700af0ee: bd80         	pop	{r7, pc}

700af0f0 <wcslen>:
700af0f0: e3a01000     	mov	r1, #0
700af0f4: e7902001     	ldr	r2, [r0, r1]
700af0f8: e2811004     	add	r1, r1, #4
700af0fc: e3520000     	cmp	r2, #0
700af100: 1afffffb     	bne	0x700af0f4 <wcslen+0x4> @ imm = #-0x14
700af104: e2410004     	sub	r0, r1, #4
700af108: e1a00140     	asr	r0, r0, #2
700af10c: e12fff1e     	bx	lr

700af110 <CSL_udmapCppi5SetEpiDataPresent>:
; {
700af110: b082         	sub	sp, #0x8
700af112: 9001         	str	r0, [sp, #0x4]
700af114: f88d 1003    	strb.w	r1, [sp, #0x3]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_EINFO, (bEpiDataPresent==(bool)true) ? (uint32_t)1U : (uint32_t)0U );
700af118: 9901         	ldr	r1, [sp, #0x4]
700af11a: 6808         	ldr	r0, [r1]
700af11c: f020 5000    	bic	r0, r0, #0x20000000
700af120: f89d 2003    	ldrb.w	r2, [sp, #0x3]
700af124: f362 705d    	bfi	r0, r2, #29, #1
700af128: 6008         	str	r0, [r1]
; }
700af12a: b002         	add	sp, #0x8
700af12c: 4770         	bx	lr
700af12e: 0000         	movs	r0, r0

700af130 <DebugP_memLogWriterInit>:
; {
700af130: b580         	push	{r7, lr}
700af132: b082         	sub	sp, #0x8
700af134: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     gDebugP_memTraceLogWriterSelfCoreName = SOC_getCoreName(selfCoreId);
700af138: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700af13c: f7fe ff90    	bl	0x700ae060 <SOC_getCoreName> @ imm = #-0x10e0
700af140: f242 61a0    	movw	r1, #0x26a0
700af144: f2c7 010b    	movt	r1, #0x700b
700af148: 6008         	str	r0, [r1]
; }
700af14a: b002         	add	sp, #0x8
700af14c: bd80         	pop	{r7, pc}
700af14e: 0000         	movs	r0, r0

700af150 <Sciclient_rmPsGetIrqNode>:
; {
700af150: b081         	sub	sp, #0x4
700af152: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return gPstack.ps[index].p_n;
700af156: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700af15a: eb00 0140    	add.w	r1, r0, r0, lsl #1
700af15e: f241 0058    	movw	r0, #0x1058
700af162: f2c7 0008    	movt	r0, #0x7008
700af166: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700af16a: b001         	add	sp, #0x4
700af16c: 4770         	bx	lr
700af16e: 0000         	movs	r0, r0

700af170 <Sciclient_rmPsInit>:
; {
700af170: b580         	push	{r7, lr}
700af172: b082         	sub	sp, #0x8
;     memset(&gPstack.ps[0], 0, sizeof(gPstack.ps));
700af174: f241 0058    	movw	r0, #0x1058
700af178: f2c7 0008    	movt	r0, #0x7008
700af17c: 9001         	str	r0, [sp, #0x4]
700af17e: 2124         	movs	r1, #0x24
700af180: f7eb ef88    	blx	0x7009b094 <__aeabi_memclr8> @ imm = #-0x140f0
700af184: 9901         	ldr	r1, [sp, #0x4]
700af186: 2000         	movs	r0, #0x0
;     gPstack.psp = 0;
700af188: 8488         	strh	r0, [r1, #0x24]
; }
700af18a: b002         	add	sp, #0x8
700af18c: bd80         	pop	{r7, pc}
700af18e: 0000         	movs	r0, r0

700af190 <UART_breakCtl>:
; {
700af190: b580         	push	{r7, lr}
700af192: b082         	sub	sp, #0x8
700af194: 9001         	str	r0, [sp, #0x4]
700af196: 9100         	str	r1, [sp]
;     HW_WR_FIELD32(baseAddr + UART_LCR, UART_LCR_BREAK_EN,
700af198: 9801         	ldr	r0, [sp, #0x4]
700af19a: 300c         	adds	r0, #0xc
700af19c: 9900         	ldr	r1, [sp]
700af19e: ea4f 1391    	lsr.w	r3, r1, #0x6
700af1a2: 2140         	movs	r1, #0x40
700af1a4: 2206         	movs	r2, #0x6
700af1a6: f7ff f933    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #-0xd9a
; }
700af1aa: b002         	add	sp, #0x8
700af1ac: bd80         	pop	{r7, pc}
700af1ae: 0000         	movs	r0, r0

700af1b0 <UART_lld_Transaction_deInit>:
; {
700af1b0: b081         	sub	sp, #0x4
700af1b2: 9000         	str	r0, [sp]
;     trans->buf              = NULL;
700af1b4: 9900         	ldr	r1, [sp]
700af1b6: 2000         	movs	r0, #0x0
700af1b8: 6008         	str	r0, [r1]
;     trans->count            = 0U;
700af1ba: 9900         	ldr	r1, [sp]
700af1bc: 6048         	str	r0, [r1, #0x4]
;     trans->timeout          = 0U;
700af1be: 9900         	ldr	r1, [sp]
700af1c0: 6088         	str	r0, [r1, #0x8]
;     trans->status           = UART_STATUS_SUCCESS;
700af1c2: 9900         	ldr	r1, [sp]
700af1c4: 60c8         	str	r0, [r1, #0xc]
;     trans->args             = NULL;
700af1c6: 9900         	ldr	r1, [sp]
700af1c8: 6108         	str	r0, [r1, #0x10]
; }
700af1ca: b001         	add	sp, #0x4
700af1cc: 4770         	bx	lr
700af1ce: 0000         	movs	r0, r0

700af1d0 <UART_writeInterrupt>:
; {
700af1d0: b580         	push	{r7, lr}
700af1d2: b084         	sub	sp, #0x10
700af1d4: 9003         	str	r0, [sp, #0xc]
700af1d6: 2000         	movs	r0, #0x0
;     int32_t     status = UART_STATUS_SUCCESS;
700af1d8: 9002         	str	r0, [sp, #0x8]
;     baseAddr = hUart->baseAddr;
700af1da: 9803         	ldr	r0, [sp, #0xc]
700af1dc: 6800         	ldr	r0, [r0]
700af1de: 9001         	str	r0, [sp, #0x4]
;     UART_intrEnable(baseAddr, UART_INTR_THR);
700af1e0: 9801         	ldr	r0, [sp, #0x4]
700af1e2: 2102         	movs	r1, #0x2
700af1e4: f7f6 fe4c    	bl	0x700a5e80 <UART_intrEnable> @ imm = #-0x9368
;     return status;
700af1e8: 9802         	ldr	r0, [sp, #0x8]
700af1ea: b004         	add	sp, #0x10
700af1ec: bd80         	pop	{r7, pc}
700af1ee: 0000         	movs	r0, r0

700af1f0 <UdmaChPdmaPrms_init>:
; {
700af1f0: b081         	sub	sp, #0x4
700af1f2: 9000         	str	r0, [sp]
;     if(NULL_PTR != pdmaPrms)
700af1f4: 9800         	ldr	r0, [sp]
700af1f6: b140         	cbz	r0, 0x700af20a <UdmaChPdmaPrms_init+0x1a> @ imm = #0x10
700af1f8: e7ff         	b	0x700af1fa <UdmaChPdmaPrms_init+0xa> @ imm = #-0x2
;         pdmaPrms->elemSize  = UDMA_PDMA_ES_8BITS;
700af1fa: 9900         	ldr	r1, [sp]
700af1fc: 2000         	movs	r0, #0x0
700af1fe: 6008         	str	r0, [r1]
;         pdmaPrms->elemCnt   = 0U;
700af200: 9900         	ldr	r1, [sp]
700af202: 6048         	str	r0, [r1, #0x4]
;         pdmaPrms->fifoCnt   = 0U;
700af204: 9900         	ldr	r1, [sp]
700af206: 6088         	str	r0, [r1, #0x8]
;     }
700af208: e7ff         	b	0x700af20a <UdmaChPdmaPrms_init+0x1a> @ imm = #-0x2
;     return;
700af20a: b001         	add	sp, #0x4
700af20c: 4770         	bx	lr
700af20e: 0000         	movs	r0, r0

700af210 <prvTimerTask>:
;     {
700af210: b580         	push	{r7, lr}
700af212: b084         	sub	sp, #0x10
700af214: 9003         	str	r0, [sp, #0xc]
;         for( ; ; )
700af216: e7ff         	b	0x700af218 <prvTimerTask+0x8> @ imm = #-0x2
700af218: a801         	add	r0, sp, #0x4
;             xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
700af21a: f7fe fc41    	bl	0x700adaa0 <prvGetNextExpireTime> @ imm = #-0x177e
700af21e: 9002         	str	r0, [sp, #0x8]
;             prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
700af220: 9802         	ldr	r0, [sp, #0x8]
700af222: 9901         	ldr	r1, [sp, #0x4]
700af224: f7fb f8d4    	bl	0x700aa3d0 <prvProcessTimerOrBlockTask> @ imm = #-0x4e58
;             prvProcessReceivedCommands();
700af228: f7f3 fbb2    	bl	0x700a2990 <prvProcessReceivedCommands> @ imm = #-0xc89c
;         for( ; ; )
700af22c: e7f4         	b	0x700af218 <prvTimerTask+0x8> @ imm = #-0x18
700af22e: 0000         	movs	r0, r0

700af230 <xPortStartScheduler>:
; BaseType_t xPortStartScheduler(void) {
700af230: b580         	push	{r7, lr}
700af232: b082         	sub	sp, #0x8
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700af234: b672         	cpsid i
;   ulPortSchedularRunning = pdTRUE;
700af236: f242 61d0    	movw	r1, #0x26d0
700af23a: f2c7 010b    	movt	r1, #0x700b
700af23e: 2001         	movs	r0, #0x1
700af240: 9001         	str	r0, [sp, #0x4]
700af242: 6008         	str	r0, [r1]
;   vPortRestoreTaskContext();
700af244: f001 e916    	blx	0x700b0474 <vPortRestoreTaskContext> @ imm = #0x122c
700af248: 9801         	ldr	r0, [sp, #0x4]
;   return pdTRUE;
700af24a: b002         	add	sp, #0x8
700af24c: bd80         	pop	{r7, pc}
700af24e: 0000         	movs	r0, r0

700af250 <xTaskGetTickCount>:
; TickType_t xTaskGetTickCount(void) {
700af250: b580         	push	{r7, lr}
700af252: b082         	sub	sp, #0x8
;   portTICK_TYPE_ENTER_CRITICAL();
700af254: f7ff f93c    	bl	0x700ae4d0 <vTaskEnterCritical> @ imm = #-0xd88
;     xTicks = xTickCount;
700af258: f242 7004    	movw	r0, #0x2704
700af25c: f2c7 000b    	movt	r0, #0x700b
700af260: 6800         	ldr	r0, [r0]
700af262: 9001         	str	r0, [sp, #0x4]
;   portTICK_TYPE_EXIT_CRITICAL();
700af264: f7fe f9f4    	bl	0x700ad650 <vTaskExitCritical> @ imm = #-0x1c18
;   return xTicks;
700af268: 9801         	ldr	r0, [sp, #0x4]
700af26a: b002         	add	sp, #0x8
700af26c: bd80         	pop	{r7, pc}
700af26e: 0000         	movs	r0, r0

700af270 <CSL_secProxyGetDataAddr>:
; {
700af270: b084         	sub	sp, #0x10
700af272: 9003         	str	r0, [sp, #0xc]
700af274: 9102         	str	r1, [sp, #0x8]
700af276: 9201         	str	r2, [sp, #0x4]
;     dataAddr = (uintptr_t)pSecProxyCfg->proxyTargetAddr + ((uintptr_t)threadNum * CSL_SEC_PROXY_TARGET_CHAN_SIZE) + (uintptr_t)CSL_SEC_PROXY_RSVD_MSG_BYTES;
700af278: 9803         	ldr	r0, [sp, #0xc]
700af27a: 6900         	ldr	r0, [r0, #0x10]
700af27c: 9902         	ldr	r1, [sp, #0x8]
700af27e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700af282: 3004         	adds	r0, #0x4
700af284: 9000         	str	r0, [sp]
;     return dataAddr;
700af286: 9800         	ldr	r0, [sp]
700af288: b004         	add	sp, #0x10
700af28a: 4770         	bx	lr
700af28c: 0000         	movs	r0, r0
700af28e: 0000         	movs	r0, r0

700af290 <UART_IsParameter>:
; {
700af290: b082         	sub	sp, #0x8
700af292: 9001         	str	r0, [sp, #0x4]
700af294: 2000         	movs	r0, #0x0
;     int32_t status = UART_STATUS_SUCCESS;
700af296: 9000         	str	r0, [sp]
;     if(InuptParameter == 0U)
700af298: 9801         	ldr	r0, [sp, #0x4]
700af29a: b920         	cbnz	r0, 0x700af2a6 <UART_IsParameter+0x16> @ imm = #0x8
700af29c: e7ff         	b	0x700af29e <UART_IsParameter+0xe> @ imm = #-0x2
700af29e: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700af2a2: 9000         	str	r0, [sp]
;     }
700af2a4: e7ff         	b	0x700af2a6 <UART_IsParameter+0x16> @ imm = #-0x2
;     return status;
700af2a6: 9800         	ldr	r0, [sp]
700af2a8: b002         	add	sp, #0x8
700af2aa: 4770         	bx	lr
700af2ac: 0000         	movs	r0, r0
700af2ae: 0000         	movs	r0, r0

700af2b0 <pvPortMalloc>:
; {
700af2b0: b580         	push	{r7, lr}
700af2b2: b082         	sub	sp, #0x8
700af2b4: 9001         	str	r0, [sp, #0x4]
;     vTaskSuspendAll();
700af2b6: f000 fafb    	bl	0x700af8b0 <vTaskSuspendAll> @ imm = #0x5f6
;         pvReturn = malloc( xWantedSize );
700af2ba: 9801         	ldr	r0, [sp, #0x4]
700af2bc: f7ed efda    	blx	0x7009d274 <malloc>     @ imm = #-0x1204c
700af2c0: 9000         	str	r0, [sp]
;     ( void ) xTaskResumeAll();
700af2c2: f7f2 fee5    	bl	0x700a2090 <xTaskResumeAll> @ imm = #-0xd236
;     return pvReturn;
700af2c6: 9800         	ldr	r0, [sp]
700af2c8: b002         	add	sp, #0x8
700af2ca: bd80         	pop	{r7, pc}

700af2cc <strlen>:
700af2cc: e3a01000     	mov	r1, #0
700af2d0: e7d02001     	ldrb	r2, [r0, r1]
700af2d4: e2811001     	add	r1, r1, #1
700af2d8: e3520000     	cmp	r2, #0
700af2dc: 1afffffb     	bne	0x700af2d0 <strlen+0x4> @ imm = #-0x14
700af2e0: e2410001     	sub	r0, r1, #1
700af2e4: e12fff1e     	bx	lr
		...

700af2f0 <vPortYeildFromISR>:
; void vPortYeildFromISR(uint32_t xSwitchRequired) {
700af2f0: b081         	sub	sp, #0x4
700af2f2: 9000         	str	r0, [sp]
;   if (xSwitchRequired != pdFALSE) {
700af2f4: 9800         	ldr	r0, [sp]
700af2f6: b138         	cbz	r0, 0x700af308 <vPortYeildFromISR+0x18> @ imm = #0xe
700af2f8: e7ff         	b	0x700af2fa <vPortYeildFromISR+0xa> @ imm = #-0x2
;     ulPortYieldRequired = pdTRUE;
700af2fa: f242 61d8    	movw	r1, #0x26d8
700af2fe: f2c7 010b    	movt	r1, #0x700b
700af302: 2001         	movs	r0, #0x1
700af304: 6008         	str	r0, [r1]
;   }
700af306: e7ff         	b	0x700af308 <vPortYeildFromISR+0x18> @ imm = #-0x2
; }
700af308: b001         	add	sp, #0x4
700af30a: 4770         	bx	lr

700af30c <TI_memcpy_small>:
700af30c: e3a0c000     	mov	r12, #0

700af310 <_loop>:
700af310: e152000c     	cmp	r2, r12
700af314: 012fff1e     	bxeq	lr
700af318: e7d1300c     	ldrb	r3, [r1, r12]
700af31c: e7c0300c     	strb	r3, [r0, r12]
700af320: e28cc001     	add	r12, r12, #1
700af324: eafffff9     	b	0x700af310 <_loop>      @ imm = #-0x1c
		...

700af330 <CSL_udmapCppi5SetDescType>:
; {
700af330: b082         	sub	sp, #0x8
700af332: 9001         	str	r0, [sp, #0x4]
700af334: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_DTYPE, descType );
700af336: 9901         	ldr	r1, [sp, #0x4]
700af338: 6808         	ldr	r0, [r1]
700af33a: f020 4040    	bic	r0, r0, #0xc0000000
700af33e: 9a00         	ldr	r2, [sp]
700af340: ea40 7082    	orr.w	r0, r0, r2, lsl #30
700af344: 6008         	str	r0, [r1]
; }
700af346: b002         	add	sp, #0x8
700af348: 4770         	bx	lr
700af34a: 0000         	movs	r0, r0
700af34c: 0000         	movs	r0, r0
700af34e: 0000         	movs	r0, r0

700af350 <UART_fifoCharGet>:
; {
700af350: b580         	push	{r7, lr}
700af352: b082         	sub	sp, #0x8
700af354: 9001         	str	r0, [sp, #0x4]
700af356: 2000         	movs	r0, #0x0
;     uint32_t tempRetVal = 0U;
700af358: 9000         	str	r0, [sp]
;     tempRetVal = HW_RD_REG32(baseAddr + UART_RHR);
700af35a: 9801         	ldr	r0, [sp, #0x4]
700af35c: f000 fa80    	bl	0x700af860 <HW_RD_REG32_RAW> @ imm = #0x500
700af360: 9000         	str	r0, [sp]
;     return ((uint8_t) tempRetVal);
700af362: f89d 0000    	ldrb.w	r0, [sp]
700af366: b002         	add	sp, #0x8
700af368: bd80         	pop	{r7, pc}
700af36a: 0000         	movs	r0, r0
700af36c: 0000         	movs	r0, r0
700af36e: 0000         	movs	r0, r0

700af370 <UART_timeGuardConfig>:
; {
700af370: b580         	push	{r7, lr}
700af372: b082         	sub	sp, #0x8
700af374: 9001         	str	r0, [sp, #0x4]
700af376: 9100         	str	r1, [sp]
;     HW_WR_FIELD32(baseAddr + UART_TIMEGUARD, UART_TIMEGUARD_TIMEGUARD,
700af378: 9801         	ldr	r0, [sp, #0x4]
700af37a: 3094         	adds	r0, #0x94
700af37c: 9b00         	ldr	r3, [sp]
700af37e: 21ff         	movs	r1, #0xff
700af380: 2200         	movs	r2, #0x0
700af382: f7ff f845    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #-0xf76
; }
700af386: b002         	add	sp, #0x8
700af388: bd80         	pop	{r7, pc}
700af38a: 0000         	movs	r0, r0
700af38c: 0000         	movs	r0, r0
700af38e: 0000         	movs	r0, r0

700af390 <CSL_udmapCppi5SetPsDataLen>:
; {
700af390: b082         	sub	sp, #0x8
700af392: 9001         	str	r0, [sp, #0x4]
700af394: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PSWCNT, (psDataLen/4U) );
700af396: 9901         	ldr	r1, [sp, #0x4]
700af398: 6808         	ldr	r0, [r1]
700af39a: 9a00         	ldr	r2, [sp]
700af39c: 0892         	lsrs	r2, r2, #0x2
700af39e: f362 509b    	bfi	r0, r2, #22, #6
700af3a2: 6008         	str	r0, [r1]
; }
700af3a4: b002         	add	sp, #0x8
700af3a6: 4770         	bx	lr
		...

700af3b0 <Sciclient_rmIrqSet>:
; {
700af3b0: b580         	push	{r7, lr}
700af3b2: b084         	sub	sp, #0x10
700af3b4: 9003         	str	r0, [sp, #0xc]
700af3b6: 9102         	str	r1, [sp, #0x8]
700af3b8: 9201         	str	r2, [sp, #0x4]
;     return Sciclient_rmProgramInterruptRoute(req, resp, timeout);
700af3ba: 9803         	ldr	r0, [sp, #0xc]
700af3bc: 9902         	ldr	r1, [sp, #0x8]
700af3be: 9a01         	ldr	r2, [sp, #0x4]
700af3c0: f7f1 fb76    	bl	0x700a0ab0 <Sciclient_rmProgramInterruptRoute> @ imm = #-0xe914
700af3c4: b004         	add	sp, #0x10
700af3c6: bd80         	pop	{r7, pc}
		...

700af3d0 <Sciclient_secProxyThreadStatusReg>:
; {
700af3d0: b081         	sub	sp, #0x4
700af3d2: 9000         	str	r0, [sp]
;     return ((uint32_t)(uintptr_t)(gSciclientSecProxyCfg.pSecProxyRtRegs) +
700af3d4: f242 5080    	movw	r0, #0x2580
700af3d8: f2c7 000b    	movt	r0, #0x700b
700af3dc: 6880         	ldr	r0, [r0, #0x8]
;         CSL_SEC_PROXY_RT_THREAD_STATUS(thread));
700af3de: 9900         	ldr	r1, [sp]
;     return ((uint32_t)(uintptr_t)(gSciclientSecProxyCfg.pSecProxyRtRegs) +
700af3e0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700af3e4: b001         	add	sp, #0x4
700af3e6: 4770         	bx	lr
		...

700af3f0 <TimerP_start>:
; {
700af3f0: b082         	sub	sp, #0x8
700af3f2: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (uint32_t *)(baseAddr + TIMER_TCLR);
700af3f4: 9801         	ldr	r0, [sp, #0x4]
700af3f6: 3038         	adds	r0, #0x38
700af3f8: 9000         	str	r0, [sp]
;     *addr |= (0x1U << 0);
700af3fa: 9900         	ldr	r1, [sp]
700af3fc: 6808         	ldr	r0, [r1]
700af3fe: f040 0001    	orr	r0, r0, #0x1
700af402: 6008         	str	r0, [r1]
; }
700af404: b002         	add	sp, #0x8
700af406: 4770         	bx	lr
		...

700af410 <TimerP_stop>:
; {
700af410: b082         	sub	sp, #0x8
700af412: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TCLR);
700af414: 9801         	ldr	r0, [sp, #0x4]
700af416: 3038         	adds	r0, #0x38
700af418: 9000         	str	r0, [sp]
;     *addr &= ~(0x1U << 0);
700af41a: 9900         	ldr	r1, [sp]
700af41c: 6808         	ldr	r0, [r1]
700af41e: f020 0001    	bic	r0, r0, #0x1
700af422: 6008         	str	r0, [r1]
; }
700af424: b002         	add	sp, #0x8
700af426: 4770         	bx	lr
		...

700af430 <UART_divisorLatchDisable>:
; {
700af430: b580         	push	{r7, lr}
700af432: b082         	sub	sp, #0x8
700af434: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_LCR, UART_LCR_DIV_EN,
700af436: 9801         	ldr	r0, [sp, #0x4]
700af438: 300c         	adds	r0, #0xc
700af43a: 2180         	movs	r1, #0x80
700af43c: 2207         	movs	r2, #0x7
700af43e: 2300         	movs	r3, #0x0
700af440: f7fe ffe6    	bl	0x700ae410 <HW_WR_FIELD32_RAW> @ imm = #-0x1034
; }
700af444: b002         	add	sp, #0x8
700af446: bd80         	pop	{r7, pc}
		...

700af450 <UART_modemControlReset>:
; {
700af450: b580         	push	{r7, lr}
700af452: b082         	sub	sp, #0x8
700af454: 9001         	str	r0, [sp, #0x4]
700af456: 2000         	movs	r0, #0x0
;     uint32_t mcrResetVal = 0U;
700af458: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_MCR, mcrResetVal);
700af45a: 9801         	ldr	r0, [sp, #0x4]
700af45c: 3010         	adds	r0, #0x10
700af45e: 9900         	ldr	r1, [sp]
700af460: f000 fa06    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x40c
; }
700af464: b002         	add	sp, #0x8
700af466: bd80         	pop	{r7, pc}
		...

700af470 <UART_putChar>:
; {
700af470: b580         	push	{r7, lr}
700af472: b082         	sub	sp, #0x8
700af474: 9001         	str	r0, [sp, #0x4]
700af476: f88d 1003    	strb.w	r1, [sp, #0x3]
;     HW_WR_REG32(baseAddr + UART_THR, (uint32_t) byteTx);
700af47a: 9801         	ldr	r0, [sp, #0x4]
700af47c: f89d 1003    	ldrb.w	r1, [sp, #0x3]
700af480: f000 f9f6    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x3ec
; }
700af484: b002         	add	sp, #0x8
700af486: bd80         	pop	{r7, pc}

700af488 <TI_memset_small>:
700af488: e3a03000     	mov	r3, #0

700af48c <_loop>:
700af48c: e1520003     	cmp	r2, r3
700af490: 012fff1e     	bxeq	lr
700af494: e7c01003     	strb	r1, [r0, r3]
700af498: e2833001     	add	r3, r3, #1
700af49c: eafffffa     	b	0x700af48c <_loop>      @ imm = #-0x18

700af4a0 <CSL_REG64_WR_RAW>:
; {
700af4a0: b084         	sub	sp, #0x10
700af4a2: 9003         	str	r0, [sp, #0xc]
700af4a4: 9301         	str	r3, [sp, #0x4]
700af4a6: 9200         	str	r2, [sp]
;     *p = v;
700af4a8: 9800         	ldr	r0, [sp]
700af4aa: 9901         	ldr	r1, [sp, #0x4]
700af4ac: 9a03         	ldr	r2, [sp, #0xc]
700af4ae: e9c2 0100    	strd	r0, r1, [r2]
;     return;
700af4b2: b004         	add	sp, #0x10
700af4b4: 4770         	bx	lr
		...
700af4be: 0000         	movs	r0, r0

700af4c0 <CSL_udmapCppi5LinkDesc>:
; {
700af4c0: b084         	sub	sp, #0x10
700af4c2: 9003         	str	r0, [sp, #0xc]
700af4c4: 9301         	str	r3, [sp, #0x4]
700af4c6: 9200         	str	r2, [sp]
;     pDesc->nextDescPtr = physBufferDescAddr;
700af4c8: 9800         	ldr	r0, [sp]
700af4ca: 9a01         	ldr	r2, [sp, #0x4]
700af4cc: 9903         	ldr	r1, [sp, #0xc]
700af4ce: 614a         	str	r2, [r1, #0x14]
700af4d0: 6108         	str	r0, [r1, #0x10]
; }
700af4d2: b004         	add	sp, #0x10
700af4d4: 4770         	bx	lr
		...
700af4de: 0000         	movs	r0, r0

700af4e0 <CSL_udmapCppi5SetBufferAddr>:
; {
700af4e0: b084         	sub	sp, #0x10
700af4e2: 9003         	str	r0, [sp, #0xc]
700af4e4: 9301         	str	r3, [sp, #0x4]
700af4e6: 9200         	str	r2, [sp]
;     pDesc->bufPtr    = physBufferAddr;
700af4e8: 9800         	ldr	r0, [sp]
700af4ea: 9a01         	ldr	r2, [sp, #0x4]
700af4ec: 9903         	ldr	r1, [sp, #0xc]
700af4ee: 61ca         	str	r2, [r1, #0x1c]
700af4f0: 6188         	str	r0, [r1, #0x18]
; }
700af4f2: b004         	add	sp, #0x10
700af4f4: 4770         	bx	lr
		...
700af4fe: 0000         	movs	r0, r0

700af500 <CSL_udmapCppi5SetBufferLen>:
; {
700af500: b082         	sub	sp, #0x8
700af502: 9001         	str	r0, [sp, #0x4]
700af504: 9100         	str	r1, [sp]
;     CSL_FINS( pDesc->bufInfo1, UDMAP_CPPI5_PD_BUFINFO1_LEN, bufferLenBytes );
700af506: 9901         	ldr	r1, [sp, #0x4]
700af508: 6a08         	ldr	r0, [r1, #0x20]
700af50a: 9a00         	ldr	r2, [sp]
700af50c: f362 0015    	bfi	r0, r2, #0, #22
700af510: 6208         	str	r0, [r1, #0x20]
; }
700af512: b002         	add	sp, #0x8
700af514: 4770         	bx	lr
		...
700af51e: 0000         	movs	r0, r0

700af520 <CSL_udmapCppi5SetOrgBufferAddr>:
; {
700af520: b084         	sub	sp, #0x10
700af522: 9003         	str	r0, [sp, #0xc]
700af524: 9301         	str	r3, [sp, #0x4]
700af526: 9200         	str	r2, [sp]
;     pDesc->orgBufPtr = physBufferAddr;
700af528: 9800         	ldr	r0, [sp]
700af52a: 9a01         	ldr	r2, [sp, #0x4]
700af52c: 9903         	ldr	r1, [sp, #0xc]
700af52e: 62ca         	str	r2, [r1, #0x2c]
700af530: 6288         	str	r0, [r1, #0x28]
; }
700af532: b004         	add	sp, #0x10
700af534: 4770         	bx	lr
		...
700af53e: 0000         	movs	r0, r0

700af540 <CSL_udmapCppi5SetPsDataLoc>:
; {
700af540: b082         	sub	sp, #0x8
700af542: 9001         	str	r0, [sp, #0x4]
700af544: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PSINFO, psLoc );
700af546: 9901         	ldr	r1, [sp, #0x4]
700af548: 6808         	ldr	r0, [r1]
700af54a: 9a00         	ldr	r2, [sp]
700af54c: f362 701c    	bfi	r0, r2, #28, #1
700af550: 6008         	str	r0, [r1]
; }
700af552: b002         	add	sp, #0x8
700af554: 4770         	bx	lr
		...
700af55e: 0000         	movs	r0, r0

700af560 <CSL_udmapCppi5SetPsFlags>:
; {
700af560: b082         	sub	sp, #0x8
700af562: 9001         	str	r0, [sp, #0x4]
700af564: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1, UDMAP_CPPI5_PD_PKTINFO1_PSFLGS, psFlags );
700af566: 9901         	ldr	r1, [sp, #0x4]
700af568: 6848         	ldr	r0, [r1, #0x4]
700af56a: 9a00         	ldr	r2, [sp]
700af56c: f362 601b    	bfi	r0, r2, #24, #4
700af570: 6048         	str	r0, [r1, #0x4]
; }
700af572: b002         	add	sp, #0x8
700af574: 4770         	bx	lr
		...
700af57e: 0000         	movs	r0, r0

700af580 <Sciclient_rmIrqRelease>:
; {
700af580: b580         	push	{r7, lr}
700af582: b084         	sub	sp, #0x10
700af584: 9003         	str	r0, [sp, #0xc]
700af586: 9102         	str	r1, [sp, #0x8]
;     return Sciclient_rmClearInterruptRoute(req, &resp, timeout);
700af588: 9803         	ldr	r0, [sp, #0xc]
700af58a: 9a02         	ldr	r2, [sp, #0x8]
700af58c: 4669         	mov	r1, sp
700af58e: f7f0 ff5f    	bl	0x700a0450 <Sciclient_rmClearInterruptRoute> @ imm = #-0xf142
700af592: b004         	add	sp, #0x10
700af594: bd80         	pop	{r7, pc}
		...
700af59e: 0000         	movs	r0, r0

700af5a0 <Sciclient_secProxyReadThreadCount>:
; {
700af5a0: b580         	push	{r7, lr}
700af5a2: b082         	sub	sp, #0x8
700af5a4: 9001         	str	r0, [sp, #0x4]
;     return (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700af5a6: 9801         	ldr	r0, [sp, #0x4]
700af5a8: f7ff ff12    	bl	0x700af3d0 <Sciclient_secProxyThreadStatusReg> @ imm = #-0x1dc
700af5ac: f000 f9b8    	bl	0x700af920 <CSL_REG32_RD_RAW> @ imm = #0x370
700af5b0: b2c0         	uxtb	r0, r0
700af5b2: b002         	add	sp, #0x8
700af5b4: bd80         	pop	{r7, pc}
		...
700af5be: 0000         	movs	r0, r0

700af5c0 <SemaphoreP_destruct>:
; {
700af5c0: b580         	push	{r7, lr}
700af5c2: b082         	sub	sp, #0x8
700af5c4: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700af5c6: 9801         	ldr	r0, [sp, #0x4]
700af5c8: 9000         	str	r0, [sp]
;     vSemaphoreDelete(pSemaphore->semHndl);
700af5ca: 9800         	ldr	r0, [sp]
700af5cc: 6d00         	ldr	r0, [r0, #0x50]
700af5ce: f7ff fb4f    	bl	0x700aec70 <vQueueDelete> @ imm = #-0x962
; }
700af5d2: b002         	add	sp, #0x8
700af5d4: bd80         	pop	{r7, pc}
		...
700af5de: 0000         	movs	r0, r0

700af5e0 <UART_divideRoundCloset>:
; {
700af5e0: b082         	sub	sp, #0x8
700af5e2: 9001         	str	r0, [sp, #0x4]
700af5e4: 9100         	str	r1, [sp]
;     return ((divident + (divisor/2U))/divisor);
700af5e6: 9801         	ldr	r0, [sp, #0x4]
700af5e8: 9900         	ldr	r1, [sp]
700af5ea: eb00 0051    	add.w	r0, r0, r1, lsr #1
700af5ee: fbb0 f0f1    	udiv	r0, r0, r1
700af5f2: b002         	add	sp, #0x8
700af5f4: 4770         	bx	lr
		...
700af5fe: 0000         	movs	r0, r0

700af600 <UART_regConfModeRestore>:
; {
700af600: b580         	push	{r7, lr}
700af602: b082         	sub	sp, #0x8
700af604: 9001         	str	r0, [sp, #0x4]
700af606: 9100         	str	r1, [sp]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700af608: 9801         	ldr	r0, [sp, #0x4]
700af60a: 300c         	adds	r0, #0xc
700af60c: 9900         	ldr	r1, [sp]
700af60e: f000 f92f    	bl	0x700af870 <HW_WR_REG32_RAW> @ imm = #0x25e
; }
700af612: b002         	add	sp, #0x8
700af614: bd80         	pop	{r7, pc}
		...
700af61e: 0000         	movs	r0, r0

700af620 <tm_thread_resume>:
; {
700af620: b580         	push	{r7, lr}
;    vTaskResume(tm_thread_array[thread_id]);
700af622: f245 1148    	movw	r1, #0x5148
700af626: f2c7 0108    	movt	r1, #0x7008
700af62a: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700af62e: f7f9 f87f    	bl	0x700a8730 <vTaskResume> @ imm = #-0x6f02
;    return TM_SUCCESS;
700af632: 2000         	movs	r0, #0x0
700af634: bd80         	pop	{r7, pc}
		...
700af63e: 0000         	movs	r0, r0

700af640 <DebugP_uartSetDrvIndex>:
; {
700af640: b081         	sub	sp, #0x4
700af642: 9000         	str	r0, [sp]
;     gDebugP_uartDrvIndex = uartDrvIndex;
700af644: 9800         	ldr	r0, [sp]
700af646: f242 61a4    	movw	r1, #0x26a4
700af64a: f2c7 010b    	movt	r1, #0x700b
700af64e: 6008         	str	r0, [r1]
; }
700af650: b001         	add	sp, #0x4
700af652: 4770         	bx	lr
		...

700af660 <Sciclient_rmIrIntControlReg>:
; {
700af660: b081         	sub	sp, #0x4
700af662: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return (outp * SCICLIENT_IR_INT_CONTROL_REG_STEP) +
700af666: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700af66a: 2004         	movs	r0, #0x4
700af66c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700af670: b001         	add	sp, #0x4
700af672: 4770         	bx	lr
		...

700af680 <Udma_rmAllocFreeRing>:
; {
700af680: b082         	sub	sp, #0x8
700af682: 9001         	str	r0, [sp, #0x4]
700af684: f64f 70ff    	movw	r0, #0xffff
;     uint16_t            ringNum = UDMA_RING_INVALID;
700af688: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return (ringNum);
700af68c: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700af690: b002         	add	sp, #0x8
700af692: 4770         	bx	lr
		...

700af6a0 <xTaskGetCurrentTaskHandle>:
; TaskHandle_t xTaskGetCurrentTaskHandle(void) {
700af6a0: b081         	sub	sp, #0x4
;   xReturn = pxCurrentTCB;
700af6a2: f242 60bc    	movw	r0, #0x26bc
700af6a6: f2c7 000b    	movt	r0, #0x700b
700af6aa: 6800         	ldr	r0, [r0]
700af6ac: 9000         	str	r0, [sp]
;   return xReturn;
700af6ae: 9800         	ldr	r0, [sp]
700af6b0: b001         	add	sp, #0x4
700af6b2: 4770         	bx	lr
		...

700af6c0 <CSL_udmapCppi5SetSrcTag>:
; {
700af6c0: b082         	sub	sp, #0x8
700af6c2: 9001         	str	r0, [sp, #0x4]
700af6c4: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->srcDstTag, UDMAP_CPPI5_PD_SRCDSTTAG_SRCTAG, srcTag );
700af6c6: 9901         	ldr	r1, [sp, #0x4]
700af6c8: f8bd 0000    	ldrh.w	r0, [sp]
700af6cc: 81c8         	strh	r0, [r1, #0xe]
; }
700af6ce: b002         	add	sp, #0x8
700af6d0: 4770         	bx	lr
		...
700af6de: 0000         	movs	r0, r0

700af6e0 <TimerP_getCount>:
; {
700af6e0: b082         	sub	sp, #0x8
700af6e2: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TCRR);
700af6e4: 9801         	ldr	r0, [sp, #0x4]
700af6e6: 303c         	adds	r0, #0x3c
700af6e8: 9000         	str	r0, [sp]
;     return *addr;
700af6ea: 9800         	ldr	r0, [sp]
700af6ec: 6800         	ldr	r0, [r0]
700af6ee: b002         	add	sp, #0x8
700af6f0: 4770         	bx	lr
		...
700af6fe: 0000         	movs	r0, r0

700af700 <TimerP_getReloadCount>:
; {
700af700: b082         	sub	sp, #0x8
700af702: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TLDR);
700af704: 9801         	ldr	r0, [sp, #0x4]
700af706: 3040         	adds	r0, #0x40
700af708: 9000         	str	r0, [sp]
;     return *addr;
700af70a: 9800         	ldr	r0, [sp]
700af70c: 6800         	ldr	r0, [r0]
700af70e: b002         	add	sp, #0x8
700af710: 4770         	bx	lr
		...
700af71e: 0000         	movs	r0, r0

700af720 <main_thread_locking_test>:
; {
700af720: b580         	push	{r7, lr}
;    tm_initialize(tm_thread_locking_test_initialize);
700af722: f64e 60f1    	movw	r0, #0xeef1
700af726: f2c7 0009    	movt	r0, #0x7009
700af72a: f000 f9d9    	bl	0x700afae0 <tm_initialize> @ imm = #0x3b2
;    return 0;
700af72e: 2000         	movs	r0, #0x0
700af730: bd80         	pop	{r7, pc}
		...
700af73e: 0000         	movs	r0, r0

700af740 <putchar_>:
; {
700af740: b510         	push	{r4, lr}
700af742: 4604         	mov	r4, r0
;     DebugP_memLogWriterPutChar(character);
700af744: f7f2 fdf4    	bl	0x700a2330 <DebugP_memLogWriterPutChar> @ imm = #-0xd418
;     DebugP_uartLogWriterPutChar(character);
700af748: 4620         	mov	r0, r4
700af74a: e8bd 4010    	pop.w	{r4, lr}
700af74e: f7fd bf07    	b.w	0x700ad560 <DebugP_uartLogWriterPutChar> @ imm = #-0x21f2
		...
700af75e: 0000         	movs	r0, r0

700af760 <tm_interrupt_handler>:
;    if (test_interrupt_handler != NULL)
700af760: f242 60c0    	movw	r0, #0x26c0
700af764: f2c7 000b    	movt	r0, #0x700b
700af768: 6800         	ldr	r0, [r0]
700af76a: 2800         	cmp	r0, #0x0
; }
700af76c: bf08         	it	eq
700af76e: 4770         	bxeq	lr
;       ((void (*)(void)) test_interrupt_handler)();
700af770: 4700         	bx	r0
		...
700af77e: 0000         	movs	r0, r0

700af780 <tm_setup_pmu>:
; {
700af780: b580         	push	{r7, lr}
;    PMU_init(&gPmuConfig);
700af782: f242 6040    	movw	r0, #0x2640
700af786: f2c7 000b    	movt	r0, #0x700b
700af78a: f7f1 fa59    	bl	0x700a0c40 <PMU_init>   @ imm = #-0xeb4e
;    return 1;
700af78e: 2001         	movs	r0, #0x1
700af790: bd80         	pop	{r7, pc}
		...
700af79e: 0000         	movs	r0, r0

700af7a0 <uiPortGetRunTimeCounterValue>:
; uint32_t uiPortGetRunTimeCounterValue() {
700af7a0: b580         	push	{r7, lr}
700af7a2: b082         	sub	sp, #0x8
;   uint64_t timeInUsecs = ClockP_getTimeUsec();
700af7a4: f7fb f8c4    	bl	0x700aa930 <ClockP_getTimeUsec> @ imm = #-0x4e78
700af7a8: 9101         	str	r1, [sp, #0x4]
700af7aa: 9000         	str	r0, [sp]
;   return (uint32_t)(timeInUsecs);
700af7ac: 9800         	ldr	r0, [sp]
700af7ae: b002         	add	sp, #0x8
700af7b0: bd80         	pop	{r7, pc}
		...
700af7be: 0000         	movs	r0, r0

700af7c0 <CSL_REG32_WR_RAW>:
; {
700af7c0: b082         	sub	sp, #0x8
700af7c2: 9001         	str	r0, [sp, #0x4]
700af7c4: 9100         	str	r1, [sp]
;     *p = v;
700af7c6: 9800         	ldr	r0, [sp]
700af7c8: 9901         	ldr	r1, [sp, #0x4]
700af7ca: 6008         	str	r0, [r1]
;     return;
700af7cc: b002         	add	sp, #0x8
700af7ce: 4770         	bx	lr

700af7d0 <CSL_REG32_WR_RAW>:
; {
700af7d0: b082         	sub	sp, #0x8
700af7d2: 9001         	str	r0, [sp, #0x4]
700af7d4: 9100         	str	r1, [sp]
;     *p = v;
700af7d6: 9800         	ldr	r0, [sp]
700af7d8: 9901         	ldr	r1, [sp, #0x4]
700af7da: 6008         	str	r0, [r1]
;     return;
700af7dc: b002         	add	sp, #0x8
700af7de: 4770         	bx	lr

700af7e0 <CSL_REG32_WR_RAW>:
; {
700af7e0: b082         	sub	sp, #0x8
700af7e2: 9001         	str	r0, [sp, #0x4]
700af7e4: 9100         	str	r1, [sp]
;     *p = v;
700af7e6: 9800         	ldr	r0, [sp]
700af7e8: 9901         	ldr	r1, [sp, #0x4]
700af7ea: 6008         	str	r0, [r1]
;     return;
700af7ec: b002         	add	sp, #0x8
700af7ee: 4770         	bx	lr

700af7f0 <CSL_REG32_WR_RAW>:
; {
700af7f0: b082         	sub	sp, #0x8
700af7f2: 9001         	str	r0, [sp, #0x4]
700af7f4: 9100         	str	r1, [sp]
;     *p = v;
700af7f6: 9800         	ldr	r0, [sp]
700af7f8: 9901         	ldr	r1, [sp, #0x4]
700af7fa: 6008         	str	r0, [r1]
;     return;
700af7fc: b002         	add	sp, #0x8
700af7fe: 4770         	bx	lr

700af800 <CSL_REG32_WR_RAW>:
; {
700af800: b082         	sub	sp, #0x8
700af802: 9001         	str	r0, [sp, #0x4]
700af804: 9100         	str	r1, [sp]
;     *p = v;
700af806: 9800         	ldr	r0, [sp]
700af808: 9901         	ldr	r1, [sp, #0x4]
700af80a: 6008         	str	r0, [r1]
;     return;
700af80c: b002         	add	sp, #0x8
700af80e: 4770         	bx	lr

700af810 <CSL_udmapCppi5SetDstTag>:
; {
700af810: b082         	sub	sp, #0x8
700af812: 9001         	str	r0, [sp, #0x4]
700af814: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->srcDstTag, UDMAP_CPPI5_PD_SRCDSTTAG_DSTTAG, dstTag );
700af816: 9901         	ldr	r1, [sp, #0x4]
700af818: 9800         	ldr	r0, [sp]
700af81a: 8188         	strh	r0, [r1, #0xc]
; }
700af81c: b002         	add	sp, #0x8
700af81e: 4770         	bx	lr

700af820 <CSL_udmapCppi5SetOrgBufferLen>:
; {
700af820: b082         	sub	sp, #0x8
700af822: 9001         	str	r0, [sp, #0x4]
700af824: 9100         	str	r1, [sp]
;     pDesc->orgBufLen = bufferLenBytes;
700af826: 9800         	ldr	r0, [sp]
700af828: 9901         	ldr	r1, [sp, #0x4]
700af82a: 6248         	str	r0, [r1, #0x24]
; }
700af82c: b002         	add	sp, #0x8
700af82e: 4770         	bx	lr

700af830 <ClockP_getTimerCount>:
; {
700af830: b580         	push	{r7, lr}
700af832: b082         	sub	sp, #0x8
700af834: 9001         	str	r0, [sp, #0x4]
;     return TimerP_getCount(timerBaseAddr);
700af836: 9801         	ldr	r0, [sp, #0x4]
700af838: f7ff ff52    	bl	0x700af6e0 <TimerP_getCount> @ imm = #-0x15c
700af83c: b002         	add	sp, #0x8
700af83e: bd80         	pop	{r7, pc}

700af840 <ClockP_sleepTicks>:
; {
700af840: b580         	push	{r7, lr}
700af842: b082         	sub	sp, #0x8
700af844: 9001         	str	r0, [sp, #0x4]
;     vTaskDelay(ticks);
700af846: 9801         	ldr	r0, [sp, #0x4]
700af848: f7fe fcaa    	bl	0x700ae1a0 <vTaskDelay> @ imm = #-0x16ac
; }
700af84c: b002         	add	sp, #0x8
700af84e: bd80         	pop	{r7, pc}

700af850 <ClockP_timerClearOverflowInt>:
; {
700af850: b580         	push	{r7, lr}
700af852: b082         	sub	sp, #0x8
700af854: 9001         	str	r0, [sp, #0x4]
;     TimerP_clearOverflowInt(timerBaseAddr);
700af856: 9801         	ldr	r0, [sp, #0x4]
700af858: f7ff f88a    	bl	0x700ae970 <TimerP_clearOverflowInt> @ imm = #-0xeec
; }
700af85c: b002         	add	sp, #0x8
700af85e: bd80         	pop	{r7, pc}

700af860 <HW_RD_REG32_RAW>:
; {
700af860: b082         	sub	sp, #0x8
700af862: 9001         	str	r0, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700af864: 9801         	ldr	r0, [sp, #0x4]
700af866: 6800         	ldr	r0, [r0]
700af868: 9000         	str	r0, [sp]
;     return (regVal);
700af86a: 9800         	ldr	r0, [sp]
700af86c: b002         	add	sp, #0x8
700af86e: 4770         	bx	lr

700af870 <HW_WR_REG32_RAW>:
; {
700af870: b082         	sub	sp, #0x8
700af872: 9001         	str	r0, [sp, #0x4]
700af874: 9100         	str	r1, [sp]
;     *(volatile uint32_t *) ((uintptr_t) addr) = value;
700af876: 9800         	ldr	r0, [sp]
700af878: 9901         	ldr	r1, [sp, #0x4]
700af87a: 6008         	str	r0, [r1]
;     return;
700af87c: b002         	add	sp, #0x8
700af87e: 4770         	bx	lr

700af880 <Udma_defaultVirtToPhyFxn>:
; {
700af880: b083         	sub	sp, #0xc
700af882: 9002         	str	r0, [sp, #0x8]
700af884: 9101         	str	r1, [sp, #0x4]
700af886: 9200         	str	r2, [sp]
;     return ((uint64_t) virtAddr);
700af888: 9802         	ldr	r0, [sp, #0x8]
700af88a: 2100         	movs	r1, #0x0
700af88c: b003         	add	sp, #0xc
700af88e: 4770         	bx	lr

700af890 <__aeabi_memset8>:
700af890: e1a03001     	mov	r3, r1
700af894: e1a01002     	mov	r1, r2
700af898: e1a02003     	mov	r2, r3
700af89c: eafffef9     	b	0x700af488 <TI_memset_small> @ imm = #-0x41c

700af8a0 <_out_null>:
; {
700af8a0: b084         	sub	sp, #0x10
700af8a2: f88d 000f    	strb.w	r0, [sp, #0xf]
700af8a6: 9102         	str	r1, [sp, #0x8]
700af8a8: 9201         	str	r2, [sp, #0x4]
700af8aa: 9300         	str	r3, [sp]
; }
700af8ac: b004         	add	sp, #0x10
700af8ae: 4770         	bx	lr

700af8b0 <vTaskSuspendAll>:
;   ++uxSchedulerSuspended;
700af8b0: f242 61e4    	movw	r1, #0x26e4
700af8b4: f2c7 010b    	movt	r1, #0x700b
700af8b8: 6808         	ldr	r0, [r1]
700af8ba: 3001         	adds	r0, #0x1
700af8bc: 6008         	str	r0, [r1]
; }
700af8be: 4770         	bx	lr

700af8c0 <CSL_REG64_RD_RAW>:
; {
700af8c0: b081         	sub	sp, #0x4
700af8c2: 9000         	str	r0, [sp]
;     return (*p);
700af8c4: 9800         	ldr	r0, [sp]
700af8c6: e9d0 0100    	ldrd	r0, r1, [r0]
700af8ca: b001         	add	sp, #0x4
700af8cc: 4770         	bx	lr
700af8ce: 0000         	movs	r0, r0

700af8d0 <vListInitialiseItem>:
; {
700af8d0: b081         	sub	sp, #0x4
700af8d2: 9000         	str	r0, [sp]
;     pxItem->pxContainer = NULL;
700af8d4: 9900         	ldr	r1, [sp]
700af8d6: 2000         	movs	r0, #0x0
700af8d8: 6108         	str	r0, [r1, #0x10]
; }
700af8da: b001         	add	sp, #0x4
700af8dc: 4770         	bx	lr
700af8de: 0000         	movs	r0, r0

700af8e0 <vTaskMissedYield>:
; void vTaskMissedYield(void) { xYieldPending = pdTRUE; }
700af8e0: f242 7110    	movw	r1, #0x2710
700af8e4: f2c7 010b    	movt	r1, #0x700b
700af8e8: 2001         	movs	r0, #0x1
700af8ea: 6008         	str	r0, [r1]
700af8ec: 4770         	bx	lr
700af8ee: 0000         	movs	r0, r0

700af8f0 <CSL_REG32_RD_RAW>:
; {
700af8f0: b081         	sub	sp, #0x4
700af8f2: 9000         	str	r0, [sp]
;     return (*p);
700af8f4: 9800         	ldr	r0, [sp]
700af8f6: 6800         	ldr	r0, [r0]
700af8f8: b001         	add	sp, #0x4
700af8fa: 4770         	bx	lr
700af8fc: 0000         	movs	r0, r0
700af8fe: 0000         	movs	r0, r0

700af900 <CSL_REG32_RD_RAW>:
; {
700af900: b081         	sub	sp, #0x4
700af902: 9000         	str	r0, [sp]
;     return (*p);
700af904: 9800         	ldr	r0, [sp]
700af906: 6800         	ldr	r0, [r0]
700af908: b001         	add	sp, #0x4
700af90a: 4770         	bx	lr
700af90c: 0000         	movs	r0, r0
700af90e: 0000         	movs	r0, r0

700af910 <CSL_REG32_RD_RAW>:
; {
700af910: b081         	sub	sp, #0x4
700af912: 9000         	str	r0, [sp]
;     return (*p);
700af914: 9800         	ldr	r0, [sp]
700af916: 6800         	ldr	r0, [r0]
700af918: b001         	add	sp, #0x4
700af91a: 4770         	bx	lr
700af91c: 0000         	movs	r0, r0
700af91e: 0000         	movs	r0, r0

700af920 <CSL_REG32_RD_RAW>:
; {
700af920: b081         	sub	sp, #0x4
700af922: 9000         	str	r0, [sp]
;     return (*p);
700af924: 9800         	ldr	r0, [sp]
700af926: 6800         	ldr	r0, [r0]
700af928: b001         	add	sp, #0x4
700af92a: 4770         	bx	lr
700af92c: 0000         	movs	r0, r0
700af92e: 0000         	movs	r0, r0

700af930 <CSL_REG32_RD_RAW>:
; {
700af930: b081         	sub	sp, #0x4
700af932: 9000         	str	r0, [sp]
;     return (*p);
700af934: 9800         	ldr	r0, [sp]
700af936: 6800         	ldr	r0, [r0]
700af938: b001         	add	sp, #0x4
700af93a: 4770         	bx	lr
700af93c: 0000         	movs	r0, r0
700af93e: 0000         	movs	r0, r0

700af940 <CSL_REG32_RD_RAW>:
; {
700af940: b081         	sub	sp, #0x4
700af942: 9000         	str	r0, [sp]
;     return (*p);
700af944: 9800         	ldr	r0, [sp]
700af946: 6800         	ldr	r0, [r0]
700af948: b001         	add	sp, #0x4
700af94a: 4770         	bx	lr
700af94c: 0000         	movs	r0, r0
700af94e: 0000         	movs	r0, r0

700af950 <PMU_resetCounters>:
; static void PMU_resetCounters(void) {
700af950: b580         	push	{r7, lr}
;   CSL_armR5PmuResetCycleCnt();
700af952: f7f2 eb88    	blx	0x700a2064 <CSL_armR5PmuResetCycleCnt> @ imm = #-0xd8f0
;   CSL_armR5PmuResetCntrs();
700af956: f7f2 eb8e    	blx	0x700a2074 <CSL_armR5PmuResetCntrs> @ imm = #-0xd8e4
; }
700af95a: bd80         	pop	{r7, pc}
700af95c: 0000         	movs	r0, r0
700af95e: 0000         	movs	r0, r0

700af960 <Sciclient_getSelfDevIdCore>:
;     return gSciclientHandle.devIdCore;
700af960: f242 6008    	movw	r0, #0x2608
700af964: f2c7 000b    	movt	r0, #0x700b
700af968: 6880         	ldr	r0, [r0, #0x8]
700af96a: 4770         	bx	lr
700af96c: 0000         	movs	r0, r0
700af96e: 0000         	movs	r0, r0

700af970 <Sciclient_rmPsGetPsp>:
;     return gPstack.psp;
700af970: f241 0058    	movw	r0, #0x1058
700af974: f2c7 0008    	movt	r0, #0x7008
700af978: 8c80         	ldrh	r0, [r0, #0x24]
700af97a: 4770         	bx	lr
700af97c: 0000         	movs	r0, r0
700af97e: 0000         	movs	r0, r0

700af980 <Udma_rmFreeFreeRing>:
; {
700af980: b082         	sub	sp, #0x8
700af982: f8ad 0006    	strh.w	r0, [sp, #0x6]
700af986: 9100         	str	r1, [sp]
;     return;
700af988: b002         	add	sp, #0x8
700af98a: 4770         	bx	lr
700af98c: 0000         	movs	r0, r0
700af98e: 0000         	movs	r0, r0

700af990 <xTaskGetIdleTaskHandle>:
;   return xIdleTaskHandle;
700af990: f242 60f0    	movw	r0, #0x26f0
700af994: f2c7 000b    	movt	r0, #0x700b
700af998: 6800         	ldr	r0, [r0]
700af99a: 4770         	bx	lr
700af99c: 0000         	movs	r0, r0
700af99e: 0000         	movs	r0, r0

700af9a0 <.Lfastpath_exit>:
700af9a0: e0420003     	sub	r0, r2, r3
700af9a4: e12fff1e     	bx	lr
700af9a8: e320f000     	nop
700af9ac: 00000000     	andeq	r0, r0, r0

700af9b0 <Hwip_dataAndInstructionBarrier>:
;     __asm__ __volatile__ (" isb"   "\n\t": : : "memory");
700af9b0: f3bf 8f6f    	isb	sy
;     __asm__ __volatile__ (" dsb"   "\n\t": : : "memory");
700af9b4: f3bf 8f4f    	dsb	sy
; }
700af9b8: 4770         	bx	lr
700af9ba: 0000         	movs	r0, r0
700af9bc: 0000         	movs	r0, r0
700af9be: 0000         	movs	r0, r0

700af9c0 <prvTaskExitError>:
; static void prvTaskExitError(void) {
700af9c0: b580         	push	{r7, lr}
700af9c2: 2000         	movs	r0, #0x0
;   DebugP_assertNoLog(0);
700af9c4: f001 fb0c    	bl	0x700b0fe0 <_DebugP_assertNoLog> @ imm = #0x1618
; }
700af9c8: bd80         	pop	{r7, pc}
700af9ca: 0000         	movs	r0, r0
700af9cc: 0000         	movs	r0, r0
700af9ce: 0000         	movs	r0, r0

700af9d0 <tm_thread_sleep>:
; {
700af9d0: f44f 717a    	mov.w	r1, #0x3e8
;    vTaskDelay((seconds * 1000U) / portTICK_RATE_MS);
700af9d4: 4348         	muls	r0, r1, r0
700af9d6: f7fe bbe3    	b.w	0x700ae1a0 <vTaskDelay> @ imm = #-0x183a
700af9da: 0000         	movs	r0, r0
700af9dc: 0000         	movs	r0, r0
700af9de: 0000         	movs	r0, r0

700af9e0 <ClockP_getTicks>:
; {
700af9e0: b580         	push	{r7, lr}
;     return ((uint32_t)xTaskGetTickCount());
700af9e2: f7ff fc35    	bl	0x700af250 <xTaskGetTickCount> @ imm = #-0x796
700af9e6: bd80         	pop	{r7, pc}
		...

700af9f0 <UART_lld_errorCallback>:
; {
700af9f0: b081         	sub	sp, #0x4
700af9f2: 9000         	str	r0, [sp]
; }
700af9f4: b001         	add	sp, #0x4
700af9f6: 4770         	bx	lr
		...

700afa00 <Udma_ringAssertFnPointers>:
; {
700afa00: b081         	sub	sp, #0x4
700afa02: 9000         	str	r0, [sp]
;     return;
700afa04: b001         	add	sp, #0x4
700afa06: 4770         	bx	lr
		...

700afa10 <vApplicationIdleHook>:
; void vApplicationIdleHook(void) {
700afa10: b580         	push	{r7, lr}
;   vApplicationLoadHook();
700afa12: f7fc f8d5    	bl	0x700abbc0 <vApplicationLoadHook> @ imm = #-0x3e56
; }
700afa16: bd80         	pop	{r7, pc}
		...

700afa20 <Board_driversOpen>:
;     return status;
700afa20: 2000         	movs	r0, #0x0
700afa22: 4770         	bx	lr
		...

700afa30 <Sciclient_rmPsGetMaxPsp>:
; {
700afa30: 2003         	movs	r0, #0x3
;     return SCICLIENT_PS_MAX_DEPTH;
700afa32: 4770         	bx	lr
		...

700afa40 <TaskP_yield>:
;     taskYIELD();
700afa40: df00         	svc	#0x0
; }
700afa42: 4770         	bx	lr
		...

700afa50 <__aeabi_idiv0>:
700afa50: e12fff1e     	bx	lr
		...

700afa60 <__aeabi_ldiv0>:
700afa60: e12fff1e     	bx	lr
		...

700afa70 <main>:
;    return rtos_main_freertos();
700afa70: f7f9 b8a6    	b.w	0x700a8bc0 <rtos_main_freertos> @ imm = #-0x6eb4
		...

700afa80 <tm_pmu_profile_end>:
;    PMU_profileEnd(name);
700afa80: f7f5 bdd6    	b.w	0x700a5630 <PMU_profileEnd> @ imm = #-0xa454
		...

700afa90 <tm_pmu_profile_print>:
;    PMU_profilePrintEntry(name);
700afa90: f7f7 bd2e    	b.w	0x700a74f0 <PMU_profilePrintEntry> @ imm = #-0x85a4
		...

700afaa0 <tm_pmu_profile_start>:
;    PMU_profileStart(name);
700afaa0: f7f9 bc4e    	b.w	0x700a9340 <PMU_profileStart> @ imm = #-0x6764
		...

700afab0 <tm_resume_scheduler>:
;    xTaskResumeAll();
700afab0: f7f2 baee    	b.w	0x700a2090 <xTaskResumeAll> @ imm = #-0xda24
		...

700afac0 <tm_suspend_scheduler>:
;    vTaskSuspendAll();
700afac0: f7ff bef6    	b.w	0x700af8b0 <vTaskSuspendAll> @ imm = #-0x214
		...

700afad0 <Board_init>:
; }
700afad0: 4770         	bx	lr
		...
700afade: 0000         	movs	r0, r0

700afae0 <tm_initialize>:
;    test_initialization_function();
700afae0: 4700         	bx	r0
		...
700afaee: 0000         	movs	r0, r0

700afaf0 <vPortConfigTimerForRunTimeStats>:
; }
700afaf0: 4770         	bx	lr
		...
700afafe: 0000         	movs	r0, r0
