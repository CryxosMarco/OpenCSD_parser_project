
.\files\freertos.out:	file format elf32-littlearm

Disassembly of section .vectors:

00000000 <_vectors>:
;         LDR pc, reset_addr          // Reset
       0: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x20 <reset_addr>
;         LDR pc, undefined_addr      // Undefined Instruction
       4: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x24 <undefined_addr>
;         LDR pc, svc_addr            // Software interrupt
       8: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x28 <svc_addr>
;         LDR pc, prefetch_abort_addr // Abort (prefetch)
       c: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x2c <prefetch_abort_addr>
;         LDR pc, data_abort_addr     // Abort (data)
      10: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x30 <data_abort_addr>
;         LDR pc, reserved_addr       // rsvd
      14: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x34 <reserved_addr>
;         LDR pc, irq_addr            // IRQ
      18: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x38 <irq_addr>
;         LDR pc, fiq_addr            // FIQ
      1c: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x3c <fiq_addr>

00000020 <reset_addr>:
      20: b4 11 0b 70  	.word	0x700b11b4

00000024 <undefined_addr>:
      24: c1 06 0b 70  	.word	0x700b06c1

00000028 <svc_addr>:
      28: ac 07 0b 70  	.word	0x700b07ac

0000002c <prefetch_abort_addr>:
      2c: 01 07 0b 70  	.word	0x700b0701

00000030 <data_abort_addr>:
      30: d0 09 0b 70  	.word	0x700b09d0

00000034 <reserved_addr>:
      34: 81 06 0b 70  	.word	0x700b0681

00000038 <irq_addr>:
      38: 1c 08 0b 70  	.word	0x700b081c

0000003c <fiq_addr>:
      3c: 11 05 0b 70  	.word	0x700b0511

Disassembly of section .text.hwi:

700afe00 <HwiP_enableInt>:
; {
700afe00: b580         	push	{r7, lr}
700afe02: b084         	sub	sp, #0x10
700afe04: 9003         	str	r0, [sp, #0xc]
;     Hwip_dataAndInstructionBarrier();
700afe06: f7ff ff63    	bl	0x700afcd0 <Hwip_dataAndInstructionBarrier> @ imm = #-0x13a
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_EN(intNum));
700afe0a: f642 10f8    	movw	r0, #0x29f8
700afe0e: f2c7 000b    	movt	r0, #0x700b
700afe12: 6801         	ldr	r1, [r0]
700afe14: 9803         	ldr	r0, [sp, #0xc]
700afe16: f400 70f0    	and	r0, r0, #0x1e0
700afe1a: 4408         	add	r0, r1
700afe1c: f500 6081    	add.w	r0, r0, #0x408
700afe20: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700afe22: 9803         	ldr	r0, [sp, #0xc]
700afe24: f000 001f    	and	r0, r0, #0x1f
700afe28: 9001         	str	r0, [sp, #0x4]
;     *addr = ((uint32_t)0x1 << bitPos);
700afe2a: 9901         	ldr	r1, [sp, #0x4]
700afe2c: 2001         	movs	r0, #0x1
700afe2e: 4088         	lsls	r0, r1
700afe30: 9902         	ldr	r1, [sp, #0x8]
700afe32: 6008         	str	r0, [r1]
; }
700afe34: b004         	add	sp, #0x10
700afe36: bd80         	pop	{r7, pc}
700afe38: bf00         	nop
700afe3a: bf00         	nop
700afe3c: bf00         	nop
700afe3e: bf00         	nop

700afe40 <HwiP_disableInt>:
; {
700afe40: b580         	push	{r7, lr}
700afe42: b084         	sub	sp, #0x10
700afe44: 9003         	str	r0, [sp, #0xc]
700afe46: 2000         	movs	r0, #0x0
;     uint32_t isEnable = 0;
700afe48: 9000         	str	r0, [sp]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_DIS(intNum));
700afe4a: f642 10f8    	movw	r0, #0x29f8
700afe4e: f2c7 000b    	movt	r0, #0x700b
700afe52: 6801         	ldr	r1, [r0]
700afe54: 9803         	ldr	r0, [sp, #0xc]
700afe56: f400 70f0    	and	r0, r0, #0x1e0
700afe5a: 4408         	add	r0, r1
700afe5c: f200 400c    	addw	r0, r0, #0x40c
700afe60: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700afe62: 9803         	ldr	r0, [sp, #0xc]
700afe64: f000 001f    	and	r0, r0, #0x1f
700afe68: 9001         	str	r0, [sp, #0x4]
;     if( (*addr & ((uint32_t)0x1 << bitPos))!=0U)
700afe6a: 9802         	ldr	r0, [sp, #0x8]
700afe6c: 6800         	ldr	r0, [r0]
700afe6e: 9901         	ldr	r1, [sp, #0x4]
700afe70: 40c8         	lsrs	r0, r1
700afe72: 07c0         	lsls	r0, r0, #0x1f
700afe74: b118         	cbz	r0, 0x700afe7e <HwiP_disableInt+0x3e> @ imm = #0x6
700afe76: e7ff         	b	0x700afe78 <HwiP_disableInt+0x38> @ imm = #-0x2
700afe78: 2001         	movs	r0, #0x1
;         isEnable = 1;
700afe7a: 9000         	str	r0, [sp]
;     }
700afe7c: e7ff         	b	0x700afe7e <HwiP_disableInt+0x3e> @ imm = #-0x2
;     *addr = ((uint32_t)0x1 << bitPos);
700afe7e: 9901         	ldr	r1, [sp, #0x4]
700afe80: 2001         	movs	r0, #0x1
700afe82: 4088         	lsls	r0, r1
700afe84: 9902         	ldr	r1, [sp, #0x8]
700afe86: 6008         	str	r0, [r1]
;     Hwip_dataAndInstructionBarrier();
700afe88: f7ff ff22    	bl	0x700afcd0 <Hwip_dataAndInstructionBarrier> @ imm = #-0x1bc
;     return isEnable;
700afe8c: 9800         	ldr	r0, [sp]
700afe8e: b004         	add	sp, #0x10
700afe90: bd80         	pop	{r7, pc}
700afe92: bf00         	nop
700afe94: bf00         	nop
700afe96: bf00         	nop
700afe98: bf00         	nop
700afe9a: bf00         	nop
700afe9c: bf00         	nop
700afe9e: bf00         	nop

700afea0 <HwiP_restoreInt>:
; {
700afea0: b580         	push	{r7, lr}
700afea2: b082         	sub	sp, #0x8
700afea4: 9001         	str	r0, [sp, #0x4]
700afea6: 9100         	str	r1, [sp]
;     if(oldIntState!=0U)
700afea8: 9800         	ldr	r0, [sp]
700afeaa: b120         	cbz	r0, 0x700afeb6 <HwiP_restoreInt+0x16> @ imm = #0x8
700afeac: e7ff         	b	0x700afeae <HwiP_restoreInt+0xe> @ imm = #-0x2
;         HwiP_enableInt(intNum);
700afeae: 9801         	ldr	r0, [sp, #0x4]
700afeb0: f7ff ffa6    	bl	0x700afe00 <HwiP_enableInt> @ imm = #-0xb4
;     }
700afeb4: e003         	b	0x700afebe <HwiP_restoreInt+0x1e> @ imm = #0x6
;        (void) HwiP_disableInt(intNum);
700afeb6: 9801         	ldr	r0, [sp, #0x4]
700afeb8: f7ff ffc2    	bl	0x700afe40 <HwiP_disableInt> @ imm = #-0x7c
700afebc: e7ff         	b	0x700afebe <HwiP_restoreInt+0x1e> @ imm = #-0x2
; }
700afebe: b002         	add	sp, #0x8
700afec0: bd80         	pop	{r7, pc}
700afec2: bf00         	nop
700afec4: bf00         	nop
700afec6: bf00         	nop
700afec8: bf00         	nop
700afeca: bf00         	nop
700afecc: bf00         	nop
700afece: bf00         	nop

700afed0 <HwiP_clearInt>:
; {
700afed0: b083         	sub	sp, #0xc
700afed2: 9002         	str	r0, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_STS(intNum));
700afed4: f642 10f8    	movw	r0, #0x29f8
700afed8: f2c7 000b    	movt	r0, #0x700b
700afedc: 6801         	ldr	r1, [r0]
700afede: 9802         	ldr	r0, [sp, #0x8]
700afee0: f400 70f0    	and	r0, r0, #0x1e0
700afee4: 4408         	add	r0, r1
700afee6: f200 4004    	addw	r0, r0, #0x404
700afeea: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700afeec: 9802         	ldr	r0, [sp, #0x8]
700afeee: f000 001f    	and	r0, r0, #0x1f
700afef2: 9000         	str	r0, [sp]
;     *addr = ((uint32_t)0x1 << bitPos);
700afef4: 9900         	ldr	r1, [sp]
700afef6: 2001         	movs	r0, #0x1
700afef8: 4088         	lsls	r0, r1
700afefa: 9901         	ldr	r1, [sp, #0x4]
700afefc: 6008         	str	r0, [r1]
; }
700afefe: b003         	add	sp, #0xc
700aff00: 4770         	bx	lr
700aff02: bf00         	nop
700aff04: bf00         	nop
700aff06: bf00         	nop
700aff08: bf00         	nop
700aff0a: bf00         	nop
700aff0c: bf00         	nop
700aff0e: bf00         	nop

700aff10 <HwiP_post>:
; {
700aff10: b580         	push	{r7, lr}
700aff12: b084         	sub	sp, #0x10
700aff14: 9003         	str	r0, [sp, #0xc]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_RAW(intNum));
700aff16: f642 10f8    	movw	r0, #0x29f8
700aff1a: f2c7 000b    	movt	r0, #0x700b
700aff1e: 6801         	ldr	r1, [r0]
700aff20: 9803         	ldr	r0, [sp, #0xc]
700aff22: f400 70f0    	and	r0, r0, #0x1e0
700aff26: 4408         	add	r0, r1
700aff28: f500 6080    	add.w	r0, r0, #0x400
700aff2c: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700aff2e: 9803         	ldr	r0, [sp, #0xc]
700aff30: f000 001f    	and	r0, r0, #0x1f
700aff34: 9001         	str	r0, [sp, #0x4]
;     *addr = ((uint32_t)0x1 << bitPos);
700aff36: 9901         	ldr	r1, [sp, #0x4]
700aff38: 2001         	movs	r0, #0x1
700aff3a: 4088         	lsls	r0, r1
700aff3c: 9902         	ldr	r1, [sp, #0x8]
700aff3e: 6008         	str	r0, [r1]
;     Hwip_dataAndInstructionBarrier();
700aff40: f7ff fec6    	bl	0x700afcd0 <Hwip_dataAndInstructionBarrier> @ imm = #-0x274
; }
700aff44: b004         	add	sp, #0x10
700aff46: bd80         	pop	{r7, pc}
700aff48: bf00         	nop
700aff4a: bf00         	nop
700aff4c: bf00         	nop
700aff4e: bf00         	nop

700aff50 <HwiP_Params_init>:
; {
700aff50: b081         	sub	sp, #0x4
700aff52: 9000         	str	r0, [sp]
;     params->intNum = 0;
700aff54: 9900         	ldr	r1, [sp]
700aff56: 2000         	movs	r0, #0x0
700aff58: 6008         	str	r0, [r1]
;     params->callback = NULL;
700aff5a: 9900         	ldr	r1, [sp]
700aff5c: 6048         	str	r0, [r1, #0x4]
;     params->args = NULL;
700aff5e: 9900         	ldr	r1, [sp]
700aff60: 6088         	str	r0, [r1, #0x8]
;     params->eventId = 0; /* NOT USED */
700aff62: 9900         	ldr	r1, [sp]
700aff64: 8188         	strh	r0, [r1, #0xc]
;     params->priority = (HwiP_MAX_PRIORITY-1U);
700aff66: 9a00         	ldr	r2, [sp]
700aff68: 210f         	movs	r1, #0xf
700aff6a: 7391         	strb	r1, [r2, #0xe]
;     params->isFIQ = 0;
700aff6c: 9900         	ldr	r1, [sp]
700aff6e: 73c8         	strb	r0, [r1, #0xf]
;     params->isPulse = 0;
700aff70: 9900         	ldr	r1, [sp]
700aff72: 7408         	strb	r0, [r1, #0x10]
; }
700aff74: b001         	add	sp, #0x4
700aff76: 4770         	bx	lr
700aff78: bf00         	nop
700aff7a: bf00         	nop
700aff7c: bf00         	nop
700aff7e: bf00         	nop

700aff80 <HwiP_construct>:
; {
700aff80: b580         	push	{r7, lr}
700aff82: b084         	sub	sp, #0x10
700aff84: 9003         	str	r0, [sp, #0xc]
700aff86: 9102         	str	r1, [sp, #0x8]
;     HwiP_Struct *obj = (HwiP_Struct *)handle;
700aff88: 9803         	ldr	r0, [sp, #0xc]
700aff8a: 9001         	str	r0, [sp, #0x4]
700aff8c: 2001         	movs	r0, #0x1
;     DebugP_assertNoLog( sizeof(HwiP_Struct) <= sizeof(HwiP_Object) );
700aff8e: f001 f9a7    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x134e
;     DebugP_assertNoLog( params->callback != NULL );
700aff92: 9802         	ldr	r0, [sp, #0x8]
700aff94: 6840         	ldr	r0, [r0, #0x4]
700aff96: 2800         	cmp	r0, #0x0
700aff98: bf18         	it	ne
700aff9a: 2001         	movne	r0, #0x1
700aff9c: f001 f9a0    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x1340
;     DebugP_assertNoLog( params->intNum < HwiP_MAX_INTERRUPTS );
700affa0: 9802         	ldr	r0, [sp, #0x8]
700affa2: 6801         	ldr	r1, [r0]
700affa4: 2000         	movs	r0, #0x0
700affa6: 9000         	str	r0, [sp]
700affa8: f5b1 7f00    	cmp.w	r1, #0x200
700affac: bf38         	it	lo
700affae: 2001         	movlo	r0, #0x1
700affb0: f001 f996    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x132c
700affb4: 9800         	ldr	r0, [sp]
;     DebugP_assertNoLog( params->priority < HwiP_MAX_PRIORITY );
700affb6: 9902         	ldr	r1, [sp, #0x8]
700affb8: 7b89         	ldrb	r1, [r1, #0xe]
700affba: 2910         	cmp	r1, #0x10
700affbc: bf38         	it	lo
700affbe: 2001         	movlo	r0, #0x1
700affc0: f001 f98e    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x131c
;     (void) HwiP_disableInt(params->intNum);
700affc4: 9802         	ldr	r0, [sp, #0x8]
700affc6: 6800         	ldr	r0, [r0]
700affc8: f7ff ff3a    	bl	0x700afe40 <HwiP_disableInt> @ imm = #-0x18c
;     HwiP_clearInt(params->intNum);
700affcc: 9802         	ldr	r0, [sp, #0x8]
700affce: 6800         	ldr	r0, [r0]
700affd0: f7ff ff7e    	bl	0x700afed0 <HwiP_clearInt> @ imm = #-0x104
;     HwiP_setAsFIQ(params->intNum, params->isFIQ);
700affd4: 9902         	ldr	r1, [sp, #0x8]
700affd6: 6808         	ldr	r0, [r1]
700affd8: 7bc9         	ldrb	r1, [r1, #0xf]
700affda: f000 f841    	bl	0x700b0060 <HwiP_setAsFIQ> @ imm = #0x82
;     HwiP_setPri(params->intNum, params->priority);
700affde: 9902         	ldr	r1, [sp, #0x8]
700affe0: 6808         	ldr	r0, [r1]
700affe2: 7b89         	ldrb	r1, [r1, #0xe]
700affe4: f000 f86c    	bl	0x700b00c0 <HwiP_setPri> @ imm = #0xd8
;     HwiP_setAsPulse(params->intNum, params->isPulse);
700affe8: 9902         	ldr	r1, [sp, #0x8]
700affea: 6808         	ldr	r0, [r1]
700affec: 7c09         	ldrb	r1, [r1, #0x10]
700affee: f000 f87f    	bl	0x700b00f0 <HwiP_setAsPulse> @ imm = #0xfe
;     if(params->isFIQ != 0U)
700afff2: 9802         	ldr	r0, [sp, #0x8]
700afff4: 7bc0         	ldrb	r0, [r0, #0xf]
700afff6: b148         	cbz	r0, 0x700b000c <HwiP_construct+0x8c> @ imm = #0x12
700afff8: e7ff         	b	0x700afffa <HwiP_construct+0x7a> @ imm = #-0x2
;         HwiP_setVecAddr(params->intNum, (uintptr_t)HwiP_fiq_handler);
700afffa: 9802         	ldr	r0, [sp, #0x8]
700afffc: 6800         	ldr	r0, [r0]
700afffe: f240 5111    	movw	r1, #0x511
700b0002: f2c7 010b    	movt	r1, #0x700b
700b0006: f000 f8a3    	bl	0x700b0150 <HwiP_setVecAddr> @ imm = #0x146
;     }
700b000a: e008         	b	0x700b001e <HwiP_construct+0x9e> @ imm = #0x10
;         HwiP_setVecAddr(params->intNum, (uintptr_t)HwiP_irq_handler);
700b000c: 9802         	ldr	r0, [sp, #0x8]
700b000e: 6800         	ldr	r0, [r0]
700b0010: f640 011c    	movw	r1, #0x81c
700b0014: f2c7 010b    	movt	r1, #0x700b
700b0018: f000 f89a    	bl	0x700b0150 <HwiP_setVecAddr> @ imm = #0x134
700b001c: e7ff         	b	0x700b001e <HwiP_construct+0x9e> @ imm = #-0x2
;     gHwiCtrl.isr[params->intNum] = params->callback;
700b001e: 9802         	ldr	r0, [sp, #0x8]
700b0020: 6802         	ldr	r2, [r0]
700b0022: 6840         	ldr	r0, [r0, #0x4]
700b0024: f240 0100    	movw	r1, #0x0
700b0028: f2c7 0108    	movt	r1, #0x7008
700b002c: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     gHwiCtrl.isrArgs[params->intNum] = params->args;
700b0030: 9802         	ldr	r0, [sp, #0x8]
700b0032: 6802         	ldr	r2, [r0]
700b0034: 6880         	ldr	r0, [r0, #0x8]
700b0036: eb01 0182    	add.w	r1, r1, r2, lsl #2
700b003a: f8c1 0800    	str.w	r0, [r1, #0x800]
;     obj->intNum = params->intNum;
700b003e: 9802         	ldr	r0, [sp, #0x8]
700b0040: 6800         	ldr	r0, [r0]
700b0042: 9901         	ldr	r1, [sp, #0x4]
700b0044: 6008         	str	r0, [r1]
;     HwiP_enableInt(params->intNum);
700b0046: 9802         	ldr	r0, [sp, #0x8]
700b0048: 6800         	ldr	r0, [r0]
700b004a: f7ff fed9    	bl	0x700afe00 <HwiP_enableInt> @ imm = #-0x24e
700b004e: 2000         	movs	r0, #0x0
;     return SystemP_SUCCESS;
700b0050: b004         	add	sp, #0x10
700b0052: bd80         	pop	{r7, pc}
700b0054: bf00         	nop
700b0056: bf00         	nop
700b0058: bf00         	nop
700b005a: bf00         	nop
700b005c: bf00         	nop
700b005e: bf00         	nop

700b0060 <HwiP_setAsFIQ>:
; {
700b0060: b084         	sub	sp, #0x10
700b0062: 9003         	str	r0, [sp, #0xc]
700b0064: 9102         	str	r1, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_MAP(intNum));
700b0066: f642 10f8    	movw	r0, #0x29f8
700b006a: f2c7 000b    	movt	r0, #0x700b
700b006e: 6801         	ldr	r1, [r0]
700b0070: 9803         	ldr	r0, [sp, #0xc]
700b0072: f400 70f0    	and	r0, r0, #0x1e0
700b0076: 4408         	add	r0, r1
700b0078: f500 6083    	add.w	r0, r0, #0x418
700b007c: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700b007e: 9803         	ldr	r0, [sp, #0xc]
700b0080: f000 001f    	and	r0, r0, #0x1f
700b0084: 9000         	str	r0, [sp]
;     if(isFIQ != 0U)
700b0086: 9802         	ldr	r0, [sp, #0x8]
700b0088: b148         	cbz	r0, 0x700b009e <HwiP_setAsFIQ+0x3e> @ imm = #0x12
700b008a: e7ff         	b	0x700b008c <HwiP_setAsFIQ+0x2c> @ imm = #-0x2
;         *addr |= ((uint32_t)0x1u << bitPos);
700b008c: 9900         	ldr	r1, [sp]
700b008e: 2001         	movs	r0, #0x1
700b0090: fa00 f201    	lsl.w	r2, r0, r1
700b0094: 9901         	ldr	r1, [sp, #0x4]
700b0096: 6808         	ldr	r0, [r1]
700b0098: 4310         	orrs	r0, r2
700b009a: 6008         	str	r0, [r1]
;     }
700b009c: e008         	b	0x700b00b0 <HwiP_setAsFIQ+0x50> @ imm = #0x10
;         *addr &= ~(0x1u << bitPos);
700b009e: 9900         	ldr	r1, [sp]
700b00a0: 2001         	movs	r0, #0x1
700b00a2: fa00 f201    	lsl.w	r2, r0, r1
700b00a6: 9901         	ldr	r1, [sp, #0x4]
700b00a8: 6808         	ldr	r0, [r1]
700b00aa: 4390         	bics	r0, r2
700b00ac: 6008         	str	r0, [r1]
700b00ae: e7ff         	b	0x700b00b0 <HwiP_setAsFIQ+0x50> @ imm = #-0x2
; }
700b00b0: b004         	add	sp, #0x10
700b00b2: 4770         	bx	lr
700b00b4: bf00         	nop
700b00b6: bf00         	nop
700b00b8: bf00         	nop
700b00ba: bf00         	nop
700b00bc: bf00         	nop
700b00be: bf00         	nop

700b00c0 <HwiP_setPri>:
; {
700b00c0: b083         	sub	sp, #0xc
700b00c2: 9002         	str	r0, [sp, #0x8]
700b00c4: 9101         	str	r1, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_PRI(intNum));
700b00c6: f642 10f8    	movw	r0, #0x29f8
700b00ca: f2c7 000b    	movt	r0, #0x700b
700b00ce: 6800         	ldr	r0, [r0]
700b00d0: 9902         	ldr	r1, [sp, #0x8]
700b00d2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700b00d6: f500 5080    	add.w	r0, r0, #0x1000
700b00da: 9000         	str	r0, [sp]
;     *addr = (priority & 0xFu);
700b00dc: 9801         	ldr	r0, [sp, #0x4]
700b00de: f000 000f    	and	r0, r0, #0xf
700b00e2: 9900         	ldr	r1, [sp]
700b00e4: 6008         	str	r0, [r1]
; }
700b00e6: b003         	add	sp, #0xc
700b00e8: 4770         	bx	lr
700b00ea: bf00         	nop
700b00ec: bf00         	nop
700b00ee: bf00         	nop

700b00f0 <HwiP_setAsPulse>:
; {
700b00f0: b084         	sub	sp, #0x10
700b00f2: 9003         	str	r0, [sp, #0xc]
700b00f4: 9102         	str	r1, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(intNum));
700b00f6: f642 10f8    	movw	r0, #0x29f8
700b00fa: f2c7 000b    	movt	r0, #0x700b
700b00fe: 6801         	ldr	r1, [r0]
700b0100: 9803         	ldr	r0, [sp, #0xc]
700b0102: f400 70f0    	and	r0, r0, #0x1e0
700b0106: 4408         	add	r0, r1
700b0108: f200 401c    	addw	r0, r0, #0x41c
700b010c: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700b010e: 9803         	ldr	r0, [sp, #0xc]
700b0110: f000 001f    	and	r0, r0, #0x1f
700b0114: 9000         	str	r0, [sp]
;     if(isPulse != 0U)
700b0116: 9802         	ldr	r0, [sp, #0x8]
700b0118: b148         	cbz	r0, 0x700b012e <HwiP_setAsPulse+0x3e> @ imm = #0x12
700b011a: e7ff         	b	0x700b011c <HwiP_setAsPulse+0x2c> @ imm = #-0x2
;         *addr |= ((uint32_t)0x1u << bitPos);
700b011c: 9900         	ldr	r1, [sp]
700b011e: 2001         	movs	r0, #0x1
700b0120: fa00 f201    	lsl.w	r2, r0, r1
700b0124: 9901         	ldr	r1, [sp, #0x4]
700b0126: 6808         	ldr	r0, [r1]
700b0128: 4310         	orrs	r0, r2
700b012a: 6008         	str	r0, [r1]
;     }
700b012c: e008         	b	0x700b0140 <HwiP_setAsPulse+0x50> @ imm = #0x10
;         *addr &= ~(0x1u << bitPos);
700b012e: 9900         	ldr	r1, [sp]
700b0130: 2001         	movs	r0, #0x1
700b0132: fa00 f201    	lsl.w	r2, r0, r1
700b0136: 9901         	ldr	r1, [sp, #0x4]
700b0138: 6808         	ldr	r0, [r1]
700b013a: 4390         	bics	r0, r2
700b013c: 6008         	str	r0, [r1]
700b013e: e7ff         	b	0x700b0140 <HwiP_setAsPulse+0x50> @ imm = #-0x2
; }
700b0140: b004         	add	sp, #0x10
700b0142: 4770         	bx	lr
700b0144: bf00         	nop
700b0146: bf00         	nop
700b0148: bf00         	nop
700b014a: bf00         	nop
700b014c: bf00         	nop
700b014e: bf00         	nop

700b0150 <HwiP_setVecAddr>:
; {
700b0150: b083         	sub	sp, #0xc
700b0152: 9002         	str	r0, [sp, #0x8]
700b0154: 9101         	str	r1, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_VEC(intNum));
700b0156: f642 10f8    	movw	r0, #0x29f8
700b015a: f2c7 000b    	movt	r0, #0x700b
700b015e: 6800         	ldr	r0, [r0]
700b0160: 9902         	ldr	r1, [sp, #0x8]
700b0162: eb00 0081    	add.w	r0, r0, r1, lsl #2
700b0166: f500 5000    	add.w	r0, r0, #0x2000
700b016a: 9000         	str	r0, [sp]
;     *addr = ((uint32_t)vecAddr & 0xFFFFFFFCU);
700b016c: 9801         	ldr	r0, [sp, #0x4]
700b016e: f020 0003    	bic	r0, r0, #0x3
700b0172: 9900         	ldr	r1, [sp]
700b0174: 6008         	str	r0, [r1]
; }
700b0176: b003         	add	sp, #0xc
700b0178: 4770         	bx	lr
700b017a: bf00         	nop
700b017c: bf00         	nop
700b017e: bf00         	nop

700b0180 <HwiP_destruct>:
; {
700b0180: b580         	push	{r7, lr}
700b0182: b084         	sub	sp, #0x10
700b0184: 9003         	str	r0, [sp, #0xc]
;     HwiP_Struct *obj = (HwiP_Struct *)handle;
700b0186: 9803         	ldr	r0, [sp, #0xc]
700b0188: 9002         	str	r0, [sp, #0x8]
;    (void) HwiP_disableInt(obj->intNum);
700b018a: 9802         	ldr	r0, [sp, #0x8]
700b018c: 6800         	ldr	r0, [r0]
700b018e: f7ff fe57    	bl	0x700afe40 <HwiP_disableInt> @ imm = #-0x352
;     HwiP_clearInt(obj->intNum);
700b0192: 9802         	ldr	r0, [sp, #0x8]
700b0194: 6800         	ldr	r0, [r0]
700b0196: f7ff fe9b    	bl	0x700afed0 <HwiP_clearInt> @ imm = #-0x2ca
;     HwiP_setAsFIQ(obj->intNum, 0);
700b019a: 9802         	ldr	r0, [sp, #0x8]
700b019c: 6800         	ldr	r0, [r0]
700b019e: 2100         	movs	r1, #0x0
700b01a0: 9101         	str	r1, [sp, #0x4]
700b01a2: f7ff ff5d    	bl	0x700b0060 <HwiP_setAsFIQ> @ imm = #-0x146
;     HwiP_setPri(obj->intNum, HwiP_MAX_PRIORITY-1U);
700b01a6: 9802         	ldr	r0, [sp, #0x8]
700b01a8: 6800         	ldr	r0, [r0]
700b01aa: 210f         	movs	r1, #0xf
700b01ac: f7ff ff88    	bl	0x700b00c0 <HwiP_setPri> @ imm = #-0xf0
700b01b0: 9901         	ldr	r1, [sp, #0x4]
;     HwiP_setAsPulse(obj->intNum, 0);
700b01b2: 9802         	ldr	r0, [sp, #0x8]
700b01b4: 6800         	ldr	r0, [r0]
700b01b6: f7ff ff9b    	bl	0x700b00f0 <HwiP_setAsPulse> @ imm = #-0xca
;     HwiP_setVecAddr(obj->intNum, (uintptr_t)HwiP_irq_handler);
700b01ba: 9802         	ldr	r0, [sp, #0x8]
700b01bc: 6800         	ldr	r0, [r0]
700b01be: f640 011c    	movw	r1, #0x81c
700b01c2: f2c7 010b    	movt	r1, #0x700b
700b01c6: f7ff ffc3    	bl	0x700b0150 <HwiP_setVecAddr> @ imm = #-0x7a
700b01ca: 9801         	ldr	r0, [sp, #0x4]
;     gHwiCtrl.isr[obj->intNum] = NULL;
700b01cc: 9902         	ldr	r1, [sp, #0x8]
700b01ce: 680a         	ldr	r2, [r1]
700b01d0: f240 0100    	movw	r1, #0x0
700b01d4: f2c7 0108    	movt	r1, #0x7008
700b01d8: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     gHwiCtrl.isrArgs[obj->intNum] = NULL;
700b01dc: 9a02         	ldr	r2, [sp, #0x8]
700b01de: 6812         	ldr	r2, [r2]
700b01e0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700b01e4: f8c1 0800    	str.w	r0, [r1, #0x800]
; }
700b01e8: b004         	add	sp, #0x10
700b01ea: bd80         	pop	{r7, pc}
700b01ec: bf00         	nop
700b01ee: bf00         	nop

700b01f0 <HwiP_init>:
; {
700b01f0: b580         	push	{r7, lr}
700b01f2: b084         	sub	sp, #0x10
;     (void) HwiP_disable();
700b01f4: f000 ebb4    	blx	0x700b0960 <HwiP_disable> @ imm = #0x768
;     (void) HwiP_disableFIQ();
700b01f8: f000 ebba    	blx	0x700b0970 <HwiP_disableFIQ> @ imm = #0x774
;     DebugP_assertNoLog(gHwiConfig.intcBaseAddr != 0U);
700b01fc: f642 10f8    	movw	r0, #0x29f8
700b0200: f2c7 000b    	movt	r0, #0x700b
700b0204: 6800         	ldr	r0, [r0]
700b0206: 2800         	cmp	r0, #0x0
700b0208: bf18         	it	ne
700b020a: 2001         	movne	r0, #0x1
700b020c: f001 f868    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x10d0
;     gHwiCtrl.spuriousIRQCount = 0;
700b0210: f240 0100    	movw	r1, #0x0
700b0214: f2c7 0108    	movt	r1, #0x7008
700b0218: f44f 5280    	mov.w	r2, #0x1000
700b021c: 2000         	movs	r0, #0x0
700b021e: 5088         	str	r0, [r1, r2]
700b0220: f241 0204    	movw	r2, #0x1004
;     gHwiCtrl.spuriousFIQCount = 0;
700b0224: 5088         	str	r0, [r1, r2]
;     for(i=0; i<HwiP_MAX_INTERRUPTS; i++)
700b0226: 9003         	str	r0, [sp, #0xc]
700b0228: e7ff         	b	0x700b022a <HwiP_init+0x3a> @ imm = #-0x2
700b022a: 9903         	ldr	r1, [sp, #0xc]
700b022c: 2000         	movs	r0, #0x0
700b022e: ebb0 2f51    	cmp.w	r0, r1, lsr #9
700b0232: d11d         	bne	0x700b0270 <HwiP_init+0x80> @ imm = #0x3a
700b0234: e7ff         	b	0x700b0236 <HwiP_init+0x46> @ imm = #-0x2
;         gHwiCtrl.isr[i] = NULL;
700b0236: 9a03         	ldr	r2, [sp, #0xc]
700b0238: f240 0100    	movw	r1, #0x0
700b023c: f2c7 0108    	movt	r1, #0x7008
700b0240: 2000         	movs	r0, #0x0
700b0242: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gHwiCtrl.isrArgs[i] = NULL;
700b0246: 9a03         	ldr	r2, [sp, #0xc]
700b0248: eb01 0182    	add.w	r1, r1, r2, lsl #2
700b024c: f8c1 0800    	str.w	r0, [r1, #0x800]
;         HwiP_setPri(i, 0xF);
700b0250: 9803         	ldr	r0, [sp, #0xc]
700b0252: 210f         	movs	r1, #0xf
700b0254: f7ff ff34    	bl	0x700b00c0 <HwiP_setPri> @ imm = #-0x198
;         HwiP_setVecAddr(i, (uintptr_t)HwiP_irq_handler);
700b0258: 9803         	ldr	r0, [sp, #0xc]
700b025a: f640 011c    	movw	r1, #0x81c
700b025e: f2c7 010b    	movt	r1, #0x700b
700b0262: f7ff ff75    	bl	0x700b0150 <HwiP_setVecAddr> @ imm = #-0x116
;     }
700b0266: e7ff         	b	0x700b0268 <HwiP_init+0x78> @ imm = #-0x2
;     for(i=0; i<HwiP_MAX_INTERRUPTS; i++)
700b0268: 9803         	ldr	r0, [sp, #0xc]
700b026a: 3001         	adds	r0, #0x1
700b026c: 9003         	str	r0, [sp, #0xc]
700b026e: e7dc         	b	0x700b022a <HwiP_init+0x3a> @ imm = #-0x48
700b0270: 2000         	movs	r0, #0x0
;     for(i=0; i<(HwiP_MAX_INTERRUPTS/INTERRUPT_VALUE); i++)
700b0272: 9003         	str	r0, [sp, #0xc]
700b0274: e7ff         	b	0x700b0276 <HwiP_init+0x86> @ imm = #-0x2
700b0276: 9803         	ldr	r0, [sp, #0xc]
700b0278: 280f         	cmp	r0, #0xf
700b027a: d838         	bhi	0x700b02ee <HwiP_init+0xfe> @ imm = #0x70
700b027c: e7ff         	b	0x700b027e <HwiP_init+0x8e> @ imm = #-0x2
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_DIS(i*INTERRUPT_VALUE));
700b027e: f642 11f8    	movw	r1, #0x29f8
700b0282: f2c7 010b    	movt	r1, #0x700b
700b0286: 6808         	ldr	r0, [r1]
700b0288: 9a03         	ldr	r2, [sp, #0xc]
700b028a: f002 020f    	and	r2, r2, #0xf
700b028e: eb00 1042    	add.w	r0, r0, r2, lsl #5
700b0292: f200 400c    	addw	r0, r0, #0x40c
700b0296: 9002         	str	r0, [sp, #0x8]
;         *addr = 0xFFFFFFFFu;
700b0298: 9a02         	ldr	r2, [sp, #0x8]
700b029a: f04f 30ff    	mov.w	r0, #0xffffffff
700b029e: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_STS(i*INTERRUPT_VALUE));
700b02a0: 680a         	ldr	r2, [r1]
700b02a2: 9b03         	ldr	r3, [sp, #0xc]
700b02a4: f003 030f    	and	r3, r3, #0xf
700b02a8: eb02 1243    	add.w	r2, r2, r3, lsl #5
700b02ac: f202 4204    	addw	r2, r2, #0x404
700b02b0: 9202         	str	r2, [sp, #0x8]
;         *addr = 0xFFFFFFFFu;
700b02b2: 9a02         	ldr	r2, [sp, #0x8]
700b02b4: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(i*INTERRUPT_VALUE));
700b02b6: 6808         	ldr	r0, [r1]
700b02b8: 9a03         	ldr	r2, [sp, #0xc]
700b02ba: f002 020f    	and	r2, r2, #0xf
700b02be: eb00 1042    	add.w	r0, r0, r2, lsl #5
700b02c2: f200 401c    	addw	r0, r0, #0x41c
700b02c6: 9002         	str	r0, [sp, #0x8]
;         *addr = 0x0u;
700b02c8: 9a02         	ldr	r2, [sp, #0x8]
700b02ca: 2000         	movs	r0, #0x0
700b02cc: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_MAP(i*INTERRUPT_VALUE));
700b02ce: 6809         	ldr	r1, [r1]
700b02d0: 9a03         	ldr	r2, [sp, #0xc]
700b02d2: f002 020f    	and	r2, r2, #0xf
700b02d6: eb01 1142    	add.w	r1, r1, r2, lsl #5
700b02da: f501 6183    	add.w	r1, r1, #0x418
700b02de: 9102         	str	r1, [sp, #0x8]
;         *addr = 0x0u;
700b02e0: 9902         	ldr	r1, [sp, #0x8]
700b02e2: 6008         	str	r0, [r1]
;     }
700b02e4: e7ff         	b	0x700b02e6 <HwiP_init+0xf6> @ imm = #-0x2
;     for(i=0; i<(HwiP_MAX_INTERRUPTS/INTERRUPT_VALUE); i++)
700b02e6: 9803         	ldr	r0, [sp, #0xc]
700b02e8: 3001         	adds	r0, #0x1
700b02ea: 9003         	str	r0, [sp, #0xc]
700b02ec: e7c3         	b	0x700b0276 <HwiP_init+0x86> @ imm = #-0x7a
;         gdummy = HwiP_getIRQVecAddr();
700b02ee: f000 f817    	bl	0x700b0320 <HwiP_getIRQVecAddr> @ imm = #0x2e
700b02f2: f245 118c    	movw	r1, #0x518c
700b02f6: f2c7 0108    	movt	r1, #0x7008
700b02fa: 9100         	str	r1, [sp]
700b02fc: 6008         	str	r0, [r1]
;         gdummy = HwiP_getFIQVecAddr();
700b02fe: f000 f81f    	bl	0x700b0340 <HwiP_getFIQVecAddr> @ imm = #0x3e
700b0302: 9900         	ldr	r1, [sp]
700b0304: 6008         	str	r0, [r1]
700b0306: 2000         	movs	r0, #0x0
;         HwiP_ackIRQ(0);
700b0308: 9001         	str	r0, [sp, #0x4]
700b030a: f000 f829    	bl	0x700b0360 <HwiP_ackIRQ> @ imm = #0x52
700b030e: 9801         	ldr	r0, [sp, #0x4]
;         HwiP_ackFIQ(0);
700b0310: f000 f836    	bl	0x700b0380 <HwiP_ackFIQ> @ imm = #0x6c
;     HwiP_enableVIC();
700b0314: f000 eb48    	blx	0x700b09a8 <HwiP_enableVIC> @ imm = #0x690
;     HwiP_enableFIQ();
700b0318: f000 eb3a    	blx	0x700b0990 <HwiP_enableFIQ> @ imm = #0x674
; }
700b031c: b004         	add	sp, #0x10
700b031e: bd80         	pop	{r7, pc}

700b0320 <HwiP_getIRQVecAddr>:
; {
700b0320: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700b0322: f642 10f8    	movw	r0, #0x29f8
700b0326: f2c7 000b    	movt	r0, #0x700b
700b032a: 6800         	ldr	r0, [r0]
700b032c: 3018         	adds	r0, #0x18
700b032e: 9000         	str	r0, [sp]
;     return *addr;
700b0330: 9800         	ldr	r0, [sp]
700b0332: 6800         	ldr	r0, [r0]
700b0334: b001         	add	sp, #0x4
700b0336: 4770         	bx	lr
700b0338: bf00         	nop
700b033a: bf00         	nop
700b033c: bf00         	nop
700b033e: bf00         	nop

700b0340 <HwiP_getFIQVecAddr>:
; {
700b0340: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b0342: f642 10f8    	movw	r0, #0x29f8
700b0346: f2c7 000b    	movt	r0, #0x700b
700b034a: 6800         	ldr	r0, [r0]
700b034c: 301c         	adds	r0, #0x1c
700b034e: 9000         	str	r0, [sp]
;     return *addr;
700b0350: 9800         	ldr	r0, [sp]
700b0352: 6800         	ldr	r0, [r0]
700b0354: b001         	add	sp, #0x4
700b0356: 4770         	bx	lr
700b0358: bf00         	nop
700b035a: bf00         	nop
700b035c: bf00         	nop
700b035e: bf00         	nop

700b0360 <HwiP_ackIRQ>:
; {
700b0360: b082         	sub	sp, #0x8
700b0362: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700b0364: f642 10f8    	movw	r0, #0x29f8
700b0368: f2c7 000b    	movt	r0, #0x700b
700b036c: 6800         	ldr	r0, [r0]
700b036e: 3018         	adds	r0, #0x18
700b0370: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0372: 9801         	ldr	r0, [sp, #0x4]
700b0374: 9900         	ldr	r1, [sp]
700b0376: 6008         	str	r0, [r1]
; }
700b0378: b002         	add	sp, #0x8
700b037a: 4770         	bx	lr
700b037c: bf00         	nop
700b037e: bf00         	nop

700b0380 <HwiP_ackFIQ>:
; {
700b0380: b082         	sub	sp, #0x8
700b0382: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b0384: f642 10f8    	movw	r0, #0x29f8
700b0388: f2c7 000b    	movt	r0, #0x700b
700b038c: 6800         	ldr	r0, [r0]
700b038e: 301c         	adds	r0, #0x1c
700b0390: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0392: 9801         	ldr	r0, [sp, #0x4]
700b0394: 9900         	ldr	r1, [sp]
700b0396: 6008         	str	r0, [r1]
; }
700b0398: b002         	add	sp, #0x8
700b039a: 4770         	bx	lr
700b039c: bf00         	nop
700b039e: bf00         	nop

700b03a0 <HwiP_inISR>:
; {
700b03a0: b580         	push	{r7, lr}
700b03a2: b082         	sub	sp, #0x8
;     uint32_t mode = (HwiP_getCPSR() & 0x1FU);
700b03a4: f000 eb10    	blx	0x700b09c8 <HwiP_getCPSR> @ imm = #0x620
700b03a8: f000 001f    	and	r0, r0, #0x1f
700b03ac: 9001         	str	r0, [sp, #0x4]
700b03ae: 2000         	movs	r0, #0x0
;     uint32_t result =0;
700b03b0: 9000         	str	r0, [sp]
;     if(mode != ARMV7R_SYSTEM_MODE)
700b03b2: 9801         	ldr	r0, [sp, #0x4]
700b03b4: 281f         	cmp	r0, #0x1f
700b03b6: d003         	beq	0x700b03c0 <HwiP_inISR+0x20> @ imm = #0x6
700b03b8: e7ff         	b	0x700b03ba <HwiP_inISR+0x1a> @ imm = #-0x2
700b03ba: 2001         	movs	r0, #0x1
;          result= 1;
700b03bc: 9000         	str	r0, [sp]
;     }
700b03be: e7ff         	b	0x700b03c0 <HwiP_inISR+0x20> @ imm = #-0x2
;     return result;
700b03c0: 9800         	ldr	r0, [sp]
700b03c2: b002         	add	sp, #0x8
700b03c4: bd80         	pop	{r7, pc}
		...
700b03ce: 0000         	movs	r0, r0

700b03d0 <HwiP_irq_handler_c>:
; {
700b03d0: b580         	push	{r7, lr}
700b03d2: b086         	sub	sp, #0x18
700b03d4: a804         	add	r0, sp, #0x10
;     status = HwiP_getIRQ(&intNum);
700b03d6: f000 f843    	bl	0x700b0460 <HwiP_getIRQ> @ imm = #0x86
700b03da: 9005         	str	r0, [sp, #0x14]
;     if(status==SystemP_SUCCESS)
700b03dc: 9805         	ldr	r0, [sp, #0x14]
700b03de: bb78         	cbnz	r0, 0x700b0440 <HwiP_irq_handler_c+0x70> @ imm = #0x5e
700b03e0: e7ff         	b	0x700b03e2 <HwiP_irq_handler_c+0x12> @ imm = #-0x2
;         uint32_t isPulse = HwiP_isPulse(intNum);
700b03e2: 9804         	ldr	r0, [sp, #0x10]
700b03e4: f000 f864    	bl	0x700b04b0 <HwiP_isPulse> @ imm = #0xc8
700b03e8: 9003         	str	r0, [sp, #0xc]
;         if(isPulse != 0U)
700b03ea: 9803         	ldr	r0, [sp, #0xc]
700b03ec: b120         	cbz	r0, 0x700b03f8 <HwiP_irq_handler_c+0x28> @ imm = #0x8
700b03ee: e7ff         	b	0x700b03f0 <HwiP_irq_handler_c+0x20> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b03f0: 9804         	ldr	r0, [sp, #0x10]
700b03f2: f7ff fd6d    	bl	0x700afed0 <HwiP_clearInt> @ imm = #-0x526
;         }
700b03f6: e7ff         	b	0x700b03f8 <HwiP_irq_handler_c+0x28> @ imm = #-0x2
;         isr = gHwiCtrl.isr[intNum];
700b03f8: 9904         	ldr	r1, [sp, #0x10]
700b03fa: f240 0000    	movw	r0, #0x0
700b03fe: f2c7 0008    	movt	r0, #0x7008
700b0402: f850 1021    	ldr.w	r1, [r0, r1, lsl #2]
700b0406: 9102         	str	r1, [sp, #0x8]
;         args = gHwiCtrl.isrArgs[intNum];
700b0408: 9904         	ldr	r1, [sp, #0x10]
700b040a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700b040e: f8d0 0800    	ldr.w	r0, [r0, #0x800]
700b0412: 9001         	str	r0, [sp, #0x4]
;         HwiP_enable();
700b0414: f000 eab4    	blx	0x700b0980 <HwiP_enable> @ imm = #0x568
;         if(isr!=NULL)
700b0418: 9802         	ldr	r0, [sp, #0x8]
700b041a: b120         	cbz	r0, 0x700b0426 <HwiP_irq_handler_c+0x56> @ imm = #0x8
700b041c: e7ff         	b	0x700b041e <HwiP_irq_handler_c+0x4e> @ imm = #-0x2
;             isr(args);
700b041e: 9902         	ldr	r1, [sp, #0x8]
700b0420: 9801         	ldr	r0, [sp, #0x4]
700b0422: 4788         	blx	r1
;         }
700b0424: e7ff         	b	0x700b0426 <HwiP_irq_handler_c+0x56> @ imm = #-0x2
;         (void)HwiP_disable();
700b0426: f000 ea9c    	blx	0x700b0960 <HwiP_disable> @ imm = #0x538
;         if(isPulse == 0U)
700b042a: 9803         	ldr	r0, [sp, #0xc]
700b042c: b920         	cbnz	r0, 0x700b0438 <HwiP_irq_handler_c+0x68> @ imm = #0x8
700b042e: e7ff         	b	0x700b0430 <HwiP_irq_handler_c+0x60> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b0430: 9804         	ldr	r0, [sp, #0x10]
700b0432: f7ff fd4d    	bl	0x700afed0 <HwiP_clearInt> @ imm = #-0x566
;         }
700b0436: e7ff         	b	0x700b0438 <HwiP_irq_handler_c+0x68> @ imm = #-0x2
;         HwiP_ackIRQ(intNum);
700b0438: 9804         	ldr	r0, [sp, #0x10]
700b043a: f000 f859    	bl	0x700b04f0 <HwiP_ackIRQ> @ imm = #0xb2
;     }
700b043e: e00c         	b	0x700b045a <HwiP_irq_handler_c+0x8a> @ imm = #0x18
;         gHwiCtrl.spuriousIRQCount++;
700b0440: f240 0100    	movw	r1, #0x0
700b0444: f2c7 0108    	movt	r1, #0x7008
700b0448: f44f 5280    	mov.w	r2, #0x1000
700b044c: 5888         	ldr	r0, [r1, r2]
700b044e: 3001         	adds	r0, #0x1
700b0450: 5088         	str	r0, [r1, r2]
700b0452: 2000         	movs	r0, #0x0
;         HwiP_ackIRQ(0);
700b0454: f000 f84c    	bl	0x700b04f0 <HwiP_ackIRQ> @ imm = #0x98
700b0458: e7ff         	b	0x700b045a <HwiP_irq_handler_c+0x8a> @ imm = #-0x2
; }
700b045a: b006         	add	sp, #0x18
700b045c: bd80         	pop	{r7, pc}
700b045e: bf00         	nop

700b0460 <HwiP_getIRQ>:
; {
700b0460: b084         	sub	sp, #0x10
700b0462: 9003         	str	r0, [sp, #0xc]
700b0464: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700b0468: 9001         	str	r0, [sp, #0x4]
;     *intNum = 0;
700b046a: 9903         	ldr	r1, [sp, #0xc]
700b046c: 2000         	movs	r0, #0x0
700b046e: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_ACTIRQ);
700b0470: f642 10f8    	movw	r0, #0x29f8
700b0474: f2c7 000b    	movt	r0, #0x700b
700b0478: 6800         	ldr	r0, [r0]
700b047a: 3020         	adds	r0, #0x20
700b047c: 9002         	str	r0, [sp, #0x8]
;     value = *addr;
700b047e: 9802         	ldr	r0, [sp, #0x8]
700b0480: 6800         	ldr	r0, [r0]
700b0482: 9000         	str	r0, [sp]
;     if((value & 0x80000000U) != 0U)
700b0484: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700b0488: 0600         	lsls	r0, r0, #0x18
700b048a: 2800         	cmp	r0, #0x0
700b048c: d508         	bpl	0x700b04a0 <HwiP_getIRQ+0x40> @ imm = #0x10
700b048e: e7ff         	b	0x700b0490 <HwiP_getIRQ+0x30> @ imm = #-0x2
;         *intNum = (value & (HwiP_MAX_INTERRUPTS-1U));
700b0490: 9800         	ldr	r0, [sp]
700b0492: f36f 205f    	bfc	r0, #9, #23
700b0496: 9903         	ldr	r1, [sp, #0xc]
700b0498: 6008         	str	r0, [r1]
700b049a: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700b049c: 9001         	str	r0, [sp, #0x4]
;     }
700b049e: e7ff         	b	0x700b04a0 <HwiP_getIRQ+0x40> @ imm = #-0x2
;     return status;
700b04a0: 9801         	ldr	r0, [sp, #0x4]
700b04a2: b004         	add	sp, #0x10
700b04a4: 4770         	bx	lr
700b04a6: bf00         	nop
700b04a8: bf00         	nop
700b04aa: bf00         	nop
700b04ac: bf00         	nop
700b04ae: bf00         	nop

700b04b0 <HwiP_isPulse>:
; {
700b04b0: b083         	sub	sp, #0xc
700b04b2: 9002         	str	r0, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(intNum));
700b04b4: f642 10f8    	movw	r0, #0x29f8
700b04b8: f2c7 000b    	movt	r0, #0x700b
700b04bc: 6801         	ldr	r1, [r0]
700b04be: 9802         	ldr	r0, [sp, #0x8]
700b04c0: f400 70f0    	and	r0, r0, #0x1e0
700b04c4: 4408         	add	r0, r1
700b04c6: f200 401c    	addw	r0, r0, #0x41c
700b04ca: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700b04cc: 9802         	ldr	r0, [sp, #0x8]
700b04ce: f000 001f    	and	r0, r0, #0x1f
700b04d2: 9000         	str	r0, [sp]
;     return ((*addr >> bitPos) & 0x1u );
700b04d4: 9801         	ldr	r0, [sp, #0x4]
700b04d6: 6800         	ldr	r0, [r0]
700b04d8: 9900         	ldr	r1, [sp]
700b04da: 40c8         	lsrs	r0, r1
700b04dc: f000 0001    	and	r0, r0, #0x1
700b04e0: b003         	add	sp, #0xc
700b04e2: 4770         	bx	lr
700b04e4: bf00         	nop
700b04e6: bf00         	nop
700b04e8: bf00         	nop
700b04ea: bf00         	nop
700b04ec: bf00         	nop
700b04ee: bf00         	nop

700b04f0 <HwiP_ackIRQ>:
; {
700b04f0: b082         	sub	sp, #0x8
700b04f2: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700b04f4: f642 10f8    	movw	r0, #0x29f8
700b04f8: f2c7 000b    	movt	r0, #0x700b
700b04fc: 6800         	ldr	r0, [r0]
700b04fe: 3018         	adds	r0, #0x18
700b0500: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0502: 9801         	ldr	r0, [sp, #0x4]
700b0504: 9900         	ldr	r1, [sp]
700b0506: 6008         	str	r0, [r1]
; }
700b0508: b002         	add	sp, #0x8
700b050a: 4770         	bx	lr
700b050c: bf00         	nop
700b050e: bf00         	nop

700b0510 <HwiP_fiq_handler>:
; {
700b0510: b5df         	push	{r0, r1, r2, r3, r4, r6, r7, lr}
700b0512: af06         	add	r7, sp, #0x18
700b0514: b086         	sub	sp, #0x18
700b0516: 466c         	mov	r4, sp
700b0518: f36f 0402    	bfc	r4, #0, #3
700b051c: 46a5         	mov	sp, r4
;     gdummy = HwiP_getFIQVecAddr();
700b051e: f000 f867    	bl	0x700b05f0 <HwiP_getFIQVecAddr> @ imm = #0xce
700b0522: f244 188c    	movw	r8, #0x418c
700b0526: f2c7 0808    	movt	r8, #0x7008
700b052a: f8c8 0000    	str.w	r0, [r8]
700b052e: a804         	add	r0, sp, #0x10
;     status = HwiP_getFIQ(&intNum);
700b0530: f000 f86e    	bl	0x700b0610 <HwiP_getFIQ> @ imm = #0xdc
700b0534: 9005         	str	r0, [sp, #0x14]
;     if(status==SystemP_SUCCESS)
700b0536: f8dd 8014    	ldr.w	r8, [sp, #0x14]
700b053a: f1b8 0f00    	cmp.w	r8, #0x0
700b053e: d13b         	bne	0x700b05b8 <HwiP_fiq_handler+0xa8> @ imm = #0x76
700b0540: e7ff         	b	0x700b0542 <HwiP_fiq_handler+0x32> @ imm = #-0x2
;         uint32_t isPulse = HwiP_isPulse(intNum);
700b0542: 9804         	ldr	r0, [sp, #0x10]
700b0544: f7ff ffb4    	bl	0x700b04b0 <HwiP_isPulse> @ imm = #-0x98
700b0548: 9003         	str	r0, [sp, #0xc]
;         if(isPulse != 0U)
700b054a: f8dd 800c    	ldr.w	r8, [sp, #0xc]
700b054e: f1b8 0f00    	cmp.w	r8, #0x0
700b0552: d004         	beq	0x700b055e <HwiP_fiq_handler+0x4e> @ imm = #0x8
700b0554: e7ff         	b	0x700b0556 <HwiP_fiq_handler+0x46> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b0556: 9804         	ldr	r0, [sp, #0x10]
700b0558: f7ff fcba    	bl	0x700afed0 <HwiP_clearInt> @ imm = #-0x68c
;         }
700b055c: e7ff         	b	0x700b055e <HwiP_fiq_handler+0x4e> @ imm = #-0x2
;         isr = gHwiCtrl.isr[intNum];
700b055e: f8dd 9010    	ldr.w	r9, [sp, #0x10]
700b0562: f240 0800    	movw	r8, #0x0
700b0566: f2c7 0808    	movt	r8, #0x7008
700b056a: f858 9029    	ldr.w	r9, [r8, r9, lsl #2]
700b056e: f8cd 9008    	str.w	r9, [sp, #0x8]
;         args = gHwiCtrl.isrArgs[intNum];
700b0572: f8dd 9010    	ldr.w	r9, [sp, #0x10]
700b0576: eb08 0889    	add.w	r8, r8, r9, lsl #2
700b057a: f8d8 8800    	ldr.w	r8, [r8, #0x800]
700b057e: f8cd 8004    	str.w	r8, [sp, #0x4]
;         if(isr!=NULL)
700b0582: f8dd 8008    	ldr.w	r8, [sp, #0x8]
700b0586: f1b8 0f00    	cmp.w	r8, #0x0
700b058a: d005         	beq	0x700b0598 <HwiP_fiq_handler+0x88> @ imm = #0xa
700b058c: e7ff         	b	0x700b058e <HwiP_fiq_handler+0x7e> @ imm = #-0x2
;             isr(args);
700b058e: f8dd 8008    	ldr.w	r8, [sp, #0x8]
700b0592: 9801         	ldr	r0, [sp, #0x4]
700b0594: 47c0         	blx	r8
;         }
700b0596: e7ff         	b	0x700b0598 <HwiP_fiq_handler+0x88> @ imm = #-0x2
;         (void)HwiP_disableFIQ();
700b0598: f000 e9ea    	blx	0x700b0970 <HwiP_disableFIQ> @ imm = #0x3d4
;         if(isPulse == 0U)
700b059c: f8dd 800c    	ldr.w	r8, [sp, #0xc]
700b05a0: f1b8 0f00    	cmp.w	r8, #0x0
700b05a4: d104         	bne	0x700b05b0 <HwiP_fiq_handler+0xa0> @ imm = #0x8
700b05a6: e7ff         	b	0x700b05a8 <HwiP_fiq_handler+0x98> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b05a8: 9804         	ldr	r0, [sp, #0x10]
700b05aa: f7ff fc91    	bl	0x700afed0 <HwiP_clearInt> @ imm = #-0x6de
;         }
700b05ae: e7ff         	b	0x700b05b0 <HwiP_fiq_handler+0xa0> @ imm = #-0x2
;         HwiP_ackFIQ(intNum);
700b05b0: 9804         	ldr	r0, [sp, #0x10]
700b05b2: f000 f855    	bl	0x700b0660 <HwiP_ackFIQ> @ imm = #0xaa
;     }
700b05b6: e00f         	b	0x700b05d8 <HwiP_fiq_handler+0xc8> @ imm = #0x1e
;         gHwiCtrl.spuriousFIQCount++;
700b05b8: f240 0900    	movw	r9, #0x0
700b05bc: f2c7 0908    	movt	r9, #0x7008
700b05c0: f241 0a04    	movw	r10, #0x1004
700b05c4: f859 800a    	ldr.w	r8, [r9, r10]
700b05c8: f108 0801    	add.w	r8, r8, #0x1
700b05cc: f849 800a    	str.w	r8, [r9, r10]
700b05d0: 2000         	movs	r0, #0x0
;         HwiP_ackFIQ(0);
700b05d2: f000 f845    	bl	0x700b0660 <HwiP_ackFIQ> @ imm = #0x8a
700b05d6: e7ff         	b	0x700b05d8 <HwiP_fiq_handler+0xc8> @ imm = #-0x2
; }
700b05d8: f1a7 0418    	sub.w	r4, r7, #0x18
700b05dc: 46a5         	mov	sp, r4
700b05de: e8bd 40df    	pop.w	{r0, r1, r2, r3, r4, r6, r7, lr}
700b05e2: f3de 8f04    	subs	pc, lr, #0x4
700b05e6: bf00         	nop
700b05e8: bf00         	nop
700b05ea: bf00         	nop
700b05ec: bf00         	nop
700b05ee: bf00         	nop

700b05f0 <HwiP_getFIQVecAddr>:
; {
700b05f0: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b05f2: f642 10f8    	movw	r0, #0x29f8
700b05f6: f2c7 000b    	movt	r0, #0x700b
700b05fa: 6800         	ldr	r0, [r0]
700b05fc: 301c         	adds	r0, #0x1c
700b05fe: 9000         	str	r0, [sp]
;     return *addr;
700b0600: 9800         	ldr	r0, [sp]
700b0602: 6800         	ldr	r0, [r0]
700b0604: b001         	add	sp, #0x4
700b0606: 4770         	bx	lr
700b0608: bf00         	nop
700b060a: bf00         	nop
700b060c: bf00         	nop
700b060e: bf00         	nop

700b0610 <HwiP_getFIQ>:
; {
700b0610: b084         	sub	sp, #0x10
700b0612: 9003         	str	r0, [sp, #0xc]
700b0614: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700b0618: 9001         	str	r0, [sp, #0x4]
;     *intNum = 0;
700b061a: 9903         	ldr	r1, [sp, #0xc]
700b061c: 2000         	movs	r0, #0x0
700b061e: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_ACTFIQ);
700b0620: f642 10f8    	movw	r0, #0x29f8
700b0624: f2c7 000b    	movt	r0, #0x700b
700b0628: 6800         	ldr	r0, [r0]
700b062a: 3024         	adds	r0, #0x24
700b062c: 9002         	str	r0, [sp, #0x8]
;     value = *addr;
700b062e: 9802         	ldr	r0, [sp, #0x8]
700b0630: 6800         	ldr	r0, [r0]
700b0632: 9000         	str	r0, [sp]
;     if((value & 0x80000000U) != 0U)
700b0634: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700b0638: 0600         	lsls	r0, r0, #0x18
700b063a: 2800         	cmp	r0, #0x0
700b063c: d508         	bpl	0x700b0650 <HwiP_getFIQ+0x40> @ imm = #0x10
700b063e: e7ff         	b	0x700b0640 <HwiP_getFIQ+0x30> @ imm = #-0x2
;         *intNum = (value & 0x3FFU);
700b0640: 9800         	ldr	r0, [sp]
700b0642: f36f 209f    	bfc	r0, #10, #22
700b0646: 9903         	ldr	r1, [sp, #0xc]
700b0648: 6008         	str	r0, [r1]
700b064a: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700b064c: 9001         	str	r0, [sp, #0x4]
;     }
700b064e: e7ff         	b	0x700b0650 <HwiP_getFIQ+0x40> @ imm = #-0x2
;     return status;
700b0650: 9801         	ldr	r0, [sp, #0x4]
700b0652: b004         	add	sp, #0x10
700b0654: 4770         	bx	lr
700b0656: bf00         	nop
700b0658: bf00         	nop
700b065a: bf00         	nop
700b065c: bf00         	nop
700b065e: bf00         	nop

700b0660 <HwiP_ackFIQ>:
; {
700b0660: b082         	sub	sp, #0x8
700b0662: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b0664: f642 10f8    	movw	r0, #0x29f8
700b0668: f2c7 000b    	movt	r0, #0x700b
700b066c: 6800         	ldr	r0, [r0]
700b066e: 301c         	adds	r0, #0x1c
700b0670: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0672: 9801         	ldr	r0, [sp, #0x4]
700b0674: 9900         	ldr	r1, [sp]
700b0676: 6008         	str	r0, [r1]
; }
700b0678: b002         	add	sp, #0x8
700b067a: 4770         	bx	lr
700b067c: bf00         	nop
700b067e: bf00         	nop

700b0680 <HwiP_reserved_handler>:
; {
700b0680: b5d0         	push	{r4, r6, r7, lr}
700b0682: af02         	add	r7, sp, #0x8
700b0684: b082         	sub	sp, #0x8
700b0686: 466c         	mov	r4, sp
700b0688: f36f 0402    	bfc	r4, #0, #3
700b068c: 46a5         	mov	sp, r4
700b068e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b0692: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U) { ; }
700b0696: e7ff         	b	0x700b0698 <HwiP_reserved_handler+0x18> @ imm = #-0x2
700b0698: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b069c: f1be 0f00    	cmp.w	lr, #0x0
700b06a0: d001         	beq	0x700b06a6 <HwiP_reserved_handler+0x26> @ imm = #0x2
700b06a2: e7ff         	b	0x700b06a4 <HwiP_reserved_handler+0x24> @ imm = #-0x2
700b06a4: e7f8         	b	0x700b0698 <HwiP_reserved_handler+0x18> @ imm = #-0x10
; }
700b06a6: f1a7 0408    	sub.w	r4, r7, #0x8
700b06aa: 46a5         	mov	sp, r4
700b06ac: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b06b0: f3de 8f00    	subs	pc, lr, #0x0
700b06b4: bf00         	nop
700b06b6: bf00         	nop
700b06b8: bf00         	nop
700b06ba: bf00         	nop
700b06bc: bf00         	nop
700b06be: bf00         	nop

700b06c0 <HwiP_undefined_handler>:
; {
700b06c0: b5d0         	push	{r4, r6, r7, lr}
700b06c2: af02         	add	r7, sp, #0x8
700b06c4: b082         	sub	sp, #0x8
700b06c6: 466c         	mov	r4, sp
700b06c8: f36f 0402    	bfc	r4, #0, #3
700b06cc: 46a5         	mov	sp, r4
700b06ce: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b06d2: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U){  ; }
700b06d6: e7ff         	b	0x700b06d8 <HwiP_undefined_handler+0x18> @ imm = #-0x2
700b06d8: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b06dc: f1be 0f00    	cmp.w	lr, #0x0
700b06e0: d001         	beq	0x700b06e6 <HwiP_undefined_handler+0x26> @ imm = #0x2
700b06e2: e7ff         	b	0x700b06e4 <HwiP_undefined_handler+0x24> @ imm = #-0x2
700b06e4: e7f8         	b	0x700b06d8 <HwiP_undefined_handler+0x18> @ imm = #-0x10
; }
700b06e6: f1a7 0408    	sub.w	r4, r7, #0x8
700b06ea: 46a5         	mov	sp, r4
700b06ec: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b06f0: f3de 8f00    	subs	pc, lr, #0x0
700b06f4: bf00         	nop
700b06f6: bf00         	nop
700b06f8: bf00         	nop
700b06fa: bf00         	nop
700b06fc: bf00         	nop
700b06fe: bf00         	nop

700b0700 <HwiP_prefetch_abort_handler>:
; {
700b0700: b5d0         	push	{r4, r6, r7, lr}
700b0702: af02         	add	r7, sp, #0x8
700b0704: b082         	sub	sp, #0x8
700b0706: 466c         	mov	r4, sp
700b0708: f36f 0402    	bfc	r4, #0, #3
700b070c: 46a5         	mov	sp, r4
700b070e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b0712: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U)  { ;}
700b0716: e7ff         	b	0x700b0718 <HwiP_prefetch_abort_handler+0x18> @ imm = #-0x2
700b0718: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b071c: f1be 0f00    	cmp.w	lr, #0x0
700b0720: d001         	beq	0x700b0726 <HwiP_prefetch_abort_handler+0x26> @ imm = #0x2
700b0722: e7ff         	b	0x700b0724 <HwiP_prefetch_abort_handler+0x24> @ imm = #-0x2
700b0724: e7f8         	b	0x700b0718 <HwiP_prefetch_abort_handler+0x18> @ imm = #-0x10
; }
700b0726: f1a7 0408    	sub.w	r4, r7, #0x8
700b072a: 46a5         	mov	sp, r4
700b072c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b0730: f3de 8f04    	subs	pc, lr, #0x4
700b0734: bf00         	nop
700b0736: bf00         	nop
700b0738: bf00         	nop
700b073a: bf00         	nop
700b073c: bf00         	nop
700b073e: bf00         	nop

700b0740 <HwiP_data_abort_handler_c>:
; {
700b0740: b5d0         	push	{r4, r6, r7, lr}
700b0742: af02         	add	r7, sp, #0x8
700b0744: b082         	sub	sp, #0x8
700b0746: 466c         	mov	r4, sp
700b0748: f36f 0402    	bfc	r4, #0, #3
700b074c: 46a5         	mov	sp, r4
700b074e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b0752: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U){ ; }
700b0756: e7ff         	b	0x700b0758 <HwiP_data_abort_handler_c+0x18> @ imm = #-0x2
700b0758: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b075c: f1be 0f00    	cmp.w	lr, #0x0
700b0760: d001         	beq	0x700b0766 <HwiP_data_abort_handler_c+0x26> @ imm = #0x2
700b0762: e7ff         	b	0x700b0764 <HwiP_data_abort_handler_c+0x24> @ imm = #-0x2
700b0764: e7f8         	b	0x700b0758 <HwiP_data_abort_handler_c+0x18> @ imm = #-0x10
; }
700b0766: f1a7 0408    	sub.w	r4, r7, #0x8
700b076a: 46a5         	mov	sp, r4
700b076c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b0770: f3de 8f04    	subs	pc, lr, #0x4

700b0774 <vPortRestoreTaskContext>:
;         CPS     #SYS_MODE
700b0774: f102001f     	cps	#0x1f
;         portRESTORE_CONTEXT
700b0778: e59f01c8     	ldr	r0, [pc, #0x1c8]        @ 0x700b0948 <pxCurrentTCBConst>
700b077c: e5901000     	ldr	r1, [r0]
700b0780: e591d000     	ldr	sp, [r1]
700b0784: e59f01c0     	ldr	r0, [pc, #0x1c0]        @ 0x700b094c <ulPortTaskHasFPUContextConst>
700b0788: e49d1004     	ldr	r1, [sp], #4
700b078c: e5801000     	str	r1, [r0]
700b0790: e3510000     	cmp	r1, #0
700b0794: 149d0004     	ldrne	r0, [sp], #4
700b0798: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b079c: 1ee10a10     	vmsrne	fpscr, r0
700b07a0: f57ff01f     	clrex
700b07a4: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b07a8: f8bd0a00     	rfeia	sp!

700b07ac <HwiP_svc_handler>:
;         portSAVE_CONTEXT
700b07ac: f96d051f     	srsdb	sp!, #0x1f
700b07b0: f102001f     	cps	#0x1f
700b07b4: e92d5fff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b07b8: e59f218c     	ldr	r2, [pc, #0x18c]        @ 0x700b094c <ulPortTaskHasFPUContextConst>
700b07bc: e5923000     	ldr	r3, [r2]
700b07c0: e3530000     	cmp	r3, #0
700b07c4: 1ef11a10     	vmrsne	r1, fpscr
700b07c8: 1d2d0b20     	vpushne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b07cc: 152d1004     	strne	r1, [sp, #-0x4]!
700b07d0: e52d3004     	str	r3, [sp, #-0x4]!
700b07d4: e59f016c     	ldr	r0, [pc, #0x16c]        @ 0x700b0948 <pxCurrentTCBConst>
700b07d8: e5901000     	ldr	r1, [r0]
700b07dc: e581d000     	str	sp, [r1]
;         LDR     R0, vTaskSwitchContextConst
700b07e0: e59f0168     	ldr	r0, [pc, #0x168]        @ 0x700b0950 <vTaskSwitchContextConst>
;         BLX     R0
700b07e4: e12fff30     	blx	r0
;         portRESTORE_CONTEXT
700b07e8: e59f0158     	ldr	r0, [pc, #0x158]        @ 0x700b0948 <pxCurrentTCBConst>
700b07ec: e5901000     	ldr	r1, [r0]
700b07f0: e591d000     	ldr	sp, [r1]
700b07f4: e59f0150     	ldr	r0, [pc, #0x150]        @ 0x700b094c <ulPortTaskHasFPUContextConst>
700b07f8: e49d1004     	ldr	r1, [sp], #4
700b07fc: e5801000     	str	r1, [r0]
700b0800: e3510000     	cmp	r1, #0
700b0804: 149d0004     	ldrne	r0, [sp], #4
700b0808: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b080c: 1ee10a10     	vmsrne	fpscr, r0
700b0810: f57ff01f     	clrex
700b0814: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b0818: f8bd0a00     	rfeia	sp!

700b081c <HwiP_irq_handler>:
;         SUB             lr, lr, #4
700b081c: e24ee004     	sub	lr, lr, #4
;         PUSH    {lr}
700b0820: e52de004     	str	lr, [sp, #-0x4]!
;         MRS     lr, SPSR
700b0824: e14fe000     	mrs	lr, spsr
;         PUSH    {lr}
700b0828: e52de004     	str	lr, [sp, #-0x4]!
;         CPS  #SVC_MODE
700b082c: f1020013     	cps	#0x13
;         PUSH    {r0-r4, r12}
700b0830: e92d101f     	push	{r0, r1, r2, r3, r4, r12}
;         LDR     r3, ulPortInterruptNestingConst
700b0834: e59f3118     	ldr	r3, [pc, #0x118]        @ 0x700b0954 <ulPortInterruptNestingConst>
;         LDR     r1, [r3]
700b0838: e5931000     	ldr	r1, [r3]
;         ADD     r4, r1, #1
700b083c: e2814001     	add	r4, r1, #1
;         STR     r4, [r3]
700b0840: e5834000     	str	r4, [r3]
;         FMRX  R0, FPSCR
700b0844: eef10a10     	vmrs	r0, fpscr
;         VPUSH {D0-D15}
700b0848: ed2d0b20     	vpush	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
;         PUSH  {R0}
700b084c: e52d0004     	str	r0, [sp, #-0x4]!
;         MOV     r2, sp
700b0850: e1a0200d     	mov	r2, sp
;         AND     r2, r2, #4
700b0854: e2022004     	and	r2, r2, #4
;         SUB     sp, sp, r2
700b0858: e04dd002     	sub	sp, sp, r2
;         PUSH    {r0-r4, lr}
700b085c: e92d401f     	push	{r0, r1, r2, r3, r4, lr}
;         LDR     r1, vApplicationIRQHandlerConst
700b0860: e59f10f0     	ldr	r1, [pc, #0xf0]         @ 0x700b0958 <vApplicationIRQHandlerConst>
;         BLX     r1
700b0864: e12fff31     	blx	r1
;         POP     {r0-r4, lr}
700b0868: e8bd401f     	pop	{r0, r1, r2, r3, r4, lr}
;         ADD     sp, sp, r2
700b086c: e08dd002     	add	sp, sp, r2
;         CPSID   i
700b0870: f10c0080     	cpsid	i
;         DSB
700b0874: f57ff04f     	dsb	sy
;         ISB
700b0878: f57ff06f     	isb	sy
;         POP   {R0}
700b087c: e49d0004     	ldr	r0, [sp], #4
;         VPOP  {D0-D15}
700b0880: ecbd0b20     	vpop	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
;         VMSR  FPSCR, R0
700b0884: eee10a10     	vmsr	fpscr, r0
;         STR     r1, [r3]
700b0888: e5831000     	str	r1, [r3]
;         CMP     r1, #0
700b088c: e3510000     	cmp	r1, #0
;         BNE     exit_without_switch
700b0890: 1a000003     	bne	0x700b08a4 <exit_without_switch> @ imm = #0xc
;         LDR     r1, =ulPortYieldRequired
700b0894: e59f10c0     	ldr	r1, [pc, #0xc0]         @ 0x700b095c <vApplicationIRQHandlerConst+0x4>
;         LDR     r0, [r1]
700b0898: e5910000     	ldr	r0, [r1]
;         CMP     r0, #0
700b089c: e3500000     	cmp	r0, #0
;         BNE     switch_before_exit
700b08a0: 1a000005     	bne	0x700b08bc <switch_before_exit> @ imm = #0x14

700b08a4 <exit_without_switch>:
;         POP     {r0-r4, r12}
700b08a4: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         CPS  #IRQ_MODE
700b08a8: f1020012     	cps	#0x12
;         POP     {LR}
700b08ac: e49de004     	ldr	lr, [sp], #4
;         MSR     SPSR_cxsf, LR
700b08b0: e16ff00e     	msr	SPSR_fsxc, lr
;         POP     {LR}
700b08b4: e49de004     	ldr	lr, [sp], #4
;         MOVS    PC, LR
700b08b8: e1b0f00e     	movs	pc, lr

700b08bc <switch_before_exit>:
;         MOV     r0, #0
700b08bc: e3a00000     	mov	r0, #0
;         STR     r0, [r1]
700b08c0: e5810000     	str	r0, [r1]
;         POP     {r0-r4, r12}
700b08c4: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         CPS  #IRQ_MODE
700b08c8: f1020012     	cps	#0x12
;         POP     {LR}
700b08cc: e49de004     	ldr	lr, [sp], #4
;         MSR     SPSR_cxsf, LR
700b08d0: e16ff00e     	msr	SPSR_fsxc, lr
;         POP     {LR}
700b08d4: e49de004     	ldr	lr, [sp], #4
;         portSAVE_CONTEXT
700b08d8: f96d051f     	srsdb	sp!, #0x1f
700b08dc: f102001f     	cps	#0x1f
700b08e0: e92d5fff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b08e4: e59f2060     	ldr	r2, [pc, #0x60]         @ 0x700b094c <ulPortTaskHasFPUContextConst>
700b08e8: e5923000     	ldr	r3, [r2]
700b08ec: e3530000     	cmp	r3, #0
700b08f0: 1ef11a10     	vmrsne	r1, fpscr
700b08f4: 1d2d0b20     	vpushne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b08f8: 152d1004     	strne	r1, [sp, #-0x4]!
700b08fc: e52d3004     	str	r3, [sp, #-0x4]!
700b0900: e59f0040     	ldr	r0, [pc, #0x40]         @ 0x700b0948 <pxCurrentTCBConst>
700b0904: e5901000     	ldr	r1, [r0]
700b0908: e581d000     	str	sp, [r1]
;         LDR     R0, vTaskSwitchContextConst
700b090c: e59f003c     	ldr	r0, [pc, #0x3c]         @ 0x700b0950 <vTaskSwitchContextConst>
;         BLX     R0
700b0910: e12fff30     	blx	r0
;         portRESTORE_CONTEXT
700b0914: e59f002c     	ldr	r0, [pc, #0x2c]         @ 0x700b0948 <pxCurrentTCBConst>
700b0918: e5901000     	ldr	r1, [r0]
700b091c: e591d000     	ldr	sp, [r1]
700b0920: e59f0024     	ldr	r0, [pc, #0x24]         @ 0x700b094c <ulPortTaskHasFPUContextConst>
700b0924: e49d1004     	ldr	r1, [sp], #4
700b0928: e5801000     	str	r1, [r0]
700b092c: e3510000     	cmp	r1, #0
700b0930: 149d0004     	ldrne	r0, [sp], #4
700b0934: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b0938: 1ee10a10     	vmsrne	fpscr, r0
700b093c: f57ff01f     	clrex
700b0940: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b0944: f8bd0a00     	rfeia	sp!

700b0948 <pxCurrentTCBConst>:
700b0948: 0c 2a 0b 70  	.word	0x700b2a0c

700b094c <ulPortTaskHasFPUContextConst>:
700b094c: 24 2a 0b 70  	.word	0x700b2a24

700b0950 <vTaskSwitchContextConst>:
700b0950: 61 6a 0a 70  	.word	0x700a6a61

700b0954 <ulPortInterruptNestingConst>:
700b0954: 1c 2a 0b 70  	.word	0x700b2a1c

700b0958 <vApplicationIRQHandlerConst>:
700b0958: d1 03 0b 70  	.word	0x700b03d1
700b095c: 28 2a 0b 70  	.word	0x700b2a28

700b0960 <HwiP_disable>:
;         mrs     r0, cpsr
700b0960: e10f0000     	mrs	r0, apsr
;         orr     r12, r0, #0x80
700b0964: e380c080     	orr	r12, r0, #128
;         msr     cpsr_cf, r12
700b0968: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b096c: e12fff1e     	bx	lr

700b0970 <HwiP_disableFIQ>:
;         mrs     r0, cpsr
700b0970: e10f0000     	mrs	r0, apsr
;         orr     r12, r0, #0x40
700b0974: e380c040     	orr	r12, r0, #64
;         msr     cpsr_cf, r12
700b0978: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b097c: e12fff1e     	bx	lr

700b0980 <HwiP_enable>:
;         mrs     r0, cpsr
700b0980: e10f0000     	mrs	r0, apsr
;         bic     r12, r0, #0x80
700b0984: e3c0c080     	bic	r12, r0, #128
;         msr     cpsr_cf, r12
700b0988: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b098c: e12fff1e     	bx	lr

700b0990 <HwiP_enableFIQ>:
;         mrs     r0, cpsr
700b0990: e10f0000     	mrs	r0, apsr
;         bic     r12, r0, #0x40
700b0994: e3c0c040     	bic	r12, r0, #64
;         msr     cpsr_cf, r12
700b0998: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b099c: e12fff1e     	bx	lr

700b09a0 <HwiP_restore>:
;         msr     cpsr_cf, r0
700b09a0: e129f000     	msr	CPSR_fc, r0
;         bx      LR
700b09a4: e12fff1e     	bx	lr

700b09a8 <HwiP_enableVIC>:
;         MRC     p15, #0, r0, c1, c0, #0  /* Read SCTLR */
700b09a8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         ORR     r0, r0, #(1<<24)         /* Set VE mask (VIC controller provides handler address for IRQ) */
700b09ac: e3800401     	orr	r0, r0, #16777216
;         MCR     p15, #0, r0, c1, c0, #0  /* Write modified SCTLR */
700b09b0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b09b4: e12fff1e     	bx	lr

700b09b8 <HwiP_disableVIC>:
;         MRC     p15, #0, r0, c1, c0, #0  /* Read SCTLR */
700b09b8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         BIC     r0, r0, #(1<<24)         /* Clear VE mask (VIC controller provides handler address for IRQ) */
700b09bc: e3c00401     	bic	r0, r0, #16777216
;         MCR     p15, #0, r0, c1, c0, #0  /* Write modified SCTLR */
700b09c0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b09c4: e12fff1e     	bx	lr

700b09c8 <HwiP_getCPSR>:
;         mrs     r0, cpsr
700b09c8: e10f0000     	mrs	r0, apsr
;         bx      LR
700b09cc: e12fff1e     	bx	lr

700b09d0 <HwiP_data_abort_handler>:
;         PUSH	{r0-r4, r12}
700b09d0: e92d101f     	push	{r0, r1, r2, r3, r4, r12}
;         MRS r0, SPSR
700b09d4: e14f0000     	mrs	r0, spsr
;         AND r1, r0, #0x20
700b09d8: e2001020     	and	r1, r0, #32
;         CMP R1, #0
700b09dc: e3510000     	cmp	r1, #0
;         BEQ ARM_STATE
700b09e0: 0a000000     	beq	0x700b09e8 <ARM_STATE>  @ imm = #0x0
;         SUB lr, lr, #2
700b09e4: e24ee002     	sub	lr, lr, #2

700b09e8 <ARM_STATE>:
;         SUB lr, lr, #4
700b09e8: e24ee004     	sub	lr, lr, #4

700b09ec <END>:
;         PUSH	{lr}
700b09ec: e52de004     	str	lr, [sp, #-0x4]!
;         MRS	lr, SPSR
700b09f0: e14fe000     	mrs	lr, spsr
;         PUSH	{lr}
700b09f4: e52de004     	str	lr, [sp, #-0x4]!
;         LDR	r1, HwiP_data_abort_handler_const
700b09f8: e59f1014     	ldr	r1, [pc, #0x14]         @ 0x700b0a14 <HwiP_data_abort_handler_const>
;         BLX	r1
700b09fc: e12fff31     	blx	r1
;         POP	{LR}
700b0a00: e49de004     	ldr	lr, [sp], #4
;         MSR	SPSR_cxsf, LR
700b0a04: e16ff00e     	msr	SPSR_fsxc, lr
;         POP	{LR}
700b0a08: e49de004     	ldr	lr, [sp], #4
;         POP	{r0-r4, r12}
700b0a0c: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         MOVS	PC, LR
700b0a10: e1b0f00e     	movs	pc, lr

700b0a14 <HwiP_data_abort_handler_const>:
700b0a14: 41 07 0b 70  	.word	0x700b0741
700b0a18: 00 00 00 00  	.word	0x00000000
700b0a1c: 00 00 00 00  	.word	0x00000000

Disassembly of section .text.cache:

700b0a20 <CacheP_disableL1d>:
;         push    {r0-r7, r9-r11, lr}
700b0a20: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700b0a24: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x0004         // clear C bit
700b0a28: e3c00004     	bic	r0, r0, #4
;         dsb
700b0a2c: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0 // L1D cache disabled
700b0a30: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         movw    r0, :lower16:CacheP_wbInvAllAsm
700b0a34: e3000c4c     	movw	r0, #0xc4c
;         movt    r0, :upper16:CacheP_wbInvAllAsm
700b0a38: e347000b     	movt	r0, #0x700b
;         blx     r0
700b0a3c: e12fff30     	blx	r0
;         pop     {r0-r7, r9-r11, lr}
700b0a40: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700b0a44: e12fff1e     	bx	lr

700b0a48 <CacheP_disableL1p>:
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700b0a48: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x1000         // clear I bit
700b0a4c: e3c00a01     	bic	r0, r0, #4096
;         mcr     p15, #0, r0, c1, c0, #0 // L1P cache disabled
700b0a50: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         mcr     p15, #0, r1, c7, c5, #0 // Invalidate entire instruction cache
700b0a54: ee071f15     	mcr	p15, #0x0, r1, c7, c5, #0x0
;         isb
700b0a58: f57ff06f     	isb	sy
;         bx      lr
700b0a5c: e12fff1e     	bx	lr

700b0a60 <CacheP_enableL1d>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCR register
700b0a60: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x0004          // set C bit (bit 2) to 1
700b0a64: e3800004     	orr	r0, r0, #4
;         dsb
700b0a68: f57ff04f     	dsb	sy
;         mcr     p15, #0, r1, c15, c5, #0 // Invalidate entire data cache
700b0a6c: ee0f1f15     	mcr	p15, #0x0, r1, c15, c5, #0x0
;         mcr     p15, #0, r0, c1, c0, #0  // L1D cache enabled
700b0a70: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      lr
700b0a74: e12fff1e     	bx	lr

700b0a78 <CacheP_enableL1p>:
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700b0a78: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x1000         // set I bit (bit 12) to 1
700b0a7c: e3800a01     	orr	r0, r0, #4096
;         mcr     p15, #0, r1, c7, c5, #0 // Invalidate entire instruction cache
700b0a80: ee071f15     	mcr	p15, #0x0, r1, c7, c5, #0x0
;         mcr     p15, #0, r0, c1, c0, #0 // ICache enabled
700b0a84: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb
700b0a88: f57ff06f     	isb	sy
;         bx      lr
700b0a8c: e12fff1e     	bx	lr

700b0a90 <CacheP_invL1d>:
;         push    {r4}
700b0a90: e52d4004     	str	r4, [sp, #-0x4]!
;         add     r1, r0, r1              // calculate last address
700b0a94: e0801001     	add	r1, r0, r1
;         ldr     r3, l1dCacheLineSizeInvL1dAddr
700b0a98: e59f3024     	ldr	r3, [pc, #0x24]         @ 0x700b0ac4 <l1dCacheLineSizeInvL1dAddr>
;         ldr     r3, [r3]
700b0a9c: e5933000     	ldr	r3, [r3]
;         sub     r4, r3, #1
700b0aa0: e2434001     	sub	r4, r3, #1
;         bic     r0, r0, r4              // align blockPtr to cache line
700b0aa4: e1c00004     	bic	r0, r0, r4

700b0aa8 <invL1dCache_loop>:
;         mcr     p15, #0, r0, c7, c6, #1 // invalidate single entry in L1D cache
700b0aa8: ee070f36     	mcr	p15, #0x0, r0, c7, c6, #0x1
;         add     r0, r0, r3              // increment address by cache line size
700b0aac: e0800003     	add	r0, r0, r3
;         cmp     r0, r1                  // compare to last address
700b0ab0: e1500001     	cmp	r0, r1
;         blo     invL1dCache_loop        // loop if > 0
700b0ab4: 3afffffb     	blo	0x700b0aa8 <invL1dCache_loop> @ imm = #-0x14
;         dsb                             // drain write buffer
700b0ab8: f57ff04f     	dsb	sy
;         pop     {r4}
700b0abc: e49d4004     	ldr	r4, [sp], #4
;         bx      lr                      // return
700b0ac0: e12fff1e     	bx	lr

700b0ac4 <l1dCacheLineSizeInvL1dAddr>:
700b0ac4: 38 26 0b 70  	.word	0x700b2638

700b0ac8 <CacheP_invL1p>:
;         push    {r4}
700b0ac8: e52d4004     	str	r4, [sp, #-0x4]!
;         add     r1, r0, r1              // calculate last address
700b0acc: e0801001     	add	r1, r0, r1
;         ldr     r3, l1pCacheLineSizeAddr
700b0ad0: e59f3028     	ldr	r3, [pc, #0x28]         @ 0x700b0b00 <l1pCacheLineSizeAddr>
;         ldr     r3, [r3]
700b0ad4: e5933000     	ldr	r3, [r3]
;         sub     r4, r3, #1
700b0ad8: e2434001     	sub	r4, r3, #1
;         bic     r0, r0, r4              // align blockPtr to cache line
700b0adc: e1c00004     	bic	r0, r0, r4

700b0ae0 <invL1pCache_loop>:
;         mcr     p15, #0, r0, c7, c5, #1 // invalidate single entry in ICache
700b0ae0: ee070f35     	mcr	p15, #0x0, r0, c7, c5, #0x1
;         add     r0, r0, r3              // increment address by cache line size
700b0ae4: e0800003     	add	r0, r0, r3
;         cmp     r0, r1                  // compare to last address
700b0ae8: e1500001     	cmp	r0, r1
;         blo     invL1pCache_loop        // loop if > 0
700b0aec: 3afffffb     	blo	0x700b0ae0 <invL1pCache_loop> @ imm = #-0x14
;         dsb                             // drain write buffer
700b0af0: f57ff04f     	dsb	sy
;         isb                             // flush instruction pipeline
700b0af4: f57ff06f     	isb	sy
;         pop     {r4}
700b0af8: e49d4004     	ldr	r4, [sp], #4
;         bx      lr
700b0afc: e12fff1e     	bx	lr

700b0b00 <l1pCacheLineSizeAddr>:
700b0b00: 3c 26 0b 70  	.word	0x700b263c

700b0b04 <CacheP_invL1dAll>:
;         mcr     p15, #0, r0, c15, c5, #0 // Invalidate entire data cache
700b0b04: ee0f0f15     	mcr	p15, #0x0, r0, c15, c5, #0x0
;         bx      lr                       // return
700b0b08: e12fff1e     	bx	lr

700b0b0c <CacheP_invL1pAll>:
;         mcr     p15, #0, r0, c7, c5, #0 // invalidate all entries in ICache
700b0b0c: ee070f15     	mcr	p15, #0x0, r0, c7, c5, #0x0
;         bx      lr                      // return
700b0b10: e12fff1e     	bx	lr

700b0b14 <CacheP_wb>:
;         push    {r4, r5}
700b0b14: e92d0030     	push	{r4, r5}
;         dmb                              // Ensure all previous memory accesses
700b0b18: f57ff05f     	dmb	sy
;         add     r1, r0, r1               // calculate last address
700b0b1c: e0801001     	add	r1, r0, r1
;         ldr     r4, l1dCacheLineSizeWbAddr
700b0b20: e59f4024     	ldr	r4, [pc, #0x24]         @ 0x700b0b4c <l1dCacheLineSizeWbAddr>
;         ldr     r4, [r4]
700b0b24: e5944000     	ldr	r4, [r4]
;         sub     r5, r4, #1
700b0b28: e2445001     	sub	r5, r4, #1
;         bic     r0, r0, r5               // align address to cache line
700b0b2c: e1c00005     	bic	r0, r0, r5

700b0b30 <writeback>:
;         mcr     p15, #0, r0, c7, c10, #1 // write back a cache line
700b0b30: ee070f3a     	mcr	p15, #0x0, r0, c7, c10, #0x1
;         add     r0, r0, r4               // increment address by cache line size
700b0b34: e0800004     	add	r0, r0, r4
;         cmp     r0, r1                   // compare to last address
700b0b38: e1500001     	cmp	r0, r1
;         blo     writeback                // loop if count > 0
700b0b3c: 3afffffb     	blo	0x700b0b30 <writeback>  @ imm = #-0x14
;         dsb                              // drain write buffer
700b0b40: f57ff04f     	dsb	sy
;         pop     {r4, r5}
700b0b44: e8bd0030     	pop	{r4, r5}
;         bx      lr
700b0b48: e12fff1e     	bx	lr

700b0b4c <l1dCacheLineSizeWbAddr>:
700b0b4c: 38 26 0b 70  	.word	0x700b2638

700b0b50 <CacheP_wbInv>:
;         push    {r4, r5}
700b0b50: e92d0030     	push	{r4, r5}
;         dmb                              // Ensure all previous memory accesses
700b0b54: f57ff05f     	dmb	sy
;         add     r1, r0, r1               // calculate last address
700b0b58: e0801001     	add	r1, r0, r1
;         ldr     r4, l1dCacheLineSizeWbInvAddr
700b0b5c: e59f4024     	ldr	r4, [pc, #0x24]         @ 0x700b0b88 <l1dCacheLineSizeWbInvAddr>
;         ldr     r4, [r4]
700b0b60: e5944000     	ldr	r4, [r4]
;         sub     r5, r4, #1
700b0b64: e2445001     	sub	r5, r4, #1
;         bic     r0, r0, r5               // align blockPtr to cache line
700b0b68: e1c00005     	bic	r0, r0, r5

700b0b6c <writebackInv>:
;         mcr     p15, #0, r0, c7, c14, #1 // writeback inv a cache line
700b0b6c: ee070f3e     	mcr	p15, #0x0, r0, c7, c14, #0x1
;         add     r0, r0, r4               // increment address by cache line size
700b0b70: e0800004     	add	r0, r0, r4
;         cmp     r0, r1                   // compare to last address
700b0b74: e1500001     	cmp	r0, r1
;         blo     writebackInv             // loop if count > 0
700b0b78: 3afffffb     	blo	0x700b0b6c <writebackInv> @ imm = #-0x14
;         dsb                              // drain write buffer
700b0b7c: f57ff04f     	dsb	sy
;         pop     {r4, r5}
700b0b80: e8bd0030     	pop	{r4, r5}
;         bx      lr
700b0b84: e12fff1e     	bx	lr

700b0b88 <l1dCacheLineSizeWbInvAddr>:
700b0b88: 38 26 0b 70  	.word	0x700b2638

700b0b8c <CacheP_wbAll>:
;         stmfd   sp!, {r0-r7, r9-r11, lr}
700b0b8c: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         dmb                             // Ensure all previous memory accesses
700b0b90: f57ff05f     	dmb	sy
;         mrc     p15, #1, r0, c0, c0, #1 // read clidr
700b0b94: ee300f30     	mrc	p15, #0x1, r0, c0, c0, #0x1
;         ands    r3, r0, #0x7000000      // extract loc from clidr
700b0b98: e2103407     	ands	r3, r0, #117440512
;         mov     r3, r3, lsr #23         // left align loc bit field
700b0b9c: e1a03ba3     	lsr	r3, r3, #23
;         beq     wbafinished             // if loc is 0, then no need to clean
700b0ba0: 0a00001d     	beq	0x700b0c1c <wbafinished> @ imm = #0x74
;         mov     r10, #0                 // start clean at cache level 0
700b0ba4: e3a0a000     	mov	r10, #0

700b0ba8 <wbaloop1>:
;         add     r2, r10, r10, lsr #1    // work out 3x current cache level
700b0ba8: e08a20aa     	add	r2, r10, r10, lsr #1
;         mov     r1, r0, lsr r2          // extract cache type bits from clidr
700b0bac: e1a01230     	lsr	r1, r0, r2
;         and     r1, r1, #7              // mask of bits for current cache only
700b0bb0: e2011007     	and	r1, r1, #7
;         cmp     r1, #2                  // see what cache we have at this level
700b0bb4: e3510002     	cmp	r1, #2
;         blt     wbaskip                 // skip if no cache, or just i-cache
700b0bb8: ba000014     	blt	0x700b0c10 <wbaskip>    @ imm = #0x50
;         mrs     r6, cpsr
700b0bbc: e10f6000     	mrs	r6, apsr
;         cpsid   i                       // disable interrupts
700b0bc0: f10c0080     	cpsid	i
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b0bc4: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         isb                             // flush prefetch buffer
700b0bc8: f57ff06f     	isb	sy
;         mrc     p15, #1, r1, c0, c0, #0 // read the new csidr
700b0bcc: ee301f10     	mrc	p15, #0x1, r1, c0, c0, #0x0
;         msr     cpsr_c, r6              // restore interrupts
700b0bd0: e121f006     	msr	CPSR_c, r6
;         and     r2, r1, #7              // extract the length of the cache lines
700b0bd4: e2012007     	and	r2, r1, #7
;         add     r2, r2, #4              // add 4 (line length offset)
700b0bd8: e2822004     	add	r2, r2, #4
;         mov     r4, #0x3ff
700b0bdc: e30043ff     	movw	r4, #0x3ff
;         ands    r4, r4, r1, lsr #3      // find maximum number on the way size
700b0be0: e01441a1     	ands	r4, r4, r1, lsr #3
;         clz     r5, r4                  // find bit position of way size inc.
700b0be4: e16f5f14     	clz	r5, r4
;         mov     r7, #0x7fff
700b0be8: e3077fff     	movw	r7, #0x7fff
;         ands    r7, r7, r1, lsr #13     // extract max number of the index size
700b0bec: e01776a1     	ands	r7, r7, r1, lsr #13

700b0bf0 <wbaloop2>:
;         mov     r9, r4                  // create working copy of max way size
700b0bf0: e1a09004     	mov	r9, r4

700b0bf4 <wbaloop3>:
;         orr     r11, r10, r9, lsl r5    // factor way and cache number into r11
700b0bf4: e18ab519     	orr	r11, r10, r9, lsl r5
;         orr     r11, r11, r7, lsl r2    // factor index number into r11
700b0bf8: e18bb217     	orr	r11, r11, r7, lsl r2
;         mcr     p15, #0, r11, c7, c10, #2 // clean line by set/way
700b0bfc: ee07bf5a     	mcr	p15, #0x0, r11, c7, c10, #0x2
;         subs    r9, r9, #1              // decrement the way
700b0c00: e2599001     	subs	r9, r9, #1
;         bge     wbaloop3
700b0c04: aafffffa     	bge	0x700b0bf4 <wbaloop3>   @ imm = #-0x18
;         subs    r7, r7, #1              // decrement the index
700b0c08: e2577001     	subs	r7, r7, #1
;         bge     wbaloop2
700b0c0c: aafffff7     	bge	0x700b0bf0 <wbaloop2>   @ imm = #-0x24

700b0c10 <wbaskip>:
;         add     r10, r10, #2            // increment cache number
700b0c10: e28aa002     	add	r10, r10, #2
;         cmp     r3, r10
700b0c14: e153000a     	cmp	r3, r10
;         bgt     wbaloop1
700b0c18: caffffe2     	bgt	0x700b0ba8 <wbaloop1>   @ imm = #-0x78

700b0c1c <wbafinished>:
;         mov     r10, #0                 // switch back to cache level 0
700b0c1c: e3a0a000     	mov	r10, #0
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b0c20: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         dsb
700b0c24: f57ff04f     	dsb	sy
;         isb                             // flush prefetch buffer
700b0c28: f57ff06f     	isb	sy
;         ldmfd   sp!, {r0-r7, r9-r11, lr}
700b0c2c: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700b0c30: e12fff1e     	bx	lr

700b0c34 <CacheP_wbInvAll>:
;         push    {r0-r7, r9-r11, lr}
700b0c34: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         movw    r0, :lower16:CacheP_wbInvAllAsm
700b0c38: e3000c4c     	movw	r0, #0xc4c
;         movt    r0, :upper16:CacheP_wbInvAllAsm
700b0c3c: e347000b     	movt	r0, #0x700b
;         blx     r0
700b0c40: e12fff30     	blx	r0
;         pop     {r0-r7, r9-r11, lr}
700b0c44: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700b0c48: e12fff1e     	bx	lr

700b0c4c <CacheP_wbInvAllAsm>:
;         dmb                             // Ensure all previous memory accesses
700b0c4c: f57ff05f     	dmb	sy
;         mrc     p15, #1, r0, c0, c0, #1 // read clidr
700b0c50: ee300f30     	mrc	p15, #0x1, r0, c0, c0, #0x1
;         ands    r3, r0, #0x7000000      // extract loc from clidr
700b0c54: e2103407     	ands	r3, r0, #117440512
;         mov     r3, r3, lsr #23         // left align loc bit field
700b0c58: e1a03ba3     	lsr	r3, r3, #23
;         beq     finished                // if loc is 0, then no need to clean
700b0c5c: 0a00001d     	beq	0x700b0cd8 <finished>   @ imm = #0x74
;         mov     r10, #0                 // start clean at cache level 0
700b0c60: e3a0a000     	mov	r10, #0

700b0c64 <loop1>:
;         add     r2, r10, r10, lsr #1    // work out 3x current cache level
700b0c64: e08a20aa     	add	r2, r10, r10, lsr #1
;         mov     r1, r0, lsr r2          // extract cache type bits from clidr
700b0c68: e1a01230     	lsr	r1, r0, r2
;         and     r1, r1, #7              // mask of bits for current cache only
700b0c6c: e2011007     	and	r1, r1, #7
;         cmp     r1, #2                  // see what cache we have at this level
700b0c70: e3510002     	cmp	r1, #2
;         blt     skip                    // skip if no cache, or just i-cache
700b0c74: ba000014     	blt	0x700b0ccc <skip>       @ imm = #0x50
;         mrs     r6, cpsr
700b0c78: e10f6000     	mrs	r6, apsr
;         cpsid   i                       // disable interrupts
700b0c7c: f10c0080     	cpsid	i
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b0c80: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         isb                             // flush prefetch buffer
700b0c84: f57ff06f     	isb	sy
;         mrc     p15, #1, r1, c0, c0, #0 // read the new csidr
700b0c88: ee301f10     	mrc	p15, #0x1, r1, c0, c0, #0x0
;         msr     cpsr_c, r6              // restore interrupts
700b0c8c: e121f006     	msr	CPSR_c, r6
;         and     r2, r1, #7              // extract the length of the cache lines
700b0c90: e2012007     	and	r2, r1, #7
;         add     r2, r2, #4              // add 4 (line length offset)
700b0c94: e2822004     	add	r2, r2, #4
;         mov     r4, #0x3ff
700b0c98: e30043ff     	movw	r4, #0x3ff
;         ands    r4, r4, r1, lsr #3      // find maximum number on the way size
700b0c9c: e01441a1     	ands	r4, r4, r1, lsr #3
;         clz     r5, r4                  // find bit position of way size inc.
700b0ca0: e16f5f14     	clz	r5, r4
;         mov     r7, #0x7fff
700b0ca4: e3077fff     	movw	r7, #0x7fff
;         ands    r7, r7, r1, lsr #13     // extract max number of the index size
700b0ca8: e01776a1     	ands	r7, r7, r1, lsr #13

700b0cac <loop2>:
;         mov     r9, r4                  // create working copy of max way size
700b0cac: e1a09004     	mov	r9, r4

700b0cb0 <loop3>:
;         orr     r11, r10, r9, lsl r5    // factor way and cache number into r11
700b0cb0: e18ab519     	orr	r11, r10, r9, lsl r5
;         orr     r11, r11, r7, lsl r2    // factor index number into r11
700b0cb4: e18bb217     	orr	r11, r11, r7, lsl r2
;         mcr     p15, #0, r11, c7, c14, #2 // clean & invalidate by set/way
700b0cb8: ee07bf5e     	mcr	p15, #0x0, r11, c7, c14, #0x2
;         subs    r9, r9, #1              // decrement the way
700b0cbc: e2599001     	subs	r9, r9, #1
;         bge     loop3
700b0cc0: aafffffa     	bge	0x700b0cb0 <loop3>      @ imm = #-0x18
;         subs    r7, r7, #1              // decrement the index
700b0cc4: e2577001     	subs	r7, r7, #1
;         bge     loop2
700b0cc8: aafffff7     	bge	0x700b0cac <loop2>      @ imm = #-0x24

700b0ccc <skip>:
;         add     r10, r10, #2            // increment cache number
700b0ccc: e28aa002     	add	r10, r10, #2
;         cmp     r3, r10
700b0cd0: e153000a     	cmp	r3, r10
;         bgt     loop1
700b0cd4: caffffe2     	bgt	0x700b0c64 <loop1>      @ imm = #-0x78

700b0cd8 <finished>:
;         mov     r10, #0                 // swith back to cache level 0
700b0cd8: e3a0a000     	mov	r10, #0
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b0cdc: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         dsb
700b0ce0: f57ff04f     	dsb	sy
;         isb                             // flush prefetch buffer
700b0ce4: f57ff06f     	isb	sy
;         bx      lr
700b0ce8: e12fff1e     	bx	lr

700b0cec <CacheP_getEnabled>:
;         mov     r0, #0
700b0cec: e3a00000     	mov	r0, #0
;         mrc     p15, #0, r1, c1, c0, #0 // fetch Control Register into r1
700b0cf0: ee111f10     	mrc	p15, #0x0, r1, c1, c0, #0x0
;         tst     r1, #0x1000             // test I bit (bit 12) for L1P
700b0cf4: e3110a01     	tst	r1, #4096
;         addne   r0, r0, #1              // if I is true, L1P is enabled
700b0cf8: 12800001     	addne	r0, r0, #1
;         tst     r1, #0x0004             // test C bit (bit 2) for L1D
700b0cfc: e3110004     	tst	r1, #4
;         addne   r0, r0, #2              // if C bit is true, L1D is enabled
700b0d00: 12800002     	addne	r0, r0, #2
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700b0d04: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         tst     r1, #0x0002             // test L2EN bit (bit 1) for L2EN
700b0d08: e3110002     	tst	r1, #2
;         beq     getEnabledDone
700b0d0c: 0a000003     	beq	0x700b0d20 <getEnabledDone> @ imm = #0xc
;         tst     r0, #0x0001
700b0d10: e3100001     	tst	r0, #1
;         addne   r0, r0, #4              // If L2EN and L1P then L2P
700b0d14: 12800004     	addne	r0, r0, #4
;         tst     r0, #0x0002
700b0d18: e3100002     	tst	r0, #2
;         addne   r0, r0, #8              // If L2EN and L1D then L2D
700b0d1c: 12800008     	addne	r0, r0, #8

700b0d20 <getEnabledDone>:
;         bx      lr
700b0d20: e12fff1e     	bx	lr

700b0d24 <CacheP_getCacheLevelInfo>:
;         mcr     p15, #2, r0, c0, c0, #0 // write to Cache Size Selection Reg
700b0d24: ee400f10     	mcr	p15, #0x2, r0, c0, c0, #0x0
;         mrc     p15, #1, r0, c0, c0, #0 // read Cache Size Id Reg
700b0d28: ee300f10     	mrc	p15, #0x1, r0, c0, c0, #0x0
;         bx      lr
700b0d2c: e12fff1e     	bx	lr

700b0d30 <CacheP_configForceWrThru>:
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700b0d30: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         cmp     r0, #0
700b0d34: e3500000     	cmp	r0, #0
;         beq     FWT_disable
700b0d38: 0a000001     	beq	0x700b0d44 <FWT_disable> @ imm = #0x4
;         orr     r1, r1, #(1 << 9)       // set (enable) force write-thru bit
700b0d3c: e3811c02     	orr	r1, r1, #512
;         b       FWT_exit
700b0d40: ea000000     	b	0x700b0d48 <FWT_exit>   @ imm = #0x0

700b0d44 <FWT_disable>:
;         bic     r1, r1, #(1 << 9)       // clear (disable) force write-thru bit
700b0d44: e3c11c02     	bic	r1, r1, #512

700b0d48 <FWT_exit>:
;         mcr     p15, #0, r1, c1, c0, #1 // write Auxiliary Ctrl Register
700b0d48: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         bx      lr
700b0d4c: e12fff1e     	bx	lr

700b0d50 <CacheP_setDLFO>:
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700b0d50: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         orr     r1, r1, #(1 << 13)      // set DLFO to disable LF optimization
700b0d54: e3811a02     	orr	r1, r1, #8192
;         mcr     p15, #0, r1, c1, c0, #1 // write Auxiliary Ctrl Register
700b0d58: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         bx      lr
700b0d5c: e12fff1e     	bx	lr

700b0d60 <CacheP_init>:
; {
700b0d60: b580         	push	{r7, lr}
700b0d62: b084         	sub	sp, #0x10
700b0d64: 2000         	movs	r0, #0x0
;     info = CacheP_getCacheLevelInfo(0);
700b0d66: f7ff efde    	blx	0x700b0d24 <CacheP_getCacheLevelInfo> @ imm = #-0x44
700b0d6a: 9003         	str	r0, [sp, #0xc]
;     DebugP_assertNoLog (gCacheL1dCacheLineSize == (4U << ((info & 0x7U) + 2U)));
700b0d6c: 9803         	ldr	r0, [sp, #0xc]
700b0d6e: f000 0007    	and	r0, r0, #0x7
700b0d72: 1c81         	adds	r1, r0, #0x2
700b0d74: 2004         	movs	r0, #0x4
700b0d76: 9001         	str	r0, [sp, #0x4]
700b0d78: 4088         	lsls	r0, r1
700b0d7a: 3820         	subs	r0, #0x20
700b0d7c: fab0 f080    	clz	r0, r0
700b0d80: 0940         	lsrs	r0, r0, #0x5
700b0d82: f000 faad    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x55a
700b0d86: 2001         	movs	r0, #0x1
;     info = CacheP_getCacheLevelInfo(1);
700b0d88: f7ff efcc    	blx	0x700b0d24 <CacheP_getCacheLevelInfo> @ imm = #-0x68
700b0d8c: 4601         	mov	r1, r0
700b0d8e: 9801         	ldr	r0, [sp, #0x4]
700b0d90: 9103         	str	r1, [sp, #0xc]
;     DebugP_assertNoLog (gCacheL1pCacheLineSize == (4U << ((info & 0x7U) + 2U)));
700b0d92: 9903         	ldr	r1, [sp, #0xc]
700b0d94: f001 0107    	and	r1, r1, #0x7
700b0d98: 3102         	adds	r1, #0x2
700b0d9a: 4088         	lsls	r0, r1
700b0d9c: 3820         	subs	r0, #0x20
700b0d9e: fab0 f080    	clz	r0, r0
700b0da2: 0940         	lsrs	r0, r0, #0x5
700b0da4: f000 fa9c    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x538
;     enabled = CacheP_getEnabled();
700b0da8: f7ff efa0    	blx	0x700b0cec <CacheP_getEnabled> @ imm = #-0xc0
700b0dac: 9002         	str	r0, [sp, #0x8]
;     if (enabled!=0U) {
700b0dae: 9802         	ldr	r0, [sp, #0x8]
700b0db0: b120         	cbz	r0, 0x700b0dbc <CacheP_init+0x5c> @ imm = #0x8
700b0db2: e7ff         	b	0x700b0db4 <CacheP_init+0x54> @ imm = #-0x2
700b0db4: 200f         	movs	r0, #0xf
;         CacheP_disable((uint32_t)CacheP_TYPE_ALL);
700b0db6: f000 f81b    	bl	0x700b0df0 <CacheP_disable> @ imm = #0x36
;     }
700b0dba: e7ff         	b	0x700b0dbc <CacheP_init+0x5c> @ imm = #-0x2
;     if (gCacheConfig.enable!=0U) {
700b0dbc: f641 0008    	movw	r0, #0x1808
700b0dc0: f2c7 000b    	movt	r0, #0x700b
700b0dc4: 6800         	ldr	r0, [r0]
700b0dc6: b158         	cbz	r0, 0x700b0de0 <CacheP_init+0x80> @ imm = #0x16
700b0dc8: e7ff         	b	0x700b0dca <CacheP_init+0x6a> @ imm = #-0x2
;          CacheP_configForceWrThru(gCacheConfig.enableForceWrThru);
700b0dca: f641 0008    	movw	r0, #0x1808
700b0dce: f2c7 000b    	movt	r0, #0x700b
700b0dd2: 6840         	ldr	r0, [r0, #0x4]
700b0dd4: f7ff efac    	blx	0x700b0d30 <CacheP_configForceWrThru> @ imm = #-0xa8
700b0dd8: 200f         	movs	r0, #0xf
;         CacheP_enable((uint32_t)CacheP_TYPE_ALL);
700b0dda: f000 f831    	bl	0x700b0e40 <CacheP_enable> @ imm = #0x62
;     }
700b0dde: e7ff         	b	0x700b0de0 <CacheP_init+0x80> @ imm = #-0x2
; }
700b0de0: b004         	add	sp, #0x10
700b0de2: bd80         	pop	{r7, pc}
700b0de4: bf00         	nop
700b0de6: bf00         	nop
700b0de8: bf00         	nop
700b0dea: bf00         	nop
700b0dec: bf00         	nop
700b0dee: bf00         	nop

700b0df0 <CacheP_disable>:
; {
700b0df0: b580         	push	{r7, lr}
700b0df2: b084         	sub	sp, #0x10
700b0df4: 9003         	str	r0, [sp, #0xc]
;     enabled = CacheP_getEnabled();
700b0df6: f7ff ef7a    	blx	0x700b0cec <CacheP_getEnabled> @ imm = #-0x10c
700b0dfa: 9002         	str	r0, [sp, #0x8]
;     if ((enabled & ((type) & ((uint32_t)CacheP_TYPE_L1D)))!=0U) {
700b0dfc: 9902         	ldr	r1, [sp, #0x8]
700b0dfe: 9803         	ldr	r0, [sp, #0xc]
700b0e00: 4008         	ands	r0, r1
700b0e02: 0780         	lsls	r0, r0, #0x1e
700b0e04: 2800         	cmp	r0, #0x0
700b0e06: d509         	bpl	0x700b0e1c <CacheP_disable+0x2c> @ imm = #0x12
700b0e08: e7ff         	b	0x700b0e0a <CacheP_disable+0x1a> @ imm = #-0x2
;         key = HwiP_disable();
700b0e0a: f7ff edaa    	blx	0x700b0960 <HwiP_disable> @ imm = #-0x4ac
700b0e0e: 9001         	str	r0, [sp, #0x4]
;         CacheP_disableL1d();             /* Disable L1D Cache */
700b0e10: f7ff ee06    	blx	0x700b0a20 <CacheP_disableL1d> @ imm = #-0x3f4
;         HwiP_restore(key);
700b0e14: 9801         	ldr	r0, [sp, #0x4]
700b0e16: f7ff edc4    	blx	0x700b09a0 <HwiP_restore> @ imm = #-0x478
;     }
700b0e1a: e7ff         	b	0x700b0e1c <CacheP_disable+0x2c> @ imm = #-0x2
;     if ((enabled & ((type) & ((uint32_t)CacheP_TYPE_L1P)))!=0U) {
700b0e1c: 9902         	ldr	r1, [sp, #0x8]
700b0e1e: 9803         	ldr	r0, [sp, #0xc]
700b0e20: 4008         	ands	r0, r1
700b0e22: 07c0         	lsls	r0, r0, #0x1f
700b0e24: b148         	cbz	r0, 0x700b0e3a <CacheP_disable+0x4a> @ imm = #0x12
700b0e26: e7ff         	b	0x700b0e28 <CacheP_disable+0x38> @ imm = #-0x2
;         key = HwiP_disable();
700b0e28: f7ff ed9a    	blx	0x700b0960 <HwiP_disable> @ imm = #-0x4cc
700b0e2c: 9001         	str	r0, [sp, #0x4]
;         CacheP_disableL1p();             /* Disable L1P Cache */
700b0e2e: f7ff ee0c    	blx	0x700b0a48 <CacheP_disableL1p> @ imm = #-0x3e8
;         HwiP_restore(key);
700b0e32: 9801         	ldr	r0, [sp, #0x4]
700b0e34: f7ff edb4    	blx	0x700b09a0 <HwiP_restore> @ imm = #-0x498
;     }
700b0e38: e7ff         	b	0x700b0e3a <CacheP_disable+0x4a> @ imm = #-0x2
; }
700b0e3a: b004         	add	sp, #0x10
700b0e3c: bd80         	pop	{r7, pc}
700b0e3e: bf00         	nop

700b0e40 <CacheP_enable>:
; {
700b0e40: b580         	push	{r7, lr}
700b0e42: b082         	sub	sp, #0x8
700b0e44: 9001         	str	r0, [sp, #0x4]
;     disabled = ~(CacheP_getEnabled());
700b0e46: f7ff ef52    	blx	0x700b0cec <CacheP_getEnabled> @ imm = #-0x15c
700b0e4a: 43c0         	mvns	r0, r0
700b0e4c: 9000         	str	r0, [sp]
;     if ((disabled & ((type) & ((uint32_t)CacheP_TYPE_L1D)))!=0U) {
700b0e4e: 9900         	ldr	r1, [sp]
700b0e50: 9801         	ldr	r0, [sp, #0x4]
700b0e52: 4008         	ands	r0, r1
700b0e54: 0780         	lsls	r0, r0, #0x1e
700b0e56: 2800         	cmp	r0, #0x0
700b0e58: d503         	bpl	0x700b0e62 <CacheP_enable+0x22> @ imm = #0x6
700b0e5a: e7ff         	b	0x700b0e5c <CacheP_enable+0x1c> @ imm = #-0x2
;         CacheP_enableL1d();              /* Enable L1D Cache */
700b0e5c: f7ff ee00    	blx	0x700b0a60 <CacheP_enableL1d> @ imm = #-0x400
;     }
700b0e60: e7ff         	b	0x700b0e62 <CacheP_enable+0x22> @ imm = #-0x2
;     if ((disabled & ((type) & ((uint32_t)CacheP_TYPE_L1P)))!=0U) {
700b0e62: 9900         	ldr	r1, [sp]
700b0e64: 9801         	ldr	r0, [sp, #0x4]
700b0e66: 4008         	ands	r0, r1
700b0e68: 07c0         	lsls	r0, r0, #0x1f
700b0e6a: b118         	cbz	r0, 0x700b0e74 <CacheP_enable+0x34> @ imm = #0x6
700b0e6c: e7ff         	b	0x700b0e6e <CacheP_enable+0x2e> @ imm = #-0x2
;         CacheP_enableL1p();              /* Enable L1P Cache */
700b0e6e: f7ff ee04    	blx	0x700b0a78 <CacheP_enableL1p> @ imm = #-0x3f8
;     }
700b0e72: e7ff         	b	0x700b0e74 <CacheP_enable+0x34> @ imm = #-0x2
; }
700b0e74: b002         	add	sp, #0x8
700b0e76: bd80         	pop	{r7, pc}
700b0e78: bf00         	nop
700b0e7a: bf00         	nop
700b0e7c: bf00         	nop
700b0e7e: bf00         	nop

700b0e80 <CacheP_inv>:
; {
700b0e80: b580         	push	{r7, lr}
700b0e82: b084         	sub	sp, #0x10
700b0e84: 9003         	str	r0, [sp, #0xc]
700b0e86: 9102         	str	r1, [sp, #0x8]
700b0e88: 9201         	str	r2, [sp, #0x4]
;     if (((type) & ((uint32_t)CacheP_TYPE_L1P))!=0U) {
700b0e8a: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700b0e8e: 07c0         	lsls	r0, r0, #0x1f
700b0e90: b128         	cbz	r0, 0x700b0e9e <CacheP_inv+0x1e> @ imm = #0xa
700b0e92: e7ff         	b	0x700b0e94 <CacheP_inv+0x14> @ imm = #-0x2
;         CacheP_invL1p((uint32_t)blockPtr, byteCnt);
700b0e94: 9803         	ldr	r0, [sp, #0xc]
700b0e96: 9902         	ldr	r1, [sp, #0x8]
700b0e98: f7ff ee16    	blx	0x700b0ac8 <CacheP_invL1p> @ imm = #-0x3d4
;     }
700b0e9c: e7ff         	b	0x700b0e9e <CacheP_inv+0x1e> @ imm = #-0x2
;     if (((type) & ((uint32_t)CacheP_TYPE_L1D))!=0U) {
700b0e9e: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700b0ea2: 0780         	lsls	r0, r0, #0x1e
700b0ea4: 2800         	cmp	r0, #0x0
700b0ea6: d505         	bpl	0x700b0eb4 <CacheP_inv+0x34> @ imm = #0xa
700b0ea8: e7ff         	b	0x700b0eaa <CacheP_inv+0x2a> @ imm = #-0x2
;         CacheP_invL1d((uint32_t)blockPtr, byteCnt);
700b0eaa: 9803         	ldr	r0, [sp, #0xc]
700b0eac: 9902         	ldr	r1, [sp, #0x8]
700b0eae: f7ff edf0    	blx	0x700b0a90 <CacheP_invL1d> @ imm = #-0x420
;     }
700b0eb2: e7ff         	b	0x700b0eb4 <CacheP_inv+0x34> @ imm = #-0x2
; }
700b0eb4: b004         	add	sp, #0x10
700b0eb6: bd80         	pop	{r7, pc}
		...

Disassembly of section .text.mpu:

700b0ec0 <MpuP_RegionAttrs_init>:
; {
700b0ec0: b081         	sub	sp, #0x4
700b0ec2: 9000         	str	r0, [sp]
;     region->isExecuteNever = 0;
700b0ec4: 9900         	ldr	r1, [sp]
700b0ec6: 2000         	movs	r0, #0x0
700b0ec8: 7108         	strb	r0, [r1, #0x4]
;     region->accessPerm     = (uint8_t)MpuP_AP_S_RW_U_R;
700b0eca: 9a00         	ldr	r2, [sp]
700b0ecc: 2102         	movs	r1, #0x2
700b0ece: 7191         	strb	r1, [r2, #0x6]
;     region->tex            = 0;
700b0ed0: 9900         	ldr	r1, [sp]
700b0ed2: 7148         	strb	r0, [r1, #0x5]
;     region->isSharable     = 1;
700b0ed4: 9a00         	ldr	r2, [sp]
700b0ed6: 2101         	movs	r1, #0x1
700b0ed8: 70d1         	strb	r1, [r2, #0x3]
;     region->isCacheable    = 0;
700b0eda: 9900         	ldr	r1, [sp]
700b0edc: 7048         	strb	r0, [r1, #0x1]
;     region->isBufferable   = 0;
700b0ede: 9900         	ldr	r1, [sp]
700b0ee0: 7088         	strb	r0, [r1, #0x2]
;     region->isEnable       = 0;
700b0ee2: 9900         	ldr	r1, [sp]
700b0ee4: 7008         	strb	r0, [r1]
;     region->subregionDisableMask = 0;
700b0ee6: 9900         	ldr	r1, [sp]
700b0ee8: 71c8         	strb	r0, [r1, #0x7]
; }
700b0eea: b001         	add	sp, #0x4
700b0eec: 4770         	bx	lr
700b0eee: bf00         	nop

700b0ef0 <MpuP_setRegion>:
; {
700b0ef0: b580         	push	{r7, lr}
700b0ef2: b08a         	sub	sp, #0x28
700b0ef4: 9009         	str	r0, [sp, #0x24]
700b0ef6: 9108         	str	r1, [sp, #0x20]
700b0ef8: 9207         	str	r2, [sp, #0x1c]
700b0efa: 9306         	str	r3, [sp, #0x18]
;     uint32_t value = size;
700b0efc: 9807         	ldr	r0, [sp, #0x1c]
700b0efe: 9000         	str	r0, [sp]
;     DebugP_assertNoLog( regionNum < MpuP_MAX_REGIONS);
700b0f00: 9909         	ldr	r1, [sp, #0x24]
700b0f02: 2000         	movs	r0, #0x0
700b0f04: 2910         	cmp	r1, #0x10
700b0f06: bf38         	it	lo
700b0f08: 2001         	movlo	r0, #0x1
700b0f0a: f000 f9e9    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x3d2
;     value = (value & (uint32_t)0x1F);
700b0f0e: 9800         	ldr	r0, [sp]
700b0f10: f000 001f    	and	r0, r0, #0x1f
700b0f14: 9000         	str	r0, [sp]
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700b0f16: 9806         	ldr	r0, [sp, #0x18]
;                   | ((uint32_t)(attrs->isEnable &  (uint32_t)0x1) << (uint32_t)0);
700b0f18: 7801         	ldrb	r1, [r0]
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700b0f1a: 79c0         	ldrb	r0, [r0, #0x7]
700b0f1c: 0200         	lsls	r0, r0, #0x8
;                   | ((uint32_t)(value            & (uint32_t)0x1F) << (uint32_t)1)
700b0f1e: 9a00         	ldr	r2, [sp]
700b0f20: f002 021f    	and	r2, r2, #0x1f
700b0f24: ea40 0042    	orr.w	r0, r0, r2, lsl #1
;                   | ((uint32_t)(attrs->isEnable &  (uint32_t)0x1) << (uint32_t)0);
700b0f28: f001 0101    	and	r1, r1, #0x1
700b0f2c: 4408         	add	r0, r1
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700b0f2e: 9004         	str	r0, [sp, #0x10]
;     baseAddress = ((uint32_t)addr & ~( (1U <<((uint64_t)value+1U))-1U ));
700b0f30: 9808         	ldr	r0, [sp, #0x20]
700b0f32: 9900         	ldr	r1, [sp]
700b0f34: 1c4a         	adds	r2, r1, #0x1
700b0f36: 2101         	movs	r1, #0x1
700b0f38: 4091         	lsls	r1, r2
700b0f3a: 4249         	rsbs	r1, r1, #0
700b0f3c: 4008         	ands	r0, r1
700b0f3e: 9005         	str	r0, [sp, #0x14]
;     regionAttrs = MpuP_getAttrs(attrs);
700b0f40: 9806         	ldr	r0, [sp, #0x18]
700b0f42: f000 f81d    	bl	0x700b0f80 <MpuP_getAttrs> @ imm = #0x3a
700b0f46: 9003         	str	r0, [sp, #0xc]
;     enabled = MpuP_isEnable();
700b0f48: f000 f84a    	bl	0x700b0fe0 <MpuP_isEnable> @ imm = #0x94
700b0f4c: 9002         	str	r0, [sp, #0x8]
;     MpuP_disable();
700b0f4e: f000 f84f    	bl	0x700b0ff0 <MpuP_disable> @ imm = #0x9e
;     key = HwiP_disable();
700b0f52: f7ff ed06    	blx	0x700b0960 <HwiP_disable> @ imm = #-0x5f4
700b0f56: 9001         	str	r0, [sp, #0x4]
;     MpuP_setRegionAsm(regionNum, baseAddress, sizeAndEnable, regionAttrs);
700b0f58: 9809         	ldr	r0, [sp, #0x24]
700b0f5a: 9905         	ldr	r1, [sp, #0x14]
700b0f5c: 9a04         	ldr	r2, [sp, #0x10]
700b0f5e: 9b03         	ldr	r3, [sp, #0xc]
700b0f60: f000 e90c    	blx	0x700b117c <MpuP_setRegionAsm> @ imm = #0x218
;     HwiP_restore(key);
700b0f64: 9801         	ldr	r0, [sp, #0x4]
700b0f66: f7ff ed1c    	blx	0x700b09a0 <HwiP_restore> @ imm = #-0x5c8
;     if (enabled != 0U) {
700b0f6a: 9802         	ldr	r0, [sp, #0x8]
700b0f6c: b118         	cbz	r0, 0x700b0f76 <MpuP_setRegion+0x86> @ imm = #0x6
700b0f6e: e7ff         	b	0x700b0f70 <MpuP_setRegion+0x80> @ imm = #-0x2
;         MpuP_enable();
700b0f70: f000 f85e    	bl	0x700b1030 <MpuP_enable> @ imm = #0xbc
;     }
700b0f74: e7ff         	b	0x700b0f76 <MpuP_setRegion+0x86> @ imm = #-0x2
; }
700b0f76: b00a         	add	sp, #0x28
700b0f78: bd80         	pop	{r7, pc}
700b0f7a: bf00         	nop
700b0f7c: bf00         	nop
700b0f7e: bf00         	nop

700b0f80 <MpuP_getAttrs>:
; {
700b0f80: b580         	push	{r7, lr}
700b0f82: b082         	sub	sp, #0x8
700b0f84: 9001         	str	r0, [sp, #0x4]
;           ((uint32_t)(region->isExecuteNever & (uint32_t)0x1) << (uint32_t)12)
700b0f86: f8dd c004    	ldr.w	r12, [sp, #0x4]
;         | ((uint32_t)(region->isCacheable    & (uint32_t)0x1) << (uint32_t)1)
700b0f8a: f89c 2001    	ldrb.w	r2, [r12, #0x1]
;         | ((uint32_t)(region->isBufferable   & (uint32_t)0x1) << (uint32_t)0);
700b0f8e: f89c 1002    	ldrb.w	r1, [r12, #0x2]
;         | ((uint32_t)(region->isSharable     & (uint32_t)0x1) << (uint32_t)2)
700b0f92: f89c 3003    	ldrb.w	r3, [r12, #0x3]
;           ((uint32_t)(region->isExecuteNever & (uint32_t)0x1) << (uint32_t)12)
700b0f96: f89c 0004    	ldrb.w	r0, [r12, #0x4]
700b0f9a: f000 0001    	and	r0, r0, #0x1
700b0f9e: 0300         	lsls	r0, r0, #0xc
;         | ((uint32_t)(region->accessPerm     & (uint32_t)0x7) << (uint32_t)8)
700b0fa0: f89c e006    	ldrb.w	lr, [r12, #0x6]
700b0fa4: f00e 0e07    	and	lr, lr, #0x7
700b0fa8: ea40 200e    	orr.w	r0, r0, lr, lsl #8
;         | ((uint32_t)(region->tex            & (uint32_t)0x7) << (uint32_t)3)
700b0fac: f89c c005    	ldrb.w	r12, [r12, #0x5]
700b0fb0: f00c 0c07    	and	r12, r12, #0x7
700b0fb4: ea40 00cc    	orr.w	r0, r0, r12, lsl #3
;         | ((uint32_t)(region->isSharable     & (uint32_t)0x1) << (uint32_t)2)
700b0fb8: f003 0301    	and	r3, r3, #0x1
700b0fbc: ea40 0083    	orr.w	r0, r0, r3, lsl #2
;         | ((uint32_t)(region->isCacheable    & (uint32_t)0x1) << (uint32_t)1)
700b0fc0: f002 0201    	and	r2, r2, #0x1
700b0fc4: ea40 0042    	orr.w	r0, r0, r2, lsl #1
;         | ((uint32_t)(region->isBufferable   & (uint32_t)0x1) << (uint32_t)0);
700b0fc8: f001 0101    	and	r1, r1, #0x1
700b0fcc: 4408         	add	r0, r1
;     uint32_t regionAttrs =
700b0fce: 9000         	str	r0, [sp]
;     return regionAttrs;
700b0fd0: 9800         	ldr	r0, [sp]
700b0fd2: b002         	add	sp, #0x8
700b0fd4: bd80         	pop	{r7, pc}
700b0fd6: bf00         	nop
700b0fd8: bf00         	nop
700b0fda: bf00         	nop
700b0fdc: bf00         	nop
700b0fde: bf00         	nop

700b0fe0 <MpuP_isEnable>:
; {
700b0fe0: b580         	push	{r7, lr}
;     return MpuP_isEnableAsm();
700b0fe2: f000 e8c2    	blx	0x700b1168 <MpuP_isEnableAsm> @ imm = #0x184
700b0fe6: bd80         	pop	{r7, pc}
700b0fe8: bf00         	nop
700b0fea: bf00         	nop
700b0fec: bf00         	nop
700b0fee: bf00         	nop

700b0ff0 <MpuP_disable>:
; {
700b0ff0: b580         	push	{r7, lr}
700b0ff2: b082         	sub	sp, #0x8
;     if(MpuP_isEnable()!=0U)
700b0ff4: f7ff fff4    	bl	0x700b0fe0 <MpuP_isEnable> @ imm = #-0x18
700b0ff8: b1a0         	cbz	r0, 0x700b1024 <MpuP_disable+0x34> @ imm = #0x28
700b0ffa: e7ff         	b	0x700b0ffc <MpuP_disable+0xc> @ imm = #-0x2
;         key = HwiP_disable();
700b0ffc: f7ff ecb0    	blx	0x700b0960 <HwiP_disable> @ imm = #-0x6a0
700b1000: 9000         	str	r0, [sp]
;         type = CacheP_getEnabled();
700b1002: f7ff ee74    	blx	0x700b0cec <CacheP_getEnabled> @ imm = #-0x318
700b1006: 9001         	str	r0, [sp, #0x4]
;         CacheP_disable(type);
700b1008: 9801         	ldr	r0, [sp, #0x4]
700b100a: f7ff fef1    	bl	0x700b0df0 <CacheP_disable> @ imm = #-0x21e
;         __asm__ __volatile__ (" dsb" "\n\t": : : "memory");
700b100e: f3bf 8f4f    	dsb	sy
;         MpuP_disableAsm();
700b1012: f000 e882    	blx	0x700b1118 <MpuP_disableAsm> @ imm = #0x104
;         CacheP_enable(type);
700b1016: 9801         	ldr	r0, [sp, #0x4]
700b1018: f7ff ff12    	bl	0x700b0e40 <CacheP_enable> @ imm = #-0x1dc
;         HwiP_restore(key);
700b101c: 9800         	ldr	r0, [sp]
700b101e: f7ff ecc0    	blx	0x700b09a0 <HwiP_restore> @ imm = #-0x680
;     }
700b1022: e7ff         	b	0x700b1024 <MpuP_disable+0x34> @ imm = #-0x2
; }
700b1024: b002         	add	sp, #0x8
700b1026: bd80         	pop	{r7, pc}
700b1028: bf00         	nop
700b102a: bf00         	nop
700b102c: bf00         	nop
700b102e: bf00         	nop

700b1030 <MpuP_enable>:
; {
700b1030: b580         	push	{r7, lr}
700b1032: b082         	sub	sp, #0x8
;     if(MpuP_isEnable()==(uint32_t) 0U)
700b1034: f7ff ffd4    	bl	0x700b0fe0 <MpuP_isEnable> @ imm = #-0x58
700b1038: b9e0         	cbnz	r0, 0x700b1074 <MpuP_enable+0x44> @ imm = #0x38
700b103a: e7ff         	b	0x700b103c <MpuP_enable+0xc> @ imm = #-0x2
;         key = HwiP_disable();
700b103c: f7ff ec90    	blx	0x700b0960 <HwiP_disable> @ imm = #-0x6e0
700b1040: 9000         	str	r0, [sp]
;         type = (uint32_t)CacheP_getEnabled();
700b1042: f7ff ee54    	blx	0x700b0cec <CacheP_getEnabled> @ imm = #-0x358
700b1046: 9001         	str	r0, [sp, #0x4]
;         if (type & CacheP_TYPE_L1) {
700b1048: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700b104c: 0780         	lsls	r0, r0, #0x1e
700b104e: b120         	cbz	r0, 0x700b105a <MpuP_enable+0x2a> @ imm = #0x8
700b1050: e7ff         	b	0x700b1052 <MpuP_enable+0x22> @ imm = #-0x2
700b1052: 2003         	movs	r0, #0x3
;             CacheP_disable(CacheP_TYPE_L1);
700b1054: f7ff fecc    	bl	0x700b0df0 <CacheP_disable> @ imm = #-0x268
;         }
700b1058: e7ff         	b	0x700b105a <MpuP_enable+0x2a> @ imm = #-0x2
;         MpuP_enableAsm();
700b105a: f000 e872    	blx	0x700b1140 <MpuP_enableAsm> @ imm = #0xe4
;         CacheP_enable(type);
700b105e: 9801         	ldr	r0, [sp, #0x4]
700b1060: f7ff feee    	bl	0x700b0e40 <CacheP_enable> @ imm = #-0x224
;         __asm__  __volatile__ (" dsb" "\n\t": : : "memory");
700b1064: f3bf 8f4f    	dsb	sy
;         __asm__  __volatile__ (" isb" "\n\t": : : "memory");
700b1068: f3bf 8f6f    	isb	sy
;         HwiP_restore(key);
700b106c: 9800         	ldr	r0, [sp]
700b106e: f7ff ec98    	blx	0x700b09a0 <HwiP_restore> @ imm = #-0x6d0
;     }
700b1072: e7ff         	b	0x700b1074 <MpuP_enable+0x44> @ imm = #-0x2
; }
700b1074: b002         	add	sp, #0x8
700b1076: bd80         	pop	{r7, pc}
700b1078: bf00         	nop
700b107a: bf00         	nop
700b107c: bf00         	nop
700b107e: bf00         	nop

700b1080 <MpuP_init>:
; {
700b1080: b580         	push	{r7, lr}
700b1082: b082         	sub	sp, #0x8
;     if (MpuP_isEnable()!=0U) {
700b1084: f7ff ffac    	bl	0x700b0fe0 <MpuP_isEnable> @ imm = #-0xa8
700b1088: b118         	cbz	r0, 0x700b1092 <MpuP_init+0x12> @ imm = #0x6
700b108a: e7ff         	b	0x700b108c <MpuP_init+0xc> @ imm = #-0x2
;         MpuP_disable();
700b108c: f7ff ffb0    	bl	0x700b0ff0 <MpuP_disable> @ imm = #-0xa0
;     }
700b1090: e7ff         	b	0x700b1092 <MpuP_init+0x12> @ imm = #-0x2
;     MpuP_disableBRAsm();
700b1092: f000 e84e    	blx	0x700b1130 <MpuP_disableBRAsm> @ imm = #0x9c
;     DebugP_assertNoLog( gMpuConfig.numRegions < MpuP_MAX_REGIONS);
700b1096: f641 0010    	movw	r0, #0x1810
700b109a: f2c7 000b    	movt	r0, #0x700b
700b109e: 6801         	ldr	r1, [r0]
700b10a0: 2000         	movs	r0, #0x0
700b10a2: 9000         	str	r0, [sp]
700b10a4: 2910         	cmp	r1, #0x10
700b10a6: bf38         	it	lo
700b10a8: 2001         	movlo	r0, #0x1
700b10aa: f000 f919    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x232
700b10ae: 9800         	ldr	r0, [sp]
;     for (i = 0; i < gMpuConfig.numRegions; i++)
700b10b0: 9001         	str	r0, [sp, #0x4]
700b10b2: e7ff         	b	0x700b10b4 <MpuP_init+0x34> @ imm = #-0x2
700b10b4: 9801         	ldr	r0, [sp, #0x4]
700b10b6: f641 0110    	movw	r1, #0x1810
700b10ba: f2c7 010b    	movt	r1, #0x700b
700b10be: 6809         	ldr	r1, [r1]
700b10c0: 4288         	cmp	r0, r1
700b10c2: d212         	bhs	0x700b10ea <MpuP_init+0x6a> @ imm = #0x24
700b10c4: e7ff         	b	0x700b10c6 <MpuP_init+0x46> @ imm = #-0x2
;         MpuP_setRegion(i,
700b10c6: 9801         	ldr	r0, [sp, #0x4]
;                 (void*)gMpuRegionConfig[i].baseAddr,
700b10c8: f641 011c    	movw	r1, #0x181c
700b10cc: f2c7 010b    	movt	r1, #0x700b
700b10d0: eb01 1300    	add.w	r3, r1, r0, lsl #4
700b10d4: 0102         	lsls	r2, r0, #0x4
700b10d6: 5889         	ldr	r1, [r1, r2]
;                 gMpuRegionConfig[i].size,
700b10d8: 685a         	ldr	r2, [r3, #0x4]
;                 &gMpuRegionConfig[i].attrs
700b10da: 3308         	adds	r3, #0x8
;         MpuP_setRegion(i,
700b10dc: f7ff ff08    	bl	0x700b0ef0 <MpuP_setRegion> @ imm = #-0x1f0
;     }
700b10e0: e7ff         	b	0x700b10e2 <MpuP_init+0x62> @ imm = #-0x2
;     for (i = 0; i < gMpuConfig.numRegions; i++)
700b10e2: 9801         	ldr	r0, [sp, #0x4]
700b10e4: 3001         	adds	r0, #0x1
700b10e6: 9001         	str	r0, [sp, #0x4]
700b10e8: e7e4         	b	0x700b10b4 <MpuP_init+0x34> @ imm = #-0x38
;     if (gMpuConfig.enableBackgroundRegion!=0U) {
700b10ea: f641 0010    	movw	r0, #0x1810
700b10ee: f2c7 000b    	movt	r0, #0x700b
700b10f2: 6840         	ldr	r0, [r0, #0x4]
700b10f4: b118         	cbz	r0, 0x700b10fe <MpuP_init+0x7e> @ imm = #0x6
700b10f6: e7ff         	b	0x700b10f8 <MpuP_init+0x78> @ imm = #-0x2
;         MpuP_enableBRAsm();
700b10f8: f000 e82e    	blx	0x700b1158 <MpuP_enableBRAsm> @ imm = #0x5c
;     }
700b10fc: e7ff         	b	0x700b10fe <MpuP_init+0x7e> @ imm = #-0x2
;     if (gMpuConfig.enableMpu!=0U) {
700b10fe: f641 0010    	movw	r0, #0x1810
700b1102: f2c7 000b    	movt	r0, #0x700b
700b1106: 6880         	ldr	r0, [r0, #0x8]
700b1108: b118         	cbz	r0, 0x700b1112 <MpuP_init+0x92> @ imm = #0x6
700b110a: e7ff         	b	0x700b110c <MpuP_init+0x8c> @ imm = #-0x2
;         MpuP_enable();
700b110c: f7ff ff90    	bl	0x700b1030 <MpuP_enable> @ imm = #-0xe0
;     }
700b1110: e7ff         	b	0x700b1112 <MpuP_init+0x92> @ imm = #-0x2
; }
700b1112: b002         	add	sp, #0x8
700b1114: bd80         	pop	{r7, pc}
700b1116: 0000         	movs	r0, r0

700b1118 <MpuP_disableAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b1118: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x1             // clear bit 0 in r0
700b111c: e3c00001     	bic	r0, r0, #1
;         dsb
700b1120: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0  // MPU disabled (bit 0 = 0)
700b1124: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb                              // flush instruction pipeline
700b1128: f57ff06f     	isb	sy
;         bx      LR
700b112c: e12fff1e     	bx	lr

700b1130 <MpuP_disableBRAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b1130: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x20000         // clear bit 17 in r0
700b1134: e3c00802     	bic	r0, r0, #131072
;         mcr     p15, #0, r0, c1, c0, #0  // disable background region
700b1138: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b113c: e12fff1e     	bx	lr

700b1140 <MpuP_enableAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b1140: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x1             // set bit 0 in r0
700b1144: e3800001     	orr	r0, r0, #1
;         dsb
700b1148: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0  // MPU enabled (bit 0 = 1)
700b114c: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb                              // flush instruction pipeline
700b1150: f57ff06f     	isb	sy
;         bx      LR
700b1154: e12fff1e     	bx	lr

700b1158 <MpuP_enableBRAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b1158: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x20000         // set bit 17 in r0
700b115c: e3800802     	orr	r0, r0, #131072
;         mcr     p15, #0, r0, c1, c0, #0  // background region enabled
700b1160: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b1164: e12fff1e     	bx	lr

700b1168 <MpuP_isEnableAsm>:
;         mov     r0, #0
700b1168: e3a00000     	mov	r0, #0
;         mrc     p15, #0, r1, c1, c0, #0  // read SCTLR register to r1
700b116c: ee111f10     	mrc	p15, #0x0, r1, c1, c0, #0x0
;         tst     r1, #0x1                 // test bit 0
700b1170: e3110001     	tst	r1, #1
;         movne   r0, #1                   // if not 0, MPU is enabled
700b1174: 13a00001     	movne	r0, #1
;         bx      LR
700b1178: e12fff1e     	bx	lr

700b117c <MpuP_setRegionAsm>:
;         mcr     p15, #0, r0, c6, c2, #0  // select MPU region
700b117c: ee060f12     	mcr	p15, #0x0, r0, c6, c2, #0x0
;         mcr     p15, #0, r1, c6, c1, #0  // set region base address
700b1180: ee061f11     	mcr	p15, #0x0, r1, c6, c1, #0x0
;         mcr     p15, #0, r2, c6, c1, #2  // set region size and enable it
700b1184: ee062f51     	mcr	p15, #0x0, r2, c6, c1, #0x2
;         mcr     p15, #0, r3, c6, c1, #4  // set protection attributes
700b1188: ee063f91     	mcr	p15, #0x0, r3, c6, c1, #0x4
;         bx      LR
700b118c: e12fff1e     	bx	lr

Disassembly of section .text.boot:

700b1190 <_c_int00_sbl>:
;         MRC     p15, #0, r1, c0, c0, #5
700b1190: ee101fb0     	mrc	p15, #0x0, r1, c0, c0, #0x5
;         BFC     r1, #8, #24
700b1194: e7df141f     	bfc	r1, #8, #24
;         CMP     r1, #0
700b1198: e3510000     	cmp	r1, #0
;         BNE     _sblLoopForever
700b119c: 1a000001     	bne	0x700b11a8 <_sblLoopForever> @ imm = #0x4
;         LDR     r1, _c_int00_addr
700b11a0: e59f1008     	ldr	r1, [pc, #0x8]          @ 0x700b11b0 <_c_int00_addr>
;         BLX     r1
700b11a4: e12fff31     	blx	r1

700b11a8 <_sblLoopForever>:
;         WFI
700b11a8: e320f003     	wfi
;         B       _sblLoopForever
700b11ac: eafffffd     	b	0x700b11a8 <_sblLoopForever> @ imm = #-0xc

700b11b0 <_c_int00_addr>:
700b11b0: b4 11 0b 70  	.word	0x700b11b4

700b11b4 <_c_int00>:
;         mrs     r0, cpsr
700b11b4: e10f0000     	mrs	r0, apsr
;         orr     r0, r0, #0xC0
700b11b8: e38000c0     	orr	r0, r0, #192
;         msr     cpsr_cf, r0
700b11bc: e129f000     	msr	CPSR_fc, r0
;         MRC      p15,#0x0,r0,c1,c0,#2
700b11c0: ee110f50     	mrc	p15, #0x0, r0, c1, c0, #0x2
;         MOV      r3,#0xf00000
700b11c4: e3a0360f     	mov	r3, #15728640
;         ORR      r0,r0,r3
700b11c8: e1800003     	orr	r0, r0, r3
;         MCR      p15,#0x0,r0,c1,c0,#2
700b11cc: ee010f50     	mcr	p15, #0x0, r0, c1, c0, #0x2
;         MOV      r0,#0x40000000
700b11d0: e3a00101     	mov	r0, #1073741824
;         FMXR     FPEXC,r0
700b11d4: eee80a10     	vmsr	fpexc, r0
;         MRS     r0, cpsr
700b11d8: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b11dc: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x11  // SET FIQ MODE
700b11e0: e3800011     	orr	r0, r0, #17
;         MSR     cpsr_cf, r0
700b11e4: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_FIQ_STACK_END
700b11e8: e59fd0d4     	ldr	sp, [pc, #0xd4]         @ 0x700b12c4 <c_FIQ_STACK_END>
;         MRS     r0, cpsr
700b11ec: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b11f0: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x12  // SET IRQ MODE
700b11f4: e3800012     	orr	r0, r0, #18
;         MSR     cpsr_cf, r0
700b11f8: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_IRQ_STACK_END
700b11fc: e59fd0bc     	ldr	sp, [pc, #0xbc]         @ 0x700b12c0 <c_IRQ_STACK_END>
;         MRS     r0, cpsr
700b1200: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b1204: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x13  // SET SVC MODE
700b1208: e3800013     	orr	r0, r0, #19
;         MSR     cpsr_cf, r0
700b120c: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_SVC_STACK_END
700b1210: e59fd0b0     	ldr	sp, [pc, #0xb0]         @ 0x700b12c8 <c_SVC_STACK_END>
;         MRS     r0, cpsr
700b1214: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b1218: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x17  // SET ABORT MODE
700b121c: e3800017     	orr	r0, r0, #23
;         MSR     cpsr_cf, r0
700b1220: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_ABORT_STACK_END
700b1224: e59fd0a0     	ldr	sp, [pc, #0xa0]         @ 0x700b12cc <c_ABORT_STACK_END>
;         MRS     r0, cpsr
700b1228: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b122c: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x1B  // SET ABORT MODE
700b1230: e380001b     	orr	r0, r0, #27
;         MSR     cpsr_cf, r0
700b1234: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_UNDEFINED_STACK_END
700b1238: e59fd090     	ldr	sp, [pc, #0x90]         @ 0x700b12d0 <c_UNDEFINED_STACK_END>
;         MRS     r0, cpsr
700b123c: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b1240: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x1F  // SET SYSTEM MODE
700b1244: e380001f     	orr	r0, r0, #31
;         MSR     cpsr_cf, r0
700b1248: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_STACK_END
700b124c: e59fd068     	ldr	sp, [pc, #0x68]         @ 0x700b12bc <c_STACK_END>
;         MRC p15, 0, r0, c1, c0, 0  // Read System Control Register
700b1250: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         BIC r0, r0, #0x1 << 2      // Disable data cache bit
700b1254: e3c00004     	bic	r0, r0, #4
;         BIC r0, r0, #0x1 << 12     // Disable instruction cache bit
700b1258: e3c00a01     	bic	r0, r0, #4096
;         DSB
700b125c: f57ff04f     	dsb	sy
;         MCR p15, 0, r0, c1, c0, 0  // Write System Control Register
700b1260: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         ISB                        // Ensures following instructions are not executed from cache
700b1264: f57ff06f     	isb	sy
;         MRC p15, 0, r1, c1, c0, 1  // Read Auxiliary Control Register
700b1268: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         ORR r1, r1, #(0x1 << 3)    //Enable ECC for Cache
700b126c: e3811008     	orr	r1, r1, #8
;         ORR r1,r1,#(0x1 << 5)
700b1270: e3811020     	orr	r1, r1, #32
;         MCR p15, 0, r1, c1, c0, 1  // Write Auxiliary Control Register
700b1274: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         MCR p15, 0, r0, c15, c5, 0 // Invalidate entire data cache
700b1278: ee0f0f15     	mcr	p15, #0x0, r0, c15, c5, #0x0
;         MCR p15, 0, r0, c7, c5, 0  // Invalidate entire instruction cache
700b127c: ee070f15     	mcr	p15, #0x0, r0, c7, c5, #0x0
;         MRC p15, 0, r0, c1, c0, 0  // Read System Control Register
700b1280: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         ORR r0, r0, #0x1 << 2      // Enable data cache bit
700b1284: e3800004     	orr	r0, r0, #4
;         ORR r0, r0, #0x1 << 12     // Enable instruction cache bit
700b1288: e3800a01     	orr	r0, r0, #4096
;         DSB
700b128c: f57ff04f     	dsb	sy
;         MCR p15, 0, r0, c1, c0, 0  // Write System Control Register
700b1290: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         ISB
700b1294: f57ff06f     	isb	sy
;         BL      __mpu_init
700b1298: fa000028     	blx	0x700b1340 <__mpu_init> @ imm = #0xa0
;         BL      _system_pre_init
700b129c: fa00001b     	blx	0x700b1310 <_system_pre_init> @ imm = #0x6c
;         CMP     R0, #0
700b12a0: e3500000     	cmp	r0, #0
;         BEQ     bypass_auto_init
700b12a4: 0a000000     	beq	0x700b12ac <bypass_auto_init> @ imm = #0x0
;         BL      __TI_auto_init
700b12a8: ebffee3a     	bl	0x700acb98 <__TI_auto_init_nobinit_nopinit> @ imm = #-0x4718

700b12ac <bypass_auto_init>:
;         BL      main
700b12ac: fafffab7     	blx	0x700afd90 <main>       @ imm = #-0x1524
;         MOV     R0, #1
700b12b0: e3a00001     	mov	r0, #1
;         BL      exit
700b12b4: eb000025     	bl	0x700b1350 <abort>      @ imm = #0x94

700b12b8 <L1>:
; L1:     B       L1
700b12b8: eafffffe     	b	0x700b12b8 <L1>         @ imm = #-0x8

700b12bc <c_STACK_END>:
700b12bc: 00 93 09 70  	.word	0x70099300

700b12c0 <c_IRQ_STACK_END>:
700b12c0: 70 2b 0b 70  	.word	0x700b2b70

700b12c4 <c_FIQ_STACK_END>:
700b12c4: 70 2c 0b 70  	.word	0x700b2c70

700b12c8 <c_SVC_STACK_END>:
700b12c8: 70 3c 0b 70  	.word	0x700b3c70

700b12cc <c_ABORT_STACK_END>:
700b12cc: 70 3d 0b 70  	.word	0x700b3d70

700b12d0 <c_UNDEFINED_STACK_END>:
700b12d0: 70 3e 0b 70  	.word	0x700b3e70
700b12d4: 00 00 00 00  	.word	0x00000000
700b12d8: 00 00 00 00  	.word	0x00000000
700b12dc: 00 00 00 00  	.word	0x00000000

700b12e0 <_DebugP_assertNoLog>:
; {
700b12e0: b580         	push	{r7, lr}
700b12e2: b082         	sub	sp, #0x8
700b12e4: 9001         	str	r0, [sp, #0x4]
;     if(expression==0)
700b12e6: 9801         	ldr	r0, [sp, #0x4]
700b12e8: b950         	cbnz	r0, 0x700b1300 <_DebugP_assertNoLog+0x20> @ imm = #0x14
700b12ea: e7ff         	b	0x700b12ec <_DebugP_assertNoLog+0xc> @ imm = #-0x2
700b12ec: 2001         	movs	r0, #0x1
;         volatile uint32_t assert_loop = 1;
700b12ee: 9000         	str	r0, [sp]
;         (void) HwiP_disable();
700b12f0: f7ff eb36    	blx	0x700b0960 <HwiP_disable> @ imm = #-0x994
;         while(assert_loop!= 0U)
700b12f4: e7ff         	b	0x700b12f6 <_DebugP_assertNoLog+0x16> @ imm = #-0x2
700b12f6: 9800         	ldr	r0, [sp]
700b12f8: b108         	cbz	r0, 0x700b12fe <_DebugP_assertNoLog+0x1e> @ imm = #0x2
700b12fa: e7ff         	b	0x700b12fc <_DebugP_assertNoLog+0x1c> @ imm = #-0x2
700b12fc: e7fb         	b	0x700b12f6 <_DebugP_assertNoLog+0x16> @ imm = #-0xa
;     }
700b12fe: e7ff         	b	0x700b1300 <_DebugP_assertNoLog+0x20> @ imm = #-0x2
; }
700b1300: b002         	add	sp, #0x8
700b1302: bd80         	pop	{r7, pc}
		...

700b1310 <_system_pre_init>:
; {
700b1310: b580         	push	{r7, lr}
700b1312: b082         	sub	sp, #0x8
;     uint32_t bss_size = ((uintptr_t)&__BSS_END - (uintptr_t)&__BSS_START);
700b1314: f240 0000    	movw	r0, #0x0
700b1318: f2c7 0008    	movt	r0, #0x7008
700b131c: f245 3100    	movw	r1, #0x5300
700b1320: f2c7 0108    	movt	r1, #0x7008
700b1324: 1a09         	subs	r1, r1, r0
700b1326: 9101         	str	r1, [sp, #0x4]
;     (void) memset((void*)&__BSS_START, 0x00, bss_size);
700b1328: 9901         	ldr	r1, [sp, #0x4]
700b132a: f7e9 eef4    	blx	0x7009b114 <__aeabi_memclr8> @ imm = #-0x16218
700b132e: 2001         	movs	r0, #0x1
;     return 1;
700b1330: b002         	add	sp, #0x8
700b1332: bd80         	pop	{r7, pc}
		...

700b1340 <__mpu_init>:
; {
700b1340: b580         	push	{r7, lr}
;     MpuP_init();
700b1342: f7ff fe9d    	bl	0x700b1080 <MpuP_init>  @ imm = #-0x2c6
;     CacheP_init();
700b1346: e8bd 4080    	pop.w	{r7, lr}
700b134a: f7ff bd09    	b.w	0x700b0d60 <CacheP_init> @ imm = #-0x5ee
700b134e: 0000         	movs	r0, r0

Disassembly of section .text:abort:

700b1350 <abort>:
700b1350: e320f000     	nop
700b1354: eafffffe     	b	0x700b1354 <abort+0x4>  @ imm = #-0x8

Disassembly of section .text:

70099300 <__TI_printfi_nofloat>:
70099300: e92d4ff0     	push	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
70099304: e24ddf89     	sub	sp, sp, #548
70099308: e5907000     	ldr	r7, [r0]
7009930c: e1a08000     	mov	r8, r0
70099310: e1a05003     	mov	r5, r3
70099314: e1a06002     	mov	r6, r2
70099318: e58d1220     	str	r1, [sp, #0x220]
7009931c: e1a00007     	mov	r0, r7
70099320: eb0058a9     	bl	0x700af5cc <strlen>     @ imm = #0x162a4
70099324: e0879000     	add	r9, r7, r0
70099328: e3a0a000     	mov	r10, #0
7009932c: e28dbf83     	add	r11, sp, #524
70099330: e3a04000     	mov	r4, #0
70099334: e3e00000     	mvn	r0, #0
70099338: e58da21c     	str	r10, [sp, #0x21c]
7009933c: e1570009     	cmp	r7, r9
70099340: 2a0000a4     	bhs	0x700995d8 <__TI_printfi_nofloat+0x2d8> @ imm = #0x290
70099344: e2877001     	add	r7, r7, #1
70099348: e58da20c     	str	r10, [sp, #0x20c]
7009934c: e5cda218     	strb	r10, [sp, #0x218]
70099350: e58da210     	str	r10, [sp, #0x210]
70099354: e58d0214     	str	r0, [sp, #0x214]
70099358: e5570001     	ldrb	r0, [r7, #-0x1]
7009935c: e3500000     	cmp	r0, #0
70099360: 0a00009c     	beq	0x700995d8 <__TI_printfi_nofloat+0x2d8> @ imm = #0x270
70099364: e3500025     	cmp	r0, #37
70099368: 0a000005     	beq	0x70099384 <__TI_printfi_nofloat+0x84> @ imm = #0x14
7009936c: e1a01006     	mov	r1, r6
70099370: e5887000     	str	r7, [r8]
70099374: e12fff35     	blx	r5
70099378: e2844001     	add	r4, r4, #1
7009937c: e2877001     	add	r7, r7, #1
70099380: eafffff4     	b	0x70099358 <__TI_printfi_nofloat+0x58> @ imm = #-0x30
70099384: e1a0000b     	mov	r0, r11
70099388: e1a01008     	mov	r1, r8
7009938c: e58d421c     	str	r4, [sp, #0x21c]
70099390: e5887000     	str	r7, [r8]
70099394: eb000092     	bl	0x700995e4 <pproc_fflags___TI_printfi_nofloat> @ imm = #0x248
70099398: e1a0000b     	mov	r0, r11
7009939c: e1a01008     	mov	r1, r8
700993a0: e28d2e22     	add	r2, sp, #544
700993a4: eb0000a8     	bl	0x7009964c <_pproc_fwp___TI_printfi_nofloat> @ imm = #0x2a0
700993a8: e5980000     	ldr	r0, [r8]
700993ac: e5d02000     	ldrb	r2, [r0]
700993b0: e2421068     	sub	r1, r2, #104
700993b4: e1a010e1     	ror	r1, r1, #1
700993b8: e3510009     	cmp	r1, #9
700993bc: 8a000026     	bhi	0x7009945c <__TI_printfi_nofloat+0x15c> @ imm = #0x98
700993c0: e28f3000     	add	r3, pc, #0
700993c4: e793f101     	ldr	pc, [r3, r1, lsl #2]
700993c8: f0 93 09 70  	.word	0x700993f0
700993cc: 0c 94 09 70  	.word	0x7009940c
700993d0: 18 94 09 70  	.word	0x70099418
700993d4: 5c 94 09 70  	.word	0x7009945c
700993d8: 5c 94 09 70  	.word	0x7009945c
700993dc: 5c 94 09 70  	.word	0x7009945c
700993e0: 38 94 09 70  	.word	0x70099438
700993e4: 5c 94 09 70  	.word	0x7009945c
700993e8: 5c 94 09 70  	.word	0x7009945c
700993ec: 44 94 09 70  	.word	0x70099444
700993f0: e1a01000     	mov	r1, r0
700993f4: e59d220c     	ldr	r2, [sp, #0x20c]
700993f8: e5f13001     	ldrb	r3, [r1, #0x1]!
700993fc: e3530068     	cmp	r3, #104
70099400: 1a00005b     	bne	0x70099574 <__TI_printfi_nofloat+0x274> @ imm = #0x16c
70099404: e3822c02     	orr	r2, r2, #512
70099408: ea000008     	b	0x70099430 <__TI_printfi_nofloat+0x130> @ imm = #0x20
7009940c: e59d120c     	ldr	r1, [sp, #0x20c]
70099410: e3812b02     	orr	r2, r1, #2048
70099414: ea00000c     	b	0x7009944c <__TI_printfi_nofloat+0x14c> @ imm = #0x30
70099418: e1a01000     	mov	r1, r0
7009941c: e59d220c     	ldr	r2, [sp, #0x20c]
70099420: e5f13001     	ldrb	r3, [r1, #0x1]!
70099424: e353006c     	cmp	r3, #108
70099428: 1a000053     	bne	0x7009957c <__TI_printfi_nofloat+0x27c> @ imm = #0x14c
7009942c: e3822c01     	orr	r2, r2, #256
70099430: e2801002     	add	r1, r0, #2
70099434: ea000005     	b	0x70099450 <__TI_printfi_nofloat+0x150> @ imm = #0x14
70099438: e59d120c     	ldr	r1, [sp, #0x20c]
7009943c: e3812a02     	orr	r2, r1, #8192
70099440: ea000001     	b	0x7009944c <__TI_printfi_nofloat+0x14c> @ imm = #0x4
70099444: e59d120c     	ldr	r1, [sp, #0x20c]
70099448: e3812a01     	orr	r2, r1, #4096
7009944c: e2801001     	add	r1, r0, #1
70099450: e58d220c     	str	r2, [sp, #0x20c]
70099454: e5d12000     	ldrb	r2, [r1]
70099458: e1a00001     	mov	r0, r1
7009945c: e2807001     	add	r7, r0, #1
70099460: e5cd2218     	strb	r2, [sp, #0x218]
70099464: e3520073     	cmp	r2, #115
70099468: e5887000     	str	r7, [r8]
7009946c: 0a00001a     	beq	0x700994dc <__TI_printfi_nofloat+0x1dc> @ imm = #0x68
70099470: e352006e     	cmp	r2, #110
70099474: 1a000022     	bne	0x70099504 <__TI_printfi_nofloat+0x204> @ imm = #0x88
70099478: e59d020c     	ldr	r0, [sp, #0x20c]
7009947c: e3031f60     	movw	r1, #0x3f60
70099480: e0000001     	and	r0, r0, r1
70099484: e3500020     	cmp	r0, #32
70099488: 0a00003e     	beq	0x70099588 <__TI_printfi_nofloat+0x288> @ imm = #0xf8
7009948c: e3500040     	cmp	r0, #64
70099490: 0a000041     	beq	0x7009959c <__TI_printfi_nofloat+0x29c> @ imm = #0x104
70099494: e3a0a000     	mov	r10, #0
70099498: e3500a02     	cmp	r0, #8192
7009949c: 0a00002f     	beq	0x70099560 <__TI_printfi_nofloat+0x260> @ imm = #0xbc
700994a0: e3500c02     	cmp	r0, #512
700994a4: 0a000042     	beq	0x700995b4 <__TI_printfi_nofloat+0x2b4> @ imm = #0x108
700994a8: e3500b02     	cmp	r0, #2048
700994ac: 0a000003     	beq	0x700994c0 <__TI_printfi_nofloat+0x1c0> @ imm = #0xc
700994b0: e3500a01     	cmp	r0, #4096
700994b4: 0a000029     	beq	0x70099560 <__TI_printfi_nofloat+0x260> @ imm = #0xa4
700994b8: e3500c01     	cmp	r0, #256
700994bc: 1a000027     	bne	0x70099560 <__TI_printfi_nofloat+0x260> @ imm = #0x9c
700994c0: e59d0220     	ldr	r0, [sp, #0x220]
700994c4: e1a03fc4     	asr	r3, r4, #31
700994c8: e4901004     	ldr	r1, [r0], #4
700994cc: e58d0220     	str	r0, [sp, #0x220]
700994d0: e5814000     	str	r4, [r1]
700994d4: e5813004     	str	r3, [r1, #0x4]
700994d8: ea000039     	b	0x700995c4 <__TI_printfi_nofloat+0x2c4> @ imm = #0xe4
700994dc: e5dd020c     	ldrb	r0, [sp, #0x20c]
700994e0: e3100040     	tst	r0, #64
700994e4: 1a000016     	bne	0x70099544 <__TI_printfi_nofloat+0x244> @ imm = #0x58
700994e8: e1a0000b     	mov	r0, r11
700994ec: e1a01006     	mov	r1, r6
700994f0: e28d2e22     	add	r2, sp, #544
700994f4: e28d3f87     	add	r3, sp, #540
700994f8: e58d5000     	str	r5, [sp]
700994fc: eb0000f9     	bl	0x700998e8 <_pproc_str___TI_printfi_nofloat> @ imm = #0x3e4
70099500: ea00002f     	b	0x700995c4 <__TI_printfi_nofloat+0x2c4> @ imm = #0xbc
70099504: e28da00e     	add	r10, sp, #14
70099508: e1a0100b     	mov	r1, r11
7009950c: e28d2e22     	add	r2, sp, #544
70099510: e1a0000a     	mov	r0, r10
70099514: eb000138     	bl	0x700999fc <_setfield___TI_printfi_nofloat> @ imm = #0x4e0
70099518: e59d3248     	ldr	r3, [sp, #0x248]
7009951c: e1a02000     	mov	r2, r0
70099520: e1a0000a     	mov	r0, r10
70099524: e1a01006     	mov	r1, r6
70099528: e12fff33     	blx	r3
7009952c: e3700001     	cmn	r0, #1
70099530: 10800004     	addne	r0, r0, r4
70099534: e3a0a000     	mov	r10, #0
70099538: e1a04000     	mov	r4, r0
7009953c: e58d021c     	str	r0, [sp, #0x21c]
70099540: ea000020     	b	0x700995c8 <__TI_printfi_nofloat+0x2c8> @ imm = #0x80
70099544: e1a0000b     	mov	r0, r11
70099548: e1a01006     	mov	r1, r6
7009954c: e28d2e22     	add	r2, sp, #544
70099550: e28d3f87     	add	r3, sp, #540
70099554: e58d5000     	str	r5, [sp]
70099558: eb000092     	bl	0x700997a8 <_pproc_wstr___TI_printfi_nofloat> @ imm = #0x248
7009955c: ea000018     	b	0x700995c4 <__TI_printfi_nofloat+0x2c4> @ imm = #0x60
70099560: e59d0220     	ldr	r0, [sp, #0x220]
70099564: e4901004     	ldr	r1, [r0], #4
70099568: e58d0220     	str	r0, [sp, #0x220]
7009956c: e5814000     	str	r4, [r1]
70099570: ea000013     	b	0x700995c4 <__TI_printfi_nofloat+0x2c4> @ imm = #0x4c
70099574: e3820020     	orr	r0, r2, #32
70099578: ea000000     	b	0x70099580 <__TI_printfi_nofloat+0x280> @ imm = #0x0
7009957c: e3820040     	orr	r0, r2, #64
70099580: e58d020c     	str	r0, [sp, #0x20c]
70099584: eaffffb2     	b	0x70099454 <__TI_printfi_nofloat+0x154> @ imm = #-0x138
70099588: e59d0220     	ldr	r0, [sp, #0x220]
7009958c: e4901004     	ldr	r1, [r0], #4
70099590: e58d0220     	str	r0, [sp, #0x220]
70099594: e1c140b0     	strh	r4, [r1]
70099598: ea000003     	b	0x700995ac <__TI_printfi_nofloat+0x2ac> @ imm = #0xc
7009959c: e59d0220     	ldr	r0, [sp, #0x220]
700995a0: e4901004     	ldr	r1, [r0], #4
700995a4: e58d0220     	str	r0, [sp, #0x220]
700995a8: e5814000     	str	r4, [r1]
700995ac: e3a0a000     	mov	r10, #0
700995b0: ea000003     	b	0x700995c4 <__TI_printfi_nofloat+0x2c4> @ imm = #0xc
700995b4: e59d0220     	ldr	r0, [sp, #0x220]
700995b8: e4901004     	ldr	r1, [r0], #4
700995bc: e58d0220     	str	r0, [sp, #0x220]
700995c0: e5c14000     	strb	r4, [r1]
700995c4: e59d421c     	ldr	r4, [sp, #0x21c]
700995c8: e3e00000     	mvn	r0, #0
700995cc: e3740001     	cmn	r4, #1
700995d0: 1affff59     	bne	0x7009933c <__TI_printfi_nofloat+0x3c> @ imm = #-0x29c
700995d4: e3e04000     	mvn	r4, #0
700995d8: e1a00004     	mov	r0, r4
700995dc: e28ddf89     	add	sp, sp, #548
700995e0: e8bd8ff0     	pop	{r4, r5, r6, r7, r8, r9, r10, r11, pc}

700995e4 <pproc_fflags___TI_printfi_nofloat>:
700995e4: e591c000     	ldr	r12, [r1]
700995e8: e5dc3000     	ldrb	r3, [r12]
700995ec: e3530020     	cmp	r3, #32
700995f0: 0a00000a     	beq	0x70099620 <pproc_fflags___TI_printfi_nofloat+0x3c> @ imm = #0x28
700995f4: e3530023     	cmp	r3, #35
700995f8: 0a00000a     	beq	0x70099628 <pproc_fflags___TI_printfi_nofloat+0x44> @ imm = #0x28
700995fc: e3530030     	cmp	r3, #48
70099600: 0a00000a     	beq	0x70099630 <pproc_fflags___TI_printfi_nofloat+0x4c> @ imm = #0x28
70099604: e3a02001     	mov	r2, #1
70099608: e353002d     	cmp	r3, #45
7009960c: 0a000008     	beq	0x70099634 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x20
70099610: e353002b     	cmp	r3, #43
70099614: 112fff1e     	bxne	lr
70099618: e3a02002     	mov	r2, #2
7009961c: ea000004     	b	0x70099634 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x10
70099620: e3a02004     	mov	r2, #4
70099624: ea000002     	b	0x70099634 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x8
70099628: e3a02008     	mov	r2, #8
7009962c: ea000000     	b	0x70099634 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x0
70099630: e3a02010     	mov	r2, #16
70099634: e5903000     	ldr	r3, [r0]
70099638: e1832002     	orr	r2, r3, r2
7009963c: e28c3001     	add	r3, r12, #1
70099640: e5802000     	str	r2, [r0]
70099644: e5813000     	str	r3, [r1]
70099648: eaffffe5     	b	0x700995e4 <pproc_fflags___TI_printfi_nofloat> @ imm = #-0x6c

7009964c <_pproc_fwp___TI_printfi_nofloat>:
7009964c: e92d48ff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r11, lr}
70099650: e1a05001     	mov	r5, r1
70099654: e5911000     	ldr	r1, [r1]
70099658: e1a06002     	mov	r6, r2
7009965c: e1a04000     	mov	r4, r0
70099660: e5d13000     	ldrb	r3, [r1]
70099664: e353002a     	cmp	r3, #42
70099668: 1a00000f     	bne	0x700996ac <_pproc_fwp___TI_printfi_nofloat+0x60> @ imm = #0x3c
7009966c: e5960000     	ldr	r0, [r6]
70099670: e2801004     	add	r1, r0, #4
70099674: e5861000     	str	r1, [r6]
70099678: e5900000     	ldr	r0, [r0]
7009967c: e3700001     	cmn	r0, #1
70099680: e5840004     	str	r0, [r4, #0x4]
70099684: ca000004     	bgt	0x7009969c <_pproc_fwp___TI_printfi_nofloat+0x50> @ imm = #0x10
70099688: e5941000     	ldr	r1, [r4]
7009968c: e2600000     	rsb	r0, r0, #0
70099690: e3811001     	orr	r1, r1, #1
70099694: e5840004     	str	r0, [r4, #0x4]
70099698: e5841000     	str	r1, [r4]
7009969c: e5950000     	ldr	r0, [r5]
700996a0: e2807001     	add	r7, r0, #1
700996a4: e5857000     	str	r7, [r5]
700996a8: ea000015     	b	0x70099704 <_pproc_fwp___TI_printfi_nofloat+0xb8> @ imm = #0x54
700996ac: e3a00000     	mov	r0, #0
700996b0: e28d2006     	add	r2, sp, #6
700996b4: e2433030     	sub	r3, r3, #48
700996b8: e3530009     	cmp	r3, #9
700996bc: 8a000007     	bhi	0x700996e0 <_pproc_fwp___TI_printfi_nofloat+0x94> @ imm = #0x1c
700996c0: e0813000     	add	r3, r1, r0
700996c4: e2837001     	add	r7, r3, #1
700996c8: e5857000     	str	r7, [r5]
700996cc: e7d17000     	ldrb	r7, [r1, r0]
700996d0: e5d33001     	ldrb	r3, [r3, #0x1]
700996d4: e7c27000     	strb	r7, [r2, r0]
700996d8: e2800001     	add	r0, r0, #1
700996dc: eafffff4     	b	0x700996b4 <_pproc_fwp___TI_printfi_nofloat+0x68> @ imm = #-0x30
700996e0: e3a03000     	mov	r3, #0
700996e4: e0817000     	add	r7, r1, r0
700996e8: e7c23000     	strb	r3, [r2, r0]
700996ec: e5dd2006     	ldrb	r2, [sp, #0x6]
700996f0: e3520000     	cmp	r2, #0
700996f4: 0a000002     	beq	0x70099704 <_pproc_fwp___TI_printfi_nofloat+0xb8> @ imm = #0x8
700996f8: e28d0006     	add	r0, sp, #6
700996fc: eb004806     	bl	0x700ab71c <atoi>       @ imm = #0x12018
70099700: e5840004     	str	r0, [r4, #0x4]
70099704: e5d70000     	ldrb	r0, [r7]
70099708: e350002e     	cmp	r0, #46
7009970c: 18bd88ff     	popne	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}
70099710: e2870001     	add	r0, r7, #1
70099714: e5850000     	str	r0, [r5]
70099718: e5d72001     	ldrb	r2, [r7, #0x1]
7009971c: e352002a     	cmp	r2, #42
70099720: 1a000008     	bne	0x70099748 <_pproc_fwp___TI_printfi_nofloat+0xfc> @ imm = #0x20
70099724: e5960000     	ldr	r0, [r6]
70099728: e2801004     	add	r1, r0, #4
7009972c: e5861000     	str	r1, [r6]
70099730: e5951000     	ldr	r1, [r5]
70099734: e5900000     	ldr	r0, [r0]
70099738: e2811001     	add	r1, r1, #1
7009973c: e5840008     	str	r0, [r4, #0x8]
70099740: e5851000     	str	r1, [r5]
70099744: e8bd88ff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}
70099748: e3a00000     	mov	r0, #0
7009974c: e28d1006     	add	r1, sp, #6
70099750: e2422030     	sub	r2, r2, #48
70099754: e3520009     	cmp	r2, #9
70099758: 8a000007     	bhi	0x7009977c <_pproc_fwp___TI_printfi_nofloat+0x130> @ imm = #0x1c
7009975c: e0872000     	add	r2, r7, r0
70099760: e2823002     	add	r3, r2, #2
70099764: e5853000     	str	r3, [r5]
70099768: e5d23001     	ldrb	r3, [r2, #0x1]
7009976c: e5d22002     	ldrb	r2, [r2, #0x2]
70099770: e7c13000     	strb	r3, [r1, r0]
70099774: e2800001     	add	r0, r0, #1
70099778: eafffff4     	b	0x70099750 <_pproc_fwp___TI_printfi_nofloat+0x104> @ imm = #-0x30
7009977c: e3a02000     	mov	r2, #0
70099780: e7c12000     	strb	r2, [r1, r0]
70099784: e5dd0006     	ldrb	r0, [sp, #0x6]
70099788: e3500000     	cmp	r0, #0
7009978c: 0a000003     	beq	0x700997a0 <_pproc_fwp___TI_printfi_nofloat+0x154> @ imm = #0xc
70099790: e28d0006     	add	r0, sp, #6
70099794: eb0047e0     	bl	0x700ab71c <atoi>       @ imm = #0x11f80
70099798: e5840008     	str	r0, [r4, #0x8]
7009979c: e8bd88ff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}
700997a0: e5842008     	str	r2, [r4, #0x8]
700997a4: e8bd88ff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}

700997a8 <_pproc_wstr___TI_printfi_nofloat>:
700997a8: e92d4ff8     	push	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
700997ac: e5927000     	ldr	r7, [r2]
700997b0: e1a04001     	mov	r4, r1
700997b4: e59dc028     	ldr	r12, [sp, #0x28]
700997b8: e2876004     	add	r6, r7, #4
700997bc: e5826000     	str	r6, [r2]
700997c0: e5976000     	ldr	r6, [r7]
700997c4: e3560000     	cmp	r6, #0
700997c8: 0a00002d     	beq	0x70099884 <_pproc_wstr___TI_printfi_nofloat+0xdc> @ imm = #0xb4
700997cc: e5907008     	ldr	r7, [r0, #0x8]
700997d0: e1a05003     	mov	r5, r3
700997d4: e1a09000     	mov	r9, r0
700997d8: e1a0800c     	mov	r8, r12
700997dc: e3570000     	cmp	r7, #0
700997e0: 4a000003     	bmi	0x700997f4 <_pproc_wstr___TI_printfi_nofloat+0x4c> @ imm = #0xc
700997e4: e1a00006     	mov	r0, r6
700997e8: eb0056f8     	bl	0x700af3d0 <wcslen>     @ imm = #0x15be0
700997ec: e1570000     	cmp	r7, r0
700997f0: 3a000002     	blo	0x70099800 <_pproc_wstr___TI_printfi_nofloat+0x58> @ imm = #0x8
700997f4: e1a00006     	mov	r0, r6
700997f8: eb0056f4     	bl	0x700af3d0 <wcslen>     @ imm = #0x15bd0
700997fc: e1a07000     	mov	r7, r0
70099800: e599a004     	ldr	r10, [r9, #0x4]
70099804: e1a0b007     	mov	r11, r7
70099808: e5950000     	ldr	r0, [r5]
7009980c: e58d5000     	str	r5, [sp]
70099810: e15a0007     	cmp	r10, r7
70099814: c1a0b00a     	movgt	r11, r10
70099818: e080000b     	add	r0, r0, r11
7009981c: e5850000     	str	r0, [r5]
70099820: da00000b     	ble	0x70099854 <_pproc_wstr___TI_printfi_nofloat+0xac> @ imm = #0x2c
70099824: e5d90000     	ldrb	r0, [r9]
70099828: e3100001     	tst	r0, #1
7009982c: 1a000008     	bne	0x70099854 <_pproc_wstr___TI_printfi_nofloat+0xac> @ imm = #0x20
70099830: e04b0007     	sub	r0, r11, r7
70099834: e1c05fc0     	bic	r5, r0, r0, asr #31
70099838: e3550000     	cmp	r5, #0
7009983c: 0a000004     	beq	0x70099854 <_pproc_wstr___TI_printfi_nofloat+0xac> @ imm = #0x10
70099840: e3a00020     	mov	r0, #32
70099844: e1a01004     	mov	r1, r4
70099848: e12fff38     	blx	r8
7009984c: e2455001     	sub	r5, r5, #1
70099850: eafffff8     	b	0x70099838 <_pproc_wstr___TI_printfi_nofloat+0x90> @ imm = #-0x20
70099854: e1c75fc7     	bic	r5, r7, r7, asr #31
70099858: e3550000     	cmp	r5, #0
7009985c: 0a00000c     	beq	0x70099894 <_pproc_wstr___TI_printfi_nofloat+0xec> @ imm = #0x30
70099860: e5960000     	ldr	r0, [r6]
70099864: e3500c01     	cmp	r0, #256
70099868: 2a000017     	bhs	0x700998cc <_pproc_wstr___TI_printfi_nofloat+0x124> @ imm = #0x5c
7009986c: e6ef0070     	uxtb	r0, r0
70099870: e1a01004     	mov	r1, r4
70099874: e2866004     	add	r6, r6, #4
70099878: e12fff38     	blx	r8
7009987c: e2455001     	sub	r5, r5, #1
70099880: eafffff4     	b	0x70099858 <_pproc_wstr___TI_printfi_nofloat+0xb0> @ imm = #-0x30
70099884: e3a00000     	mov	r0, #0
70099888: e1a01004     	mov	r1, r4
7009988c: e8bd4ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
70099890: e12fff1c     	bx	r12
70099894: e15a0007     	cmp	r10, r7
70099898: da000011     	ble	0x700998e4 <_pproc_wstr___TI_printfi_nofloat+0x13c> @ imm = #0x44
7009989c: e5d90000     	ldrb	r0, [r9]
700998a0: e3100001     	tst	r0, #1
700998a4: 08bd8ff8     	popeq	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
700998a8: e04b0007     	sub	r0, r11, r7
700998ac: e1c05fc0     	bic	r5, r0, r0, asr #31
700998b0: e3550000     	cmp	r5, #0
700998b4: 0a00000a     	beq	0x700998e4 <_pproc_wstr___TI_printfi_nofloat+0x13c> @ imm = #0x28
700998b8: e3a00020     	mov	r0, #32
700998bc: e1a01004     	mov	r1, r4
700998c0: e12fff38     	blx	r8
700998c4: e2455001     	sub	r5, r5, #1
700998c8: eafffff8     	b	0x700998b0 <_pproc_wstr___TI_printfi_nofloat+0x108> @ imm = #-0x20
700998cc: e3e00000     	mvn	r0, #0
700998d0: e59d1000     	ldr	r1, [sp]
700998d4: e5810000     	str	r0, [r1]
700998d8: eb00048d     	bl	0x7009ab14 <__aeabi_errno_addr> @ imm = #0x1234
700998dc: e3a01058     	mov	r1, #88
700998e0: e5801000     	str	r1, [r0]
700998e4: e8bd8ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}

700998e8 <_pproc_str___TI_printfi_nofloat>:
700998e8: e92d4ff8     	push	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
700998ec: e5927000     	ldr	r7, [r2]
700998f0: e1a04001     	mov	r4, r1
700998f4: e59dc028     	ldr	r12, [sp, #0x28]
700998f8: e2876004     	add	r6, r7, #4
700998fc: e5826000     	str	r6, [r2]
70099900: e5977000     	ldr	r7, [r7]
70099904: e3570000     	cmp	r7, #0
70099908: 0a000037     	beq	0x700999ec <_pproc_str___TI_printfi_nofloat+0x104> @ imm = #0xdc
7009990c: e590b008     	ldr	r11, [r0, #0x8]
70099910: e1a05003     	mov	r5, r3
70099914: e1a08000     	mov	r8, r0
70099918: e1a0600c     	mov	r6, r12
7009991c: e35b0000     	cmp	r11, #0
70099920: 4a000003     	bmi	0x70099934 <_pproc_str___TI_printfi_nofloat+0x4c> @ imm = #0xc
70099924: e1a00007     	mov	r0, r7
70099928: eb005727     	bl	0x700af5cc <strlen>     @ imm = #0x15c9c
7009992c: e15b0000     	cmp	r11, r0
70099930: 3a000002     	blo	0x70099940 <_pproc_str___TI_printfi_nofloat+0x58> @ imm = #0x8
70099934: e1a00007     	mov	r0, r7
70099938: eb005723     	bl	0x700af5cc <strlen>     @ imm = #0x15c8c
7009993c: e1a0b000     	mov	r11, r0
70099940: e598a004     	ldr	r10, [r8, #0x4]
70099944: e1a0900b     	mov	r9, r11
70099948: e5950000     	ldr	r0, [r5]
7009994c: e15a000b     	cmp	r10, r11
70099950: c1a0900a     	movgt	r9, r10
70099954: e0800009     	add	r0, r0, r9
70099958: e5850000     	str	r0, [r5]
7009995c: da00000b     	ble	0x70099990 <_pproc_str___TI_printfi_nofloat+0xa8> @ imm = #0x2c
70099960: e5d80000     	ldrb	r0, [r8]
70099964: e3100001     	tst	r0, #1
70099968: 1a000008     	bne	0x70099990 <_pproc_str___TI_printfi_nofloat+0xa8> @ imm = #0x20
7009996c: e049000b     	sub	r0, r9, r11
70099970: e1c05fc0     	bic	r5, r0, r0, asr #31
70099974: e3550000     	cmp	r5, #0
70099978: 0a000004     	beq	0x70099990 <_pproc_str___TI_printfi_nofloat+0xa8> @ imm = #0x10
7009997c: e3a00020     	mov	r0, #32
70099980: e1a01004     	mov	r1, r4
70099984: e12fff36     	blx	r6
70099988: e2455001     	sub	r5, r5, #1
7009998c: eafffff8     	b	0x70099974 <_pproc_str___TI_printfi_nofloat+0x8c> @ imm = #-0x20
70099990: e1cb5fcb     	bic	r5, r11, r11, asr #31
70099994: e3550000     	cmp	r5, #0
70099998: 0a000004     	beq	0x700999b0 <_pproc_str___TI_printfi_nofloat+0xc8> @ imm = #0x10
7009999c: e4d70001     	ldrb	r0, [r7], #1
700999a0: e1a01004     	mov	r1, r4
700999a4: e12fff36     	blx	r6
700999a8: e2455001     	sub	r5, r5, #1
700999ac: eafffff8     	b	0x70099994 <_pproc_str___TI_printfi_nofloat+0xac> @ imm = #-0x20
700999b0: e15a000b     	cmp	r10, r11
700999b4: da00000b     	ble	0x700999e8 <_pproc_str___TI_printfi_nofloat+0x100> @ imm = #0x2c
700999b8: e5d80000     	ldrb	r0, [r8]
700999bc: e3100001     	tst	r0, #1
700999c0: 08bd8ff8     	popeq	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
700999c4: e049000b     	sub	r0, r9, r11
700999c8: e1c05fc0     	bic	r5, r0, r0, asr #31
700999cc: e3550000     	cmp	r5, #0
700999d0: 0a000004     	beq	0x700999e8 <_pproc_str___TI_printfi_nofloat+0x100> @ imm = #0x10
700999d4: e3a00020     	mov	r0, #32
700999d8: e1a01004     	mov	r1, r4
700999dc: e12fff36     	blx	r6
700999e0: e2455001     	sub	r5, r5, #1
700999e4: eafffff8     	b	0x700999cc <_pproc_str___TI_printfi_nofloat+0xe4> @ imm = #-0x20
700999e8: e8bd8ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
700999ec: e3a00000     	mov	r0, #0
700999f0: e1a01004     	mov	r1, r4
700999f4: e8bd4ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
700999f8: e12fff1c     	bx	r12

700999fc <_setfield___TI_printfi_nofloat>:
700999fc: e92d4ffe     	push	{r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
70099a00: e1a05001     	mov	r5, r1
70099a04: e5918004     	ldr	r8, [r1, #0x4]
70099a08: e3a09000     	mov	r9, #0
70099a0c: e1a06002     	mov	r6, r2
70099a10: e30011fd     	movw	r1, #0x1fd
70099a14: e3a02020     	mov	r2, #32
70099a18: e1a04000     	mov	r4, r0
70099a1c: e58d9004     	str	r9, [sp, #0x4]
70099a20: eb005862     	bl	0x700afbb0 <__aeabi_memset8> @ imm = #0x16188
70099a24: e1a0b004     	mov	r11, r4
70099a28: e2842f7f     	add	r2, r4, #508
70099a2c: e5eb91fd     	strb	r9, [r11, #0x1fd]!
70099a30: e5d5000c     	ldrb	r0, [r5, #0xc]
70099a34: e58d2008     	str	r2, [sp, #0x8]
70099a38: e2401063     	sub	r1, r0, #99
70099a3c: e3510015     	cmp	r1, #21
70099a40: 8a000080     	bhi	0x70099c48 <_setfield___TI_printfi_nofloat+0x24c> @ imm = #0x200
70099a44: e59f2258     	ldr	r2, [pc, #0x258]        @ 0x70099ca4 <_setfield___TI_printfi_nofloat+0x2a8>
70099a48: e3a03001     	mov	r3, #1
70099a4c: e1120113     	tst	r2, r3, lsl r1
70099a50: 0a00006b     	beq	0x70099c04 <_setfield___TI_printfi_nofloat+0x208> @ imm = #0x1ac
70099a54: e28d1004     	add	r1, sp, #4
70099a58: e28d2008     	add	r2, sp, #8
70099a5c: e1a00005     	mov	r0, r5
70099a60: e1a03006     	mov	r3, r6
70099a64: eb00008f     	bl	0x70099ca8 <_pproc_diouxp___TI_printfi_nofloat> @ imm = #0x23c
70099a68: e3a09000     	mov	r9, #0
70099a6c: e5d5000c     	ldrb	r0, [r5, #0xc]
70099a70: e240106f     	sub	r1, r0, #111
70099a74: e3510009     	cmp	r1, #9
70099a78: 8a00003c     	bhi	0x70099b70 <_setfield___TI_printfi_nofloat+0x174> @ imm = #0xf0
70099a7c: e3a02001     	mov	r2, #1
70099a80: e3003243     	movw	r3, #0x243
70099a84: e1130112     	tst	r3, r2, lsl r1
70099a88: 0a000038     	beq	0x70099b70 <_setfield___TI_printfi_nofloat+0x174> @ imm = #0xe0
70099a8c: e3a0a000     	mov	r10, #0
70099a90: e5d51000     	ldrb	r1, [r5]
70099a94: e0847008     	add	r7, r4, r8
70099a98: e59d0008     	ldr	r0, [sp, #0x8]
70099a9c: e1a06004     	mov	r6, r4
70099aa0: e3110001     	tst	r1, #1
70099aa4: 1a000006     	bne	0x70099ac4 <_setfield___TI_printfi_nofloat+0xc8> @ imm = #0x18
70099aa8: e5952004     	ldr	r2, [r5, #0x4]
70099aac: e04b1000     	sub	r1, r11, r0
70099ab0: e1a06004     	mov	r6, r4
70099ab4: e1510002     	cmp	r1, r2
70099ab8: ca000001     	bgt	0x70099ac4 <_setfield___TI_printfi_nofloat+0xc8> @ imm = #0x4
70099abc: e0471001     	sub	r1, r7, r1
70099ac0: e2816001     	add	r6, r1, #1
70099ac4: e2801001     	add	r1, r0, #1
70099ac8: e1a00006     	mov	r0, r6
70099acc: e3a02000     	mov	r2, #0
70099ad0: e30031fe     	movw	r3, #0x1fe
70099ad4: e3a08000     	mov	r8, #0
70099ad8: eb004eea     	bl	0x700ad688 <memccpy>    @ imm = #0x13ba8
70099adc: e58d0008     	str	r0, [sp, #0x8]
70099ae0: e3590000     	cmp	r9, #0
70099ae4: 0a000001     	beq	0x70099af0 <_setfield___TI_printfi_nofloat+0xf4> @ imm = #0x4
70099ae8: e4c08001     	strb	r8, [r0], #1
70099aec: e58d0008     	str	r0, [sp, #0x8]
70099af0: e1500007     	cmp	r0, r7
70099af4: 8a000006     	bhi	0x70099b14 <_setfield___TI_printfi_nofloat+0x118> @ imm = #0x18
70099af8: e0471000     	sub	r1, r7, r0
70099afc: e2400001     	sub	r0, r0, #1
70099b00: e3a02020     	mov	r2, #32
70099b04: e2811001     	add	r1, r1, #1
70099b08: eb005828     	bl	0x700afbb0 <__aeabi_memset8> @ imm = #0x160a0
70099b0c: e3a00000     	mov	r0, #0
70099b10: e5c70000     	strb	r0, [r7]
70099b14: e5d50000     	ldrb	r0, [r5]
70099b18: e3100010     	tst	r0, #16
70099b1c: 1a000004     	bne	0x70099b34 <_setfield___TI_printfi_nofloat+0x138> @ imm = #0x10
70099b20: e0461004     	sub	r1, r6, r4
70099b24: e1a00004     	mov	r0, r4
70099b28: e3a02020     	mov	r2, #32
70099b2c: eb00581f     	bl	0x700afbb0 <__aeabi_memset8> @ imm = #0x1607c
70099b30: ea00002f     	b	0x70099bf4 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0xbc
70099b34: e1560004     	cmp	r6, r4
70099b38: 0a00002d     	beq	0x70099bf4 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0xb4
70099b3c: e0461004     	sub	r1, r6, r4
70099b40: e1a00004     	mov	r0, r4
70099b44: e3a02030     	mov	r2, #48
70099b48: e3a07030     	mov	r7, #48
70099b4c: eb005817     	bl	0x700afbb0 <__aeabi_memset8> @ imm = #0x1605c
70099b50: e59d0004     	ldr	r0, [sp, #0x4]
70099b54: e190000a     	orrs	r0, r0, r10
70099b58: 1a00000e     	bne	0x70099b98 <_setfield___TI_printfi_nofloat+0x19c> @ imm = #0x38
70099b5c: e5d50000     	ldrb	r0, [r5]
70099b60: e3100004     	tst	r0, #4
70099b64: 1a00000b     	bne	0x70099b98 <_setfield___TI_printfi_nofloat+0x19c> @ imm = #0x2c
70099b68: e1a00004     	mov	r0, r4
70099b6c: ea00000d     	b	0x70099ba8 <_setfield___TI_printfi_nofloat+0x1ac> @ imm = #0x34
70099b70: e3500058     	cmp	r0, #88
70099b74: 0affffc4     	beq	0x70099a8c <_setfield___TI_printfi_nofloat+0x90> @ imm = #-0xf0
70099b78: e5950000     	ldr	r0, [r5]
70099b7c: e59d1004     	ldr	r1, [sp, #0x4]
70099b80: e200a002     	and	r10, r0, #2
70099b84: e3510000     	cmp	r1, #0
70099b88: 0a000037     	beq	0x70099c6c <_setfield___TI_printfi_nofloat+0x270> @ imm = #0xdc
70099b8c: e3a0002d     	mov	r0, #45
70099b90: e59d1008     	ldr	r1, [sp, #0x8]
70099b94: ea00003f     	b	0x70099c98 <_setfield___TI_printfi_nofloat+0x29c> @ imm = #0xfc
70099b98: e5d61000     	ldrb	r1, [r6]
70099b9c: e1a00004     	mov	r0, r4
70099ba0: e4c01001     	strb	r1, [r0], #1
70099ba4: e4c67001     	strb	r7, [r6], #1
70099ba8: e5d5100c     	ldrb	r1, [r5, #0xc]
70099bac: e3510041     	cmp	r1, #65
70099bb0: 0a00000b     	beq	0x70099be4 <_setfield___TI_printfi_nofloat+0x1e8> @ imm = #0x2c
70099bb4: e3510058     	cmp	r1, #88
70099bb8: 0a000004     	beq	0x70099bd0 <_setfield___TI_printfi_nofloat+0x1d4> @ imm = #0x10
70099bbc: e3510061     	cmp	r1, #97
70099bc0: 0a000007     	beq	0x70099be4 <_setfield___TI_printfi_nofloat+0x1e8> @ imm = #0x1c
70099bc4: e3510078     	cmp	r1, #120
70099bc8: 13510070     	cmpne	r1, #112
70099bcc: 1a000008     	bne	0x70099bf4 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0x20
70099bd0: e5d52000     	ldrb	r2, [r5]
70099bd4: e3120008     	tst	r2, #8
70099bd8: 1a000001     	bne	0x70099be4 <_setfield___TI_printfi_nofloat+0x1e8> @ imm = #0x4
70099bdc: e3510061     	cmp	r1, #97
70099be0: 1a000003     	bne	0x70099bf4 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0xc
70099be4: e5d61001     	ldrb	r1, [r6, #0x1]
70099be8: e3a02030     	mov	r2, #48
70099bec: e5c01001     	strb	r1, [r0, #0x1]
70099bf0: e5c62001     	strb	r2, [r6, #0x1]
70099bf4: e1a00004     	mov	r0, r4
70099bf8: eb005673     	bl	0x700af5cc <strlen>     @ imm = #0x159cc
70099bfc: e0800009     	add	r0, r0, r9
70099c00: e8bd8ffe     	pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
70099c04: e3510000     	cmp	r1, #0
70099c08: 1a00000e     	bne	0x70099c48 <_setfield___TI_printfi_nofloat+0x24c> @ imm = #0x38
70099c0c: e5960000     	ldr	r0, [r6]
70099c10: e2801004     	add	r1, r0, #4
70099c14: e5861000     	str	r1, [r6]
70099c18: e5900000     	ldr	r0, [r0]
70099c1c: e6ef1070     	uxtb	r1, r0
70099c20: e5c401fc     	strb	r0, [r4, #0x1fc]
70099c24: e30001fb     	movw	r0, #0x1fb
70099c28: e5952000     	ldr	r2, [r5]
70099c2c: e16f1f11     	clz	r1, r1
70099c30: e0840000     	add	r0, r4, r0
70099c34: e3c22002     	bic	r2, r2, #2
70099c38: e1a092a1     	lsr	r9, r1, #5
70099c3c: e58d0008     	str	r0, [sp, #0x8]
70099c40: e5852000     	str	r2, [r5]
70099c44: eaffff88     	b	0x70099a6c <_setfield___TI_printfi_nofloat+0x70> @ imm = #-0x1e0
70099c48: e3500025     	cmp	r0, #37
70099c4c: 0a000002     	beq	0x70099c5c <_setfield___TI_printfi_nofloat+0x260> @ imm = #0x8
70099c50: e3500058     	cmp	r0, #88
70099c54: 0affff7e     	beq	0x70099a54 <_setfield___TI_printfi_nofloat+0x58> @ imm = #-0x208
70099c58: eaffff84     	b	0x70099a70 <_setfield___TI_printfi_nofloat+0x74> @ imm = #-0x1f0
70099c5c: e3a01025     	mov	r1, #37
70099c60: e3a00001     	mov	r0, #1
70099c64: e1c410b0     	strh	r1, [r4]
70099c68: e8bd8ffe     	pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
70099c6c: e35a0000     	cmp	r10, #0
70099c70: 1a000005     	bne	0x70099c8c <_setfield___TI_printfi_nofloat+0x290> @ imm = #0x14
70099c74: e3100004     	tst	r0, #4
70099c78: 0affff83     	beq	0x70099a8c <_setfield___TI_printfi_nofloat+0x90> @ imm = #-0x1f4
70099c7c: e3a00020     	mov	r0, #32
70099c80: e59d1008     	ldr	r1, [sp, #0x8]
70099c84: e3a0a000     	mov	r10, #0
70099c88: ea000002     	b	0x70099c98 <_setfield___TI_printfi_nofloat+0x29c> @ imm = #0x8
70099c8c: e3a0002b     	mov	r0, #43
70099c90: e59d1008     	ldr	r1, [sp, #0x8]
70099c94: e3a0a001     	mov	r10, #1
70099c98: e4410001     	strb	r0, [r1], #-1
70099c9c: e58d1008     	str	r1, [sp, #0x8]
70099ca0: eaffff7a     	b	0x70099a90 <_setfield___TI_printfi_nofloat+0x94> @ imm = #-0x218
70099ca4: 42 30 24 00  	.word	0x00243042

70099ca8 <_pproc_diouxp___TI_printfi_nofloat>:
70099ca8: e92d48fc     	push	{r2, r3, r4, r5, r6, r7, r11, lr}
70099cac: e1a05000     	mov	r5, r0
70099cb0: e5900008     	ldr	r0, [r0, #0x8]
70099cb4: e1a04002     	mov	r4, r2
70099cb8: e1a07001     	mov	r7, r1
70099cbc: e3a06010     	mov	r6, #16
70099cc0: e3700001     	cmn	r0, #1
70099cc4: c5950000     	ldrgt	r0, [r5]
70099cc8: c3c00010     	bicgt	r0, r0, #16
70099ccc: c5850000     	strgt	r0, [r5]
70099cd0: d3a00001     	movle	r0, #1
70099cd4: d5850008     	strle	r0, [r5, #0x8]
70099cd8: e5d5000c     	ldrb	r0, [r5, #0xc]
70099cdc: e3500058     	cmp	r0, #88
70099ce0: 0a000005     	beq	0x70099cfc <_pproc_diouxp___TI_printfi_nofloat+0x54> @ imm = #0x14
70099ce4: e3500078     	cmp	r0, #120
70099ce8: 13500070     	cmpne	r0, #112
70099cec: 0a000002     	beq	0x70099cfc <_pproc_diouxp___TI_printfi_nofloat+0x54> @ imm = #0x8
70099cf0: e350006f     	cmp	r0, #111
70099cf4: 13a0600a     	movne	r6, #10
70099cf8: 03a06008     	moveq	r6, #8
70099cfc: e1a00005     	mov	r0, r5
70099d00: e1a01003     	mov	r1, r3
70099d04: eb00004d     	bl	0x70099e40 <_getarg_diouxp___TI_printfi_nofloat> @ imm = #0x134
70099d08: e5952008     	ldr	r2, [r5, #0x8]
70099d0c: e3520000     	cmp	r2, #0
70099d10: 01902001     	orrseq	r2, r0, r1
70099d14: 0a000007     	beq	0x70099d38 <_pproc_diouxp___TI_printfi_nofloat+0x90> @ imm = #0x1c
70099d18: e5d5300c     	ldrb	r3, [r5, #0xc]
70099d1c: e3530064     	cmp	r3, #100
70099d20: 1a00000b     	bne	0x70099d54 <_pproc_diouxp___TI_printfi_nofloat+0xac> @ imm = #0x2c
70099d24: e3a02064     	mov	r2, #100
70099d28: e3a03064     	mov	r3, #100
70099d2c: e3710001     	cmn	r1, #1
70099d30: ca000011     	bgt	0x70099d7c <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x44
70099d34: ea00000b     	b	0x70099d68 <_pproc_diouxp___TI_printfi_nofloat+0xc0> @ imm = #0x2c
70099d38: e5d50000     	ldrb	r0, [r5]
70099d3c: e3100008     	tst	r0, #8
70099d40: 0a00003d     	beq	0x70099e3c <_pproc_diouxp___TI_printfi_nofloat+0x194> @ imm = #0xf4
70099d44: e5d5300c     	ldrb	r3, [r5, #0xc]
70099d48: e3a00000     	mov	r0, #0
70099d4c: e3a01000     	mov	r1, #0
70099d50: ea000009     	b	0x70099d7c <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x24
70099d54: e3530069     	cmp	r3, #105
70099d58: 1a000007     	bne	0x70099d7c <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x1c
70099d5c: e3a02069     	mov	r2, #105
70099d60: e3510000     	cmp	r1, #0
70099d64: 5a000004     	bpl	0x70099d7c <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x10
70099d68: e2700000     	rsbs	r0, r0, #0
70099d6c: e3a0c001     	mov	r12, #1
70099d70: e2e11000     	rsc	r1, r1, #0
70099d74: e1a03002     	mov	r3, r2
70099d78: e587c000     	str	r12, [r7]
70099d7c: e1a02006     	mov	r2, r6
70099d80: e58d4000     	str	r4, [sp]
70099d84: eb00009c     	bl	0x70099ffc <_ltostr___TI_printfi_nofloat> @ imm = #0x270
70099d88: e3a01030     	mov	r1, #48
70099d8c: e5952008     	ldr	r2, [r5, #0x8]
70099d90: e1500002     	cmp	r0, r2
70099d94: aa000005     	bge	0x70099db0 <_pproc_diouxp___TI_printfi_nofloat+0x108> @ imm = #0x14
70099d98: e5942000     	ldr	r2, [r4]
70099d9c: e2800001     	add	r0, r0, #1
70099da0: e2423001     	sub	r3, r2, #1
70099da4: e5843000     	str	r3, [r4]
70099da8: e5c21000     	strb	r1, [r2]
70099dac: eafffff6     	b	0x70099d8c <_pproc_diouxp___TI_printfi_nofloat+0xe4> @ imm = #-0x28
70099db0: e5d5000c     	ldrb	r0, [r5, #0xc]
70099db4: e3500058     	cmp	r0, #88
70099db8: 13500078     	cmpne	r0, #120
70099dbc: 1a00000f     	bne	0x70099e00 <_pproc_diouxp___TI_printfi_nofloat+0x158> @ imm = #0x3c
70099dc0: e5d51000     	ldrb	r1, [r5]
70099dc4: e3110008     	tst	r1, #8
70099dc8: 0a00000e     	beq	0x70099e08 <_pproc_diouxp___TI_printfi_nofloat+0x160> @ imm = #0x38
70099dcc: e5941000     	ldr	r1, [r4]
70099dd0: e3500070     	cmp	r0, #112
70099dd4: 03000078     	movweq	r0, #0x78
70099dd8: e2412001     	sub	r2, r1, #1
70099ddc: e5842000     	str	r2, [r4]
70099de0: e3a02030     	mov	r2, #48
70099de4: e5c10000     	strb	r0, [r1]
70099de8: e5940000     	ldr	r0, [r4]
70099dec: e2401001     	sub	r1, r0, #1
70099df0: e5841000     	str	r1, [r4]
70099df4: e5c02000     	strb	r2, [r0]
70099df8: e5d5000c     	ldrb	r0, [r5, #0xc]
70099dfc: ea000001     	b	0x70099e08 <_pproc_diouxp___TI_printfi_nofloat+0x160> @ imm = #0x4
70099e00: e3500070     	cmp	r0, #112
70099e04: 0affffed     	beq	0x70099dc0 <_pproc_diouxp___TI_printfi_nofloat+0x118> @ imm = #-0x4c
70099e08: e350006f     	cmp	r0, #111
70099e0c: 1a00000a     	bne	0x70099e3c <_pproc_diouxp___TI_printfi_nofloat+0x194> @ imm = #0x28
70099e10: e5d50000     	ldrb	r0, [r5]
70099e14: e3100008     	tst	r0, #8
70099e18: 0a000007     	beq	0x70099e3c <_pproc_diouxp___TI_printfi_nofloat+0x194> @ imm = #0x1c
70099e1c: e5940000     	ldr	r0, [r4]
70099e20: e5d01001     	ldrb	r1, [r0, #0x1]
70099e24: e3510030     	cmp	r1, #48
70099e28: 08bd88fc     	popeq	{r2, r3, r4, r5, r6, r7, r11, pc}
70099e2c: e2401001     	sub	r1, r0, #1
70099e30: e3a02030     	mov	r2, #48
70099e34: e5841000     	str	r1, [r4]
70099e38: e5c02000     	strb	r2, [r0]
70099e3c: e8bd88fc     	pop	{r2, r3, r4, r5, r6, r7, r11, pc}

70099e40 <_getarg_diouxp___TI_printfi_nofloat>:
70099e40: e92d4800     	push	{r11, lr}
70099e44: e5d0200c     	ldrb	r2, [r0, #0xc]
70099e48: e3520070     	cmp	r2, #112
70099e4c: 1a000002     	bne	0x70099e5c <_getarg_diouxp___TI_printfi_nofloat+0x1c> @ imm = #0x8
70099e50: e5910000     	ldr	r0, [r1]
70099e54: e3a03000     	mov	r3, #0
70099e58: ea000037     	b	0x70099f3c <_getarg_diouxp___TI_printfi_nofloat+0xfc> @ imm = #0xdc
70099e5c: e5900000     	ldr	r0, [r0]
70099e60: e3033f60     	movw	r3, #0x3f60
70099e64: e0000003     	and	r0, r0, r3
70099e68: e3500a02     	cmp	r0, #8192
70099e6c: 13500040     	cmpne	r0, #64
70099e70: 1a000011     	bne	0x70099ebc <_getarg_diouxp___TI_printfi_nofloat+0x7c> @ imm = #0x44
70099e74: e3a03000     	mov	r3, #0
70099e78: e242e064     	sub	lr, r2, #100
70099e7c: e35e0014     	cmp	lr, #20
70099e80: 8a00002a     	bhi	0x70099f30 <_getarg_diouxp___TI_printfi_nofloat+0xf0> @ imm = #0xa8
70099e84: e3000800     	movw	r0, #0x800
70099e88: e3a0c001     	mov	r12, #1
70099e8c: e3400012     	movt	r0, #0x12
70099e90: e1100e1c     	tst	r0, r12, lsl lr
70099e94: 1a000027     	bne	0x70099f38 <_getarg_diouxp___TI_printfi_nofloat+0xf8> @ imm = #0x9c
70099e98: e3a00021     	mov	r0, #33
70099e9c: e1100e1c     	tst	r0, r12, lsl lr
70099ea0: 0a000022     	beq	0x70099f30 <_getarg_diouxp___TI_printfi_nofloat+0xf0> @ imm = #0x88
70099ea4: e5910000     	ldr	r0, [r1]
70099ea8: e2802004     	add	r2, r0, #4
70099eac: e5812000     	str	r2, [r1]
70099eb0: e5900000     	ldr	r0, [r0]
70099eb4: e1a03fc0     	asr	r3, r0, #31
70099eb8: ea000022     	b	0x70099f48 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #0x88
70099ebc: e3500c01     	cmp	r0, #256
70099ec0: 0a000022     	beq	0x70099f50 <_getarg_diouxp___TI_printfi_nofloat+0x110> @ imm = #0x88
70099ec4: e3500c02     	cmp	r0, #512
70099ec8: 0a000036     	beq	0x70099fa8 <_getarg_diouxp___TI_printfi_nofloat+0x168> @ imm = #0xd8
70099ecc: e3500b02     	cmp	r0, #2048
70099ed0: 0a00001e     	beq	0x70099f50 <_getarg_diouxp___TI_printfi_nofloat+0x110> @ imm = #0x78
70099ed4: e3a03000     	mov	r3, #0
70099ed8: e242e064     	sub	lr, r2, #100
70099edc: e3500a01     	cmp	r0, #4096
70099ee0: 0affffe5     	beq	0x70099e7c <_getarg_diouxp___TI_printfi_nofloat+0x3c> @ imm = #-0x6c
70099ee4: e3500020     	cmp	r0, #32
70099ee8: 1affffe3     	bne	0x70099e7c <_getarg_diouxp___TI_printfi_nofloat+0x3c> @ imm = #-0x74
70099eec: e35e0014     	cmp	lr, #20
70099ef0: 8a000007     	bhi	0x70099f14 <_getarg_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x1c
70099ef4: e3000800     	movw	r0, #0x800
70099ef8: e3a0c001     	mov	r12, #1
70099efc: e3400012     	movt	r0, #0x12
70099f00: e1100e1c     	tst	r0, r12, lsl lr
70099f04: 1a000004     	bne	0x70099f1c <_getarg_diouxp___TI_printfi_nofloat+0xdc> @ imm = #0x10
70099f08: e3a00021     	mov	r0, #33
70099f0c: e1100e1c     	tst	r0, r12, lsl lr
70099f10: 1affffe3     	bne	0x70099ea4 <_getarg_diouxp___TI_printfi_nofloat+0x64> @ imm = #-0x74
70099f14: e3520058     	cmp	r2, #88
70099f18: 1a000035     	bne	0x70099ff4 <_getarg_diouxp___TI_printfi_nofloat+0x1b4> @ imm = #0xd4
70099f1c: e5910000     	ldr	r0, [r1]
70099f20: e2802004     	add	r2, r0, #4
70099f24: e5812000     	str	r2, [r1]
70099f28: e1d000b0     	ldrh	r0, [r0]
70099f2c: ea000005     	b	0x70099f48 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #0x14
70099f30: e3520058     	cmp	r2, #88
70099f34: 1a00002e     	bne	0x70099ff4 <_getarg_diouxp___TI_printfi_nofloat+0x1b4> @ imm = #0xb8
70099f38: e5910000     	ldr	r0, [r1]
70099f3c: e2802004     	add	r2, r0, #4
70099f40: e5812000     	str	r2, [r1]
70099f44: e5900000     	ldr	r0, [r0]
70099f48: e1a01003     	mov	r1, r3
70099f4c: e8bd8800     	pop	{r11, pc}
70099f50: e2420064     	sub	r0, r2, #100
70099f54: e3500014     	cmp	r0, #20
70099f58: 8a000007     	bhi	0x70099f7c <_getarg_diouxp___TI_printfi_nofloat+0x13c> @ imm = #0x1c
70099f5c: e3003800     	movw	r3, #0x800
70099f60: e3a0c001     	mov	r12, #1
70099f64: e3403012     	movt	r3, #0x12
70099f68: e113001c     	tst	r3, r12, lsl r0
70099f6c: 1a000006     	bne	0x70099f8c <_getarg_diouxp___TI_printfi_nofloat+0x14c> @ imm = #0x18
70099f70: e3a03021     	mov	r3, #33
70099f74: e113001c     	tst	r3, r12, lsl r0
70099f78: 1a000003     	bne	0x70099f8c <_getarg_diouxp___TI_printfi_nofloat+0x14c> @ imm = #0xc
70099f7c: e3a00000     	mov	r0, #0
70099f80: e3a03000     	mov	r3, #0
70099f84: e3520058     	cmp	r2, #88
70099f88: 1affffee     	bne	0x70099f48 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0x48
70099f8c: e5910000     	ldr	r0, [r1]
70099f90: e2800007     	add	r0, r0, #7
70099f94: e3c00007     	bic	r0, r0, #7
70099f98: e2802008     	add	r2, r0, #8
70099f9c: e5812000     	str	r2, [r1]
70099fa0: e8900009     	ldm	r0, {r0, r3}
70099fa4: eaffffe7     	b	0x70099f48 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0x64
70099fa8: e3a03000     	mov	r3, #0
70099fac: e242e064     	sub	lr, r2, #100
70099fb0: e35e0014     	cmp	lr, #20
70099fb4: 8a000007     	bhi	0x70099fd8 <_getarg_diouxp___TI_printfi_nofloat+0x198> @ imm = #0x1c
70099fb8: e3000800     	movw	r0, #0x800
70099fbc: e3a0c001     	mov	r12, #1
70099fc0: e3400012     	movt	r0, #0x12
70099fc4: e1100e1c     	tst	r0, r12, lsl lr
70099fc8: 1a000004     	bne	0x70099fe0 <_getarg_diouxp___TI_printfi_nofloat+0x1a0> @ imm = #0x10
70099fcc: e3a00021     	mov	r0, #33
70099fd0: e1100e1c     	tst	r0, r12, lsl lr
70099fd4: 1affffb2     	bne	0x70099ea4 <_getarg_diouxp___TI_printfi_nofloat+0x64> @ imm = #-0x138
70099fd8: e3520058     	cmp	r2, #88
70099fdc: 1a000004     	bne	0x70099ff4 <_getarg_diouxp___TI_printfi_nofloat+0x1b4> @ imm = #0x10
70099fe0: e5910000     	ldr	r0, [r1]
70099fe4: e2802004     	add	r2, r0, #4
70099fe8: e5812000     	str	r2, [r1]
70099fec: e5d00000     	ldrb	r0, [r0]
70099ff0: eaffffd4     	b	0x70099f48 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0xb0
70099ff4: e3a00000     	mov	r0, #0
70099ff8: eaffffd2     	b	0x70099f48 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0xb8

70099ffc <_ltostr___TI_printfi_nofloat>:
70099ffc: e92d41f0     	push	{r4, r5, r6, r7, r8, lr}
7009a000: e59fc074     	ldr	r12, [pc, #0x74]        @ 0x7009a07c <_ltostr___TI_printfi_nofloat+0x80>
7009a004: e1a04002     	mov	r4, r2
7009a008: e59f6070     	ldr	r6, [pc, #0x70]         @ 0x7009a080 <_ltostr___TI_printfi_nofloat+0x84>
7009a00c: e1a05000     	mov	r5, r0
7009a010: e59d8018     	ldr	r8, [sp, #0x18]
7009a014: e3530058     	cmp	r3, #88
7009a018: 01a0600c     	moveq	r6, r12
7009a01c: e1900001     	orrs	r0, r0, r1
7009a020: 1a00000f     	bne	0x7009a064 <_ltostr___TI_printfi_nofloat+0x68> @ imm = #0x3c
7009a024: e5980000     	ldr	r0, [r8]
7009a028: e3a03030     	mov	r3, #48
7009a02c: e2402001     	sub	r2, r0, #1
7009a030: e5882000     	str	r2, [r8]
7009a034: e5c03000     	strb	r3, [r0]
7009a038: ea000009     	b	0x7009a064 <_ltostr___TI_printfi_nofloat+0x68> @ imm = #0x24
7009a03c: e1a00005     	mov	r0, r5
7009a040: e1a02004     	mov	r2, r4
7009a044: eb00000e     	bl	0x7009a084 <_div___TI_printfi_nofloat> @ imm = #0x38
7009a048: e0625490     	mls	r2, r0, r4, r5
7009a04c: e5983000     	ldr	r3, [r8]
7009a050: e1a05000     	mov	r5, r0
7009a054: e2437001     	sub	r7, r3, #1
7009a058: e7d62002     	ldrb	r2, [r6, r2]
7009a05c: e5887000     	str	r7, [r8]
7009a060: e5c32000     	strb	r2, [r3]
7009a064: e1950001     	orrs	r0, r5, r1
7009a068: 1afffff3     	bne	0x7009a03c <_ltostr___TI_printfi_nofloat+0x40> @ imm = #-0x34
7009a06c: e5980000     	ldr	r0, [r8]
7009a070: eb005555     	bl	0x700af5cc <strlen>     @ imm = #0x15554
7009a074: e2400001     	sub	r0, r0, #1
7009a078: e8bd81f0     	pop	{r4, r5, r6, r7, r8, pc}
7009a07c: 4d 20 0b 70  	.word	0x700b204d
7009a080: 5e 20 0b 70  	.word	0x700b205e

7009a084 <_div___TI_printfi_nofloat>:
7009a084: e92d4800     	push	{r11, lr}
7009a088: e3520010     	cmp	r2, #16
7009a08c: 0a000005     	beq	0x7009a0a8 <_div___TI_printfi_nofloat+0x24> @ imm = #0x14
7009a090: e3520008     	cmp	r2, #8
7009a094: 1a000007     	bne	0x7009a0b8 <_div___TI_printfi_nofloat+0x34> @ imm = #0x1c
7009a098: e1a001a0     	lsr	r0, r0, #3
7009a09c: e1800e81     	orr	r0, r0, r1, lsl #29
7009a0a0: e1a011a1     	lsr	r1, r1, #3
7009a0a4: e8bd8800     	pop	{r11, pc}
7009a0a8: e1a00220     	lsr	r0, r0, #4
7009a0ac: e1800e01     	orr	r0, r0, r1, lsl #28
7009a0b0: e1a01221     	lsr	r1, r1, #4
7009a0b4: e8bd8800     	pop	{r11, pc}
7009a0b8: e3510000     	cmp	r1, #0
7009a0bc: 1a000003     	bne	0x7009a0d0 <_div___TI_printfi_nofloat+0x4c> @ imm = #0xc
7009a0c0: e1a01002     	mov	r1, r2
7009a0c4: eb0015ef     	bl	0x7009f888 <__udivsi3>  @ imm = #0x57bc
7009a0c8: e3a01000     	mov	r1, #0
7009a0cc: e8bd8800     	pop	{r11, pc}
7009a0d0: e3a03000     	mov	r3, #0
7009a0d4: eb005442     	bl	0x700af1e4 <__aeabi_uldivmod> @ imm = #0x15108
7009a0d8: e8bd8800     	pop	{r11, pc}

7009a0dc <__aeabi_memcpy8>:
7009a0dc: ea00554a     	b	0x700af60c <TI_memcpy_small> @ imm = #0x15528

7009a0e0 <_vsnprintf>:
; {
7009a0e0: e92d 43f0    	push.w	{r4, r5, r6, r7, r8, r9, lr}
7009a0e4: b0c1         	sub	sp, #0x104
7009a0e6: f8dd c120    	ldr.w	r12, [sp, #0x120]
7009a0ea: f8cd c100    	str.w	r12, [sp, #0x100]
7009a0ee: 903f         	str	r0, [sp, #0xfc]
7009a0f0: 913e         	str	r1, [sp, #0xf8]
7009a0f2: 923d         	str	r2, [sp, #0xf4]
7009a0f4: 933c         	str	r3, [sp, #0xf0]
7009a0f6: 2000         	movs	r0, #0x0
;   size_t idx = 0U;
7009a0f8: 9037         	str	r0, [sp, #0xdc]
;   if (!buffer) {
7009a0fa: 983e         	ldr	r0, [sp, #0xf8]
7009a0fc: b930         	cbnz	r0, 0x7009a10c <_vsnprintf+0x2c> @ imm = #0xc
7009a0fe: e7ff         	b	0x7009a100 <_vsnprintf+0x20> @ imm = #-0x2
;     out = _out_null;
7009a100: f64f 30c1    	movw	r0, #0xfbc1
7009a104: f2c7 000a    	movt	r0, #0x700a
7009a108: 903f         	str	r0, [sp, #0xfc]
;   }
7009a10a: e7ff         	b	0x7009a10c <_vsnprintf+0x2c> @ imm = #-0x2
;   while (*format)
7009a10c: e7ff         	b	0x7009a10e <_vsnprintf+0x2e> @ imm = #-0x2
7009a10e: 983c         	ldr	r0, [sp, #0xf0]
7009a110: 7800         	ldrb	r0, [r0]
7009a112: 2800         	cmp	r0, #0x0
7009a114: f000 84e3    	beq.w	0x7009aade <_vsnprintf+0x9fe> @ imm = #0x9c6
7009a118: e7ff         	b	0x7009a11a <_vsnprintf+0x3a> @ imm = #-0x2
;     if (*format != '%') {
7009a11a: 983c         	ldr	r0, [sp, #0xf0]
7009a11c: 7800         	ldrb	r0, [r0]
7009a11e: 2825         	cmp	r0, #0x25
7009a120: d00e         	beq	0x7009a140 <_vsnprintf+0x60> @ imm = #0x1c
7009a122: e7ff         	b	0x7009a124 <_vsnprintf+0x44> @ imm = #-0x2
;       out(*format, buffer, idx++, maxlen);
7009a124: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a128: 983c         	ldr	r0, [sp, #0xf0]
7009a12a: 7800         	ldrb	r0, [r0]
7009a12c: 993e         	ldr	r1, [sp, #0xf8]
7009a12e: 9a37         	ldr	r2, [sp, #0xdc]
7009a130: 1c53         	adds	r3, r2, #0x1
7009a132: 9337         	str	r3, [sp, #0xdc]
7009a134: 9b3d         	ldr	r3, [sp, #0xf4]
7009a136: 47e0         	blx	r12
;       format++;
7009a138: 983c         	ldr	r0, [sp, #0xf0]
7009a13a: 3001         	adds	r0, #0x1
7009a13c: 903c         	str	r0, [sp, #0xf0]
;       continue;
7009a13e: e7e6         	b	0x7009a10e <_vsnprintf+0x2e> @ imm = #-0x34
;       format++;
7009a140: 983c         	ldr	r0, [sp, #0xf0]
7009a142: 3001         	adds	r0, #0x1
7009a144: 903c         	str	r0, [sp, #0xf0]
7009a146: e7ff         	b	0x7009a148 <_vsnprintf+0x68> @ imm = #-0x2
7009a148: 2000         	movs	r0, #0x0
;     flags = 0U;
7009a14a: 903b         	str	r0, [sp, #0xec]
;     do {
7009a14c: e7ff         	b	0x7009a14e <_vsnprintf+0x6e> @ imm = #-0x2
;       switch (*format) {
7009a14e: 983c         	ldr	r0, [sp, #0xf0]
7009a150: 7800         	ldrb	r0, [r0]
7009a152: 3820         	subs	r0, #0x20
7009a154: 4601         	mov	r1, r0
7009a156: 912a         	str	r1, [sp, #0xa8]
7009a158: 2810         	cmp	r0, #0x10
7009a15a: d83d         	bhi	0x7009a1d8 <_vsnprintf+0xf8> @ imm = #0x7a
7009a15c: 992a         	ldr	r1, [sp, #0xa8]
7009a15e: e8df f001    	tbb	[pc, r1]
7009a162: 27 3b 3b 31  	.word	0x313b3b27
7009a166: 3b 3b 3b 3b  	.word	0x3b3b3b3b
7009a16a: 3b 3b 3b 1d  	.word	0x1d3b3b3b
7009a16e: 3b 13 3b 3b  	.word	0x3b3b133b
7009a172: 09 00        	.short	0x0009
;         case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
7009a174: 983b         	ldr	r0, [sp, #0xec]
7009a176: f040 0001    	orr	r0, r0, #0x1
7009a17a: 903b         	str	r0, [sp, #0xec]
7009a17c: 983c         	ldr	r0, [sp, #0xf0]
7009a17e: 3001         	adds	r0, #0x1
7009a180: 903c         	str	r0, [sp, #0xf0]
7009a182: 2001         	movs	r0, #0x1
7009a184: 9038         	str	r0, [sp, #0xe0]
7009a186: e02a         	b	0x7009a1de <_vsnprintf+0xfe> @ imm = #0x54
;         case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
7009a188: 983b         	ldr	r0, [sp, #0xec]
7009a18a: f040 0002    	orr	r0, r0, #0x2
7009a18e: 903b         	str	r0, [sp, #0xec]
7009a190: 983c         	ldr	r0, [sp, #0xf0]
7009a192: 3001         	adds	r0, #0x1
7009a194: 903c         	str	r0, [sp, #0xf0]
7009a196: 2001         	movs	r0, #0x1
7009a198: 9038         	str	r0, [sp, #0xe0]
7009a19a: e020         	b	0x7009a1de <_vsnprintf+0xfe> @ imm = #0x40
;         case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
7009a19c: 983b         	ldr	r0, [sp, #0xec]
7009a19e: f040 0004    	orr	r0, r0, #0x4
7009a1a2: 903b         	str	r0, [sp, #0xec]
7009a1a4: 983c         	ldr	r0, [sp, #0xf0]
7009a1a6: 3001         	adds	r0, #0x1
7009a1a8: 903c         	str	r0, [sp, #0xf0]
7009a1aa: 2001         	movs	r0, #0x1
7009a1ac: 9038         	str	r0, [sp, #0xe0]
7009a1ae: e016         	b	0x7009a1de <_vsnprintf+0xfe> @ imm = #0x2c
;         case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
7009a1b0: 983b         	ldr	r0, [sp, #0xec]
7009a1b2: f040 0008    	orr	r0, r0, #0x8
7009a1b6: 903b         	str	r0, [sp, #0xec]
7009a1b8: 983c         	ldr	r0, [sp, #0xf0]
7009a1ba: 3001         	adds	r0, #0x1
7009a1bc: 903c         	str	r0, [sp, #0xf0]
7009a1be: 2001         	movs	r0, #0x1
7009a1c0: 9038         	str	r0, [sp, #0xe0]
7009a1c2: e00c         	b	0x7009a1de <_vsnprintf+0xfe> @ imm = #0x18
;         case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
7009a1c4: 983b         	ldr	r0, [sp, #0xec]
7009a1c6: f040 0010    	orr	r0, r0, #0x10
7009a1ca: 903b         	str	r0, [sp, #0xec]
7009a1cc: 983c         	ldr	r0, [sp, #0xf0]
7009a1ce: 3001         	adds	r0, #0x1
7009a1d0: 903c         	str	r0, [sp, #0xf0]
7009a1d2: 2001         	movs	r0, #0x1
7009a1d4: 9038         	str	r0, [sp, #0xe0]
7009a1d6: e002         	b	0x7009a1de <_vsnprintf+0xfe> @ imm = #0x4
7009a1d8: 2000         	movs	r0, #0x0
;         default :                                   n = 0U; break;
7009a1da: 9038         	str	r0, [sp, #0xe0]
7009a1dc: e7ff         	b	0x7009a1de <_vsnprintf+0xfe> @ imm = #-0x2
;     } while (n);
7009a1de: e7ff         	b	0x7009a1e0 <_vsnprintf+0x100> @ imm = #-0x2
7009a1e0: 9838         	ldr	r0, [sp, #0xe0]
7009a1e2: 2800         	cmp	r0, #0x0
7009a1e4: d1b3         	bne	0x7009a14e <_vsnprintf+0x6e> @ imm = #-0x9a
7009a1e6: e7ff         	b	0x7009a1e8 <_vsnprintf+0x108> @ imm = #-0x2
7009a1e8: 2000         	movs	r0, #0x0
;     width = 0U;
7009a1ea: 903a         	str	r0, [sp, #0xe8]
;     if (_is_digit(*format)) {
7009a1ec: 983c         	ldr	r0, [sp, #0xf0]
7009a1ee: 7800         	ldrb	r0, [r0]
7009a1f0: f014 fbf6    	bl	0x700ae9e0 <_is_digit>  @ imm = #0x147ec
7009a1f4: b128         	cbz	r0, 0x7009a202 <_vsnprintf+0x122> @ imm = #0xa
7009a1f6: e7ff         	b	0x7009a1f8 <_vsnprintf+0x118> @ imm = #-0x2
7009a1f8: a83c         	add	r0, sp, #0xf0
;       width = _atoi(&format);
7009a1fa: f014 f809    	bl	0x700ae210 <_atoi>      @ imm = #0x14012
7009a1fe: 903a         	str	r0, [sp, #0xe8]
;     }
7009a200: e01e         	b	0x7009a240 <_vsnprintf+0x160> @ imm = #0x3c
;     else if (*format == '*') {
7009a202: 983c         	ldr	r0, [sp, #0xf0]
7009a204: 7800         	ldrb	r0, [r0]
7009a206: 282a         	cmp	r0, #0x2a
7009a208: d119         	bne	0x7009a23e <_vsnprintf+0x15e> @ imm = #0x32
7009a20a: e7ff         	b	0x7009a20c <_vsnprintf+0x12c> @ imm = #-0x2
;       const int w = va_arg(va, int);
7009a20c: 9840         	ldr	r0, [sp, #0x100]
7009a20e: 1d01         	adds	r1, r0, #0x4
7009a210: 9140         	str	r1, [sp, #0x100]
7009a212: 6800         	ldr	r0, [r0]
7009a214: 9036         	str	r0, [sp, #0xd8]
;       if (w < 0) {
7009a216: 9836         	ldr	r0, [sp, #0xd8]
7009a218: f1b0 3fff    	cmp.w	r0, #0xffffffff
7009a21c: dc08         	bgt	0x7009a230 <_vsnprintf+0x150> @ imm = #0x10
7009a21e: e7ff         	b	0x7009a220 <_vsnprintf+0x140> @ imm = #-0x2
;         flags |= FLAGS_LEFT;    // reverse padding
7009a220: 983b         	ldr	r0, [sp, #0xec]
7009a222: f040 0002    	orr	r0, r0, #0x2
7009a226: 903b         	str	r0, [sp, #0xec]
;         width = (unsigned int)-w;
7009a228: 9836         	ldr	r0, [sp, #0xd8]
7009a22a: 4240         	rsbs	r0, r0, #0
7009a22c: 903a         	str	r0, [sp, #0xe8]
;       }
7009a22e: e002         	b	0x7009a236 <_vsnprintf+0x156> @ imm = #0x4
;         width = (unsigned int)w;
7009a230: 9836         	ldr	r0, [sp, #0xd8]
7009a232: 903a         	str	r0, [sp, #0xe8]
7009a234: e7ff         	b	0x7009a236 <_vsnprintf+0x156> @ imm = #-0x2
;       format++;
7009a236: 983c         	ldr	r0, [sp, #0xf0]
7009a238: 3001         	adds	r0, #0x1
7009a23a: 903c         	str	r0, [sp, #0xf0]
;     }
7009a23c: e7ff         	b	0x7009a23e <_vsnprintf+0x15e> @ imm = #-0x2
7009a23e: e7ff         	b	0x7009a240 <_vsnprintf+0x160> @ imm = #-0x2
7009a240: 2000         	movs	r0, #0x0
;     precision = 0U;
7009a242: 9039         	str	r0, [sp, #0xe4]
;     if (*format == '.') {
7009a244: 983c         	ldr	r0, [sp, #0xf0]
7009a246: 7800         	ldrb	r0, [r0]
7009a248: 282e         	cmp	r0, #0x2e
7009a24a: d12e         	bne	0x7009a2aa <_vsnprintf+0x1ca> @ imm = #0x5c
7009a24c: e7ff         	b	0x7009a24e <_vsnprintf+0x16e> @ imm = #-0x2
;       flags |= FLAGS_PRECISION;
7009a24e: 983b         	ldr	r0, [sp, #0xec]
7009a250: f440 6080    	orr	r0, r0, #0x400
7009a254: 903b         	str	r0, [sp, #0xec]
;       format++;
7009a256: 983c         	ldr	r0, [sp, #0xf0]
7009a258: 3001         	adds	r0, #0x1
7009a25a: 903c         	str	r0, [sp, #0xf0]
;       if (_is_digit(*format)) {
7009a25c: 983c         	ldr	r0, [sp, #0xf0]
7009a25e: 7800         	ldrb	r0, [r0]
7009a260: f014 fbbe    	bl	0x700ae9e0 <_is_digit>  @ imm = #0x1477c
7009a264: b128         	cbz	r0, 0x7009a272 <_vsnprintf+0x192> @ imm = #0xa
7009a266: e7ff         	b	0x7009a268 <_vsnprintf+0x188> @ imm = #-0x2
7009a268: a83c         	add	r0, sp, #0xf0
;         precision = _atoi(&format);
7009a26a: f013 ffd1    	bl	0x700ae210 <_atoi>      @ imm = #0x13fa2
7009a26e: 9039         	str	r0, [sp, #0xe4]
;       }
7009a270: e01a         	b	0x7009a2a8 <_vsnprintf+0x1c8> @ imm = #0x34
;       else if (*format == '*') {
7009a272: 983c         	ldr	r0, [sp, #0xf0]
7009a274: 7800         	ldrb	r0, [r0]
7009a276: 282a         	cmp	r0, #0x2a
7009a278: d115         	bne	0x7009a2a6 <_vsnprintf+0x1c6> @ imm = #0x2a
7009a27a: e7ff         	b	0x7009a27c <_vsnprintf+0x19c> @ imm = #-0x2
;         const int prec = (int)va_arg(va, int);
7009a27c: 9840         	ldr	r0, [sp, #0x100]
7009a27e: 1d01         	adds	r1, r0, #0x4
7009a280: 9140         	str	r1, [sp, #0x100]
7009a282: 6800         	ldr	r0, [r0]
7009a284: 9035         	str	r0, [sp, #0xd4]
;         precision = prec > 0 ? (unsigned int)prec : 0U;
7009a286: 9835         	ldr	r0, [sp, #0xd4]
7009a288: 2801         	cmp	r0, #0x1
7009a28a: db03         	blt	0x7009a294 <_vsnprintf+0x1b4> @ imm = #0x6
7009a28c: e7ff         	b	0x7009a28e <_vsnprintf+0x1ae> @ imm = #-0x2
7009a28e: 9835         	ldr	r0, [sp, #0xd4]
7009a290: 9029         	str	r0, [sp, #0xa4]
7009a292: e002         	b	0x7009a29a <_vsnprintf+0x1ba> @ imm = #0x4
7009a294: 2000         	movs	r0, #0x0
;         precision = prec > 0 ? (unsigned int)prec : 0U;
7009a296: 9029         	str	r0, [sp, #0xa4]
7009a298: e7ff         	b	0x7009a29a <_vsnprintf+0x1ba> @ imm = #-0x2
7009a29a: 9829         	ldr	r0, [sp, #0xa4]
7009a29c: 9039         	str	r0, [sp, #0xe4]
;         format++;
7009a29e: 983c         	ldr	r0, [sp, #0xf0]
7009a2a0: 3001         	adds	r0, #0x1
7009a2a2: 903c         	str	r0, [sp, #0xf0]
;       }
7009a2a4: e7ff         	b	0x7009a2a6 <_vsnprintf+0x1c6> @ imm = #-0x2
7009a2a6: e7ff         	b	0x7009a2a8 <_vsnprintf+0x1c8> @ imm = #-0x2
;     }
7009a2a8: e7ff         	b	0x7009a2aa <_vsnprintf+0x1ca> @ imm = #-0x2
;     switch (*format) {
7009a2aa: 983c         	ldr	r0, [sp, #0xf0]
7009a2ac: 7800         	ldrb	r0, [r0]
7009a2ae: 3868         	subs	r0, #0x68
7009a2b0: 4601         	mov	r1, r0
7009a2b2: 9128         	str	r1, [sp, #0xa0]
7009a2b4: 2812         	cmp	r0, #0x12
7009a2b6: d84e         	bhi	0x7009a356 <_vsnprintf+0x276> @ imm = #0x9c
7009a2b8: 9928         	ldr	r1, [sp, #0xa0]
7009a2ba: e8df f001    	tbb	[pc, r1]
7009a2be: 1f 4c 3c 4c  	.word	0x4c3c4c1f
7009a2c2: 0a 4c 4c 4c  	.word	0x4c4c4c0a
7009a2c6: 4c 4c 4c 4c  	.word	0x4c4c4c4c
7009a2ca: 34 4c 4c 4c  	.word	0x4c4c4c34
7009a2ce: 4c 4c 44 00  	.word	0x00444c4c
;         flags |= FLAGS_LONG;
7009a2d2: 983b         	ldr	r0, [sp, #0xec]
7009a2d4: f440 7080    	orr	r0, r0, #0x100
7009a2d8: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a2da: 983c         	ldr	r0, [sp, #0xf0]
7009a2dc: 3001         	adds	r0, #0x1
7009a2de: 903c         	str	r0, [sp, #0xf0]
;         if (*format == 'l') {
7009a2e0: 983c         	ldr	r0, [sp, #0xf0]
7009a2e2: 7800         	ldrb	r0, [r0]
7009a2e4: 286c         	cmp	r0, #0x6c
7009a2e6: d108         	bne	0x7009a2fa <_vsnprintf+0x21a> @ imm = #0x10
7009a2e8: e7ff         	b	0x7009a2ea <_vsnprintf+0x20a> @ imm = #-0x2
;           flags |= FLAGS_LONG_LONG;
7009a2ea: 983b         	ldr	r0, [sp, #0xec]
7009a2ec: f440 7000    	orr	r0, r0, #0x200
7009a2f0: 903b         	str	r0, [sp, #0xec]
;           format++;
7009a2f2: 983c         	ldr	r0, [sp, #0xf0]
7009a2f4: 3001         	adds	r0, #0x1
7009a2f6: 903c         	str	r0, [sp, #0xf0]
;         }
7009a2f8: e7ff         	b	0x7009a2fa <_vsnprintf+0x21a> @ imm = #-0x2
;         break;
7009a2fa: e02d         	b	0x7009a358 <_vsnprintf+0x278> @ imm = #0x5a
;         flags |= FLAGS_SHORT;
7009a2fc: 983b         	ldr	r0, [sp, #0xec]
7009a2fe: f040 0080    	orr	r0, r0, #0x80
7009a302: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a304: 983c         	ldr	r0, [sp, #0xf0]
7009a306: 3001         	adds	r0, #0x1
7009a308: 903c         	str	r0, [sp, #0xf0]
;         if (*format == 'h') {
7009a30a: 983c         	ldr	r0, [sp, #0xf0]
7009a30c: 7800         	ldrb	r0, [r0]
7009a30e: 2868         	cmp	r0, #0x68
7009a310: d108         	bne	0x7009a324 <_vsnprintf+0x244> @ imm = #0x10
7009a312: e7ff         	b	0x7009a314 <_vsnprintf+0x234> @ imm = #-0x2
;           flags |= FLAGS_CHAR;
7009a314: 983b         	ldr	r0, [sp, #0xec]
7009a316: f040 0040    	orr	r0, r0, #0x40
7009a31a: 903b         	str	r0, [sp, #0xec]
;           format++;
7009a31c: 983c         	ldr	r0, [sp, #0xf0]
7009a31e: 3001         	adds	r0, #0x1
7009a320: 903c         	str	r0, [sp, #0xf0]
;         }
7009a322: e7ff         	b	0x7009a324 <_vsnprintf+0x244> @ imm = #-0x2
;         break;
7009a324: e018         	b	0x7009a358 <_vsnprintf+0x278> @ imm = #0x30
;         flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
7009a326: 983b         	ldr	r0, [sp, #0xec]
7009a328: f440 7080    	orr	r0, r0, #0x100
7009a32c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a32e: 983c         	ldr	r0, [sp, #0xf0]
7009a330: 3001         	adds	r0, #0x1
7009a332: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a334: e010         	b	0x7009a358 <_vsnprintf+0x278> @ imm = #0x20
;         flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
7009a336: 983b         	ldr	r0, [sp, #0xec]
7009a338: f440 7000    	orr	r0, r0, #0x200
7009a33c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a33e: 983c         	ldr	r0, [sp, #0xf0]
7009a340: 3001         	adds	r0, #0x1
7009a342: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a344: e008         	b	0x7009a358 <_vsnprintf+0x278> @ imm = #0x10
;         flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
7009a346: 983b         	ldr	r0, [sp, #0xec]
7009a348: f440 7080    	orr	r0, r0, #0x100
7009a34c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a34e: 983c         	ldr	r0, [sp, #0xf0]
7009a350: 3001         	adds	r0, #0x1
7009a352: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a354: e000         	b	0x7009a358 <_vsnprintf+0x278> @ imm = #0x0
;         break;
7009a356: e7ff         	b	0x7009a358 <_vsnprintf+0x278> @ imm = #-0x2
;     switch (*format) {
7009a358: 983c         	ldr	r0, [sp, #0xf0]
7009a35a: 7800         	ldrb	r0, [r0]
7009a35c: 3825         	subs	r0, #0x25
7009a35e: 4601         	mov	r1, r0
7009a360: 9127         	str	r1, [sp, #0x9c]
7009a362: 2853         	cmp	r0, #0x53
7009a364: f200 83ab    	bhi.w	0x7009aabe <_vsnprintf+0x9de> @ imm = #0x756
7009a368: 9927         	ldr	r1, [sp, #0x9c]
7009a36a: e8df f011    	tbh	[pc, r1, lsl #1]
7009a36e: 9b 03 a8 03  	.word	0x03a8039b
7009a372: a8 03 a8 03  	.word	0x03a803a8
7009a376: a8 03 a8 03  	.word	0x03a803a8
7009a37a: a8 03 a8 03  	.word	0x03a803a8
7009a37e: a8 03 a8 03  	.word	0x03a803a8
7009a382: a8 03 a8 03  	.word	0x03a803a8
7009a386: a8 03 a8 03  	.word	0x03a803a8
7009a38a: a8 03 a8 03  	.word	0x03a803a8
7009a38e: a8 03 a8 03  	.word	0x03a803a8
7009a392: a8 03 a8 03  	.word	0x03a803a8
7009a396: a8 03 a8 03  	.word	0x03a803a8
7009a39a: a8 03 a8 03  	.word	0x03a803a8
7009a39e: a8 03 a8 03  	.word	0x03a803a8
7009a3a2: a8 03 a8 03  	.word	0x03a803a8
7009a3a6: a8 03 a8 03  	.word	0x03a803a8
7009a3aa: a8 03 a8 03  	.word	0x03a803a8
7009a3ae: 5e 02 32 02  	.word	0x0232025e
7009a3b2: 5e 02 a8 03  	.word	0x03a8025e
7009a3b6: a8 03 a8 03  	.word	0x03a803a8
7009a3ba: a8 03 a8 03  	.word	0x03a803a8
7009a3be: a8 03 a8 03  	.word	0x03a803a8
7009a3c2: a8 03 a8 03  	.word	0x03a803a8
7009a3c6: a8 03 a8 03  	.word	0x03a803a8
7009a3ca: a8 03 a8 03  	.word	0x03a803a8
7009a3ce: a8 03 a8 03  	.word	0x03a803a8
7009a3d2: a8 03 54 00  	.word	0x005403a8
7009a3d6: a8 03 a8 03  	.word	0x03a803a8
7009a3da: a8 03 a8 03  	.word	0x03a803a8
7009a3de: a8 03 a8 03  	.word	0x03a803a8
7009a3e2: a8 03 a8 03  	.word	0x03a803a8
7009a3e6: a8 03 54 00  	.word	0x005403a8
7009a3ea: 9e 02 54 00  	.word	0x0054029e
7009a3ee: 5e 02 32 02  	.word	0x0232025e
7009a3f2: 5e 02 a8 03  	.word	0x03a8025e
7009a3f6: 54 00 a8 03  	.word	0x03a80054
7009a3fa: a8 03 a8 03  	.word	0x03a803a8
7009a3fe: a8 03 a8 03  	.word	0x03a803a8
7009a402: 54 00 6e 03  	.word	0x036e0054
7009a406: a8 03 a8 03  	.word	0x03a803a8
7009a40a: e2 02 a8 03  	.word	0x03a802e2
7009a40e: 54 00 a8 03  	.word	0x03a80054
7009a412: a8 03 54 00  	.word	0x005403a8
;         if (*format == 'x' || *format == 'X') {
7009a416: 983c         	ldr	r0, [sp, #0xf0]
7009a418: 7800         	ldrb	r0, [r0]
7009a41a: 2878         	cmp	r0, #0x78
7009a41c: d005         	beq	0x7009a42a <_vsnprintf+0x34a> @ imm = #0xa
7009a41e: e7ff         	b	0x7009a420 <_vsnprintf+0x340> @ imm = #-0x2
7009a420: 983c         	ldr	r0, [sp, #0xf0]
7009a422: 7800         	ldrb	r0, [r0]
7009a424: 2858         	cmp	r0, #0x58
7009a426: d103         	bne	0x7009a430 <_vsnprintf+0x350> @ imm = #0x6
7009a428: e7ff         	b	0x7009a42a <_vsnprintf+0x34a> @ imm = #-0x2
7009a42a: 2010         	movs	r0, #0x10
;           base = 16U;
7009a42c: 9034         	str	r0, [sp, #0xd0]
;         }
7009a42e: e018         	b	0x7009a462 <_vsnprintf+0x382> @ imm = #0x30
;         else if (*format == 'o') {
7009a430: 983c         	ldr	r0, [sp, #0xf0]
7009a432: 7800         	ldrb	r0, [r0]
7009a434: 286f         	cmp	r0, #0x6f
7009a436: d103         	bne	0x7009a440 <_vsnprintf+0x360> @ imm = #0x6
7009a438: e7ff         	b	0x7009a43a <_vsnprintf+0x35a> @ imm = #-0x2
7009a43a: 2008         	movs	r0, #0x8
;           base =  8U;
7009a43c: 9034         	str	r0, [sp, #0xd0]
;         }
7009a43e: e00f         	b	0x7009a460 <_vsnprintf+0x380> @ imm = #0x1e
;         else if (*format == 'b') {
7009a440: 983c         	ldr	r0, [sp, #0xf0]
7009a442: 7800         	ldrb	r0, [r0]
7009a444: 2862         	cmp	r0, #0x62
7009a446: d103         	bne	0x7009a450 <_vsnprintf+0x370> @ imm = #0x6
7009a448: e7ff         	b	0x7009a44a <_vsnprintf+0x36a> @ imm = #-0x2
7009a44a: 2002         	movs	r0, #0x2
;           base =  2U;
7009a44c: 9034         	str	r0, [sp, #0xd0]
;         }
7009a44e: e006         	b	0x7009a45e <_vsnprintf+0x37e> @ imm = #0xc
7009a450: 200a         	movs	r0, #0xa
;           base = 10U;
7009a452: 9034         	str	r0, [sp, #0xd0]
;           flags &= ~FLAGS_HASH;   // no hash for dec format
7009a454: 983b         	ldr	r0, [sp, #0xec]
7009a456: f020 0010    	bic	r0, r0, #0x10
7009a45a: 903b         	str	r0, [sp, #0xec]
7009a45c: e7ff         	b	0x7009a45e <_vsnprintf+0x37e> @ imm = #-0x2
7009a45e: e7ff         	b	0x7009a460 <_vsnprintf+0x380> @ imm = #-0x2
7009a460: e7ff         	b	0x7009a462 <_vsnprintf+0x382> @ imm = #-0x2
;         if (*format == 'X') {
7009a462: 983c         	ldr	r0, [sp, #0xf0]
7009a464: 7800         	ldrb	r0, [r0]
7009a466: 2858         	cmp	r0, #0x58
7009a468: d105         	bne	0x7009a476 <_vsnprintf+0x396> @ imm = #0xa
7009a46a: e7ff         	b	0x7009a46c <_vsnprintf+0x38c> @ imm = #-0x2
;           flags |= FLAGS_UPPERCASE;
7009a46c: 983b         	ldr	r0, [sp, #0xec]
7009a46e: f040 0020    	orr	r0, r0, #0x20
7009a472: 903b         	str	r0, [sp, #0xec]
;         }
7009a474: e7ff         	b	0x7009a476 <_vsnprintf+0x396> @ imm = #-0x2
;         if ((*format != 'i') && (*format != 'd')) {
7009a476: 983c         	ldr	r0, [sp, #0xf0]
7009a478: 7800         	ldrb	r0, [r0]
7009a47a: 2869         	cmp	r0, #0x69
7009a47c: d00a         	beq	0x7009a494 <_vsnprintf+0x3b4> @ imm = #0x14
7009a47e: e7ff         	b	0x7009a480 <_vsnprintf+0x3a0> @ imm = #-0x2
7009a480: 983c         	ldr	r0, [sp, #0xf0]
7009a482: 7800         	ldrb	r0, [r0]
7009a484: 2864         	cmp	r0, #0x64
7009a486: d005         	beq	0x7009a494 <_vsnprintf+0x3b4> @ imm = #0xa
7009a488: e7ff         	b	0x7009a48a <_vsnprintf+0x3aa> @ imm = #-0x2
;           flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
7009a48a: 983b         	ldr	r0, [sp, #0xec]
7009a48c: f020 000c    	bic	r0, r0, #0xc
7009a490: 903b         	str	r0, [sp, #0xec]
;         }
7009a492: e7ff         	b	0x7009a494 <_vsnprintf+0x3b4> @ imm = #-0x2
;         if (flags & FLAGS_PRECISION) {
7009a494: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a498: 0740         	lsls	r0, r0, #0x1d
7009a49a: 2800         	cmp	r0, #0x0
7009a49c: d505         	bpl	0x7009a4aa <_vsnprintf+0x3ca> @ imm = #0xa
7009a49e: e7ff         	b	0x7009a4a0 <_vsnprintf+0x3c0> @ imm = #-0x2
;           flags &= ~FLAGS_ZEROPAD;
7009a4a0: 983b         	ldr	r0, [sp, #0xec]
7009a4a2: f020 0001    	bic	r0, r0, #0x1
7009a4a6: 903b         	str	r0, [sp, #0xec]
;         }
7009a4a8: e7ff         	b	0x7009a4aa <_vsnprintf+0x3ca> @ imm = #-0x2
;         if ((*format == 'i') || (*format == 'd')) {
7009a4aa: 983c         	ldr	r0, [sp, #0xf0]
7009a4ac: 7800         	ldrb	r0, [r0]
7009a4ae: 2869         	cmp	r0, #0x69
7009a4b0: d006         	beq	0x7009a4c0 <_vsnprintf+0x3e0> @ imm = #0xc
7009a4b2: e7ff         	b	0x7009a4b4 <_vsnprintf+0x3d4> @ imm = #-0x2
7009a4b4: 983c         	ldr	r0, [sp, #0xf0]
7009a4b6: 7800         	ldrb	r0, [r0]
7009a4b8: 2864         	cmp	r0, #0x64
7009a4ba: f040 80e9    	bne.w	0x7009a690 <_vsnprintf+0x5b0> @ imm = #0x1d2
7009a4be: e7ff         	b	0x7009a4c0 <_vsnprintf+0x3e0> @ imm = #-0x2
;           if (flags & FLAGS_LONG_LONG) {
7009a4c0: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a4c4: 0780         	lsls	r0, r0, #0x1e
7009a4c6: 2800         	cmp	r0, #0x0
7009a4c8: d550         	bpl	0x7009a56c <_vsnprintf+0x48c> @ imm = #0xa0
7009a4ca: e7ff         	b	0x7009a4cc <_vsnprintf+0x3ec> @ imm = #-0x2
;             const long long value = va_arg(va, long long);
7009a4cc: 9840         	ldr	r0, [sp, #0x100]
7009a4ce: 3007         	adds	r0, #0x7
7009a4d0: f020 0107    	bic	r1, r0, #0x7
7009a4d4: f101 0008    	add.w	r0, r1, #0x8
7009a4d8: 9040         	str	r0, [sp, #0x100]
7009a4da: 6808         	ldr	r0, [r1]
7009a4dc: 6849         	ldr	r1, [r1, #0x4]
7009a4de: 9133         	str	r1, [sp, #0xcc]
7009a4e0: 9032         	str	r0, [sp, #0xc8]
;             idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009a4e2: 983f         	ldr	r0, [sp, #0xfc]
7009a4e4: 9023         	str	r0, [sp, #0x8c]
7009a4e6: 983e         	ldr	r0, [sp, #0xf8]
7009a4e8: 9024         	str	r0, [sp, #0x90]
7009a4ea: 9837         	ldr	r0, [sp, #0xdc]
7009a4ec: 9025         	str	r0, [sp, #0x94]
7009a4ee: 983d         	ldr	r0, [sp, #0xf4]
7009a4f0: 9026         	str	r0, [sp, #0x98]
7009a4f2: 9932         	ldr	r1, [sp, #0xc8]
7009a4f4: 9833         	ldr	r0, [sp, #0xcc]
7009a4f6: 3901         	subs	r1, #0x1
7009a4f8: f170 0000    	sbcs	r0, r0, #0x0
7009a4fc: db05         	blt	0x7009a50a <_vsnprintf+0x42a> @ imm = #0xa
7009a4fe: e7ff         	b	0x7009a500 <_vsnprintf+0x420> @ imm = #-0x2
7009a500: 9932         	ldr	r1, [sp, #0xc8]
7009a502: 9833         	ldr	r0, [sp, #0xcc]
7009a504: 9121         	str	r1, [sp, #0x84]
7009a506: 9022         	str	r0, [sp, #0x88]
7009a508: e008         	b	0x7009a51c <_vsnprintf+0x43c> @ imm = #0x10
7009a50a: 9832         	ldr	r0, [sp, #0xc8]
7009a50c: 9a33         	ldr	r2, [sp, #0xcc]
7009a50e: 4241         	rsbs	r1, r0, #0
7009a510: f04f 0000    	mov.w	r0, #0x0
7009a514: 4190         	sbcs	r0, r2
7009a516: 9121         	str	r1, [sp, #0x84]
7009a518: 9022         	str	r0, [sp, #0x88]
7009a51a: e7ff         	b	0x7009a51c <_vsnprintf+0x43c> @ imm = #-0x2
7009a51c: 9b26         	ldr	r3, [sp, #0x98]
7009a51e: 9a25         	ldr	r2, [sp, #0x94]
7009a520: 9924         	ldr	r1, [sp, #0x90]
7009a522: 9823         	ldr	r0, [sp, #0x8c]
7009a524: f8dd c084    	ldr.w	r12, [sp, #0x84]
7009a528: 9c22         	ldr	r4, [sp, #0x88]
7009a52a: 9d33         	ldr	r5, [sp, #0xcc]
7009a52c: 9e34         	ldr	r6, [sp, #0xd0]
7009a52e: 9f39         	ldr	r7, [sp, #0xe4]
7009a530: f8dd 80e8    	ldr.w	r8, [sp, #0xe8]
7009a534: f8dd 90ec    	ldr.w	r9, [sp, #0xec]
7009a538: 46ee         	mov	lr, sp
7009a53a: f8cd e080    	str.w	lr, [sp, #0x80]
7009a53e: f8ce 9020    	str.w	r9, [lr, #0x20]
7009a542: f8ce 801c    	str.w	r8, [lr, #0x1c]
7009a546: f8ce 7018    	str.w	r7, [lr, #0x18]
7009a54a: 2700         	movs	r7, #0x0
7009a54c: f8ce 7014    	str.w	r7, [lr, #0x14]
7009a550: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a554: ea4f 75d5    	lsr.w	r5, r5, #0x1f
7009a558: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a55c: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a560: f8ce c000    	str.w	r12, [lr]
7009a564: f008 fbbc    	bl	0x700a2ce0 <_ntoa_long_long> @ imm = #0x8778
7009a568: 9037         	str	r0, [sp, #0xdc]
;           }
7009a56a: e090         	b	0x7009a68e <_vsnprintf+0x5ae> @ imm = #0x120
;           else if (flags & FLAGS_LONG) {
7009a56c: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a570: 07c0         	lsls	r0, r0, #0x1f
7009a572: b3b0         	cbz	r0, 0x7009a5e2 <_vsnprintf+0x502> @ imm = #0x6c
7009a574: e7ff         	b	0x7009a576 <_vsnprintf+0x496> @ imm = #-0x2
;             const long value = va_arg(va, long);
7009a576: 9840         	ldr	r0, [sp, #0x100]
7009a578: 1d01         	adds	r1, r0, #0x4
7009a57a: 9140         	str	r1, [sp, #0x100]
7009a57c: 6800         	ldr	r0, [r0]
7009a57e: 9031         	str	r0, [sp, #0xc4]
;             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009a580: 983f         	ldr	r0, [sp, #0xfc]
7009a582: 901c         	str	r0, [sp, #0x70]
7009a584: 983e         	ldr	r0, [sp, #0xf8]
7009a586: 901d         	str	r0, [sp, #0x74]
7009a588: 9837         	ldr	r0, [sp, #0xdc]
7009a58a: 901e         	str	r0, [sp, #0x78]
7009a58c: 983d         	ldr	r0, [sp, #0xf4]
7009a58e: 901f         	str	r0, [sp, #0x7c]
7009a590: 9831         	ldr	r0, [sp, #0xc4]
7009a592: 2801         	cmp	r0, #0x1
7009a594: db03         	blt	0x7009a59e <_vsnprintf+0x4be> @ imm = #0x6
7009a596: e7ff         	b	0x7009a598 <_vsnprintf+0x4b8> @ imm = #-0x2
7009a598: 9831         	ldr	r0, [sp, #0xc4]
7009a59a: 901b         	str	r0, [sp, #0x6c]
7009a59c: e003         	b	0x7009a5a6 <_vsnprintf+0x4c6> @ imm = #0x6
7009a59e: 9831         	ldr	r0, [sp, #0xc4]
7009a5a0: 4240         	rsbs	r0, r0, #0
7009a5a2: 901b         	str	r0, [sp, #0x6c]
7009a5a4: e7ff         	b	0x7009a5a6 <_vsnprintf+0x4c6> @ imm = #-0x2
7009a5a6: 9b1f         	ldr	r3, [sp, #0x7c]
7009a5a8: 9a1e         	ldr	r2, [sp, #0x78]
7009a5aa: 991d         	ldr	r1, [sp, #0x74]
7009a5ac: 981c         	ldr	r0, [sp, #0x70]
7009a5ae: f8dd c06c    	ldr.w	r12, [sp, #0x6c]
7009a5b2: 9c31         	ldr	r4, [sp, #0xc4]
7009a5b4: 9d34         	ldr	r5, [sp, #0xd0]
7009a5b6: 9e39         	ldr	r6, [sp, #0xe4]
7009a5b8: 9f3a         	ldr	r7, [sp, #0xe8]
7009a5ba: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
7009a5be: 46ee         	mov	lr, sp
7009a5c0: f8ce 8014    	str.w	r8, [lr, #0x14]
7009a5c4: f8ce 7010    	str.w	r7, [lr, #0x10]
7009a5c8: f8ce 600c    	str.w	r6, [lr, #0xc]
7009a5cc: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a5d0: 0fe4         	lsrs	r4, r4, #0x1f
7009a5d2: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a5d6: f8ce c000    	str.w	r12, [lr]
7009a5da: f00a fb59    	bl	0x700a4c90 <_ntoa_long> @ imm = #0xa6b2
7009a5de: 9037         	str	r0, [sp, #0xdc]
;           }
7009a5e0: e054         	b	0x7009a68c <_vsnprintf+0x5ac> @ imm = #0xa8
;             const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
7009a5e2: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a5e6: 0640         	lsls	r0, r0, #0x19
7009a5e8: 2800         	cmp	r0, #0x0
7009a5ea: d506         	bpl	0x7009a5fa <_vsnprintf+0x51a> @ imm = #0xc
7009a5ec: e7ff         	b	0x7009a5ee <_vsnprintf+0x50e> @ imm = #-0x2
7009a5ee: 9840         	ldr	r0, [sp, #0x100]
7009a5f0: 1d01         	adds	r1, r0, #0x4
7009a5f2: 9140         	str	r1, [sp, #0x100]
7009a5f4: 7800         	ldrb	r0, [r0]
7009a5f6: 901a         	str	r0, [sp, #0x68]
7009a5f8: e015         	b	0x7009a626 <_vsnprintf+0x546> @ imm = #0x2a
7009a5fa: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a5fe: 0600         	lsls	r0, r0, #0x18
7009a600: 2800         	cmp	r0, #0x0
7009a602: d507         	bpl	0x7009a614 <_vsnprintf+0x534> @ imm = #0xe
7009a604: e7ff         	b	0x7009a606 <_vsnprintf+0x526> @ imm = #-0x2
7009a606: 9840         	ldr	r0, [sp, #0x100]
7009a608: 1d01         	adds	r1, r0, #0x4
7009a60a: 9140         	str	r1, [sp, #0x100]
7009a60c: f9b0 0000    	ldrsh.w	r0, [r0]
7009a610: 9019         	str	r0, [sp, #0x64]
7009a612: e005         	b	0x7009a620 <_vsnprintf+0x540> @ imm = #0xa
7009a614: 9840         	ldr	r0, [sp, #0x100]
7009a616: 1d01         	adds	r1, r0, #0x4
7009a618: 9140         	str	r1, [sp, #0x100]
7009a61a: 6800         	ldr	r0, [r0]
7009a61c: 9019         	str	r0, [sp, #0x64]
7009a61e: e7ff         	b	0x7009a620 <_vsnprintf+0x540> @ imm = #-0x2
7009a620: 9819         	ldr	r0, [sp, #0x64]
7009a622: 901a         	str	r0, [sp, #0x68]
7009a624: e7ff         	b	0x7009a626 <_vsnprintf+0x546> @ imm = #-0x2
7009a626: 981a         	ldr	r0, [sp, #0x68]
7009a628: 9030         	str	r0, [sp, #0xc0]
;             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009a62a: 983f         	ldr	r0, [sp, #0xfc]
7009a62c: 9015         	str	r0, [sp, #0x54]
7009a62e: 983e         	ldr	r0, [sp, #0xf8]
7009a630: 9016         	str	r0, [sp, #0x58]
7009a632: 9837         	ldr	r0, [sp, #0xdc]
7009a634: 9017         	str	r0, [sp, #0x5c]
7009a636: 983d         	ldr	r0, [sp, #0xf4]
7009a638: 9018         	str	r0, [sp, #0x60]
7009a63a: 9830         	ldr	r0, [sp, #0xc0]
7009a63c: 2801         	cmp	r0, #0x1
7009a63e: db03         	blt	0x7009a648 <_vsnprintf+0x568> @ imm = #0x6
7009a640: e7ff         	b	0x7009a642 <_vsnprintf+0x562> @ imm = #-0x2
7009a642: 9830         	ldr	r0, [sp, #0xc0]
7009a644: 9014         	str	r0, [sp, #0x50]
7009a646: e003         	b	0x7009a650 <_vsnprintf+0x570> @ imm = #0x6
7009a648: 9830         	ldr	r0, [sp, #0xc0]
7009a64a: 4240         	rsbs	r0, r0, #0
7009a64c: 9014         	str	r0, [sp, #0x50]
7009a64e: e7ff         	b	0x7009a650 <_vsnprintf+0x570> @ imm = #-0x2
7009a650: 9b18         	ldr	r3, [sp, #0x60]
7009a652: 9a17         	ldr	r2, [sp, #0x5c]
7009a654: 9916         	ldr	r1, [sp, #0x58]
7009a656: 9815         	ldr	r0, [sp, #0x54]
7009a658: f8dd c050    	ldr.w	r12, [sp, #0x50]
7009a65c: 9c30         	ldr	r4, [sp, #0xc0]
7009a65e: 9d34         	ldr	r5, [sp, #0xd0]
7009a660: 9e39         	ldr	r6, [sp, #0xe4]
7009a662: 9f3a         	ldr	r7, [sp, #0xe8]
7009a664: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
7009a668: 46ee         	mov	lr, sp
7009a66a: f8ce 8014    	str.w	r8, [lr, #0x14]
7009a66e: f8ce 7010    	str.w	r7, [lr, #0x10]
7009a672: f8ce 600c    	str.w	r6, [lr, #0xc]
7009a676: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a67a: 0fe4         	lsrs	r4, r4, #0x1f
7009a67c: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a680: f8ce c000    	str.w	r12, [lr]
7009a684: f00a fb04    	bl	0x700a4c90 <_ntoa_long> @ imm = #0xa608
7009a688: 9037         	str	r0, [sp, #0xdc]
7009a68a: e7ff         	b	0x7009a68c <_vsnprintf+0x5ac> @ imm = #-0x2
7009a68c: e7ff         	b	0x7009a68e <_vsnprintf+0x5ae> @ imm = #-0x2
;         }
7009a68e: e09c         	b	0x7009a7ca <_vsnprintf+0x6ea> @ imm = #0x138
;           if (flags & FLAGS_LONG_LONG) {
7009a690: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a694: 0780         	lsls	r0, r0, #0x1e
7009a696: 2800         	cmp	r0, #0x0
7009a698: d52f         	bpl	0x7009a6fa <_vsnprintf+0x61a> @ imm = #0x5e
7009a69a: e7ff         	b	0x7009a69c <_vsnprintf+0x5bc> @ imm = #-0x2
;             idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
7009a69c: 983f         	ldr	r0, [sp, #0xfc]
7009a69e: 993e         	ldr	r1, [sp, #0xf8]
7009a6a0: 9a37         	ldr	r2, [sp, #0xdc]
7009a6a2: 9b3d         	ldr	r3, [sp, #0xf4]
7009a6a4: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a6a8: f10c 0c07    	add.w	r12, r12, #0x7
7009a6ac: f02c 0e07    	bic	lr, r12, #0x7
7009a6b0: f10e 0c08    	add.w	r12, lr, #0x8
7009a6b4: f8cd c100    	str.w	r12, [sp, #0x100]
7009a6b8: f8de c000    	ldr.w	r12, [lr]
7009a6bc: f8de 4004    	ldr.w	r4, [lr, #0x4]
7009a6c0: 9e34         	ldr	r6, [sp, #0xd0]
7009a6c2: 9d39         	ldr	r5, [sp, #0xe4]
7009a6c4: 9f3a         	ldr	r7, [sp, #0xe8]
7009a6c6: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
7009a6ca: 46ee         	mov	lr, sp
7009a6cc: f8cd e04c    	str.w	lr, [sp, #0x4c]
7009a6d0: f8ce 8020    	str.w	r8, [lr, #0x20]
7009a6d4: f8ce 701c    	str.w	r7, [lr, #0x1c]
7009a6d8: f8ce 5018    	str.w	r5, [lr, #0x18]
7009a6dc: 2500         	movs	r5, #0x0
7009a6de: f8ce 5014    	str.w	r5, [lr, #0x14]
7009a6e2: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a6e6: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a6ea: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a6ee: f8ce c000    	str.w	r12, [lr]
7009a6f2: f008 faf5    	bl	0x700a2ce0 <_ntoa_long_long> @ imm = #0x85ea
7009a6f6: 9037         	str	r0, [sp, #0xdc]
;           }
7009a6f8: e066         	b	0x7009a7c8 <_vsnprintf+0x6e8> @ imm = #0xcc
;           else if (flags & FLAGS_LONG) {
7009a6fa: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a6fe: 07c0         	lsls	r0, r0, #0x1f
7009a700: b310         	cbz	r0, 0x7009a748 <_vsnprintf+0x668> @ imm = #0x44
7009a702: e7ff         	b	0x7009a704 <_vsnprintf+0x624> @ imm = #-0x2
;             idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
7009a704: 983f         	ldr	r0, [sp, #0xfc]
7009a706: 993e         	ldr	r1, [sp, #0xf8]
7009a708: 9a37         	ldr	r2, [sp, #0xdc]
7009a70a: 9b3d         	ldr	r3, [sp, #0xf4]
7009a70c: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a710: f10c 0e04    	add.w	lr, r12, #0x4
7009a714: f8cd e100    	str.w	lr, [sp, #0x100]
7009a718: f8dc c000    	ldr.w	r12, [r12]
7009a71c: 9c34         	ldr	r4, [sp, #0xd0]
7009a71e: 9d39         	ldr	r5, [sp, #0xe4]
7009a720: 9e3a         	ldr	r6, [sp, #0xe8]
7009a722: 9f3b         	ldr	r7, [sp, #0xec]
7009a724: 46ee         	mov	lr, sp
7009a726: f8ce 7014    	str.w	r7, [lr, #0x14]
7009a72a: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a72e: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a732: f8ce 4008    	str.w	r4, [lr, #0x8]
7009a736: 2400         	movs	r4, #0x0
7009a738: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a73c: f8ce c000    	str.w	r12, [lr]
7009a740: f00a faa6    	bl	0x700a4c90 <_ntoa_long> @ imm = #0xa54c
7009a744: 9037         	str	r0, [sp, #0xdc]
;           }
7009a746: e03e         	b	0x7009a7c6 <_vsnprintf+0x6e6> @ imm = #0x7c
;             const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
7009a748: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a74c: 0640         	lsls	r0, r0, #0x19
7009a74e: 2800         	cmp	r0, #0x0
7009a750: d506         	bpl	0x7009a760 <_vsnprintf+0x680> @ imm = #0xc
7009a752: e7ff         	b	0x7009a754 <_vsnprintf+0x674> @ imm = #-0x2
7009a754: 9840         	ldr	r0, [sp, #0x100]
7009a756: 1d01         	adds	r1, r0, #0x4
7009a758: 9140         	str	r1, [sp, #0x100]
7009a75a: 7800         	ldrb	r0, [r0]
7009a75c: 9012         	str	r0, [sp, #0x48]
7009a75e: e014         	b	0x7009a78a <_vsnprintf+0x6aa> @ imm = #0x28
7009a760: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a764: 0600         	lsls	r0, r0, #0x18
7009a766: 2800         	cmp	r0, #0x0
7009a768: d506         	bpl	0x7009a778 <_vsnprintf+0x698> @ imm = #0xc
7009a76a: e7ff         	b	0x7009a76c <_vsnprintf+0x68c> @ imm = #-0x2
7009a76c: 9840         	ldr	r0, [sp, #0x100]
7009a76e: 1d01         	adds	r1, r0, #0x4
7009a770: 9140         	str	r1, [sp, #0x100]
7009a772: 8800         	ldrh	r0, [r0]
7009a774: 9011         	str	r0, [sp, #0x44]
7009a776: e005         	b	0x7009a784 <_vsnprintf+0x6a4> @ imm = #0xa
7009a778: 9840         	ldr	r0, [sp, #0x100]
7009a77a: 1d01         	adds	r1, r0, #0x4
7009a77c: 9140         	str	r1, [sp, #0x100]
7009a77e: 6800         	ldr	r0, [r0]
7009a780: 9011         	str	r0, [sp, #0x44]
7009a782: e7ff         	b	0x7009a784 <_vsnprintf+0x6a4> @ imm = #-0x2
7009a784: 9811         	ldr	r0, [sp, #0x44]
7009a786: 9012         	str	r0, [sp, #0x48]
7009a788: e7ff         	b	0x7009a78a <_vsnprintf+0x6aa> @ imm = #-0x2
7009a78a: 9812         	ldr	r0, [sp, #0x48]
7009a78c: 902f         	str	r0, [sp, #0xbc]
;             idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
7009a78e: 983f         	ldr	r0, [sp, #0xfc]
7009a790: 993e         	ldr	r1, [sp, #0xf8]
7009a792: 9a37         	ldr	r2, [sp, #0xdc]
7009a794: 9b3d         	ldr	r3, [sp, #0xf4]
7009a796: f8dd c0bc    	ldr.w	r12, [sp, #0xbc]
7009a79a: 9c34         	ldr	r4, [sp, #0xd0]
7009a79c: 9d39         	ldr	r5, [sp, #0xe4]
7009a79e: 9e3a         	ldr	r6, [sp, #0xe8]
7009a7a0: 9f3b         	ldr	r7, [sp, #0xec]
7009a7a2: 46ee         	mov	lr, sp
7009a7a4: f8ce 7014    	str.w	r7, [lr, #0x14]
7009a7a8: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a7ac: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a7b0: f8ce 4008    	str.w	r4, [lr, #0x8]
7009a7b4: 2400         	movs	r4, #0x0
7009a7b6: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a7ba: f8ce c000    	str.w	r12, [lr]
7009a7be: f00a fa67    	bl	0x700a4c90 <_ntoa_long> @ imm = #0xa4ce
7009a7c2: 9037         	str	r0, [sp, #0xdc]
7009a7c4: e7ff         	b	0x7009a7c6 <_vsnprintf+0x6e6> @ imm = #-0x2
7009a7c6: e7ff         	b	0x7009a7c8 <_vsnprintf+0x6e8> @ imm = #-0x2
7009a7c8: e7ff         	b	0x7009a7ca <_vsnprintf+0x6ea> @ imm = #-0x2
;         format++;
7009a7ca: 983c         	ldr	r0, [sp, #0xf0]
7009a7cc: 3001         	adds	r0, #0x1
7009a7ce: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a7d0: e183         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #0x306
;         if (*format == 'F') flags |= FLAGS_UPPERCASE;
7009a7d2: 983c         	ldr	r0, [sp, #0xf0]
7009a7d4: 7800         	ldrb	r0, [r0]
7009a7d6: 2846         	cmp	r0, #0x46
7009a7d8: d105         	bne	0x7009a7e6 <_vsnprintf+0x706> @ imm = #0xa
7009a7da: e7ff         	b	0x7009a7dc <_vsnprintf+0x6fc> @ imm = #-0x2
7009a7dc: 983b         	ldr	r0, [sp, #0xec]
7009a7de: f040 0020    	orr	r0, r0, #0x20
7009a7e2: 903b         	str	r0, [sp, #0xec]
7009a7e4: e7ff         	b	0x7009a7e6 <_vsnprintf+0x706> @ imm = #-0x2
;         idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
7009a7e6: 983f         	ldr	r0, [sp, #0xfc]
7009a7e8: 993e         	ldr	r1, [sp, #0xf8]
7009a7ea: 9a37         	ldr	r2, [sp, #0xdc]
7009a7ec: 9b3d         	ldr	r3, [sp, #0xf4]
7009a7ee: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a7f2: f10c 0c07    	add.w	r12, r12, #0x7
7009a7f6: f02c 0c07    	bic	r12, r12, #0x7
7009a7fa: f10c 0e08    	add.w	lr, r12, #0x8
7009a7fe: f8cd e100    	str.w	lr, [sp, #0x100]
7009a802: ed9c 0b00    	vldr	d0, [r12]
7009a806: f8dd c0e4    	ldr.w	r12, [sp, #0xe4]
7009a80a: 9c3a         	ldr	r4, [sp, #0xe8]
7009a80c: 9d3b         	ldr	r5, [sp, #0xec]
7009a80e: 46ee         	mov	lr, sp
7009a810: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a814: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a818: f8ce c000    	str.w	r12, [lr]
7009a81c: f000 fc80    	bl	0x7009b120 <_ftoa>      @ imm = #0x900
7009a820: 9037         	str	r0, [sp, #0xdc]
;         format++;
7009a822: 983c         	ldr	r0, [sp, #0xf0]
7009a824: 3001         	adds	r0, #0x1
7009a826: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a828: e157         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #0x2ae
;         if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
7009a82a: 983c         	ldr	r0, [sp, #0xf0]
7009a82c: 7800         	ldrb	r0, [r0]
7009a82e: 2867         	cmp	r0, #0x67
7009a830: d005         	beq	0x7009a83e <_vsnprintf+0x75e> @ imm = #0xa
7009a832: e7ff         	b	0x7009a834 <_vsnprintf+0x754> @ imm = #-0x2
7009a834: 983c         	ldr	r0, [sp, #0xf0]
7009a836: 7800         	ldrb	r0, [r0]
7009a838: 2847         	cmp	r0, #0x47
7009a83a: d105         	bne	0x7009a848 <_vsnprintf+0x768> @ imm = #0xa
7009a83c: e7ff         	b	0x7009a83e <_vsnprintf+0x75e> @ imm = #-0x2
7009a83e: 983b         	ldr	r0, [sp, #0xec]
7009a840: f440 6000    	orr	r0, r0, #0x800
7009a844: 903b         	str	r0, [sp, #0xec]
7009a846: e7ff         	b	0x7009a848 <_vsnprintf+0x768> @ imm = #-0x2
;         if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
7009a848: 983c         	ldr	r0, [sp, #0xf0]
7009a84a: 7800         	ldrb	r0, [r0]
7009a84c: 2845         	cmp	r0, #0x45
7009a84e: d005         	beq	0x7009a85c <_vsnprintf+0x77c> @ imm = #0xa
7009a850: e7ff         	b	0x7009a852 <_vsnprintf+0x772> @ imm = #-0x2
7009a852: 983c         	ldr	r0, [sp, #0xf0]
7009a854: 7800         	ldrb	r0, [r0]
7009a856: 2847         	cmp	r0, #0x47
7009a858: d105         	bne	0x7009a866 <_vsnprintf+0x786> @ imm = #0xa
7009a85a: e7ff         	b	0x7009a85c <_vsnprintf+0x77c> @ imm = #-0x2
7009a85c: 983b         	ldr	r0, [sp, #0xec]
7009a85e: f040 0020    	orr	r0, r0, #0x20
7009a862: 903b         	str	r0, [sp, #0xec]
7009a864: e7ff         	b	0x7009a866 <_vsnprintf+0x786> @ imm = #-0x2
;         idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
7009a866: 983f         	ldr	r0, [sp, #0xfc]
7009a868: 993e         	ldr	r1, [sp, #0xf8]
7009a86a: 9a37         	ldr	r2, [sp, #0xdc]
7009a86c: 9b3d         	ldr	r3, [sp, #0xf4]
7009a86e: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a872: f10c 0c07    	add.w	r12, r12, #0x7
7009a876: f02c 0c07    	bic	r12, r12, #0x7
7009a87a: f10c 0e08    	add.w	lr, r12, #0x8
7009a87e: f8cd e100    	str.w	lr, [sp, #0x100]
7009a882: ed9c 0b00    	vldr	d0, [r12]
7009a886: f8dd c0e4    	ldr.w	r12, [sp, #0xe4]
7009a88a: 9c3a         	ldr	r4, [sp, #0xe8]
7009a88c: 9d3b         	ldr	r5, [sp, #0xec]
7009a88e: 46ee         	mov	lr, sp
7009a890: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a894: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a898: f8ce c000    	str.w	r12, [lr]
7009a89c: f000 fed0    	bl	0x7009b640 <_etoa>      @ imm = #0xda0
7009a8a0: 9037         	str	r0, [sp, #0xdc]
;         format++;
7009a8a2: 983c         	ldr	r0, [sp, #0xf0]
7009a8a4: 3001         	adds	r0, #0x1
7009a8a6: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a8a8: e117         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #0x22e
7009a8aa: 2001         	movs	r0, #0x1
;         unsigned int l = 1U;
7009a8ac: 902e         	str	r0, [sp, #0xb8]
;         if (!(flags & FLAGS_LEFT)) {
7009a8ae: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a8b2: 0780         	lsls	r0, r0, #0x1e
7009a8b4: 2800         	cmp	r0, #0x0
7009a8b6: d413         	bmi	0x7009a8e0 <_vsnprintf+0x800> @ imm = #0x26
7009a8b8: e7ff         	b	0x7009a8ba <_vsnprintf+0x7da> @ imm = #-0x2
;           while (l++ < width) {
7009a8ba: e7ff         	b	0x7009a8bc <_vsnprintf+0x7dc> @ imm = #-0x2
7009a8bc: 982e         	ldr	r0, [sp, #0xb8]
7009a8be: 1c41         	adds	r1, r0, #0x1
7009a8c0: 912e         	str	r1, [sp, #0xb8]
7009a8c2: 993a         	ldr	r1, [sp, #0xe8]
7009a8c4: 4288         	cmp	r0, r1
7009a8c6: d20a         	bhs	0x7009a8de <_vsnprintf+0x7fe> @ imm = #0x14
7009a8c8: e7ff         	b	0x7009a8ca <_vsnprintf+0x7ea> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009a8ca: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a8ce: 993e         	ldr	r1, [sp, #0xf8]
7009a8d0: 9a37         	ldr	r2, [sp, #0xdc]
7009a8d2: 1c50         	adds	r0, r2, #0x1
7009a8d4: 9037         	str	r0, [sp, #0xdc]
7009a8d6: 9b3d         	ldr	r3, [sp, #0xf4]
7009a8d8: 2020         	movs	r0, #0x20
7009a8da: 47e0         	blx	r12
;           while (l++ < width) {
7009a8dc: e7ee         	b	0x7009a8bc <_vsnprintf+0x7dc> @ imm = #-0x24
;         }
7009a8de: e7ff         	b	0x7009a8e0 <_vsnprintf+0x800> @ imm = #-0x2
;         out((char)va_arg(va, int), buffer, idx++, maxlen);
7009a8e0: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a8e4: 9840         	ldr	r0, [sp, #0x100]
7009a8e6: 1d01         	adds	r1, r0, #0x4
7009a8e8: 9140         	str	r1, [sp, #0x100]
7009a8ea: 7800         	ldrb	r0, [r0]
7009a8ec: 993e         	ldr	r1, [sp, #0xf8]
7009a8ee: 9a37         	ldr	r2, [sp, #0xdc]
7009a8f0: 1c53         	adds	r3, r2, #0x1
7009a8f2: 9337         	str	r3, [sp, #0xdc]
7009a8f4: 9b3d         	ldr	r3, [sp, #0xf4]
7009a8f6: 47e0         	blx	r12
;         if (flags & FLAGS_LEFT) {
7009a8f8: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a8fc: 0780         	lsls	r0, r0, #0x1e
7009a8fe: 2800         	cmp	r0, #0x0
7009a900: d513         	bpl	0x7009a92a <_vsnprintf+0x84a> @ imm = #0x26
7009a902: e7ff         	b	0x7009a904 <_vsnprintf+0x824> @ imm = #-0x2
;           while (l++ < width) {
7009a904: e7ff         	b	0x7009a906 <_vsnprintf+0x826> @ imm = #-0x2
7009a906: 982e         	ldr	r0, [sp, #0xb8]
7009a908: 1c41         	adds	r1, r0, #0x1
7009a90a: 912e         	str	r1, [sp, #0xb8]
7009a90c: 993a         	ldr	r1, [sp, #0xe8]
7009a90e: 4288         	cmp	r0, r1
7009a910: d20a         	bhs	0x7009a928 <_vsnprintf+0x848> @ imm = #0x14
7009a912: e7ff         	b	0x7009a914 <_vsnprintf+0x834> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009a914: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a918: 993e         	ldr	r1, [sp, #0xf8]
7009a91a: 9a37         	ldr	r2, [sp, #0xdc]
7009a91c: 1c50         	adds	r0, r2, #0x1
7009a91e: 9037         	str	r0, [sp, #0xdc]
7009a920: 9b3d         	ldr	r3, [sp, #0xf4]
7009a922: 2020         	movs	r0, #0x20
7009a924: 47e0         	blx	r12
;           while (l++ < width) {
7009a926: e7ee         	b	0x7009a906 <_vsnprintf+0x826> @ imm = #-0x24
;         }
7009a928: e7ff         	b	0x7009a92a <_vsnprintf+0x84a> @ imm = #-0x2
;         format++;
7009a92a: 983c         	ldr	r0, [sp, #0xf0]
7009a92c: 3001         	adds	r0, #0x1
7009a92e: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a930: e0d3         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #0x1a6
;         const char* p = va_arg(va, char*);
7009a932: 9840         	ldr	r0, [sp, #0x100]
7009a934: 1d01         	adds	r1, r0, #0x4
7009a936: 9140         	str	r1, [sp, #0x100]
7009a938: 6800         	ldr	r0, [r0]
7009a93a: 902d         	str	r0, [sp, #0xb4]
;         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
7009a93c: 982d         	ldr	r0, [sp, #0xb4]
7009a93e: 9010         	str	r0, [sp, #0x40]
7009a940: 9839         	ldr	r0, [sp, #0xe4]
7009a942: b118         	cbz	r0, 0x7009a94c <_vsnprintf+0x86c> @ imm = #0x6
7009a944: e7ff         	b	0x7009a946 <_vsnprintf+0x866> @ imm = #-0x2
7009a946: 9839         	ldr	r0, [sp, #0xe4]
7009a948: 900f         	str	r0, [sp, #0x3c]
7009a94a: e003         	b	0x7009a954 <_vsnprintf+0x874> @ imm = #0x6
7009a94c: f04f 30ff    	mov.w	r0, #0xffffffff
;         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
7009a950: 900f         	str	r0, [sp, #0x3c]
7009a952: e7ff         	b	0x7009a954 <_vsnprintf+0x874> @ imm = #-0x2
7009a954: 9810         	ldr	r0, [sp, #0x40]
7009a956: 990f         	ldr	r1, [sp, #0x3c]
7009a958: f013 f822    	bl	0x700ad9a0 <_strnlen_s> @ imm = #0x13044
7009a95c: 902c         	str	r0, [sp, #0xb0]
;         if (flags & FLAGS_PRECISION) {
7009a95e: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a962: 0740         	lsls	r0, r0, #0x1d
7009a964: 2800         	cmp	r0, #0x0
7009a966: d50e         	bpl	0x7009a986 <_vsnprintf+0x8a6> @ imm = #0x1c
7009a968: e7ff         	b	0x7009a96a <_vsnprintf+0x88a> @ imm = #-0x2
;           l = (l < precision ? l : precision);
7009a96a: 982c         	ldr	r0, [sp, #0xb0]
7009a96c: 9939         	ldr	r1, [sp, #0xe4]
7009a96e: 4288         	cmp	r0, r1
7009a970: d203         	bhs	0x7009a97a <_vsnprintf+0x89a> @ imm = #0x6
7009a972: e7ff         	b	0x7009a974 <_vsnprintf+0x894> @ imm = #-0x2
7009a974: 982c         	ldr	r0, [sp, #0xb0]
7009a976: 900e         	str	r0, [sp, #0x38]
7009a978: e002         	b	0x7009a980 <_vsnprintf+0x8a0> @ imm = #0x4
7009a97a: 9839         	ldr	r0, [sp, #0xe4]
7009a97c: 900e         	str	r0, [sp, #0x38]
7009a97e: e7ff         	b	0x7009a980 <_vsnprintf+0x8a0> @ imm = #-0x2
7009a980: 980e         	ldr	r0, [sp, #0x38]
7009a982: 902c         	str	r0, [sp, #0xb0]
;         }
7009a984: e7ff         	b	0x7009a986 <_vsnprintf+0x8a6> @ imm = #-0x2
;         if (!(flags & FLAGS_LEFT)) {
7009a986: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a98a: 0780         	lsls	r0, r0, #0x1e
7009a98c: 2800         	cmp	r0, #0x0
7009a98e: d413         	bmi	0x7009a9b8 <_vsnprintf+0x8d8> @ imm = #0x26
7009a990: e7ff         	b	0x7009a992 <_vsnprintf+0x8b2> @ imm = #-0x2
;           while (l++ < width) {
7009a992: e7ff         	b	0x7009a994 <_vsnprintf+0x8b4> @ imm = #-0x2
7009a994: 982c         	ldr	r0, [sp, #0xb0]
7009a996: 1c41         	adds	r1, r0, #0x1
7009a998: 912c         	str	r1, [sp, #0xb0]
7009a99a: 993a         	ldr	r1, [sp, #0xe8]
7009a99c: 4288         	cmp	r0, r1
7009a99e: d20a         	bhs	0x7009a9b6 <_vsnprintf+0x8d6> @ imm = #0x14
7009a9a0: e7ff         	b	0x7009a9a2 <_vsnprintf+0x8c2> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009a9a2: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a9a6: 993e         	ldr	r1, [sp, #0xf8]
7009a9a8: 9a37         	ldr	r2, [sp, #0xdc]
7009a9aa: 1c50         	adds	r0, r2, #0x1
7009a9ac: 9037         	str	r0, [sp, #0xdc]
7009a9ae: 9b3d         	ldr	r3, [sp, #0xf4]
7009a9b0: 2020         	movs	r0, #0x20
7009a9b2: 47e0         	blx	r12
;           while (l++ < width) {
7009a9b4: e7ee         	b	0x7009a994 <_vsnprintf+0x8b4> @ imm = #-0x24
;         }
7009a9b6: e7ff         	b	0x7009a9b8 <_vsnprintf+0x8d8> @ imm = #-0x2
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009a9b8: e7ff         	b	0x7009a9ba <_vsnprintf+0x8da> @ imm = #-0x2
7009a9ba: 982d         	ldr	r0, [sp, #0xb4]
7009a9bc: 7801         	ldrb	r1, [r0]
7009a9be: 2000         	movs	r0, #0x0
7009a9c0: 900d         	str	r0, [sp, #0x34]
7009a9c2: b1a1         	cbz	r1, 0x7009a9ee <_vsnprintf+0x90e> @ imm = #0x28
7009a9c4: e7ff         	b	0x7009a9c6 <_vsnprintf+0x8e6> @ imm = #-0x2
7009a9c6: 2001         	movs	r0, #0x1
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009a9c8: f89d 10ed    	ldrb.w	r1, [sp, #0xed]
7009a9cc: ea4f 7141    	lsl.w	r1, r1, #0x1d
7009a9d0: 2900         	cmp	r1, #0x0
7009a9d2: 900c         	str	r0, [sp, #0x30]
7009a9d4: d508         	bpl	0x7009a9e8 <_vsnprintf+0x908> @ imm = #0x10
7009a9d6: e7ff         	b	0x7009a9d8 <_vsnprintf+0x8f8> @ imm = #-0x2
7009a9d8: 9839         	ldr	r0, [sp, #0xe4]
7009a9da: 1e41         	subs	r1, r0, #0x1
7009a9dc: 9139         	str	r1, [sp, #0xe4]
7009a9de: 2800         	cmp	r0, #0x0
7009a9e0: bf18         	it	ne
7009a9e2: 2001         	movne	r0, #0x1
7009a9e4: 900c         	str	r0, [sp, #0x30]
7009a9e6: e7ff         	b	0x7009a9e8 <_vsnprintf+0x908> @ imm = #-0x2
7009a9e8: 980c         	ldr	r0, [sp, #0x30]
7009a9ea: 900d         	str	r0, [sp, #0x34]
7009a9ec: e7ff         	b	0x7009a9ee <_vsnprintf+0x90e> @ imm = #-0x2
7009a9ee: 980d         	ldr	r0, [sp, #0x34]
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009a9f0: 07c0         	lsls	r0, r0, #0x1f
7009a9f2: b168         	cbz	r0, 0x7009aa10 <_vsnprintf+0x930> @ imm = #0x1a
7009a9f4: e7ff         	b	0x7009a9f6 <_vsnprintf+0x916> @ imm = #-0x2
;           out(*(p++), buffer, idx++, maxlen);
7009a9f6: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a9fa: 982d         	ldr	r0, [sp, #0xb4]
7009a9fc: 1c41         	adds	r1, r0, #0x1
7009a9fe: 912d         	str	r1, [sp, #0xb4]
7009aa00: 7800         	ldrb	r0, [r0]
7009aa02: 993e         	ldr	r1, [sp, #0xf8]
7009aa04: 9a37         	ldr	r2, [sp, #0xdc]
7009aa06: 1c53         	adds	r3, r2, #0x1
7009aa08: 9337         	str	r3, [sp, #0xdc]
7009aa0a: 9b3d         	ldr	r3, [sp, #0xf4]
7009aa0c: 47e0         	blx	r12
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009aa0e: e7d4         	b	0x7009a9ba <_vsnprintf+0x8da> @ imm = #-0x58
;         if (flags & FLAGS_LEFT) {
7009aa10: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009aa14: 0780         	lsls	r0, r0, #0x1e
7009aa16: 2800         	cmp	r0, #0x0
7009aa18: d513         	bpl	0x7009aa42 <_vsnprintf+0x962> @ imm = #0x26
7009aa1a: e7ff         	b	0x7009aa1c <_vsnprintf+0x93c> @ imm = #-0x2
;           while (l++ < width) {
7009aa1c: e7ff         	b	0x7009aa1e <_vsnprintf+0x93e> @ imm = #-0x2
7009aa1e: 982c         	ldr	r0, [sp, #0xb0]
7009aa20: 1c41         	adds	r1, r0, #0x1
7009aa22: 912c         	str	r1, [sp, #0xb0]
7009aa24: 993a         	ldr	r1, [sp, #0xe8]
7009aa26: 4288         	cmp	r0, r1
7009aa28: d20a         	bhs	0x7009aa40 <_vsnprintf+0x960> @ imm = #0x14
7009aa2a: e7ff         	b	0x7009aa2c <_vsnprintf+0x94c> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009aa2c: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009aa30: 993e         	ldr	r1, [sp, #0xf8]
7009aa32: 9a37         	ldr	r2, [sp, #0xdc]
7009aa34: 1c50         	adds	r0, r2, #0x1
7009aa36: 9037         	str	r0, [sp, #0xdc]
7009aa38: 9b3d         	ldr	r3, [sp, #0xf4]
7009aa3a: 2020         	movs	r0, #0x20
7009aa3c: 47e0         	blx	r12
;           while (l++ < width) {
7009aa3e: e7ee         	b	0x7009aa1e <_vsnprintf+0x93e> @ imm = #-0x24
;         }
7009aa40: e7ff         	b	0x7009aa42 <_vsnprintf+0x962> @ imm = #-0x2
;         format++;
7009aa42: 983c         	ldr	r0, [sp, #0xf0]
7009aa44: 3001         	adds	r0, #0x1
7009aa46: 903c         	str	r0, [sp, #0xf0]
;         break;
7009aa48: e047         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #0x8e
7009aa4a: 2008         	movs	r0, #0x8
;         width = sizeof(void*) * 2U;
7009aa4c: 903a         	str	r0, [sp, #0xe8]
;         flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
7009aa4e: 983b         	ldr	r0, [sp, #0xec]
7009aa50: f040 0021    	orr	r0, r0, #0x21
7009aa54: 903b         	str	r0, [sp, #0xec]
7009aa56: 2400         	movs	r4, #0x0
;         const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
7009aa58: f88d 40af    	strb.w	r4, [sp, #0xaf]
;           idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
7009aa5c: 983f         	ldr	r0, [sp, #0xfc]
7009aa5e: 993e         	ldr	r1, [sp, #0xf8]
7009aa60: 9a37         	ldr	r2, [sp, #0xdc]
7009aa62: 9b3d         	ldr	r3, [sp, #0xf4]
7009aa64: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009aa68: f10c 0e04    	add.w	lr, r12, #0x4
7009aa6c: f8cd e100    	str.w	lr, [sp, #0x100]
7009aa70: f8dc c000    	ldr.w	r12, [r12]
7009aa74: 9d39         	ldr	r5, [sp, #0xe4]
7009aa76: 9e3a         	ldr	r6, [sp, #0xe8]
7009aa78: 9f3b         	ldr	r7, [sp, #0xec]
7009aa7a: 46ee         	mov	lr, sp
7009aa7c: f8ce 7014    	str.w	r7, [lr, #0x14]
7009aa80: f8ce 6010    	str.w	r6, [lr, #0x10]
7009aa84: f8ce 500c    	str.w	r5, [lr, #0xc]
7009aa88: 2510         	movs	r5, #0x10
7009aa8a: f8ce 5008    	str.w	r5, [lr, #0x8]
7009aa8e: f8ce 4004    	str.w	r4, [lr, #0x4]
7009aa92: f8ce c000    	str.w	r12, [lr]
7009aa96: f00a f8fb    	bl	0x700a4c90 <_ntoa_long> @ imm = #0xa1f6
7009aa9a: 9037         	str	r0, [sp, #0xdc]
;         format++;
7009aa9c: 983c         	ldr	r0, [sp, #0xf0]
7009aa9e: 3001         	adds	r0, #0x1
7009aaa0: 903c         	str	r0, [sp, #0xf0]
;         break;
7009aaa2: e01a         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #0x34
;         out('%', buffer, idx++, maxlen);
7009aaa4: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009aaa8: 993e         	ldr	r1, [sp, #0xf8]
7009aaaa: 9a37         	ldr	r2, [sp, #0xdc]
7009aaac: 1c50         	adds	r0, r2, #0x1
7009aaae: 9037         	str	r0, [sp, #0xdc]
7009aab0: 9b3d         	ldr	r3, [sp, #0xf4]
7009aab2: 2025         	movs	r0, #0x25
7009aab4: 47e0         	blx	r12
;         format++;
7009aab6: 983c         	ldr	r0, [sp, #0xf0]
7009aab8: 3001         	adds	r0, #0x1
7009aaba: 903c         	str	r0, [sp, #0xf0]
;         break;
7009aabc: e00d         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #0x1a
;         out(*format, buffer, idx++, maxlen);
7009aabe: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009aac2: 983c         	ldr	r0, [sp, #0xf0]
7009aac4: 7800         	ldrb	r0, [r0]
7009aac6: 993e         	ldr	r1, [sp, #0xf8]
7009aac8: 9a37         	ldr	r2, [sp, #0xdc]
7009aaca: 1c53         	adds	r3, r2, #0x1
7009aacc: 9337         	str	r3, [sp, #0xdc]
7009aace: 9b3d         	ldr	r3, [sp, #0xf4]
7009aad0: 47e0         	blx	r12
;         format++;
7009aad2: 983c         	ldr	r0, [sp, #0xf0]
7009aad4: 3001         	adds	r0, #0x1
7009aad6: 903c         	str	r0, [sp, #0xf0]
;         break;
7009aad8: e7ff         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #-0x2
;   while (*format)
7009aada: f7ff bb18    	b.w	0x7009a10e <_vsnprintf+0x2e> @ imm = #-0x9d0
;   out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
7009aade: 983f         	ldr	r0, [sp, #0xfc]
7009aae0: 900a         	str	r0, [sp, #0x28]
7009aae2: 983e         	ldr	r0, [sp, #0xf8]
7009aae4: 900b         	str	r0, [sp, #0x2c]
7009aae6: 9837         	ldr	r0, [sp, #0xdc]
7009aae8: 993d         	ldr	r1, [sp, #0xf4]
7009aaea: 4288         	cmp	r0, r1
7009aaec: d203         	bhs	0x7009aaf6 <_vsnprintf+0xa16> @ imm = #0x6
7009aaee: e7ff         	b	0x7009aaf0 <_vsnprintf+0xa10> @ imm = #-0x2
7009aaf0: 9837         	ldr	r0, [sp, #0xdc]
7009aaf2: 9009         	str	r0, [sp, #0x24]
7009aaf4: e003         	b	0x7009aafe <_vsnprintf+0xa1e> @ imm = #0x6
7009aaf6: 983d         	ldr	r0, [sp, #0xf4]
7009aaf8: 3801         	subs	r0, #0x1
7009aafa: 9009         	str	r0, [sp, #0x24]
7009aafc: e7ff         	b	0x7009aafe <_vsnprintf+0xa1e> @ imm = #-0x2
7009aafe: f8dd c028    	ldr.w	r12, [sp, #0x28]
7009ab02: 990b         	ldr	r1, [sp, #0x2c]
7009ab04: 9a09         	ldr	r2, [sp, #0x24]
7009ab06: 9b3d         	ldr	r3, [sp, #0xf4]
7009ab08: 2000         	movs	r0, #0x0
7009ab0a: 47e0         	blx	r12
;   return (int)idx;
7009ab0c: 9837         	ldr	r0, [sp, #0xdc]
7009ab0e: b041         	add	sp, #0x104
7009ab10: e8bd 83f0    	pop.w	{r4, r5, r6, r7, r8, r9, pc}

7009ab14 <__aeabi_errno_addr>:
7009ab14: e59f0000     	ldr	r0, [pc]                @ 0x7009ab1c <__aeabi_errno_addr+0x8>
7009ab18: e12fff1e     	bx	lr
7009ab1c: d0 29 0b 70  	.word	0x700b29d0

7009ab20 <Sciclient_rmIrqRouteValidate>:
; {
7009ab20: b580         	push	{r7, lr}
7009ab22: b09e         	sub	sp, #0x78
7009ab24: 901d         	str	r0, [sp, #0x74]
7009ab26: 2001         	movs	r0, #0x1
;     bool valid = true;
7009ab28: f88d 0073    	strb.w	r0, [sp, #0x73]
7009ab2c: 2000         	movs	r0, #0x0
;     const struct Sciclient_rmIrqNode *cur_n, *next_n = NULL;
7009ab2e: 9009         	str	r0, [sp, #0x24]
7009ab30: 9019         	str	r0, [sp, #0x64]
;     bool cur_outp_valid = false, next_inp_valid = false;
7009ab32: f88d 005f    	strb.w	r0, [sp, #0x5f]
7009ab36: f88d 005e    	strb.w	r0, [sp, #0x5e]
;     uint16_t cur_outp = 0, next_inp = 0;
7009ab3a: f8ad 0056    	strh.w	r0, [sp, #0x56]
7009ab3e: f8ad 0054    	strh.w	r0, [sp, #0x54]
;     struct tisci_msg_rm_get_resource_range_req req = {{0}};
7009ab42: 9014         	str	r0, [sp, #0x50]
7009ab44: 9013         	str	r0, [sp, #0x4c]
7009ab46: 9012         	str	r0, [sp, #0x48]
;     struct tisci_msg_rm_get_resource_range_resp host_resp = {{0}};
7009ab48: 9011         	str	r0, [sp, #0x44]
7009ab4a: 9010         	str	r0, [sp, #0x40]
7009ab4c: 900f         	str	r0, [sp, #0x3c]
7009ab4e: 900e         	str	r0, [sp, #0x38]
;     struct tisci_msg_rm_get_resource_range_resp all_resp = {{0}};
7009ab50: 900d         	str	r0, [sp, #0x34]
7009ab52: 900c         	str	r0, [sp, #0x30]
7009ab54: 900b         	str	r0, [sp, #0x2c]
7009ab56: 900a         	str	r0, [sp, #0x28]
;     if (cfg->s_ia == SCICLIENT_RM_DEV_NONE) {
7009ab58: 981d         	ldr	r0, [sp, #0x74]
7009ab5a: 8a00         	ldrh	r0, [r0, #0x10]
7009ab5c: 28ff         	cmp	r0, #0xff
7009ab5e: d12c         	bne	0x7009abba <Sciclient_rmIrqRouteValidate+0x9a> @ imm = #0x58
7009ab60: e7ff         	b	0x7009ab62 <Sciclient_rmIrqRouteValidate+0x42> @ imm = #-0x2
7009ab62: 2000         	movs	r0, #0x0
;         cur_n = Sciclient_rmPsGetIrqNode(0u);
7009ab64: f014 fc64    	bl	0x700af430 <Sciclient_rmPsGetIrqNode> @ imm = #0x148c8
7009ab68: 901a         	str	r0, [sp, #0x68]
;         if (cur_n == NULL) {
7009ab6a: 981a         	ldr	r0, [sp, #0x68]
7009ab6c: b920         	cbnz	r0, 0x7009ab78 <Sciclient_rmIrqRouteValidate+0x58> @ imm = #0x8
7009ab6e: e7ff         	b	0x7009ab70 <Sciclient_rmIrqRouteValidate+0x50> @ imm = #-0x2
7009ab70: 2000         	movs	r0, #0x0
;             valid = false;
7009ab72: f88d 0073    	strb.w	r0, [sp, #0x73]
;         } else {
7009ab76: e01f         	b	0x7009abb8 <Sciclient_rmIrqRouteValidate+0x98> @ imm = #0x3e
;             cur_if = cur_n->p_if[Sciclient_rmPsGetIfIdx(0u)];
7009ab78: 981a         	ldr	r0, [sp, #0x68]
7009ab7a: 6840         	ldr	r0, [r0, #0x4]
7009ab7c: 9008         	str	r0, [sp, #0x20]
7009ab7e: 2000         	movs	r0, #0x0
7009ab80: f013 f866    	bl	0x700adc50 <Sciclient_rmPsGetIfIdx> @ imm = #0x130cc
7009ab84: 4601         	mov	r1, r0
7009ab86: 9808         	ldr	r0, [sp, #0x20]
7009ab88: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009ab8c: 9018         	str	r0, [sp, #0x60]
;             if ((cfg->s_idx < cur_if->lbase) ||
7009ab8e: 981d         	ldr	r0, [sp, #0x74]
7009ab90: 8900         	ldrh	r0, [r0, #0x8]
7009ab92: 9918         	ldr	r1, [sp, #0x60]
7009ab94: 8809         	ldrh	r1, [r1]
7009ab96: 4288         	cmp	r0, r1
7009ab98: db09         	blt	0x7009abae <Sciclient_rmIrqRouteValidate+0x8e> @ imm = #0x12
7009ab9a: e7ff         	b	0x7009ab9c <Sciclient_rmIrqRouteValidate+0x7c> @ imm = #-0x2
;                 (cfg->s_idx >= (cur_if->lbase + cur_if->len))) {
7009ab9c: 981d         	ldr	r0, [sp, #0x74]
7009ab9e: 8900         	ldrh	r0, [r0, #0x8]
7009aba0: 9a18         	ldr	r2, [sp, #0x60]
7009aba2: 8811         	ldrh	r1, [r2]
7009aba4: 8892         	ldrh	r2, [r2, #0x4]
7009aba6: 4411         	add	r1, r2
;             if ((cfg->s_idx < cur_if->lbase) ||
7009aba8: 4288         	cmp	r0, r1
7009abaa: db04         	blt	0x7009abb6 <Sciclient_rmIrqRouteValidate+0x96> @ imm = #0x8
7009abac: e7ff         	b	0x7009abae <Sciclient_rmIrqRouteValidate+0x8e> @ imm = #-0x2
7009abae: 2000         	movs	r0, #0x0
;                 valid = false;
7009abb0: f88d 0073    	strb.w	r0, [sp, #0x73]
;             }
7009abb4: e7ff         	b	0x7009abb6 <Sciclient_rmIrqRouteValidate+0x96> @ imm = #-0x2
7009abb6: e7ff         	b	0x7009abb8 <Sciclient_rmIrqRouteValidate+0x98> @ imm = #-0x2
;     }
7009abb8: e7ff         	b	0x7009abba <Sciclient_rmIrqRouteValidate+0x9a> @ imm = #-0x2
;     if ((valid == true) &&
7009abba: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009abbe: 07c0         	lsls	r0, r0, #0x1f
7009abc0: b148         	cbz	r0, 0x7009abd6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #0x12
7009abc2: e7ff         	b	0x7009abc4 <Sciclient_rmIrqRouteValidate+0xa4> @ imm = #-0x2
;         (Sciclient_rmPsGetPsp() <= 1U)) {
7009abc4: f015 f864    	bl	0x700afc90 <Sciclient_rmPsGetPsp> @ imm = #0x150c8
;     if ((valid == true) &&
7009abc8: 2801         	cmp	r0, #0x1
7009abca: d804         	bhi	0x7009abd6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #0x8
7009abcc: e7ff         	b	0x7009abce <Sciclient_rmIrqRouteValidate+0xae> @ imm = #-0x2
7009abce: 2000         	movs	r0, #0x0
;         valid = false;
7009abd0: f88d 0073    	strb.w	r0, [sp, #0x73]
;     }
7009abd4: e7ff         	b	0x7009abd6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #-0x2
;     if (valid == true) {
7009abd6: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009abda: 07c0         	lsls	r0, r0, #0x1f
7009abdc: b150         	cbz	r0, 0x7009abf4 <Sciclient_rmIrqRouteValidate+0xd4> @ imm = #0x14
7009abde: e7ff         	b	0x7009abe0 <Sciclient_rmIrqRouteValidate+0xc0> @ imm = #-0x2
;         if (Sciclient_rmIrqCheckLoop(cfg) == true) {
7009abe0: 981d         	ldr	r0, [sp, #0x74]
7009abe2: f00d fdd5    	bl	0x700a8790 <Sciclient_rmIrqCheckLoop> @ imm = #0xdbaa
7009abe6: b120         	cbz	r0, 0x7009abf2 <Sciclient_rmIrqRouteValidate+0xd2> @ imm = #0x8
7009abe8: e7ff         	b	0x7009abea <Sciclient_rmIrqRouteValidate+0xca> @ imm = #-0x2
7009abea: 2000         	movs	r0, #0x0
;             valid = false;
7009abec: f88d 0073    	strb.w	r0, [sp, #0x73]
;         }
7009abf0: e7ff         	b	0x7009abf2 <Sciclient_rmIrqRouteValidate+0xd2> @ imm = #-0x2
;     }
7009abf2: e7ff         	b	0x7009abf4 <Sciclient_rmIrqRouteValidate+0xd4> @ imm = #-0x2
7009abf4: 2000         	movs	r0, #0x0
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
7009abf6: f8ad 0070    	strh.w	r0, [sp, #0x70]
7009abfa: e7ff         	b	0x7009abfc <Sciclient_rmIrqRouteValidate+0xdc> @ imm = #-0x2
7009abfc: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac00: 9006         	str	r0, [sp, #0x18]
7009ac02: f015 f845    	bl	0x700afc90 <Sciclient_rmPsGetPsp> @ imm = #0x1508a
7009ac06: 9906         	ldr	r1, [sp, #0x18]
7009ac08: 4602         	mov	r2, r0
7009ac0a: 2000         	movs	r0, #0x0
7009ac0c: 4291         	cmp	r1, r2
7009ac0e: 9007         	str	r0, [sp, #0x1c]
7009ac10: da06         	bge	0x7009ac20 <Sciclient_rmIrqRouteValidate+0x100> @ imm = #0xc
7009ac12: e7ff         	b	0x7009ac14 <Sciclient_rmIrqRouteValidate+0xf4> @ imm = #-0x2
7009ac14: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009ac18: f000 0001    	and	r0, r0, #0x1
7009ac1c: 9007         	str	r0, [sp, #0x1c]
7009ac1e: e7ff         	b	0x7009ac20 <Sciclient_rmIrqRouteValidate+0x100> @ imm = #-0x2
7009ac20: 9807         	ldr	r0, [sp, #0x1c]
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
7009ac22: 07c0         	lsls	r0, r0, #0x1f
7009ac24: 2800         	cmp	r0, #0x0
7009ac26: f000 826f    	beq.w	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x4de
7009ac2a: e7ff         	b	0x7009ac2c <Sciclient_rmIrqRouteValidate+0x10c> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
7009ac2c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac30: f014 fbfe    	bl	0x700af430 <Sciclient_rmPsGetIrqNode> @ imm = #0x147fc
7009ac34: 901a         	str	r0, [sp, #0x68]
;         cur_if = cur_n->p_if[Sciclient_rmPsGetIfIdx(i)];
7009ac36: 981a         	ldr	r0, [sp, #0x68]
7009ac38: 6840         	ldr	r0, [r0, #0x4]
7009ac3a: 9004         	str	r0, [sp, #0x10]
7009ac3c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac40: f013 f806    	bl	0x700adc50 <Sciclient_rmPsGetIfIdx> @ imm = #0x1300c
7009ac44: 4601         	mov	r1, r0
7009ac46: 9804         	ldr	r0, [sp, #0x10]
7009ac48: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009ac4c: 9018         	str	r0, [sp, #0x60]
;         if (i < (Sciclient_rmPsGetPsp() - 1u)) {
7009ac4e: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac52: 9005         	str	r0, [sp, #0x14]
7009ac54: f015 f81c    	bl	0x700afc90 <Sciclient_rmPsGetPsp> @ imm = #0x15038
7009ac58: 4601         	mov	r1, r0
7009ac5a: 9805         	ldr	r0, [sp, #0x14]
7009ac5c: 3901         	subs	r1, #0x1
7009ac5e: 4288         	cmp	r0, r1
7009ac60: d20f         	bhs	0x7009ac82 <Sciclient_rmIrqRouteValidate+0x162> @ imm = #0x1e
7009ac62: e7ff         	b	0x7009ac64 <Sciclient_rmIrqRouteValidate+0x144> @ imm = #-0x2
;             next_n = Sciclient_rmPsGetIrqNode(i + 1u);
7009ac64: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac68: 3001         	adds	r0, #0x1
7009ac6a: b280         	uxth	r0, r0
7009ac6c: f014 fbe0    	bl	0x700af430 <Sciclient_rmPsGetIrqNode> @ imm = #0x147c0
7009ac70: 9019         	str	r0, [sp, #0x64]
;             if (next_n == NULL) {
7009ac72: 9819         	ldr	r0, [sp, #0x64]
7009ac74: b920         	cbnz	r0, 0x7009ac80 <Sciclient_rmIrqRouteValidate+0x160> @ imm = #0x8
7009ac76: e7ff         	b	0x7009ac78 <Sciclient_rmIrqRouteValidate+0x158> @ imm = #-0x2
7009ac78: 2000         	movs	r0, #0x0
;                 valid = false;
7009ac7a: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009ac7e: e243         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x486
;         }
7009ac80: e7ff         	b	0x7009ac82 <Sciclient_rmIrqRouteValidate+0x162> @ imm = #-0x2
;         if (i > 0u) {
7009ac82: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac86: b158         	cbz	r0, 0x7009aca0 <Sciclient_rmIrqRouteValidate+0x180> @ imm = #0x16
7009ac88: e7ff         	b	0x7009ac8a <Sciclient_rmIrqRouteValidate+0x16a> @ imm = #-0x2
;             if (Sciclient_rmIrIsIr(cur_n->id) != true) {
7009ac8a: 981a         	ldr	r0, [sp, #0x68]
7009ac8c: 8800         	ldrh	r0, [r0]
7009ac8e: f013 fe5f    	bl	0x700ae950 <Sciclient_rmIrIsIr> @ imm = #0x13cbe
7009ac92: b920         	cbnz	r0, 0x7009ac9e <Sciclient_rmIrqRouteValidate+0x17e> @ imm = #0x8
7009ac94: e7ff         	b	0x7009ac96 <Sciclient_rmIrqRouteValidate+0x176> @ imm = #-0x2
7009ac96: 2000         	movs	r0, #0x0
;                 valid = false;
7009ac98: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009ac9c: e234         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x468
;         }
7009ac9e: e7ff         	b	0x7009aca0 <Sciclient_rmIrqRouteValidate+0x180> @ imm = #-0x2
;         if ((i == 0u) && (i < (Sciclient_rmPsGetPsp() - 1u))) {
7009aca0: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009aca4: 2800         	cmp	r0, #0x0
7009aca6: f040 8080    	bne.w	0x7009adaa <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #0x100
7009acaa: e7ff         	b	0x7009acac <Sciclient_rmIrqRouteValidate+0x18c> @ imm = #-0x2
7009acac: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009acb0: 9003         	str	r0, [sp, #0xc]
7009acb2: f014 ffed    	bl	0x700afc90 <Sciclient_rmPsGetPsp> @ imm = #0x14fda
7009acb6: 4601         	mov	r1, r0
7009acb8: 9803         	ldr	r0, [sp, #0xc]
7009acba: 3901         	subs	r1, #0x1
7009acbc: 4288         	cmp	r0, r1
7009acbe: d274         	bhs	0x7009adaa <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #0xe8
7009acc0: e7ff         	b	0x7009acc2 <Sciclient_rmIrqRouteValidate+0x1a2> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cur_n->id) == true) {
7009acc2: 981a         	ldr	r0, [sp, #0x68]
7009acc4: 8800         	ldrh	r0, [r0]
7009acc6: f013 fe2b    	bl	0x700ae920 <Sciclient_rmIaIsIa> @ imm = #0x13c56
7009acca: 2800         	cmp	r0, #0x0
7009accc: d049         	beq	0x7009ad62 <Sciclient_rmIrqRouteValidate+0x242> @ imm = #0x92
7009acce: e7ff         	b	0x7009acd0 <Sciclient_rmIrqRouteValidate+0x1b0> @ imm = #-0x2
7009acd0: 2000         	movs	r0, #0x0
;                 cur_outp_valid = false;
7009acd2: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 next_inp_valid = false;
7009acd6: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cfg->vint,
7009acda: 9a18         	ldr	r2, [sp, #0x60]
7009acdc: 8850         	ldrh	r0, [r2, #0x2]
7009acde: 991d         	ldr	r1, [sp, #0x74]
7009ace0: 8a49         	ldrh	r1, [r1, #0x12]
7009ace2: 8812         	ldrh	r2, [r2]
7009ace4: 1a89         	subs	r1, r1, r2
7009ace6: 4408         	add	r0, r1
7009ace8: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 cur_outp = cfg->vint;
7009acec: 981d         	ldr	r0, [sp, #0x74]
7009acee: 8a40         	ldrh	r0, [r0, #0x12]
7009acf0: f8ad 0056    	strh.w	r0, [sp, #0x56]
7009acf4: 2001         	movs	r0, #0x1
;                 cur_outp_valid = true;
7009acf6: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 if ((next_n != NULL) && (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
7009acfa: 9819         	ldr	r0, [sp, #0x64]
7009acfc: b160         	cbz	r0, 0x7009ad18 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #0x18
7009acfe: e7ff         	b	0x7009ad00 <Sciclient_rmIrqRouteValidate+0x1e0> @ imm = #-0x2
7009ad00: 9819         	ldr	r0, [sp, #0x64]
7009ad02: 8800         	ldrh	r0, [r0]
7009ad04: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009ad08: f00b faba    	bl	0x700a6280 <Sciclient_rmIrInpIsFree> @ imm = #0xb574
7009ad0c: b920         	cbnz	r0, 0x7009ad18 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #0x8
7009ad0e: e7ff         	b	0x7009ad10 <Sciclient_rmIrqRouteValidate+0x1f0> @ imm = #-0x2
7009ad10: 2001         	movs	r0, #0x1
;                     next_inp_valid = true;
7009ad12: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 }
7009ad16: e7ff         	b	0x7009ad18 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #-0x2
;                 if (Sciclient_rmParamIsValid(cfg->valid_params,
7009ad18: 981d         	ldr	r0, [sp, #0x74]
7009ad1a: 6800         	ldr	r0, [r0]
7009ad1c: 2110         	movs	r1, #0x10
7009ad1e: f013 fff7    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x13fee
7009ad22: b1e8         	cbz	r0, 0x7009ad60 <Sciclient_rmIrqRouteValidate+0x240> @ imm = #0x3a
7009ad24: e7ff         	b	0x7009ad26 <Sciclient_rmIrqRouteValidate+0x206> @ imm = #-0x2
;                     cur_inp = cfg->global_evt;
7009ad26: 981d         	ldr	r0, [sp, #0x74]
7009ad28: 89c0         	ldrh	r0, [r0, #0xe]
7009ad2a: 9016         	str	r0, [sp, #0x58]
;                     if (Sciclient_rmIaValidateGlobalEvt(cur_n->id,
7009ad2c: 981a         	ldr	r0, [sp, #0x68]
7009ad2e: 8800         	ldrh	r0, [r0]
;                                       cur_inp) ==
7009ad30: f8bd 1058    	ldrh.w	r1, [sp, #0x58]
;                     if (Sciclient_rmIaValidateGlobalEvt(cur_n->id,
7009ad34: f011 fccc    	bl	0x700ac6d0 <Sciclient_rmIaValidateGlobalEvt> @ imm = #0x11998
7009ad38: b968         	cbnz	r0, 0x7009ad56 <Sciclient_rmIrqRouteValidate+0x236> @ imm = #0x1a
7009ad3a: e7ff         	b	0x7009ad3c <Sciclient_rmIrqRouteValidate+0x21c> @ imm = #-0x2
;                         if (Sciclient_rmPsSetInp(i, cur_inp) != SystemP_SUCCESS) {
7009ad3c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ad40: f8bd 1058    	ldrh.w	r1, [sp, #0x58]
7009ad44: f012 faec    	bl	0x700ad320 <Sciclient_rmPsSetInp> @ imm = #0x125d8
7009ad48: b120         	cbz	r0, 0x7009ad54 <Sciclient_rmIrqRouteValidate+0x234> @ imm = #0x8
7009ad4a: e7ff         	b	0x7009ad4c <Sciclient_rmIrqRouteValidate+0x22c> @ imm = #-0x2
7009ad4c: 2000         	movs	r0, #0x0
;                             valid = false;
7009ad4e: f88d 0073    	strb.w	r0, [sp, #0x73]
;                             break;
7009ad52: e1d9         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x3b2
;                     } else {
7009ad54: e003         	b	0x7009ad5e <Sciclient_rmIrqRouteValidate+0x23e> @ imm = #0x6
7009ad56: 2000         	movs	r0, #0x0
;                         valid = false;
7009ad58: f88d 0073    	strb.w	r0, [sp, #0x73]
;                         break;
7009ad5c: e1d4         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x3a8
;                 }
7009ad5e: e7ff         	b	0x7009ad60 <Sciclient_rmIrqRouteValidate+0x240> @ imm = #-0x2
;             } else {
7009ad60: e022         	b	0x7009ada8 <Sciclient_rmIrqRouteValidate+0x288> @ imm = #0x44
7009ad62: 2001         	movs	r0, #0x1
;                 cur_outp_valid = true;
7009ad64: f88d 005f    	strb.w	r0, [sp, #0x5f]
7009ad68: 2000         	movs	r0, #0x0
;                 next_inp_valid = false;
7009ad6a: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 cur_outp = cfg->s_idx;
7009ad6e: 981d         	ldr	r0, [sp, #0x74]
7009ad70: 8900         	ldrh	r0, [r0, #0x8]
7009ad72: f8ad 0056    	strh.w	r0, [sp, #0x56]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cur_outp, cur_if->lbase,
7009ad76: 9a18         	ldr	r2, [sp, #0x60]
7009ad78: 8850         	ldrh	r0, [r2, #0x2]
7009ad7a: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009ad7e: 8812         	ldrh	r2, [r2]
7009ad80: 1a89         	subs	r1, r1, r2
7009ad82: 4408         	add	r0, r1
7009ad84: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 if ((next_n != NULL) && (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
7009ad88: 9819         	ldr	r0, [sp, #0x64]
7009ad8a: b160         	cbz	r0, 0x7009ada6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #0x18
7009ad8c: e7ff         	b	0x7009ad8e <Sciclient_rmIrqRouteValidate+0x26e> @ imm = #-0x2
7009ad8e: 9819         	ldr	r0, [sp, #0x64]
7009ad90: 8800         	ldrh	r0, [r0]
7009ad92: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009ad96: f00b fa73    	bl	0x700a6280 <Sciclient_rmIrInpIsFree> @ imm = #0xb4e6
7009ad9a: b920         	cbnz	r0, 0x7009ada6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #0x8
7009ad9c: e7ff         	b	0x7009ad9e <Sciclient_rmIrqRouteValidate+0x27e> @ imm = #-0x2
7009ad9e: 2001         	movs	r0, #0x1
;                     next_inp_valid = true;
7009ada0: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 }
7009ada4: e7ff         	b	0x7009ada6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #-0x2
7009ada6: e7ff         	b	0x7009ada8 <Sciclient_rmIrqRouteValidate+0x288> @ imm = #-0x2
;         }
7009ada8: e7ff         	b	0x7009adaa <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #-0x2
;         if ((i > 0u) && (i < (Sciclient_rmPsGetPsp() - 1u))) {
7009adaa: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009adae: 2800         	cmp	r0, #0x0
7009adb0: f000 80c4    	beq.w	0x7009af3c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #0x188
7009adb4: e7ff         	b	0x7009adb6 <Sciclient_rmIrqRouteValidate+0x296> @ imm = #-0x2
7009adb6: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009adba: 9002         	str	r0, [sp, #0x8]
7009adbc: f014 ff68    	bl	0x700afc90 <Sciclient_rmPsGetPsp> @ imm = #0x14ed0
7009adc0: 4601         	mov	r1, r0
7009adc2: 9802         	ldr	r0, [sp, #0x8]
7009adc4: 3901         	subs	r1, #0x1
7009adc6: 4288         	cmp	r0, r1
7009adc8: f080 80b8    	bhs.w	0x7009af3c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #0x170
7009adcc: e7ff         	b	0x7009adce <Sciclient_rmIrqRouteValidate+0x2ae> @ imm = #-0x2
;             req.secondary_host = cfg->host;
7009adce: 981d         	ldr	r0, [sp, #0x74]
7009add0: 7900         	ldrb	r0, [r0, #0x4]
7009add2: f88d 0053    	strb.w	r0, [sp, #0x53]
;             req.type = cur_n->id;
7009add6: 981a         	ldr	r0, [sp, #0x68]
7009add8: 8800         	ldrh	r0, [r0]
7009adda: f8ad 0050    	strh.w	r0, [sp, #0x50]
7009adde: 2000         	movs	r0, #0x0
;             req.subtype = TISCI_RESASG_SUBTYPE_IR_OUTPUT;
7009ade0: f88d 0052    	strb.w	r0, [sp, #0x52]
7009ade4: a812         	add	r0, sp, #0x48
7009ade6: a90e         	add	r1, sp, #0x38
7009ade8: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &host_resp,
7009adec: f010 fb48    	bl	0x700ab480 <Sciclient_rmGetResourceRange> @ imm = #0x10690
7009adf0: b120         	cbz	r0, 0x7009adfc <Sciclient_rmIrqRouteValidate+0x2dc> @ imm = #0x8
7009adf2: e7ff         	b	0x7009adf4 <Sciclient_rmIrqRouteValidate+0x2d4> @ imm = #-0x2
7009adf4: 2000         	movs	r0, #0x0
;                 valid = false;
7009adf6: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009adfa: e185         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x30a
7009adfc: 2080         	movs	r0, #0x80
;             req.secondary_host = TISCI_HOST_ID_ALL;
7009adfe: f88d 0053    	strb.w	r0, [sp, #0x53]
7009ae02: a812         	add	r0, sp, #0x48
7009ae04: a90a         	add	r1, sp, #0x28
7009ae06: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &all_resp,
7009ae0a: f010 fb39    	bl	0x700ab480 <Sciclient_rmGetResourceRange> @ imm = #0x10672
7009ae0e: b120         	cbz	r0, 0x7009ae1a <Sciclient_rmIrqRouteValidate+0x2fa> @ imm = #0x8
7009ae10: e7ff         	b	0x7009ae12 <Sciclient_rmIrqRouteValidate+0x2f2> @ imm = #-0x2
7009ae12: 2000         	movs	r0, #0x0
;                 valid = false;
7009ae14: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009ae18: e176         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x2ec
;             for (j = cur_if->lbase; j < cur_if->lbase + cur_if->len;
7009ae1a: 9818         	ldr	r0, [sp, #0x60]
7009ae1c: 8800         	ldrh	r0, [r0]
7009ae1e: f8ad 006e    	strh.w	r0, [sp, #0x6e]
7009ae22: e7ff         	b	0x7009ae24 <Sciclient_rmIrqRouteValidate+0x304> @ imm = #-0x2
7009ae24: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
7009ae28: 9a18         	ldr	r2, [sp, #0x60]
7009ae2a: 8811         	ldrh	r1, [r2]
7009ae2c: 8892         	ldrh	r2, [r2, #0x4]
7009ae2e: 4411         	add	r1, r2
7009ae30: 4288         	cmp	r0, r1
7009ae32: f280 8082    	bge.w	0x7009af3a <Sciclient_rmIrqRouteValidate+0x41a> @ imm = #0x104
7009ae36: e7ff         	b	0x7009ae38 <Sciclient_rmIrqRouteValidate+0x318> @ imm = #-0x2
7009ae38: 2000         	movs	r0, #0x0
;                 cur_outp_valid = false;
7009ae3a: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 next_inp_valid = false;
7009ae3e: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 cur_outp = j;
7009ae42: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
7009ae46: f8ad 0056    	strh.w	r0, [sp, #0x56]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cur_outp, cur_if->lbase,
7009ae4a: 9a18         	ldr	r2, [sp, #0x60]
7009ae4c: 8850         	ldrh	r0, [r2, #0x2]
7009ae4e: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009ae52: 8812         	ldrh	r2, [r2]
7009ae54: 1a89         	subs	r1, r1, r2
7009ae56: 4408         	add	r0, r1
7009ae58: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 if ((((cur_outp >= host_resp.range_start) &&
7009ae5c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae60: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009ae64: 4288         	cmp	r0, r1
7009ae66: db0a         	blt	0x7009ae7e <Sciclient_rmIrqRouteValidate+0x35e> @ imm = #0x14
7009ae68: e7ff         	b	0x7009ae6a <Sciclient_rmIrqRouteValidate+0x34a> @ imm = #-0x2
;                       (cur_outp < host_resp.range_start + host_resp.range_num)) ||
7009ae6a: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae6e: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009ae72: f8bd 2042    	ldrh.w	r2, [sp, #0x42]
7009ae76: 4411         	add	r1, r2
7009ae78: 4288         	cmp	r0, r1
7009ae7a: db33         	blt	0x7009aee4 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x66
7009ae7c: e7ff         	b	0x7009ae7e <Sciclient_rmIrqRouteValidate+0x35e> @ imm = #-0x2
;                      ((cur_outp >= host_resp.range_start_sec) &&
7009ae7e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae82: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
7009ae86: 4288         	cmp	r0, r1
7009ae88: db0a         	blt	0x7009aea0 <Sciclient_rmIrqRouteValidate+0x380> @ imm = #0x14
7009ae8a: e7ff         	b	0x7009ae8c <Sciclient_rmIrqRouteValidate+0x36c> @ imm = #-0x2
;                       (cur_outp < host_resp.range_start_sec +
7009ae8c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae90: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
;                                   host_resp.range_num_sec))) ||
7009ae94: f8bd 2046    	ldrh.w	r2, [sp, #0x46]
;                       (cur_outp < host_resp.range_start_sec +
7009ae98: 4411         	add	r1, r2
;                                   host_resp.range_num_sec))) ||
7009ae9a: 4288         	cmp	r0, r1
7009ae9c: db22         	blt	0x7009aee4 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x44
7009ae9e: e7ff         	b	0x7009aea0 <Sciclient_rmIrqRouteValidate+0x380> @ imm = #-0x2
;                     (((cur_outp >= all_resp.range_start) &&
7009aea0: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009aea4: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009aea8: 4288         	cmp	r0, r1
7009aeaa: db0a         	blt	0x7009aec2 <Sciclient_rmIrqRouteValidate+0x3a2> @ imm = #0x14
7009aeac: e7ff         	b	0x7009aeae <Sciclient_rmIrqRouteValidate+0x38e> @ imm = #-0x2
;                       (cur_outp < all_resp.range_start + all_resp.range_num)) ||
7009aeae: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009aeb2: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009aeb6: f8bd 2032    	ldrh.w	r2, [sp, #0x32]
7009aeba: 4411         	add	r1, r2
7009aebc: 4288         	cmp	r0, r1
7009aebe: db11         	blt	0x7009aee4 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x22
7009aec0: e7ff         	b	0x7009aec2 <Sciclient_rmIrqRouteValidate+0x3a2> @ imm = #-0x2
;                      ((cur_outp >= all_resp.range_start_sec) &&
7009aec2: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009aec6: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
7009aeca: 4288         	cmp	r0, r1
7009aecc: db2e         	blt	0x7009af2c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #0x5c
7009aece: e7ff         	b	0x7009aed0 <Sciclient_rmIrqRouteValidate+0x3b0> @ imm = #-0x2
;                       (cur_outp < all_resp.range_start_sec +
7009aed0: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009aed4: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
;                                   all_resp.range_num_sec)))) {
7009aed8: f8bd 2036    	ldrh.w	r2, [sp, #0x36]
;                       (cur_outp < all_resp.range_start_sec +
7009aedc: 4411         	add	r1, r2
;                 if ((((cur_outp >= host_resp.range_start) &&
7009aede: 4288         	cmp	r0, r1
7009aee0: da24         	bge	0x7009af2c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #0x48
7009aee2: e7ff         	b	0x7009aee4 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #-0x2
;                     if (Sciclient_rmIrOutpIsFree(cur_n->id, cur_outp) ==
7009aee4: 981a         	ldr	r0, [sp, #0x68]
7009aee6: 8800         	ldrh	r0, [r0]
7009aee8: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009aeec: f00e f928    	bl	0x700a9140 <Sciclient_rmIrOutpIsFree> @ imm = #0xe250
7009aef0: b920         	cbnz	r0, 0x7009aefc <Sciclient_rmIrqRouteValidate+0x3dc> @ imm = #0x8
7009aef2: e7ff         	b	0x7009aef4 <Sciclient_rmIrqRouteValidate+0x3d4> @ imm = #-0x2
7009aef4: 2001         	movs	r0, #0x1
;                         cur_outp_valid = true;
7009aef6: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                     }
7009aefa: e7ff         	b	0x7009aefc <Sciclient_rmIrqRouteValidate+0x3dc> @ imm = #-0x2
;                     if (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
7009aefc: 9819         	ldr	r0, [sp, #0x64]
7009aefe: 8800         	ldrh	r0, [r0]
7009af00: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009af04: f00b f9bc    	bl	0x700a6280 <Sciclient_rmIrInpIsFree> @ imm = #0xb378
7009af08: b920         	cbnz	r0, 0x7009af14 <Sciclient_rmIrqRouteValidate+0x3f4> @ imm = #0x8
7009af0a: e7ff         	b	0x7009af0c <Sciclient_rmIrqRouteValidate+0x3ec> @ imm = #-0x2
7009af0c: 2001         	movs	r0, #0x1
;                         next_inp_valid = true;
7009af0e: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                     }
7009af12: e7ff         	b	0x7009af14 <Sciclient_rmIrqRouteValidate+0x3f4> @ imm = #-0x2
;                     if ((cur_outp_valid == true) &&
7009af14: f89d 005f    	ldrb.w	r0, [sp, #0x5f]
7009af18: 07c0         	lsls	r0, r0, #0x1f
7009af1a: b130         	cbz	r0, 0x7009af2a <Sciclient_rmIrqRouteValidate+0x40a> @ imm = #0xc
7009af1c: e7ff         	b	0x7009af1e <Sciclient_rmIrqRouteValidate+0x3fe> @ imm = #-0x2
;                         (next_inp_valid == true)) {
7009af1e: f89d 005e    	ldrb.w	r0, [sp, #0x5e]
;                     if ((cur_outp_valid == true) &&
7009af22: 07c0         	lsls	r0, r0, #0x1f
7009af24: b108         	cbz	r0, 0x7009af2a <Sciclient_rmIrqRouteValidate+0x40a> @ imm = #0x2
7009af26: e7ff         	b	0x7009af28 <Sciclient_rmIrqRouteValidate+0x408> @ imm = #-0x2
;                         break;
7009af28: e007         	b	0x7009af3a <Sciclient_rmIrqRouteValidate+0x41a> @ imm = #0xe
;                 }
7009af2a: e7ff         	b	0x7009af2c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #-0x2
;             }
7009af2c: e7ff         	b	0x7009af2e <Sciclient_rmIrqRouteValidate+0x40e> @ imm = #-0x2
;                  j++) {
7009af2e: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
7009af32: 3001         	adds	r0, #0x1
7009af34: f8ad 006e    	strh.w	r0, [sp, #0x6e]
;             for (j = cur_if->lbase; j < cur_if->lbase + cur_if->len;
7009af38: e774         	b	0x7009ae24 <Sciclient_rmIrqRouteValidate+0x304> @ imm = #-0x118
;         }
7009af3a: e7ff         	b	0x7009af3c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #-0x2
;         if (i == (Sciclient_rmPsGetPsp() - 1u)) {
7009af3c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009af40: 9001         	str	r0, [sp, #0x4]
7009af42: f014 fea5    	bl	0x700afc90 <Sciclient_rmPsGetPsp> @ imm = #0x14d4a
7009af46: 4601         	mov	r1, r0
7009af48: 9801         	ldr	r0, [sp, #0x4]
7009af4a: 3901         	subs	r1, #0x1
7009af4c: 4288         	cmp	r0, r1
7009af4e: f040 809f    	bne.w	0x7009b090 <Sciclient_rmIrqRouteValidate+0x570> @ imm = #0x13e
7009af52: e7ff         	b	0x7009af54 <Sciclient_rmIrqRouteValidate+0x434> @ imm = #-0x2
7009af54: 2000         	movs	r0, #0x0
;             cur_outp_valid = false;
7009af56: f88d 005f    	strb.w	r0, [sp, #0x5f]
7009af5a: 2101         	movs	r1, #0x1
;             next_inp_valid = true;
7009af5c: f88d 105e    	strb.w	r1, [sp, #0x5e]
;             req.secondary_host = cfg->host;
7009af60: 991d         	ldr	r1, [sp, #0x74]
7009af62: 7909         	ldrb	r1, [r1, #0x4]
7009af64: f88d 1053    	strb.w	r1, [sp, #0x53]
;             req.type = cur_n->id;
7009af68: 991a         	ldr	r1, [sp, #0x68]
7009af6a: 8809         	ldrh	r1, [r1]
7009af6c: f8ad 1050    	strh.w	r1, [sp, #0x50]
;             req.subtype = TISCI_RESASG_SUBTYPE_IR_OUTPUT;
7009af70: f88d 0052    	strb.w	r0, [sp, #0x52]
7009af74: a812         	add	r0, sp, #0x48
7009af76: a90e         	add	r1, sp, #0x38
7009af78: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &host_resp,
7009af7c: f010 fa80    	bl	0x700ab480 <Sciclient_rmGetResourceRange> @ imm = #0x10500
7009af80: b120         	cbz	r0, 0x7009af8c <Sciclient_rmIrqRouteValidate+0x46c> @ imm = #0x8
7009af82: e7ff         	b	0x7009af84 <Sciclient_rmIrqRouteValidate+0x464> @ imm = #-0x2
7009af84: 2000         	movs	r0, #0x0
;                 valid = false;
7009af86: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009af8a: e0bd         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x17a
7009af8c: 2080         	movs	r0, #0x80
;             req.secondary_host = TISCI_HOST_ID_ALL;
7009af8e: f88d 0053    	strb.w	r0, [sp, #0x53]
7009af92: a812         	add	r0, sp, #0x48
7009af94: a90a         	add	r1, sp, #0x28
7009af96: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &all_resp,
7009af9a: f010 fa71    	bl	0x700ab480 <Sciclient_rmGetResourceRange> @ imm = #0x104e2
7009af9e: b120         	cbz	r0, 0x7009afaa <Sciclient_rmIrqRouteValidate+0x48a> @ imm = #0x8
7009afa0: e7ff         	b	0x7009afa2 <Sciclient_rmIrqRouteValidate+0x482> @ imm = #-0x2
7009afa2: 2000         	movs	r0, #0x0
;                 valid = false;
7009afa4: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009afa8: e0ae         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x15c
;             cur_outp = SCICLIENT_INP_TO_OUTP(cfg->d_irq,
7009afaa: 9a18         	ldr	r2, [sp, #0x60]
7009afac: 8810         	ldrh	r0, [r2]
7009afae: 991d         	ldr	r1, [sp, #0x74]
7009afb0: 8989         	ldrh	r1, [r1, #0xc]
7009afb2: 8852         	ldrh	r2, [r2, #0x2]
7009afb4: 1a89         	subs	r1, r1, r2
7009afb6: 4408         	add	r0, r1
7009afb8: f8ad 0056    	strh.w	r0, [sp, #0x56]
;             if ((((cur_outp >= host_resp.range_start) &&
7009afbc: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009afc0: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009afc4: 4288         	cmp	r0, r1
7009afc6: db0a         	blt	0x7009afde <Sciclient_rmIrqRouteValidate+0x4be> @ imm = #0x14
7009afc8: e7ff         	b	0x7009afca <Sciclient_rmIrqRouteValidate+0x4aa> @ imm = #-0x2
;                   (cur_outp < host_resp.range_start + host_resp.range_num)) ||
7009afca: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009afce: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009afd2: f8bd 2042    	ldrh.w	r2, [sp, #0x42]
7009afd6: 4411         	add	r1, r2
7009afd8: 4288         	cmp	r0, r1
7009afda: db33         	blt	0x7009b044 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x66
7009afdc: e7ff         	b	0x7009afde <Sciclient_rmIrqRouteValidate+0x4be> @ imm = #-0x2
;                  ((cur_outp >= host_resp.range_start_sec) &&
7009afde: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009afe2: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
7009afe6: 4288         	cmp	r0, r1
7009afe8: db0a         	blt	0x7009b000 <Sciclient_rmIrqRouteValidate+0x4e0> @ imm = #0x14
7009afea: e7ff         	b	0x7009afec <Sciclient_rmIrqRouteValidate+0x4cc> @ imm = #-0x2
;                   (cur_outp < host_resp.range_start_sec +
7009afec: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009aff0: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
;                               host_resp.range_num_sec))) ||
7009aff4: f8bd 2046    	ldrh.w	r2, [sp, #0x46]
;                   (cur_outp < host_resp.range_start_sec +
7009aff8: 4411         	add	r1, r2
;                               host_resp.range_num_sec))) ||
7009affa: 4288         	cmp	r0, r1
7009affc: db22         	blt	0x7009b044 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x44
7009affe: e7ff         	b	0x7009b000 <Sciclient_rmIrqRouteValidate+0x4e0> @ imm = #-0x2
;                 (((cur_outp >= all_resp.range_start) &&
7009b000: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009b004: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009b008: 4288         	cmp	r0, r1
7009b00a: db0a         	blt	0x7009b022 <Sciclient_rmIrqRouteValidate+0x502> @ imm = #0x14
7009b00c: e7ff         	b	0x7009b00e <Sciclient_rmIrqRouteValidate+0x4ee> @ imm = #-0x2
;                   (cur_outp < all_resp.range_start + all_resp.range_num)) ||
7009b00e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009b012: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009b016: f8bd 2032    	ldrh.w	r2, [sp, #0x32]
7009b01a: 4411         	add	r1, r2
7009b01c: 4288         	cmp	r0, r1
7009b01e: db11         	blt	0x7009b044 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x22
7009b020: e7ff         	b	0x7009b022 <Sciclient_rmIrqRouteValidate+0x502> @ imm = #-0x2
;                  ((cur_outp >= all_resp.range_start_sec) &&
7009b022: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009b026: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
7009b02a: 4288         	cmp	r0, r1
7009b02c: db2f         	blt	0x7009b08e <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #0x5e
7009b02e: e7ff         	b	0x7009b030 <Sciclient_rmIrqRouteValidate+0x510> @ imm = #-0x2
;                   (cur_outp < all_resp.range_start_sec +
7009b030: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009b034: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
;                               all_resp.range_num_sec)))) {
7009b038: f8bd 2036    	ldrh.w	r2, [sp, #0x36]
;                   (cur_outp < all_resp.range_start_sec +
7009b03c: 4411         	add	r1, r2
;             if ((((cur_outp >= host_resp.range_start) &&
7009b03e: 4288         	cmp	r0, r1
7009b040: da25         	bge	0x7009b08e <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #0x4a
7009b042: e7ff         	b	0x7009b044 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #-0x2
;                 if ((cur_if->rid == cfg->d_id) &&
7009b044: 9818         	ldr	r0, [sp, #0x60]
7009b046: 88c0         	ldrh	r0, [r0, #0x6]
7009b048: 991d         	ldr	r1, [sp, #0x74]
7009b04a: 8949         	ldrh	r1, [r1, #0xa]
7009b04c: 4288         	cmp	r0, r1
7009b04e: d11d         	bne	0x7009b08c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x3a
7009b050: e7ff         	b	0x7009b052 <Sciclient_rmIrqRouteValidate+0x532> @ imm = #-0x2
;                     (cfg->d_irq >= (cur_if->rbase)) &&
7009b052: 981d         	ldr	r0, [sp, #0x74]
7009b054: 8980         	ldrh	r0, [r0, #0xc]
7009b056: 9918         	ldr	r1, [sp, #0x60]
7009b058: 8849         	ldrh	r1, [r1, #0x2]
7009b05a: 4288         	cmp	r0, r1
7009b05c: db16         	blt	0x7009b08c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x2c
7009b05e: e7ff         	b	0x7009b060 <Sciclient_rmIrqRouteValidate+0x540> @ imm = #-0x2
;                     (cfg->d_irq < (cur_if->rbase + cur_if->len))) {
7009b060: 981d         	ldr	r0, [sp, #0x74]
7009b062: 8980         	ldrh	r0, [r0, #0xc]
7009b064: 9a18         	ldr	r2, [sp, #0x60]
7009b066: 8851         	ldrh	r1, [r2, #0x2]
7009b068: 8892         	ldrh	r2, [r2, #0x4]
7009b06a: 4411         	add	r1, r2
;                 if ((cur_if->rid == cfg->d_id) &&
7009b06c: 4288         	cmp	r0, r1
7009b06e: da0d         	bge	0x7009b08c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x1a
7009b070: e7ff         	b	0x7009b072 <Sciclient_rmIrqRouteValidate+0x552> @ imm = #-0x2
;                     if (Sciclient_rmIrOutpIsFree(cur_n->id, cur_outp) ==
7009b072: 981a         	ldr	r0, [sp, #0x68]
7009b074: 8800         	ldrh	r0, [r0]
7009b076: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009b07a: f00e f861    	bl	0x700a9140 <Sciclient_rmIrOutpIsFree> @ imm = #0xe0c2
7009b07e: b920         	cbnz	r0, 0x7009b08a <Sciclient_rmIrqRouteValidate+0x56a> @ imm = #0x8
7009b080: e7ff         	b	0x7009b082 <Sciclient_rmIrqRouteValidate+0x562> @ imm = #-0x2
7009b082: 2001         	movs	r0, #0x1
;                         cur_outp_valid = true;
7009b084: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                     }
7009b088: e7ff         	b	0x7009b08a <Sciclient_rmIrqRouteValidate+0x56a> @ imm = #-0x2
;                 }
7009b08a: e7ff         	b	0x7009b08c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #-0x2
; 	    }
7009b08c: e7ff         	b	0x7009b08e <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #-0x2
;         }
7009b08e: e7ff         	b	0x7009b090 <Sciclient_rmIrqRouteValidate+0x570> @ imm = #-0x2
;         if ((cur_outp_valid == true) && (next_inp_valid == true)) {
7009b090: f89d 005f    	ldrb.w	r0, [sp, #0x5f]
7009b094: 07c0         	lsls	r0, r0, #0x1f
7009b096: b360         	cbz	r0, 0x7009b0f2 <Sciclient_rmIrqRouteValidate+0x5d2> @ imm = #0x58
7009b098: e7ff         	b	0x7009b09a <Sciclient_rmIrqRouteValidate+0x57a> @ imm = #-0x2
7009b09a: f89d 005e    	ldrb.w	r0, [sp, #0x5e]
7009b09e: 07c0         	lsls	r0, r0, #0x1f
7009b0a0: b338         	cbz	r0, 0x7009b0f2 <Sciclient_rmIrqRouteValidate+0x5d2> @ imm = #0x4e
7009b0a2: e7ff         	b	0x7009b0a4 <Sciclient_rmIrqRouteValidate+0x584> @ imm = #-0x2
;             if (i < (Sciclient_rmPsGetPsp() - (1u))) {
7009b0a4: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009b0a8: 9000         	str	r0, [sp]
7009b0aa: f014 fdf1    	bl	0x700afc90 <Sciclient_rmPsGetPsp> @ imm = #0x14be2
7009b0ae: 4601         	mov	r1, r0
7009b0b0: 9800         	ldr	r0, [sp]
7009b0b2: 3901         	subs	r1, #0x1
7009b0b4: 4288         	cmp	r0, r1
7009b0b6: d20f         	bhs	0x7009b0d8 <Sciclient_rmIrqRouteValidate+0x5b8> @ imm = #0x1e
7009b0b8: e7ff         	b	0x7009b0ba <Sciclient_rmIrqRouteValidate+0x59a> @ imm = #-0x2
;                 if (Sciclient_rmPsSetInp(i + (1u), next_inp) != SystemP_SUCCESS) {
7009b0ba: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009b0be: 3001         	adds	r0, #0x1
7009b0c0: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009b0c4: b280         	uxth	r0, r0
7009b0c6: f012 f92b    	bl	0x700ad320 <Sciclient_rmPsSetInp> @ imm = #0x12256
7009b0ca: b120         	cbz	r0, 0x7009b0d6 <Sciclient_rmIrqRouteValidate+0x5b6> @ imm = #0x8
7009b0cc: e7ff         	b	0x7009b0ce <Sciclient_rmIrqRouteValidate+0x5ae> @ imm = #-0x2
7009b0ce: 2000         	movs	r0, #0x0
;                     valid = false;
7009b0d0: f88d 0073    	strb.w	r0, [sp, #0x73]
;                     break;
7009b0d4: e018         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x30
;             }
7009b0d6: e7ff         	b	0x7009b0d8 <Sciclient_rmIrqRouteValidate+0x5b8> @ imm = #-0x2
;             if (Sciclient_rmPsSetOutp(i, cur_outp) != SystemP_SUCCESS) {
7009b0d8: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009b0dc: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009b0e0: f012 f946    	bl	0x700ad370 <Sciclient_rmPsSetOutp> @ imm = #0x1228c
7009b0e4: b120         	cbz	r0, 0x7009b0f0 <Sciclient_rmIrqRouteValidate+0x5d0> @ imm = #0x8
7009b0e6: e7ff         	b	0x7009b0e8 <Sciclient_rmIrqRouteValidate+0x5c8> @ imm = #-0x2
7009b0e8: 2000         	movs	r0, #0x0
;                 valid = false;
7009b0ea: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009b0ee: e00b         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x16
;         } else {
7009b0f0: e003         	b	0x7009b0fa <Sciclient_rmIrqRouteValidate+0x5da> @ imm = #0x6
7009b0f2: 2000         	movs	r0, #0x0
;             valid = false;
7009b0f4: f88d 0073    	strb.w	r0, [sp, #0x73]
;             break;
7009b0f8: e006         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0xc
;     }
7009b0fa: e7ff         	b	0x7009b0fc <Sciclient_rmIrqRouteValidate+0x5dc> @ imm = #-0x2
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
7009b0fc: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009b100: 3001         	adds	r0, #0x1
7009b102: f8ad 0070    	strh.w	r0, [sp, #0x70]
7009b106: e579         	b	0x7009abfc <Sciclient_rmIrqRouteValidate+0xdc> @ imm = #-0x50e
;     return valid;
7009b108: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009b10c: f000 0001    	and	r0, r0, #0x1
7009b110: b01e         	add	sp, #0x78
7009b112: bd80         	pop	{r7, pc}

7009b114 <__aeabi_memclr8>:
7009b114: e1a02001     	mov	r2, r1
7009b118: e3b01000     	movs	r1, #0
7009b11c: ea005199     	b	0x700af788 <TI_memset_small> @ imm = #0x14664

7009b120 <_ftoa>:
; {
7009b120: b570         	push	{r4, r5, r6, lr}
7009b122: b0a2         	sub	sp, #0x88
7009b124: f8dd c0a0    	ldr.w	r12, [sp, #0xa0]
7009b128: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009b12c: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009b130: 9020         	str	r0, [sp, #0x80]
7009b132: 911f         	str	r1, [sp, #0x7c]
7009b134: 921e         	str	r2, [sp, #0x78]
7009b136: 931d         	str	r3, [sp, #0x74]
7009b138: ed8d 0b1a    	vstr	d0, [sp, #104]
7009b13c: 2000         	movs	r0, #0x0
;   size_t len  = 0U;
7009b13e: 9011         	str	r0, [sp, #0x44]
;   double diff = 0.0;
7009b140: 900f         	str	r0, [sp, #0x3c]
7009b142: 900e         	str	r0, [sp, #0x38]
;   if (value != value)
7009b144: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b148: eeb4 0b40    	vcmp.f64	d0, d0
7009b14c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b150: d71a         	bvc	0x7009b188 <_ftoa+0x68> @ imm = #0x34
7009b152: e7ff         	b	0x7009b154 <_ftoa+0x34> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
7009b154: 9820         	ldr	r0, [sp, #0x80]
7009b156: 991f         	ldr	r1, [sp, #0x7c]
7009b158: 9a1e         	ldr	r2, [sp, #0x78]
7009b15a: 9b1d         	ldr	r3, [sp, #0x74]
7009b15c: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009b160: 9c28         	ldr	r4, [sp, #0xa0]
7009b162: 46ee         	mov	lr, sp
7009b164: f8ce 400c    	str.w	r4, [lr, #0xc]
7009b168: f8ce c008    	str.w	r12, [lr, #0x8]
7009b16c: f04f 0c03    	mov.w	r12, #0x3
7009b170: f8ce c004    	str.w	r12, [lr, #0x4]
7009b174: f242 6c48    	movw	r12, #0x2648
7009b178: f2c7 0c0b    	movt	r12, #0x700b
7009b17c: f8ce c000    	str.w	r12, [lr]
7009b180: f00c fa86    	bl	0x700a7690 <_out_rev>   @ imm = #0xc50c
7009b184: 9021         	str	r0, [sp, #0x84]
7009b186: e257         	b	0x7009b638 <_ftoa+0x518> @ imm = #0x4ae
;   if (value < -DBL_MAX)
7009b188: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b18c: ed9f 1bd2    	vldr	d1, [pc, #840]          @ 0x7009b4d8 <_ftoa+0x3b8>
7009b190: eeb4 0b41    	vcmp.f64	d0, d1
7009b194: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b198: d51a         	bpl	0x7009b1d0 <_ftoa+0xb0> @ imm = #0x34
7009b19a: e7ff         	b	0x7009b19c <_ftoa+0x7c> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
7009b19c: 9820         	ldr	r0, [sp, #0x80]
7009b19e: 991f         	ldr	r1, [sp, #0x7c]
7009b1a0: 9a1e         	ldr	r2, [sp, #0x78]
7009b1a2: 9b1d         	ldr	r3, [sp, #0x74]
7009b1a4: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009b1a8: 9c28         	ldr	r4, [sp, #0xa0]
7009b1aa: 46ee         	mov	lr, sp
7009b1ac: f8ce 400c    	str.w	r4, [lr, #0xc]
7009b1b0: f8ce c008    	str.w	r12, [lr, #0x8]
7009b1b4: f04f 0c04    	mov.w	r12, #0x4
7009b1b8: f8ce c004    	str.w	r12, [lr, #0x4]
7009b1bc: f242 6c21    	movw	r12, #0x2621
7009b1c0: f2c7 0c0b    	movt	r12, #0x700b
7009b1c4: f8ce c000    	str.w	r12, [lr]
7009b1c8: f00c fa62    	bl	0x700a7690 <_out_rev>   @ imm = #0xc4c4
7009b1cc: 9021         	str	r0, [sp, #0x84]
7009b1ce: e233         	b	0x7009b638 <_ftoa+0x518> @ imm = #0x466
;   if (value > DBL_MAX)
7009b1d0: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b1d4: ed9f 1bc2    	vldr	d1, [pc, #776]          @ 0x7009b4e0 <_ftoa+0x3c0>
7009b1d8: eeb4 0b41    	vcmp.f64	d0, d1
7009b1dc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b1e0: dd26         	ble	0x7009b230 <_ftoa+0x110> @ imm = #0x4c
7009b1e2: e7ff         	b	0x7009b1e4 <_ftoa+0xc4> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
7009b1e4: 9820         	ldr	r0, [sp, #0x80]
7009b1e6: 991f         	ldr	r1, [sp, #0x7c]
7009b1e8: 9a1e         	ldr	r2, [sp, #0x78]
7009b1ea: 9b1d         	ldr	r3, [sp, #0x74]
7009b1ec: 9e28         	ldr	r6, [sp, #0xa0]
7009b1ee: f006 0e04    	and	lr, r6, #0x4
7009b1f2: f242 642b    	movw	r4, #0x262b
7009b1f6: f2c7 040b    	movt	r4, #0x700b
7009b1fa: f242 6c44    	movw	r12, #0x2644
7009b1fe: f2c7 0c0b    	movt	r12, #0x700b
7009b202: f1be 0f00    	cmp.w	lr, #0x0
7009b206: bf18         	it	ne
7009b208: 46a4         	movne	r12, r4
7009b20a: 2403         	movs	r4, #0x3
7009b20c: f1be 0f00    	cmp.w	lr, #0x0
7009b210: bf18         	it	ne
7009b212: 2404         	movne	r4, #0x4
7009b214: 9d27         	ldr	r5, [sp, #0x9c]
7009b216: 46ee         	mov	lr, sp
7009b218: f8ce 600c    	str.w	r6, [lr, #0xc]
7009b21c: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b220: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b224: f8ce c000    	str.w	r12, [lr]
7009b228: f00c fa32    	bl	0x700a7690 <_out_rev>   @ imm = #0xc464
7009b22c: 9021         	str	r0, [sp, #0x84]
7009b22e: e203         	b	0x7009b638 <_ftoa+0x518> @ imm = #0x406
;   if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
7009b230: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b234: ed9f 1bac    	vldr	d1, [pc, #688]          @ 0x7009b4e8 <_ftoa+0x3c8>
7009b238: eeb4 0b41    	vcmp.f64	d0, d1
7009b23c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b240: dc0a         	bgt	0x7009b258 <_ftoa+0x138> @ imm = #0x14
7009b242: e7ff         	b	0x7009b244 <_ftoa+0x124> @ imm = #-0x2
7009b244: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b248: ed9f 1ba9    	vldr	d1, [pc, #676]          @ 0x7009b4f0 <_ftoa+0x3d0>
7009b24c: eeb4 0b41    	vcmp.f64	d0, d1
7009b250: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b254: d515         	bpl	0x7009b282 <_ftoa+0x162> @ imm = #0x2a
7009b256: e7ff         	b	0x7009b258 <_ftoa+0x138> @ imm = #-0x2
;     return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
7009b258: 9820         	ldr	r0, [sp, #0x80]
7009b25a: 991f         	ldr	r1, [sp, #0x7c]
7009b25c: 9a1e         	ldr	r2, [sp, #0x78]
7009b25e: 9b1d         	ldr	r3, [sp, #0x74]
7009b260: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b264: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009b268: 9c27         	ldr	r4, [sp, #0x9c]
7009b26a: 9d28         	ldr	r5, [sp, #0xa0]
7009b26c: 46ee         	mov	lr, sp
7009b26e: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b272: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b276: f8ce c000    	str.w	r12, [lr]
7009b27a: f000 f9e1    	bl	0x7009b640 <_etoa>      @ imm = #0x3c2
7009b27e: 9021         	str	r0, [sp, #0x84]
7009b280: e1da         	b	0x7009b638 <_ftoa+0x518> @ imm = #0x3b4
7009b282: f04f 0000    	mov.w	r0, #0x0
;   bool negative = false;
7009b286: f88d 0037    	strb.w	r0, [sp, #0x37]
;   if (value < 0) {
7009b28a: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b28e: eeb5 0b40    	vcmp.f64	d0, #0
7009b292: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b296: d50d         	bpl	0x7009b2b4 <_ftoa+0x194> @ imm = #0x1a
7009b298: e7ff         	b	0x7009b29a <_ftoa+0x17a> @ imm = #-0x2
7009b29a: f04f 0001    	mov.w	r0, #0x1
;     negative = true;
7009b29e: f88d 0037    	strb.w	r0, [sp, #0x37]
;     value = 0 - value;
7009b2a2: ed9d 1b1a    	vldr	d1, [sp, #104]
7009b2a6: ed9f 0b94    	vldr	d0, [pc, #592]          @ 0x7009b4f8 <_ftoa+0x3d8>
7009b2aa: ee30 0b41    	vsub.f64	d0, d0, d1
7009b2ae: ed8d 0b1a    	vstr	d0, [sp, #104]
;   }
7009b2b2: e7ff         	b	0x7009b2b4 <_ftoa+0x194> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION)) {
7009b2b4: f89d 00a1    	ldrb.w	r0, [sp, #0xa1]
7009b2b8: ea4f 7040    	lsl.w	r0, r0, #0x1d
7009b2bc: 2800         	cmp	r0, #0x0
7009b2be: d403         	bmi	0x7009b2c8 <_ftoa+0x1a8> @ imm = #0x6
7009b2c0: e7ff         	b	0x7009b2c2 <_ftoa+0x1a2> @ imm = #-0x2
7009b2c2: 2006         	movs	r0, #0x6
;     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
7009b2c4: 9026         	str	r0, [sp, #0x98]
;   }
7009b2c6: e7ff         	b	0x7009b2c8 <_ftoa+0x1a8> @ imm = #-0x2
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009b2c8: e7ff         	b	0x7009b2ca <_ftoa+0x1aa> @ imm = #-0x2
7009b2ca: 9911         	ldr	r1, [sp, #0x44]
7009b2cc: 2000         	movs	r0, #0x0
7009b2ce: 291f         	cmp	r1, #0x1f
7009b2d0: 9007         	str	r0, [sp, #0x1c]
7009b2d2: d807         	bhi	0x7009b2e4 <_ftoa+0x1c4> @ imm = #0xe
7009b2d4: e7ff         	b	0x7009b2d6 <_ftoa+0x1b6> @ imm = #-0x2
7009b2d6: 9926         	ldr	r1, [sp, #0x98]
7009b2d8: 2000         	movs	r0, #0x0
7009b2da: 2909         	cmp	r1, #0x9
7009b2dc: bf88         	it	hi
7009b2de: 2001         	movhi	r0, #0x1
7009b2e0: 9007         	str	r0, [sp, #0x1c]
7009b2e2: e7ff         	b	0x7009b2e4 <_ftoa+0x1c4> @ imm = #-0x2
7009b2e4: 9807         	ldr	r0, [sp, #0x1c]
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009b2e6: 07c0         	lsls	r0, r0, #0x1f
7009b2e8: b150         	cbz	r0, 0x7009b300 <_ftoa+0x1e0> @ imm = #0x14
7009b2ea: e7ff         	b	0x7009b2ec <_ftoa+0x1cc> @ imm = #-0x2
;     buf[len++] = '0';
7009b2ec: 9a11         	ldr	r2, [sp, #0x44]
7009b2ee: 1c50         	adds	r0, r2, #0x1
7009b2f0: 9011         	str	r0, [sp, #0x44]
7009b2f2: a912         	add	r1, sp, #0x48
7009b2f4: 2030         	movs	r0, #0x30
7009b2f6: 5488         	strb	r0, [r1, r2]
;     prec--;
7009b2f8: 9826         	ldr	r0, [sp, #0x98]
7009b2fa: 3801         	subs	r0, #0x1
7009b2fc: 9026         	str	r0, [sp, #0x98]
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009b2fe: e7e4         	b	0x7009b2ca <_ftoa+0x1aa> @ imm = #-0x38
;   int whole = (int)value;
7009b300: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b304: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009b308: ed8d 0a0c    	vstr	s0, [sp, #48]
;   double tmp = (value - whole) * pow10[prec];
7009b30c: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b310: ed9d 1a0c    	vldr	s2, [sp, #48]
7009b314: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009b318: ee30 0b41    	vsub.f64	d0, d0, d1
7009b31c: 9926         	ldr	r1, [sp, #0x98]
7009b31e: f641 1020    	movw	r0, #0x1920
7009b322: f2c7 000b    	movt	r0, #0x700b
7009b326: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009b32a: ed90 1b00    	vldr	d1, [r0]
7009b32e: ee20 0b01    	vmul.f64	d0, d0, d1
7009b332: ed8d 0b0a    	vstr	d0, [sp, #40]
;   unsigned long frac = (unsigned long)tmp;
7009b336: ed9d 0b0a    	vldr	d0, [sp, #40]
7009b33a: eebc 0bc0    	vcvt.u32.f64	s0, d0
7009b33e: ed8d 0a09    	vstr	s0, [sp, #36]
;   diff = tmp - frac;
7009b342: ed9d 0b0a    	vldr	d0, [sp, #40]
7009b346: ed9d 1a09    	vldr	s2, [sp, #36]
7009b34a: eeb8 1b41    	vcvt.f64.u32	d1, s2
7009b34e: ee30 0b41    	vsub.f64	d0, d0, d1
7009b352: ed8d 0b0e    	vstr	d0, [sp, #56]
;   if (diff > 0.5) {
7009b356: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b35a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b35e: eeb4 0b41    	vcmp.f64	d0, d1
7009b362: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b366: dd1e         	ble	0x7009b3a6 <_ftoa+0x286> @ imm = #0x3c
7009b368: e7ff         	b	0x7009b36a <_ftoa+0x24a> @ imm = #-0x2
;     ++frac;
7009b36a: 9809         	ldr	r0, [sp, #0x24]
7009b36c: 3001         	adds	r0, #0x1
7009b36e: 9009         	str	r0, [sp, #0x24]
;     if (frac >= pow10[prec]) {
7009b370: ed9d 0a09    	vldr	s0, [sp, #36]
7009b374: eeb8 0b40    	vcvt.f64.u32	d0, s0
7009b378: 9926         	ldr	r1, [sp, #0x98]
7009b37a: f641 1020    	movw	r0, #0x1920
7009b37e: f2c7 000b    	movt	r0, #0x700b
7009b382: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009b386: ed90 1b00    	vldr	d1, [r0]
7009b38a: eeb4 0b41    	vcmp.f64	d0, d1
7009b38e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b392: db07         	blt	0x7009b3a4 <_ftoa+0x284> @ imm = #0xe
7009b394: e7ff         	b	0x7009b396 <_ftoa+0x276> @ imm = #-0x2
7009b396: f04f 0000    	mov.w	r0, #0x0
;       frac = 0;
7009b39a: 9009         	str	r0, [sp, #0x24]
;       ++whole;
7009b39c: 980c         	ldr	r0, [sp, #0x30]
7009b39e: 3001         	adds	r0, #0x1
7009b3a0: 900c         	str	r0, [sp, #0x30]
;     }
7009b3a2: e7ff         	b	0x7009b3a4 <_ftoa+0x284> @ imm = #-0x2
;   }
7009b3a4: e018         	b	0x7009b3d8 <_ftoa+0x2b8> @ imm = #0x30
;   else if (diff < 0.5) {
7009b3a6: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b3aa: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b3ae: eeb4 0b41    	vcmp.f64	d0, d1
7009b3b2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b3b6: d501         	bpl	0x7009b3bc <_ftoa+0x29c> @ imm = #0x2
7009b3b8: e7ff         	b	0x7009b3ba <_ftoa+0x29a> @ imm = #-0x2
;   }
7009b3ba: e00c         	b	0x7009b3d6 <_ftoa+0x2b6> @ imm = #0x18
;   else if ((frac == 0U) || (frac & 1U)) {
7009b3bc: 9809         	ldr	r0, [sp, #0x24]
7009b3be: b128         	cbz	r0, 0x7009b3cc <_ftoa+0x2ac> @ imm = #0xa
7009b3c0: e7ff         	b	0x7009b3c2 <_ftoa+0x2a2> @ imm = #-0x2
7009b3c2: f89d 0024    	ldrb.w	r0, [sp, #0x24]
7009b3c6: 07c0         	lsls	r0, r0, #0x1f
7009b3c8: b120         	cbz	r0, 0x7009b3d4 <_ftoa+0x2b4> @ imm = #0x8
7009b3ca: e7ff         	b	0x7009b3cc <_ftoa+0x2ac> @ imm = #-0x2
;     ++frac;
7009b3cc: 9809         	ldr	r0, [sp, #0x24]
7009b3ce: 3001         	adds	r0, #0x1
7009b3d0: 9009         	str	r0, [sp, #0x24]
;   }
7009b3d2: e7ff         	b	0x7009b3d4 <_ftoa+0x2b4> @ imm = #-0x2
7009b3d4: e7ff         	b	0x7009b3d6 <_ftoa+0x2b6> @ imm = #-0x2
7009b3d6: e7ff         	b	0x7009b3d8 <_ftoa+0x2b8> @ imm = #-0x2
;   if (prec == 0U) {
7009b3d8: 9826         	ldr	r0, [sp, #0x98]
7009b3da: bb48         	cbnz	r0, 0x7009b430 <_ftoa+0x310> @ imm = #0x52
7009b3dc: e7ff         	b	0x7009b3de <_ftoa+0x2be> @ imm = #-0x2
;     diff = value - (double)whole;
7009b3de: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b3e2: ed9d 1a0c    	vldr	s2, [sp, #48]
7009b3e6: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009b3ea: ee30 0b41    	vsub.f64	d0, d0, d1
7009b3ee: ed8d 0b0e    	vstr	d0, [sp, #56]
;     if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
7009b3f2: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b3f6: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b3fa: eeb4 0b41    	vcmp.f64	d0, d1
7009b3fe: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b402: d50a         	bpl	0x7009b41a <_ftoa+0x2fa> @ imm = #0x14
7009b404: e7ff         	b	0x7009b406 <_ftoa+0x2e6> @ imm = #-0x2
7009b406: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b40a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b40e: eeb4 0b41    	vcmp.f64	d0, d1
7009b412: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b416: dd0a         	ble	0x7009b42e <_ftoa+0x30e> @ imm = #0x14
7009b418: e7ff         	b	0x7009b41a <_ftoa+0x2fa> @ imm = #-0x2
7009b41a: f89d 0030    	ldrb.w	r0, [sp, #0x30]
7009b41e: ea4f 70c0    	lsl.w	r0, r0, #0x1f
7009b422: b120         	cbz	r0, 0x7009b42e <_ftoa+0x30e> @ imm = #0x8
7009b424: e7ff         	b	0x7009b426 <_ftoa+0x306> @ imm = #-0x2
;       ++whole;
7009b426: 980c         	ldr	r0, [sp, #0x30]
7009b428: 3001         	adds	r0, #0x1
7009b42a: 900c         	str	r0, [sp, #0x30]
;     }
7009b42c: e7ff         	b	0x7009b42e <_ftoa+0x30e> @ imm = #-0x2
;   }
7009b42e: e04d         	b	0x7009b4cc <_ftoa+0x3ac> @ imm = #0x9a
;     unsigned int count = prec;
7009b430: 9826         	ldr	r0, [sp, #0x98]
7009b432: 9008         	str	r0, [sp, #0x20]
;     while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b434: e7ff         	b	0x7009b436 <_ftoa+0x316> @ imm = #-0x2
7009b436: 9811         	ldr	r0, [sp, #0x44]
7009b438: 281f         	cmp	r0, #0x1f
7009b43a: d821         	bhi	0x7009b480 <_ftoa+0x360> @ imm = #0x42
7009b43c: e7ff         	b	0x7009b43e <_ftoa+0x31e> @ imm = #-0x2
;       --count;
7009b43e: 9808         	ldr	r0, [sp, #0x20]
7009b440: 3801         	subs	r0, #0x1
7009b442: 9008         	str	r0, [sp, #0x20]
;       buf[len++] = (char)(48U + (frac % 10U));
7009b444: 9809         	ldr	r0, [sp, #0x24]
7009b446: f64c 41cd    	movw	r1, #0xcccd
7009b44a: f6cc 41cc    	movt	r1, #0xcccc
7009b44e: fba0 3201    	umull	r3, r2, r0, r1
7009b452: ea4f 02d2    	lsr.w	r2, r2, #0x3
7009b456: eb02 0282    	add.w	r2, r2, r2, lsl #2
7009b45a: eba0 0042    	sub.w	r0, r0, r2, lsl #1
7009b45e: f040 0030    	orr	r0, r0, #0x30
7009b462: 9b11         	ldr	r3, [sp, #0x44]
7009b464: 1c5a         	adds	r2, r3, #0x1
7009b466: 9211         	str	r2, [sp, #0x44]
7009b468: aa12         	add	r2, sp, #0x48
7009b46a: 54d0         	strb	r0, [r2, r3]
;       if (!(frac /= 10U)) {
7009b46c: 9809         	ldr	r0, [sp, #0x24]
7009b46e: fba0 1001    	umull	r1, r0, r0, r1
7009b472: ea4f 00d0    	lsr.w	r0, r0, #0x3
7009b476: 9009         	str	r0, [sp, #0x24]
7009b478: b908         	cbnz	r0, 0x7009b47e <_ftoa+0x35e> @ imm = #0x2
7009b47a: e7ff         	b	0x7009b47c <_ftoa+0x35c> @ imm = #-0x2
;         break;
7009b47c: e000         	b	0x7009b480 <_ftoa+0x360> @ imm = #0x0
;     while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b47e: e7da         	b	0x7009b436 <_ftoa+0x316> @ imm = #-0x4c
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009b480: e7ff         	b	0x7009b482 <_ftoa+0x362> @ imm = #-0x2
7009b482: 9911         	ldr	r1, [sp, #0x44]
7009b484: 2000         	movs	r0, #0x0
7009b486: 291f         	cmp	r1, #0x1f
7009b488: 9006         	str	r0, [sp, #0x18]
7009b48a: d808         	bhi	0x7009b49e <_ftoa+0x37e> @ imm = #0x10
7009b48c: e7ff         	b	0x7009b48e <_ftoa+0x36e> @ imm = #-0x2
7009b48e: 9808         	ldr	r0, [sp, #0x20]
7009b490: 1e41         	subs	r1, r0, #0x1
7009b492: 9108         	str	r1, [sp, #0x20]
7009b494: 2800         	cmp	r0, #0x0
7009b496: bf18         	it	ne
7009b498: 2001         	movne	r0, #0x1
7009b49a: 9006         	str	r0, [sp, #0x18]
7009b49c: e7ff         	b	0x7009b49e <_ftoa+0x37e> @ imm = #-0x2
7009b49e: 9806         	ldr	r0, [sp, #0x18]
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009b4a0: 07c0         	lsls	r0, r0, #0x1f
7009b4a2: b138         	cbz	r0, 0x7009b4b4 <_ftoa+0x394> @ imm = #0xe
7009b4a4: e7ff         	b	0x7009b4a6 <_ftoa+0x386> @ imm = #-0x2
;       buf[len++] = '0';
7009b4a6: 9a11         	ldr	r2, [sp, #0x44]
7009b4a8: 1c50         	adds	r0, r2, #0x1
7009b4aa: 9011         	str	r0, [sp, #0x44]
7009b4ac: a912         	add	r1, sp, #0x48
7009b4ae: 2030         	movs	r0, #0x30
7009b4b0: 5488         	strb	r0, [r1, r2]
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009b4b2: e7e6         	b	0x7009b482 <_ftoa+0x362> @ imm = #-0x34
;     if (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b4b4: 9811         	ldr	r0, [sp, #0x44]
7009b4b6: 281f         	cmp	r0, #0x1f
7009b4b8: d807         	bhi	0x7009b4ca <_ftoa+0x3aa> @ imm = #0xe
7009b4ba: e7ff         	b	0x7009b4bc <_ftoa+0x39c> @ imm = #-0x2
;       buf[len++] = '.';
7009b4bc: 9a11         	ldr	r2, [sp, #0x44]
7009b4be: 1c50         	adds	r0, r2, #0x1
7009b4c0: 9011         	str	r0, [sp, #0x44]
7009b4c2: a912         	add	r1, sp, #0x48
7009b4c4: 202e         	movs	r0, #0x2e
7009b4c6: 5488         	strb	r0, [r1, r2]
;     }
7009b4c8: e7ff         	b	0x7009b4ca <_ftoa+0x3aa> @ imm = #-0x2
7009b4ca: e7ff         	b	0x7009b4cc <_ftoa+0x3ac> @ imm = #-0x2
;   while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b4cc: e7ff         	b	0x7009b4ce <_ftoa+0x3ae> @ imm = #-0x2
7009b4ce: 9811         	ldr	r0, [sp, #0x44]
7009b4d0: 281f         	cmp	r0, #0x1f
7009b4d2: d835         	bhi	0x7009b540 <_ftoa+0x420> @ imm = #0x6a
7009b4d4: e014         	b	0x7009b500 <_ftoa+0x3e0> @ imm = #0x28
7009b4d6: bf00         	nop
7009b4d8: ff ff ff ff  	.word	0xffffffff
7009b4dc: ff ff ef ff  	.word	0xffefffff
7009b4e0: ff ff ff ff  	.word	0xffffffff
7009b4e4: ff ff ef 7f  	.word	0x7fefffff
7009b4e8: 00 00 00 00  	.word	0x00000000
7009b4ec: 65 cd cd 41  	.word	0x41cdcd65
7009b4f0: 00 00 00 00  	.word	0x00000000
7009b4f4: 65 cd cd c1  	.word	0xc1cdcd65
7009b4f8: 00 00 00 00  	.word	0x00000000
7009b4fc: 00 00 00 00  	.word	0x00000000
;     buf[len++] = (char)(48 + (whole % 10));
7009b500: 980c         	ldr	r0, [sp, #0x30]
7009b502: f246 6167    	movw	r1, #0x6667
7009b506: f2c6 6166    	movt	r1, #0x6666
7009b50a: fb50 f301    	smmul	r3, r0, r1
7009b50e: 089a         	lsrs	r2, r3, #0x2
7009b510: eb02 72d3    	add.w	r2, r2, r3, lsr #31
7009b514: eb02 0282    	add.w	r2, r2, r2, lsl #2
7009b518: eba0 0042    	sub.w	r0, r0, r2, lsl #1
7009b51c: 3030         	adds	r0, #0x30
7009b51e: 9b11         	ldr	r3, [sp, #0x44]
7009b520: 1c5a         	adds	r2, r3, #0x1
7009b522: 9211         	str	r2, [sp, #0x44]
7009b524: aa12         	add	r2, sp, #0x48
7009b526: 54d0         	strb	r0, [r2, r3]
;     if (!(whole /= 10)) {
7009b528: 980c         	ldr	r0, [sp, #0x30]
7009b52a: fb50 f101    	smmul	r1, r0, r1
7009b52e: ea4f 00a1    	asr.w	r0, r1, #0x2
7009b532: eb00 70d1    	add.w	r0, r0, r1, lsr #31
7009b536: 900c         	str	r0, [sp, #0x30]
7009b538: b908         	cbnz	r0, 0x7009b53e <_ftoa+0x41e> @ imm = #0x2
7009b53a: e7ff         	b	0x7009b53c <_ftoa+0x41c> @ imm = #-0x2
;       break;
7009b53c: e000         	b	0x7009b540 <_ftoa+0x420> @ imm = #0x0
;   while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b53e: e7c6         	b	0x7009b4ce <_ftoa+0x3ae> @ imm = #-0x74
;   if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
7009b540: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b544: 0780         	lsls	r0, r0, #0x1e
7009b546: 2800         	cmp	r0, #0x0
7009b548: d432         	bmi	0x7009b5b0 <_ftoa+0x490> @ imm = #0x64
7009b54a: e7ff         	b	0x7009b54c <_ftoa+0x42c> @ imm = #-0x2
7009b54c: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b550: 07c0         	lsls	r0, r0, #0x1f
7009b552: b368         	cbz	r0, 0x7009b5b0 <_ftoa+0x490> @ imm = #0x5a
7009b554: e7ff         	b	0x7009b556 <_ftoa+0x436> @ imm = #-0x2
;     if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
7009b556: 9827         	ldr	r0, [sp, #0x9c]
7009b558: b178         	cbz	r0, 0x7009b57a <_ftoa+0x45a> @ imm = #0x1e
7009b55a: e7ff         	b	0x7009b55c <_ftoa+0x43c> @ imm = #-0x2
7009b55c: f89d 0037    	ldrb.w	r0, [sp, #0x37]
7009b560: 07c0         	lsls	r0, r0, #0x1f
7009b562: b930         	cbnz	r0, 0x7009b572 <_ftoa+0x452> @ imm = #0xc
7009b564: e7ff         	b	0x7009b566 <_ftoa+0x446> @ imm = #-0x2
7009b566: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b56a: f010 0f0c    	tst.w	r0, #0xc
7009b56e: d004         	beq	0x7009b57a <_ftoa+0x45a> @ imm = #0x8
7009b570: e7ff         	b	0x7009b572 <_ftoa+0x452> @ imm = #-0x2
;       width--;
7009b572: 9827         	ldr	r0, [sp, #0x9c]
7009b574: 3801         	subs	r0, #0x1
7009b576: 9027         	str	r0, [sp, #0x9c]
;     }
7009b578: e7ff         	b	0x7009b57a <_ftoa+0x45a> @ imm = #-0x2
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009b57a: e7ff         	b	0x7009b57c <_ftoa+0x45c> @ imm = #-0x2
7009b57c: 9911         	ldr	r1, [sp, #0x44]
7009b57e: 9a27         	ldr	r2, [sp, #0x9c]
7009b580: 2000         	movs	r0, #0x0
7009b582: 4291         	cmp	r1, r2
7009b584: 9005         	str	r0, [sp, #0x14]
7009b586: d207         	bhs	0x7009b598 <_ftoa+0x478> @ imm = #0xe
7009b588: e7ff         	b	0x7009b58a <_ftoa+0x46a> @ imm = #-0x2
7009b58a: 9911         	ldr	r1, [sp, #0x44]
7009b58c: 2000         	movs	r0, #0x0
7009b58e: 2920         	cmp	r1, #0x20
7009b590: bf38         	it	lo
7009b592: 2001         	movlo	r0, #0x1
7009b594: 9005         	str	r0, [sp, #0x14]
7009b596: e7ff         	b	0x7009b598 <_ftoa+0x478> @ imm = #-0x2
7009b598: 9805         	ldr	r0, [sp, #0x14]
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009b59a: 07c0         	lsls	r0, r0, #0x1f
7009b59c: b138         	cbz	r0, 0x7009b5ae <_ftoa+0x48e> @ imm = #0xe
7009b59e: e7ff         	b	0x7009b5a0 <_ftoa+0x480> @ imm = #-0x2
;       buf[len++] = '0';
7009b5a0: 9a11         	ldr	r2, [sp, #0x44]
7009b5a2: 1c50         	adds	r0, r2, #0x1
7009b5a4: 9011         	str	r0, [sp, #0x44]
7009b5a6: a912         	add	r1, sp, #0x48
7009b5a8: 2030         	movs	r0, #0x30
7009b5aa: 5488         	strb	r0, [r1, r2]
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009b5ac: e7e6         	b	0x7009b57c <_ftoa+0x45c> @ imm = #-0x34
;   }
7009b5ae: e7ff         	b	0x7009b5b0 <_ftoa+0x490> @ imm = #-0x2
;   if (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b5b0: 9811         	ldr	r0, [sp, #0x44]
7009b5b2: 281f         	cmp	r0, #0x1f
7009b5b4: d829         	bhi	0x7009b60a <_ftoa+0x4ea> @ imm = #0x52
7009b5b6: e7ff         	b	0x7009b5b8 <_ftoa+0x498> @ imm = #-0x2
;     if (negative) {
7009b5b8: f89d 0037    	ldrb.w	r0, [sp, #0x37]
7009b5bc: 07c0         	lsls	r0, r0, #0x1f
7009b5be: b138         	cbz	r0, 0x7009b5d0 <_ftoa+0x4b0> @ imm = #0xe
7009b5c0: e7ff         	b	0x7009b5c2 <_ftoa+0x4a2> @ imm = #-0x2
;       buf[len++] = '-';
7009b5c2: 9a11         	ldr	r2, [sp, #0x44]
7009b5c4: 1c50         	adds	r0, r2, #0x1
7009b5c6: 9011         	str	r0, [sp, #0x44]
7009b5c8: a912         	add	r1, sp, #0x48
7009b5ca: 202d         	movs	r0, #0x2d
7009b5cc: 5488         	strb	r0, [r1, r2]
;     }
7009b5ce: e01b         	b	0x7009b608 <_ftoa+0x4e8> @ imm = #0x36
;     else if (flags & FLAGS_PLUS) {
7009b5d0: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b5d4: 0740         	lsls	r0, r0, #0x1d
7009b5d6: 2800         	cmp	r0, #0x0
7009b5d8: d507         	bpl	0x7009b5ea <_ftoa+0x4ca> @ imm = #0xe
7009b5da: e7ff         	b	0x7009b5dc <_ftoa+0x4bc> @ imm = #-0x2
;       buf[len++] = '+';  // ignore the space if the '+' exists
7009b5dc: 9a11         	ldr	r2, [sp, #0x44]
7009b5de: 1c50         	adds	r0, r2, #0x1
7009b5e0: 9011         	str	r0, [sp, #0x44]
7009b5e2: a912         	add	r1, sp, #0x48
7009b5e4: 202b         	movs	r0, #0x2b
7009b5e6: 5488         	strb	r0, [r1, r2]
;     }
7009b5e8: e00d         	b	0x7009b606 <_ftoa+0x4e6> @ imm = #0x1a
;     else if (flags & FLAGS_SPACE) {
7009b5ea: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b5ee: 0700         	lsls	r0, r0, #0x1c
7009b5f0: 2800         	cmp	r0, #0x0
7009b5f2: d507         	bpl	0x7009b604 <_ftoa+0x4e4> @ imm = #0xe
7009b5f4: e7ff         	b	0x7009b5f6 <_ftoa+0x4d6> @ imm = #-0x2
;       buf[len++] = ' ';
7009b5f6: 9a11         	ldr	r2, [sp, #0x44]
7009b5f8: 1c50         	adds	r0, r2, #0x1
7009b5fa: 9011         	str	r0, [sp, #0x44]
7009b5fc: a912         	add	r1, sp, #0x48
7009b5fe: 2020         	movs	r0, #0x20
7009b600: 5488         	strb	r0, [r1, r2]
;     }
7009b602: e7ff         	b	0x7009b604 <_ftoa+0x4e4> @ imm = #-0x2
7009b604: e7ff         	b	0x7009b606 <_ftoa+0x4e6> @ imm = #-0x2
7009b606: e7ff         	b	0x7009b608 <_ftoa+0x4e8> @ imm = #-0x2
;   }
7009b608: e7ff         	b	0x7009b60a <_ftoa+0x4ea> @ imm = #-0x2
;   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
7009b60a: 9820         	ldr	r0, [sp, #0x80]
7009b60c: 991f         	ldr	r1, [sp, #0x7c]
7009b60e: 9a1e         	ldr	r2, [sp, #0x78]
7009b610: 9b1d         	ldr	r3, [sp, #0x74]
7009b612: f8dd c044    	ldr.w	r12, [sp, #0x44]
7009b616: 9c27         	ldr	r4, [sp, #0x9c]
7009b618: 9d28         	ldr	r5, [sp, #0xa0]
7009b61a: 46ee         	mov	lr, sp
7009b61c: f8ce 500c    	str.w	r5, [lr, #0xc]
7009b620: f8ce 4008    	str.w	r4, [lr, #0x8]
7009b624: f8ce c004    	str.w	r12, [lr, #0x4]
7009b628: f10d 0c48    	add.w	r12, sp, #0x48
7009b62c: f8ce c000    	str.w	r12, [lr]
7009b630: f00c f82e    	bl	0x700a7690 <_out_rev>   @ imm = #0xc05c
7009b634: 9021         	str	r0, [sp, #0x84]
7009b636: e7ff         	b	0x7009b638 <_ftoa+0x518> @ imm = #-0x2
; }
7009b638: 9821         	ldr	r0, [sp, #0x84]
7009b63a: b022         	add	sp, #0x88
7009b63c: bd70         	pop	{r4, r5, r6, pc}
7009b63e: 0000         	movs	r0, r0

7009b640 <_etoa>:
; {
7009b640: b570         	push	{r4, r5, r6, lr}
7009b642: b0a8         	sub	sp, #0xa0
7009b644: f8dd c0b8    	ldr.w	r12, [sp, #0xb8]
7009b648: f8dd c0b4    	ldr.w	r12, [sp, #0xb4]
7009b64c: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009b650: 9026         	str	r0, [sp, #0x98]
7009b652: 9125         	str	r1, [sp, #0x94]
7009b654: 9224         	str	r2, [sp, #0x90]
7009b656: 9323         	str	r3, [sp, #0x8c]
7009b658: ed8d 0b20    	vstr	d0, [sp, #128]
;   if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
7009b65c: ed9d 0b20    	vldr	d0, [sp, #128]
7009b660: eeb4 0b40    	vcmp.f64	d0, d0
7009b664: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b668: d614         	bvs	0x7009b694 <_etoa+0x54> @ imm = #0x28
7009b66a: e7ff         	b	0x7009b66c <_etoa+0x2c> @ imm = #-0x2
7009b66c: ed9d 0b20    	vldr	d0, [sp, #128]
7009b670: ed9f 1bdb    	vldr	d1, [pc, #876]          @ 0x7009b9e0 <_etoa+0x3a0>
7009b674: eeb4 0b41    	vcmp.f64	d0, d1
7009b678: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b67c: dc0a         	bgt	0x7009b694 <_etoa+0x54> @ imm = #0x14
7009b67e: e7ff         	b	0x7009b680 <_etoa+0x40> @ imm = #-0x2
7009b680: ed9d 0b20    	vldr	d0, [sp, #128]
7009b684: ed9f 1bd8    	vldr	d1, [pc, #864]          @ 0x7009b9e8 <_etoa+0x3a8>
7009b688: eeb4 0b41    	vcmp.f64	d0, d1
7009b68c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b690: d515         	bpl	0x7009b6be <_etoa+0x7e> @ imm = #0x2a
7009b692: e7ff         	b	0x7009b694 <_etoa+0x54> @ imm = #-0x2
;     return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
7009b694: 9826         	ldr	r0, [sp, #0x98]
7009b696: 9925         	ldr	r1, [sp, #0x94]
7009b698: 9a24         	ldr	r2, [sp, #0x90]
7009b69a: 9b23         	ldr	r3, [sp, #0x8c]
7009b69c: ed9d 0b20    	vldr	d0, [sp, #128]
7009b6a0: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009b6a4: 9c2d         	ldr	r4, [sp, #0xb4]
7009b6a6: 9d2e         	ldr	r5, [sp, #0xb8]
7009b6a8: 46ee         	mov	lr, sp
7009b6aa: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b6ae: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b6b2: f8ce c000    	str.w	r12, [lr]
7009b6b6: f7ff fd33    	bl	0x7009b120 <_ftoa>      @ imm = #-0x59a
7009b6ba: 9027         	str	r0, [sp, #0x9c]
7009b6bc: e1d8         	b	0x7009ba70 <_etoa+0x430> @ imm = #0x3b0
;   const bool negative = value < 0;
7009b6be: ed9d 0b20    	vldr	d0, [sp, #128]
7009b6c2: f04f 0000    	mov.w	r0, #0x0
7009b6c6: eeb5 0b40    	vcmp.f64	d0, #0
7009b6ca: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b6ce: bf48         	it	mi
7009b6d0: 2001         	movmi	r0, #0x1
7009b6d2: f88d 007f    	strb.w	r0, [sp, #0x7f]
;   if (negative) {
7009b6d6: f89d 007f    	ldrb.w	r0, [sp, #0x7f]
7009b6da: ea4f 70c0    	lsl.w	r0, r0, #0x1f
7009b6de: b138         	cbz	r0, 0x7009b6f0 <_etoa+0xb0> @ imm = #0xe
7009b6e0: e7ff         	b	0x7009b6e2 <_etoa+0xa2> @ imm = #-0x2
;     value = -value;
7009b6e2: ed9d 0b20    	vldr	d0, [sp, #128]
7009b6e6: eeb1 0b40    	vneg.f64	d0, d0
7009b6ea: ed8d 0b20    	vstr	d0, [sp, #128]
;   }
7009b6ee: e7ff         	b	0x7009b6f0 <_etoa+0xb0> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION)) {
7009b6f0: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009b6f4: 0740         	lsls	r0, r0, #0x1d
7009b6f6: 2800         	cmp	r0, #0x0
7009b6f8: d403         	bmi	0x7009b702 <_etoa+0xc2> @ imm = #0x6
7009b6fa: e7ff         	b	0x7009b6fc <_etoa+0xbc> @ imm = #-0x2
7009b6fc: 2006         	movs	r0, #0x6
;     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
7009b6fe: 902c         	str	r0, [sp, #0xb0]
;   }
7009b700: e7ff         	b	0x7009b702 <_etoa+0xc2> @ imm = #-0x2
;   conv.F = value;
7009b702: ed9d 0b20    	vldr	d0, [sp, #128]
7009b706: ed8d 0b1c    	vstr	d0, [sp, #112]
;   int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
7009b70a: 981d         	ldr	r0, [sp, #0x74]
7009b70c: f3c0 500a    	ubfx	r0, r0, #0x14, #0xb
7009b710: f2a0 30ff    	subw	r0, r0, #0x3ff
7009b714: 901b         	str	r0, [sp, #0x6c]
;   conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
7009b716: 981d         	ldr	r0, [sp, #0x74]
7009b718: f240 31ff    	movw	r1, #0x3ff
7009b71c: f361 501f    	bfi	r0, r1, #20, #12
7009b720: 901d         	str	r0, [sp, #0x74]
;   int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
7009b722: ed9d 0a1b    	vldr	s0, [sp, #108]
7009b726: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009b72a: ed9f 1bd3    	vldr	d1, [pc, #844]          @ 0x7009ba78 <_etoa+0x438>
7009b72e: ee20 0b01    	vmul.f64	d0, d0, d1
7009b732: ed9f 1bd3    	vldr	d1, [pc, #844]          @ 0x7009ba80 <_etoa+0x440>
7009b736: ee30 1b01    	vadd.f64	d1, d0, d1
7009b73a: ed9d 0b1c    	vldr	d0, [sp, #112]
7009b73e: eebf 2b08    	vmov.f64	d2, #-1.500000e+00
7009b742: ee30 0b02    	vadd.f64	d0, d0, d2
7009b746: ed9f 2bd0    	vldr	d2, [pc, #832]          @ 0x7009ba88 <_etoa+0x448>
7009b74a: ee20 0b02    	vmul.f64	d0, d0, d2
7009b74e: ee30 0b01    	vadd.f64	d0, d0, d1
7009b752: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009b756: ed8d 0a1a    	vstr	s0, [sp, #104]
;   exp2 = (int)(expval * 3.321928094887362 + 0.5);
7009b75a: ed9d 0a1a    	vldr	s0, [sp, #104]
7009b75e: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009b762: ed9f 1bcb    	vldr	d1, [pc, #812]          @ 0x7009ba90 <_etoa+0x450>
7009b766: ee20 0b01    	vmul.f64	d0, d0, d1
7009b76a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b76e: ee30 0b01    	vadd.f64	d0, d0, d1
7009b772: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009b776: ed8d 0a1b    	vstr	s0, [sp, #108]
;   const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
7009b77a: ed9d 0a1a    	vldr	s0, [sp, #104]
7009b77e: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009b782: ed9d 1a1b    	vldr	s2, [sp, #108]
7009b786: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009b78a: ed9f 2bc3    	vldr	d2, [pc, #780]          @ 0x7009ba98 <_etoa+0x458>
7009b78e: ee21 1b02    	vmul.f64	d1, d1, d2
7009b792: ed9f 2bc3    	vldr	d2, [pc, #780]          @ 0x7009baa0 <_etoa+0x460>
7009b796: ee20 0b02    	vmul.f64	d0, d0, d2
7009b79a: ee30 0b01    	vadd.f64	d0, d0, d1
7009b79e: ed8d 0b18    	vstr	d0, [sp, #96]
;   const double z2 = z * z;
7009b7a2: ed9d 0b18    	vldr	d0, [sp, #96]
7009b7a6: ee20 0b00    	vmul.f64	d0, d0, d0
7009b7aa: ed8d 0b16    	vstr	d0, [sp, #88]
;   conv.U = (uint64_t)(exp2 + 1023) << 52U;
7009b7ae: 981b         	ldr	r0, [sp, #0x6c]
7009b7b0: f200 30ff    	addw	r0, r0, #0x3ff
7009b7b4: 0500         	lsls	r0, r0, #0x14
7009b7b6: 2100         	movs	r1, #0x0
7009b7b8: 911c         	str	r1, [sp, #0x70]
7009b7ba: 901d         	str	r0, [sp, #0x74]
;   conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
7009b7bc: ed9d 2b18    	vldr	d2, [sp, #96]
7009b7c0: ee32 0b02    	vadd.f64	d0, d2, d2
7009b7c4: eeb0 1b00    	vmov.f64	d1, #2.000000e+00
7009b7c8: ee31 1b42    	vsub.f64	d1, d1, d2
7009b7cc: ed9d 2b16    	vldr	d2, [sp, #88]
7009b7d0: eeb2 3b0c    	vmov.f64	d3, #1.400000e+01
7009b7d4: ee82 3b03    	vdiv.f64	d3, d2, d3
7009b7d8: eeb2 4b04    	vmov.f64	d4, #1.000000e+01
7009b7dc: ee33 3b04    	vadd.f64	d3, d3, d4
7009b7e0: ee82 3b03    	vdiv.f64	d3, d2, d3
7009b7e4: eeb1 4b08    	vmov.f64	d4, #6.000000e+00
7009b7e8: ee33 3b04    	vadd.f64	d3, d3, d4
7009b7ec: ee82 2b03    	vdiv.f64	d2, d2, d3
7009b7f0: ee31 1b02    	vadd.f64	d1, d1, d2
7009b7f4: ee80 0b01    	vdiv.f64	d0, d0, d1
7009b7f8: eeb7 1b00    	vmov.f64	d1, #1.000000e+00
7009b7fc: ee30 1b01    	vadd.f64	d1, d0, d1
7009b800: ed9d 0b1c    	vldr	d0, [sp, #112]
7009b804: ee20 0b01    	vmul.f64	d0, d0, d1
7009b808: ed8d 0b1c    	vstr	d0, [sp, #112]
;   if (value < conv.F) {
7009b80c: ed9d 0b20    	vldr	d0, [sp, #128]
7009b810: ed9d 1b1c    	vldr	d1, [sp, #112]
7009b814: eeb4 0b41    	vcmp.f64	d0, d1
7009b818: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b81c: d50c         	bpl	0x7009b838 <_etoa+0x1f8> @ imm = #0x18
7009b81e: e7ff         	b	0x7009b820 <_etoa+0x1e0> @ imm = #-0x2
;     expval--;
7009b820: 981a         	ldr	r0, [sp, #0x68]
7009b822: 3801         	subs	r0, #0x1
7009b824: 901a         	str	r0, [sp, #0x68]
;     conv.F /= 10;
7009b826: ed9d 0b1c    	vldr	d0, [sp, #112]
7009b82a: eeb2 1b04    	vmov.f64	d1, #1.000000e+01
7009b82e: ee80 0b01    	vdiv.f64	d0, d0, d1
7009b832: ed8d 0b1c    	vstr	d0, [sp, #112]
;   }
7009b836: e7ff         	b	0x7009b838 <_etoa+0x1f8> @ imm = #-0x2
;   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
7009b838: 991a         	ldr	r1, [sp, #0x68]
7009b83a: f04f 0000    	mov.w	r0, #0x0
7009b83e: 2963         	cmp	r1, #0x63
7009b840: 9012         	str	r0, [sp, #0x48]
7009b842: dc08         	bgt	0x7009b856 <_etoa+0x216> @ imm = #0x10
7009b844: e7ff         	b	0x7009b846 <_etoa+0x206> @ imm = #-0x2
7009b846: 991a         	ldr	r1, [sp, #0x68]
7009b848: 2000         	movs	r0, #0x0
7009b84a: f111 0f64    	cmn.w	r1, #0x64
7009b84e: bfc8         	it	gt
7009b850: 2001         	movgt	r0, #0x1
7009b852: 9012         	str	r0, [sp, #0x48]
7009b854: e7ff         	b	0x7009b856 <_etoa+0x216> @ imm = #-0x2
7009b856: 9812         	ldr	r0, [sp, #0x48]
;   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
7009b858: 07c1         	lsls	r1, r0, #0x1f
7009b85a: 2005         	movs	r0, #0x5
7009b85c: 2900         	cmp	r1, #0x0
7009b85e: bf18         	it	ne
7009b860: 2004         	movne	r0, #0x4
7009b862: 9015         	str	r0, [sp, #0x54]
;   if (flags & FLAGS_ADAPT_EXP) {
7009b864: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009b868: ea4f 7000    	lsl.w	r0, r0, #0x1c
7009b86c: 2800         	cmp	r0, #0x0
7009b86e: d539         	bpl	0x7009b8e4 <_etoa+0x2a4> @ imm = #0x72
7009b870: e7ff         	b	0x7009b872 <_etoa+0x232> @ imm = #-0x2
;     if ((value >= 1e-4) && (value < 1e6)) {
7009b872: ed9d 0b20    	vldr	d0, [sp, #128]
7009b876: ed9f 1b8c    	vldr	d1, [pc, #560]          @ 0x7009baa8 <_etoa+0x468>
7009b87a: eeb4 0b41    	vcmp.f64	d0, d1
7009b87e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b882: db20         	blt	0x7009b8c6 <_etoa+0x286> @ imm = #0x40
7009b884: e7ff         	b	0x7009b886 <_etoa+0x246> @ imm = #-0x2
7009b886: ed9d 0b20    	vldr	d0, [sp, #128]
7009b88a: ed9f 1b89    	vldr	d1, [pc, #548]          @ 0x7009bab0 <_etoa+0x470>
7009b88e: eeb4 0b41    	vcmp.f64	d0, d1
7009b892: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b896: d516         	bpl	0x7009b8c6 <_etoa+0x286> @ imm = #0x2c
7009b898: e7ff         	b	0x7009b89a <_etoa+0x25a> @ imm = #-0x2
;       if ((int)prec > expval) {
7009b89a: 982c         	ldr	r0, [sp, #0xb0]
7009b89c: 991a         	ldr	r1, [sp, #0x68]
7009b89e: 4288         	cmp	r0, r1
7009b8a0: dd06         	ble	0x7009b8b0 <_etoa+0x270> @ imm = #0xc
7009b8a2: e7ff         	b	0x7009b8a4 <_etoa+0x264> @ imm = #-0x2
;         prec = (unsigned)((int)prec - expval - 1);
7009b8a4: 992c         	ldr	r1, [sp, #0xb0]
7009b8a6: 981a         	ldr	r0, [sp, #0x68]
7009b8a8: 43c0         	mvns	r0, r0
7009b8aa: 4408         	add	r0, r1
7009b8ac: 902c         	str	r0, [sp, #0xb0]
;       }
7009b8ae: e002         	b	0x7009b8b6 <_etoa+0x276> @ imm = #0x4
7009b8b0: 2000         	movs	r0, #0x0
;         prec = 0;
7009b8b2: 902c         	str	r0, [sp, #0xb0]
7009b8b4: e7ff         	b	0x7009b8b6 <_etoa+0x276> @ imm = #-0x2
;       flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
7009b8b6: 982e         	ldr	r0, [sp, #0xb8]
7009b8b8: f440 6080    	orr	r0, r0, #0x400
7009b8bc: 902e         	str	r0, [sp, #0xb8]
7009b8be: 2000         	movs	r0, #0x0
;       minwidth = 0U;
7009b8c0: 9015         	str	r0, [sp, #0x54]
;       expval   = 0;
7009b8c2: 901a         	str	r0, [sp, #0x68]
;     }
7009b8c4: e00d         	b	0x7009b8e2 <_etoa+0x2a2> @ imm = #0x1a
;       if ((prec > 0) && (flags & FLAGS_PRECISION)) {
7009b8c6: 982c         	ldr	r0, [sp, #0xb0]
7009b8c8: b150         	cbz	r0, 0x7009b8e0 <_etoa+0x2a0> @ imm = #0x14
7009b8ca: e7ff         	b	0x7009b8cc <_etoa+0x28c> @ imm = #-0x2
7009b8cc: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009b8d0: 0740         	lsls	r0, r0, #0x1d
7009b8d2: 2800         	cmp	r0, #0x0
7009b8d4: d504         	bpl	0x7009b8e0 <_etoa+0x2a0> @ imm = #0x8
7009b8d6: e7ff         	b	0x7009b8d8 <_etoa+0x298> @ imm = #-0x2
;         --prec;
7009b8d8: 982c         	ldr	r0, [sp, #0xb0]
7009b8da: 3801         	subs	r0, #0x1
7009b8dc: 902c         	str	r0, [sp, #0xb0]
;       }
7009b8de: e7ff         	b	0x7009b8e0 <_etoa+0x2a0> @ imm = #-0x2
7009b8e0: e7ff         	b	0x7009b8e2 <_etoa+0x2a2> @ imm = #-0x2
;   }
7009b8e2: e7ff         	b	0x7009b8e4 <_etoa+0x2a4> @ imm = #-0x2
;   unsigned int fwidth = width;
7009b8e4: 982d         	ldr	r0, [sp, #0xb4]
7009b8e6: 9014         	str	r0, [sp, #0x50]
;   if (width > minwidth) {
7009b8e8: 982d         	ldr	r0, [sp, #0xb4]
7009b8ea: 9915         	ldr	r1, [sp, #0x54]
7009b8ec: 4288         	cmp	r0, r1
7009b8ee: d905         	bls	0x7009b8fc <_etoa+0x2bc> @ imm = #0xa
7009b8f0: e7ff         	b	0x7009b8f2 <_etoa+0x2b2> @ imm = #-0x2
;     fwidth -= minwidth;
7009b8f2: 9915         	ldr	r1, [sp, #0x54]
7009b8f4: 9814         	ldr	r0, [sp, #0x50]
7009b8f6: 1a40         	subs	r0, r0, r1
7009b8f8: 9014         	str	r0, [sp, #0x50]
;   } else {
7009b8fa: e002         	b	0x7009b902 <_etoa+0x2c2> @ imm = #0x4
7009b8fc: 2000         	movs	r0, #0x0
;     fwidth = 0U;
7009b8fe: 9014         	str	r0, [sp, #0x50]
7009b900: e7ff         	b	0x7009b902 <_etoa+0x2c2> @ imm = #-0x2
;   if ((flags & FLAGS_LEFT) && minwidth) {
7009b902: f89d 00b8    	ldrb.w	r0, [sp, #0xb8]
7009b906: 0780         	lsls	r0, r0, #0x1e
7009b908: 2800         	cmp	r0, #0x0
7009b90a: d506         	bpl	0x7009b91a <_etoa+0x2da> @ imm = #0xc
7009b90c: e7ff         	b	0x7009b90e <_etoa+0x2ce> @ imm = #-0x2
7009b90e: 9815         	ldr	r0, [sp, #0x54]
7009b910: b118         	cbz	r0, 0x7009b91a <_etoa+0x2da> @ imm = #0x6
7009b912: e7ff         	b	0x7009b914 <_etoa+0x2d4> @ imm = #-0x2
7009b914: 2000         	movs	r0, #0x0
;     fwidth = 0U;
7009b916: 9014         	str	r0, [sp, #0x50]
;   }
7009b918: e7ff         	b	0x7009b91a <_etoa+0x2da> @ imm = #-0x2
;   if (expval) {
7009b91a: 981a         	ldr	r0, [sp, #0x68]
7009b91c: b148         	cbz	r0, 0x7009b932 <_etoa+0x2f2> @ imm = #0x12
7009b91e: e7ff         	b	0x7009b920 <_etoa+0x2e0> @ imm = #-0x2
;     value /= conv.F;
7009b920: ed9d 1b1c    	vldr	d1, [sp, #112]
7009b924: ed9d 0b20    	vldr	d0, [sp, #128]
7009b928: ee80 0b01    	vdiv.f64	d0, d0, d1
7009b92c: ed8d 0b20    	vstr	d0, [sp, #128]
;   }
7009b930: e7ff         	b	0x7009b932 <_etoa+0x2f2> @ imm = #-0x2
;   const size_t start_idx = idx;
7009b932: 9824         	ldr	r0, [sp, #0x90]
7009b934: 9013         	str	r0, [sp, #0x4c]
;   idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
7009b936: 9826         	ldr	r0, [sp, #0x98]
7009b938: 900e         	str	r0, [sp, #0x38]
7009b93a: 9825         	ldr	r0, [sp, #0x94]
7009b93c: 900f         	str	r0, [sp, #0x3c]
7009b93e: 9824         	ldr	r0, [sp, #0x90]
7009b940: 9010         	str	r0, [sp, #0x40]
7009b942: 9823         	ldr	r0, [sp, #0x8c]
7009b944: 9011         	str	r0, [sp, #0x44]
7009b946: f89d 007f    	ldrb.w	r0, [sp, #0x7f]
7009b94a: 07c0         	lsls	r0, r0, #0x1f
7009b94c: b138         	cbz	r0, 0x7009b95e <_etoa+0x31e> @ imm = #0xe
7009b94e: e7ff         	b	0x7009b950 <_etoa+0x310> @ imm = #-0x2
7009b950: ed9d 0b20    	vldr	d0, [sp, #128]
7009b954: eeb1 0b40    	vneg.f64	d0, d0
7009b958: ed8d 0b0c    	vstr	d0, [sp, #48]
7009b95c: e004         	b	0x7009b968 <_etoa+0x328> @ imm = #0x8
7009b95e: ed9d 0b20    	vldr	d0, [sp, #128]
7009b962: ed8d 0b0c    	vstr	d0, [sp, #48]
7009b966: e7ff         	b	0x7009b968 <_etoa+0x328> @ imm = #-0x2
7009b968: 9b11         	ldr	r3, [sp, #0x44]
7009b96a: 9a10         	ldr	r2, [sp, #0x40]
7009b96c: 990f         	ldr	r1, [sp, #0x3c]
7009b96e: 980e         	ldr	r0, [sp, #0x38]
7009b970: ed9d 0b0c    	vldr	d0, [sp, #48]
7009b974: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009b978: 9c14         	ldr	r4, [sp, #0x50]
7009b97a: f8dd e0b8    	ldr.w	lr, [sp, #0xb8]
7009b97e: f42e 6500    	bic	r5, lr, #0x800
7009b982: 46ee         	mov	lr, sp
7009b984: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b988: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b98c: f8ce c000    	str.w	r12, [lr]
7009b990: f7ff fbc6    	bl	0x7009b120 <_ftoa>      @ imm = #-0x874
7009b994: 9024         	str	r0, [sp, #0x90]
;   if (minwidth) {
7009b996: 9815         	ldr	r0, [sp, #0x54]
7009b998: 2800         	cmp	r0, #0x0
7009b99a: d066         	beq	0x7009ba6a <_etoa+0x42a> @ imm = #0xcc
7009b99c: e7ff         	b	0x7009b99e <_etoa+0x35e> @ imm = #-0x2
;     out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
7009b99e: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009b9a2: 982e         	ldr	r0, [sp, #0xb8]
7009b9a4: 0681         	lsls	r1, r0, #0x1a
7009b9a6: 2065         	movs	r0, #0x65
7009b9a8: 2900         	cmp	r1, #0x0
7009b9aa: bf48         	it	mi
7009b9ac: 2045         	movmi	r0, #0x45
7009b9ae: 9925         	ldr	r1, [sp, #0x94]
7009b9b0: 9a24         	ldr	r2, [sp, #0x90]
7009b9b2: 1c53         	adds	r3, r2, #0x1
7009b9b4: 9324         	str	r3, [sp, #0x90]
7009b9b6: 9b23         	ldr	r3, [sp, #0x8c]
7009b9b8: 47e0         	blx	r12
;     idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
7009b9ba: 9826         	ldr	r0, [sp, #0x98]
7009b9bc: 9008         	str	r0, [sp, #0x20]
7009b9be: 9825         	ldr	r0, [sp, #0x94]
7009b9c0: 9009         	str	r0, [sp, #0x24]
7009b9c2: 9824         	ldr	r0, [sp, #0x90]
7009b9c4: 900a         	str	r0, [sp, #0x28]
7009b9c6: 9823         	ldr	r0, [sp, #0x8c]
7009b9c8: 900b         	str	r0, [sp, #0x2c]
7009b9ca: 981a         	ldr	r0, [sp, #0x68]
7009b9cc: f1b0 3fff    	cmp.w	r0, #0xffffffff
7009b9d0: dc0e         	bgt	0x7009b9f0 <_etoa+0x3b0> @ imm = #0x1c
7009b9d2: e7ff         	b	0x7009b9d4 <_etoa+0x394> @ imm = #-0x2
7009b9d4: 981a         	ldr	r0, [sp, #0x68]
7009b9d6: 4240         	rsbs	r0, r0, #0
7009b9d8: 9007         	str	r0, [sp, #0x1c]
7009b9da: e00c         	b	0x7009b9f6 <_etoa+0x3b6> @ imm = #0x18
7009b9dc: bf00         	nop
7009b9de: bf00         	nop
7009b9e0: ff ff ff ff  	.word	0xffffffff
7009b9e4: ff ff ef 7f  	.word	0x7fefffff
7009b9e8: ff ff ff ff  	.word	0xffffffff
7009b9ec: ff ff ef ff  	.word	0xffefffff
7009b9f0: 981a         	ldr	r0, [sp, #0x68]
7009b9f2: 9007         	str	r0, [sp, #0x1c]
7009b9f4: e7ff         	b	0x7009b9f6 <_etoa+0x3b6> @ imm = #-0x2
7009b9f6: 9b0b         	ldr	r3, [sp, #0x2c]
7009b9f8: 9a0a         	ldr	r2, [sp, #0x28]
7009b9fa: 9909         	ldr	r1, [sp, #0x24]
7009b9fc: 9808         	ldr	r0, [sp, #0x20]
7009b9fe: f8dd c01c    	ldr.w	r12, [sp, #0x1c]
7009ba02: 9c1a         	ldr	r4, [sp, #0x68]
7009ba04: f8dd e054    	ldr.w	lr, [sp, #0x54]
7009ba08: f1ae 0501    	sub.w	r5, lr, #0x1
7009ba0c: 46ee         	mov	lr, sp
7009ba0e: 2605         	movs	r6, #0x5
7009ba10: f8ce 6014    	str.w	r6, [lr, #0x14]
7009ba14: f8ce 5010    	str.w	r5, [lr, #0x10]
7009ba18: 2500         	movs	r5, #0x0
7009ba1a: f8ce 500c    	str.w	r5, [lr, #0xc]
7009ba1e: 250a         	movs	r5, #0xa
7009ba20: f8ce 5008    	str.w	r5, [lr, #0x8]
7009ba24: ea4f 74d4    	lsr.w	r4, r4, #0x1f
7009ba28: f8ce 4004    	str.w	r4, [lr, #0x4]
7009ba2c: f8ce c000    	str.w	r12, [lr]
7009ba30: f009 f92e    	bl	0x700a4c90 <_ntoa_long> @ imm = #0x925c
7009ba34: 9024         	str	r0, [sp, #0x90]
;     if (flags & FLAGS_LEFT) {
7009ba36: f89d 00b8    	ldrb.w	r0, [sp, #0xb8]
7009ba3a: 0780         	lsls	r0, r0, #0x1e
7009ba3c: 2800         	cmp	r0, #0x0
7009ba3e: d513         	bpl	0x7009ba68 <_etoa+0x428> @ imm = #0x26
7009ba40: e7ff         	b	0x7009ba42 <_etoa+0x402> @ imm = #-0x2
;       while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
7009ba42: e7ff         	b	0x7009ba44 <_etoa+0x404> @ imm = #-0x2
7009ba44: 9824         	ldr	r0, [sp, #0x90]
7009ba46: 9913         	ldr	r1, [sp, #0x4c]
7009ba48: 1a40         	subs	r0, r0, r1
7009ba4a: 992d         	ldr	r1, [sp, #0xb4]
7009ba4c: 4288         	cmp	r0, r1
7009ba4e: d20a         	bhs	0x7009ba66 <_etoa+0x426> @ imm = #0x14
7009ba50: e7ff         	b	0x7009ba52 <_etoa+0x412> @ imm = #-0x2
7009ba52: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009ba56: 9925         	ldr	r1, [sp, #0x94]
7009ba58: 9a24         	ldr	r2, [sp, #0x90]
7009ba5a: 1c50         	adds	r0, r2, #0x1
7009ba5c: 9024         	str	r0, [sp, #0x90]
7009ba5e: 9b23         	ldr	r3, [sp, #0x8c]
7009ba60: 2020         	movs	r0, #0x20
7009ba62: 47e0         	blx	r12
7009ba64: e7ee         	b	0x7009ba44 <_etoa+0x404> @ imm = #-0x24
;     }
7009ba66: e7ff         	b	0x7009ba68 <_etoa+0x428> @ imm = #-0x2
;   }
7009ba68: e7ff         	b	0x7009ba6a <_etoa+0x42a> @ imm = #-0x2
;   return idx;
7009ba6a: 9824         	ldr	r0, [sp, #0x90]
7009ba6c: 9027         	str	r0, [sp, #0x9c]
7009ba6e: e7ff         	b	0x7009ba70 <_etoa+0x430> @ imm = #-0x2
; }
7009ba70: 9827         	ldr	r0, [sp, #0x9c]
7009ba72: b028         	add	sp, #0xa0
7009ba74: bd70         	pop	{r4, r5, r6, pc}
7009ba76: bf00         	nop
7009ba78: fb 79 9f 50  	.word	0x509f79fb
7009ba7c: 13 44 d3 3f  	.word	0x3fd34413
7009ba80: b3 c8 60 8b  	.word	0x8b60c8b3
7009ba84: 28 8a c6 3f  	.word	0x3fc68a28
7009ba88: 61 43 6f 63  	.word	0x636f4361
7009ba8c: a7 87 d2 3f  	.word	0x3fd287a7
7009ba90: 71 a3 79 09  	.word	0x0979a371
7009ba94: 4f 93 0a 40  	.word	0x400a934f
7009ba98: ef 39 fa fe  	.word	0xfefa39ef
7009ba9c: 42 2e e6 bf  	.word	0xbfe62e42
7009baa0: 16 55 b5 bb  	.word	0xbbb55516
7009baa4: b1 6b 02 40  	.word	0x40026bb1
7009baa8: 2d 43 1c eb  	.word	0xeb1c432d
7009baac: e2 36 1a 3f  	.word	0x3f1a36e2
7009bab0: 00 00 00 00  	.word	0x00000000
7009bab4: 80 84 2e 41  	.word	0x412e8480

7009bab8 <_nop>:
7009bab8: e12fff1e     	bx	lr
7009babc: 00000000     	andeq	r0, r0, r0

7009bac0 <UART_open>:
; {
7009bac0: b580         	push	{r7, lr}
7009bac2: b092         	sub	sp, #0x48
7009bac4: 9011         	str	r0, [sp, #0x44]
7009bac6: 9110         	str	r1, [sp, #0x40]
7009bac8: 2000         	movs	r0, #0x0
;     int32_t             status = SystemP_SUCCESS;
7009baca: 900f         	str	r0, [sp, #0x3c]
;     UART_Handle         handle = NULL;
7009bacc: 900e         	str	r0, [sp, #0x38]
;     UART_Config        *config = NULL;
7009bace: 900d         	str	r0, [sp, #0x34]
;     UART_Object        *object    = NULL;
7009bad0: 900c         	str	r0, [sp, #0x30]
;     if(index >= gUartConfigNum)
7009bad2: 9811         	ldr	r0, [sp, #0x44]
7009bad4: f642 11fc    	movw	r1, #0x29fc
7009bad8: f2c7 010b    	movt	r1, #0x700b
7009badc: 6809         	ldr	r1, [r1]
7009bade: 4288         	cmp	r0, r1
7009bae0: d304         	blo	0x7009baec <UART_open+0x2c> @ imm = #0x8
7009bae2: e7ff         	b	0x7009bae4 <UART_open+0x24> @ imm = #-0x2
7009bae4: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009bae8: 900f         	str	r0, [sp, #0x3c]
;     }
7009baea: e008         	b	0x7009bafe <UART_open+0x3e> @ imm = #0x10
;         config = &gUartConfig[index];
7009baec: 9911         	ldr	r1, [sp, #0x44]
7009baee: f642 10b4    	movw	r0, #0x29b4
7009baf2: f2c7 000b    	movt	r0, #0x700b
7009baf6: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009bafa: 900d         	str	r0, [sp, #0x34]
7009bafc: e7ff         	b	0x7009bafe <UART_open+0x3e> @ imm = #-0x2
;     DebugP_assert(NULL_PTR != gUartDrvObj.lock);
7009bafe: f242 7138    	movw	r1, #0x2738
7009bb02: f2c7 010b    	movt	r1, #0x700b
7009bb06: f851 0b04    	ldr	r0, [r1], #4
7009bb0a: 9103         	str	r1, [sp, #0xc]
7009bb0c: 2800         	cmp	r0, #0x0
7009bb0e: bf18         	it	ne
7009bb10: 2001         	movne	r0, #0x1
7009bb12: f641 51c0    	movw	r1, #0x1dc0
7009bb16: f2c7 010b    	movt	r1, #0x700b
7009bb1a: 466a         	mov	r2, sp
7009bb1c: 6011         	str	r1, [r2]
7009bb1e: f641 71e1    	movw	r1, #0x1fe1
7009bb22: f2c7 010b    	movt	r1, #0x700b
7009bb26: f242 125b    	movw	r2, #0x215b
7009bb2a: f2c7 020b    	movt	r2, #0x700b
7009bb2e: f240 1301    	movw	r3, #0x101
7009bb32: f00f f8ad    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xf15a
7009bb36: 9803         	ldr	r0, [sp, #0xc]
7009bb38: f04f 31ff    	mov.w	r1, #0xffffffff
;     (void)SemaphoreP_pend(&gUartDrvObj.lockObj, SystemP_WAIT_FOREVER);
7009bb3c: f00e fe50    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0xeca0
;     if(SystemP_SUCCESS  == status)
7009bb40: 980f         	ldr	r0, [sp, #0x3c]
7009bb42: bb38         	cbnz	r0, 0x7009bb94 <UART_open+0xd4> @ imm = #0x4e
7009bb44: e7ff         	b	0x7009bb46 <UART_open+0x86> @ imm = #-0x2
;         object = config->object;
7009bb46: 980d         	ldr	r0, [sp, #0x34]
7009bb48: 6840         	ldr	r0, [r0, #0x4]
7009bb4a: 900c         	str	r0, [sp, #0x30]
;         attrs  = config->attrs;
7009bb4c: 980d         	ldr	r0, [sp, #0x34]
7009bb4e: 6800         	ldr	r0, [r0]
7009bb50: 900b         	str	r0, [sp, #0x2c]
;         DebugP_assert(NULL_PTR != object);
7009bb52: 980c         	ldr	r0, [sp, #0x30]
7009bb54: 2800         	cmp	r0, #0x0
7009bb56: bf18         	it	ne
7009bb58: 2001         	movne	r0, #0x1
7009bb5a: f641 71ce    	movw	r1, #0x1fce
7009bb5e: f2c7 010b    	movt	r1, #0x700b
7009bb62: 466a         	mov	r2, sp
7009bb64: 6011         	str	r1, [r2]
7009bb66: f641 71e1    	movw	r1, #0x1fe1
7009bb6a: f2c7 010b    	movt	r1, #0x700b
7009bb6e: f242 125b    	movw	r2, #0x215b
7009bb72: f2c7 020b    	movt	r2, #0x700b
7009bb76: f44f 7384    	mov.w	r3, #0x108
7009bb7a: f00f f889    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xf112
;         if(TRUE == object->isOpen)
7009bb7e: 980c         	ldr	r0, [sp, #0x30]
7009bb80: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009bb84: 2801         	cmp	r0, #0x1
7009bb86: d104         	bne	0x7009bb92 <UART_open+0xd2> @ imm = #0x8
7009bb88: e7ff         	b	0x7009bb8a <UART_open+0xca> @ imm = #-0x2
7009bb8a: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009bb8e: 900f         	str	r0, [sp, #0x3c]
;         }
7009bb90: e7ff         	b	0x7009bb92 <UART_open+0xd2> @ imm = #-0x2
;     }
7009bb92: e7ff         	b	0x7009bb94 <UART_open+0xd4> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009bb94: 980f         	ldr	r0, [sp, #0x3c]
7009bb96: 2800         	cmp	r0, #0x0
7009bb98: f040 80cd    	bne.w	0x7009bd36 <UART_open+0x276> @ imm = #0x19a
7009bb9c: e7ff         	b	0x7009bb9e <UART_open+0xde> @ imm = #-0x2
;         object->handle = (UART_Handle) config;
7009bb9e: 980d         	ldr	r0, [sp, #0x34]
7009bba0: 990c         	ldr	r1, [sp, #0x30]
7009bba2: 6008         	str	r0, [r1]
;         if(NULL != prms)
7009bba4: 9810         	ldr	r0, [sp, #0x40]
7009bba6: b138         	cbz	r0, 0x7009bbb8 <UART_open+0xf8> @ imm = #0xe
7009bba8: e7ff         	b	0x7009bbaa <UART_open+0xea> @ imm = #-0x2
;             ( void )memcpy(&object->prms, prms, sizeof(UART_Params));
7009bbaa: 980c         	ldr	r0, [sp, #0x30]
7009bbac: 3004         	adds	r0, #0x4
7009bbae: 9910         	ldr	r1, [sp, #0x40]
7009bbb0: 2258         	movs	r2, #0x58
7009bbb2: f7fe ea94    	blx	0x7009a0dc <__aeabi_memcpy8> @ imm = #-0x1ad8
;         }
7009bbb6: e004         	b	0x7009bbc2 <UART_open+0x102> @ imm = #0x8
;             UART_Params_init(&object->prms);
7009bbb8: 980c         	ldr	r0, [sp, #0x30]
7009bbba: 3004         	adds	r0, #0x4
7009bbbc: f00f f8a8    	bl	0x700aad10 <UART_Params_init> @ imm = #0xf150
7009bbc0: e7ff         	b	0x7009bbc2 <UART_open+0x102> @ imm = #-0x2
;         object->uartLld_handle             = &object->uartLld_object;
7009bbc2: 990c         	ldr	r1, [sp, #0x30]
7009bbc4: f501 7022    	add.w	r0, r1, #0x288
7009bbc8: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;         uartLld_handle                     = object->uartLld_handle;
7009bbcc: 980c         	ldr	r0, [sp, #0x30]
7009bbce: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009bbd2: 9005         	str	r0, [sp, #0x14]
;         object->uartLld_initHandle         = &object->uartLld_initObject;
7009bbd4: 990c         	ldr	r1, [sp, #0x30]
7009bbd6: f501 7040    	add.w	r0, r1, #0x300
7009bbda: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;         uartLldInit_handle                 = object->uartLld_initHandle;
7009bbde: 980c         	ldr	r0, [sp, #0x30]
7009bbe0: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
7009bbe4: 9004         	str	r0, [sp, #0x10]
;         uartLld_handle->hUartInit          = uartLldInit_handle;
7009bbe6: 9804         	ldr	r0, [sp, #0x10]
7009bbe8: 9905         	ldr	r1, [sp, #0x14]
7009bbea: 6048         	str	r0, [r1, #0x4]
;         uartLld_handle->baseAddr           = attrs->baseAddr;
7009bbec: 980b         	ldr	r0, [sp, #0x2c]
7009bbee: 6800         	ldr	r0, [r0]
7009bbf0: 9905         	ldr	r1, [sp, #0x14]
7009bbf2: 6008         	str	r0, [r1]
;         uartLld_handle->args               = (void *)object->handle;
7009bbf4: 980c         	ldr	r0, [sp, #0x30]
7009bbf6: 6800         	ldr	r0, [r0]
7009bbf8: 9905         	ldr	r1, [sp, #0x14]
7009bbfa: 6608         	str	r0, [r1, #0x60]
;         uartLld_handle->writeBuf           = object->writeBuf;
7009bbfc: 980c         	ldr	r0, [sp, #0x30]
7009bbfe: 6dc0         	ldr	r0, [r0, #0x5c]
7009bc00: 9905         	ldr	r1, [sp, #0x14]
7009bc02: 6088         	str	r0, [r1, #0x8]
;         uartLld_handle->writeCount         = object->writeCount;
7009bc04: 980c         	ldr	r0, [sp, #0x30]
7009bc06: 6e00         	ldr	r0, [r0, #0x60]
7009bc08: 9905         	ldr	r1, [sp, #0x14]
7009bc0a: 60c8         	str	r0, [r1, #0xc]
;         uartLld_handle->writeSizeRemaining = object->writeSizeRemaining;
7009bc0c: 980c         	ldr	r0, [sp, #0x30]
7009bc0e: 6e40         	ldr	r0, [r0, #0x64]
7009bc10: 9905         	ldr	r1, [sp, #0x14]
7009bc12: 6108         	str	r0, [r1, #0x10]
;         uartLld_handle->readBuf            = object->readBuf;
7009bc14: 980c         	ldr	r0, [sp, #0x30]
7009bc16: 6e80         	ldr	r0, [r0, #0x68]
7009bc18: 9905         	ldr	r1, [sp, #0x14]
7009bc1a: 6148         	str	r0, [r1, #0x14]
;         uartLld_handle->readCount          = object->readCount;
7009bc1c: 980c         	ldr	r0, [sp, #0x30]
7009bc1e: 6ec0         	ldr	r0, [r0, #0x6c]
7009bc20: 9905         	ldr	r1, [sp, #0x14]
7009bc22: 6188         	str	r0, [r1, #0x18]
;         uartLld_handle->readSizeRemaining  = object->readSizeRemaining;
7009bc24: 980c         	ldr	r0, [sp, #0x30]
7009bc26: 6f00         	ldr	r0, [r0, #0x70]
7009bc28: 9905         	ldr	r1, [sp, #0x14]
7009bc2a: 61c8         	str	r0, [r1, #0x1c]
;         uartLld_handle->rxTimeoutCnt       = object->rxTimeoutCnt;
7009bc2c: 980c         	ldr	r0, [sp, #0x30]
7009bc2e: 6f40         	ldr	r0, [r0, #0x74]
7009bc30: 9905         	ldr	r1, [sp, #0x14]
7009bc32: 6208         	str	r0, [r1, #0x20]
;         uartLld_handle->readErrorCnt       = object->readErrorCnt;
7009bc34: 980c         	ldr	r0, [sp, #0x30]
7009bc36: 6f80         	ldr	r0, [r0, #0x78]
7009bc38: 9905         	ldr	r1, [sp, #0x14]
7009bc3a: 6248         	str	r0, [r1, #0x24]
;         uartLld_handle->state              = UART_STATE_RESET;
7009bc3c: 9905         	ldr	r1, [sp, #0x14]
7009bc3e: 2000         	movs	r0, #0x0
7009bc40: 6548         	str	r0, [r1, #0x54]
;         uartLldInit_handle->inputClkFreq      = attrs->inputClkFreq;
7009bc42: 990b         	ldr	r1, [sp, #0x2c]
7009bc44: 6849         	ldr	r1, [r1, #0x4]
7009bc46: 9a04         	ldr	r2, [sp, #0x10]
7009bc48: 6011         	str	r1, [r2]
;         uartLldInit_handle->baudRate          = object->prms.baudRate;
7009bc4a: 990c         	ldr	r1, [sp, #0x30]
7009bc4c: 6849         	ldr	r1, [r1, #0x4]
7009bc4e: 9a04         	ldr	r2, [sp, #0x10]
7009bc50: 6051         	str	r1, [r2, #0x4]
;         uartLldInit_handle->baudRate          = object->prms.baudRate;
7009bc52: 990c         	ldr	r1, [sp, #0x30]
7009bc54: 6849         	ldr	r1, [r1, #0x4]
7009bc56: 9a04         	ldr	r2, [sp, #0x10]
7009bc58: 6051         	str	r1, [r2, #0x4]
;         uartLldInit_handle->dataLength        = object->prms.dataLength;
7009bc5a: 990c         	ldr	r1, [sp, #0x30]
7009bc5c: 6889         	ldr	r1, [r1, #0x8]
7009bc5e: 9a04         	ldr	r2, [sp, #0x10]
7009bc60: 6091         	str	r1, [r2, #0x8]
;         uartLldInit_handle->stopBits          = object->prms.stopBits;
7009bc62: 990c         	ldr	r1, [sp, #0x30]
7009bc64: 68c9         	ldr	r1, [r1, #0xc]
7009bc66: 9a04         	ldr	r2, [sp, #0x10]
7009bc68: 60d1         	str	r1, [r2, #0xc]
;         uartLldInit_handle->parityType        = object->prms.parityType;
7009bc6a: 990c         	ldr	r1, [sp, #0x30]
7009bc6c: 6909         	ldr	r1, [r1, #0x10]
7009bc6e: 9a04         	ldr	r2, [sp, #0x10]
7009bc70: 6111         	str	r1, [r2, #0x10]
;         uartLldInit_handle->readReturnMode    = object->prms.readReturnMode;
7009bc72: 990c         	ldr	r1, [sp, #0x30]
7009bc74: 6989         	ldr	r1, [r1, #0x18]
7009bc76: 9a04         	ldr	r2, [sp, #0x10]
7009bc78: 6151         	str	r1, [r2, #0x14]
;         uartLldInit_handle->hwFlowControl     = object->prms.hwFlowControl;
7009bc7a: 990c         	ldr	r1, [sp, #0x30]
7009bc7c: 6a89         	ldr	r1, [r1, #0x28]
7009bc7e: 9a04         	ldr	r2, [sp, #0x10]
7009bc80: 6191         	str	r1, [r2, #0x18]
;         uartLldInit_handle->hwFlowControlThr  = object->prms.hwFlowControlThr;
7009bc82: 990c         	ldr	r1, [sp, #0x30]
7009bc84: 6ac9         	ldr	r1, [r1, #0x2c]
7009bc86: 9a04         	ldr	r2, [sp, #0x10]
7009bc88: 61d1         	str	r1, [r2, #0x1c]
;         uartLldInit_handle->intrNum           = object->prms.intrNum;
7009bc8a: 990c         	ldr	r1, [sp, #0x30]
7009bc8c: 6b49         	ldr	r1, [r1, #0x34]
7009bc8e: 9a04         	ldr	r2, [sp, #0x10]
7009bc90: 6251         	str	r1, [r2, #0x24]
;         uartLldInit_handle->transferMode      = object->prms.transferMode;
7009bc92: 990c         	ldr	r1, [sp, #0x30]
7009bc94: 6b09         	ldr	r1, [r1, #0x30]
7009bc96: 9a04         	ldr	r2, [sp, #0x10]
7009bc98: 6211         	str	r1, [r2, #0x20]
;         uartLldInit_handle->intrPriority      = object->prms.intrPriority;
7009bc9a: 990c         	ldr	r1, [sp, #0x30]
7009bc9c: f891 1038    	ldrb.w	r1, [r1, #0x38]
7009bca0: 9a04         	ldr	r2, [sp, #0x10]
7009bca2: f882 1028    	strb.w	r1, [r2, #0x28]
;         uartLldInit_handle->operMode          = object->prms.operMode;
7009bca6: 990c         	ldr	r1, [sp, #0x30]
7009bca8: 6c49         	ldr	r1, [r1, #0x44]
7009bcaa: 9a04         	ldr	r2, [sp, #0x10]
7009bcac: 62d1         	str	r1, [r2, #0x2c]
;         uartLldInit_handle->rxTrigLvl         = object->prms.rxTrigLvl;
7009bcae: 990c         	ldr	r1, [sp, #0x30]
7009bcb0: 6c89         	ldr	r1, [r1, #0x48]
7009bcb2: 9a04         	ldr	r2, [sp, #0x10]
7009bcb4: 6391         	str	r1, [r2, #0x38]
;         uartLldInit_handle->txTrigLvl         = object->prms.txTrigLvl;
7009bcb6: 990c         	ldr	r1, [sp, #0x30]
7009bcb8: 6cc9         	ldr	r1, [r1, #0x4c]
7009bcba: 9a04         	ldr	r2, [sp, #0x10]
7009bcbc: 63d1         	str	r1, [r2, #0x3c]
;         uartLldInit_handle->uartDmaHandle     = NULL;
7009bcbe: 9904         	ldr	r1, [sp, #0x10]
7009bcc0: 6488         	str	r0, [r1, #0x48]
;         uartLldInit_handle->dmaChCfg          = NULL;
7009bcc2: 9904         	ldr	r1, [sp, #0x10]
7009bcc4: 64c8         	str	r0, [r1, #0x4c]
;         uartLldInit_handle->rxEvtNum          = object->prms.rxEvtNum;
7009bcc6: 980c         	ldr	r0, [sp, #0x30]
7009bcc8: 6d00         	ldr	r0, [r0, #0x50]
7009bcca: 9904         	ldr	r1, [sp, #0x10]
7009bccc: 6408         	str	r0, [r1, #0x40]
;         uartLldInit_handle->txEvtNum          = object->prms.txEvtNum;
7009bcce: 980c         	ldr	r0, [sp, #0x30]
7009bcd0: 6d40         	ldr	r0, [r0, #0x54]
7009bcd2: 9904         	ldr	r1, [sp, #0x10]
7009bcd4: 6448         	str	r0, [r1, #0x44]
;         uartLldInit_handle->writeMode         = object->prms.writeMode;
7009bcd6: 980c         	ldr	r0, [sp, #0x30]
7009bcd8: 69c0         	ldr	r0, [r0, #0x1c]
7009bcda: 9904         	ldr	r1, [sp, #0x10]
7009bcdc: 6348         	str	r0, [r1, #0x34]
;         uartLldInit_handle->readMode          = object->prms.readMode;
7009bcde: 980c         	ldr	r0, [sp, #0x30]
7009bce0: 6940         	ldr	r0, [r0, #0x14]
7009bce2: 9904         	ldr	r1, [sp, #0x10]
7009bce4: 6308         	str	r0, [r1, #0x30]
;         uartLldInit_handle->timeGuardVal      = object->prms.timeGuardVal;
7009bce6: 980c         	ldr	r0, [sp, #0x30]
7009bce8: 6d80         	ldr	r0, [r0, #0x58]
7009bcea: 9904         	ldr	r1, [sp, #0x10]
7009bcec: 6508         	str	r0, [r1, #0x50]
;         uartLldInit_handle->clockP_get        = ClockP_getTicks;
7009bcee: 9904         	ldr	r1, [sp, #0x10]
7009bcf0: f64f 40f1    	movw	r0, #0xfcf1
7009bcf4: f2c7 000a    	movt	r0, #0x700a
7009bcf8: 6548         	str	r0, [r1, #0x54]
;         uartLldInit_handle->clockP_usecToTick = ClockP_usecToTicks;
7009bcfa: 9904         	ldr	r1, [sp, #0x10]
7009bcfc: f24f 3031    	movw	r0, #0xf331
7009bd00: f2c7 000a    	movt	r0, #0x700a
7009bd04: 6588         	str	r0, [r1, #0x58]
;         uartLldInit_handle->readCompleteCallbackFxn =  UART_lld_readCompleteCallback;
7009bd06: 9904         	ldr	r1, [sp, #0x10]
7009bd08: f24c 7031    	movw	r0, #0xc731
7009bd0c: f2c7 000a    	movt	r0, #0x700a
7009bd10: 65c8         	str	r0, [r1, #0x5c]
;         uartLldInit_handle->writeCompleteCallbackFxn = UART_lld_writeCompleteCallback;
7009bd12: 9904         	ldr	r1, [sp, #0x10]
7009bd14: f24c 6071    	movw	r0, #0xc671
7009bd18: f2c7 000a    	movt	r0, #0x700a
7009bd1c: 6608         	str	r0, [r1, #0x60]
;         uartLldInit_handle->errorCallbackFxn =         UART_lld_errorCallback;
7009bd1e: 9904         	ldr	r1, [sp, #0x10]
7009bd20: f64f 5001    	movw	r0, #0xfd01
7009bd24: f2c7 000a    	movt	r0, #0x700a
7009bd28: 6648         	str	r0, [r1, #0x64]
;         status = UART_checkOpenParams(&object->prms);
7009bd2a: 980c         	ldr	r0, [sp, #0x30]
7009bd2c: 3004         	adds	r0, #0x4
7009bd2e: f011 fed7    	bl	0x700adae0 <UART_checkOpenParams> @ imm = #0x11dae
7009bd32: 900f         	str	r0, [sp, #0x3c]
;     }
7009bd34: e7ff         	b	0x7009bd36 <UART_open+0x276> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009bd36: 980f         	ldr	r0, [sp, #0x3c]
7009bd38: 2800         	cmp	r0, #0x0
7009bd3a: f040 80b8    	bne.w	0x7009beae <UART_open+0x3ee> @ imm = #0x170
7009bd3e: e7ff         	b	0x7009bd40 <UART_open+0x280> @ imm = #-0x2
;         uartLld_handle->state = UART_STATE_RESET;
7009bd40: 9905         	ldr	r1, [sp, #0x14]
7009bd42: 2000         	movs	r0, #0x0
7009bd44: 6548         	str	r0, [r1, #0x54]
;         if(UART_CONFIG_MODE_DMA == object->prms.transferMode)
7009bd46: 980c         	ldr	r0, [sp, #0x30]
7009bd48: 6b00         	ldr	r0, [r0, #0x30]
7009bd4a: 2803         	cmp	r0, #0x3
7009bd4c: d117         	bne	0x7009bd7e <UART_open+0x2be> @ imm = #0x2e
7009bd4e: e7ff         	b	0x7009bd50 <UART_open+0x290> @ imm = #-0x2
;             uartLldInit_handle->uartDmaHandle = (UART_DmaHandle) gUartDmaHandle[index];
7009bd50: 9911         	ldr	r1, [sp, #0x44]
7009bd52: f242 6080    	movw	r0, #0x2680
7009bd56: f2c7 000b    	movt	r0, #0x700b
7009bd5a: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009bd5e: 9904         	ldr	r1, [sp, #0x10]
7009bd60: 6488         	str	r0, [r1, #0x48]
;             uartLldInit_handle->dmaChCfg      = gUartDmaChConfig[index];
7009bd62: 9911         	ldr	r1, [sp, #0x44]
7009bd64: f642 2000    	movw	r0, #0x2a00
7009bd68: f2c7 000b    	movt	r0, #0x700b
7009bd6c: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009bd70: 9904         	ldr	r1, [sp, #0x10]
7009bd72: 64c8         	str	r0, [r1, #0x4c]
;             status = UART_lld_initDma(uartLld_handle);
7009bd74: 9805         	ldr	r0, [sp, #0x14]
7009bd76: f006 f93b    	bl	0x700a1ff0 <UART_lld_initDma> @ imm = #0x6276
7009bd7a: 900f         	str	r0, [sp, #0x3c]
;         }
7009bd7c: e008         	b	0x7009bd90 <UART_open+0x2d0> @ imm = #0x10
;             status = UART_lld_init(uartLld_handle);
7009bd7e: 9805         	ldr	r0, [sp, #0x14]
7009bd80: f007 fb56    	bl	0x700a3430 <UART_lld_init> @ imm = #0x76ac
7009bd84: 900f         	str	r0, [sp, #0x3c]
;             object->uartDmaHandle = NULL;
7009bd86: 990c         	ldr	r1, [sp, #0x30]
7009bd88: 2000         	movs	r0, #0x0
7009bd8a: f8c1 0280    	str.w	r0, [r1, #0x280]
7009bd8e: e7ff         	b	0x7009bd90 <UART_open+0x2d0> @ imm = #-0x2
;         if(SystemP_SUCCESS == status)
7009bd90: 980f         	ldr	r0, [sp, #0x3c]
7009bd92: 2800         	cmp	r0, #0x0
7009bd94: f040 808a    	bne.w	0x7009beac <UART_open+0x3ec> @ imm = #0x114
7009bd98: e7ff         	b	0x7009bd9a <UART_open+0x2da> @ imm = #-0x2
;             status = SemaphoreP_constructMutex(&object->lockObj);
7009bd9a: 980c         	ldr	r0, [sp, #0x30]
7009bd9c: 308c         	adds	r0, #0x8c
7009bd9e: f00f fc4f    	bl	0x700ab640 <SemaphoreP_constructMutex> @ imm = #0xf89e
7009bda2: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009bda4: 980f         	ldr	r0, [sp, #0x3c]
7009bda6: b930         	cbnz	r0, 0x7009bdb6 <UART_open+0x2f6> @ imm = #0xc
7009bda8: e7ff         	b	0x7009bdaa <UART_open+0x2ea> @ imm = #-0x2
;                 object->lock = &object->lockObj;
7009bdaa: 990c         	ldr	r1, [sp, #0x30]
7009bdac: f101 008c    	add.w	r0, r1, #0x8c
7009bdb0: f8c1 0088    	str.w	r0, [r1, #0x88]
;             }
7009bdb4: e7ff         	b	0x7009bdb6 <UART_open+0x2f6> @ imm = #-0x2
;             status += SemaphoreP_constructBinary(&object->readTransferSemObj, 0U);
7009bdb6: 980c         	ldr	r0, [sp, #0x30]
7009bdb8: f500 7094    	add.w	r0, r0, #0x128
7009bdbc: 2100         	movs	r1, #0x0
7009bdbe: f00c f8c7    	bl	0x700a7f50 <SemaphoreP_constructBinary> @ imm = #0xc18e
7009bdc2: 4601         	mov	r1, r0
7009bdc4: 980f         	ldr	r0, [sp, #0x3c]
7009bdc6: 4408         	add	r0, r1
7009bdc8: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009bdca: 980f         	ldr	r0, [sp, #0x3c]
7009bdcc: b958         	cbnz	r0, 0x7009bde6 <UART_open+0x326> @ imm = #0x16
7009bdce: e7ff         	b	0x7009bdd0 <UART_open+0x310> @ imm = #-0x2
;                 object->readTransferSem = &object->readTransferSemObj;
7009bdd0: 990c         	ldr	r1, [sp, #0x30]
7009bdd2: f501 7094    	add.w	r0, r1, #0x128
7009bdd6: f8c1 0124    	str.w	r0, [r1, #0x124]
;                 uartLld_handle->readTransferMutex = object->readTransferSem;
7009bdda: 980c         	ldr	r0, [sp, #0x30]
7009bddc: f8d0 0124    	ldr.w	r0, [r0, #0x124]
7009bde0: 9905         	ldr	r1, [sp, #0x14]
7009bde2: 6588         	str	r0, [r1, #0x58]
;             }
7009bde4: e7ff         	b	0x7009bde6 <UART_open+0x326> @ imm = #-0x2
;             status += SemaphoreP_constructBinary(&object->writeTransferSemObj, 0U);
7009bde6: 980c         	ldr	r0, [sp, #0x30]
7009bde8: f500 70e2    	add.w	r0, r0, #0x1c4
7009bdec: 2100         	movs	r1, #0x0
7009bdee: f00c f8af    	bl	0x700a7f50 <SemaphoreP_constructBinary> @ imm = #0xc15e
7009bdf2: 4601         	mov	r1, r0
7009bdf4: 980f         	ldr	r0, [sp, #0x3c]
7009bdf6: 4408         	add	r0, r1
7009bdf8: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009bdfa: 980f         	ldr	r0, [sp, #0x3c]
7009bdfc: b958         	cbnz	r0, 0x7009be16 <UART_open+0x356> @ imm = #0x16
7009bdfe: e7ff         	b	0x7009be00 <UART_open+0x340> @ imm = #-0x2
;                 object->writeTransferSem = &object->writeTransferSemObj;
7009be00: 990c         	ldr	r1, [sp, #0x30]
7009be02: f501 70e2    	add.w	r0, r1, #0x1c4
7009be06: f8c1 01c0    	str.w	r0, [r1, #0x1c0]
;                 uartLld_handle->writeTransferMutex = object->writeTransferSem;
7009be0a: 980c         	ldr	r0, [sp, #0x30]
7009be0c: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
7009be10: 9905         	ldr	r1, [sp, #0x14]
7009be12: 65c8         	str	r0, [r1, #0x5c]
;             }
7009be14: e7ff         	b	0x7009be16 <UART_open+0x356> @ imm = #-0x2
;             if((UART_CONFIG_MODE_INTERRUPT == object->prms.transferMode) && (TRUE != object->prms.skipIntrReg))
7009be16: 980c         	ldr	r0, [sp, #0x30]
7009be18: 6b00         	ldr	r0, [r0, #0x30]
7009be1a: 2801         	cmp	r0, #0x1
7009be1c: d145         	bne	0x7009beaa <UART_open+0x3ea> @ imm = #0x8a
7009be1e: e7ff         	b	0x7009be20 <UART_open+0x360> @ imm = #-0x2
7009be20: 980c         	ldr	r0, [sp, #0x30]
7009be22: 6bc0         	ldr	r0, [r0, #0x3c]
7009be24: 2801         	cmp	r0, #0x1
7009be26: d040         	beq	0x7009beaa <UART_open+0x3ea> @ imm = #0x80
7009be28: e7ff         	b	0x7009be2a <UART_open+0x36a> @ imm = #-0x2
;                 DebugP_assert(object->prms.intrNum != 0xFFFFU);
7009be2a: 980c         	ldr	r0, [sp, #0x30]
7009be2c: 6b40         	ldr	r0, [r0, #0x34]
7009be2e: f64f 71ff    	movw	r1, #0xffff
7009be32: 1a40         	subs	r0, r0, r1
7009be34: bf18         	it	ne
7009be36: 2001         	movne	r0, #0x1
7009be38: f641 41e7    	movw	r1, #0x1ce7
7009be3c: f2c7 010b    	movt	r1, #0x700b
7009be40: 466a         	mov	r2, sp
7009be42: 6011         	str	r1, [r2]
7009be44: f641 71e1    	movw	r1, #0x1fe1
7009be48: f2c7 010b    	movt	r1, #0x700b
7009be4c: f242 125b    	movw	r2, #0x215b
7009be50: f2c7 020b    	movt	r2, #0x700b
7009be54: f44f 73bf    	mov.w	r3, #0x17e
7009be58: f00e ff1a    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xee34
7009be5c: a806         	add	r0, sp, #0x18
;                 HwiP_Params_init(&hwiPrms);
7009be5e: 9002         	str	r0, [sp, #0x8]
7009be60: f014 f876    	bl	0x700aff50 <HwiP_Params_init> @ imm = #0x140ec
7009be64: 9902         	ldr	r1, [sp, #0x8]
;                 hwiPrms.intNum      = object->prms.intrNum;
7009be66: 980c         	ldr	r0, [sp, #0x30]
7009be68: 6b40         	ldr	r0, [r0, #0x34]
7009be6a: 9006         	str	r0, [sp, #0x18]
;                 hwiPrms.callback    = &UART_lld_controllerIsr;
7009be6c: f240 3001    	movw	r0, #0x301
7009be70: f2c7 000a    	movt	r0, #0x700a
7009be74: 9007         	str	r0, [sp, #0x1c]
;                 hwiPrms.priority    = object->prms.intrPriority;
7009be76: 980c         	ldr	r0, [sp, #0x30]
7009be78: f890 0038    	ldrb.w	r0, [r0, #0x38]
7009be7c: f88d 0026    	strb.w	r0, [sp, #0x26]
;                 hwiPrms.args        = (void *) uartLld_handle;
7009be80: 9805         	ldr	r0, [sp, #0x14]
7009be82: 9008         	str	r0, [sp, #0x20]
;                 status += HwiP_construct(&object->hwiObj, &hwiPrms);
7009be84: 980c         	ldr	r0, [sp, #0x30]
7009be86: f500 7018    	add.w	r0, r0, #0x260
7009be8a: f014 f879    	bl	0x700aff80 <HwiP_construct> @ imm = #0x140f2
7009be8e: 4601         	mov	r1, r0
7009be90: 980f         	ldr	r0, [sp, #0x3c]
7009be92: 4408         	add	r0, r1
7009be94: 900f         	str	r0, [sp, #0x3c]
;                 if(SystemP_SUCCESS == status)
7009be96: 980f         	ldr	r0, [sp, #0x3c]
7009be98: b930         	cbnz	r0, 0x7009bea8 <UART_open+0x3e8> @ imm = #0xc
7009be9a: e7ff         	b	0x7009be9c <UART_open+0x3dc> @ imm = #-0x2
;                     object->hwiHandle = &object->hwiObj;
7009be9c: 990c         	ldr	r1, [sp, #0x30]
7009be9e: f501 7018    	add.w	r0, r1, #0x260
7009bea2: f8c1 025c    	str.w	r0, [r1, #0x25c]
;                 }
7009bea6: e7ff         	b	0x7009bea8 <UART_open+0x3e8> @ imm = #-0x2
;             }
7009bea8: e7ff         	b	0x7009beaa <UART_open+0x3ea> @ imm = #-0x2
;         }
7009beaa: e7ff         	b	0x7009beac <UART_open+0x3ec> @ imm = #-0x2
;     }
7009beac: e7ff         	b	0x7009beae <UART_open+0x3ee> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009beae: 980f         	ldr	r0, [sp, #0x3c]
7009beb0: b938         	cbnz	r0, 0x7009bec2 <UART_open+0x402> @ imm = #0xe
7009beb2: e7ff         	b	0x7009beb4 <UART_open+0x3f4> @ imm = #-0x2
;         object->isOpen = TRUE;
7009beb4: 990c         	ldr	r1, [sp, #0x30]
7009beb6: 2001         	movs	r0, #0x1
7009beb8: f8c1 0084    	str.w	r0, [r1, #0x84]
;         handle = (UART_Handle) config;
7009bebc: 980d         	ldr	r0, [sp, #0x34]
7009bebe: 900e         	str	r0, [sp, #0x38]
;     }
7009bec0: e7ff         	b	0x7009bec2 <UART_open+0x402> @ imm = #-0x2
;     SemaphoreP_post(&gUartDrvObj.lockObj);
7009bec2: f242 7038    	movw	r0, #0x2738
7009bec6: f2c7 000b    	movt	r0, #0x700b
7009beca: 3004         	adds	r0, #0x4
7009becc: f010 f818    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x10030
;     if(SystemP_SUCCESS != status)
7009bed0: 980f         	ldr	r0, [sp, #0x3c]
7009bed2: b140         	cbz	r0, 0x7009bee6 <UART_open+0x426> @ imm = #0x10
7009bed4: e7ff         	b	0x7009bed6 <UART_open+0x416> @ imm = #-0x2
;         if(NULL != config)
7009bed6: 980d         	ldr	r0, [sp, #0x34]
7009bed8: b120         	cbz	r0, 0x7009bee4 <UART_open+0x424> @ imm = #0x8
7009beda: e7ff         	b	0x7009bedc <UART_open+0x41c> @ imm = #-0x2
;             UART_close((UART_Handle) config);
7009bedc: 980d         	ldr	r0, [sp, #0x34]
7009bede: f004 f857    	bl	0x7009ff90 <UART_close> @ imm = #0x40ae
;         }
7009bee2: e7ff         	b	0x7009bee4 <UART_open+0x424> @ imm = #-0x2
;     }
7009bee4: e7ff         	b	0x7009bee6 <UART_open+0x426> @ imm = #-0x2
;     return (handle);
7009bee6: 980e         	ldr	r0, [sp, #0x38]
7009bee8: b012         	add	sp, #0x48
7009beea: bd80         	pop	{r7, pc}
7009beec: 0000         	movs	r0, r0
7009beee: 0000         	movs	r0, r0

7009bef0 <Udma_chAllocResource>:
; {
7009bef0: b580         	push	{r7, lr}
7009bef2: b088         	sub	sp, #0x20
7009bef4: 9007         	str	r0, [sp, #0x1c]
7009bef6: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK, tempRetVal;
7009bef8: 9006         	str	r0, [sp, #0x18]
7009befa: f64f 70ff    	movw	r0, #0xffff
;     uint16_t                ringNum = UDMA_RING_INVALID;
7009befe: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     drvHandle = chHandle->drvHandle;
7009bf02: 9807         	ldr	r0, [sp, #0x1c]
7009bf04: 6e80         	ldr	r0, [r0, #0x68]
7009bf06: 9004         	str	r0, [sp, #0x10]
;     if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009bf08: 9807         	ldr	r0, [sp, #0x1c]
7009bf0a: 7800         	ldrb	r0, [r0]
7009bf0c: 0740         	lsls	r0, r0, #0x1d
7009bf0e: 2800         	cmp	r0, #0x0
7009bf10: d54d         	bpl	0x7009bfae <Udma_chAllocResource+0xbe> @ imm = #0x9a
7009bf12: e7ff         	b	0x7009bf14 <Udma_chAllocResource+0x24> @ imm = #-0x2
;         if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009bf14: 9807         	ldr	r0, [sp, #0x1c]
7009bf16: 7800         	ldrb	r0, [r0]
7009bf18: 0640         	lsls	r0, r0, #0x19
7009bf1a: 2800         	cmp	r0, #0x0
7009bf1c: d508         	bpl	0x7009bf30 <Udma_chAllocResource+0x40> @ imm = #0x10
7009bf1e: e7ff         	b	0x7009bf20 <Udma_chAllocResource+0x30> @ imm = #-0x2
;                 Udma_rmAllocBlkCopyHcCh(chHandle->chPrms.chNum, drvHandle);
7009bf20: 9807         	ldr	r0, [sp, #0x1c]
7009bf22: 6840         	ldr	r0, [r0, #0x4]
7009bf24: 9904         	ldr	r1, [sp, #0x10]
7009bf26: f007 fd7b    	bl	0x700a3a20 <Udma_rmAllocBlkCopyHcCh> @ imm = #0x7af6
;             chHandle->txChNum =
7009bf2a: 9907         	ldr	r1, [sp, #0x1c]
7009bf2c: 66c8         	str	r0, [r1, #0x6c]
;         }
7009bf2e: e016         	b	0x7009bf5e <Udma_chAllocResource+0x6e> @ imm = #0x2c
;         else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009bf30: 9807         	ldr	r0, [sp, #0x1c]
7009bf32: 7800         	ldrb	r0, [r0]
7009bf34: 0600         	lsls	r0, r0, #0x18
7009bf36: 2800         	cmp	r0, #0x0
7009bf38: d508         	bpl	0x7009bf4c <Udma_chAllocResource+0x5c> @ imm = #0x10
7009bf3a: e7ff         	b	0x7009bf3c <Udma_chAllocResource+0x4c> @ imm = #-0x2
;                 Udma_rmAllocBlkCopyUhcCh(chHandle->chPrms.chNum, drvHandle);
7009bf3c: 9807         	ldr	r0, [sp, #0x1c]
7009bf3e: 6840         	ldr	r0, [r0, #0x4]
7009bf40: 9904         	ldr	r1, [sp, #0x10]
7009bf42: f007 fe05    	bl	0x700a3b50 <Udma_rmAllocBlkCopyUhcCh> @ imm = #0x7c0a
;             chHandle->txChNum =
7009bf46: 9907         	ldr	r1, [sp, #0x1c]
7009bf48: 66c8         	str	r0, [r1, #0x6c]
;         }
7009bf4a: e007         	b	0x7009bf5c <Udma_chAllocResource+0x6c> @ imm = #0xe
;                 Udma_rmAllocBlkCopyCh(chHandle->chPrms.chNum, drvHandle);
7009bf4c: 9807         	ldr	r0, [sp, #0x1c]
7009bf4e: 6840         	ldr	r0, [r0, #0x4]
7009bf50: 9904         	ldr	r1, [sp, #0x10]
7009bf52: f007 fccd    	bl	0x700a38f0 <Udma_rmAllocBlkCopyCh> @ imm = #0x799a
;             chHandle->txChNum =
7009bf56: 9907         	ldr	r1, [sp, #0x1c]
7009bf58: 66c8         	str	r0, [r1, #0x6c]
7009bf5a: e7ff         	b	0x7009bf5c <Udma_chAllocResource+0x6c> @ imm = #-0x2
7009bf5c: e7ff         	b	0x7009bf5e <Udma_chAllocResource+0x6e> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID == chHandle->txChNum)
7009bf5e: 9807         	ldr	r0, [sp, #0x1c]
7009bf60: 6ec0         	ldr	r0, [r0, #0x6c]
7009bf62: f510 3f80    	cmn.w	r0, #0x10000
7009bf66: d104         	bne	0x7009bf72 <Udma_chAllocResource+0x82> @ imm = #0x8
7009bf68: e7ff         	b	0x7009bf6a <Udma_chAllocResource+0x7a> @ imm = #-0x2
7009bf6a: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
7009bf6e: 9006         	str	r0, [sp, #0x18]
;         }
7009bf70: e01c         	b	0x7009bfac <Udma_chAllocResource+0xbc> @ imm = #0x38
;             if (UDMA_INST_TYPE_LCDMA_BCDMA == chHandle->drvHandle->instType)
7009bf72: 9807         	ldr	r0, [sp, #0x1c]
7009bf74: 6e80         	ldr	r0, [r0, #0x68]
7009bf76: 6800         	ldr	r0, [r0]
7009bf78: 2801         	cmp	r0, #0x1
7009bf7a: d10b         	bne	0x7009bf94 <Udma_chAllocResource+0xa4> @ imm = #0x16
7009bf7c: e7ff         	b	0x7009bf7e <Udma_chAllocResource+0x8e> @ imm = #-0x2
;                 chHandle->rxChNum     = UDMA_DMA_CH_INVALID;
7009bf7e: 9907         	ldr	r1, [sp, #0x1c]
7009bf80: 2000         	movs	r0, #0x0
7009bf82: f6cf 70ff    	movt	r0, #0xffff
7009bf86: 6708         	str	r0, [r1, #0x70]
;                 chHandle->peerThreadId = UDMA_THREAD_ID_INVALID;
7009bf88: 9907         	ldr	r1, [sp, #0x1c]
7009bf8a: 2004         	movs	r0, #0x4
7009bf8c: f6cf 70ff    	movt	r0, #0xffff
7009bf90: 67c8         	str	r0, [r1, #0x7c]
;             }
7009bf92: e00a         	b	0x7009bfaa <Udma_chAllocResource+0xba> @ imm = #0x14
;                 chHandle->rxChNum = chHandle->txChNum;
7009bf94: 9907         	ldr	r1, [sp, #0x1c]
7009bf96: 6ec8         	ldr	r0, [r1, #0x6c]
7009bf98: 6708         	str	r0, [r1, #0x70]
;                     chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
7009bf9a: 9907         	ldr	r1, [sp, #0x1c]
7009bf9c: 6f08         	ldr	r0, [r1, #0x70]
7009bf9e: 9a04         	ldr	r2, [sp, #0x10]
7009bfa0: f8d2 20d8    	ldr.w	r2, [r2, #0xd8]
7009bfa4: 4410         	add	r0, r2
;                 chHandle->peerThreadId =
7009bfa6: 67c8         	str	r0, [r1, #0x7c]
7009bfa8: e7ff         	b	0x7009bfaa <Udma_chAllocResource+0xba> @ imm = #-0x2
7009bfaa: e7ff         	b	0x7009bfac <Udma_chAllocResource+0xbc> @ imm = #-0x2
;     }
7009bfac: e0bd         	b	0x7009c12a <Udma_chAllocResource+0x23a> @ imm = #0x17a
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009bfae: 9807         	ldr	r0, [sp, #0x1c]
7009bfb0: 7800         	ldrb	r0, [r0]
7009bfb2: 07c0         	lsls	r0, r0, #0x1f
7009bfb4: 2800         	cmp	r0, #0x0
7009bfb6: d03f         	beq	0x7009c038 <Udma_chAllocResource+0x148> @ imm = #0x7e
7009bfb8: e7ff         	b	0x7009bfba <Udma_chAllocResource+0xca> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009bfba: 9807         	ldr	r0, [sp, #0x1c]
7009bfbc: 7800         	ldrb	r0, [r0]
7009bfbe: 0640         	lsls	r0, r0, #0x19
7009bfc0: 2800         	cmp	r0, #0x0
7009bfc2: d508         	bpl	0x7009bfd6 <Udma_chAllocResource+0xe6> @ imm = #0x10
7009bfc4: e7ff         	b	0x7009bfc6 <Udma_chAllocResource+0xd6> @ imm = #-0x2
;                     Udma_rmAllocTxHcCh(chHandle->chPrms.chNum, drvHandle);
7009bfc6: 9807         	ldr	r0, [sp, #0x1c]
7009bfc8: 6840         	ldr	r0, [r0, #0x4]
7009bfca: 9904         	ldr	r1, [sp, #0x10]
7009bfcc: f008 f8b8    	bl	0x700a4140 <Udma_rmAllocTxHcCh> @ imm = #0x8170
;                 chHandle->txChNum =
7009bfd0: 9907         	ldr	r1, [sp, #0x1c]
7009bfd2: 66c8         	str	r0, [r1, #0x6c]
;             }
7009bfd4: e025         	b	0x7009c022 <Udma_chAllocResource+0x132> @ imm = #0x4a
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009bfd6: 9807         	ldr	r0, [sp, #0x1c]
7009bfd8: 7840         	ldrb	r0, [r0, #0x1]
7009bfda: 07c0         	lsls	r0, r0, #0x1f
7009bfdc: b148         	cbz	r0, 0x7009bff2 <Udma_chAllocResource+0x102> @ imm = #0x12
7009bfde: e7ff         	b	0x7009bfe0 <Udma_chAllocResource+0xf0> @ imm = #-0x2
;                     Udma_rmAllocMappedTxCh(chHandle->chPrms.chNum, drvHandle, chHandle->chPrms.mappedChGrp);
7009bfe0: 9a07         	ldr	r2, [sp, #0x1c]
7009bfe2: 9904         	ldr	r1, [sp, #0x10]
7009bfe4: 6850         	ldr	r0, [r2, #0x4]
7009bfe6: 68d2         	ldr	r2, [r2, #0xc]
7009bfe8: f005 fea2    	bl	0x700a1d30 <Udma_rmAllocMappedTxCh> @ imm = #0x5d44
;                 chHandle->txChNum =
7009bfec: 9907         	ldr	r1, [sp, #0x1c]
7009bfee: 66c8         	str	r0, [r1, #0x6c]
;             }
7009bff0: e016         	b	0x7009c020 <Udma_chAllocResource+0x130> @ imm = #0x2c
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009bff2: 9807         	ldr	r0, [sp, #0x1c]
7009bff4: 7800         	ldrb	r0, [r0]
7009bff6: 0600         	lsls	r0, r0, #0x18
7009bff8: 2800         	cmp	r0, #0x0
7009bffa: d508         	bpl	0x7009c00e <Udma_chAllocResource+0x11e> @ imm = #0x10
7009bffc: e7ff         	b	0x7009bffe <Udma_chAllocResource+0x10e> @ imm = #-0x2
;                     Udma_rmAllocTxUhcCh(chHandle->chPrms.chNum, drvHandle);
7009bffe: 9807         	ldr	r0, [sp, #0x1c]
7009c000: 6840         	ldr	r0, [r0, #0x4]
7009c002: 9904         	ldr	r1, [sp, #0x10]
7009c004: f008 f934    	bl	0x700a4270 <Udma_rmAllocTxUhcCh> @ imm = #0x8268
;                 chHandle->txChNum =
7009c008: 9907         	ldr	r1, [sp, #0x1c]
7009c00a: 66c8         	str	r0, [r1, #0x6c]
;             }
7009c00c: e007         	b	0x7009c01e <Udma_chAllocResource+0x12e> @ imm = #0xe
;                     Udma_rmAllocTxCh(chHandle->chPrms.chNum, drvHandle);
7009c00e: 9807         	ldr	r0, [sp, #0x1c]
7009c010: 6840         	ldr	r0, [r0, #0x4]
7009c012: 9904         	ldr	r1, [sp, #0x10]
7009c014: f007 fffc    	bl	0x700a4010 <Udma_rmAllocTxCh> @ imm = #0x7ff8
;                 chHandle->txChNum =
7009c018: 9907         	ldr	r1, [sp, #0x1c]
7009c01a: 66c8         	str	r0, [r1, #0x6c]
7009c01c: e7ff         	b	0x7009c01e <Udma_chAllocResource+0x12e> @ imm = #-0x2
7009c01e: e7ff         	b	0x7009c020 <Udma_chAllocResource+0x130> @ imm = #-0x2
7009c020: e7ff         	b	0x7009c022 <Udma_chAllocResource+0x132> @ imm = #-0x2
;             if(UDMA_DMA_CH_INVALID == chHandle->txChNum)
7009c022: 9807         	ldr	r0, [sp, #0x1c]
7009c024: 6ec0         	ldr	r0, [r0, #0x6c]
7009c026: f510 3f80    	cmn.w	r0, #0x10000
7009c02a: d104         	bne	0x7009c036 <Udma_chAllocResource+0x146> @ imm = #0x8
7009c02c: e7ff         	b	0x7009c02e <Udma_chAllocResource+0x13e> @ imm = #-0x2
7009c02e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009c032: 9006         	str	r0, [sp, #0x18]
;             }
7009c034: e7ff         	b	0x7009c036 <Udma_chAllocResource+0x146> @ imm = #-0x2
;         }
7009c036: e05c         	b	0x7009c0f2 <Udma_chAllocResource+0x202> @ imm = #0xb8
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009c038: 9807         	ldr	r0, [sp, #0x1c]
7009c03a: 7800         	ldrb	r0, [r0]
7009c03c: 0640         	lsls	r0, r0, #0x19
7009c03e: 2800         	cmp	r0, #0x0
7009c040: d508         	bpl	0x7009c054 <Udma_chAllocResource+0x164> @ imm = #0x10
7009c042: e7ff         	b	0x7009c044 <Udma_chAllocResource+0x154> @ imm = #-0x2
;                     Udma_rmAllocRxHcCh(chHandle->chPrms.chNum, drvHandle);
7009c044: 9807         	ldr	r0, [sp, #0x1c]
7009c046: 6840         	ldr	r0, [r0, #0x4]
7009c048: 9904         	ldr	r1, [sp, #0x10]
7009c04a: f007 feb1    	bl	0x700a3db0 <Udma_rmAllocRxHcCh> @ imm = #0x7d62
;                 chHandle->rxChNum =
7009c04e: 9907         	ldr	r1, [sp, #0x1c]
7009c050: 6708         	str	r0, [r1, #0x70]
;             }
7009c052: e026         	b	0x7009c0a2 <Udma_chAllocResource+0x1b2> @ imm = #0x4c
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009c054: 9807         	ldr	r0, [sp, #0x1c]
7009c056: 7840         	ldrb	r0, [r0, #0x1]
7009c058: 07c0         	lsls	r0, r0, #0x1f
7009c05a: b150         	cbz	r0, 0x7009c072 <Udma_chAllocResource+0x182> @ imm = #0x14
7009c05c: e7ff         	b	0x7009c05e <Udma_chAllocResource+0x16e> @ imm = #-0x2
;                     Udma_rmAllocMappedRxCh(chHandle->chPrms.chNum, drvHandle, chHandle->chPrms.mappedChGrp - UDMA_NUM_MAPPED_TX_GROUP);
7009c05e: 9a07         	ldr	r2, [sp, #0x1c]
7009c060: 9904         	ldr	r1, [sp, #0x10]
7009c062: 6850         	ldr	r0, [r2, #0x4]
7009c064: 68d2         	ldr	r2, [r2, #0xc]
7009c066: 3a04         	subs	r2, #0x4
7009c068: f005 fdb2    	bl	0x700a1bd0 <Udma_rmAllocMappedRxCh> @ imm = #0x5b64
;                 chHandle->rxChNum =
7009c06c: 9907         	ldr	r1, [sp, #0x1c]
7009c06e: 6708         	str	r0, [r1, #0x70]
;             }
7009c070: e016         	b	0x7009c0a0 <Udma_chAllocResource+0x1b0> @ imm = #0x2c
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009c072: 9807         	ldr	r0, [sp, #0x1c]
7009c074: 7800         	ldrb	r0, [r0]
7009c076: 0600         	lsls	r0, r0, #0x18
7009c078: 2800         	cmp	r0, #0x0
7009c07a: d508         	bpl	0x7009c08e <Udma_chAllocResource+0x19e> @ imm = #0x10
7009c07c: e7ff         	b	0x7009c07e <Udma_chAllocResource+0x18e> @ imm = #-0x2
;                     Udma_rmAllocRxUhcCh(chHandle->chPrms.chNum, drvHandle);
7009c07e: 9807         	ldr	r0, [sp, #0x1c]
7009c080: 6840         	ldr	r0, [r0, #0x4]
7009c082: 9904         	ldr	r1, [sp, #0x10]
7009c084: f007 ff2c    	bl	0x700a3ee0 <Udma_rmAllocRxUhcCh> @ imm = #0x7e58
;                 chHandle->rxChNum =
7009c088: 9907         	ldr	r1, [sp, #0x1c]
7009c08a: 6708         	str	r0, [r1, #0x70]
;             }
7009c08c: e007         	b	0x7009c09e <Udma_chAllocResource+0x1ae> @ imm = #0xe
;                     Udma_rmAllocRxCh(chHandle->chPrms.chNum, drvHandle);
7009c08e: 9807         	ldr	r0, [sp, #0x1c]
7009c090: 6840         	ldr	r0, [r0, #0x4]
7009c092: 9904         	ldr	r1, [sp, #0x10]
7009c094: f007 fdf4    	bl	0x700a3c80 <Udma_rmAllocRxCh> @ imm = #0x7be8
;                 chHandle->rxChNum =
7009c098: 9907         	ldr	r1, [sp, #0x1c]
7009c09a: 6708         	str	r0, [r1, #0x70]
7009c09c: e7ff         	b	0x7009c09e <Udma_chAllocResource+0x1ae> @ imm = #-0x2
7009c09e: e7ff         	b	0x7009c0a0 <Udma_chAllocResource+0x1b0> @ imm = #-0x2
7009c0a0: e7ff         	b	0x7009c0a2 <Udma_chAllocResource+0x1b2> @ imm = #-0x2
;             if(UDMA_DMA_CH_INVALID == chHandle->rxChNum)
7009c0a2: 9807         	ldr	r0, [sp, #0x1c]
7009c0a4: 6f00         	ldr	r0, [r0, #0x70]
7009c0a6: f510 3f80    	cmn.w	r0, #0x10000
7009c0aa: d104         	bne	0x7009c0b6 <Udma_chAllocResource+0x1c6> @ imm = #0x8
7009c0ac: e7ff         	b	0x7009c0ae <Udma_chAllocResource+0x1be> @ imm = #-0x2
7009c0ae: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009c0b2: 9006         	str	r0, [sp, #0x18]
;             }
7009c0b4: e01c         	b	0x7009c0f0 <Udma_chAllocResource+0x200> @ imm = #0x38
;                 chHandle->defaultFlow               = &chHandle->defaultFlowObj;
7009c0b6: 9907         	ldr	r1, [sp, #0x1c]
7009c0b8: f501 70e6    	add.w	r0, r1, #0x1cc
7009c0bc: f8c1 01c8    	str.w	r0, [r1, #0x1c8]
;                 chHandle->defaultFlow->drvHandle    = drvHandle;
7009c0c0: 9804         	ldr	r0, [sp, #0x10]
7009c0c2: 9907         	ldr	r1, [sp, #0x1c]
7009c0c4: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009c0c8: 6008         	str	r0, [r1]
;                 chHandle->defaultFlow->flowStart    = chHandle->rxChNum;
7009c0ca: 9907         	ldr	r1, [sp, #0x1c]
7009c0cc: 6f08         	ldr	r0, [r1, #0x70]
7009c0ce: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009c0d2: 6048         	str	r0, [r1, #0x4]
;                 chHandle->defaultFlow->flowCnt      = 1U;
7009c0d4: 9807         	ldr	r0, [sp, #0x1c]
7009c0d6: f8d0 11c8    	ldr.w	r1, [r0, #0x1c8]
7009c0da: 2001         	movs	r0, #0x1
7009c0dc: 6088         	str	r0, [r1, #0x8]
;                 chHandle->defaultFlow->flowInitDone = UDMA_INIT_DONE;
7009c0de: 9807         	ldr	r0, [sp, #0x1c]
7009c0e0: f8d0 11c8    	ldr.w	r1, [r0, #0x1c8]
7009c0e4: f64a 30cd    	movw	r0, #0xabcd
7009c0e8: f6ca 30dc    	movt	r0, #0xabdc
7009c0ec: 60c8         	str	r0, [r1, #0xc]
7009c0ee: e7ff         	b	0x7009c0f0 <Udma_chAllocResource+0x200> @ imm = #-0x2
7009c0f0: e7ff         	b	0x7009c0f2 <Udma_chAllocResource+0x202> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
7009c0f2: 9806         	ldr	r0, [sp, #0x18]
7009c0f4: b9c0         	cbnz	r0, 0x7009c128 <Udma_chAllocResource+0x238> @ imm = #0x30
7009c0f6: e7ff         	b	0x7009c0f8 <Udma_chAllocResource+0x208> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA)
7009c0f8: 9807         	ldr	r0, [sp, #0x1c]
7009c0fa: 7800         	ldrb	r0, [r0]
7009c0fc: 0700         	lsls	r0, r0, #0x1c
7009c0fe: 2800         	cmp	r0, #0x0
7009c100: d507         	bpl	0x7009c112 <Udma_chAllocResource+0x222> @ imm = #0xe
7009c102: e7ff         	b	0x7009c104 <Udma_chAllocResource+0x214> @ imm = #-0x2
;                 chHandle->pdmaChNum = chHandle->chPrms.peerChNum;
7009c104: 9907         	ldr	r1, [sp, #0x1c]
7009c106: 6888         	ldr	r0, [r1, #0x8]
7009c108: 6788         	str	r0, [r1, #0x78]
;                 chHandle->peerThreadId = chHandle->pdmaChNum;
7009c10a: 9907         	ldr	r1, [sp, #0x1c]
7009c10c: 6f88         	ldr	r0, [r1, #0x78]
7009c10e: 67c8         	str	r0, [r1, #0x7c]
;             }
7009c110: e7ff         	b	0x7009c112 <Udma_chAllocResource+0x222> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_PSIL) == UDMA_CH_FLAG_PSIL)
7009c112: 9807         	ldr	r0, [sp, #0x1c]
7009c114: 7800         	ldrb	r0, [r0]
7009c116: 06c0         	lsls	r0, r0, #0x1b
7009c118: 2800         	cmp	r0, #0x0
7009c11a: d504         	bpl	0x7009c126 <Udma_chAllocResource+0x236> @ imm = #0x8
7009c11c: e7ff         	b	0x7009c11e <Udma_chAllocResource+0x22e> @ imm = #-0x2
;                 chHandle->peerThreadId = chHandle->chPrms.peerChNum;
7009c11e: 9907         	ldr	r1, [sp, #0x1c]
7009c120: 6888         	ldr	r0, [r1, #0x8]
7009c122: 67c8         	str	r0, [r1, #0x7c]
;             }
7009c124: e7ff         	b	0x7009c126 <Udma_chAllocResource+0x236> @ imm = #-0x2
;         }
7009c126: e7ff         	b	0x7009c128 <Udma_chAllocResource+0x238> @ imm = #-0x2
7009c128: e7ff         	b	0x7009c12a <Udma_chAllocResource+0x23a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c12a: 9806         	ldr	r0, [sp, #0x18]
7009c12c: 2800         	cmp	r0, #0x0
7009c12e: f040 8088    	bne.w	0x7009c242 <Udma_chAllocResource+0x352> @ imm = #0x110
7009c132: e7ff         	b	0x7009c134 <Udma_chAllocResource+0x244> @ imm = #-0x2
;         if(NULL_PTR != chHandle->chPrms.fqRingPrms.ringMem)
7009c134: 9807         	ldr	r0, [sp, #0x1c]
7009c136: 6940         	ldr	r0, [r0, #0x14]
7009c138: 2800         	cmp	r0, #0x0
7009c13a: f000 8081    	beq.w	0x7009c240 <Udma_chAllocResource+0x350> @ imm = #0x102
7009c13e: e7ff         	b	0x7009c140 <Udma_chAllocResource+0x250> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) ==
7009c140: 9807         	ldr	r0, [sp, #0x1c]
7009c142: 7800         	ldrb	r0, [r0]
7009c144: 0740         	lsls	r0, r0, #0x1d
7009c146: 2800         	cmp	r0, #0x0
7009c148: d505         	bpl	0x7009c156 <Udma_chAllocResource+0x266> @ imm = #0xa
7009c14a: e7ff         	b	0x7009c14c <Udma_chAllocResource+0x25c> @ imm = #-0x2
;                 ringNum = (uint16_t)chHandle->txChNum;
7009c14c: 9807         	ldr	r0, [sp, #0x1c]
7009c14e: 6ec0         	ldr	r0, [r0, #0x6c]
7009c150: f8ad 000e    	strh.w	r0, [sp, #0xe]
;             }
7009c154: e044         	b	0x7009c1e0 <Udma_chAllocResource+0x2f0> @ imm = #0x88
;                 if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009c156: 9807         	ldr	r0, [sp, #0x1c]
7009c158: 7840         	ldrb	r0, [r0, #0x1]
7009c15a: 07c0         	lsls	r0, r0, #0x1f
7009c15c: b338         	cbz	r0, 0x7009c1ae <Udma_chAllocResource+0x2be> @ imm = #0x4e
7009c15e: e7ff         	b	0x7009c160 <Udma_chAllocResource+0x270> @ imm = #-0x2
;                     chHandle->chPrms.fqRingPrms.mappedRingGrp  = chHandle->chPrms.mappedChGrp;
7009c160: 9907         	ldr	r1, [sp, #0x1c]
7009c162: 68c8         	ldr	r0, [r1, #0xc]
7009c164: 6288         	str	r0, [r1, #0x28]
;                     if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009c166: 9807         	ldr	r0, [sp, #0x1c]
7009c168: 7800         	ldrb	r0, [r0]
7009c16a: 07c0         	lsls	r0, r0, #0x1f
7009c16c: b178         	cbz	r0, 0x7009c18e <Udma_chAllocResource+0x29e> @ imm = #0x1e
7009c16e: e7ff         	b	0x7009c170 <Udma_chAllocResource+0x280> @ imm = #-0x2
;                         chHandle->chPrms.fqRingPrms.mappedChNum    = chHandle->txChNum;
7009c170: 9907         	ldr	r1, [sp, #0x1c]
7009c172: 6ec8         	ldr	r0, [r1, #0x6c]
7009c174: 62c8         	str	r0, [r1, #0x2c]
;                         retVal = Udma_getMappedChRingAttributes(drvHandle, chHandle->chPrms.mappedChGrp, chHandle->txChNum, &chAttr);
7009c176: 9804         	ldr	r0, [sp, #0x10]
7009c178: 9a07         	ldr	r2, [sp, #0x1c]
7009c17a: 68d1         	ldr	r1, [r2, #0xc]
7009c17c: 6ed2         	ldr	r2, [r2, #0x6c]
7009c17e: 466b         	mov	r3, sp
7009c180: f00b fe36    	bl	0x700a7df0 <Udma_getMappedChRingAttributes> @ imm = #0xbc6c
7009c184: 9006         	str	r0, [sp, #0x18]
;                         ringNum = chAttr.defaultRing;
7009c186: 9800         	ldr	r0, [sp]
7009c188: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                     }
7009c18c: e00e         	b	0x7009c1ac <Udma_chAllocResource+0x2bc> @ imm = #0x1c
;                         chHandle->chPrms.fqRingPrms.mappedChNum    = chHandle->rxChNum;
7009c18e: 9907         	ldr	r1, [sp, #0x1c]
7009c190: 6f08         	ldr	r0, [r1, #0x70]
7009c192: 62c8         	str	r0, [r1, #0x2c]
;                         retVal = Udma_getMappedChRingAttributes(drvHandle, chHandle->chPrms.mappedChGrp, chHandle->rxChNum, &chAttr);
7009c194: 9804         	ldr	r0, [sp, #0x10]
7009c196: 9a07         	ldr	r2, [sp, #0x1c]
7009c198: 68d1         	ldr	r1, [r2, #0xc]
7009c19a: 6f12         	ldr	r2, [r2, #0x70]
7009c19c: 466b         	mov	r3, sp
7009c19e: f00b fe27    	bl	0x700a7df0 <Udma_getMappedChRingAttributes> @ imm = #0xbc4e
7009c1a2: 9006         	str	r0, [sp, #0x18]
;                         ringNum = chAttr.defaultRing;
7009c1a4: 9800         	ldr	r0, [sp]
7009c1a6: f8ad 000e    	strh.w	r0, [sp, #0xe]
7009c1aa: e7ff         	b	0x7009c1ac <Udma_chAllocResource+0x2bc> @ imm = #-0x2
;                 }
7009c1ac: e017         	b	0x7009c1de <Udma_chAllocResource+0x2ee> @ imm = #0x2e
;                 else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009c1ae: 9807         	ldr	r0, [sp, #0x1c]
7009c1b0: 7800         	ldrb	r0, [r0]
7009c1b2: 07c0         	lsls	r0, r0, #0x1f
7009c1b4: b148         	cbz	r0, 0x7009c1ca <Udma_chAllocResource+0x2da> @ imm = #0x12
7009c1b6: e7ff         	b	0x7009c1b8 <Udma_chAllocResource+0x2c8> @ imm = #-0x2
;                     ringNum = (uint16_t)(chHandle->txChNum + drvHandle->txChOffset);
7009c1b8: 9807         	ldr	r0, [sp, #0x1c]
7009c1ba: 6ec0         	ldr	r0, [r0, #0x6c]
7009c1bc: 9904         	ldr	r1, [sp, #0x10]
7009c1be: f8d1 110c    	ldr.w	r1, [r1, #0x10c]
7009c1c2: 4408         	add	r0, r1
7009c1c4: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                 }
7009c1c8: e008         	b	0x7009c1dc <Udma_chAllocResource+0x2ec> @ imm = #0x10
;                     ringNum = (uint16_t)(chHandle->rxChNum + drvHandle->rxChOffset);
7009c1ca: 9807         	ldr	r0, [sp, #0x1c]
7009c1cc: 6f00         	ldr	r0, [r0, #0x70]
7009c1ce: 9904         	ldr	r1, [sp, #0x10]
7009c1d0: f8d1 1114    	ldr.w	r1, [r1, #0x114]
7009c1d4: 4408         	add	r0, r1
7009c1d6: f8ad 000e    	strh.w	r0, [sp, #0xe]
7009c1da: e7ff         	b	0x7009c1dc <Udma_chAllocResource+0x2ec> @ imm = #-0x2
7009c1dc: e7ff         	b	0x7009c1de <Udma_chAllocResource+0x2ee> @ imm = #-0x2
7009c1de: e7ff         	b	0x7009c1e0 <Udma_chAllocResource+0x2f0> @ imm = #-0x2
;             chHandle->fqRing = &chHandle->fqRingObj;
7009c1e0: 9907         	ldr	r1, [sp, #0x1c]
7009c1e2: f101 0090    	add.w	r0, r1, #0x90
7009c1e6: f8c1 0080    	str.w	r0, [r1, #0x80]
;                          drvHandle,
7009c1ea: 9804         	ldr	r0, [sp, #0x10]
;                          chHandle->fqRing,
7009c1ec: 9b07         	ldr	r3, [sp, #0x1c]
7009c1ee: f8d3 1080    	ldr.w	r1, [r3, #0x80]
;                          ringNum,
7009c1f2: f8bd 200e    	ldrh.w	r2, [sp, #0xe]
;                          &chHandle->chPrms.fqRingPrms);
7009c1f6: 3314         	adds	r3, #0x14
;             retVal = Udma_ringAlloc(
7009c1f8: f003 f85a    	bl	0x7009f2b0 <Udma_ringAlloc> @ imm = #0x30b4
7009c1fc: 9006         	str	r0, [sp, #0x18]
;             if(UDMA_SOK != retVal)
7009c1fe: 9806         	ldr	r0, [sp, #0x18]
7009c200: b128         	cbz	r0, 0x7009c20e <Udma_chAllocResource+0x31e> @ imm = #0xa
7009c202: e7ff         	b	0x7009c204 <Udma_chAllocResource+0x314> @ imm = #-0x2
;                 chHandle->fqRing = (Udma_RingHandleInt) NULL_PTR;
7009c204: 9907         	ldr	r1, [sp, #0x1c]
7009c206: 2000         	movs	r0, #0x0
7009c208: f8c1 0080    	str.w	r0, [r1, #0x80]
;             }
7009c20c: e017         	b	0x7009c23e <Udma_chAllocResource+0x34e> @ imm = #0x2e
;             else if(((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED) &&
7009c20e: 9807         	ldr	r0, [sp, #0x1c]
7009c210: 7840         	ldrb	r0, [r0, #0x1]
7009c212: 07c0         	lsls	r0, r0, #0x1f
7009c214: b190         	cbz	r0, 0x7009c23c <Udma_chAllocResource+0x34c> @ imm = #0x24
7009c216: e7ff         	b	0x7009c218 <Udma_chAllocResource+0x328> @ imm = #-0x2
;                     ((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX))
7009c218: 9807         	ldr	r0, [sp, #0x1c]
;             else if(((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED) &&
7009c21a: 7800         	ldrb	r0, [r0]
7009c21c: 0780         	lsls	r0, r0, #0x1e
7009c21e: 2800         	cmp	r0, #0x0
7009c220: d50c         	bpl	0x7009c23c <Udma_chAllocResource+0x34c> @ imm = #0x18
7009c222: e7ff         	b	0x7009c224 <Udma_chAllocResource+0x334> @ imm = #-0x2
;                 chHandle->defaultFlow->flowStart    = chHandle->fqRing->ringNum - drvHandle->rxChOffset;
7009c224: 9907         	ldr	r1, [sp, #0x1c]
7009c226: f8d1 0080    	ldr.w	r0, [r1, #0x80]
7009c22a: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009c22e: 8880         	ldrh	r0, [r0, #0x4]
7009c230: 9a04         	ldr	r2, [sp, #0x10]
7009c232: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c236: 1a80         	subs	r0, r0, r2
7009c238: 6048         	str	r0, [r1, #0x4]
;             }
7009c23a: e7ff         	b	0x7009c23c <Udma_chAllocResource+0x34c> @ imm = #-0x2
7009c23c: e7ff         	b	0x7009c23e <Udma_chAllocResource+0x34e> @ imm = #-0x2
;         }
7009c23e: e7ff         	b	0x7009c240 <Udma_chAllocResource+0x350> @ imm = #-0x2
;     }
7009c240: e7ff         	b	0x7009c242 <Udma_chAllocResource+0x352> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c242: 9806         	ldr	r0, [sp, #0x18]
7009c244: b930         	cbnz	r0, 0x7009c254 <Udma_chAllocResource+0x364> @ imm = #0xc
7009c246: e7ff         	b	0x7009c248 <Udma_chAllocResource+0x358> @ imm = #-0x2
;         chHandle->cqRing = &chHandle->fqRingObj;
7009c248: 9907         	ldr	r1, [sp, #0x1c]
7009c24a: f101 0090    	add.w	r0, r1, #0x90
7009c24e: f8c1 0084    	str.w	r0, [r1, #0x84]
;     }
7009c252: e7ff         	b	0x7009c254 <Udma_chAllocResource+0x364> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c254: 9806         	ldr	r0, [sp, #0x18]
7009c256: b928         	cbnz	r0, 0x7009c264 <Udma_chAllocResource+0x374> @ imm = #0xa
7009c258: e7ff         	b	0x7009c25a <Udma_chAllocResource+0x36a> @ imm = #-0x2
;         chHandle->tdCqRing = (Udma_RingHandleInt) NULL_PTR;
7009c25a: 9907         	ldr	r1, [sp, #0x1c]
7009c25c: 2000         	movs	r0, #0x0
7009c25e: f8c1 0088    	str.w	r0, [r1, #0x88]
;     }
7009c262: e7ff         	b	0x7009c264 <Udma_chAllocResource+0x374> @ imm = #-0x2
;     if(UDMA_SOK != retVal)
7009c264: 9806         	ldr	r0, [sp, #0x18]
7009c266: b148         	cbz	r0, 0x7009c27c <Udma_chAllocResource+0x38c> @ imm = #0x12
7009c268: e7ff         	b	0x7009c26a <Udma_chAllocResource+0x37a> @ imm = #-0x2
;         tempRetVal = Udma_chFreeResource(chHandle);
7009c26a: 9807         	ldr	r0, [sp, #0x1c]
7009c26c: f002 ff18    	bl	0x7009f0a0 <Udma_chFreeResource> @ imm = #0x2e30
7009c270: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK != tempRetVal)
7009c272: 9805         	ldr	r0, [sp, #0x14]
7009c274: b108         	cbz	r0, 0x7009c27a <Udma_chAllocResource+0x38a> @ imm = #0x2
7009c276: e7ff         	b	0x7009c278 <Udma_chAllocResource+0x388> @ imm = #-0x2
;         }
7009c278: e7ff         	b	0x7009c27a <Udma_chAllocResource+0x38a> @ imm = #-0x2
;     }
7009c27a: e004         	b	0x7009c286 <Udma_chAllocResource+0x396> @ imm = #0x8
;         Udma_chAssignRegOverlay(drvHandle, chHandle);
7009c27c: 9804         	ldr	r0, [sp, #0x10]
7009c27e: 9907         	ldr	r1, [sp, #0x1c]
7009c280: f006 f8b6    	bl	0x700a23f0 <Udma_chAssignRegOverlay> @ imm = #0x616c
7009c284: e7ff         	b	0x7009c286 <Udma_chAllocResource+0x396> @ imm = #-0x2
;     return (retVal);
7009c286: 9806         	ldr	r0, [sp, #0x18]
7009c288: b008         	add	sp, #0x20
7009c28a: bd80         	pop	{r7, pc}
7009c28c: 0000         	movs	r0, r0
7009c28e: 0000         	movs	r0, r0

7009c290 <CSL_REG32_WR_RAW>:
; {
7009c290: b082         	sub	sp, #0x8
7009c292: 9001         	str	r0, [sp, #0x4]
7009c294: 9100         	str	r1, [sp]
;     *p = v;
7009c296: 9800         	ldr	r0, [sp]
7009c298: 9901         	ldr	r1, [sp, #0x4]
7009c29a: 6008         	str	r0, [r1]
;     return;
7009c29c: b002         	add	sp, #0x8
7009c29e: 4770         	bx	lr

7009c2a0 <strcmp>:
7009c2a0: e5d02000     	ldrb	r2, [r0]
7009c2a4: e5d13000     	ldrb	r3, [r1]
7009c2a8: e3520001     	cmp	r2, #1
7009c2ac: 21520003     	cmphs	r2, r3
7009c2b0: 1a004e82     	bne	0x700afcc0 <.Lfastpath_exit> @ imm = #0x13a08
7009c2b4: e16d41f0     	strd	r4, r5, [sp, #-16]!
7009c2b8: e1804001     	orr	r4, r0, r1
7009c2bc: e1cd60f8     	strd	r6, r7, [sp, #8]
7009c2c0: e3e0c000     	mvn	r12, #0
7009c2c4: e1a02e84     	lsl	r2, r4, #29
7009c2c8: e3520000     	cmp	r2, #0
7009c2cc: 0a000013     	beq	0x7009c320 <strcmp+0x80> @ imm = #0x4c
7009c2d0: e0204001     	eor	r4, r0, r1
7009c2d4: e3140007     	tst	r4, #7
7009c2d8: 1a00003e     	bne	0x7009c3d8 <strcmp+0x138> @ imm = #0xf8
7009c2dc: e2004007     	and	r4, r0, #7
7009c2e0: e3c00007     	bic	r0, r0, #7
7009c2e4: e2045003     	and	r5, r4, #3
7009c2e8: e3c11007     	bic	r1, r1, #7
7009c2ec: e1a05185     	lsl	r5, r5, #3
7009c2f0: e0c021d0     	ldrd	r2, r3, [r0], #16
7009c2f4: e3140004     	tst	r4, #4
7009c2f8: e0c161d0     	ldrd	r6, r7, [r1], #16
7009c2fc: e1e0451c     	mvn	r4, r12, lsl r5
7009c300: e1822004     	orr	r2, r2, r4
7009c304: e1866004     	orr	r6, r6, r4
7009c308: 0a000006     	beq	0x7009c328 <strcmp+0x88> @ imm = #0x18
7009c30c: e1833004     	orr	r3, r3, r4
7009c310: e1a0200c     	mov	r2, r12
7009c314: e1877004     	orr	r7, r7, r4
7009c318: e1a0600c     	mov	r6, r12
7009c31c: ea000001     	b	0x7009c328 <strcmp+0x88> @ imm = #0x4
7009c320: e0c021d0     	ldrd	r2, r3, [r0], #16
7009c324: e0c161d0     	ldrd	r6, r7, [r1], #16
7009c328: e6525f9c     	uadd8	r5, r2, r12
7009c32c: e0224006     	eor	r4, r2, r6
7009c330: e6844fbc     	sel	r4, r4, r12
7009c334: e3540000     	cmp	r4, #0
7009c338: 1a00001b     	bne	0x7009c3ac <strcmp+0x10c> @ imm = #0x6c
7009c33c: e6535f9c     	uadd8	r5, r3, r12
7009c340: e0235007     	eor	r5, r3, r7
7009c344: e6855fbc     	sel	r5, r5, r12
7009c348: e3550000     	cmp	r5, #0
7009c34c: 1a00000b     	bne	0x7009c380 <strcmp+0xe0> @ imm = #0x2c
7009c350: e14020d8     	ldrd	r2, r3, [r0, #-8]
7009c354: e14160d8     	ldrd	r6, r7, [r1, #-8]
7009c358: e6525f9c     	uadd8	r5, r2, r12
7009c35c: e0224006     	eor	r4, r2, r6
7009c360: e6844fbc     	sel	r4, r4, r12
7009c364: e6535f9c     	uadd8	r5, r3, r12
7009c368: e0235007     	eor	r5, r3, r7
7009c36c: e6855fbc     	sel	r5, r5, r12
7009c370: e1955004     	orrs	r5, r5, r4
7009c374: 0affffe9     	beq	0x7009c320 <strcmp+0x80> @ imm = #-0x5c
7009c378: e3540000     	cmp	r4, #0
7009c37c: 1a00000a     	bne	0x7009c3ac <strcmp+0x10c> @ imm = #0x28
7009c380: e6bf5f35     	rev	r5, r5
7009c384: e16f4f15     	clz	r4, r5
7009c388: e3c44007     	bic	r4, r4, #7
7009c38c: e1a01437     	lsr	r1, r7, r4
7009c390: e1cd60d8     	ldrd	r6, r7, [sp, #8]
7009c394: e1a03433     	lsr	r3, r3, r4
7009c398: e20300ff     	and	r0, r3, #255
7009c39c: e20110ff     	and	r1, r1, #255
7009c3a0: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c3a4: e0400001     	sub	r0, r0, r1
7009c3a8: e12fff1e     	bx	lr
7009c3ac: e6bf4f34     	rev	r4, r4
7009c3b0: e16f4f14     	clz	r4, r4
7009c3b4: e3c44007     	bic	r4, r4, #7
7009c3b8: e1a01436     	lsr	r1, r6, r4
7009c3bc: e1cd60d8     	ldrd	r6, r7, [sp, #8]
7009c3c0: e1a02432     	lsr	r2, r2, r4
7009c3c4: e20200ff     	and	r0, r2, #255
7009c3c8: e20110ff     	and	r1, r1, #255
7009c3cc: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c3d0: e0400001     	sub	r0, r0, r1
7009c3d4: e12fff1e     	bx	lr
7009c3d8: e3140003     	tst	r4, #3
7009c3dc: 1a000022     	bne	0x7009c46c <strcmp+0x1cc> @ imm = #0x88
7009c3e0: e2104003     	ands	r4, r0, #3
7009c3e4: 1a000017     	bne	0x7009c448 <strcmp+0x1a8> @ imm = #0x5c
7009c3e8: e4902008     	ldr	r2, [r0], #8
7009c3ec: e4913008     	ldr	r3, [r1], #8
7009c3f0: e6525f9c     	uadd8	r5, r2, r12
7009c3f4: e0225003     	eor	r5, r2, r3
7009c3f8: e6855fbc     	sel	r5, r5, r12
7009c3fc: e3550000     	cmp	r5, #0
7009c400: 1a000006     	bne	0x7009c420 <strcmp+0x180> @ imm = #0x18
7009c404: e5102004     	ldr	r2, [r0, #-0x4]
7009c408: e5113004     	ldr	r3, [r1, #-0x4]
7009c40c: e6525f9c     	uadd8	r5, r2, r12
7009c410: e0225003     	eor	r5, r2, r3
7009c414: e6855fbc     	sel	r5, r5, r12
7009c418: e3550000     	cmp	r5, #0
7009c41c: 0afffff1     	beq	0x7009c3e8 <strcmp+0x148> @ imm = #-0x3c
7009c420: e6bf5f35     	rev	r5, r5
7009c424: e16f4f15     	clz	r4, r5
7009c428: e3c44007     	bic	r4, r4, #7
7009c42c: e1a01433     	lsr	r1, r3, r4
7009c430: e1a02432     	lsr	r2, r2, r4
7009c434: e20200ff     	and	r0, r2, #255
7009c438: e20110ff     	and	r1, r1, #255
7009c43c: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c440: e0400001     	sub	r0, r0, r1
7009c444: e12fff1e     	bx	lr
7009c448: e1a04184     	lsl	r4, r4, #3
7009c44c: e3c00003     	bic	r0, r0, #3
7009c450: e4902008     	ldr	r2, [r0], #8
7009c454: e3c11003     	bic	r1, r1, #3
7009c458: e4913008     	ldr	r3, [r1], #8
7009c45c: e1e0441c     	mvn	r4, r12, lsl r4
7009c460: e1822004     	orr	r2, r2, r4
7009c464: e1833004     	orr	r3, r3, r4
7009c468: eaffffe0     	b	0x7009c3f0 <strcmp+0x150> @ imm = #-0x80
7009c46c: e2104003     	ands	r4, r0, #3
7009c470: 0a000015     	beq	0x7009c4cc <strcmp+0x22c> @ imm = #0x54
7009c474: e0411004     	sub	r1, r1, r4
7009c478: e3c00003     	bic	r0, r0, #3
7009c47c: e1b04f84     	lsls	r4, r4, #31
7009c480: e4902004     	ldr	r2, [r0], #4
7009c484: 0a000006     	beq	0x7009c4a4 <strcmp+0x204> @ imm = #0x18
7009c488: 2a00000e     	bhs	0x7009c4c8 <strcmp+0x228> @ imm = #0x38
7009c48c: e5d13002     	ldrb	r3, [r1, #0x2]
7009c490: e6ef4872     	uxtb	r4, r2, ror #16
7009c494: e0544003     	subs	r4, r4, r3
7009c498: 1a000007     	bne	0x7009c4bc <strcmp+0x21c> @ imm = #0x1c
7009c49c: e3530000     	cmp	r3, #0
7009c4a0: 0a000005     	beq	0x7009c4bc <strcmp+0x21c> @ imm = #0x14
7009c4a4: e5d13003     	ldrb	r3, [r1, #0x3]
7009c4a8: e6ef4c72     	uxtb	r4, r2, ror #24
7009c4ac: e0544003     	subs	r4, r4, r3
7009c4b0: 1a000001     	bne	0x7009c4bc <strcmp+0x21c> @ imm = #0x4
7009c4b4: e3530000     	cmp	r3, #0
7009c4b8: 1a000002     	bne	0x7009c4c8 <strcmp+0x228> @ imm = #0x8
7009c4bc: e1a00004     	mov	r0, r4
7009c4c0: e49d4010     	ldr	r4, [sp], #16
7009c4c4: e12fff1e     	bx	lr
7009c4c8: e2811004     	add	r1, r1, #4
7009c4cc: e4902004     	ldr	r2, [r0], #4
7009c4d0: e1b04f81     	lsls	r4, r1, #31
7009c4d4: e3c11003     	bic	r1, r1, #3
7009c4d8: e4913004     	ldr	r3, [r1], #4
7009c4dc: 8a00002f     	bhi	0x7009c5a0 <strcmp+0x300> @ imm = #0xbc
7009c4e0: 2a000017     	bhs	0x7009c544 <strcmp+0x2a4> @ imm = #0x5c
7009c4e4: e3c244ff     	bic	r4, r2, #-16777216
7009c4e8: e6525f9c     	uadd8	r5, r2, r12
7009c4ec: e0345423     	eors	r5, r4, r3, lsr #8
7009c4f0: e6855fbc     	sel	r5, r5, r12
7009c4f4: 1a000007     	bne	0x7009c518 <strcmp+0x278> @ imm = #0x1c
7009c4f8: e3550000     	cmp	r5, #0
7009c4fc: 1a000007     	bne	0x7009c520 <strcmp+0x280> @ imm = #0x1c
7009c500: e4913004     	ldr	r3, [r1], #4
7009c504: e0244002     	eor	r4, r4, r2
7009c508: e1540c03     	cmp	r4, r3, lsl #24
7009c50c: 1a000009     	bne	0x7009c538 <strcmp+0x298> @ imm = #0x24
7009c510: e4902004     	ldr	r2, [r0], #4
7009c514: eafffff2     	b	0x7009c4e4 <strcmp+0x244> @ imm = #-0x38
7009c518: e1a03423     	lsr	r3, r3, #8
7009c51c: ea000037     	b	0x7009c600 <strcmp+0x360> @ imm = #0xdc
7009c520: e3d554ff     	bics	r5, r5, #-16777216
7009c524: 1a000032     	bne	0x7009c5f4 <strcmp+0x354> @ imm = #0xc8
7009c528: e5d10000     	ldrb	r0, [r1]
7009c52c: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c530: e2600000     	rsb	r0, r0, #0
7009c534: e12fff1e     	bx	lr
7009c538: e1a02c22     	lsr	r2, r2, #24
7009c53c: e20330ff     	and	r3, r3, #255
7009c540: ea00002e     	b	0x7009c600 <strcmp+0x360> @ imm = #0xb8
7009c544: e002482c     	and	r4, r2, r12, lsr #16
7009c548: e6525f9c     	uadd8	r5, r2, r12
7009c54c: e0345823     	eors	r5, r4, r3, lsr #16
7009c550: e6855fbc     	sel	r5, r5, r12
7009c554: 1a000007     	bne	0x7009c578 <strcmp+0x2d8> @ imm = #0x1c
7009c558: e3550000     	cmp	r5, #0
7009c55c: 1a000007     	bne	0x7009c580 <strcmp+0x2e0> @ imm = #0x1c
7009c560: e4913004     	ldr	r3, [r1], #4
7009c564: e0244002     	eor	r4, r4, r2
7009c568: e1540803     	cmp	r4, r3, lsl #16
7009c56c: 1a000008     	bne	0x7009c594 <strcmp+0x2f4> @ imm = #0x20
7009c570: e4902004     	ldr	r2, [r0], #4
7009c574: eafffff2     	b	0x7009c544 <strcmp+0x2a4> @ imm = #-0x38
7009c578: e1a03823     	lsr	r3, r3, #16
7009c57c: ea00001f     	b	0x7009c600 <strcmp+0x360> @ imm = #0x7c
7009c580: e015582c     	ands	r5, r5, r12, lsr #16
7009c584: 1a00001a     	bne	0x7009c5f4 <strcmp+0x354> @ imm = #0x68
7009c588: e1d130b0     	ldrh	r3, [r1]
7009c58c: e1a02822     	lsr	r2, r2, #16
7009c590: ea00001a     	b	0x7009c600 <strcmp+0x360> @ imm = #0x68
7009c594: e1a02822     	lsr	r2, r2, #16
7009c598: e003382c     	and	r3, r3, r12, lsr #16
7009c59c: ea000017     	b	0x7009c600 <strcmp+0x360> @ imm = #0x5c
7009c5a0: e20240ff     	and	r4, r2, #255
7009c5a4: e6525f9c     	uadd8	r5, r2, r12
7009c5a8: e0345c23     	eors	r5, r4, r3, lsr #24
7009c5ac: e6855fbc     	sel	r5, r5, r12
7009c5b0: 1a000007     	bne	0x7009c5d4 <strcmp+0x334> @ imm = #0x1c
7009c5b4: e3550000     	cmp	r5, #0
7009c5b8: 1a000007     	bne	0x7009c5dc <strcmp+0x33c> @ imm = #0x1c
7009c5bc: e4913004     	ldr	r3, [r1], #4
7009c5c0: e0244002     	eor	r4, r4, r2
7009c5c4: e1540403     	cmp	r4, r3, lsl #8
7009c5c8: 1a000006     	bne	0x7009c5e8 <strcmp+0x348> @ imm = #0x18
7009c5cc: e4902004     	ldr	r2, [r0], #4
7009c5d0: eafffff2     	b	0x7009c5a0 <strcmp+0x300> @ imm = #-0x38
7009c5d4: e1a03c23     	lsr	r3, r3, #24
7009c5d8: ea000008     	b	0x7009c600 <strcmp+0x360> @ imm = #0x20
7009c5dc: e31500ff     	tst	r5, #255
7009c5e0: 1a000003     	bne	0x7009c5f4 <strcmp+0x354> @ imm = #0xc
7009c5e4: e5913000     	ldr	r3, [r1]
7009c5e8: e1a02422     	lsr	r2, r2, #8
7009c5ec: e3c334ff     	bic	r3, r3, #-16777216
7009c5f0: ea000002     	b	0x7009c600 <strcmp+0x360> @ imm = #0x8
7009c5f4: e3a00000     	mov	r0, #0
7009c5f8: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c5fc: e12fff1e     	bx	lr
7009c600: e6bf2f32     	rev	r2, r2
7009c604: e6bf3f33     	rev	r3, r3
7009c608: e6524f9c     	uadd8	r4, r2, r12
7009c60c: e0224003     	eor	r4, r2, r3
7009c610: e6845fbc     	sel	r5, r4, r12
7009c614: e16f4f15     	clz	r4, r5
7009c618: e1a02412     	lsl	r2, r2, r4
7009c61c: e1a03413     	lsl	r3, r3, r4
7009c620: e1a00c22     	lsr	r0, r2, #24
7009c624: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c628: e0400c23     	sub	r0, r0, r3, lsr #24
7009c62c: e12fff1e     	bx	lr

7009c630 <Udma_chDisableTxChan>:
; {
7009c630: b580         	push	{r7, lr}
7009c632: b09a         	sub	sp, #0x68
7009c634: 9019         	str	r0, [sp, #0x64]
7009c636: 9118         	str	r1, [sp, #0x60]
7009c638: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009c63a: 9017         	str	r0, [sp, #0x5c]
;     uint32_t            peerRtEnable = 0U, currTimeout = 0U;
7009c63c: 9016         	str	r0, [sp, #0x58]
7009c63e: 9015         	str	r0, [sp, #0x54]
;     drvHandle = chHandle->drvHandle;
7009c640: 9819         	ldr	r0, [sp, #0x64]
7009c642: 6e80         	ldr	r0, [r0, #0x68]
7009c644: 9014         	str	r0, [sp, #0x50]
7009c646: 2008         	movs	r0, #0x8
;     rtEnableRegOffset = CSL_PSILCFG_REG_RT_ENABLE - CSL_PSILCFG_REG_STATIC_TR;
7009c648: 9008         	str	r0, [sp, #0x20]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c64a: 9814         	ldr	r0, [sp, #0x50]
7009c64c: 6800         	ldr	r0, [r0]
7009c64e: 2801         	cmp	r0, #0x1
7009c650: d10e         	bne	0x7009c670 <Udma_chDisableTxChan+0x40> @ imm = #0x1c
7009c652: e7ff         	b	0x7009c654 <Udma_chDisableTxChan+0x24> @ imm = #-0x2
;                  &drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, (bool)false, (bool)false);
7009c654: 9a14         	ldr	r2, [sp, #0x50]
7009c656: f102 0008    	add.w	r0, r2, #0x8
7009c65a: 9919         	ldr	r1, [sp, #0x64]
7009c65c: 6ec9         	ldr	r1, [r1, #0x6c]
7009c65e: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c662: 4411         	add	r1, r2
7009c664: 2300         	movs	r3, #0x0
;         retVal = CSL_bcdmaTeardownTxChan(
7009c666: 461a         	mov	r2, r3
7009c668: f011 f8aa    	bl	0x700ad7c0 <CSL_bcdmaTeardownTxChan> @ imm = #0x11154
7009c66c: 9017         	str	r0, [sp, #0x5c]
;     }
7009c66e: e00f         	b	0x7009c690 <Udma_chDisableTxChan+0x60> @ imm = #0x1e
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c670: 9814         	ldr	r0, [sp, #0x50]
7009c672: 6800         	ldr	r0, [r0]
7009c674: 2802         	cmp	r0, #0x2
7009c676: d10a         	bne	0x7009c68e <Udma_chDisableTxChan+0x5e> @ imm = #0x14
7009c678: e7ff         	b	0x7009c67a <Udma_chDisableTxChan+0x4a> @ imm = #-0x2
;                  &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009c67a: 9814         	ldr	r0, [sp, #0x50]
7009c67c: 3054         	adds	r0, #0x54
7009c67e: 9919         	ldr	r1, [sp, #0x64]
7009c680: 6ec9         	ldr	r1, [r1, #0x6c]
7009c682: 2300         	movs	r3, #0x0
;         retVal = CSL_pktdmaTeardownTxChan(
7009c684: 461a         	mov	r2, r3
7009c686: f011 ff43    	bl	0x700ae510 <CSL_pktdmaTeardownTxChan> @ imm = #0x11e86
7009c68a: 9017         	str	r0, [sp, #0x5c]
;     }
7009c68c: e7ff         	b	0x7009c68e <Udma_chDisableTxChan+0x5e> @ imm = #-0x2
7009c68e: e7ff         	b	0x7009c690 <Udma_chDisableTxChan+0x60> @ imm = #-0x2
;     if(CSL_PASS != retVal)
7009c690: 9817         	ldr	r0, [sp, #0x5c]
7009c692: b108         	cbz	r0, 0x7009c698 <Udma_chDisableTxChan+0x68> @ imm = #0x2
7009c694: e7ff         	b	0x7009c696 <Udma_chDisableTxChan+0x66> @ imm = #-0x2
;     }
7009c696: e7ff         	b	0x7009c698 <Udma_chDisableTxChan+0x68> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009c698: e7ff         	b	0x7009c69a <Udma_chDisableTxChan+0x6a> @ imm = #-0x2
7009c69a: 9817         	ldr	r0, [sp, #0x5c]
7009c69c: bbc8         	cbnz	r0, 0x7009c712 <Udma_chDisableTxChan+0xe2> @ imm = #0x72
7009c69e: e7ff         	b	0x7009c6a0 <Udma_chDisableTxChan+0x70> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c6a0: 9814         	ldr	r0, [sp, #0x50]
7009c6a2: 6800         	ldr	r0, [r0]
7009c6a4: 2801         	cmp	r0, #0x1
7009c6a6: d110         	bne	0x7009c6ca <Udma_chDisableTxChan+0x9a> @ imm = #0x20
7009c6a8: e7ff         	b	0x7009c6aa <Udma_chDisableTxChan+0x7a> @ imm = #-0x2
;             (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009c6aa: 9a14         	ldr	r2, [sp, #0x50]
7009c6ac: f102 0008    	add.w	r0, r2, #0x8
7009c6b0: 9919         	ldr	r1, [sp, #0x64]
7009c6b2: 6ec9         	ldr	r1, [r1, #0x6c]
7009c6b4: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c6b8: 4411         	add	r1, r2
7009c6ba: aa0e         	add	r2, sp, #0x38
7009c6bc: f012 fa20    	bl	0x700aeb00 <CSL_bcdmaGetTxRT> @ imm = #0x12440
;             if(FALSE == bcdmaRtStatus.enable)
7009c6c0: 980e         	ldr	r0, [sp, #0x38]
7009c6c2: b908         	cbnz	r0, 0x7009c6c8 <Udma_chDisableTxChan+0x98> @ imm = #0x2
7009c6c4: e7ff         	b	0x7009c6c6 <Udma_chDisableTxChan+0x96> @ imm = #-0x2
;                 break;
7009c6c6: e024         	b	0x7009c712 <Udma_chDisableTxChan+0xe2> @ imm = #0x48
;         }
7009c6c8: e011         	b	0x7009c6ee <Udma_chDisableTxChan+0xbe> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c6ca: 9814         	ldr	r0, [sp, #0x50]
7009c6cc: 6800         	ldr	r0, [r0]
7009c6ce: 2802         	cmp	r0, #0x2
7009c6d0: d10c         	bne	0x7009c6ec <Udma_chDisableTxChan+0xbc> @ imm = #0x18
7009c6d2: e7ff         	b	0x7009c6d4 <Udma_chDisableTxChan+0xa4> @ imm = #-0x2
;             (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009c6d4: 9814         	ldr	r0, [sp, #0x50]
7009c6d6: 3054         	adds	r0, #0x54
7009c6d8: 9919         	ldr	r1, [sp, #0x64]
7009c6da: 6ec9         	ldr	r1, [r1, #0x6c]
7009c6dc: aa09         	add	r2, sp, #0x24
7009c6de: f010 febf    	bl	0x700ad460 <CSL_pktdmaGetTxRT> @ imm = #0x10d7e
;             if(FALSE == pktdmaRtStatus.enable)
7009c6e2: 9809         	ldr	r0, [sp, #0x24]
7009c6e4: b908         	cbnz	r0, 0x7009c6ea <Udma_chDisableTxChan+0xba> @ imm = #0x2
7009c6e6: e7ff         	b	0x7009c6e8 <Udma_chDisableTxChan+0xb8> @ imm = #-0x2
;                 break;
7009c6e8: e013         	b	0x7009c712 <Udma_chDisableTxChan+0xe2> @ imm = #0x26
;         }
7009c6ea: e7ff         	b	0x7009c6ec <Udma_chDisableTxChan+0xbc> @ imm = #-0x2
7009c6ec: e7ff         	b	0x7009c6ee <Udma_chDisableTxChan+0xbe> @ imm = #-0x2
;         if(currTimeout > timeout)
7009c6ee: 9815         	ldr	r0, [sp, #0x54]
7009c6f0: 9918         	ldr	r1, [sp, #0x60]
7009c6f2: 4288         	cmp	r0, r1
7009c6f4: d904         	bls	0x7009c700 <Udma_chDisableTxChan+0xd0> @ imm = #0x8
7009c6f6: e7ff         	b	0x7009c6f8 <Udma_chDisableTxChan+0xc8> @ imm = #-0x2
7009c6f8: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009c6fc: 9017         	str	r0, [sp, #0x5c]
;         }
7009c6fe: e007         	b	0x7009c710 <Udma_chDisableTxChan+0xe0> @ imm = #0xe
7009c700: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009c704: f00e fd44    	bl	0x700ab190 <ClockP_usleep> @ imm = #0xea88
;             currTimeout++;
7009c708: 9815         	ldr	r0, [sp, #0x54]
7009c70a: 3001         	adds	r0, #0x1
7009c70c: 9015         	str	r0, [sp, #0x54]
7009c70e: e7ff         	b	0x7009c710 <Udma_chDisableTxChan+0xe0> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009c710: e7c3         	b	0x7009c69a <Udma_chDisableTxChan+0x6a> @ imm = #-0x7a
;     if(UDMA_SOK != retVal)
7009c712: 9817         	ldr	r0, [sp, #0x5c]
7009c714: 2800         	cmp	r0, #0x0
7009c716: f000 80e4    	beq.w	0x7009c8e2 <Udma_chDisableTxChan+0x2b2> @ imm = #0x1c8
7009c71a: e7ff         	b	0x7009c71c <Udma_chDisableTxChan+0xec> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c71c: 9814         	ldr	r0, [sp, #0x50]
7009c71e: 6800         	ldr	r0, [r0]
7009c720: 2801         	cmp	r0, #0x1
7009c722: d10e         	bne	0x7009c742 <Udma_chDisableTxChan+0x112> @ imm = #0x1c
7009c724: e7ff         	b	0x7009c726 <Udma_chDisableTxChan+0xf6> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, (bool)true, (bool)false);
7009c726: 9a14         	ldr	r2, [sp, #0x50]
7009c728: f102 0008    	add.w	r0, r2, #0x8
7009c72c: 9919         	ldr	r1, [sp, #0x64]
7009c72e: 6ec9         	ldr	r1, [r1, #0x6c]
7009c730: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c734: 4411         	add	r1, r2
7009c736: 2201         	movs	r2, #0x1
7009c738: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownTxChan(
7009c73a: f011 f841    	bl	0x700ad7c0 <CSL_bcdmaTeardownTxChan> @ imm = #0x11082
7009c73e: 9017         	str	r0, [sp, #0x5c]
;         }
7009c740: e00f         	b	0x7009c762 <Udma_chDisableTxChan+0x132> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c742: 9814         	ldr	r0, [sp, #0x50]
7009c744: 6800         	ldr	r0, [r0]
7009c746: 2802         	cmp	r0, #0x2
7009c748: d10a         	bne	0x7009c760 <Udma_chDisableTxChan+0x130> @ imm = #0x14
7009c74a: e7ff         	b	0x7009c74c <Udma_chDisableTxChan+0x11c> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009c74c: 9814         	ldr	r0, [sp, #0x50]
7009c74e: 3054         	adds	r0, #0x54
7009c750: 9919         	ldr	r1, [sp, #0x64]
7009c752: 6ec9         	ldr	r1, [r1, #0x6c]
7009c754: 2201         	movs	r2, #0x1
7009c756: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownTxChan(
7009c758: f011 feda    	bl	0x700ae510 <CSL_pktdmaTeardownTxChan> @ imm = #0x11db4
7009c75c: 9017         	str	r0, [sp, #0x5c]
;         }
7009c75e: e7ff         	b	0x7009c760 <Udma_chDisableTxChan+0x130> @ imm = #-0x2
7009c760: e7ff         	b	0x7009c762 <Udma_chDisableTxChan+0x132> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009c762: 9817         	ldr	r0, [sp, #0x5c]
7009c764: b108         	cbz	r0, 0x7009c76a <Udma_chDisableTxChan+0x13a> @ imm = #0x2
7009c766: e7ff         	b	0x7009c768 <Udma_chDisableTxChan+0x138> @ imm = #-0x2
;         }
7009c768: e7ff         	b	0x7009c76a <Udma_chDisableTxChan+0x13a> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c76a: 9814         	ldr	r0, [sp, #0x50]
7009c76c: 6800         	ldr	r0, [r0]
7009c76e: 2801         	cmp	r0, #0x1
7009c770: d128         	bne	0x7009c7c4 <Udma_chDisableTxChan+0x194> @ imm = #0x50
7009c772: e7ff         	b	0x7009c774 <Udma_chDisableTxChan+0x144> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs,
7009c774: 9a14         	ldr	r2, [sp, #0x50]
7009c776: f102 0008    	add.w	r0, r2, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009c77a: 9919         	ldr	r1, [sp, #0x64]
7009c77c: 6ec9         	ldr	r1, [r1, #0x6c]
7009c77e: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c782: 4411         	add	r1, r2
;                 rtEnableRegOffset,
7009c784: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaGetChanPeerReg(
7009c786: 46ec         	mov	r12, sp
7009c788: aa16         	add	r2, sp, #0x58
7009c78a: 9206         	str	r2, [sp, #0x18]
7009c78c: f8cc 2000    	str.w	r2, [r12]
7009c790: 2200         	movs	r2, #0x0
7009c792: 9207         	str	r2, [sp, #0x1c]
7009c794: f011 f8dc    	bl	0x700ad950 <CSL_bcdmaGetChanPeerReg> @ imm = #0x111b8
7009c798: f8dd c018    	ldr.w	r12, [sp, #0x18]
7009c79c: 9a07         	ldr	r2, [sp, #0x1c]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_FLUSH, (uint32_t) 1U);
7009c79e: 9816         	ldr	r0, [sp, #0x58]
7009c7a0: f040 5080    	orr	r0, r0, #0x10000000
7009c7a4: 9016         	str	r0, [sp, #0x58]
;                 &drvHandle->bcdmaRegs,
7009c7a6: 9b14         	ldr	r3, [sp, #0x50]
7009c7a8: f103 0008    	add.w	r0, r3, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009c7ac: 9919         	ldr	r1, [sp, #0x64]
7009c7ae: 6ec9         	ldr	r1, [r1, #0x6c]
7009c7b0: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
7009c7b4: 4419         	add	r1, r3
;                 rtEnableRegOffset,
7009c7b6: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaSetChanPeerReg(
7009c7b8: 46ee         	mov	lr, sp
7009c7ba: f8ce c000    	str.w	r12, [lr]
7009c7be: f011 fba7    	bl	0x700adf10 <CSL_bcdmaSetChanPeerReg> @ imm = #0x1174e
;         }
7009c7c2: e025         	b	0x7009c810 <Udma_chDisableTxChan+0x1e0> @ imm = #0x4a
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c7c4: 9814         	ldr	r0, [sp, #0x50]
7009c7c6: 6800         	ldr	r0, [r0]
7009c7c8: 2802         	cmp	r0, #0x2
7009c7ca: d120         	bne	0x7009c80e <Udma_chDisableTxChan+0x1de> @ imm = #0x40
7009c7cc: e7ff         	b	0x7009c7ce <Udma_chDisableTxChan+0x19e> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs,
7009c7ce: 9814         	ldr	r0, [sp, #0x50]
7009c7d0: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009c7d2: 9919         	ldr	r1, [sp, #0x64]
7009c7d4: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009c7d6: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaGetChanPeerReg(
7009c7d8: 46ec         	mov	r12, sp
7009c7da: aa16         	add	r2, sp, #0x58
7009c7dc: 9204         	str	r2, [sp, #0x10]
7009c7de: f8cc 2000    	str.w	r2, [r12]
7009c7e2: 2200         	movs	r2, #0x0
7009c7e4: 9205         	str	r2, [sp, #0x14]
7009c7e6: f012 f80b    	bl	0x700ae800 <CSL_pktdmaGetChanPeerReg> @ imm = #0x12016
7009c7ea: f8dd c010    	ldr.w	r12, [sp, #0x10]
7009c7ee: 9a05         	ldr	r2, [sp, #0x14]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_FLUSH, (uint32_t) 1U);
7009c7f0: 9816         	ldr	r0, [sp, #0x58]
7009c7f2: f040 5080    	orr	r0, r0, #0x10000000
7009c7f6: 9016         	str	r0, [sp, #0x58]
;                 &drvHandle->pktdmaRegs,
7009c7f8: 9814         	ldr	r0, [sp, #0x50]
7009c7fa: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009c7fc: 9919         	ldr	r1, [sp, #0x64]
7009c7fe: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009c800: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaSetChanPeerReg(
7009c802: 46ee         	mov	lr, sp
7009c804: f8ce c000    	str.w	r12, [lr]
7009c808: f012 f812    	bl	0x700ae830 <CSL_pktdmaSetChanPeerReg> @ imm = #0x12024
;         }
7009c80c: e7ff         	b	0x7009c80e <Udma_chDisableTxChan+0x1de> @ imm = #-0x2
7009c80e: e7ff         	b	0x7009c810 <Udma_chDisableTxChan+0x1e0> @ imm = #-0x2
7009c810: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009c812: 9015         	str	r0, [sp, #0x54]
;         while(UDMA_SOK == retVal)
7009c814: e7ff         	b	0x7009c816 <Udma_chDisableTxChan+0x1e6> @ imm = #-0x2
7009c816: 9817         	ldr	r0, [sp, #0x5c]
7009c818: 2800         	cmp	r0, #0x0
7009c81a: d161         	bne	0x7009c8e0 <Udma_chDisableTxChan+0x2b0> @ imm = #0xc2
7009c81c: e7ff         	b	0x7009c81e <Udma_chDisableTxChan+0x1ee> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c81e: 9814         	ldr	r0, [sp, #0x50]
7009c820: 6800         	ldr	r0, [r0]
7009c822: 2801         	cmp	r0, #0x1
7009c824: d126         	bne	0x7009c874 <Udma_chDisableTxChan+0x244> @ imm = #0x4c
7009c826: e7ff         	b	0x7009c828 <Udma_chDisableTxChan+0x1f8> @ imm = #-0x2
;                 (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009c828: 9a14         	ldr	r2, [sp, #0x50]
7009c82a: f102 0008    	add.w	r0, r2, #0x8
7009c82e: 9919         	ldr	r1, [sp, #0x64]
7009c830: 6ec9         	ldr	r1, [r1, #0x6c]
7009c832: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c836: 4411         	add	r1, r2
7009c838: aa0e         	add	r2, sp, #0x38
7009c83a: f012 f961    	bl	0x700aeb00 <CSL_bcdmaGetTxRT> @ imm = #0x122c2
;                     &drvHandle->bcdmaRegs,
7009c83e: 9a14         	ldr	r2, [sp, #0x50]
7009c840: f102 0008    	add.w	r0, r2, #0x8
;                     chHandle->txChNum + drvHandle->txChOffset,
7009c844: 9919         	ldr	r1, [sp, #0x64]
7009c846: 6ec9         	ldr	r1, [r1, #0x6c]
7009c848: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c84c: 4411         	add	r1, r2
;                     rtEnableRegOffset, &peerRtEnable);
7009c84e: 9b08         	ldr	r3, [sp, #0x20]
;                 (void) CSL_bcdmaGetChanPeerReg(
7009c850: 46ec         	mov	r12, sp
7009c852: aa16         	add	r2, sp, #0x58
7009c854: f8cc 2000    	str.w	r2, [r12]
7009c858: 2200         	movs	r2, #0x0
7009c85a: f011 f879    	bl	0x700ad950 <CSL_bcdmaGetChanPeerReg> @ imm = #0x110f2
;                 if((FALSE == bcdmaRtStatus.enable) &&
7009c85e: 980e         	ldr	r0, [sp, #0x38]
7009c860: b938         	cbnz	r0, 0x7009c872 <Udma_chDisableTxChan+0x242> @ imm = #0xe
7009c862: e7ff         	b	0x7009c864 <Udma_chDisableTxChan+0x234> @ imm = #-0x2
;                 (CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE) == FALSE))
7009c864: 9916         	ldr	r1, [sp, #0x58]
7009c866: 2000         	movs	r0, #0x0
;                 if((FALSE == bcdmaRtStatus.enable) &&
7009c868: ebb0 7fd1    	cmp.w	r0, r1, lsr #31
7009c86c: d101         	bne	0x7009c872 <Udma_chDisableTxChan+0x242> @ imm = #0x2
7009c86e: e7ff         	b	0x7009c870 <Udma_chDisableTxChan+0x240> @ imm = #-0x2
;                     break;
7009c870: e036         	b	0x7009c8e0 <Udma_chDisableTxChan+0x2b0> @ imm = #0x6c
;             }
7009c872: e023         	b	0x7009c8bc <Udma_chDisableTxChan+0x28c> @ imm = #0x46
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c874: 9814         	ldr	r0, [sp, #0x50]
7009c876: 6800         	ldr	r0, [r0]
7009c878: 2802         	cmp	r0, #0x2
7009c87a: d11e         	bne	0x7009c8ba <Udma_chDisableTxChan+0x28a> @ imm = #0x3c
7009c87c: e7ff         	b	0x7009c87e <Udma_chDisableTxChan+0x24e> @ imm = #-0x2
;                 (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009c87e: 9814         	ldr	r0, [sp, #0x50]
7009c880: 3054         	adds	r0, #0x54
7009c882: 9919         	ldr	r1, [sp, #0x64]
7009c884: 6ec9         	ldr	r1, [r1, #0x6c]
7009c886: aa09         	add	r2, sp, #0x24
7009c888: f010 fdea    	bl	0x700ad460 <CSL_pktdmaGetTxRT> @ imm = #0x10bd4
;                     &drvHandle->pktdmaRegs,
7009c88c: 9814         	ldr	r0, [sp, #0x50]
7009c88e: 3054         	adds	r0, #0x54
;                     chHandle->txChNum,
7009c890: 9919         	ldr	r1, [sp, #0x64]
7009c892: 6ec9         	ldr	r1, [r1, #0x6c]
;                     rtEnableRegOffset, &peerRtEnable);
7009c894: 9b08         	ldr	r3, [sp, #0x20]
;                 (void) CSL_pktdmaGetChanPeerReg(
7009c896: 46ec         	mov	r12, sp
7009c898: aa16         	add	r2, sp, #0x58
7009c89a: f8cc 2000    	str.w	r2, [r12]
7009c89e: 2200         	movs	r2, #0x0
7009c8a0: f011 ffae    	bl	0x700ae800 <CSL_pktdmaGetChanPeerReg> @ imm = #0x11f5c
;                 if((FALSE == pktdmaRtStatus.enable) &&
7009c8a4: 9809         	ldr	r0, [sp, #0x24]
7009c8a6: b938         	cbnz	r0, 0x7009c8b8 <Udma_chDisableTxChan+0x288> @ imm = #0xe
7009c8a8: e7ff         	b	0x7009c8aa <Udma_chDisableTxChan+0x27a> @ imm = #-0x2
;                 (CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE) == FALSE))
7009c8aa: 9916         	ldr	r1, [sp, #0x58]
7009c8ac: 2000         	movs	r0, #0x0
;                 if((FALSE == pktdmaRtStatus.enable) &&
7009c8ae: ebb0 7fd1    	cmp.w	r0, r1, lsr #31
7009c8b2: d101         	bne	0x7009c8b8 <Udma_chDisableTxChan+0x288> @ imm = #0x2
7009c8b4: e7ff         	b	0x7009c8b6 <Udma_chDisableTxChan+0x286> @ imm = #-0x2
;                     break;
7009c8b6: e013         	b	0x7009c8e0 <Udma_chDisableTxChan+0x2b0> @ imm = #0x26
;             }
7009c8b8: e7ff         	b	0x7009c8ba <Udma_chDisableTxChan+0x28a> @ imm = #-0x2
7009c8ba: e7ff         	b	0x7009c8bc <Udma_chDisableTxChan+0x28c> @ imm = #-0x2
;             if(currTimeout > timeout)
7009c8bc: 9815         	ldr	r0, [sp, #0x54]
7009c8be: 9918         	ldr	r1, [sp, #0x60]
7009c8c0: 4288         	cmp	r0, r1
7009c8c2: d904         	bls	0x7009c8ce <Udma_chDisableTxChan+0x29e> @ imm = #0x8
7009c8c4: e7ff         	b	0x7009c8c6 <Udma_chDisableTxChan+0x296> @ imm = #-0x2
7009c8c6: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009c8ca: 9017         	str	r0, [sp, #0x5c]
;             }
7009c8cc: e007         	b	0x7009c8de <Udma_chDisableTxChan+0x2ae> @ imm = #0xe
7009c8ce: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009c8d2: f00e fc5d    	bl	0x700ab190 <ClockP_usleep> @ imm = #0xe8ba
;                 currTimeout++;
7009c8d6: 9815         	ldr	r0, [sp, #0x54]
7009c8d8: 3001         	adds	r0, #0x1
7009c8da: 9015         	str	r0, [sp, #0x54]
7009c8dc: e7ff         	b	0x7009c8de <Udma_chDisableTxChan+0x2ae> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009c8de: e79a         	b	0x7009c816 <Udma_chDisableTxChan+0x1e6> @ imm = #-0xcc
;     }
7009c8e0: e7ff         	b	0x7009c8e2 <Udma_chDisableTxChan+0x2b2> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c8e2: 9817         	ldr	r0, [sp, #0x5c]
7009c8e4: 2800         	cmp	r0, #0x0
7009c8e6: d150         	bne	0x7009c98a <Udma_chDisableTxChan+0x35a> @ imm = #0xa0
7009c8e8: e7ff         	b	0x7009c8ea <Udma_chDisableTxChan+0x2ba> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c8ea: 9814         	ldr	r0, [sp, #0x50]
7009c8ec: 6800         	ldr	r0, [r0]
7009c8ee: 2801         	cmp	r0, #0x1
7009c8f0: d126         	bne	0x7009c940 <Udma_chDisableTxChan+0x310> @ imm = #0x4c
7009c8f2: e7ff         	b	0x7009c8f4 <Udma_chDisableTxChan+0x2c4> @ imm = #-0x2
7009c8f4: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.enable   = FALSE;
7009c8f6: 9003         	str	r0, [sp, #0xc]
7009c8f8: 900e         	str	r0, [sp, #0x38]
;             bcdmaRtStatus.teardown = FALSE;
7009c8fa: 900f         	str	r0, [sp, #0x3c]
;             bcdmaRtStatus.forcedTeardown = FALSE;
7009c8fc: 9012         	str	r0, [sp, #0x48]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 0U);
7009c8fe: 9816         	ldr	r0, [sp, #0x58]
7009c900: f020 4080    	bic	r0, r0, #0x40000000
7009c904: 9016         	str	r0, [sp, #0x58]
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009c906: 9a14         	ldr	r2, [sp, #0x50]
7009c908: f102 0008    	add.w	r0, r2, #0x8
7009c90c: 9919         	ldr	r1, [sp, #0x64]
7009c90e: 6ec9         	ldr	r1, [r1, #0x6c]
7009c910: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c914: 4411         	add	r1, r2
7009c916: aa0e         	add	r2, sp, #0x38
7009c918: f012 f922    	bl	0x700aeb60 <CSL_bcdmaSetTxRT> @ imm = #0x12244
7009c91c: 9a03         	ldr	r2, [sp, #0xc]
;                 &drvHandle->bcdmaRegs,
7009c91e: 9b14         	ldr	r3, [sp, #0x50]
7009c920: f103 0008    	add.w	r0, r3, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009c924: 9919         	ldr	r1, [sp, #0x64]
7009c926: 6ec9         	ldr	r1, [r1, #0x6c]
7009c928: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
7009c92c: 4419         	add	r1, r3
;                 rtEnableRegOffset,
7009c92e: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaSetChanPeerReg(
7009c930: 46ee         	mov	lr, sp
7009c932: f10d 0c58    	add.w	r12, sp, #0x58
7009c936: f8ce c000    	str.w	r12, [lr]
7009c93a: f011 fae9    	bl	0x700adf10 <CSL_bcdmaSetChanPeerReg> @ imm = #0x115d2
;         }
7009c93e: e023         	b	0x7009c988 <Udma_chDisableTxChan+0x358> @ imm = #0x46
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c940: 9814         	ldr	r0, [sp, #0x50]
7009c942: 6800         	ldr	r0, [r0]
7009c944: 2802         	cmp	r0, #0x2
7009c946: d11e         	bne	0x7009c986 <Udma_chDisableTxChan+0x356> @ imm = #0x3c
7009c948: e7ff         	b	0x7009c94a <Udma_chDisableTxChan+0x31a> @ imm = #-0x2
7009c94a: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.enable   = FALSE;
7009c94c: 9002         	str	r0, [sp, #0x8]
7009c94e: 9009         	str	r0, [sp, #0x24]
;             pktdmaRtStatus.teardown = FALSE;
7009c950: 900a         	str	r0, [sp, #0x28]
;             pktdmaRtStatus.forcedTeardown = FALSE;
7009c952: 900d         	str	r0, [sp, #0x34]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 0U);
7009c954: 9816         	ldr	r0, [sp, #0x58]
7009c956: f020 4080    	bic	r0, r0, #0x40000000
7009c95a: 9016         	str	r0, [sp, #0x58]
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009c95c: 9814         	ldr	r0, [sp, #0x50]
7009c95e: 3054         	adds	r0, #0x54
7009c960: 9919         	ldr	r1, [sp, #0x64]
7009c962: 6ec9         	ldr	r1, [r1, #0x6c]
7009c964: aa09         	add	r2, sp, #0x24
7009c966: f011 fb33    	bl	0x700adfd0 <CSL_pktdmaSetTxRT> @ imm = #0x11666
7009c96a: 9a02         	ldr	r2, [sp, #0x8]
;                 &drvHandle->pktdmaRegs,
7009c96c: 9814         	ldr	r0, [sp, #0x50]
7009c96e: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009c970: 9919         	ldr	r1, [sp, #0x64]
7009c972: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009c974: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaSetChanPeerReg(
7009c976: 46ee         	mov	lr, sp
7009c978: f10d 0c58    	add.w	r12, sp, #0x58
7009c97c: f8ce c000    	str.w	r12, [lr]
7009c980: f011 ff56    	bl	0x700ae830 <CSL_pktdmaSetChanPeerReg> @ imm = #0x11eac
;         }
7009c984: e7ff         	b	0x7009c986 <Udma_chDisableTxChan+0x356> @ imm = #-0x2
7009c986: e7ff         	b	0x7009c988 <Udma_chDisableTxChan+0x358> @ imm = #-0x2
;     }
7009c988: e7ff         	b	0x7009c98a <Udma_chDisableTxChan+0x35a> @ imm = #-0x2
;     return (retVal);
7009c98a: 9817         	ldr	r0, [sp, #0x5c]
7009c98c: b01a         	add	sp, #0x68
7009c98e: bd80         	pop	{r7, pc}

7009c990 <Udma_eventConfig>:
; {
7009c990: b580         	push	{r7, lr}
7009c992: b098         	sub	sp, #0x60
7009c994: 9017         	str	r0, [sp, #0x5c]
7009c996: 9116         	str	r1, [sp, #0x58]
7009c998: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009c99a: 9001         	str	r0, [sp, #0x4]
7009c99c: 9015         	str	r0, [sp, #0x54]
;     eventPrms = &eventHandle->eventPrms;
7009c99e: 9916         	ldr	r1, [sp, #0x58]
7009c9a0: 3108         	adds	r1, #0x8
7009c9a2: 9110         	str	r1, [sp, #0x40]
;     rmIrqReq.valid_params           = 0U;
7009c9a4: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.global_event           = 0U;
7009c9a6: f8ad 0028    	strh.w	r0, [sp, #0x28]
;     rmIrqReq.src_id                 = 0U;
7009c9aa: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.src_index              = 0U;
7009c9ae: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     rmIrqReq.dst_id                 = 0U;
7009c9b2: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     rmIrqReq.dst_host_irq           = 0U;
7009c9b6: f8ad 0022    	strh.w	r0, [sp, #0x22]
;     rmIrqReq.ia_id                  = 0U;
7009c9ba: f8ad 0024    	strh.w	r0, [sp, #0x24]
;     rmIrqReq.vint                   = 0U;
7009c9be: f8ad 0026    	strh.w	r0, [sp, #0x26]
;     rmIrqReq.vint_status_bit_index  = 0U;
7009c9c2: f88d 002a    	strb.w	r0, [sp, #0x2a]
7009c9c6: 20ff         	movs	r0, #0xff
;     rmIrqReq.secondary_host         = TISCI_MSG_VALUE_RM_UNUSED_SECONDARY_HOST;
7009c9c8: f88d 002b    	strb.w	r0, [sp, #0x2b]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009c9cc: 9810         	ldr	r0, [sp, #0x40]
7009c9ce: 6800         	ldr	r0, [r0]
7009c9d0: 2805         	cmp	r0, #0x5
7009c9d2: d00a         	beq	0x7009c9ea <Udma_eventConfig+0x5a> @ imm = #0x14
7009c9d4: e7ff         	b	0x7009c9d6 <Udma_eventConfig+0x46> @ imm = #-0x2
;         rmIrqReq.valid_params  |= TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID;
7009c9d6: 9806         	ldr	r0, [sp, #0x18]
7009c9d8: f040 0010    	orr	r0, r0, #0x10
7009c9dc: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.global_event   = (uint16_t)Udma_eventGetId(eventHandle);
7009c9de: 9816         	ldr	r0, [sp, #0x58]
7009c9e0: f010 fcee    	bl	0x700ad3c0 <Udma_eventGetId> @ imm = #0x109dc
7009c9e4: f8ad 0028    	strh.w	r0, [sp, #0x28]
;     }
7009c9e8: e7ff         	b	0x7009c9ea <Udma_eventConfig+0x5a> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009c9ea: 9816         	ldr	r0, [sp, #0x58]
7009c9ec: 6d80         	ldr	r0, [r0, #0x58]
7009c9ee: f510 3f80    	cmn.w	r0, #0x10000
7009c9f2: d012         	beq	0x7009ca1a <Udma_eventConfig+0x8a> @ imm = #0x24
7009c9f4: e7ff         	b	0x7009c9f6 <Udma_eventConfig+0x66> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_ID_VALID;
7009c9f6: 9806         	ldr	r0, [sp, #0x18]
7009c9f8: f040 0001    	orr	r0, r0, #0x1
7009c9fc: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID;
7009c9fe: 9806         	ldr	r0, [sp, #0x18]
7009ca00: f040 0002    	orr	r0, r0, #0x2
7009ca04: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.dst_id        = drvHandle->devIdCore;
7009ca06: 9817         	ldr	r0, [sp, #0x5c]
7009ca08: f8b0 00ea    	ldrh.w	r0, [r0, #0xea]
7009ca0c: f8ad 0020    	strh.w	r0, [sp, #0x20]
;         rmIrqReq.dst_host_irq  = (uint16_t)eventHandle->coreIntrNum;
7009ca10: 9816         	ldr	r0, [sp, #0x58]
7009ca12: 6d80         	ldr	r0, [r0, #0x58]
7009ca14: f8ad 0022    	strh.w	r0, [sp, #0x22]
;     }
7009ca18: e7ff         	b	0x7009ca1a <Udma_eventConfig+0x8a> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->eventPrms.controllerEventHandle)
7009ca1a: 9816         	ldr	r0, [sp, #0x58]
7009ca1c: 6980         	ldr	r0, [r0, #0x18]
7009ca1e: b128         	cbz	r0, 0x7009ca2c <Udma_eventConfig+0x9c> @ imm = #0xa
7009ca20: e7ff         	b	0x7009ca22 <Udma_eventConfig+0x92> @ imm = #-0x2
;         vintrNum = ((Udma_EventHandleInt) (eventHandle->eventPrms.controllerEventHandle))->vintrNum;
7009ca22: 9816         	ldr	r0, [sp, #0x58]
7009ca24: 6980         	ldr	r0, [r0, #0x18]
7009ca26: 6cc0         	ldr	r0, [r0, #0x4c]
7009ca28: 9014         	str	r0, [sp, #0x50]
;     }
7009ca2a: e003         	b	0x7009ca34 <Udma_eventConfig+0xa4> @ imm = #0x6
;         vintrNum = eventHandle->vintrNum;
7009ca2c: 9816         	ldr	r0, [sp, #0x58]
7009ca2e: 6cc0         	ldr	r0, [r0, #0x4c]
7009ca30: 9014         	str	r0, [sp, #0x50]
7009ca32: e7ff         	b	0x7009ca34 <Udma_eventConfig+0xa4> @ imm = #-0x2
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_IA_ID_VALID;
7009ca34: 9806         	ldr	r0, [sp, #0x18]
7009ca36: f040 0004    	orr	r0, r0, #0x4
7009ca3a: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_VALID;
7009ca3c: 9806         	ldr	r0, [sp, #0x18]
7009ca3e: f040 0008    	orr	r0, r0, #0x8
7009ca42: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.ia_id         = drvHandle->devIdIa;
7009ca44: 9817         	ldr	r0, [sp, #0x5c]
7009ca46: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009ca4a: f8ad 0024    	strh.w	r0, [sp, #0x24]
;     rmIrqReq.vint          = (uint16_t)vintrNum;
7009ca4e: 9814         	ldr	r0, [sp, #0x50]
7009ca50: f8ad 0026    	strh.w	r0, [sp, #0x26]
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
7009ca54: 9816         	ldr	r0, [sp, #0x58]
7009ca56: 6d00         	ldr	r0, [r0, #0x50]
7009ca58: f64f 71ff    	movw	r1, #0xffff
7009ca5c: 4288         	cmp	r0, r1
7009ca5e: d009         	beq	0x7009ca74 <Udma_eventConfig+0xe4> @ imm = #0x12
7009ca60: e7ff         	b	0x7009ca62 <Udma_eventConfig+0xd2> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_STATUS_BIT_INDEX_VALID;
7009ca62: 9806         	ldr	r0, [sp, #0x18]
7009ca64: f040 0020    	orr	r0, r0, #0x20
7009ca68: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.vint_status_bit_index  = (uint8_t)eventHandle->vintrBitNum;
7009ca6a: 9816         	ldr	r0, [sp, #0x58]
7009ca6c: 6d00         	ldr	r0, [r0, #0x50]
7009ca6e: f88d 002a    	strb.w	r0, [sp, #0x2a]
;     }
7009ca72: e7ff         	b	0x7009ca74 <Udma_eventConfig+0xe4> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009ca74: 9810         	ldr	r0, [sp, #0x40]
7009ca76: 6800         	ldr	r0, [r0]
7009ca78: 2801         	cmp	r0, #0x1
7009ca7a: d00a         	beq	0x7009ca92 <Udma_eventConfig+0x102> @ imm = #0x14
7009ca7c: e7ff         	b	0x7009ca7e <Udma_eventConfig+0xee> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType) ||
7009ca7e: 9810         	ldr	r0, [sp, #0x40]
7009ca80: 6800         	ldr	r0, [r0]
7009ca82: 2802         	cmp	r0, #0x2
7009ca84: d005         	beq	0x7009ca92 <Udma_eventConfig+0x102> @ imm = #0xa
7009ca86: e7ff         	b	0x7009ca88 <Udma_eventConfig+0xf8> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009ca88: 9810         	ldr	r0, [sp, #0x40]
7009ca8a: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009ca8c: 2806         	cmp	r0, #0x6
7009ca8e: d14d         	bne	0x7009cb2c <Udma_eventConfig+0x19c> @ imm = #0x9a
7009ca90: e7ff         	b	0x7009ca92 <Udma_eventConfig+0x102> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009ca92: 9810         	ldr	r0, [sp, #0x40]
7009ca94: 6880         	ldr	r0, [r0, #0x8]
7009ca96: 9012         	str	r0, [sp, #0x48]
;         rmIrqReq.src_id = drvHandle->srcIdRingIrq;
7009ca98: 9817         	ldr	r0, [sp, #0x5c]
7009ca9a: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009ca9e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009caa2: 9810         	ldr	r0, [sp, #0x40]
7009caa4: 6800         	ldr	r0, [r0]
7009caa6: 2801         	cmp	r0, #0x1
7009caa8: d005         	beq	0x7009cab6 <Udma_eventConfig+0x126> @ imm = #0xa
7009caaa: e7ff         	b	0x7009caac <Udma_eventConfig+0x11c> @ imm = #-0x2
7009caac: 9810         	ldr	r0, [sp, #0x40]
7009caae: 6800         	ldr	r0, [r0]
7009cab0: 2806         	cmp	r0, #0x6
7009cab2: d12e         	bne	0x7009cb12 <Udma_eventConfig+0x182> @ imm = #0x5c
7009cab4: e7ff         	b	0x7009cab6 <Udma_eventConfig+0x126> @ imm = #-0x2
;             rmIrqReq.src_index = chHandle->cqRing->ringNum;
7009cab6: 9812         	ldr	r0, [sp, #0x48]
7009cab8: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009cabc: 8880         	ldrh	r0, [r0, #0x4]
7009cabe: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009cac2: 9812         	ldr	r0, [sp, #0x48]
7009cac4: 7800         	ldrb	r0, [r0]
7009cac6: 0740         	lsls	r0, r0, #0x1d
7009cac8: 2800         	cmp	r0, #0x0
7009caca: d509         	bpl	0x7009cae0 <Udma_eventConfig+0x150> @ imm = #0x12
7009cacc: e7ff         	b	0x7009cace <Udma_eventConfig+0x13e> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->blkCopyRingIrqOffset;
7009cace: 9817         	ldr	r0, [sp, #0x5c]
7009cad0: f8d0 10f0    	ldr.w	r1, [r0, #0xf0]
7009cad4: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cad8: 4408         	add	r0, r1
7009cada: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009cade: e017         	b	0x7009cb10 <Udma_eventConfig+0x180> @ imm = #0x2e
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009cae0: 9812         	ldr	r0, [sp, #0x48]
7009cae2: 7800         	ldrb	r0, [r0]
7009cae4: 07c0         	lsls	r0, r0, #0x1f
7009cae6: b148         	cbz	r0, 0x7009cafc <Udma_eventConfig+0x16c> @ imm = #0x12
7009cae8: e7ff         	b	0x7009caea <Udma_eventConfig+0x15a> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009caea: 9817         	ldr	r0, [sp, #0x5c]
7009caec: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009caf0: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009caf4: 4408         	add	r0, r1
7009caf6: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009cafa: e008         	b	0x7009cb0e <Udma_eventConfig+0x17e> @ imm = #0x10
;                 rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009cafc: 9817         	ldr	r0, [sp, #0x5c]
7009cafe: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009cb02: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cb06: 4408         	add	r0, r1
7009cb08: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009cb0c: e7ff         	b	0x7009cb0e <Udma_eventConfig+0x17e> @ imm = #-0x2
7009cb0e: e7ff         	b	0x7009cb10 <Udma_eventConfig+0x180> @ imm = #-0x2
;         }
7009cb10: e00b         	b	0x7009cb2a <Udma_eventConfig+0x19a> @ imm = #0x16
;             rmIrqReq.src_index = chHandle->tdCqRing->ringNum;
7009cb12: 9812         	ldr	r0, [sp, #0x48]
7009cb14: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009cb18: 8880         	ldrh	r0, [r0, #0x4]
7009cb1a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             rmIrqReq.src_index += TISCI_RINGACC0_OES_IRQ_SRC_IDX_START;
7009cb1e: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cb22: 3014         	adds	r0, #0x14
7009cb24: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009cb28: e7ff         	b	0x7009cb2a <Udma_eventConfig+0x19a> @ imm = #-0x2
;     }
7009cb2a: e7ff         	b	0x7009cb2c <Udma_eventConfig+0x19c> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009cb2c: 9810         	ldr	r0, [sp, #0x40]
7009cb2e: 6800         	ldr	r0, [r0]
7009cb30: 2803         	cmp	r0, #0x3
7009cb32: d156         	bne	0x7009cbe2 <Udma_eventConfig+0x252> @ imm = #0xac
7009cb34: e7ff         	b	0x7009cb36 <Udma_eventConfig+0x1a6> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009cb36: 9817         	ldr	r0, [sp, #0x5c]
7009cb38: 6800         	ldr	r0, [r0]
7009cb3a: 2802         	cmp	r0, #0x2
7009cb3c: d104         	bne	0x7009cb48 <Udma_eventConfig+0x1b8> @ imm = #0x8
7009cb3e: e7ff         	b	0x7009cb40 <Udma_eventConfig+0x1b0> @ imm = #-0x2
7009cb40: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009cb44: 9015         	str	r0, [sp, #0x54]
;         }
7009cb46: e04b         	b	0x7009cbe0 <Udma_eventConfig+0x250> @ imm = #0x96
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009cb48: 9810         	ldr	r0, [sp, #0x40]
7009cb4a: 6880         	ldr	r0, [r0, #0x8]
7009cb4c: 9012         	str	r0, [sp, #0x48]
;             rmIrqReq.src_id = drvHandle->srcIdTrIrq;
7009cb4e: 9817         	ldr	r0, [sp, #0x5c]
7009cb50: f8b0 00fc    	ldrh.w	r0, [r0, #0xfc]
7009cb54: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009cb58: 9812         	ldr	r0, [sp, #0x48]
7009cb5a: 7800         	ldrb	r0, [r0]
7009cb5c: 0740         	lsls	r0, r0, #0x1d
7009cb5e: 2800         	cmp	r0, #0x0
7009cb60: d50d         	bpl	0x7009cb7e <Udma_eventConfig+0x1ee> @ imm = #0x1a
7009cb62: e7ff         	b	0x7009cb64 <Udma_eventConfig+0x1d4> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009cb64: 9812         	ldr	r0, [sp, #0x48]
7009cb66: 6ec0         	ldr	r0, [r0, #0x6c]
7009cb68: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->blkCopyTrIrqOffset;
7009cb6c: 9817         	ldr	r0, [sp, #0x5c]
7009cb6e: f8d0 1100    	ldr.w	r1, [r0, #0x100]
7009cb72: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cb76: 4408         	add	r0, r1
7009cb78: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009cb7c: e02f         	b	0x7009cbde <Udma_eventConfig+0x24e> @ imm = #0x5e
;             else if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009cb7e: 9812         	ldr	r0, [sp, #0x48]
7009cb80: 7800         	ldrb	r0, [r0]
7009cb82: 0780         	lsls	r0, r0, #0x1e
7009cb84: 2800         	cmp	r0, #0x0
7009cb86: d50d         	bpl	0x7009cba4 <Udma_eventConfig+0x214> @ imm = #0x1a
7009cb88: e7ff         	b	0x7009cb8a <Udma_eventConfig+0x1fa> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->rxChNum;
7009cb8a: 9812         	ldr	r0, [sp, #0x48]
7009cb8c: 6f00         	ldr	r0, [r0, #0x70]
7009cb8e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->rxTrIrqOffset;
7009cb92: 9817         	ldr	r0, [sp, #0x5c]
7009cb94: f8d0 1108    	ldr.w	r1, [r0, #0x108]
7009cb98: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cb9c: 4408         	add	r0, r1
7009cb9e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009cba2: e01b         	b	0x7009cbdc <Udma_eventConfig+0x24c> @ imm = #0x36
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009cba4: 9812         	ldr	r0, [sp, #0x48]
7009cba6: 7800         	ldrb	r0, [r0]
7009cba8: 07c0         	lsls	r0, r0, #0x1f
7009cbaa: b168         	cbz	r0, 0x7009cbc8 <Udma_eventConfig+0x238> @ imm = #0x1a
7009cbac: e7ff         	b	0x7009cbae <Udma_eventConfig+0x21e> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009cbae: 9812         	ldr	r0, [sp, #0x48]
7009cbb0: 6ec0         	ldr	r0, [r0, #0x6c]
7009cbb2: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->txTrIrqOffset;
7009cbb6: 9817         	ldr	r0, [sp, #0x5c]
7009cbb8: f8d0 1104    	ldr.w	r1, [r0, #0x104]
7009cbbc: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cbc0: 4408         	add	r0, r1
7009cbc2: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009cbc6: e008         	b	0x7009cbda <Udma_eventConfig+0x24a> @ imm = #0x10
;                 rmIrqReq.src_id = drvHandle->devIdIa;
7009cbc8: 9817         	ldr	r0, [sp, #0x5c]
7009cbca: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009cbce: f8ad 001c    	strh.w	r0, [sp, #0x1c]
7009cbd2: 2000         	movs	r0, #0x0
;                 rmIrqReq.src_index = 0U;                /* Not used by DMSC RM */
7009cbd4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009cbd8: e7ff         	b	0x7009cbda <Udma_eventConfig+0x24a> @ imm = #-0x2
7009cbda: e7ff         	b	0x7009cbdc <Udma_eventConfig+0x24c> @ imm = #-0x2
7009cbdc: e7ff         	b	0x7009cbde <Udma_eventConfig+0x24e> @ imm = #-0x2
7009cbde: e7ff         	b	0x7009cbe0 <Udma_eventConfig+0x250> @ imm = #-0x2
;     }
7009cbe0: e7ff         	b	0x7009cbe2 <Udma_eventConfig+0x252> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
7009cbe2: 9810         	ldr	r0, [sp, #0x40]
7009cbe4: 6800         	ldr	r0, [r0]
7009cbe6: 2804         	cmp	r0, #0x4
7009cbe8: d130         	bne	0x7009cc4c <Udma_eventConfig+0x2bc> @ imm = #0x60
7009cbea: e7ff         	b	0x7009cbec <Udma_eventConfig+0x25c> @ imm = #-0x2
;         ringHandle = (Udma_RingHandleInt) eventPrms->ringHandle;
7009cbec: 9810         	ldr	r0, [sp, #0x40]
7009cbee: 68c0         	ldr	r0, [r0, #0xc]
7009cbf0: 9011         	str	r0, [sp, #0x44]
;         rmIrqReq.src_id     = drvHandle->srcIdRingIrq;
7009cbf2: 9817         	ldr	r0, [sp, #0x5c]
7009cbf4: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009cbf8: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         rmIrqReq.src_index  = ringHandle->ringNum;
7009cbfc: 9811         	ldr	r0, [sp, #0x44]
7009cbfe: 8880         	ldrh	r0, [r0, #0x4]
7009cc00: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009cc04: 9817         	ldr	r0, [sp, #0x5c]
7009cc06: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009cc0a: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cc0e: 4408         	add	r0, r1
7009cc10: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009cc14: 9811         	ldr	r0, [sp, #0x44]
7009cc16: 6dc0         	ldr	r0, [r0, #0x5c]
7009cc18: 2804         	cmp	r0, #0x4
7009cc1a: d316         	blo	0x7009cc4a <Udma_eventConfig+0x2ba> @ imm = #0x2c
7009cc1c: e7ff         	b	0x7009cc1e <Udma_eventConfig+0x28e> @ imm = #-0x2
;            (ringHandle->mappedRingGrp < (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
7009cc1e: 9811         	ldr	r0, [sp, #0x44]
7009cc20: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009cc22: 2807         	cmp	r0, #0x7
7009cc24: d811         	bhi	0x7009cc4a <Udma_eventConfig+0x2ba> @ imm = #0x22
7009cc26: e7ff         	b	0x7009cc28 <Udma_eventConfig+0x298> @ imm = #-0x2
;             rmIrqReq.src_index -= drvHandle->txRingIrqOffset;
7009cc28: 9817         	ldr	r0, [sp, #0x5c]
7009cc2a: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009cc2e: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cc32: 1a40         	subs	r0, r0, r1
7009cc34: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009cc38: 9817         	ldr	r0, [sp, #0x5c]
7009cc3a: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009cc3e: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cc42: 4408         	add	r0, r1
7009cc44: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         }
7009cc48: e7ff         	b	0x7009cc4a <Udma_eventConfig+0x2ba> @ imm = #-0x2
;     }
7009cc4a: e7ff         	b	0x7009cc4c <Udma_eventConfig+0x2bc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009cc4c: 9815         	ldr	r0, [sp, #0x54]
7009cc4e: b9d8         	cbnz	r0, 0x7009cc88 <Udma_eventConfig+0x2f8> @ imm = #0x36
7009cc50: e7ff         	b	0x7009cc52 <Udma_eventConfig+0x2c2> @ imm = #-0x2
;         Udma_eventProgramSteering(drvHandle, eventHandle);
7009cc52: 9817         	ldr	r0, [sp, #0x5c]
7009cc54: 9916         	ldr	r1, [sp, #0x58]
7009cc56: f012 f903    	bl	0x700aee60 <Udma_eventProgramSteering> @ imm = #0x12206
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009cc5a: 9817         	ldr	r0, [sp, #0x5c]
7009cc5c: 6800         	ldr	r0, [r0]
7009cc5e: b130         	cbz	r0, 0x7009cc6e <Udma_eventConfig+0x2de> @ imm = #0xc
7009cc60: e7ff         	b	0x7009cc62 <Udma_eventConfig+0x2d2> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009cc62: 9810         	ldr	r0, [sp, #0x40]
7009cc64: 6800         	ldr	r0, [r0]
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009cc66: 2805         	cmp	r0, #0x5
7009cc68: d101         	bne	0x7009cc6e <Udma_eventConfig+0x2de> @ imm = #0x2
7009cc6a: e7ff         	b	0x7009cc6c <Udma_eventConfig+0x2dc> @ imm = #-0x2
;         }
7009cc6c: e00b         	b	0x7009cc86 <Udma_eventConfig+0x2f6> @ imm = #0x16
7009cc6e: a804         	add	r0, sp, #0x10
7009cc70: a902         	add	r1, sp, #0x8
7009cc72: f04f 32ff    	mov.w	r2, #0xffffffff
;             retVal = Sciclient_rmIrqSet(
7009cc76: f012 fd1b    	bl	0x700af6b0 <Sciclient_rmIrqSet> @ imm = #0x12a36
7009cc7a: 9015         	str	r0, [sp, #0x54]
;             if(CSL_PASS != retVal)
7009cc7c: 9815         	ldr	r0, [sp, #0x54]
7009cc7e: b108         	cbz	r0, 0x7009cc84 <Udma_eventConfig+0x2f4> @ imm = #0x2
7009cc80: e7ff         	b	0x7009cc82 <Udma_eventConfig+0x2f2> @ imm = #-0x2
;             }
7009cc82: e7ff         	b	0x7009cc84 <Udma_eventConfig+0x2f4> @ imm = #-0x2
7009cc84: e7ff         	b	0x7009cc86 <Udma_eventConfig+0x2f6> @ imm = #-0x2
;     }
7009cc86: e7ff         	b	0x7009cc88 <Udma_eventConfig+0x2f8> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009cc88: 9815         	ldr	r0, [sp, #0x54]
7009cc8a: bb58         	cbnz	r0, 0x7009cce4 <Udma_eventConfig+0x354> @ imm = #0x56
7009cc8c: e7ff         	b	0x7009cc8e <Udma_eventConfig+0x2fe> @ imm = #-0x2
;         if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009cc8e: 9816         	ldr	r0, [sp, #0x58]
7009cc90: 6d80         	ldr	r0, [r0, #0x58]
7009cc92: f510 3f80    	cmn.w	r0, #0x10000
7009cc96: d024         	beq	0x7009cce2 <Udma_eventConfig+0x352> @ imm = #0x48
7009cc98: e7ff         	b	0x7009cc9a <Udma_eventConfig+0x30a> @ imm = #-0x2
;             coreIntrNum = eventHandle->coreIntrNum;
7009cc9a: 9816         	ldr	r0, [sp, #0x58]
7009cc9c: 6d80         	ldr	r0, [r0, #0x58]
7009cc9e: 9013         	str	r0, [sp, #0x4c]
7009cca0: a80b         	add	r0, sp, #0x2c
;             HwiP_Params_init(&hwiPrms);
7009cca2: 9000         	str	r0, [sp]
7009cca4: f013 f954    	bl	0x700aff50 <HwiP_Params_init> @ imm = #0x132a8
7009cca8: 9900         	ldr	r1, [sp]
;             hwiPrms.intNum = coreIntrNum;
7009ccaa: 9813         	ldr	r0, [sp, #0x4c]
7009ccac: 900b         	str	r0, [sp, #0x2c]
;             hwiPrms.callback = &Udma_eventIsrFxn;
7009ccae: f645 2041    	movw	r0, #0x5a41
7009ccb2: f2c7 000a    	movt	r0, #0x700a
7009ccb6: 900c         	str	r0, [sp, #0x30]
;             hwiPrms.args = eventHandle;
7009ccb8: 9816         	ldr	r0, [sp, #0x58]
7009ccba: 900d         	str	r0, [sp, #0x34]
;             hwiPrms.priority = eventHandle->eventPrms.intrPriority;
7009ccbc: 9816         	ldr	r0, [sp, #0x58]
7009ccbe: 6a00         	ldr	r0, [r0, #0x20]
7009ccc0: f88d 003a    	strb.w	r0, [sp, #0x3a]
;             retVal = HwiP_construct(&eventHandle->hwiObject, &hwiPrms);
7009ccc4: 9816         	ldr	r0, [sp, #0x58]
7009ccc6: 3068         	adds	r0, #0x68
7009ccc8: f013 f95a    	bl	0x700aff80 <HwiP_construct> @ imm = #0x132b4
7009cccc: 9015         	str	r0, [sp, #0x54]
;             if(SystemP_SUCCESS != retVal)
7009ccce: 9815         	ldr	r0, [sp, #0x54]
7009ccd0: b108         	cbz	r0, 0x7009ccd6 <Udma_eventConfig+0x346> @ imm = #0x2
7009ccd2: e7ff         	b	0x7009ccd4 <Udma_eventConfig+0x344> @ imm = #-0x2
;             }
7009ccd4: e004         	b	0x7009cce0 <Udma_eventConfig+0x350> @ imm = #0x8
;                 eventHandle->hwiHandle = &eventHandle->hwiObject;
7009ccd6: 9916         	ldr	r1, [sp, #0x58]
7009ccd8: f101 0068    	add.w	r0, r1, #0x68
7009ccdc: 6648         	str	r0, [r1, #0x64]
7009ccde: e7ff         	b	0x7009cce0 <Udma_eventConfig+0x350> @ imm = #-0x2
;         }
7009cce0: e7ff         	b	0x7009cce2 <Udma_eventConfig+0x352> @ imm = #-0x2
;     }
7009cce2: e7ff         	b	0x7009cce4 <Udma_eventConfig+0x354> @ imm = #-0x2
;     return (retVal);
7009cce4: 9815         	ldr	r0, [sp, #0x54]
7009cce6: b018         	add	sp, #0x60
7009cce8: bd80         	pop	{r7, pc}
7009ccea: 0000         	movs	r0, r0
7009ccec: 0000         	movs	r0, r0
7009ccee: 0000         	movs	r0, r0

7009ccf0 <Sciclient_rmIrqGetRoute>:
; {
7009ccf0: b580         	push	{r7, lr}
7009ccf2: b08e         	sub	sp, #0x38
7009ccf4: 900d         	str	r0, [sp, #0x34]
7009ccf6: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009ccf8: 900c         	str	r0, [sp, #0x30]
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009ccfa: 980d         	ldr	r0, [sp, #0x34]
7009ccfc: 88c0         	ldrh	r0, [r0, #0x6]
7009ccfe: f011 fe27    	bl	0x700ae950 <Sciclient_rmIrIsIr> @ imm = #0x11c4e
7009cd02: b930         	cbnz	r0, 0x7009cd12 <Sciclient_rmIrqGetRoute+0x22> @ imm = #0xc
7009cd04: e7ff         	b	0x7009cd06 <Sciclient_rmIrqGetRoute+0x16> @ imm = #-0x2
;         (Sciclient_rmIrIsIr(cfg->d_id) == true)) {
7009cd06: 980d         	ldr	r0, [sp, #0x34]
7009cd08: 8940         	ldrh	r0, [r0, #0xa]
7009cd0a: f011 fe21    	bl	0x700ae950 <Sciclient_rmIrIsIr> @ imm = #0x11c42
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009cd0e: b120         	cbz	r0, 0x7009cd1a <Sciclient_rmIrqGetRoute+0x2a> @ imm = #0x8
7009cd10: e7ff         	b	0x7009cd12 <Sciclient_rmIrqGetRoute+0x22> @ imm = #-0x2
7009cd12: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009cd16: 900c         	str	r0, [sp, #0x30]
;     }
7009cd18: e7ff         	b	0x7009cd1a <Sciclient_rmIrqGetRoute+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009cd1a: 980c         	ldr	r0, [sp, #0x30]
7009cd1c: 2800         	cmp	r0, #0x0
7009cd1e: d156         	bne	0x7009cdce <Sciclient_rmIrqGetRoute+0xde> @ imm = #0xac
7009cd20: e7ff         	b	0x7009cd22 <Sciclient_rmIrqGetRoute+0x32> @ imm = #-0x2
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009cd22: 980d         	ldr	r0, [sp, #0x34]
7009cd24: 8a00         	ldrh	r0, [r0, #0x10]
7009cd26: 28ff         	cmp	r0, #0xff
7009cd28: d042         	beq	0x7009cdb0 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x84
7009cd2a: e7ff         	b	0x7009cd2c <Sciclient_rmIrqGetRoute+0x3c> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009cd2c: 980d         	ldr	r0, [sp, #0x34]
7009cd2e: 6800         	ldr	r0, [r0]
7009cd30: 2104         	movs	r1, #0x4
7009cd32: f011 ffed    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x11fda
;              true) &&
7009cd36: b3d8         	cbz	r0, 0x7009cdb0 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x76
7009cd38: e7ff         	b	0x7009cd3a <Sciclient_rmIrqGetRoute+0x4a> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009cd3a: 980d         	ldr	r0, [sp, #0x34]
7009cd3c: 6800         	ldr	r0, [r0]
7009cd3e: 2108         	movs	r1, #0x8
7009cd40: f011 ffe6    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x11fcc
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009cd44: b3a0         	cbz	r0, 0x7009cdb0 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x68
7009cd46: e7ff         	b	0x7009cd48 <Sciclient_rmIrqGetRoute+0x58> @ imm = #-0x2
;             if ((Sciclient_rmParamIsValid(cfg->valid_params,
7009cd48: 980d         	ldr	r0, [sp, #0x34]
7009cd4a: 6800         	ldr	r0, [r0]
7009cd4c: 2110         	movs	r1, #0x10
7009cd4e: f011 ffdf    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x11fbe
;                  true) &&
7009cd52: b1d0         	cbz	r0, 0x7009cd8a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #0x34
7009cd54: e7ff         	b	0x7009cd56 <Sciclient_rmIrqGetRoute+0x66> @ imm = #-0x2
;                 (Sciclient_rmParamIsValid(cfg->valid_params,
7009cd56: 980d         	ldr	r0, [sp, #0x34]
7009cd58: 6800         	ldr	r0, [r0]
7009cd5a: 2120         	movs	r1, #0x20
7009cd5c: f011 ffd8    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x11fb0
;             if ((Sciclient_rmParamIsValid(cfg->valid_params,
7009cd60: b198         	cbz	r0, 0x7009cd8a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #0x26
7009cd62: e7ff         	b	0x7009cd64 <Sciclient_rmIrqGetRoute+0x74> @ imm = #-0x2
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009cd64: f8dd c034    	ldr.w	r12, [sp, #0x34]
7009cd68: f8bc 1010    	ldrh.w	r1, [r12, #0x10]
;                                cfg->vint, cfg->global_evt,
7009cd6c: f8bc 2012    	ldrh.w	r2, [r12, #0x12]
7009cd70: f8bc 300e    	ldrh.w	r3, [r12, #0xe]
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009cd74: f89c 0004    	ldrb.w	r0, [r12, #0x4]
;                                cfg->vint_sb);
7009cd78: f89c c014    	ldrb.w	r12, [r12, #0x14]
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009cd7c: 46ee         	mov	lr, sp
7009cd7e: f8ce c000    	str.w	r12, [lr]
7009cd82: f005 fd2d    	bl	0x700a27e0 <Sciclient_rmIaValidateMapping> @ imm = #0x5a5a
7009cd86: 900c         	str	r0, [sp, #0x30]
;             }
7009cd88: e7ff         	b	0x7009cd8a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #-0x2
;             if (r == SystemP_SUCCESS) {
7009cd8a: 980c         	ldr	r0, [sp, #0x30]
7009cd8c: b978         	cbnz	r0, 0x7009cdae <Sciclient_rmIrqGetRoute+0xbe> @ imm = #0x1e
7009cd8e: e7ff         	b	0x7009cd90 <Sciclient_rmIrqGetRoute+0xa0> @ imm = #-0x2
;                 inp = cfg->global_evt;
7009cd90: 980d         	ldr	r0, [sp, #0x34]
7009cd92: 89c0         	ldrh	r0, [r0, #0xe]
7009cd94: f8ad 0028    	strh.w	r0, [sp, #0x28]
;                 outp = cfg->vint;
7009cd98: 980d         	ldr	r0, [sp, #0x34]
7009cd9a: 8a40         	ldrh	r0, [r0, #0x12]
7009cd9c: f8ad 0024    	strh.w	r0, [sp, #0x24]
;                 r = Sciclient_rmIrqGetNode(cfg->s_ia, &cur_n);
7009cda0: 980d         	ldr	r0, [sp, #0x34]
7009cda2: 8a00         	ldrh	r0, [r0, #0x10]
7009cda4: a906         	add	r1, sp, #0x18
7009cda6: f009 f8a3    	bl	0x700a5ef0 <Sciclient_rmIrqGetNode> @ imm = #0x9146
7009cdaa: 900c         	str	r0, [sp, #0x30]
;             }
7009cdac: e7ff         	b	0x7009cdae <Sciclient_rmIrqGetRoute+0xbe> @ imm = #-0x2
;         } else {
7009cdae: e00d         	b	0x7009cdcc <Sciclient_rmIrqGetRoute+0xdc> @ imm = #0x1a
7009cdb0: 2000         	movs	r0, #0x0
;             inp = 0u;
7009cdb2: f8ad 0028    	strh.w	r0, [sp, #0x28]
;             outp = cfg->s_idx;
7009cdb6: 980d         	ldr	r0, [sp, #0x34]
7009cdb8: 8900         	ldrh	r0, [r0, #0x8]
7009cdba: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             r = Sciclient_rmIrqGetNode(cfg->s_id, &cur_n);
7009cdbe: 980d         	ldr	r0, [sp, #0x34]
7009cdc0: 88c0         	ldrh	r0, [r0, #0x6]
7009cdc2: a906         	add	r1, sp, #0x18
7009cdc4: f009 f894    	bl	0x700a5ef0 <Sciclient_rmIrqGetNode> @ imm = #0x9128
7009cdc8: 900c         	str	r0, [sp, #0x30]
7009cdca: e7ff         	b	0x7009cdcc <Sciclient_rmIrqGetRoute+0xdc> @ imm = #-0x2
;     }
7009cdcc: e7ff         	b	0x7009cdce <Sciclient_rmIrqGetRoute+0xde> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009cdce: 980c         	ldr	r0, [sp, #0x30]
7009cdd0: b948         	cbnz	r0, 0x7009cde6 <Sciclient_rmIrqGetRoute+0xf6> @ imm = #0x12
7009cdd2: e7ff         	b	0x7009cdd4 <Sciclient_rmIrqGetRoute+0xe4> @ imm = #-0x2
7009cdd4: 2001         	movs	r0, #0x1
;         search = true;
7009cdd6: f88d 0021    	strb.w	r0, [sp, #0x21]
7009cdda: 2000         	movs	r0, #0x0
;         rt_complete = false;
7009cddc: f88d 0020    	strb.w	r0, [sp, #0x20]
;         Sciclient_rmPsInit();
7009cde0: f012 fb36    	bl	0x700af450 <Sciclient_rmPsInit> @ imm = #0x1266c
;     } else {
7009cde4: e003         	b	0x7009cdee <Sciclient_rmIrqGetRoute+0xfe> @ imm = #0x6
7009cde6: 2000         	movs	r0, #0x0
;         search = false;
7009cde8: f88d 0021    	strb.w	r0, [sp, #0x21]
7009cdec: e7ff         	b	0x7009cdee <Sciclient_rmIrqGetRoute+0xfe> @ imm = #-0x2
7009cdee: 2000         	movs	r0, #0x0
;     for (search_depth = 0u;
7009cdf0: f8ad 002e    	strh.w	r0, [sp, #0x2e]
7009cdf4: e7ff         	b	0x7009cdf6 <Sciclient_rmIrqGetRoute+0x106> @ imm = #-0x2
;          (search_depth < Sciclient_rmPsGetMaxPsp()) && (search == true);
7009cdf6: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cdfa: 9002         	str	r0, [sp, #0x8]
7009cdfc: f012 ffa8    	bl	0x700afd50 <Sciclient_rmPsGetMaxPsp> @ imm = #0x12f50
7009ce00: 9902         	ldr	r1, [sp, #0x8]
7009ce02: 4602         	mov	r2, r0
7009ce04: 2000         	movs	r0, #0x0
7009ce06: 4291         	cmp	r1, r2
7009ce08: 9003         	str	r0, [sp, #0xc]
7009ce0a: da06         	bge	0x7009ce1a <Sciclient_rmIrqGetRoute+0x12a> @ imm = #0xc
7009ce0c: e7ff         	b	0x7009ce0e <Sciclient_rmIrqGetRoute+0x11e> @ imm = #-0x2
7009ce0e: f89d 0021    	ldrb.w	r0, [sp, #0x21]
7009ce12: f000 0001    	and	r0, r0, #0x1
7009ce16: 9003         	str	r0, [sp, #0xc]
7009ce18: e7ff         	b	0x7009ce1a <Sciclient_rmIrqGetRoute+0x12a> @ imm = #-0x2
7009ce1a: 9803         	ldr	r0, [sp, #0xc]
;     for (search_depth = 0u;
7009ce1c: 07c0         	lsls	r0, r0, #0x1f
7009ce1e: 2800         	cmp	r0, #0x0
7009ce20: f000 80d8    	beq.w	0x7009cfd4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x1b0
7009ce24: e7ff         	b	0x7009ce26 <Sciclient_rmIrqGetRoute+0x136> @ imm = #-0x2
7009ce26: 2000         	movs	r0, #0x0
;         push_node = false;
7009ce28: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         for (if_idx = 0u; if_idx < cur_n->n_if; if_idx++) {
7009ce2c: f8ad 002c    	strh.w	r0, [sp, #0x2c]
7009ce30: e7ff         	b	0x7009ce32 <Sciclient_rmIrqGetRoute+0x142> @ imm = #-0x2
7009ce32: f8bd 002c    	ldrh.w	r0, [sp, #0x2c]
7009ce36: 9906         	ldr	r1, [sp, #0x18]
7009ce38: 8849         	ldrh	r1, [r1, #0x2]
7009ce3a: 4288         	cmp	r0, r1
7009ce3c: da6b         	bge	0x7009cf16 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0xd6
7009ce3e: e7ff         	b	0x7009ce40 <Sciclient_rmIrqGetRoute+0x150> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(cur_n, if_idx, &cur_if);
7009ce40: 9806         	ldr	r0, [sp, #0x18]
7009ce42: f8bd 102c    	ldrh.w	r1, [sp, #0x2c]
7009ce46: aa04         	add	r2, sp, #0x10
7009ce48: f010 fe22    	bl	0x700ada90 <Sciclient_rmIrqGetNodeItf> @ imm = #0x10c44
7009ce4c: 900c         	str	r0, [sp, #0x30]
;             if (r != SystemP_SUCCESS) {
7009ce4e: 980c         	ldr	r0, [sp, #0x30]
7009ce50: b108         	cbz	r0, 0x7009ce56 <Sciclient_rmIrqGetRoute+0x166> @ imm = #0x2
7009ce52: e7ff         	b	0x7009ce54 <Sciclient_rmIrqGetRoute+0x164> @ imm = #-0x2
;                 break;
7009ce54: e05f         	b	0x7009cf16 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0xbe
;             if ((outp >= cur_if->lbase) &&
7009ce56: f8bd 0024    	ldrh.w	r0, [sp, #0x24]
7009ce5a: 9904         	ldr	r1, [sp, #0x10]
7009ce5c: 8809         	ldrh	r1, [r1]
7009ce5e: 4288         	cmp	r0, r1
7009ce60: db52         	blt	0x7009cf08 <Sciclient_rmIrqGetRoute+0x218> @ imm = #0xa4
7009ce62: e7ff         	b	0x7009ce64 <Sciclient_rmIrqGetRoute+0x174> @ imm = #-0x2
;                 (outp < (cur_if->lbase + cur_if->len))) {
7009ce64: f8bd 0024    	ldrh.w	r0, [sp, #0x24]
7009ce68: 9a04         	ldr	r2, [sp, #0x10]
7009ce6a: 8811         	ldrh	r1, [r2]
7009ce6c: 8892         	ldrh	r2, [r2, #0x4]
7009ce6e: 4411         	add	r1, r2
;             if ((outp >= cur_if->lbase) &&
7009ce70: 4288         	cmp	r0, r1
7009ce72: da49         	bge	0x7009cf08 <Sciclient_rmIrqGetRoute+0x218> @ imm = #0x92
7009ce74: e7ff         	b	0x7009ce76 <Sciclient_rmIrqGetRoute+0x186> @ imm = #-0x2
;                 if ((cur_if->rid == cfg->d_id) &&
7009ce76: 9804         	ldr	r0, [sp, #0x10]
7009ce78: 88c0         	ldrh	r0, [r0, #0x6]
7009ce7a: 990d         	ldr	r1, [sp, #0x34]
7009ce7c: 8949         	ldrh	r1, [r1, #0xa]
7009ce7e: 4288         	cmp	r0, r1
7009ce80: d110         	bne	0x7009cea4 <Sciclient_rmIrqGetRoute+0x1b4> @ imm = #0x20
7009ce82: e7ff         	b	0x7009ce84 <Sciclient_rmIrqGetRoute+0x194> @ imm = #-0x2
;                     (SCICLIENT_OUTP_TO_INP(outp, cur_if->lbase,
7009ce84: 9a04         	ldr	r2, [sp, #0x10]
7009ce86: 8850         	ldrh	r0, [r2, #0x2]
7009ce88: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
7009ce8c: 8812         	ldrh	r2, [r2]
7009ce8e: 1a89         	subs	r1, r1, r2
7009ce90: 4408         	add	r0, r1
;                      cfg->d_irq)) {
7009ce92: 990d         	ldr	r1, [sp, #0x34]
7009ce94: 8989         	ldrh	r1, [r1, #0xc]
;                 if ((cur_if->rid == cfg->d_id) &&
7009ce96: 4288         	cmp	r0, r1
7009ce98: d104         	bne	0x7009cea4 <Sciclient_rmIrqGetRoute+0x1b4> @ imm = #0x8
7009ce9a: e7ff         	b	0x7009ce9c <Sciclient_rmIrqGetRoute+0x1ac> @ imm = #-0x2
7009ce9c: 2001         	movs	r0, #0x1
;                     rt_complete = true;
7009ce9e: f88d 0020    	strb.w	r0, [sp, #0x20]
;                     break;
7009cea2: e038         	b	0x7009cf16 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x70
;                 if (Sciclient_rmIrIsIr(cur_if->rid) == true) {
7009cea4: 9804         	ldr	r0, [sp, #0x10]
7009cea6: 88c0         	ldrh	r0, [r0, #0x6]
7009cea8: f011 fd52    	bl	0x700ae950 <Sciclient_rmIrIsIr> @ imm = #0x11aa4
7009ceac: b358         	cbz	r0, 0x7009cf06 <Sciclient_rmIrqGetRoute+0x216> @ imm = #0x56
7009ceae: e7ff         	b	0x7009ceb0 <Sciclient_rmIrqGetRoute+0x1c0> @ imm = #-0x2
;                     r = Sciclient_rmIrqGetNode(cur_if->rid, &next_n);
7009ceb0: 9804         	ldr	r0, [sp, #0x10]
7009ceb2: 88c0         	ldrh	r0, [r0, #0x6]
7009ceb4: a905         	add	r1, sp, #0x14
7009ceb6: f009 f81b    	bl	0x700a5ef0 <Sciclient_rmIrqGetNode> @ imm = #0x9036
7009ceba: 900c         	str	r0, [sp, #0x30]
;                     if (r != SystemP_SUCCESS) {
7009cebc: 980c         	ldr	r0, [sp, #0x30]
7009cebe: b108         	cbz	r0, 0x7009cec4 <Sciclient_rmIrqGetRoute+0x1d4> @ imm = #0x2
7009cec0: e7ff         	b	0x7009cec2 <Sciclient_rmIrqGetRoute+0x1d2> @ imm = #-0x2
;                         break;
7009cec2: e028         	b	0x7009cf16 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x50
;                     next_inp = SCICLIENT_OUTP_TO_INP(outp,
7009cec4: 9a04         	ldr	r2, [sp, #0x10]
7009cec6: 8850         	ldrh	r0, [r2, #0x2]
7009cec8: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
7009cecc: 8812         	ldrh	r2, [r2]
7009cece: 1a89         	subs	r1, r1, r2
7009ced0: 4408         	add	r0, r1
7009ced2: f8ad 0026    	strh.w	r0, [sp, #0x26]
;                     r = Sciclient_rmIrGetOutp(next_n->id, next_inp,
7009ced6: 9805         	ldr	r0, [sp, #0x14]
7009ced8: 8800         	ldrh	r0, [r0]
7009ceda: f8bd 1026    	ldrh.w	r1, [sp, #0x26]
7009cede: f10d 0222    	add.w	r2, sp, #0x22
7009cee2: f008 fc35    	bl	0x700a5750 <Sciclient_rmIrGetOutp> @ imm = #0x886a
7009cee6: 900c         	str	r0, [sp, #0x30]
;                     if (r == SystemP_SUCCESS) {
7009cee8: 980c         	ldr	r0, [sp, #0x30]
7009ceea: b930         	cbnz	r0, 0x7009cefa <Sciclient_rmIrqGetRoute+0x20a> @ imm = #0xc
7009ceec: e7ff         	b	0x7009ceee <Sciclient_rmIrqGetRoute+0x1fe> @ imm = #-0x2
7009ceee: 2001         	movs	r0, #0x1
;                         push_node = true;
7009cef0: f88d 001f    	strb.w	r0, [sp, #0x1f]
7009cef4: 2000         	movs	r0, #0x0
;                         r = SystemP_SUCCESS;
7009cef6: 900c         	str	r0, [sp, #0x30]
;                         break;
7009cef8: e00d         	b	0x7009cf16 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x1a
;                     if (r != SystemP_FAILURE) {
7009cefa: 980c         	ldr	r0, [sp, #0x30]
7009cefc: 3001         	adds	r0, #0x1
7009cefe: b108         	cbz	r0, 0x7009cf04 <Sciclient_rmIrqGetRoute+0x214> @ imm = #0x2
7009cf00: e7ff         	b	0x7009cf02 <Sciclient_rmIrqGetRoute+0x212> @ imm = #-0x2
;                         break;
7009cf02: e008         	b	0x7009cf16 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x10
;                 }
7009cf04: e7ff         	b	0x7009cf06 <Sciclient_rmIrqGetRoute+0x216> @ imm = #-0x2
;             }
7009cf06: e7ff         	b	0x7009cf08 <Sciclient_rmIrqGetRoute+0x218> @ imm = #-0x2
;         }
7009cf08: e7ff         	b	0x7009cf0a <Sciclient_rmIrqGetRoute+0x21a> @ imm = #-0x2
;         for (if_idx = 0u; if_idx < cur_n->n_if; if_idx++) {
7009cf0a: f8bd 002c    	ldrh.w	r0, [sp, #0x2c]
7009cf0e: 3001         	adds	r0, #0x1
7009cf10: f8ad 002c    	strh.w	r0, [sp, #0x2c]
7009cf14: e78d         	b	0x7009ce32 <Sciclient_rmIrqGetRoute+0x142> @ imm = #-0xe6
;         if (r != SystemP_SUCCESS) {
7009cf16: 980c         	ldr	r0, [sp, #0x30]
7009cf18: b108         	cbz	r0, 0x7009cf1e <Sciclient_rmIrqGetRoute+0x22e> @ imm = #0x2
7009cf1a: e7ff         	b	0x7009cf1c <Sciclient_rmIrqGetRoute+0x22c> @ imm = #-0x2
;             break;
7009cf1c: e05a         	b	0x7009cfd4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0xb4
;         if ((rt_complete == true) || (push_node == true)) {
7009cf1e: f89d 0020    	ldrb.w	r0, [sp, #0x20]
7009cf22: 07c0         	lsls	r0, r0, #0x1f
7009cf24: b930         	cbnz	r0, 0x7009cf34 <Sciclient_rmIrqGetRoute+0x244> @ imm = #0xc
7009cf26: e7ff         	b	0x7009cf28 <Sciclient_rmIrqGetRoute+0x238> @ imm = #-0x2
7009cf28: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009cf2c: 07c0         	lsls	r0, r0, #0x1f
7009cf2e: 2800         	cmp	r0, #0x0
7009cf30: d049         	beq	0x7009cfc6 <Sciclient_rmIrqGetRoute+0x2d6> @ imm = #0x92
7009cf32: e7ff         	b	0x7009cf34 <Sciclient_rmIrqGetRoute+0x244> @ imm = #-0x2
;             r = Sciclient_rmPsPush(cur_n, if_idx);
7009cf34: 9806         	ldr	r0, [sp, #0x18]
7009cf36: f8bd 102c    	ldrh.w	r1, [sp, #0x2c]
7009cf3a: f00f fb39    	bl	0x700ac5b0 <Sciclient_rmPsPush> @ imm = #0xf672
7009cf3e: 900c         	str	r0, [sp, #0x30]
;             if (r != SystemP_SUCCESS) {
7009cf40: 980c         	ldr	r0, [sp, #0x30]
7009cf42: b108         	cbz	r0, 0x7009cf48 <Sciclient_rmIrqGetRoute+0x258> @ imm = #0x2
7009cf44: e7ff         	b	0x7009cf46 <Sciclient_rmIrqGetRoute+0x256> @ imm = #-0x2
;                 break;
7009cf46: e045         	b	0x7009cfd4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x8a
;             if ((search_depth > 0u) ||
7009cf48: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cf4c: b950         	cbnz	r0, 0x7009cf64 <Sciclient_rmIrqGetRoute+0x274> @ imm = #0x14
7009cf4e: e7ff         	b	0x7009cf50 <Sciclient_rmIrqGetRoute+0x260> @ imm = #-0x2
;                 ((search_depth == 0u) &&
7009cf50: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cf54: bb28         	cbnz	r0, 0x7009cfa2 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #0x4a
7009cf56: e7ff         	b	0x7009cf58 <Sciclient_rmIrqGetRoute+0x268> @ imm = #-0x2
;                  (Sciclient_rmIaIsIa(cur_n->id) == true))) {
7009cf58: 9806         	ldr	r0, [sp, #0x18]
7009cf5a: 8800         	ldrh	r0, [r0]
7009cf5c: f011 fce0    	bl	0x700ae920 <Sciclient_rmIaIsIa> @ imm = #0x119c0
;             if ((search_depth > 0u) ||
7009cf60: b1f8         	cbz	r0, 0x7009cfa2 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #0x3e
7009cf62: e7ff         	b	0x7009cf64 <Sciclient_rmIrqGetRoute+0x274> @ imm = #-0x2
;                 cur_psp = Sciclient_rmPsGetPsp();
7009cf64: f012 fe94    	bl	0x700afc90 <Sciclient_rmPsGetPsp> @ imm = #0x12d28
7009cf68: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;                 r = Sciclient_rmPsSetInp(cur_psp - (1u), inp);
7009cf6c: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009cf70: 3801         	subs	r0, #0x1
7009cf72: f8bd 1028    	ldrh.w	r1, [sp, #0x28]
7009cf76: b280         	uxth	r0, r0
7009cf78: f010 f9d2    	bl	0x700ad320 <Sciclient_rmPsSetInp> @ imm = #0x103a4
7009cf7c: 900c         	str	r0, [sp, #0x30]
;                 if (r != SystemP_SUCCESS) {
7009cf7e: 980c         	ldr	r0, [sp, #0x30]
7009cf80: b108         	cbz	r0, 0x7009cf86 <Sciclient_rmIrqGetRoute+0x296> @ imm = #0x2
7009cf82: e7ff         	b	0x7009cf84 <Sciclient_rmIrqGetRoute+0x294> @ imm = #-0x2
;                     break;
7009cf84: e026         	b	0x7009cfd4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x4c
;                 r = Sciclient_rmPsSetOutp(cur_psp - (1u),
7009cf86: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009cf8a: 3801         	subs	r0, #0x1
;                         outp);
7009cf8c: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
;                 r = Sciclient_rmPsSetOutp(cur_psp - (1u),
7009cf90: b280         	uxth	r0, r0
7009cf92: f010 f9ed    	bl	0x700ad370 <Sciclient_rmPsSetOutp> @ imm = #0x103da
7009cf96: 900c         	str	r0, [sp, #0x30]
;                 if (r != SystemP_SUCCESS) {
7009cf98: 980c         	ldr	r0, [sp, #0x30]
7009cf9a: b108         	cbz	r0, 0x7009cfa0 <Sciclient_rmIrqGetRoute+0x2b0> @ imm = #0x2
7009cf9c: e7ff         	b	0x7009cf9e <Sciclient_rmIrqGetRoute+0x2ae> @ imm = #-0x2
;                     break;
7009cf9e: e019         	b	0x7009cfd4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x32
;             }
7009cfa0: e7ff         	b	0x7009cfa2 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #-0x2
;             if (rt_complete == true) {
7009cfa2: f89d 0020    	ldrb.w	r0, [sp, #0x20]
7009cfa6: 07c0         	lsls	r0, r0, #0x1f
7009cfa8: b108         	cbz	r0, 0x7009cfae <Sciclient_rmIrqGetRoute+0x2be> @ imm = #0x2
7009cfaa: e7ff         	b	0x7009cfac <Sciclient_rmIrqGetRoute+0x2bc> @ imm = #-0x2
;                 break;
7009cfac: e012         	b	0x7009cfd4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x24
;                 cur_n = next_n;
7009cfae: 9805         	ldr	r0, [sp, #0x14]
7009cfb0: 9006         	str	r0, [sp, #0x18]
;                 inp = next_inp;
7009cfb2: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
7009cfb6: f8ad 0028    	strh.w	r0, [sp, #0x28]
;                 outp = next_outp;
7009cfba: f8bd 0022    	ldrh.w	r0, [sp, #0x22]
7009cfbe: f8ad 0024    	strh.w	r0, [sp, #0x24]
7009cfc2: e7ff         	b	0x7009cfc4 <Sciclient_rmIrqGetRoute+0x2d4> @ imm = #-0x2
;         }
7009cfc4: e7ff         	b	0x7009cfc6 <Sciclient_rmIrqGetRoute+0x2d6> @ imm = #-0x2
;     }
7009cfc6: e7ff         	b	0x7009cfc8 <Sciclient_rmIrqGetRoute+0x2d8> @ imm = #-0x2
;          search_depth++) {
7009cfc8: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cfcc: 3001         	adds	r0, #0x1
7009cfce: f8ad 002e    	strh.w	r0, [sp, #0x2e]
;     for (search_depth = 0u;
7009cfd2: e710         	b	0x7009cdf6 <Sciclient_rmIrqGetRoute+0x106> @ imm = #-0x1e0
;     if (search_depth >= Sciclient_rmPsGetMaxPsp()) {
7009cfd4: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cfd8: 9001         	str	r0, [sp, #0x4]
7009cfda: f012 feb9    	bl	0x700afd50 <Sciclient_rmPsGetMaxPsp> @ imm = #0x12d72
7009cfde: 4601         	mov	r1, r0
7009cfe0: 9801         	ldr	r0, [sp, #0x4]
7009cfe2: 4288         	cmp	r0, r1
7009cfe4: db04         	blt	0x7009cff0 <Sciclient_rmIrqGetRoute+0x300> @ imm = #0x8
7009cfe6: e7ff         	b	0x7009cfe8 <Sciclient_rmIrqGetRoute+0x2f8> @ imm = #-0x2
7009cfe8: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
7009cfec: 900c         	str	r0, [sp, #0x30]
;     }
7009cfee: e7ff         	b	0x7009cff0 <Sciclient_rmIrqGetRoute+0x300> @ imm = #-0x2
;     return r;
7009cff0: 980c         	ldr	r0, [sp, #0x30]
7009cff2: b00e         	add	sp, #0x38
7009cff4: bd80         	pop	{r7, pc}
7009cff6: 0000         	movs	r0, r0

7009cff8 <$Ven$TA$L$PI$$HwiP_enable>:
7009cff8: f8df f000    	ldr.w	pc, [pc, #0x0]          @ 0x7009cffc <$Ven$TA$L$PI$$HwiP_enable+0x4>
7009cffc: 80 09 0b 70  	.word	0x700b0980

7009d000 <Udma_eventReset>:
; {
7009d000: b580         	push	{r7, lr}
7009d002: b090         	sub	sp, #0x40
7009d004: 900f         	str	r0, [sp, #0x3c]
7009d006: 910e         	str	r1, [sp, #0x38]
7009d008: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009d00a: 9001         	str	r0, [sp, #0x4]
7009d00c: 900d         	str	r0, [sp, #0x34]
;     eventPrms = &eventHandle->eventPrms;
7009d00e: 990e         	ldr	r1, [sp, #0x38]
7009d010: 3108         	adds	r1, #0x8
7009d012: 9109         	str	r1, [sp, #0x24]
;     rmIrqReq.valid_params           = 0U;
7009d014: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.global_event           = 0U;
7009d016: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     rmIrqReq.src_id                 = 0U;
7009d01a: f8ad 0014    	strh.w	r0, [sp, #0x14]
;     rmIrqReq.src_index              = 0U;
7009d01e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;     rmIrqReq.dst_id                 = 0U;
7009d022: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     rmIrqReq.dst_host_irq           = 0U;
7009d026: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     rmIrqReq.ia_id                  = 0U;
7009d02a: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.vint                   = 0U;
7009d02e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     rmIrqReq.vint_status_bit_index  = 0U;
7009d032: f88d 0022    	strb.w	r0, [sp, #0x22]
7009d036: 20ff         	movs	r0, #0xff
;     rmIrqReq.secondary_host         = TISCI_MSG_VALUE_RM_UNUSED_SECONDARY_HOST;
7009d038: f88d 0023    	strb.w	r0, [sp, #0x23]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009d03c: 9809         	ldr	r0, [sp, #0x24]
7009d03e: 6800         	ldr	r0, [r0]
7009d040: 2805         	cmp	r0, #0x5
7009d042: d00a         	beq	0x7009d05a <Udma_eventReset+0x5a> @ imm = #0x14
7009d044: e7ff         	b	0x7009d046 <Udma_eventReset+0x46> @ imm = #-0x2
;         rmIrqReq.valid_params  |= TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID;
7009d046: 9804         	ldr	r0, [sp, #0x10]
7009d048: f040 0010    	orr	r0, r0, #0x10
7009d04c: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.global_event   = (uint16_t)Udma_eventGetId(eventHandle);
7009d04e: 980e         	ldr	r0, [sp, #0x38]
7009d050: f010 f9b6    	bl	0x700ad3c0 <Udma_eventGetId> @ imm = #0x1036c
7009d054: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     }
7009d058: e7ff         	b	0x7009d05a <Udma_eventReset+0x5a> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009d05a: 980e         	ldr	r0, [sp, #0x38]
7009d05c: 6d80         	ldr	r0, [r0, #0x58]
7009d05e: f510 3f80    	cmn.w	r0, #0x10000
7009d062: d012         	beq	0x7009d08a <Udma_eventReset+0x8a> @ imm = #0x24
7009d064: e7ff         	b	0x7009d066 <Udma_eventReset+0x66> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_ID_VALID;
7009d066: 9804         	ldr	r0, [sp, #0x10]
7009d068: f040 0001    	orr	r0, r0, #0x1
7009d06c: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID;
7009d06e: 9804         	ldr	r0, [sp, #0x10]
7009d070: f040 0002    	orr	r0, r0, #0x2
7009d074: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.dst_id       = drvHandle->devIdCore;
7009d076: 980f         	ldr	r0, [sp, #0x3c]
7009d078: f8b0 00ea    	ldrh.w	r0, [r0, #0xea]
7009d07c: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         rmIrqReq.dst_host_irq = (uint16_t)eventHandle->coreIntrNum;
7009d080: 980e         	ldr	r0, [sp, #0x38]
7009d082: 6d80         	ldr	r0, [r0, #0x58]
7009d084: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     }
7009d088: e7ff         	b	0x7009d08a <Udma_eventReset+0x8a> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->eventPrms.controllerEventHandle)
7009d08a: 980e         	ldr	r0, [sp, #0x38]
7009d08c: 6980         	ldr	r0, [r0, #0x18]
7009d08e: b128         	cbz	r0, 0x7009d09c <Udma_eventReset+0x9c> @ imm = #0xa
7009d090: e7ff         	b	0x7009d092 <Udma_eventReset+0x92> @ imm = #-0x2
;         vintrNum = ((Udma_EventHandleInt) (eventHandle->eventPrms.controllerEventHandle))->vintrNum;
7009d092: 980e         	ldr	r0, [sp, #0x38]
7009d094: 6980         	ldr	r0, [r0, #0x18]
7009d096: 6cc0         	ldr	r0, [r0, #0x4c]
7009d098: 900c         	str	r0, [sp, #0x30]
;     }
7009d09a: e003         	b	0x7009d0a4 <Udma_eventReset+0xa4> @ imm = #0x6
;         vintrNum = eventHandle->vintrNum;
7009d09c: 980e         	ldr	r0, [sp, #0x38]
7009d09e: 6cc0         	ldr	r0, [r0, #0x4c]
7009d0a0: 900c         	str	r0, [sp, #0x30]
7009d0a2: e7ff         	b	0x7009d0a4 <Udma_eventReset+0xa4> @ imm = #-0x2
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_IA_ID_VALID;
7009d0a4: 9804         	ldr	r0, [sp, #0x10]
7009d0a6: f040 0004    	orr	r0, r0, #0x4
7009d0aa: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_VALID;
7009d0ac: 9804         	ldr	r0, [sp, #0x10]
7009d0ae: f040 0008    	orr	r0, r0, #0x8
7009d0b2: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.ia_id         = drvHandle->devIdIa;
7009d0b4: 980f         	ldr	r0, [sp, #0x3c]
7009d0b6: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009d0ba: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.vint          = (uint16_t)vintrNum;
7009d0be: 980c         	ldr	r0, [sp, #0x30]
7009d0c0: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
7009d0c4: 980e         	ldr	r0, [sp, #0x38]
7009d0c6: 6d00         	ldr	r0, [r0, #0x50]
7009d0c8: f64f 71ff    	movw	r1, #0xffff
7009d0cc: 4288         	cmp	r0, r1
7009d0ce: d009         	beq	0x7009d0e4 <Udma_eventReset+0xe4> @ imm = #0x12
7009d0d0: e7ff         	b	0x7009d0d2 <Udma_eventReset+0xd2> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_STATUS_BIT_INDEX_VALID;
7009d0d2: 9804         	ldr	r0, [sp, #0x10]
7009d0d4: f040 0020    	orr	r0, r0, #0x20
7009d0d8: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.vint_status_bit_index  = (uint8_t)eventHandle->vintrBitNum;
7009d0da: 980e         	ldr	r0, [sp, #0x38]
7009d0dc: 6d00         	ldr	r0, [r0, #0x50]
7009d0de: f88d 0022    	strb.w	r0, [sp, #0x22]
;     }
7009d0e2: e7ff         	b	0x7009d0e4 <Udma_eventReset+0xe4> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009d0e4: 9809         	ldr	r0, [sp, #0x24]
7009d0e6: 6800         	ldr	r0, [r0]
7009d0e8: 2801         	cmp	r0, #0x1
7009d0ea: d00a         	beq	0x7009d102 <Udma_eventReset+0x102> @ imm = #0x14
7009d0ec: e7ff         	b	0x7009d0ee <Udma_eventReset+0xee> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType)||
7009d0ee: 9809         	ldr	r0, [sp, #0x24]
7009d0f0: 6800         	ldr	r0, [r0]
7009d0f2: 2806         	cmp	r0, #0x6
7009d0f4: d005         	beq	0x7009d102 <Udma_eventReset+0x102> @ imm = #0xa
7009d0f6: e7ff         	b	0x7009d0f8 <Udma_eventReset+0xf8> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType))
7009d0f8: 9809         	ldr	r0, [sp, #0x24]
7009d0fa: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009d0fc: 2802         	cmp	r0, #0x2
7009d0fe: d14d         	bne	0x7009d19c <Udma_eventReset+0x19c> @ imm = #0x9a
7009d100: e7ff         	b	0x7009d102 <Udma_eventReset+0x102> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009d102: 9809         	ldr	r0, [sp, #0x24]
7009d104: 6880         	ldr	r0, [r0, #0x8]
7009d106: 900b         	str	r0, [sp, #0x2c]
;         rmIrqReq.src_id = drvHandle->srcIdRingIrq;
7009d108: 980f         	ldr	r0, [sp, #0x3c]
7009d10a: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009d10e: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009d112: 9809         	ldr	r0, [sp, #0x24]
7009d114: 6800         	ldr	r0, [r0]
7009d116: 2801         	cmp	r0, #0x1
7009d118: d005         	beq	0x7009d126 <Udma_eventReset+0x126> @ imm = #0xa
7009d11a: e7ff         	b	0x7009d11c <Udma_eventReset+0x11c> @ imm = #-0x2
7009d11c: 9809         	ldr	r0, [sp, #0x24]
7009d11e: 6800         	ldr	r0, [r0]
7009d120: 2806         	cmp	r0, #0x6
7009d122: d12e         	bne	0x7009d182 <Udma_eventReset+0x182> @ imm = #0x5c
7009d124: e7ff         	b	0x7009d126 <Udma_eventReset+0x126> @ imm = #-0x2
;             rmIrqReq.src_index = chHandle->cqRing->ringNum;
7009d126: 980b         	ldr	r0, [sp, #0x2c]
7009d128: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009d12c: 8880         	ldrh	r0, [r0, #0x4]
7009d12e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009d132: 980b         	ldr	r0, [sp, #0x2c]
7009d134: 7800         	ldrb	r0, [r0]
7009d136: 0740         	lsls	r0, r0, #0x1d
7009d138: 2800         	cmp	r0, #0x0
7009d13a: d509         	bpl	0x7009d150 <Udma_eventReset+0x150> @ imm = #0x12
7009d13c: e7ff         	b	0x7009d13e <Udma_eventReset+0x13e> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->blkCopyRingIrqOffset;
7009d13e: 980f         	ldr	r0, [sp, #0x3c]
7009d140: f8d0 10f0    	ldr.w	r1, [r0, #0xf0]
7009d144: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d148: 4408         	add	r0, r1
7009d14a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d14e: e017         	b	0x7009d180 <Udma_eventReset+0x180> @ imm = #0x2e
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009d150: 980b         	ldr	r0, [sp, #0x2c]
7009d152: 7800         	ldrb	r0, [r0]
7009d154: 07c0         	lsls	r0, r0, #0x1f
7009d156: b148         	cbz	r0, 0x7009d16c <Udma_eventReset+0x16c> @ imm = #0x12
7009d158: e7ff         	b	0x7009d15a <Udma_eventReset+0x15a> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009d15a: 980f         	ldr	r0, [sp, #0x3c]
7009d15c: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009d160: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d164: 4408         	add	r0, r1
7009d166: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d16a: e008         	b	0x7009d17e <Udma_eventReset+0x17e> @ imm = #0x10
;                 rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009d16c: 980f         	ldr	r0, [sp, #0x3c]
7009d16e: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009d172: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d176: 4408         	add	r0, r1
7009d178: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d17c: e7ff         	b	0x7009d17e <Udma_eventReset+0x17e> @ imm = #-0x2
7009d17e: e7ff         	b	0x7009d180 <Udma_eventReset+0x180> @ imm = #-0x2
;         }
7009d180: e00b         	b	0x7009d19a <Udma_eventReset+0x19a> @ imm = #0x16
;             rmIrqReq.src_index = chHandle->tdCqRing->ringNum;
7009d182: 980b         	ldr	r0, [sp, #0x2c]
7009d184: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009d188: 8880         	ldrh	r0, [r0, #0x4]
7009d18a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             rmIrqReq.src_index += TISCI_RINGACC0_OES_IRQ_SRC_IDX_START;
7009d18e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d192: 3014         	adds	r0, #0x14
7009d194: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d198: e7ff         	b	0x7009d19a <Udma_eventReset+0x19a> @ imm = #-0x2
;     }
7009d19a: e7ff         	b	0x7009d19c <Udma_eventReset+0x19c> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009d19c: 9809         	ldr	r0, [sp, #0x24]
7009d19e: 6800         	ldr	r0, [r0]
7009d1a0: 2803         	cmp	r0, #0x3
7009d1a2: d156         	bne	0x7009d252 <Udma_eventReset+0x252> @ imm = #0xac
7009d1a4: e7ff         	b	0x7009d1a6 <Udma_eventReset+0x1a6> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d1a6: 980f         	ldr	r0, [sp, #0x3c]
7009d1a8: 6800         	ldr	r0, [r0]
7009d1aa: 2802         	cmp	r0, #0x2
7009d1ac: d104         	bne	0x7009d1b8 <Udma_eventReset+0x1b8> @ imm = #0x8
7009d1ae: e7ff         	b	0x7009d1b0 <Udma_eventReset+0x1b0> @ imm = #-0x2
7009d1b0: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009d1b4: 900d         	str	r0, [sp, #0x34]
;         }
7009d1b6: e04b         	b	0x7009d250 <Udma_eventReset+0x250> @ imm = #0x96
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009d1b8: 9809         	ldr	r0, [sp, #0x24]
7009d1ba: 6880         	ldr	r0, [r0, #0x8]
7009d1bc: 900b         	str	r0, [sp, #0x2c]
;             rmIrqReq.src_id = drvHandle->srcIdTrIrq;
7009d1be: 980f         	ldr	r0, [sp, #0x3c]
7009d1c0: f8b0 00fc    	ldrh.w	r0, [r0, #0xfc]
7009d1c4: f8ad 0014    	strh.w	r0, [sp, #0x14]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009d1c8: 980b         	ldr	r0, [sp, #0x2c]
7009d1ca: 7800         	ldrb	r0, [r0]
7009d1cc: 0740         	lsls	r0, r0, #0x1d
7009d1ce: 2800         	cmp	r0, #0x0
7009d1d0: d50d         	bpl	0x7009d1ee <Udma_eventReset+0x1ee> @ imm = #0x1a
7009d1d2: e7ff         	b	0x7009d1d4 <Udma_eventReset+0x1d4> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009d1d4: 980b         	ldr	r0, [sp, #0x2c]
7009d1d6: 6ec0         	ldr	r0, [r0, #0x6c]
7009d1d8: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->blkCopyTrIrqOffset;
7009d1dc: 980f         	ldr	r0, [sp, #0x3c]
7009d1de: f8d0 1100    	ldr.w	r1, [r0, #0x100]
7009d1e2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d1e6: 4408         	add	r0, r1
7009d1e8: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d1ec: e02f         	b	0x7009d24e <Udma_eventReset+0x24e> @ imm = #0x5e
;             else if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009d1ee: 980b         	ldr	r0, [sp, #0x2c]
7009d1f0: 7800         	ldrb	r0, [r0]
7009d1f2: 0780         	lsls	r0, r0, #0x1e
7009d1f4: 2800         	cmp	r0, #0x0
7009d1f6: d50d         	bpl	0x7009d214 <Udma_eventReset+0x214> @ imm = #0x1a
7009d1f8: e7ff         	b	0x7009d1fa <Udma_eventReset+0x1fa> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->rxChNum;
7009d1fa: 980b         	ldr	r0, [sp, #0x2c]
7009d1fc: 6f00         	ldr	r0, [r0, #0x70]
7009d1fe: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->rxTrIrqOffset;
7009d202: 980f         	ldr	r0, [sp, #0x3c]
7009d204: f8d0 1108    	ldr.w	r1, [r0, #0x108]
7009d208: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d20c: 4408         	add	r0, r1
7009d20e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d212: e01b         	b	0x7009d24c <Udma_eventReset+0x24c> @ imm = #0x36
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009d214: 980b         	ldr	r0, [sp, #0x2c]
7009d216: 7800         	ldrb	r0, [r0]
7009d218: 07c0         	lsls	r0, r0, #0x1f
7009d21a: b168         	cbz	r0, 0x7009d238 <Udma_eventReset+0x238> @ imm = #0x1a
7009d21c: e7ff         	b	0x7009d21e <Udma_eventReset+0x21e> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009d21e: 980b         	ldr	r0, [sp, #0x2c]
7009d220: 6ec0         	ldr	r0, [r0, #0x6c]
7009d222: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->txTrIrqOffset;
7009d226: 980f         	ldr	r0, [sp, #0x3c]
7009d228: f8d0 1104    	ldr.w	r1, [r0, #0x104]
7009d22c: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d230: 4408         	add	r0, r1
7009d232: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d236: e008         	b	0x7009d24a <Udma_eventReset+0x24a> @ imm = #0x10
;                 rmIrqReq.src_id = drvHandle->devIdIa;
7009d238: 980f         	ldr	r0, [sp, #0x3c]
7009d23a: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009d23e: f8ad 0014    	strh.w	r0, [sp, #0x14]
7009d242: 2000         	movs	r0, #0x0
;                 rmIrqReq.src_index = 0U;                /* Not used by DMSC RM */
7009d244: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d248: e7ff         	b	0x7009d24a <Udma_eventReset+0x24a> @ imm = #-0x2
7009d24a: e7ff         	b	0x7009d24c <Udma_eventReset+0x24c> @ imm = #-0x2
7009d24c: e7ff         	b	0x7009d24e <Udma_eventReset+0x24e> @ imm = #-0x2
7009d24e: e7ff         	b	0x7009d250 <Udma_eventReset+0x250> @ imm = #-0x2
;     }
7009d250: e7ff         	b	0x7009d252 <Udma_eventReset+0x252> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
7009d252: 9809         	ldr	r0, [sp, #0x24]
7009d254: 6800         	ldr	r0, [r0]
7009d256: 2804         	cmp	r0, #0x4
7009d258: d130         	bne	0x7009d2bc <Udma_eventReset+0x2bc> @ imm = #0x60
7009d25a: e7ff         	b	0x7009d25c <Udma_eventReset+0x25c> @ imm = #-0x2
;         ringHandle = (Udma_RingHandleInt) eventPrms->ringHandle;
7009d25c: 9809         	ldr	r0, [sp, #0x24]
7009d25e: 68c0         	ldr	r0, [r0, #0xc]
7009d260: 900a         	str	r0, [sp, #0x28]
;         rmIrqReq.src_id     = drvHandle->srcIdRingIrq;
7009d262: 980f         	ldr	r0, [sp, #0x3c]
7009d264: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009d268: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmIrqReq.src_index  = ringHandle->ringNum;
7009d26c: 980a         	ldr	r0, [sp, #0x28]
7009d26e: 8880         	ldrh	r0, [r0, #0x4]
7009d270: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009d274: 980f         	ldr	r0, [sp, #0x3c]
7009d276: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009d27a: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d27e: 4408         	add	r0, r1
7009d280: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009d284: 980a         	ldr	r0, [sp, #0x28]
7009d286: 6dc0         	ldr	r0, [r0, #0x5c]
7009d288: 2804         	cmp	r0, #0x4
7009d28a: d316         	blo	0x7009d2ba <Udma_eventReset+0x2ba> @ imm = #0x2c
7009d28c: e7ff         	b	0x7009d28e <Udma_eventReset+0x28e> @ imm = #-0x2
;            (ringHandle->mappedRingGrp < (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
7009d28e: 980a         	ldr	r0, [sp, #0x28]
7009d290: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009d292: 2807         	cmp	r0, #0x7
7009d294: d811         	bhi	0x7009d2ba <Udma_eventReset+0x2ba> @ imm = #0x22
7009d296: e7ff         	b	0x7009d298 <Udma_eventReset+0x298> @ imm = #-0x2
;             rmIrqReq.src_index -= drvHandle->txRingIrqOffset;
7009d298: 980f         	ldr	r0, [sp, #0x3c]
7009d29a: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009d29e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d2a2: 1a40         	subs	r0, r0, r1
7009d2a4: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009d2a8: 980f         	ldr	r0, [sp, #0x3c]
7009d2aa: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009d2ae: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d2b2: 4408         	add	r0, r1
7009d2b4: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         }
7009d2b8: e7ff         	b	0x7009d2ba <Udma_eventReset+0x2ba> @ imm = #-0x2
;     }
7009d2ba: e7ff         	b	0x7009d2bc <Udma_eventReset+0x2bc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d2bc: 980d         	ldr	r0, [sp, #0x34]
7009d2be: b9b0         	cbnz	r0, 0x7009d2ee <Udma_eventReset+0x2ee> @ imm = #0x2c
7009d2c0: e7ff         	b	0x7009d2c2 <Udma_eventReset+0x2c2> @ imm = #-0x2
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009d2c2: 980f         	ldr	r0, [sp, #0x3c]
7009d2c4: 6800         	ldr	r0, [r0]
7009d2c6: b130         	cbz	r0, 0x7009d2d6 <Udma_eventReset+0x2d6> @ imm = #0xc
7009d2c8: e7ff         	b	0x7009d2ca <Udma_eventReset+0x2ca> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009d2ca: 9809         	ldr	r0, [sp, #0x24]
7009d2cc: 6800         	ldr	r0, [r0]
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009d2ce: 2805         	cmp	r0, #0x5
7009d2d0: d101         	bne	0x7009d2d6 <Udma_eventReset+0x2d6> @ imm = #0x2
7009d2d2: e7ff         	b	0x7009d2d4 <Udma_eventReset+0x2d4> @ imm = #-0x2
;         }
7009d2d4: e00a         	b	0x7009d2ec <Udma_eventReset+0x2ec> @ imm = #0x14
7009d2d6: a802         	add	r0, sp, #0x8
7009d2d8: f04f 31ff    	mov.w	r1, #0xffffffff
;             retVal = Sciclient_rmIrqRelease(&rmIrqReq, UDMA_SCICLIENT_TIMEOUT);
7009d2dc: f012 fad0    	bl	0x700af880 <Sciclient_rmIrqRelease> @ imm = #0x125a0
7009d2e0: 900d         	str	r0, [sp, #0x34]
;             if(CSL_PASS != retVal)
7009d2e2: 980d         	ldr	r0, [sp, #0x34]
7009d2e4: b108         	cbz	r0, 0x7009d2ea <Udma_eventReset+0x2ea> @ imm = #0x2
7009d2e6: e7ff         	b	0x7009d2e8 <Udma_eventReset+0x2e8> @ imm = #-0x2
;             }
7009d2e8: e7ff         	b	0x7009d2ea <Udma_eventReset+0x2ea> @ imm = #-0x2
7009d2ea: e7ff         	b	0x7009d2ec <Udma_eventReset+0x2ec> @ imm = #-0x2
;     }
7009d2ec: e7ff         	b	0x7009d2ee <Udma_eventReset+0x2ee> @ imm = #-0x2
;     return (retVal);
7009d2ee: 980d         	ldr	r0, [sp, #0x34]
7009d2f0: b010         	add	sp, #0x40
7009d2f2: bd80         	pop	{r7, pc}

7009d2f4 <malloc>:
7009d2f4: e1a01000     	mov	r1, r0
7009d2f8: e3a00008     	mov	r0, #8
7009d2fc: ea000ab4     	b	0x7009fdd4 <memalign>   @ imm = #0x2ad0

7009d300 <tm_receiver_thread_entry>:
; {
7009d300: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
7009d304: f644 1878    	movw	r8, #0x4978
7009d308: f245 0540    	movw	r5, #0x5040
7009d30c: f2c7 0808    	movt	r8, #0x7008
7009d310: f642 2718    	movw	r7, #0x2a18
7009d314: f641 19ae    	movw	r9, #0x19ae
7009d318: f2c7 0508    	movt	r5, #0x7008
7009d31c: f2c7 070b    	movt	r7, #0x700b
7009d320: f2c7 090b    	movt	r9, #0x700b
7009d324: 2400         	movs	r4, #0x0
7009d326: 4646         	mov	r6, r8
7009d328: e007         	b	0x7009d33a <tm_receiver_thread_entry+0x3a> @ imm = #0xe
7009d32a: bf00         	nop
7009d32c: bf00         	nop
7009d32e: bf00         	nop
;    for (i = 0; i < ITERATION_COUNT; i++)
7009d330: 3402         	adds	r4, #0x2
7009d332: 3620         	adds	r6, #0x20
7009d334: 2c20         	cmp	r4, #0x20
7009d336: f000 80a3    	beq.w	0x7009d480 <tm_receiver_thread_entry+0x180> @ imm = #0x146
;       tm_interrupt_raise();
7009d33a: f012 fcf9    	bl	0x700afd30 <tm_interrupt_raise> @ imm = #0x129f2
;       tm_queue_receive(0, message_received_arr);
7009d33e: 4629         	mov	r1, r5
7009d340: 2000         	movs	r0, #0x0
7009d342: f012 f8e5    	bl	0x700af510 <tm_queue_receive> @ imm = #0x121ca
;       tm_pmu_profile_end(pmu_send_names[i]);
7009d346: 4630         	mov	r0, r6
7009d348: f012 fd2a    	bl	0x700afda0 <tm_pmu_profile_end> @ imm = #0x12a54
;       tm_isr_to_task_counter++;
7009d34c: 6838         	ldr	r0, [r7]
7009d34e: 3001         	adds	r0, #0x1
7009d350: 6038         	str	r0, [r7]
;       checksum += msg[i];
7009d352: e895 0007    	ldm.w	r5, {r0, r1, r2}
7009d356: 4408         	add	r0, r1
7009d358: 68e9         	ldr	r1, [r5, #0xc]
7009d35a: 4410         	add	r0, r2
7009d35c: 692a         	ldr	r2, [r5, #0x10]
7009d35e: 4408         	add	r0, r1
7009d360: 6969         	ldr	r1, [r5, #0x14]
7009d362: 4410         	add	r0, r2
7009d364: 69aa         	ldr	r2, [r5, #0x18]
7009d366: 4408         	add	r0, r1
7009d368: 69e9         	ldr	r1, [r5, #0x1c]
7009d36a: 4410         	add	r0, r2
7009d36c: 6a2a         	ldr	r2, [r5, #0x20]
7009d36e: 4408         	add	r0, r1
7009d370: 6a69         	ldr	r1, [r5, #0x24]
7009d372: 4410         	add	r0, r2
7009d374: 6aaa         	ldr	r2, [r5, #0x28]
7009d376: 4408         	add	r0, r1
7009d378: 6ae9         	ldr	r1, [r5, #0x2c]
7009d37a: 4410         	add	r0, r2
7009d37c: 6b2a         	ldr	r2, [r5, #0x30]
7009d37e: 4408         	add	r0, r1
7009d380: 6b69         	ldr	r1, [r5, #0x34]
7009d382: 4410         	add	r0, r2
7009d384: 6baa         	ldr	r2, [r5, #0x38]
7009d386: 4408         	add	r0, r1
7009d388: 6be9         	ldr	r1, [r5, #0x3c]
7009d38a: 4410         	add	r0, r2
7009d38c: 6c2a         	ldr	r2, [r5, #0x40]
7009d38e: 4408         	add	r0, r1
7009d390: 6c69         	ldr	r1, [r5, #0x44]
7009d392: 4410         	add	r0, r2
7009d394: 6caa         	ldr	r2, [r5, #0x48]
7009d396: 4408         	add	r0, r1
7009d398: 6ce9         	ldr	r1, [r5, #0x4c]
7009d39a: 4410         	add	r0, r2
7009d39c: 6d2a         	ldr	r2, [r5, #0x50]
7009d39e: 4408         	add	r0, r1
7009d3a0: 6d69         	ldr	r1, [r5, #0x54]
7009d3a2: 4410         	add	r0, r2
7009d3a4: 6daa         	ldr	r2, [r5, #0x58]
7009d3a6: 4408         	add	r0, r1
7009d3a8: 6de9         	ldr	r1, [r5, #0x5c]
7009d3aa: 4410         	add	r0, r2
7009d3ac: 6e2a         	ldr	r2, [r5, #0x60]
7009d3ae: 4408         	add	r0, r1
7009d3b0: 6e69         	ldr	r1, [r5, #0x64]
7009d3b2: 4410         	add	r0, r2
7009d3b4: 6eaa         	ldr	r2, [r5, #0x68]
7009d3b6: 4408         	add	r0, r1
7009d3b8: 6ee9         	ldr	r1, [r5, #0x6c]
7009d3ba: 4410         	add	r0, r2
7009d3bc: 6f2a         	ldr	r2, [r5, #0x70]
7009d3be: 4408         	add	r0, r1
7009d3c0: 6f69         	ldr	r1, [r5, #0x74]
7009d3c2: 4410         	add	r0, r2
7009d3c4: 6faa         	ldr	r2, [r5, #0x78]
7009d3c6: 4408         	add	r0, r1
;       if (compute_checksum(message_received_arr, MESSAGE_SIZE - 1) != message_received_arr[MESSAGE_SIZE - 1])
7009d3c8: 6fe9         	ldr	r1, [r5, #0x7c]
;       checksum += msg[i];
7009d3ca: 4410         	add	r0, r2
;       if (compute_checksum(message_received_arr, MESSAGE_SIZE - 1) != message_received_arr[MESSAGE_SIZE - 1])
7009d3cc: 4288         	cmp	r0, r1
7009d3ce: d004         	beq	0x7009d3da <tm_receiver_thread_entry+0xda> @ imm = #0x8
;          printf("Message integrity error in iteration %d: checksum mismatch\r\n", i);
7009d3d0: 4649         	mov	r1, r9
7009d3d2: 4622         	mov	r2, r4
7009d3d4: 2001         	movs	r0, #0x1
7009d3d6: f00c fca3    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc946
;       tm_interrupt_raise();
7009d3da: f012 fca9    	bl	0x700afd30 <tm_interrupt_raise> @ imm = #0x12952
;       tm_queue_receive(0, message_received_arr);
7009d3de: 4629         	mov	r1, r5
7009d3e0: 2000         	movs	r0, #0x0
7009d3e2: f012 f895    	bl	0x700af510 <tm_queue_receive> @ imm = #0x1212a
;       tm_pmu_profile_end(pmu_send_names[i]);
7009d3e6: f106 0010    	add.w	r0, r6, #0x10
7009d3ea: f012 fcd9    	bl	0x700afda0 <tm_pmu_profile_end> @ imm = #0x129b2
;       tm_isr_to_task_counter++;
7009d3ee: 6838         	ldr	r0, [r7]
7009d3f0: 3001         	adds	r0, #0x1
7009d3f2: 6038         	str	r0, [r7]
;       checksum += msg[i];
7009d3f4: e895 0007    	ldm.w	r5, {r0, r1, r2}
7009d3f8: 4408         	add	r0, r1
7009d3fa: 68e9         	ldr	r1, [r5, #0xc]
7009d3fc: 4410         	add	r0, r2
7009d3fe: 692a         	ldr	r2, [r5, #0x10]
7009d400: 4408         	add	r0, r1
7009d402: 6969         	ldr	r1, [r5, #0x14]
7009d404: 4410         	add	r0, r2
7009d406: 69aa         	ldr	r2, [r5, #0x18]
7009d408: 4408         	add	r0, r1
7009d40a: 69e9         	ldr	r1, [r5, #0x1c]
7009d40c: 4410         	add	r0, r2
7009d40e: 6a2a         	ldr	r2, [r5, #0x20]
7009d410: 4408         	add	r0, r1
7009d412: 6a69         	ldr	r1, [r5, #0x24]
7009d414: 4410         	add	r0, r2
7009d416: 6aaa         	ldr	r2, [r5, #0x28]
7009d418: 4408         	add	r0, r1
7009d41a: 6ae9         	ldr	r1, [r5, #0x2c]
7009d41c: 4410         	add	r0, r2
7009d41e: 6b2a         	ldr	r2, [r5, #0x30]
7009d420: 4408         	add	r0, r1
7009d422: 6b69         	ldr	r1, [r5, #0x34]
7009d424: 4410         	add	r0, r2
7009d426: 6baa         	ldr	r2, [r5, #0x38]
7009d428: 4408         	add	r0, r1
7009d42a: 6be9         	ldr	r1, [r5, #0x3c]
7009d42c: 4410         	add	r0, r2
7009d42e: 6c2a         	ldr	r2, [r5, #0x40]
7009d430: 4408         	add	r0, r1
7009d432: 6c69         	ldr	r1, [r5, #0x44]
7009d434: 4410         	add	r0, r2
7009d436: 6caa         	ldr	r2, [r5, #0x48]
7009d438: 4408         	add	r0, r1
7009d43a: 6ce9         	ldr	r1, [r5, #0x4c]
7009d43c: 4410         	add	r0, r2
7009d43e: 6d2a         	ldr	r2, [r5, #0x50]
7009d440: 4408         	add	r0, r1
7009d442: 6d69         	ldr	r1, [r5, #0x54]
7009d444: 4410         	add	r0, r2
7009d446: 6daa         	ldr	r2, [r5, #0x58]
7009d448: 4408         	add	r0, r1
7009d44a: 6de9         	ldr	r1, [r5, #0x5c]
7009d44c: 4410         	add	r0, r2
7009d44e: 6e2a         	ldr	r2, [r5, #0x60]
7009d450: 4408         	add	r0, r1
7009d452: 6e69         	ldr	r1, [r5, #0x64]
7009d454: 4410         	add	r0, r2
7009d456: 6eaa         	ldr	r2, [r5, #0x68]
7009d458: 4408         	add	r0, r1
7009d45a: 6ee9         	ldr	r1, [r5, #0x6c]
7009d45c: 4410         	add	r0, r2
7009d45e: 6f2a         	ldr	r2, [r5, #0x70]
7009d460: 4408         	add	r0, r1
7009d462: 6f69         	ldr	r1, [r5, #0x74]
7009d464: 4410         	add	r0, r2
7009d466: 6faa         	ldr	r2, [r5, #0x78]
7009d468: 4408         	add	r0, r1
;       if (compute_checksum(message_received_arr, MESSAGE_SIZE - 1) != message_received_arr[MESSAGE_SIZE - 1])
7009d46a: 6fe9         	ldr	r1, [r5, #0x7c]
;       checksum += msg[i];
7009d46c: 4410         	add	r0, r2
;       if (compute_checksum(message_received_arr, MESSAGE_SIZE - 1) != message_received_arr[MESSAGE_SIZE - 1])
7009d46e: 4288         	cmp	r0, r1
7009d470: f43f af5e    	beq.w	0x7009d330 <tm_receiver_thread_entry+0x30> @ imm = #-0x144
7009d474: 1c62         	adds	r2, r4, #0x1
;          printf("Message integrity error in iteration %d: checksum mismatch\r\n", i);
7009d476: 4649         	mov	r1, r9
7009d478: 2001         	movs	r0, #0x1
7009d47a: f00c fc51    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc8a2
7009d47e: e757         	b	0x7009d330 <tm_receiver_thread_entry+0x30> @ imm = #-0x152
;    printf("==== ISR-to-Task Benchmark Complete ====\r\n");
7009d480: f641 21f0    	movw	r1, #0x1af0
7009d484: 2001         	movs	r0, #0x1
7009d486: f2c7 010b    	movt	r1, #0x700b
7009d48a: f00c fc49    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc892
;    printf("Total messages processed: %lu\r\n", tm_isr_to_task_counter);
7009d48e: f641 41c7    	movw	r1, #0x1cc7
7009d492: 683a         	ldr	r2, [r7]
7009d494: f2c7 010b    	movt	r1, #0x700b
7009d498: 2001         	movs	r0, #0x1
7009d49a: f00c fc41    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc882
;    printf("Total interrupts processed: %lu\r\n", tm_isr_counter);
7009d49e: f642 2014    	movw	r0, #0x2a14
7009d4a2: f641 411f    	movw	r1, #0x1c1f
7009d4a6: f2c7 000b    	movt	r0, #0x700b
7009d4aa: f2c7 010b    	movt	r1, #0x700b
7009d4ae: 6802         	ldr	r2, [r0]
7009d4b0: 2001         	movs	r0, #0x1
7009d4b2: f00c fc35    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc86a
7009d4b6: f242 0917    	movw	r9, #0x2017
7009d4ba: f244 7a78    	movw	r10, #0x4778
7009d4be: f242 05d4    	movw	r5, #0x20d4
7009d4c2: f2c7 090b    	movt	r9, #0x700b
7009d4c6: f2c7 0a08    	movt	r10, #0x7008
7009d4ca: f2c7 050b    	movt	r5, #0x700b
7009d4ce: 2400         	movs	r4, #0x0
;       printf("Receive Latency: ");
7009d4d0: 4649         	mov	r1, r9
7009d4d2: f04f 0001    	mov.w	r0, #0x1
7009d4d6: f00c fc23    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc846
;       tm_pmu_profile_print(pmu_recv_names[i]);
7009d4da: eb0a 0604    	add.w	r6, r10, r4
7009d4de: 4630         	mov	r0, r6
7009d4e0: f012 fc66    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x128cc
;       printf("Send Latency: ");
7009d4e4: 4629         	mov	r1, r5
7009d4e6: 2001         	movs	r0, #0x1
7009d4e8: f00c fc1a    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc834
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d4ec: eb08 0704    	add.w	r7, r8, r4
7009d4f0: 4638         	mov	r0, r7
7009d4f2: f012 fc5d    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x128ba
;       printf("Receive Latency: ");
7009d4f6: 4649         	mov	r1, r9
7009d4f8: 2001         	movs	r0, #0x1
7009d4fa: f00c fc11    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc822
;       tm_pmu_profile_print(pmu_recv_names[i]);
7009d4fe: f106 0010    	add.w	r0, r6, #0x10
7009d502: f012 fc55    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x128aa
;       printf("Send Latency: ");
7009d506: 4629         	mov	r1, r5
7009d508: 2001         	movs	r0, #0x1
7009d50a: f00c fc09    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc812
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d50e: f107 0010    	add.w	r0, r7, #0x10
7009d512: f012 fc4d    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x1289a
;       printf("Receive Latency: ");
7009d516: 4649         	mov	r1, r9
7009d518: 2001         	movs	r0, #0x1
7009d51a: f00c fc01    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc802
;       tm_pmu_profile_print(pmu_recv_names[i]);
7009d51e: f106 0020    	add.w	r0, r6, #0x20
7009d522: f012 fc45    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x1288a
;       printf("Send Latency: ");
7009d526: 4629         	mov	r1, r5
7009d528: 2001         	movs	r0, #0x1
7009d52a: f00c fbf9    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc7f2
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d52e: f107 0020    	add.w	r0, r7, #0x20
7009d532: f012 fc3d    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x1287a
;       printf("Receive Latency: ");
7009d536: 4649         	mov	r1, r9
7009d538: 2001         	movs	r0, #0x1
7009d53a: f00c fbf1    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc7e2
;       tm_pmu_profile_print(pmu_recv_names[i]);
7009d53e: f106 0030    	add.w	r0, r6, #0x30
7009d542: f012 fc35    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x1286a
;       printf("Send Latency: ");
7009d546: 4629         	mov	r1, r5
7009d548: 2001         	movs	r0, #0x1
7009d54a: f00c fbe9    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc7d2
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d54e: f107 0030    	add.w	r0, r7, #0x30
7009d552: f012 fc2d    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x1285a
;       printf("Receive Latency: ");
7009d556: 4649         	mov	r1, r9
7009d558: 2001         	movs	r0, #0x1
7009d55a: f00c fbe1    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc7c2
;       tm_pmu_profile_print(pmu_recv_names[i]);
7009d55e: f106 0040    	add.w	r0, r6, #0x40
7009d562: f012 fc25    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x1284a
;       printf("Send Latency: ");
7009d566: 4629         	mov	r1, r5
7009d568: 2001         	movs	r0, #0x1
7009d56a: f00c fbd9    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc7b2
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d56e: f107 0040    	add.w	r0, r7, #0x40
7009d572: f012 fc1d    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x1283a
;       printf("Receive Latency: ");
7009d576: 4649         	mov	r1, r9
7009d578: 2001         	movs	r0, #0x1
7009d57a: f00c fbd1    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc7a2
;       tm_pmu_profile_print(pmu_recv_names[i]);
7009d57e: f106 0050    	add.w	r0, r6, #0x50
7009d582: f012 fc15    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x1282a
;       printf("Send Latency: ");
7009d586: 4629         	mov	r1, r5
7009d588: 2001         	movs	r0, #0x1
7009d58a: f00c fbc9    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc792
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d58e: f107 0050    	add.w	r0, r7, #0x50
7009d592: f012 fc0d    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x1281a
;       printf("Receive Latency: ");
7009d596: 4649         	mov	r1, r9
7009d598: 2001         	movs	r0, #0x1
7009d59a: f00c fbc1    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc782
;       tm_pmu_profile_print(pmu_recv_names[i]);
7009d59e: f106 0060    	add.w	r0, r6, #0x60
7009d5a2: f012 fc05    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x1280a
;       printf("Send Latency: ");
7009d5a6: 4629         	mov	r1, r5
7009d5a8: 2001         	movs	r0, #0x1
7009d5aa: f00c fbb9    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc772
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d5ae: f107 0060    	add.w	r0, r7, #0x60
7009d5b2: f012 fbfd    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x127fa
;       printf("Receive Latency: ");
7009d5b6: 4649         	mov	r1, r9
7009d5b8: 2001         	movs	r0, #0x1
7009d5ba: f00c fbb1    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc762
;       tm_pmu_profile_print(pmu_recv_names[i]);
7009d5be: f106 0070    	add.w	r0, r6, #0x70
7009d5c2: f012 fbf5    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x127ea
;       printf("Send Latency: ");
7009d5c6: 4629         	mov	r1, r5
7009d5c8: 2001         	movs	r0, #0x1
7009d5ca: f00c fba9    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xc752
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d5ce: f107 0070    	add.w	r0, r7, #0x70
7009d5d2: f012 fbed    	bl	0x700afdb0 <tm_pmu_profile_print> @ imm = #0x127da
;    for (i = 0; i < ITERATION_COUNT; i++)
7009d5d6: 3480         	adds	r4, #0x80
7009d5d8: f5b4 7f00    	cmp.w	r4, #0x200
7009d5dc: f47f af78    	bne.w	0x7009d4d0 <tm_receiver_thread_entry+0x1d0> @ imm = #-0x110
;    tm_thread_suspend(0);
7009d5e0: 2000         	movs	r0, #0x0
7009d5e2: e8bd 47f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, lr}
7009d5e6: f012 b9ab    	b.w	0x700af940 <tm_thread_suspend> @ imm = #0x12356
7009d5ea: 0000         	movs	r0, r0
7009d5ec: 0000         	movs	r0, r0
7009d5ee: 0000         	movs	r0, r0

7009d5f0 <Sciclient_service>:
; {
7009d5f0: b580         	push	{r7, lr}
7009d5f2: b094         	sub	sp, #0x50
7009d5f4: 9013         	str	r0, [sp, #0x4c]
7009d5f6: 9112         	str	r1, [sp, #0x48]
7009d5f8: 2000         	movs	r0, #0x0
;     int32_t   status        = SystemP_SUCCESS;
7009d5fa: 9011         	str	r0, [sp, #0x44]
7009d5fc: 210f         	movs	r1, #0xf
;     uint32_t  contextId     = SCICLIENT_CONTEXT_MAX_NUM;
7009d5fe: 9110         	str	r1, [sp, #0x40]
;     uint32_t  initialCount  = 0U;
7009d600: 900f         	str	r0, [sp, #0x3c]
;     uint8_t   localSeqId    = gSciclientHandle.currSeqId;
7009d602: f642 1158    	movw	r1, #0x2958
7009d606: f2c7 010b    	movt	r1, #0x700b
7009d60a: 6809         	ldr	r1, [r1]
7009d60c: f88d 103b    	strb.w	r1, [sp, #0x3b]
;     uint32_t  txPayloadSize = 0U;
7009d610: 900d         	str	r0, [sp, #0x34]
;     uint32_t  rxPayloadSize = 0U;
7009d612: 900c         	str	r0, [sp, #0x30]
;     uint8_t  *pLocalRespPayload = NULL;
7009d614: 900b         	str	r0, [sp, #0x2c]
;     uint8_t  *pSecHeader = NULL;
7009d616: 9007         	str	r0, [sp, #0x1c]
;     if((pReqPrm == NULL) || (pRespPrm == NULL) || (pReqPrm->pReqPayload == NULL))
7009d618: 9813         	ldr	r0, [sp, #0x4c]
7009d61a: b138         	cbz	r0, 0x7009d62c <Sciclient_service+0x3c> @ imm = #0xe
7009d61c: e7ff         	b	0x7009d61e <Sciclient_service+0x2e> @ imm = #-0x2
7009d61e: 9812         	ldr	r0, [sp, #0x48]
7009d620: b120         	cbz	r0, 0x7009d62c <Sciclient_service+0x3c> @ imm = #0x8
7009d622: e7ff         	b	0x7009d624 <Sciclient_service+0x34> @ imm = #-0x2
7009d624: 9813         	ldr	r0, [sp, #0x4c]
7009d626: 6880         	ldr	r0, [r0, #0x8]
7009d628: b920         	cbnz	r0, 0x7009d634 <Sciclient_service+0x44> @ imm = #0x8
7009d62a: e7ff         	b	0x7009d62c <Sciclient_service+0x3c> @ imm = #-0x2
7009d62c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009d630: 9011         	str	r0, [sp, #0x44]
;     }
7009d632: e09e         	b	0x7009d772 <Sciclient_service+0x182> @ imm = #0x13c
;         contextId = Sciclient_getCurrentContext(pReqPrm->messageType);
7009d634: 9813         	ldr	r0, [sp, #0x4c]
7009d636: 8800         	ldrh	r0, [r0]
7009d638: f00a faca    	bl	0x700a7bd0 <Sciclient_getCurrentContext> @ imm = #0xa594
7009d63c: 9010         	str	r0, [sp, #0x40]
;         if(contextId < SCICLIENT_CONTEXT_MAX_NUM)
7009d63e: 9810         	ldr	r0, [sp, #0x40]
7009d640: 280e         	cmp	r0, #0xe
7009d642: f200 8091    	bhi.w	0x7009d768 <Sciclient_service+0x178> @ imm = #0x122
7009d646: e7ff         	b	0x7009d648 <Sciclient_service+0x58> @ imm = #-0x2
;             txThread = Sciclient_getTxThreadId(contextId);
7009d648: 9810         	ldr	r0, [sp, #0x40]
7009d64a: f011 fea1    	bl	0x700af390 <Sciclient_getTxThreadId> @ imm = #0x11d42
7009d64e: 900a         	str	r0, [sp, #0x28]
;             rxThread = Sciclient_getRxThreadId(contextId);
7009d650: 9810         	ldr	r0, [sp, #0x40]
7009d652: f011 fe8d    	bl	0x700af370 <Sciclient_getRxThreadId> @ imm = #0x11d1a
7009d656: 9009         	str	r0, [sp, #0x24]
;             if(gSciclientMap[contextId].context == SCICLIENT_SECURE_CONTEXT)
7009d658: 9810         	ldr	r0, [sp, #0x40]
7009d65a: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009d65e: f241 3060    	movw	r0, #0x1360
7009d662: f2c7 000b    	movt	r0, #0x700b
7009d666: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
7009d66a: b938         	cbnz	r0, 0x7009d67c <Sciclient_service+0x8c> @ imm = #0xe
7009d66c: e7ff         	b	0x7009d66e <Sciclient_service+0x7e> @ imm = #-0x2
;                 gSecHeaderSizeWords = sizeof(struct tisci_sec_header)/sizeof(uint32_t);
7009d66e: f642 2164    	movw	r1, #0x2a64
7009d672: f2c7 010b    	movt	r1, #0x700b
7009d676: 2001         	movs	r0, #0x1
7009d678: 7008         	strb	r0, [r1]
;             }
7009d67a: e006         	b	0x7009d68a <Sciclient_service+0x9a> @ imm = #0xc
;                 gSecHeaderSizeWords = 0;
7009d67c: f642 2164    	movw	r1, #0x2a64
7009d680: f2c7 010b    	movt	r1, #0x700b
7009d684: 2000         	movs	r0, #0x0
7009d686: 7008         	strb	r0, [r1]
7009d688: e7ff         	b	0x7009d68a <Sciclient_service+0x9a> @ imm = #-0x2
;             gSciclientHandle.maxMsgSizeBytes = CSL_secProxyGetMaxMsgSize(&gSciclientSecProxyCfg) -
7009d68a: f642 00d0    	movw	r0, #0x28d0
7009d68e: f2c7 000b    	movt	r0, #0x700b
7009d692: f011 f92d    	bl	0x700ae8f0 <CSL_secProxyGetMaxMsgSize> @ imm = #0x1125a
7009d696: 3804         	subs	r0, #0x4
7009d698: f642 1158    	movw	r1, #0x2958
7009d69c: f2c7 010b    	movt	r1, #0x700b
7009d6a0: 6148         	str	r0, [r1, #0x14]
;             if(gSciclientMap[contextId].context == SCICLIENT_SECURE_CONTEXT)
7009d6a2: 9810         	ldr	r0, [sp, #0x40]
7009d6a4: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009d6a8: f241 3060    	movw	r0, #0x1360
7009d6ac: f2c7 000b    	movt	r0, #0x700b
7009d6b0: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
7009d6b4: b940         	cbnz	r0, 0x7009d6c8 <Sciclient_service+0xd8> @ imm = #0x10
7009d6b6: e7ff         	b	0x7009d6b8 <Sciclient_service+0xc8> @ imm = #-0x2
7009d6b8: 2000         	movs	r0, #0x0
;                 secHeader.integ_check = (uint16_t)0;
7009d6ba: f8ad 0014    	strh.w	r0, [sp, #0x14]
;                 secHeader.rsvd = (uint16_t)0;
7009d6be: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d6c2: a805         	add	r0, sp, #0x14
;                 pSecHeader = (uint8_t * )(&secHeader);
7009d6c4: 9007         	str	r0, [sp, #0x1c]
;             }
7009d6c6: e7ff         	b	0x7009d6c8 <Sciclient_service+0xd8> @ imm = #-0x2
;             if (pReqPrm->reqPayloadSize > 0U)
7009d6c8: 9813         	ldr	r0, [sp, #0x4c]
7009d6ca: 68c0         	ldr	r0, [r0, #0xc]
7009d6cc: b128         	cbz	r0, 0x7009d6da <Sciclient_service+0xea> @ imm = #0xa
7009d6ce: e7ff         	b	0x7009d6d0 <Sciclient_service+0xe0> @ imm = #-0x2
;                 txPayloadSize = pReqPrm->reqPayloadSize - sizeof(struct tisci_header);
7009d6d0: 9813         	ldr	r0, [sp, #0x4c]
7009d6d2: 68c0         	ldr	r0, [r0, #0xc]
7009d6d4: 3808         	subs	r0, #0x8
7009d6d6: 900d         	str	r0, [sp, #0x34]
;             }
7009d6d8: e002         	b	0x7009d6e0 <Sciclient_service+0xf0> @ imm = #0x4
7009d6da: 2000         	movs	r0, #0x0
;                 txPayloadSize = 0U;
7009d6dc: 900d         	str	r0, [sp, #0x34]
7009d6de: e7ff         	b	0x7009d6e0 <Sciclient_service+0xf0> @ imm = #-0x2
;             if (txPayloadSize > (gSciclientHandle.maxMsgSizeBytes - sizeof(struct tisci_header)))
7009d6e0: 980d         	ldr	r0, [sp, #0x34]
7009d6e2: f642 1158    	movw	r1, #0x2958
7009d6e6: f2c7 010b    	movt	r1, #0x700b
7009d6ea: 6949         	ldr	r1, [r1, #0x14]
7009d6ec: 3908         	subs	r1, #0x8
7009d6ee: 4288         	cmp	r0, r1
7009d6f0: d904         	bls	0x7009d6fc <Sciclient_service+0x10c> @ imm = #0x8
7009d6f2: e7ff         	b	0x7009d6f4 <Sciclient_service+0x104> @ imm = #-0x2
7009d6f4: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d6f8: 9011         	str	r0, [sp, #0x44]
;             }
7009d6fa: e7ff         	b	0x7009d6fc <Sciclient_service+0x10c> @ imm = #-0x2
;             if ((txPayloadSize > 0U) && (pReqPrm->pReqPayload == NULL))
7009d6fc: 980d         	ldr	r0, [sp, #0x34]
7009d6fe: b140         	cbz	r0, 0x7009d712 <Sciclient_service+0x122> @ imm = #0x10
7009d700: e7ff         	b	0x7009d702 <Sciclient_service+0x112> @ imm = #-0x2
7009d702: 9813         	ldr	r0, [sp, #0x4c]
7009d704: 6880         	ldr	r0, [r0, #0x8]
7009d706: b920         	cbnz	r0, 0x7009d712 <Sciclient_service+0x122> @ imm = #0x8
7009d708: e7ff         	b	0x7009d70a <Sciclient_service+0x11a> @ imm = #-0x2
7009d70a: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d70e: 9011         	str	r0, [sp, #0x44]
;             }
7009d710: e7ff         	b	0x7009d712 <Sciclient_service+0x122> @ imm = #-0x2
;             if (pRespPrm->respPayloadSize > 0U)
7009d712: 9812         	ldr	r0, [sp, #0x48]
7009d714: 6880         	ldr	r0, [r0, #0x8]
7009d716: b128         	cbz	r0, 0x7009d724 <Sciclient_service+0x134> @ imm = #0xa
7009d718: e7ff         	b	0x7009d71a <Sciclient_service+0x12a> @ imm = #-0x2
;                 rxPayloadSize = pRespPrm->respPayloadSize - sizeof(struct tisci_header);
7009d71a: 9812         	ldr	r0, [sp, #0x48]
7009d71c: 6880         	ldr	r0, [r0, #0x8]
7009d71e: 3808         	subs	r0, #0x8
7009d720: 900c         	str	r0, [sp, #0x30]
;             }
7009d722: e002         	b	0x7009d72a <Sciclient_service+0x13a> @ imm = #0x4
7009d724: 2000         	movs	r0, #0x0
;                 rxPayloadSize = 0U;
7009d726: 900c         	str	r0, [sp, #0x30]
7009d728: e7ff         	b	0x7009d72a <Sciclient_service+0x13a> @ imm = #-0x2
;             if (rxPayloadSize > (gSciclientHandle.maxMsgSizeBytes - sizeof(struct tisci_header)))
7009d72a: 980c         	ldr	r0, [sp, #0x30]
7009d72c: f642 1158    	movw	r1, #0x2958
7009d730: f2c7 010b    	movt	r1, #0x700b
7009d734: 6949         	ldr	r1, [r1, #0x14]
7009d736: 3908         	subs	r1, #0x8
7009d738: 4288         	cmp	r0, r1
7009d73a: d904         	bls	0x7009d746 <Sciclient_service+0x156> @ imm = #0x8
7009d73c: e7ff         	b	0x7009d73e <Sciclient_service+0x14e> @ imm = #-0x2
7009d73e: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d742: 9011         	str	r0, [sp, #0x44]
;             }
7009d744: e7ff         	b	0x7009d746 <Sciclient_service+0x156> @ imm = #-0x2
;             if ((rxPayloadSize > 0U) && (pRespPrm->pRespPayload == NULL))
7009d746: 980c         	ldr	r0, [sp, #0x30]
7009d748: b140         	cbz	r0, 0x7009d75c <Sciclient_service+0x16c> @ imm = #0x10
7009d74a: e7ff         	b	0x7009d74c <Sciclient_service+0x15c> @ imm = #-0x2
7009d74c: 9812         	ldr	r0, [sp, #0x48]
7009d74e: 6840         	ldr	r0, [r0, #0x4]
7009d750: b920         	cbnz	r0, 0x7009d75c <Sciclient_service+0x16c> @ imm = #0x8
7009d752: e7ff         	b	0x7009d754 <Sciclient_service+0x164> @ imm = #-0x2
7009d754: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d758: 9011         	str	r0, [sp, #0x44]
;             }
7009d75a: e004         	b	0x7009d766 <Sciclient_service+0x176> @ imm = #0x8
;                 pLocalRespPayload = (uint8_t *)(pRespPrm->pRespPayload + sizeof(struct tisci_header));
7009d75c: 9812         	ldr	r0, [sp, #0x48]
7009d75e: 6840         	ldr	r0, [r0, #0x4]
7009d760: 3008         	adds	r0, #0x8
7009d762: 900b         	str	r0, [sp, #0x2c]
7009d764: e7ff         	b	0x7009d766 <Sciclient_service+0x176> @ imm = #-0x2
;         }
7009d766: e003         	b	0x7009d770 <Sciclient_service+0x180> @ imm = #0x6
7009d768: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009d76c: 9011         	str	r0, [sp, #0x44]
7009d76e: e7ff         	b	0x7009d770 <Sciclient_service+0x180> @ imm = #-0x2
7009d770: e7ff         	b	0x7009d772 <Sciclient_service+0x182> @ imm = #-0x2
;     key = HwiP_disable();
7009d772: f013 e8f6    	blx	0x700b0960 <HwiP_disable> @ imm = #0x131ec
7009d776: 9008         	str	r0, [sp, #0x20]
;     if (SystemP_SUCCESS == status)
7009d778: 9811         	ldr	r0, [sp, #0x44]
7009d77a: 2800         	cmp	r0, #0x0
7009d77c: d159         	bne	0x7009d832 <Sciclient_service+0x242> @ imm = #0xb2
7009d77e: e7ff         	b	0x7009d780 <Sciclient_service+0x190> @ imm = #-0x2
;         Sciclient_secProxyFlush(rxThread);
7009d780: 9809         	ldr	r0, [sp, #0x24]
7009d782: f010 fde5    	bl	0x700ae350 <Sciclient_secProxyFlush> @ imm = #0x10bca
;         header = (struct tisci_header*)pReqPrm->pReqPayload;
7009d786: 9813         	ldr	r0, [sp, #0x4c]
7009d788: 6880         	ldr	r0, [r0, #0x8]
7009d78a: 9006         	str	r0, [sp, #0x18]
;         header->type = pReqPrm->messageType;
7009d78c: 9813         	ldr	r0, [sp, #0x4c]
7009d78e: 8800         	ldrh	r0, [r0]
7009d790: 9906         	ldr	r1, [sp, #0x18]
7009d792: 8008         	strh	r0, [r1]
;         header->host = (uint8_t) gSciclientMap[contextId].hostId;
7009d794: 9810         	ldr	r0, [sp, #0x40]
7009d796: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009d79a: f241 3060    	movw	r0, #0x1360
7009d79e: f2c7 000b    	movt	r0, #0x700b
7009d7a2: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009d7a6: 6840         	ldr	r0, [r0, #0x4]
7009d7a8: 9906         	ldr	r1, [sp, #0x18]
7009d7aa: 7088         	strb	r0, [r1, #0x2]
;         header->seq = localSeqId;
7009d7ac: f89d 003b    	ldrb.w	r0, [sp, #0x3b]
7009d7b0: 9906         	ldr	r1, [sp, #0x18]
7009d7b2: 70c8         	strb	r0, [r1, #0x3]
;         pFlags = (uint8_t*)&pReqPrm->flags;
7009d7b4: 9813         	ldr	r0, [sp, #0x4c]
7009d7b6: 3004         	adds	r0, #0x4
7009d7b8: 9004         	str	r0, [sp, #0x10]
7009d7ba: 2000         	movs	r0, #0x0
;         for (numBytes = 0; numBytes < sizeof(pReqPrm->flags); numBytes++)
7009d7bc: 9003         	str	r0, [sp, #0xc]
7009d7be: e7ff         	b	0x7009d7c0 <Sciclient_service+0x1d0> @ imm = #-0x2
7009d7c0: 9803         	ldr	r0, [sp, #0xc]
7009d7c2: 2803         	cmp	r0, #0x3
7009d7c4: d811         	bhi	0x7009d7ea <Sciclient_service+0x1fa> @ imm = #0x22
7009d7c6: e7ff         	b	0x7009d7c8 <Sciclient_service+0x1d8> @ imm = #-0x2
;             uint8_t *pDestFlags = ((uint8_t*)&header->flags) + numBytes;
7009d7c8: 9806         	ldr	r0, [sp, #0x18]
7009d7ca: 9903         	ldr	r1, [sp, #0xc]
7009d7cc: 4408         	add	r0, r1
7009d7ce: 3004         	adds	r0, #0x4
7009d7d0: 9002         	str	r0, [sp, #0x8]
;             *pDestFlags = *pFlags;
7009d7d2: 9804         	ldr	r0, [sp, #0x10]
7009d7d4: 7800         	ldrb	r0, [r0]
7009d7d6: 9902         	ldr	r1, [sp, #0x8]
7009d7d8: 7008         	strb	r0, [r1]
;             pFlags++;
7009d7da: 9804         	ldr	r0, [sp, #0x10]
7009d7dc: 3001         	adds	r0, #0x1
7009d7de: 9004         	str	r0, [sp, #0x10]
;         }
7009d7e0: e7ff         	b	0x7009d7e2 <Sciclient_service+0x1f2> @ imm = #-0x2
;         for (numBytes = 0; numBytes < sizeof(pReqPrm->flags); numBytes++)
7009d7e2: 9803         	ldr	r0, [sp, #0xc]
7009d7e4: 3001         	adds	r0, #0x1
7009d7e6: 9003         	str	r0, [sp, #0xc]
7009d7e8: e7ea         	b	0x7009d7c0 <Sciclient_service+0x1d0> @ imm = #-0x2c
;         gSciclientHandle.currSeqId = (gSciclientHandle.currSeqId + 1U) %
7009d7ea: f642 1158    	movw	r1, #0x2958
7009d7ee: f2c7 010b    	movt	r1, #0x700b
7009d7f2: 6808         	ldr	r0, [r1]
7009d7f4: 3001         	adds	r0, #0x1
7009d7f6: f644 1225    	movw	r2, #0x4925
7009d7fa: f2c2 4292    	movt	r2, #0x2492
7009d7fe: fba0 3202    	umull	r3, r2, r0, r2
7009d802: 1a83         	subs	r3, r0, r2
7009d804: eb02 0353    	add.w	r3, r2, r3, lsr #1
7009d808: 089a         	lsrs	r2, r3, #0x2
7009d80a: 00d2         	lsls	r2, r2, #0x3
7009d80c: eba2 0293    	sub.w	r2, r2, r3, lsr #2
7009d810: 1a80         	subs	r0, r0, r2
7009d812: 6008         	str	r0, [r1]
;         status = Sciclient_secProxyVerifyThread(txThread);
7009d814: 980a         	ldr	r0, [sp, #0x28]
7009d816: f011 fb53    	bl	0x700aeec0 <Sciclient_secProxyVerifyThread> @ imm = #0x116a6
7009d81a: 9011         	str	r0, [sp, #0x44]
;         if (SystemP_SUCCESS == status)
7009d81c: 9811         	ldr	r0, [sp, #0x44]
7009d81e: b938         	cbnz	r0, 0x7009d830 <Sciclient_service+0x240> @ imm = #0xe
7009d820: e7ff         	b	0x7009d822 <Sciclient_service+0x232> @ imm = #-0x2
;             status = Sciclient_secProxyWaitThread(txThread, pReqPrm->timeout);
7009d822: 980a         	ldr	r0, [sp, #0x28]
7009d824: 9913         	ldr	r1, [sp, #0x4c]
7009d826: 6909         	ldr	r1, [r1, #0x10]
7009d828: f010 fab2    	bl	0x700add90 <Sciclient_secProxyWaitThread> @ imm = #0x10564
7009d82c: 9011         	str	r0, [sp, #0x44]
;         }
7009d82e: e7ff         	b	0x7009d830 <Sciclient_service+0x240> @ imm = #-0x2
;     }
7009d830: e7ff         	b	0x7009d832 <Sciclient_service+0x242> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
7009d832: 9811         	ldr	r0, [sp, #0x44]
7009d834: b9b0         	cbnz	r0, 0x7009d864 <Sciclient_service+0x274> @ imm = #0x2c
7009d836: e7ff         	b	0x7009d838 <Sciclient_service+0x248> @ imm = #-0x2
;         initialCount = Sciclient_secProxyReadThreadCount(rxThread);
7009d838: 9809         	ldr	r0, [sp, #0x24]
7009d83a: f012 f831    	bl	0x700af8a0 <Sciclient_secProxyReadThreadCount> @ imm = #0x12062
7009d83e: 900f         	str	r0, [sp, #0x3c]
;         Sciclient_sendMessage(txThread, pSecHeader ,(uint8_t *) header,
7009d840: 980a         	ldr	r0, [sp, #0x28]
7009d842: 9907         	ldr	r1, [sp, #0x1c]
7009d844: 9a06         	ldr	r2, [sp, #0x18]
;                               (pReqPrm->pReqPayload + sizeof(struct tisci_header)),
7009d846: 9b13         	ldr	r3, [sp, #0x4c]
7009d848: 689b         	ldr	r3, [r3, #0x8]
7009d84a: 3308         	adds	r3, #0x8
;                               txPayloadSize);
7009d84c: f8dd c034    	ldr.w	r12, [sp, #0x34]
;         Sciclient_sendMessage(txThread, pSecHeader ,(uint8_t *) header,
7009d850: 46ee         	mov	lr, sp
7009d852: f8ce c000    	str.w	r12, [lr]
7009d856: f004 ff1b    	bl	0x700a2690 <Sciclient_sendMessage> @ imm = #0x4e36
;         status = Sciclient_secProxyVerifyThread(rxThread);
7009d85a: 9809         	ldr	r0, [sp, #0x24]
7009d85c: f011 fb30    	bl	0x700aeec0 <Sciclient_secProxyVerifyThread> @ imm = #0x11660
7009d860: 9011         	str	r0, [sp, #0x44]
;     }
7009d862: e7ff         	b	0x7009d864 <Sciclient_service+0x274> @ imm = #-0x2
;     if ((status == SystemP_SUCCESS) &&
7009d864: 9811         	ldr	r0, [sp, #0x44]
7009d866: b978         	cbnz	r0, 0x7009d888 <Sciclient_service+0x298> @ imm = #0x1e
7009d868: e7ff         	b	0x7009d86a <Sciclient_service+0x27a> @ imm = #-0x2
;         ((pReqPrm->flags & TISCI_MSG_FLAG_MASK) != 0U))
7009d86a: 9813         	ldr	r0, [sp, #0x4c]
;     if ((status == SystemP_SUCCESS) &&
7009d86c: 7900         	ldrb	r0, [r0, #0x4]
7009d86e: 0780         	lsls	r0, r0, #0x1e
7009d870: b150         	cbz	r0, 0x7009d888 <Sciclient_service+0x298> @ imm = #0x14
7009d872: e7ff         	b	0x7009d874 <Sciclient_service+0x284> @ imm = #-0x2
;         status = Sciclient_waitForMessage(rxThread, pReqPrm->timeout, initialCount, localSeqId);
7009d874: 9809         	ldr	r0, [sp, #0x24]
7009d876: 9913         	ldr	r1, [sp, #0x4c]
7009d878: 6909         	ldr	r1, [r1, #0x10]
7009d87a: 9a0f         	ldr	r2, [sp, #0x3c]
7009d87c: f89d 303b    	ldrb.w	r3, [sp, #0x3b]
7009d880: f008 fc1e    	bl	0x700a60c0 <Sciclient_waitForMessage> @ imm = #0x883c
7009d884: 9011         	str	r0, [sp, #0x44]
;     }
7009d886: e7ff         	b	0x7009d888 <Sciclient_service+0x298> @ imm = #-0x2
;     if(status == SystemP_SUCCESS)
7009d888: 9811         	ldr	r0, [sp, #0x44]
7009d88a: b990         	cbnz	r0, 0x7009d8b2 <Sciclient_service+0x2c2> @ imm = #0x24
7009d88c: e7ff         	b	0x7009d88e <Sciclient_service+0x29e> @ imm = #-0x2
;         pRespPrm->flags = Sciclient_secProxyReadThread32(rxThread, 1U+gSecHeaderSizeWords);
7009d88e: 9809         	ldr	r0, [sp, #0x24]
7009d890: f642 2164    	movw	r1, #0x2a64
7009d894: f2c7 010b    	movt	r1, #0x700b
7009d898: 7809         	ldrb	r1, [r1]
7009d89a: 3101         	adds	r1, #0x1
7009d89c: b2c9         	uxtb	r1, r1
7009d89e: f011 f86f    	bl	0x700ae980 <Sciclient_secProxyReadThread32> @ imm = #0x110de
7009d8a2: 9912         	ldr	r1, [sp, #0x48]
7009d8a4: 6008         	str	r0, [r1]
;         Sciclient_recvMessage(rxThread, pLocalRespPayload, rxPayloadSize);
7009d8a6: 9809         	ldr	r0, [sp, #0x24]
7009d8a8: 990b         	ldr	r1, [sp, #0x2c]
7009d8aa: 9a0c         	ldr	r2, [sp, #0x30]
7009d8ac: f005 fbf8    	bl	0x700a30a0 <Sciclient_recvMessage> @ imm = #0x57f0
;     }
7009d8b0: e7ff         	b	0x7009d8b2 <Sciclient_service+0x2c2> @ imm = #-0x2
;     HwiP_restore(key);
7009d8b2: 9808         	ldr	r0, [sp, #0x20]
7009d8b4: f013 e874    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x130e8
;     return status;
7009d8b8: 9811         	ldr	r0, [sp, #0x44]
7009d8ba: b014         	add	sp, #0x50
7009d8bc: bd80         	pop	{r7, pc}
7009d8be: 0000         	movs	r0, r0

7009d8c0 <Udma_chDisableRxChan>:
; {
7009d8c0: b580         	push	{r7, lr}
7009d8c2: b096         	sub	sp, #0x58
7009d8c4: 9015         	str	r0, [sp, #0x54]
7009d8c6: 9114         	str	r1, [sp, #0x50]
7009d8c8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009d8ca: 9013         	str	r0, [sp, #0x4c]
;     uint32_t            currTimeout = 0U, regVal;
7009d8cc: 9012         	str	r0, [sp, #0x48]
;     uint32_t            peerRtEnable = 0U, peerRtEnableBit = 0U;
7009d8ce: 9004         	str	r0, [sp, #0x10]
7009d8d0: 9003         	str	r0, [sp, #0xc]
;     drvHandle = chHandle->drvHandle;
7009d8d2: 9815         	ldr	r0, [sp, #0x54]
7009d8d4: 6e80         	ldr	r0, [r0, #0x68]
7009d8d6: 9010         	str	r0, [sp, #0x40]
7009d8d8: 2008         	movs	r0, #0x8
;     rtEnableRegOffset = CSL_PSILCFG_REG_RT_ENABLE - CSL_PSILCFG_REG_STATIC_TR;
7009d8da: 9002         	str	r0, [sp, #0x8]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d8dc: 9810         	ldr	r0, [sp, #0x40]
7009d8de: 6800         	ldr	r0, [r0]
7009d8e0: 2801         	cmp	r0, #0x1
7009d8e2: d115         	bne	0x7009d910 <Udma_chDisableRxChan+0x50> @ imm = #0x2a
7009d8e4: e7ff         	b	0x7009d8e6 <Udma_chDisableRxChan+0x26> @ imm = #-0x2
;         regVal = CSL_REG32_RD(&chHandle->pBcdmaRxRtRegs->PEER8);
7009d8e6: 9815         	ldr	r0, [sp, #0x54]
7009d8e8: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009d8ec: f500 7008    	add.w	r0, r0, #0x220
7009d8f0: f012 f9b6    	bl	0x700afc60 <CSL_REG32_RD_RAW> @ imm = #0x1236c
7009d8f4: 9011         	str	r0, [sp, #0x44]
;         CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 1U);
7009d8f6: 9811         	ldr	r0, [sp, #0x44]
7009d8f8: f040 4080    	orr	r0, r0, #0x40000000
7009d8fc: 9011         	str	r0, [sp, #0x44]
;         CSL_REG32_WR(&chHandle->pBcdmaRxRtRegs->PEER8, regVal);
7009d8fe: 9815         	ldr	r0, [sp, #0x54]
7009d900: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009d904: f500 7008    	add.w	r0, r0, #0x220
7009d908: 9911         	ldr	r1, [sp, #0x44]
7009d90a: f012 f909    	bl	0x700afb20 <CSL_REG32_WR_RAW> @ imm = #0x12212
;     }
7009d90e: e01a         	b	0x7009d946 <Udma_chDisableRxChan+0x86> @ imm = #0x34
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d910: 9810         	ldr	r0, [sp, #0x40]
7009d912: 6800         	ldr	r0, [r0]
7009d914: 2802         	cmp	r0, #0x2
7009d916: d115         	bne	0x7009d944 <Udma_chDisableRxChan+0x84> @ imm = #0x2a
7009d918: e7ff         	b	0x7009d91a <Udma_chDisableRxChan+0x5a> @ imm = #-0x2
;         regVal = CSL_REG32_RD(&chHandle->pPktdmaRxRtRegs->PEER8);
7009d91a: 9815         	ldr	r0, [sp, #0x54]
7009d91c: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009d920: f500 7008    	add.w	r0, r0, #0x220
7009d924: f012 f99c    	bl	0x700afc60 <CSL_REG32_RD_RAW> @ imm = #0x12338
7009d928: 9011         	str	r0, [sp, #0x44]
;         CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 1U);
7009d92a: 9811         	ldr	r0, [sp, #0x44]
7009d92c: f040 4080    	orr	r0, r0, #0x40000000
7009d930: 9011         	str	r0, [sp, #0x44]
;         CSL_REG32_WR(&chHandle->pPktdmaRxRtRegs->PEER8, regVal);
7009d932: 9815         	ldr	r0, [sp, #0x54]
7009d934: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009d938: f500 7008    	add.w	r0, r0, #0x220
7009d93c: 9911         	ldr	r1, [sp, #0x44]
7009d93e: f012 f8ef    	bl	0x700afb20 <CSL_REG32_WR_RAW> @ imm = #0x121de
;     }
7009d942: e7ff         	b	0x7009d944 <Udma_chDisableRxChan+0x84> @ imm = #-0x2
7009d944: e7ff         	b	0x7009d946 <Udma_chDisableRxChan+0x86> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009d946: e7ff         	b	0x7009d948 <Udma_chDisableRxChan+0x88> @ imm = #-0x2
7009d948: 9813         	ldr	r0, [sp, #0x4c]
7009d94a: bbc8         	cbnz	r0, 0x7009d9c0 <Udma_chDisableRxChan+0x100> @ imm = #0x72
7009d94c: e7ff         	b	0x7009d94e <Udma_chDisableRxChan+0x8e> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d94e: 9810         	ldr	r0, [sp, #0x40]
7009d950: 6800         	ldr	r0, [r0]
7009d952: 2801         	cmp	r0, #0x1
7009d954: d110         	bne	0x7009d978 <Udma_chDisableRxChan+0xb8> @ imm = #0x20
7009d956: e7ff         	b	0x7009d958 <Udma_chDisableRxChan+0x98> @ imm = #-0x2
;             (void) CSL_bcdmaGetRxRT(&drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009d958: 9a10         	ldr	r2, [sp, #0x40]
7009d95a: f102 0008    	add.w	r0, r2, #0x8
7009d95e: 9915         	ldr	r1, [sp, #0x54]
7009d960: 6f09         	ldr	r1, [r1, #0x70]
7009d962: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d966: 4411         	add	r1, r2
7009d968: aa0a         	add	r2, sp, #0x28
7009d96a: f011 f8b1    	bl	0x700aead0 <CSL_bcdmaGetRxRT> @ imm = #0x11162
;             if(FALSE == bcdmaRtStatus.enable)
7009d96e: 980a         	ldr	r0, [sp, #0x28]
7009d970: b908         	cbnz	r0, 0x7009d976 <Udma_chDisableRxChan+0xb6> @ imm = #0x2
7009d972: e7ff         	b	0x7009d974 <Udma_chDisableRxChan+0xb4> @ imm = #-0x2
;                 break;
7009d974: e024         	b	0x7009d9c0 <Udma_chDisableRxChan+0x100> @ imm = #0x48
;         }
7009d976: e011         	b	0x7009d99c <Udma_chDisableRxChan+0xdc> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d978: 9810         	ldr	r0, [sp, #0x40]
7009d97a: 6800         	ldr	r0, [r0]
7009d97c: 2802         	cmp	r0, #0x2
7009d97e: d10c         	bne	0x7009d99a <Udma_chDisableRxChan+0xda> @ imm = #0x18
7009d980: e7ff         	b	0x7009d982 <Udma_chDisableRxChan+0xc2> @ imm = #-0x2
;             (void) CSL_pktdmaGetRxRT(&drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009d982: 9810         	ldr	r0, [sp, #0x40]
7009d984: 3054         	adds	r0, #0x54
7009d986: 9915         	ldr	r1, [sp, #0x54]
7009d988: 6f09         	ldr	r1, [r1, #0x70]
7009d98a: aa05         	add	r2, sp, #0x14
7009d98c: f00f fd40    	bl	0x700ad410 <CSL_pktdmaGetRxRT> @ imm = #0xfa80
;             if(FALSE == pktdmaRtStatus.enable)
7009d990: 9805         	ldr	r0, [sp, #0x14]
7009d992: b908         	cbnz	r0, 0x7009d998 <Udma_chDisableRxChan+0xd8> @ imm = #0x2
7009d994: e7ff         	b	0x7009d996 <Udma_chDisableRxChan+0xd6> @ imm = #-0x2
;                 break;
7009d996: e013         	b	0x7009d9c0 <Udma_chDisableRxChan+0x100> @ imm = #0x26
;         }
7009d998: e7ff         	b	0x7009d99a <Udma_chDisableRxChan+0xda> @ imm = #-0x2
7009d99a: e7ff         	b	0x7009d99c <Udma_chDisableRxChan+0xdc> @ imm = #-0x2
;         if(currTimeout > timeout)
7009d99c: 9812         	ldr	r0, [sp, #0x48]
7009d99e: 9914         	ldr	r1, [sp, #0x50]
7009d9a0: 4288         	cmp	r0, r1
7009d9a2: d904         	bls	0x7009d9ae <Udma_chDisableRxChan+0xee> @ imm = #0x8
7009d9a4: e7ff         	b	0x7009d9a6 <Udma_chDisableRxChan+0xe6> @ imm = #-0x2
7009d9a6: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009d9aa: 9013         	str	r0, [sp, #0x4c]
;         }
7009d9ac: e007         	b	0x7009d9be <Udma_chDisableRxChan+0xfe> @ imm = #0xe
7009d9ae: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009d9b2: f00d fbed    	bl	0x700ab190 <ClockP_usleep> @ imm = #0xd7da
;             currTimeout++;
7009d9b6: 9812         	ldr	r0, [sp, #0x48]
7009d9b8: 3001         	adds	r0, #0x1
7009d9ba: 9012         	str	r0, [sp, #0x48]
7009d9bc: e7ff         	b	0x7009d9be <Udma_chDisableRxChan+0xfe> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009d9be: e7c3         	b	0x7009d948 <Udma_chDisableRxChan+0x88> @ imm = #-0x7a
;     if(UDMA_SOK != retVal)
7009d9c0: 9813         	ldr	r0, [sp, #0x4c]
7009d9c2: 2800         	cmp	r0, #0x0
7009d9c4: f000 8091    	beq.w	0x7009daea <Udma_chDisableRxChan+0x22a> @ imm = #0x122
7009d9c8: e7ff         	b	0x7009d9ca <Udma_chDisableRxChan+0x10a> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d9ca: 9810         	ldr	r0, [sp, #0x40]
7009d9cc: 6800         	ldr	r0, [r0]
7009d9ce: 2801         	cmp	r0, #0x1
7009d9d0: d10e         	bne	0x7009d9f0 <Udma_chDisableRxChan+0x130> @ imm = #0x1c
7009d9d2: e7ff         	b	0x7009d9d4 <Udma_chDisableRxChan+0x114> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, (bool)true, (bool)false);
7009d9d4: 9a10         	ldr	r2, [sp, #0x40]
7009d9d6: f102 0008    	add.w	r0, r2, #0x8
7009d9da: 9915         	ldr	r1, [sp, #0x54]
7009d9dc: 6f09         	ldr	r1, [r1, #0x70]
7009d9de: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d9e2: 4411         	add	r1, r2
7009d9e4: 2201         	movs	r2, #0x1
7009d9e6: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownRxChan(
7009d9e8: f00f fec2    	bl	0x700ad770 <CSL_bcdmaTeardownRxChan> @ imm = #0xfd84
7009d9ec: 9013         	str	r0, [sp, #0x4c]
;         }
7009d9ee: e00f         	b	0x7009da10 <Udma_chDisableRxChan+0x150> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d9f0: 9810         	ldr	r0, [sp, #0x40]
7009d9f2: 6800         	ldr	r0, [r0]
7009d9f4: 2802         	cmp	r0, #0x2
7009d9f6: d10a         	bne	0x7009da0e <Udma_chDisableRxChan+0x14e> @ imm = #0x14
7009d9f8: e7ff         	b	0x7009d9fa <Udma_chDisableRxChan+0x13a> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->rxChNum, (bool)true, (bool)false);
7009d9fa: 9810         	ldr	r0, [sp, #0x40]
7009d9fc: 3054         	adds	r0, #0x54
7009d9fe: 9915         	ldr	r1, [sp, #0x54]
7009da00: 6f09         	ldr	r1, [r1, #0x70]
7009da02: 2201         	movs	r2, #0x1
7009da04: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownRxChan(
7009da06: f010 fd63    	bl	0x700ae4d0 <CSL_pktdmaTeardownRxChan> @ imm = #0x10ac6
7009da0a: 9013         	str	r0, [sp, #0x4c]
;         }
7009da0c: e7ff         	b	0x7009da0e <Udma_chDisableRxChan+0x14e> @ imm = #-0x2
7009da0e: e7ff         	b	0x7009da10 <Udma_chDisableRxChan+0x150> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009da10: 9813         	ldr	r0, [sp, #0x4c]
7009da12: b108         	cbz	r0, 0x7009da18 <Udma_chDisableRxChan+0x158> @ imm = #0x2
7009da14: e7ff         	b	0x7009da16 <Udma_chDisableRxChan+0x156> @ imm = #-0x2
;         }
7009da16: e7ff         	b	0x7009da18 <Udma_chDisableRxChan+0x158> @ imm = #-0x2
7009da18: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009da1a: 9012         	str	r0, [sp, #0x48]
;         while(UDMA_SOK == retVal)
7009da1c: e7ff         	b	0x7009da1e <Udma_chDisableRxChan+0x15e> @ imm = #-0x2
7009da1e: 9813         	ldr	r0, [sp, #0x4c]
7009da20: 2800         	cmp	r0, #0x0
7009da22: d161         	bne	0x7009dae8 <Udma_chDisableRxChan+0x228> @ imm = #0xc2
7009da24: e7ff         	b	0x7009da26 <Udma_chDisableRxChan+0x166> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009da26: 9810         	ldr	r0, [sp, #0x40]
7009da28: 6800         	ldr	r0, [r0]
7009da2a: 2801         	cmp	r0, #0x1
7009da2c: d126         	bne	0x7009da7c <Udma_chDisableRxChan+0x1bc> @ imm = #0x4c
7009da2e: e7ff         	b	0x7009da30 <Udma_chDisableRxChan+0x170> @ imm = #-0x2
;                 (void) CSL_bcdmaGetRxRT(&drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009da30: 9a10         	ldr	r2, [sp, #0x40]
7009da32: f102 0008    	add.w	r0, r2, #0x8
7009da36: 9915         	ldr	r1, [sp, #0x54]
7009da38: 6f09         	ldr	r1, [r1, #0x70]
7009da3a: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009da3e: 4411         	add	r1, r2
7009da40: aa0a         	add	r2, sp, #0x28
7009da42: f011 f845    	bl	0x700aead0 <CSL_bcdmaGetRxRT> @ imm = #0x1108a
;                     &drvHandle->bcdmaRegs,
7009da46: 9a10         	ldr	r2, [sp, #0x40]
7009da48: f102 0008    	add.w	r0, r2, #0x8
;                     chHandle->rxChNum + drvHandle->rxChOffset,
7009da4c: 9915         	ldr	r1, [sp, #0x54]
7009da4e: 6f09         	ldr	r1, [r1, #0x70]
7009da50: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009da54: 4411         	add	r1, r2
;                     rtEnableRegOffset, &peerRtEnable);
7009da56: 9b02         	ldr	r3, [sp, #0x8]
;                 (void) CSL_bcdmaGetChanPeerReg(
7009da58: 46ec         	mov	r12, sp
7009da5a: aa04         	add	r2, sp, #0x10
7009da5c: f8cc 2000    	str.w	r2, [r12]
7009da60: 2201         	movs	r2, #0x1
7009da62: f00f ff75    	bl	0x700ad950 <CSL_bcdmaGetChanPeerReg> @ imm = #0xfeea
;                 peerRtEnableBit = CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE);
7009da66: 9804         	ldr	r0, [sp, #0x10]
7009da68: 0fc0         	lsrs	r0, r0, #0x1f
7009da6a: 9003         	str	r0, [sp, #0xc]
;                 if((FALSE == bcdmaRtStatus.enable) && (FALSE == peerRtEnableBit))
7009da6c: 980a         	ldr	r0, [sp, #0x28]
7009da6e: b920         	cbnz	r0, 0x7009da7a <Udma_chDisableRxChan+0x1ba> @ imm = #0x8
7009da70: e7ff         	b	0x7009da72 <Udma_chDisableRxChan+0x1b2> @ imm = #-0x2
7009da72: 9803         	ldr	r0, [sp, #0xc]
7009da74: b908         	cbnz	r0, 0x7009da7a <Udma_chDisableRxChan+0x1ba> @ imm = #0x2
7009da76: e7ff         	b	0x7009da78 <Udma_chDisableRxChan+0x1b8> @ imm = #-0x2
;                     break;
7009da78: e036         	b	0x7009dae8 <Udma_chDisableRxChan+0x228> @ imm = #0x6c
;             }
7009da7a: e023         	b	0x7009dac4 <Udma_chDisableRxChan+0x204> @ imm = #0x46
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009da7c: 9810         	ldr	r0, [sp, #0x40]
7009da7e: 6800         	ldr	r0, [r0]
7009da80: 2802         	cmp	r0, #0x2
7009da82: d11e         	bne	0x7009dac2 <Udma_chDisableRxChan+0x202> @ imm = #0x3c
7009da84: e7ff         	b	0x7009da86 <Udma_chDisableRxChan+0x1c6> @ imm = #-0x2
;                 (void) CSL_pktdmaGetRxRT(&drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009da86: 9810         	ldr	r0, [sp, #0x40]
7009da88: 3054         	adds	r0, #0x54
7009da8a: 9915         	ldr	r1, [sp, #0x54]
7009da8c: 6f09         	ldr	r1, [r1, #0x70]
7009da8e: aa05         	add	r2, sp, #0x14
7009da90: f00f fcbe    	bl	0x700ad410 <CSL_pktdmaGetRxRT> @ imm = #0xf97c
;                     &drvHandle->pktdmaRegs,
7009da94: 9810         	ldr	r0, [sp, #0x40]
7009da96: 3054         	adds	r0, #0x54
;                     chHandle->rxChNum,
7009da98: 9915         	ldr	r1, [sp, #0x54]
7009da9a: 6f09         	ldr	r1, [r1, #0x70]
;                     rtEnableRegOffset, &peerRtEnable);
7009da9c: 9b02         	ldr	r3, [sp, #0x8]
;                 (void) CSL_pktdmaGetChanPeerReg(
7009da9e: 46ec         	mov	r12, sp
7009daa0: aa04         	add	r2, sp, #0x10
7009daa2: f8cc 2000    	str.w	r2, [r12]
7009daa6: 2201         	movs	r2, #0x1
7009daa8: f010 feaa    	bl	0x700ae800 <CSL_pktdmaGetChanPeerReg> @ imm = #0x10d54
;                 peerRtEnableBit = CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE);
7009daac: 9804         	ldr	r0, [sp, #0x10]
7009daae: 0fc0         	lsrs	r0, r0, #0x1f
7009dab0: 9003         	str	r0, [sp, #0xc]
;                 if((FALSE == pktdmaRtStatus.enable) && (FALSE == peerRtEnableBit))
7009dab2: 9805         	ldr	r0, [sp, #0x14]
7009dab4: b920         	cbnz	r0, 0x7009dac0 <Udma_chDisableRxChan+0x200> @ imm = #0x8
7009dab6: e7ff         	b	0x7009dab8 <Udma_chDisableRxChan+0x1f8> @ imm = #-0x2
7009dab8: 9803         	ldr	r0, [sp, #0xc]
7009daba: b908         	cbnz	r0, 0x7009dac0 <Udma_chDisableRxChan+0x200> @ imm = #0x2
7009dabc: e7ff         	b	0x7009dabe <Udma_chDisableRxChan+0x1fe> @ imm = #-0x2
;                     break;
7009dabe: e013         	b	0x7009dae8 <Udma_chDisableRxChan+0x228> @ imm = #0x26
;             }
7009dac0: e7ff         	b	0x7009dac2 <Udma_chDisableRxChan+0x202> @ imm = #-0x2
7009dac2: e7ff         	b	0x7009dac4 <Udma_chDisableRxChan+0x204> @ imm = #-0x2
;             if(currTimeout > timeout)
7009dac4: 9812         	ldr	r0, [sp, #0x48]
7009dac6: 9914         	ldr	r1, [sp, #0x50]
7009dac8: 4288         	cmp	r0, r1
7009daca: d904         	bls	0x7009dad6 <Udma_chDisableRxChan+0x216> @ imm = #0x8
7009dacc: e7ff         	b	0x7009dace <Udma_chDisableRxChan+0x20e> @ imm = #-0x2
7009dace: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009dad2: 9013         	str	r0, [sp, #0x4c]
;             }
7009dad4: e007         	b	0x7009dae6 <Udma_chDisableRxChan+0x226> @ imm = #0xe
7009dad6: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009dada: f00d fb59    	bl	0x700ab190 <ClockP_usleep> @ imm = #0xd6b2
;                 currTimeout++;
7009dade: 9812         	ldr	r0, [sp, #0x48]
7009dae0: 3001         	adds	r0, #0x1
7009dae2: 9012         	str	r0, [sp, #0x48]
7009dae4: e7ff         	b	0x7009dae6 <Udma_chDisableRxChan+0x226> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009dae6: e79a         	b	0x7009da1e <Udma_chDisableRxChan+0x15e> @ imm = #-0xcc
;     }
7009dae8: e7ff         	b	0x7009daea <Udma_chDisableRxChan+0x22a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009daea: 9813         	ldr	r0, [sp, #0x4c]
7009daec: 2800         	cmp	r0, #0x0
7009daee: d148         	bne	0x7009db82 <Udma_chDisableRxChan+0x2c2> @ imm = #0x90
7009daf0: e7ff         	b	0x7009daf2 <Udma_chDisableRxChan+0x232> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009daf2: 9810         	ldr	r0, [sp, #0x40]
7009daf4: 6800         	ldr	r0, [r0]
7009daf6: 2801         	cmp	r0, #0x1
7009daf8: d122         	bne	0x7009db40 <Udma_chDisableRxChan+0x280> @ imm = #0x44
7009dafa: e7ff         	b	0x7009dafc <Udma_chDisableRxChan+0x23c> @ imm = #-0x2
7009dafc: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.teardown = FALSE;   /* Note that other bits are cleared from previous call */
7009dafe: 900b         	str	r0, [sp, #0x2c]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) FALSE);
7009db00: 9804         	ldr	r0, [sp, #0x10]
7009db02: f020 4080    	bic	r0, r0, #0x40000000
7009db06: 9004         	str	r0, [sp, #0x10]
;                 &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009db08: 9a10         	ldr	r2, [sp, #0x40]
7009db0a: f102 0008    	add.w	r0, r2, #0x8
7009db0e: 9915         	ldr	r1, [sp, #0x54]
7009db10: 6f09         	ldr	r1, [r1, #0x70]
7009db12: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009db16: 4411         	add	r1, r2
7009db18: aa0a         	add	r2, sp, #0x28
;             (void) CSL_bcdmaSetRxRT(
7009db1a: f011 f809    	bl	0x700aeb30 <CSL_bcdmaSetRxRT> @ imm = #0x11012
;                 &drvHandle->bcdmaRegs,
7009db1e: 9a10         	ldr	r2, [sp, #0x40]
7009db20: f102 0008    	add.w	r0, r2, #0x8
;                 chHandle->rxChNum + drvHandle->rxChOffset,
7009db24: 9915         	ldr	r1, [sp, #0x54]
7009db26: 6f09         	ldr	r1, [r1, #0x70]
7009db28: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009db2c: 4411         	add	r1, r2
;                 rtEnableRegOffset,
7009db2e: 9b02         	ldr	r3, [sp, #0x8]
;             (void) CSL_bcdmaSetChanPeerReg(
7009db30: 46ec         	mov	r12, sp
7009db32: aa04         	add	r2, sp, #0x10
7009db34: f8cc 2000    	str.w	r2, [r12]
7009db38: 2201         	movs	r2, #0x1
7009db3a: f010 f9e9    	bl	0x700adf10 <CSL_bcdmaSetChanPeerReg> @ imm = #0x103d2
;         }
7009db3e: e01f         	b	0x7009db80 <Udma_chDisableRxChan+0x2c0> @ imm = #0x3e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009db40: 9810         	ldr	r0, [sp, #0x40]
7009db42: 6800         	ldr	r0, [r0]
7009db44: 2802         	cmp	r0, #0x2
7009db46: d11a         	bne	0x7009db7e <Udma_chDisableRxChan+0x2be> @ imm = #0x34
7009db48: e7ff         	b	0x7009db4a <Udma_chDisableRxChan+0x28a> @ imm = #-0x2
7009db4a: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.teardown = FALSE;   /* Note that other bits are cleared from previous call */
7009db4c: 9006         	str	r0, [sp, #0x18]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) FALSE);
7009db4e: 9804         	ldr	r0, [sp, #0x10]
7009db50: f020 4080    	bic	r0, r0, #0x40000000
7009db54: 9004         	str	r0, [sp, #0x10]
;                 &drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009db56: 9810         	ldr	r0, [sp, #0x40]
7009db58: 3054         	adds	r0, #0x54
7009db5a: 9915         	ldr	r1, [sp, #0x54]
7009db5c: 6f09         	ldr	r1, [r1, #0x70]
7009db5e: aa05         	add	r2, sp, #0x14
;             (void) CSL_pktdmaSetRxRT(
7009db60: f010 fa16    	bl	0x700adf90 <CSL_pktdmaSetRxRT> @ imm = #0x1042c
;                 &drvHandle->pktdmaRegs,
7009db64: 9810         	ldr	r0, [sp, #0x40]
7009db66: 3054         	adds	r0, #0x54
;                 chHandle->rxChNum,
7009db68: 9915         	ldr	r1, [sp, #0x54]
7009db6a: 6f09         	ldr	r1, [r1, #0x70]
;                 rtEnableRegOffset,
7009db6c: 9b02         	ldr	r3, [sp, #0x8]
;             (void) CSL_pktdmaSetChanPeerReg(
7009db6e: 46ec         	mov	r12, sp
7009db70: aa04         	add	r2, sp, #0x10
7009db72: f8cc 2000    	str.w	r2, [r12]
7009db76: 2201         	movs	r2, #0x1
7009db78: f010 fe5a    	bl	0x700ae830 <CSL_pktdmaSetChanPeerReg> @ imm = #0x10cb4
;         }
7009db7c: e7ff         	b	0x7009db7e <Udma_chDisableRxChan+0x2be> @ imm = #-0x2
7009db7e: e7ff         	b	0x7009db80 <Udma_chDisableRxChan+0x2c0> @ imm = #-0x2
;     }
7009db80: e7ff         	b	0x7009db82 <Udma_chDisableRxChan+0x2c2> @ imm = #-0x2
;     return (retVal);
7009db82: 9813         	ldr	r0, [sp, #0x4c]
7009db84: b016         	add	sp, #0x58
7009db86: bd80         	pop	{r7, pc}
		...

7009db90 <CSL_bcdmaChanOpCfgChan>:
; {
7009db90: b580         	push	{r7, lr}
7009db92: b08a         	sub	sp, #0x28
7009db94: 9009         	str	r0, [sp, #0x24]
7009db96: 9108         	str	r1, [sp, #0x20]
7009db98: 9207         	str	r2, [sp, #0x1c]
7009db9a: 9306         	str	r3, [sp, #0x18]
7009db9c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
7009db9e: 9005         	str	r0, [sp, #0x14]
;     if( pOpData == NULL )
7009dba0: 9806         	ldr	r0, [sp, #0x18]
7009dba2: b920         	cbnz	r0, 0x7009dbae <CSL_bcdmaChanOpCfgChan+0x1e> @ imm = #0x8
7009dba4: e7ff         	b	0x7009dba6 <CSL_bcdmaChanOpCfgChan+0x16> @ imm = #-0x2
7009dba6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
7009dbaa: 9005         	str	r0, [sp, #0x14]
;     }
7009dbac: e137         	b	0x7009de1e <CSL_bcdmaChanOpCfgChan+0x28e> @ imm = #0x26e
;         switch( chanType )
7009dbae: 9808         	ldr	r0, [sp, #0x20]
7009dbb0: 9000         	str	r0, [sp]
7009dbb2: b148         	cbz	r0, 0x7009dbc8 <CSL_bcdmaChanOpCfgChan+0x38> @ imm = #0x12
7009dbb4: e7ff         	b	0x7009dbb6 <CSL_bcdmaChanOpCfgChan+0x26> @ imm = #-0x2
7009dbb6: 9800         	ldr	r0, [sp]
7009dbb8: 2801         	cmp	r0, #0x1
7009dbba: d057         	beq	0x7009dc6c <CSL_bcdmaChanOpCfgChan+0xdc> @ imm = #0xae
7009dbbc: e7ff         	b	0x7009dbbe <CSL_bcdmaChanOpCfgChan+0x2e> @ imm = #-0x2
7009dbbe: 9800         	ldr	r0, [sp]
7009dbc0: 2802         	cmp	r0, #0x2
7009dbc2: f000 80c1    	beq.w	0x7009dd48 <CSL_bcdmaChanOpCfgChan+0x1b8> @ imm = #0x182
7009dbc6: e125         	b	0x7009de14 <CSL_bcdmaChanOpCfgChan+0x284> @ imm = #0x24a
;                     CSL_BcdmaTxChanCfg *pChanCfg = (CSL_BcdmaTxChanCfg *)pOpData;
7009dbc8: 9806         	ldr	r0, [sp, #0x18]
7009dbca: 9003         	str	r0, [sp, #0xc]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES)   ||    /* Block-copy supports 32, 64, and 128-byte bursts */
7009dbcc: 9803         	ldr	r0, [sp, #0xc]
7009dbce: 6c40         	ldr	r0, [r0, #0x44]
7009dbd0: 2802         	cmp	r0, #0x2
7009dbd2: d80a         	bhi	0x7009dbea <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #0x14
7009dbd4: e7ff         	b	0x7009dbd6 <CSL_bcdmaChanOpCfgChan+0x46> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009dbd6: 9803         	ldr	r0, [sp, #0xc]
7009dbd8: 6a00         	ldr	r0, [r0, #0x20]
7009dbda: 2807         	cmp	r0, #0x7
7009dbdc: d805         	bhi	0x7009dbea <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #0xa
7009dbde: e7ff         	b	0x7009dbe0 <CSL_bcdmaChanOpCfgChan+0x50> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009dbe0: 9803         	ldr	r0, [sp, #0xc]
7009dbe2: 6ac0         	ldr	r0, [r0, #0x2c]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES)   ||    /* Block-copy supports 32, 64, and 128-byte bursts */
7009dbe4: 2804         	cmp	r0, #0x4
7009dbe6: d304         	blo	0x7009dbf2 <CSL_bcdmaChanOpCfgChan+0x62> @ imm = #0x8
7009dbe8: e7ff         	b	0x7009dbea <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #-0x2
7009dbea: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009dbee: 9005         	str	r0, [sp, #0x14]
;                     }
7009dbf0: e03b         	b	0x7009dc6a <CSL_bcdmaChanOpCfgChan+0xda> @ imm = #0x76
;                         regVal = CSL_REG32_RD( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG );
7009dbf2: 9809         	ldr	r0, [sp, #0x24]
7009dbf4: 6840         	ldr	r0, [r0, #0x4]
7009dbf6: 9907         	ldr	r1, [sp, #0x1c]
7009dbf8: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dbfc: f012 f808    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0x12010
7009dc00: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_BCCFG_CHAN_CFG_PAUSE_ON_ERR, pChanCfg->pauseOnError );
7009dc02: 9804         	ldr	r0, [sp, #0x10]
7009dc04: f020 4000    	bic	r0, r0, #0x80000000
7009dc08: 9903         	ldr	r1, [sp, #0xc]
7009dc0a: 6809         	ldr	r1, [r1]
7009dc0c: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009dc10: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_BCCFG_CHAN_CFG_BURST_SIZE, pChanCfg->burstSize );
7009dc12: 9804         	ldr	r0, [sp, #0x10]
7009dc14: 9903         	ldr	r1, [sp, #0xc]
7009dc16: 6c49         	ldr	r1, [r1, #0x44]
7009dc18: f361 208b    	bfi	r0, r1, #10, #2
7009dc1c: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG, regVal );
7009dc1e: 9809         	ldr	r0, [sp, #0x24]
7009dc20: 6840         	ldr	r0, [r0, #0x4]
7009dc22: 9907         	ldr	r1, [sp, #0x1c]
7009dc24: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dc28: 9904         	ldr	r1, [sp, #0x10]
7009dc2a: f7fe fb31    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x199e
;                         regVal = CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009dc2e: 9803         	ldr	r0, [sp, #0xc]
7009dc30: 6a01         	ldr	r1, [r0, #0x20]
;                                  CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009dc32: 6a80         	ldr	r0, [r0, #0x28]
7009dc34: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009dc38: f361 701e    	bfi	r0, r1, #28, #3
7009dc3c: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].PRI_CTRL, regVal );
7009dc3e: 9809         	ldr	r0, [sp, #0x24]
7009dc40: 6840         	ldr	r0, [r0, #0x4]
7009dc42: 9907         	ldr	r1, [sp, #0x1c]
7009dc44: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dc48: 3064         	adds	r0, #0x64
7009dc4a: 9904         	ldr	r1, [sp, #0x10]
7009dc4c: f7fe fb20    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x19c0
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].TST_SCHED, CSL_FMK(BCDMA_BCCFG_CHAN_TST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009dc50: 9809         	ldr	r0, [sp, #0x24]
7009dc52: 6840         	ldr	r0, [r0, #0x4]
7009dc54: 9907         	ldr	r1, [sp, #0x1c]
7009dc56: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dc5a: 3080         	adds	r0, #0x80
7009dc5c: 9903         	ldr	r1, [sp, #0xc]
7009dc5e: 6ac9         	ldr	r1, [r1, #0x2c]
7009dc60: f001 0103    	and	r1, r1, #0x3
7009dc64: f7fe fb14    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x19d8
7009dc68: e7ff         	b	0x7009dc6a <CSL_bcdmaChanOpCfgChan+0xda> @ imm = #-0x2
;                 break;
7009dc6a: e0d7         	b	0x7009de1c <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0x1ae
;                     CSL_BcdmaTxChanCfg *pChanCfg = (CSL_BcdmaTxChanCfg *)pOpData;
7009dc6c: 9806         	ldr	r0, [sp, #0x18]
7009dc6e: 9002         	str	r0, [sp, #0x8]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||    /* Split-tx supports 32, and 64-byte bursts */
7009dc70: 9802         	ldr	r0, [sp, #0x8]
7009dc72: 6c40         	ldr	r0, [r0, #0x44]
7009dc74: 2801         	cmp	r0, #0x1
7009dc76: d80a         	bhi	0x7009dc8e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #0x14
7009dc78: e7ff         	b	0x7009dc7a <CSL_bcdmaChanOpCfgChan+0xea> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009dc7a: 9802         	ldr	r0, [sp, #0x8]
7009dc7c: 6a00         	ldr	r0, [r0, #0x20]
7009dc7e: 2807         	cmp	r0, #0x7
7009dc80: d805         	bhi	0x7009dc8e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #0xa
7009dc82: e7ff         	b	0x7009dc84 <CSL_bcdmaChanOpCfgChan+0xf4> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009dc84: 9802         	ldr	r0, [sp, #0x8]
7009dc86: 6ac0         	ldr	r0, [r0, #0x2c]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||    /* Split-tx supports 32, and 64-byte bursts */
7009dc88: 2804         	cmp	r0, #0x4
7009dc8a: d304         	blo	0x7009dc96 <CSL_bcdmaChanOpCfgChan+0x106> @ imm = #0x8
7009dc8c: e7ff         	b	0x7009dc8e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #-0x2
7009dc8e: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009dc92: 9005         	str	r0, [sp, #0x14]
;                     }
7009dc94: e057         	b	0x7009dd46 <CSL_bcdmaChanOpCfgChan+0x1b6> @ imm = #0xae
;                         regVal = CSL_REG32_RD( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG );
7009dc96: 9809         	ldr	r0, [sp, #0x24]
7009dc98: 68c0         	ldr	r0, [r0, #0xc]
7009dc9a: 9907         	ldr	r1, [sp, #0x1c]
7009dc9c: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dca0: f011 ffb6    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0x11f6c
7009dca4: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_PAUSE_ON_ERR, pChanCfg->pauseOnError);
7009dca6: 9804         	ldr	r0, [sp, #0x10]
7009dca8: f020 4000    	bic	r0, r0, #0x80000000
7009dcac: 9902         	ldr	r1, [sp, #0x8]
7009dcae: 6809         	ldr	r1, [r1]
7009dcb0: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009dcb4: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_BURST_SIZE, pChanCfg->burstSize );
7009dcb6: 9804         	ldr	r0, [sp, #0x10]
7009dcb8: 9902         	ldr	r1, [sp, #0x8]
7009dcba: 6c49         	ldr	r1, [r1, #0x44]
7009dcbc: f361 208b    	bfi	r0, r1, #10, #2
7009dcc0: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_TDTYPE, pChanCfg->tdType );
7009dcc2: 9804         	ldr	r0, [sp, #0x10]
7009dcc4: 9902         	ldr	r1, [sp, #0x8]
7009dcc6: 6c09         	ldr	r1, [r1, #0x40]
7009dcc8: f361 2049    	bfi	r0, r1, #9, #1
7009dccc: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_NOTDPKT, pChanCfg->bNoTeardownCompletePkt );
7009dcce: 9804         	ldr	r0, [sp, #0x10]
7009dcd0: f420 7080    	bic	r0, r0, #0x100
7009dcd4: 9902         	ldr	r1, [sp, #0x8]
7009dcd6: f891 103c    	ldrb.w	r1, [r1, #0x3c]
7009dcda: f001 0101    	and	r1, r1, #0x1
7009dcde: ea40 2001    	orr.w	r0, r0, r1, lsl #8
7009dce2: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG, regVal );
7009dce4: 9809         	ldr	r0, [sp, #0x24]
7009dce6: 68c0         	ldr	r0, [r0, #0xc]
7009dce8: 9907         	ldr	r1, [sp, #0x1c]
7009dcea: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dcee: 9904         	ldr	r1, [sp, #0x10]
7009dcf0: f7fe face    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1a64
;                         regVal = CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009dcf4: 9802         	ldr	r0, [sp, #0x8]
7009dcf6: 6a01         	ldr	r1, [r0, #0x20]
;                                  CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009dcf8: 6a80         	ldr	r0, [r0, #0x28]
7009dcfa: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009dcfe: f361 701e    	bfi	r0, r1, #28, #3
7009dd02: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TPRI_CTRL, regVal );
7009dd04: 9809         	ldr	r0, [sp, #0x24]
7009dd06: 68c0         	ldr	r0, [r0, #0xc]
7009dd08: 9907         	ldr	r1, [sp, #0x1c]
7009dd0a: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dd0e: 3064         	adds	r0, #0x64
7009dd10: 9904         	ldr	r1, [sp, #0x10]
7009dd12: f7fe fabd    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1a86
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].THREAD, CSL_FMK(BCDMA_TXCCFG_CHAN_THREAD_ID, pChanCfg->threadId) );
7009dd16: 9809         	ldr	r0, [sp, #0x24]
7009dd18: 68c0         	ldr	r0, [r0, #0xc]
7009dd1a: 9907         	ldr	r1, [sp, #0x1c]
7009dd1c: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dd20: 3068         	adds	r0, #0x68
7009dd22: 9902         	ldr	r1, [sp, #0x8]
7009dd24: f8b1 1048    	ldrh.w	r1, [r1, #0x48]
7009dd28: f7fe fab2    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1a9c
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TST_SCHED, CSL_FMK(BCDMA_TXCCFG_CHAN_TST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009dd2c: 9809         	ldr	r0, [sp, #0x24]
7009dd2e: 68c0         	ldr	r0, [r0, #0xc]
7009dd30: 9907         	ldr	r1, [sp, #0x1c]
7009dd32: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dd36: 3080         	adds	r0, #0x80
7009dd38: 9902         	ldr	r1, [sp, #0x8]
7009dd3a: 6ac9         	ldr	r1, [r1, #0x2c]
7009dd3c: f001 0103    	and	r1, r1, #0x3
7009dd40: f7fe faa6    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1ab4
7009dd44: e7ff         	b	0x7009dd46 <CSL_bcdmaChanOpCfgChan+0x1b6> @ imm = #-0x2
;                 break;
7009dd46: e069         	b	0x7009de1c <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0xd2
;                     CSL_BcdmaRxChanCfg *pChanCfg = (CSL_BcdmaRxChanCfg *)pOpData;
7009dd48: 9806         	ldr	r0, [sp, #0x18]
7009dd4a: 9001         	str	r0, [sp, #0x4]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||     /* Split-rx supports 32, and 64-byte bursts */
7009dd4c: 9801         	ldr	r0, [sp, #0x4]
7009dd4e: 6bc0         	ldr	r0, [r0, #0x3c]
7009dd50: 2801         	cmp	r0, #0x1
7009dd52: d80a         	bhi	0x7009dd6a <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #0x14
7009dd54: e7ff         	b	0x7009dd56 <CSL_bcdmaChanOpCfgChan+0x1c6> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009dd56: 9801         	ldr	r0, [sp, #0x4]
7009dd58: 6980         	ldr	r0, [r0, #0x18]
7009dd5a: 2807         	cmp	r0, #0x7
7009dd5c: d805         	bhi	0x7009dd6a <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #0xa
7009dd5e: e7ff         	b	0x7009dd60 <CSL_bcdmaChanOpCfgChan+0x1d0> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009dd60: 9801         	ldr	r0, [sp, #0x4]
7009dd62: 6b80         	ldr	r0, [r0, #0x38]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||     /* Split-rx supports 32, and 64-byte bursts */
7009dd64: 2804         	cmp	r0, #0x4
7009dd66: d304         	blo	0x7009dd72 <CSL_bcdmaChanOpCfgChan+0x1e2> @ imm = #0x8
7009dd68: e7ff         	b	0x7009dd6a <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #-0x2
7009dd6a: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009dd6e: 9005         	str	r0, [sp, #0x14]
;                     }
7009dd70: e04f         	b	0x7009de12 <CSL_bcdmaChanOpCfgChan+0x282> @ imm = #0x9e
;                         regVal = CSL_REG32_RD( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG );
7009dd72: 9809         	ldr	r0, [sp, #0x24]
7009dd74: 6940         	ldr	r0, [r0, #0x14]
7009dd76: 9907         	ldr	r1, [sp, #0x1c]
7009dd78: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dd7c: f011 ff48    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0x11e90
7009dd80: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_PAUSE_ON_ERR, pChanCfg->pauseOnError);
7009dd82: 9804         	ldr	r0, [sp, #0x10]
7009dd84: f020 4000    	bic	r0, r0, #0x80000000
7009dd88: 9901         	ldr	r1, [sp, #0x4]
7009dd8a: 6809         	ldr	r1, [r1]
7009dd8c: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009dd90: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_BURST_SIZE, pChanCfg->burstSize );
7009dd92: 9804         	ldr	r0, [sp, #0x10]
7009dd94: 9901         	ldr	r1, [sp, #0x4]
7009dd96: 6bc9         	ldr	r1, [r1, #0x3c]
7009dd98: f361 208b    	bfi	r0, r1, #10, #2
7009dd9c: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_IGNORE_LONG, pChanCfg->bIgnoreLongPkts ? (uint32_t)1U : (uint32_t)0U );
7009dd9e: 9804         	ldr	r0, [sp, #0x10]
7009dda0: f420 4080    	bic	r0, r0, #0x4000
7009dda4: 9901         	ldr	r1, [sp, #0x4]
7009dda6: f891 1035    	ldrb.w	r1, [r1, #0x35]
7009ddaa: f361 308e    	bfi	r0, r1, #14, #1
7009ddae: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG, regVal );
7009ddb0: 9809         	ldr	r0, [sp, #0x24]
7009ddb2: 6940         	ldr	r0, [r0, #0x14]
7009ddb4: 9907         	ldr	r1, [sp, #0x1c]
7009ddb6: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009ddba: 9904         	ldr	r1, [sp, #0x10]
7009ddbc: f7fe fa68    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1b30
;                         regVal = CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009ddc0: 9801         	ldr	r0, [sp, #0x4]
7009ddc2: 6981         	ldr	r1, [r0, #0x18]
;                                  CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009ddc4: 6a00         	ldr	r0, [r0, #0x20]
7009ddc6: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009ddca: f361 701e    	bfi	r0, r1, #28, #3
7009ddce: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RPRI_CTRL, regVal );
7009ddd0: 9809         	ldr	r0, [sp, #0x24]
7009ddd2: 6940         	ldr	r0, [r0, #0x14]
7009ddd4: 9907         	ldr	r1, [sp, #0x1c]
7009ddd6: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009ddda: 3064         	adds	r0, #0x64
7009dddc: 9904         	ldr	r1, [sp, #0x10]
7009ddde: f7fe fa57    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1b52
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].THREAD, CSL_FMK(BCDMA_RXCCFG_CHAN_THREAD_ID, pChanCfg->threadId) );
7009dde2: 9809         	ldr	r0, [sp, #0x24]
7009dde4: 6940         	ldr	r0, [r0, #0x14]
7009dde6: 9907         	ldr	r1, [sp, #0x1c]
7009dde8: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009ddec: 3068         	adds	r0, #0x68
7009ddee: 9901         	ldr	r1, [sp, #0x4]
7009ddf0: f8b1 1040    	ldrh.w	r1, [r1, #0x40]
7009ddf4: f7fe fa4c    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1b68
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RST_SCHED, CSL_FMK(BCDMA_RXCCFG_CHAN_RST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009ddf8: 9809         	ldr	r0, [sp, #0x24]
7009ddfa: 6940         	ldr	r0, [r0, #0x14]
7009ddfc: 9907         	ldr	r1, [sp, #0x1c]
7009ddfe: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009de02: 3080         	adds	r0, #0x80
7009de04: 9901         	ldr	r1, [sp, #0x4]
7009de06: 6b89         	ldr	r1, [r1, #0x38]
7009de08: f001 0103    	and	r1, r1, #0x3
7009de0c: f7fe fa40    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1b80
7009de10: e7ff         	b	0x7009de12 <CSL_bcdmaChanOpCfgChan+0x282> @ imm = #-0x2
;                 break;
7009de12: e003         	b	0x7009de1c <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0x6
7009de14: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
7009de18: 9005         	str	r0, [sp, #0x14]
;                 break;
7009de1a: e7ff         	b	0x7009de1c <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #-0x2
7009de1c: e7ff         	b	0x7009de1e <CSL_bcdmaChanOpCfgChan+0x28e> @ imm = #-0x2
;     return retVal;
7009de1e: 9805         	ldr	r0, [sp, #0x14]
7009de20: b00a         	add	sp, #0x28
7009de22: bd80         	pop	{r7, pc}
		...

7009de30 <TimerP_setup>:
; {
7009de30: b510         	push	{r4, lr}
7009de32: b096         	sub	sp, #0x58
7009de34: 9015         	str	r0, [sp, #0x54]
7009de36: 9114         	str	r1, [sp, #0x50]
;     DebugP_assert( baseAddr!=0U);
7009de38: 9815         	ldr	r0, [sp, #0x54]
7009de3a: 2800         	cmp	r0, #0x0
7009de3c: bf18         	it	ne
7009de3e: 2001         	movne	r0, #0x1
7009de40: f242 01f1    	movw	r1, #0x20f1
7009de44: f2c7 010b    	movt	r1, #0x700b
7009de48: 466a         	mov	r2, sp
7009de4a: 6011         	str	r1, [r2]
7009de4c: f641 5185    	movw	r1, #0x1d85
7009de50: f2c7 010b    	movt	r1, #0x700b
7009de54: 9106         	str	r1, [sp, #0x18]
7009de56: f242 02fe    	movw	r2, #0x20fe
7009de5a: f2c7 020b    	movt	r2, #0x700b
7009de5e: 9207         	str	r2, [sp, #0x1c]
7009de60: 2342         	movs	r3, #0x42
7009de62: f00c ff15    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xce2a
7009de66: 9906         	ldr	r1, [sp, #0x18]
7009de68: 9a07         	ldr	r2, [sp, #0x1c]
;     DebugP_assert( params->inputPreScaler != 0U);
7009de6a: 9814         	ldr	r0, [sp, #0x50]
7009de6c: 6800         	ldr	r0, [r0]
7009de6e: 2800         	cmp	r0, #0x0
7009de70: bf18         	it	ne
7009de72: 2001         	movne	r0, #0x1
7009de74: f641 53a3    	movw	r3, #0x1da3
7009de78: f2c7 030b    	movt	r3, #0x700b
7009de7c: 46ec         	mov	r12, sp
7009de7e: f8cc 3000    	str.w	r3, [r12]
7009de82: 2343         	movs	r3, #0x43
7009de84: f00c ff04    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xce08
7009de88: 9906         	ldr	r1, [sp, #0x18]
7009de8a: 9a07         	ldr	r2, [sp, #0x1c]
;     DebugP_assert( params->inputClkHz != 0U);
7009de8c: 9814         	ldr	r0, [sp, #0x50]
7009de8e: 6840         	ldr	r0, [r0, #0x4]
7009de90: 2800         	cmp	r0, #0x0
7009de92: bf18         	it	ne
7009de94: 2001         	movne	r0, #0x1
7009de96: f641 63ba    	movw	r3, #0x1eba
7009de9a: f2c7 030b    	movt	r3, #0x700b
7009de9e: 46ec         	mov	r12, sp
7009dea0: f8cc 3000    	str.w	r3, [r12]
7009dea4: 2344         	movs	r3, #0x44
7009dea6: f00c fef3    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xcde6
;     DebugP_assert(( params->periodInUsec != 0U) || (params->periodInNsec != 0U) );
7009deaa: 9814         	ldr	r0, [sp, #0x50]
7009deac: 6881         	ldr	r1, [r0, #0x8]
7009deae: 2001         	movs	r0, #0x1
7009deb0: 9008         	str	r0, [sp, #0x20]
7009deb2: b939         	cbnz	r1, 0x7009dec4 <TimerP_setup+0x94> @ imm = #0xe
7009deb4: e7ff         	b	0x7009deb6 <TimerP_setup+0x86> @ imm = #-0x2
7009deb6: 9814         	ldr	r0, [sp, #0x50]
7009deb8: 68c0         	ldr	r0, [r0, #0xc]
7009deba: 2800         	cmp	r0, #0x0
7009debc: bf18         	it	ne
7009debe: 2001         	movne	r0, #0x1
7009dec0: 9008         	str	r0, [sp, #0x20]
7009dec2: e7ff         	b	0x7009dec4 <TimerP_setup+0x94> @ imm = #-0x2
7009dec4: 9808         	ldr	r0, [sp, #0x20]
;     DebugP_assert(( params->periodInUsec != 0U) || (params->periodInNsec != 0U) );
7009dec6: f000 0001    	and	r0, r0, #0x1
7009deca: f641 1170    	movw	r1, #0x1970
7009dece: f2c7 010b    	movt	r1, #0x700b
7009ded2: 466a         	mov	r2, sp
7009ded4: 6011         	str	r1, [r2]
7009ded6: f641 5185    	movw	r1, #0x1d85
7009deda: f2c7 010b    	movt	r1, #0x700b
7009dede: 9103         	str	r1, [sp, #0xc]
7009dee0: f242 02fe    	movw	r2, #0x20fe
7009dee4: f2c7 020b    	movt	r2, #0x700b
7009dee8: 9204         	str	r2, [sp, #0x10]
7009deea: 2345         	movs	r3, #0x45
7009deec: f00c fed0    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xcda0
7009def0: 9903         	ldr	r1, [sp, #0xc]
7009def2: 9a04         	ldr	r2, [sp, #0x10]
;     DebugP_assert( params->inputPreScaler <= 256U);
7009def4: 9814         	ldr	r0, [sp, #0x50]
7009def6: 6803         	ldr	r3, [r0]
7009def8: 2000         	movs	r0, #0x0
7009defa: 9005         	str	r0, [sp, #0x14]
7009defc: f5b3 7f80    	cmp.w	r3, #0x100
7009df00: bf98         	it	ls
7009df02: 2001         	movls	r0, #0x1
7009df04: f641 5347    	movw	r3, #0x1d47
7009df08: f2c7 030b    	movt	r3, #0x700b
7009df0c: 46ec         	mov	r12, sp
7009df0e: f8cc 3000    	str.w	r3, [r12]
7009df12: 2347         	movs	r3, #0x47
7009df14: f00c febc    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xcd78
7009df18: 9903         	ldr	r1, [sp, #0xc]
7009df1a: 9a04         	ldr	r2, [sp, #0x10]
;     DebugP_assert( (params->inputClkHz % params->inputPreScaler) == 0U);
7009df1c: 9814         	ldr	r0, [sp, #0x50]
7009df1e: 6803         	ldr	r3, [r0]
7009df20: f8d0 c004    	ldr.w	r12, [r0, #0x4]
7009df24: fbbc f0f3    	udiv	r0, r12, r3
7009df28: fb00 c013    	mls	r0, r0, r3, r12
7009df2c: fab0 f080    	clz	r0, r0
7009df30: 0940         	lsrs	r0, r0, #0x5
7009df32: f641 2357    	movw	r3, #0x1a57
7009df36: f2c7 030b    	movt	r3, #0x700b
7009df3a: 46ec         	mov	r12, sp
7009df3c: f8cc 3000    	str.w	r3, [r12]
7009df40: 2349         	movs	r3, #0x49
7009df42: f00c fea5    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xcd4a
;     TimerP_stop(baseAddr);
7009df46: 9815         	ldr	r0, [sp, #0x54]
7009df48: f011 fbe2    	bl	0x700af710 <TimerP_stop> @ imm = #0x117c4
;     TimerP_clearOverflowInt(baseAddr);
7009df4c: 9815         	ldr	r0, [sp, #0x54]
7009df4e: f010 fe67    	bl	0x700aec20 <TimerP_clearOverflowInt> @ imm = #0x10cce
7009df52: 9905         	ldr	r1, [sp, #0x14]
;     timeInNsec = (uint64_t)params->periodInNsec;
7009df54: 9814         	ldr	r0, [sp, #0x50]
7009df56: 68c0         	ldr	r0, [r0, #0xc]
7009df58: 910f         	str	r1, [sp, #0x3c]
7009df5a: 900e         	str	r0, [sp, #0x38]
;     if(timeInNsec == 0U)
7009df5c: 980e         	ldr	r0, [sp, #0x38]
7009df5e: 990f         	ldr	r1, [sp, #0x3c]
7009df60: 4308         	orrs	r0, r1
7009df62: b948         	cbnz	r0, 0x7009df78 <TimerP_setup+0x148> @ imm = #0x12
7009df64: e7ff         	b	0x7009df66 <TimerP_setup+0x136> @ imm = #-0x2
;         timeInNsec = (uint64_t)params->periodInUsec*1000U;
7009df66: 9814         	ldr	r0, [sp, #0x50]
7009df68: 6880         	ldr	r0, [r0, #0x8]
7009df6a: f44f 717a    	mov.w	r1, #0x3e8
7009df6e: fba0 0101    	umull	r0, r1, r0, r1
7009df72: 910f         	str	r1, [sp, #0x3c]
7009df74: 900e         	str	r0, [sp, #0x38]
;     }
7009df76: e7ff         	b	0x7009df78 <TimerP_setup+0x148> @ imm = #-0x2
;     inputClkHz = (uint64_t)params->inputClkHz / (uint64_t)params->inputPreScaler;
7009df78: 9814         	ldr	r0, [sp, #0x50]
7009df7a: 6802         	ldr	r2, [r0]
7009df7c: 6840         	ldr	r0, [r0, #0x4]
7009df7e: 2300         	movs	r3, #0x0
7009df80: 9302         	str	r3, [sp, #0x8]
7009df82: 4619         	mov	r1, r3
7009df84: f011 e92e    	blx	0x700af1e4 <__aeabi_uldivmod> @ imm = #0x1125c
7009df88: 9b02         	ldr	r3, [sp, #0x8]
7009df8a: 910d         	str	r1, [sp, #0x34]
7009df8c: 900c         	str	r0, [sp, #0x30]
;     timerCycles =  ( inputClkHz * timeInNsec ) / 1000000000U;
7009df8e: f8dd c030    	ldr.w	r12, [sp, #0x30]
7009df92: 990d         	ldr	r1, [sp, #0x34]
7009df94: 9a0e         	ldr	r2, [sp, #0x38]
7009df96: f8dd e03c    	ldr.w	lr, [sp, #0x3c]
7009df9a: fbac 0402    	umull	r0, r4, r12, r2
7009df9e: fb0c 4c0e    	mla	r12, r12, lr, r4
7009dfa2: fb01 c102    	mla	r1, r1, r2, r12
7009dfa6: f64c 2200    	movw	r2, #0xca00
7009dfaa: f6c3 329a    	movt	r2, #0x3b9a
7009dfae: f011 e91a    	blx	0x700af1e4 <__aeabi_uldivmod> @ imm = #0x11234
7009dfb2: 4602         	mov	r2, r0
7009dfb4: 9802         	ldr	r0, [sp, #0x8]
7009dfb6: 9201         	str	r2, [sp, #0x4]
7009dfb8: 460a         	mov	r2, r1
7009dfba: 9901         	ldr	r1, [sp, #0x4]
7009dfbc: 920b         	str	r2, [sp, #0x2c]
7009dfbe: 910a         	str	r1, [sp, #0x28]
;     DebugP_assert( timerCycles < 0xFFFFFFFFU );
7009dfc0: 9a0a         	ldr	r2, [sp, #0x28]
7009dfc2: 990b         	ldr	r1, [sp, #0x2c]
7009dfc4: f1b2 32ff    	subs.w	r2, r2, #0xffffffff
7009dfc8: f171 0100    	sbcs	r1, r1, #0x0
7009dfcc: bf38         	it	lo
7009dfce: 2001         	movlo	r0, #0x1
7009dfd0: f641 61a0    	movw	r1, #0x1ea0
7009dfd4: f2c7 010b    	movt	r1, #0x700b
7009dfd8: 466a         	mov	r2, sp
7009dfda: 6011         	str	r1, [r2]
7009dfdc: f641 5185    	movw	r1, #0x1d85
7009dfe0: f2c7 010b    	movt	r1, #0x700b
7009dfe4: f242 02fe    	movw	r2, #0x20fe
7009dfe8: f2c7 020b    	movt	r2, #0x700b
7009dfec: 2359         	movs	r3, #0x59
7009dfee: f00c fe4f    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xcc9e
7009dff2: 9802         	ldr	r0, [sp, #0x8]
;     countVal = 0xFFFFFFFFu - (timerCycles - 1U);
7009dff4: 990a         	ldr	r1, [sp, #0x28]
7009dff6: 4249         	rsbs	r1, r1, #0
7009dff8: 9111         	str	r1, [sp, #0x44]
;     reloadVal = 0;
7009dffa: 9010         	str	r0, [sp, #0x40]
;     ctrlVal = 0;
7009dffc: 9012         	str	r0, [sp, #0x48]
;     if(params->inputPreScaler>1U)
7009dffe: 9814         	ldr	r0, [sp, #0x50]
7009e000: 6800         	ldr	r0, [r0]
7009e002: 2802         	cmp	r0, #0x2
7009e004: d320         	blo	0x7009e048 <TimerP_setup+0x218> @ imm = #0x40
7009e006: e7ff         	b	0x7009e008 <TimerP_setup+0x1d8> @ imm = #-0x2
7009e008: 2008         	movs	r0, #0x8
;         for(preScaleVal=8U; preScaleVal>=1U; preScaleVal--)
7009e00a: 9009         	str	r0, [sp, #0x24]
7009e00c: e7ff         	b	0x7009e00e <TimerP_setup+0x1de> @ imm = #-0x2
7009e00e: 9809         	ldr	r0, [sp, #0x24]
7009e010: b168         	cbz	r0, 0x7009e02e <TimerP_setup+0x1fe> @ imm = #0x1a
7009e012: e7ff         	b	0x7009e014 <TimerP_setup+0x1e4> @ imm = #-0x2
;             if( (params->inputPreScaler & (0x1U << preScaleVal)) != 0U )
7009e014: 9814         	ldr	r0, [sp, #0x50]
7009e016: 6800         	ldr	r0, [r0]
7009e018: 9909         	ldr	r1, [sp, #0x24]
7009e01a: 40c8         	lsrs	r0, r1
7009e01c: 07c0         	lsls	r0, r0, #0x1f
7009e01e: b108         	cbz	r0, 0x7009e024 <TimerP_setup+0x1f4> @ imm = #0x2
7009e020: e7ff         	b	0x7009e022 <TimerP_setup+0x1f2> @ imm = #-0x2
;                 break;
7009e022: e004         	b	0x7009e02e <TimerP_setup+0x1fe> @ imm = #0x8
;         }
7009e024: e7ff         	b	0x7009e026 <TimerP_setup+0x1f6> @ imm = #-0x2
;         for(preScaleVal=8U; preScaleVal>=1U; preScaleVal--)
7009e026: 9809         	ldr	r0, [sp, #0x24]
7009e028: 3801         	subs	r0, #0x1
7009e02a: 9009         	str	r0, [sp, #0x24]
7009e02c: e7ef         	b	0x7009e00e <TimerP_setup+0x1de> @ imm = #-0x22
;         ctrlVal |= (0x1U << 5);
7009e02e: 9812         	ldr	r0, [sp, #0x48]
7009e030: f040 0020    	orr	r0, r0, #0x20
7009e034: 9012         	str	r0, [sp, #0x48]
;         ctrlVal |= ( ((preScaleVal - 1U) & 0x7U) << 2);
7009e036: 9809         	ldr	r0, [sp, #0x24]
7009e038: 3801         	subs	r0, #0x1
7009e03a: f000 0107    	and	r1, r0, #0x7
7009e03e: 9812         	ldr	r0, [sp, #0x48]
7009e040: ea40 0081    	orr.w	r0, r0, r1, lsl #2
7009e044: 9012         	str	r0, [sp, #0x48]
;     }
7009e046: e7ff         	b	0x7009e048 <TimerP_setup+0x218> @ imm = #-0x2
;     if(params->oneshotMode==0U)
7009e048: 9814         	ldr	r0, [sp, #0x50]
7009e04a: 6900         	ldr	r0, [r0, #0x10]
7009e04c: b938         	cbnz	r0, 0x7009e05e <TimerP_setup+0x22e> @ imm = #0xe
7009e04e: e7ff         	b	0x7009e050 <TimerP_setup+0x220> @ imm = #-0x2
;         ctrlVal |= (0x1U << 1);
7009e050: 9812         	ldr	r0, [sp, #0x48]
7009e052: f040 0002    	orr	r0, r0, #0x2
7009e056: 9012         	str	r0, [sp, #0x48]
;         reloadVal = countVal;
7009e058: 9811         	ldr	r0, [sp, #0x44]
7009e05a: 9010         	str	r0, [sp, #0x40]
;     }
7009e05c: e7ff         	b	0x7009e05e <TimerP_setup+0x22e> @ imm = #-0x2
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TCLR);
7009e05e: 9815         	ldr	r0, [sp, #0x54]
7009e060: 3038         	adds	r0, #0x38
7009e062: 9013         	str	r0, [sp, #0x4c]
;     *addr = ctrlVal;
7009e064: 9812         	ldr	r0, [sp, #0x48]
7009e066: 9913         	ldr	r1, [sp, #0x4c]
7009e068: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TCRR);
7009e06a: 9815         	ldr	r0, [sp, #0x54]
7009e06c: 303c         	adds	r0, #0x3c
7009e06e: 9013         	str	r0, [sp, #0x4c]
;     *addr = countVal;
7009e070: 9811         	ldr	r0, [sp, #0x44]
7009e072: 9913         	ldr	r1, [sp, #0x4c]
7009e074: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TLDR);
7009e076: 9815         	ldr	r0, [sp, #0x54]
7009e078: 3040         	adds	r0, #0x40
7009e07a: 9013         	str	r0, [sp, #0x4c]
;     *addr = reloadVal;
7009e07c: 9810         	ldr	r0, [sp, #0x40]
7009e07e: 9913         	ldr	r1, [sp, #0x4c]
7009e080: 6008         	str	r0, [r1]
;     if((params->enableOverflowInt) != 0U)
7009e082: 9814         	ldr	r0, [sp, #0x50]
7009e084: 6940         	ldr	r0, [r0, #0x14]
7009e086: b138         	cbz	r0, 0x7009e098 <TimerP_setup+0x268> @ imm = #0xe
7009e088: e7ff         	b	0x7009e08a <TimerP_setup+0x25a> @ imm = #-0x2
;         addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_INT_ENABLE);
7009e08a: 9815         	ldr	r0, [sp, #0x54]
7009e08c: 302c         	adds	r0, #0x2c
7009e08e: 9013         	str	r0, [sp, #0x4c]
;         *addr = (0x1U << TIMER_OVF_INT_SHIFT);
7009e090: 9913         	ldr	r1, [sp, #0x4c]
7009e092: 2002         	movs	r0, #0x2
7009e094: 6008         	str	r0, [r1]
;     }
7009e096: e006         	b	0x7009e0a6 <TimerP_setup+0x276> @ imm = #0xc
;         addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_INT_DISABLE);
7009e098: 9815         	ldr	r0, [sp, #0x54]
7009e09a: 3030         	adds	r0, #0x30
7009e09c: 9013         	str	r0, [sp, #0x4c]
;         *addr = (0x1U << TIMER_OVF_INT_SHIFT);
7009e09e: 9913         	ldr	r1, [sp, #0x4c]
7009e0a0: 2002         	movs	r0, #0x2
7009e0a2: 6008         	str	r0, [r1]
7009e0a4: e7ff         	b	0x7009e0a6 <TimerP_setup+0x276> @ imm = #-0x2
; }
7009e0a6: b016         	add	sp, #0x58
7009e0a8: bd10         	pop	{r4, pc}
7009e0aa: 0000         	movs	r0, r0
7009e0ac: 0000         	movs	r0, r0
7009e0ae: 0000         	movs	r0, r0

7009e0b0 <Udma_chConfigRx>:
; {
7009e0b0: b580         	push	{r7, lr}
7009e0b2: b09c         	sub	sp, #0x70
7009e0b4: 901b         	str	r0, [sp, #0x6c]
7009e0b6: 911a         	str	r1, [sp, #0x68]
7009e0b8: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009e0ba: 9019         	str	r0, [sp, #0x64]
;     Udma_ChHandleInt        chHandleInt = (Udma_ChHandleInt) chHandle;
7009e0bc: 981b         	ldr	r0, [sp, #0x6c]
7009e0be: 9017         	str	r0, [sp, #0x5c]
;     if((NULL_PTR == chHandleInt) ||
7009e0c0: 9817         	ldr	r0, [sp, #0x5c]
7009e0c2: b188         	cbz	r0, 0x7009e0e8 <Udma_chConfigRx+0x38> @ imm = #0x22
7009e0c4: e7ff         	b	0x7009e0c6 <Udma_chConfigRx+0x16> @ imm = #-0x2
;         (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
7009e0c6: 9817         	ldr	r0, [sp, #0x5c]
7009e0c8: f8d0 0244    	ldr.w	r0, [r0, #0x244]
7009e0cc: f64a 31cd    	movw	r1, #0xabcd
7009e0d0: f6ca 31dc    	movt	r1, #0xabdc
7009e0d4: 4288         	cmp	r0, r1
7009e0d6: d107         	bne	0x7009e0e8 <Udma_chConfigRx+0x38> @ imm = #0xe
7009e0d8: e7ff         	b	0x7009e0da <Udma_chConfigRx+0x2a> @ imm = #-0x2
;         ((chHandleInt->chType & UDMA_CH_FLAG_RX) != UDMA_CH_FLAG_RX))
7009e0da: 9817         	ldr	r0, [sp, #0x5c]
7009e0dc: 6800         	ldr	r0, [r0]
7009e0de: f000 0002    	and	r0, r0, #0x2
;     if((NULL_PTR == chHandleInt) ||
7009e0e2: 2802         	cmp	r0, #0x2
7009e0e4: d004         	beq	0x7009e0f0 <Udma_chConfigRx+0x40> @ imm = #0x8
7009e0e6: e7ff         	b	0x7009e0e8 <Udma_chConfigRx+0x38> @ imm = #-0x2
7009e0e8: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009e0ec: 9019         	str	r0, [sp, #0x64]
;     }
7009e0ee: e7ff         	b	0x7009e0f0 <Udma_chConfigRx+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e0f0: 9819         	ldr	r0, [sp, #0x64]
7009e0f2: b9a8         	cbnz	r0, 0x7009e120 <Udma_chConfigRx+0x70> @ imm = #0x2a
7009e0f4: e7ff         	b	0x7009e0f6 <Udma_chConfigRx+0x46> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
7009e0f6: 9817         	ldr	r0, [sp, #0x5c]
7009e0f8: 6e80         	ldr	r0, [r0, #0x68]
7009e0fa: 9018         	str	r0, [sp, #0x60]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009e0fc: 9818         	ldr	r0, [sp, #0x60]
7009e0fe: b150         	cbz	r0, 0x7009e116 <Udma_chConfigRx+0x66> @ imm = #0x14
7009e100: e7ff         	b	0x7009e102 <Udma_chConfigRx+0x52> @ imm = #-0x2
7009e102: 9818         	ldr	r0, [sp, #0x60]
7009e104: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009e108: f64a 31cd    	movw	r1, #0xabcd
7009e10c: f6ca 31dc    	movt	r1, #0xabdc
7009e110: 4288         	cmp	r0, r1
7009e112: d004         	beq	0x7009e11e <Udma_chConfigRx+0x6e> @ imm = #0x8
7009e114: e7ff         	b	0x7009e116 <Udma_chConfigRx+0x66> @ imm = #-0x2
7009e116: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009e11a: 9019         	str	r0, [sp, #0x64]
;         }
7009e11c: e7ff         	b	0x7009e11e <Udma_chConfigRx+0x6e> @ imm = #-0x2
;     }
7009e11e: e7ff         	b	0x7009e120 <Udma_chConfigRx+0x70> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e120: 9819         	ldr	r0, [sp, #0x64]
7009e122: 2800         	cmp	r0, #0x0
7009e124: f040 80f1    	bne.w	0x7009e30a <Udma_chConfigRx+0x25a> @ imm = #0x1e2
7009e128: e7ff         	b	0x7009e12a <Udma_chConfigRx+0x7a> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
7009e12a: 9818         	ldr	r0, [sp, #0x60]
7009e12c: 6800         	ldr	r0, [r0]
7009e12e: 2801         	cmp	r0, #0x1
7009e130: d107         	bne	0x7009e142 <Udma_chConfigRx+0x92> @ imm = #0xe
7009e132: e7ff         	b	0x7009e134 <Udma_chConfigRx+0x84> @ imm = #-0x2
;             ((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
7009e134: 9817         	ldr	r0, [sp, #0x5c]
;         if ((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
7009e136: 7800         	ldrb	r0, [r0]
7009e138: 0740         	lsls	r0, r0, #0x1d
7009e13a: 2800         	cmp	r0, #0x0
7009e13c: d501         	bpl	0x7009e142 <Udma_chConfigRx+0x92> @ imm = #0x2
7009e13e: e7ff         	b	0x7009e140 <Udma_chConfigRx+0x90> @ imm = #-0x2
;         }
7009e140: e0e2         	b	0x7009e308 <Udma_chConfigRx+0x258> @ imm = #0x1c4
7009e142: f645 70ff    	movw	r0, #0x5fff
;             rmUdmaRxReq.valid_params        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERR_VALID |
7009e146: 9010         	str	r0, [sp, #0x40]
;             rmUdmaRxReq.nav_id              = drvHandle->devIdUdma;
7009e148: 9818         	ldr	r0, [sp, #0x60]
7009e14a: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009e14e: f8ad 0044    	strh.w	r0, [sp, #0x44]
;             rmUdmaRxReq.index               = (uint16_t)chHandleInt->rxChNum;
7009e152: 9817         	ldr	r0, [sp, #0x5c]
7009e154: 6f00         	ldr	r0, [r0, #0x70]
7009e156: f8ad 0046    	strh.w	r0, [sp, #0x46]
;             rmUdmaRxReq.rx_pause_on_err     = rxPrms->pauseOnError;
7009e15a: 981a         	ldr	r0, [sp, #0x68]
7009e15c: 7800         	ldrb	r0, [r0]
7009e15e: f88d 0054    	strb.w	r0, [sp, #0x54]
;             rmUdmaRxReq.rx_atype            = rxPrms->addrType;
7009e162: 981a         	ldr	r0, [sp, #0x68]
7009e164: 7840         	ldrb	r0, [r0, #0x1]
7009e166: f88d 0055    	strb.w	r0, [sp, #0x55]
;             rmUdmaRxReq.rx_chan_type        = rxPrms->chanType;
7009e16a: 981a         	ldr	r0, [sp, #0x68]
7009e16c: 7880         	ldrb	r0, [r0, #0x2]
7009e16e: f88d 0056    	strb.w	r0, [sp, #0x56]
;             rmUdmaRxReq.rx_fetch_size       = rxPrms->fetchWordSize;
7009e172: 981a         	ldr	r0, [sp, #0x68]
7009e174: 8880         	ldrh	r0, [r0, #0x4]
7009e176: f8ad 0048    	strh.w	r0, [sp, #0x48]
;             rmUdmaRxReq.rx_priority         = rxPrms->busPriority;
7009e17a: 981a         	ldr	r0, [sp, #0x68]
7009e17c: 7980         	ldrb	r0, [r0, #0x6]
7009e17e: f88d 004c    	strb.w	r0, [sp, #0x4c]
;             rmUdmaRxReq.rx_qos              = rxPrms->busQos;
7009e182: 981a         	ldr	r0, [sp, #0x68]
7009e184: 79c0         	ldrb	r0, [r0, #0x7]
7009e186: f88d 004d    	strb.w	r0, [sp, #0x4d]
;             rmUdmaRxReq.rx_orderid          = rxPrms->busOrderId;
7009e18a: 981a         	ldr	r0, [sp, #0x68]
7009e18c: 7a00         	ldrb	r0, [r0, #0x8]
7009e18e: f88d 004e    	strb.w	r0, [sp, #0x4e]
;             rmUdmaRxReq.rx_sched_priority   = rxPrms->dmaPriority;
7009e192: 981a         	ldr	r0, [sp, #0x68]
7009e194: 7a40         	ldrb	r0, [r0, #0x9]
7009e196: f88d 004f    	strb.w	r0, [sp, #0x4f]
;             rmUdmaRxReq.flowid_start        = rxPrms->flowIdFwRangeStart;
7009e19a: 981a         	ldr	r0, [sp, #0x68]
7009e19c: 8940         	ldrh	r0, [r0, #0xa]
7009e19e: f8ad 0050    	strh.w	r0, [sp, #0x50]
;             rmUdmaRxReq.flowid_cnt          = rxPrms->flowIdFwRangeCnt;
7009e1a2: 981a         	ldr	r0, [sp, #0x68]
7009e1a4: 8980         	ldrh	r0, [r0, #0xc]
7009e1a6: f8ad 0052    	strh.w	r0, [sp, #0x52]
;             rmUdmaRxReq.rx_ignore_short     = rxPrms->ignoreShortPkts;
7009e1aa: 981a         	ldr	r0, [sp, #0x68]
7009e1ac: 7c80         	ldrb	r0, [r0, #0x12]
7009e1ae: f88d 0057    	strb.w	r0, [sp, #0x57]
;             rmUdmaRxReq.rx_ignore_long      = rxPrms->ignoreLongPkts;
7009e1b2: 981a         	ldr	r0, [sp, #0x68]
7009e1b4: 7cc0         	ldrb	r0, [r0, #0x13]
7009e1b6: f88d 0058    	strb.w	r0, [sp, #0x58]
;             rmUdmaRxReq.rx_burst_size       = rxPrms->burstSize;
7009e1ba: 981a         	ldr	r0, [sp, #0x68]
7009e1bc: 7e00         	ldrb	r0, [r0, #0x18]
7009e1be: f88d 0059    	strb.w	r0, [sp, #0x59]
;             if(NULL_PTR != chHandleInt->tdCqRing)
7009e1c2: 9817         	ldr	r0, [sp, #0x5c]
7009e1c4: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009e1c8: b138         	cbz	r0, 0x7009e1da <Udma_chConfigRx+0x12a> @ imm = #0xe
7009e1ca: e7ff         	b	0x7009e1cc <Udma_chConfigRx+0x11c> @ imm = #-0x2
;                 rmUdmaRxReq.rxcq_qnum          = chHandleInt->tdCqRing->ringNum;
7009e1cc: 9817         	ldr	r0, [sp, #0x5c]
7009e1ce: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009e1d2: 8880         	ldrh	r0, [r0, #0x4]
7009e1d4: f8ad 004a    	strh.w	r0, [sp, #0x4a]
;             }
7009e1d8: e004         	b	0x7009e1e4 <Udma_chConfigRx+0x134> @ imm = #0x8
7009e1da: f64f 70ff    	movw	r0, #0xffff
;                 rmUdmaRxReq.rxcq_qnum          = UDMA_RING_INVALID;
7009e1de: f8ad 004a    	strh.w	r0, [sp, #0x4a]
7009e1e2: e7ff         	b	0x7009e1e4 <Udma_chConfigRx+0x134> @ imm = #-0x2
7009e1e4: a80e         	add	r0, sp, #0x38
7009e1e6: a90c         	add	r1, sp, #0x30
7009e1e8: f04f 32ff    	mov.w	r2, #0xffffffff
;             retVal = Sciclient_rmUdmapRxChCfg(
7009e1ec: f00e fc20    	bl	0x700aca30 <Sciclient_rmUdmapRxChCfg> @ imm = #0xe840
7009e1f0: 9019         	str	r0, [sp, #0x64]
;             if(CSL_PASS != retVal)
7009e1f2: 9819         	ldr	r0, [sp, #0x64]
7009e1f4: b108         	cbz	r0, 0x7009e1fa <Udma_chConfigRx+0x14a> @ imm = #0x2
7009e1f6: e7ff         	b	0x7009e1f8 <Udma_chConfigRx+0x148> @ imm = #-0x2
;             }
7009e1f8: e7ff         	b	0x7009e1fa <Udma_chConfigRx+0x14a> @ imm = #-0x2
;             if((((chHandleInt->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA) ||
7009e1fa: 9817         	ldr	r0, [sp, #0x5c]
7009e1fc: 6800         	ldr	r0, [r0]
7009e1fe: f000 0008    	and	r0, r0, #0x8
7009e202: 2808         	cmp	r0, #0x8
7009e204: d006         	beq	0x7009e214 <Udma_chConfigRx+0x164> @ imm = #0xc
7009e206: e7ff         	b	0x7009e208 <Udma_chConfigRx+0x158> @ imm = #-0x2
;                     ((chHandleInt->chType & UDMA_CH_FLAG_PSIL) == UDMA_CH_FLAG_PSIL)) &&
7009e208: 9817         	ldr	r0, [sp, #0x5c]
7009e20a: 7800         	ldrb	r0, [r0]
7009e20c: 06c0         	lsls	r0, r0, #0x1b
7009e20e: 2800         	cmp	r0, #0x0
7009e210: d569         	bpl	0x7009e2e6 <Udma_chConfigRx+0x236> @ imm = #0xd2
7009e212: e7ff         	b	0x7009e214 <Udma_chConfigRx+0x164> @ imm = #-0x2
;                (TRUE == rxPrms->configDefaultFlow))
7009e214: 981a         	ldr	r0, [sp, #0x68]
7009e216: 6940         	ldr	r0, [r0, #0x14]
;             if((((chHandleInt->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA) ||
7009e218: 2801         	cmp	r0, #0x1
7009e21a: d164         	bne	0x7009e2e6 <Udma_chConfigRx+0x236> @ imm = #0xc8
7009e21c: e7ff         	b	0x7009e21e <Udma_chConfigRx+0x16e> @ imm = #-0x2
;                 UdmaFlowPrms_init(&flowPrms, chHandleInt->chType);
7009e21e: 9817         	ldr	r0, [sp, #0x5c]
7009e220: 6801         	ldr	r1, [r0]
7009e222: a801         	add	r0, sp, #0x4
7009e224: f00b fb4c    	bl	0x700a98c0 <UdmaFlowPrms_init> @ imm = #0xb698
;                 flowPrms.psInfoPresent = rxPrms->flowPsInfoPresent;
7009e228: 981a         	ldr	r0, [sp, #0x68]
7009e22a: 7bc0         	ldrb	r0, [r0, #0xf]
7009e22c: f88d 0009    	strb.w	r0, [sp, #0x9]
;                 flowPrms.einfoPresent  = rxPrms->flowEInfoPresent;
7009e230: 981a         	ldr	r0, [sp, #0x68]
7009e232: 7b80         	ldrb	r0, [r0, #0xe]
7009e234: f88d 0008    	strb.w	r0, [sp, #0x8]
;                 flowPrms.errorHandling = rxPrms->flowErrorHandling;
7009e238: 981a         	ldr	r0, [sp, #0x68]
7009e23a: 7c00         	ldrb	r0, [r0, #0x10]
7009e23c: f88d 000a    	strb.w	r0, [sp, #0xa]
;                 flowPrms.sopOffset     = rxPrms->flowSopOffset;
7009e240: 981a         	ldr	r0, [sp, #0x68]
7009e242: 7c40         	ldrb	r0, [r0, #0x11]
7009e244: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                 if(NULL_PTR == chHandleInt->cqRing)
7009e248: 9817         	ldr	r0, [sp, #0x5c]
7009e24a: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009e24e: b928         	cbnz	r0, 0x7009e25c <Udma_chConfigRx+0x1ac> @ imm = #0xa
7009e250: e7ff         	b	0x7009e252 <Udma_chConfigRx+0x1a2> @ imm = #-0x2
7009e252: f64f 70ff    	movw	r0, #0xffff
;                     cqRing = UDMA_RING_INVALID;
7009e256: f8ad 0002    	strh.w	r0, [sp, #0x2]
;                 }
7009e25a: e006         	b	0x7009e26a <Udma_chConfigRx+0x1ba> @ imm = #0xc
;                     cqRing = chHandleInt->cqRing->ringNum;
7009e25c: 9817         	ldr	r0, [sp, #0x5c]
7009e25e: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009e262: 8880         	ldrh	r0, [r0, #0x4]
7009e264: f8ad 0002    	strh.w	r0, [sp, #0x2]
7009e268: e7ff         	b	0x7009e26a <Udma_chConfigRx+0x1ba> @ imm = #-0x2
;                 if(NULL_PTR == chHandleInt->fqRing)
7009e26a: 9817         	ldr	r0, [sp, #0x5c]
7009e26c: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009e270: b928         	cbnz	r0, 0x7009e27e <Udma_chConfigRx+0x1ce> @ imm = #0xa
7009e272: e7ff         	b	0x7009e274 <Udma_chConfigRx+0x1c4> @ imm = #-0x2
7009e274: f64f 70ff    	movw	r0, #0xffff
;                     fqRing = UDMA_RING_INVALID;
7009e278: f8ad 0000    	strh.w	r0, [sp]
;                 }
7009e27c: e006         	b	0x7009e28c <Udma_chConfigRx+0x1dc> @ imm = #0xc
;                     fqRing = chHandleInt->fqRing->ringNum;
7009e27e: 9817         	ldr	r0, [sp, #0x5c]
7009e280: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009e284: 8880         	ldrh	r0, [r0, #0x4]
7009e286: f8ad 0000    	strh.w	r0, [sp]
7009e28a: e7ff         	b	0x7009e28c <Udma_chConfigRx+0x1dc> @ imm = #-0x2
;                 flowPrms.defaultRxCQ    = cqRing;
7009e28c: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
7009e290: f8ad 0010    	strh.w	r0, [sp, #0x10]
;                 flowPrms.fdq0Sz0Qnum    = fqRing;
7009e294: f8bd 0000    	ldrh.w	r0, [sp]
7009e298: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;                 flowPrms.fdq0Sz1Qnum    = fqRing;
7009e29c: f8bd 0000    	ldrh.w	r0, [sp]
7009e2a0: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;                 flowPrms.fdq0Sz2Qnum    = fqRing;
7009e2a4: f8bd 0000    	ldrh.w	r0, [sp]
7009e2a8: f8ad 002c    	strh.w	r0, [sp, #0x2c]
;                 flowPrms.fdq0Sz3Qnum    = fqRing;
7009e2ac: f8bd 0000    	ldrh.w	r0, [sp]
7009e2b0: f8ad 002e    	strh.w	r0, [sp, #0x2e]
;                 flowPrms.fdq1Qnum       = fqRing;
7009e2b4: f8bd 0000    	ldrh.w	r0, [sp]
7009e2b8: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 flowPrms.fdq2Qnum       = fqRing;
7009e2bc: f8bd 0000    	ldrh.w	r0, [sp]
7009e2c0: f8ad 0020    	strh.w	r0, [sp, #0x20]
;                 flowPrms.fdq3Qnum       = fqRing;
7009e2c4: f8bd 0000    	ldrh.w	r0, [sp]
7009e2c8: f8ad 0022    	strh.w	r0, [sp, #0x22]
;                 retVal = Udma_flowConfig(chHandleInt->defaultFlow, 0U, &flowPrms);
7009e2cc: 9817         	ldr	r0, [sp, #0x5c]
7009e2ce: f8d0 01c8    	ldr.w	r0, [r0, #0x1c8]
7009e2d2: 2100         	movs	r1, #0x0
7009e2d4: aa01         	add	r2, sp, #0x4
7009e2d6: f001 f9eb    	bl	0x7009f6b0 <Udma_flowConfig> @ imm = #0x13d6
7009e2da: 9019         	str	r0, [sp, #0x64]
;                 if(UDMA_SOK != retVal)
7009e2dc: 9819         	ldr	r0, [sp, #0x64]
7009e2de: b108         	cbz	r0, 0x7009e2e4 <Udma_chConfigRx+0x234> @ imm = #0x2
7009e2e0: e7ff         	b	0x7009e2e2 <Udma_chConfigRx+0x232> @ imm = #-0x2
;                 }
7009e2e2: e7ff         	b	0x7009e2e4 <Udma_chConfigRx+0x234> @ imm = #-0x2
;             }
7009e2e4: e7ff         	b	0x7009e2e6 <Udma_chConfigRx+0x236> @ imm = #-0x2
;             if(UDMA_SOK == retVal)
7009e2e6: 9819         	ldr	r0, [sp, #0x64]
7009e2e8: b968         	cbnz	r0, 0x7009e306 <Udma_chConfigRx+0x256> @ imm = #0x1a
7009e2ea: e7ff         	b	0x7009e2ec <Udma_chConfigRx+0x23c> @ imm = #-0x2
;                 (void) memcpy(&chHandleInt->rxPrms, rxPrms, sizeof(chHandleInt->rxPrms));
7009e2ec: 9817         	ldr	r0, [sp, #0x5c]
7009e2ee: f500 70fc    	add.w	r0, r0, #0x1f8
7009e2f2: 991a         	ldr	r1, [sp, #0x68]
7009e2f4: e8b1 100c    	ldm.w	r1!, {r2, r3, r12}
7009e2f8: e8a0 100c    	stm.w	r0!, {r2, r3, r12}
7009e2fc: e891 500c    	ldm.w	r1, {r2, r3, r12, lr}
7009e300: e880 500c    	stm.w	r0, {r2, r3, r12, lr}
;             }
7009e304: e7ff         	b	0x7009e306 <Udma_chConfigRx+0x256> @ imm = #-0x2
7009e306: e7ff         	b	0x7009e308 <Udma_chConfigRx+0x258> @ imm = #-0x2
;     }
7009e308: e7ff         	b	0x7009e30a <Udma_chConfigRx+0x25a> @ imm = #-0x2
;     return (retVal);
7009e30a: 9819         	ldr	r0, [sp, #0x64]
7009e30c: b01c         	add	sp, #0x70
7009e30e: bd80         	pop	{r7, pc}

7009e310 <tm_message_isr_to_task_initialize>:
; {
7009e310: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
7009e314: b081         	sub	sp, #0x4
;    tm_setup_pmu();
7009e316: f011 fbc3    	bl	0x700afaa0 <tm_setup_pmu> @ imm = #0x11786
;    tm_queue_create(0);
7009e31a: 2000         	movs	r0, #0x0
7009e31c: f04f 0a00    	mov.w	r10, #0x0
7009e320: f010 ff8e    	bl	0x700af240 <tm_queue_create> @ imm = #0x10f1c
7009e324: f242 681b    	movw	r8, #0x261b
7009e328: f244 7b78    	movw	r11, #0x4778
7009e32c: f242 6915    	movw	r9, #0x2615
7009e330: f2c7 080b    	movt	r8, #0x700b
7009e334: f2c7 0b08    	movt	r11, #0x7008
7009e338: f2c7 090b    	movt	r9, #0x700b
7009e33c: 2600         	movs	r6, #0x0
7009e33e: bf00         	nop
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e340: f644 1078    	movw	r0, #0x4978
7009e344: 4642         	mov	r2, r8
7009e346: f2c7 0008    	movt	r0, #0x7008
7009e34a: 4633         	mov	r3, r6
7009e34c: f04f 0110    	mov.w	r1, #0x10
7009e350: eb00 040a    	add.w	r4, r0, r10
7009e354: 4620         	mov	r0, r4
7009e356: f00c ed5a    	blx	0x700aae0c <snprintf>   @ imm = #0xcab4
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e35a: eb0b 070a    	add.w	r7, r11, r10
7009e35e: 464a         	mov	r2, r9
7009e360: 4633         	mov	r3, r6
7009e362: 2110         	movs	r1, #0x10
7009e364: 4638         	mov	r0, r7
7009e366: f00c ed52    	blx	0x700aae0c <snprintf>   @ imm = #0xcaa4
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e36a: 1c75         	adds	r5, r6, #0x1
7009e36c: f104 0010    	add.w	r0, r4, #0x10
7009e370: 4642         	mov	r2, r8
7009e372: 2110         	movs	r1, #0x10
7009e374: 462b         	mov	r3, r5
7009e376: f00c ed4a    	blx	0x700aae0c <snprintf>   @ imm = #0xca94
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e37a: f107 0010    	add.w	r0, r7, #0x10
7009e37e: 464a         	mov	r2, r9
7009e380: 462b         	mov	r3, r5
7009e382: 2110         	movs	r1, #0x10
7009e384: f00c ed42    	blx	0x700aae0c <snprintf>   @ imm = #0xca84
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e388: 1cb5         	adds	r5, r6, #0x2
7009e38a: f104 0020    	add.w	r0, r4, #0x20
7009e38e: 4642         	mov	r2, r8
7009e390: 2110         	movs	r1, #0x10
7009e392: 462b         	mov	r3, r5
7009e394: f00c ed3a    	blx	0x700aae0c <snprintf>   @ imm = #0xca74
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e398: f107 0020    	add.w	r0, r7, #0x20
7009e39c: 464a         	mov	r2, r9
7009e39e: 462b         	mov	r3, r5
7009e3a0: 2110         	movs	r1, #0x10
7009e3a2: f00c ed34    	blx	0x700aae0c <snprintf>   @ imm = #0xca68
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e3a6: 1cf5         	adds	r5, r6, #0x3
7009e3a8: f104 0030    	add.w	r0, r4, #0x30
7009e3ac: 4642         	mov	r2, r8
7009e3ae: 2110         	movs	r1, #0x10
7009e3b0: 462b         	mov	r3, r5
7009e3b2: f00c ed2c    	blx	0x700aae0c <snprintf>   @ imm = #0xca58
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e3b6: f107 0030    	add.w	r0, r7, #0x30
7009e3ba: 464a         	mov	r2, r9
7009e3bc: 462b         	mov	r3, r5
7009e3be: 2110         	movs	r1, #0x10
7009e3c0: f00c ed24    	blx	0x700aae0c <snprintf>   @ imm = #0xca48
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e3c4: 1d35         	adds	r5, r6, #0x4
7009e3c6: f104 0040    	add.w	r0, r4, #0x40
7009e3ca: 4642         	mov	r2, r8
7009e3cc: 2110         	movs	r1, #0x10
7009e3ce: 462b         	mov	r3, r5
7009e3d0: f00c ed1c    	blx	0x700aae0c <snprintf>   @ imm = #0xca38
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e3d4: f107 0040    	add.w	r0, r7, #0x40
7009e3d8: 464a         	mov	r2, r9
7009e3da: 462b         	mov	r3, r5
7009e3dc: 2110         	movs	r1, #0x10
7009e3de: f00c ed16    	blx	0x700aae0c <snprintf>   @ imm = #0xca2c
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e3e2: 1d75         	adds	r5, r6, #0x5
7009e3e4: f104 0050    	add.w	r0, r4, #0x50
7009e3e8: 4642         	mov	r2, r8
7009e3ea: 2110         	movs	r1, #0x10
7009e3ec: 462b         	mov	r3, r5
7009e3ee: f00c ed0e    	blx	0x700aae0c <snprintf>   @ imm = #0xca1c
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e3f2: f107 0050    	add.w	r0, r7, #0x50
7009e3f6: 464a         	mov	r2, r9
7009e3f8: 462b         	mov	r3, r5
7009e3fa: 2110         	movs	r1, #0x10
7009e3fc: f00c ed06    	blx	0x700aae0c <snprintf>   @ imm = #0xca0c
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e400: 1db5         	adds	r5, r6, #0x6
7009e402: f104 0060    	add.w	r0, r4, #0x60
7009e406: 4642         	mov	r2, r8
7009e408: 2110         	movs	r1, #0x10
7009e40a: 462b         	mov	r3, r5
7009e40c: f00c ecfe    	blx	0x700aae0c <snprintf>   @ imm = #0xc9fc
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e410: f107 0060    	add.w	r0, r7, #0x60
7009e414: 464a         	mov	r2, r9
7009e416: 462b         	mov	r3, r5
7009e418: 2110         	movs	r1, #0x10
7009e41a: f00c ecf8    	blx	0x700aae0c <snprintf>   @ imm = #0xc9f0
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e41e: 1df5         	adds	r5, r6, #0x7
7009e420: f104 0070    	add.w	r0, r4, #0x70
7009e424: 4642         	mov	r2, r8
7009e426: 2110         	movs	r1, #0x10
7009e428: 462b         	mov	r3, r5
7009e42a: f00c ecf0    	blx	0x700aae0c <snprintf>   @ imm = #0xc9e0
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e42e: f107 0070    	add.w	r0, r7, #0x70
7009e432: 464a         	mov	r2, r9
7009e434: 462b         	mov	r3, r5
7009e436: 2110         	movs	r1, #0x10
7009e438: f00c ece8    	blx	0x700aae0c <snprintf>   @ imm = #0xc9d0
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e43c: f106 0508    	add.w	r5, r6, #0x8
7009e440: f104 0080    	add.w	r0, r4, #0x80
7009e444: 4642         	mov	r2, r8
7009e446: 2110         	movs	r1, #0x10
7009e448: 462b         	mov	r3, r5
7009e44a: f00c ece0    	blx	0x700aae0c <snprintf>   @ imm = #0xc9c0
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e44e: f107 0080    	add.w	r0, r7, #0x80
7009e452: 464a         	mov	r2, r9
7009e454: 462b         	mov	r3, r5
7009e456: 2110         	movs	r1, #0x10
7009e458: f00c ecd8    	blx	0x700aae0c <snprintf>   @ imm = #0xc9b0
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e45c: f106 0509    	add.w	r5, r6, #0x9
7009e460: f104 0090    	add.w	r0, r4, #0x90
7009e464: 4642         	mov	r2, r8
7009e466: 2110         	movs	r1, #0x10
7009e468: 462b         	mov	r3, r5
7009e46a: f00c ecd0    	blx	0x700aae0c <snprintf>   @ imm = #0xc9a0
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e46e: f107 0090    	add.w	r0, r7, #0x90
7009e472: 464a         	mov	r2, r9
7009e474: 462b         	mov	r3, r5
7009e476: 2110         	movs	r1, #0x10
7009e478: f00c ecc8    	blx	0x700aae0c <snprintf>   @ imm = #0xc990
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e47c: f106 050a    	add.w	r5, r6, #0xa
7009e480: f104 00a0    	add.w	r0, r4, #0xa0
7009e484: 4642         	mov	r2, r8
7009e486: 2110         	movs	r1, #0x10
7009e488: 462b         	mov	r3, r5
7009e48a: f00c ecc0    	blx	0x700aae0c <snprintf>   @ imm = #0xc980
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e48e: f107 00a0    	add.w	r0, r7, #0xa0
7009e492: 464a         	mov	r2, r9
7009e494: 462b         	mov	r3, r5
7009e496: 2110         	movs	r1, #0x10
7009e498: f00c ecb8    	blx	0x700aae0c <snprintf>   @ imm = #0xc970
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e49c: f106 050b    	add.w	r5, r6, #0xb
7009e4a0: f104 00b0    	add.w	r0, r4, #0xb0
7009e4a4: 4642         	mov	r2, r8
7009e4a6: 2110         	movs	r1, #0x10
7009e4a8: 462b         	mov	r3, r5
7009e4aa: f00c ecb0    	blx	0x700aae0c <snprintf>   @ imm = #0xc960
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e4ae: f107 00b0    	add.w	r0, r7, #0xb0
7009e4b2: 464a         	mov	r2, r9
7009e4b4: 462b         	mov	r3, r5
7009e4b6: 2110         	movs	r1, #0x10
7009e4b8: f00c eca8    	blx	0x700aae0c <snprintf>   @ imm = #0xc950
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e4bc: f106 050c    	add.w	r5, r6, #0xc
7009e4c0: f104 00c0    	add.w	r0, r4, #0xc0
7009e4c4: 4642         	mov	r2, r8
7009e4c6: 2110         	movs	r1, #0x10
7009e4c8: 462b         	mov	r3, r5
7009e4ca: f00c eca0    	blx	0x700aae0c <snprintf>   @ imm = #0xc940
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e4ce: f107 00c0    	add.w	r0, r7, #0xc0
7009e4d2: 464a         	mov	r2, r9
7009e4d4: 462b         	mov	r3, r5
7009e4d6: 2110         	movs	r1, #0x10
7009e4d8: f00c ec98    	blx	0x700aae0c <snprintf>   @ imm = #0xc930
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e4dc: f106 050d    	add.w	r5, r6, #0xd
7009e4e0: f104 00d0    	add.w	r0, r4, #0xd0
7009e4e4: 4642         	mov	r2, r8
7009e4e6: 2110         	movs	r1, #0x10
7009e4e8: 462b         	mov	r3, r5
7009e4ea: f00c ec90    	blx	0x700aae0c <snprintf>   @ imm = #0xc920
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e4ee: f107 00d0    	add.w	r0, r7, #0xd0
7009e4f2: 464a         	mov	r2, r9
7009e4f4: 462b         	mov	r3, r5
7009e4f6: 2110         	movs	r1, #0x10
7009e4f8: f00c ec88    	blx	0x700aae0c <snprintf>   @ imm = #0xc910
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e4fc: f106 050e    	add.w	r5, r6, #0xe
7009e500: f104 00e0    	add.w	r0, r4, #0xe0
7009e504: 4642         	mov	r2, r8
7009e506: 2110         	movs	r1, #0x10
7009e508: 462b         	mov	r3, r5
7009e50a: f00c ec80    	blx	0x700aae0c <snprintf>   @ imm = #0xc900
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e50e: f107 00e0    	add.w	r0, r7, #0xe0
7009e512: 464a         	mov	r2, r9
7009e514: 462b         	mov	r3, r5
7009e516: 2110         	movs	r1, #0x10
7009e518: f00c ec78    	blx	0x700aae0c <snprintf>   @ imm = #0xc8f0
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e51c: f104 00f0    	add.w	r0, r4, #0xf0
7009e520: f106 040f    	add.w	r4, r6, #0xf
7009e524: 4642         	mov	r2, r8
7009e526: 2110         	movs	r1, #0x10
7009e528: 4623         	mov	r3, r4
7009e52a: f00c ec70    	blx	0x700aae0c <snprintf>   @ imm = #0xc8e0
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e52e: f107 00f0    	add.w	r0, r7, #0xf0
7009e532: 464a         	mov	r2, r9
7009e534: 4623         	mov	r3, r4
7009e536: 2110         	movs	r1, #0x10
7009e538: f00c ec68    	blx	0x700aae0c <snprintf>   @ imm = #0xc8d0
;    for (i = 0; i < ITERATION_COUNT; i++)
7009e53c: 3610         	adds	r6, #0x10
7009e53e: f50a 7a80    	add.w	r10, r10, #0x100
7009e542: 2e20         	cmp	r6, #0x20
7009e544: f47f aefc    	bne.w	0x7009e340 <tm_message_isr_to_task_initialize+0x30> @ imm = #-0x208
;    tm_thread_create(0, 5, tm_receiver_thread_entry);
7009e548: f24d 3201    	movw	r2, #0xd301
7009e54c: 2000         	movs	r0, #0x0
7009e54e: f2c7 0209    	movt	r2, #0x7009
7009e552: 2105         	movs	r1, #0x5
7009e554: f00f ff5c    	bl	0x700ae410 <tm_thread_create> @ imm = #0xfeb8
;    tm_thread_resume(0);
7009e558: 2000         	movs	r0, #0x0
7009e55a: b001         	add	sp, #0x4
7009e55c: e8bd 4ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
7009e560: f011 b9de    	b.w	0x700af920 <tm_thread_resume> @ imm = #0x113bc
		...

7009e570 <Sciclient_rmIrqFindRoute>:
; {
7009e570: b580         	push	{r7, lr}
7009e572: b08a         	sub	sp, #0x28
7009e574: 9009         	str	r0, [sp, #0x24]
7009e576: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009e578: 9008         	str	r0, [sp, #0x20]
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009e57a: 9809         	ldr	r0, [sp, #0x24]
7009e57c: 88c0         	ldrh	r0, [r0, #0x6]
7009e57e: f010 f9e7    	bl	0x700ae950 <Sciclient_rmIrIsIr> @ imm = #0x103ce
7009e582: b930         	cbnz	r0, 0x7009e592 <Sciclient_rmIrqFindRoute+0x22> @ imm = #0xc
7009e584: e7ff         	b	0x7009e586 <Sciclient_rmIrqFindRoute+0x16> @ imm = #-0x2
;         (Sciclient_rmIrIsIr(cfg->d_id) == true)) {
7009e586: 9809         	ldr	r0, [sp, #0x24]
7009e588: 8940         	ldrh	r0, [r0, #0xa]
7009e58a: f010 f9e1    	bl	0x700ae950 <Sciclient_rmIrIsIr> @ imm = #0x103c2
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009e58e: b120         	cbz	r0, 0x7009e59a <Sciclient_rmIrqFindRoute+0x2a> @ imm = #0x8
7009e590: e7ff         	b	0x7009e592 <Sciclient_rmIrqFindRoute+0x22> @ imm = #-0x2
7009e592: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009e596: 9008         	str	r0, [sp, #0x20]
;     }
7009e598: e7ff         	b	0x7009e59a <Sciclient_rmIrqFindRoute+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009e59a: 9808         	ldr	r0, [sp, #0x20]
7009e59c: bb20         	cbnz	r0, 0x7009e5e8 <Sciclient_rmIrqFindRoute+0x78> @ imm = #0x48
7009e59e: e7ff         	b	0x7009e5a0 <Sciclient_rmIrqFindRoute+0x30> @ imm = #-0x2
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009e5a0: 9809         	ldr	r0, [sp, #0x24]
7009e5a2: 8a00         	ldrh	r0, [r0, #0x10]
7009e5a4: 28ff         	cmp	r0, #0xff
7009e5a6: d015         	beq	0x7009e5d4 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0x2a
7009e5a8: e7ff         	b	0x7009e5aa <Sciclient_rmIrqFindRoute+0x3a> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009e5aa: 9809         	ldr	r0, [sp, #0x24]
7009e5ac: 6800         	ldr	r0, [r0]
7009e5ae: 2104         	movs	r1, #0x4
7009e5b0: f010 fbae    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x1075c
;              true) &&
7009e5b4: b170         	cbz	r0, 0x7009e5d4 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0x1c
7009e5b6: e7ff         	b	0x7009e5b8 <Sciclient_rmIrqFindRoute+0x48> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009e5b8: 9809         	ldr	r0, [sp, #0x24]
7009e5ba: 6800         	ldr	r0, [r0]
7009e5bc: 2108         	movs	r1, #0x8
7009e5be: f010 fba7    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x1074e
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009e5c2: b138         	cbz	r0, 0x7009e5d4 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0xe
7009e5c4: e7ff         	b	0x7009e5c6 <Sciclient_rmIrqFindRoute+0x56> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNode(cfg->s_ia, &cur_n);
7009e5c6: 9809         	ldr	r0, [sp, #0x24]
7009e5c8: 8a00         	ldrh	r0, [r0, #0x10]
7009e5ca: a905         	add	r1, sp, #0x14
7009e5cc: f007 fc90    	bl	0x700a5ef0 <Sciclient_rmIrqGetNode> @ imm = #0x7920
7009e5d0: 9008         	str	r0, [sp, #0x20]
;         } else {
7009e5d2: e006         	b	0x7009e5e2 <Sciclient_rmIrqFindRoute+0x72> @ imm = #0xc
;             r = Sciclient_rmIrqGetNode(cfg->s_id, &cur_n);
7009e5d4: 9809         	ldr	r0, [sp, #0x24]
7009e5d6: 88c0         	ldrh	r0, [r0, #0x6]
7009e5d8: a905         	add	r1, sp, #0x14
7009e5da: f007 fc89    	bl	0x700a5ef0 <Sciclient_rmIrqGetNode> @ imm = #0x7912
7009e5de: 9008         	str	r0, [sp, #0x20]
7009e5e0: e7ff         	b	0x7009e5e2 <Sciclient_rmIrqFindRoute+0x72> @ imm = #-0x2
;         root_n = cur_n;
7009e5e2: 9805         	ldr	r0, [sp, #0x14]
7009e5e4: 9004         	str	r0, [sp, #0x10]
;     }
7009e5e6: e7ff         	b	0x7009e5e8 <Sciclient_rmIrqFindRoute+0x78> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009e5e8: 9808         	ldr	r0, [sp, #0x20]
7009e5ea: b968         	cbnz	r0, 0x7009e608 <Sciclient_rmIrqFindRoute+0x98> @ imm = #0x1a
7009e5ec: e7ff         	b	0x7009e5ee <Sciclient_rmIrqFindRoute+0x7e> @ imm = #-0x2
7009e5ee: 2001         	movs	r0, #0x1
;         search = true;
7009e5f0: 9002         	str	r0, [sp, #0x8]
7009e5f2: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         Sciclient_rmPsInit();
7009e5f6: f010 ff2b    	bl	0x700af450 <Sciclient_rmPsInit> @ imm = #0x10e56
7009e5fa: 9802         	ldr	r0, [sp, #0x8]
;         search_depth = 1u;
7009e5fc: f8ad 001c    	strh.w	r0, [sp, #0x1c]
7009e600: 2000         	movs	r0, #0x0
;         if_idx = 0u;
7009e602: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     } else {
7009e606: e003         	b	0x7009e610 <Sciclient_rmIrqFindRoute+0xa0> @ imm = #0x6
7009e608: 2000         	movs	r0, #0x0
;         search = false;
7009e60a: f88d 001f    	strb.w	r0, [sp, #0x1f]
7009e60e: e7ff         	b	0x7009e610 <Sciclient_rmIrqFindRoute+0xa0> @ imm = #-0x2
;     while (search == true) {
7009e610: e7ff         	b	0x7009e612 <Sciclient_rmIrqFindRoute+0xa2> @ imm = #-0x2
7009e612: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009e616: 07c0         	lsls	r0, r0, #0x1f
7009e618: 2800         	cmp	r0, #0x0
7009e61a: f000 80ca    	beq.w	0x7009e7b2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x194
7009e61e: e7ff         	b	0x7009e620 <Sciclient_rmIrqFindRoute+0xb0> @ imm = #-0x2
7009e620: 2000         	movs	r0, #0x0
;         node_clear = false;
7009e622: f88d 0019    	strb.w	r0, [sp, #0x19]
;         if (if_idx < cur_n->n_if) {
7009e626: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009e62a: 9905         	ldr	r1, [sp, #0x14]
7009e62c: 8849         	ldrh	r1, [r1, #0x2]
7009e62e: 4288         	cmp	r0, r1
7009e630: f280 8087    	bge.w	0x7009e742 <Sciclient_rmIrqFindRoute+0x1d2> @ imm = #0x10e
7009e634: e7ff         	b	0x7009e636 <Sciclient_rmIrqFindRoute+0xc6> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(cur_n, if_idx, &cur_if);
7009e636: 9805         	ldr	r0, [sp, #0x14]
7009e638: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009e63c: aa03         	add	r2, sp, #0xc
7009e63e: f00f fa27    	bl	0x700ada90 <Sciclient_rmIrqGetNodeItf> @ imm = #0xf44e
7009e642: 9008         	str	r0, [sp, #0x20]
;             if (r != SystemP_SUCCESS) {
7009e644: 9808         	ldr	r0, [sp, #0x20]
7009e646: b108         	cbz	r0, 0x7009e64c <Sciclient_rmIrqFindRoute+0xdc> @ imm = #0x2
7009e648: e7ff         	b	0x7009e64a <Sciclient_rmIrqFindRoute+0xda> @ imm = #-0x2
;                 break;
7009e64a: e0b2         	b	0x7009e7b2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x164
;             if ((Sciclient_rmIaIsIa(cur_n->id) == false) &&
7009e64c: 9805         	ldr	r0, [sp, #0x14]
7009e64e: 8800         	ldrh	r0, [r0]
7009e650: f010 f966    	bl	0x700ae920 <Sciclient_rmIaIsIa> @ imm = #0x102cc
7009e654: b9d0         	cbnz	r0, 0x7009e68c <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0x34
7009e656: e7ff         	b	0x7009e658 <Sciclient_rmIrqFindRoute+0xe8> @ imm = #-0x2
;                 (Sciclient_rmPsIsEmpty() == true) &&
7009e658: f010 fb72    	bl	0x700aed40 <Sciclient_rmPsIsEmpty> @ imm = #0x106e4
7009e65c: b1b0         	cbz	r0, 0x7009e68c <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0x2c
7009e65e: e7ff         	b	0x7009e660 <Sciclient_rmIrqFindRoute+0xf0> @ imm = #-0x2
;                 ((cfg->s_idx < cur_if->lbase) ||
7009e660: 9809         	ldr	r0, [sp, #0x24]
7009e662: 8900         	ldrh	r0, [r0, #0x8]
7009e664: 9903         	ldr	r1, [sp, #0xc]
7009e666: 8809         	ldrh	r1, [r1]
7009e668: 4288         	cmp	r0, r1
7009e66a: db09         	blt	0x7009e680 <Sciclient_rmIrqFindRoute+0x110> @ imm = #0x12
7009e66c: e7ff         	b	0x7009e66e <Sciclient_rmIrqFindRoute+0xfe> @ imm = #-0x2
;                  (cfg->s_idx >= (cur_if->lbase + cur_if->len)))) {
7009e66e: 9809         	ldr	r0, [sp, #0x24]
7009e670: 8900         	ldrh	r0, [r0, #0x8]
7009e672: 9a03         	ldr	r2, [sp, #0xc]
7009e674: 8811         	ldrh	r1, [r2]
7009e676: 8892         	ldrh	r2, [r2, #0x4]
7009e678: 4411         	add	r1, r2
;             if ((Sciclient_rmIaIsIa(cur_n->id) == false) &&
7009e67a: 4288         	cmp	r0, r1
7009e67c: db06         	blt	0x7009e68c <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0xc
7009e67e: e7ff         	b	0x7009e680 <Sciclient_rmIrqFindRoute+0x110> @ imm = #-0x2
;                 if_idx++;
7009e680: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009e684: 3001         	adds	r0, #0x1
7009e686: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             } else if (Sciclient_rmPsGetPsp() < search_depth) {
7009e68a: e059         	b	0x7009e740 <Sciclient_rmIrqFindRoute+0x1d0> @ imm = #0xb2
7009e68c: f011 fb00    	bl	0x700afc90 <Sciclient_rmPsGetPsp> @ imm = #0x11600
7009e690: f8bd 101c    	ldrh.w	r1, [sp, #0x1c]
7009e694: 4288         	cmp	r0, r1
7009e696: da1e         	bge	0x7009e6d6 <Sciclient_rmIrqFindRoute+0x166> @ imm = #0x3c
7009e698: e7ff         	b	0x7009e69a <Sciclient_rmIrqFindRoute+0x12a> @ imm = #-0x2
;                 r = Sciclient_rmPsPush(cur_n, if_idx);
7009e69a: 9805         	ldr	r0, [sp, #0x14]
7009e69c: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009e6a0: f00d ff86    	bl	0x700ac5b0 <Sciclient_rmPsPush> @ imm = #0xdf0c
7009e6a4: 9008         	str	r0, [sp, #0x20]
;                 if (r != SystemP_SUCCESS) {
7009e6a6: 9808         	ldr	r0, [sp, #0x20]
7009e6a8: b108         	cbz	r0, 0x7009e6ae <Sciclient_rmIrqFindRoute+0x13e> @ imm = #0x2
7009e6aa: e7ff         	b	0x7009e6ac <Sciclient_rmIrqFindRoute+0x13c> @ imm = #-0x2
;                     break;
7009e6ac: e081         	b	0x7009e7b2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x102
;                 r = Sciclient_rmIrqGetNode(cur_if->rid, &cur_n);
7009e6ae: 9803         	ldr	r0, [sp, #0xc]
7009e6b0: 88c0         	ldrh	r0, [r0, #0x6]
7009e6b2: a905         	add	r1, sp, #0x14
7009e6b4: f007 fc1c    	bl	0x700a5ef0 <Sciclient_rmIrqGetNode> @ imm = #0x7838
7009e6b8: 9008         	str	r0, [sp, #0x20]
;                 if (cur_n == NULL) {
7009e6ba: 9805         	ldr	r0, [sp, #0x14]
7009e6bc: b930         	cbnz	r0, 0x7009e6cc <Sciclient_rmIrqFindRoute+0x15c> @ imm = #0xc
7009e6be: e7ff         	b	0x7009e6c0 <Sciclient_rmIrqFindRoute+0x150> @ imm = #-0x2
7009e6c0: 2001         	movs	r0, #0x1
;                     node_clear = true;
7009e6c2: f88d 0019    	strb.w	r0, [sp, #0x19]
7009e6c6: 2000         	movs	r0, #0x0
;                     r = SystemP_SUCCESS;
7009e6c8: 9008         	str	r0, [sp, #0x20]
;                 } else {
7009e6ca: e003         	b	0x7009e6d4 <Sciclient_rmIrqFindRoute+0x164> @ imm = #0x6
7009e6cc: 2000         	movs	r0, #0x0
;                     if_idx = 0u;
7009e6ce: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009e6d2: e7ff         	b	0x7009e6d4 <Sciclient_rmIrqFindRoute+0x164> @ imm = #-0x2
;             } else {
7009e6d4: e033         	b	0x7009e73e <Sciclient_rmIrqFindRoute+0x1ce> @ imm = #0x66
;                 if ((cur_if->rid == cfg->d_id) &&
7009e6d6: 9803         	ldr	r0, [sp, #0xc]
7009e6d8: 88c0         	ldrh	r0, [r0, #0x6]
7009e6da: 9909         	ldr	r1, [sp, #0x24]
7009e6dc: 8949         	ldrh	r1, [r1, #0xa]
7009e6de: 4288         	cmp	r0, r1
7009e6e0: d127         	bne	0x7009e732 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x4e
7009e6e2: e7ff         	b	0x7009e6e4 <Sciclient_rmIrqFindRoute+0x174> @ imm = #-0x2
;                     (cfg->d_irq >= (cur_if->rbase)) &&
7009e6e4: 9809         	ldr	r0, [sp, #0x24]
7009e6e6: 8980         	ldrh	r0, [r0, #0xc]
7009e6e8: 9903         	ldr	r1, [sp, #0xc]
7009e6ea: 8849         	ldrh	r1, [r1, #0x2]
7009e6ec: 4288         	cmp	r0, r1
7009e6ee: db20         	blt	0x7009e732 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x40
7009e6f0: e7ff         	b	0x7009e6f2 <Sciclient_rmIrqFindRoute+0x182> @ imm = #-0x2
;                     (cfg->d_irq <
7009e6f2: 9809         	ldr	r0, [sp, #0x24]
7009e6f4: 8980         	ldrh	r0, [r0, #0xc]
;                      (cur_if->rbase + cur_if->len))) {
7009e6f6: 9a03         	ldr	r2, [sp, #0xc]
7009e6f8: 8851         	ldrh	r1, [r2, #0x2]
7009e6fa: 8892         	ldrh	r2, [r2, #0x4]
7009e6fc: 4411         	add	r1, r2
;                 if ((cur_if->rid == cfg->d_id) &&
7009e6fe: 4288         	cmp	r0, r1
7009e700: da17         	bge	0x7009e732 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x2e
7009e702: e7ff         	b	0x7009e704 <Sciclient_rmIrqFindRoute+0x194> @ imm = #-0x2
;                     r = Sciclient_rmPsPush(cur_n, if_idx);
7009e704: 9805         	ldr	r0, [sp, #0x14]
7009e706: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009e70a: f00d ff51    	bl	0x700ac5b0 <Sciclient_rmPsPush> @ imm = #0xdea2
7009e70e: 9008         	str	r0, [sp, #0x20]
;                     if (r != SystemP_SUCCESS) {
7009e710: 9808         	ldr	r0, [sp, #0x20]
7009e712: b108         	cbz	r0, 0x7009e718 <Sciclient_rmIrqFindRoute+0x1a8> @ imm = #0x2
7009e714: e7ff         	b	0x7009e716 <Sciclient_rmIrqFindRoute+0x1a6> @ imm = #-0x2
;                         break;
7009e716: e04c         	b	0x7009e7b2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x98
;                     if (Sciclient_rmIrqRouteValidate(cfg) == true) {
7009e718: 9809         	ldr	r0, [sp, #0x24]
7009e71a: f7fc fa01    	bl	0x7009ab20 <Sciclient_rmIrqRouteValidate> @ imm = #-0x3bfe
7009e71e: b108         	cbz	r0, 0x7009e724 <Sciclient_rmIrqFindRoute+0x1b4> @ imm = #0x2
7009e720: e7ff         	b	0x7009e722 <Sciclient_rmIrqFindRoute+0x1b2> @ imm = #-0x2
;                         break;
7009e722: e046         	b	0x7009e7b2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x8c
7009e724: a805         	add	r0, sp, #0x14
7009e726: f10d 011a    	add.w	r1, sp, #0x1a
;                         Sciclient_rmPsPop(&cur_n, &if_idx);
7009e72a: f00b faa9    	bl	0x700a9c80 <Sciclient_rmPsPop> @ imm = #0xb552
7009e72e: e7ff         	b	0x7009e730 <Sciclient_rmIrqFindRoute+0x1c0> @ imm = #-0x2
;                 }
7009e730: e7ff         	b	0x7009e732 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #-0x2
;                 if_idx++;
7009e732: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009e736: 3001         	adds	r0, #0x1
7009e738: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009e73c: e7ff         	b	0x7009e73e <Sciclient_rmIrqFindRoute+0x1ce> @ imm = #-0x2
7009e73e: e7ff         	b	0x7009e740 <Sciclient_rmIrqFindRoute+0x1d0> @ imm = #-0x2
;         } else {
7009e740: e003         	b	0x7009e74a <Sciclient_rmIrqFindRoute+0x1da> @ imm = #0x6
7009e742: 2001         	movs	r0, #0x1
;             node_clear = true;
7009e744: f88d 0019    	strb.w	r0, [sp, #0x19]
7009e748: e7ff         	b	0x7009e74a <Sciclient_rmIrqFindRoute+0x1da> @ imm = #-0x2
;         if (node_clear == true) {
7009e74a: f89d 0019    	ldrb.w	r0, [sp, #0x19]
7009e74e: 07c0         	lsls	r0, r0, #0x1f
7009e750: b370         	cbz	r0, 0x7009e7b0 <Sciclient_rmIrqFindRoute+0x240> @ imm = #0x5c
7009e752: e7ff         	b	0x7009e754 <Sciclient_rmIrqFindRoute+0x1e4> @ imm = #-0x2
;             if (Sciclient_rmPsIsEmpty() == true) {
7009e754: f010 faf4    	bl	0x700aed40 <Sciclient_rmPsIsEmpty> @ imm = #0x105e8
7009e758: b1c8         	cbz	r0, 0x7009e78e <Sciclient_rmIrqFindRoute+0x21e> @ imm = #0x32
7009e75a: e7ff         	b	0x7009e75c <Sciclient_rmIrqFindRoute+0x1ec> @ imm = #-0x2
;                 search_depth++;
7009e75c: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
7009e760: 3001         	adds	r0, #0x1
7009e762: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;                 cur_n = root_n;
7009e766: 9804         	ldr	r0, [sp, #0x10]
7009e768: 9005         	str	r0, [sp, #0x14]
7009e76a: 2000         	movs	r0, #0x0
;                 if_idx = 0u;
7009e76c: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;                 if (search_depth >= Sciclient_rmPsGetMaxPsp()) {
7009e770: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
7009e774: 9001         	str	r0, [sp, #0x4]
7009e776: f011 faeb    	bl	0x700afd50 <Sciclient_rmPsGetMaxPsp> @ imm = #0x115d6
7009e77a: 4601         	mov	r1, r0
7009e77c: 9801         	ldr	r0, [sp, #0x4]
7009e77e: 4288         	cmp	r0, r1
7009e780: db04         	blt	0x7009e78c <Sciclient_rmIrqFindRoute+0x21c> @ imm = #0x8
7009e782: e7ff         	b	0x7009e784 <Sciclient_rmIrqFindRoute+0x214> @ imm = #-0x2
7009e784: f04f 30ff    	mov.w	r0, #0xffffffff
;                     r = SystemP_FAILURE;
7009e788: 9008         	str	r0, [sp, #0x20]
;                     break;
7009e78a: e012         	b	0x7009e7b2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x24
;             } else {
7009e78c: e00f         	b	0x7009e7ae <Sciclient_rmIrqFindRoute+0x23e> @ imm = #0x1e
7009e78e: a805         	add	r0, sp, #0x14
7009e790: f10d 011a    	add.w	r1, sp, #0x1a
;                 r = Sciclient_rmPsPop(&cur_n, &if_idx);
7009e794: f00b fa74    	bl	0x700a9c80 <Sciclient_rmPsPop> @ imm = #0xb4e8
7009e798: 9008         	str	r0, [sp, #0x20]
;                 if (r != SystemP_SUCCESS) {
7009e79a: 9808         	ldr	r0, [sp, #0x20]
7009e79c: b108         	cbz	r0, 0x7009e7a2 <Sciclient_rmIrqFindRoute+0x232> @ imm = #0x2
7009e79e: e7ff         	b	0x7009e7a0 <Sciclient_rmIrqFindRoute+0x230> @ imm = #-0x2
;                     break;
7009e7a0: e007         	b	0x7009e7b2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0xe
;                 if_idx++;
7009e7a2: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009e7a6: 3001         	adds	r0, #0x1
7009e7a8: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009e7ac: e7ff         	b	0x7009e7ae <Sciclient_rmIrqFindRoute+0x23e> @ imm = #-0x2
;         }
7009e7ae: e7ff         	b	0x7009e7b0 <Sciclient_rmIrqFindRoute+0x240> @ imm = #-0x2
;     while (search == true) {
7009e7b0: e72f         	b	0x7009e612 <Sciclient_rmIrqFindRoute+0xa2> @ imm = #-0x1a2
;     return r;
7009e7b2: 9808         	ldr	r0, [sp, #0x20]
7009e7b4: b00a         	add	sp, #0x28
7009e7b6: bd80         	pop	{r7, pc}
		...

7009e7c0 <UART_fifoConfig>:
; {
7009e7c0: b580         	push	{r7, lr}
7009e7c2: b092         	sub	sp, #0x48
7009e7c4: 9011         	str	r0, [sp, #0x44]
7009e7c6: 9110         	str	r1, [sp, #0x40]
7009e7c8: 2000         	movs	r0, #0x0
;     uint32_t fcrValue = 0U;
7009e7ca: 900c         	str	r0, [sp, #0x30]
;     uint32_t txGra = (fifoConfig & UART_FIFO_CONFIG_TXGRA) >> 26;
7009e7cc: 9810         	ldr	r0, [sp, #0x40]
7009e7ce: f3c0 6083    	ubfx	r0, r0, #0x1a, #0x4
7009e7d2: 900b         	str	r0, [sp, #0x2c]
;     uint32_t rxGra = (fifoConfig & UART_FIFO_CONFIG_RXGRA) >> 22;
7009e7d4: 9810         	ldr	r0, [sp, #0x40]
7009e7d6: f3c0 5083    	ubfx	r0, r0, #0x16, #0x4
7009e7da: 900a         	str	r0, [sp, #0x28]
;     uint32_t txTrig = (fifoConfig & UART_FIFO_CONFIG_TXTRIG) >> 14;
7009e7dc: 9810         	ldr	r0, [sp, #0x40]
7009e7de: f3c0 3087    	ubfx	r0, r0, #0xe, #0x8
7009e7e2: 9009         	str	r0, [sp, #0x24]
;     uint32_t rxTrig = (fifoConfig & UART_FIFO_CONFIG_RXTRIG) >> 6;
7009e7e4: 9810         	ldr	r0, [sp, #0x40]
7009e7e6: f3c0 1087    	ubfx	r0, r0, #0x6, #0x8
7009e7ea: 9008         	str	r0, [sp, #0x20]
;     uint32_t txClr = (fifoConfig & UART_FIFO_CONFIG_TXCLR) >> 5;
7009e7ec: 9810         	ldr	r0, [sp, #0x40]
7009e7ee: f3c0 1040    	ubfx	r0, r0, #0x5, #0x1
7009e7f2: 9007         	str	r0, [sp, #0x1c]
;     uint32_t rxClr = (fifoConfig & UART_FIFO_CONFIG_RXCLR) >> 4;
7009e7f4: 9810         	ldr	r0, [sp, #0x40]
7009e7f6: f3c0 1000    	ubfx	r0, r0, #0x4, #0x1
7009e7fa: 9006         	str	r0, [sp, #0x18]
;     uint32_t dmaEnPath = (fifoConfig & UART_FIFO_CONFIG_DMAENPATH) >> 3;
7009e7fc: 9810         	ldr	r0, [sp, #0x40]
7009e7fe: f3c0 00c0    	ubfx	r0, r0, #0x3, #0x1
7009e802: 9005         	str	r0, [sp, #0x14]
;     uint32_t dmaMode   = (fifoConfig & UART_FIFO_CONFIG_DMAMODE);
7009e804: 9810         	ldr	r0, [sp, #0x40]
7009e806: f000 0007    	and	r0, r0, #0x7
7009e80a: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = UART_enhanFuncEnable(baseAddr);
7009e80c: 9811         	ldr	r0, [sp, #0x44]
7009e80e: f00f fc5f    	bl	0x700ae0d0 <UART_enhanFuncEnable> @ imm = #0xf8be
7009e812: 900f         	str	r0, [sp, #0x3c]
;     tcrTlrBitVal = UART_subConfigTCRTLRModeEn(baseAddr);
7009e814: 9811         	ldr	r0, [sp, #0x44]
7009e816: f00a ff63    	bl	0x700a96e0 <UART_subConfigTCRTLRModeEn> @ imm = #0xaec6
7009e81a: 900e         	str	r0, [sp, #0x38]
;     fcrValue |= UART_FCR_FIFO_EN_MASK;
7009e81c: 980c         	ldr	r0, [sp, #0x30]
7009e81e: f040 0001    	orr	r0, r0, #0x1
7009e822: 900c         	str	r0, [sp, #0x30]
;     if(UART_TRIG_LVL_GRANULARITY_1 != rxGra)
7009e824: 980a         	ldr	r0, [sp, #0x28]
7009e826: 2801         	cmp	r0, #0x1
7009e828: d033         	beq	0x7009e892 <UART_fifoConfig+0xd2> @ imm = #0x66
7009e82a: e7ff         	b	0x7009e82c <UART_fifoConfig+0x6c> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_RX_TRIG_GRANU1,
7009e82c: 9811         	ldr	r0, [sp, #0x44]
7009e82e: 3040         	adds	r0, #0x40
7009e830: 2180         	movs	r1, #0x80
7009e832: 2207         	movs	r2, #0x7
7009e834: 2300         	movs	r3, #0x0
7009e836: 9303         	str	r3, [sp, #0xc]
7009e838: f00f ff42    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0xfe84
7009e83c: 9b03         	ldr	r3, [sp, #0xc]
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA,
7009e83e: 9811         	ldr	r0, [sp, #0x44]
7009e840: 301c         	adds	r0, #0x1c
7009e842: 21f0         	movs	r1, #0xf0
7009e844: 2204         	movs	r2, #0x4
7009e846: f00f ff3b    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0xfe76
;         fcrValue &= ~((uint32_t) UART_FCR_RX_FIFO_TRIG_MASK);
7009e84a: 980c         	ldr	r0, [sp, #0x30]
7009e84c: f020 00c0    	bic	r0, r0, #0xc0
7009e850: 900c         	str	r0, [sp, #0x30]
;         if((UART_RXTRIGLVL_8 == rxTrig) ||
7009e852: 9808         	ldr	r0, [sp, #0x20]
7009e854: 2808         	cmp	r0, #0x8
7009e856: d00c         	beq	0x7009e872 <UART_fifoConfig+0xb2> @ imm = #0x18
7009e858: e7ff         	b	0x7009e85a <UART_fifoConfig+0x9a> @ imm = #-0x2
;            (UART_RXTRIGLVL_16 == rxTrig) ||
7009e85a: 9808         	ldr	r0, [sp, #0x20]
7009e85c: 2810         	cmp	r0, #0x10
7009e85e: d008         	beq	0x7009e872 <UART_fifoConfig+0xb2> @ imm = #0x10
7009e860: e7ff         	b	0x7009e862 <UART_fifoConfig+0xa2> @ imm = #-0x2
;            (UART_RXTRIGLVL_56 == rxTrig) ||
7009e862: 9808         	ldr	r0, [sp, #0x20]
7009e864: 2838         	cmp	r0, #0x38
7009e866: d004         	beq	0x7009e872 <UART_fifoConfig+0xb2> @ imm = #0x8
7009e868: e7ff         	b	0x7009e86a <UART_fifoConfig+0xaa> @ imm = #-0x2
;            (UART_RXTRIGLVL_60 == rxTrig))
7009e86a: 9808         	ldr	r0, [sp, #0x20]
;         if((UART_RXTRIGLVL_8 == rxTrig) ||
7009e86c: 283c         	cmp	r0, #0x3c
7009e86e: d107         	bne	0x7009e880 <UART_fifoConfig+0xc0> @ imm = #0xe
7009e870: e7ff         	b	0x7009e872 <UART_fifoConfig+0xb2> @ imm = #-0x2
;             fcrValue |= rxTrig & UART_FCR_RX_FIFO_TRIG_MASK;
7009e872: 9808         	ldr	r0, [sp, #0x20]
7009e874: f000 01c0    	and	r1, r0, #0xc0
7009e878: 980c         	ldr	r0, [sp, #0x30]
7009e87a: 4308         	orrs	r0, r1
7009e87c: 900c         	str	r0, [sp, #0x30]
;         }
7009e87e: e007         	b	0x7009e890 <UART_fifoConfig+0xd0> @ imm = #0xe
;             HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA,
7009e880: 9811         	ldr	r0, [sp, #0x44]
7009e882: 301c         	adds	r0, #0x1c
7009e884: 9b08         	ldr	r3, [sp, #0x20]
7009e886: 21f0         	movs	r1, #0xf0
7009e888: 2204         	movs	r2, #0x4
7009e88a: f00f ff19    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0xfe32
7009e88e: e7ff         	b	0x7009e890 <UART_fifoConfig+0xd0> @ imm = #-0x2
;     }
7009e890: e01d         	b	0x7009e8ce <UART_fifoConfig+0x10e> @ imm = #0x3a
;         rxTrig &= 0x003FU;
7009e892: 9808         	ldr	r0, [sp, #0x20]
7009e894: f000 003f    	and	r0, r0, #0x3f
7009e898: 9008         	str	r0, [sp, #0x20]
;         tlrValue = (rxTrig & 0x003CU) >> 2;
7009e89a: 9808         	ldr	r0, [sp, #0x20]
7009e89c: f3c0 0083    	ubfx	r0, r0, #0x2, #0x4
7009e8a0: 900d         	str	r0, [sp, #0x34]
;         fcrValue |= (rxTrig & 0x0003U) << UART_FCR_RX_FIFO_TRIG_SHIFT;
7009e8a2: 9808         	ldr	r0, [sp, #0x20]
7009e8a4: f000 0103    	and	r1, r0, #0x3
7009e8a8: 980c         	ldr	r0, [sp, #0x30]
7009e8aa: ea40 1081    	orr.w	r0, r0, r1, lsl #6
7009e8ae: 900c         	str	r0, [sp, #0x30]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_RX_TRIG_GRANU1,
7009e8b0: 9811         	ldr	r0, [sp, #0x44]
7009e8b2: 3040         	adds	r0, #0x40
7009e8b4: 2180         	movs	r1, #0x80
7009e8b6: 2207         	movs	r2, #0x7
7009e8b8: 2301         	movs	r3, #0x1
7009e8ba: f00f ff01    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0xfe02
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA, tlrValue);
7009e8be: 9811         	ldr	r0, [sp, #0x44]
7009e8c0: 301c         	adds	r0, #0x1c
7009e8c2: 9b0d         	ldr	r3, [sp, #0x34]
7009e8c4: 21f0         	movs	r1, #0xf0
7009e8c6: 2204         	movs	r2, #0x4
7009e8c8: f00f fefa    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0xfdf4
7009e8cc: e7ff         	b	0x7009e8ce <UART_fifoConfig+0x10e> @ imm = #-0x2
;     if(UART_TRIG_LVL_GRANULARITY_1 != txGra)
7009e8ce: 980b         	ldr	r0, [sp, #0x2c]
7009e8d0: 2801         	cmp	r0, #0x1
7009e8d2: d033         	beq	0x7009e93c <UART_fifoConfig+0x17c> @ imm = #0x66
7009e8d4: e7ff         	b	0x7009e8d6 <UART_fifoConfig+0x116> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_TX_TRIG_GRANU1,
7009e8d6: 9811         	ldr	r0, [sp, #0x44]
7009e8d8: 3040         	adds	r0, #0x40
7009e8da: 2140         	movs	r1, #0x40
7009e8dc: 2206         	movs	r2, #0x6
7009e8de: 2300         	movs	r3, #0x0
7009e8e0: 9302         	str	r3, [sp, #0x8]
7009e8e2: f00f feed    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0xfdda
7009e8e6: 9b02         	ldr	r3, [sp, #0x8]
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA,
7009e8e8: 9811         	ldr	r0, [sp, #0x44]
7009e8ea: 301c         	adds	r0, #0x1c
7009e8ec: 210f         	movs	r1, #0xf
7009e8ee: 461a         	mov	r2, r3
7009e8f0: f00f fee6    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0xfdcc
;         fcrValue &= ~((uint32_t) UART_FCR_TX_FIFO_TRIG_MASK);
7009e8f4: 980c         	ldr	r0, [sp, #0x30]
7009e8f6: f020 0030    	bic	r0, r0, #0x30
7009e8fa: 900c         	str	r0, [sp, #0x30]
;         if((UART_TXTRIGLVL_8 == (txTrig)) ||
7009e8fc: 9809         	ldr	r0, [sp, #0x24]
7009e8fe: 2808         	cmp	r0, #0x8
7009e900: d00c         	beq	0x7009e91c <UART_fifoConfig+0x15c> @ imm = #0x18
7009e902: e7ff         	b	0x7009e904 <UART_fifoConfig+0x144> @ imm = #-0x2
;            (UART_TXTRIGLVL_16 == (txTrig)) ||
7009e904: 9809         	ldr	r0, [sp, #0x24]
7009e906: 2810         	cmp	r0, #0x10
7009e908: d008         	beq	0x7009e91c <UART_fifoConfig+0x15c> @ imm = #0x10
7009e90a: e7ff         	b	0x7009e90c <UART_fifoConfig+0x14c> @ imm = #-0x2
;            (UART_TXTRIGLVL_32 == (txTrig)) ||
7009e90c: 9809         	ldr	r0, [sp, #0x24]
7009e90e: 2820         	cmp	r0, #0x20
7009e910: d004         	beq	0x7009e91c <UART_fifoConfig+0x15c> @ imm = #0x8
7009e912: e7ff         	b	0x7009e914 <UART_fifoConfig+0x154> @ imm = #-0x2
;            (UART_TXTRIGLVL_56 == (txTrig)))
7009e914: 9809         	ldr	r0, [sp, #0x24]
;         if((UART_TXTRIGLVL_8 == (txTrig)) ||
7009e916: 2838         	cmp	r0, #0x38
7009e918: d107         	bne	0x7009e92a <UART_fifoConfig+0x16a> @ imm = #0xe
7009e91a: e7ff         	b	0x7009e91c <UART_fifoConfig+0x15c> @ imm = #-0x2
;             fcrValue |= txTrig & UART_FCR_TX_FIFO_TRIG_MASK;
7009e91c: 9809         	ldr	r0, [sp, #0x24]
7009e91e: f000 0130    	and	r1, r0, #0x30
7009e922: 980c         	ldr	r0, [sp, #0x30]
7009e924: 4308         	orrs	r0, r1
7009e926: 900c         	str	r0, [sp, #0x30]
;         }
7009e928: e007         	b	0x7009e93a <UART_fifoConfig+0x17a> @ imm = #0xe
;             HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA,
7009e92a: 9811         	ldr	r0, [sp, #0x44]
7009e92c: 301c         	adds	r0, #0x1c
7009e92e: 9b09         	ldr	r3, [sp, #0x24]
7009e930: 210f         	movs	r1, #0xf
7009e932: 2200         	movs	r2, #0x0
7009e934: f00f fec4    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0xfd88
7009e938: e7ff         	b	0x7009e93a <UART_fifoConfig+0x17a> @ imm = #-0x2
;     }
7009e93a: e01d         	b	0x7009e978 <UART_fifoConfig+0x1b8> @ imm = #0x3a
;         txTrig &= 0x003FU;
7009e93c: 9809         	ldr	r0, [sp, #0x24]
7009e93e: f000 003f    	and	r0, r0, #0x3f
7009e942: 9009         	str	r0, [sp, #0x24]
;         tlrValue = (txTrig & 0x003CU) >> 2;
7009e944: 9809         	ldr	r0, [sp, #0x24]
7009e946: f3c0 0083    	ubfx	r0, r0, #0x2, #0x4
7009e94a: 900d         	str	r0, [sp, #0x34]
;         fcrValue |= (txTrig & 0x0003U) << UART_FCR_TX_FIFO_TRIG_SHIFT;
7009e94c: 9809         	ldr	r0, [sp, #0x24]
7009e94e: f000 0103    	and	r1, r0, #0x3
7009e952: 980c         	ldr	r0, [sp, #0x30]
7009e954: ea40 1001    	orr.w	r0, r0, r1, lsl #4
7009e958: 900c         	str	r0, [sp, #0x30]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_TX_TRIG_GRANU1,
7009e95a: 9811         	ldr	r0, [sp, #0x44]
7009e95c: 3040         	adds	r0, #0x40
7009e95e: 2140         	movs	r1, #0x40
7009e960: 2206         	movs	r2, #0x6
7009e962: 2301         	movs	r3, #0x1
7009e964: f00f feac    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0xfd58
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA, tlrValue);
7009e968: 9811         	ldr	r0, [sp, #0x44]
7009e96a: 301c         	adds	r0, #0x1c
7009e96c: 9b0d         	ldr	r3, [sp, #0x34]
7009e96e: 210f         	movs	r1, #0xf
7009e970: 2200         	movs	r2, #0x0
7009e972: f00f fea5    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0xfd4a
7009e976: e7ff         	b	0x7009e978 <UART_fifoConfig+0x1b8> @ imm = #-0x2
;     if(UART_DMA_EN_PATH_FCR == dmaEnPath)
7009e978: 9805         	ldr	r0, [sp, #0x14]
7009e97a: b9a8         	cbnz	r0, 0x7009e9a8 <UART_fifoConfig+0x1e8> @ imm = #0x2a
7009e97c: e7ff         	b	0x7009e97e <UART_fifoConfig+0x1be> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_CTL,
7009e97e: 9811         	ldr	r0, [sp, #0x44]
7009e980: 3040         	adds	r0, #0x40
7009e982: 2101         	movs	r1, #0x1
7009e984: 2300         	movs	r3, #0x0
7009e986: 461a         	mov	r2, r3
7009e988: f00f fe9a    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0xfd34
;         dmaMode &= 0x1U;
7009e98c: 9804         	ldr	r0, [sp, #0x10]
7009e98e: f000 0001    	and	r0, r0, #0x1
7009e992: 9004         	str	r0, [sp, #0x10]
;         fcrValue &= ~((uint32_t) UART_FCR_DMA_MODE_MASK);
7009e994: 980c         	ldr	r0, [sp, #0x30]
7009e996: f020 0008    	bic	r0, r0, #0x8
7009e99a: 900c         	str	r0, [sp, #0x30]
;         fcrValue |= dmaMode << UART_FCR_DMA_MODE_SHIFT;
7009e99c: 9904         	ldr	r1, [sp, #0x10]
7009e99e: 980c         	ldr	r0, [sp, #0x30]
7009e9a0: ea40 00c1    	orr.w	r0, r0, r1, lsl #3
7009e9a4: 900c         	str	r0, [sp, #0x30]
;     }
7009e9a6: e013         	b	0x7009e9d0 <UART_fifoConfig+0x210> @ imm = #0x26
;         dmaMode &= 0x3U;
7009e9a8: 9804         	ldr	r0, [sp, #0x10]
7009e9aa: f000 0003    	and	r0, r0, #0x3
7009e9ae: 9004         	str	r0, [sp, #0x10]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_CTL,
7009e9b0: 9811         	ldr	r0, [sp, #0x44]
7009e9b2: 3040         	adds	r0, #0x40
7009e9b4: 2200         	movs	r2, #0x0
7009e9b6: 2301         	movs	r3, #0x1
7009e9b8: 9301         	str	r3, [sp, #0x4]
7009e9ba: 4619         	mov	r1, r3
7009e9bc: f00f fe80    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0xfd00
7009e9c0: 9a01         	ldr	r2, [sp, #0x4]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_2, dmaMode);
7009e9c2: 9811         	ldr	r0, [sp, #0x44]
7009e9c4: 3040         	adds	r0, #0x40
7009e9c6: 9b04         	ldr	r3, [sp, #0x10]
7009e9c8: 2106         	movs	r1, #0x6
7009e9ca: f00f fe79    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0xfcf2
7009e9ce: e7ff         	b	0x7009e9d0 <UART_fifoConfig+0x210> @ imm = #-0x2
;     fcrValue |= rxClr << UART_FCR_RX_FIFO_CLEAR_SHIFT;
7009e9d0: 9906         	ldr	r1, [sp, #0x18]
7009e9d2: 980c         	ldr	r0, [sp, #0x30]
7009e9d4: ea40 0041    	orr.w	r0, r0, r1, lsl #1
7009e9d8: 900c         	str	r0, [sp, #0x30]
;     fcrValue |= txClr << UART_FCR_TX_FIFO_CLEAR_SHIFT;
7009e9da: 9907         	ldr	r1, [sp, #0x1c]
7009e9dc: 980c         	ldr	r0, [sp, #0x30]
7009e9de: ea40 0081    	orr.w	r0, r0, r1, lsl #2
7009e9e2: 900c         	str	r0, [sp, #0x30]
;     UART_fifoRegisterWrite(baseAddr, fcrValue);
7009e9e4: 9811         	ldr	r0, [sp, #0x44]
7009e9e6: 990c         	ldr	r1, [sp, #0x30]
7009e9e8: f00d f902    	bl	0x700abbf0 <UART_fifoRegisterWrite> @ imm = #0xd204
;     UART_tcrTlrBitValRestore(baseAddr, tcrTlrBitVal);
7009e9ec: 9811         	ldr	r0, [sp, #0x44]
7009e9ee: 990e         	ldr	r1, [sp, #0x38]
7009e9f0: f00b fd8e    	bl	0x700aa510 <UART_tcrTlrBitValRestore> @ imm = #0xbb1c
;     UART_enhanFuncBitValRestore(baseAddr, enhanFnBitVal);
7009e9f4: 9811         	ldr	r0, [sp, #0x44]
7009e9f6: 990f         	ldr	r1, [sp, #0x3c]
7009e9f8: f00f fe82    	bl	0x700ae700 <UART_enhanFuncBitValRestore> @ imm = #0xfd04
;     return fcrValue;
7009e9fc: 980c         	ldr	r0, [sp, #0x30]
7009e9fe: b012         	add	sp, #0x48
7009ea00: bd80         	pop	{r7, pc}
		...
7009ea0e: 0000         	movs	r0, r0

7009ea10 <_ntoa_format>:
; {
7009ea10: b570         	push	{r4, r5, r6, lr}
7009ea12: b08c         	sub	sp, #0x30
7009ea14: 4684         	mov	r12, r0
7009ea16: 9816         	ldr	r0, [sp, #0x58]
7009ea18: 9815         	ldr	r0, [sp, #0x54]
7009ea1a: 9814         	ldr	r0, [sp, #0x50]
7009ea1c: 9813         	ldr	r0, [sp, #0x4c]
7009ea1e: 9812         	ldr	r0, [sp, #0x48]
7009ea20: f8dd e044    	ldr.w	lr, [sp, #0x44]
7009ea24: f8dd e040    	ldr.w	lr, [sp, #0x40]
7009ea28: f8cd c02c    	str.w	r12, [sp, #0x2c]
7009ea2c: 910a         	str	r1, [sp, #0x28]
7009ea2e: 9209         	str	r2, [sp, #0x24]
7009ea30: 9308         	str	r3, [sp, #0x20]
7009ea32: f88d 001f    	strb.w	r0, [sp, #0x1f]
;   if (!(flags & FLAGS_LEFT)) {
7009ea36: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009ea3a: 0780         	lsls	r0, r0, #0x1e
7009ea3c: 2800         	cmp	r0, #0x0
7009ea3e: d454         	bmi	0x7009eaea <_ntoa_format+0xda> @ imm = #0xa8
7009ea40: e7ff         	b	0x7009ea42 <_ntoa_format+0x32> @ imm = #-0x2
;     if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
7009ea42: 9815         	ldr	r0, [sp, #0x54]
7009ea44: b1a0         	cbz	r0, 0x7009ea70 <_ntoa_format+0x60> @ imm = #0x28
7009ea46: e7ff         	b	0x7009ea48 <_ntoa_format+0x38> @ imm = #-0x2
7009ea48: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009ea4c: 07c0         	lsls	r0, r0, #0x1f
7009ea4e: b178         	cbz	r0, 0x7009ea70 <_ntoa_format+0x60> @ imm = #0x1e
7009ea50: e7ff         	b	0x7009ea52 <_ntoa_format+0x42> @ imm = #-0x2
7009ea52: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009ea56: 07c0         	lsls	r0, r0, #0x1f
7009ea58: b930         	cbnz	r0, 0x7009ea68 <_ntoa_format+0x58> @ imm = #0xc
7009ea5a: e7ff         	b	0x7009ea5c <_ntoa_format+0x4c> @ imm = #-0x2
7009ea5c: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009ea60: f010 0f0c    	tst.w	r0, #0xc
7009ea64: d004         	beq	0x7009ea70 <_ntoa_format+0x60> @ imm = #0x8
7009ea66: e7ff         	b	0x7009ea68 <_ntoa_format+0x58> @ imm = #-0x2
;       width--;
7009ea68: 9815         	ldr	r0, [sp, #0x54]
7009ea6a: 3801         	subs	r0, #0x1
7009ea6c: 9015         	str	r0, [sp, #0x54]
;     }
7009ea6e: e7ff         	b	0x7009ea70 <_ntoa_format+0x60> @ imm = #-0x2
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009ea70: e7ff         	b	0x7009ea72 <_ntoa_format+0x62> @ imm = #-0x2
7009ea72: 9911         	ldr	r1, [sp, #0x44]
7009ea74: 9a14         	ldr	r2, [sp, #0x50]
7009ea76: 2000         	movs	r0, #0x0
7009ea78: 4291         	cmp	r1, r2
7009ea7a: 9006         	str	r0, [sp, #0x18]
7009ea7c: d207         	bhs	0x7009ea8e <_ntoa_format+0x7e> @ imm = #0xe
7009ea7e: e7ff         	b	0x7009ea80 <_ntoa_format+0x70> @ imm = #-0x2
7009ea80: 9911         	ldr	r1, [sp, #0x44]
7009ea82: 2000         	movs	r0, #0x0
7009ea84: 2920         	cmp	r1, #0x20
7009ea86: bf38         	it	lo
7009ea88: 2001         	movlo	r0, #0x1
7009ea8a: 9006         	str	r0, [sp, #0x18]
7009ea8c: e7ff         	b	0x7009ea8e <_ntoa_format+0x7e> @ imm = #-0x2
7009ea8e: 9806         	ldr	r0, [sp, #0x18]
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009ea90: 07c0         	lsls	r0, r0, #0x1f
7009ea92: b138         	cbz	r0, 0x7009eaa4 <_ntoa_format+0x94> @ imm = #0xe
7009ea94: e7ff         	b	0x7009ea96 <_ntoa_format+0x86> @ imm = #-0x2
;       buf[len++] = '0';
7009ea96: 9910         	ldr	r1, [sp, #0x40]
7009ea98: 9a11         	ldr	r2, [sp, #0x44]
7009ea9a: 1c50         	adds	r0, r2, #0x1
7009ea9c: 9011         	str	r0, [sp, #0x44]
7009ea9e: 2030         	movs	r0, #0x30
7009eaa0: 5488         	strb	r0, [r1, r2]
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009eaa2: e7e6         	b	0x7009ea72 <_ntoa_format+0x62> @ imm = #-0x34
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009eaa4: e7ff         	b	0x7009eaa6 <_ntoa_format+0x96> @ imm = #-0x2
7009eaa6: 2000         	movs	r0, #0x0
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009eaa8: f89d 1058    	ldrb.w	r1, [sp, #0x58]
7009eaac: ea4f 71c1    	lsl.w	r1, r1, #0x1f
7009eab0: 9005         	str	r0, [sp, #0x14]
7009eab2: b171         	cbz	r1, 0x7009ead2 <_ntoa_format+0xc2> @ imm = #0x1c
7009eab4: e7ff         	b	0x7009eab6 <_ntoa_format+0xa6> @ imm = #-0x2
7009eab6: 9911         	ldr	r1, [sp, #0x44]
7009eab8: 9a15         	ldr	r2, [sp, #0x54]
7009eaba: 2000         	movs	r0, #0x0
7009eabc: 4291         	cmp	r1, r2
7009eabe: 9005         	str	r0, [sp, #0x14]
7009eac0: d207         	bhs	0x7009ead2 <_ntoa_format+0xc2> @ imm = #0xe
7009eac2: e7ff         	b	0x7009eac4 <_ntoa_format+0xb4> @ imm = #-0x2
7009eac4: 9911         	ldr	r1, [sp, #0x44]
7009eac6: 2000         	movs	r0, #0x0
7009eac8: 2920         	cmp	r1, #0x20
7009eaca: bf38         	it	lo
7009eacc: 2001         	movlo	r0, #0x1
7009eace: 9005         	str	r0, [sp, #0x14]
7009ead0: e7ff         	b	0x7009ead2 <_ntoa_format+0xc2> @ imm = #-0x2
7009ead2: 9805         	ldr	r0, [sp, #0x14]
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009ead4: 07c0         	lsls	r0, r0, #0x1f
7009ead6: b138         	cbz	r0, 0x7009eae8 <_ntoa_format+0xd8> @ imm = #0xe
7009ead8: e7ff         	b	0x7009eada <_ntoa_format+0xca> @ imm = #-0x2
;       buf[len++] = '0';
7009eada: 9910         	ldr	r1, [sp, #0x40]
7009eadc: 9a11         	ldr	r2, [sp, #0x44]
7009eade: 1c50         	adds	r0, r2, #0x1
7009eae0: 9011         	str	r0, [sp, #0x44]
7009eae2: 2030         	movs	r0, #0x30
7009eae4: 5488         	strb	r0, [r1, r2]
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009eae6: e7de         	b	0x7009eaa6 <_ntoa_format+0x96> @ imm = #-0x44
;   }
7009eae8: e7ff         	b	0x7009eaea <_ntoa_format+0xda> @ imm = #-0x2
;   if (flags & FLAGS_HASH) {
7009eaea: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009eaee: 06c0         	lsls	r0, r0, #0x1b
7009eaf0: 2800         	cmp	r0, #0x0
7009eaf2: d569         	bpl	0x7009ebc8 <_ntoa_format+0x1b8> @ imm = #0xd2
7009eaf4: e7ff         	b	0x7009eaf6 <_ntoa_format+0xe6> @ imm = #-0x2
;     if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
7009eaf6: f89d 0059    	ldrb.w	r0, [sp, #0x59]
7009eafa: 0740         	lsls	r0, r0, #0x1d
7009eafc: 2800         	cmp	r0, #0x0
7009eafe: d41c         	bmi	0x7009eb3a <_ntoa_format+0x12a> @ imm = #0x38
7009eb00: e7ff         	b	0x7009eb02 <_ntoa_format+0xf2> @ imm = #-0x2
7009eb02: 9811         	ldr	r0, [sp, #0x44]
7009eb04: b1c8         	cbz	r0, 0x7009eb3a <_ntoa_format+0x12a> @ imm = #0x32
7009eb06: e7ff         	b	0x7009eb08 <_ntoa_format+0xf8> @ imm = #-0x2
7009eb08: 9811         	ldr	r0, [sp, #0x44]
7009eb0a: 9914         	ldr	r1, [sp, #0x50]
7009eb0c: 4288         	cmp	r0, r1
7009eb0e: d005         	beq	0x7009eb1c <_ntoa_format+0x10c> @ imm = #0xa
7009eb10: e7ff         	b	0x7009eb12 <_ntoa_format+0x102> @ imm = #-0x2
7009eb12: 9811         	ldr	r0, [sp, #0x44]
7009eb14: 9915         	ldr	r1, [sp, #0x54]
7009eb16: 4288         	cmp	r0, r1
7009eb18: d10f         	bne	0x7009eb3a <_ntoa_format+0x12a> @ imm = #0x1e
7009eb1a: e7ff         	b	0x7009eb1c <_ntoa_format+0x10c> @ imm = #-0x2
;       len--;
7009eb1c: 9811         	ldr	r0, [sp, #0x44]
7009eb1e: 3801         	subs	r0, #0x1
7009eb20: 9011         	str	r0, [sp, #0x44]
;       if (len && (base == 16U)) {
7009eb22: 9811         	ldr	r0, [sp, #0x44]
7009eb24: b140         	cbz	r0, 0x7009eb38 <_ntoa_format+0x128> @ imm = #0x10
7009eb26: e7ff         	b	0x7009eb28 <_ntoa_format+0x118> @ imm = #-0x2
7009eb28: 9813         	ldr	r0, [sp, #0x4c]
7009eb2a: 2810         	cmp	r0, #0x10
7009eb2c: d104         	bne	0x7009eb38 <_ntoa_format+0x128> @ imm = #0x8
7009eb2e: e7ff         	b	0x7009eb30 <_ntoa_format+0x120> @ imm = #-0x2
;         len--;
7009eb30: 9811         	ldr	r0, [sp, #0x44]
7009eb32: 3801         	subs	r0, #0x1
7009eb34: 9011         	str	r0, [sp, #0x44]
;       }
7009eb36: e7ff         	b	0x7009eb38 <_ntoa_format+0x128> @ imm = #-0x2
;     }
7009eb38: e7ff         	b	0x7009eb3a <_ntoa_format+0x12a> @ imm = #-0x2
;     if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009eb3a: 9813         	ldr	r0, [sp, #0x4c]
7009eb3c: 2810         	cmp	r0, #0x10
7009eb3e: d111         	bne	0x7009eb64 <_ntoa_format+0x154> @ imm = #0x22
7009eb40: e7ff         	b	0x7009eb42 <_ntoa_format+0x132> @ imm = #-0x2
7009eb42: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009eb46: 0680         	lsls	r0, r0, #0x1a
7009eb48: 2800         	cmp	r0, #0x0
7009eb4a: d40b         	bmi	0x7009eb64 <_ntoa_format+0x154> @ imm = #0x16
7009eb4c: e7ff         	b	0x7009eb4e <_ntoa_format+0x13e> @ imm = #-0x2
7009eb4e: 9811         	ldr	r0, [sp, #0x44]
7009eb50: 281f         	cmp	r0, #0x1f
7009eb52: d807         	bhi	0x7009eb64 <_ntoa_format+0x154> @ imm = #0xe
7009eb54: e7ff         	b	0x7009eb56 <_ntoa_format+0x146> @ imm = #-0x2
;       buf[len++] = 'x';
7009eb56: 9910         	ldr	r1, [sp, #0x40]
7009eb58: 9a11         	ldr	r2, [sp, #0x44]
7009eb5a: 1c50         	adds	r0, r2, #0x1
7009eb5c: 9011         	str	r0, [sp, #0x44]
7009eb5e: 2078         	movs	r0, #0x78
7009eb60: 5488         	strb	r0, [r1, r2]
;     }
7009eb62: e025         	b	0x7009ebb0 <_ntoa_format+0x1a0> @ imm = #0x4a
;     else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009eb64: 9813         	ldr	r0, [sp, #0x4c]
7009eb66: 2810         	cmp	r0, #0x10
7009eb68: d111         	bne	0x7009eb8e <_ntoa_format+0x17e> @ imm = #0x22
7009eb6a: e7ff         	b	0x7009eb6c <_ntoa_format+0x15c> @ imm = #-0x2
7009eb6c: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009eb70: 0680         	lsls	r0, r0, #0x1a
7009eb72: 2800         	cmp	r0, #0x0
7009eb74: d50b         	bpl	0x7009eb8e <_ntoa_format+0x17e> @ imm = #0x16
7009eb76: e7ff         	b	0x7009eb78 <_ntoa_format+0x168> @ imm = #-0x2
7009eb78: 9811         	ldr	r0, [sp, #0x44]
7009eb7a: 281f         	cmp	r0, #0x1f
7009eb7c: d807         	bhi	0x7009eb8e <_ntoa_format+0x17e> @ imm = #0xe
7009eb7e: e7ff         	b	0x7009eb80 <_ntoa_format+0x170> @ imm = #-0x2
;       buf[len++] = 'X';
7009eb80: 9910         	ldr	r1, [sp, #0x40]
7009eb82: 9a11         	ldr	r2, [sp, #0x44]
7009eb84: 1c50         	adds	r0, r2, #0x1
7009eb86: 9011         	str	r0, [sp, #0x44]
7009eb88: 2058         	movs	r0, #0x58
7009eb8a: 5488         	strb	r0, [r1, r2]
;     }
7009eb8c: e00f         	b	0x7009ebae <_ntoa_format+0x19e> @ imm = #0x1e
;     else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009eb8e: 9813         	ldr	r0, [sp, #0x4c]
7009eb90: 2802         	cmp	r0, #0x2
7009eb92: d10b         	bne	0x7009ebac <_ntoa_format+0x19c> @ imm = #0x16
7009eb94: e7ff         	b	0x7009eb96 <_ntoa_format+0x186> @ imm = #-0x2
7009eb96: 9811         	ldr	r0, [sp, #0x44]
7009eb98: 281f         	cmp	r0, #0x1f
7009eb9a: d807         	bhi	0x7009ebac <_ntoa_format+0x19c> @ imm = #0xe
7009eb9c: e7ff         	b	0x7009eb9e <_ntoa_format+0x18e> @ imm = #-0x2
;       buf[len++] = 'b';
7009eb9e: 9910         	ldr	r1, [sp, #0x40]
7009eba0: 9a11         	ldr	r2, [sp, #0x44]
7009eba2: 1c50         	adds	r0, r2, #0x1
7009eba4: 9011         	str	r0, [sp, #0x44]
7009eba6: 2062         	movs	r0, #0x62
7009eba8: 5488         	strb	r0, [r1, r2]
;     }
7009ebaa: e7ff         	b	0x7009ebac <_ntoa_format+0x19c> @ imm = #-0x2
7009ebac: e7ff         	b	0x7009ebae <_ntoa_format+0x19e> @ imm = #-0x2
7009ebae: e7ff         	b	0x7009ebb0 <_ntoa_format+0x1a0> @ imm = #-0x2
;     if (len < PRINTF_NTOA_BUFFER_SIZE) {
7009ebb0: 9811         	ldr	r0, [sp, #0x44]
7009ebb2: 281f         	cmp	r0, #0x1f
7009ebb4: d807         	bhi	0x7009ebc6 <_ntoa_format+0x1b6> @ imm = #0xe
7009ebb6: e7ff         	b	0x7009ebb8 <_ntoa_format+0x1a8> @ imm = #-0x2
;       buf[len++] = '0';
7009ebb8: 9910         	ldr	r1, [sp, #0x40]
7009ebba: 9a11         	ldr	r2, [sp, #0x44]
7009ebbc: 1c50         	adds	r0, r2, #0x1
7009ebbe: 9011         	str	r0, [sp, #0x44]
7009ebc0: 2030         	movs	r0, #0x30
7009ebc2: 5488         	strb	r0, [r1, r2]
;     }
7009ebc4: e7ff         	b	0x7009ebc6 <_ntoa_format+0x1b6> @ imm = #-0x2
;   }
7009ebc6: e7ff         	b	0x7009ebc8 <_ntoa_format+0x1b8> @ imm = #-0x2
;   if (len < PRINTF_NTOA_BUFFER_SIZE) {
7009ebc8: 9811         	ldr	r0, [sp, #0x44]
7009ebca: 281f         	cmp	r0, #0x1f
7009ebcc: d829         	bhi	0x7009ec22 <_ntoa_format+0x212> @ imm = #0x52
7009ebce: e7ff         	b	0x7009ebd0 <_ntoa_format+0x1c0> @ imm = #-0x2
;     if (negative) {
7009ebd0: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009ebd4: 07c0         	lsls	r0, r0, #0x1f
7009ebd6: b138         	cbz	r0, 0x7009ebe8 <_ntoa_format+0x1d8> @ imm = #0xe
7009ebd8: e7ff         	b	0x7009ebda <_ntoa_format+0x1ca> @ imm = #-0x2
;       buf[len++] = '-';
7009ebda: 9910         	ldr	r1, [sp, #0x40]
7009ebdc: 9a11         	ldr	r2, [sp, #0x44]
7009ebde: 1c50         	adds	r0, r2, #0x1
7009ebe0: 9011         	str	r0, [sp, #0x44]
7009ebe2: 202d         	movs	r0, #0x2d
7009ebe4: 5488         	strb	r0, [r1, r2]
;     }
7009ebe6: e01b         	b	0x7009ec20 <_ntoa_format+0x210> @ imm = #0x36
;     else if (flags & FLAGS_PLUS) {
7009ebe8: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009ebec: 0740         	lsls	r0, r0, #0x1d
7009ebee: 2800         	cmp	r0, #0x0
7009ebf0: d507         	bpl	0x7009ec02 <_ntoa_format+0x1f2> @ imm = #0xe
7009ebf2: e7ff         	b	0x7009ebf4 <_ntoa_format+0x1e4> @ imm = #-0x2
;       buf[len++] = '+';  // ignore the space if the '+' exists
7009ebf4: 9910         	ldr	r1, [sp, #0x40]
7009ebf6: 9a11         	ldr	r2, [sp, #0x44]
7009ebf8: 1c50         	adds	r0, r2, #0x1
7009ebfa: 9011         	str	r0, [sp, #0x44]
7009ebfc: 202b         	movs	r0, #0x2b
7009ebfe: 5488         	strb	r0, [r1, r2]
;     }
7009ec00: e00d         	b	0x7009ec1e <_ntoa_format+0x20e> @ imm = #0x1a
;     else if (flags & FLAGS_SPACE) {
7009ec02: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009ec06: 0700         	lsls	r0, r0, #0x1c
7009ec08: 2800         	cmp	r0, #0x0
7009ec0a: d507         	bpl	0x7009ec1c <_ntoa_format+0x20c> @ imm = #0xe
7009ec0c: e7ff         	b	0x7009ec0e <_ntoa_format+0x1fe> @ imm = #-0x2
;       buf[len++] = ' ';
7009ec0e: 9910         	ldr	r1, [sp, #0x40]
7009ec10: 9a11         	ldr	r2, [sp, #0x44]
7009ec12: 1c50         	adds	r0, r2, #0x1
7009ec14: 9011         	str	r0, [sp, #0x44]
7009ec16: 2020         	movs	r0, #0x20
7009ec18: 5488         	strb	r0, [r1, r2]
;     }
7009ec1a: e7ff         	b	0x7009ec1c <_ntoa_format+0x20c> @ imm = #-0x2
7009ec1c: e7ff         	b	0x7009ec1e <_ntoa_format+0x20e> @ imm = #-0x2
7009ec1e: e7ff         	b	0x7009ec20 <_ntoa_format+0x210> @ imm = #-0x2
;   }
7009ec20: e7ff         	b	0x7009ec22 <_ntoa_format+0x212> @ imm = #-0x2
;   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
7009ec22: 980b         	ldr	r0, [sp, #0x2c]
7009ec24: 990a         	ldr	r1, [sp, #0x28]
7009ec26: 9a09         	ldr	r2, [sp, #0x24]
7009ec28: 9b08         	ldr	r3, [sp, #0x20]
7009ec2a: f8dd c040    	ldr.w	r12, [sp, #0x40]
7009ec2e: 9c11         	ldr	r4, [sp, #0x44]
7009ec30: 9d15         	ldr	r5, [sp, #0x54]
7009ec32: 9e16         	ldr	r6, [sp, #0x58]
7009ec34: 46ee         	mov	lr, sp
7009ec36: f8ce 600c    	str.w	r6, [lr, #0xc]
7009ec3a: f8ce 5008    	str.w	r5, [lr, #0x8]
7009ec3e: f8ce 4004    	str.w	r4, [lr, #0x4]
7009ec42: f8ce c000    	str.w	r12, [lr]
7009ec46: f008 fd23    	bl	0x700a7690 <_out_rev>   @ imm = #0x8a46
7009ec4a: b00c         	add	sp, #0x30
7009ec4c: bd70         	pop	{r4, r5, r6, pc}
7009ec4e: 0000         	movs	r0, r0

7009ec50 <Udma_eventRegister>:
; {
7009ec50: b5b0         	push	{r4, r5, r7, lr}
7009ec52: b088         	sub	sp, #0x20
7009ec54: 9007         	str	r0, [sp, #0x1c]
7009ec56: 9106         	str	r1, [sp, #0x18]
7009ec58: 9205         	str	r2, [sp, #0x14]
7009ec5a: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009ec5c: 9004         	str	r0, [sp, #0x10]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009ec5e: 9003         	str	r0, [sp, #0xc]
;     if((NULL_PTR == drvHandle) || (NULL_PTR == eventHandle) || (NULL_PTR == eventPrms))
7009ec60: 9807         	ldr	r0, [sp, #0x1c]
7009ec62: b130         	cbz	r0, 0x7009ec72 <Udma_eventRegister+0x22> @ imm = #0xc
7009ec64: e7ff         	b	0x7009ec66 <Udma_eventRegister+0x16> @ imm = #-0x2
7009ec66: 9806         	ldr	r0, [sp, #0x18]
7009ec68: b118         	cbz	r0, 0x7009ec72 <Udma_eventRegister+0x22> @ imm = #0x6
7009ec6a: e7ff         	b	0x7009ec6c <Udma_eventRegister+0x1c> @ imm = #-0x2
7009ec6c: 9805         	ldr	r0, [sp, #0x14]
7009ec6e: b920         	cbnz	r0, 0x7009ec7a <Udma_eventRegister+0x2a> @ imm = #0x8
7009ec70: e7ff         	b	0x7009ec72 <Udma_eventRegister+0x22> @ imm = #-0x2
7009ec72: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009ec76: 9004         	str	r0, [sp, #0x10]
;     }
7009ec78: e7ff         	b	0x7009ec7a <Udma_eventRegister+0x2a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ec7a: 9804         	ldr	r0, [sp, #0x10]
7009ec7c: b988         	cbnz	r0, 0x7009eca2 <Udma_eventRegister+0x52> @ imm = #0x22
7009ec7e: e7ff         	b	0x7009ec80 <Udma_eventRegister+0x30> @ imm = #-0x2
;         drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009ec80: 9807         	ldr	r0, [sp, #0x1c]
7009ec82: 9002         	str	r0, [sp, #0x8]
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009ec84: 9802         	ldr	r0, [sp, #0x8]
7009ec86: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009ec8a: f64a 31cd    	movw	r1, #0xabcd
7009ec8e: f6ca 31dc    	movt	r1, #0xabdc
7009ec92: 4288         	cmp	r0, r1
7009ec94: d004         	beq	0x7009eca0 <Udma_eventRegister+0x50> @ imm = #0x8
7009ec96: e7ff         	b	0x7009ec98 <Udma_eventRegister+0x48> @ imm = #-0x2
7009ec98: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009ec9c: 9004         	str	r0, [sp, #0x10]
;         }
7009ec9e: e7ff         	b	0x7009eca0 <Udma_eventRegister+0x50> @ imm = #-0x2
;     }
7009eca0: e7ff         	b	0x7009eca2 <Udma_eventRegister+0x52> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009eca2: 9804         	ldr	r0, [sp, #0x10]
7009eca4: b930         	cbnz	r0, 0x7009ecb4 <Udma_eventRegister+0x64> @ imm = #0xc
7009eca6: e7ff         	b	0x7009eca8 <Udma_eventRegister+0x58> @ imm = #-0x2
;         retVal = Udma_eventCheckParams(drvHandleInt, eventPrms);
7009eca8: 9802         	ldr	r0, [sp, #0x8]
7009ecaa: 9905         	ldr	r1, [sp, #0x14]
7009ecac: f006 fbb8    	bl	0x700a5420 <Udma_eventCheckParams> @ imm = #0x6770
7009ecb0: 9004         	str	r0, [sp, #0x10]
;     }
7009ecb2: e7ff         	b	0x7009ecb4 <Udma_eventRegister+0x64> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ecb4: 9804         	ldr	r0, [sp, #0x10]
7009ecb6: bbb0         	cbnz	r0, 0x7009ed26 <Udma_eventRegister+0xd6> @ imm = #0x6c
7009ecb8: e7ff         	b	0x7009ecba <Udma_eventRegister+0x6a> @ imm = #-0x2
;         eventHandleInt = (Udma_EventHandleInt) eventHandle;
7009ecba: 9806         	ldr	r0, [sp, #0x18]
7009ecbc: 9001         	str	r0, [sp, #0x4]
;             &eventHandleInt->eventPrms, eventPrms, sizeof(eventHandleInt->eventPrms));
7009ecbe: 9801         	ldr	r0, [sp, #0x4]
7009ecc0: 3008         	adds	r0, #0x8
7009ecc2: 9905         	ldr	r1, [sp, #0x14]
;         (void) memcpy(
7009ecc4: e8b1 501c    	ldm.w	r1!, {r2, r3, r4, r12, lr}
7009ecc8: e8a0 501c    	stm.w	r0!, {r2, r3, r4, r12, lr}
7009eccc: e8b1 501c    	ldm.w	r1!, {r2, r3, r4, r12, lr}
7009ecd0: e8a0 501c    	stm.w	r0!, {r2, r3, r4, r12, lr}
7009ecd4: e891 503c    	ldm.w	r1, {r2, r3, r4, r5, r12, lr}
7009ecd8: e880 503c    	stm.w	r0, {r2, r3, r4, r5, r12, lr}
;         eventHandleInt->drvHandle       = drvHandleInt;
7009ecdc: 9802         	ldr	r0, [sp, #0x8]
7009ecde: 9901         	ldr	r1, [sp, #0x4]
7009ece0: 6008         	str	r0, [r1]
;         eventHandleInt->globalEvent     = UDMA_EVENT_INVALID;
7009ece2: 9901         	ldr	r1, [sp, #0x4]
7009ece4: f64f 70ff    	movw	r0, #0xffff
7009ece8: 6488         	str	r0, [r1, #0x48]
;         eventHandleInt->vintrNum        = UDMA_EVENT_INVALID;
7009ecea: 9901         	ldr	r1, [sp, #0x4]
7009ecec: 64c8         	str	r0, [r1, #0x4c]
;         eventHandleInt->vintrBitNum     = UDMA_EVENT_INVALID;
7009ecee: 9901         	ldr	r1, [sp, #0x4]
7009ecf0: 6508         	str	r0, [r1, #0x50]
;         eventHandleInt->irIntrNum       = UDMA_INTR_INVALID;
7009ecf2: 9901         	ldr	r1, [sp, #0x4]
7009ecf4: 2000         	movs	r0, #0x0
7009ecf6: f6cf 70ff    	movt	r0, #0xffff
7009ecfa: 6548         	str	r0, [r1, #0x54]
;         eventHandleInt->coreIntrNum     = UDMA_INTR_INVALID;
7009ecfc: 9901         	ldr	r1, [sp, #0x4]
7009ecfe: 6588         	str	r0, [r1, #0x58]
;         eventHandleInt->nextEvent       = (Udma_EventHandleInt) NULL_PTR;
7009ed00: 9901         	ldr	r1, [sp, #0x4]
7009ed02: 2000         	movs	r0, #0x0
7009ed04: 65c8         	str	r0, [r1, #0x5c]
;         eventHandleInt->prevEvent       = (Udma_EventHandleInt) NULL_PTR;
7009ed06: 9901         	ldr	r1, [sp, #0x4]
7009ed08: 6608         	str	r0, [r1, #0x60]
;         eventHandleInt->hwiHandle       = NULL_PTR;
7009ed0a: 9901         	ldr	r1, [sp, #0x4]
7009ed0c: 6648         	str	r0, [r1, #0x64]
;         eventHandleInt->vintrBitAllocFlag = 0U;
7009ed0e: 9901         	ldr	r1, [sp, #0x4]
7009ed10: f8c1 008c    	str.w	r0, [r1, #0x8c]
7009ed14: f8c1 0088    	str.w	r0, [r1, #0x88]
;         eventHandleInt->pIaGeviRegs     = (volatile CSL_intaggr_imapRegs_gevi *) NULL_PTR;
7009ed18: 9901         	ldr	r1, [sp, #0x4]
7009ed1a: f8c1 0090    	str.w	r0, [r1, #0x90]
;         eventHandleInt->pIaVintrRegs    = (volatile CSL_intaggr_intrRegs_vint *) NULL_PTR;
7009ed1e: 9901         	ldr	r1, [sp, #0x4]
7009ed20: f8c1 0094    	str.w	r0, [r1, #0x94]
;     }
7009ed24: e7ff         	b	0x7009ed26 <Udma_eventRegister+0xd6> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ed26: 9804         	ldr	r0, [sp, #0x10]
7009ed28: 2800         	cmp	r0, #0x0
7009ed2a: f040 809f    	bne.w	0x7009ee6c <Udma_eventRegister+0x21c> @ imm = #0x13e
7009ed2e: e7ff         	b	0x7009ed30 <Udma_eventRegister+0xe0> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandleInt->instType) &&
7009ed30: 9802         	ldr	r0, [sp, #0x8]
7009ed32: 6800         	ldr	r0, [r0]
7009ed34: b130         	cbz	r0, 0x7009ed44 <Udma_eventRegister+0xf4> @ imm = #0xc
7009ed36: e7ff         	b	0x7009ed38 <Udma_eventRegister+0xe8> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType))
7009ed38: 9805         	ldr	r0, [sp, #0x14]
7009ed3a: 6800         	ldr	r0, [r0]
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandleInt->instType) &&
7009ed3c: 2802         	cmp	r0, #0x2
7009ed3e: d101         	bne	0x7009ed44 <Udma_eventRegister+0xf4> @ imm = #0x2
7009ed40: e7ff         	b	0x7009ed42 <Udma_eventRegister+0xf2> @ imm = #-0x2
;         }
7009ed42: e092         	b	0x7009ee6a <Udma_eventRegister+0x21a> @ imm = #0x124
;             retVal = Udma_eventAllocResource(drvHandleInt, eventHandleInt);
7009ed44: 9802         	ldr	r0, [sp, #0x8]
7009ed46: 9901         	ldr	r1, [sp, #0x4]
7009ed48: f000 f89a    	bl	0x7009ee80 <Udma_eventAllocResource> @ imm = #0x134
7009ed4c: 9004         	str	r0, [sp, #0x10]
;             if(UDMA_SOK == retVal)
7009ed4e: 9804         	ldr	r0, [sp, #0x10]
7009ed50: b918         	cbnz	r0, 0x7009ed5a <Udma_eventRegister+0x10a> @ imm = #0x6
7009ed52: e7ff         	b	0x7009ed54 <Udma_eventRegister+0x104> @ imm = #-0x2
7009ed54: 2001         	movs	r0, #0x1
;                 allocDone = (uint32_t) TRUE;
7009ed56: 9003         	str	r0, [sp, #0xc]
;             }
7009ed58: e000         	b	0x7009ed5c <Udma_eventRegister+0x10c> @ imm = #0x0
7009ed5a: e7ff         	b	0x7009ed5c <Udma_eventRegister+0x10c> @ imm = #-0x2
;             if(UDMA_SOK == retVal)
7009ed5c: 9804         	ldr	r0, [sp, #0x10]
7009ed5e: b9a0         	cbnz	r0, 0x7009ed8a <Udma_eventRegister+0x13a> @ imm = #0x28
7009ed60: e7ff         	b	0x7009ed62 <Udma_eventRegister+0x112> @ imm = #-0x2
;                 eventHandleInt->eventInitDone = UDMA_INIT_DONE;
7009ed62: 9901         	ldr	r1, [sp, #0x4]
7009ed64: f64a 30cd    	movw	r0, #0xabcd
7009ed68: f6ca 30dc    	movt	r0, #0xabdc
7009ed6c: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 retVal = Udma_eventConfig(drvHandleInt, eventHandleInt);
7009ed70: 9802         	ldr	r0, [sp, #0x8]
7009ed72: 9901         	ldr	r1, [sp, #0x4]
7009ed74: f7fd fe0c    	bl	0x7009c990 <Udma_eventConfig> @ imm = #-0x23e8
7009ed78: 9004         	str	r0, [sp, #0x10]
;                 if(UDMA_SOK == retVal)
7009ed7a: 9804         	ldr	r0, [sp, #0x10]
7009ed7c: b918         	cbnz	r0, 0x7009ed86 <Udma_eventRegister+0x136> @ imm = #0x6
7009ed7e: e7ff         	b	0x7009ed80 <Udma_eventRegister+0x130> @ imm = #-0x2
7009ed80: 2001         	movs	r0, #0x1
;                     allocDone = (uint32_t) TRUE;
7009ed82: 9003         	str	r0, [sp, #0xc]
;                 }
7009ed84: e000         	b	0x7009ed88 <Udma_eventRegister+0x138> @ imm = #0x0
7009ed86: e7ff         	b	0x7009ed88 <Udma_eventRegister+0x138> @ imm = #-0x2
;             }
7009ed88: e7ff         	b	0x7009ed8a <Udma_eventRegister+0x13a> @ imm = #-0x2
;             if(UDMA_SOK != retVal)
7009ed8a: 9804         	ldr	r0, [sp, #0x10]
7009ed8c: b170         	cbz	r0, 0x7009edac <Udma_eventRegister+0x15c> @ imm = #0x1c
7009ed8e: e7ff         	b	0x7009ed90 <Udma_eventRegister+0x140> @ imm = #-0x2
;                 if(((uint32_t) TRUE) == allocDone)
7009ed90: 9803         	ldr	r0, [sp, #0xc]
7009ed92: 2801         	cmp	r0, #0x1
7009ed94: d109         	bne	0x7009edaa <Udma_eventRegister+0x15a> @ imm = #0x12
7009ed96: e7ff         	b	0x7009ed98 <Udma_eventRegister+0x148> @ imm = #-0x2
;                     Udma_eventFreeResource(drvHandleInt, eventHandleInt);
7009ed98: 9802         	ldr	r0, [sp, #0x8]
7009ed9a: 9901         	ldr	r1, [sp, #0x4]
7009ed9c: f006 ffb8    	bl	0x700a5d10 <Udma_eventFreeResource> @ imm = #0x6f70
;                     eventHandleInt->eventInitDone = UDMA_DEINIT_DONE;
7009eda0: 9901         	ldr	r1, [sp, #0x4]
7009eda2: 2000         	movs	r0, #0x0
7009eda4: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 }
7009eda8: e7ff         	b	0x7009edaa <Udma_eventRegister+0x15a> @ imm = #-0x2
;             }
7009edaa: e05d         	b	0x7009ee68 <Udma_eventRegister+0x218> @ imm = #0xba
;                 eventPrms->intrStatusReg    = &eventHandleInt->pIaVintrRegs->STATUSM;
7009edac: 9801         	ldr	r0, [sp, #0x4]
7009edae: f8d0 0094    	ldr.w	r0, [r0, #0x94]
7009edb2: 3020         	adds	r0, #0x20
7009edb4: 9905         	ldr	r1, [sp, #0x14]
7009edb6: 6248         	str	r0, [r1, #0x24]
;                 eventPrms->intrClearReg     = &eventHandleInt->pIaVintrRegs->STATUS_CLEAR;
7009edb8: 9801         	ldr	r0, [sp, #0x4]
7009edba: f8d0 0094    	ldr.w	r0, [r0, #0x94]
7009edbe: 3018         	adds	r0, #0x18
7009edc0: 9905         	ldr	r1, [sp, #0x14]
7009edc2: 6288         	str	r0, [r1, #0x28]
;                 if(eventHandleInt->vintrBitNum != UDMA_EVENT_INVALID)
7009edc4: 9801         	ldr	r0, [sp, #0x4]
7009edc6: 6d00         	ldr	r0, [r0, #0x50]
7009edc8: f64f 71ff    	movw	r1, #0xffff
7009edcc: 4288         	cmp	r0, r1
7009edce: d017         	beq	0x7009ee00 <Udma_eventRegister+0x1b0> @ imm = #0x2e
7009edd0: e7ff         	b	0x7009edd2 <Udma_eventRegister+0x182> @ imm = #-0x2
;                     eventPrms->intrMask     = ((uint64_t)1U << eventHandleInt->vintrBitNum);
7009edd2: 9801         	ldr	r0, [sp, #0x4]
7009edd4: 6d03         	ldr	r3, [r0, #0x50]
7009edd6: f1a3 0120    	sub.w	r1, r3, #0x20
7009edda: 2201         	movs	r2, #0x1
7009eddc: fa02 fc01    	lsl.w	r12, r2, r1
7009ede0: f1c3 0020    	rsb.w	r0, r3, #0x20
7009ede4: fa22 f000    	lsr.w	r0, r2, r0
7009ede8: 2900         	cmp	r1, #0x0
7009edea: bf58         	it	pl
7009edec: 4660         	movpl	r0, r12
7009edee: fa02 f203    	lsl.w	r2, r2, r3
7009edf2: 2900         	cmp	r1, #0x0
7009edf4: bf58         	it	pl
7009edf6: 2200         	movpl	r2, #0x0
7009edf8: 9905         	ldr	r1, [sp, #0x14]
7009edfa: 630a         	str	r2, [r1, #0x30]
7009edfc: 6348         	str	r0, [r1, #0x34]
;                 }
7009edfe: e004         	b	0x7009ee0a <Udma_eventRegister+0x1ba> @ imm = #0x8
;                     eventPrms->intrMask     = 0U;
7009ee00: 9905         	ldr	r1, [sp, #0x14]
7009ee02: 2000         	movs	r0, #0x0
7009ee04: 6348         	str	r0, [r1, #0x34]
7009ee06: 6308         	str	r0, [r1, #0x30]
7009ee08: e7ff         	b	0x7009ee0a <Udma_eventRegister+0x1ba> @ imm = #-0x2
;                 if(NULL_PTR == eventHandleInt->eventPrms.controllerEventHandle)
7009ee0a: 9801         	ldr	r0, [sp, #0x4]
7009ee0c: 6980         	ldr	r0, [r0, #0x18]
7009ee0e: b948         	cbnz	r0, 0x7009ee24 <Udma_eventRegister+0x1d4> @ imm = #0x12
7009ee10: e7ff         	b	0x7009ee12 <Udma_eventRegister+0x1c2> @ imm = #-0x2
;                     eventPrms->vintrNum     = eventHandleInt->vintrNum;
7009ee12: 9801         	ldr	r0, [sp, #0x4]
7009ee14: 6cc0         	ldr	r0, [r0, #0x4c]
7009ee16: 9905         	ldr	r1, [sp, #0x14]
7009ee18: 6388         	str	r0, [r1, #0x38]
;                     eventPrms->coreIntrNum  = eventHandleInt->coreIntrNum;
7009ee1a: 9801         	ldr	r0, [sp, #0x4]
7009ee1c: 6d80         	ldr	r0, [r0, #0x58]
7009ee1e: 9905         	ldr	r1, [sp, #0x14]
7009ee20: 63c8         	str	r0, [r1, #0x3c]
;                 }
7009ee22: e00a         	b	0x7009ee3a <Udma_eventRegister+0x1ea> @ imm = #0x14
;                        ((Udma_EventHandleInt) (eventHandleInt->eventPrms.controllerEventHandle))->vintrNum;
7009ee24: 9801         	ldr	r0, [sp, #0x4]
7009ee26: 6980         	ldr	r0, [r0, #0x18]
7009ee28: 6cc0         	ldr	r0, [r0, #0x4c]
;                     eventPrms->vintrNum       =
7009ee2a: 9905         	ldr	r1, [sp, #0x14]
7009ee2c: 6388         	str	r0, [r1, #0x38]
;                         ((Udma_EventHandleInt) (eventHandleInt->eventPrms.controllerEventHandle))->coreIntrNum;
7009ee2e: 9801         	ldr	r0, [sp, #0x4]
7009ee30: 6980         	ldr	r0, [r0, #0x18]
7009ee32: 6d80         	ldr	r0, [r0, #0x58]
;                     eventPrms->coreIntrNum    =
7009ee34: 9905         	ldr	r1, [sp, #0x14]
7009ee36: 63c8         	str	r0, [r1, #0x3c]
7009ee38: e7ff         	b	0x7009ee3a <Udma_eventRegister+0x1ea> @ imm = #-0x2
;                 eventHandleInt->eventPrms.intrStatusReg   = eventPrms->intrStatusReg;
7009ee3a: 9805         	ldr	r0, [sp, #0x14]
7009ee3c: 6a40         	ldr	r0, [r0, #0x24]
7009ee3e: 9901         	ldr	r1, [sp, #0x4]
7009ee40: 62c8         	str	r0, [r1, #0x2c]
;                 eventHandleInt->eventPrms.intrClearReg    = eventPrms->intrClearReg;
7009ee42: 9805         	ldr	r0, [sp, #0x14]
7009ee44: 6a80         	ldr	r0, [r0, #0x28]
7009ee46: 9901         	ldr	r1, [sp, #0x4]
7009ee48: 6308         	str	r0, [r1, #0x30]
;                 eventHandleInt->eventPrms.intrMask        = eventPrms->intrMask;
7009ee4a: 9905         	ldr	r1, [sp, #0x14]
7009ee4c: 6b08         	ldr	r0, [r1, #0x30]
7009ee4e: 6b4a         	ldr	r2, [r1, #0x34]
7009ee50: 9901         	ldr	r1, [sp, #0x4]
7009ee52: 63ca         	str	r2, [r1, #0x3c]
7009ee54: 6388         	str	r0, [r1, #0x38]
;                 eventHandleInt->eventPrms.vintrNum        = eventPrms->vintrNum;
7009ee56: 9805         	ldr	r0, [sp, #0x14]
7009ee58: 6b80         	ldr	r0, [r0, #0x38]
7009ee5a: 9901         	ldr	r1, [sp, #0x4]
7009ee5c: 6408         	str	r0, [r1, #0x40]
;                 eventHandleInt->eventPrms.coreIntrNum     = eventPrms->coreIntrNum;
7009ee5e: 9805         	ldr	r0, [sp, #0x14]
7009ee60: 6bc0         	ldr	r0, [r0, #0x3c]
7009ee62: 9901         	ldr	r1, [sp, #0x4]
7009ee64: 6448         	str	r0, [r1, #0x44]
7009ee66: e7ff         	b	0x7009ee68 <Udma_eventRegister+0x218> @ imm = #-0x2
7009ee68: e7ff         	b	0x7009ee6a <Udma_eventRegister+0x21a> @ imm = #-0x2
;     }
7009ee6a: e7ff         	b	0x7009ee6c <Udma_eventRegister+0x21c> @ imm = #-0x2
;     return (retVal);
7009ee6c: 9804         	ldr	r0, [sp, #0x10]
7009ee6e: b008         	add	sp, #0x20
7009ee70: bdb0         	pop	{r4, r5, r7, pc}
		...
7009ee7e: 0000         	movs	r0, r0

7009ee80 <Udma_eventAllocResource>:
; {
7009ee80: b580         	push	{r7, lr}
7009ee82: b08a         	sub	sp, #0x28
7009ee84: 9009         	str	r0, [sp, #0x24]
7009ee86: 9108         	str	r1, [sp, #0x20]
7009ee88: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009ee8a: 9007         	str	r0, [sp, #0x1c]
;     eventPrms = &eventHandle->eventPrms;
7009ee8c: 9808         	ldr	r0, [sp, #0x20]
7009ee8e: 3008         	adds	r0, #0x8
7009ee90: 9004         	str	r0, [sp, #0x10]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009ee92: 9804         	ldr	r0, [sp, #0x10]
7009ee94: 6800         	ldr	r0, [r0]
7009ee96: 2805         	cmp	r0, #0x5
7009ee98: d01b         	beq	0x7009eed2 <Udma_eventAllocResource+0x52> @ imm = #0x36
7009ee9a: e7ff         	b	0x7009ee9c <Udma_eventAllocResource+0x1c> @ imm = #-0x2
;         eventHandle->globalEvent = Udma_rmAllocEvent(drvHandle);
7009ee9c: 9809         	ldr	r0, [sp, #0x24]
7009ee9e: f009 fe7f    	bl	0x700a8ba0 <Udma_rmAllocEvent> @ imm = #0x9cfe
7009eea2: 9908         	ldr	r1, [sp, #0x20]
7009eea4: 6488         	str	r0, [r1, #0x48]
;         if(UDMA_EVENT_INVALID == eventHandle->globalEvent)
7009eea6: 9808         	ldr	r0, [sp, #0x20]
7009eea8: 6c80         	ldr	r0, [r0, #0x48]
7009eeaa: f64f 71ff    	movw	r1, #0xffff
7009eeae: 4288         	cmp	r0, r1
7009eeb0: d104         	bne	0x7009eebc <Udma_eventAllocResource+0x3c> @ imm = #0x8
7009eeb2: e7ff         	b	0x7009eeb4 <Udma_eventAllocResource+0x34> @ imm = #-0x2
7009eeb4: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
7009eeb8: 9007         	str	r0, [sp, #0x1c]
;         }
7009eeba: e009         	b	0x7009eed0 <Udma_eventAllocResource+0x50> @ imm = #0x12
;                 &drvHandle->iaRegs.pImapRegs->GEVI[eventHandle->globalEvent];
7009eebc: 9809         	ldr	r0, [sp, #0x24]
7009eebe: f8d0 00a0    	ldr.w	r0, [r0, #0xa0]
7009eec2: 9908         	ldr	r1, [sp, #0x20]
7009eec4: 6c8a         	ldr	r2, [r1, #0x48]
7009eec6: eb00 00c2    	add.w	r0, r0, r2, lsl #3
;             eventHandle->pIaGeviRegs =
7009eeca: f8c1 0090    	str.w	r0, [r1, #0x90]
7009eece: e7ff         	b	0x7009eed0 <Udma_eventAllocResource+0x50> @ imm = #-0x2
;     }
7009eed0: e7ff         	b	0x7009eed2 <Udma_eventAllocResource+0x52> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009eed2: 9807         	ldr	r0, [sp, #0x1c]
7009eed4: bb00         	cbnz	r0, 0x7009ef18 <Udma_eventAllocResource+0x98> @ imm = #0x40
7009eed6: e7ff         	b	0x7009eed8 <Udma_eventAllocResource+0x58> @ imm = #-0x2
;         if((UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode) ||
7009eed8: 9804         	ldr	r0, [sp, #0x10]
7009eeda: 6840         	ldr	r0, [r0, #0x4]
7009eedc: 2801         	cmp	r0, #0x1
7009eede: d009         	beq	0x7009eef4 <Udma_eventAllocResource+0x74> @ imm = #0x12
7009eee0: e7ff         	b	0x7009eee2 <Udma_eventAllocResource+0x62> @ imm = #-0x2
;             ((UDMA_EVENT_MODE_SHARED == eventPrms->eventMode) &&
7009eee2: 9804         	ldr	r0, [sp, #0x10]
7009eee4: 6840         	ldr	r0, [r0, #0x4]
7009eee6: 2802         	cmp	r0, #0x2
7009eee8: d115         	bne	0x7009ef16 <Udma_eventAllocResource+0x96> @ imm = #0x2a
7009eeea: e7ff         	b	0x7009eeec <Udma_eventAllocResource+0x6c> @ imm = #-0x2
;                 (NULL_PTR == eventPrms->controllerEventHandle)))
7009eeec: 9804         	ldr	r0, [sp, #0x10]
7009eeee: 6900         	ldr	r0, [r0, #0x10]
;         if((UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode) ||
7009eef0: b988         	cbnz	r0, 0x7009ef16 <Udma_eventAllocResource+0x96> @ imm = #0x22
7009eef2: e7ff         	b	0x7009eef4 <Udma_eventAllocResource+0x74> @ imm = #-0x2
;             eventHandle->vintrNum = Udma_rmAllocVintr(drvHandle);
7009eef4: 9809         	ldr	r0, [sp, #0x24]
7009eef6: f009 fea3    	bl	0x700a8c40 <Udma_rmAllocVintr> @ imm = #0x9d46
7009eefa: 9908         	ldr	r1, [sp, #0x20]
7009eefc: 64c8         	str	r0, [r1, #0x4c]
;             if(UDMA_EVENT_INVALID == eventHandle->vintrNum)
7009eefe: 9808         	ldr	r0, [sp, #0x20]
7009ef00: 6cc0         	ldr	r0, [r0, #0x4c]
7009ef02: f64f 71ff    	movw	r1, #0xffff
7009ef06: 4288         	cmp	r0, r1
7009ef08: d104         	bne	0x7009ef14 <Udma_eventAllocResource+0x94> @ imm = #0x8
7009ef0a: e7ff         	b	0x7009ef0c <Udma_eventAllocResource+0x8c> @ imm = #-0x2
7009ef0c: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009ef10: 9007         	str	r0, [sp, #0x1c]
;             }
7009ef12: e7ff         	b	0x7009ef14 <Udma_eventAllocResource+0x94> @ imm = #-0x2
;         }
7009ef14: e7ff         	b	0x7009ef16 <Udma_eventAllocResource+0x96> @ imm = #-0x2
;     }
7009ef16: e7ff         	b	0x7009ef18 <Udma_eventAllocResource+0x98> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ef18: 9807         	ldr	r0, [sp, #0x1c]
7009ef1a: b9b8         	cbnz	r0, 0x7009ef4c <Udma_eventAllocResource+0xcc> @ imm = #0x2e
7009ef1c: e7ff         	b	0x7009ef1e <Udma_eventAllocResource+0x9e> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009ef1e: 9804         	ldr	r0, [sp, #0x10]
7009ef20: 6800         	ldr	r0, [r0]
7009ef22: 2805         	cmp	r0, #0x5
7009ef24: d011         	beq	0x7009ef4a <Udma_eventAllocResource+0xca> @ imm = #0x22
7009ef26: e7ff         	b	0x7009ef28 <Udma_eventAllocResource+0xa8> @ imm = #-0x2
;             eventHandle->vintrBitNum = Udma_rmAllocVintrBit(eventHandle);
7009ef28: 9808         	ldr	r0, [sp, #0x20]
7009ef2a: f007 fe09    	bl	0x700a6b40 <Udma_rmAllocVintrBit> @ imm = #0x7c12
7009ef2e: 9908         	ldr	r1, [sp, #0x20]
7009ef30: 6508         	str	r0, [r1, #0x50]
;             if(UDMA_EVENT_INVALID == eventHandle->vintrBitNum)
7009ef32: 9808         	ldr	r0, [sp, #0x20]
7009ef34: 6d00         	ldr	r0, [r0, #0x50]
7009ef36: f64f 71ff    	movw	r1, #0xffff
7009ef3a: 4288         	cmp	r0, r1
7009ef3c: d104         	bne	0x7009ef48 <Udma_eventAllocResource+0xc8> @ imm = #0x8
7009ef3e: e7ff         	b	0x7009ef40 <Udma_eventAllocResource+0xc0> @ imm = #-0x2
7009ef40: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009ef44: 9007         	str	r0, [sp, #0x1c]
;             }
7009ef46: e7ff         	b	0x7009ef48 <Udma_eventAllocResource+0xc8> @ imm = #-0x2
;         }
7009ef48: e7ff         	b	0x7009ef4a <Udma_eventAllocResource+0xca> @ imm = #-0x2
;     }
7009ef4a: e7ff         	b	0x7009ef4c <Udma_eventAllocResource+0xcc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ef4c: 9807         	ldr	r0, [sp, #0x1c]
7009ef4e: 2800         	cmp	r0, #0x0
7009ef50: d146         	bne	0x7009efe0 <Udma_eventAllocResource+0x160> @ imm = #0x8c
7009ef52: e7ff         	b	0x7009ef54 <Udma_eventAllocResource+0xd4> @ imm = #-0x2
;         if((((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
7009ef54: 9804         	ldr	r0, [sp, #0x10]
7009ef56: 6940         	ldr	r0, [r0, #0x14]
7009ef58: b120         	cbz	r0, 0x7009ef64 <Udma_eventAllocResource+0xe4> @ imm = #0x8
7009ef5a: e7ff         	b	0x7009ef5c <Udma_eventAllocResource+0xdc> @ imm = #-0x2
;                 (NULL_PTR == eventPrms->controllerEventHandle)) ||
7009ef5c: 9804         	ldr	r0, [sp, #0x10]
7009ef5e: 6900         	ldr	r0, [r0, #0x10]
7009ef60: b128         	cbz	r0, 0x7009ef6e <Udma_eventAllocResource+0xee> @ imm = #0xa
7009ef62: e7ff         	b	0x7009ef64 <Udma_eventAllocResource+0xe4> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009ef64: 9804         	ldr	r0, [sp, #0x10]
7009ef66: 6800         	ldr	r0, [r0]
;         if((((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
7009ef68: 2805         	cmp	r0, #0x5
7009ef6a: d138         	bne	0x7009efde <Udma_eventAllocResource+0x15e> @ imm = #0x70
7009ef6c: e7ff         	b	0x7009ef6e <Udma_eventAllocResource+0xee> @ imm = #-0x2
;             if(UDMA_CORE_INTR_ANY != eventPrms->preferredCoreIntrNum)
7009ef6e: 9804         	ldr	r0, [sp, #0x10]
7009ef70: 6a00         	ldr	r0, [r0, #0x20]
7009ef72: 2101         	movs	r1, #0x1
7009ef74: f6cf 71ff    	movt	r1, #0xffff
7009ef78: 4288         	cmp	r0, r1
7009ef7a: d007         	beq	0x7009ef8c <Udma_eventAllocResource+0x10c> @ imm = #0xe
7009ef7c: e7ff         	b	0x7009ef7e <Udma_eventAllocResource+0xfe> @ imm = #-0x2
;                 preferredIrIntrNum = Udma_rmTranslateCoreIntrInput(drvHandle, eventPrms->preferredCoreIntrNum);
7009ef7e: 9809         	ldr	r0, [sp, #0x24]
7009ef80: 9904         	ldr	r1, [sp, #0x10]
7009ef82: 6a09         	ldr	r1, [r1, #0x20]
7009ef84: f010 f9a4    	bl	0x700af2d0 <Udma_rmTranslateCoreIntrInput> @ imm = #0x10348
7009ef88: 9005         	str	r0, [sp, #0x14]
;             }
7009ef8a: e003         	b	0x7009ef94 <Udma_eventAllocResource+0x114> @ imm = #0x6
;                 preferredIrIntrNum = eventPrms->preferredCoreIntrNum;
7009ef8c: 9804         	ldr	r0, [sp, #0x10]
7009ef8e: 6a00         	ldr	r0, [r0, #0x20]
7009ef90: 9005         	str	r0, [sp, #0x14]
7009ef92: e7ff         	b	0x7009ef94 <Udma_eventAllocResource+0x114> @ imm = #-0x2
;             if(UDMA_INTR_INVALID != preferredIrIntrNum)
7009ef94: 9805         	ldr	r0, [sp, #0x14]
7009ef96: f510 3f80    	cmn.w	r0, #0x10000
7009ef9a: d015         	beq	0x7009efc8 <Udma_eventAllocResource+0x148> @ imm = #0x2a
7009ef9c: e7ff         	b	0x7009ef9e <Udma_eventAllocResource+0x11e> @ imm = #-0x2
;                     Udma_rmAllocIrIntr(preferredIrIntrNum, drvHandle);
7009ef9e: 9805         	ldr	r0, [sp, #0x14]
7009efa0: 9909         	ldr	r1, [sp, #0x24]
7009efa2: f004 f915    	bl	0x700a31d0 <Udma_rmAllocIrIntr> @ imm = #0x422a
;                 eventHandle->irIntrNum =
7009efa6: 9908         	ldr	r1, [sp, #0x20]
7009efa8: 6548         	str	r0, [r1, #0x54]
;                 if(UDMA_INTR_INVALID != eventHandle->irIntrNum)
7009efaa: 9808         	ldr	r0, [sp, #0x20]
7009efac: 6d40         	ldr	r0, [r0, #0x54]
7009efae: f510 3f80    	cmn.w	r0, #0x10000
7009efb2: d008         	beq	0x7009efc6 <Udma_eventAllocResource+0x146> @ imm = #0x10
7009efb4: e7ff         	b	0x7009efb6 <Udma_eventAllocResource+0x136> @ imm = #-0x2
;                     eventHandle->coreIntrNum = Udma_rmTranslateIrOutput(drvHandle, eventHandle->irIntrNum);
7009efb6: 9809         	ldr	r0, [sp, #0x24]
7009efb8: 9908         	ldr	r1, [sp, #0x20]
7009efba: 6d49         	ldr	r1, [r1, #0x54]
7009efbc: f010 f9a0    	bl	0x700af300 <Udma_rmTranslateIrOutput> @ imm = #0x10340
7009efc0: 9908         	ldr	r1, [sp, #0x20]
7009efc2: 6588         	str	r0, [r1, #0x58]
;                 }
7009efc4: e7ff         	b	0x7009efc6 <Udma_eventAllocResource+0x146> @ imm = #-0x2
;             }
7009efc6: e7ff         	b	0x7009efc8 <Udma_eventAllocResource+0x148> @ imm = #-0x2
;             if(UDMA_INTR_INVALID == eventHandle->coreIntrNum)
7009efc8: 9808         	ldr	r0, [sp, #0x20]
7009efca: 6d80         	ldr	r0, [r0, #0x58]
7009efcc: f510 3f80    	cmn.w	r0, #0x10000
7009efd0: d104         	bne	0x7009efdc <Udma_eventAllocResource+0x15c> @ imm = #0x8
7009efd2: e7ff         	b	0x7009efd4 <Udma_eventAllocResource+0x154> @ imm = #-0x2
7009efd4: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009efd8: 9007         	str	r0, [sp, #0x1c]
;             }
7009efda: e7ff         	b	0x7009efdc <Udma_eventAllocResource+0x15c> @ imm = #-0x2
;         }
7009efdc: e7ff         	b	0x7009efde <Udma_eventAllocResource+0x15e> @ imm = #-0x2
;     }
7009efde: e7ff         	b	0x7009efe0 <Udma_eventAllocResource+0x160> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009efe0: 9807         	ldr	r0, [sp, #0x1c]
7009efe2: bb18         	cbnz	r0, 0x7009f02c <Udma_eventAllocResource+0x1ac> @ imm = #0x46
7009efe4: e7ff         	b	0x7009efe6 <Udma_eventAllocResource+0x166> @ imm = #-0x2
;         cookie = HwiP_disable();
7009efe6: f011 ecbc    	blx	0x700b0960 <HwiP_disable> @ imm = #0x11978
7009efea: 9002         	str	r0, [sp, #0x8]
;         eventHandle->prevEvent = (Udma_EventHandleInt) NULL_PTR;
7009efec: 9908         	ldr	r1, [sp, #0x20]
7009efee: 2000         	movs	r0, #0x0
7009eff0: 6608         	str	r0, [r1, #0x60]
;         eventHandle->nextEvent = (Udma_EventHandleInt) NULL_PTR;
7009eff2: 9908         	ldr	r1, [sp, #0x20]
7009eff4: 65c8         	str	r0, [r1, #0x5c]
;         if(NULL_PTR != eventPrms->controllerEventHandle)
7009eff6: 9804         	ldr	r0, [sp, #0x10]
7009eff8: 6900         	ldr	r0, [r0, #0x10]
7009effa: b198         	cbz	r0, 0x7009f024 <Udma_eventAllocResource+0x1a4> @ imm = #0x26
7009effc: e7ff         	b	0x7009effe <Udma_eventAllocResource+0x17e> @ imm = #-0x2
;             lastEvent = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
7009effe: 9804         	ldr	r0, [sp, #0x10]
7009f000: 6900         	ldr	r0, [r0, #0x10]
7009f002: 9003         	str	r0, [sp, #0xc]
;             while(NULL_PTR != lastEvent->nextEvent)
7009f004: e7ff         	b	0x7009f006 <Udma_eventAllocResource+0x186> @ imm = #-0x2
7009f006: 9803         	ldr	r0, [sp, #0xc]
7009f008: 6dc0         	ldr	r0, [r0, #0x5c]
7009f00a: b120         	cbz	r0, 0x7009f016 <Udma_eventAllocResource+0x196> @ imm = #0x8
7009f00c: e7ff         	b	0x7009f00e <Udma_eventAllocResource+0x18e> @ imm = #-0x2
;                 lastEvent = lastEvent->nextEvent;
7009f00e: 9803         	ldr	r0, [sp, #0xc]
7009f010: 6dc0         	ldr	r0, [r0, #0x5c]
7009f012: 9003         	str	r0, [sp, #0xc]
;             while(NULL_PTR != lastEvent->nextEvent)
7009f014: e7f7         	b	0x7009f006 <Udma_eventAllocResource+0x186> @ imm = #-0x12
;             eventHandle->prevEvent = lastEvent;
7009f016: 9803         	ldr	r0, [sp, #0xc]
7009f018: 9908         	ldr	r1, [sp, #0x20]
7009f01a: 6608         	str	r0, [r1, #0x60]
;             lastEvent->nextEvent   = eventHandle;
7009f01c: 9808         	ldr	r0, [sp, #0x20]
7009f01e: 9903         	ldr	r1, [sp, #0xc]
7009f020: 65c8         	str	r0, [r1, #0x5c]
;         }
7009f022: e7ff         	b	0x7009f024 <Udma_eventAllocResource+0x1a4> @ imm = #-0x2
;         HwiP_restore(cookie);
7009f024: 9802         	ldr	r0, [sp, #0x8]
7009f026: f011 ecbc    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x11978
;     }
7009f02a: e7ff         	b	0x7009f02c <Udma_eventAllocResource+0x1ac> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f02c: 9807         	ldr	r0, [sp, #0x1c]
7009f02e: b9a0         	cbnz	r0, 0x7009f05a <Udma_eventAllocResource+0x1da> @ imm = #0x28
7009f030: e7ff         	b	0x7009f032 <Udma_eventAllocResource+0x1b2> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009f032: 9804         	ldr	r0, [sp, #0x10]
7009f034: 6800         	ldr	r0, [r0]
7009f036: 2803         	cmp	r0, #0x3
7009f038: d10e         	bne	0x7009f058 <Udma_eventAllocResource+0x1d8> @ imm = #0x1c
7009f03a: e7ff         	b	0x7009f03c <Udma_eventAllocResource+0x1bc> @ imm = #-0x2
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009f03c: 9804         	ldr	r0, [sp, #0x10]
7009f03e: 6880         	ldr	r0, [r0, #0x8]
7009f040: 9001         	str	r0, [sp, #0x4]
;             if(TRUE == chHandle->chOesAllocDone)
7009f042: 9801         	ldr	r0, [sp, #0x4]
7009f044: f8d0 0248    	ldr.w	r0, [r0, #0x248]
7009f048: 2801         	cmp	r0, #0x1
7009f04a: d104         	bne	0x7009f056 <Udma_eventAllocResource+0x1d6> @ imm = #0x8
7009f04c: e7ff         	b	0x7009f04e <Udma_eventAllocResource+0x1ce> @ imm = #-0x2
7009f04e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009f052: 9007         	str	r0, [sp, #0x1c]
;             }
7009f054: e7ff         	b	0x7009f056 <Udma_eventAllocResource+0x1d6> @ imm = #-0x2
;         }
7009f056: e7ff         	b	0x7009f058 <Udma_eventAllocResource+0x1d8> @ imm = #-0x2
;     }
7009f058: e7ff         	b	0x7009f05a <Udma_eventAllocResource+0x1da> @ imm = #-0x2
;     if(UDMA_SOK != retVal)
7009f05a: 9807         	ldr	r0, [sp, #0x1c]
7009f05c: b128         	cbz	r0, 0x7009f06a <Udma_eventAllocResource+0x1ea> @ imm = #0xa
7009f05e: e7ff         	b	0x7009f060 <Udma_eventAllocResource+0x1e0> @ imm = #-0x2
;         Udma_eventFreeResource(drvHandle, eventHandle);
7009f060: 9809         	ldr	r0, [sp, #0x24]
7009f062: 9908         	ldr	r1, [sp, #0x20]
7009f064: f006 fe54    	bl	0x700a5d10 <Udma_eventFreeResource> @ imm = #0x6ca8
;     }
7009f068: e016         	b	0x7009f098 <Udma_eventAllocResource+0x218> @ imm = #0x2c
;         if(NULL_PTR == eventPrms->controllerEventHandle)
7009f06a: 9804         	ldr	r0, [sp, #0x10]
7009f06c: 6900         	ldr	r0, [r0, #0x10]
7009f06e: b920         	cbnz	r0, 0x7009f07a <Udma_eventAllocResource+0x1fa> @ imm = #0x8
7009f070: e7ff         	b	0x7009f072 <Udma_eventAllocResource+0x1f2> @ imm = #-0x2
;             vintrNum = eventHandle->vintrNum;
7009f072: 9808         	ldr	r0, [sp, #0x20]
7009f074: 6cc0         	ldr	r0, [r0, #0x4c]
7009f076: 9006         	str	r0, [sp, #0x18]
;         }
7009f078: e004         	b	0x7009f084 <Udma_eventAllocResource+0x204> @ imm = #0x8
;             vintrNum = ((Udma_EventHandleInt) (eventPrms->controllerEventHandle))->vintrNum;
7009f07a: 9804         	ldr	r0, [sp, #0x10]
7009f07c: 6900         	ldr	r0, [r0, #0x10]
7009f07e: 6cc0         	ldr	r0, [r0, #0x4c]
7009f080: 9006         	str	r0, [sp, #0x18]
7009f082: e7ff         	b	0x7009f084 <Udma_eventAllocResource+0x204> @ imm = #-0x2
;         eventHandle->pIaVintrRegs = &drvHandle->iaRegs.pIntrRegs->VINT[vintrNum];
7009f084: 9809         	ldr	r0, [sp, #0x24]
7009f086: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
7009f08a: 9906         	ldr	r1, [sp, #0x18]
7009f08c: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009f090: 9908         	ldr	r1, [sp, #0x20]
7009f092: f8c1 0094    	str.w	r0, [r1, #0x94]
7009f096: e7ff         	b	0x7009f098 <Udma_eventAllocResource+0x218> @ imm = #-0x2
;     return (retVal);
7009f098: 9807         	ldr	r0, [sp, #0x1c]
7009f09a: b00a         	add	sp, #0x28
7009f09c: bd80         	pop	{r7, pc}
7009f09e: 0000         	movs	r0, r0

7009f0a0 <Udma_chFreeResource>:
; {
7009f0a0: b580         	push	{r7, lr}
7009f0a2: b084         	sub	sp, #0x10
7009f0a4: 9003         	str	r0, [sp, #0xc]
7009f0a6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f0a8: 9002         	str	r0, [sp, #0x8]
;     drvHandle = chHandle->drvHandle;
7009f0aa: 9803         	ldr	r0, [sp, #0xc]
7009f0ac: 6e80         	ldr	r0, [r0, #0x68]
7009f0ae: 9001         	str	r0, [sp, #0x4]
;     if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009f0b0: 9803         	ldr	r0, [sp, #0xc]
7009f0b2: 7800         	ldrb	r0, [r0]
7009f0b4: 0740         	lsls	r0, r0, #0x1d
7009f0b6: 2800         	cmp	r0, #0x0
7009f0b8: d52e         	bpl	0x7009f118 <Udma_chFreeResource+0x78> @ imm = #0x5c
7009f0ba: e7ff         	b	0x7009f0bc <Udma_chFreeResource+0x1c> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID != chHandle->txChNum)
7009f0bc: 9803         	ldr	r0, [sp, #0xc]
7009f0be: 6ec0         	ldr	r0, [r0, #0x6c]
7009f0c0: f510 3f80    	cmn.w	r0, #0x10000
7009f0c4: d027         	beq	0x7009f116 <Udma_chFreeResource+0x76> @ imm = #0x4e
7009f0c6: e7ff         	b	0x7009f0c8 <Udma_chFreeResource+0x28> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009f0c8: 9803         	ldr	r0, [sp, #0xc]
7009f0ca: 7800         	ldrb	r0, [r0]
7009f0cc: 0640         	lsls	r0, r0, #0x19
7009f0ce: 2800         	cmp	r0, #0x0
7009f0d0: d506         	bpl	0x7009f0e0 <Udma_chFreeResource+0x40> @ imm = #0xc
7009f0d2: e7ff         	b	0x7009f0d4 <Udma_chFreeResource+0x34> @ imm = #-0x2
;                 Udma_rmFreeBlkCopyHcCh(chHandle->txChNum, drvHandle);
7009f0d4: 9803         	ldr	r0, [sp, #0xc]
7009f0d6: 6ec0         	ldr	r0, [r0, #0x6c]
7009f0d8: 9901         	ldr	r1, [sp, #0x4]
7009f0da: f00c ffb9    	bl	0x700ac050 <Udma_rmFreeBlkCopyHcCh> @ imm = #0xcf72
;             }
7009f0de: e012         	b	0x7009f106 <Udma_chFreeResource+0x66> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009f0e0: 9803         	ldr	r0, [sp, #0xc]
7009f0e2: 7800         	ldrb	r0, [r0]
7009f0e4: 0600         	lsls	r0, r0, #0x18
7009f0e6: 2800         	cmp	r0, #0x0
7009f0e8: d506         	bpl	0x7009f0f8 <Udma_chFreeResource+0x58> @ imm = #0xc
7009f0ea: e7ff         	b	0x7009f0ec <Udma_chFreeResource+0x4c> @ imm = #-0x2
;                 Udma_rmFreeBlkCopyUhcCh(chHandle->txChNum, drvHandle);
7009f0ec: 9803         	ldr	r0, [sp, #0xc]
7009f0ee: 6ec0         	ldr	r0, [r0, #0x6c]
7009f0f0: 9901         	ldr	r1, [sp, #0x4]
7009f0f2: f00c ffe5    	bl	0x700ac0c0 <Udma_rmFreeBlkCopyUhcCh> @ imm = #0xcfca
;             }
7009f0f6: e005         	b	0x7009f104 <Udma_chFreeResource+0x64> @ imm = #0xa
;                 Udma_rmFreeBlkCopyCh(chHandle->txChNum, drvHandle);
7009f0f8: 9803         	ldr	r0, [sp, #0xc]
7009f0fa: 6ec0         	ldr	r0, [r0, #0x6c]
7009f0fc: 9901         	ldr	r1, [sp, #0x4]
7009f0fe: f00c ff6f    	bl	0x700abfe0 <Udma_rmFreeBlkCopyCh> @ imm = #0xcede
7009f102: e7ff         	b	0x7009f104 <Udma_chFreeResource+0x64> @ imm = #-0x2
7009f104: e7ff         	b	0x7009f106 <Udma_chFreeResource+0x66> @ imm = #-0x2
;             chHandle->txChNum = UDMA_DMA_CH_INVALID;
7009f106: 9903         	ldr	r1, [sp, #0xc]
7009f108: 2000         	movs	r0, #0x0
7009f10a: f6cf 70ff    	movt	r0, #0xffff
7009f10e: 66c8         	str	r0, [r1, #0x6c]
;             chHandle->rxChNum = UDMA_DMA_CH_INVALID;
7009f110: 9903         	ldr	r1, [sp, #0xc]
7009f112: 6708         	str	r0, [r1, #0x70]
;         }
7009f114: e7ff         	b	0x7009f116 <Udma_chFreeResource+0x76> @ imm = #-0x2
;     }
7009f116: e084         	b	0x7009f222 <Udma_chFreeResource+0x182> @ imm = #0x108
;         if(UDMA_DMA_CH_INVALID != chHandle->txChNum)
7009f118: 9803         	ldr	r0, [sp, #0xc]
7009f11a: 6ec0         	ldr	r0, [r0, #0x6c]
7009f11c: f510 3f80    	cmn.w	r0, #0x10000
7009f120: d032         	beq	0x7009f188 <Udma_chFreeResource+0xe8> @ imm = #0x64
7009f122: e7ff         	b	0x7009f124 <Udma_chFreeResource+0x84> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009f124: 9803         	ldr	r0, [sp, #0xc]
7009f126: 7800         	ldrb	r0, [r0]
7009f128: 0640         	lsls	r0, r0, #0x19
7009f12a: 2800         	cmp	r0, #0x0
7009f12c: d506         	bpl	0x7009f13c <Udma_chFreeResource+0x9c> @ imm = #0xc
7009f12e: e7ff         	b	0x7009f130 <Udma_chFreeResource+0x90> @ imm = #-0x2
;                 Udma_rmFreeTxHcCh(chHandle->txChNum, drvHandle);
7009f130: 9803         	ldr	r0, [sp, #0xc]
7009f132: 6ec0         	ldr	r0, [r0, #0x6c]
7009f134: 9901         	ldr	r1, [sp, #0x4]
7009f136: f00d f8db    	bl	0x700ac2f0 <Udma_rmFreeTxHcCh> @ imm = #0xd1b6
;             }
7009f13a: e01f         	b	0x7009f17c <Udma_chFreeResource+0xdc> @ imm = #0x3e
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009f13c: 9803         	ldr	r0, [sp, #0xc]
7009f13e: 7840         	ldrb	r0, [r0, #0x1]
7009f140: 07c0         	lsls	r0, r0, #0x1f
7009f142: b138         	cbz	r0, 0x7009f154 <Udma_chFreeResource+0xb4> @ imm = #0xe
7009f144: e7ff         	b	0x7009f146 <Udma_chFreeResource+0xa6> @ imm = #-0x2
;                 Udma_rmFreeMappedTxCh(chHandle->txChNum, drvHandle, chHandle->chPrms.mappedChGrp);
7009f146: 9803         	ldr	r0, [sp, #0xc]
7009f148: 68c2         	ldr	r2, [r0, #0xc]
7009f14a: 6ec0         	ldr	r0, [r0, #0x6c]
7009f14c: 9901         	ldr	r1, [sp, #0x4]
7009f14e: f00c fa07    	bl	0x700ab560 <Udma_rmFreeMappedTxCh> @ imm = #0xc40e
;             }
7009f152: e012         	b	0x7009f17a <Udma_chFreeResource+0xda> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009f154: 9803         	ldr	r0, [sp, #0xc]
7009f156: 7800         	ldrb	r0, [r0]
7009f158: 0600         	lsls	r0, r0, #0x18
7009f15a: 2800         	cmp	r0, #0x0
7009f15c: d506         	bpl	0x7009f16c <Udma_chFreeResource+0xcc> @ imm = #0xc
7009f15e: e7ff         	b	0x7009f160 <Udma_chFreeResource+0xc0> @ imm = #-0x2
;                 Udma_rmFreeTxUhcCh(chHandle->txChNum, drvHandle);
7009f160: 9803         	ldr	r0, [sp, #0xc]
7009f162: 6ec0         	ldr	r0, [r0, #0x6c]
7009f164: 9901         	ldr	r1, [sp, #0x4]
7009f166: f00d f8fb    	bl	0x700ac360 <Udma_rmFreeTxUhcCh> @ imm = #0xd1f6
;             }
7009f16a: e005         	b	0x7009f178 <Udma_chFreeResource+0xd8> @ imm = #0xa
;                 Udma_rmFreeTxCh(chHandle->txChNum, drvHandle);
7009f16c: 9803         	ldr	r0, [sp, #0xc]
7009f16e: 6ec0         	ldr	r0, [r0, #0x6c]
7009f170: 9901         	ldr	r1, [sp, #0x4]
7009f172: f00d f885    	bl	0x700ac280 <Udma_rmFreeTxCh> @ imm = #0xd10a
7009f176: e7ff         	b	0x7009f178 <Udma_chFreeResource+0xd8> @ imm = #-0x2
7009f178: e7ff         	b	0x7009f17a <Udma_chFreeResource+0xda> @ imm = #-0x2
7009f17a: e7ff         	b	0x7009f17c <Udma_chFreeResource+0xdc> @ imm = #-0x2
;             chHandle->txChNum = UDMA_DMA_CH_INVALID;
7009f17c: 9903         	ldr	r1, [sp, #0xc]
7009f17e: 2000         	movs	r0, #0x0
7009f180: f6cf 70ff    	movt	r0, #0xffff
7009f184: 66c8         	str	r0, [r1, #0x6c]
;         }
7009f186: e7ff         	b	0x7009f188 <Udma_chFreeResource+0xe8> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID != chHandle->rxChNum)
7009f188: 9803         	ldr	r0, [sp, #0xc]
7009f18a: 6f00         	ldr	r0, [r0, #0x70]
7009f18c: f510 3f80    	cmn.w	r0, #0x10000
7009f190: d033         	beq	0x7009f1fa <Udma_chFreeResource+0x15a> @ imm = #0x66
7009f192: e7ff         	b	0x7009f194 <Udma_chFreeResource+0xf4> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009f194: 9803         	ldr	r0, [sp, #0xc]
7009f196: 7800         	ldrb	r0, [r0]
7009f198: 0640         	lsls	r0, r0, #0x19
7009f19a: 2800         	cmp	r0, #0x0
7009f19c: d506         	bpl	0x7009f1ac <Udma_chFreeResource+0x10c> @ imm = #0xc
7009f19e: e7ff         	b	0x7009f1a0 <Udma_chFreeResource+0x100> @ imm = #-0x2
;                 Udma_rmFreeRxHcCh(chHandle->rxChNum, drvHandle);
7009f1a0: 9803         	ldr	r0, [sp, #0xc]
7009f1a2: 6f00         	ldr	r0, [r0, #0x70]
7009f1a4: 9901         	ldr	r1, [sp, #0x4]
7009f1a6: f00c fffb    	bl	0x700ac1a0 <Udma_rmFreeRxHcCh> @ imm = #0xcff6
;             }
7009f1aa: e020         	b	0x7009f1ee <Udma_chFreeResource+0x14e> @ imm = #0x40
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009f1ac: 9803         	ldr	r0, [sp, #0xc]
7009f1ae: 7840         	ldrb	r0, [r0, #0x1]
7009f1b0: 07c0         	lsls	r0, r0, #0x1f
7009f1b2: b140         	cbz	r0, 0x7009f1c6 <Udma_chFreeResource+0x126> @ imm = #0x10
7009f1b4: e7ff         	b	0x7009f1b6 <Udma_chFreeResource+0x116> @ imm = #-0x2
;                 Udma_rmFreeMappedRxCh(chHandle->rxChNum, drvHandle, chHandle->chPrms.mappedChGrp - UDMA_NUM_MAPPED_TX_GROUP);
7009f1b6: 9803         	ldr	r0, [sp, #0xc]
7009f1b8: 68c2         	ldr	r2, [r0, #0xc]
7009f1ba: 6f00         	ldr	r0, [r0, #0x70]
7009f1bc: 9901         	ldr	r1, [sp, #0x4]
7009f1be: 3a04         	subs	r2, #0x4
7009f1c0: f00c f996    	bl	0x700ab4f0 <Udma_rmFreeMappedRxCh> @ imm = #0xc32c
;             }
7009f1c4: e012         	b	0x7009f1ec <Udma_chFreeResource+0x14c> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009f1c6: 9803         	ldr	r0, [sp, #0xc]
7009f1c8: 7800         	ldrb	r0, [r0]
7009f1ca: 0600         	lsls	r0, r0, #0x18
7009f1cc: 2800         	cmp	r0, #0x0
7009f1ce: d506         	bpl	0x7009f1de <Udma_chFreeResource+0x13e> @ imm = #0xc
7009f1d0: e7ff         	b	0x7009f1d2 <Udma_chFreeResource+0x132> @ imm = #-0x2
;                 Udma_rmFreeRxUhcCh(chHandle->rxChNum, drvHandle);
7009f1d2: 9803         	ldr	r0, [sp, #0xc]
7009f1d4: 6f00         	ldr	r0, [r0, #0x70]
7009f1d6: 9901         	ldr	r1, [sp, #0x4]
7009f1d8: f00d f81a    	bl	0x700ac210 <Udma_rmFreeRxUhcCh> @ imm = #0xd034
;             }
7009f1dc: e005         	b	0x7009f1ea <Udma_chFreeResource+0x14a> @ imm = #0xa
;                 Udma_rmFreeRxCh(chHandle->rxChNum, drvHandle);
7009f1de: 9803         	ldr	r0, [sp, #0xc]
7009f1e0: 6f00         	ldr	r0, [r0, #0x70]
7009f1e2: 9901         	ldr	r1, [sp, #0x4]
7009f1e4: f00c ffa4    	bl	0x700ac130 <Udma_rmFreeRxCh> @ imm = #0xcf48
7009f1e8: e7ff         	b	0x7009f1ea <Udma_chFreeResource+0x14a> @ imm = #-0x2
7009f1ea: e7ff         	b	0x7009f1ec <Udma_chFreeResource+0x14c> @ imm = #-0x2
7009f1ec: e7ff         	b	0x7009f1ee <Udma_chFreeResource+0x14e> @ imm = #-0x2
;             chHandle->rxChNum = UDMA_DMA_CH_INVALID;
7009f1ee: 9903         	ldr	r1, [sp, #0xc]
7009f1f0: 2000         	movs	r0, #0x0
7009f1f2: f6cf 70ff    	movt	r0, #0xffff
7009f1f6: 6708         	str	r0, [r1, #0x70]
;         }
7009f1f8: e7ff         	b	0x7009f1fa <Udma_chFreeResource+0x15a> @ imm = #-0x2
;         chHandle->defaultFlowObj.drvHandle    = (Udma_DrvHandleInt) NULL_PTR;
7009f1fa: 9903         	ldr	r1, [sp, #0xc]
7009f1fc: 2000         	movs	r0, #0x0
7009f1fe: f8c1 01cc    	str.w	r0, [r1, #0x1cc]
;         chHandle->defaultFlowObj.flowStart    = UDMA_FLOW_INVALID;
7009f202: 9a03         	ldr	r2, [sp, #0xc]
7009f204: 2100         	movs	r1, #0x0
7009f206: f6cf 71ff    	movt	r1, #0xffff
7009f20a: f8c2 11d0    	str.w	r1, [r2, #0x1d0]
;         chHandle->defaultFlowObj.flowCnt      = 0U;
7009f20e: 9903         	ldr	r1, [sp, #0xc]
7009f210: f8c1 01d4    	str.w	r0, [r1, #0x1d4]
;         chHandle->defaultFlowObj.flowInitDone = UDMA_DEINIT_DONE;
7009f214: 9903         	ldr	r1, [sp, #0xc]
7009f216: f8c1 01d8    	str.w	r0, [r1, #0x1d8]
;         chHandle->defaultFlow                 = (Udma_FlowHandleInt) NULL_PTR;
7009f21a: 9903         	ldr	r1, [sp, #0xc]
7009f21c: f8c1 01c8    	str.w	r0, [r1, #0x1c8]
7009f220: e7ff         	b	0x7009f222 <Udma_chFreeResource+0x182> @ imm = #-0x2
;     chHandle->pdmaChNum = UDMA_DMA_CH_INVALID;
7009f222: 9903         	ldr	r1, [sp, #0xc]
7009f224: 2000         	movs	r0, #0x0
7009f226: f6cf 70ff    	movt	r0, #0xffff
7009f22a: 6788         	str	r0, [r1, #0x78]
;     chHandle->peerThreadId = UDMA_THREAD_ID_INVALID;
7009f22c: 9903         	ldr	r1, [sp, #0xc]
7009f22e: 2004         	movs	r0, #0x4
7009f230: f6cf 70ff    	movt	r0, #0xffff
7009f234: 67c8         	str	r0, [r1, #0x7c]
;     if(NULL_PTR != chHandle->fqRing)
7009f236: 9803         	ldr	r0, [sp, #0xc]
7009f238: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009f23c: b190         	cbz	r0, 0x7009f264 <Udma_chFreeResource+0x1c4> @ imm = #0x24
7009f23e: e7ff         	b	0x7009f240 <Udma_chFreeResource+0x1a0> @ imm = #-0x2
;         retVal += Udma_ringFree(chHandle->fqRing);
7009f240: 9803         	ldr	r0, [sp, #0xc]
7009f242: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009f246: f007 ff53    	bl	0x700a70f0 <Udma_ringFree> @ imm = #0x7ea6
7009f24a: 4601         	mov	r1, r0
7009f24c: 9802         	ldr	r0, [sp, #0x8]
7009f24e: 4408         	add	r0, r1
7009f250: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
7009f252: 9802         	ldr	r0, [sp, #0x8]
7009f254: b108         	cbz	r0, 0x7009f25a <Udma_chFreeResource+0x1ba> @ imm = #0x2
7009f256: e7ff         	b	0x7009f258 <Udma_chFreeResource+0x1b8> @ imm = #-0x2
;         }
7009f258: e7ff         	b	0x7009f25a <Udma_chFreeResource+0x1ba> @ imm = #-0x2
;         chHandle->fqRing = (Udma_RingHandleInt) NULL_PTR;
7009f25a: 9903         	ldr	r1, [sp, #0xc]
7009f25c: 2000         	movs	r0, #0x0
7009f25e: f8c1 0080    	str.w	r0, [r1, #0x80]
;     }
7009f262: e7ff         	b	0x7009f264 <Udma_chFreeResource+0x1c4> @ imm = #-0x2
;     if(NULL_PTR != chHandle->cqRing)
7009f264: 9803         	ldr	r0, [sp, #0xc]
7009f266: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009f26a: b128         	cbz	r0, 0x7009f278 <Udma_chFreeResource+0x1d8> @ imm = #0xa
7009f26c: e7ff         	b	0x7009f26e <Udma_chFreeResource+0x1ce> @ imm = #-0x2
;         chHandle->cqRing = (Udma_RingHandleInt) NULL_PTR;
7009f26e: 9903         	ldr	r1, [sp, #0xc]
7009f270: 2000         	movs	r0, #0x0
7009f272: f8c1 0084    	str.w	r0, [r1, #0x84]
;     }
7009f276: e7ff         	b	0x7009f278 <Udma_chFreeResource+0x1d8> @ imm = #-0x2
;     if(NULL_PTR != chHandle->tdCqRing)
7009f278: 9803         	ldr	r0, [sp, #0xc]
7009f27a: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009f27e: b190         	cbz	r0, 0x7009f2a6 <Udma_chFreeResource+0x206> @ imm = #0x24
7009f280: e7ff         	b	0x7009f282 <Udma_chFreeResource+0x1e2> @ imm = #-0x2
;         retVal += Udma_ringFree(chHandle->tdCqRing);
7009f282: 9803         	ldr	r0, [sp, #0xc]
7009f284: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009f288: f007 ff32    	bl	0x700a70f0 <Udma_ringFree> @ imm = #0x7e64
7009f28c: 4601         	mov	r1, r0
7009f28e: 9802         	ldr	r0, [sp, #0x8]
7009f290: 4408         	add	r0, r1
7009f292: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
7009f294: 9802         	ldr	r0, [sp, #0x8]
7009f296: b108         	cbz	r0, 0x7009f29c <Udma_chFreeResource+0x1fc> @ imm = #0x2
7009f298: e7ff         	b	0x7009f29a <Udma_chFreeResource+0x1fa> @ imm = #-0x2
;         }
7009f29a: e7ff         	b	0x7009f29c <Udma_chFreeResource+0x1fc> @ imm = #-0x2
;         chHandle->tdCqRing = (Udma_RingHandleInt) NULL_PTR;
7009f29c: 9903         	ldr	r1, [sp, #0xc]
7009f29e: 2000         	movs	r0, #0x0
7009f2a0: f8c1 0088    	str.w	r0, [r1, #0x88]
;     }
7009f2a4: e7ff         	b	0x7009f2a6 <Udma_chFreeResource+0x206> @ imm = #-0x2
;     return (retVal);
7009f2a6: 9802         	ldr	r0, [sp, #0x8]
7009f2a8: b004         	add	sp, #0x10
7009f2aa: bd80         	pop	{r7, pc}
7009f2ac: 0000         	movs	r0, r0
7009f2ae: 0000         	movs	r0, r0

7009f2b0 <Udma_ringAlloc>:
; {
7009f2b0: b580         	push	{r7, lr}
7009f2b2: b096         	sub	sp, #0x58
7009f2b4: 9015         	str	r0, [sp, #0x54]
7009f2b6: 9114         	str	r1, [sp, #0x50]
7009f2b8: f8ad 204e    	strh.w	r2, [sp, #0x4e]
7009f2bc: 9312         	str	r3, [sp, #0x48]
7009f2be: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f2c0: 9011         	str	r0, [sp, #0x44]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009f2c2: 900d         	str	r0, [sp, #0x34]
;     Udma_DrvHandleInt   drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009f2c4: 9815         	ldr	r0, [sp, #0x54]
7009f2c6: 900c         	str	r0, [sp, #0x30]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
7009f2c8: 9814         	ldr	r0, [sp, #0x50]
7009f2ca: 900b         	str	r0, [sp, #0x2c]
;     if((NULL_PTR == drvHandleInt) ||
7009f2cc: 980c         	ldr	r0, [sp, #0x30]
7009f2ce: b130         	cbz	r0, 0x7009f2de <Udma_ringAlloc+0x2e> @ imm = #0xc
7009f2d0: e7ff         	b	0x7009f2d2 <Udma_ringAlloc+0x22> @ imm = #-0x2
;        (NULL_PTR == ringHandleInt) ||
7009f2d2: 980b         	ldr	r0, [sp, #0x2c]
7009f2d4: b118         	cbz	r0, 0x7009f2de <Udma_ringAlloc+0x2e> @ imm = #0x6
7009f2d6: e7ff         	b	0x7009f2d8 <Udma_ringAlloc+0x28> @ imm = #-0x2
;        (NULL_PTR == ringPrms))
7009f2d8: 9812         	ldr	r0, [sp, #0x48]
;     if((NULL_PTR == drvHandleInt) ||
7009f2da: b920         	cbnz	r0, 0x7009f2e6 <Udma_ringAlloc+0x36> @ imm = #0x8
7009f2dc: e7ff         	b	0x7009f2de <Udma_ringAlloc+0x2e> @ imm = #-0x2
7009f2de: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009f2e2: 9011         	str	r0, [sp, #0x44]
;     }
7009f2e4: e7ff         	b	0x7009f2e6 <Udma_ringAlloc+0x36> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f2e6: 9811         	ldr	r0, [sp, #0x44]
7009f2e8: b978         	cbnz	r0, 0x7009f30a <Udma_ringAlloc+0x5a> @ imm = #0x1e
7009f2ea: e7ff         	b	0x7009f2ec <Udma_ringAlloc+0x3c> @ imm = #-0x2
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009f2ec: 980c         	ldr	r0, [sp, #0x30]
7009f2ee: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009f2f2: f64a 31cd    	movw	r1, #0xabcd
7009f2f6: f6ca 31dc    	movt	r1, #0xabdc
7009f2fa: 4288         	cmp	r0, r1
7009f2fc: d004         	beq	0x7009f308 <Udma_ringAlloc+0x58> @ imm = #0x8
7009f2fe: e7ff         	b	0x7009f300 <Udma_ringAlloc+0x50> @ imm = #-0x2
7009f300: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009f304: 9011         	str	r0, [sp, #0x44]
;         }
7009f306: e7ff         	b	0x7009f308 <Udma_ringAlloc+0x58> @ imm = #-0x2
;     }
7009f308: e7ff         	b	0x7009f30a <Udma_ringAlloc+0x5a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f30a: 9811         	ldr	r0, [sp, #0x44]
7009f30c: b930         	cbnz	r0, 0x7009f31c <Udma_ringAlloc+0x6c> @ imm = #0xc
7009f30e: e7ff         	b	0x7009f310 <Udma_ringAlloc+0x60> @ imm = #-0x2
;         retVal = Udma_ringCheckParams(drvHandleInt, ringPrms);
7009f310: 980c         	ldr	r0, [sp, #0x30]
7009f312: 9912         	ldr	r1, [sp, #0x48]
7009f314: f007 fd4c    	bl	0x700a6db0 <Udma_ringCheckParams> @ imm = #0x7a98
7009f318: 9011         	str	r0, [sp, #0x44]
;     }
7009f31a: e7ff         	b	0x7009f31c <Udma_ringAlloc+0x6c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f31c: 9811         	ldr	r0, [sp, #0x44]
7009f31e: 2800         	cmp	r0, #0x0
7009f320: d140         	bne	0x7009f3a4 <Udma_ringAlloc+0xf4> @ imm = #0x80
7009f322: e7ff         	b	0x7009f324 <Udma_ringAlloc+0x74> @ imm = #-0x2
;         if(UDMA_RING_ANY == ringNum)
7009f324: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009f328: f64f 71fe    	movw	r1, #0xfffe
7009f32c: 4288         	cmp	r0, r1
7009f32e: d126         	bne	0x7009f37e <Udma_ringAlloc+0xce> @ imm = #0x4c
7009f330: e7ff         	b	0x7009f332 <Udma_ringAlloc+0x82> @ imm = #-0x2
;             if(UDMA_MAPPED_GROUP_INVALID == ringPrms->mappedRingGrp)
7009f332: 9812         	ldr	r0, [sp, #0x48]
7009f334: 6940         	ldr	r0, [r0, #0x14]
7009f336: 2104         	movs	r1, #0x4
7009f338: f6cf 71ff    	movt	r1, #0xffff
7009f33c: 4288         	cmp	r0, r1
7009f33e: d106         	bne	0x7009f34e <Udma_ringAlloc+0x9e> @ imm = #0xc
7009f340: e7ff         	b	0x7009f342 <Udma_ringAlloc+0x92> @ imm = #-0x2
;                 ringHandleInt->ringNum = Udma_rmAllocFreeRing(drvHandleInt);
7009f342: 980c         	ldr	r0, [sp, #0x30]
7009f344: f010 fb2c    	bl	0x700af9a0 <Udma_rmAllocFreeRing> @ imm = #0x10658
7009f348: 990b         	ldr	r1, [sp, #0x2c]
7009f34a: 8088         	strh	r0, [r1, #0x4]
;             }
7009f34c: e008         	b	0x7009f360 <Udma_ringAlloc+0xb0> @ imm = #0x10
;                 ringHandleInt->ringNum = Udma_rmAllocMappedRing(drvHandleInt, ringPrms->mappedRingGrp, ringPrms->mappedChNum);
7009f34e: 980c         	ldr	r0, [sp, #0x30]
7009f350: 9a12         	ldr	r2, [sp, #0x48]
7009f352: 6951         	ldr	r1, [r2, #0x14]
7009f354: 6992         	ldr	r2, [r2, #0x18]
7009f356: f003 fae3    	bl	0x700a2920 <Udma_rmAllocMappedRing> @ imm = #0x35c6
7009f35a: 990b         	ldr	r1, [sp, #0x2c]
7009f35c: 8088         	strh	r0, [r1, #0x4]
7009f35e: e7ff         	b	0x7009f360 <Udma_ringAlloc+0xb0> @ imm = #-0x2
;             if(UDMA_RING_INVALID == ringHandleInt->ringNum)
7009f360: 980b         	ldr	r0, [sp, #0x2c]
7009f362: 8880         	ldrh	r0, [r0, #0x4]
7009f364: f64f 71ff    	movw	r1, #0xffff
7009f368: 4288         	cmp	r0, r1
7009f36a: d104         	bne	0x7009f376 <Udma_ringAlloc+0xc6> @ imm = #0x8
7009f36c: e7ff         	b	0x7009f36e <Udma_ringAlloc+0xbe> @ imm = #-0x2
7009f36e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009f372: 9011         	str	r0, [sp, #0x44]
;             }
7009f374: e002         	b	0x7009f37c <Udma_ringAlloc+0xcc> @ imm = #0x4
7009f376: 2001         	movs	r0, #0x1
;                 allocDone = (uint32_t) TRUE;
7009f378: 900d         	str	r0, [sp, #0x34]
7009f37a: e7ff         	b	0x7009f37c <Udma_ringAlloc+0xcc> @ imm = #-0x2
;         }
7009f37c: e011         	b	0x7009f3a2 <Udma_ringAlloc+0xf2> @ imm = #0x22
;             if(ringNum >= drvHandleInt->maxRings)
7009f37e: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009f382: 990c         	ldr	r1, [sp, #0x30]
7009f384: f8d1 10dc    	ldr.w	r1, [r1, #0xdc]
7009f388: 4288         	cmp	r0, r1
7009f38a: d304         	blo	0x7009f396 <Udma_ringAlloc+0xe6> @ imm = #0x8
7009f38c: e7ff         	b	0x7009f38e <Udma_ringAlloc+0xde> @ imm = #-0x2
7009f38e: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
7009f392: 9011         	str	r0, [sp, #0x44]
;             }
7009f394: e004         	b	0x7009f3a0 <Udma_ringAlloc+0xf0> @ imm = #0x8
;                 ringHandleInt->ringNum = ringNum;
7009f396: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009f39a: 990b         	ldr	r1, [sp, #0x2c]
7009f39c: 8088         	strh	r0, [r1, #0x4]
7009f39e: e7ff         	b	0x7009f3a0 <Udma_ringAlloc+0xf0> @ imm = #-0x2
7009f3a0: e7ff         	b	0x7009f3a2 <Udma_ringAlloc+0xf2> @ imm = #-0x2
;     }
7009f3a2: e7ff         	b	0x7009f3a4 <Udma_ringAlloc+0xf4> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f3a4: 9811         	ldr	r0, [sp, #0x44]
7009f3a6: b9a8         	cbnz	r0, 0x7009f3d4 <Udma_ringAlloc+0x124> @ imm = #0x2a
7009f3a8: e7ff         	b	0x7009f3aa <Udma_ringAlloc+0xfa> @ imm = #-0x2
;         Udma_ringAssertFnPointers(drvHandleInt);
7009f3aa: 980c         	ldr	r0, [sp, #0x30]
7009f3ac: f010 fcb0    	bl	0x700afd10 <Udma_ringAssertFnPointers> @ imm = #0x10960
;         ringHandleInt->drvHandle = drvHandleInt;
7009f3b0: 980c         	ldr	r0, [sp, #0x30]
7009f3b2: 990b         	ldr	r1, [sp, #0x2c]
7009f3b4: 6008         	str	r0, [r1]
;         ringHandleInt->mappedRingGrp   = ringPrms->mappedRingGrp;
7009f3b6: 9812         	ldr	r0, [sp, #0x48]
7009f3b8: 6940         	ldr	r0, [r0, #0x14]
7009f3ba: 990b         	ldr	r1, [sp, #0x2c]
7009f3bc: 65c8         	str	r0, [r1, #0x5c]
;         ringHandleInt->mappedChNum     = ringPrms->mappedChNum;
7009f3be: 9812         	ldr	r0, [sp, #0x48]
7009f3c0: 6980         	ldr	r0, [r0, #0x18]
7009f3c2: 990b         	ldr	r1, [sp, #0x2c]
7009f3c4: 6608         	str	r0, [r1, #0x60]
;         drvHandleInt->ringSetCfg(drvHandleInt, ringHandleInt, ringPrms);
7009f3c6: 980c         	ldr	r0, [sp, #0x30]
7009f3c8: f8d0 35c4    	ldr.w	r3, [r0, #0x5c4]
7009f3cc: 990b         	ldr	r1, [sp, #0x2c]
7009f3ce: 9a12         	ldr	r2, [sp, #0x48]
7009f3d0: 4798         	blx	r3
;     }
7009f3d2: e7ff         	b	0x7009f3d4 <Udma_ringAlloc+0x124> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f3d4: 9811         	ldr	r0, [sp, #0x44]
7009f3d6: 2800         	cmp	r0, #0x0
7009f3d8: d146         	bne	0x7009f468 <Udma_ringAlloc+0x1b8> @ imm = #0x8c
7009f3da: e7ff         	b	0x7009f3dc <Udma_ringAlloc+0x12c> @ imm = #-0x2
7009f3dc: 20bf         	movs	r0, #0xbf
;         rmRingReq.valid_params  = TISCI_MSG_VALUE_RM_RING_ADDR_LO_VALID |
7009f3de: 9004         	str	r0, [sp, #0x10]
;         rmRingReq.nav_id        = drvHandleInt->devIdRing;
7009f3e0: 980c         	ldr	r0, [sp, #0x30]
7009f3e2: f8b0 00e0    	ldrh.w	r0, [r0, #0xe0]
7009f3e6: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmRingReq.index         = ringHandleInt->ringNum;
7009f3ea: 980b         	ldr	r0, [sp, #0x2c]
7009f3ec: 8880         	ldrh	r0, [r0, #0x4]
7009f3ee: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         physBase = Udma_virtToPhyFxn(ringPrms->ringMem, drvHandleInt, (Udma_ChHandleInt) NULL_PTR);
7009f3f2: 9812         	ldr	r0, [sp, #0x48]
7009f3f4: 6800         	ldr	r0, [r0]
7009f3f6: 990c         	ldr	r1, [sp, #0x30]
7009f3f8: 2200         	movs	r2, #0x0
7009f3fa: f00d f849    	bl	0x700ac490 <Udma_virtToPhyFxn> @ imm = #0xd092
7009f3fe: 910f         	str	r1, [sp, #0x3c]
7009f400: 900e         	str	r0, [sp, #0x38]
;         rmRingReq.addr_lo       = (uint32_t)physBase;
7009f402: 980e         	ldr	r0, [sp, #0x38]
7009f404: 9006         	str	r0, [sp, #0x18]
;         rmRingReq.addr_hi       = (uint32_t)(physBase >> 32UL);
7009f406: 980f         	ldr	r0, [sp, #0x3c]
7009f408: 9007         	str	r0, [sp, #0x1c]
;         rmRingReq.count         = ringPrms->elemCnt;
7009f40a: 9812         	ldr	r0, [sp, #0x48]
7009f40c: 68c0         	ldr	r0, [r0, #0xc]
7009f40e: 9008         	str	r0, [sp, #0x20]
;         rmRingReq.mode          = ringPrms->mode;
7009f410: 9812         	ldr	r0, [sp, #0x48]
7009f412: 7a00         	ldrb	r0, [r0, #0x8]
7009f414: f88d 0024    	strb.w	r0, [sp, #0x24]
;         rmRingReq.size          = ringPrms->elemSize;
7009f418: 9812         	ldr	r0, [sp, #0x48]
7009f41a: 7c00         	ldrb	r0, [r0, #0x10]
7009f41c: f88d 0025    	strb.w	r0, [sp, #0x25]
;         rmRingReq.order_id      = ringPrms->orderId;
7009f420: 9812         	ldr	r0, [sp, #0x48]
7009f422: 7c40         	ldrb	r0, [r0, #0x11]
7009f424: f88d 0026    	strb.w	r0, [sp, #0x26]
;         rmRingReq.asel          = ringPrms->asel;
7009f428: 9812         	ldr	r0, [sp, #0x48]
7009f42a: 7c80         	ldrb	r0, [r0, #0x12]
7009f42c: f88d 0029    	strb.w	r0, [sp, #0x29]
;         if(UDMA_RING_VIRTID_INVALID != ringPrms->virtId)
7009f430: 9812         	ldr	r0, [sp, #0x48]
7009f432: 8940         	ldrh	r0, [r0, #0xa]
7009f434: f64f 71ff    	movw	r1, #0xffff
7009f438: 4288         	cmp	r0, r1
7009f43a: d009         	beq	0x7009f450 <Udma_ringAlloc+0x1a0> @ imm = #0x12
7009f43c: e7ff         	b	0x7009f43e <Udma_ringAlloc+0x18e> @ imm = #-0x2
;             rmRingReq.valid_params |= TISCI_MSG_VALUE_RM_RING_VIRTID_VALID;
7009f43e: 9804         	ldr	r0, [sp, #0x10]
7009f440: f040 0040    	orr	r0, r0, #0x40
7009f444: 9004         	str	r0, [sp, #0x10]
;             rmRingReq.virtid        = ringPrms->virtId;
7009f446: 9812         	ldr	r0, [sp, #0x48]
7009f448: 8940         	ldrh	r0, [r0, #0xa]
7009f44a: f8ad 0027    	strh.w	r0, [sp, #0x27]
;         }
7009f44e: e7ff         	b	0x7009f450 <Udma_ringAlloc+0x1a0> @ imm = #-0x2
7009f450: a802         	add	r0, sp, #0x8
7009f452: 4669         	mov	r1, sp
7009f454: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmRingCfg(
7009f458: f00d fa5a    	bl	0x700ac910 <Sciclient_rmRingCfg> @ imm = #0xd4b4
7009f45c: 9011         	str	r0, [sp, #0x44]
;         if(CSL_PASS != retVal)
7009f45e: 9811         	ldr	r0, [sp, #0x44]
7009f460: b108         	cbz	r0, 0x7009f466 <Udma_ringAlloc+0x1b6> @ imm = #0x2
7009f462: e7ff         	b	0x7009f464 <Udma_ringAlloc+0x1b4> @ imm = #-0x2
;         }
7009f464: e7ff         	b	0x7009f466 <Udma_ringAlloc+0x1b6> @ imm = #-0x2
;     }
7009f466: e7ff         	b	0x7009f468 <Udma_ringAlloc+0x1b8> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f468: 9811         	ldr	r0, [sp, #0x44]
7009f46a: b938         	cbnz	r0, 0x7009f47c <Udma_ringAlloc+0x1cc> @ imm = #0xe
7009f46c: e7ff         	b	0x7009f46e <Udma_ringAlloc+0x1be> @ imm = #-0x2
;         ringHandleInt->ringInitDone = UDMA_INIT_DONE;
7009f46e: 990b         	ldr	r1, [sp, #0x2c]
7009f470: f64a 30cd    	movw	r0, #0xabcd
7009f474: f6ca 30dc    	movt	r0, #0xabdc
7009f478: 6588         	str	r0, [r1, #0x58]
;     }
7009f47a: e01b         	b	0x7009f4b4 <Udma_ringAlloc+0x204> @ imm = #0x36
;         if(((uint32_t) TRUE) == allocDone)
7009f47c: 980d         	ldr	r0, [sp, #0x34]
7009f47e: 2801         	cmp	r0, #0x1
7009f480: d117         	bne	0x7009f4b2 <Udma_ringAlloc+0x202> @ imm = #0x2e
7009f482: e7ff         	b	0x7009f484 <Udma_ringAlloc+0x1d4> @ imm = #-0x2
;             if(UDMA_MAPPED_GROUP_INVALID == ringPrms->mappedRingGrp)
7009f484: 9812         	ldr	r0, [sp, #0x48]
7009f486: 6940         	ldr	r0, [r0, #0x14]
7009f488: 2104         	movs	r1, #0x4
7009f48a: f6cf 71ff    	movt	r1, #0xffff
7009f48e: 4288         	cmp	r0, r1
7009f490: d106         	bne	0x7009f4a0 <Udma_ringAlloc+0x1f0> @ imm = #0xc
7009f492: e7ff         	b	0x7009f494 <Udma_ringAlloc+0x1e4> @ imm = #-0x2
;                 Udma_rmFreeFreeRing(ringHandleInt->ringNum, drvHandleInt);
7009f494: 980b         	ldr	r0, [sp, #0x2c]
7009f496: 8880         	ldrh	r0, [r0, #0x4]
7009f498: 990c         	ldr	r1, [sp, #0x30]
7009f49a: f010 fc01    	bl	0x700afca0 <Udma_rmFreeFreeRing> @ imm = #0x10802
;             }
7009f49e: e007         	b	0x7009f4b0 <Udma_ringAlloc+0x200> @ imm = #0xe
;                 Udma_rmFreeMappedRing(ringHandleInt->ringNum, drvHandleInt, ringHandleInt->mappedRingGrp, ringHandleInt->mappedChNum);
7009f4a0: 9b0b         	ldr	r3, [sp, #0x2c]
7009f4a2: 8898         	ldrh	r0, [r3, #0x4]
7009f4a4: 990c         	ldr	r1, [sp, #0x30]
7009f4a6: 6dda         	ldr	r2, [r3, #0x5c]
7009f4a8: 6e1b         	ldr	r3, [r3, #0x60]
7009f4aa: f00a fc89    	bl	0x700a9dc0 <Udma_rmFreeMappedRing> @ imm = #0xa912
7009f4ae: e7ff         	b	0x7009f4b0 <Udma_ringAlloc+0x200> @ imm = #-0x2
;         }
7009f4b0: e7ff         	b	0x7009f4b2 <Udma_ringAlloc+0x202> @ imm = #-0x2
7009f4b2: e7ff         	b	0x7009f4b4 <Udma_ringAlloc+0x204> @ imm = #-0x2
;     return (retVal);
7009f4b4: 9811         	ldr	r0, [sp, #0x44]
7009f4b6: b016         	add	sp, #0x58
7009f4b8: bd80         	pop	{r7, pc}
7009f4ba: 0000         	movs	r0, r0
7009f4bc: 0000         	movs	r0, r0
7009f4be: 0000         	movs	r0, r0

7009f4c0 <Udma_chDisableBlkCpyChan>:
; {
7009f4c0: b580         	push	{r7, lr}
7009f4c2: b090         	sub	sp, #0x40
7009f4c4: 900f         	str	r0, [sp, #0x3c]
7009f4c6: 910e         	str	r1, [sp, #0x38]
7009f4c8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f4ca: 900d         	str	r0, [sp, #0x34]
;     uint32_t            currTimeout = 0U;
7009f4cc: 900c         	str	r0, [sp, #0x30]
;     drvHandle = chHandle->drvHandle;
7009f4ce: 980f         	ldr	r0, [sp, #0x3c]
7009f4d0: 6e80         	ldr	r0, [r0, #0x68]
7009f4d2: 900b         	str	r0, [sp, #0x2c]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f4d4: 980b         	ldr	r0, [sp, #0x2c]
7009f4d6: 6800         	ldr	r0, [r0]
7009f4d8: 2801         	cmp	r0, #0x1
7009f4da: d10a         	bne	0x7009f4f2 <Udma_chDisableBlkCpyChan+0x32> @ imm = #0x14
7009f4dc: e7ff         	b	0x7009f4de <Udma_chDisableBlkCpyChan+0x1e> @ imm = #-0x2
;                  &drvHandle->bcdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009f4de: 980b         	ldr	r0, [sp, #0x2c]
7009f4e0: 3008         	adds	r0, #0x8
7009f4e2: 990f         	ldr	r1, [sp, #0x3c]
7009f4e4: 6ec9         	ldr	r1, [r1, #0x6c]
7009f4e6: 2300         	movs	r3, #0x0
;         retVal = CSL_bcdmaTeardownTxChan(
7009f4e8: 461a         	mov	r2, r3
7009f4ea: f00e f969    	bl	0x700ad7c0 <CSL_bcdmaTeardownTxChan> @ imm = #0xe2d2
7009f4ee: 900d         	str	r0, [sp, #0x34]
;     }
7009f4f0: e00f         	b	0x7009f512 <Udma_chDisableBlkCpyChan+0x52> @ imm = #0x1e
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f4f2: 980b         	ldr	r0, [sp, #0x2c]
7009f4f4: 6800         	ldr	r0, [r0]
7009f4f6: 2802         	cmp	r0, #0x2
7009f4f8: d10a         	bne	0x7009f510 <Udma_chDisableBlkCpyChan+0x50> @ imm = #0x14
7009f4fa: e7ff         	b	0x7009f4fc <Udma_chDisableBlkCpyChan+0x3c> @ imm = #-0x2
;                  &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009f4fc: 980b         	ldr	r0, [sp, #0x2c]
7009f4fe: 3054         	adds	r0, #0x54
7009f500: 990f         	ldr	r1, [sp, #0x3c]
7009f502: 6ec9         	ldr	r1, [r1, #0x6c]
7009f504: 2300         	movs	r3, #0x0
;         retVal = CSL_pktdmaTeardownTxChan(
7009f506: 461a         	mov	r2, r3
7009f508: f00f f802    	bl	0x700ae510 <CSL_pktdmaTeardownTxChan> @ imm = #0xf004
7009f50c: 900d         	str	r0, [sp, #0x34]
;     }
7009f50e: e7ff         	b	0x7009f510 <Udma_chDisableBlkCpyChan+0x50> @ imm = #-0x2
7009f510: e7ff         	b	0x7009f512 <Udma_chDisableBlkCpyChan+0x52> @ imm = #-0x2
;     if(CSL_PASS != retVal)
7009f512: 980d         	ldr	r0, [sp, #0x34]
7009f514: b108         	cbz	r0, 0x7009f51a <Udma_chDisableBlkCpyChan+0x5a> @ imm = #0x2
7009f516: e7ff         	b	0x7009f518 <Udma_chDisableBlkCpyChan+0x58> @ imm = #-0x2
;     }
7009f518: e7ff         	b	0x7009f51a <Udma_chDisableBlkCpyChan+0x5a> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009f51a: e7ff         	b	0x7009f51c <Udma_chDisableBlkCpyChan+0x5c> @ imm = #-0x2
7009f51c: 980d         	ldr	r0, [sp, #0x34]
7009f51e: bba8         	cbnz	r0, 0x7009f58c <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x6a
7009f520: e7ff         	b	0x7009f522 <Udma_chDisableBlkCpyChan+0x62> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f522: 980b         	ldr	r0, [sp, #0x2c]
7009f524: 6800         	ldr	r0, [r0]
7009f526: 2801         	cmp	r0, #0x1
7009f528: d10c         	bne	0x7009f544 <Udma_chDisableBlkCpyChan+0x84> @ imm = #0x18
7009f52a: e7ff         	b	0x7009f52c <Udma_chDisableBlkCpyChan+0x6c> @ imm = #-0x2
;             (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009f52c: 980b         	ldr	r0, [sp, #0x2c]
7009f52e: 3008         	adds	r0, #0x8
7009f530: 990f         	ldr	r1, [sp, #0x3c]
7009f532: 6ec9         	ldr	r1, [r1, #0x6c]
7009f534: aa05         	add	r2, sp, #0x14
7009f536: f00f fae3    	bl	0x700aeb00 <CSL_bcdmaGetTxRT> @ imm = #0xf5c6
;             if(FALSE == bcdmaRtStatus.enable)
7009f53a: 9805         	ldr	r0, [sp, #0x14]
7009f53c: b908         	cbnz	r0, 0x7009f542 <Udma_chDisableBlkCpyChan+0x82> @ imm = #0x2
7009f53e: e7ff         	b	0x7009f540 <Udma_chDisableBlkCpyChan+0x80> @ imm = #-0x2
;                 break;
7009f540: e024         	b	0x7009f58c <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x48
;         }
7009f542: e011         	b	0x7009f568 <Udma_chDisableBlkCpyChan+0xa8> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f544: 980b         	ldr	r0, [sp, #0x2c]
7009f546: 6800         	ldr	r0, [r0]
7009f548: 2802         	cmp	r0, #0x2
7009f54a: d10c         	bne	0x7009f566 <Udma_chDisableBlkCpyChan+0xa6> @ imm = #0x18
7009f54c: e7ff         	b	0x7009f54e <Udma_chDisableBlkCpyChan+0x8e> @ imm = #-0x2
;             (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009f54e: 980b         	ldr	r0, [sp, #0x2c]
7009f550: 3054         	adds	r0, #0x54
7009f552: 990f         	ldr	r1, [sp, #0x3c]
7009f554: 6ec9         	ldr	r1, [r1, #0x6c]
7009f556: 466a         	mov	r2, sp
7009f558: f00d ff82    	bl	0x700ad460 <CSL_pktdmaGetTxRT> @ imm = #0xdf04
;             if(FALSE == pktdmaRtStatus.enable)
7009f55c: 9800         	ldr	r0, [sp]
7009f55e: b908         	cbnz	r0, 0x7009f564 <Udma_chDisableBlkCpyChan+0xa4> @ imm = #0x2
7009f560: e7ff         	b	0x7009f562 <Udma_chDisableBlkCpyChan+0xa2> @ imm = #-0x2
;                 break;
7009f562: e013         	b	0x7009f58c <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x26
;         }
7009f564: e7ff         	b	0x7009f566 <Udma_chDisableBlkCpyChan+0xa6> @ imm = #-0x2
7009f566: e7ff         	b	0x7009f568 <Udma_chDisableBlkCpyChan+0xa8> @ imm = #-0x2
;         if(currTimeout > timeout)
7009f568: 980c         	ldr	r0, [sp, #0x30]
7009f56a: 990e         	ldr	r1, [sp, #0x38]
7009f56c: 4288         	cmp	r0, r1
7009f56e: d904         	bls	0x7009f57a <Udma_chDisableBlkCpyChan+0xba> @ imm = #0x8
7009f570: e7ff         	b	0x7009f572 <Udma_chDisableBlkCpyChan+0xb2> @ imm = #-0x2
7009f572: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009f576: 900d         	str	r0, [sp, #0x34]
;         }
7009f578: e007         	b	0x7009f58a <Udma_chDisableBlkCpyChan+0xca> @ imm = #0xe
7009f57a: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009f57e: f00b fe07    	bl	0x700ab190 <ClockP_usleep> @ imm = #0xbc0e
;             currTimeout++;
7009f582: 980c         	ldr	r0, [sp, #0x30]
7009f584: 3001         	adds	r0, #0x1
7009f586: 900c         	str	r0, [sp, #0x30]
7009f588: e7ff         	b	0x7009f58a <Udma_chDisableBlkCpyChan+0xca> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009f58a: e7c7         	b	0x7009f51c <Udma_chDisableBlkCpyChan+0x5c> @ imm = #-0x72
;     if(UDMA_SOK != retVal)
7009f58c: 980d         	ldr	r0, [sp, #0x34]
7009f58e: 2800         	cmp	r0, #0x0
7009f590: d05f         	beq	0x7009f652 <Udma_chDisableBlkCpyChan+0x192> @ imm = #0xbe
7009f592: e7ff         	b	0x7009f594 <Udma_chDisableBlkCpyChan+0xd4> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f594: 980b         	ldr	r0, [sp, #0x2c]
7009f596: 6800         	ldr	r0, [r0]
7009f598: 2801         	cmp	r0, #0x1
7009f59a: d10a         	bne	0x7009f5b2 <Udma_chDisableBlkCpyChan+0xf2> @ imm = #0x14
7009f59c: e7ff         	b	0x7009f59e <Udma_chDisableBlkCpyChan+0xde> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009f59e: 980b         	ldr	r0, [sp, #0x2c]
7009f5a0: 3008         	adds	r0, #0x8
7009f5a2: 990f         	ldr	r1, [sp, #0x3c]
7009f5a4: 6ec9         	ldr	r1, [r1, #0x6c]
7009f5a6: 2201         	movs	r2, #0x1
7009f5a8: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownTxChan(
7009f5aa: f00e f909    	bl	0x700ad7c0 <CSL_bcdmaTeardownTxChan> @ imm = #0xe212
7009f5ae: 900d         	str	r0, [sp, #0x34]
;         }
7009f5b0: e00f         	b	0x7009f5d2 <Udma_chDisableBlkCpyChan+0x112> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f5b2: 980b         	ldr	r0, [sp, #0x2c]
7009f5b4: 6800         	ldr	r0, [r0]
7009f5b6: 2802         	cmp	r0, #0x2
7009f5b8: d10a         	bne	0x7009f5d0 <Udma_chDisableBlkCpyChan+0x110> @ imm = #0x14
7009f5ba: e7ff         	b	0x7009f5bc <Udma_chDisableBlkCpyChan+0xfc> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009f5bc: 980b         	ldr	r0, [sp, #0x2c]
7009f5be: 3054         	adds	r0, #0x54
7009f5c0: 990f         	ldr	r1, [sp, #0x3c]
7009f5c2: 6ec9         	ldr	r1, [r1, #0x6c]
7009f5c4: 2201         	movs	r2, #0x1
7009f5c6: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownTxChan(
7009f5c8: f00e ffa2    	bl	0x700ae510 <CSL_pktdmaTeardownTxChan> @ imm = #0xef44
7009f5cc: 900d         	str	r0, [sp, #0x34]
;         }
7009f5ce: e7ff         	b	0x7009f5d0 <Udma_chDisableBlkCpyChan+0x110> @ imm = #-0x2
7009f5d0: e7ff         	b	0x7009f5d2 <Udma_chDisableBlkCpyChan+0x112> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009f5d2: 980d         	ldr	r0, [sp, #0x34]
7009f5d4: b108         	cbz	r0, 0x7009f5da <Udma_chDisableBlkCpyChan+0x11a> @ imm = #0x2
7009f5d6: e7ff         	b	0x7009f5d8 <Udma_chDisableBlkCpyChan+0x118> @ imm = #-0x2
;         }
7009f5d8: e7ff         	b	0x7009f5da <Udma_chDisableBlkCpyChan+0x11a> @ imm = #-0x2
7009f5da: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009f5dc: 900c         	str	r0, [sp, #0x30]
;         while(UDMA_SOK == retVal)
7009f5de: e7ff         	b	0x7009f5e0 <Udma_chDisableBlkCpyChan+0x120> @ imm = #-0x2
7009f5e0: 980d         	ldr	r0, [sp, #0x34]
7009f5e2: bba8         	cbnz	r0, 0x7009f650 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x6a
7009f5e4: e7ff         	b	0x7009f5e6 <Udma_chDisableBlkCpyChan+0x126> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f5e6: 980b         	ldr	r0, [sp, #0x2c]
7009f5e8: 6800         	ldr	r0, [r0]
7009f5ea: 2801         	cmp	r0, #0x1
7009f5ec: d10c         	bne	0x7009f608 <Udma_chDisableBlkCpyChan+0x148> @ imm = #0x18
7009f5ee: e7ff         	b	0x7009f5f0 <Udma_chDisableBlkCpyChan+0x130> @ imm = #-0x2
;                 (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009f5f0: 980b         	ldr	r0, [sp, #0x2c]
7009f5f2: 3008         	adds	r0, #0x8
7009f5f4: 990f         	ldr	r1, [sp, #0x3c]
7009f5f6: 6ec9         	ldr	r1, [r1, #0x6c]
7009f5f8: aa05         	add	r2, sp, #0x14
7009f5fa: f00f fa81    	bl	0x700aeb00 <CSL_bcdmaGetTxRT> @ imm = #0xf502
;                 if(FALSE == bcdmaRtStatus.enable)
7009f5fe: 9805         	ldr	r0, [sp, #0x14]
7009f600: b908         	cbnz	r0, 0x7009f606 <Udma_chDisableBlkCpyChan+0x146> @ imm = #0x2
7009f602: e7ff         	b	0x7009f604 <Udma_chDisableBlkCpyChan+0x144> @ imm = #-0x2
;                     break;
7009f604: e024         	b	0x7009f650 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x48
;             }
7009f606: e011         	b	0x7009f62c <Udma_chDisableBlkCpyChan+0x16c> @ imm = #0x22
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f608: 980b         	ldr	r0, [sp, #0x2c]
7009f60a: 6800         	ldr	r0, [r0]
7009f60c: 2802         	cmp	r0, #0x2
7009f60e: d10c         	bne	0x7009f62a <Udma_chDisableBlkCpyChan+0x16a> @ imm = #0x18
7009f610: e7ff         	b	0x7009f612 <Udma_chDisableBlkCpyChan+0x152> @ imm = #-0x2
;                 (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009f612: 980b         	ldr	r0, [sp, #0x2c]
7009f614: 3054         	adds	r0, #0x54
7009f616: 990f         	ldr	r1, [sp, #0x3c]
7009f618: 6ec9         	ldr	r1, [r1, #0x6c]
7009f61a: 466a         	mov	r2, sp
7009f61c: f00d ff20    	bl	0x700ad460 <CSL_pktdmaGetTxRT> @ imm = #0xde40
;                 if(FALSE == pktdmaRtStatus.enable)
7009f620: 9800         	ldr	r0, [sp]
7009f622: b908         	cbnz	r0, 0x7009f628 <Udma_chDisableBlkCpyChan+0x168> @ imm = #0x2
7009f624: e7ff         	b	0x7009f626 <Udma_chDisableBlkCpyChan+0x166> @ imm = #-0x2
;                     break;
7009f626: e013         	b	0x7009f650 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x26
;             }
7009f628: e7ff         	b	0x7009f62a <Udma_chDisableBlkCpyChan+0x16a> @ imm = #-0x2
7009f62a: e7ff         	b	0x7009f62c <Udma_chDisableBlkCpyChan+0x16c> @ imm = #-0x2
;             if(currTimeout > timeout)
7009f62c: 980c         	ldr	r0, [sp, #0x30]
7009f62e: 990e         	ldr	r1, [sp, #0x38]
7009f630: 4288         	cmp	r0, r1
7009f632: d904         	bls	0x7009f63e <Udma_chDisableBlkCpyChan+0x17e> @ imm = #0x8
7009f634: e7ff         	b	0x7009f636 <Udma_chDisableBlkCpyChan+0x176> @ imm = #-0x2
7009f636: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009f63a: 900d         	str	r0, [sp, #0x34]
;             }
7009f63c: e007         	b	0x7009f64e <Udma_chDisableBlkCpyChan+0x18e> @ imm = #0xe
7009f63e: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009f642: f00b fda5    	bl	0x700ab190 <ClockP_usleep> @ imm = #0xbb4a
;                 currTimeout++;
7009f646: 980c         	ldr	r0, [sp, #0x30]
7009f648: 3001         	adds	r0, #0x1
7009f64a: 900c         	str	r0, [sp, #0x30]
7009f64c: e7ff         	b	0x7009f64e <Udma_chDisableBlkCpyChan+0x18e> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009f64e: e7c7         	b	0x7009f5e0 <Udma_chDisableBlkCpyChan+0x120> @ imm = #-0x72
;     }
7009f650: e7ff         	b	0x7009f652 <Udma_chDisableBlkCpyChan+0x192> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f652: 980d         	ldr	r0, [sp, #0x34]
7009f654: bb20         	cbnz	r0, 0x7009f6a0 <Udma_chDisableBlkCpyChan+0x1e0> @ imm = #0x48
7009f656: e7ff         	b	0x7009f658 <Udma_chDisableBlkCpyChan+0x198> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f658: 980b         	ldr	r0, [sp, #0x2c]
7009f65a: 6800         	ldr	r0, [r0]
7009f65c: 2801         	cmp	r0, #0x1
7009f65e: d10c         	bne	0x7009f67a <Udma_chDisableBlkCpyChan+0x1ba> @ imm = #0x18
7009f660: e7ff         	b	0x7009f662 <Udma_chDisableBlkCpyChan+0x1a2> @ imm = #-0x2
7009f662: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.enable   = FALSE;
7009f664: 9005         	str	r0, [sp, #0x14]
;             bcdmaRtStatus.teardown = FALSE;
7009f666: 9006         	str	r0, [sp, #0x18]
;             bcdmaRtStatus.forcedTeardown = FALSE;
7009f668: 9009         	str	r0, [sp, #0x24]
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009f66a: 980b         	ldr	r0, [sp, #0x2c]
7009f66c: 3008         	adds	r0, #0x8
7009f66e: 990f         	ldr	r1, [sp, #0x3c]
7009f670: 6ec9         	ldr	r1, [r1, #0x6c]
7009f672: aa05         	add	r2, sp, #0x14
7009f674: f00f fa74    	bl	0x700aeb60 <CSL_bcdmaSetTxRT> @ imm = #0xf4e8
;         }
7009f678: e011         	b	0x7009f69e <Udma_chDisableBlkCpyChan+0x1de> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f67a: 980b         	ldr	r0, [sp, #0x2c]
7009f67c: 6800         	ldr	r0, [r0]
7009f67e: 2802         	cmp	r0, #0x2
7009f680: d10c         	bne	0x7009f69c <Udma_chDisableBlkCpyChan+0x1dc> @ imm = #0x18
7009f682: e7ff         	b	0x7009f684 <Udma_chDisableBlkCpyChan+0x1c4> @ imm = #-0x2
7009f684: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.enable   = FALSE;
7009f686: 9000         	str	r0, [sp]
;             pktdmaRtStatus.teardown = FALSE;
7009f688: 9001         	str	r0, [sp, #0x4]
;             pktdmaRtStatus.forcedTeardown = FALSE;
7009f68a: 9004         	str	r0, [sp, #0x10]
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009f68c: 980b         	ldr	r0, [sp, #0x2c]
7009f68e: 3054         	adds	r0, #0x54
7009f690: 990f         	ldr	r1, [sp, #0x3c]
7009f692: 6ec9         	ldr	r1, [r1, #0x6c]
7009f694: 466a         	mov	r2, sp
7009f696: f00e fc9b    	bl	0x700adfd0 <CSL_pktdmaSetTxRT> @ imm = #0xe936
;         }
7009f69a: e7ff         	b	0x7009f69c <Udma_chDisableBlkCpyChan+0x1dc> @ imm = #-0x2
7009f69c: e7ff         	b	0x7009f69e <Udma_chDisableBlkCpyChan+0x1de> @ imm = #-0x2
;     }
7009f69e: e7ff         	b	0x7009f6a0 <Udma_chDisableBlkCpyChan+0x1e0> @ imm = #-0x2
;     return (retVal);
7009f6a0: 980d         	ldr	r0, [sp, #0x34]
7009f6a2: b010         	add	sp, #0x40
7009f6a4: bd80         	pop	{r7, pc}
		...
7009f6ae: 0000         	movs	r0, r0

7009f6b0 <Udma_flowConfig>:
; {
7009f6b0: b580         	push	{r7, lr}
7009f6b2: b09e         	sub	sp, #0x78
7009f6b4: 901d         	str	r0, [sp, #0x74]
7009f6b6: 911c         	str	r1, [sp, #0x70]
7009f6b8: 921b         	str	r2, [sp, #0x6c]
7009f6ba: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f6bc: 901a         	str	r0, [sp, #0x68]
;     Udma_FlowHandleInt  flowHandleInt = (Udma_FlowHandleInt) flowHandle;
7009f6be: 981d         	ldr	r0, [sp, #0x74]
7009f6c0: 9018         	str	r0, [sp, #0x60]
;     if((NULL_PTR == flowHandleInt) ||
7009f6c2: 9818         	ldr	r0, [sp, #0x60]
7009f6c4: b160         	cbz	r0, 0x7009f6e0 <Udma_flowConfig+0x30> @ imm = #0x18
7009f6c6: e7ff         	b	0x7009f6c8 <Udma_flowConfig+0x18> @ imm = #-0x2
;        (flowHandleInt->flowInitDone != UDMA_INIT_DONE) ||
7009f6c8: 9818         	ldr	r0, [sp, #0x60]
7009f6ca: 68c0         	ldr	r0, [r0, #0xc]
7009f6cc: f64a 31cd    	movw	r1, #0xabcd
7009f6d0: f6ca 31dc    	movt	r1, #0xabdc
7009f6d4: 4288         	cmp	r0, r1
7009f6d6: d103         	bne	0x7009f6e0 <Udma_flowConfig+0x30> @ imm = #0x6
7009f6d8: e7ff         	b	0x7009f6da <Udma_flowConfig+0x2a> @ imm = #-0x2
;        (NULL_PTR == flowPrms))
7009f6da: 981b         	ldr	r0, [sp, #0x6c]
;     if((NULL_PTR == flowHandleInt) ||
7009f6dc: b920         	cbnz	r0, 0x7009f6e8 <Udma_flowConfig+0x38> @ imm = #0x8
7009f6de: e7ff         	b	0x7009f6e0 <Udma_flowConfig+0x30> @ imm = #-0x2
7009f6e0: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009f6e4: 901a         	str	r0, [sp, #0x68]
;     }
7009f6e6: e7ff         	b	0x7009f6e8 <Udma_flowConfig+0x38> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f6e8: 981a         	ldr	r0, [sp, #0x68]
7009f6ea: b9a8         	cbnz	r0, 0x7009f718 <Udma_flowConfig+0x68> @ imm = #0x2a
7009f6ec: e7ff         	b	0x7009f6ee <Udma_flowConfig+0x3e> @ imm = #-0x2
;         drvHandle = flowHandleInt->drvHandle;
7009f6ee: 9818         	ldr	r0, [sp, #0x60]
7009f6f0: 6800         	ldr	r0, [r0]
7009f6f2: 9019         	str	r0, [sp, #0x64]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009f6f4: 9819         	ldr	r0, [sp, #0x64]
7009f6f6: b150         	cbz	r0, 0x7009f70e <Udma_flowConfig+0x5e> @ imm = #0x14
7009f6f8: e7ff         	b	0x7009f6fa <Udma_flowConfig+0x4a> @ imm = #-0x2
7009f6fa: 9819         	ldr	r0, [sp, #0x64]
7009f6fc: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009f700: f64a 31cd    	movw	r1, #0xabcd
7009f704: f6ca 31dc    	movt	r1, #0xabdc
7009f708: 4288         	cmp	r0, r1
7009f70a: d004         	beq	0x7009f716 <Udma_flowConfig+0x66> @ imm = #0x8
7009f70c: e7ff         	b	0x7009f70e <Udma_flowConfig+0x5e> @ imm = #-0x2
7009f70e: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009f712: 901a         	str	r0, [sp, #0x68]
;         }
7009f714: e7ff         	b	0x7009f716 <Udma_flowConfig+0x66> @ imm = #-0x2
;     }
7009f716: e7ff         	b	0x7009f718 <Udma_flowConfig+0x68> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f718: 981a         	ldr	r0, [sp, #0x68]
7009f71a: b958         	cbnz	r0, 0x7009f734 <Udma_flowConfig+0x84> @ imm = #0x16
7009f71c: e7ff         	b	0x7009f71e <Udma_flowConfig+0x6e> @ imm = #-0x2
;         if(flowIdx >= flowHandleInt->flowCnt)
7009f71e: 981c         	ldr	r0, [sp, #0x70]
7009f720: 9918         	ldr	r1, [sp, #0x60]
7009f722: 6889         	ldr	r1, [r1, #0x8]
7009f724: 4288         	cmp	r0, r1
7009f726: d304         	blo	0x7009f732 <Udma_flowConfig+0x82> @ imm = #0x8
7009f728: e7ff         	b	0x7009f72a <Udma_flowConfig+0x7a> @ imm = #-0x2
7009f72a: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
7009f72e: 901a         	str	r0, [sp, #0x68]
;         }
7009f730: e7ff         	b	0x7009f732 <Udma_flowConfig+0x82> @ imm = #-0x2
;     }
7009f732: e7ff         	b	0x7009f734 <Udma_flowConfig+0x84> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f734: 981a         	ldr	r0, [sp, #0x68]
7009f736: 2800         	cmp	r0, #0x0
7009f738: f040 80a3    	bne.w	0x7009f882 <Udma_flowConfig+0x1d2> @ imm = #0x146
7009f73c: e7ff         	b	0x7009f73e <Udma_flowConfig+0x8e> @ imm = #-0x2
7009f73e: f64f 70ff    	movw	r0, #0xffff
7009f742: f2c0 0007    	movt	r0, #0x7
;         rmFlowReq.valid_params          = TISCI_MSG_VALUE_RM_UDMAP_FLOW_EINFO_PRESENT_VALID |
7009f746: 900f         	str	r0, [sp, #0x3c]
;         rmFlowReq.nav_id                = drvHandle->devIdUdma;
7009f748: 9819         	ldr	r0, [sp, #0x64]
7009f74a: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009f74e: f8ad 0040    	strh.w	r0, [sp, #0x40]
;         rmFlowReq.flow_index            = (uint16_t)(flowHandleInt->flowStart + flowIdx);
7009f752: 9818         	ldr	r0, [sp, #0x60]
7009f754: 6840         	ldr	r0, [r0, #0x4]
7009f756: 991c         	ldr	r1, [sp, #0x70]
7009f758: 4408         	add	r0, r1
7009f75a: f8ad 0042    	strh.w	r0, [sp, #0x42]
;         rmFlowReq.rx_einfo_present      = flowPrms->einfoPresent;
7009f75e: 981b         	ldr	r0, [sp, #0x6c]
7009f760: 7900         	ldrb	r0, [r0, #0x4]
7009f762: f88d 0044    	strb.w	r0, [sp, #0x44]
;         rmFlowReq.rx_psinfo_present     = flowPrms->psInfoPresent;
7009f766: 981b         	ldr	r0, [sp, #0x6c]
7009f768: 7940         	ldrb	r0, [r0, #0x5]
7009f76a: f88d 0045    	strb.w	r0, [sp, #0x45]
;         rmFlowReq.rx_error_handling     = flowPrms->errorHandling;
7009f76e: 981b         	ldr	r0, [sp, #0x6c]
7009f770: 7980         	ldrb	r0, [r0, #0x6]
7009f772: f88d 0046    	strb.w	r0, [sp, #0x46]
;         rmFlowReq.rx_desc_type          = flowPrms->descType;
7009f776: 981b         	ldr	r0, [sp, #0x6c]
7009f778: 79c0         	ldrb	r0, [r0, #0x7]
7009f77a: f88d 0047    	strb.w	r0, [sp, #0x47]
;         rmFlowReq.rx_ps_location        = flowPrms->psLocation;
7009f77e: 981b         	ldr	r0, [sp, #0x6c]
7009f780: 7a00         	ldrb	r0, [r0, #0x8]
7009f782: f88d 005c    	strb.w	r0, [sp, #0x5c]
;         rmFlowReq.rx_sop_offset         = flowPrms->sopOffset;
7009f786: 981b         	ldr	r0, [sp, #0x6c]
7009f788: 8940         	ldrh	r0, [r0, #0xa]
7009f78a: f8ad 0048    	strh.w	r0, [sp, #0x48]
;         rmFlowReq.rx_dest_qnum          = flowPrms->defaultRxCQ;
7009f78e: 981b         	ldr	r0, [sp, #0x6c]
7009f790: 8980         	ldrh	r0, [r0, #0xc]
7009f792: f8ad 004a    	strh.w	r0, [sp, #0x4a]
;         rmFlowReq.rx_src_tag_hi         = flowPrms->srcTagHi;
7009f796: 981b         	ldr	r0, [sp, #0x6c]
7009f798: 7b80         	ldrb	r0, [r0, #0xe]
7009f79a: f88d 004c    	strb.w	r0, [sp, #0x4c]
;         rmFlowReq.rx_src_tag_lo         = flowPrms->srcTagLo;
7009f79e: 981b         	ldr	r0, [sp, #0x6c]
7009f7a0: 7bc0         	ldrb	r0, [r0, #0xf]
7009f7a2: f88d 004d    	strb.w	r0, [sp, #0x4d]
;         rmFlowReq.rx_src_tag_hi_sel     = flowPrms->srcTagHiSel;
7009f7a6: 981b         	ldr	r0, [sp, #0x6c]
7009f7a8: 7c00         	ldrb	r0, [r0, #0x10]
7009f7aa: f88d 0050    	strb.w	r0, [sp, #0x50]
;         rmFlowReq.rx_src_tag_lo_sel     = flowPrms->srcTagLoSel;
7009f7ae: 981b         	ldr	r0, [sp, #0x6c]
7009f7b0: 7c40         	ldrb	r0, [r0, #0x11]
7009f7b2: f88d 0051    	strb.w	r0, [sp, #0x51]
;         rmFlowReq.rx_dest_tag_hi        = flowPrms->destTagHi;
7009f7b6: 981b         	ldr	r0, [sp, #0x6c]
7009f7b8: 7c80         	ldrb	r0, [r0, #0x12]
7009f7ba: f88d 004e    	strb.w	r0, [sp, #0x4e]
;         rmFlowReq.rx_dest_tag_lo        = flowPrms->destTagLo;
7009f7be: 981b         	ldr	r0, [sp, #0x6c]
7009f7c0: 7cc0         	ldrb	r0, [r0, #0x13]
7009f7c2: f88d 004f    	strb.w	r0, [sp, #0x4f]
;         rmFlowReq.rx_dest_tag_hi_sel    = flowPrms->destTagHiSel;
7009f7c6: 981b         	ldr	r0, [sp, #0x6c]
7009f7c8: 7d00         	ldrb	r0, [r0, #0x14]
7009f7ca: f88d 0052    	strb.w	r0, [sp, #0x52]
;         rmFlowReq.rx_dest_tag_lo_sel    = flowPrms->destTagLoSel;
7009f7ce: 981b         	ldr	r0, [sp, #0x6c]
7009f7d0: 7d40         	ldrb	r0, [r0, #0x15]
7009f7d2: f88d 0053    	strb.w	r0, [sp, #0x53]
;         rmFlowReq.rx_fdq0_sz0_qnum      = flowPrms->fdq0Sz0Qnum;
7009f7d6: 981b         	ldr	r0, [sp, #0x6c]
7009f7d8: 8b00         	ldrh	r0, [r0, #0x18]
7009f7da: f8ad 0054    	strh.w	r0, [sp, #0x54]
;         rmFlowReq.rx_fdq1_qnum          = flowPrms->fdq1Qnum;
7009f7de: 981b         	ldr	r0, [sp, #0x6c]
7009f7e0: 8b40         	ldrh	r0, [r0, #0x1a]
7009f7e2: f8ad 0056    	strh.w	r0, [sp, #0x56]
;         rmFlowReq.rx_fdq2_qnum          = flowPrms->fdq2Qnum;
7009f7e6: 981b         	ldr	r0, [sp, #0x6c]
7009f7e8: 8b80         	ldrh	r0, [r0, #0x1c]
7009f7ea: f8ad 0058    	strh.w	r0, [sp, #0x58]
;         rmFlowReq.rx_fdq3_qnum          = flowPrms->fdq3Qnum;
7009f7ee: 981b         	ldr	r0, [sp, #0x6c]
7009f7f0: 8bc0         	ldrh	r0, [r0, #0x1e]
7009f7f2: f8ad 005a    	strh.w	r0, [sp, #0x5a]
7009f7f6: a80d         	add	r0, sp, #0x34
7009f7f8: a90b         	add	r1, sp, #0x2c
7009f7fa: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmUdmapFlowCfg(
7009f7fe: f00d f8b7    	bl	0x700ac970 <Sciclient_rmUdmapFlowCfg> @ imm = #0xd16e
7009f802: 901a         	str	r0, [sp, #0x68]
;         if(CSL_PASS != retVal)
7009f804: 981a         	ldr	r0, [sp, #0x68]
7009f806: b108         	cbz	r0, 0x7009f80c <Udma_flowConfig+0x15c> @ imm = #0x2
7009f808: e7ff         	b	0x7009f80a <Udma_flowConfig+0x15a> @ imm = #-0x2
;         }
7009f80a: e7ff         	b	0x7009f80c <Udma_flowConfig+0x15c> @ imm = #-0x2
7009f80c: 207f         	movs	r0, #0x7f
;         rmOptFlowReq.valid_params       = TISCI_MSG_VALUE_RM_UDMAP_FLOW_SIZE_THRESH0_VALID |
7009f80e: 9005         	str	r0, [sp, #0x14]
;         rmOptFlowReq.nav_id             = drvHandle->devIdUdma;
7009f810: 9819         	ldr	r0, [sp, #0x64]
7009f812: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009f816: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         rmOptFlowReq.flow_index         = (uint16_t)(flowHandleInt->flowStart + flowIdx);
7009f81a: 9818         	ldr	r0, [sp, #0x60]
7009f81c: 6840         	ldr	r0, [r0, #0x4]
7009f81e: 991c         	ldr	r1, [sp, #0x70]
7009f820: 4408         	add	r0, r1
7009f822: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         rmOptFlowReq.rx_size_thresh0    = (flowPrms->sizeThresh0 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009f826: 981b         	ldr	r0, [sp, #0x6c]
7009f828: 8c00         	ldrh	r0, [r0, #0x20]
7009f82a: 0940         	lsrs	r0, r0, #0x5
7009f82c: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         rmOptFlowReq.rx_size_thresh1    = (flowPrms->sizeThresh1 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009f830: 981b         	ldr	r0, [sp, #0x6c]
7009f832: 8c40         	ldrh	r0, [r0, #0x22]
7009f834: 0940         	lsrs	r0, r0, #0x5
7009f836: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmOptFlowReq.rx_size_thresh2    = (flowPrms->sizeThresh2 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009f83a: 981b         	ldr	r0, [sp, #0x6c]
7009f83c: 8c80         	ldrh	r0, [r0, #0x24]
7009f83e: 0940         	lsrs	r0, r0, #0x5
7009f840: f8ad 0020    	strh.w	r0, [sp, #0x20]
;         rmOptFlowReq.rx_fdq0_sz1_qnum   = flowPrms->fdq0Sz1Qnum;
7009f844: 981b         	ldr	r0, [sp, #0x6c]
7009f846: 8cc0         	ldrh	r0, [r0, #0x26]
7009f848: f8ad 0022    	strh.w	r0, [sp, #0x22]
;         rmOptFlowReq.rx_fdq0_sz2_qnum   = flowPrms->fdq0Sz2Qnum;
7009f84c: 981b         	ldr	r0, [sp, #0x6c]
7009f84e: 8d00         	ldrh	r0, [r0, #0x28]
7009f850: f8ad 0024    	strh.w	r0, [sp, #0x24]
;         rmOptFlowReq.rx_fdq0_sz3_qnum   = flowPrms->fdq0Sz3Qnum;
7009f854: 981b         	ldr	r0, [sp, #0x6c]
7009f856: 8d40         	ldrh	r0, [r0, #0x2a]
7009f858: f8ad 0026    	strh.w	r0, [sp, #0x26]
;         rmOptFlowReq.rx_size_thresh_en  = flowPrms->sizeThreshEn;
7009f85c: 981b         	ldr	r0, [sp, #0x6c]
7009f85e: 7d80         	ldrb	r0, [r0, #0x16]
7009f860: f88d 0028    	strb.w	r0, [sp, #0x28]
7009f864: a803         	add	r0, sp, #0xc
7009f866: a901         	add	r1, sp, #0x4
7009f868: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal += Sciclient_rmUdmapFlowSizeThreshCfg(
7009f86c: f00d f8b0    	bl	0x700ac9d0 <Sciclient_rmUdmapFlowSizeThreshCfg> @ imm = #0xd160
7009f870: 4601         	mov	r1, r0
7009f872: 981a         	ldr	r0, [sp, #0x68]
7009f874: 4408         	add	r0, r1
7009f876: 901a         	str	r0, [sp, #0x68]
;         if(CSL_PASS != retVal)
7009f878: 981a         	ldr	r0, [sp, #0x68]
7009f87a: b108         	cbz	r0, 0x7009f880 <Udma_flowConfig+0x1d0> @ imm = #0x2
7009f87c: e7ff         	b	0x7009f87e <Udma_flowConfig+0x1ce> @ imm = #-0x2
;         }
7009f87e: e7ff         	b	0x7009f880 <Udma_flowConfig+0x1d0> @ imm = #-0x2
;     }
7009f880: e7ff         	b	0x7009f882 <Udma_flowConfig+0x1d2> @ imm = #-0x2
;     return (retVal);
7009f882: 981a         	ldr	r0, [sp, #0x68]
7009f884: b01e         	add	sp, #0x78
7009f886: bd80         	pop	{r7, pc}

7009f888 <__udivsi3>:
7009f888: e3510001     	cmp	r1, #1
7009f88c: 3a00000b     	blo	0x7009f8c0 <__udivsi3+0x38> @ imm = #0x2c
7009f890: 012fff1e     	bxeq	lr
7009f894: e1500001     	cmp	r0, r1
7009f898: 33a00000     	movlo	r0, #0
7009f89c: 312fff1e     	bxlo	lr
7009f8a0: e16fcf10     	clz	r12, r0
7009f8a4: e16f3f11     	clz	r3, r1
7009f8a8: e043300c     	sub	r3, r3, r12
7009f8ac: e28fce19     	add	r12, pc, #400
7009f8b0: e04cc103     	sub	r12, r12, r3, lsl #2
7009f8b4: e04cc183     	sub	r12, r12, r3, lsl #3
7009f8b8: e3a03000     	mov	r3, #0
7009f8bc: e12fff1c     	bx	r12
7009f8c0: e3b00000     	movs	r0, #0
7009f8c4: e92d4080     	push	{r7, lr}
7009f8c8: eb004128     	bl	0x700afd70 <__aeabi_idiv0> @ imm = #0x104a0
7009f8cc: e8bd8080     	pop	{r7, pc}
7009f8d0: e1500f81     	cmp	r0, r1, lsl #31
7009f8d4: 22833102     	addhs	r3, r3, #-2147483648
7009f8d8: 20400f81     	subhs	r0, r0, r1, lsl #31
7009f8dc: e1500f01     	cmp	r0, r1, lsl #30
7009f8e0: 22833101     	addhs	r3, r3, #1073741824
7009f8e4: 20400f01     	subhs	r0, r0, r1, lsl #30
7009f8e8: e1500e81     	cmp	r0, r1, lsl #29
7009f8ec: 22833202     	addhs	r3, r3, #536870912
7009f8f0: 20400e81     	subhs	r0, r0, r1, lsl #29
7009f8f4: e1500e01     	cmp	r0, r1, lsl #28
7009f8f8: 22833201     	addhs	r3, r3, #268435456
7009f8fc: 20400e01     	subhs	r0, r0, r1, lsl #28
7009f900: e1500d81     	cmp	r0, r1, lsl #27
7009f904: 22833302     	addhs	r3, r3, #134217728
7009f908: 20400d81     	subhs	r0, r0, r1, lsl #27
7009f90c: e1500d01     	cmp	r0, r1, lsl #26
7009f910: 22833301     	addhs	r3, r3, #67108864
7009f914: 20400d01     	subhs	r0, r0, r1, lsl #26
7009f918: e1500c81     	cmp	r0, r1, lsl #25
7009f91c: 22833402     	addhs	r3, r3, #33554432
7009f920: 20400c81     	subhs	r0, r0, r1, lsl #25
7009f924: e1500c01     	cmp	r0, r1, lsl #24
7009f928: 22833401     	addhs	r3, r3, #16777216
7009f92c: 20400c01     	subhs	r0, r0, r1, lsl #24
7009f930: e1500b81     	cmp	r0, r1, lsl #23
7009f934: 22833502     	addhs	r3, r3, #8388608
7009f938: 20400b81     	subhs	r0, r0, r1, lsl #23
7009f93c: e1500b01     	cmp	r0, r1, lsl #22
7009f940: 22833501     	addhs	r3, r3, #4194304
7009f944: 20400b01     	subhs	r0, r0, r1, lsl #22
7009f948: e1500a81     	cmp	r0, r1, lsl #21
7009f94c: 22833602     	addhs	r3, r3, #2097152
7009f950: 20400a81     	subhs	r0, r0, r1, lsl #21
7009f954: e1500a01     	cmp	r0, r1, lsl #20
7009f958: 22833601     	addhs	r3, r3, #1048576
7009f95c: 20400a01     	subhs	r0, r0, r1, lsl #20
7009f960: e1500981     	cmp	r0, r1, lsl #19
7009f964: 22833702     	addhs	r3, r3, #524288
7009f968: 20400981     	subhs	r0, r0, r1, lsl #19
7009f96c: e1500901     	cmp	r0, r1, lsl #18
7009f970: 22833701     	addhs	r3, r3, #262144
7009f974: 20400901     	subhs	r0, r0, r1, lsl #18
7009f978: e1500881     	cmp	r0, r1, lsl #17
7009f97c: 22833802     	addhs	r3, r3, #131072
7009f980: 20400881     	subhs	r0, r0, r1, lsl #17
7009f984: e1500801     	cmp	r0, r1, lsl #16
7009f988: 22833801     	addhs	r3, r3, #65536
7009f98c: 20400801     	subhs	r0, r0, r1, lsl #16
7009f990: e1500781     	cmp	r0, r1, lsl #15
7009f994: 22833902     	addhs	r3, r3, #32768
7009f998: 20400781     	subhs	r0, r0, r1, lsl #15
7009f99c: e1500701     	cmp	r0, r1, lsl #14
7009f9a0: 22833901     	addhs	r3, r3, #16384
7009f9a4: 20400701     	subhs	r0, r0, r1, lsl #14
7009f9a8: e1500681     	cmp	r0, r1, lsl #13
7009f9ac: 22833a02     	addhs	r3, r3, #8192
7009f9b0: 20400681     	subhs	r0, r0, r1, lsl #13
7009f9b4: e1500601     	cmp	r0, r1, lsl #12
7009f9b8: 22833a01     	addhs	r3, r3, #4096
7009f9bc: 20400601     	subhs	r0, r0, r1, lsl #12
7009f9c0: e1500581     	cmp	r0, r1, lsl #11
7009f9c4: 22833b02     	addhs	r3, r3, #2048
7009f9c8: 20400581     	subhs	r0, r0, r1, lsl #11
7009f9cc: e1500501     	cmp	r0, r1, lsl #10
7009f9d0: 22833b01     	addhs	r3, r3, #1024
7009f9d4: 20400501     	subhs	r0, r0, r1, lsl #10
7009f9d8: e1500481     	cmp	r0, r1, lsl #9
7009f9dc: 22833c02     	addhs	r3, r3, #512
7009f9e0: 20400481     	subhs	r0, r0, r1, lsl #9
7009f9e4: e1500401     	cmp	r0, r1, lsl #8
7009f9e8: 22833c01     	addhs	r3, r3, #256
7009f9ec: 20400401     	subhs	r0, r0, r1, lsl #8
7009f9f0: e1500381     	cmp	r0, r1, lsl #7
7009f9f4: 22833080     	addhs	r3, r3, #128
7009f9f8: 20400381     	subhs	r0, r0, r1, lsl #7
7009f9fc: e1500301     	cmp	r0, r1, lsl #6
7009fa00: 22833040     	addhs	r3, r3, #64
7009fa04: 20400301     	subhs	r0, r0, r1, lsl #6
7009fa08: e1500281     	cmp	r0, r1, lsl #5
7009fa0c: 22833020     	addhs	r3, r3, #32
7009fa10: 20400281     	subhs	r0, r0, r1, lsl #5
7009fa14: e1500201     	cmp	r0, r1, lsl #4
7009fa18: 22833010     	addhs	r3, r3, #16
7009fa1c: 20400201     	subhs	r0, r0, r1, lsl #4
7009fa20: e1500181     	cmp	r0, r1, lsl #3
7009fa24: 22833008     	addhs	r3, r3, #8
7009fa28: 20400181     	subhs	r0, r0, r1, lsl #3
7009fa2c: e1500101     	cmp	r0, r1, lsl #2
7009fa30: 22833004     	addhs	r3, r3, #4
7009fa34: 20400101     	subhs	r0, r0, r1, lsl #2
7009fa38: e1500081     	cmp	r0, r1, lsl #1
7009fa3c: 22833002     	addhs	r3, r3, #2
7009fa40: 20400081     	subhs	r0, r0, r1, lsl #1
7009fa44: e1500001     	cmp	r0, r1
7009fa48: 22833001     	addhs	r3, r3, #1
7009fa4c: 20400001     	subhs	r0, r0, r1
7009fa50: e1a00003     	mov	r0, r3
7009fa54: e12fff1e     	bx	lr
		...

7009fa60 <SOC_moduleSetClockFrequency>:
; {
7009fa60: b580         	push	{r7, lr}
7009fa62: b090         	sub	sp, #0x40
7009fa64: 900f         	str	r0, [sp, #0x3c]
7009fa66: 910e         	str	r1, [sp, #0x38]
7009fa68: 930d         	str	r3, [sp, #0x34]
7009fa6a: 920c         	str	r2, [sp, #0x30]
7009fa6c: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
7009fa6e: 9002         	str	r0, [sp, #0x8]
7009fa70: 900b         	str	r0, [sp, #0x2c]
;     uint32_t i = 0U;
7009fa72: 900a         	str	r0, [sp, #0x28]
;     uint64_t respClkRate = 0;
7009fa74: 9009         	str	r0, [sp, #0x24]
7009fa76: 9008         	str	r0, [sp, #0x20]
;     uint32_t numParents = 0U;
7009fa78: 9007         	str	r0, [sp, #0x1c]
;     uint32_t moduleClockParentChanged = 0U;
7009fa7a: 9006         	str	r0, [sp, #0x18]
;     uint32_t clockStatus = 0U;
7009fa7c: 9005         	str	r0, [sp, #0x14]
;     uint32_t origParent = 0U;
7009fa7e: 9004         	str	r0, [sp, #0x10]
;     uint32_t foundParent = 0U;
7009fa80: 9003         	str	r0, [sp, #0xc]
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009fa82: 980f         	ldr	r0, [sp, #0x3c]
;                                             clkId,
7009fa84: 990e         	ldr	r1, [sp, #0x38]
7009fa86: aa05         	add	r2, sp, #0x14
7009fa88: f04f 33ff    	mov.w	r3, #0xffffffff
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009fa8c: f009 fc98    	bl	0x700a93c0 <Sciclient_pmModuleGetClkStatus> @ imm = #0x9930
7009fa90: 900b         	str	r0, [sp, #0x2c]
;     if (status == SystemP_SUCCESS)
7009fa92: 980b         	ldr	r0, [sp, #0x2c]
7009fa94: b948         	cbnz	r0, 0x7009faaa <SOC_moduleSetClockFrequency+0x4a> @ imm = #0x12
7009fa96: e7ff         	b	0x7009fa98 <SOC_moduleSetClockFrequency+0x38> @ imm = #-0x2
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009fa98: 980f         	ldr	r0, [sp, #0x3c]
;                                                    clkId,
7009fa9a: 990e         	ldr	r1, [sp, #0x38]
7009fa9c: aa07         	add	r2, sp, #0x1c
7009fa9e: f04f 33ff    	mov.w	r3, #0xffffffff
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009faa2: f008 fd6d    	bl	0x700a8580 <Sciclient_pmGetModuleClkNumParent> @ imm = #0x8ada
7009faa6: 900b         	str	r0, [sp, #0x2c]
;     }
7009faa8: e7ff         	b	0x7009faaa <SOC_moduleSetClockFrequency+0x4a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009faaa: 980b         	ldr	r0, [sp, #0x2c]
7009faac: b970         	cbnz	r0, 0x7009facc <SOC_moduleSetClockFrequency+0x6c> @ imm = #0x1c
7009faae: e7ff         	b	0x7009fab0 <SOC_moduleSetClockFrequency+0x50> @ imm = #-0x2
;         if(numParents > 1U)
7009fab0: 9807         	ldr	r0, [sp, #0x1c]
7009fab2: 2802         	cmp	r0, #0x2
7009fab4: d309         	blo	0x7009faca <SOC_moduleSetClockFrequency+0x6a> @ imm = #0x12
7009fab6: e7ff         	b	0x7009fab8 <SOC_moduleSetClockFrequency+0x58> @ imm = #-0x2
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009fab8: 980f         	ldr	r0, [sp, #0x3c]
;                                                     clkId,
7009faba: 990e         	ldr	r1, [sp, #0x38]
7009fabc: aa04         	add	r2, sp, #0x10
7009fabe: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009fac2: f009 fa9d    	bl	0x700a9000 <Sciclient_pmGetModuleClkParent> @ imm = #0x953a
7009fac6: 900b         	str	r0, [sp, #0x2c]
;         }
7009fac8: e7ff         	b	0x7009faca <SOC_moduleSetClockFrequency+0x6a> @ imm = #-0x2
;     }
7009faca: e7ff         	b	0x7009facc <SOC_moduleSetClockFrequency+0x6c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009facc: 980b         	ldr	r0, [sp, #0x2c]
7009face: b960         	cbnz	r0, 0x7009faea <SOC_moduleSetClockFrequency+0x8a> @ imm = #0x18
7009fad0: e7ff         	b	0x7009fad2 <SOC_moduleSetClockFrequency+0x72> @ imm = #-0x2
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009fad2: 980f         	ldr	r0, [sp, #0x3c]
;                                               clkId,
7009fad4: 990e         	ldr	r1, [sp, #0x38]
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009fad6: 466b         	mov	r3, sp
7009fad8: f04f 32ff    	mov.w	r2, #0xffffffff
7009fadc: 601a         	str	r2, [r3]
7009fade: 2300         	movs	r3, #0x0
7009fae0: 461a         	mov	r2, r3
7009fae2: f00a fa45    	bl	0x700a9f70 <Sciclient_pmModuleClkRequest> @ imm = #0xa48a
7009fae6: 900b         	str	r0, [sp, #0x2c]
;     }
7009fae8: e7ff         	b	0x7009faea <SOC_moduleSetClockFrequency+0x8a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009faea: 980b         	ldr	r0, [sp, #0x2c]
7009faec: 2800         	cmp	r0, #0x0
7009faee: d14d         	bne	0x7009fb8c <SOC_moduleSetClockFrequency+0x12c> @ imm = #0x9a
7009faf0: e7ff         	b	0x7009faf2 <SOC_moduleSetClockFrequency+0x92> @ imm = #-0x2
7009faf2: 2000         	movs	r0, #0x0
;         foundParent = 0U;
7009faf4: 9003         	str	r0, [sp, #0xc]
;         for(i=0U;i<numParents;i++)
7009faf6: 900a         	str	r0, [sp, #0x28]
7009faf8: e7ff         	b	0x7009fafa <SOC_moduleSetClockFrequency+0x9a> @ imm = #-0x2
7009fafa: 980a         	ldr	r0, [sp, #0x28]
7009fafc: 9907         	ldr	r1, [sp, #0x1c]
7009fafe: 4288         	cmp	r0, r1
7009fb00: d243         	bhs	0x7009fb8a <SOC_moduleSetClockFrequency+0x12a> @ imm = #0x86
7009fb02: e7ff         	b	0x7009fb04 <SOC_moduleSetClockFrequency+0xa4> @ imm = #-0x2
;             if (numParents > 1U)
7009fb04: 9807         	ldr	r0, [sp, #0x1c]
7009fb06: 2802         	cmp	r0, #0x2
7009fb08: d311         	blo	0x7009fb2e <SOC_moduleSetClockFrequency+0xce> @ imm = #0x22
7009fb0a: e7ff         	b	0x7009fb0c <SOC_moduleSetClockFrequency+0xac> @ imm = #-0x2
;                 status = Sciclient_pmSetModuleClkParent(moduleId,
7009fb0c: 980f         	ldr	r0, [sp, #0x3c]
;                                                         clkId,
7009fb0e: 990e         	ldr	r1, [sp, #0x38]
;                                                         clkId+i+1,
7009fb10: 9a0a         	ldr	r2, [sp, #0x28]
7009fb12: 440a         	add	r2, r1
7009fb14: 3201         	adds	r2, #0x1
7009fb16: f04f 33ff    	mov.w	r3, #0xffffffff
;                 status = Sciclient_pmSetModuleClkParent(moduleId,
7009fb1a: f009 fac1    	bl	0x700a90a0 <Sciclient_pmSetModuleClkParent> @ imm = #0x9582
7009fb1e: 900b         	str	r0, [sp, #0x2c]
;                 if (status == SystemP_SUCCESS)
7009fb20: 980b         	ldr	r0, [sp, #0x2c]
7009fb22: b918         	cbnz	r0, 0x7009fb2c <SOC_moduleSetClockFrequency+0xcc> @ imm = #0x6
7009fb24: e7ff         	b	0x7009fb26 <SOC_moduleSetClockFrequency+0xc6> @ imm = #-0x2
7009fb26: 2001         	movs	r0, #0x1
;                     moduleClockParentChanged = 1U;
7009fb28: 9006         	str	r0, [sp, #0x18]
;                 }
7009fb2a: e7ff         	b	0x7009fb2c <SOC_moduleSetClockFrequency+0xcc> @ imm = #-0x2
;             }
7009fb2c: e7ff         	b	0x7009fb2e <SOC_moduleSetClockFrequency+0xce> @ imm = #-0x2
;             if (status == SystemP_SUCCESS)
7009fb2e: 980b         	ldr	r0, [sp, #0x2c]
7009fb30: b988         	cbnz	r0, 0x7009fb56 <SOC_moduleSetClockFrequency+0xf6> @ imm = #0x22
7009fb32: e7ff         	b	0x7009fb34 <SOC_moduleSetClockFrequency+0xd4> @ imm = #-0x2
;                 status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009fb34: 980f         	ldr	r0, [sp, #0x3c]
;                                                         clkId,
7009fb36: 990e         	ldr	r1, [sp, #0x38]
;                                                         clkRate,
7009fb38: 9a0c         	ldr	r2, [sp, #0x30]
7009fb3a: 9b0d         	ldr	r3, [sp, #0x34]
;                 status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009fb3c: 46ee         	mov	lr, sp
7009fb3e: f04f 3cff    	mov.w	r12, #0xffffffff
7009fb42: f8ce c004    	str.w	r12, [lr, #0x4]
7009fb46: f10d 0c20    	add.w	r12, sp, #0x20
7009fb4a: f8ce c000    	str.w	r12, [lr]
7009fb4e: f003 fd07    	bl	0x700a3560 <Sciclient_pmQueryModuleClkFreq> @ imm = #0x3a0e
7009fb52: 900b         	str	r0, [sp, #0x2c]
;             }
7009fb54: e7ff         	b	0x7009fb56 <SOC_moduleSetClockFrequency+0xf6> @ imm = #-0x2
;             if (status == SystemP_SUCCESS)
7009fb56: 980b         	ldr	r0, [sp, #0x2c]
7009fb58: b970         	cbnz	r0, 0x7009fb78 <SOC_moduleSetClockFrequency+0x118> @ imm = #0x1c
7009fb5a: e7ff         	b	0x7009fb5c <SOC_moduleSetClockFrequency+0xfc> @ imm = #-0x2
;                 if(respClkRate == clkRate)
7009fb5c: 9808         	ldr	r0, [sp, #0x20]
7009fb5e: 9909         	ldr	r1, [sp, #0x24]
7009fb60: 9a0c         	ldr	r2, [sp, #0x30]
7009fb62: 9b0d         	ldr	r3, [sp, #0x34]
7009fb64: 4059         	eors	r1, r3
7009fb66: ea80 0002    	eor.w	r0, r0, r2
7009fb6a: 4308         	orrs	r0, r1
7009fb6c: b918         	cbnz	r0, 0x7009fb76 <SOC_moduleSetClockFrequency+0x116> @ imm = #0x6
7009fb6e: e7ff         	b	0x7009fb70 <SOC_moduleSetClockFrequency+0x110> @ imm = #-0x2
7009fb70: 2001         	movs	r0, #0x1
;                     foundParent = 1U;
7009fb72: 9003         	str	r0, [sp, #0xc]
;                 }
7009fb74: e7ff         	b	0x7009fb76 <SOC_moduleSetClockFrequency+0x116> @ imm = #-0x2
;             }
7009fb76: e7ff         	b	0x7009fb78 <SOC_moduleSetClockFrequency+0x118> @ imm = #-0x2
;             if(foundParent)
7009fb78: 9803         	ldr	r0, [sp, #0xc]
7009fb7a: b108         	cbz	r0, 0x7009fb80 <SOC_moduleSetClockFrequency+0x120> @ imm = #0x2
7009fb7c: e7ff         	b	0x7009fb7e <SOC_moduleSetClockFrequency+0x11e> @ imm = #-0x2
;                 break; /* found a parent to set clock frequency, rebak form the loop */
7009fb7e: e004         	b	0x7009fb8a <SOC_moduleSetClockFrequency+0x12a> @ imm = #0x8
;         }
7009fb80: e7ff         	b	0x7009fb82 <SOC_moduleSetClockFrequency+0x122> @ imm = #-0x2
;         for(i=0U;i<numParents;i++)
7009fb82: 980a         	ldr	r0, [sp, #0x28]
7009fb84: 3001         	adds	r0, #0x1
7009fb86: 900a         	str	r0, [sp, #0x28]
7009fb88: e7b7         	b	0x7009fafa <SOC_moduleSetClockFrequency+0x9a> @ imm = #-0x92
;     }
7009fb8a: e7ff         	b	0x7009fb8c <SOC_moduleSetClockFrequency+0x12c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fb8c: 980b         	ldr	r0, [sp, #0x2c]
7009fb8e: b9d0         	cbnz	r0, 0x7009fbc6 <SOC_moduleSetClockFrequency+0x166> @ imm = #0x34
7009fb90: e7ff         	b	0x7009fb92 <SOC_moduleSetClockFrequency+0x132> @ imm = #-0x2
;         if(foundParent == 1U)
7009fb92: 9803         	ldr	r0, [sp, #0xc]
7009fb94: 2801         	cmp	r0, #0x1
7009fb96: d111         	bne	0x7009fbbc <SOC_moduleSetClockFrequency+0x15c> @ imm = #0x22
7009fb98: e7ff         	b	0x7009fb9a <SOC_moduleSetClockFrequency+0x13a> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009fb9a: 980f         	ldr	r0, [sp, #0x3c]
;                                                   clkId,
7009fb9c: 990e         	ldr	r1, [sp, #0x38]
;                                                   clkRate,
7009fb9e: 9a0c         	ldr	r2, [sp, #0x30]
7009fba0: 9b0d         	ldr	r3, [sp, #0x34]
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009fba2: 46ee         	mov	lr, sp
7009fba4: f04f 3cff    	mov.w	r12, #0xffffffff
7009fba8: f8ce c004    	str.w	r12, [lr, #0x4]
7009fbac: f44f 7c00    	mov.w	r12, #0x200
7009fbb0: f8ce c000    	str.w	r12, [lr]
7009fbb4: f005 f98c    	bl	0x700a4ed0 <Sciclient_pmSetModuleClkFreq> @ imm = #0x5318
7009fbb8: 900b         	str	r0, [sp, #0x2c]
;         }
7009fbba: e003         	b	0x7009fbc4 <SOC_moduleSetClockFrequency+0x164> @ imm = #0x6
7009fbbc: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009fbc0: 900b         	str	r0, [sp, #0x2c]
7009fbc2: e7ff         	b	0x7009fbc4 <SOC_moduleSetClockFrequency+0x164> @ imm = #-0x2
;     }
7009fbc4: e7ff         	b	0x7009fbc6 <SOC_moduleSetClockFrequency+0x166> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fbc6: 980b         	ldr	r0, [sp, #0x2c]
7009fbc8: b988         	cbnz	r0, 0x7009fbee <SOC_moduleSetClockFrequency+0x18e> @ imm = #0x22
7009fbca: e7ff         	b	0x7009fbcc <SOC_moduleSetClockFrequency+0x16c> @ imm = #-0x2
;         if (clockStatus == TISCI_MSG_VALUE_CLOCK_HW_STATE_NOT_READY)
7009fbcc: 9805         	ldr	r0, [sp, #0x14]
7009fbce: b968         	cbnz	r0, 0x7009fbec <SOC_moduleSetClockFrequency+0x18c> @ imm = #0x1a
7009fbd0: e7ff         	b	0x7009fbd2 <SOC_moduleSetClockFrequency+0x172> @ imm = #-0x2
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009fbd2: 980f         	ldr	r0, [sp, #0x3c]
;                                                   clkId,
7009fbd4: 990e         	ldr	r1, [sp, #0x38]
;                                                   clockStatus,
7009fbd6: 9a05         	ldr	r2, [sp, #0x14]
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009fbd8: 46ec         	mov	r12, sp
7009fbda: f04f 33ff    	mov.w	r3, #0xffffffff
7009fbde: f8cc 3000    	str.w	r3, [r12]
7009fbe2: 2300         	movs	r3, #0x0
7009fbe4: f00a f9c4    	bl	0x700a9f70 <Sciclient_pmModuleClkRequest> @ imm = #0xa388
7009fbe8: 900b         	str	r0, [sp, #0x2c]
;         }
7009fbea: e7ff         	b	0x7009fbec <SOC_moduleSetClockFrequency+0x18c> @ imm = #-0x2
;     }
7009fbec: e7ff         	b	0x7009fbee <SOC_moduleSetClockFrequency+0x18e> @ imm = #-0x2
;     if (status != SystemP_SUCCESS)
7009fbee: 980b         	ldr	r0, [sp, #0x2c]
7009fbf0: b168         	cbz	r0, 0x7009fc0e <SOC_moduleSetClockFrequency+0x1ae> @ imm = #0x1a
7009fbf2: e7ff         	b	0x7009fbf4 <SOC_moduleSetClockFrequency+0x194> @ imm = #-0x2
;         if (moduleClockParentChanged == 1U)
7009fbf4: 9806         	ldr	r0, [sp, #0x18]
7009fbf6: 2801         	cmp	r0, #0x1
7009fbf8: d108         	bne	0x7009fc0c <SOC_moduleSetClockFrequency+0x1ac> @ imm = #0x10
7009fbfa: e7ff         	b	0x7009fbfc <SOC_moduleSetClockFrequency+0x19c> @ imm = #-0x2
;             Sciclient_pmSetModuleClkParent(moduleId,
7009fbfc: 980f         	ldr	r0, [sp, #0x3c]
;                                            clkId,
7009fbfe: 990e         	ldr	r1, [sp, #0x38]
;                                            origParent,
7009fc00: 9a04         	ldr	r2, [sp, #0x10]
7009fc02: f04f 33ff    	mov.w	r3, #0xffffffff
;             Sciclient_pmSetModuleClkParent(moduleId,
7009fc06: f009 fa4b    	bl	0x700a90a0 <Sciclient_pmSetModuleClkParent> @ imm = #0x9496
;         }
7009fc0a: e7ff         	b	0x7009fc0c <SOC_moduleSetClockFrequency+0x1ac> @ imm = #-0x2
;     }
7009fc0c: e7ff         	b	0x7009fc0e <SOC_moduleSetClockFrequency+0x1ae> @ imm = #-0x2
;     return status;
7009fc0e: 980b         	ldr	r0, [sp, #0x2c]
7009fc10: b010         	add	sp, #0x40
7009fc12: bd80         	pop	{r7, pc}
		...

7009fc20 <SOC_moduleSetClockFrequencyWithParent>:
; {
7009fc20: b580         	push	{r7, lr}
7009fc22: b092         	sub	sp, #0x48
7009fc24: 460b         	mov	r3, r1
7009fc26: 4684         	mov	r12, r0
7009fc28: 9915         	ldr	r1, [sp, #0x54]
7009fc2a: 9814         	ldr	r0, [sp, #0x50]
7009fc2c: f8cd c044    	str.w	r12, [sp, #0x44]
7009fc30: 9310         	str	r3, [sp, #0x40]
7009fc32: 920f         	str	r2, [sp, #0x3c]
7009fc34: 910d         	str	r1, [sp, #0x34]
7009fc36: 900c         	str	r0, [sp, #0x30]
7009fc38: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
7009fc3a: 9002         	str	r0, [sp, #0x8]
7009fc3c: 900b         	str	r0, [sp, #0x2c]
;     uint64_t respClkRate = 0;
7009fc3e: 9009         	str	r0, [sp, #0x24]
7009fc40: 9008         	str	r0, [sp, #0x20]
;     uint32_t numParents = 0U;
7009fc42: 9007         	str	r0, [sp, #0x1c]
;     uint32_t moduleClockParentChanged = 0U;
7009fc44: 9006         	str	r0, [sp, #0x18]
;     uint32_t clockStatus = 0U;
7009fc46: 9005         	str	r0, [sp, #0x14]
;     uint32_t origParent = 0U;
7009fc48: 9004         	str	r0, [sp, #0x10]
;     uint32_t foundParent = 0U;
7009fc4a: 9003         	str	r0, [sp, #0xc]
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009fc4c: 9811         	ldr	r0, [sp, #0x44]
;                                             clkId,
7009fc4e: 9910         	ldr	r1, [sp, #0x40]
7009fc50: aa05         	add	r2, sp, #0x14
7009fc52: f04f 33ff    	mov.w	r3, #0xffffffff
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009fc56: f009 fbb3    	bl	0x700a93c0 <Sciclient_pmModuleGetClkStatus> @ imm = #0x9766
7009fc5a: 900b         	str	r0, [sp, #0x2c]
;     if (status == SystemP_SUCCESS)
7009fc5c: 980b         	ldr	r0, [sp, #0x2c]
7009fc5e: b948         	cbnz	r0, 0x7009fc74 <SOC_moduleSetClockFrequencyWithParent+0x54> @ imm = #0x12
7009fc60: e7ff         	b	0x7009fc62 <SOC_moduleSetClockFrequencyWithParent+0x42> @ imm = #-0x2
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009fc62: 9811         	ldr	r0, [sp, #0x44]
;                                                    clkId,
7009fc64: 9910         	ldr	r1, [sp, #0x40]
7009fc66: aa07         	add	r2, sp, #0x1c
7009fc68: f04f 33ff    	mov.w	r3, #0xffffffff
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009fc6c: f008 fc88    	bl	0x700a8580 <Sciclient_pmGetModuleClkNumParent> @ imm = #0x8910
7009fc70: 900b         	str	r0, [sp, #0x2c]
;     }
7009fc72: e7ff         	b	0x7009fc74 <SOC_moduleSetClockFrequencyWithParent+0x54> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fc74: 980b         	ldr	r0, [sp, #0x2c]
7009fc76: b970         	cbnz	r0, 0x7009fc96 <SOC_moduleSetClockFrequencyWithParent+0x76> @ imm = #0x1c
7009fc78: e7ff         	b	0x7009fc7a <SOC_moduleSetClockFrequencyWithParent+0x5a> @ imm = #-0x2
;         if(numParents > 1U)
7009fc7a: 9807         	ldr	r0, [sp, #0x1c]
7009fc7c: 2802         	cmp	r0, #0x2
7009fc7e: d309         	blo	0x7009fc94 <SOC_moduleSetClockFrequencyWithParent+0x74> @ imm = #0x12
7009fc80: e7ff         	b	0x7009fc82 <SOC_moduleSetClockFrequencyWithParent+0x62> @ imm = #-0x2
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009fc82: 9811         	ldr	r0, [sp, #0x44]
;                                                     clkId,
7009fc84: 9910         	ldr	r1, [sp, #0x40]
7009fc86: aa04         	add	r2, sp, #0x10
7009fc88: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009fc8c: f009 f9b8    	bl	0x700a9000 <Sciclient_pmGetModuleClkParent> @ imm = #0x9370
7009fc90: 900b         	str	r0, [sp, #0x2c]
;         }
7009fc92: e7ff         	b	0x7009fc94 <SOC_moduleSetClockFrequencyWithParent+0x74> @ imm = #-0x2
;     }
7009fc94: e7ff         	b	0x7009fc96 <SOC_moduleSetClockFrequencyWithParent+0x76> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fc96: 980b         	ldr	r0, [sp, #0x2c]
7009fc98: b960         	cbnz	r0, 0x7009fcb4 <SOC_moduleSetClockFrequencyWithParent+0x94> @ imm = #0x18
7009fc9a: e7ff         	b	0x7009fc9c <SOC_moduleSetClockFrequencyWithParent+0x7c> @ imm = #-0x2
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009fc9c: 9811         	ldr	r0, [sp, #0x44]
;                                               clkId,
7009fc9e: 9910         	ldr	r1, [sp, #0x40]
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009fca0: 466b         	mov	r3, sp
7009fca2: f04f 32ff    	mov.w	r2, #0xffffffff
7009fca6: 601a         	str	r2, [r3]
7009fca8: 2300         	movs	r3, #0x0
7009fcaa: 461a         	mov	r2, r3
7009fcac: f00a f960    	bl	0x700a9f70 <Sciclient_pmModuleClkRequest> @ imm = #0xa2c0
7009fcb0: 900b         	str	r0, [sp, #0x2c]
;     }
7009fcb2: e7ff         	b	0x7009fcb4 <SOC_moduleSetClockFrequencyWithParent+0x94> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fcb4: 980b         	ldr	r0, [sp, #0x2c]
7009fcb6: b960         	cbnz	r0, 0x7009fcd2 <SOC_moduleSetClockFrequencyWithParent+0xb2> @ imm = #0x18
7009fcb8: e7ff         	b	0x7009fcba <SOC_moduleSetClockFrequencyWithParent+0x9a> @ imm = #-0x2
;         if (clkParent > (clkId + numParents))
7009fcba: 980f         	ldr	r0, [sp, #0x3c]
7009fcbc: 9910         	ldr	r1, [sp, #0x40]
7009fcbe: 9a07         	ldr	r2, [sp, #0x1c]
7009fcc0: 4411         	add	r1, r2
7009fcc2: 4288         	cmp	r0, r1
7009fcc4: d904         	bls	0x7009fcd0 <SOC_moduleSetClockFrequencyWithParent+0xb0> @ imm = #0x8
7009fcc6: e7ff         	b	0x7009fcc8 <SOC_moduleSetClockFrequencyWithParent+0xa8> @ imm = #-0x2
7009fcc8: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009fccc: 900b         	str	r0, [sp, #0x2c]
;         }
7009fcce: e7ff         	b	0x7009fcd0 <SOC_moduleSetClockFrequencyWithParent+0xb0> @ imm = #-0x2
;     }
7009fcd0: e7ff         	b	0x7009fcd2 <SOC_moduleSetClockFrequencyWithParent+0xb2> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fcd2: 980b         	ldr	r0, [sp, #0x2c]
7009fcd4: b9a8         	cbnz	r0, 0x7009fd02 <SOC_moduleSetClockFrequencyWithParent+0xe2> @ imm = #0x2a
7009fcd6: e7ff         	b	0x7009fcd8 <SOC_moduleSetClockFrequencyWithParent+0xb8> @ imm = #-0x2
;         if (clkParent != origParent)
7009fcd8: 980f         	ldr	r0, [sp, #0x3c]
7009fcda: 9904         	ldr	r1, [sp, #0x10]
7009fcdc: 4288         	cmp	r0, r1
7009fcde: d00f         	beq	0x7009fd00 <SOC_moduleSetClockFrequencyWithParent+0xe0> @ imm = #0x1e
7009fce0: e7ff         	b	0x7009fce2 <SOC_moduleSetClockFrequencyWithParent+0xc2> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkParent(moduleId,
7009fce2: 9811         	ldr	r0, [sp, #0x44]
;                                                         clkId,
7009fce4: 9910         	ldr	r1, [sp, #0x40]
;                                                         clkParent,
7009fce6: 9a0f         	ldr	r2, [sp, #0x3c]
7009fce8: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmSetModuleClkParent(moduleId,
7009fcec: f009 f9d8    	bl	0x700a90a0 <Sciclient_pmSetModuleClkParent> @ imm = #0x93b0
7009fcf0: 900b         	str	r0, [sp, #0x2c]
;             if (status == SystemP_SUCCESS)
7009fcf2: 980b         	ldr	r0, [sp, #0x2c]
7009fcf4: b918         	cbnz	r0, 0x7009fcfe <SOC_moduleSetClockFrequencyWithParent+0xde> @ imm = #0x6
7009fcf6: e7ff         	b	0x7009fcf8 <SOC_moduleSetClockFrequencyWithParent+0xd8> @ imm = #-0x2
7009fcf8: 2001         	movs	r0, #0x1
;                 moduleClockParentChanged = 1U;
7009fcfa: 9006         	str	r0, [sp, #0x18]
;             }
7009fcfc: e7ff         	b	0x7009fcfe <SOC_moduleSetClockFrequencyWithParent+0xde> @ imm = #-0x2
;         }
7009fcfe: e7ff         	b	0x7009fd00 <SOC_moduleSetClockFrequencyWithParent+0xe0> @ imm = #-0x2
;     }
7009fd00: e7ff         	b	0x7009fd02 <SOC_moduleSetClockFrequencyWithParent+0xe2> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fd02: 980b         	ldr	r0, [sp, #0x2c]
7009fd04: b988         	cbnz	r0, 0x7009fd2a <SOC_moduleSetClockFrequencyWithParent+0x10a> @ imm = #0x22
7009fd06: e7ff         	b	0x7009fd08 <SOC_moduleSetClockFrequencyWithParent+0xe8> @ imm = #-0x2
;         status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009fd08: 9811         	ldr	r0, [sp, #0x44]
;                                                 clkId,
7009fd0a: 9910         	ldr	r1, [sp, #0x40]
;                                                 clkRate,
7009fd0c: 9a0c         	ldr	r2, [sp, #0x30]
7009fd0e: 9b0d         	ldr	r3, [sp, #0x34]
;         status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009fd10: 46ee         	mov	lr, sp
7009fd12: f04f 3cff    	mov.w	r12, #0xffffffff
7009fd16: f8ce c004    	str.w	r12, [lr, #0x4]
7009fd1a: f10d 0c20    	add.w	r12, sp, #0x20
7009fd1e: f8ce c000    	str.w	r12, [lr]
7009fd22: f003 fc1d    	bl	0x700a3560 <Sciclient_pmQueryModuleClkFreq> @ imm = #0x383a
7009fd26: 900b         	str	r0, [sp, #0x2c]
;     }
7009fd28: e7ff         	b	0x7009fd2a <SOC_moduleSetClockFrequencyWithParent+0x10a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fd2a: 980b         	ldr	r0, [sp, #0x2c]
7009fd2c: b970         	cbnz	r0, 0x7009fd4c <SOC_moduleSetClockFrequencyWithParent+0x12c> @ imm = #0x1c
7009fd2e: e7ff         	b	0x7009fd30 <SOC_moduleSetClockFrequencyWithParent+0x110> @ imm = #-0x2
;         if(respClkRate == clkRate)
7009fd30: 9808         	ldr	r0, [sp, #0x20]
7009fd32: 9909         	ldr	r1, [sp, #0x24]
7009fd34: 9a0c         	ldr	r2, [sp, #0x30]
7009fd36: 9b0d         	ldr	r3, [sp, #0x34]
7009fd38: 4059         	eors	r1, r3
7009fd3a: ea80 0002    	eor.w	r0, r0, r2
7009fd3e: 4308         	orrs	r0, r1
7009fd40: b918         	cbnz	r0, 0x7009fd4a <SOC_moduleSetClockFrequencyWithParent+0x12a> @ imm = #0x6
7009fd42: e7ff         	b	0x7009fd44 <SOC_moduleSetClockFrequencyWithParent+0x124> @ imm = #-0x2
7009fd44: 2001         	movs	r0, #0x1
;             foundParent = 1U;
7009fd46: 9003         	str	r0, [sp, #0xc]
;         }
7009fd48: e7ff         	b	0x7009fd4a <SOC_moduleSetClockFrequencyWithParent+0x12a> @ imm = #-0x2
;     }
7009fd4a: e7ff         	b	0x7009fd4c <SOC_moduleSetClockFrequencyWithParent+0x12c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fd4c: 980b         	ldr	r0, [sp, #0x2c]
7009fd4e: b9d0         	cbnz	r0, 0x7009fd86 <SOC_moduleSetClockFrequencyWithParent+0x166> @ imm = #0x34
7009fd50: e7ff         	b	0x7009fd52 <SOC_moduleSetClockFrequencyWithParent+0x132> @ imm = #-0x2
;         if(foundParent == 1U)
7009fd52: 9803         	ldr	r0, [sp, #0xc]
7009fd54: 2801         	cmp	r0, #0x1
7009fd56: d111         	bne	0x7009fd7c <SOC_moduleSetClockFrequencyWithParent+0x15c> @ imm = #0x22
7009fd58: e7ff         	b	0x7009fd5a <SOC_moduleSetClockFrequencyWithParent+0x13a> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009fd5a: 9811         	ldr	r0, [sp, #0x44]
;                                                   clkId,
7009fd5c: 9910         	ldr	r1, [sp, #0x40]
;                                                   clkRate,
7009fd5e: 9a0c         	ldr	r2, [sp, #0x30]
7009fd60: 9b0d         	ldr	r3, [sp, #0x34]
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009fd62: 46ee         	mov	lr, sp
7009fd64: f04f 3cff    	mov.w	r12, #0xffffffff
7009fd68: f8ce c004    	str.w	r12, [lr, #0x4]
7009fd6c: f44f 7c00    	mov.w	r12, #0x200
7009fd70: f8ce c000    	str.w	r12, [lr]
7009fd74: f005 f8ac    	bl	0x700a4ed0 <Sciclient_pmSetModuleClkFreq> @ imm = #0x5158
7009fd78: 900b         	str	r0, [sp, #0x2c]
;         }
7009fd7a: e003         	b	0x7009fd84 <SOC_moduleSetClockFrequencyWithParent+0x164> @ imm = #0x6
7009fd7c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009fd80: 900b         	str	r0, [sp, #0x2c]
7009fd82: e7ff         	b	0x7009fd84 <SOC_moduleSetClockFrequencyWithParent+0x164> @ imm = #-0x2
;     }
7009fd84: e7ff         	b	0x7009fd86 <SOC_moduleSetClockFrequencyWithParent+0x166> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fd86: 980b         	ldr	r0, [sp, #0x2c]
7009fd88: b988         	cbnz	r0, 0x7009fdae <SOC_moduleSetClockFrequencyWithParent+0x18e> @ imm = #0x22
7009fd8a: e7ff         	b	0x7009fd8c <SOC_moduleSetClockFrequencyWithParent+0x16c> @ imm = #-0x2
;         if (clockStatus == TISCI_MSG_VALUE_CLOCK_HW_STATE_NOT_READY)
7009fd8c: 9805         	ldr	r0, [sp, #0x14]
7009fd8e: b968         	cbnz	r0, 0x7009fdac <SOC_moduleSetClockFrequencyWithParent+0x18c> @ imm = #0x1a
7009fd90: e7ff         	b	0x7009fd92 <SOC_moduleSetClockFrequencyWithParent+0x172> @ imm = #-0x2
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009fd92: 9811         	ldr	r0, [sp, #0x44]
;                                                   clkId,
7009fd94: 9910         	ldr	r1, [sp, #0x40]
;                                                   clockStatus,
7009fd96: 9a05         	ldr	r2, [sp, #0x14]
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009fd98: 46ec         	mov	r12, sp
7009fd9a: f04f 33ff    	mov.w	r3, #0xffffffff
7009fd9e: f8cc 3000    	str.w	r3, [r12]
7009fda2: 2300         	movs	r3, #0x0
7009fda4: f00a f8e4    	bl	0x700a9f70 <Sciclient_pmModuleClkRequest> @ imm = #0xa1c8
7009fda8: 900b         	str	r0, [sp, #0x2c]
;         }
7009fdaa: e7ff         	b	0x7009fdac <SOC_moduleSetClockFrequencyWithParent+0x18c> @ imm = #-0x2
;     }
7009fdac: e7ff         	b	0x7009fdae <SOC_moduleSetClockFrequencyWithParent+0x18e> @ imm = #-0x2
;     if (status != SystemP_SUCCESS)
7009fdae: 980b         	ldr	r0, [sp, #0x2c]
7009fdb0: b168         	cbz	r0, 0x7009fdce <SOC_moduleSetClockFrequencyWithParent+0x1ae> @ imm = #0x1a
7009fdb2: e7ff         	b	0x7009fdb4 <SOC_moduleSetClockFrequencyWithParent+0x194> @ imm = #-0x2
;         if (moduleClockParentChanged == 1U)
7009fdb4: 9806         	ldr	r0, [sp, #0x18]
7009fdb6: 2801         	cmp	r0, #0x1
7009fdb8: d108         	bne	0x7009fdcc <SOC_moduleSetClockFrequencyWithParent+0x1ac> @ imm = #0x10
7009fdba: e7ff         	b	0x7009fdbc <SOC_moduleSetClockFrequencyWithParent+0x19c> @ imm = #-0x2
;             Sciclient_pmSetModuleClkParent(moduleId,
7009fdbc: 9811         	ldr	r0, [sp, #0x44]
;                                            clkId,
7009fdbe: 9910         	ldr	r1, [sp, #0x40]
;                                            origParent,
7009fdc0: 9a04         	ldr	r2, [sp, #0x10]
7009fdc2: f04f 33ff    	mov.w	r3, #0xffffffff
;             Sciclient_pmSetModuleClkParent(moduleId,
7009fdc6: f009 f96b    	bl	0x700a90a0 <Sciclient_pmSetModuleClkParent> @ imm = #0x92d6
;         }
7009fdca: e7ff         	b	0x7009fdcc <SOC_moduleSetClockFrequencyWithParent+0x1ac> @ imm = #-0x2
;     }
7009fdcc: e7ff         	b	0x7009fdce <SOC_moduleSetClockFrequencyWithParent+0x1ae> @ imm = #-0x2
;     return status;
7009fdce: 980b         	ldr	r0, [sp, #0x2c]
7009fdd0: b012         	add	sp, #0x48
7009fdd2: bd80         	pop	{r7, pc}

7009fdd4 <memalign>:
7009fdd4: e92d4bf0     	push	{r4, r5, r6, r7, r8, r9, r11, lr}
7009fdd8: e59f5190     	ldr	r5, [pc, #0x190]        @ 0x7009ff70 <memalign+0x19c>
7009fddc: e3a02000     	mov	r2, #0
7009fde0: e3a08000     	mov	r8, #0
7009fde4: e2413001     	sub	r3, r1, #1
7009fde8: e2454008     	sub	r4, r5, #8
7009fdec: e3550007     	cmp	r5, #7
7009fdf0: 81a02004     	movhi	r2, r4
7009fdf4: e1530002     	cmp	r3, r2
7009fdf8: 2a00005a     	bhs	0x7009ff68 <memalign+0x194> @ imm = #0x168
7009fdfc: e2402001     	sub	r2, r0, #1
7009fe00: e59f316c     	ldr	r3, [pc, #0x16c]        @ 0x7009ff74 <memalign+0x1a0>
7009fe04: e3a07008     	mov	r7, #8
7009fe08: e2816007     	add	r6, r1, #7
7009fe0c: e1100002     	tst	r0, r2
7009fe10: 01a07000     	moveq	r7, r0
7009fe14: e3500007     	cmp	r0, #7
7009fe18: e5930000     	ldr	r0, [r3]
7009fe1c: e3a02008     	mov	r2, #8
7009fe20: 91a07002     	movls	r7, r2
7009fe24: e12fff30     	blx	r0
7009fe28: e59f0148     	ldr	r0, [pc, #0x148]        @ 0x7009ff78 <memalign+0x1a4>
7009fe2c: e5d01000     	ldrb	r1, [r0]
7009fe30: e3510000     	cmp	r1, #0
7009fe34: 1a000011     	bne	0x7009fe80 <memalign+0xac> @ imm = #0x44
7009fe38: e3a02000     	mov	r2, #0
7009fe3c: e3a01000     	mov	r1, #0
7009fe40: e3550007     	cmp	r5, #7
7009fe44: 81a02004     	movhi	r2, r4
7009fe48: e3520000     	cmp	r2, #0
7009fe4c: 1a000002     	bne	0x7009fe5c <memalign+0x88> @ imm = #0x8
7009fe50: e59f2124     	ldr	r2, [pc, #0x124]        @ 0x7009ff7c <memalign+0x1a8>
7009fe54: e5821000     	str	r1, [r2]
7009fe58: ea000006     	b	0x7009fe78 <memalign+0xa4> @ imm = #0x18
7009fe5c: e59f211c     	ldr	r2, [pc, #0x11c]        @ 0x7009ff80 <memalign+0x1ac>
7009fe60: e3550007     	cmp	r5, #7
7009fe64: 91a04001     	movls	r4, r1
7009fe68: e59f310c     	ldr	r3, [pc, #0x10c]        @ 0x7009ff7c <memalign+0x1a8>
7009fe6c: e5821008     	str	r1, [r2, #0x8]
7009fe70: e5832000     	str	r2, [r3]
7009fe74: e5824000     	str	r4, [r2]
7009fe78: e3a01001     	mov	r1, #1
7009fe7c: e5c01000     	strb	r1, [r0]
7009fe80: e59f50f4     	ldr	r5, [pc, #0xf4]         @ 0x7009ff7c <memalign+0x1a8>
7009fe84: e3c69007     	bic	r9, r6, #7
7009fe88: e2470001     	sub	r0, r7, #1
7009fe8c: e2671000     	rsb	r1, r7, #0
7009fe90: e5956000     	ldr	r6, [r5]
7009fe94: e3560000     	cmp	r6, #0
7009fe98: 0a00002f     	beq	0x7009ff5c <memalign+0x188> @ imm = #0xbc
7009fe9c: e2865008     	add	r5, r6, #8
7009fea0: e0802005     	add	r2, r0, r5
7009fea4: e0024001     	and	r4, r2, r1
7009fea8: e1550004     	cmp	r5, r4
7009feac: 0a00000c     	beq	0x7009fee4 <memalign+0x110> @ imm = #0x30
7009feb0: e2862010     	add	r2, r6, #16
7009feb4: e2443008     	sub	r3, r4, #8
7009feb8: e1520003     	cmp	r2, r3
7009febc: 9a000001     	bls	0x7009fec8 <memalign+0xf4> @ imm = #0x4
7009fec0: e0844007     	add	r4, r4, r7
7009fec4: eafffffa     	b	0x7009feb4 <memalign+0xe0> @ imm = #-0x18
7009fec8: e5962000     	ldr	r2, [r6]
7009fecc: e0843009     	add	r3, r4, r9
7009fed0: e3c22001     	bic	r2, r2, #1
7009fed4: e0852002     	add	r2, r5, r2
7009fed8: e1520003     	cmp	r2, r3
7009fedc: 3affffeb     	blo	0x7009fe90 <memalign+0xbc> @ imm = #-0x54
7009fee0: ea000004     	b	0x7009fef8 <memalign+0x124> @ imm = #0x10
7009fee4: e5962000     	ldr	r2, [r6]
7009fee8: e3c22001     	bic	r2, r2, #1
7009feec: e1520009     	cmp	r2, r9
7009fef0: baffffe6     	blt	0x7009fe90 <memalign+0xbc> @ imm = #-0x68
7009fef4: e1a04005     	mov	r4, r5
7009fef8: e1a00006     	mov	r0, r6
7009fefc: eb0039c0     	bl	0x700ae604 <free_list_remove> @ imm = #0xe700
7009ff00: e1540005     	cmp	r4, r5
7009ff04: 0a00000c     	beq	0x7009ff3c <memalign+0x168> @ imm = #0x30
7009ff08: e5960000     	ldr	r0, [r6]
7009ff0c: e0441005     	sub	r1, r4, r5
7009ff10: e2412008     	sub	r2, r1, #8
7009ff14: e1a04006     	mov	r4, r6
7009ff18: e3c00001     	bic	r0, r0, #1
7009ff1c: e0400001     	sub	r0, r0, r1
7009ff20: e3c21001     	bic	r1, r2, #1
7009ff24: e3800001     	orr	r0, r0, #1
7009ff28: e6842001     	str	r2, [r4], r1
7009ff2c: e5a40008     	str	r0, [r4, #0x8]!
7009ff30: e1a00006     	mov	r0, r6
7009ff34: eb003775     	bl	0x700add10 <free_list_insert> @ imm = #0xddd4
7009ff38: e1a06004     	mov	r6, r4
7009ff3c: e1a00006     	mov	r0, r6
7009ff40: e1a01009     	mov	r1, r9
7009ff44: eb002266     	bl	0x700a88e4 <split>      @ imm = #0x8998
7009ff48: e59f0034     	ldr	r0, [pc, #0x34]         @ 0x7009ff84 <memalign+0x1b0>
7009ff4c: e5900000     	ldr	r0, [r0]
7009ff50: e12fff30     	blx	r0
7009ff54: e2868008     	add	r8, r6, #8
7009ff58: ea000002     	b	0x7009ff68 <memalign+0x194> @ imm = #0x8
7009ff5c: e59f0020     	ldr	r0, [pc, #0x20]         @ 0x7009ff84 <memalign+0x1b0>
7009ff60: e5900000     	ldr	r0, [r0]
7009ff64: e12fff30     	blx	r0
7009ff68: e1a00008     	mov	r0, r8
7009ff6c: e8bd8bf0     	pop	{r4, r5, r6, r7, r8, r9, r11, pc}
7009ff70: 00 00 01 00  	.word	0x00010000
7009ff74: d4 29 0b 70  	.word	0x700b29d4
7009ff78: 68 2a 0b 70  	.word	0x700b2a68
7009ff7c: ac 52 08 70  	.word	0x700852ac
7009ff80: 00 53 08 70  	.word	0x70085300
7009ff84: d8 29 0b 70  	.word	0x700b29d8
7009ff88: 00 00 00 00  	.word	0x00000000
7009ff8c: 00 00 00 00  	.word	0x00000000

7009ff90 <UART_close>:
; {
7009ff90: b580         	push	{r7, lr}
7009ff92: b08a         	sub	sp, #0x28
7009ff94: 9009         	str	r0, [sp, #0x24]
;     config = (UART_Config *) handle;
7009ff96: 9809         	ldr	r0, [sp, #0x24]
7009ff98: 9008         	str	r0, [sp, #0x20]
;     if ((NULL != config) && (config->object != NULL) && (config->object->isOpen != FALSE))
7009ff9a: 9808         	ldr	r0, [sp, #0x20]
7009ff9c: 2800         	cmp	r0, #0x0
7009ff9e: f000 80ce    	beq.w	0x700a013e <UART_close+0x1ae> @ imm = #0x19c
7009ffa2: e7ff         	b	0x7009ffa4 <UART_close+0x14> @ imm = #-0x2
7009ffa4: 9808         	ldr	r0, [sp, #0x20]
7009ffa6: 6840         	ldr	r0, [r0, #0x4]
7009ffa8: 2800         	cmp	r0, #0x0
7009ffaa: f000 80c8    	beq.w	0x700a013e <UART_close+0x1ae> @ imm = #0x190
7009ffae: e7ff         	b	0x7009ffb0 <UART_close+0x20> @ imm = #-0x2
7009ffb0: 9808         	ldr	r0, [sp, #0x20]
7009ffb2: 6840         	ldr	r0, [r0, #0x4]
7009ffb4: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009ffb8: 2800         	cmp	r0, #0x0
7009ffba: f000 80c0    	beq.w	0x700a013e <UART_close+0x1ae> @ imm = #0x180
7009ffbe: e7ff         	b	0x7009ffc0 <UART_close+0x30> @ imm = #-0x2
;         object = config->object;
7009ffc0: 9808         	ldr	r0, [sp, #0x20]
7009ffc2: 6840         	ldr	r0, [r0, #0x4]
7009ffc4: 9007         	str	r0, [sp, #0x1c]
;         attrs = config->attrs;
7009ffc6: 9808         	ldr	r0, [sp, #0x20]
7009ffc8: 6800         	ldr	r0, [r0]
7009ffca: 9006         	str	r0, [sp, #0x18]
;         object->uartLld_handle = &object->uartLld_object;
7009ffcc: 9907         	ldr	r1, [sp, #0x1c]
7009ffce: f501 7022    	add.w	r0, r1, #0x288
7009ffd2: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;         uartLld_handle = object->uartLld_handle;
7009ffd6: 9807         	ldr	r0, [sp, #0x1c]
7009ffd8: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009ffdc: 9005         	str	r0, [sp, #0x14]
;         DebugP_assert(NULL_PTR != object);
7009ffde: 9807         	ldr	r0, [sp, #0x1c]
7009ffe0: 2800         	cmp	r0, #0x0
7009ffe2: bf18         	it	ne
7009ffe4: 2001         	movne	r0, #0x1
7009ffe6: f641 71ce    	movw	r1, #0x1fce
7009ffea: f2c7 010b    	movt	r1, #0x700b
7009ffee: 466a         	mov	r2, sp
7009fff0: 6011         	str	r1, [r2]
7009fff2: f641 71e1    	movw	r1, #0x1fe1
7009fff6: f2c7 010b    	movt	r1, #0x700b
7009fffa: 9101         	str	r1, [sp, #0x4]
7009fffc: f242 1246    	movw	r2, #0x2146
700a0000: f2c7 020b    	movt	r2, #0x700b
700a0004: 9202         	str	r2, [sp, #0x8]
700a0006: f240 13c5    	movw	r3, #0x1c5
700a000a: f00a fe41    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xac82
700a000e: 9901         	ldr	r1, [sp, #0x4]
700a0010: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != attrs);
700a0012: 9806         	ldr	r0, [sp, #0x18]
700a0014: 2800         	cmp	r0, #0x0
700a0016: bf18         	it	ne
700a0018: 2001         	movne	r0, #0x1
700a001a: f242 0329    	movw	r3, #0x2029
700a001e: f2c7 030b    	movt	r3, #0x700b
700a0022: 46ec         	mov	r12, sp
700a0024: f8cc 3000    	str.w	r3, [r12]
700a0028: f44f 73e3    	mov.w	r3, #0x1c6
700a002c: f00a fe30    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xac60
700a0030: 9901         	ldr	r1, [sp, #0x4]
700a0032: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != gUartDrvObj.lock);
700a0034: f242 7338    	movw	r3, #0x2738
700a0038: f2c7 030b    	movt	r3, #0x700b
700a003c: f853 0b04    	ldr	r0, [r3], #4
700a0040: 9303         	str	r3, [sp, #0xc]
700a0042: 2800         	cmp	r0, #0x0
700a0044: bf18         	it	ne
700a0046: 2001         	movne	r0, #0x1
700a0048: f641 53c0    	movw	r3, #0x1dc0
700a004c: f2c7 030b    	movt	r3, #0x700b
700a0050: 46ec         	mov	r12, sp
700a0052: f8cc 3000    	str.w	r3, [r12]
700a0056: f44f 73e4    	mov.w	r3, #0x1c8
700a005a: f00a fe19    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xac32
700a005e: 9803         	ldr	r0, [sp, #0xc]
700a0060: f04f 31ff    	mov.w	r1, #0xffffffff
;         (void)SemaphoreP_pend(&gUartDrvObj.lockObj, SystemP_WAIT_FOREVER);
700a0064: f00a fbbc    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0xa778
;         UART_flushTxFifo(handle);
700a0068: 9809         	ldr	r0, [sp, #0x24]
700a006a: f007 f9e1    	bl	0x700a7430 <UART_flushTxFifo> @ imm = #0x73c2
;         UART_intrDisable(attrs->baseAddr,
700a006e: 9806         	ldr	r0, [sp, #0x18]
700a0070: 6800         	ldr	r0, [r0]
700a0072: 2107         	movs	r1, #0x7
700a0074: 9104         	str	r1, [sp, #0x10]
700a0076: f006 f973    	bl	0x700a6360 <UART_intrDisable> @ imm = #0x62e6
;         UART_intr2Disable(attrs->baseAddr, UART_INT2_TX_EMPTY);
700a007a: 9806         	ldr	r0, [sp, #0x18]
700a007c: 6800         	ldr	r0, [r0]
700a007e: 2102         	movs	r1, #0x2
700a0080: f00e fe8e    	bl	0x700aeda0 <UART_intr2Disable> @ imm = #0xed1c
700a0084: 9904         	ldr	r1, [sp, #0x10]
;         (void)UART_operatingModeSelect(attrs->baseAddr, UART_OPER_MODE_DISABLED);
700a0086: 9806         	ldr	r0, [sp, #0x18]
700a0088: 6800         	ldr	r0, [r0]
700a008a: f00e fed1    	bl	0x700aee30 <UART_operatingModeSelect> @ imm = #0xeda2
;         if(UART_CONFIG_MODE_DMA == object->prms.transferMode)
700a008e: 9807         	ldr	r0, [sp, #0x1c]
700a0090: 6b00         	ldr	r0, [r0, #0x30]
700a0092: 2803         	cmp	r0, #0x3
700a0094: d104         	bne	0x700a00a0 <UART_close+0x110> @ imm = #0x8
700a0096: e7ff         	b	0x700a0098 <UART_close+0x108> @ imm = #-0x2
;             (void)UART_lld_deInitDma(uartLld_handle);
700a0098: 9805         	ldr	r0, [sp, #0x14]
700a009a: f00b fde1    	bl	0x700abc60 <UART_lld_deInitDma> @ imm = #0xbbc2
;         }
700a009e: e003         	b	0x700a00a8 <UART_close+0x118> @ imm = #0x6
;             (void)UART_lld_deInit(uartLld_handle);
700a00a0: 9805         	ldr	r0, [sp, #0x14]
700a00a2: f00c fab5    	bl	0x700ac610 <UART_lld_deInit> @ imm = #0xc56a
700a00a6: e7ff         	b	0x700a00a8 <UART_close+0x118> @ imm = #-0x2
;         if(NULL != object->lock)
700a00a8: 9807         	ldr	r0, [sp, #0x1c]
700a00aa: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a00ae: b148         	cbz	r0, 0x700a00c4 <UART_close+0x134> @ imm = #0x12
700a00b0: e7ff         	b	0x700a00b2 <UART_close+0x122> @ imm = #-0x2
;             SemaphoreP_destruct(&object->lockObj);
700a00b2: 9807         	ldr	r0, [sp, #0x1c]
700a00b4: 308c         	adds	r0, #0x8c
700a00b6: f00f fc03    	bl	0x700af8c0 <SemaphoreP_destruct> @ imm = #0xf806
;             object->lock = NULL;
700a00ba: 9907         	ldr	r1, [sp, #0x1c]
700a00bc: 2000         	movs	r0, #0x0
700a00be: f8c1 0088    	str.w	r0, [r1, #0x88]
;         }
700a00c2: e7ff         	b	0x700a00c4 <UART_close+0x134> @ imm = #-0x2
;         if(NULL != object->readTransferSem)
700a00c4: 9807         	ldr	r0, [sp, #0x1c]
700a00c6: f8d0 0124    	ldr.w	r0, [r0, #0x124]
700a00ca: b160         	cbz	r0, 0x700a00e6 <UART_close+0x156> @ imm = #0x18
700a00cc: e7ff         	b	0x700a00ce <UART_close+0x13e> @ imm = #-0x2
;             SemaphoreP_destruct(&object->readTransferSemObj);
700a00ce: 9807         	ldr	r0, [sp, #0x1c]
700a00d0: f500 7094    	add.w	r0, r0, #0x128
700a00d4: f00f fbf4    	bl	0x700af8c0 <SemaphoreP_destruct> @ imm = #0xf7e8
;             object->readTransferSem = NULL;
700a00d8: 9907         	ldr	r1, [sp, #0x1c]
700a00da: 2000         	movs	r0, #0x0
700a00dc: f8c1 0124    	str.w	r0, [r1, #0x124]
;             uartLld_handle->readTransferMutex = NULL;
700a00e0: 9905         	ldr	r1, [sp, #0x14]
700a00e2: 6588         	str	r0, [r1, #0x58]
;         }
700a00e4: e7ff         	b	0x700a00e6 <UART_close+0x156> @ imm = #-0x2
;         if(NULL != object->writeTransferSem)
700a00e6: 9807         	ldr	r0, [sp, #0x1c]
700a00e8: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
700a00ec: b160         	cbz	r0, 0x700a0108 <UART_close+0x178> @ imm = #0x18
700a00ee: e7ff         	b	0x700a00f0 <UART_close+0x160> @ imm = #-0x2
;             SemaphoreP_destruct(&object->writeTransferSemObj);
700a00f0: 9807         	ldr	r0, [sp, #0x1c]
700a00f2: f500 70e2    	add.w	r0, r0, #0x1c4
700a00f6: f00f fbe3    	bl	0x700af8c0 <SemaphoreP_destruct> @ imm = #0xf7c6
;             object->writeTransferSem = NULL;
700a00fa: 9907         	ldr	r1, [sp, #0x1c]
700a00fc: 2000         	movs	r0, #0x0
700a00fe: f8c1 01c0    	str.w	r0, [r1, #0x1c0]
;             uartLld_handle->writeTransferMutex = NULL;
700a0102: 9905         	ldr	r1, [sp, #0x14]
700a0104: 65c8         	str	r0, [r1, #0x5c]
;         }
700a0106: e7ff         	b	0x700a0108 <UART_close+0x178> @ imm = #-0x2
;         if(NULL != object->hwiHandle)
700a0108: 9807         	ldr	r0, [sp, #0x1c]
700a010a: f8d0 025c    	ldr.w	r0, [r0, #0x25c]
700a010e: b150         	cbz	r0, 0x700a0126 <UART_close+0x196> @ imm = #0x14
700a0110: e7ff         	b	0x700a0112 <UART_close+0x182> @ imm = #-0x2
;             HwiP_destruct(&object->hwiObj);
700a0112: 9807         	ldr	r0, [sp, #0x1c]
700a0114: f500 7018    	add.w	r0, r0, #0x260
700a0118: f010 f832    	bl	0x700b0180 <HwiP_destruct> @ imm = #0x10064
;             object->hwiHandle = NULL;
700a011c: 9907         	ldr	r1, [sp, #0x1c]
700a011e: 2000         	movs	r0, #0x0
700a0120: f8c1 025c    	str.w	r0, [r1, #0x25c]
;         }
700a0124: e7ff         	b	0x700a0126 <UART_close+0x196> @ imm = #-0x2
;         object->isOpen = FALSE;
700a0126: 9907         	ldr	r1, [sp, #0x1c]
700a0128: 2000         	movs	r0, #0x0
700a012a: f8c1 0084    	str.w	r0, [r1, #0x84]
;         SemaphoreP_post(&gUartDrvObj.lockObj);
700a012e: f242 7038    	movw	r0, #0x2738
700a0132: f2c7 000b    	movt	r0, #0x700b
700a0136: 3004         	adds	r0, #0x4
700a0138: f00b fee2    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0xbdc4
;     }
700a013c: e7ff         	b	0x700a013e <UART_close+0x1ae> @ imm = #-0x2
;     return;
700a013e: b00a         	add	sp, #0x28
700a0140: bd80         	pop	{r7, pc}
700a0142: 0000         	movs	r0, r0

700a0144 <free>:
700a0144: e3500000     	cmp	r0, #0
700a0148: 012fff1e     	bxeq	lr
700a014c: e92d41f0     	push	{r4, r5, r6, r7, r8, lr}
700a0150: e1a04000     	mov	r4, r0
700a0154: e59f0188     	ldr	r0, [pc, #0x188]        @ 0x700a02e4 <free+0x1a0>
700a0158: e5900000     	ldr	r0, [r0]
700a015c: e12fff30     	blx	r0
700a0160: e59f0180     	ldr	r0, [pc, #0x180]        @ 0x700a02e8 <free+0x1a4>
700a0164: e2444008     	sub	r4, r4, #8
700a0168: e3a05000     	mov	r5, #0
700a016c: e5901000     	ldr	r1, [r0]
700a0170: e1500004     	cmp	r0, r4
700a0174: e3c12001     	bic	r2, r1, #1
700a0178: 2a000004     	bhs	0x700a0190 <free+0x4c>  @ imm = #0x10
700a017c: e0801002     	add	r1, r0, r2
700a0180: e1a05000     	mov	r5, r0
700a0184: e2811008     	add	r1, r1, #8
700a0188: e1a00001     	mov	r0, r1
700a018c: eafffff6     	b	0x700a016c <free+0x28>  @ imm = #-0x28
700a0190: e59f3150     	ldr	r3, [pc, #0x150]        @ 0x700a02e8 <free+0x1a4>
700a0194: e0802002     	add	r2, r0, r2
700a0198: e59f714c     	ldr	r7, [pc, #0x14c]        @ 0x700a02ec <free+0x1a8>
700a019c: e2826008     	add	r6, r2, #8
700a01a0: e0872003     	add	r2, r7, r3
700a01a4: e3570007     	cmp	r7, #7
700a01a8: 82423008     	subhi	r3, r2, #8
700a01ac: e1560003     	cmp	r6, r3
700a01b0: 83006000     	movwhi	r6, #0x0
700a01b4: e1500004     	cmp	r0, r4
700a01b8: 1a000045     	bne	0x700a02d4 <free+0x190> @ imm = #0x114
700a01bc: e2110001     	ands	r0, r1, #1
700a01c0: 0a000043     	beq	0x700a02d4 <free+0x190> @ imm = #0x10c
700a01c4: e3550000     	cmp	r5, #0
700a01c8: 0a000009     	beq	0x700a01f4 <free+0xb0>  @ imm = #0x24
700a01cc: e5951000     	ldr	r1, [r5]
700a01d0: e3a00000     	mov	r0, #0
700a01d4: e3a07000     	mov	r7, #0
700a01d8: e2111001     	ands	r1, r1, #1
700a01dc: 01a00005     	moveq	r0, r5
700a01e0: e3560000     	cmp	r6, #0
700a01e4: 1a000005     	bne	0x700a0200 <free+0xbc>  @ imm = #0x14
700a01e8: e3510000     	cmp	r1, #0
700a01ec: 0a00000b     	beq	0x700a0220 <free+0xdc>  @ imm = #0x2c
700a01f0: ea000022     	b	0x700a0280 <free+0x13c> @ imm = #0x88
700a01f4: e3a00000     	mov	r0, #0
700a01f8: e3560000     	cmp	r6, #0
700a01fc: 0a00001f     	beq	0x700a0280 <free+0x13c> @ imm = #0x7c
700a0200: e5d61000     	ldrb	r1, [r6]
700a0204: e3a07000     	mov	r7, #0
700a0208: e3a08000     	mov	r8, #0
700a020c: e3110001     	tst	r1, #1
700a0210: 01a07006     	moveq	r7, r6
700a0214: e3500000     	cmp	r0, #0
700a0218: 0a000007     	beq	0x700a023c <free+0xf8>  @ imm = #0x1c
700a021c: e1a05000     	mov	r5, r0
700a0220: e1a00005     	mov	r0, r5
700a0224: eb0038f6     	bl	0x700ae604 <free_list_remove> @ imm = #0xe3d8
700a0228: e3a08001     	mov	r8, #1
700a022c: e3570000     	cmp	r7, #0
700a0230: 0a00001d     	beq	0x700a02ac <free+0x168> @ imm = #0x74
700a0234: e1a06007     	mov	r6, r7
700a0238: ea000002     	b	0x700a0248 <free+0x104> @ imm = #0x8
700a023c: e3a05000     	mov	r5, #0
700a0240: e3570000     	cmp	r7, #0
700a0244: 0a00000d     	beq	0x700a0280 <free+0x13c> @ imm = #0x34
700a0248: e1a00006     	mov	r0, r6
700a024c: eb0038ec     	bl	0x700ae604 <free_list_remove> @ imm = #0xe3b0
700a0250: e3580000     	cmp	r8, #0
700a0254: 0a00000c     	beq	0x700a028c <free+0x148> @ imm = #0x30
700a0258: e5950000     	ldr	r0, [r5]
700a025c: e5941000     	ldr	r1, [r4]
700a0260: e5962000     	ldr	r2, [r6]
700a0264: e2800010     	add	r0, r0, #16
700a0268: e3c11001     	bic	r1, r1, #1
700a026c: e3c00001     	bic	r0, r0, #1
700a0270: e3c22001     	bic	r2, r2, #1
700a0274: e0800001     	add	r0, r0, r1
700a0278: e0800002     	add	r0, r0, r2
700a027c: ea000010     	b	0x700a02c4 <free+0x180> @ imm = #0x40
700a0280: e5940000     	ldr	r0, [r4]
700a0284: e3c00001     	bic	r0, r0, #1
700a0288: ea000005     	b	0x700a02a4 <free+0x160> @ imm = #0x14
700a028c: e5940000     	ldr	r0, [r4]
700a0290: e5961000     	ldr	r1, [r6]
700a0294: e2800008     	add	r0, r0, #8
700a0298: e3c11001     	bic	r1, r1, #1
700a029c: e3c00001     	bic	r0, r0, #1
700a02a0: e0800001     	add	r0, r0, r1
700a02a4: e5840000     	str	r0, [r4]
700a02a8: ea000007     	b	0x700a02cc <free+0x188> @ imm = #0x1c
700a02ac: e5950000     	ldr	r0, [r5]
700a02b0: e5941000     	ldr	r1, [r4]
700a02b4: e2800008     	add	r0, r0, #8
700a02b8: e3c11001     	bic	r1, r1, #1
700a02bc: e3c00001     	bic	r0, r0, #1
700a02c0: e0800001     	add	r0, r0, r1
700a02c4: e1a04005     	mov	r4, r5
700a02c8: e5850000     	str	r0, [r5]
700a02cc: e1a00004     	mov	r0, r4
700a02d0: eb00368e     	bl	0x700add10 <free_list_insert> @ imm = #0xda38
700a02d4: e59f0014     	ldr	r0, [pc, #0x14]         @ 0x700a02f0 <free+0x1ac>
700a02d8: e5900000     	ldr	r0, [r0]
700a02dc: e8bd41f0     	pop	{r4, r5, r6, r7, r8, lr}
700a02e0: e12fff10     	bx	r0
700a02e4: d4 29 0b 70  	.word	0x700b29d4
700a02e8: 00 53 08 70  	.word	0x70085300
700a02ec: 00 00 01 00  	.word	0x00010000
700a02f0: d8 29 0b 70  	.word	0x700b29d8
700a02f4: 00 00 00 00  	.word	0x00000000
700a02f8: 00 00 00 00  	.word	0x00000000
700a02fc: 00 00 00 00  	.word	0x00000000

700a0300 <UART_lld_controllerIsr>:
; {
700a0300: b580         	push	{r7, lr}
700a0302: b086         	sub	sp, #0x18
700a0304: 9005         	str	r0, [sp, #0x14]
700a0306: 2001         	movs	r0, #0x1
;     uint32_t            retVal = TRUE;
700a0308: 9001         	str	r0, [sp, #0x4]
;     if(NULL != args)
700a030a: 9805         	ldr	r0, [sp, #0x14]
700a030c: 2800         	cmp	r0, #0x0
700a030e: f000 80c8    	beq.w	0x700a04a2 <UART_lld_controllerIsr+0x1a2> @ imm = #0x190
700a0312: e7ff         	b	0x700a0314 <UART_lld_controllerIsr+0x14> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a0314: 9805         	ldr	r0, [sp, #0x14]
700a0316: 9002         	str	r0, [sp, #0x8]
;         while (retVal == TRUE)
700a0318: e7ff         	b	0x700a031a <UART_lld_controllerIsr+0x1a> @ imm = #-0x2
700a031a: 9801         	ldr	r0, [sp, #0x4]
700a031c: 2801         	cmp	r0, #0x1
700a031e: f040 80bf    	bne.w	0x700a04a0 <UART_lld_controllerIsr+0x1a0> @ imm = #0x17e
700a0322: e7ff         	b	0x700a0324 <UART_lld_controllerIsr+0x24> @ imm = #-0x2
;             intType = UART_getIntrIdentityStatus(hUart->baseAddr);
700a0324: 9802         	ldr	r0, [sp, #0x8]
700a0326: 6800         	ldr	r0, [r0]
700a0328: f00d f8ea    	bl	0x700ad500 <UART_getIntrIdentityStatus> @ imm = #0xd1d4
700a032c: 9004         	str	r0, [sp, #0x10]
;             if ((intType & UART_INTID_RX_THRES_REACH) == UART_INTID_RX_THRES_REACH)
700a032e: f89d 0010    	ldrb.w	r0, [sp, #0x10]
700a0332: 0740         	lsls	r0, r0, #0x1d
700a0334: 2800         	cmp	r0, #0x0
700a0336: d561         	bpl	0x700a03fc <UART_lld_controllerIsr+0xfc> @ imm = #0xc2
700a0338: e7ff         	b	0x700a033a <UART_lld_controllerIsr+0x3a> @ imm = #-0x2
;                 if ((intType & UART_INTID_RX_LINE_STAT_ERROR) ==
700a033a: 9804         	ldr	r0, [sp, #0x10]
700a033c: f000 0006    	and	r0, r0, #0x6
700a0340: 2806         	cmp	r0, #0x6
700a0342: d104         	bne	0x700a034e <UART_lld_controllerIsr+0x4e> @ imm = #0x8
700a0344: e7ff         	b	0x700a0346 <UART_lld_controllerIsr+0x46> @ imm = #-0x2
;                     (void)UART_procLineStatusErr(hUart);
700a0346: 9802         	ldr	r0, [sp, #0x8]
700a0348: f002 fb8a    	bl	0x700a2a60 <UART_procLineStatusErr> @ imm = #0x2714
;                 }
700a034c: e055         	b	0x700a03fa <UART_lld_controllerIsr+0xfa> @ imm = #0xaa
;                     if ((intType & UART_INTID_CHAR_TIMEOUT) == UART_INTID_CHAR_TIMEOUT)
700a034e: 9804         	ldr	r0, [sp, #0x10]
700a0350: f000 000c    	and	r0, r0, #0xc
700a0354: 280c         	cmp	r0, #0xc
700a0356: d10a         	bne	0x700a036e <UART_lld_controllerIsr+0x6e> @ imm = #0x14
700a0358: e7ff         	b	0x700a035a <UART_lld_controllerIsr+0x5a> @ imm = #-0x2
;                         UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a035a: 9802         	ldr	r0, [sp, #0x8]
700a035c: 6800         	ldr	r0, [r0]
700a035e: 2105         	movs	r1, #0x5
700a0360: f005 fffe    	bl	0x700a6360 <UART_intrDisable> @ imm = #0x5ffc
;                         hUart->rxTimeoutCnt++;
700a0364: 9902         	ldr	r1, [sp, #0x8]
700a0366: 6a08         	ldr	r0, [r1, #0x20]
700a0368: 3001         	adds	r0, #0x1
700a036a: 6208         	str	r0, [r1, #0x20]
;                     }
700a036c: e7ff         	b	0x700a036e <UART_lld_controllerIsr+0x6e> @ imm = #-0x2
;                     if (hUart->readSizeRemaining > 0U)
700a036e: 9802         	ldr	r0, [sp, #0x8]
700a0370: 69c0         	ldr	r0, [r0, #0x1c]
700a0372: b3a8         	cbz	r0, 0x700a03e0 <UART_lld_controllerIsr+0xe0> @ imm = #0x6a
700a0374: e7ff         	b	0x700a0376 <UART_lld_controllerIsr+0x76> @ imm = #-0x2
;                         hUart->readSizeRemaining = UART_readData(hUart, hUart->readSizeRemaining);
700a0376: 9802         	ldr	r0, [sp, #0x8]
700a0378: 69c1         	ldr	r1, [r0, #0x1c]
700a037a: f00a fc49    	bl	0x700aac10 <UART_readData> @ imm = #0xa892
700a037e: 9902         	ldr	r1, [sp, #0x8]
700a0380: 61c8         	str	r0, [r1, #0x1c]
;                         if ((hUart->readSizeRemaining == 0U) ||
700a0382: 9802         	ldr	r0, [sp, #0x8]
700a0384: 69c0         	ldr	r0, [r0, #0x1c]
700a0386: b130         	cbz	r0, 0x700a0396 <UART_lld_controllerIsr+0x96> @ imm = #0xc
700a0388: e7ff         	b	0x700a038a <UART_lld_controllerIsr+0x8a> @ imm = #-0x2
;                             (hUart->hUartInit->readReturnMode == UART_READ_RETURN_MODE_PARTIAL))
700a038a: 9802         	ldr	r0, [sp, #0x8]
700a038c: 6840         	ldr	r0, [r0, #0x4]
700a038e: 6940         	ldr	r0, [r0, #0x14]
;                         if ((hUart->readSizeRemaining == 0U) ||
700a0390: 2801         	cmp	r0, #0x1
700a0392: d11e         	bne	0x700a03d2 <UART_lld_controllerIsr+0xd2> @ imm = #0x3c
700a0394: e7ff         	b	0x700a0396 <UART_lld_controllerIsr+0x96> @ imm = #-0x2
;                             UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a0396: 9802         	ldr	r0, [sp, #0x8]
700a0398: 6800         	ldr	r0, [r0]
700a039a: 2105         	movs	r1, #0x5
700a039c: f005 ffe0    	bl	0x700a6360 <UART_intrDisable> @ imm = #0x5fc0
;                             hUart->readBuf = (uint8_t *)hUart->readBuf - hUart->readCount;
700a03a0: 9902         	ldr	r1, [sp, #0x8]
700a03a2: 6948         	ldr	r0, [r1, #0x14]
700a03a4: 698a         	ldr	r2, [r1, #0x18]
700a03a6: 1a80         	subs	r0, r0, r2
700a03a8: 6148         	str	r0, [r1, #0x14]
;                             if (hUart->readTrans.buf != NULL)
700a03aa: 9802         	ldr	r0, [sp, #0x8]
700a03ac: 6a80         	ldr	r0, [r0, #0x28]
700a03ae: b138         	cbz	r0, 0x700a03c0 <UART_lld_controllerIsr+0xc0> @ imm = #0xe
700a03b0: e7ff         	b	0x700a03b2 <UART_lld_controllerIsr+0xb2> @ imm = #-0x2
;                                 hUart->readTrans.count = (uint32_t)(hUart->readCount);
700a03b2: 9902         	ldr	r1, [sp, #0x8]
700a03b4: 6988         	ldr	r0, [r1, #0x18]
700a03b6: 62c8         	str	r0, [r1, #0x2c]
;                                 hUart->readTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a03b8: 9902         	ldr	r1, [sp, #0x8]
700a03ba: 2000         	movs	r0, #0x0
700a03bc: 6348         	str	r0, [r1, #0x34]
;                             }
700a03be: e7ff         	b	0x700a03c0 <UART_lld_controllerIsr+0xc0> @ imm = #-0x2
;                             hUart->hUartInit->readCompleteCallbackFxn(hUart);
700a03c0: 9802         	ldr	r0, [sp, #0x8]
700a03c2: 6841         	ldr	r1, [r0, #0x4]
700a03c4: 6dc9         	ldr	r1, [r1, #0x5c]
700a03c6: 4788         	blx	r1
;                             UART_lld_Transaction_deInit(&hUart->readTrans);
700a03c8: 9802         	ldr	r0, [sp, #0x8]
700a03ca: 3028         	adds	r0, #0x28
700a03cc: f00f f860    	bl	0x700af490 <UART_lld_Transaction_deInit> @ imm = #0xf0c0
;                         }
700a03d0: e005         	b	0x700a03de <UART_lld_controllerIsr+0xde> @ imm = #0xa
;                             UART_intrEnable(hUart->baseAddr, (uint32_t) UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a03d2: 9802         	ldr	r0, [sp, #0x8]
700a03d4: 6800         	ldr	r0, [r0]
700a03d6: 2105         	movs	r1, #0x5
700a03d8: f005 fee2    	bl	0x700a61a0 <UART_intrEnable> @ imm = #0x5dc4
700a03dc: e7ff         	b	0x700a03de <UART_lld_controllerIsr+0xde> @ imm = #-0x2
;                     }
700a03de: e00b         	b	0x700a03f8 <UART_lld_controllerIsr+0xf8> @ imm = #0x16
;                         (void)UART_getChar(hUart->baseAddr, &rdData);
700a03e0: 9802         	ldr	r0, [sp, #0x8]
700a03e2: 6800         	ldr	r0, [r0]
700a03e4: f10d 010f    	add.w	r1, sp, #0xf
700a03e8: f00b fff2    	bl	0x700ac3d0 <UART_getChar> @ imm = #0xbfe4
;                         UART_intrDisable(hUart->baseAddr, (uint32_t) UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a03ec: 9802         	ldr	r0, [sp, #0x8]
700a03ee: 6800         	ldr	r0, [r0]
700a03f0: 2105         	movs	r1, #0x5
700a03f2: f005 ffb5    	bl	0x700a6360 <UART_intrDisable> @ imm = #0x5f6a
700a03f6: e7ff         	b	0x700a03f8 <UART_lld_controllerIsr+0xf8> @ imm = #-0x2
700a03f8: e7ff         	b	0x700a03fa <UART_lld_controllerIsr+0xfa> @ imm = #-0x2
;             }
700a03fa: e050         	b	0x700a049e <UART_lld_controllerIsr+0x19e> @ imm = #0xa0
;             else if ((intType & UART_INTID_TX_THRES_REACH) == UART_INTID_TX_THRES_REACH)
700a03fc: f89d 0010    	ldrb.w	r0, [sp, #0x10]
700a0400: 0780         	lsls	r0, r0, #0x1e
700a0402: 2800         	cmp	r0, #0x0
700a0404: d534         	bpl	0x700a0470 <UART_lld_controllerIsr+0x170> @ imm = #0x68
700a0406: e7ff         	b	0x700a0408 <UART_lld_controllerIsr+0x108> @ imm = #-0x2
;                 if (hUart->writeSizeRemaining > 0U)
700a0408: 9802         	ldr	r0, [sp, #0x8]
700a040a: 6900         	ldr	r0, [r0, #0x10]
700a040c: b348         	cbz	r0, 0x700a0462 <UART_lld_controllerIsr+0x162> @ imm = #0x52
700a040e: e7ff         	b	0x700a0410 <UART_lld_controllerIsr+0x110> @ imm = #-0x2
;                     hUart->writeSizeRemaining = (uint32_t)UART_writeData(hUart, (hUart->writeSizeRemaining));
700a0410: 9802         	ldr	r0, [sp, #0x8]
700a0412: 6901         	ldr	r1, [r0, #0x10]
700a0414: f00c f80c    	bl	0x700ac430 <UART_writeData> @ imm = #0xc018
700a0418: 9902         	ldr	r1, [sp, #0x8]
700a041a: 6108         	str	r0, [r1, #0x10]
;                     if ((hUart->writeSizeRemaining) == 0U)
700a041c: 9802         	ldr	r0, [sp, #0x8]
700a041e: 6900         	ldr	r0, [r0, #0x10]
700a0420: b9f0         	cbnz	r0, 0x700a0460 <UART_lld_controllerIsr+0x160> @ imm = #0x3c
700a0422: e7ff         	b	0x700a0424 <UART_lld_controllerIsr+0x124> @ imm = #-0x2
;                         UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
700a0424: 9802         	ldr	r0, [sp, #0x8]
700a0426: 6800         	ldr	r0, [r0]
700a0428: 2102         	movs	r1, #0x2
700a042a: f005 ff99    	bl	0x700a6360 <UART_intrDisable> @ imm = #0x5f32
;                         hUart->writeBuf = (const void *)((uint8_t *)hUart->writeBuf - hUart->writeCount);
700a042e: 9902         	ldr	r1, [sp, #0x8]
700a0430: 6888         	ldr	r0, [r1, #0x8]
700a0432: 68ca         	ldr	r2, [r1, #0xc]
700a0434: 1a80         	subs	r0, r0, r2
700a0436: 6088         	str	r0, [r1, #0x8]
;                         if (hUart->writeTrans.buf != NULL)
700a0438: 9802         	ldr	r0, [sp, #0x8]
700a043a: 6bc0         	ldr	r0, [r0, #0x3c]
700a043c: b138         	cbz	r0, 0x700a044e <UART_lld_controllerIsr+0x14e> @ imm = #0xe
700a043e: e7ff         	b	0x700a0440 <UART_lld_controllerIsr+0x140> @ imm = #-0x2
;                             hUart->writeTrans.count = (uint32_t)(hUart->writeCount);
700a0440: 9902         	ldr	r1, [sp, #0x8]
700a0442: 68c8         	ldr	r0, [r1, #0xc]
700a0444: 6408         	str	r0, [r1, #0x40]
;                             hUart->writeTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a0446: 9902         	ldr	r1, [sp, #0x8]
700a0448: 2000         	movs	r0, #0x0
700a044a: 6488         	str	r0, [r1, #0x48]
;                         }
700a044c: e7ff         	b	0x700a044e <UART_lld_controllerIsr+0x14e> @ imm = #-0x2
;                         hUart->hUartInit->writeCompleteCallbackFxn(hUart);
700a044e: 9802         	ldr	r0, [sp, #0x8]
700a0450: 6841         	ldr	r1, [r0, #0x4]
700a0452: 6e09         	ldr	r1, [r1, #0x60]
700a0454: 4788         	blx	r1
;                         UART_lld_Transaction_deInit(&hUart->writeTrans);
700a0456: 9802         	ldr	r0, [sp, #0x8]
700a0458: 303c         	adds	r0, #0x3c
700a045a: f00f f819    	bl	0x700af490 <UART_lld_Transaction_deInit> @ imm = #0xf032
;                     }
700a045e: e7ff         	b	0x700a0460 <UART_lld_controllerIsr+0x160> @ imm = #-0x2
;                 }
700a0460: e005         	b	0x700a046e <UART_lld_controllerIsr+0x16e> @ imm = #0xa
;                     UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
700a0462: 9802         	ldr	r0, [sp, #0x8]
700a0464: 6800         	ldr	r0, [r0]
700a0466: 2102         	movs	r1, #0x2
700a0468: f005 ff7a    	bl	0x700a6360 <UART_intrDisable> @ imm = #0x5ef4
700a046c: e7ff         	b	0x700a046e <UART_lld_controllerIsr+0x16e> @ imm = #-0x2
;             }
700a046e: e015         	b	0x700a049c <UART_lld_controllerIsr+0x19c> @ imm = #0x2a
;             else if ((intType & UART_INTID_CHAR_TIMEOUT) == UART_INTID_CHAR_TIMEOUT)
700a0470: 9804         	ldr	r0, [sp, #0x10]
700a0472: f000 000c    	and	r0, r0, #0xc
700a0476: 280c         	cmp	r0, #0xc
700a0478: d10c         	bne	0x700a0494 <UART_lld_controllerIsr+0x194> @ imm = #0x18
700a047a: e7ff         	b	0x700a047c <UART_lld_controllerIsr+0x17c> @ imm = #-0x2
;                 if (FALSE == UART_checkCharsAvailInFifo(hUart->baseAddr))
700a047c: 9802         	ldr	r0, [sp, #0x8]
700a047e: 6800         	ldr	r0, [r0]
700a0480: f00c fe86    	bl	0x700ad190 <UART_checkCharsAvailInFifo> @ imm = #0xcd0c
700a0484: b928         	cbnz	r0, 0x700a0492 <UART_lld_controllerIsr+0x192> @ imm = #0xa
700a0486: e7ff         	b	0x700a0488 <UART_lld_controllerIsr+0x188> @ imm = #-0x2
;                     UART_i2310WA(hUart->baseAddr);
700a0488: 9802         	ldr	r0, [sp, #0x8]
700a048a: 6800         	ldr	r0, [r0]
700a048c: f00d fd00    	bl	0x700ade90 <UART_i2310WA> @ imm = #0xda00
;                 }
700a0490: e7ff         	b	0x700a0492 <UART_lld_controllerIsr+0x192> @ imm = #-0x2
;             }
700a0492: e002         	b	0x700a049a <UART_lld_controllerIsr+0x19a> @ imm = #0x4
700a0494: 2000         	movs	r0, #0x0
;                 retVal = FALSE;
700a0496: 9001         	str	r0, [sp, #0x4]
700a0498: e7ff         	b	0x700a049a <UART_lld_controllerIsr+0x19a> @ imm = #-0x2
700a049a: e7ff         	b	0x700a049c <UART_lld_controllerIsr+0x19c> @ imm = #-0x2
700a049c: e7ff         	b	0x700a049e <UART_lld_controllerIsr+0x19e> @ imm = #-0x2
;         while (retVal == TRUE)
700a049e: e73c         	b	0x700a031a <UART_lld_controllerIsr+0x1a> @ imm = #-0x188
;     }
700a04a0: e000         	b	0x700a04a4 <UART_lld_controllerIsr+0x1a4> @ imm = #0x0
700a04a2: e7ff         	b	0x700a04a4 <UART_lld_controllerIsr+0x1a4> @ imm = #-0x2
; }
700a04a4: b006         	add	sp, #0x18
700a04a6: bd80         	pop	{r7, pc}
		...

700a04b0 <UART_write>:
; {
700a04b0: b580         	push	{r7, lr}
700a04b2: b08e         	sub	sp, #0x38
700a04b4: 900d         	str	r0, [sp, #0x34]
700a04b6: 910c         	str	r1, [sp, #0x30]
700a04b8: 2000         	movs	r0, #0x0
;     int32_t             status = SystemP_SUCCESS, semStatus = SystemP_SUCCESS;
700a04ba: 900b         	str	r0, [sp, #0x2c]
700a04bc: 900a         	str	r0, [sp, #0x28]
;     if ((NULL_PTR == handle) || (NULL_PTR == trans))
700a04be: 980d         	ldr	r0, [sp, #0x34]
700a04c0: b118         	cbz	r0, 0x700a04ca <UART_write+0x1a> @ imm = #0x6
700a04c2: e7ff         	b	0x700a04c4 <UART_write+0x14> @ imm = #-0x2
700a04c4: 980c         	ldr	r0, [sp, #0x30]
700a04c6: b920         	cbnz	r0, 0x700a04d2 <UART_write+0x22> @ imm = #0x8
700a04c8: e7ff         	b	0x700a04ca <UART_write+0x1a> @ imm = #-0x2
700a04ca: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700a04ce: 900b         	str	r0, [sp, #0x2c]
;     }
700a04d0: e7ff         	b	0x700a04d2 <UART_write+0x22> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
700a04d2: 980b         	ldr	r0, [sp, #0x2c]
700a04d4: 2800         	cmp	r0, #0x0
700a04d6: d141         	bne	0x700a055c <UART_write+0xac> @ imm = #0x82
700a04d8: e7ff         	b	0x700a04da <UART_write+0x2a> @ imm = #-0x2
;         config  = (UART_Config *) handle;
700a04da: 980d         	ldr	r0, [sp, #0x34]
700a04dc: 9009         	str	r0, [sp, #0x24]
;         object  = config->object;
700a04de: 9809         	ldr	r0, [sp, #0x24]
700a04e0: 6840         	ldr	r0, [r0, #0x4]
700a04e2: 9008         	str	r0, [sp, #0x20]
;         attrs   = config->attrs;
700a04e4: 9809         	ldr	r0, [sp, #0x24]
700a04e6: 6800         	ldr	r0, [r0]
700a04e8: 9007         	str	r0, [sp, #0x1c]
;         prms    = &config->object->prms;
700a04ea: 9809         	ldr	r0, [sp, #0x24]
700a04ec: 6840         	ldr	r0, [r0, #0x4]
700a04ee: 3004         	adds	r0, #0x4
700a04f0: 9006         	str	r0, [sp, #0x18]
;         uartLld_handle = object->uartLld_handle;
700a04f2: 9808         	ldr	r0, [sp, #0x20]
700a04f4: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a04f8: 9004         	str	r0, [sp, #0x10]
;         object->writeTrans = trans;
700a04fa: 980c         	ldr	r0, [sp, #0x30]
700a04fc: 9908         	ldr	r1, [sp, #0x20]
700a04fe: f8c1 0080    	str.w	r0, [r1, #0x80]
;         DebugP_assert(NULL_PTR != object);
700a0502: 9808         	ldr	r0, [sp, #0x20]
700a0504: 2800         	cmp	r0, #0x0
700a0506: bf18         	it	ne
700a0508: 2001         	movne	r0, #0x1
700a050a: f641 71ce    	movw	r1, #0x1fce
700a050e: f2c7 010b    	movt	r1, #0x700b
700a0512: 466a         	mov	r2, sp
700a0514: 6011         	str	r1, [r2]
700a0516: f641 71e1    	movw	r1, #0x1fe1
700a051a: f2c7 010b    	movt	r1, #0x700b
700a051e: 9101         	str	r1, [sp, #0x4]
700a0520: f242 123b    	movw	r2, #0x213b
700a0524: f2c7 020b    	movt	r2, #0x700b
700a0528: 9202         	str	r2, [sp, #0x8]
700a052a: f44f 7305    	mov.w	r3, #0x214
700a052e: f00a fbaf    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xa75e
700a0532: 9901         	ldr	r1, [sp, #0x4]
700a0534: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != attrs);
700a0536: 9807         	ldr	r0, [sp, #0x1c]
700a0538: 2800         	cmp	r0, #0x0
700a053a: bf18         	it	ne
700a053c: 2001         	movne	r0, #0x1
700a053e: f242 0329    	movw	r3, #0x2029
700a0542: f2c7 030b    	movt	r3, #0x700b
700a0546: 46ec         	mov	r12, sp
700a0548: f8cc 3000    	str.w	r3, [r12]
700a054c: f240 2315    	movw	r3, #0x215
700a0550: f00a fb9e    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xa73c
;         extendedParams.args = trans->args;
700a0554: 980c         	ldr	r0, [sp, #0x30]
700a0556: 6900         	ldr	r0, [r0, #0x10]
700a0558: 9003         	str	r0, [sp, #0xc]
;     }
700a055a: e7ff         	b	0x700a055c <UART_write+0xac> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
700a055c: 980b         	ldr	r0, [sp, #0x2c]
700a055e: b950         	cbnz	r0, 0x700a0576 <UART_write+0xc6> @ imm = #0x14
700a0560: e7ff         	b	0x700a0562 <UART_write+0xb2> @ imm = #-0x2
;         if (TRUE == prms->skipIntrReg)
700a0562: 9806         	ldr	r0, [sp, #0x18]
700a0564: 6b80         	ldr	r0, [r0, #0x38]
700a0566: 2801         	cmp	r0, #0x1
700a0568: d104         	bne	0x700a0574 <UART_write+0xc4> @ imm = #0x8
700a056a: e7ff         	b	0x700a056c <UART_write+0xbc> @ imm = #-0x2
700a056c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
700a0570: 900b         	str	r0, [sp, #0x2c]
;         }
700a0572: e7ff         	b	0x700a0574 <UART_write+0xc4> @ imm = #-0x2
;     }
700a0574: e7ff         	b	0x700a0576 <UART_write+0xc6> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
700a0576: 980b         	ldr	r0, [sp, #0x2c]
700a0578: 2800         	cmp	r0, #0x0
700a057a: d168         	bne	0x700a064e <UART_write+0x19e> @ imm = #0xd0
700a057c: e7ff         	b	0x700a057e <UART_write+0xce> @ imm = #-0x2
;         key = HwiP_disable();
700a057e: f010 e9f0    	blx	0x700b0960 <HwiP_disable> @ imm = #0x103e0
700a0582: 9005         	str	r0, [sp, #0x14]
;         HwiP_restore(key);
700a0584: 9805         	ldr	r0, [sp, #0x14]
700a0586: f010 ea0c    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x10418
;         uartLld_handle->state = UART_STATE_READY;
700a058a: 9904         	ldr	r1, [sp, #0x10]
700a058c: 2001         	movs	r0, #0x1
700a058e: 6548         	str	r0, [r1, #0x54]
;         if ((UART_CONFIG_MODE_INTERRUPT == prms->transferMode) ||
700a0590: 9806         	ldr	r0, [sp, #0x18]
700a0592: 6ac0         	ldr	r0, [r0, #0x2c]
700a0594: 2801         	cmp	r0, #0x1
700a0596: d005         	beq	0x700a05a4 <UART_write+0xf4> @ imm = #0xa
700a0598: e7ff         	b	0x700a059a <UART_write+0xea> @ imm = #-0x2
;             (UART_CONFIG_MODE_DMA == prms->transferMode))
700a059a: 9806         	ldr	r0, [sp, #0x18]
700a059c: 6ac0         	ldr	r0, [r0, #0x2c]
;         if ((UART_CONFIG_MODE_INTERRUPT == prms->transferMode) ||
700a059e: 2803         	cmp	r0, #0x3
700a05a0: d146         	bne	0x700a0630 <UART_write+0x180> @ imm = #0x8c
700a05a2: e7ff         	b	0x700a05a4 <UART_write+0xf4> @ imm = #-0x2
;             if (UART_CONFIG_MODE_INTERRUPT == prms->transferMode)
700a05a4: 9806         	ldr	r0, [sp, #0x18]
700a05a6: 6ac0         	ldr	r0, [r0, #0x2c]
700a05a8: 2801         	cmp	r0, #0x1
700a05aa: d109         	bne	0x700a05c0 <UART_write+0x110> @ imm = #0x12
700a05ac: e7ff         	b	0x700a05ae <UART_write+0xfe> @ imm = #-0x2
;                 status = UART_lld_writeIntr(uartLld_handle, trans->buf, trans->count, &extendedParams);
700a05ae: 9804         	ldr	r0, [sp, #0x10]
700a05b0: 9a0c         	ldr	r2, [sp, #0x30]
700a05b2: 6811         	ldr	r1, [r2]
700a05b4: 6852         	ldr	r2, [r2, #0x4]
700a05b6: ab03         	add	r3, sp, #0xc
700a05b8: f006 fe02    	bl	0x700a71c0 <UART_lld_writeIntr> @ imm = #0x6c04
700a05bc: 900b         	str	r0, [sp, #0x2c]
;             }
700a05be: e008         	b	0x700a05d2 <UART_write+0x122> @ imm = #0x10
;                 status = UART_lld_writeDma(uartLld_handle, trans->buf, trans->count, &extendedParams);
700a05c0: 9804         	ldr	r0, [sp, #0x10]
700a05c2: 9a0c         	ldr	r2, [sp, #0x30]
700a05c4: 6811         	ldr	r1, [r2]
700a05c6: 6852         	ldr	r2, [r2, #0x4]
700a05c8: ab03         	add	r3, sp, #0xc
700a05ca: f006 fc59    	bl	0x700a6e80 <UART_lld_writeDma> @ imm = #0x68b2
700a05ce: 900b         	str	r0, [sp, #0x2c]
700a05d0: e7ff         	b	0x700a05d2 <UART_write+0x122> @ imm = #-0x2
;             if (SystemP_SUCCESS == status)
700a05d2: 980b         	ldr	r0, [sp, #0x2c]
700a05d4: bb58         	cbnz	r0, 0x700a062e <UART_write+0x17e> @ imm = #0x56
700a05d6: e7ff         	b	0x700a05d8 <UART_write+0x128> @ imm = #-0x2
;                 if(object->prms.writeMode == UART_TRANSFER_MODE_BLOCKING)
700a05d8: 9808         	ldr	r0, [sp, #0x20]
700a05da: 69c0         	ldr	r0, [r0, #0x1c]
700a05dc: bb18         	cbnz	r0, 0x700a0626 <UART_write+0x176> @ imm = #0x46
700a05de: e7ff         	b	0x700a05e0 <UART_write+0x130> @ imm = #-0x2
;                     semStatus = SemaphoreP_pend(&object->writeTransferSemObj, trans->timeout);
700a05e0: 9808         	ldr	r0, [sp, #0x20]
700a05e2: f500 70e2    	add.w	r0, r0, #0x1c4
700a05e6: 990c         	ldr	r1, [sp, #0x30]
700a05e8: 6889         	ldr	r1, [r1, #0x8]
700a05ea: f00a f8f9    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0xa1f2
700a05ee: 900a         	str	r0, [sp, #0x28]
;                     if (semStatus == SystemP_SUCCESS)
700a05f0: 980a         	ldr	r0, [sp, #0x28]
700a05f2: b960         	cbnz	r0, 0x700a060e <UART_write+0x15e> @ imm = #0x18
700a05f4: e7ff         	b	0x700a05f6 <UART_write+0x146> @ imm = #-0x2
;                         if (trans->status == (uint32_t)UART_STATUS_SUCCESS)
700a05f6: 980c         	ldr	r0, [sp, #0x30]
700a05f8: 68c0         	ldr	r0, [r0, #0xc]
700a05fa: b918         	cbnz	r0, 0x700a0604 <UART_write+0x154> @ imm = #0x6
700a05fc: e7ff         	b	0x700a05fe <UART_write+0x14e> @ imm = #-0x2
700a05fe: 2000         	movs	r0, #0x0
;                             status = SystemP_SUCCESS;
700a0600: 900b         	str	r0, [sp, #0x2c]
;                         }
700a0602: e003         	b	0x700a060c <UART_write+0x15c> @ imm = #0x6
700a0604: f04f 30ff    	mov.w	r0, #0xffffffff
;                             status = SystemP_FAILURE;
700a0608: 900b         	str	r0, [sp, #0x2c]
700a060a: e7ff         	b	0x700a060c <UART_write+0x15c> @ imm = #-0x2
;                     }
700a060c: e00a         	b	0x700a0624 <UART_write+0x174> @ imm = #0x14
;                         trans->status = UART_TRANSFER_TIMEOUT;
700a060e: 990c         	ldr	r1, [sp, #0x30]
700a0610: f06f 0001    	mvn	r0, #0x1
700a0614: 60c8         	str	r0, [r1, #0xc]
;                         (void)UART_writeCancelNoCB(uartLld_handle);
700a0616: 9804         	ldr	r0, [sp, #0x10]
700a0618: f009 fd82    	bl	0x700aa120 <UART_writeCancelNoCB> @ imm = #0x9b04
700a061c: f04f 30ff    	mov.w	r0, #0xffffffff
;                         status = SystemP_FAILURE;
700a0620: 900b         	str	r0, [sp, #0x2c]
700a0622: e7ff         	b	0x700a0624 <UART_write+0x174> @ imm = #-0x2
;                 }
700a0624: e002         	b	0x700a062c <UART_write+0x17c> @ imm = #0x4
700a0626: 2000         	movs	r0, #0x0
;                     status = SystemP_SUCCESS;
700a0628: 900b         	str	r0, [sp, #0x2c]
700a062a: e7ff         	b	0x700a062c <UART_write+0x17c> @ imm = #-0x2
;             }
700a062c: e7ff         	b	0x700a062e <UART_write+0x17e> @ imm = #-0x2
;         }
700a062e: e00d         	b	0x700a064c <UART_write+0x19c> @ imm = #0x1a
;             status = UART_lld_write(uartLld_handle, trans->buf, trans->count, trans->timeout, &extendedParams);
700a0630: 9804         	ldr	r0, [sp, #0x10]
700a0632: 9b0c         	ldr	r3, [sp, #0x30]
700a0634: 6819         	ldr	r1, [r3]
700a0636: 685a         	ldr	r2, [r3, #0x4]
700a0638: 689b         	ldr	r3, [r3, #0x8]
700a063a: 46ee         	mov	lr, sp
700a063c: f10d 0c0c    	add.w	r12, sp, #0xc
700a0640: f8ce c000    	str.w	r12, [lr]
700a0644: f006 f92c    	bl	0x700a68a0 <UART_lld_write> @ imm = #0x6258
700a0648: 900b         	str	r0, [sp, #0x2c]
700a064a: e7ff         	b	0x700a064c <UART_write+0x19c> @ imm = #-0x2
;     }
700a064c: e7ff         	b	0x700a064e <UART_write+0x19e> @ imm = #-0x2
;     return (status);
700a064e: 980b         	ldr	r0, [sp, #0x2c]
700a0650: b00e         	add	sp, #0x38
700a0652: bd80         	pop	{r7, pc}
		...

700a0660 <Sciclient_rmClearInterruptRoute>:
; {
700a0660: b580         	push	{r7, lr}
700a0662: b08e         	sub	sp, #0x38
700a0664: 900d         	str	r0, [sp, #0x34]
700a0666: 910c         	str	r1, [sp, #0x30]
700a0668: 920b         	str	r2, [sp, #0x2c]
700a066a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a066c: 9001         	str	r0, [sp, #0x4]
700a066e: 900a         	str	r0, [sp, #0x28]
700a0670: f241 0101    	movw	r1, #0x1001
;     uint16_t messageType = TISCI_MSG_RM_IRQ_RELEASE;
700a0674: f8ad 1026    	strh.w	r1, [sp, #0x26]
;     memset(&cfg, 0, sizeof(cfg));
700a0678: 9008         	str	r0, [sp, #0x20]
700a067a: 9007         	str	r0, [sp, #0x1c]
700a067c: 9006         	str	r0, [sp, #0x18]
700a067e: 9005         	str	r0, [sp, #0x14]
700a0680: 9004         	str	r0, [sp, #0x10]
700a0682: 9003         	str	r0, [sp, #0xc]
700a0684: 9002         	str	r0, [sp, #0x8]
;     if((req == NULL) || (resp == NULL)) {
700a0686: 980d         	ldr	r0, [sp, #0x34]
700a0688: b118         	cbz	r0, 0x700a0692 <Sciclient_rmClearInterruptRoute+0x32> @ imm = #0x6
700a068a: e7ff         	b	0x700a068c <Sciclient_rmClearInterruptRoute+0x2c> @ imm = #-0x2
700a068c: 980c         	ldr	r0, [sp, #0x30]
700a068e: b920         	cbnz	r0, 0x700a069a <Sciclient_rmClearInterruptRoute+0x3a> @ imm = #0x8
700a0690: e7ff         	b	0x700a0692 <Sciclient_rmClearInterruptRoute+0x32> @ imm = #-0x2
700a0692: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a0696: 900a         	str	r0, [sp, #0x28]
;     }
700a0698: e7ff         	b	0x700a069a <Sciclient_rmClearInterruptRoute+0x3a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a069a: 980a         	ldr	r0, [sp, #0x28]
700a069c: b968         	cbnz	r0, 0x700a06ba <Sciclient_rmClearInterruptRoute+0x5a> @ imm = #0x1a
700a069e: e7ff         	b	0x700a06a0 <Sciclient_rmClearInterruptRoute+0x40> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a06a0: 980d         	ldr	r0, [sp, #0x34]
700a06a2: 6880         	ldr	r0, [r0, #0x8]
700a06a4: f04f 4100    	mov.w	r1, #0x80000000
700a06a8: f00e fb32    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0xe664
;     if (r == SystemP_SUCCESS &&
700a06ac: b128         	cbz	r0, 0x700a06ba <Sciclient_rmClearInterruptRoute+0x5a> @ imm = #0xa
700a06ae: e7ff         	b	0x700a06b0 <Sciclient_rmClearInterruptRoute+0x50> @ imm = #-0x2
;         dst_host = req->secondary_host;
700a06b0: 980d         	ldr	r0, [sp, #0x34]
700a06b2: 7ec0         	ldrb	r0, [r0, #0x1b]
700a06b4: f88d 0025    	strb.w	r0, [sp, #0x25]
;     } else {
700a06b8: e00f         	b	0x700a06da <Sciclient_rmClearInterruptRoute+0x7a> @ imm = #0x1e
;         dst_host = (uint8_t) gSciclientMap[Sciclient_getCurrentContext(messageType)].hostId;
700a06ba: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
700a06be: f007 fa87    	bl	0x700a7bd0 <Sciclient_getCurrentContext> @ imm = #0x750e
700a06c2: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a06c6: f241 3060    	movw	r0, #0x1360
700a06ca: f2c7 000b    	movt	r0, #0x700b
700a06ce: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a06d2: 6840         	ldr	r0, [r0, #0x4]
700a06d4: f88d 0025    	strb.w	r0, [sp, #0x25]
700a06d8: e7ff         	b	0x700a06da <Sciclient_rmClearInterruptRoute+0x7a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a06da: 980a         	ldr	r0, [sp, #0x28]
700a06dc: b960         	cbnz	r0, 0x700a06f8 <Sciclient_rmClearInterruptRoute+0x98> @ imm = #0x18
700a06de: e7ff         	b	0x700a06e0 <Sciclient_rmClearInterruptRoute+0x80> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a06e0: 980d         	ldr	r0, [sp, #0x34]
700a06e2: 6880         	ldr	r0, [r0, #0x8]
700a06e4: 2104         	movs	r1, #0x4
700a06e6: f00e fb13    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0xe626
;     if (r == SystemP_SUCCESS &&
700a06ea: b128         	cbz	r0, 0x700a06f8 <Sciclient_rmClearInterruptRoute+0x98> @ imm = #0xa
700a06ec: e7ff         	b	0x700a06ee <Sciclient_rmClearInterruptRoute+0x8e> @ imm = #-0x2
;         cfg.s_ia = req->ia_id;
700a06ee: 980d         	ldr	r0, [sp, #0x34]
700a06f0: 8a80         	ldrh	r0, [r0, #0x14]
700a06f2: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     } else {
700a06f6: e003         	b	0x700a0700 <Sciclient_rmClearInterruptRoute+0xa0> @ imm = #0x6
700a06f8: 20ff         	movs	r0, #0xff
;         cfg.s_ia = SCICLIENT_RM_DEV_NONE;
700a06fa: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a06fe: e7ff         	b	0x700a0700 <Sciclient_rmClearInterruptRoute+0xa0> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a0700: 980a         	ldr	r0, [sp, #0x28]
700a0702: 2800         	cmp	r0, #0x0
700a0704: d175         	bne	0x700a07f2 <Sciclient_rmClearInterruptRoute+0x192> @ imm = #0xea
700a0706: e7ff         	b	0x700a0708 <Sciclient_rmClearInterruptRoute+0xa8> @ imm = #-0x2
;         cfg.valid_params = req->valid_params;
700a0708: 980d         	ldr	r0, [sp, #0x34]
700a070a: 6880         	ldr	r0, [r0, #0x8]
700a070c: 9002         	str	r0, [sp, #0x8]
;         cfg.host = dst_host;
700a070e: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a0712: f88d 000c    	strb.w	r0, [sp, #0xc]
;         cfg.s_id = req->src_id;
700a0716: 980d         	ldr	r0, [sp, #0x34]
700a0718: 8980         	ldrh	r0, [r0, #0xc]
700a071a: f8ad 000e    	strh.w	r0, [sp, #0xe]
;         cfg.s_idx = req->src_index;
700a071e: 980d         	ldr	r0, [sp, #0x34]
700a0720: 89c0         	ldrh	r0, [r0, #0xe]
700a0722: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         cfg.d_id = req->dst_id;
700a0726: 980d         	ldr	r0, [sp, #0x34]
700a0728: 8a00         	ldrh	r0, [r0, #0x10]
700a072a: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         cfg.d_irq = req->dst_host_irq;
700a072e: 980d         	ldr	r0, [sp, #0x34]
700a0730: 8a40         	ldrh	r0, [r0, #0x12]
700a0732: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         cfg.global_evt = req->global_event;
700a0736: 980d         	ldr	r0, [sp, #0x34]
700a0738: 8b00         	ldrh	r0, [r0, #0x18]
700a073a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         cfg.vint = req->vint;
700a073e: 980d         	ldr	r0, [sp, #0x34]
700a0740: 8ac0         	ldrh	r0, [r0, #0x16]
700a0742: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         cfg.vint_sb = req->vint_status_bit_index;
700a0746: 980d         	ldr	r0, [sp, #0x34]
700a0748: 7e80         	ldrb	r0, [r0, #0x1a]
700a074a: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         if (Sciclient_rmIrqCfgIsDirectNonEvent(cfg.valid_params) == true) {
700a074e: 9802         	ldr	r0, [sp, #0x8]
700a0750: f00b f8c6    	bl	0x700ab8e0 <Sciclient_rmIrqCfgIsDirectNonEvent> @ imm = #0xb18c
700a0754: b310         	cbz	r0, 0x700a079c <Sciclient_rmClearInterruptRoute+0x13c> @ imm = #0x44
700a0756: e7ff         	b	0x700a0758 <Sciclient_rmClearInterruptRoute+0xf8> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cfg.s_id) == true) {
700a0758: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a075c: f00e f8e0    	bl	0x700ae920 <Sciclient_rmIaIsIa> @ imm = #0xe1c0
700a0760: b168         	cbz	r0, 0x700a077e <Sciclient_rmClearInterruptRoute+0x11e> @ imm = #0x1a
700a0762: e7ff         	b	0x700a0764 <Sciclient_rmClearInterruptRoute+0x104> @ imm = #-0x2
;                 cfg.s_ia = cfg.s_id;
700a0764: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a0768: f8ad 0018    	strh.w	r0, [sp, #0x18]
;                 cfg.vint = cfg.s_idx;
700a076c: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a0770: f8ad 001a    	strh.w	r0, [sp, #0x1a]
700a0774: a802         	add	r0, sp, #0x8
;                 r = Sciclient_rmIrqUnmappedVintRouteDelete(&cfg);
700a0776: f00c f89b    	bl	0x700ac8b0 <Sciclient_rmIrqUnmappedVintRouteDelete> @ imm = #0xc136
700a077a: 900a         	str	r0, [sp, #0x28]
;             } else {
700a077c: e00d         	b	0x700a079a <Sciclient_rmClearInterruptRoute+0x13a> @ imm = #0x1a
700a077e: a802         	add	r0, sp, #0x8
;                 r = Sciclient_rmIrqGetRoute(&cfg);
700a0780: f7fc fab6    	bl	0x7009ccf0 <Sciclient_rmIrqGetRoute> @ imm = #-0x3a94
700a0784: 900a         	str	r0, [sp, #0x28]
;                 if (r == SystemP_SUCCESS) {
700a0786: 980a         	ldr	r0, [sp, #0x28]
700a0788: b930         	cbnz	r0, 0x700a0798 <Sciclient_rmClearInterruptRoute+0x138> @ imm = #0xc
700a078a: e7ff         	b	0x700a078c <Sciclient_rmClearInterruptRoute+0x12c> @ imm = #-0x2
700a078c: a802         	add	r0, sp, #0x8
700a078e: 2100         	movs	r1, #0x0
;                     r = Sciclient_rmIrqDeleteRoute(&cfg, false);
700a0790: f000 f9ce    	bl	0x700a0b30 <Sciclient_rmIrqDeleteRoute> @ imm = #0x39c
700a0794: 900a         	str	r0, [sp, #0x28]
;                 }
700a0796: e7ff         	b	0x700a0798 <Sciclient_rmClearInterruptRoute+0x138> @ imm = #-0x2
700a0798: e7ff         	b	0x700a079a <Sciclient_rmClearInterruptRoute+0x13a> @ imm = #-0x2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a079a: e029         	b	0x700a07f0 <Sciclient_rmClearInterruptRoute+0x190> @ imm = #0x52
700a079c: 9802         	ldr	r0, [sp, #0x8]
700a079e: f00b f867    	bl	0x700ab870 <Sciclient_rmIrqCfgIsDirectEvent> @ imm = #0xb0ce
;                 true) ||
700a07a2: b928         	cbnz	r0, 0x700a07b0 <Sciclient_rmClearInterruptRoute+0x150> @ imm = #0xa
700a07a4: e7ff         	b	0x700a07a6 <Sciclient_rmClearInterruptRoute+0x146> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg.valid_params) ==
700a07a6: 9802         	ldr	r0, [sp, #0x8]
700a07a8: f00b f8d2    	bl	0x700ab950 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0xb1a4
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a07ac: b128         	cbz	r0, 0x700a07ba <Sciclient_rmClearInterruptRoute+0x15a> @ imm = #0xa
700a07ae: e7ff         	b	0x700a07b0 <Sciclient_rmClearInterruptRoute+0x150> @ imm = #-0x2
700a07b0: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqVintDelete(&cfg);
700a07b2: f002 fb35    	bl	0x700a2e20 <Sciclient_rmIrqVintDelete> @ imm = #0x266a
700a07b6: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsUnmappedVintDirectEvent(cfg.valid_params) ==
700a07b8: e019         	b	0x700a07ee <Sciclient_rmClearInterruptRoute+0x18e> @ imm = #0x32
700a07ba: 9802         	ldr	r0, [sp, #0x8]
700a07bc: f00b f938    	bl	0x700aba30 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent> @ imm = #0xb270
700a07c0: b128         	cbz	r0, 0x700a07ce <Sciclient_rmClearInterruptRoute+0x16e> @ imm = #0xa
700a07c2: e7ff         	b	0x700a07c4 <Sciclient_rmClearInterruptRoute+0x164> @ imm = #-0x2
700a07c4: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqUnmappedVintRouteDelete(&cfg);
700a07c6: f00c f873    	bl	0x700ac8b0 <Sciclient_rmIrqUnmappedVintRouteDelete> @ imm = #0xc0e6
700a07ca: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsOesOnly(cfg.valid_params) == true) {
700a07cc: e00e         	b	0x700a07ec <Sciclient_rmClearInterruptRoute+0x18c> @ imm = #0x1c
700a07ce: 9802         	ldr	r0, [sp, #0x8]
700a07d0: f00b f8f6    	bl	0x700ab9c0 <Sciclient_rmIrqCfgIsOesOnly> @ imm = #0xb1ec
700a07d4: b128         	cbz	r0, 0x700a07e2 <Sciclient_rmClearInterruptRoute+0x182> @ imm = #0xa
700a07d6: e7ff         	b	0x700a07d8 <Sciclient_rmClearInterruptRoute+0x178> @ imm = #-0x2
700a07d8: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqClearOesRegister(&cfg);
700a07da: f00d fc19    	bl	0x700ae010 <Sciclient_rmIrqClearOesRegister> @ imm = #0xd832
700a07de: 900a         	str	r0, [sp, #0x28]
;         } else {
700a07e0: e003         	b	0x700a07ea <Sciclient_rmClearInterruptRoute+0x18a> @ imm = #0x6
700a07e2: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a07e6: 900a         	str	r0, [sp, #0x28]
700a07e8: e7ff         	b	0x700a07ea <Sciclient_rmClearInterruptRoute+0x18a> @ imm = #-0x2
700a07ea: e7ff         	b	0x700a07ec <Sciclient_rmClearInterruptRoute+0x18c> @ imm = #-0x2
700a07ec: e7ff         	b	0x700a07ee <Sciclient_rmClearInterruptRoute+0x18e> @ imm = #-0x2
700a07ee: e7ff         	b	0x700a07f0 <Sciclient_rmClearInterruptRoute+0x190> @ imm = #-0x2
;     }
700a07f0: e7ff         	b	0x700a07f2 <Sciclient_rmClearInterruptRoute+0x192> @ imm = #-0x2
;     return r;
700a07f2: 980a         	ldr	r0, [sp, #0x28]
700a07f4: b00e         	add	sp, #0x38
700a07f6: bd80         	pop	{r7, pc}
		...

700a0800 <Udma_chConfigTx>:
; {
700a0800: b580         	push	{r7, lr}
700a0802: b090         	sub	sp, #0x40
700a0804: 900f         	str	r0, [sp, #0x3c]
700a0806: 910e         	str	r1, [sp, #0x38]
700a0808: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
700a080a: 900d         	str	r0, [sp, #0x34]
;     Udma_ChHandleInt        chHandleInt = (Udma_ChHandleInt) chHandle;
700a080c: 980f         	ldr	r0, [sp, #0x3c]
700a080e: 900b         	str	r0, [sp, #0x2c]
;     if((NULL_PTR == chHandleInt) ||
700a0810: 980b         	ldr	r0, [sp, #0x2c]
700a0812: b178         	cbz	r0, 0x700a0834 <Udma_chConfigTx+0x34> @ imm = #0x1e
700a0814: e7ff         	b	0x700a0816 <Udma_chConfigTx+0x16> @ imm = #-0x2
;        (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
700a0816: 980b         	ldr	r0, [sp, #0x2c]
700a0818: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a081c: f64a 31cd    	movw	r1, #0xabcd
700a0820: f6ca 31dc    	movt	r1, #0xabdc
700a0824: 4288         	cmp	r0, r1
700a0826: d105         	bne	0x700a0834 <Udma_chConfigTx+0x34> @ imm = #0xa
700a0828: e7ff         	b	0x700a082a <Udma_chConfigTx+0x2a> @ imm = #-0x2
;        ((chHandleInt->chType & UDMA_CH_FLAG_TX) != UDMA_CH_FLAG_TX))
700a082a: 980b         	ldr	r0, [sp, #0x2c]
;     if((NULL_PTR == chHandleInt) ||
700a082c: 7800         	ldrb	r0, [r0]
700a082e: 07c0         	lsls	r0, r0, #0x1f
700a0830: b920         	cbnz	r0, 0x700a083c <Udma_chConfigTx+0x3c> @ imm = #0x8
700a0832: e7ff         	b	0x700a0834 <Udma_chConfigTx+0x34> @ imm = #-0x2
700a0834: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a0838: 900d         	str	r0, [sp, #0x34]
;     }
700a083a: e7ff         	b	0x700a083c <Udma_chConfigTx+0x3c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a083c: 980d         	ldr	r0, [sp, #0x34]
700a083e: b9a8         	cbnz	r0, 0x700a086c <Udma_chConfigTx+0x6c> @ imm = #0x2a
700a0840: e7ff         	b	0x700a0842 <Udma_chConfigTx+0x42> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a0842: 980b         	ldr	r0, [sp, #0x2c]
700a0844: 6e80         	ldr	r0, [r0, #0x68]
700a0846: 900c         	str	r0, [sp, #0x30]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a0848: 980c         	ldr	r0, [sp, #0x30]
700a084a: b150         	cbz	r0, 0x700a0862 <Udma_chConfigTx+0x62> @ imm = #0x14
700a084c: e7ff         	b	0x700a084e <Udma_chConfigTx+0x4e> @ imm = #-0x2
700a084e: 980c         	ldr	r0, [sp, #0x30]
700a0850: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a0854: f64a 31cd    	movw	r1, #0xabcd
700a0858: f6ca 31dc    	movt	r1, #0xabdc
700a085c: 4288         	cmp	r0, r1
700a085e: d004         	beq	0x700a086a <Udma_chConfigTx+0x6a> @ imm = #0x8
700a0860: e7ff         	b	0x700a0862 <Udma_chConfigTx+0x62> @ imm = #-0x2
700a0862: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a0866: 900d         	str	r0, [sp, #0x34]
;         }
700a0868: e7ff         	b	0x700a086a <Udma_chConfigTx+0x6a> @ imm = #-0x2
;     }
700a086a: e7ff         	b	0x700a086c <Udma_chConfigTx+0x6c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a086c: 980d         	ldr	r0, [sp, #0x34]
700a086e: 2800         	cmp	r0, #0x0
700a0870: f040 808e    	bne.w	0x700a0990 <Udma_chConfigTx+0x190> @ imm = #0x11c
700a0874: e7ff         	b	0x700a0876 <Udma_chConfigTx+0x76> @ imm = #-0x2
700a0876: f647 70ff    	movw	r0, #0x7fff
;         rmUdmaTxReq.valid_params        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERR_VALID |
700a087a: 9004         	str	r0, [sp, #0x10]
;         rmUdmaTxReq.nav_id              = drvHandle->devIdUdma;
700a087c: 980c         	ldr	r0, [sp, #0x30]
700a087e: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
700a0882: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmUdmaTxReq.index               = (uint16_t)chHandleInt->txChNum;
700a0886: 980b         	ldr	r0, [sp, #0x2c]
700a0888: 6ec0         	ldr	r0, [r0, #0x6c]
700a088a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         rmUdmaTxReq.tx_pause_on_err     = txPrms->pauseOnError;
700a088e: 980e         	ldr	r0, [sp, #0x38]
700a0890: 7800         	ldrb	r0, [r0]
700a0892: f88d 0018    	strb.w	r0, [sp, #0x18]
;         rmUdmaTxReq.tx_filt_einfo       = txPrms->filterEinfo;
700a0896: 980e         	ldr	r0, [sp, #0x38]
700a0898: 7840         	ldrb	r0, [r0, #0x1]
700a089a: f88d 0019    	strb.w	r0, [sp, #0x19]
;         rmUdmaTxReq.tx_filt_pswords     = txPrms->filterPsWords;
700a089e: 980e         	ldr	r0, [sp, #0x38]
700a08a0: 7880         	ldrb	r0, [r0, #0x2]
700a08a2: f88d 001a    	strb.w	r0, [sp, #0x1a]
;         rmUdmaTxReq.tx_atype            = txPrms->addrType;
700a08a6: 980e         	ldr	r0, [sp, #0x38]
700a08a8: 78c0         	ldrb	r0, [r0, #0x3]
700a08aa: f88d 001b    	strb.w	r0, [sp, #0x1b]
;         rmUdmaTxReq.tx_chan_type        = txPrms->chanType;
700a08ae: 980e         	ldr	r0, [sp, #0x38]
700a08b0: 7900         	ldrb	r0, [r0, #0x4]
700a08b2: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         rmUdmaTxReq.tx_fetch_size       = txPrms->fetchWordSize;
700a08b6: 980e         	ldr	r0, [sp, #0x38]
700a08b8: 88c0         	ldrh	r0, [r0, #0x6]
700a08ba: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmUdmaTxReq.tx_priority         = txPrms->busPriority;
700a08be: 980e         	ldr	r0, [sp, #0x38]
700a08c0: 7a00         	ldrb	r0, [r0, #0x8]
700a08c2: f88d 0023    	strb.w	r0, [sp, #0x23]
;         rmUdmaTxReq.tx_qos              = txPrms->busQos;
700a08c6: 980e         	ldr	r0, [sp, #0x38]
700a08c8: 7a40         	ldrb	r0, [r0, #0x9]
700a08ca: f88d 0024    	strb.w	r0, [sp, #0x24]
;         rmUdmaTxReq.tx_orderid          = txPrms->busOrderId;
700a08ce: 980e         	ldr	r0, [sp, #0x38]
700a08d0: 7a80         	ldrb	r0, [r0, #0xa]
700a08d2: f88d 0025    	strb.w	r0, [sp, #0x25]
;         rmUdmaTxReq.fdepth              = txPrms->fifoDepth;
700a08d6: 980e         	ldr	r0, [sp, #0x38]
700a08d8: 89c0         	ldrh	r0, [r0, #0xe]
700a08da: f8ad 0026    	strh.w	r0, [sp, #0x26]
;         rmUdmaTxReq.tx_burst_size       = txPrms->burstSize;
700a08de: 980e         	ldr	r0, [sp, #0x38]
700a08e0: 7c00         	ldrb	r0, [r0, #0x10]
700a08e2: f88d 0029    	strb.w	r0, [sp, #0x29]
;         rmUdmaTxReq.tx_sched_priority   = txPrms->dmaPriority;
700a08e6: 980e         	ldr	r0, [sp, #0x38]
700a08e8: 7ac0         	ldrb	r0, [r0, #0xb]
700a08ea: f88d 0028    	strb.w	r0, [sp, #0x28]
;         rmUdmaTxReq.tx_credit_count     = txPrms->txCredit;
700a08ee: 980e         	ldr	r0, [sp, #0x38]
700a08f0: 7b00         	ldrb	r0, [r0, #0xc]
700a08f2: f88d 0020    	strb.w	r0, [sp, #0x20]
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a08f6: 980c         	ldr	r0, [sp, #0x30]
700a08f8: 6800         	ldr	r0, [r0]
700a08fa: 2801         	cmp	r0, #0x1
700a08fc: d11d         	bne	0x700a093a <Udma_chConfigTx+0x13a> @ imm = #0x3a
700a08fe: e7ff         	b	0x700a0900 <Udma_chConfigTx+0x100> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a0900: 980b         	ldr	r0, [sp, #0x2c]
700a0902: 7800         	ldrb	r0, [r0]
700a0904: 0740         	lsls	r0, r0, #0x1d
700a0906: 2800         	cmp	r0, #0x0
700a0908: d508         	bpl	0x700a091c <Udma_chConfigTx+0x11c> @ imm = #0x10
700a090a: e7ff         	b	0x700a090c <Udma_chConfigTx+0x10c> @ imm = #-0x2
;                 rmUdmaTxReq.valid_params    |= TISCI_MSG_VALUE_RM_UDMAP_EXTENDED_CH_TYPE_VALID;
700a090c: 9804         	ldr	r0, [sp, #0x10]
700a090e: f440 3080    	orr	r0, r0, #0x10000
700a0912: 9004         	str	r0, [sp, #0x10]
700a0914: 2001         	movs	r0, #0x1
;                 rmUdmaTxReq.extended_ch_type = UDMA_DMSC_EXTENDED_CH_TYPE_BCDMA_BLK_CPY;
700a0916: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             }
700a091a: e00d         	b	0x700a0938 <Udma_chConfigTx+0x138> @ imm = #0x1a
;             else if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a091c: 980b         	ldr	r0, [sp, #0x2c]
700a091e: 7800         	ldrb	r0, [r0]
700a0920: 07c0         	lsls	r0, r0, #0x1f
700a0922: b140         	cbz	r0, 0x700a0936 <Udma_chConfigTx+0x136> @ imm = #0x10
700a0924: e7ff         	b	0x700a0926 <Udma_chConfigTx+0x126> @ imm = #-0x2
;                 rmUdmaTxReq.valid_params    |= TISCI_MSG_VALUE_RM_UDMAP_EXTENDED_CH_TYPE_VALID;
700a0926: 9804         	ldr	r0, [sp, #0x10]
700a0928: f440 3080    	orr	r0, r0, #0x10000
700a092c: 9004         	str	r0, [sp, #0x10]
700a092e: 2000         	movs	r0, #0x0
;                 rmUdmaTxReq.extended_ch_type = UDMA_DMSC_EXTENDED_CH_TYPE_BCDMA_SPLIT_TR_TX;
700a0930: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             }
700a0934: e7ff         	b	0x700a0936 <Udma_chConfigTx+0x136> @ imm = #-0x2
700a0936: e7ff         	b	0x700a0938 <Udma_chConfigTx+0x138> @ imm = #-0x2
;         }
700a0938: e7ff         	b	0x700a093a <Udma_chConfigTx+0x13a> @ imm = #-0x2
;         if(NULL_PTR != chHandleInt->tdCqRing)
700a093a: 980b         	ldr	r0, [sp, #0x2c]
700a093c: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a0940: b158         	cbz	r0, 0x700a095a <Udma_chConfigTx+0x15a> @ imm = #0x16
700a0942: e7ff         	b	0x700a0944 <Udma_chConfigTx+0x144> @ imm = #-0x2
;             rmUdmaTxReq.txcq_qnum       = chHandleInt->tdCqRing->ringNum;
700a0944: 980b         	ldr	r0, [sp, #0x2c]
700a0946: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a094a: 8880         	ldrh	r0, [r0, #0x4]
700a094c: f8ad 0021    	strh.w	r0, [sp, #0x21]
;             rmUdmaTxReq.tx_supr_tdpkt   = txPrms->supressTdCqPkt;
700a0950: 980e         	ldr	r0, [sp, #0x38]
700a0952: 7c40         	ldrb	r0, [r0, #0x11]
700a0954: f88d 001d    	strb.w	r0, [sp, #0x1d]
;         }
700a0958: e007         	b	0x700a096a <Udma_chConfigTx+0x16a> @ imm = #0xe
700a095a: f64f 70ff    	movw	r0, #0xffff
;             rmUdmaTxReq.txcq_qnum       = UDMA_RING_INVALID;
700a095e: f8ad 0021    	strh.w	r0, [sp, #0x21]
700a0962: 2001         	movs	r0, #0x1
;             rmUdmaTxReq.tx_supr_tdpkt   = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_SUPPRESS_TD_ENABLED;
700a0964: f88d 001d    	strb.w	r0, [sp, #0x1d]
700a0968: e7ff         	b	0x700a096a <Udma_chConfigTx+0x16a> @ imm = #-0x2
700a096a: a802         	add	r0, sp, #0x8
700a096c: 4669         	mov	r1, sp
700a096e: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmUdmapTxChCfg(
700a0972: f00c f88d    	bl	0x700aca90 <Sciclient_rmUdmapTxChCfg> @ imm = #0xc11a
700a0976: 900d         	str	r0, [sp, #0x34]
;         if(CSL_PASS != retVal)
700a0978: 980d         	ldr	r0, [sp, #0x34]
700a097a: b108         	cbz	r0, 0x700a0980 <Udma_chConfigTx+0x180> @ imm = #0x2
700a097c: e7ff         	b	0x700a097e <Udma_chConfigTx+0x17e> @ imm = #-0x2
;         }
700a097e: e7ff         	b	0x700a0980 <Udma_chConfigTx+0x180> @ imm = #-0x2
;         (void) memcpy(&chHandleInt->txPrms, txPrms, sizeof(chHandleInt->txPrms));
700a0980: 980b         	ldr	r0, [sp, #0x2c]
700a0982: f500 70f2    	add.w	r0, r0, #0x1e4
700a0986: 990e         	ldr	r1, [sp, #0x38]
700a0988: 2212         	movs	r2, #0x12
700a098a: f7f9 eba8    	blx	0x7009a0dc <__aeabi_memcpy8> @ imm = #-0x68b0
;     }
700a098e: e7ff         	b	0x700a0990 <Udma_chConfigTx+0x190> @ imm = #-0x2
;     return (retVal);
700a0990: 980d         	ldr	r0, [sp, #0x34]
700a0992: b010         	add	sp, #0x40
700a0994: bd80         	pop	{r7, pc}
		...
700a099e: 0000         	movs	r0, r0

700a09a0 <ClockP_init>:
; {
700a09a0: b580         	push	{r7, lr}
700a09a2: b096         	sub	sp, #0x58
;     DebugP_assert( gClockConfig.timerInputPreScaler != 0U);
700a09a4: f642 1010    	movw	r0, #0x2910
700a09a8: f2c7 000b    	movt	r0, #0x700b
700a09ac: 9009         	str	r0, [sp, #0x24]
700a09ae: 68c0         	ldr	r0, [r0, #0xc]
700a09b0: 2800         	cmp	r0, #0x0
700a09b2: bf18         	it	ne
700a09b4: 2001         	movne	r0, #0x1
700a09b6: f641 3145    	movw	r1, #0x1b45
700a09ba: f2c7 010b    	movt	r1, #0x700b
700a09be: 466a         	mov	r2, sp
700a09c0: 6011         	str	r1, [r2]
700a09c2: f641 51f9    	movw	r1, #0x1df9
700a09c6: f2c7 010b    	movt	r1, #0x700b
700a09ca: 9107         	str	r1, [sp, #0x1c]
700a09cc: f242 120b    	movw	r2, #0x210b
700a09d0: f2c7 020b    	movt	r2, #0x700b
700a09d4: 9208         	str	r2, [sp, #0x20]
700a09d6: 2334         	movs	r3, #0x34
700a09d8: f00a f95a    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xa2b4
700a09dc: 9907         	ldr	r1, [sp, #0x1c]
700a09de: 9a08         	ldr	r2, [sp, #0x20]
700a09e0: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.timerInputClkHz != 0U);
700a09e2: 6880         	ldr	r0, [r0, #0x8]
700a09e4: 2800         	cmp	r0, #0x0
700a09e6: bf18         	it	ne
700a09e8: 2001         	movne	r0, #0x1
700a09ea: f641 33b8    	movw	r3, #0x1bb8
700a09ee: f2c7 030b    	movt	r3, #0x700b
700a09f2: 46ec         	mov	r12, sp
700a09f4: f8cc 3000    	str.w	r3, [r12]
700a09f8: 2335         	movs	r3, #0x35
700a09fa: f00a f949    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xa292
700a09fe: 9907         	ldr	r1, [sp, #0x1c]
700a0a00: 9a08         	ldr	r2, [sp, #0x20]
700a0a02: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.usecPerTick != 0U);
700a0a04: 6900         	ldr	r0, [r0, #0x10]
700a0a06: 2800         	cmp	r0, #0x0
700a0a08: bf18         	it	ne
700a0a0a: 2001         	movne	r0, #0x1
700a0a0c: f641 5328    	movw	r3, #0x1d28
700a0a10: f2c7 030b    	movt	r3, #0x700b
700a0a14: 46ec         	mov	r12, sp
700a0a16: f8cc 3000    	str.w	r3, [r12]
700a0a1a: 2336         	movs	r3, #0x36
700a0a1c: f00a f938    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xa270
700a0a20: 9907         	ldr	r1, [sp, #0x1c]
700a0a22: 9a08         	ldr	r2, [sp, #0x20]
700a0a24: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.timerBaseAddr != 0U);
700a0a26: 6800         	ldr	r0, [r0]
700a0a28: 2800         	cmp	r0, #0x0
700a0a2a: bf18         	it	ne
700a0a2c: 2001         	movne	r0, #0x1
700a0a2e: f641 4385    	movw	r3, #0x1c85
700a0a32: f2c7 030b    	movt	r3, #0x700b
700a0a36: 46ec         	mov	r12, sp
700a0a38: f8cc 3000    	str.w	r3, [r12]
700a0a3c: 2337         	movs	r3, #0x37
700a0a3e: f00a f927    	bl	0x700aac90 <_DebugP_assert> @ imm = #0xa24e
700a0a42: 9809         	ldr	r0, [sp, #0x24]
;     gClockCtrl.ticks = 0;
700a0a44: f245 1290    	movw	r2, #0x5190
700a0a48: f2c7 0208    	movt	r2, #0x7008
700a0a4c: 2100         	movs	r1, #0x0
700a0a4e: 6051         	str	r1, [r2, #0x4]
700a0a50: 6011         	str	r1, [r2]
;     gClockCtrl.usecPerTick = gClockConfig.usecPerTick;
700a0a52: 6903         	ldr	r3, [r0, #0x10]
700a0a54: 6093         	str	r3, [r2, #0x8]
;     gClockCtrl.timerBaseAddr = gClockConfig.timerBaseAddr;
700a0a56: 6800         	ldr	r0, [r0]
700a0a58: 62d0         	str	r0, [r2, #0x2c]
700a0a5a: f244 2040    	movw	r0, #0x4240
700a0a5e: f2c0 000f    	movt	r0, #0xf
;     if( pdMS_TO_TICKS( TIME_IN_MILLI_SECONDS ) != ClockP_usecToTicks( TIME_IN_MICRO_SECONDS ) )
700a0a62: f00e fc65    	bl	0x700af330 <ClockP_usecToTicks> @ imm = #0xe8ca
700a0a66: f5b0 7f7a    	cmp.w	r0, #0x3e8
700a0a6a: d01d         	beq	0x700a0aa8 <ClockP_init+0x108> @ imm = #0x3a
700a0a6c: e7ff         	b	0x700a0a6e <ClockP_init+0xce> @ imm = #-0x2
;         DebugP_logWarn("FreeRTOS configTICK_RATE_HZ (%d), does not match ClockP tick rate Hz (%d)\r\n",
700a0a6e: f642 1010    	movw	r0, #0x2910
700a0a72: f2c7 000b    	movt	r0, #0x700b
700a0a76: 6901         	ldr	r1, [r0, #0x10]
700a0a78: f244 2040    	movw	r0, #0x4240
700a0a7c: f2c0 000f    	movt	r0, #0xf
700a0a80: fbb0 f0f1    	udiv	r0, r0, r1
700a0a84: 4669         	mov	r1, sp
700a0a86: 6048         	str	r0, [r1, #0x4]
700a0a88: f44f 707a    	mov.w	r0, #0x3e8
700a0a8c: 6008         	str	r0, [r1]
700a0a8e: f641 016c    	movw	r1, #0x186c
700a0a92: f2c7 010b    	movt	r1, #0x700b
700a0a96: f242 120b    	movw	r2, #0x210b
700a0a9a: f2c7 020b    	movt	r2, #0x700b
700a0a9e: 2004         	movs	r0, #0x4
700a0aa0: 2346         	movs	r3, #0x46
700a0aa2: f009 f93d    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0x927a
;     }
700a0aa6: e7ff         	b	0x700a0aa8 <ClockP_init+0x108> @ imm = #-0x2
700a0aa8: a80f         	add	r0, sp, #0x3c
;     TimerP_Params_init(&timerParams);
700a0aaa: 9002         	str	r0, [sp, #0x8]
700a0aac: f00d fd50    	bl	0x700ae550 <TimerP_Params_init> @ imm = #0xdaa0
700a0ab0: 9902         	ldr	r1, [sp, #0x8]
;     timerParams.inputPreScaler    = gClockConfig.timerInputPreScaler;
700a0ab2: f642 1010    	movw	r0, #0x2910
700a0ab6: f2c7 000b    	movt	r0, #0x700b
700a0aba: 9004         	str	r0, [sp, #0x10]
700a0abc: 68c2         	ldr	r2, [r0, #0xc]
700a0abe: 920f         	str	r2, [sp, #0x3c]
;     timerParams.inputClkHz        = gClockConfig.timerInputClkHz;
700a0ac0: 6882         	ldr	r2, [r0, #0x8]
700a0ac2: 9210         	str	r2, [sp, #0x40]
;     timerParams.periodInUsec      = gClockConfig.usecPerTick;
700a0ac4: 6900         	ldr	r0, [r0, #0x10]
700a0ac6: 9011         	str	r0, [sp, #0x44]
700a0ac8: 2000         	movs	r0, #0x0
;     timerParams.oneshotMode       = 0;
700a0aca: 9003         	str	r0, [sp, #0xc]
700a0acc: 9013         	str	r0, [sp, #0x4c]
700a0ace: 2001         	movs	r0, #0x1
;     timerParams.enableOverflowInt = 1;
700a0ad0: 9014         	str	r0, [sp, #0x50]
;     TimerP_setup(gClockCtrl.timerBaseAddr, &timerParams);
700a0ad2: f245 1090    	movw	r0, #0x5190
700a0ad6: f2c7 0008    	movt	r0, #0x7008
700a0ada: 9006         	str	r0, [sp, #0x18]
700a0adc: 6ac0         	ldr	r0, [r0, #0x2c]
700a0ade: f7fd f9a7    	bl	0x7009de30 <TimerP_setup> @ imm = #-0x2cb2
700a0ae2: 9806         	ldr	r0, [sp, #0x18]
;     gClockCtrl.timerReloadCount = TimerP_getReloadCount(gClockCtrl.timerBaseAddr);
700a0ae4: 6ac0         	ldr	r0, [r0, #0x2c]
700a0ae6: f00e ff9b    	bl	0x700afa20 <TimerP_getReloadCount> @ imm = #0xef36
700a0aea: 9906         	ldr	r1, [sp, #0x18]
700a0aec: 6308         	str	r0, [r1, #0x30]
700a0aee: a80a         	add	r0, sp, #0x28
;     HwiP_Params_init(&timerHwiParams);
700a0af0: 9005         	str	r0, [sp, #0x14]
700a0af2: f00f fa2d    	bl	0x700aff50 <HwiP_Params_init> @ imm = #0xf45a
700a0af6: 9b03         	ldr	r3, [sp, #0xc]
700a0af8: 9a04         	ldr	r2, [sp, #0x10]
700a0afa: 9905         	ldr	r1, [sp, #0x14]
700a0afc: 9806         	ldr	r0, [sp, #0x18]
;     timerHwiParams.intNum = gClockConfig.timerHwiIntNum;
700a0afe: f8d2 c004    	ldr.w	r12, [r2, #0x4]
700a0b02: f8cd c028    	str.w	r12, [sp, #0x28]
;     timerHwiParams.callback = ClockP_timerTickIsr;
700a0b06: f24e 6c81    	movw	r12, #0xe681
700a0b0a: f2c7 0c0a    	movt	r12, #0x700a
700a0b0e: f8cd c02c    	str.w	r12, [sp, #0x2c]
;     timerHwiParams.isPulse = 0;
700a0b12: f88d 3038    	strb.w	r3, [sp, #0x38]
;     timerHwiParams.priority = gClockConfig.intrPriority;
700a0b16: 7d12         	ldrb	r2, [r2, #0x14]
700a0b18: f88d 2036    	strb.w	r2, [sp, #0x36]
;     (void)HwiP_construct(&gClockCtrl.timerHwiObj, &timerHwiParams);
700a0b1c: 300c         	adds	r0, #0xc
700a0b1e: f00f fa2f    	bl	0x700aff80 <HwiP_construct> @ imm = #0xf45e
;     TimerP_start(gClockCtrl.timerBaseAddr);
700a0b22: 9806         	ldr	r0, [sp, #0x18]
700a0b24: 6ac0         	ldr	r0, [r0, #0x2c]
700a0b26: f00e fde3    	bl	0x700af6f0 <TimerP_start> @ imm = #0xebc6
; }
700a0b2a: b016         	add	sp, #0x58
700a0b2c: bd80         	pop	{r7, pc}
700a0b2e: 0000         	movs	r0, r0

700a0b30 <Sciclient_rmIrqDeleteRoute>:
; {
700a0b30: b580         	push	{r7, lr}
700a0b32: b090         	sub	sp, #0x40
700a0b34: 900f         	str	r0, [sp, #0x3c]
700a0b36: f88d 103b    	strb.w	r1, [sp, #0x3b]
700a0b3a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a0b3c: 900d         	str	r0, [sp, #0x34]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a0b3e: 9002         	str	r0, [sp, #0x8]
;     struct Sciclient_rmIrInst *ir_inst = NULL;
700a0b40: 9001         	str	r0, [sp, #0x4]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a0b42: f8ad 0032    	strh.w	r0, [sp, #0x32]
700a0b46: e7ff         	b	0x700a0b48 <Sciclient_rmIrqDeleteRoute+0x18> @ imm = #-0x2
700a0b48: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0b4c: 9000         	str	r0, [sp]
700a0b4e: f00f f89f    	bl	0x700afc90 <Sciclient_rmPsGetPsp> @ imm = #0xf13e
700a0b52: 4601         	mov	r1, r0
700a0b54: 9800         	ldr	r0, [sp]
700a0b56: 4288         	cmp	r0, r1
700a0b58: f280 80ac    	bge.w	0x700a0cb4 <Sciclient_rmIrqDeleteRoute+0x184> @ imm = #0x158
700a0b5c: e7ff         	b	0x700a0b5e <Sciclient_rmIrqDeleteRoute+0x2e> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a0b5e: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0b62: f00e fc65    	bl	0x700af430 <Sciclient_rmPsGetIrqNode> @ imm = #0xe8ca
700a0b66: 900b         	str	r0, [sp, #0x2c]
;         cur_inp = Sciclient_rmPsGetInp(i);
700a0b68: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0b6c: f00d f890    	bl	0x700adc90 <Sciclient_rmPsGetInp> @ imm = #0xd120
700a0b70: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;         cur_outp = Sciclient_rmPsGetOutp(i);
700a0b74: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0b78: f00d f8aa    	bl	0x700adcd0 <Sciclient_rmPsGetOutp> @ imm = #0xd154
700a0b7c: f8ad 0028    	strh.w	r0, [sp, #0x28]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a0b80: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0b84: 2800         	cmp	r0, #0x0
700a0b86: d156         	bne	0x700a0c36 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0xac
700a0b88: e7ff         	b	0x700a0b8a <Sciclient_rmIrqDeleteRoute+0x5a> @ imm = #-0x2
700a0b8a: 980b         	ldr	r0, [sp, #0x2c]
700a0b8c: 8800         	ldrh	r0, [r0]
700a0b8e: f00d fec7    	bl	0x700ae920 <Sciclient_rmIaIsIa> @ imm = #0xdd8e
700a0b92: 2800         	cmp	r0, #0x0
700a0b94: d04f         	beq	0x700a0c36 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0x9e
700a0b96: e7ff         	b	0x700a0b98 <Sciclient_rmIrqDeleteRoute+0x68> @ imm = #-0x2
;             (unmap_vint == true)) {
700a0b98: f89d 003b    	ldrb.w	r0, [sp, #0x3b]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a0b9c: 07c0         	lsls	r0, r0, #0x1f
700a0b9e: 2800         	cmp	r0, #0x0
700a0ba0: d049         	beq	0x700a0c36 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0x92
700a0ba2: e7ff         	b	0x700a0ba4 <Sciclient_rmIrqDeleteRoute+0x74> @ imm = #-0x2
700a0ba4: 203c         	movs	r0, #0x3c
700a0ba6: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a0baa: 9005         	str	r0, [sp, #0x14]
;             req.secondary_host = cfg->host;
700a0bac: 980f         	ldr	r0, [sp, #0x3c]
700a0bae: 7900         	ldrb	r0, [r0, #0x4]
700a0bb0: f88d 0027    	strb.w	r0, [sp, #0x27]
;             req.src_id = cfg->s_id;
700a0bb4: 980f         	ldr	r0, [sp, #0x3c]
700a0bb6: 88c0         	ldrh	r0, [r0, #0x6]
700a0bb8: f8ad 0018    	strh.w	r0, [sp, #0x18]
;             req.src_index = cfg->s_idx;
700a0bbc: 980f         	ldr	r0, [sp, #0x3c]
700a0bbe: 8900         	ldrh	r0, [r0, #0x8]
700a0bc0: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             req.ia_id = cfg->s_ia;
700a0bc4: 980f         	ldr	r0, [sp, #0x3c]
700a0bc6: 8a00         	ldrh	r0, [r0, #0x10]
700a0bc8: f8ad 0020    	strh.w	r0, [sp, #0x20]
;             req.vint = cur_outp;
700a0bcc: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
700a0bd0: f8ad 0022    	strh.w	r0, [sp, #0x22]
;             req.global_event = cur_inp;
700a0bd4: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
700a0bd8: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             req.vint_status_bit_index = cfg->vint_sb;
700a0bdc: 980f         	ldr	r0, [sp, #0x3c]
700a0bde: 7d00         	ldrb	r0, [r0, #0x14]
700a0be0: f88d 0026    	strb.w	r0, [sp, #0x26]
700a0be4: a803         	add	r0, sp, #0xc
700a0be6: f04f 31ff    	mov.w	r1, #0xffffffff
;             r = Sciclient_rmIrqReleaseRaw(&req,
700a0bea: f00c f801    	bl	0x700acbf0 <Sciclient_rmIrqReleaseRaw> @ imm = #0xc002
700a0bee: 900d         	str	r0, [sp, #0x34]
;             if (r == SystemP_SUCCESS) {
700a0bf0: 980d         	ldr	r0, [sp, #0x34]
700a0bf2: b9f8         	cbnz	r0, 0x700a0c34 <Sciclient_rmIrqDeleteRoute+0x104> @ imm = #0x3e
700a0bf4: e7ff         	b	0x700a0bf6 <Sciclient_rmIrqDeleteRoute+0xc6> @ imm = #-0x2
;                 ia_inst = Sciclient_rmIaGetInst(cur_n->id);
700a0bf6: 980b         	ldr	r0, [sp, #0x2c]
700a0bf8: 8800         	ldrh	r0, [r0]
700a0bfa: f00b fca9    	bl	0x700ac550 <Sciclient_rmIaGetInst> @ imm = #0xb952
700a0bfe: 9002         	str	r0, [sp, #0x8]
;                 if (ia_inst != NULL) {
700a0c00: 9802         	ldr	r0, [sp, #0x8]
700a0c02: b1b0         	cbz	r0, 0x700a0c32 <Sciclient_rmIrqDeleteRoute+0x102> @ imm = #0x2c
700a0c04: e7ff         	b	0x700a0c06 <Sciclient_rmIrqDeleteRoute+0xd6> @ imm = #-0x2
;                     ia_inst->vint_usage_count[cur_outp]--;
700a0c06: 9802         	ldr	r0, [sp, #0x8]
700a0c08: 6901         	ldr	r1, [r0, #0x10]
700a0c0a: f8bd 2028    	ldrh.w	r2, [sp, #0x28]
700a0c0e: 5c88         	ldrb	r0, [r1, r2]
700a0c10: 3801         	subs	r0, #0x1
700a0c12: 5488         	strb	r0, [r1, r2]
;                     if (ia_inst->v0_b0_evt == cur_inp - ia_inst->sevt_offset) {
700a0c14: 9a02         	ldr	r2, [sp, #0x8]
700a0c16: 8a90         	ldrh	r0, [r2, #0x14]
700a0c18: f8bd 102a    	ldrh.w	r1, [sp, #0x2a]
700a0c1c: 8912         	ldrh	r2, [r2, #0x8]
700a0c1e: 1a89         	subs	r1, r1, r2
700a0c20: 4288         	cmp	r0, r1
700a0c22: d105         	bne	0x700a0c30 <Sciclient_rmIrqDeleteRoute+0x100> @ imm = #0xa
700a0c24: e7ff         	b	0x700a0c26 <Sciclient_rmIrqDeleteRoute+0xf6> @ imm = #-0x2
;                         ia_inst->v0_b0_evt = SCICLIENT_RM_IA_GENERIC_EVT_RESETVAL;
700a0c26: 9902         	ldr	r1, [sp, #0x8]
700a0c28: f64f 70ff    	movw	r0, #0xffff
700a0c2c: 8288         	strh	r0, [r1, #0x14]
;                     }
700a0c2e: e7ff         	b	0x700a0c30 <Sciclient_rmIrqDeleteRoute+0x100> @ imm = #-0x2
;                 }
700a0c30: e7ff         	b	0x700a0c32 <Sciclient_rmIrqDeleteRoute+0x102> @ imm = #-0x2
;             }
700a0c32: e7ff         	b	0x700a0c34 <Sciclient_rmIrqDeleteRoute+0x104> @ imm = #-0x2
;         }
700a0c34: e7ff         	b	0x700a0c36 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #-0x2
;         if (i > 0u) {
700a0c36: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0c3a: b3a0         	cbz	r0, 0x700a0ca6 <Sciclient_rmIrqDeleteRoute+0x176> @ imm = #0x68
700a0c3c: e7ff         	b	0x700a0c3e <Sciclient_rmIrqDeleteRoute+0x10e> @ imm = #-0x2
700a0c3e: 2003         	movs	r0, #0x3
700a0c40: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_DST_ID_VALID |
700a0c44: 9005         	str	r0, [sp, #0x14]
;             req.secondary_host = cfg->host;
700a0c46: 980f         	ldr	r0, [sp, #0x3c]
700a0c48: 7900         	ldrb	r0, [r0, #0x4]
700a0c4a: f88d 0027    	strb.w	r0, [sp, #0x27]
;             req.src_id = cur_n->id;
700a0c4e: 980b         	ldr	r0, [sp, #0x2c]
700a0c50: 8800         	ldrh	r0, [r0]
700a0c52: f8ad 0018    	strh.w	r0, [sp, #0x18]
;             req.src_index = cur_inp;
700a0c56: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
700a0c5a: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             req.dst_id = cur_n->id;
700a0c5e: 980b         	ldr	r0, [sp, #0x2c]
700a0c60: 8800         	ldrh	r0, [r0]
700a0c62: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.dst_host_irq = cur_outp;
700a0c66: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
700a0c6a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
700a0c6e: a803         	add	r0, sp, #0xc
700a0c70: f04f 31ff    	mov.w	r1, #0xffffffff
;             r = Sciclient_rmIrqReleaseRaw(&req,
700a0c74: f00b ffbc    	bl	0x700acbf0 <Sciclient_rmIrqReleaseRaw> @ imm = #0xbf78
700a0c78: 900d         	str	r0, [sp, #0x34]
;             if ((r == SystemP_SUCCESS) && (cur_outp == 0)) {
700a0c7a: 980d         	ldr	r0, [sp, #0x34]
700a0c7c: b990         	cbnz	r0, 0x700a0ca4 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #0x24
700a0c7e: e7ff         	b	0x700a0c80 <Sciclient_rmIrqDeleteRoute+0x150> @ imm = #-0x2
700a0c80: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
700a0c84: b970         	cbnz	r0, 0x700a0ca4 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #0x1c
700a0c86: e7ff         	b	0x700a0c88 <Sciclient_rmIrqDeleteRoute+0x158> @ imm = #-0x2
;                 ir_inst = Sciclient_rmIrGetInst(cur_n->id);
700a0c88: 980b         	ldr	r0, [sp, #0x2c]
700a0c8a: 8800         	ldrh	r0, [r0]
700a0c8c: f00a ff78    	bl	0x700abb80 <Sciclient_rmIrGetInst> @ imm = #0xaef0
700a0c90: 9001         	str	r0, [sp, #0x4]
;                 if (ir_inst != NULL) {
700a0c92: 9801         	ldr	r0, [sp, #0x4]
700a0c94: b128         	cbz	r0, 0x700a0ca2 <Sciclient_rmIrqDeleteRoute+0x172> @ imm = #0xa
700a0c96: e7ff         	b	0x700a0c98 <Sciclient_rmIrqDeleteRoute+0x168> @ imm = #-0x2
;                     ir_inst->inp0_mapping = SCICLIENT_RM_IR_MAPPING_FREE;
700a0c98: 9901         	ldr	r1, [sp, #0x4]
700a0c9a: f64f 70ff    	movw	r0, #0xffff
700a0c9e: 8188         	strh	r0, [r1, #0xc]
;                 }
700a0ca0: e7ff         	b	0x700a0ca2 <Sciclient_rmIrqDeleteRoute+0x172> @ imm = #-0x2
;             }
700a0ca2: e7ff         	b	0x700a0ca4 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #-0x2
;         }
700a0ca4: e7ff         	b	0x700a0ca6 <Sciclient_rmIrqDeleteRoute+0x176> @ imm = #-0x2
;     }
700a0ca6: e7ff         	b	0x700a0ca8 <Sciclient_rmIrqDeleteRoute+0x178> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a0ca8: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0cac: 3001         	adds	r0, #0x1
700a0cae: f8ad 0032    	strh.w	r0, [sp, #0x32]
700a0cb2: e749         	b	0x700a0b48 <Sciclient_rmIrqDeleteRoute+0x18> @ imm = #-0x16e
;     return r;
700a0cb4: 980d         	ldr	r0, [sp, #0x34]
700a0cb6: b010         	add	sp, #0x40
700a0cb8: bd80         	pop	{r7, pc}
700a0cba: 0000         	movs	r0, r0
700a0cbc: 0000         	movs	r0, r0
700a0cbe: 0000         	movs	r0, r0

700a0cc0 <Sciclient_rmProgramInterruptRoute>:
; {
700a0cc0: b580         	push	{r7, lr}
700a0cc2: b08e         	sub	sp, #0x38
700a0cc4: 900d         	str	r0, [sp, #0x34]
700a0cc6: 910c         	str	r1, [sp, #0x30]
700a0cc8: 920b         	str	r2, [sp, #0x2c]
700a0cca: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a0ccc: 9001         	str	r0, [sp, #0x4]
700a0cce: 900a         	str	r0, [sp, #0x28]
700a0cd0: f44f 5180    	mov.w	r1, #0x1000
;     uint16_t messageType = TISCI_MSG_RM_IRQ_SET;
700a0cd4: f8ad 1026    	strh.w	r1, [sp, #0x26]
;     memset(&cfg, 0, sizeof(cfg));
700a0cd8: 9008         	str	r0, [sp, #0x20]
700a0cda: 9007         	str	r0, [sp, #0x1c]
700a0cdc: 9006         	str	r0, [sp, #0x18]
700a0cde: 9005         	str	r0, [sp, #0x14]
700a0ce0: 9004         	str	r0, [sp, #0x10]
700a0ce2: 9003         	str	r0, [sp, #0xc]
700a0ce4: 9002         	str	r0, [sp, #0x8]
;     if((req == NULL) || (resp == NULL)) {
700a0ce6: 980d         	ldr	r0, [sp, #0x34]
700a0ce8: b118         	cbz	r0, 0x700a0cf2 <Sciclient_rmProgramInterruptRoute+0x32> @ imm = #0x6
700a0cea: e7ff         	b	0x700a0cec <Sciclient_rmProgramInterruptRoute+0x2c> @ imm = #-0x2
700a0cec: 980c         	ldr	r0, [sp, #0x30]
700a0cee: b920         	cbnz	r0, 0x700a0cfa <Sciclient_rmProgramInterruptRoute+0x3a> @ imm = #0x8
700a0cf0: e7ff         	b	0x700a0cf2 <Sciclient_rmProgramInterruptRoute+0x32> @ imm = #-0x2
700a0cf2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a0cf6: 900a         	str	r0, [sp, #0x28]
;     }
700a0cf8: e7ff         	b	0x700a0cfa <Sciclient_rmProgramInterruptRoute+0x3a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a0cfa: 980a         	ldr	r0, [sp, #0x28]
700a0cfc: b968         	cbnz	r0, 0x700a0d1a <Sciclient_rmProgramInterruptRoute+0x5a> @ imm = #0x1a
700a0cfe: e7ff         	b	0x700a0d00 <Sciclient_rmProgramInterruptRoute+0x40> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a0d00: 980d         	ldr	r0, [sp, #0x34]
700a0d02: 6880         	ldr	r0, [r0, #0x8]
700a0d04: f04f 4100    	mov.w	r1, #0x80000000
700a0d08: f00e f802    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0xe004
;     if (r == SystemP_SUCCESS &&
700a0d0c: b128         	cbz	r0, 0x700a0d1a <Sciclient_rmProgramInterruptRoute+0x5a> @ imm = #0xa
700a0d0e: e7ff         	b	0x700a0d10 <Sciclient_rmProgramInterruptRoute+0x50> @ imm = #-0x2
;         dst_host = req->secondary_host;
700a0d10: 980d         	ldr	r0, [sp, #0x34]
700a0d12: 7ec0         	ldrb	r0, [r0, #0x1b]
700a0d14: f88d 0025    	strb.w	r0, [sp, #0x25]
;     } else {
700a0d18: e00f         	b	0x700a0d3a <Sciclient_rmProgramInterruptRoute+0x7a> @ imm = #0x1e
;         dst_host = (uint8_t) gSciclientMap[Sciclient_getCurrentContext(messageType)].hostId;
700a0d1a: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
700a0d1e: f006 ff57    	bl	0x700a7bd0 <Sciclient_getCurrentContext> @ imm = #0x6eae
700a0d22: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a0d26: f241 3060    	movw	r0, #0x1360
700a0d2a: f2c7 000b    	movt	r0, #0x700b
700a0d2e: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a0d32: 6840         	ldr	r0, [r0, #0x4]
700a0d34: f88d 0025    	strb.w	r0, [sp, #0x25]
700a0d38: e7ff         	b	0x700a0d3a <Sciclient_rmProgramInterruptRoute+0x7a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a0d3a: 980a         	ldr	r0, [sp, #0x28]
700a0d3c: b960         	cbnz	r0, 0x700a0d58 <Sciclient_rmProgramInterruptRoute+0x98> @ imm = #0x18
700a0d3e: e7ff         	b	0x700a0d40 <Sciclient_rmProgramInterruptRoute+0x80> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a0d40: 980d         	ldr	r0, [sp, #0x34]
700a0d42: 6880         	ldr	r0, [r0, #0x8]
700a0d44: 2104         	movs	r1, #0x4
700a0d46: f00d ffe3    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0xdfc6
;     if (r == SystemP_SUCCESS &&
700a0d4a: b128         	cbz	r0, 0x700a0d58 <Sciclient_rmProgramInterruptRoute+0x98> @ imm = #0xa
700a0d4c: e7ff         	b	0x700a0d4e <Sciclient_rmProgramInterruptRoute+0x8e> @ imm = #-0x2
;         cfg.s_ia = req->ia_id;
700a0d4e: 980d         	ldr	r0, [sp, #0x34]
700a0d50: 8a80         	ldrh	r0, [r0, #0x14]
700a0d52: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     } else {
700a0d56: e003         	b	0x700a0d60 <Sciclient_rmProgramInterruptRoute+0xa0> @ imm = #0x6
700a0d58: 20ff         	movs	r0, #0xff
;         cfg.s_ia = SCICLIENT_RM_DEV_NONE;
700a0d5a: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a0d5e: e7ff         	b	0x700a0d60 <Sciclient_rmProgramInterruptRoute+0xa0> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a0d60: 980a         	ldr	r0, [sp, #0x28]
700a0d62: 2800         	cmp	r0, #0x0
700a0d64: d16e         	bne	0x700a0e44 <Sciclient_rmProgramInterruptRoute+0x184> @ imm = #0xdc
700a0d66: e7ff         	b	0x700a0d68 <Sciclient_rmProgramInterruptRoute+0xa8> @ imm = #-0x2
;         cfg.valid_params = req->valid_params;
700a0d68: 980d         	ldr	r0, [sp, #0x34]
700a0d6a: 6880         	ldr	r0, [r0, #0x8]
700a0d6c: 9002         	str	r0, [sp, #0x8]
;         cfg.host = dst_host;
700a0d6e: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a0d72: f88d 000c    	strb.w	r0, [sp, #0xc]
;         cfg.s_id = req->src_id;
700a0d76: 980d         	ldr	r0, [sp, #0x34]
700a0d78: 8980         	ldrh	r0, [r0, #0xc]
700a0d7a: f8ad 000e    	strh.w	r0, [sp, #0xe]
;         cfg.s_idx = req->src_index;
700a0d7e: 980d         	ldr	r0, [sp, #0x34]
700a0d80: 89c0         	ldrh	r0, [r0, #0xe]
700a0d82: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         cfg.d_id = req->dst_id;
700a0d86: 980d         	ldr	r0, [sp, #0x34]
700a0d88: 8a00         	ldrh	r0, [r0, #0x10]
700a0d8a: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         cfg.d_irq = req->dst_host_irq;
700a0d8e: 980d         	ldr	r0, [sp, #0x34]
700a0d90: 8a40         	ldrh	r0, [r0, #0x12]
700a0d92: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         cfg.global_evt = req->global_event;
700a0d96: 980d         	ldr	r0, [sp, #0x34]
700a0d98: 8b00         	ldrh	r0, [r0, #0x18]
700a0d9a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         cfg.vint = req->vint;
700a0d9e: 980d         	ldr	r0, [sp, #0x34]
700a0da0: 8ac0         	ldrh	r0, [r0, #0x16]
700a0da2: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         cfg.vint_sb = req->vint_status_bit_index;
700a0da6: 980d         	ldr	r0, [sp, #0x34]
700a0da8: 7e80         	ldrb	r0, [r0, #0x1a]
700a0daa: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         cfg.set_resp = resp;
700a0dae: 980c         	ldr	r0, [sp, #0x30]
700a0db0: 9008         	str	r0, [sp, #0x20]
;         if (Sciclient_rmIrqCfgIsDirectNonEvent(cfg.valid_params) == true) {
700a0db2: 9802         	ldr	r0, [sp, #0x8]
700a0db4: f00a fd94    	bl	0x700ab8e0 <Sciclient_rmIrqCfgIsDirectNonEvent> @ imm = #0xab28
700a0db8: b1c8         	cbz	r0, 0x700a0dee <Sciclient_rmProgramInterruptRoute+0x12e> @ imm = #0x32
700a0dba: e7ff         	b	0x700a0dbc <Sciclient_rmProgramInterruptRoute+0xfc> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cfg.s_id) == true) {
700a0dbc: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a0dc0: f00d fdae    	bl	0x700ae920 <Sciclient_rmIaIsIa> @ imm = #0xdb5c
700a0dc4: b128         	cbz	r0, 0x700a0dd2 <Sciclient_rmProgramInterruptRoute+0x112> @ imm = #0xa
700a0dc6: e7ff         	b	0x700a0dc8 <Sciclient_rmProgramInterruptRoute+0x108> @ imm = #-0x2
;                 cfg.vint = cfg.s_idx;
700a0dc8: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a0dcc: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             }
700a0dd0: e7ff         	b	0x700a0dd2 <Sciclient_rmProgramInterruptRoute+0x112> @ imm = #-0x2
700a0dd2: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqFindRoute(&cfg);
700a0dd4: f7fd fbcc    	bl	0x7009e570 <Sciclient_rmIrqFindRoute> @ imm = #-0x2868
700a0dd8: 900a         	str	r0, [sp, #0x28]
;             if (r == SystemP_SUCCESS) {
700a0dda: 980a         	ldr	r0, [sp, #0x28]
700a0ddc: b930         	cbnz	r0, 0x700a0dec <Sciclient_rmProgramInterruptRoute+0x12c> @ imm = #0xc
700a0dde: e7ff         	b	0x700a0de0 <Sciclient_rmProgramInterruptRoute+0x120> @ imm = #-0x2
700a0de0: a802         	add	r0, sp, #0x8
700a0de2: 2100         	movs	r1, #0x0
;                 r = Sciclient_rmIrqProgramRoute(&cfg, false);
700a0de4: f000 f8fc    	bl	0x700a0fe0 <Sciclient_rmIrqProgramRoute> @ imm = #0x1f8
700a0de8: 900a         	str	r0, [sp, #0x28]
;             }
700a0dea: e7ff         	b	0x700a0dec <Sciclient_rmProgramInterruptRoute+0x12c> @ imm = #-0x2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a0dec: e029         	b	0x700a0e42 <Sciclient_rmProgramInterruptRoute+0x182> @ imm = #0x52
700a0dee: 9802         	ldr	r0, [sp, #0x8]
700a0df0: f00a fd3e    	bl	0x700ab870 <Sciclient_rmIrqCfgIsDirectEvent> @ imm = #0xaa7c
;                 true) ||
700a0df4: b928         	cbnz	r0, 0x700a0e02 <Sciclient_rmProgramInterruptRoute+0x142> @ imm = #0xa
700a0df6: e7ff         	b	0x700a0df8 <Sciclient_rmProgramInterruptRoute+0x138> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg.valid_params) ==
700a0df8: 9802         	ldr	r0, [sp, #0x8]
700a0dfa: f00a fda9    	bl	0x700ab950 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0xab52
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a0dfe: b128         	cbz	r0, 0x700a0e0c <Sciclient_rmProgramInterruptRoute+0x14c> @ imm = #0xa
700a0e00: e7ff         	b	0x700a0e02 <Sciclient_rmProgramInterruptRoute+0x142> @ imm = #-0x2
700a0e02: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqVintAdd(&cfg);
700a0e04: f003 fc7c    	bl	0x700a4700 <Sciclient_rmIrqVintAdd> @ imm = #0x38f8
700a0e08: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsUnmappedVintDirectEvent(cfg.valid_params) ==
700a0e0a: e019         	b	0x700a0e40 <Sciclient_rmProgramInterruptRoute+0x180> @ imm = #0x32
700a0e0c: 9802         	ldr	r0, [sp, #0x8]
700a0e0e: f00a fe0f    	bl	0x700aba30 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent> @ imm = #0xac1e
700a0e12: b128         	cbz	r0, 0x700a0e20 <Sciclient_rmProgramInterruptRoute+0x160> @ imm = #0xa
700a0e14: e7ff         	b	0x700a0e16 <Sciclient_rmProgramInterruptRoute+0x156> @ imm = #-0x2
700a0e16: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmUnmappedVintRouteCreate(&cfg);
700a0e18: f00c f80a    	bl	0x700ace30 <Sciclient_rmUnmappedVintRouteCreate> @ imm = #0xc014
700a0e1c: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsOesOnly(cfg.valid_params) == true) {
700a0e1e: e00e         	b	0x700a0e3e <Sciclient_rmProgramInterruptRoute+0x17e> @ imm = #0x1c
700a0e20: 9802         	ldr	r0, [sp, #0x8]
700a0e22: f00a fdcd    	bl	0x700ab9c0 <Sciclient_rmIrqCfgIsOesOnly> @ imm = #0xab9a
700a0e26: b128         	cbz	r0, 0x700a0e34 <Sciclient_rmProgramInterruptRoute+0x174> @ imm = #0xa
700a0e28: e7ff         	b	0x700a0e2a <Sciclient_rmProgramInterruptRoute+0x16a> @ imm = #-0x2
700a0e2a: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqProgramOesRegister(&cfg);
700a0e2c: f00c fef0    	bl	0x700adc10 <Sciclient_rmIrqProgramOesRegister> @ imm = #0xcde0
700a0e30: 900a         	str	r0, [sp, #0x28]
;         } else {
700a0e32: e003         	b	0x700a0e3c <Sciclient_rmProgramInterruptRoute+0x17c> @ imm = #0x6
700a0e34: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a0e38: 900a         	str	r0, [sp, #0x28]
700a0e3a: e7ff         	b	0x700a0e3c <Sciclient_rmProgramInterruptRoute+0x17c> @ imm = #-0x2
700a0e3c: e7ff         	b	0x700a0e3e <Sciclient_rmProgramInterruptRoute+0x17e> @ imm = #-0x2
700a0e3e: e7ff         	b	0x700a0e40 <Sciclient_rmProgramInterruptRoute+0x180> @ imm = #-0x2
700a0e40: e7ff         	b	0x700a0e42 <Sciclient_rmProgramInterruptRoute+0x182> @ imm = #-0x2
;     }
700a0e42: e7ff         	b	0x700a0e44 <Sciclient_rmProgramInterruptRoute+0x184> @ imm = #-0x2
;     return r;
700a0e44: 980a         	ldr	r0, [sp, #0x28]
700a0e46: b00e         	add	sp, #0x38
700a0e48: bd80         	pop	{r7, pc}
700a0e4a: 0000         	movs	r0, r0
700a0e4c: 0000         	movs	r0, r0
700a0e4e: 0000         	movs	r0, r0

700a0e50 <PMU_init>:
; int32_t PMU_init(PMU_Config *cfg) {
700a0e50: b580         	push	{r7, lr}
700a0e52: b08a         	sub	sp, #0x28
700a0e54: 9009         	str	r0, [sp, #0x24]
;   memset((void *)&gProfileObject, 0U, sizeof(gProfileObject));
700a0e56: f243 0080    	movw	r0, #0x3080
700a0e5a: f2c7 0008    	movt	r0, #0x7008
700a0e5e: 9003         	str	r0, [sp, #0xc]
700a0e60: f640 510c    	movw	r1, #0xd0c
700a0e64: f7fa e956    	blx	0x7009b114 <__aeabi_memclr8> @ imm = #-0x5d54
700a0e68: 9a03         	ldr	r2, [sp, #0xc]
700a0e6a: 2000         	movs	r0, #0x0
;   gProfileObject.logIndex = 0U;
700a0e6c: 9004         	str	r0, [sp, #0x10]
700a0e6e: 6010         	str	r0, [r2]
;   gProfileObject.bCycleCounter = cfg->bCycleCounter;
700a0e70: 9909         	ldr	r1, [sp, #0x24]
700a0e72: 6809         	ldr	r1, [r1]
700a0e74: 6051         	str	r1, [r2, #0x4]
;   DebugP_assert(cfg->numEventCounters <= 3U);
700a0e76: 9909         	ldr	r1, [sp, #0x24]
700a0e78: 6849         	ldr	r1, [r1, #0x4]
700a0e7a: 2904         	cmp	r1, #0x4
700a0e7c: bf38         	it	lo
700a0e7e: 2001         	movlo	r0, #0x1
700a0e80: f641 51dd    	movw	r1, #0x1ddd
700a0e84: f2c7 010b    	movt	r1, #0x700b
700a0e88: 466a         	mov	r2, sp
700a0e8a: 6011         	str	r1, [r2]
700a0e8c: f242 1165    	movw	r1, #0x2165
700a0e90: f2c7 010b    	movt	r1, #0x700b
700a0e94: f242 126f    	movw	r2, #0x216f
700a0e98: f2c7 020b    	movt	r2, #0x700b
700a0e9c: 236e         	movs	r3, #0x6e
700a0e9e: f009 fef7    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x9dee
700a0ea2: 9a03         	ldr	r2, [sp, #0xc]
700a0ea4: 9804         	ldr	r0, [sp, #0x10]
;   gProfileObject.numEvents = cfg->numEventCounters;
700a0ea6: 9909         	ldr	r1, [sp, #0x24]
700a0ea8: 6849         	ldr	r1, [r1, #0x4]
700a0eaa: 6091         	str	r1, [r2, #0x8]
;   for (i = 0; i < PMU_MAX_LOG_ENTRIES; i++) {
700a0eac: 9008         	str	r0, [sp, #0x20]
700a0eae: e7ff         	b	0x700a0eb0 <PMU_init+0x60> @ imm = #-0x2
700a0eb0: 9808         	ldr	r0, [sp, #0x20]
700a0eb2: 283f         	cmp	r0, #0x3f
700a0eb4: d833         	bhi	0x700a0f1e <PMU_init+0xce> @ imm = #0x66
700a0eb6: e7ff         	b	0x700a0eb8 <PMU_init+0x68> @ imm = #-0x2
;     PMU_ProfilePoint *p = &gProfileObject.point[i];
700a0eb8: 9808         	ldr	r0, [sp, #0x20]
700a0eba: f243 0280    	movw	r2, #0x3080
700a0ebe: f2c7 0208    	movt	r2, #0x7008
700a0ec2: 2134         	movs	r1, #0x34
700a0ec4: fb00 2001    	mla	r0, r0, r1, r2
700a0ec8: 300c         	adds	r0, #0xc
700a0eca: 9006         	str	r0, [sp, #0x18]
700a0ecc: 2000         	movs	r0, #0x0
;     for (j = 0; j < cfg->numEventCounters; j++) {
700a0ece: 9007         	str	r0, [sp, #0x1c]
700a0ed0: e7ff         	b	0x700a0ed2 <PMU_init+0x82> @ imm = #-0x2
700a0ed2: 9807         	ldr	r0, [sp, #0x1c]
700a0ed4: 9909         	ldr	r1, [sp, #0x24]
700a0ed6: 6849         	ldr	r1, [r1, #0x4]
700a0ed8: 4288         	cmp	r0, r1
700a0eda: d21b         	bhs	0x700a0f14 <PMU_init+0xc4> @ imm = #0x36
700a0edc: e7ff         	b	0x700a0ede <PMU_init+0x8e> @ imm = #-0x2
;       p->events[j].name = cfg->eventCounters[j].name;
700a0ede: 9809         	ldr	r0, [sp, #0x24]
700a0ee0: 6880         	ldr	r0, [r0, #0x8]
700a0ee2: 9a07         	ldr	r2, [sp, #0x1c]
700a0ee4: eb00 00c2    	add.w	r0, r0, r2, lsl #3
700a0ee8: 6840         	ldr	r0, [r0, #0x4]
700a0eea: 9906         	ldr	r1, [sp, #0x18]
700a0eec: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a0ef0: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;       p->events[j].type = cfg->eventCounters[j].type;
700a0ef4: 9809         	ldr	r0, [sp, #0x24]
700a0ef6: 6880         	ldr	r0, [r0, #0x8]
700a0ef8: 9a07         	ldr	r2, [sp, #0x1c]
700a0efa: f850 0032    	ldr.w	r0, [r0, r2, lsl #3]
700a0efe: 9906         	ldr	r1, [sp, #0x18]
700a0f00: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a0f04: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0f08: 6048         	str	r0, [r1, #0x4]
;     }
700a0f0a: e7ff         	b	0x700a0f0c <PMU_init+0xbc> @ imm = #-0x2
;     for (j = 0; j < cfg->numEventCounters; j++) {
700a0f0c: 9807         	ldr	r0, [sp, #0x1c]
700a0f0e: 3001         	adds	r0, #0x1
700a0f10: 9007         	str	r0, [sp, #0x1c]
700a0f12: e7de         	b	0x700a0ed2 <PMU_init+0x82> @ imm = #-0x44
;   }
700a0f14: e7ff         	b	0x700a0f16 <PMU_init+0xc6> @ imm = #-0x2
;   for (i = 0; i < PMU_MAX_LOG_ENTRIES; i++) {
700a0f16: 9808         	ldr	r0, [sp, #0x20]
700a0f18: 3001         	adds	r0, #0x1
700a0f1a: 9008         	str	r0, [sp, #0x20]
700a0f1c: e7c8         	b	0x700a0eb0 <PMU_init+0x60> @ imm = #-0x70
;   int32_t numCount = CSL_armR5PmuGetNumCntrs();
700a0f1e: f001 e946    	blx	0x700a21ac <CSL_armR5PmuGetNumCntrs> @ imm = #0x128c
700a0f22: 9005         	str	r0, [sp, #0x14]
;   DebugP_assert(numCount == cfg->numEventCounters);
700a0f24: 9805         	ldr	r0, [sp, #0x14]
700a0f26: 9909         	ldr	r1, [sp, #0x24]
700a0f28: 6849         	ldr	r1, [r1, #0x4]
700a0f2a: 1a40         	subs	r0, r0, r1
700a0f2c: fab0 f080    	clz	r0, r0
700a0f30: 0940         	lsrs	r0, r0, #0x5
700a0f32: f641 31db    	movw	r1, #0x1bdb
700a0f36: f2c7 010b    	movt	r1, #0x700b
700a0f3a: 466a         	mov	r2, sp
700a0f3c: 6011         	str	r1, [r2]
700a0f3e: f242 1165    	movw	r1, #0x2165
700a0f42: f2c7 010b    	movt	r1, #0x700b
700a0f46: f242 126f    	movw	r2, #0x216f
700a0f4a: f2c7 020b    	movt	r2, #0x700b
700a0f4e: 237d         	movs	r3, #0x7d
700a0f50: f009 fe9e    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x9d3c
700a0f54: 2100         	movs	r1, #0x0
700a0f56: 9102         	str	r1, [sp, #0x8]
700a0f58: 2201         	movs	r2, #0x1
;   CSL_armR5PmuCfg(0, 0, 1);
700a0f5a: 4608         	mov	r0, r1
700a0f5c: f001 e8f8    	blx	0x700a2150 <CSL_armR5PmuCfg> @ imm = #0x11f0
700a0f60: 9802         	ldr	r0, [sp, #0x8]
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0f62: 9008         	str	r0, [sp, #0x20]
700a0f64: e7ff         	b	0x700a0f66 <PMU_init+0x116> @ imm = #-0x2
700a0f66: 9808         	ldr	r0, [sp, #0x20]
700a0f68: 9909         	ldr	r1, [sp, #0x24]
700a0f6a: 6849         	ldr	r1, [r1, #0x4]
700a0f6c: 4288         	cmp	r0, r1
700a0f6e: d20c         	bhs	0x700a0f8a <PMU_init+0x13a> @ imm = #0x18
700a0f70: e7ff         	b	0x700a0f72 <PMU_init+0x122> @ imm = #-0x2
;     CSL_armR5PmuCfgCntr(i, (cfg->eventCounters[i].type & 0xFF));
700a0f72: 9808         	ldr	r0, [sp, #0x20]
700a0f74: 9909         	ldr	r1, [sp, #0x24]
700a0f76: 6889         	ldr	r1, [r1, #0x8]
700a0f78: f811 1030    	ldrb.w	r1, [r1, r0, lsl #3]
700a0f7c: f001 e91e    	blx	0x700a21bc <CSL_armR5PmuCfgCntr> @ imm = #0x123c
;   }
700a0f80: e7ff         	b	0x700a0f82 <PMU_init+0x132> @ imm = #-0x2
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0f82: 9808         	ldr	r0, [sp, #0x20]
700a0f84: 3001         	adds	r0, #0x1
700a0f86: 9008         	str	r0, [sp, #0x20]
700a0f88: e7ed         	b	0x700a0f66 <PMU_init+0x116> @ imm = #-0x26
700a0f8a: 2000         	movs	r0, #0x0
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0f8c: 9008         	str	r0, [sp, #0x20]
700a0f8e: e7ff         	b	0x700a0f90 <PMU_init+0x140> @ imm = #-0x2
700a0f90: 9808         	ldr	r0, [sp, #0x20]
700a0f92: 9909         	ldr	r1, [sp, #0x24]
700a0f94: 6849         	ldr	r1, [r1, #0x4]
700a0f96: 4288         	cmp	r0, r1
700a0f98: d209         	bhs	0x700a0fae <PMU_init+0x15e> @ imm = #0x12
700a0f9a: e7ff         	b	0x700a0f9c <PMU_init+0x14c> @ imm = #-0x2
;     CSL_armR5PmuEnableCntrOverflowIntr(i, 0);
700a0f9c: 9808         	ldr	r0, [sp, #0x20]
700a0f9e: 2100         	movs	r1, #0x0
700a0fa0: f001 e918    	blx	0x700a21d4 <CSL_armR5PmuEnableCntrOverflowIntr> @ imm = #0x1230
;   }
700a0fa4: e7ff         	b	0x700a0fa6 <PMU_init+0x156> @ imm = #-0x2
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0fa6: 9808         	ldr	r0, [sp, #0x20]
700a0fa8: 3001         	adds	r0, #0x1
700a0faa: 9008         	str	r0, [sp, #0x20]
700a0fac: e7f0         	b	0x700a0f90 <PMU_init+0x140> @ imm = #-0x20
;   if (cfg->bCycleCounter == TRUE) {
700a0fae: 9809         	ldr	r0, [sp, #0x24]
700a0fb0: 6800         	ldr	r0, [r0]
700a0fb2: 2801         	cmp	r0, #0x1
700a0fb4: d105         	bne	0x700a0fc2 <PMU_init+0x172> @ imm = #0xa
700a0fb6: e7ff         	b	0x700a0fb8 <PMU_init+0x168> @ imm = #-0x2
700a0fb8: 201f         	movs	r0, #0x1f
700a0fba: 2100         	movs	r1, #0x0
;     CSL_armR5PmuEnableCntrOverflowIntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM, 0);
700a0fbc: f001 e90a    	blx	0x700a21d4 <CSL_armR5PmuEnableCntrOverflowIntr> @ imm = #0x1214
;   }
700a0fc0: e7ff         	b	0x700a0fc2 <PMU_init+0x172> @ imm = #-0x2
;   CSL_armR5PmuResetCntrs();
700a0fc2: f001 e960    	blx	0x700a2284 <CSL_armR5PmuResetCntrs> @ imm = #0x12c0
;   CSL_armR5PmuResetCycleCnt();
700a0fc6: f001 e956    	blx	0x700a2274 <CSL_armR5PmuResetCycleCnt> @ imm = #0x12ac
;   PMU_enableAllCounters(cfg->numEventCounters);
700a0fca: 9809         	ldr	r0, [sp, #0x24]
700a0fcc: 6840         	ldr	r0, [r0, #0x4]
700a0fce: f00d f8ff    	bl	0x700ae1d0 <PMU_enableAllCounters> @ imm = #0xd1fe
700a0fd2: 2000         	movs	r0, #0x0
;   return SystemP_SUCCESS;
700a0fd4: b00a         	add	sp, #0x28
700a0fd6: bd80         	pop	{r7, pc}
		...

700a0fe0 <Sciclient_rmIrqProgramRoute>:
; {
700a0fe0: b580         	push	{r7, lr}
700a0fe2: b092         	sub	sp, #0x48
700a0fe4: 9011         	str	r0, [sp, #0x44]
700a0fe6: f88d 1043    	strb.w	r1, [sp, #0x43]
700a0fea: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a0fec: 900f         	str	r0, [sp, #0x3c]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a0fee: 9003         	str	r0, [sp, #0xc]
;     struct Sciclient_rmIrInst *ir_inst = NULL;
700a0ff0: 9002         	str	r0, [sp, #0x8]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a0ff2: f8ad 003a    	strh.w	r0, [sp, #0x3a]
700a0ff6: e7ff         	b	0x700a0ff8 <Sciclient_rmIrqProgramRoute+0x18> @ imm = #-0x2
700a0ff8: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0ffc: 9001         	str	r0, [sp, #0x4]
700a0ffe: f00e fe47    	bl	0x700afc90 <Sciclient_rmPsGetPsp> @ imm = #0xec8e
700a1002: 4601         	mov	r1, r0
700a1004: 9801         	ldr	r0, [sp, #0x4]
700a1006: 4288         	cmp	r0, r1
700a1008: f280 80aa    	bge.w	0x700a1160 <Sciclient_rmIrqProgramRoute+0x180> @ imm = #0x154
700a100c: e7ff         	b	0x700a100e <Sciclient_rmIrqProgramRoute+0x2e> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a100e: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a1012: f00e fa0d    	bl	0x700af430 <Sciclient_rmPsGetIrqNode> @ imm = #0xe41a
700a1016: 900d         	str	r0, [sp, #0x34]
;         cur_inp = Sciclient_rmPsGetInp(i);
700a1018: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a101c: f00c fe38    	bl	0x700adc90 <Sciclient_rmPsGetInp> @ imm = #0xcc70
700a1020: 900c         	str	r0, [sp, #0x30]
;         cur_outp = Sciclient_rmPsGetOutp(i);
700a1022: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a1026: f00c fe53    	bl	0x700adcd0 <Sciclient_rmPsGetOutp> @ imm = #0xcca6
700a102a: 900b         	str	r0, [sp, #0x2c]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a102c: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a1030: 2800         	cmp	r0, #0x0
700a1032: d154         	bne	0x700a10de <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0xa8
700a1034: e7ff         	b	0x700a1036 <Sciclient_rmIrqProgramRoute+0x56> @ imm = #-0x2
700a1036: 980d         	ldr	r0, [sp, #0x34]
700a1038: 8800         	ldrh	r0, [r0]
700a103a: f00d fc71    	bl	0x700ae920 <Sciclient_rmIaIsIa> @ imm = #0xd8e2
700a103e: 2800         	cmp	r0, #0x0
700a1040: d04d         	beq	0x700a10de <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0x9a
700a1042: e7ff         	b	0x700a1044 <Sciclient_rmIrqProgramRoute+0x64> @ imm = #-0x2
;             (map_vint == true)) {
700a1044: f89d 0043    	ldrb.w	r0, [sp, #0x43]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a1048: 07c0         	lsls	r0, r0, #0x1f
700a104a: 2800         	cmp	r0, #0x0
700a104c: d047         	beq	0x700a10de <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0x8e
700a104e: e7ff         	b	0x700a1050 <Sciclient_rmIrqProgramRoute+0x70> @ imm = #-0x2
700a1050: 203c         	movs	r0, #0x3c
700a1052: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a1056: 9006         	str	r0, [sp, #0x18]
;             req.secondary_host = cfg->host;
700a1058: 9811         	ldr	r0, [sp, #0x44]
700a105a: 7900         	ldrb	r0, [r0, #0x4]
700a105c: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             req.src_id = cfg->s_id;
700a1060: 9811         	ldr	r0, [sp, #0x44]
700a1062: 88c0         	ldrh	r0, [r0, #0x6]
700a1064: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.src_index = cfg->s_idx;
700a1068: 9811         	ldr	r0, [sp, #0x44]
700a106a: 8900         	ldrh	r0, [r0, #0x8]
700a106c: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             req.ia_id = cfg->s_ia;
700a1070: 9811         	ldr	r0, [sp, #0x44]
700a1072: 8a00         	ldrh	r0, [r0, #0x10]
700a1074: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             req.vint = cur_outp;
700a1078: 980b         	ldr	r0, [sp, #0x2c]
700a107a: f8ad 0026    	strh.w	r0, [sp, #0x26]
;             req.global_event = cur_inp;
700a107e: 980c         	ldr	r0, [sp, #0x30]
700a1080: f8ad 0028    	strh.w	r0, [sp, #0x28]
;             req.vint_status_bit_index = cfg->vint_sb;
700a1084: 9811         	ldr	r0, [sp, #0x44]
700a1086: 7d00         	ldrb	r0, [r0, #0x14]
700a1088: f88d 002a    	strb.w	r0, [sp, #0x2a]
;                                       cfg->set_resp,
700a108c: 9811         	ldr	r0, [sp, #0x44]
700a108e: 6981         	ldr	r1, [r0, #0x18]
700a1090: a804         	add	r0, sp, #0x10
700a1092: f04f 32ff    	mov.w	r2, #0xffffffff
;             r = Sciclient_rmIrqSetRaw(&req,
700a1096: f00b fbdb    	bl	0x700ac850 <Sciclient_rmIrqSetRaw> @ imm = #0xb7b6
700a109a: 900f         	str	r0, [sp, #0x3c]
;             if (r == SystemP_SUCCESS) {
700a109c: 980f         	ldr	r0, [sp, #0x3c]
700a109e: b9e8         	cbnz	r0, 0x700a10dc <Sciclient_rmIrqProgramRoute+0xfc> @ imm = #0x3a
700a10a0: e7ff         	b	0x700a10a2 <Sciclient_rmIrqProgramRoute+0xc2> @ imm = #-0x2
;                 ia_inst = Sciclient_rmIaGetInst(cur_n->id);
700a10a2: 980d         	ldr	r0, [sp, #0x34]
700a10a4: 8800         	ldrh	r0, [r0]
700a10a6: f00b fa53    	bl	0x700ac550 <Sciclient_rmIaGetInst> @ imm = #0xb4a6
700a10aa: 9003         	str	r0, [sp, #0xc]
;                 if (ia_inst != NULL) {
700a10ac: 9803         	ldr	r0, [sp, #0xc]
700a10ae: b1a0         	cbz	r0, 0x700a10da <Sciclient_rmIrqProgramRoute+0xfa> @ imm = #0x28
700a10b0: e7ff         	b	0x700a10b2 <Sciclient_rmIrqProgramRoute+0xd2> @ imm = #-0x2
;                     ia_inst->vint_usage_count[cur_outp]++;
700a10b2: 9803         	ldr	r0, [sp, #0xc]
700a10b4: 6901         	ldr	r1, [r0, #0x10]
700a10b6: 9a0b         	ldr	r2, [sp, #0x2c]
700a10b8: 5c88         	ldrb	r0, [r1, r2]
700a10ba: 3001         	adds	r0, #0x1
700a10bc: 5488         	strb	r0, [r1, r2]
;                     if ((cur_outp == 0) && (cfg->vint_sb == 0)) {
700a10be: 980b         	ldr	r0, [sp, #0x2c]
700a10c0: b950         	cbnz	r0, 0x700a10d8 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #0x14
700a10c2: e7ff         	b	0x700a10c4 <Sciclient_rmIrqProgramRoute+0xe4> @ imm = #-0x2
700a10c4: 9811         	ldr	r0, [sp, #0x44]
700a10c6: 7d00         	ldrb	r0, [r0, #0x14]
700a10c8: b930         	cbnz	r0, 0x700a10d8 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #0xc
700a10ca: e7ff         	b	0x700a10cc <Sciclient_rmIrqProgramRoute+0xec> @ imm = #-0x2
;                         ia_inst->v0_b0_evt = cur_inp - ia_inst->sevt_offset;
700a10cc: 980c         	ldr	r0, [sp, #0x30]
700a10ce: 9903         	ldr	r1, [sp, #0xc]
700a10d0: 890a         	ldrh	r2, [r1, #0x8]
700a10d2: 1a80         	subs	r0, r0, r2
700a10d4: 8288         	strh	r0, [r1, #0x14]
;                     }
700a10d6: e7ff         	b	0x700a10d8 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #-0x2
;                 }
700a10d8: e7ff         	b	0x700a10da <Sciclient_rmIrqProgramRoute+0xfa> @ imm = #-0x2
;             }
700a10da: e7ff         	b	0x700a10dc <Sciclient_rmIrqProgramRoute+0xfc> @ imm = #-0x2
;         }
700a10dc: e7ff         	b	0x700a10de <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #-0x2
;         if (i > 0u) {
700a10de: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a10e2: b390         	cbz	r0, 0x700a114a <Sciclient_rmIrqProgramRoute+0x16a> @ imm = #0x64
700a10e4: e7ff         	b	0x700a10e6 <Sciclient_rmIrqProgramRoute+0x106> @ imm = #-0x2
700a10e6: 2003         	movs	r0, #0x3
700a10e8: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_DST_ID_VALID |
700a10ec: 9006         	str	r0, [sp, #0x18]
;             req.secondary_host = cfg->host;
700a10ee: 9811         	ldr	r0, [sp, #0x44]
700a10f0: 7900         	ldrb	r0, [r0, #0x4]
700a10f2: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             req.src_id = cur_n->id;
700a10f6: 980d         	ldr	r0, [sp, #0x34]
700a10f8: 8800         	ldrh	r0, [r0]
700a10fa: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.src_index = cur_inp;
700a10fe: 980c         	ldr	r0, [sp, #0x30]
700a1100: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             req.dst_id = cur_n->id;
700a1104: 980d         	ldr	r0, [sp, #0x34]
700a1106: 8800         	ldrh	r0, [r0]
700a1108: f8ad 0020    	strh.w	r0, [sp, #0x20]
;             req.dst_host_irq = cur_outp;
700a110c: 980b         	ldr	r0, [sp, #0x2c]
700a110e: f8ad 0022    	strh.w	r0, [sp, #0x22]
;                                       cfg->set_resp,
700a1112: 9811         	ldr	r0, [sp, #0x44]
700a1114: 6981         	ldr	r1, [r0, #0x18]
700a1116: a804         	add	r0, sp, #0x10
700a1118: f04f 32ff    	mov.w	r2, #0xffffffff
;             r = Sciclient_rmIrqSetRaw(&req,
700a111c: f00b fb98    	bl	0x700ac850 <Sciclient_rmIrqSetRaw> @ imm = #0xb730
700a1120: 900f         	str	r0, [sp, #0x3c]
;             if ((r == SystemP_SUCCESS) && (cur_outp == 0)) {
700a1122: 980f         	ldr	r0, [sp, #0x3c]
700a1124: b980         	cbnz	r0, 0x700a1148 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #0x20
700a1126: e7ff         	b	0x700a1128 <Sciclient_rmIrqProgramRoute+0x148> @ imm = #-0x2
700a1128: 980b         	ldr	r0, [sp, #0x2c]
700a112a: b968         	cbnz	r0, 0x700a1148 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #0x1a
700a112c: e7ff         	b	0x700a112e <Sciclient_rmIrqProgramRoute+0x14e> @ imm = #-0x2
;                 ir_inst = Sciclient_rmIrGetInst(cur_n->id);
700a112e: 980d         	ldr	r0, [sp, #0x34]
700a1130: 8800         	ldrh	r0, [r0]
700a1132: f00a fd25    	bl	0x700abb80 <Sciclient_rmIrGetInst> @ imm = #0xaa4a
700a1136: 9002         	str	r0, [sp, #0x8]
;                 if (ir_inst != NULL) {
700a1138: 9802         	ldr	r0, [sp, #0x8]
700a113a: b120         	cbz	r0, 0x700a1146 <Sciclient_rmIrqProgramRoute+0x166> @ imm = #0x8
700a113c: e7ff         	b	0x700a113e <Sciclient_rmIrqProgramRoute+0x15e> @ imm = #-0x2
;                     ir_inst->inp0_mapping = cur_outp;
700a113e: 980b         	ldr	r0, [sp, #0x2c]
700a1140: 9902         	ldr	r1, [sp, #0x8]
700a1142: 8188         	strh	r0, [r1, #0xc]
;                 }
700a1144: e7ff         	b	0x700a1146 <Sciclient_rmIrqProgramRoute+0x166> @ imm = #-0x2
;             }
700a1146: e7ff         	b	0x700a1148 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #-0x2
;         }
700a1148: e7ff         	b	0x700a114a <Sciclient_rmIrqProgramRoute+0x16a> @ imm = #-0x2
;         if (r != SystemP_SUCCESS) {
700a114a: 980f         	ldr	r0, [sp, #0x3c]
700a114c: b108         	cbz	r0, 0x700a1152 <Sciclient_rmIrqProgramRoute+0x172> @ imm = #0x2
700a114e: e7ff         	b	0x700a1150 <Sciclient_rmIrqProgramRoute+0x170> @ imm = #-0x2
;             break;
700a1150: e006         	b	0x700a1160 <Sciclient_rmIrqProgramRoute+0x180> @ imm = #0xc
;     }
700a1152: e7ff         	b	0x700a1154 <Sciclient_rmIrqProgramRoute+0x174> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a1154: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a1158: 3001         	adds	r0, #0x1
700a115a: f8ad 003a    	strh.w	r0, [sp, #0x3a]
700a115e: e74b         	b	0x700a0ff8 <Sciclient_rmIrqProgramRoute+0x18> @ imm = #-0x16a
;     return r;
700a1160: 980f         	ldr	r0, [sp, #0x3c]
700a1162: b012         	add	sp, #0x48
700a1164: bd80         	pop	{r7, pc}
		...
700a116e: 0000         	movs	r0, r0

700a1170 <Udma_chEnableLocal>:
; {
700a1170: b580         	push	{r7, lr}
700a1172: b08e         	sub	sp, #0x38
700a1174: 900d         	str	r0, [sp, #0x34]
;     drvHandle = chHandle->drvHandle;
700a1176: 980d         	ldr	r0, [sp, #0x34]
700a1178: 6e80         	ldr	r0, [r0, #0x68]
700a117a: 900b         	str	r0, [sp, #0x2c]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a117c: 980b         	ldr	r0, [sp, #0x2c]
700a117e: 6800         	ldr	r0, [r0]
700a1180: 2801         	cmp	r0, #0x1
700a1182: d163         	bne	0x700a124c <Udma_chEnableLocal+0xdc> @ imm = #0xc6
700a1184: e7ff         	b	0x700a1186 <Udma_chEnableLocal+0x16> @ imm = #-0x2
700a1186: 2001         	movs	r0, #0x1
;         bcdmaRtEnable.enable         = TRUE;
700a1188: 9005         	str	r0, [sp, #0x14]
700a118a: 2000         	movs	r0, #0x0
;         bcdmaRtEnable.teardown       = FALSE;
700a118c: 9006         	str	r0, [sp, #0x18]
;         bcdmaRtEnable.forcedTeardown = FALSE;
700a118e: 9009         	str	r0, [sp, #0x24]
;         bcdmaRtEnable.pause          = FALSE;
700a1190: 9007         	str	r0, [sp, #0x1c]
;         bcdmaRtEnable.error          = FALSE;
700a1192: 9008         	str	r0, [sp, #0x20]
;         if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a1194: 980d         	ldr	r0, [sp, #0x34]
700a1196: 7800         	ldrb	r0, [r0]
700a1198: 0740         	lsls	r0, r0, #0x1d
700a119a: 2800         	cmp	r0, #0x0
700a119c: d508         	bpl	0x700a11b0 <Udma_chEnableLocal+0x40> @ imm = #0x10
700a119e: e7ff         	b	0x700a11a0 <Udma_chEnableLocal+0x30> @ imm = #-0x2
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum , &bcdmaRtEnable);
700a11a0: 980b         	ldr	r0, [sp, #0x2c]
700a11a2: 3008         	adds	r0, #0x8
700a11a4: 990d         	ldr	r1, [sp, #0x34]
700a11a6: 6ec9         	ldr	r1, [r1, #0x6c]
700a11a8: aa05         	add	r2, sp, #0x14
700a11aa: f00d fcd9    	bl	0x700aeb60 <CSL_bcdmaSetTxRT> @ imm = #0xd9b2
;         }
700a11ae: e04c         	b	0x700a124a <Udma_chEnableLocal+0xda> @ imm = #0x98
;         else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a11b0: 980d         	ldr	r0, [sp, #0x34]
700a11b2: 7800         	ldrb	r0, [r0]
700a11b4: 07c0         	lsls	r0, r0, #0x1f
700a11b6: b300         	cbz	r0, 0x700a11fa <Udma_chEnableLocal+0x8a> @ imm = #0x40
700a11b8: e7ff         	b	0x700a11ba <Udma_chEnableLocal+0x4a> @ imm = #-0x2
;             regVal = CSL_REG32_RD(&chHandle->pBcdmaTxRtRegs->PEER8);
700a11ba: 980d         	ldr	r0, [sp, #0x34]
700a11bc: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a11c0: f500 7008    	add.w	r0, r0, #0x220
700a11c4: f00e fd4c    	bl	0x700afc60 <CSL_REG32_RD_RAW> @ imm = #0xea98
700a11c8: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a11ca: 980c         	ldr	r0, [sp, #0x30]
700a11cc: f040 4000    	orr	r0, r0, #0x80000000
700a11d0: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pBcdmaTxRtRegs->PEER8, regVal);
700a11d2: 980d         	ldr	r0, [sp, #0x34]
700a11d4: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a11d8: f500 7008    	add.w	r0, r0, #0x220
700a11dc: 990c         	ldr	r1, [sp, #0x30]
700a11de: f00e fc9f    	bl	0x700afb20 <CSL_REG32_WR_RAW> @ imm = #0xe93e
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtEnable);
700a11e2: 9a0b         	ldr	r2, [sp, #0x2c]
700a11e4: f102 0008    	add.w	r0, r2, #0x8
700a11e8: 990d         	ldr	r1, [sp, #0x34]
700a11ea: 6ec9         	ldr	r1, [r1, #0x6c]
700a11ec: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
700a11f0: 4411         	add	r1, r2
700a11f2: aa05         	add	r2, sp, #0x14
700a11f4: f00d fcb4    	bl	0x700aeb60 <CSL_bcdmaSetTxRT> @ imm = #0xd968
;         }
700a11f8: e026         	b	0x700a1248 <Udma_chEnableLocal+0xd8> @ imm = #0x4c
;         else if ((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a11fa: 980d         	ldr	r0, [sp, #0x34]
700a11fc: 7800         	ldrb	r0, [r0]
700a11fe: 0780         	lsls	r0, r0, #0x1e
700a1200: 2800         	cmp	r0, #0x0
700a1202: d520         	bpl	0x700a1246 <Udma_chEnableLocal+0xd6> @ imm = #0x40
700a1204: e7ff         	b	0x700a1206 <Udma_chEnableLocal+0x96> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtEnable);
700a1206: 9a0b         	ldr	r2, [sp, #0x2c]
700a1208: f102 0008    	add.w	r0, r2, #0x8
700a120c: 990d         	ldr	r1, [sp, #0x34]
700a120e: 6f09         	ldr	r1, [r1, #0x70]
700a1210: f8d2 2114    	ldr.w	r2, [r2, #0x114]
700a1214: 4411         	add	r1, r2
700a1216: aa05         	add	r2, sp, #0x14
;             (void) CSL_bcdmaSetRxRT(
700a1218: f00d fc8a    	bl	0x700aeb30 <CSL_bcdmaSetRxRT> @ imm = #0xd914
;             regVal = CSL_REG32_RD(&chHandle->pBcdmaRxRtRegs->PEER8);
700a121c: 980d         	ldr	r0, [sp, #0x34]
700a121e: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a1222: f500 7008    	add.w	r0, r0, #0x220
700a1226: f00e fd1b    	bl	0x700afc60 <CSL_REG32_RD_RAW> @ imm = #0xea36
700a122a: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a122c: 980c         	ldr	r0, [sp, #0x30]
700a122e: f040 4000    	orr	r0, r0, #0x80000000
700a1232: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pBcdmaRxRtRegs->PEER8, regVal);
700a1234: 980d         	ldr	r0, [sp, #0x34]
700a1236: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a123a: f500 7008    	add.w	r0, r0, #0x220
700a123e: 990c         	ldr	r1, [sp, #0x30]
700a1240: f00e fc6e    	bl	0x700afb20 <CSL_REG32_WR_RAW> @ imm = #0xe8dc
;         }
700a1244: e7ff         	b	0x700a1246 <Udma_chEnableLocal+0xd6> @ imm = #-0x2
700a1246: e7ff         	b	0x700a1248 <Udma_chEnableLocal+0xd8> @ imm = #-0x2
700a1248: e7ff         	b	0x700a124a <Udma_chEnableLocal+0xda> @ imm = #-0x2
;     }
700a124a: e050         	b	0x700a12ee <Udma_chEnableLocal+0x17e> @ imm = #0xa0
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a124c: 980b         	ldr	r0, [sp, #0x2c]
700a124e: 6800         	ldr	r0, [r0]
700a1250: 2802         	cmp	r0, #0x2
700a1252: d14b         	bne	0x700a12ec <Udma_chEnableLocal+0x17c> @ imm = #0x96
700a1254: e7ff         	b	0x700a1256 <Udma_chEnableLocal+0xe6> @ imm = #-0x2
700a1256: 2001         	movs	r0, #0x1
;         pktdmaRtEnable.enable         = TRUE;
700a1258: 9000         	str	r0, [sp]
700a125a: 2000         	movs	r0, #0x0
;         pktdmaRtEnable.teardown       = FALSE;
700a125c: 9001         	str	r0, [sp, #0x4]
;         pktdmaRtEnable.forcedTeardown = FALSE;
700a125e: 9004         	str	r0, [sp, #0x10]
;         pktdmaRtEnable.pause          = FALSE;
700a1260: 9002         	str	r0, [sp, #0x8]
;         pktdmaRtEnable.error          = FALSE;
700a1262: 9003         	str	r0, [sp, #0xc]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a1264: 980d         	ldr	r0, [sp, #0x34]
700a1266: 7800         	ldrb	r0, [r0]
700a1268: 07c0         	lsls	r0, r0, #0x1f
700a126a: b1e0         	cbz	r0, 0x700a12a6 <Udma_chEnableLocal+0x136> @ imm = #0x38
700a126c: e7ff         	b	0x700a126e <Udma_chEnableLocal+0xfe> @ imm = #-0x2
;             regVal = CSL_REG32_RD(&chHandle->pPktdmaTxRtRegs->PEER8);
700a126e: 980d         	ldr	r0, [sp, #0x34]
700a1270: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a1274: f500 7008    	add.w	r0, r0, #0x220
700a1278: f00e fcf2    	bl	0x700afc60 <CSL_REG32_RD_RAW> @ imm = #0xe9e4
700a127c: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a127e: 980c         	ldr	r0, [sp, #0x30]
700a1280: f040 4000    	orr	r0, r0, #0x80000000
700a1284: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pPktdmaTxRtRegs->PEER8, regVal);
700a1286: 980d         	ldr	r0, [sp, #0x34]
700a1288: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a128c: f500 7008    	add.w	r0, r0, #0x220
700a1290: 990c         	ldr	r1, [sp, #0x30]
700a1292: f00e fc45    	bl	0x700afb20 <CSL_REG32_WR_RAW> @ imm = #0xe88a
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtEnable);
700a1296: 980b         	ldr	r0, [sp, #0x2c]
700a1298: 3054         	adds	r0, #0x54
700a129a: 990d         	ldr	r1, [sp, #0x34]
700a129c: 6ec9         	ldr	r1, [r1, #0x6c]
700a129e: 466a         	mov	r2, sp
700a12a0: f00c fe96    	bl	0x700adfd0 <CSL_pktdmaSetTxRT> @ imm = #0xcd2c
;         }
700a12a4: e7ff         	b	0x700a12a6 <Udma_chEnableLocal+0x136> @ imm = #-0x2
;         if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a12a6: 980d         	ldr	r0, [sp, #0x34]
700a12a8: 7800         	ldrb	r0, [r0]
700a12aa: 0780         	lsls	r0, r0, #0x1e
700a12ac: 2800         	cmp	r0, #0x0
700a12ae: d51c         	bpl	0x700a12ea <Udma_chEnableLocal+0x17a> @ imm = #0x38
700a12b0: e7ff         	b	0x700a12b2 <Udma_chEnableLocal+0x142> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtEnable);
700a12b2: 980b         	ldr	r0, [sp, #0x2c]
700a12b4: 3054         	adds	r0, #0x54
700a12b6: 990d         	ldr	r1, [sp, #0x34]
700a12b8: 6f09         	ldr	r1, [r1, #0x70]
700a12ba: 466a         	mov	r2, sp
;             (void) CSL_pktdmaSetRxRT(
700a12bc: f00c fe68    	bl	0x700adf90 <CSL_pktdmaSetRxRT> @ imm = #0xccd0
;             regVal = CSL_REG32_RD(&chHandle->pPktdmaRxRtRegs->PEER8);
700a12c0: 980d         	ldr	r0, [sp, #0x34]
700a12c2: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a12c6: f500 7008    	add.w	r0, r0, #0x220
700a12ca: f00e fcc9    	bl	0x700afc60 <CSL_REG32_RD_RAW> @ imm = #0xe992
700a12ce: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a12d0: 980c         	ldr	r0, [sp, #0x30]
700a12d2: f040 4000    	orr	r0, r0, #0x80000000
700a12d6: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pPktdmaRxRtRegs->PEER8, regVal);
700a12d8: 980d         	ldr	r0, [sp, #0x34]
700a12da: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a12de: f500 7008    	add.w	r0, r0, #0x220
700a12e2: 990c         	ldr	r1, [sp, #0x30]
700a12e4: f00e fc1c    	bl	0x700afb20 <CSL_REG32_WR_RAW> @ imm = #0xe838
;         }
700a12e8: e7ff         	b	0x700a12ea <Udma_chEnableLocal+0x17a> @ imm = #-0x2
;     }
700a12ea: e7ff         	b	0x700a12ec <Udma_chEnableLocal+0x17c> @ imm = #-0x2
700a12ec: e7ff         	b	0x700a12ee <Udma_chEnableLocal+0x17e> @ imm = #-0x2
;     return;
700a12ee: b00e         	add	sp, #0x38
700a12f0: bd80         	pop	{r7, pc}
		...
700a12fe: 0000         	movs	r0, r0

700a1300 <Udma_chConfigPdma>:
; {
700a1300: b580         	push	{r7, lr}
700a1302: b08a         	sub	sp, #0x28
700a1304: 9009         	str	r0, [sp, #0x24]
700a1306: 9108         	str	r1, [sp, #0x20]
700a1308: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a130a: 9007         	str	r0, [sp, #0x1c]
;     volatile uint32_t  *PEER8=NULL, *PEER0=NULL, *PEER1=NULL;
700a130c: 9006         	str	r0, [sp, #0x18]
700a130e: 9005         	str	r0, [sp, #0x14]
700a1310: 9004         	str	r0, [sp, #0x10]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a1312: 9809         	ldr	r0, [sp, #0x24]
700a1314: 9002         	str	r0, [sp, #0x8]
;     if((NULL_PTR == chHandleInt) ||
700a1316: 9802         	ldr	r0, [sp, #0x8]
700a1318: b1a0         	cbz	r0, 0x700a1344 <Udma_chConfigPdma+0x44> @ imm = #0x28
700a131a: e7ff         	b	0x700a131c <Udma_chConfigPdma+0x1c> @ imm = #-0x2
;        (NULL_PTR == pdmaPrms) ||
700a131c: 9808         	ldr	r0, [sp, #0x20]
700a131e: b188         	cbz	r0, 0x700a1344 <Udma_chConfigPdma+0x44> @ imm = #0x22
700a1320: e7ff         	b	0x700a1322 <Udma_chConfigPdma+0x22> @ imm = #-0x2
;        (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
700a1322: 9802         	ldr	r0, [sp, #0x8]
700a1324: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a1328: f64a 31cd    	movw	r1, #0xabcd
700a132c: f6ca 31dc    	movt	r1, #0xabdc
700a1330: 4288         	cmp	r0, r1
700a1332: d107         	bne	0x700a1344 <Udma_chConfigPdma+0x44> @ imm = #0xe
700a1334: e7ff         	b	0x700a1336 <Udma_chConfigPdma+0x36> @ imm = #-0x2
;        ((chHandleInt->chType & UDMA_CH_FLAG_PDMA) != UDMA_CH_FLAG_PDMA))
700a1336: 9802         	ldr	r0, [sp, #0x8]
700a1338: 6800         	ldr	r0, [r0]
700a133a: f000 0008    	and	r0, r0, #0x8
;     if((NULL_PTR == chHandleInt) ||
700a133e: 2808         	cmp	r0, #0x8
700a1340: d004         	beq	0x700a134c <Udma_chConfigPdma+0x4c> @ imm = #0x8
700a1342: e7ff         	b	0x700a1344 <Udma_chConfigPdma+0x44> @ imm = #-0x2
700a1344: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a1348: 9007         	str	r0, [sp, #0x1c]
;     }
700a134a: e7ff         	b	0x700a134c <Udma_chConfigPdma+0x4c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a134c: 9807         	ldr	r0, [sp, #0x1c]
700a134e: b9a8         	cbnz	r0, 0x700a137c <Udma_chConfigPdma+0x7c> @ imm = #0x2a
700a1350: e7ff         	b	0x700a1352 <Udma_chConfigPdma+0x52> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a1352: 9802         	ldr	r0, [sp, #0x8]
700a1354: 6e80         	ldr	r0, [r0, #0x68]
700a1356: 9003         	str	r0, [sp, #0xc]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a1358: 9803         	ldr	r0, [sp, #0xc]
700a135a: b150         	cbz	r0, 0x700a1372 <Udma_chConfigPdma+0x72> @ imm = #0x14
700a135c: e7ff         	b	0x700a135e <Udma_chConfigPdma+0x5e> @ imm = #-0x2
700a135e: 9803         	ldr	r0, [sp, #0xc]
700a1360: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a1364: f64a 31cd    	movw	r1, #0xabcd
700a1368: f6ca 31dc    	movt	r1, #0xabdc
700a136c: 4288         	cmp	r0, r1
700a136e: d004         	beq	0x700a137a <Udma_chConfigPdma+0x7a> @ imm = #0x8
700a1370: e7ff         	b	0x700a1372 <Udma_chConfigPdma+0x72> @ imm = #-0x2
700a1372: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a1376: 9007         	str	r0, [sp, #0x1c]
;         }
700a1378: e7ff         	b	0x700a137a <Udma_chConfigPdma+0x7a> @ imm = #-0x2
;     }
700a137a: e7ff         	b	0x700a137c <Udma_chConfigPdma+0x7c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a137c: 9807         	ldr	r0, [sp, #0x1c]
700a137e: 2800         	cmp	r0, #0x0
700a1380: d17a         	bne	0x700a1478 <Udma_chConfigPdma+0x178> @ imm = #0xf4
700a1382: e7ff         	b	0x700a1384 <Udma_chConfigPdma+0x84> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a1384: 9803         	ldr	r0, [sp, #0xc]
700a1386: 6800         	ldr	r0, [r0]
700a1388: 2801         	cmp	r0, #0x1
700a138a: d137         	bne	0x700a13fc <Udma_chConfigPdma+0xfc> @ imm = #0x6e
700a138c: e7ff         	b	0x700a138e <Udma_chConfigPdma+0x8e> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a138e: 9802         	ldr	r0, [sp, #0x8]
700a1390: 7800         	ldrb	r0, [r0]
700a1392: 07c0         	lsls	r0, r0, #0x1f
700a1394: b198         	cbz	r0, 0x700a13be <Udma_chConfigPdma+0xbe> @ imm = #0x26
700a1396: e7ff         	b	0x700a1398 <Udma_chConfigPdma+0x98> @ imm = #-0x2
;                 PEER8 = &chHandleInt->pBcdmaTxRtRegs->PEER8;
700a1398: 9802         	ldr	r0, [sp, #0x8]
700a139a: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a139e: f500 7008    	add.w	r0, r0, #0x220
700a13a2: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pBcdmaTxRtRegs->PEER1;
700a13a4: 9802         	ldr	r0, [sp, #0x8]
700a13a6: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a13aa: f500 7001    	add.w	r0, r0, #0x204
700a13ae: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pBcdmaTxRtRegs->PEER0;
700a13b0: 9802         	ldr	r0, [sp, #0x8]
700a13b2: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a13b6: f500 7000    	add.w	r0, r0, #0x200
700a13ba: 9005         	str	r0, [sp, #0x14]
;             }
700a13bc: e012         	b	0x700a13e4 <Udma_chConfigPdma+0xe4> @ imm = #0x24
;                 PEER8 = &chHandleInt->pBcdmaRxRtRegs->PEER8;
700a13be: 9802         	ldr	r0, [sp, #0x8]
700a13c0: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a13c4: f500 7008    	add.w	r0, r0, #0x220
700a13c8: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pBcdmaRxRtRegs->PEER1;
700a13ca: 9802         	ldr	r0, [sp, #0x8]
700a13cc: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a13d0: f500 7001    	add.w	r0, r0, #0x204
700a13d4: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pBcdmaRxRtRegs->PEER0;
700a13d6: 9802         	ldr	r0, [sp, #0x8]
700a13d8: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a13dc: f500 7000    	add.w	r0, r0, #0x200
700a13e0: 9005         	str	r0, [sp, #0x14]
700a13e2: e7ff         	b	0x700a13e4 <Udma_chConfigPdma+0xe4> @ imm = #-0x2
;             Udma_chSetPeerReg(drvHandle, pdmaPrms, PEER8, PEER1, PEER0);
700a13e4: 9803         	ldr	r0, [sp, #0xc]
700a13e6: 9908         	ldr	r1, [sp, #0x20]
700a13e8: 9a06         	ldr	r2, [sp, #0x18]
700a13ea: 9b04         	ldr	r3, [sp, #0x10]
700a13ec: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a13f0: 46ee         	mov	lr, sp
700a13f2: f8ce c000    	str.w	r12, [lr]
700a13f6: f00b fc8b    	bl	0x700acd10 <Udma_chSetPeerReg> @ imm = #0xb916
;         }
700a13fa: e03c         	b	0x700a1476 <Udma_chConfigPdma+0x176> @ imm = #0x78
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a13fc: 9803         	ldr	r0, [sp, #0xc]
700a13fe: 6800         	ldr	r0, [r0]
700a1400: 2802         	cmp	r0, #0x2
700a1402: d137         	bne	0x700a1474 <Udma_chConfigPdma+0x174> @ imm = #0x6e
700a1404: e7ff         	b	0x700a1406 <Udma_chConfigPdma+0x106> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a1406: 9802         	ldr	r0, [sp, #0x8]
700a1408: 7800         	ldrb	r0, [r0]
700a140a: 07c0         	lsls	r0, r0, #0x1f
700a140c: b198         	cbz	r0, 0x700a1436 <Udma_chConfigPdma+0x136> @ imm = #0x26
700a140e: e7ff         	b	0x700a1410 <Udma_chConfigPdma+0x110> @ imm = #-0x2
;                 PEER8 = &chHandleInt->pPktdmaTxRtRegs->PEER8;
700a1410: 9802         	ldr	r0, [sp, #0x8]
700a1412: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a1416: f500 7008    	add.w	r0, r0, #0x220
700a141a: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pPktdmaTxRtRegs->PEER1;
700a141c: 9802         	ldr	r0, [sp, #0x8]
700a141e: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a1422: f500 7001    	add.w	r0, r0, #0x204
700a1426: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pPktdmaTxRtRegs->PEER0;
700a1428: 9802         	ldr	r0, [sp, #0x8]
700a142a: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a142e: f500 7000    	add.w	r0, r0, #0x200
700a1432: 9005         	str	r0, [sp, #0x14]
;             }
700a1434: e012         	b	0x700a145c <Udma_chConfigPdma+0x15c> @ imm = #0x24
;                 PEER8 = &chHandleInt->pPktdmaRxRtRegs->PEER8;
700a1436: 9802         	ldr	r0, [sp, #0x8]
700a1438: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a143c: f500 7008    	add.w	r0, r0, #0x220
700a1440: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pPktdmaRxRtRegs->PEER1;
700a1442: 9802         	ldr	r0, [sp, #0x8]
700a1444: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a1448: f500 7001    	add.w	r0, r0, #0x204
700a144c: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pPktdmaRxRtRegs->PEER0;
700a144e: 9802         	ldr	r0, [sp, #0x8]
700a1450: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a1454: f500 7000    	add.w	r0, r0, #0x200
700a1458: 9005         	str	r0, [sp, #0x14]
700a145a: e7ff         	b	0x700a145c <Udma_chConfigPdma+0x15c> @ imm = #-0x2
;             Udma_chSetPeerReg(drvHandle, pdmaPrms, PEER8, PEER1, PEER0);
700a145c: 9803         	ldr	r0, [sp, #0xc]
700a145e: 9908         	ldr	r1, [sp, #0x20]
700a1460: 9a06         	ldr	r2, [sp, #0x18]
700a1462: 9b04         	ldr	r3, [sp, #0x10]
700a1464: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a1468: 46ee         	mov	lr, sp
700a146a: f8ce c000    	str.w	r12, [lr]
700a146e: f00b fc4f    	bl	0x700acd10 <Udma_chSetPeerReg> @ imm = #0xb89e
;         }
700a1472: e7ff         	b	0x700a1474 <Udma_chConfigPdma+0x174> @ imm = #-0x2
700a1474: e7ff         	b	0x700a1476 <Udma_chConfigPdma+0x176> @ imm = #-0x2
;     }
700a1476: e7ff         	b	0x700a1478 <Udma_chConfigPdma+0x178> @ imm = #-0x2
;     return (retVal);
700a1478: 9807         	ldr	r0, [sp, #0x1c]
700a147a: b00a         	add	sp, #0x28
700a147c: bd80         	pop	{r7, pc}
700a147e: 0000         	movs	r0, r0

700a1480 <xQueueSemaphoreTake>:
; {
700a1480: b580         	push	{r7, lr}
700a1482: b08a         	sub	sp, #0x28
700a1484: 9008         	str	r0, [sp, #0x20]
700a1486: 9107         	str	r1, [sp, #0x1c]
700a1488: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
700a148a: 9006         	str	r0, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a148c: 9908         	ldr	r1, [sp, #0x20]
700a148e: 9103         	str	r1, [sp, #0xc]
;         BaseType_t xInheritanceOccurred = pdFALSE;
700a1490: 9002         	str	r0, [sp, #0x8]
;     for( ; ; )
700a1492: e7ff         	b	0x700a1494 <xQueueSemaphoreTake+0x14> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a1494: f00d f974    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0xd2e8
;             const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
700a1498: 9803         	ldr	r0, [sp, #0xc]
700a149a: 6b80         	ldr	r0, [r0, #0x38]
700a149c: 9001         	str	r0, [sp, #0x4]
;             if( uxSemaphoreCount > ( UBaseType_t ) 0 )
700a149e: 9801         	ldr	r0, [sp, #0x4]
700a14a0: b310         	cbz	r0, 0x700a14e8 <xQueueSemaphoreTake+0x68> @ imm = #0x44
700a14a2: e7ff         	b	0x700a14a4 <xQueueSemaphoreTake+0x24> @ imm = #-0x2
;                 pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
700a14a4: 9801         	ldr	r0, [sp, #0x4]
700a14a6: 3801         	subs	r0, #0x1
700a14a8: 9903         	ldr	r1, [sp, #0xc]
700a14aa: 6388         	str	r0, [r1, #0x38]
;                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a14ac: 9803         	ldr	r0, [sp, #0xc]
700a14ae: 6800         	ldr	r0, [r0]
700a14b0: b928         	cbnz	r0, 0x700a14be <xQueueSemaphoreTake+0x3e> @ imm = #0xa
700a14b2: e7ff         	b	0x700a14b4 <xQueueSemaphoreTake+0x34> @ imm = #-0x2
;                             pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
700a14b4: f00d fbe4    	bl	0x700aec80 <pvTaskIncrementMutexHeldCount> @ imm = #0xd7c8
700a14b8: 9903         	ldr	r1, [sp, #0xc]
700a14ba: 6088         	str	r0, [r1, #0x8]
;                         }
700a14bc: e000         	b	0x700a14c0 <xQueueSemaphoreTake+0x40> @ imm = #0x0
700a14be: e7ff         	b	0x700a14c0 <xQueueSemaphoreTake+0x40> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a14c0: 9803         	ldr	r0, [sp, #0xc]
700a14c2: 6900         	ldr	r0, [r0, #0x10]
700a14c4: b150         	cbz	r0, 0x700a14dc <xQueueSemaphoreTake+0x5c> @ imm = #0x14
700a14c6: e7ff         	b	0x700a14c8 <xQueueSemaphoreTake+0x48> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a14c8: 9803         	ldr	r0, [sp, #0xc]
700a14ca: 3010         	adds	r0, #0x10
700a14cc: f006 fb20    	bl	0x700a7b10 <xTaskRemoveFromEventList> @ imm = #0x6640
700a14d0: b110         	cbz	r0, 0x700a14d8 <xQueueSemaphoreTake+0x58> @ imm = #0x4
700a14d2: e7ff         	b	0x700a14d4 <xQueueSemaphoreTake+0x54> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
700a14d4: df00         	svc	#0x0
;                     }
700a14d6: e000         	b	0x700a14da <xQueueSemaphoreTake+0x5a> @ imm = #0x0
700a14d8: e7ff         	b	0x700a14da <xQueueSemaphoreTake+0x5a> @ imm = #-0x2
;                 }
700a14da: e000         	b	0x700a14de <xQueueSemaphoreTake+0x5e> @ imm = #0x0
700a14dc: e7ff         	b	0x700a14de <xQueueSemaphoreTake+0x5e> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a14de: f00c fa0f    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xc41e
700a14e2: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a14e4: 9009         	str	r0, [sp, #0x24]
700a14e6: e083         	b	0x700a15f0 <xQueueSemaphoreTake+0x170> @ imm = #0x106
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a14e8: 9807         	ldr	r0, [sp, #0x1c]
700a14ea: b928         	cbnz	r0, 0x700a14f8 <xQueueSemaphoreTake+0x78> @ imm = #0xa
700a14ec: e7ff         	b	0x700a14ee <xQueueSemaphoreTake+0x6e> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a14ee: f00c fa07    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xc40e
700a14f2: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
700a14f4: 9009         	str	r0, [sp, #0x24]
700a14f6: e07b         	b	0x700a15f0 <xQueueSemaphoreTake+0x170> @ imm = #0xf6
;                 else if( xEntryTimeSet == pdFALSE )
700a14f8: 9806         	ldr	r0, [sp, #0x18]
700a14fa: b930         	cbnz	r0, 0x700a150a <xQueueSemaphoreTake+0x8a> @ imm = #0xc
700a14fc: e7ff         	b	0x700a14fe <xQueueSemaphoreTake+0x7e> @ imm = #-0x2
700a14fe: a804         	add	r0, sp, #0x10
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a1500: f00d feb6    	bl	0x700af270 <vTaskInternalSetTimeOutState> @ imm = #0xdd6c
700a1504: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a1506: 9006         	str	r0, [sp, #0x18]
;                 }
700a1508: e000         	b	0x700a150c <xQueueSemaphoreTake+0x8c> @ imm = #0x0
700a150a: e7ff         	b	0x700a150c <xQueueSemaphoreTake+0x8c> @ imm = #-0x2
700a150c: e7ff         	b	0x700a150e <xQueueSemaphoreTake+0x8e> @ imm = #-0x2
700a150e: e7ff         	b	0x700a1510 <xQueueSemaphoreTake+0x90> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a1510: f00c f9f6    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xc3ec
;         vTaskSuspendAll();
700a1514: f00e fb5c    	bl	0x700afbd0 <vTaskSuspendAll> @ imm = #0xe6b8
;         prvLockQueue( pxQueue );
700a1518: f00d f932    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0xd264
700a151c: 9803         	ldr	r0, [sp, #0xc]
700a151e: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a1522: 3001         	adds	r0, #0x1
700a1524: b928         	cbnz	r0, 0x700a1532 <xQueueSemaphoreTake+0xb2> @ imm = #0xa
700a1526: e7ff         	b	0x700a1528 <xQueueSemaphoreTake+0xa8> @ imm = #-0x2
700a1528: 9903         	ldr	r1, [sp, #0xc]
700a152a: 2000         	movs	r0, #0x0
700a152c: f881 0044    	strb.w	r0, [r1, #0x44]
700a1530: e7ff         	b	0x700a1532 <xQueueSemaphoreTake+0xb2> @ imm = #-0x2
700a1532: 9803         	ldr	r0, [sp, #0xc]
700a1534: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a1538: 3001         	adds	r0, #0x1
700a153a: b928         	cbnz	r0, 0x700a1548 <xQueueSemaphoreTake+0xc8> @ imm = #0xa
700a153c: e7ff         	b	0x700a153e <xQueueSemaphoreTake+0xbe> @ imm = #-0x2
700a153e: 9903         	ldr	r1, [sp, #0xc]
700a1540: 2000         	movs	r0, #0x0
700a1542: f881 0045    	strb.w	r0, [r1, #0x45]
700a1546: e7ff         	b	0x700a1548 <xQueueSemaphoreTake+0xc8> @ imm = #-0x2
700a1548: f00c f9da    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xc3b4
700a154c: a804         	add	r0, sp, #0x10
700a154e: a907         	add	r1, sp, #0x1c
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a1550: f007 fe96    	bl	0x700a9280 <xTaskCheckForTimeOut> @ imm = #0x7d2c
700a1554: bb58         	cbnz	r0, 0x700a15ae <xQueueSemaphoreTake+0x12e> @ imm = #0x56
700a1556: e7ff         	b	0x700a1558 <xQueueSemaphoreTake+0xd8> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a1558: 9803         	ldr	r0, [sp, #0xc]
700a155a: f00d fcc9    	bl	0x700aeef0 <prvIsQueueEmpty> @ imm = #0xd992
700a155e: b1f8         	cbz	r0, 0x700a15a0 <xQueueSemaphoreTake+0x120> @ imm = #0x3e
700a1560: e7ff         	b	0x700a1562 <xQueueSemaphoreTake+0xe2> @ imm = #-0x2
;                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a1562: 9803         	ldr	r0, [sp, #0xc]
700a1564: 6800         	ldr	r0, [r0]
700a1566: b950         	cbnz	r0, 0x700a157e <xQueueSemaphoreTake+0xfe> @ imm = #0x14
700a1568: e7ff         	b	0x700a156a <xQueueSemaphoreTake+0xea> @ imm = #-0x2
;                             taskENTER_CRITICAL();
700a156a: f00d f909    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0xd212
;                                 xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
700a156e: 9803         	ldr	r0, [sp, #0xc]
700a1570: 6880         	ldr	r0, [r0, #0x8]
700a1572: f003 fe45    	bl	0x700a5200 <xTaskPriorityInherit> @ imm = #0x3c8a
700a1576: 9002         	str	r0, [sp, #0x8]
;                             taskEXIT_CRITICAL();
700a1578: f00c f9c2    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xc384
;                         }
700a157c: e000         	b	0x700a1580 <xQueueSemaphoreTake+0x100> @ imm = #0x0
700a157e: e7ff         	b	0x700a1580 <xQueueSemaphoreTake+0x100> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
700a1580: 9803         	ldr	r0, [sp, #0xc]
700a1582: 3024         	adds	r0, #0x24
700a1584: 9907         	ldr	r1, [sp, #0x1c]
700a1586: f00d fd73    	bl	0x700af070 <vTaskPlaceOnEventList> @ imm = #0xdae6
;                 prvUnlockQueue( pxQueue );
700a158a: 9803         	ldr	r0, [sp, #0xc]
700a158c: f006 fc88    	bl	0x700a7ea0 <prvUnlockQueue> @ imm = #0x6910
;                 if( xTaskResumeAll() == pdFALSE )
700a1590: f000 fe86    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #0xd0c
700a1594: b910         	cbnz	r0, 0x700a159c <xQueueSemaphoreTake+0x11c> @ imm = #0x4
700a1596: e7ff         	b	0x700a1598 <xQueueSemaphoreTake+0x118> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a1598: df00         	svc	#0x0
;                 }
700a159a: e000         	b	0x700a159e <xQueueSemaphoreTake+0x11e> @ imm = #0x0
700a159c: e7ff         	b	0x700a159e <xQueueSemaphoreTake+0x11e> @ imm = #-0x2
;             }
700a159e: e005         	b	0x700a15ac <xQueueSemaphoreTake+0x12c> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a15a0: 9803         	ldr	r0, [sp, #0xc]
700a15a2: f006 fc7d    	bl	0x700a7ea0 <prvUnlockQueue> @ imm = #0x68fa
;                 ( void ) xTaskResumeAll();
700a15a6: f000 fe7b    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #0xcf6
700a15aa: e7ff         	b	0x700a15ac <xQueueSemaphoreTake+0x12c> @ imm = #-0x2
;         }
700a15ac: e01f         	b	0x700a15ee <xQueueSemaphoreTake+0x16e> @ imm = #0x3e
;             prvUnlockQueue( pxQueue );
700a15ae: 9803         	ldr	r0, [sp, #0xc]
700a15b0: f006 fc76    	bl	0x700a7ea0 <prvUnlockQueue> @ imm = #0x68ec
;             ( void ) xTaskResumeAll();
700a15b4: f000 fe74    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #0xce8
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a15b8: 9803         	ldr	r0, [sp, #0xc]
700a15ba: f00d fc99    	bl	0x700aeef0 <prvIsQueueEmpty> @ imm = #0xd932
700a15be: b1a0         	cbz	r0, 0x700a15ea <xQueueSemaphoreTake+0x16a> @ imm = #0x28
700a15c0: e7ff         	b	0x700a15c2 <xQueueSemaphoreTake+0x142> @ imm = #-0x2
;                         if( xInheritanceOccurred != pdFALSE )
700a15c2: 9802         	ldr	r0, [sp, #0x8]
700a15c4: b170         	cbz	r0, 0x700a15e4 <xQueueSemaphoreTake+0x164> @ imm = #0x1c
700a15c6: e7ff         	b	0x700a15c8 <xQueueSemaphoreTake+0x148> @ imm = #-0x2
;                             taskENTER_CRITICAL();
700a15c8: f00d f8da    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0xd1b4
;                                 uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
700a15cc: 9803         	ldr	r0, [sp, #0xc]
700a15ce: f00d fd37    	bl	0x700af040 <prvGetDisinheritPriorityAfterTimeout> @ imm = #0xda6e
700a15d2: 9000         	str	r0, [sp]
;                                 vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
700a15d4: 9803         	ldr	r0, [sp, #0xc]
700a15d6: 6880         	ldr	r0, [r0, #0x8]
700a15d8: 9900         	ldr	r1, [sp]
700a15da: f004 faa9    	bl	0x700a5b30 <vTaskPriorityDisinheritAfterTimeout> @ imm = #0x4552
;                             taskEXIT_CRITICAL();
700a15de: f00c f98f    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xc31e
;                         }
700a15e2: e7ff         	b	0x700a15e4 <xQueueSemaphoreTake+0x164> @ imm = #-0x2
700a15e4: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
700a15e6: 9009         	str	r0, [sp, #0x24]
700a15e8: e002         	b	0x700a15f0 <xQueueSemaphoreTake+0x170> @ imm = #0x4
700a15ea: e7ff         	b	0x700a15ec <xQueueSemaphoreTake+0x16c> @ imm = #-0x2
700a15ec: e7ff         	b	0x700a15ee <xQueueSemaphoreTake+0x16e> @ imm = #-0x2
;     for( ; ; )
700a15ee: e751         	b	0x700a1494 <xQueueSemaphoreTake+0x14> @ imm = #-0x15e
; }
700a15f0: 9809         	ldr	r0, [sp, #0x24]
700a15f2: b00a         	add	sp, #0x28
700a15f4: bd80         	pop	{r7, pc}
		...
700a15fe: 0000         	movs	r0, r0

700a1600 <xTaskIncrementTick>:
; BaseType_t xTaskIncrementTick(void) {
700a1600: b580         	push	{r7, lr}
700a1602: b086         	sub	sp, #0x18
700a1604: 2000         	movs	r0, #0x0
;   BaseType_t xSwitchRequired = pdFALSE;
700a1606: 9003         	str	r0, [sp, #0xc]
;   if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a1608: f642 2034    	movw	r0, #0x2a34
700a160c: f2c7 000b    	movt	r0, #0x700b
700a1610: 6800         	ldr	r0, [r0]
700a1612: 2800         	cmp	r0, #0x0
700a1614: f040 80a3    	bne.w	0x700a175e <xTaskIncrementTick+0x15e> @ imm = #0x146
700a1618: e7ff         	b	0x700a161a <xTaskIncrementTick+0x1a> @ imm = #-0x2
;     const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
700a161a: f642 2154    	movw	r1, #0x2a54
700a161e: f2c7 010b    	movt	r1, #0x700b
700a1622: 6808         	ldr	r0, [r1]
700a1624: 3001         	adds	r0, #0x1
700a1626: 9002         	str	r0, [sp, #0x8]
;     xTickCount = xConstTickCount;
700a1628: 9802         	ldr	r0, [sp, #0x8]
700a162a: 6008         	str	r0, [r1]
;     if (xConstTickCount ==
700a162c: 9802         	ldr	r0, [sp, #0x8]
700a162e: b9c0         	cbnz	r0, 0x700a1662 <xTaskIncrementTick+0x62> @ imm = #0x30
700a1630: e7ff         	b	0x700a1632 <xTaskIncrementTick+0x32> @ imm = #-0x2
;       taskSWITCH_DELAYED_LISTS();
700a1632: f245 22a0    	movw	r2, #0x52a0
700a1636: f2c7 0208    	movt	r2, #0x7008
700a163a: 6810         	ldr	r0, [r2]
700a163c: 9001         	str	r0, [sp, #0x4]
700a163e: f245 21a4    	movw	r1, #0x52a4
700a1642: f2c7 0108    	movt	r1, #0x7008
700a1646: 6808         	ldr	r0, [r1]
700a1648: 6010         	str	r0, [r2]
700a164a: 9801         	ldr	r0, [sp, #0x4]
700a164c: 6008         	str	r0, [r1]
700a164e: f642 2148    	movw	r1, #0x2a48
700a1652: f2c7 010b    	movt	r1, #0x700b
700a1656: 6808         	ldr	r0, [r1]
700a1658: 3001         	adds	r0, #0x1
700a165a: 6008         	str	r0, [r1]
700a165c: f00c fd98    	bl	0x700ae190 <prvResetNextTaskUnblockTime> @ imm = #0xcb30
;     } else {
700a1660: e000         	b	0x700a1664 <xTaskIncrementTick+0x64> @ imm = #0x0
700a1662: e7ff         	b	0x700a1664 <xTaskIncrementTick+0x64> @ imm = #-0x2
;     if (xConstTickCount >= xNextTaskUnblockTime) {
700a1664: 9802         	ldr	r0, [sp, #0x8]
700a1666: f642 2144    	movw	r1, #0x2a44
700a166a: f2c7 010b    	movt	r1, #0x700b
700a166e: 6809         	ldr	r1, [r1]
700a1670: 4288         	cmp	r0, r1
700a1672: d368         	blo	0x700a1746 <xTaskIncrementTick+0x146> @ imm = #0xd0
700a1674: e7ff         	b	0x700a1676 <xTaskIncrementTick+0x76> @ imm = #-0x2
;       for (;;) {
700a1676: e7ff         	b	0x700a1678 <xTaskIncrementTick+0x78> @ imm = #-0x2
;         if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
700a1678: f245 20a0    	movw	r0, #0x52a0
700a167c: f2c7 0008    	movt	r0, #0x7008
700a1680: 6800         	ldr	r0, [r0]
700a1682: 6800         	ldr	r0, [r0]
700a1684: b940         	cbnz	r0, 0x700a1698 <xTaskIncrementTick+0x98> @ imm = #0x10
700a1686: e7ff         	b	0x700a1688 <xTaskIncrementTick+0x88> @ imm = #-0x2
;           xNextTaskUnblockTime =
700a1688: f642 2144    	movw	r1, #0x2a44
700a168c: f2c7 010b    	movt	r1, #0x700b
700a1690: f04f 30ff    	mov.w	r0, #0xffffffff
700a1694: 6008         	str	r0, [r1]
;           break;
700a1696: e055         	b	0x700a1744 <xTaskIncrementTick+0x144> @ imm = #0xaa
;           pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a1698: f245 20a0    	movw	r0, #0x52a0
700a169c: f2c7 0008    	movt	r0, #0x7008
700a16a0: 6800         	ldr	r0, [r0]
700a16a2: 68c0         	ldr	r0, [r0, #0xc]
700a16a4: 68c0         	ldr	r0, [r0, #0xc]
700a16a6: 9005         	str	r0, [sp, #0x14]
;           xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
700a16a8: 9805         	ldr	r0, [sp, #0x14]
700a16aa: 6840         	ldr	r0, [r0, #0x4]
700a16ac: 9004         	str	r0, [sp, #0x10]
;           if (xConstTickCount < xItemValue) {
700a16ae: 9802         	ldr	r0, [sp, #0x8]
700a16b0: 9904         	ldr	r1, [sp, #0x10]
700a16b2: 4288         	cmp	r0, r1
700a16b4: d207         	bhs	0x700a16c6 <xTaskIncrementTick+0xc6> @ imm = #0xe
700a16b6: e7ff         	b	0x700a16b8 <xTaskIncrementTick+0xb8> @ imm = #-0x2
;             xNextTaskUnblockTime = xItemValue;
700a16b8: 9804         	ldr	r0, [sp, #0x10]
700a16ba: f642 2144    	movw	r1, #0x2a44
700a16be: f2c7 010b    	movt	r1, #0x700b
700a16c2: 6008         	str	r0, [r1]
;             break; /*lint !e9011 Code structure here is deedmed easier to
700a16c4: e03e         	b	0x700a1744 <xTaskIncrementTick+0x144> @ imm = #0x7c
700a16c6: e7ff         	b	0x700a16c8 <xTaskIncrementTick+0xc8> @ imm = #-0x2
;           (void)uxListRemove(&(pxTCB->xStateListItem));
700a16c8: 9805         	ldr	r0, [sp, #0x14]
700a16ca: 3004         	adds	r0, #0x4
700a16cc: f00c f828    	bl	0x700ad720 <uxListRemove> @ imm = #0xc050
;           if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a16d0: 9805         	ldr	r0, [sp, #0x14]
700a16d2: 6a80         	ldr	r0, [r0, #0x28]
700a16d4: b128         	cbz	r0, 0x700a16e2 <xTaskIncrementTick+0xe2> @ imm = #0xa
700a16d6: e7ff         	b	0x700a16d8 <xTaskIncrementTick+0xd8> @ imm = #-0x2
;             (void)uxListRemove(&(pxTCB->xEventListItem));
700a16d8: 9805         	ldr	r0, [sp, #0x14]
700a16da: 3018         	adds	r0, #0x18
700a16dc: f00c f820    	bl	0x700ad720 <uxListRemove> @ imm = #0xc040
;           } else {
700a16e0: e000         	b	0x700a16e4 <xTaskIncrementTick+0xe4> @ imm = #0x0
700a16e2: e7ff         	b	0x700a16e4 <xTaskIncrementTick+0xe4> @ imm = #-0x2
;           prvAddTaskToReadyList(pxTCB);
700a16e4: 9805         	ldr	r0, [sp, #0x14]
700a16e6: 6ac0         	ldr	r0, [r0, #0x2c]
700a16e8: f642 213c    	movw	r1, #0x2a3c
700a16ec: f2c7 010b    	movt	r1, #0x700b
700a16f0: 6809         	ldr	r1, [r1]
700a16f2: 4288         	cmp	r0, r1
700a16f4: d908         	bls	0x700a1708 <xTaskIncrementTick+0x108> @ imm = #0x10
700a16f6: e7ff         	b	0x700a16f8 <xTaskIncrementTick+0xf8> @ imm = #-0x2
700a16f8: 9805         	ldr	r0, [sp, #0x14]
700a16fa: 6ac0         	ldr	r0, [r0, #0x2c]
700a16fc: f642 213c    	movw	r1, #0x2a3c
700a1700: f2c7 010b    	movt	r1, #0x700b
700a1704: 6008         	str	r0, [r1]
700a1706: e7ff         	b	0x700a1708 <xTaskIncrementTick+0x108> @ imm = #-0x2
700a1708: 9905         	ldr	r1, [sp, #0x14]
700a170a: 6ac8         	ldr	r0, [r1, #0x2c]
700a170c: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a1710: f244 40f8    	movw	r0, #0x44f8
700a1714: f2c7 0008    	movt	r0, #0x7008
700a1718: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a171c: 3104         	adds	r1, #0x4
700a171e: f00c fdb7    	bl	0x700ae290 <vListInsertEnd> @ imm = #0xcb6e
;             if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a1722: 9805         	ldr	r0, [sp, #0x14]
700a1724: 6ac0         	ldr	r0, [r0, #0x2c]
700a1726: f642 210c    	movw	r1, #0x2a0c
700a172a: f2c7 010b    	movt	r1, #0x700b
700a172e: 6809         	ldr	r1, [r1]
700a1730: 6ac9         	ldr	r1, [r1, #0x2c]
700a1732: 4288         	cmp	r0, r1
700a1734: d303         	blo	0x700a173e <xTaskIncrementTick+0x13e> @ imm = #0x6
700a1736: e7ff         	b	0x700a1738 <xTaskIncrementTick+0x138> @ imm = #-0x2
700a1738: 2001         	movs	r0, #0x1
;               xSwitchRequired = pdTRUE;
700a173a: 9003         	str	r0, [sp, #0xc]
;             } else {
700a173c: e000         	b	0x700a1740 <xTaskIncrementTick+0x140> @ imm = #0x0
700a173e: e7ff         	b	0x700a1740 <xTaskIncrementTick+0x140> @ imm = #-0x2
700a1740: e7ff         	b	0x700a1742 <xTaskIncrementTick+0x142> @ imm = #-0x2
;       for (;;) {
700a1742: e799         	b	0x700a1678 <xTaskIncrementTick+0x78> @ imm = #-0xce
;     }
700a1744: e7ff         	b	0x700a1746 <xTaskIncrementTick+0x146> @ imm = #-0x2
;       if (xYieldPending != pdFALSE) {
700a1746: f642 2060    	movw	r0, #0x2a60
700a174a: f2c7 000b    	movt	r0, #0x700b
700a174e: 6800         	ldr	r0, [r0]
700a1750: b118         	cbz	r0, 0x700a175a <xTaskIncrementTick+0x15a> @ imm = #0x6
700a1752: e7ff         	b	0x700a1754 <xTaskIncrementTick+0x154> @ imm = #-0x2
700a1754: 2001         	movs	r0, #0x1
;         xSwitchRequired = pdTRUE;
700a1756: 9003         	str	r0, [sp, #0xc]
;       } else {
700a1758: e000         	b	0x700a175c <xTaskIncrementTick+0x15c> @ imm = #0x0
700a175a: e7ff         	b	0x700a175c <xTaskIncrementTick+0x15c> @ imm = #-0x2
;   } else {
700a175c: e007         	b	0x700a176e <xTaskIncrementTick+0x16e> @ imm = #0xe
;     ++xPendedTicks;
700a175e: f642 214c    	movw	r1, #0x2a4c
700a1762: f2c7 010b    	movt	r1, #0x700b
700a1766: 6808         	ldr	r0, [r1]
700a1768: 3001         	adds	r0, #0x1
700a176a: 6008         	str	r0, [r1]
700a176c: e7ff         	b	0x700a176e <xTaskIncrementTick+0x16e> @ imm = #-0x2
;   return xSwitchRequired;
700a176e: 9803         	ldr	r0, [sp, #0xc]
700a1770: b006         	add	sp, #0x18
700a1772: bd80         	pop	{r7, pc}
		...

700a1780 <CSL_bcdmaChanOpTeardownChan>:
; {
700a1780: b580         	push	{r7, lr}
700a1782: b08c         	sub	sp, #0x30
700a1784: 900b         	str	r0, [sp, #0x2c]
700a1786: 910a         	str	r1, [sp, #0x28]
700a1788: 9209         	str	r2, [sp, #0x24]
700a178a: 9308         	str	r3, [sp, #0x20]
700a178c: 2000         	movs	r0, #0x0
;     int32_t  retVal = CSL_PASS;
700a178e: 9007         	str	r0, [sp, #0x1c]
;     if( CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)false )
700a1790: 980b         	ldr	r0, [sp, #0x2c]
700a1792: 990a         	ldr	r1, [sp, #0x28]
700a1794: 9a09         	ldr	r2, [sp, #0x24]
700a1796: f009 f93b    	bl	0x700aaa10 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x9276
700a179a: b920         	cbnz	r0, 0x700a17a6 <CSL_bcdmaChanOpTeardownChan+0x26> @ imm = #0x8
700a179c: e7ff         	b	0x700a179e <CSL_bcdmaChanOpTeardownChan+0x1e> @ imm = #-0x2
700a179e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a17a2: 9007         	str	r0, [sp, #0x1c]
;     }
700a17a4: e09f         	b	0x700a18e6 <CSL_bcdmaChanOpTeardownChan+0x166> @ imm = #0x13e
700a17a6: 2000         	movs	r0, #0x0
;         uint32_t force = (uint32_t)0U, wait = (uint32_t)0U;
700a17a8: 9005         	str	r0, [sp, #0x14]
700a17aa: 9004         	str	r0, [sp, #0x10]
;         if( pOpData != NULL )
700a17ac: 9808         	ldr	r0, [sp, #0x20]
700a17ae: b148         	cbz	r0, 0x700a17c4 <CSL_bcdmaChanOpTeardownChan+0x44> @ imm = #0x12
700a17b0: e7ff         	b	0x700a17b2 <CSL_bcdmaChanOpTeardownChan+0x32> @ imm = #-0x2
;             CSL_BcdmaTeardownOpts *pTdOpts = (CSL_BcdmaTeardownOpts *)pOpData;
700a17b2: 9808         	ldr	r0, [sp, #0x20]
700a17b4: 9003         	str	r0, [sp, #0xc]
;             force = pTdOpts->force;
700a17b6: 9803         	ldr	r0, [sp, #0xc]
700a17b8: 6800         	ldr	r0, [r0]
700a17ba: 9005         	str	r0, [sp, #0x14]
;             wait  = pTdOpts->wait;
700a17bc: 9803         	ldr	r0, [sp, #0xc]
700a17be: 6840         	ldr	r0, [r0, #0x4]
700a17c0: 9004         	str	r0, [sp, #0x10]
;         }
700a17c2: e7ff         	b	0x700a17c4 <CSL_bcdmaChanOpTeardownChan+0x44> @ imm = #-0x2
;         switch( chanType )
700a17c4: 980a         	ldr	r0, [sp, #0x28]
700a17c6: 9001         	str	r0, [sp, #0x4]
700a17c8: b148         	cbz	r0, 0x700a17de <CSL_bcdmaChanOpTeardownChan+0x5e> @ imm = #0x12
700a17ca: e7ff         	b	0x700a17cc <CSL_bcdmaChanOpTeardownChan+0x4c> @ imm = #-0x2
700a17cc: 9801         	ldr	r0, [sp, #0x4]
700a17ce: 2801         	cmp	r0, #0x1
700a17d0: d024         	beq	0x700a181c <CSL_bcdmaChanOpTeardownChan+0x9c> @ imm = #0x48
700a17d2: e7ff         	b	0x700a17d4 <CSL_bcdmaChanOpTeardownChan+0x54> @ imm = #-0x2
700a17d4: 9801         	ldr	r0, [sp, #0x4]
700a17d6: 2802         	cmp	r0, #0x2
700a17d8: d03f         	beq	0x700a185a <CSL_bcdmaChanOpTeardownChan+0xda> @ imm = #0x7e
700a17da: e7ff         	b	0x700a17dc <CSL_bcdmaChanOpTeardownChan+0x5c> @ imm = #-0x2
;         {
700a17dc: e7ff         	b	0x700a17de <CSL_bcdmaChanOpTeardownChan+0x5e> @ imm = #-0x2
;                 regVal = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL );
700a17de: 980b         	ldr	r0, [sp, #0x2c]
700a17e0: 6880         	ldr	r0, [r0, #0x8]
700a17e2: 9909         	ldr	r1, [sp, #0x24]
700a17e4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a17e8: f00e fa12    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xe424
700a17ec: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_BCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a17ee: 9806         	ldr	r0, [sp, #0x18]
700a17f0: f040 4080    	orr	r0, r0, #0x40000000
700a17f4: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_BCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
700a17f6: 9806         	ldr	r0, [sp, #0x18]
700a17f8: f020 5180    	bic	r1, r0, #0x10000000
700a17fc: 9a05         	ldr	r2, [sp, #0x14]
700a17fe: f101 5080    	add.w	r0, r1, #0x10000000
700a1802: 2a00         	cmp	r2, #0x0
700a1804: bf08         	it	eq
700a1806: 4608         	moveq	r0, r1
700a1808: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a180a: 980b         	ldr	r0, [sp, #0x2c]
700a180c: 6880         	ldr	r0, [r0, #0x8]
700a180e: 9909         	ldr	r1, [sp, #0x24]
700a1810: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1814: 9906         	ldr	r1, [sp, #0x18]
700a1816: f7fa fd3b    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x558a
;                 break;
700a181a: e03d         	b	0x700a1898 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #0x7a
;                 regVal = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a181c: 980b         	ldr	r0, [sp, #0x2c]
700a181e: 6900         	ldr	r0, [r0, #0x10]
700a1820: 9909         	ldr	r1, [sp, #0x24]
700a1822: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1826: f00e f9f3    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xe3e6
700a182a: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_TXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a182c: 9806         	ldr	r0, [sp, #0x18]
700a182e: f040 4080    	orr	r0, r0, #0x40000000
700a1832: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_TXCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
700a1834: 9806         	ldr	r0, [sp, #0x18]
700a1836: f020 5180    	bic	r1, r0, #0x10000000
700a183a: 9a05         	ldr	r2, [sp, #0x14]
700a183c: f101 5080    	add.w	r0, r1, #0x10000000
700a1840: 2a00         	cmp	r2, #0x0
700a1842: bf08         	it	eq
700a1844: 4608         	moveq	r0, r1
700a1846: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a1848: 980b         	ldr	r0, [sp, #0x2c]
700a184a: 6900         	ldr	r0, [r0, #0x10]
700a184c: 9909         	ldr	r1, [sp, #0x24]
700a184e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1852: 9906         	ldr	r1, [sp, #0x18]
700a1854: f7fa fd1c    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x55c8
;                 break;
700a1858: e01e         	b	0x700a1898 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #0x3c
;                 regVal = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a185a: 980b         	ldr	r0, [sp, #0x2c]
700a185c: 6980         	ldr	r0, [r0, #0x18]
700a185e: 9909         	ldr	r1, [sp, #0x24]
700a1860: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1864: f00e f9d4    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xe3a8
700a1868: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_RXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a186a: 9806         	ldr	r0, [sp, #0x18]
700a186c: f040 4080    	orr	r0, r0, #0x40000000
700a1870: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_RXCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
700a1872: 9806         	ldr	r0, [sp, #0x18]
700a1874: f020 5180    	bic	r1, r0, #0x10000000
700a1878: 9a05         	ldr	r2, [sp, #0x14]
700a187a: f101 5080    	add.w	r0, r1, #0x10000000
700a187e: 2a00         	cmp	r2, #0x0
700a1880: bf08         	it	eq
700a1882: 4608         	moveq	r0, r1
700a1884: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a1886: 980b         	ldr	r0, [sp, #0x2c]
700a1888: 6980         	ldr	r0, [r0, #0x18]
700a188a: 9909         	ldr	r1, [sp, #0x24]
700a188c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1890: 9906         	ldr	r1, [sp, #0x18]
700a1892: f7fa fcfd    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x5606
;                 break;
700a1896: e7ff         	b	0x700a1898 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #-0x2
;         if(wait != 0U)
700a1898: 9804         	ldr	r0, [sp, #0x10]
700a189a: b318         	cbz	r0, 0x700a18e4 <CSL_bcdmaChanOpTeardownChan+0x164> @ imm = #0x46
700a189c: e7ff         	b	0x700a189e <CSL_bcdmaChanOpTeardownChan+0x11e> @ imm = #-0x2
700a189e: 2080         	movs	r0, #0x80
;             uint32_t retryCnt = CSL_BCDMA_TEARDOWN_COMPLETE_WAIT_MAX_CNT;
700a18a0: 9002         	str	r0, [sp, #0x8]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a18a2: e7ff         	b	0x700a18a4 <CSL_bcdmaChanOpTeardownChan+0x124> @ imm = #-0x2
700a18a4: 980b         	ldr	r0, [sp, #0x2c]
700a18a6: 990a         	ldr	r1, [sp, #0x28]
700a18a8: 9a09         	ldr	r2, [sp, #0x24]
700a18aa: f009 f8b1    	bl	0x700aaa10 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x9162
700a18ae: 4601         	mov	r1, r0
700a18b0: 2000         	movs	r0, #0x0
700a18b2: 9000         	str	r0, [sp]
700a18b4: b131         	cbz	r1, 0x700a18c4 <CSL_bcdmaChanOpTeardownChan+0x144> @ imm = #0xc
700a18b6: e7ff         	b	0x700a18b8 <CSL_bcdmaChanOpTeardownChan+0x138> @ imm = #-0x2
700a18b8: 9802         	ldr	r0, [sp, #0x8]
700a18ba: 2800         	cmp	r0, #0x0
700a18bc: bf18         	it	ne
700a18be: 2001         	movne	r0, #0x1
700a18c0: 9000         	str	r0, [sp]
700a18c2: e7ff         	b	0x700a18c4 <CSL_bcdmaChanOpTeardownChan+0x144> @ imm = #-0x2
700a18c4: 9800         	ldr	r0, [sp]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a18c6: 07c0         	lsls	r0, r0, #0x1f
700a18c8: b120         	cbz	r0, 0x700a18d4 <CSL_bcdmaChanOpTeardownChan+0x154> @ imm = #0x8
700a18ca: e7ff         	b	0x700a18cc <CSL_bcdmaChanOpTeardownChan+0x14c> @ imm = #-0x2
;                 retryCnt--;
700a18cc: 9802         	ldr	r0, [sp, #0x8]
700a18ce: 3801         	subs	r0, #0x1
700a18d0: 9002         	str	r0, [sp, #0x8]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a18d2: e7e7         	b	0x700a18a4 <CSL_bcdmaChanOpTeardownChan+0x124> @ imm = #-0x32
;             if( retryCnt == (uint32_t)0U ) {
700a18d4: 9802         	ldr	r0, [sp, #0x8]
700a18d6: b920         	cbnz	r0, 0x700a18e2 <CSL_bcdmaChanOpTeardownChan+0x162> @ imm = #0x8
700a18d8: e7ff         	b	0x700a18da <CSL_bcdmaChanOpTeardownChan+0x15a> @ imm = #-0x2
700a18da: f04f 30ff    	mov.w	r0, #0xffffffff
;                 retVal = CSL_EFAIL;
700a18de: 9007         	str	r0, [sp, #0x1c]
;             }
700a18e0: e7ff         	b	0x700a18e2 <CSL_bcdmaChanOpTeardownChan+0x162> @ imm = #-0x2
;         }
700a18e2: e7ff         	b	0x700a18e4 <CSL_bcdmaChanOpTeardownChan+0x164> @ imm = #-0x2
700a18e4: e7ff         	b	0x700a18e6 <CSL_bcdmaChanOpTeardownChan+0x166> @ imm = #-0x2
;     return retVal;
700a18e6: 9807         	ldr	r0, [sp, #0x1c]
700a18e8: b00c         	add	sp, #0x30
700a18ea: bd80         	pop	{r7, pc}
700a18ec: 0000         	movs	r0, r0
700a18ee: 0000         	movs	r0, r0

700a18f0 <CSL_bcdmaChanOp>:
; {
700a18f0: b580         	push	{r7, lr}
700a18f2: b088         	sub	sp, #0x20
700a18f4: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a18f8: 9007         	str	r0, [sp, #0x1c]
700a18fa: 9106         	str	r1, [sp, #0x18]
700a18fc: 9205         	str	r2, [sp, #0x14]
700a18fe: 9304         	str	r3, [sp, #0x10]
700a1900: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a1902: 9003         	str	r0, [sp, #0xc]
;     if( ( pCfg == NULL )                                    ||
700a1904: 9807         	ldr	r0, [sp, #0x1c]
700a1906: b158         	cbz	r0, 0x700a1920 <CSL_bcdmaChanOp+0x30> @ imm = #0x16
700a1908: e7ff         	b	0x700a190a <CSL_bcdmaChanOp+0x1a> @ imm = #-0x2
;         ( chanType > CSL_BCDMA_CHAN_TYPE_SPLIT_RX )         ||
700a190a: 9805         	ldr	r0, [sp, #0x14]
700a190c: 2802         	cmp	r0, #0x2
700a190e: d807         	bhi	0x700a1920 <CSL_bcdmaChanOp+0x30> @ imm = #0xe
700a1910: e7ff         	b	0x700a1912 <CSL_bcdmaChanOp+0x22> @ imm = #-0x2
;         ( !CSL_bcdmaChanOpIsValidChanIdx( pCfg, chanType, chanIdx ) )
700a1912: 9807         	ldr	r0, [sp, #0x1c]
700a1914: 9905         	ldr	r1, [sp, #0x14]
700a1916: 9a04         	ldr	r2, [sp, #0x10]
700a1918: f009 f8ba    	bl	0x700aaa90 <CSL_bcdmaChanOpIsValidChanIdx> @ imm = #0x9174
;     if( ( pCfg == NULL )                                    ||
700a191c: b920         	cbnz	r0, 0x700a1928 <CSL_bcdmaChanOp+0x38> @ imm = #0x8
700a191e: e7ff         	b	0x700a1920 <CSL_bcdmaChanOp+0x30> @ imm = #-0x2
700a1920: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a1924: 9003         	str	r0, [sp, #0xc]
;     }
700a1926: e094         	b	0x700a1a52 <CSL_bcdmaChanOp+0x162> @ imm = #0x128
;         switch(chanOp )
700a1928: 9806         	ldr	r0, [sp, #0x18]
700a192a: 9002         	str	r0, [sp, #0x8]
700a192c: 280e         	cmp	r0, #0xe
700a192e: f200 808b    	bhi.w	0x700a1a48 <CSL_bcdmaChanOp+0x158> @ imm = #0x116
700a1932: 9902         	ldr	r1, [sp, #0x8]
700a1934: e8df f001    	tbb	[pc, r1]
700a1938: 08 10 18 20  	.word	0x20181008
700a193c: 28 30 38 3f  	.word	0x3f383028
700a1940: 47 4f 57 5f  	.word	0x5f574f47
700a1944: 6c 79 81 00  	.word	0x0081796c
;                 retVal = CSL_bcdmaChanOpCfgChan( pCfg, chanType, chanIdx, pOpData );
700a1948: 9807         	ldr	r0, [sp, #0x1c]
700a194a: 9905         	ldr	r1, [sp, #0x14]
700a194c: 9a04         	ldr	r2, [sp, #0x10]
700a194e: 9b0a         	ldr	r3, [sp, #0x28]
700a1950: f7fc f91e    	bl	0x7009db90 <CSL_bcdmaChanOpCfgChan> @ imm = #-0x3dc4
700a1954: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1956: e07b         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0xf6
;                 retVal = CSL_bcdmaChanOpSetChanEnable( pCfg, chanType, chanIdx, (bool)true );
700a1958: 9807         	ldr	r0, [sp, #0x1c]
700a195a: 9905         	ldr	r1, [sp, #0x14]
700a195c: 9a04         	ldr	r2, [sp, #0x10]
700a195e: 2301         	movs	r3, #0x1
700a1960: f007 fcde    	bl	0x700a9320 <CSL_bcdmaChanOpSetChanEnable> @ imm = #0x79bc
700a1964: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1966: e073         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0xe6
;                 retVal = CSL_bcdmaChanOpSetChanEnable( pCfg, chanType, chanIdx, (bool)false );
700a1968: 9807         	ldr	r0, [sp, #0x1c]
700a196a: 9905         	ldr	r1, [sp, #0x14]
700a196c: 9a04         	ldr	r2, [sp, #0x10]
700a196e: 2300         	movs	r3, #0x0
700a1970: f007 fcd6    	bl	0x700a9320 <CSL_bcdmaChanOpSetChanEnable> @ imm = #0x79ac
700a1974: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1976: e06b         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0xd6
;                 retVal = CSL_bcdmaChanOpSetChanPause( pCfg, chanType, chanIdx, (bool)true );
700a1978: 9807         	ldr	r0, [sp, #0x1c]
700a197a: 9905         	ldr	r1, [sp, #0x14]
700a197c: 9a04         	ldr	r2, [sp, #0x10]
700a197e: 2301         	movs	r3, #0x1
700a1980: f006 fc46    	bl	0x700a8210 <CSL_bcdmaChanOpSetChanPause> @ imm = #0x688c
700a1984: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1986: e063         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0xc6
;                 retVal = CSL_bcdmaChanOpSetChanPause( pCfg, chanType, chanIdx, (bool)false );
700a1988: 9807         	ldr	r0, [sp, #0x1c]
700a198a: 9905         	ldr	r1, [sp, #0x14]
700a198c: 9a04         	ldr	r2, [sp, #0x10]
700a198e: 2300         	movs	r3, #0x0
700a1990: f006 fc3e    	bl	0x700a8210 <CSL_bcdmaChanOpSetChanPause> @ imm = #0x687c
700a1994: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1996: e05b         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0xb6
;                 retVal = CSL_bcdmaChanOpTeardownChan( pCfg, chanType, chanIdx, pOpData );
700a1998: 9807         	ldr	r0, [sp, #0x1c]
700a199a: 9905         	ldr	r1, [sp, #0x14]
700a199c: 9a04         	ldr	r2, [sp, #0x10]
700a199e: 9b0a         	ldr	r3, [sp, #0x28]
700a19a0: f7ff feee    	bl	0x700a1780 <CSL_bcdmaChanOpTeardownChan> @ imm = #-0x224
700a19a4: 9003         	str	r0, [sp, #0xc]
;                 break;
700a19a6: e053         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0xa6
;                 retVal = CSL_bcdmaChanOpTriggerChan( pCfg, chanType, chanIdx );
700a19a8: 9807         	ldr	r0, [sp, #0x1c]
700a19aa: 9905         	ldr	r1, [sp, #0x14]
700a19ac: 9a04         	ldr	r2, [sp, #0x10]
700a19ae: f009 fc6f    	bl	0x700ab290 <CSL_bcdmaChanOpTriggerChan> @ imm = #0x98de
700a19b2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a19b4: e04c         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0x98
;                 retVal = CSL_bcdmaChanOpGetChanRT( pCfg, chanType, chanIdx, pOpData );
700a19b6: 9807         	ldr	r0, [sp, #0x1c]
700a19b8: 9905         	ldr	r1, [sp, #0x14]
700a19ba: 9a04         	ldr	r2, [sp, #0x10]
700a19bc: 9b0a         	ldr	r3, [sp, #0x28]
700a19be: f004 fe1f    	bl	0x700a6600 <CSL_bcdmaChanOpGetChanRT> @ imm = #0x4c3e
700a19c2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a19c4: e044         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0x88
;                 retVal = CSL_bcdmaChanOpSetChanRT( pCfg, chanType, chanIdx, pOpData );
700a19c6: 9807         	ldr	r0, [sp, #0x1c]
700a19c8: 9905         	ldr	r1, [sp, #0x14]
700a19ca: 9a04         	ldr	r2, [sp, #0x10]
700a19cc: 9b0a         	ldr	r3, [sp, #0x28]
700a19ce: f006 fc77    	bl	0x700a82c0 <CSL_bcdmaChanOpSetChanRT> @ imm = #0x68ee
700a19d2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a19d4: e03c         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0x78
;                 retVal = CSL_bcdmaChanOpGetChanStats( pCfg, chanType, chanIdx, pOpData );
700a19d6: 9807         	ldr	r0, [sp, #0x1c]
700a19d8: 9905         	ldr	r1, [sp, #0x14]
700a19da: 9a04         	ldr	r2, [sp, #0x10]
700a19dc: 9b0a         	ldr	r3, [sp, #0x28]
700a19de: f000 fa57    	bl	0x700a1e90 <CSL_bcdmaChanOpGetChanStats> @ imm = #0x4ae
700a19e2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a19e4: e034         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0x68
;                 retVal = CSL_bcdmaChanOpDecChanStats( pCfg, chanType, chanIdx, pOpData );
700a19e6: 9807         	ldr	r0, [sp, #0x1c]
700a19e8: 9905         	ldr	r1, [sp, #0x14]
700a19ea: 9a04         	ldr	r2, [sp, #0x10]
700a19ec: 9b0a         	ldr	r3, [sp, #0x28]
700a19ee: f003 f82f    	bl	0x700a4a50 <CSL_bcdmaChanOpDecChanStats> @ imm = #0x305e
700a19f2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a19f4: e02c         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0x58
;                 retVal = CSL_bcdmaChanOpAccessRemotePeerReg( pCfg, chanType, chanIdx, pOpData, (bool)true );
700a19f6: 9807         	ldr	r0, [sp, #0x1c]
700a19f8: 9905         	ldr	r1, [sp, #0x14]
700a19fa: 9a04         	ldr	r2, [sp, #0x10]
700a19fc: 9b0a         	ldr	r3, [sp, #0x28]
700a19fe: 46ee         	mov	lr, sp
700a1a00: f04f 0c01    	mov.w	r12, #0x1
700a1a04: f8ce c000    	str.w	r12, [lr]
700a1a08: f005 fde2    	bl	0x700a75d0 <CSL_bcdmaChanOpAccessRemotePeerReg> @ imm = #0x5bc4
700a1a0c: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1a0e: e01f         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0x3e
;                 retVal = CSL_bcdmaChanOpAccessRemotePeerReg( pCfg, chanType, chanIdx, pOpData, (bool)false );
700a1a10: 9807         	ldr	r0, [sp, #0x1c]
700a1a12: 9905         	ldr	r1, [sp, #0x14]
700a1a14: 9a04         	ldr	r2, [sp, #0x10]
700a1a16: 9b0a         	ldr	r3, [sp, #0x28]
700a1a18: 46ee         	mov	lr, sp
700a1a1a: f04f 0c00    	mov.w	r12, #0x0
700a1a1e: f8ce c000    	str.w	r12, [lr]
700a1a22: f005 fdd5    	bl	0x700a75d0 <CSL_bcdmaChanOpAccessRemotePeerReg> @ imm = #0x5baa
700a1a26: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1a28: e012         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0x24
;                 retVal = CSL_bcdmaChanOpSetBurstSize( pCfg, chanType, chanIdx, pOpData );
700a1a2a: 9807         	ldr	r0, [sp, #0x1c]
700a1a2c: 9905         	ldr	r1, [sp, #0x14]
700a1a2e: 9a04         	ldr	r2, [sp, #0x10]
700a1a30: 9b0a         	ldr	r3, [sp, #0x28]
700a1a32: f005 f955    	bl	0x700a6ce0 <CSL_bcdmaChanOpSetBurstSize> @ imm = #0x52aa
700a1a36: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1a38: e00a         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0x14
;                 retVal = CSL_bcdmaChanOpClearError( pCfg, chanType, chanIdx );
700a1a3a: 9807         	ldr	r0, [sp, #0x1c]
700a1a3c: 9905         	ldr	r1, [sp, #0x14]
700a1a3e: 9a04         	ldr	r2, [sp, #0x10]
700a1a40: f009 fa66    	bl	0x700aaf10 <CSL_bcdmaChanOpClearError> @ imm = #0x94cc
700a1a44: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1a46: e003         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #0x6
700a1a48: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a1a4c: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1a4e: e7ff         	b	0x700a1a50 <CSL_bcdmaChanOp+0x160> @ imm = #-0x2
700a1a50: e7ff         	b	0x700a1a52 <CSL_bcdmaChanOp+0x162> @ imm = #-0x2
;     return retVal;
700a1a52: 9803         	ldr	r0, [sp, #0xc]
700a1a54: b008         	add	sp, #0x20
700a1a56: bd80         	pop	{r7, pc}
		...

700a1a60 <Udma_chOpen>:
; {
700a1a60: b580         	push	{r7, lr}
700a1a62: b08a         	sub	sp, #0x28
700a1a64: 9009         	str	r0, [sp, #0x24]
700a1a66: 9108         	str	r1, [sp, #0x20]
700a1a68: 9207         	str	r2, [sp, #0x1c]
700a1a6a: 9306         	str	r3, [sp, #0x18]
700a1a6c: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK, tempRetVal;
700a1a6e: 9005         	str	r0, [sp, #0x14]
;     uint32_t            allocDone = (uint32_t) FALSE;
700a1a70: 9003         	str	r0, [sp, #0xc]
;     Udma_DrvHandleInt   drvHandleInt = (Udma_DrvHandleInt) drvHandle;
700a1a72: 9809         	ldr	r0, [sp, #0x24]
700a1a74: 9001         	str	r0, [sp, #0x4]
;     if((drvHandleInt == NULL_PTR) || (NULL_PTR == chHandle) || (NULL_PTR == chPrms))
700a1a76: 9801         	ldr	r0, [sp, #0x4]
700a1a78: b130         	cbz	r0, 0x700a1a88 <Udma_chOpen+0x28> @ imm = #0xc
700a1a7a: e7ff         	b	0x700a1a7c <Udma_chOpen+0x1c> @ imm = #-0x2
700a1a7c: 9808         	ldr	r0, [sp, #0x20]
700a1a7e: b118         	cbz	r0, 0x700a1a88 <Udma_chOpen+0x28> @ imm = #0x6
700a1a80: e7ff         	b	0x700a1a82 <Udma_chOpen+0x22> @ imm = #-0x2
700a1a82: 9806         	ldr	r0, [sp, #0x18]
700a1a84: b920         	cbnz	r0, 0x700a1a90 <Udma_chOpen+0x30> @ imm = #0x8
700a1a86: e7ff         	b	0x700a1a88 <Udma_chOpen+0x28> @ imm = #-0x2
700a1a88: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a1a8c: 9005         	str	r0, [sp, #0x14]
;     }
700a1a8e: e7ff         	b	0x700a1a90 <Udma_chOpen+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1a90: 9805         	ldr	r0, [sp, #0x14]
700a1a92: b978         	cbnz	r0, 0x700a1ab4 <Udma_chOpen+0x54> @ imm = #0x1e
700a1a94: e7ff         	b	0x700a1a96 <Udma_chOpen+0x36> @ imm = #-0x2
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
700a1a96: 9801         	ldr	r0, [sp, #0x4]
700a1a98: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a1a9c: f64a 31cd    	movw	r1, #0xabcd
700a1aa0: f6ca 31dc    	movt	r1, #0xabdc
700a1aa4: 4288         	cmp	r0, r1
700a1aa6: d004         	beq	0x700a1ab2 <Udma_chOpen+0x52> @ imm = #0x8
700a1aa8: e7ff         	b	0x700a1aaa <Udma_chOpen+0x4a> @ imm = #-0x2
700a1aaa: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a1aae: 9005         	str	r0, [sp, #0x14]
;         }
700a1ab0: e7ff         	b	0x700a1ab2 <Udma_chOpen+0x52> @ imm = #-0x2
;     }
700a1ab2: e7ff         	b	0x700a1ab4 <Udma_chOpen+0x54> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1ab4: 9805         	ldr	r0, [sp, #0x14]
700a1ab6: b938         	cbnz	r0, 0x700a1ac8 <Udma_chOpen+0x68> @ imm = #0xe
700a1ab8: e7ff         	b	0x700a1aba <Udma_chOpen+0x5a> @ imm = #-0x2
;         retVal = Udma_chCheckParams(drvHandleInt, chType, chPrms);
700a1aba: 9801         	ldr	r0, [sp, #0x4]
700a1abc: 9907         	ldr	r1, [sp, #0x1c]
700a1abe: 9a06         	ldr	r2, [sp, #0x18]
700a1ac0: f006 f93e    	bl	0x700a7d40 <Udma_chCheckParams> @ imm = #0x627c
700a1ac4: 9005         	str	r0, [sp, #0x14]
;     }
700a1ac6: e7ff         	b	0x700a1ac8 <Udma_chOpen+0x68> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1ac8: 9805         	ldr	r0, [sp, #0x14]
700a1aca: 2800         	cmp	r0, #0x0
700a1acc: d145         	bne	0x700a1b5a <Udma_chOpen+0xfa> @ imm = #0x8a
700a1ace: e7ff         	b	0x700a1ad0 <Udma_chOpen+0x70> @ imm = #-0x2
;         chHandleInt = (Udma_ChHandleInt) chHandle;
700a1ad0: 9808         	ldr	r0, [sp, #0x20]
700a1ad2: 9002         	str	r0, [sp, #0x8]
;         (void) memset(chHandleInt, 0, sizeof(Udma_ChObject));
700a1ad4: 9802         	ldr	r0, [sp, #0x8]
700a1ad6: f44f 7116    	mov.w	r1, #0x258
700a1ada: f7f9 eb1c    	blx	0x7009b114 <__aeabi_memclr8> @ imm = #-0x69c8
;         (void) memcpy(&chHandleInt->chPrms, chPrms, sizeof(Udma_ChPrms));
700a1ade: 9802         	ldr	r0, [sp, #0x8]
700a1ae0: 3004         	adds	r0, #0x4
700a1ae2: 9906         	ldr	r1, [sp, #0x18]
700a1ae4: 2264         	movs	r2, #0x64
700a1ae6: f7f8 eafa    	blx	0x7009a0dc <__aeabi_memcpy8> @ imm = #-0x7a0c
;         chHandleInt->chType            = chType;
700a1aea: 9807         	ldr	r0, [sp, #0x1c]
700a1aec: 9902         	ldr	r1, [sp, #0x8]
700a1aee: 6008         	str	r0, [r1]
;         chHandleInt->drvHandle         = drvHandleInt;
700a1af0: 9801         	ldr	r0, [sp, #0x4]
700a1af2: 9902         	ldr	r1, [sp, #0x8]
700a1af4: 6688         	str	r0, [r1, #0x68]
;         chHandleInt->txChNum           = UDMA_DMA_CH_INVALID;
700a1af6: 9902         	ldr	r1, [sp, #0x8]
700a1af8: 2000         	movs	r0, #0x0
700a1afa: f6cf 70ff    	movt	r0, #0xffff
700a1afe: 66c8         	str	r0, [r1, #0x6c]
;         chHandleInt->rxChNum           = UDMA_DMA_CH_INVALID;
700a1b00: 9902         	ldr	r1, [sp, #0x8]
700a1b02: 6708         	str	r0, [r1, #0x70]
;         chHandleInt->extChNum          = UDMA_DMA_CH_INVALID;
700a1b04: 9902         	ldr	r1, [sp, #0x8]
700a1b06: 6748         	str	r0, [r1, #0x74]
;         chHandleInt->pdmaChNum         = UDMA_DMA_CH_INVALID;
700a1b08: 9902         	ldr	r1, [sp, #0x8]
700a1b0a: 6788         	str	r0, [r1, #0x78]
;         chHandleInt->peerThreadId      = UDMA_THREAD_ID_INVALID;
700a1b0c: 9902         	ldr	r1, [sp, #0x8]
700a1b0e: 2004         	movs	r0, #0x4
700a1b10: f6cf 70ff    	movt	r0, #0xffff
700a1b14: 67c8         	str	r0, [r1, #0x7c]
;         chHandleInt->fqRing            = (Udma_RingHandleInt) NULL_PTR;
700a1b16: 9902         	ldr	r1, [sp, #0x8]
700a1b18: 2000         	movs	r0, #0x0
700a1b1a: 9000         	str	r0, [sp]
700a1b1c: f8c1 0080    	str.w	r0, [r1, #0x80]
;         chHandleInt->cqRing            = (Udma_RingHandleInt) NULL_PTR;
700a1b20: 9902         	ldr	r1, [sp, #0x8]
700a1b22: f8c1 0084    	str.w	r0, [r1, #0x84]
;         chHandleInt->tdCqRing          = (Udma_RingHandleInt) NULL_PTR;
700a1b26: 9902         	ldr	r1, [sp, #0x8]
700a1b28: f8c1 0088    	str.w	r0, [r1, #0x88]
;         UdmaChTxPrms_init(&chHandleInt->txPrms, chType);
700a1b2c: 9802         	ldr	r0, [sp, #0x8]
700a1b2e: f500 70f2    	add.w	r0, r0, #0x1e4
700a1b32: 9907         	ldr	r1, [sp, #0x1c]
700a1b34: f006 fabc    	bl	0x700a80b0 <UdmaChTxPrms_init> @ imm = #0x6578
;         UdmaChRxPrms_init(&chHandleInt->rxPrms, chType);
700a1b38: 9802         	ldr	r0, [sp, #0x8]
700a1b3a: f500 70fc    	add.w	r0, r0, #0x1f8
700a1b3e: 9907         	ldr	r1, [sp, #0x1c]
700a1b40: f006 fa5e    	bl	0x700a8000 <UdmaChRxPrms_init> @ imm = #0x64bc
;         Udma_chInitRegs(chHandleInt);
700a1b44: 9802         	ldr	r0, [sp, #0x8]
700a1b46: f00b fa93    	bl	0x700ad070 <Udma_chInitRegs> @ imm = #0xb526
700a1b4a: 9800         	ldr	r0, [sp]
;         chHandleInt->chOesAllocDone    = FALSE;
700a1b4c: 9902         	ldr	r1, [sp, #0x8]
700a1b4e: f8c1 0248    	str.w	r0, [r1, #0x248]
;         chHandleInt->trigger           = CSL_UDMAP_TR_FLAGS_TRIGGER_NONE;
700a1b52: 9902         	ldr	r1, [sp, #0x8]
700a1b54: f8c1 024c    	str.w	r0, [r1, #0x24c]
;     }
700a1b58: e7ff         	b	0x700a1b5a <Udma_chOpen+0xfa> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1b5a: 9805         	ldr	r0, [sp, #0x14]
700a1b5c: b960         	cbnz	r0, 0x700a1b78 <Udma_chOpen+0x118> @ imm = #0x18
700a1b5e: e7ff         	b	0x700a1b60 <Udma_chOpen+0x100> @ imm = #-0x2
;         retVal = Udma_chAllocResource(chHandleInt);
700a1b60: 9802         	ldr	r0, [sp, #0x8]
700a1b62: f7fa f9c5    	bl	0x7009bef0 <Udma_chAllocResource> @ imm = #-0x5c76
700a1b66: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK == retVal)
700a1b68: 9805         	ldr	r0, [sp, #0x14]
700a1b6a: b918         	cbnz	r0, 0x700a1b74 <Udma_chOpen+0x114> @ imm = #0x6
700a1b6c: e7ff         	b	0x700a1b6e <Udma_chOpen+0x10e> @ imm = #-0x2
700a1b6e: 2001         	movs	r0, #0x1
;             allocDone = (uint32_t) TRUE;
700a1b70: 9003         	str	r0, [sp, #0xc]
;         }
700a1b72: e000         	b	0x700a1b76 <Udma_chOpen+0x116> @ imm = #0x0
700a1b74: e7ff         	b	0x700a1b76 <Udma_chOpen+0x116> @ imm = #-0x2
;     }
700a1b76: e7ff         	b	0x700a1b78 <Udma_chOpen+0x118> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1b78: 9805         	ldr	r0, [sp, #0x14]
700a1b7a: b948         	cbnz	r0, 0x700a1b90 <Udma_chOpen+0x130> @ imm = #0x12
700a1b7c: e7ff         	b	0x700a1b7e <Udma_chOpen+0x11e> @ imm = #-0x2
;         retVal = Udma_chPair(chHandleInt);
700a1b7e: 9802         	ldr	r0, [sp, #0x8]
700a1b80: f008 fe76    	bl	0x700aa870 <Udma_chPair> @ imm = #0x8cec
700a1b84: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK != retVal)
700a1b86: 9805         	ldr	r0, [sp, #0x14]
700a1b88: b108         	cbz	r0, 0x700a1b8e <Udma_chOpen+0x12e> @ imm = #0x2
700a1b8a: e7ff         	b	0x700a1b8c <Udma_chOpen+0x12c> @ imm = #-0x2
;         }
700a1b8c: e7ff         	b	0x700a1b8e <Udma_chOpen+0x12e> @ imm = #-0x2
;     }
700a1b8e: e7ff         	b	0x700a1b90 <Udma_chOpen+0x130> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1b90: 9805         	ldr	r0, [sp, #0x14]
700a1b92: b940         	cbnz	r0, 0x700a1ba6 <Udma_chOpen+0x146> @ imm = #0x10
700a1b94: e7ff         	b	0x700a1b96 <Udma_chOpen+0x136> @ imm = #-0x2
;         chHandleInt->chInitDone = UDMA_INIT_DONE;
700a1b96: 9902         	ldr	r1, [sp, #0x8]
700a1b98: f64a 30cd    	movw	r0, #0xabcd
700a1b9c: f6ca 30dc    	movt	r0, #0xabdc
700a1ba0: f8c1 0244    	str.w	r0, [r1, #0x244]
;     }
700a1ba4: e00d         	b	0x700a1bc2 <Udma_chOpen+0x162> @ imm = #0x1a
;         if(((uint32_t) TRUE) == allocDone)
700a1ba6: 9803         	ldr	r0, [sp, #0xc]
700a1ba8: 2801         	cmp	r0, #0x1
700a1baa: d109         	bne	0x700a1bc0 <Udma_chOpen+0x160> @ imm = #0x12
700a1bac: e7ff         	b	0x700a1bae <Udma_chOpen+0x14e> @ imm = #-0x2
;             tempRetVal = Udma_chFreeResource(chHandleInt);
700a1bae: 9802         	ldr	r0, [sp, #0x8]
700a1bb0: f7fd fa76    	bl	0x7009f0a0 <Udma_chFreeResource> @ imm = #-0x2b14
700a1bb4: 9004         	str	r0, [sp, #0x10]
;             if(UDMA_SOK != tempRetVal)
700a1bb6: 9804         	ldr	r0, [sp, #0x10]
700a1bb8: b108         	cbz	r0, 0x700a1bbe <Udma_chOpen+0x15e> @ imm = #0x2
700a1bba: e7ff         	b	0x700a1bbc <Udma_chOpen+0x15c> @ imm = #-0x2
;             }
700a1bbc: e7ff         	b	0x700a1bbe <Udma_chOpen+0x15e> @ imm = #-0x2
;         }
700a1bbe: e7ff         	b	0x700a1bc0 <Udma_chOpen+0x160> @ imm = #-0x2
700a1bc0: e7ff         	b	0x700a1bc2 <Udma_chOpen+0x162> @ imm = #-0x2
;     return (retVal);
700a1bc2: 9805         	ldr	r0, [sp, #0x14]
700a1bc4: b00a         	add	sp, #0x28
700a1bc6: bd80         	pop	{r7, pc}
		...

700a1bd0 <Udma_rmAllocMappedRxCh>:
; {
700a1bd0: b580         	push	{r7, lr}
700a1bd2: b08a         	sub	sp, #0x28
700a1bd4: 9009         	str	r0, [sp, #0x24]
700a1bd6: 9108         	str	r1, [sp, #0x20]
700a1bd8: 9207         	str	r2, [sp, #0x1c]
700a1bda: 2000         	movs	r0, #0x0
700a1bdc: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1be0: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1be2: 9808         	ldr	r0, [sp, #0x20]
700a1be4: f500 70ea    	add.w	r0, r0, #0x1d4
700a1be8: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1bea: 9808         	ldr	r0, [sp, #0x20]
700a1bec: f500 609f    	add.w	r0, r0, #0x4f8
700a1bf0: f04f 31ff    	mov.w	r1, #0xffffffff
700a1bf4: f008 fdf4    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x8be8
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1bf8: 9809         	ldr	r0, [sp, #0x24]
700a1bfa: 2101         	movs	r1, #0x1
700a1bfc: f6cf 71ff    	movt	r1, #0xffff
700a1c00: 4288         	cmp	r0, r1
700a1c02: d142         	bne	0x700a1c8a <Udma_rmAllocMappedRxCh+0xba> @ imm = #0x84
700a1c04: e7ff         	b	0x700a1c06 <Udma_rmAllocMappedRxCh+0x36> @ imm = #-0x2
700a1c06: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numMappedRxCh[mappedChGrp]; i++)
700a1c08: 9005         	str	r0, [sp, #0x14]
700a1c0a: e7ff         	b	0x700a1c0c <Udma_rmAllocMappedRxCh+0x3c> @ imm = #-0x2
700a1c0c: 9805         	ldr	r0, [sp, #0x14]
700a1c0e: 9901         	ldr	r1, [sp, #0x4]
700a1c10: 9a07         	ldr	r2, [sp, #0x1c]
700a1c12: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1c16: 6f89         	ldr	r1, [r1, #0x78]
700a1c18: 4288         	cmp	r0, r1
700a1c1a: d235         	bhs	0x700a1c88 <Udma_rmAllocMappedRxCh+0xb8> @ imm = #0x6a
700a1c1c: e7ff         	b	0x700a1c1e <Udma_rmAllocMappedRxCh+0x4e> @ imm = #-0x2
;             offset = i >> 5U;
700a1c1e: 9805         	ldr	r0, [sp, #0x14]
700a1c20: 0940         	lsrs	r0, r0, #0x5
700a1c22: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1c24: 9805         	ldr	r0, [sp, #0x14]
700a1c26: 9904         	ldr	r1, [sp, #0x10]
700a1c28: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1c2c: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1c2e: 9903         	ldr	r1, [sp, #0xc]
700a1c30: 2001         	movs	r0, #0x1
700a1c32: 4088         	lsls	r0, r1
700a1c34: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedRxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1c36: 9808         	ldr	r0, [sp, #0x20]
700a1c38: 9907         	ldr	r1, [sp, #0x1c]
700a1c3a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1c3e: 9904         	ldr	r1, [sp, #0x10]
700a1c40: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1c44: f8d0 0334    	ldr.w	r0, [r0, #0x334]
700a1c48: 9902         	ldr	r1, [sp, #0x8]
700a1c4a: 4008         	ands	r0, r1
700a1c4c: 4288         	cmp	r0, r1
700a1c4e: d116         	bne	0x700a1c7e <Udma_rmAllocMappedRxCh+0xae> @ imm = #0x2c
700a1c50: e7ff         	b	0x700a1c52 <Udma_rmAllocMappedRxCh+0x82> @ imm = #-0x2
;                 drvHandle->mappedRxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1c52: 9a02         	ldr	r2, [sp, #0x8]
700a1c54: 9808         	ldr	r0, [sp, #0x20]
700a1c56: 9907         	ldr	r1, [sp, #0x1c]
700a1c58: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1c5c: 9904         	ldr	r1, [sp, #0x10]
700a1c5e: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1c62: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700a1c66: 4390         	bics	r0, r2
700a1c68: f8c1 0334    	str.w	r0, [r1, #0x334]
;                 chNum = i + rmInitPrms->startMappedRxCh[mappedChGrp];  /* Add start offset */
700a1c6c: 9805         	ldr	r0, [sp, #0x14]
700a1c6e: 9901         	ldr	r1, [sp, #0x4]
700a1c70: 9a07         	ldr	r2, [sp, #0x1c]
700a1c72: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1c76: 6e89         	ldr	r1, [r1, #0x68]
700a1c78: 4408         	add	r0, r1
700a1c7a: 9006         	str	r0, [sp, #0x18]
;                 break;
700a1c7c: e004         	b	0x700a1c88 <Udma_rmAllocMappedRxCh+0xb8> @ imm = #0x8
;         }
700a1c7e: e7ff         	b	0x700a1c80 <Udma_rmAllocMappedRxCh+0xb0> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numMappedRxCh[mappedChGrp]; i++)
700a1c80: 9805         	ldr	r0, [sp, #0x14]
700a1c82: 3001         	adds	r0, #0x1
700a1c84: 9005         	str	r0, [sp, #0x14]
700a1c86: e7c1         	b	0x700a1c0c <Udma_rmAllocMappedRxCh+0x3c> @ imm = #-0x7e
;     }
700a1c88: e047         	b	0x700a1d1a <Udma_rmAllocMappedRxCh+0x14a> @ imm = #0x8e
;         if((preferredChNum >= rmInitPrms->startMappedRxCh[mappedChGrp]) &&
700a1c8a: 9809         	ldr	r0, [sp, #0x24]
700a1c8c: 9901         	ldr	r1, [sp, #0x4]
700a1c8e: 9a07         	ldr	r2, [sp, #0x1c]
700a1c90: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1c94: 6e89         	ldr	r1, [r1, #0x68]
700a1c96: 4288         	cmp	r0, r1
700a1c98: d33e         	blo	0x700a1d18 <Udma_rmAllocMappedRxCh+0x148> @ imm = #0x7c
700a1c9a: e7ff         	b	0x700a1c9c <Udma_rmAllocMappedRxCh+0xcc> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startMappedRxCh[mappedChGrp] + rmInitPrms->numMappedRxCh[mappedChGrp])))
700a1c9c: 9809         	ldr	r0, [sp, #0x24]
700a1c9e: 9901         	ldr	r1, [sp, #0x4]
700a1ca0: 9a07         	ldr	r2, [sp, #0x1c]
700a1ca2: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a1ca6: 6e91         	ldr	r1, [r2, #0x68]
700a1ca8: 6f92         	ldr	r2, [r2, #0x78]
700a1caa: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startMappedRxCh[mappedChGrp]) &&
700a1cac: 4288         	cmp	r0, r1
700a1cae: d233         	bhs	0x700a1d18 <Udma_rmAllocMappedRxCh+0x148> @ imm = #0x66
700a1cb0: e7ff         	b	0x700a1cb2 <Udma_rmAllocMappedRxCh+0xe2> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startMappedRxCh[mappedChGrp];
700a1cb2: 9809         	ldr	r0, [sp, #0x24]
700a1cb4: 9901         	ldr	r1, [sp, #0x4]
700a1cb6: 9a07         	ldr	r2, [sp, #0x1c]
700a1cb8: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1cbc: 6e89         	ldr	r1, [r1, #0x68]
700a1cbe: 1a40         	subs	r0, r0, r1
700a1cc0: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1cc2: 9805         	ldr	r0, [sp, #0x14]
700a1cc4: 0940         	lsrs	r0, r0, #0x5
700a1cc6: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1cc8: 9805         	ldr	r0, [sp, #0x14]
700a1cca: 9904         	ldr	r1, [sp, #0x10]
700a1ccc: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1cd0: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1cd2: 9903         	ldr	r1, [sp, #0xc]
700a1cd4: 2001         	movs	r0, #0x1
700a1cd6: 4088         	lsls	r0, r1
700a1cd8: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedRxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1cda: 9808         	ldr	r0, [sp, #0x20]
700a1cdc: 9907         	ldr	r1, [sp, #0x1c]
700a1cde: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1ce2: 9904         	ldr	r1, [sp, #0x10]
700a1ce4: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1ce8: f8d0 0334    	ldr.w	r0, [r0, #0x334]
700a1cec: 9902         	ldr	r1, [sp, #0x8]
700a1cee: 4008         	ands	r0, r1
700a1cf0: 4288         	cmp	r0, r1
700a1cf2: d110         	bne	0x700a1d16 <Udma_rmAllocMappedRxCh+0x146> @ imm = #0x20
700a1cf4: e7ff         	b	0x700a1cf6 <Udma_rmAllocMappedRxCh+0x126> @ imm = #-0x2
;                 drvHandle->mappedRxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1cf6: 9a02         	ldr	r2, [sp, #0x8]
700a1cf8: 9808         	ldr	r0, [sp, #0x20]
700a1cfa: 9907         	ldr	r1, [sp, #0x1c]
700a1cfc: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1d00: 9904         	ldr	r1, [sp, #0x10]
700a1d02: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1d06: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700a1d0a: 4390         	bics	r0, r2
700a1d0c: f8c1 0334    	str.w	r0, [r1, #0x334]
;                 chNum = preferredChNum;
700a1d10: 9809         	ldr	r0, [sp, #0x24]
700a1d12: 9006         	str	r0, [sp, #0x18]
;             }
700a1d14: e7ff         	b	0x700a1d16 <Udma_rmAllocMappedRxCh+0x146> @ imm = #-0x2
;         }
700a1d16: e7ff         	b	0x700a1d18 <Udma_rmAllocMappedRxCh+0x148> @ imm = #-0x2
700a1d18: e7ff         	b	0x700a1d1a <Udma_rmAllocMappedRxCh+0x14a> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1d1a: 9808         	ldr	r0, [sp, #0x20]
700a1d1c: f500 609f    	add.w	r0, r0, #0x4f8
700a1d20: f00a f8ee    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0xa1dc
;     return (chNum);
700a1d24: 9806         	ldr	r0, [sp, #0x18]
700a1d26: b00a         	add	sp, #0x28
700a1d28: bd80         	pop	{r7, pc}
700a1d2a: 0000         	movs	r0, r0
700a1d2c: 0000         	movs	r0, r0
700a1d2e: 0000         	movs	r0, r0

700a1d30 <Udma_rmAllocMappedTxCh>:
; {
700a1d30: b580         	push	{r7, lr}
700a1d32: b08a         	sub	sp, #0x28
700a1d34: 9009         	str	r0, [sp, #0x24]
700a1d36: 9108         	str	r1, [sp, #0x20]
700a1d38: 9207         	str	r2, [sp, #0x1c]
700a1d3a: 2000         	movs	r0, #0x0
700a1d3c: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1d40: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1d42: 9808         	ldr	r0, [sp, #0x20]
700a1d44: f500 70ea    	add.w	r0, r0, #0x1d4
700a1d48: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1d4a: 9808         	ldr	r0, [sp, #0x20]
700a1d4c: f500 609f    	add.w	r0, r0, #0x4f8
700a1d50: f04f 31ff    	mov.w	r1, #0xffffffff
700a1d54: f008 fd44    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x8a88
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1d58: 9809         	ldr	r0, [sp, #0x24]
700a1d5a: 2101         	movs	r1, #0x1
700a1d5c: f6cf 71ff    	movt	r1, #0xffff
700a1d60: 4288         	cmp	r0, r1
700a1d62: d142         	bne	0x700a1dea <Udma_rmAllocMappedTxCh+0xba> @ imm = #0x84
700a1d64: e7ff         	b	0x700a1d66 <Udma_rmAllocMappedTxCh+0x36> @ imm = #-0x2
700a1d66: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numMappedTxCh[mappedChGrp]; i++)
700a1d68: 9005         	str	r0, [sp, #0x14]
700a1d6a: e7ff         	b	0x700a1d6c <Udma_rmAllocMappedTxCh+0x3c> @ imm = #-0x2
700a1d6c: 9805         	ldr	r0, [sp, #0x14]
700a1d6e: 9901         	ldr	r1, [sp, #0x4]
700a1d70: 9a07         	ldr	r2, [sp, #0x1c]
700a1d72: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1d76: 6d89         	ldr	r1, [r1, #0x58]
700a1d78: 4288         	cmp	r0, r1
700a1d7a: d235         	bhs	0x700a1de8 <Udma_rmAllocMappedTxCh+0xb8> @ imm = #0x6a
700a1d7c: e7ff         	b	0x700a1d7e <Udma_rmAllocMappedTxCh+0x4e> @ imm = #-0x2
;             offset = i >> 5U;
700a1d7e: 9805         	ldr	r0, [sp, #0x14]
700a1d80: 0940         	lsrs	r0, r0, #0x5
700a1d82: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1d84: 9805         	ldr	r0, [sp, #0x14]
700a1d86: 9904         	ldr	r1, [sp, #0x10]
700a1d88: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1d8c: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1d8e: 9903         	ldr	r1, [sp, #0xc]
700a1d90: 2001         	movs	r0, #0x1
700a1d92: 4088         	lsls	r0, r1
700a1d94: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedTxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1d96: 9808         	ldr	r0, [sp, #0x20]
700a1d98: 9907         	ldr	r1, [sp, #0x1c]
700a1d9a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1d9e: 9904         	ldr	r1, [sp, #0x10]
700a1da0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1da4: f8d0 0324    	ldr.w	r0, [r0, #0x324]
700a1da8: 9902         	ldr	r1, [sp, #0x8]
700a1daa: 4008         	ands	r0, r1
700a1dac: 4288         	cmp	r0, r1
700a1dae: d116         	bne	0x700a1dde <Udma_rmAllocMappedTxCh+0xae> @ imm = #0x2c
700a1db0: e7ff         	b	0x700a1db2 <Udma_rmAllocMappedTxCh+0x82> @ imm = #-0x2
;                 drvHandle->mappedTxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1db2: 9a02         	ldr	r2, [sp, #0x8]
700a1db4: 9808         	ldr	r0, [sp, #0x20]
700a1db6: 9907         	ldr	r1, [sp, #0x1c]
700a1db8: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1dbc: 9904         	ldr	r1, [sp, #0x10]
700a1dbe: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1dc2: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a1dc6: 4390         	bics	r0, r2
700a1dc8: f8c1 0324    	str.w	r0, [r1, #0x324]
;                 chNum = i + rmInitPrms->startMappedTxCh[mappedChGrp];  /* Add start offset */
700a1dcc: 9805         	ldr	r0, [sp, #0x14]
700a1dce: 9901         	ldr	r1, [sp, #0x4]
700a1dd0: 9a07         	ldr	r2, [sp, #0x1c]
700a1dd2: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1dd6: 6c89         	ldr	r1, [r1, #0x48]
700a1dd8: 4408         	add	r0, r1
700a1dda: 9006         	str	r0, [sp, #0x18]
;                 break;
700a1ddc: e004         	b	0x700a1de8 <Udma_rmAllocMappedTxCh+0xb8> @ imm = #0x8
;         }
700a1dde: e7ff         	b	0x700a1de0 <Udma_rmAllocMappedTxCh+0xb0> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numMappedTxCh[mappedChGrp]; i++)
700a1de0: 9805         	ldr	r0, [sp, #0x14]
700a1de2: 3001         	adds	r0, #0x1
700a1de4: 9005         	str	r0, [sp, #0x14]
700a1de6: e7c1         	b	0x700a1d6c <Udma_rmAllocMappedTxCh+0x3c> @ imm = #-0x7e
;     }
700a1de8: e047         	b	0x700a1e7a <Udma_rmAllocMappedTxCh+0x14a> @ imm = #0x8e
;         if((preferredChNum >= rmInitPrms->startMappedTxCh[mappedChGrp]) &&
700a1dea: 9809         	ldr	r0, [sp, #0x24]
700a1dec: 9901         	ldr	r1, [sp, #0x4]
700a1dee: 9a07         	ldr	r2, [sp, #0x1c]
700a1df0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1df4: 6c89         	ldr	r1, [r1, #0x48]
700a1df6: 4288         	cmp	r0, r1
700a1df8: d33e         	blo	0x700a1e78 <Udma_rmAllocMappedTxCh+0x148> @ imm = #0x7c
700a1dfa: e7ff         	b	0x700a1dfc <Udma_rmAllocMappedTxCh+0xcc> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startMappedTxCh[mappedChGrp] + rmInitPrms->numMappedTxCh[mappedChGrp])))
700a1dfc: 9809         	ldr	r0, [sp, #0x24]
700a1dfe: 9901         	ldr	r1, [sp, #0x4]
700a1e00: 9a07         	ldr	r2, [sp, #0x1c]
700a1e02: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a1e06: 6c91         	ldr	r1, [r2, #0x48]
700a1e08: 6d92         	ldr	r2, [r2, #0x58]
700a1e0a: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startMappedTxCh[mappedChGrp]) &&
700a1e0c: 4288         	cmp	r0, r1
700a1e0e: d233         	bhs	0x700a1e78 <Udma_rmAllocMappedTxCh+0x148> @ imm = #0x66
700a1e10: e7ff         	b	0x700a1e12 <Udma_rmAllocMappedTxCh+0xe2> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startMappedTxCh[mappedChGrp];
700a1e12: 9809         	ldr	r0, [sp, #0x24]
700a1e14: 9901         	ldr	r1, [sp, #0x4]
700a1e16: 9a07         	ldr	r2, [sp, #0x1c]
700a1e18: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1e1c: 6c89         	ldr	r1, [r1, #0x48]
700a1e1e: 1a40         	subs	r0, r0, r1
700a1e20: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1e22: 9805         	ldr	r0, [sp, #0x14]
700a1e24: 0940         	lsrs	r0, r0, #0x5
700a1e26: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1e28: 9805         	ldr	r0, [sp, #0x14]
700a1e2a: 9904         	ldr	r1, [sp, #0x10]
700a1e2c: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1e30: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1e32: 9903         	ldr	r1, [sp, #0xc]
700a1e34: 2001         	movs	r0, #0x1
700a1e36: 4088         	lsls	r0, r1
700a1e38: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedTxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1e3a: 9808         	ldr	r0, [sp, #0x20]
700a1e3c: 9907         	ldr	r1, [sp, #0x1c]
700a1e3e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1e42: 9904         	ldr	r1, [sp, #0x10]
700a1e44: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1e48: f8d0 0324    	ldr.w	r0, [r0, #0x324]
700a1e4c: 9902         	ldr	r1, [sp, #0x8]
700a1e4e: 4008         	ands	r0, r1
700a1e50: 4288         	cmp	r0, r1
700a1e52: d110         	bne	0x700a1e76 <Udma_rmAllocMappedTxCh+0x146> @ imm = #0x20
700a1e54: e7ff         	b	0x700a1e56 <Udma_rmAllocMappedTxCh+0x126> @ imm = #-0x2
;                 drvHandle->mappedTxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1e56: 9a02         	ldr	r2, [sp, #0x8]
700a1e58: 9808         	ldr	r0, [sp, #0x20]
700a1e5a: 9907         	ldr	r1, [sp, #0x1c]
700a1e5c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1e60: 9904         	ldr	r1, [sp, #0x10]
700a1e62: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1e66: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a1e6a: 4390         	bics	r0, r2
700a1e6c: f8c1 0324    	str.w	r0, [r1, #0x324]
;                 chNum = preferredChNum;
700a1e70: 9809         	ldr	r0, [sp, #0x24]
700a1e72: 9006         	str	r0, [sp, #0x18]
;             }
700a1e74: e7ff         	b	0x700a1e76 <Udma_rmAllocMappedTxCh+0x146> @ imm = #-0x2
;         }
700a1e76: e7ff         	b	0x700a1e78 <Udma_rmAllocMappedTxCh+0x148> @ imm = #-0x2
700a1e78: e7ff         	b	0x700a1e7a <Udma_rmAllocMappedTxCh+0x14a> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1e7a: 9808         	ldr	r0, [sp, #0x20]
700a1e7c: f500 609f    	add.w	r0, r0, #0x4f8
700a1e80: f00a f83e    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0xa07c
;     return (chNum);
700a1e84: 9806         	ldr	r0, [sp, #0x18]
700a1e86: b00a         	add	sp, #0x28
700a1e88: bd80         	pop	{r7, pc}
700a1e8a: 0000         	movs	r0, r0
700a1e8c: 0000         	movs	r0, r0
700a1e8e: 0000         	movs	r0, r0

700a1e90 <CSL_bcdmaChanOpGetChanStats>:
; {
700a1e90: b580         	push	{r7, lr}
700a1e92: b088         	sub	sp, #0x20
700a1e94: 9007         	str	r0, [sp, #0x1c]
700a1e96: 9106         	str	r1, [sp, #0x18]
700a1e98: 9205         	str	r2, [sp, #0x14]
700a1e9a: 9304         	str	r3, [sp, #0x10]
700a1e9c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a1e9e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a1ea0: 9804         	ldr	r0, [sp, #0x10]
700a1ea2: b920         	cbnz	r0, 0x700a1eae <CSL_bcdmaChanOpGetChanStats+0x1e> @ imm = #0x8
700a1ea4: e7ff         	b	0x700a1ea6 <CSL_bcdmaChanOpGetChanStats+0x16> @ imm = #-0x2
700a1ea6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a1eaa: 9003         	str	r0, [sp, #0xc]
;     }
700a1eac: e099         	b	0x700a1fe2 <CSL_bcdmaChanOpGetChanStats+0x152> @ imm = #0x132
;         CSL_BcdmaChanStats *pChanStats = (CSL_BcdmaChanStats *)pOpData;
700a1eae: 9804         	ldr	r0, [sp, #0x10]
700a1eb0: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a1eb2: 9806         	ldr	r0, [sp, #0x18]
700a1eb4: 9001         	str	r0, [sp, #0x4]
700a1eb6: b140         	cbz	r0, 0x700a1eca <CSL_bcdmaChanOpGetChanStats+0x3a> @ imm = #0x10
700a1eb8: e7ff         	b	0x700a1eba <CSL_bcdmaChanOpGetChanStats+0x2a> @ imm = #-0x2
700a1eba: 9801         	ldr	r0, [sp, #0x4]
700a1ebc: 2801         	cmp	r0, #0x1
700a1ebe: d031         	beq	0x700a1f24 <CSL_bcdmaChanOpGetChanStats+0x94> @ imm = #0x62
700a1ec0: e7ff         	b	0x700a1ec2 <CSL_bcdmaChanOpGetChanStats+0x32> @ imm = #-0x2
700a1ec2: 9801         	ldr	r0, [sp, #0x4]
700a1ec4: 2802         	cmp	r0, #0x2
700a1ec6: d05a         	beq	0x700a1f7e <CSL_bcdmaChanOpGetChanStats+0xee> @ imm = #0xb4
700a1ec8: e086         	b	0x700a1fd8 <CSL_bcdmaChanOpGetChanStats+0x148> @ imm = #0x10c
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].PCNT );
700a1eca: 9807         	ldr	r0, [sp, #0x1c]
700a1ecc: 6880         	ldr	r0, [r0, #0x8]
700a1ece: 9905         	ldr	r1, [sp, #0x14]
700a1ed0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1ed4: f500 6080    	add.w	r0, r0, #0x400
700a1ed8: f00d fe9a    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xdd34
700a1edc: 9902         	ldr	r1, [sp, #0x8]
700a1ede: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].BCNT );
700a1ee0: 9807         	ldr	r0, [sp, #0x1c]
700a1ee2: 6880         	ldr	r0, [r0, #0x8]
700a1ee4: 9905         	ldr	r1, [sp, #0x14]
700a1ee6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1eea: f500 6081    	add.w	r0, r0, #0x408
700a1eee: f00d fe8f    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xdd1e
700a1ef2: 9902         	ldr	r1, [sp, #0x8]
700a1ef4: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].SBCNT );
700a1ef6: 9807         	ldr	r0, [sp, #0x1c]
700a1ef8: 6880         	ldr	r0, [r0, #0x8]
700a1efa: 9905         	ldr	r1, [sp, #0x14]
700a1efc: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1f00: f500 6082    	add.w	r0, r0, #0x410
700a1f04: f00d fe84    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xdd08
700a1f08: 9902         	ldr	r1, [sp, #0x8]
700a1f0a: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = (uint32_t)0U;
700a1f0c: 9902         	ldr	r1, [sp, #0x8]
700a1f0e: 2000         	movs	r0, #0x0
700a1f10: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = (uint32_t)0U;
700a1f12: 9902         	ldr	r1, [sp, #0x8]
700a1f14: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->txPayloadByteCnt;
700a1f16: 9902         	ldr	r1, [sp, #0x8]
700a1f18: 6848         	ldr	r0, [r1, #0x4]
700a1f1a: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->txStartedByteCnt;
700a1f1c: 9902         	ldr	r1, [sp, #0x8]
700a1f1e: 6888         	ldr	r0, [r1, #0x8]
700a1f20: 6188         	str	r0, [r1, #0x18]
;                 break;
700a1f22: e05d         	b	0x700a1fe0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0xba
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].PCNT );
700a1f24: 9807         	ldr	r0, [sp, #0x1c]
700a1f26: 6900         	ldr	r0, [r0, #0x10]
700a1f28: 9905         	ldr	r1, [sp, #0x14]
700a1f2a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1f2e: f500 6080    	add.w	r0, r0, #0x400
700a1f32: f00d fe6d    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xdcda
700a1f36: 9902         	ldr	r1, [sp, #0x8]
700a1f38: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].BCNT );
700a1f3a: 9807         	ldr	r0, [sp, #0x1c]
700a1f3c: 6900         	ldr	r0, [r0, #0x10]
700a1f3e: 9905         	ldr	r1, [sp, #0x14]
700a1f40: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1f44: f500 6081    	add.w	r0, r0, #0x408
700a1f48: f00d fe62    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xdcc4
700a1f4c: 9902         	ldr	r1, [sp, #0x8]
700a1f4e: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].SBCNT );
700a1f50: 9807         	ldr	r0, [sp, #0x1c]
700a1f52: 6900         	ldr	r0, [r0, #0x10]
700a1f54: 9905         	ldr	r1, [sp, #0x14]
700a1f56: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1f5a: f500 6082    	add.w	r0, r0, #0x410
700a1f5e: f00d fe57    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xdcae
700a1f62: 9902         	ldr	r1, [sp, #0x8]
700a1f64: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = (uint32_t)0U;
700a1f66: 9902         	ldr	r1, [sp, #0x8]
700a1f68: 2000         	movs	r0, #0x0
700a1f6a: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = (uint32_t)0U;
700a1f6c: 9902         	ldr	r1, [sp, #0x8]
700a1f6e: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->txPayloadByteCnt;
700a1f70: 9902         	ldr	r1, [sp, #0x8]
700a1f72: 6848         	ldr	r0, [r1, #0x4]
700a1f74: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->txStartedByteCnt;
700a1f76: 9902         	ldr	r1, [sp, #0x8]
700a1f78: 6888         	ldr	r0, [r1, #0x8]
700a1f7a: 6188         	str	r0, [r1, #0x18]
;                 break;
700a1f7c: e030         	b	0x700a1fe0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0x60
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].PCNT );
700a1f7e: 9807         	ldr	r0, [sp, #0x1c]
700a1f80: 6980         	ldr	r0, [r0, #0x18]
700a1f82: 9905         	ldr	r1, [sp, #0x14]
700a1f84: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1f88: f500 6080    	add.w	r0, r0, #0x400
700a1f8c: f00d fe40    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xdc80
700a1f90: 9902         	ldr	r1, [sp, #0x8]
700a1f92: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = (uint32_t)0U;
700a1f94: 9902         	ldr	r1, [sp, #0x8]
700a1f96: 2000         	movs	r0, #0x0
700a1f98: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = (uint32_t)0U;
700a1f9a: 9902         	ldr	r1, [sp, #0x8]
700a1f9c: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].BCNT );
700a1f9e: 9807         	ldr	r0, [sp, #0x1c]
700a1fa0: 6980         	ldr	r0, [r0, #0x18]
700a1fa2: 9905         	ldr	r1, [sp, #0x14]
700a1fa4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1fa8: f500 6081    	add.w	r0, r0, #0x408
700a1fac: f00d fe30    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xdc60
700a1fb0: 9902         	ldr	r1, [sp, #0x8]
700a1fb2: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].SBCNT );
700a1fb4: 9807         	ldr	r0, [sp, #0x1c]
700a1fb6: 6980         	ldr	r0, [r0, #0x18]
700a1fb8: 9905         	ldr	r1, [sp, #0x14]
700a1fba: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1fbe: f500 6082    	add.w	r0, r0, #0x410
700a1fc2: f00d fe25    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xdc4a
700a1fc6: 9902         	ldr	r1, [sp, #0x8]
700a1fc8: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->rxPayloadByteCnt;
700a1fca: 9902         	ldr	r1, [sp, #0x8]
700a1fcc: 68c8         	ldr	r0, [r1, #0xc]
700a1fce: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->rxStartedByteCnt;
700a1fd0: 9902         	ldr	r1, [sp, #0x8]
700a1fd2: 6908         	ldr	r0, [r1, #0x10]
700a1fd4: 6188         	str	r0, [r1, #0x18]
;                 break;
700a1fd6: e003         	b	0x700a1fe0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0x6
700a1fd8: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a1fdc: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1fde: e7ff         	b	0x700a1fe0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #-0x2
700a1fe0: e7ff         	b	0x700a1fe2 <CSL_bcdmaChanOpGetChanStats+0x152> @ imm = #-0x2
;     return retVal;
700a1fe2: 9803         	ldr	r0, [sp, #0xc]
700a1fe4: b008         	add	sp, #0x20
700a1fe6: bd80         	pop	{r7, pc}
		...

700a1ff0 <UART_lld_initDma>:
; {
700a1ff0: b580         	push	{r7, lr}
700a1ff2: b084         	sub	sp, #0x10
700a1ff4: 9003         	str	r0, [sp, #0xc]
700a1ff6: 2000         	movs	r0, #0x0
;     int32_t                status = UART_STATUS_SUCCESS;
700a1ff8: 9002         	str	r0, [sp, #0x8]
;     if((hUart != NULL_PTR) && (hUart->hUartInit != NULL_PTR))
700a1ffa: 9803         	ldr	r0, [sp, #0xc]
700a1ffc: b168         	cbz	r0, 0x700a201a <UART_lld_initDma+0x2a> @ imm = #0x1a
700a1ffe: e7ff         	b	0x700a2000 <UART_lld_initDma+0x10> @ imm = #-0x2
700a2000: 9803         	ldr	r0, [sp, #0xc]
700a2002: 6840         	ldr	r0, [r0, #0x4]
700a2004: b148         	cbz	r0, 0x700a201a <UART_lld_initDma+0x2a> @ imm = #0x12
700a2006: e7ff         	b	0x700a2008 <UART_lld_initDma+0x18> @ imm = #-0x2
;         if(hUart->state != UART_STATE_RESET)
700a2008: 9803         	ldr	r0, [sp, #0xc]
700a200a: 6d40         	ldr	r0, [r0, #0x54]
700a200c: b120         	cbz	r0, 0x700a2018 <UART_lld_initDma+0x28> @ imm = #0x8
700a200e: e7ff         	b	0x700a2010 <UART_lld_initDma+0x20> @ imm = #-0x2
700a2010: f06f 0004    	mvn	r0, #0x4
;             status = UART_TRANSFER_INVALID_STATE;
700a2014: 9002         	str	r0, [sp, #0x8]
;         }
700a2016: e7ff         	b	0x700a2018 <UART_lld_initDma+0x28> @ imm = #-0x2
;     }
700a2018: e003         	b	0x700a2022 <UART_lld_initDma+0x32> @ imm = #0x6
700a201a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a201e: 9002         	str	r0, [sp, #0x8]
700a2020: e7ff         	b	0x700a2022 <UART_lld_initDma+0x32> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a2022: 9802         	ldr	r0, [sp, #0x8]
700a2024: 2800         	cmp	r0, #0x0
700a2026: d170         	bne	0x700a210a <UART_lld_initDma+0x11a> @ imm = #0xe0
700a2028: e7ff         	b	0x700a202a <UART_lld_initDma+0x3a> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a202a: 9903         	ldr	r1, [sp, #0xc]
700a202c: 2002         	movs	r0, #0x2
700a202e: 6548         	str	r0, [r1, #0x54]
;         hUartInit = hUart->hUartInit;
700a2030: 9803         	ldr	r0, [sp, #0xc]
700a2032: 6840         	ldr	r0, [r0, #0x4]
700a2034: 9001         	str	r0, [sp, #0x4]
;         hUart->lineStatusTimeout = hUartInit->clockP_usecToTick(UART_READ_LINE_STATUS_TIMEOUT_IN_US);
700a2036: 9801         	ldr	r0, [sp, #0x4]
700a2038: 6d82         	ldr	r2, [r0, #0x58]
700a203a: f244 2040    	movw	r0, #0x4240
700a203e: f2c0 000f    	movt	r0, #0xf
700a2042: 2100         	movs	r1, #0x0
700a2044: 9100         	str	r1, [sp]
700a2046: 4790         	blx	r2
700a2048: 9a00         	ldr	r2, [sp]
700a204a: 9903         	ldr	r1, [sp, #0xc]
700a204c: 66ca         	str	r2, [r1, #0x6c]
700a204e: 6688         	str	r0, [r1, #0x68]
;         status += UART_IsBaseAddrValid(hUart->baseAddr);
700a2050: 9803         	ldr	r0, [sp, #0xc]
700a2052: 6800         	ldr	r0, [r0]
700a2054: f006 fbf4    	bl	0x700a8840 <UART_IsBaseAddrValid> @ imm = #0x67e8
700a2058: 4601         	mov	r1, r0
700a205a: 9802         	ldr	r0, [sp, #0x8]
700a205c: 4408         	add	r0, r1
700a205e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->inputClkFreq);
700a2060: 9801         	ldr	r0, [sp, #0x4]
700a2062: 6800         	ldr	r0, [r0]
700a2064: f00d fa94    	bl	0x700af590 <UART_IsParameter> @ imm = #0xd528
700a2068: 4601         	mov	r1, r0
700a206a: 9802         	ldr	r0, [sp, #0x8]
700a206c: 4408         	add	r0, r1
700a206e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->baudRate);
700a2070: 9801         	ldr	r0, [sp, #0x4]
700a2072: 6840         	ldr	r0, [r0, #0x4]
700a2074: f00d fa8c    	bl	0x700af590 <UART_IsParameter> @ imm = #0xd518
700a2078: 4601         	mov	r1, r0
700a207a: 9802         	ldr	r0, [sp, #0x8]
700a207c: 4408         	add	r0, r1
700a207e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsDataLengthValid(hUartInit->dataLength);
700a2080: 9801         	ldr	r0, [sp, #0x4]
700a2082: 6880         	ldr	r0, [r0, #0x8]
700a2084: f00c fa84    	bl	0x700ae590 <UART_IsDataLengthValid> @ imm = #0xc508
700a2088: 4601         	mov	r1, r0
700a208a: 9802         	ldr	r0, [sp, #0x8]
700a208c: 4408         	add	r0, r1
700a208e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsStopBitsValid(hUartInit->stopBits);
700a2090: 9801         	ldr	r0, [sp, #0x4]
700a2092: 68c0         	ldr	r0, [r0, #0xc]
700a2094: f00d f894    	bl	0x700af1c0 <UART_IsStopBitsValid> @ imm = #0xd128
700a2098: 4601         	mov	r1, r0
700a209a: 9802         	ldr	r0, [sp, #0x8]
700a209c: 4408         	add	r0, r1
700a209e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParityTypeValid(hUartInit->parityType);
700a20a0: 9801         	ldr	r0, [sp, #0x4]
700a20a2: 6900         	ldr	r0, [r0, #0x10]
700a20a4: f00b ffd4    	bl	0x700ae050 <UART_IsParityTypeValid> @ imm = #0xbfa8
700a20a8: 4601         	mov	r1, r0
700a20aa: 9802         	ldr	r0, [sp, #0x8]
700a20ac: 4408         	add	r0, r1
700a20ae: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsHWFlowCtrlValid(hUartInit->hwFlowControlThr);
700a20b0: 9801         	ldr	r0, [sp, #0x4]
700a20b2: 69c0         	ldr	r0, [r0, #0x1c]
700a20b4: f00b fe8c    	bl	0x700addd0 <UART_IsHWFlowCtrlValid> @ imm = #0xbd18
700a20b8: 4601         	mov	r1, r0
700a20ba: 9802         	ldr	r0, [sp, #0x8]
700a20bc: 4408         	add	r0, r1
700a20be: 9002         	str	r0, [sp, #0x8]
;         status += UART_OperModeValid(hUartInit->operMode);
700a20c0: 9801         	ldr	r0, [sp, #0x4]
700a20c2: 6ac0         	ldr	r0, [r0, #0x2c]
700a20c4: f00a fee4    	bl	0x700ace90 <UART_OperModeValid> @ imm = #0xadc8
700a20c8: 4601         	mov	r1, r0
700a20ca: 9802         	ldr	r0, [sp, #0x8]
700a20cc: 4408         	add	r0, r1
700a20ce: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsRxTrigLvlValid(hUartInit->rxTrigLvl);
700a20d0: 9801         	ldr	r0, [sp, #0x4]
700a20d2: 6b80         	ldr	r0, [r0, #0x38]
700a20d4: f00b fe9c    	bl	0x700ade10 <UART_IsRxTrigLvlValid> @ imm = #0xbd38
700a20d8: 4601         	mov	r1, r0
700a20da: 9802         	ldr	r0, [sp, #0x8]
700a20dc: 4408         	add	r0, r1
700a20de: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsTxTrigLvlValid(hUartInit->txTrigLvl);
700a20e0: 9801         	ldr	r0, [sp, #0x4]
700a20e2: 6bc0         	ldr	r0, [r0, #0x3c]
700a20e4: f00b feb4    	bl	0x700ade50 <UART_IsTxTrigLvlValid> @ imm = #0xbd68
700a20e8: 4601         	mov	r1, r0
700a20ea: 9802         	ldr	r0, [sp, #0x8]
700a20ec: 4408         	add	r0, r1
700a20ee: 9002         	str	r0, [sp, #0x8]
;         if((hUartInit->uartDmaHandle == NULL_PTR)
700a20f0: 9801         	ldr	r0, [sp, #0x4]
700a20f2: 6c80         	ldr	r0, [r0, #0x48]
;             || (hUartInit->dmaChCfg == NULL_PTR))
700a20f4: b120         	cbz	r0, 0x700a2100 <UART_lld_initDma+0x110> @ imm = #0x8
700a20f6: e7ff         	b	0x700a20f8 <UART_lld_initDma+0x108> @ imm = #-0x2
700a20f8: 9801         	ldr	r0, [sp, #0x4]
700a20fa: 6cc0         	ldr	r0, [r0, #0x4c]
;         if((hUartInit->uartDmaHandle == NULL_PTR)
700a20fc: b920         	cbnz	r0, 0x700a2108 <UART_lld_initDma+0x118> @ imm = #0x8
700a20fe: e7ff         	b	0x700a2100 <UART_lld_initDma+0x110> @ imm = #-0x2
;             status += UART_INVALID_PARAM;
700a2100: 9802         	ldr	r0, [sp, #0x8]
700a2102: 3803         	subs	r0, #0x3
700a2104: 9002         	str	r0, [sp, #0x8]
;         }
700a2106: e7ff         	b	0x700a2108 <UART_lld_initDma+0x118> @ imm = #-0x2
;     }
700a2108: e7ff         	b	0x700a210a <UART_lld_initDma+0x11a> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a210a: 9802         	ldr	r0, [sp, #0x8]
700a210c: b950         	cbnz	r0, 0x700a2124 <UART_lld_initDma+0x134> @ imm = #0x14
700a210e: e7ff         	b	0x700a2110 <UART_lld_initDma+0x120> @ imm = #-0x2
;         UART_configInstance(hUart);
700a2110: 9803         	ldr	r0, [sp, #0xc]
700a2112: f003 fa95    	bl	0x700a5640 <UART_configInstance> @ imm = #0x352a
;         status = UART_lld_dmaInit(hUart, hUart->hUartInit->dmaChCfg);
700a2116: 9803         	ldr	r0, [sp, #0xc]
700a2118: 6841         	ldr	r1, [r0, #0x4]
700a211a: 6cc9         	ldr	r1, [r1, #0x4c]
700a211c: f00b fa40    	bl	0x700ad5a0 <UART_lld_dmaInit> @ imm = #0xb480
700a2120: 9002         	str	r0, [sp, #0x8]
;     }
700a2122: e7ff         	b	0x700a2124 <UART_lld_initDma+0x134> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a2124: 9802         	ldr	r0, [sp, #0x8]
700a2126: b920         	cbnz	r0, 0x700a2132 <UART_lld_initDma+0x142> @ imm = #0x8
700a2128: e7ff         	b	0x700a212a <UART_lld_initDma+0x13a> @ imm = #-0x2
;         hUart->state = UART_STATE_READY;
700a212a: 9903         	ldr	r1, [sp, #0xc]
700a212c: 2001         	movs	r0, #0x1
700a212e: 6548         	str	r0, [r1, #0x54]
;     }
700a2130: e004         	b	0x700a213c <UART_lld_initDma+0x14c> @ imm = #0x8
;        status = UART_lld_deInitDma(hUart);
700a2132: 9803         	ldr	r0, [sp, #0xc]
700a2134: f009 fd94    	bl	0x700abc60 <UART_lld_deInitDma> @ imm = #0x9b28
700a2138: 9002         	str	r0, [sp, #0x8]
700a213a: e7ff         	b	0x700a213c <UART_lld_initDma+0x14c> @ imm = #-0x2
;     return status;
700a213c: 9802         	ldr	r0, [sp, #0x8]
700a213e: b004         	add	sp, #0x10
700a2140: bd80         	pop	{r7, pc}
700a2142: 0000         	movs	r0, r0

700a2144 <CSL_armR5PmuSelectCntr>:
;     AND     r0, r0, #0x1F
700a2144: e200001f     	and	r0, r0, #31
;     MCR     p15, #0, r0, c9, c12, #5        /* Write PMSELR Register */
700a2148: ee090fbc     	mcr	p15, #0x0, r0, c9, c12, #0x5
;     BX      lr
700a214c: e12fff1e     	bx	lr

700a2150 <CSL_armR5PmuCfg>:
;     MRC     p15, #0, r3, c9, c12, #0        /* Read PMCR Register */
700a2150: ee193f1c     	mrc	p15, #0x0, r3, c9, c12, #0x0
;     BIC     r3, r3, #((1<<3) | (1<<4))      /* Clear D and X bits */
700a2154: e3c33018     	bic	r3, r3, #24
;     CMP     r0, #0
700a2158: e3500000     	cmp	r0, #0
;     BEQ     armR5PmuCfg_00
700a215c: 0a000000     	beq	0x700a2164 <armR5PmuCfg_00> @ imm = #0x0
;     ORR     r3, r3, #(1<<3)                 /* Set D bit */
700a2160: e3833008     	orr	r3, r3, #8

700a2164 <armR5PmuCfg_00>:
;     CMP     r1, #0
700a2164: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuCfg_01
700a2168: 0a000000     	beq	0x700a2170 <armR5PmuCfg_01> @ imm = #0x0
;     ORR     r3, r3, #(1<<4)                 /* Set X bit */
700a216c: e3833010     	orr	r3, r3, #16

700a2170 <armR5PmuCfg_01>:
;     MCR     p15, #0, r3, c9, c12, #0        /* Write PMCR Register */
700a2170: ee093f1c     	mcr	p15, #0x0, r3, c9, c12, #0x0
;     EOR     r3, r3, r3                      /* Clear r3 */
700a2174: e0233003     	eor	r3, r3, r3
;     CMP     r2, #0
700a2178: e3520000     	cmp	r2, #0
;     BEQ     armR5PmuCfg_02
700a217c: 0a000000     	beq	0x700a2184 <armR5PmuCfg_02> @ imm = #0x0
;     ORR     r3, r3, #1
700a2180: e3833001     	orr	r3, r3, #1

700a2184 <armR5PmuCfg_02>:
;     MCR     p15, #0, r3, c9, c14, #0        /* Write PMUSERENR Register */
700a2184: ee093f1e     	mcr	p15, #0x0, r3, c9, c14, #0x0
;     BX      lr
700a2188: e12fff1e     	bx	lr

700a218c <CSL_armR5PmuEnableAllCntrs>:
;     MRC     p15, #0, r1, c9, c12, #0        /* Read PMCR */
700a218c: ee191f1c     	mrc	p15, #0x0, r1, c9, c12, #0x0
;     CMP     r0, #0
700a2190: e3500000     	cmp	r0, #0
;     BEQ     armR5PmuEnableAllCntrs_disable
700a2194: 0a000001     	beq	0x700a21a0 <armR5PmuEnableAllCntrs_disable> @ imm = #0x4
;     ORR     r1, r1, #0x1                    /* Set E bit to enable all counters */
700a2198: e3811001     	orr	r1, r1, #1
;     B       armR5PmuEnableAllCntrs_00
700a219c: ea000000     	b	0x700a21a4 <armR5PmuEnableAllCntrs_00> @ imm = #0x0

700a21a0 <armR5PmuEnableAllCntrs_disable>:
;     BIC     r1, r1, #0x1                    /* Clr E bit to disable all counters */
700a21a0: e3c11001     	bic	r1, r1, #1

700a21a4 <armR5PmuEnableAllCntrs_00>:
;     MCR     p15, #0, r1, c9, c12, #0        /* Write modified PMCR */
700a21a4: ee091f1c     	mcr	p15, #0x0, r1, c9, c12, #0x0
;     BX      lr
700a21a8: e12fff1e     	bx	lr

700a21ac <CSL_armR5PmuGetNumCntrs>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR (Performance Monitor Control Register) */
700a21ac: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     LSR     r0, r0, #11                     /* Shift and */
700a21b0: e1a005a0     	lsr	r0, r0, #11
;     AND     r0, r0, #0x1F                   /*   mask to get N */
700a21b4: e200001f     	and	r0, r0, #31
;     BX      lr
700a21b8: e12fff1e     	bx	lr

700a21bc <CSL_armR5PmuCfgCntr>:
;     PUSH    {lr}
700a21bc: e52de004     	str	lr, [sp, #-0x4]!
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a21c0: ebffffdf     	bl	0x700a2144 <CSL_armR5PmuSelectCntr> @ imm = #-0x84
;     AND     r1, r1, #0xFF
700a21c4: e20110ff     	and	r1, r1, #255
;     MCR     p15, #0, r1, c9, c13, #1        /* Write PMXEVTYPERx Register */
700a21c8: ee091f3d     	mcr	p15, #0x0, r1, c9, c13, #0x1
;     POP     {lr}
700a21cc: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a21d0: e12fff1e     	bx	lr

700a21d4 <CSL_armR5PmuEnableCntrOverflowIntr>:
;     AND     r0, r0, #0x1F                   /* cntrNum must be <= 31 */
700a21d4: e200001f     	and	r0, r0, #31
;     MOV     r2, #1
700a21d8: e3a02001     	mov	r2, #1
;     LSL     r0, r2, r0                      /* r0 is bit-mask corresponding to cntrNum */
700a21dc: e1a00012     	lsl	r0, r2, r0
;     CMP     r1, #0
700a21e0: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuEnableCntrOverflowIntr_clear
700a21e4: 0a000001     	beq	0x700a21f0 <armR5PmuEnableCntrOverflowIntr_clear> @ imm = #0x4
;     MCR     p15, #0, r0, c9, c14, #1        /* Write PMINTENSET Register (writes of 0 have no effect) */
700a21e8: ee090f3e     	mcr	p15, #0x0, r0, c9, c14, #0x1
;     B       armR5PmuEnableCntrOverflowIntr_00
700a21ec: ea000000     	b	0x700a21f4 <armR5PmuEnableCntrOverflowIntr_00> @ imm = #0x0

700a21f0 <armR5PmuEnableCntrOverflowIntr_clear>:
;     MCR     p15, #0, r0, c9, c14, #2        /* Write PMINTENCLR Register (writes of 0 have no effect) */
700a21f0: ee090f5e     	mcr	p15, #0x0, r0, c9, c14, #0x2

700a21f4 <armR5PmuEnableCntrOverflowIntr_00>:
;     BX      lr
700a21f4: e12fff1e     	bx	lr

700a21f8 <CSL_armR5PmuEnableCntr>:
;     AND     r0, r0, #0x1F                   /* cntrNum must be <= 31 */
700a21f8: e200001f     	and	r0, r0, #31
;     MOV     r2, #1
700a21fc: e3a02001     	mov	r2, #1
;     LSL     r0, r2, r0                      /* r0 is bit-mask corresponding to cntrNum */
700a2200: e1a00012     	lsl	r0, r2, r0
;     CMP     r1, #0
700a2204: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuEnableCntrs_clear
700a2208: 0a000001     	beq	0x700a2214 <armR5PmuEnableCntrs_clear> @ imm = #0x4
;     MCR     p15, #0, r0, c9, c12, #1        /* Write PMCNTENSET Register (writes of 0 have no effect) */
700a220c: ee090f3c     	mcr	p15, #0x0, r0, c9, c12, #0x1
;     B       armR5PmuEnableCntrs_00
700a2210: ea000000     	b	0x700a2218 <armR5PmuEnableCntrs_00> @ imm = #0x0

700a2214 <armR5PmuEnableCntrs_clear>:
;     MCR     p15, #0, r0, c9, c12, #2        /* Write PMCNTENCLR Register (writes of 0 have no effect) */
700a2214: ee090f5c     	mcr	p15, #0x0, r0, c9, c12, #0x2

700a2218 <armR5PmuEnableCntrs_00>:
;     BX      lr
700a2218: e12fff1e     	bx	lr

700a221c <CSL_armR5PmuReadCntr>:
;     PUSH    {lr}
700a221c: e52de004     	str	lr, [sp, #-0x4]!
;     CMP     r0, #CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM
700a2220: e350001f     	cmp	r0, #31
;     BEQ     armR5PmuReadCntr_cycles
700a2224: 0a000002     	beq	0x700a2234 <armR5PmuReadCntr_cycles> @ imm = #0x8
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a2228: ebffffc5     	bl	0x700a2144 <CSL_armR5PmuSelectCntr> @ imm = #-0xec
;     MRC     p15, #0, r0, c9, c13, #2        /* Read current PMNx Register */
700a222c: ee190f5d     	mrc	p15, #0x0, r0, c9, c13, #0x2
;     B       armR5PmuReadCntr_00
700a2230: ea000000     	b	0x700a2238 <armR5PmuReadCntr_00> @ imm = #0x0

700a2234 <armR5PmuReadCntr_cycles>:
;     MRC     p15, #0, r0, c9, c13, #0        /* Read PMCCNTR Register */
700a2234: ee190f1d     	mrc	p15, #0x0, r0, c9, c13, #0x0

700a2238 <armR5PmuReadCntr_00>:
;     POP     {lr}
700a2238: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a223c: e12fff1e     	bx	lr

700a2240 <CSL_armR5PmuSetCntr>:
;     PUSH    {lr}
700a2240: e52de004     	str	lr, [sp, #-0x4]!
;     CMP     r0, #CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM
700a2244: e350001f     	cmp	r0, #31
;     BEQ     armR5PmuSetCntr_cycles
700a2248: 0a000002     	beq	0x700a2258 <armR5PmuSetCntr_cycles> @ imm = #0x8
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a224c: ebffffbc     	bl	0x700a2144 <CSL_armR5PmuSelectCntr> @ imm = #-0x110
;     MCR     p15, #0, r1, c9, c13, #2        /* Write current PMNx Register */
700a2250: ee091f5d     	mcr	p15, #0x0, r1, c9, c13, #0x2
;     B       armR5PmuSetCntr_00
700a2254: ea000000     	b	0x700a225c <armR5PmuSetCntr_00> @ imm = #0x0

700a2258 <armR5PmuSetCntr_cycles>:
;     MCR     p15, #0, r1, c9, c13, #0        /* Write PMCCNTR Register */
700a2258: ee091f1d     	mcr	p15, #0x0, r1, c9, c13, #0x0

700a225c <armR5PmuSetCntr_00>:
;     POP     {lr}
700a225c: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a2260: e12fff1e     	bx	lr

700a2264 <CSL_armR5PmuReadCntrOverflowStatus>:
;     MRC     p15, #0, r0, c9, c12, #3        /* Read PMOVSR Register */
700a2264: ee190f7c     	mrc	p15, #0x0, r0, c9, c12, #0x3
;     BX      lr
700a2268: e12fff1e     	bx	lr

700a226c <CSL_armR5PmuClearCntrOverflowStatus>:
;     MCR     p15, #0, r0, c9, c12, #3        /* Write PMOVSR Register */
700a226c: ee090f7c     	mcr	p15, #0x0, r0, c9, c12, #0x3
;     BX      lr
700a2270: e12fff1e     	bx	lr

700a2274 <CSL_armR5PmuResetCycleCnt>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR */
700a2274: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     ORR     r0, r0, #(1<<2)                 /* Set C bit to reset the cycle counter, PMCCNTR, to zero */
700a2278: e3800004     	orr	r0, r0, #4
;     MCR     p15, #0, r0, c9, c12, #0        /* Write modified PMCR*/
700a227c: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;     BX      lr
700a2280: e12fff1e     	bx	lr

700a2284 <CSL_armR5PmuResetCntrs>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR */
700a2284: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     ORR     r0, r0, #(1<<1)                 /* Set P bit to reset all event counters to zero */
700a2288: e3800002     	orr	r0, r0, #2
;     MCR     p15, #0, r0, c9, c12, #0        /* Write modified PMCR */
700a228c: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;     BX      lr
700a2290: e12fff1e     	bx	lr
		...

700a22a0 <xTaskResumeAll>:
; BaseType_t xTaskResumeAll(void) {
700a22a0: b580         	push	{r7, lr}
700a22a2: b084         	sub	sp, #0x10
700a22a4: 2000         	movs	r0, #0x0
;   TCB_t *pxTCB = NULL;
700a22a6: 9003         	str	r0, [sp, #0xc]
;   BaseType_t xAlreadyYielded = pdFALSE;
700a22a8: 9002         	str	r0, [sp, #0x8]
;   taskENTER_CRITICAL();
700a22aa: f00c fa69    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0xc4d2
;     --uxSchedulerSuspended;
700a22ae: f642 2034    	movw	r0, #0x2a34
700a22b2: f2c7 000b    	movt	r0, #0x700b
700a22b6: 6801         	ldr	r1, [r0]
700a22b8: 3901         	subs	r1, #0x1
700a22ba: 6001         	str	r1, [r0]
;     if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a22bc: 6800         	ldr	r0, [r0]
700a22be: 2800         	cmp	r0, #0x0
700a22c0: f040 808f    	bne.w	0x700a23e2 <xTaskResumeAll+0x142> @ imm = #0x11e
700a22c4: e7ff         	b	0x700a22c6 <xTaskResumeAll+0x26> @ imm = #-0x2
;       if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
700a22c6: f642 202c    	movw	r0, #0x2a2c
700a22ca: f2c7 000b    	movt	r0, #0x700b
700a22ce: 6800         	ldr	r0, [r0]
700a22d0: 2800         	cmp	r0, #0x0
700a22d2: f000 8085    	beq.w	0x700a23e0 <xTaskResumeAll+0x140> @ imm = #0x10a
700a22d6: e7ff         	b	0x700a22d8 <xTaskResumeAll+0x38> @ imm = #-0x2
;         while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
700a22d8: e7ff         	b	0x700a22da <xTaskResumeAll+0x3a> @ imm = #-0x2
700a22da: f245 2060    	movw	r0, #0x5260
700a22de: f2c7 0008    	movt	r0, #0x7008
700a22e2: 6800         	ldr	r0, [r0]
700a22e4: 2800         	cmp	r0, #0x0
700a22e6: d042         	beq	0x700a236e <xTaskResumeAll+0xce> @ imm = #0x84
700a22e8: e7ff         	b	0x700a22ea <xTaskResumeAll+0x4a> @ imm = #-0x2
;           pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a22ea: f245 2060    	movw	r0, #0x5260
700a22ee: f2c7 0008    	movt	r0, #0x7008
700a22f2: 68c0         	ldr	r0, [r0, #0xc]
700a22f4: 68c0         	ldr	r0, [r0, #0xc]
700a22f6: 9003         	str	r0, [sp, #0xc]
;           (void)uxListRemove(&(pxTCB->xEventListItem));
700a22f8: 9803         	ldr	r0, [sp, #0xc]
700a22fa: 3018         	adds	r0, #0x18
700a22fc: f00b fa10    	bl	0x700ad720 <uxListRemove> @ imm = #0xb420
;           (void)uxListRemove(&(pxTCB->xStateListItem));
700a2300: 9803         	ldr	r0, [sp, #0xc]
700a2302: 3004         	adds	r0, #0x4
700a2304: f00b fa0c    	bl	0x700ad720 <uxListRemove> @ imm = #0xb418
;           prvAddTaskToReadyList(pxTCB);
700a2308: 9803         	ldr	r0, [sp, #0xc]
700a230a: 6ac0         	ldr	r0, [r0, #0x2c]
700a230c: f642 213c    	movw	r1, #0x2a3c
700a2310: f2c7 010b    	movt	r1, #0x700b
700a2314: 6809         	ldr	r1, [r1]
700a2316: 4288         	cmp	r0, r1
700a2318: d908         	bls	0x700a232c <xTaskResumeAll+0x8c> @ imm = #0x10
700a231a: e7ff         	b	0x700a231c <xTaskResumeAll+0x7c> @ imm = #-0x2
700a231c: 9803         	ldr	r0, [sp, #0xc]
700a231e: 6ac0         	ldr	r0, [r0, #0x2c]
700a2320: f642 213c    	movw	r1, #0x2a3c
700a2324: f2c7 010b    	movt	r1, #0x700b
700a2328: 6008         	str	r0, [r1]
700a232a: e7ff         	b	0x700a232c <xTaskResumeAll+0x8c> @ imm = #-0x2
700a232c: 9903         	ldr	r1, [sp, #0xc]
700a232e: 6ac8         	ldr	r0, [r1, #0x2c]
700a2330: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a2334: f244 40f8    	movw	r0, #0x44f8
700a2338: f2c7 0008    	movt	r0, #0x7008
700a233c: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a2340: 3104         	adds	r1, #0x4
700a2342: f00b ffa5    	bl	0x700ae290 <vListInsertEnd> @ imm = #0xbf4a
;           if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a2346: 9803         	ldr	r0, [sp, #0xc]
700a2348: 6ac0         	ldr	r0, [r0, #0x2c]
700a234a: f642 210c    	movw	r1, #0x2a0c
700a234e: f2c7 010b    	movt	r1, #0x700b
700a2352: 6809         	ldr	r1, [r1]
700a2354: 6ac9         	ldr	r1, [r1, #0x2c]
700a2356: 4288         	cmp	r0, r1
700a2358: d307         	blo	0x700a236a <xTaskResumeAll+0xca> @ imm = #0xe
700a235a: e7ff         	b	0x700a235c <xTaskResumeAll+0xbc> @ imm = #-0x2
;             xYieldPending = pdTRUE;
700a235c: f642 2160    	movw	r1, #0x2a60
700a2360: f2c7 010b    	movt	r1, #0x700b
700a2364: 2001         	movs	r0, #0x1
700a2366: 6008         	str	r0, [r1]
;           } else {
700a2368: e000         	b	0x700a236c <xTaskResumeAll+0xcc> @ imm = #0x0
700a236a: e7ff         	b	0x700a236c <xTaskResumeAll+0xcc> @ imm = #-0x2
;         while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
700a236c: e7b5         	b	0x700a22da <xTaskResumeAll+0x3a> @ imm = #-0x96
;         if (pxTCB != NULL) {
700a236e: 9803         	ldr	r0, [sp, #0xc]
700a2370: b118         	cbz	r0, 0x700a237a <xTaskResumeAll+0xda> @ imm = #0x6
700a2372: e7ff         	b	0x700a2374 <xTaskResumeAll+0xd4> @ imm = #-0x2
;           prvResetNextTaskUnblockTime();
700a2374: f00b ff0c    	bl	0x700ae190 <prvResetNextTaskUnblockTime> @ imm = #0xbe18
;         }
700a2378: e7ff         	b	0x700a237a <xTaskResumeAll+0xda> @ imm = #-0x2
;           TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
700a237a: f642 204c    	movw	r0, #0x2a4c
700a237e: f2c7 000b    	movt	r0, #0x700b
700a2382: 6800         	ldr	r0, [r0]
700a2384: 9001         	str	r0, [sp, #0x4]
;           if (xPendedCounts > (TickType_t)0U) {
700a2386: 9801         	ldr	r0, [sp, #0x4]
700a2388: b1e0         	cbz	r0, 0x700a23c4 <xTaskResumeAll+0x124> @ imm = #0x38
700a238a: e7ff         	b	0x700a238c <xTaskResumeAll+0xec> @ imm = #-0x2
;             do {
700a238c: e7ff         	b	0x700a238e <xTaskResumeAll+0xee> @ imm = #-0x2
;               if (xTaskIncrementTick() != pdFALSE) {
700a238e: f7ff f937    	bl	0x700a1600 <xTaskIncrementTick> @ imm = #-0xd92
700a2392: b138         	cbz	r0, 0x700a23a4 <xTaskResumeAll+0x104> @ imm = #0xe
700a2394: e7ff         	b	0x700a2396 <xTaskResumeAll+0xf6> @ imm = #-0x2
;                 xYieldPending = pdTRUE;
700a2396: f642 2160    	movw	r1, #0x2a60
700a239a: f2c7 010b    	movt	r1, #0x700b
700a239e: 2001         	movs	r0, #0x1
700a23a0: 6008         	str	r0, [r1]
;               } else {
700a23a2: e000         	b	0x700a23a6 <xTaskResumeAll+0x106> @ imm = #0x0
700a23a4: e7ff         	b	0x700a23a6 <xTaskResumeAll+0x106> @ imm = #-0x2
;               --xPendedCounts;
700a23a6: 9801         	ldr	r0, [sp, #0x4]
700a23a8: 3801         	subs	r0, #0x1
700a23aa: 9001         	str	r0, [sp, #0x4]
;             } while (xPendedCounts > (TickType_t)0U);
700a23ac: e7ff         	b	0x700a23ae <xTaskResumeAll+0x10e> @ imm = #-0x2
700a23ae: 9801         	ldr	r0, [sp, #0x4]
700a23b0: 2800         	cmp	r0, #0x0
700a23b2: d1ec         	bne	0x700a238e <xTaskResumeAll+0xee> @ imm = #-0x28
700a23b4: e7ff         	b	0x700a23b6 <xTaskResumeAll+0x116> @ imm = #-0x2
;             xPendedTicks = 0;
700a23b6: f642 214c    	movw	r1, #0x2a4c
700a23ba: f2c7 010b    	movt	r1, #0x700b
700a23be: 2000         	movs	r0, #0x0
700a23c0: 6008         	str	r0, [r1]
;           } else {
700a23c2: e000         	b	0x700a23c6 <xTaskResumeAll+0x126> @ imm = #0x0
700a23c4: e7ff         	b	0x700a23c6 <xTaskResumeAll+0x126> @ imm = #-0x2
;         if (xYieldPending != pdFALSE) {
700a23c6: f642 2060    	movw	r0, #0x2a60
700a23ca: f2c7 000b    	movt	r0, #0x700b
700a23ce: 6800         	ldr	r0, [r0]
700a23d0: b120         	cbz	r0, 0x700a23dc <xTaskResumeAll+0x13c> @ imm = #0x8
700a23d2: e7ff         	b	0x700a23d4 <xTaskResumeAll+0x134> @ imm = #-0x2
700a23d4: 2001         	movs	r0, #0x1
;             xAlreadyYielded = pdTRUE;
700a23d6: 9002         	str	r0, [sp, #0x8]
;           taskYIELD_IF_USING_PREEMPTION();
700a23d8: df00         	svc	#0x0
;         } else {
700a23da: e000         	b	0x700a23de <xTaskResumeAll+0x13e> @ imm = #0x0
700a23dc: e7ff         	b	0x700a23de <xTaskResumeAll+0x13e> @ imm = #-0x2
;       }
700a23de: e7ff         	b	0x700a23e0 <xTaskResumeAll+0x140> @ imm = #-0x2
;     } else {
700a23e0: e000         	b	0x700a23e4 <xTaskResumeAll+0x144> @ imm = #0x0
700a23e2: e7ff         	b	0x700a23e4 <xTaskResumeAll+0x144> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a23e4: f00b fa8c    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xb518
;   return xAlreadyYielded;
700a23e8: 9802         	ldr	r0, [sp, #0x8]
700a23ea: b004         	add	sp, #0x10
700a23ec: bd80         	pop	{r7, pc}
700a23ee: 0000         	movs	r0, r0

700a23f0 <Udma_chAssignRegOverlay>:
; {
700a23f0: b082         	sub	sp, #0x8
700a23f2: 9001         	str	r0, [sp, #0x4]
700a23f4: 9100         	str	r1, [sp]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a23f6: 9801         	ldr	r0, [sp, #0x4]
700a23f8: 6800         	ldr	r0, [r0]
700a23fa: 2801         	cmp	r0, #0x1
700a23fc: d147         	bne	0x700a248e <Udma_chAssignRegOverlay+0x9e> @ imm = #0x8e
700a23fe: e7ff         	b	0x700a2400 <Udma_chAssignRegOverlay+0x10> @ imm = #-0x2
;         if(chHandle->txChNum != UDMA_DMA_CH_INVALID)
700a2400: 9800         	ldr	r0, [sp]
700a2402: 6ec0         	ldr	r0, [r0, #0x6c]
700a2404: f510 3f80    	cmn.w	r0, #0x10000
700a2408: d029         	beq	0x700a245e <Udma_chAssignRegOverlay+0x6e> @ imm = #0x52
700a240a: e7ff         	b	0x700a240c <Udma_chAssignRegOverlay+0x1c> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a240c: 9800         	ldr	r0, [sp]
700a240e: 7800         	ldrb	r0, [r0]
700a2410: 0740         	lsls	r0, r0, #0x1d
700a2412: 2800         	cmp	r0, #0x0
700a2414: d511         	bpl	0x700a243a <Udma_chAssignRegOverlay+0x4a> @ imm = #0x22
700a2416: e7ff         	b	0x700a2418 <Udma_chAssignRegOverlay+0x28> @ imm = #-0x2
;                     &drvHandle->bcdmaRegs.pBcChanCfgRegs->CHAN[chHandle->txChNum];
700a2418: 9801         	ldr	r0, [sp, #0x4]
700a241a: 68c0         	ldr	r0, [r0, #0xc]
700a241c: 9900         	ldr	r1, [sp]
700a241e: 6eca         	ldr	r2, [r1, #0x6c]
700a2420: eb00 2002    	add.w	r0, r0, r2, lsl #8
;                 chHandle->pBcdmaBcCfgRegs =
700a2424: f8c1 0214    	str.w	r0, [r1, #0x214]
;                     &drvHandle->bcdmaRegs.pBcChanRtRegs->CHAN[chHandle->txChNum];
700a2428: 9801         	ldr	r0, [sp, #0x4]
700a242a: 6900         	ldr	r0, [r0, #0x10]
700a242c: 9900         	ldr	r1, [sp]
700a242e: 6eca         	ldr	r2, [r1, #0x6c]
700a2430: eb00 3002    	add.w	r0, r0, r2, lsl #12
;                 chHandle->pBcdmaBcRtRegs  =
700a2434: f8c1 0218    	str.w	r0, [r1, #0x218]
;             }
700a2438: e010         	b	0x700a245c <Udma_chAssignRegOverlay+0x6c> @ imm = #0x20
;                     &drvHandle->bcdmaRegs.pTxChanCfgRegs->CHAN[chHandle->txChNum];
700a243a: 9801         	ldr	r0, [sp, #0x4]
700a243c: 6940         	ldr	r0, [r0, #0x14]
700a243e: 9900         	ldr	r1, [sp]
700a2440: 6eca         	ldr	r2, [r1, #0x6c]
700a2442: eb00 2002    	add.w	r0, r0, r2, lsl #8
;                 chHandle->pBcdmaTxCfgRegs =
700a2446: f8c1 021c    	str.w	r0, [r1, #0x21c]
;                     &drvHandle->bcdmaRegs.pTxChanRtRegs->CHAN[chHandle->txChNum];
700a244a: 9801         	ldr	r0, [sp, #0x4]
700a244c: 6980         	ldr	r0, [r0, #0x18]
700a244e: 9900         	ldr	r1, [sp]
700a2450: 6eca         	ldr	r2, [r1, #0x6c]
700a2452: eb00 3002    	add.w	r0, r0, r2, lsl #12
;                 chHandle->pBcdmaTxRtRegs  =
700a2456: f8c1 0220    	str.w	r0, [r1, #0x220]
700a245a: e7ff         	b	0x700a245c <Udma_chAssignRegOverlay+0x6c> @ imm = #-0x2
;         }
700a245c: e7ff         	b	0x700a245e <Udma_chAssignRegOverlay+0x6e> @ imm = #-0x2
;         if(chHandle->rxChNum != UDMA_DMA_CH_INVALID)
700a245e: 9800         	ldr	r0, [sp]
700a2460: 6f00         	ldr	r0, [r0, #0x70]
700a2462: f510 3f80    	cmn.w	r0, #0x10000
700a2466: d011         	beq	0x700a248c <Udma_chAssignRegOverlay+0x9c> @ imm = #0x22
700a2468: e7ff         	b	0x700a246a <Udma_chAssignRegOverlay+0x7a> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs.pRxChanCfgRegs->CHAN[chHandle->rxChNum];
700a246a: 9801         	ldr	r0, [sp, #0x4]
700a246c: 69c0         	ldr	r0, [r0, #0x1c]
700a246e: 9900         	ldr	r1, [sp]
700a2470: 6f0a         	ldr	r2, [r1, #0x70]
700a2472: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pBcdmaRxCfgRegs =
700a2476: f8c1 0224    	str.w	r0, [r1, #0x224]
;                 &drvHandle->bcdmaRegs.pRxChanRtRegs->CHAN[chHandle->rxChNum];
700a247a: 9801         	ldr	r0, [sp, #0x4]
700a247c: 6a00         	ldr	r0, [r0, #0x20]
700a247e: 9900         	ldr	r1, [sp]
700a2480: 6f0a         	ldr	r2, [r1, #0x70]
700a2482: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pBcdmaRxRtRegs  =
700a2486: f8c1 0228    	str.w	r0, [r1, #0x228]
;         }
700a248a: e7ff         	b	0x700a248c <Udma_chAssignRegOverlay+0x9c> @ imm = #-0x2
;     }
700a248c: e051         	b	0x700a2532 <Udma_chAssignRegOverlay+0x142> @ imm = #0xa2
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a248e: 9801         	ldr	r0, [sp, #0x4]
700a2490: 6800         	ldr	r0, [r0]
700a2492: 2802         	cmp	r0, #0x2
700a2494: d14c         	bne	0x700a2530 <Udma_chAssignRegOverlay+0x140> @ imm = #0x98
700a2496: e7ff         	b	0x700a2498 <Udma_chAssignRegOverlay+0xa8> @ imm = #-0x2
;         if(chHandle->txChNum != UDMA_DMA_CH_INVALID)
700a2498: 9800         	ldr	r0, [sp]
700a249a: 6ec0         	ldr	r0, [r0, #0x6c]
700a249c: f510 3f80    	cmn.w	r0, #0x10000
700a24a0: d011         	beq	0x700a24c6 <Udma_chAssignRegOverlay+0xd6> @ imm = #0x22
700a24a2: e7ff         	b	0x700a24a4 <Udma_chAssignRegOverlay+0xb4> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[chHandle->txChNum];
700a24a4: 9801         	ldr	r0, [sp, #0x4]
700a24a6: 6dc0         	ldr	r0, [r0, #0x5c]
700a24a8: 9900         	ldr	r1, [sp]
700a24aa: 6eca         	ldr	r2, [r1, #0x6c]
700a24ac: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaTxCfgRegs =
700a24b0: f8c1 022c    	str.w	r0, [r1, #0x22c]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[chHandle->txChNum];
700a24b4: 9801         	ldr	r0, [sp, #0x4]
700a24b6: 6e40         	ldr	r0, [r0, #0x64]
700a24b8: 9900         	ldr	r1, [sp]
700a24ba: 6eca         	ldr	r2, [r1, #0x6c]
700a24bc: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaTxRtRegs  =
700a24c0: f8c1 0230    	str.w	r0, [r1, #0x230]
;         }
700a24c4: e7ff         	b	0x700a24c6 <Udma_chAssignRegOverlay+0xd6> @ imm = #-0x2
;         if(chHandle->rxChNum != UDMA_DMA_CH_INVALID)
700a24c6: 9800         	ldr	r0, [sp]
700a24c8: 6f00         	ldr	r0, [r0, #0x70]
700a24ca: f510 3f80    	cmn.w	r0, #0x10000
700a24ce: d011         	beq	0x700a24f4 <Udma_chAssignRegOverlay+0x104> @ imm = #0x22
700a24d0: e7ff         	b	0x700a24d2 <Udma_chAssignRegOverlay+0xe2> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pRxChanCfgRegs->CHAN[chHandle->rxChNum];
700a24d2: 9801         	ldr	r0, [sp, #0x4]
700a24d4: 6e00         	ldr	r0, [r0, #0x60]
700a24d6: 9900         	ldr	r1, [sp]
700a24d8: 6f0a         	ldr	r2, [r1, #0x70]
700a24da: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaRxCfgRegs =
700a24de: f8c1 0234    	str.w	r0, [r1, #0x234]
;                 &drvHandle->pktdmaRegs.pRxChanRtRegs->CHAN[chHandle->rxChNum];
700a24e2: 9801         	ldr	r0, [sp, #0x4]
700a24e4: 6e80         	ldr	r0, [r0, #0x68]
700a24e6: 9900         	ldr	r1, [sp]
700a24e8: 6f0a         	ldr	r2, [r1, #0x70]
700a24ea: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaRxRtRegs  =
700a24ee: f8c1 0238    	str.w	r0, [r1, #0x238]
;         }
700a24f2: e7ff         	b	0x700a24f4 <Udma_chAssignRegOverlay+0x104> @ imm = #-0x2
;         if(chHandle->extChNum != UDMA_DMA_CH_INVALID)
700a24f4: 9800         	ldr	r0, [sp]
700a24f6: 6f40         	ldr	r0, [r0, #0x74]
700a24f8: f510 3f80    	cmn.w	r0, #0x10000
700a24fc: d017         	beq	0x700a252e <Udma_chAssignRegOverlay+0x13e> @ imm = #0x2e
700a24fe: e7ff         	b	0x700a2500 <Udma_chAssignRegOverlay+0x110> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a2500: 9b01         	ldr	r3, [sp, #0x4]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a2502: 9900         	ldr	r1, [sp]
700a2504: 6f4a         	ldr	r2, [r1, #0x74]
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a2506: 6dd8         	ldr	r0, [r3, #0x5c]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a2508: f8d3 3110    	ldr.w	r3, [r3, #0x110]
700a250c: 441a         	add	r2, r3
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a250e: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaExtCfgRegs =
700a2512: f8c1 023c    	str.w	r0, [r1, #0x23c]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a2516: 9b01         	ldr	r3, [sp, #0x4]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a2518: 9900         	ldr	r1, [sp]
700a251a: 6f4a         	ldr	r2, [r1, #0x74]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a251c: 6e58         	ldr	r0, [r3, #0x64]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a251e: f8d3 3110    	ldr.w	r3, [r3, #0x110]
700a2522: 441a         	add	r2, r3
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a2524: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaExtRtRegs  =
700a2528: f8c1 0240    	str.w	r0, [r1, #0x240]
;         }
700a252c: e7ff         	b	0x700a252e <Udma_chAssignRegOverlay+0x13e> @ imm = #-0x2
;     }
700a252e: e7ff         	b	0x700a2530 <Udma_chAssignRegOverlay+0x140> @ imm = #-0x2
700a2530: e7ff         	b	0x700a2532 <Udma_chAssignRegOverlay+0x142> @ imm = #-0x2
; }
700a2532: b002         	add	sp, #0x8
700a2534: 4770         	bx	lr
		...
700a253e: 0000         	movs	r0, r0

700a2540 <DebugP_memLogWriterPutChar>:
; {
700a2540: b580         	push	{r7, lr}
700a2542: b088         	sub	sp, #0x20
700a2544: f88d 001f    	strb.w	r0, [sp, #0x1f]
;     if(lineBufIndex==0U)
700a2548: f642 00cc    	movw	r0, #0x28cc
700a254c: f2c7 000b    	movt	r0, #0x700b
700a2550: 6800         	ldr	r0, [r0]
700a2552: bb40         	cbnz	r0, 0x700a25a6 <DebugP_memLogWriterPutChar+0x66> @ imm = #0x50
700a2554: e7ff         	b	0x700a2556 <DebugP_memLogWriterPutChar+0x16> @ imm = #-0x2
;         uint64_t curTime = ClockP_getTimeUsec();
700a2556: f008 fb1b    	bl	0x700aab90 <ClockP_getTimeUsec> @ imm = #0x8636
700a255a: 9105         	str	r1, [sp, #0x14]
700a255c: 9004         	str	r0, [sp, #0x10]
;                             gDebugP_memTraceLogWriterSelfCoreName,
700a255e: f642 10f0    	movw	r0, #0x29f0
700a2562: f2c7 000b    	movt	r0, #0x700b
700a2566: 6800         	ldr	r0, [r0]
;                             (uint32_t)(curTime/TIME_IN_MICRO_SECONDS),
700a2568: 9003         	str	r0, [sp, #0xc]
700a256a: 9804         	ldr	r0, [sp, #0x10]
700a256c: 9905         	ldr	r1, [sp, #0x14]
700a256e: f244 2240    	movw	r2, #0x4240
700a2572: f2c0 020f    	movt	r2, #0xf
700a2576: 2300         	movs	r3, #0x0
;                             (uint32_t)(curTime%TIME_IN_MICRO_SECONDS)
700a2578: f00c ee34    	blx	0x700af1e4 <__aeabi_uldivmod> @ imm = #0xcc68
700a257c: 9b03         	ldr	r3, [sp, #0xc]
;         lineBufIndex = (uint32_t)snprintf_((char*)lineBuf, DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE, "[%6s] %5d.%06ds : ",
700a257e: 4669         	mov	r1, sp
700a2580: 604a         	str	r2, [r1, #0x4]
700a2582: 6008         	str	r0, [r1]
700a2584: f245 00c0    	movw	r0, #0x50c0
700a2588: f2c7 0008    	movt	r0, #0x7008
700a258c: f641 72a8    	movw	r2, #0x1fa8
700a2590: f2c7 020b    	movt	r2, #0x700b
700a2594: 2178         	movs	r1, #0x78
700a2596: f00b fe5b    	bl	0x700ae250 <snprintf_>  @ imm = #0xbcb6
700a259a: f642 01cc    	movw	r1, #0x28cc
700a259e: f2c7 010b    	movt	r1, #0x700b
700a25a2: 6008         	str	r0, [r1]
;     }
700a25a4: e7ff         	b	0x700a25a6 <DebugP_memLogWriterPutChar+0x66> @ imm = #-0x2
;     lineBuf[lineBufIndex]=(uint8_t)character;
700a25a6: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700a25aa: f642 01cc    	movw	r1, #0x28cc
700a25ae: f2c7 010b    	movt	r1, #0x700b
700a25b2: 680b         	ldr	r3, [r1]
700a25b4: f245 02c0    	movw	r2, #0x50c0
700a25b8: f2c7 0208    	movt	r2, #0x7008
700a25bc: 54d0         	strb	r0, [r2, r3]
; 	lineBufIndex = lineBufIndex + 1U;
700a25be: 6808         	ldr	r0, [r1]
700a25c0: 3001         	adds	r0, #0x1
700a25c2: 6008         	str	r0, [r1]
;     if( (character == '\n') ||
700a25c4: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700a25c8: 280a         	cmp	r0, #0xa
700a25ca: d008         	beq	0x700a25de <DebugP_memLogWriterPutChar+0x9e> @ imm = #0x10
700a25cc: e7ff         	b	0x700a25ce <DebugP_memLogWriterPutChar+0x8e> @ imm = #-0x2
;         (lineBufIndex >= (DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE)))
700a25ce: f642 00cc    	movw	r0, #0x28cc
700a25d2: f2c7 000b    	movt	r0, #0x700b
700a25d6: 6800         	ldr	r0, [r0]
;     if( (character == '\n') ||
700a25d8: 2878         	cmp	r0, #0x78
700a25da: d350         	blo	0x700a267e <DebugP_memLogWriterPutChar+0x13e> @ imm = #0xa0
700a25dc: e7ff         	b	0x700a25de <DebugP_memLogWriterPutChar+0x9e> @ imm = #-0x2
;         if(lineBufIndex >= (DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE))
700a25de: f642 00cc    	movw	r0, #0x28cc
700a25e2: f2c7 000b    	movt	r0, #0x700b
700a25e6: 6800         	ldr	r0, [r0]
700a25e8: 2878         	cmp	r0, #0x78
700a25ea: d315         	blo	0x700a2618 <DebugP_memLogWriterPutChar+0xd8> @ imm = #0x2a
700a25ec: e7ff         	b	0x700a25ee <DebugP_memLogWriterPutChar+0xae> @ imm = #-0x2
;             lineBuf[lineBufIndex]=(uint8_t)'\r';
700a25ee: f642 01cc    	movw	r1, #0x28cc
700a25f2: f2c7 010b    	movt	r1, #0x700b
700a25f6: 680b         	ldr	r3, [r1]
700a25f8: f245 02c0    	movw	r2, #0x50c0
700a25fc: f2c7 0208    	movt	r2, #0x7008
700a2600: 200d         	movs	r0, #0xd
700a2602: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a2604: 6808         	ldr	r0, [r1]
700a2606: 3001         	adds	r0, #0x1
700a2608: 6008         	str	r0, [r1]
;             lineBuf[lineBufIndex]=(uint8_t)'\n';
700a260a: 680b         	ldr	r3, [r1]
700a260c: 200a         	movs	r0, #0xa
700a260e: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a2610: 6808         	ldr	r0, [r1]
700a2612: 3001         	adds	r0, #0x1
700a2614: 6008         	str	r0, [r1]
;         }
700a2616: e7ff         	b	0x700a2618 <DebugP_memLogWriterPutChar+0xd8> @ imm = #-0x2
;         if(lineBuf[lineBufIndex-UNSIGNED_INTEGERVAL_TWO]!=(uint8_t)'\r')
700a2618: f642 00cc    	movw	r0, #0x28cc
700a261c: f2c7 000b    	movt	r0, #0x700b
700a2620: 6800         	ldr	r0, [r0]
700a2622: f245 01c0    	movw	r1, #0x50c0
700a2626: f2c7 0108    	movt	r1, #0x7008
700a262a: 4408         	add	r0, r1
700a262c: f810 0c02    	ldrb	r0, [r0, #-2]
700a2630: 280d         	cmp	r0, #0xd
700a2632: d014         	beq	0x700a265e <DebugP_memLogWriterPutChar+0x11e> @ imm = #0x28
700a2634: e7ff         	b	0x700a2636 <DebugP_memLogWriterPutChar+0xf6> @ imm = #-0x2
;             lineBuf[lineBufIndex-1U]=(uint8_t)'\r';
700a2636: f642 01cc    	movw	r1, #0x28cc
700a263a: f2c7 010b    	movt	r1, #0x700b
700a263e: 6808         	ldr	r0, [r1]
700a2640: f245 02c0    	movw	r2, #0x50c0
700a2644: f2c7 0208    	movt	r2, #0x7008
700a2648: 1883         	adds	r3, r0, r2
700a264a: 200d         	movs	r0, #0xd
700a264c: f803 0c01    	strb	r0, [r3, #-1]
;             lineBuf[lineBufIndex]=(uint8_t)'\n';
700a2650: 680b         	ldr	r3, [r1]
700a2652: 200a         	movs	r0, #0xa
700a2654: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a2656: 6808         	ldr	r0, [r1]
700a2658: 3001         	adds	r0, #0x1
700a265a: 6008         	str	r0, [r1]
;         }
700a265c: e7ff         	b	0x700a265e <DebugP_memLogWriterPutChar+0x11e> @ imm = #-0x2
;         DebugP_memTraceLogWriterPutLine(lineBuf, (uint16_t)lineBufIndex);
700a265e: f642 00cc    	movw	r0, #0x28cc
700a2662: f2c7 000b    	movt	r0, #0x700b
700a2666: 9002         	str	r0, [sp, #0x8]
700a2668: 8801         	ldrh	r1, [r0]
700a266a: f245 00c0    	movw	r0, #0x50c0
700a266e: f2c7 0008    	movt	r0, #0x7008
700a2672: f003 fbc5    	bl	0x700a5e00 <DebugP_memTraceLogWriterPutLine> @ imm = #0x378a
700a2676: 9902         	ldr	r1, [sp, #0x8]
700a2678: 2000         	movs	r0, #0x0
;         lineBufIndex = 0;
700a267a: 6008         	str	r0, [r1]
;     }
700a267c: e7ff         	b	0x700a267e <DebugP_memLogWriterPutChar+0x13e> @ imm = #-0x2
; }
700a267e: b008         	add	sp, #0x20
700a2680: bd80         	pop	{r7, pc}
		...
700a268e: 0000         	movs	r0, r0

700a2690 <Sciclient_sendMessage>:
; {
700a2690: b580         	push	{r7, lr}
700a2692: b08a         	sub	sp, #0x28
700a2694: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a2698: 9009         	str	r0, [sp, #0x24]
700a269a: 9108         	str	r1, [sp, #0x20]
700a269c: 9207         	str	r2, [sp, #0x1c]
700a269e: 9306         	str	r3, [sp, #0x18]
700a26a0: 2200         	movs	r2, #0x0
;     uint32_t        i   = 0U;
700a26a2: 9205         	str	r2, [sp, #0x14]
;     const uint8_t *msg = pSecHeader;
700a26a4: 9808         	ldr	r0, [sp, #0x20]
700a26a6: 9004         	str	r0, [sp, #0x10]
;     uint32_t numWords   = 0U;
700a26a8: 9203         	str	r2, [sp, #0xc]
;     uint32_t test = 0U;
700a26aa: 9202         	str	r2, [sp, #0x8]
;     uintptr_t threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U);
700a26ac: 9909         	ldr	r1, [sp, #0x24]
700a26ae: f642 00d0    	movw	r0, #0x28d0
700a26b2: f2c7 000b    	movt	r0, #0x700b
700a26b6: f00c ff5b    	bl	0x700af570 <CSL_secProxyGetDataAddr> @ imm = #0xceb6
700a26ba: 9001         	str	r0, [sp, #0x4]
;     if(pSecHeader != NULL)
700a26bc: 9808         	ldr	r0, [sp, #0x20]
700a26be: b1f8         	cbz	r0, 0x700a2700 <Sciclient_sendMessage+0x70> @ imm = #0x3e
700a26c0: e7ff         	b	0x700a26c2 <Sciclient_sendMessage+0x32> @ imm = #-0x2
700a26c2: 2000         	movs	r0, #0x0
;         for (i = 0U; i < gSecHeaderSizeWords; i++)
700a26c4: 9005         	str	r0, [sp, #0x14]
700a26c6: e7ff         	b	0x700a26c8 <Sciclient_sendMessage+0x38> @ imm = #-0x2
700a26c8: 9805         	ldr	r0, [sp, #0x14]
700a26ca: f642 2164    	movw	r1, #0x2a64
700a26ce: f2c7 010b    	movt	r1, #0x700b
700a26d2: 7809         	ldrb	r1, [r1]
700a26d4: 4288         	cmp	r0, r1
700a26d6: d212         	bhs	0x700a26fe <Sciclient_sendMessage+0x6e> @ imm = #0x24
700a26d8: e7ff         	b	0x700a26da <Sciclient_sendMessage+0x4a> @ imm = #-0x2
;             (void) memcpy((void *)&test, (const void *)msg, 4);
700a26da: 9804         	ldr	r0, [sp, #0x10]
700a26dc: 6800         	ldr	r0, [r0]
700a26de: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(threadAddr, test);
700a26e0: 9801         	ldr	r0, [sp, #0x4]
700a26e2: 9902         	ldr	r1, [sp, #0x8]
700a26e4: f00d fa0c    	bl	0x700afb00 <CSL_REG32_WR_RAW> @ imm = #0xd418
;             msg += 4;
700a26e8: 9804         	ldr	r0, [sp, #0x10]
700a26ea: 3004         	adds	r0, #0x4
700a26ec: 9004         	str	r0, [sp, #0x10]
;             threadAddr+=sizeof(uint32_t);
700a26ee: 9801         	ldr	r0, [sp, #0x4]
700a26f0: 3004         	adds	r0, #0x4
700a26f2: 9001         	str	r0, [sp, #0x4]
;         }
700a26f4: e7ff         	b	0x700a26f6 <Sciclient_sendMessage+0x66> @ imm = #-0x2
;         for (i = 0U; i < gSecHeaderSizeWords; i++)
700a26f6: 9805         	ldr	r0, [sp, #0x14]
700a26f8: 3001         	adds	r0, #0x1
700a26fa: 9005         	str	r0, [sp, #0x14]
700a26fc: e7e4         	b	0x700a26c8 <Sciclient_sendMessage+0x38> @ imm = #-0x38
;     }
700a26fe: e7ff         	b	0x700a2700 <Sciclient_sendMessage+0x70> @ imm = #-0x2
;     msg = pHeader;
700a2700: 9807         	ldr	r0, [sp, #0x1c]
700a2702: 9004         	str	r0, [sp, #0x10]
700a2704: 2000         	movs	r0, #0x0
;     for (i = 0U; i < SCICLIENT_HEADER_SIZE_IN_WORDS; i++)
700a2706: 9005         	str	r0, [sp, #0x14]
700a2708: e7ff         	b	0x700a270a <Sciclient_sendMessage+0x7a> @ imm = #-0x2
700a270a: 9805         	ldr	r0, [sp, #0x14]
700a270c: 2801         	cmp	r0, #0x1
700a270e: d812         	bhi	0x700a2736 <Sciclient_sendMessage+0xa6> @ imm = #0x24
700a2710: e7ff         	b	0x700a2712 <Sciclient_sendMessage+0x82> @ imm = #-0x2
;         (void) memcpy((void *)&test, (const void *)msg, 4);
700a2712: 9804         	ldr	r0, [sp, #0x10]
700a2714: 6800         	ldr	r0, [r0]
700a2716: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(threadAddr, test);
700a2718: 9801         	ldr	r0, [sp, #0x4]
700a271a: 9902         	ldr	r1, [sp, #0x8]
700a271c: f00d f9f0    	bl	0x700afb00 <CSL_REG32_WR_RAW> @ imm = #0xd3e0
;         msg += 4;
700a2720: 9804         	ldr	r0, [sp, #0x10]
700a2722: 3004         	adds	r0, #0x4
700a2724: 9004         	str	r0, [sp, #0x10]
;         threadAddr+=sizeof(uint32_t);
700a2726: 9801         	ldr	r0, [sp, #0x4]
700a2728: 3004         	adds	r0, #0x4
700a272a: 9001         	str	r0, [sp, #0x4]
;     }
700a272c: e7ff         	b	0x700a272e <Sciclient_sendMessage+0x9e> @ imm = #-0x2
;     for (i = 0U; i < SCICLIENT_HEADER_SIZE_IN_WORDS; i++)
700a272e: 9805         	ldr	r0, [sp, #0x14]
700a2730: 3001         	adds	r0, #0x1
700a2732: 9005         	str	r0, [sp, #0x14]
700a2734: e7e9         	b	0x700a270a <Sciclient_sendMessage+0x7a> @ imm = #-0x2e
;     if (payloadSize > 0U)
700a2736: 980c         	ldr	r0, [sp, #0x30]
700a2738: b300         	cbz	r0, 0x700a277c <Sciclient_sendMessage+0xec> @ imm = #0x40
700a273a: e7ff         	b	0x700a273c <Sciclient_sendMessage+0xac> @ imm = #-0x2
;         numWords   = (payloadSize+3U)/4U;
700a273c: 980c         	ldr	r0, [sp, #0x30]
700a273e: 3003         	adds	r0, #0x3
700a2740: 0880         	lsrs	r0, r0, #0x2
700a2742: 9003         	str	r0, [sp, #0xc]
;         msg = pPayload;
700a2744: 9806         	ldr	r0, [sp, #0x18]
700a2746: 9004         	str	r0, [sp, #0x10]
;         for (; i < (SCICLIENT_HEADER_SIZE_IN_WORDS + numWords); i++)
700a2748: e7ff         	b	0x700a274a <Sciclient_sendMessage+0xba> @ imm = #-0x2
700a274a: 9805         	ldr	r0, [sp, #0x14]
700a274c: 9903         	ldr	r1, [sp, #0xc]
700a274e: 3102         	adds	r1, #0x2
700a2750: 4288         	cmp	r0, r1
700a2752: d212         	bhs	0x700a277a <Sciclient_sendMessage+0xea> @ imm = #0x24
700a2754: e7ff         	b	0x700a2756 <Sciclient_sendMessage+0xc6> @ imm = #-0x2
;             (void) memcpy((void *)&test, (const void *)msg, 4);
700a2756: 9804         	ldr	r0, [sp, #0x10]
700a2758: 6800         	ldr	r0, [r0]
700a275a: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(threadAddr, test);
700a275c: 9801         	ldr	r0, [sp, #0x4]
700a275e: 9902         	ldr	r1, [sp, #0x8]
700a2760: f00d f9ce    	bl	0x700afb00 <CSL_REG32_WR_RAW> @ imm = #0xd39c
;             msg += 4;
700a2764: 9804         	ldr	r0, [sp, #0x10]
700a2766: 3004         	adds	r0, #0x4
700a2768: 9004         	str	r0, [sp, #0x10]
;             threadAddr+=sizeof(uint32_t);
700a276a: 9801         	ldr	r0, [sp, #0x4]
700a276c: 3004         	adds	r0, #0x4
700a276e: 9001         	str	r0, [sp, #0x4]
;         }
700a2770: e7ff         	b	0x700a2772 <Sciclient_sendMessage+0xe2> @ imm = #-0x2
;         for (; i < (SCICLIENT_HEADER_SIZE_IN_WORDS + numWords); i++)
700a2772: 9805         	ldr	r0, [sp, #0x14]
700a2774: 3001         	adds	r0, #0x1
700a2776: 9005         	str	r0, [sp, #0x14]
700a2778: e7e7         	b	0x700a274a <Sciclient_sendMessage+0xba> @ imm = #-0x32
;     }
700a277a: e7ff         	b	0x700a277c <Sciclient_sendMessage+0xec> @ imm = #-0x2
;     if ((((uint32_t) gSecHeaderSizeWords*4U)+(SCICLIENT_HEADER_SIZE_IN_WORDS*4U)+payloadSize) <=
700a277c: f642 2064    	movw	r0, #0x2a64
700a2780: f2c7 000b    	movt	r0, #0x700b
700a2784: 7801         	ldrb	r1, [r0]
700a2786: 980c         	ldr	r0, [sp, #0x30]
700a2788: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a278c: 3008         	adds	r0, #0x8
;         (gSciclientHandle.maxMsgSizeBytes - 4U))
700a278e: f642 1158    	movw	r1, #0x2958
700a2792: f2c7 010b    	movt	r1, #0x700b
700a2796: 6949         	ldr	r1, [r1, #0x14]
700a2798: 3904         	subs	r1, #0x4
;     if ((((uint32_t) gSecHeaderSizeWords*4U)+(SCICLIENT_HEADER_SIZE_IN_WORDS*4U)+payloadSize) <=
700a279a: 4288         	cmp	r0, r1
700a279c: d817         	bhi	0x700a27ce <Sciclient_sendMessage+0x13e> @ imm = #0x2e
700a279e: e7ff         	b	0x700a27a0 <Sciclient_sendMessage+0x110> @ imm = #-0x2
;         threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U) +
700a27a0: 9909         	ldr	r1, [sp, #0x24]
700a27a2: f642 00d0    	movw	r0, #0x28d0
700a27a6: f2c7 000b    	movt	r0, #0x700b
700a27aa: 2200         	movs	r2, #0x0
700a27ac: 9200         	str	r2, [sp]
700a27ae: f00c fedf    	bl	0x700af570 <CSL_secProxyGetDataAddr> @ imm = #0xcdbe
700a27b2: 9900         	ldr	r1, [sp]
700a27b4: 4602         	mov	r2, r0
;         ((uintptr_t) gSciclientHandle.maxMsgSizeBytes  - (uintptr_t) 4U) ;
700a27b6: f642 1058    	movw	r0, #0x2958
700a27ba: f2c7 000b    	movt	r0, #0x700b
700a27be: 6940         	ldr	r0, [r0, #0x14]
;         threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U) +
700a27c0: 4410         	add	r0, r2
700a27c2: 3804         	subs	r0, #0x4
700a27c4: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(threadAddr,0U);
700a27c6: 9801         	ldr	r0, [sp, #0x4]
700a27c8: f00d f99a    	bl	0x700afb00 <CSL_REG32_WR_RAW> @ imm = #0xd334
;     }
700a27cc: e7ff         	b	0x700a27ce <Sciclient_sendMessage+0x13e> @ imm = #-0x2
; }
700a27ce: b00a         	add	sp, #0x28
700a27d0: bd80         	pop	{r7, pc}
		...
700a27de: 0000         	movs	r0, r0

700a27e0 <Sciclient_rmIaValidateMapping>:
; {
700a27e0: b580         	push	{r7, lr}
700a27e2: b088         	sub	sp, #0x20
700a27e4: 4684         	mov	r12, r0
700a27e6: 980a         	ldr	r0, [sp, #0x28]
700a27e8: f88d c01f    	strb.w	r12, [sp, #0x1f]
700a27ec: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a27f0: f8ad 201a    	strh.w	r2, [sp, #0x1a]
700a27f4: f8ad 3018    	strh.w	r3, [sp, #0x18]
700a27f8: f88d 0017    	strb.w	r0, [sp, #0x17]
700a27fc: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a27fe: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIaInst *inst = NULL;
700a2800: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIaGetInst(id);
700a2802: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a2806: f009 fea3    	bl	0x700ac550 <Sciclient_rmIaGetInst> @ imm = #0x9d46
700a280a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a280c: 9803         	ldr	r0, [sp, #0xc]
700a280e: b920         	cbnz	r0, 0x700a281a <Sciclient_rmIaValidateMapping+0x3a> @ imm = #0x8
700a2810: e7ff         	b	0x700a2812 <Sciclient_rmIaValidateMapping+0x32> @ imm = #-0x2
700a2812: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a2816: 9004         	str	r0, [sp, #0x10]
;     } else {
700a2818: e00b         	b	0x700a2832 <Sciclient_rmIaValidateMapping+0x52> @ imm = #0x16
;         if (vint >= inst->n_vint) {
700a281a: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a281e: 9903         	ldr	r1, [sp, #0xc]
700a2820: 8989         	ldrh	r1, [r1, #0xc]
700a2822: 4288         	cmp	r0, r1
700a2824: db04         	blt	0x700a2830 <Sciclient_rmIaValidateMapping+0x50> @ imm = #0x8
700a2826: e7ff         	b	0x700a2828 <Sciclient_rmIaValidateMapping+0x48> @ imm = #-0x2
700a2828: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a282c: 9004         	str	r0, [sp, #0x10]
;         }
700a282e: e7ff         	b	0x700a2830 <Sciclient_rmIaValidateMapping+0x50> @ imm = #-0x2
700a2830: e7ff         	b	0x700a2832 <Sciclient_rmIaValidateMapping+0x52> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (vint_sb_index >= SCICLIENT_IA_VINT_MAX_BITS)) {
700a2832: 9804         	ldr	r0, [sp, #0x10]
700a2834: b948         	cbnz	r0, 0x700a284a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #0x12
700a2836: e7ff         	b	0x700a2838 <Sciclient_rmIaValidateMapping+0x58> @ imm = #-0x2
700a2838: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a283c: 2840         	cmp	r0, #0x40
700a283e: d304         	blo	0x700a284a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #0x8
700a2840: e7ff         	b	0x700a2842 <Sciclient_rmIaValidateMapping+0x62> @ imm = #-0x2
700a2842: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a2846: 9004         	str	r0, [sp, #0x10]
;     }
700a2848: e7ff         	b	0x700a284a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a284a: 9804         	ldr	r0, [sp, #0x10]
700a284c: b998         	cbnz	r0, 0x700a2876 <Sciclient_rmIaValidateMapping+0x96> @ imm = #0x26
700a284e: e7ff         	b	0x700a2850 <Sciclient_rmIaValidateMapping+0x70> @ imm = #-0x2
;         evt = global_evt - inst->sevt_offset;
700a2850: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a2854: 9903         	ldr	r1, [sp, #0xc]
700a2856: 8909         	ldrh	r1, [r1, #0x8]
700a2858: 1a40         	subs	r0, r0, r1
700a285a: f8ad 000a    	strh.w	r0, [sp, #0xa]
;         if (evt >= inst->n_sevt) {
700a285e: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a2862: 9903         	ldr	r1, [sp, #0xc]
700a2864: 8949         	ldrh	r1, [r1, #0xa]
700a2866: 4288         	cmp	r0, r1
700a2868: db04         	blt	0x700a2874 <Sciclient_rmIaValidateMapping+0x94> @ imm = #0x8
700a286a: e7ff         	b	0x700a286c <Sciclient_rmIaValidateMapping+0x8c> @ imm = #-0x2
700a286c: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a2870: 9004         	str	r0, [sp, #0x10]
;         }
700a2872: e7ff         	b	0x700a2874 <Sciclient_rmIaValidateMapping+0x94> @ imm = #-0x2
;     }
700a2874: e7ff         	b	0x700a2876 <Sciclient_rmIaValidateMapping+0x96> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a2876: 9804         	ldr	r0, [sp, #0x10]
700a2878: 2800         	cmp	r0, #0x0
700a287a: d14e         	bne	0x700a291a <Sciclient_rmIaValidateMapping+0x13a> @ imm = #0x9c
700a287c: e7ff         	b	0x700a287e <Sciclient_rmIaValidateMapping+0x9e> @ imm = #-0x2
;         entry_int_map_lo = (volatile uint32_t *)(inst->imap + SCICLIENT_IA_ENTRY_INTMAP_LO(evt));
700a287e: 9803         	ldr	r0, [sp, #0xc]
700a2880: 6840         	ldr	r0, [r0, #0x4]
700a2882: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700a2886: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a288a: 9001         	str	r0, [sp, #0x4]
;         reg_vint = CSL_REG32_FEXT(entry_int_map_lo,
700a288c: 9801         	ldr	r0, [sp, #0x4]
700a288e: f64f 7100    	movw	r1, #0xff00
700a2892: f2c0 0101    	movt	r1, #0x1
700a2896: 2208         	movs	r2, #0x8
700a2898: f00c fc62    	bl	0x700af160 <CSL_REG32_FEXT_RAW> @ imm = #0xc8c4
700a289c: f8ad 0002    	strh.w	r0, [sp, #0x2]
;         reg_sb = CSL_REG32_FEXT(entry_int_map_lo,
700a28a0: 9801         	ldr	r0, [sp, #0x4]
700a28a2: 213f         	movs	r1, #0x3f
700a28a4: 2200         	movs	r2, #0x0
700a28a6: f00c fc5b    	bl	0x700af160 <CSL_REG32_FEXT_RAW> @ imm = #0xc8b6
700a28aa: f8ad 0000    	strh.w	r0, [sp]
;         if ((reg_vint == 0u) && (reg_sb == 0u)) {
700a28ae: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a28b2: b9f0         	cbnz	r0, 0x700a28f2 <Sciclient_rmIaValidateMapping+0x112> @ imm = #0x3c
700a28b4: e7ff         	b	0x700a28b6 <Sciclient_rmIaValidateMapping+0xd6> @ imm = #-0x2
700a28b6: f8bd 0000    	ldrh.w	r0, [sp]
700a28ba: b9d0         	cbnz	r0, 0x700a28f2 <Sciclient_rmIaValidateMapping+0x112> @ imm = #0x34
700a28bc: e7ff         	b	0x700a28be <Sciclient_rmIaValidateMapping+0xde> @ imm = #-0x2
;             if ((vint != reg_vint) &&
700a28be: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a28c2: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a28c6: 4288         	cmp	r0, r1
700a28c8: d012         	beq	0x700a28f0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x24
700a28ca: e7ff         	b	0x700a28cc <Sciclient_rmIaValidateMapping+0xec> @ imm = #-0x2
;                 (vint_sb_index != reg_sb) &&
700a28cc: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a28d0: f8bd 1000    	ldrh.w	r1, [sp]
700a28d4: 4288         	cmp	r0, r1
700a28d6: d00b         	beq	0x700a28f0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x16
700a28d8: e7ff         	b	0x700a28da <Sciclient_rmIaValidateMapping+0xfa> @ imm = #-0x2
;                 (evt != inst->v0_b0_evt)) {
700a28da: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a28de: 9903         	ldr	r1, [sp, #0xc]
700a28e0: 8a89         	ldrh	r1, [r1, #0x14]
;             if ((vint != reg_vint) &&
700a28e2: 4288         	cmp	r0, r1
700a28e4: d004         	beq	0x700a28f0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x8
700a28e6: e7ff         	b	0x700a28e8 <Sciclient_rmIaValidateMapping+0x108> @ imm = #-0x2
700a28e8: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a28ec: 9004         	str	r0, [sp, #0x10]
;             }
700a28ee: e7ff         	b	0x700a28f0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #-0x2
;         } else {
700a28f0: e012         	b	0x700a2918 <Sciclient_rmIaValidateMapping+0x138> @ imm = #0x24
;             if ((vint != reg_vint) &&
700a28f2: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a28f6: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a28fa: 4288         	cmp	r0, r1
700a28fc: d00b         	beq	0x700a2916 <Sciclient_rmIaValidateMapping+0x136> @ imm = #0x16
700a28fe: e7ff         	b	0x700a2900 <Sciclient_rmIaValidateMapping+0x120> @ imm = #-0x2
;                 (vint_sb_index != reg_sb)) {
700a2900: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a2904: f8bd 1000    	ldrh.w	r1, [sp]
;             if ((vint != reg_vint) &&
700a2908: 4288         	cmp	r0, r1
700a290a: d004         	beq	0x700a2916 <Sciclient_rmIaValidateMapping+0x136> @ imm = #0x8
700a290c: e7ff         	b	0x700a290e <Sciclient_rmIaValidateMapping+0x12e> @ imm = #-0x2
700a290e: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a2912: 9004         	str	r0, [sp, #0x10]
;             }
700a2914: e7ff         	b	0x700a2916 <Sciclient_rmIaValidateMapping+0x136> @ imm = #-0x2
700a2916: e7ff         	b	0x700a2918 <Sciclient_rmIaValidateMapping+0x138> @ imm = #-0x2
;     }
700a2918: e7ff         	b	0x700a291a <Sciclient_rmIaValidateMapping+0x13a> @ imm = #-0x2
;     return r;
700a291a: 9804         	ldr	r0, [sp, #0x10]
700a291c: b008         	add	sp, #0x20
700a291e: bd80         	pop	{r7, pc}

700a2920 <Udma_rmAllocMappedRing>:
; {
700a2920: b580         	push	{r7, lr}
700a2922: b090         	sub	sp, #0x40
700a2924: 900f         	str	r0, [sp, #0x3c]
700a2926: 910e         	str	r1, [sp, #0x38]
700a2928: 920d         	str	r2, [sp, #0x34]
700a292a: f64f 70ff    	movw	r0, #0xffff
;     uint32_t    ringNum = UDMA_RING_INVALID;
700a292e: 900c         	str	r0, [sp, #0x30]
700a2930: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a2932: 9005         	str	r0, [sp, #0x14]
;     Udma_RmInitPrms             *rmInitPrms = &drvHandle->rmInitPrms;
700a2934: 980f         	ldr	r0, [sp, #0x3c]
700a2936: f500 70ea    	add.w	r0, r0, #0x1d4
700a293a: 9004         	str	r0, [sp, #0x10]
;     retVal = Udma_getMappedChRingAttributes(drvHandle, mappedRingGrp, mappedChNum, &chAttr);
700a293c: 980f         	ldr	r0, [sp, #0x3c]
700a293e: 990e         	ldr	r1, [sp, #0x38]
700a2940: 9a0d         	ldr	r2, [sp, #0x34]
700a2942: ab01         	add	r3, sp, #0x4
700a2944: f005 fa54    	bl	0x700a7df0 <Udma_getMappedChRingAttributes> @ imm = #0x54a8
700a2948: 9005         	str	r0, [sp, #0x14]
;     if(UDMA_SOK == retVal)
700a294a: 9805         	ldr	r0, [sp, #0x14]
700a294c: 2800         	cmp	r0, #0x0
700a294e: f040 8084    	bne.w	0x700a2a5a <Udma_rmAllocMappedRing+0x13a> @ imm = #0x108
700a2952: e7ff         	b	0x700a2954 <Udma_rmAllocMappedRing+0x34> @ imm = #-0x2
700a2954: 2000         	movs	r0, #0x0
;         loopStart = 0;
700a2956: 9007         	str	r0, [sp, #0x1c]
;         loopMax   = rmInitPrms->numMappedRing[mappedRingGrp];
700a2958: 9804         	ldr	r0, [sp, #0x10]
700a295a: 990e         	ldr	r1, [sp, #0x38]
700a295c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2960: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
700a2964: 9006         	str	r0, [sp, #0x18]
;         if(chAttr.startFreeRing > rmInitPrms->startMappedRing[mappedRingGrp])
700a2966: 9802         	ldr	r0, [sp, #0x8]
700a2968: 9904         	ldr	r1, [sp, #0x10]
700a296a: 9a0e         	ldr	r2, [sp, #0x38]
700a296c: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a2970: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a2974: 4288         	cmp	r0, r1
700a2976: d90a         	bls	0x700a298e <Udma_rmAllocMappedRing+0x6e> @ imm = #0x14
700a2978: e7ff         	b	0x700a297a <Udma_rmAllocMappedRing+0x5a> @ imm = #-0x2
;             loopStart = chAttr.startFreeRing - rmInitPrms->startMappedRing[mappedRingGrp];
700a297a: 9802         	ldr	r0, [sp, #0x8]
700a297c: 9904         	ldr	r1, [sp, #0x10]
700a297e: 9a0e         	ldr	r2, [sp, #0x38]
700a2980: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a2984: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a2988: 1a40         	subs	r0, r0, r1
700a298a: 9007         	str	r0, [sp, #0x1c]
;         }
700a298c: e7ff         	b	0x700a298e <Udma_rmAllocMappedRing+0x6e> @ imm = #-0x2
;         if((chAttr.startFreeRing + chAttr.numFreeRing) < (rmInitPrms->startMappedRing[mappedRingGrp] + rmInitPrms->numMappedRing[mappedRingGrp]))
700a298e: 9802         	ldr	r0, [sp, #0x8]
700a2990: 9903         	ldr	r1, [sp, #0xc]
700a2992: 4408         	add	r0, r1
700a2994: 9904         	ldr	r1, [sp, #0x10]
700a2996: 9a0e         	ldr	r2, [sp, #0x38]
700a2998: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a299c: f8d2 1088    	ldr.w	r1, [r2, #0x88]
700a29a0: f8d2 20a8    	ldr.w	r2, [r2, #0xa8]
700a29a4: 4411         	add	r1, r2
700a29a6: 4288         	cmp	r0, r1
700a29a8: d20c         	bhs	0x700a29c4 <Udma_rmAllocMappedRing+0xa4> @ imm = #0x18
700a29aa: e7ff         	b	0x700a29ac <Udma_rmAllocMappedRing+0x8c> @ imm = #-0x2
;             loopMax = (chAttr.startFreeRing + chAttr.numFreeRing) - rmInitPrms->startMappedRing[mappedRingGrp];
700a29ac: 9802         	ldr	r0, [sp, #0x8]
700a29ae: 9903         	ldr	r1, [sp, #0xc]
700a29b0: 4408         	add	r0, r1
700a29b2: 9904         	ldr	r1, [sp, #0x10]
700a29b4: 9a0e         	ldr	r2, [sp, #0x38]
700a29b6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a29ba: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a29be: 1a40         	subs	r0, r0, r1
700a29c0: 9006         	str	r0, [sp, #0x18]
;         }
700a29c2: e7ff         	b	0x700a29c4 <Udma_rmAllocMappedRing+0xa4> @ imm = #-0x2
;         SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a29c4: 980f         	ldr	r0, [sp, #0x3c]
700a29c6: f500 609f    	add.w	r0, r0, #0x4f8
700a29ca: f04f 31ff    	mov.w	r1, #0xffffffff
700a29ce: f007 ff07    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x7e0e
;         for(i = loopStart; i < loopMax; i++)
700a29d2: 9807         	ldr	r0, [sp, #0x1c]
700a29d4: 900b         	str	r0, [sp, #0x2c]
700a29d6: e7ff         	b	0x700a29d8 <Udma_rmAllocMappedRing+0xb8> @ imm = #-0x2
700a29d8: 980b         	ldr	r0, [sp, #0x2c]
700a29da: 9906         	ldr	r1, [sp, #0x18]
700a29dc: 4288         	cmp	r0, r1
700a29de: d236         	bhs	0x700a2a4e <Udma_rmAllocMappedRing+0x12e> @ imm = #0x6c
700a29e0: e7ff         	b	0x700a29e2 <Udma_rmAllocMappedRing+0xc2> @ imm = #-0x2
;             offset = i >> 5U;
700a29e2: 980b         	ldr	r0, [sp, #0x2c]
700a29e4: 0940         	lsrs	r0, r0, #0x5
700a29e6: 900a         	str	r0, [sp, #0x28]
;             bitPos = i - (offset << 5U);
700a29e8: 980b         	ldr	r0, [sp, #0x2c]
700a29ea: 990a         	ldr	r1, [sp, #0x28]
700a29ec: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a29f0: 9009         	str	r0, [sp, #0x24]
;             bitMask = (uint32_t) 1U << bitPos;
700a29f2: 9909         	ldr	r1, [sp, #0x24]
700a29f4: 2001         	movs	r0, #0x1
700a29f6: 4088         	lsls	r0, r1
700a29f8: 9008         	str	r0, [sp, #0x20]
;             if((drvHandle->mappedRingFlag[mappedRingGrp][offset] & bitMask) == bitMask)
700a29fa: 980f         	ldr	r0, [sp, #0x3c]
700a29fc: 990e         	ldr	r1, [sp, #0x38]
700a29fe: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a2a02: 990a         	ldr	r1, [sp, #0x28]
700a2a04: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2a08: f8d0 0344    	ldr.w	r0, [r0, #0x344]
700a2a0c: 9908         	ldr	r1, [sp, #0x20]
700a2a0e: 4008         	ands	r0, r1
700a2a10: 4288         	cmp	r0, r1
700a2a12: d117         	bne	0x700a2a44 <Udma_rmAllocMappedRing+0x124> @ imm = #0x2e
700a2a14: e7ff         	b	0x700a2a16 <Udma_rmAllocMappedRing+0xf6> @ imm = #-0x2
;                 drvHandle->mappedRingFlag[mappedRingGrp][offset] &= ~bitMask;
700a2a16: 9a08         	ldr	r2, [sp, #0x20]
700a2a18: 980f         	ldr	r0, [sp, #0x3c]
700a2a1a: 990e         	ldr	r1, [sp, #0x38]
700a2a1c: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a2a20: 990a         	ldr	r1, [sp, #0x28]
700a2a22: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a2a26: f8d1 0344    	ldr.w	r0, [r1, #0x344]
700a2a2a: 4390         	bics	r0, r2
700a2a2c: f8c1 0344    	str.w	r0, [r1, #0x344]
;                 ringNum = i + rmInitPrms->startMappedRing[mappedRingGrp];  /* Add start offset */
700a2a30: 980b         	ldr	r0, [sp, #0x2c]
700a2a32: 9904         	ldr	r1, [sp, #0x10]
700a2a34: 9a0e         	ldr	r2, [sp, #0x38]
700a2a36: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a2a3a: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a2a3e: 4408         	add	r0, r1
700a2a40: 900c         	str	r0, [sp, #0x30]
;                 break;
700a2a42: e004         	b	0x700a2a4e <Udma_rmAllocMappedRing+0x12e> @ imm = #0x8
;         }
700a2a44: e7ff         	b	0x700a2a46 <Udma_rmAllocMappedRing+0x126> @ imm = #-0x2
;         for(i = loopStart; i < loopMax; i++)
700a2a46: 980b         	ldr	r0, [sp, #0x2c]
700a2a48: 3001         	adds	r0, #0x1
700a2a4a: 900b         	str	r0, [sp, #0x2c]
700a2a4c: e7c4         	b	0x700a29d8 <Udma_rmAllocMappedRing+0xb8> @ imm = #-0x78
;         SemaphoreP_post(&drvHandle->rmLockObj);
700a2a4e: 980f         	ldr	r0, [sp, #0x3c]
700a2a50: f500 609f    	add.w	r0, r0, #0x4f8
700a2a54: f009 fa54    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x94a8
;     }
700a2a58: e7ff         	b	0x700a2a5a <Udma_rmAllocMappedRing+0x13a> @ imm = #-0x2
;     return (ringNum);
700a2a5a: 980c         	ldr	r0, [sp, #0x30]
700a2a5c: b010         	add	sp, #0x40
700a2a5e: bd80         	pop	{r7, pc}

700a2a60 <UART_procLineStatusErr>:
; {
700a2a60: b580         	push	{r7, lr}
700a2a62: b086         	sub	sp, #0x18
700a2a64: 9005         	str	r0, [sp, #0x14]
700a2a66: 2000         	movs	r0, #0x0
;     int32_t            status = UART_STATUS_SUCCESS;
700a2a68: 9004         	str	r0, [sp, #0x10]
;     uint32_t           lineStatus, iteration = 0U;
700a2a6a: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == hUart)
700a2a6c: 9805         	ldr	r0, [sp, #0x14]
700a2a6e: b920         	cbnz	r0, 0x700a2a7a <UART_procLineStatusErr+0x1a> @ imm = #0x8
700a2a70: e7ff         	b	0x700a2a72 <UART_procLineStatusErr+0x12> @ imm = #-0x2
700a2a72: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a2a76: 9004         	str	r0, [sp, #0x10]
;     }
700a2a78: e7ff         	b	0x700a2a7a <UART_procLineStatusErr+0x1a> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a2a7a: 9804         	ldr	r0, [sp, #0x10]
700a2a7c: 2800         	cmp	r0, #0x0
700a2a7e: f040 808b    	bne.w	0x700a2b98 <UART_procLineStatusErr+0x138> @ imm = #0x116
700a2a82: e7ff         	b	0x700a2a84 <UART_procLineStatusErr+0x24> @ imm = #-0x2
;         lineStatus = UART_readLineStatus(hUart->baseAddr);
700a2a84: 9805         	ldr	r0, [sp, #0x14]
700a2a86: 6800         	ldr	r0, [r0]
700a2a88: f00a ff12    	bl	0x700ad8b0 <UART_readLineStatus> @ imm = #0xae24
700a2a8c: 9003         	str	r0, [sp, #0xc]
;         if(((lineStatus & UART_FIFO_PE_FE_BI_DETECTED) == UART_FIFO_PE_FE_BI_DETECTED)
700a2a8e: 9803         	ldr	r0, [sp, #0xc]
700a2a90: f000 0080    	and	r0, r0, #0x80
;                 || ((lineStatus & UART_OVERRUN_ERROR) == UART_OVERRUN_ERROR))
700a2a94: 2880         	cmp	r0, #0x80
700a2a96: d006         	beq	0x700a2aa6 <UART_procLineStatusErr+0x46> @ imm = #0xc
700a2a98: e7ff         	b	0x700a2a9a <UART_procLineStatusErr+0x3a> @ imm = #-0x2
;         if(((lineStatus & UART_FIFO_PE_FE_BI_DETECTED) == UART_FIFO_PE_FE_BI_DETECTED)
700a2a9a: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a2a9e: 0780         	lsls	r0, r0, #0x1e
700a2aa0: 2800         	cmp	r0, #0x0
700a2aa2: d578         	bpl	0x700a2b96 <UART_procLineStatusErr+0x136> @ imm = #0xf0
700a2aa4: e7ff         	b	0x700a2aa6 <UART_procLineStatusErr+0x46> @ imm = #-0x2
;             if (hUart->readTrans.buf != NULL)
700a2aa6: 9805         	ldr	r0, [sp, #0x14]
700a2aa8: 6a80         	ldr	r0, [r0, #0x28]
700a2aaa: b120         	cbz	r0, 0x700a2ab6 <UART_procLineStatusErr+0x56> @ imm = #0x8
700a2aac: e7ff         	b	0x700a2aae <UART_procLineStatusErr+0x4e> @ imm = #-0x2
;                 hUart->readTrans.count = (uint32_t)(hUart->readCount);
700a2aae: 9905         	ldr	r1, [sp, #0x14]
700a2ab0: 6988         	ldr	r0, [r1, #0x18]
700a2ab2: 62c8         	str	r0, [r1, #0x2c]
;             }
700a2ab4: e7ff         	b	0x700a2ab6 <UART_procLineStatusErr+0x56> @ imm = #-0x2
700a2ab6: 2040         	movs	r0, #0x40
;             iteration = UART_FIFO_SIZE;
700a2ab8: 9002         	str	r0, [sp, #0x8]
;             do
700a2aba: e7ff         	b	0x700a2abc <UART_procLineStatusErr+0x5c> @ imm = #-0x2
;                 (void)UART_fifoCharGet(hUart->baseAddr);
700a2abc: 9805         	ldr	r0, [sp, #0x14]
700a2abe: 6800         	ldr	r0, [r0]
700a2ac0: f00c fdc6    	bl	0x700af650 <UART_fifoCharGet> @ imm = #0xcb8c
;                 iteration--;
700a2ac4: 9802         	ldr	r0, [sp, #0x8]
700a2ac6: 3801         	subs	r0, #0x1
700a2ac8: 9002         	str	r0, [sp, #0x8]
;                 lineStatus = (uint32_t) UART_readLineStatus(hUart->baseAddr);
700a2aca: 9805         	ldr	r0, [sp, #0x14]
700a2acc: 6800         	ldr	r0, [r0]
700a2ace: f00a feef    	bl	0x700ad8b0 <UART_readLineStatus> @ imm = #0xadde
700a2ad2: 9003         	str	r0, [sp, #0xc]
;                 lineStatus &= (UART_LSR_RX_FIFO_STS_MASK |
700a2ad4: 9803         	ldr	r0, [sp, #0xc]
700a2ad6: f000 009f    	and	r0, r0, #0x9f
700a2ada: 9003         	str	r0, [sp, #0xc]
;             }
700a2adc: e7ff         	b	0x700a2ade <UART_procLineStatusErr+0x7e> @ imm = #-0x2
;             while ((lineStatus != 0U) && (iteration != 0U));
700a2ade: 9903         	ldr	r1, [sp, #0xc]
700a2ae0: 2000         	movs	r0, #0x0
700a2ae2: 9001         	str	r0, [sp, #0x4]
700a2ae4: b131         	cbz	r1, 0x700a2af4 <UART_procLineStatusErr+0x94> @ imm = #0xc
700a2ae6: e7ff         	b	0x700a2ae8 <UART_procLineStatusErr+0x88> @ imm = #-0x2
700a2ae8: 9802         	ldr	r0, [sp, #0x8]
700a2aea: 2800         	cmp	r0, #0x0
700a2aec: bf18         	it	ne
700a2aee: 2001         	movne	r0, #0x1
700a2af0: 9001         	str	r0, [sp, #0x4]
700a2af2: e7ff         	b	0x700a2af4 <UART_procLineStatusErr+0x94> @ imm = #-0x2
700a2af4: 9801         	ldr	r0, [sp, #0x4]
;             }
700a2af6: 07c0         	lsls	r0, r0, #0x1f
700a2af8: 2800         	cmp	r0, #0x0
700a2afa: d1df         	bne	0x700a2abc <UART_procLineStatusErr+0x5c> @ imm = #-0x42
700a2afc: e7ff         	b	0x700a2afe <UART_procLineStatusErr+0x9e> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a2afe: 9805         	ldr	r0, [sp, #0x14]
700a2b00: 6800         	ldr	r0, [r0]
700a2b02: 2105         	movs	r1, #0x5
700a2b04: f003 fc2c    	bl	0x700a6360 <UART_intrDisable> @ imm = #0x3858
;             hUart->readBuf = (void *)((uint8_t *)hUart->readBuf - hUart->readCount);
700a2b08: 9905         	ldr	r1, [sp, #0x14]
700a2b0a: 6948         	ldr	r0, [r1, #0x14]
700a2b0c: 698a         	ldr	r2, [r1, #0x18]
700a2b0e: 1a80         	subs	r0, r0, r2
700a2b10: 6148         	str	r0, [r1, #0x14]
;             if (hUart->readTrans.buf != NULL)
700a2b12: 9805         	ldr	r0, [sp, #0x14]
700a2b14: 6a80         	ldr	r0, [r0, #0x28]
700a2b16: b3a8         	cbz	r0, 0x700a2b84 <UART_procLineStatusErr+0x124> @ imm = #0x6a
700a2b18: e7ff         	b	0x700a2b1a <UART_procLineStatusErr+0xba> @ imm = #-0x2
;                 if ((lineStatus & UART_BREAK_DETECTED_ERROR) != 0U)
700a2b1a: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a2b1e: 06c0         	lsls	r0, r0, #0x1b
700a2b20: 2800         	cmp	r0, #0x0
700a2b22: d508         	bpl	0x700a2b36 <UART_procLineStatusErr+0xd6> @ imm = #0x10
700a2b24: e7ff         	b	0x700a2b26 <UART_procLineStatusErr+0xc6> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_BI;
700a2b26: 9905         	ldr	r1, [sp, #0x14]
700a2b28: 2002         	movs	r0, #0x2
700a2b2a: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a2b2c: 9905         	ldr	r1, [sp, #0x14]
700a2b2e: 6a48         	ldr	r0, [r1, #0x24]
700a2b30: 3001         	adds	r0, #0x1
700a2b32: 6248         	str	r0, [r1, #0x24]
;                 }
700a2b34: e025         	b	0x700a2b82 <UART_procLineStatusErr+0x122> @ imm = #0x4a
;                 else if ((lineStatus & UART_FRAMING_ERROR) != 0U)
700a2b36: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a2b3a: 0700         	lsls	r0, r0, #0x1c
700a2b3c: 2800         	cmp	r0, #0x0
700a2b3e: d508         	bpl	0x700a2b52 <UART_procLineStatusErr+0xf2> @ imm = #0x10
700a2b40: e7ff         	b	0x700a2b42 <UART_procLineStatusErr+0xe2> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_FE;
700a2b42: 9905         	ldr	r1, [sp, #0x14]
700a2b44: 2003         	movs	r0, #0x3
700a2b46: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a2b48: 9905         	ldr	r1, [sp, #0x14]
700a2b4a: 6a48         	ldr	r0, [r1, #0x24]
700a2b4c: 3001         	adds	r0, #0x1
700a2b4e: 6248         	str	r0, [r1, #0x24]
;                 }
700a2b50: e016         	b	0x700a2b80 <UART_procLineStatusErr+0x120> @ imm = #0x2c
;                 else if ((lineStatus & UART_PARITY_ERROR) != 0U)
700a2b52: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a2b56: 0740         	lsls	r0, r0, #0x1d
700a2b58: 2800         	cmp	r0, #0x0
700a2b5a: d508         	bpl	0x700a2b6e <UART_procLineStatusErr+0x10e> @ imm = #0x10
700a2b5c: e7ff         	b	0x700a2b5e <UART_procLineStatusErr+0xfe> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_PE;
700a2b5e: 9905         	ldr	r1, [sp, #0x14]
700a2b60: 2004         	movs	r0, #0x4
700a2b62: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a2b64: 9905         	ldr	r1, [sp, #0x14]
700a2b66: 6a48         	ldr	r0, [r1, #0x24]
700a2b68: 3001         	adds	r0, #0x1
700a2b6a: 6248         	str	r0, [r1, #0x24]
;                 }
700a2b6c: e007         	b	0x700a2b7e <UART_procLineStatusErr+0x11e> @ imm = #0xe
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_OE;
700a2b6e: 9905         	ldr	r1, [sp, #0x14]
700a2b70: 2005         	movs	r0, #0x5
700a2b72: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a2b74: 9905         	ldr	r1, [sp, #0x14]
700a2b76: 6a48         	ldr	r0, [r1, #0x24]
700a2b78: 3001         	adds	r0, #0x1
700a2b7a: 6248         	str	r0, [r1, #0x24]
700a2b7c: e7ff         	b	0x700a2b7e <UART_procLineStatusErr+0x11e> @ imm = #-0x2
700a2b7e: e7ff         	b	0x700a2b80 <UART_procLineStatusErr+0x120> @ imm = #-0x2
700a2b80: e7ff         	b	0x700a2b82 <UART_procLineStatusErr+0x122> @ imm = #-0x2
;             }
700a2b82: e7ff         	b	0x700a2b84 <UART_procLineStatusErr+0x124> @ imm = #-0x2
;             hUart->hUartInit->errorCallbackFxn(hUart);
700a2b84: 9805         	ldr	r0, [sp, #0x14]
700a2b86: 6841         	ldr	r1, [r0, #0x4]
700a2b88: 6e49         	ldr	r1, [r1, #0x64]
700a2b8a: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->readTrans);
700a2b8c: 9805         	ldr	r0, [sp, #0x14]
700a2b8e: 3028         	adds	r0, #0x28
700a2b90: f00c fc7e    	bl	0x700af490 <UART_lld_Transaction_deInit> @ imm = #0xc8fc
;         }
700a2b94: e7ff         	b	0x700a2b96 <UART_procLineStatusErr+0x136> @ imm = #-0x2
;     }
700a2b96: e7ff         	b	0x700a2b98 <UART_procLineStatusErr+0x138> @ imm = #-0x2
;     return status;
700a2b98: 9804         	ldr	r0, [sp, #0x10]
700a2b9a: b006         	add	sp, #0x18
700a2b9c: bd80         	pop	{r7, pc}
700a2b9e: 0000         	movs	r0, r0

700a2ba0 <prvProcessReceivedCommands>:
;     {
700a2ba0: b580         	push	{r7, lr}
700a2ba2: b08c         	sub	sp, #0x30
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
700a2ba4: e7ff         	b	0x700a2ba6 <prvProcessReceivedCommands+0x6> @ imm = #-0x2
700a2ba6: f642 2058    	movw	r0, #0x2a58
700a2baa: f2c7 000b    	movt	r0, #0x700b
700a2bae: 6800         	ldr	r0, [r0]
700a2bb0: a908         	add	r1, sp, #0x20
700a2bb2: 2200         	movs	r2, #0x0
700a2bb4: f000 fd6c    	bl	0x700a3690 <xQueueReceive> @ imm = #0xad8
700a2bb8: 2800         	cmp	r0, #0x0
700a2bba: f000 808c    	beq.w	0x700a2cd6 <prvProcessReceivedCommands+0x136> @ imm = #0x118
700a2bbe: e7ff         	b	0x700a2bc0 <prvProcessReceivedCommands+0x20> @ imm = #-0x2
;                     if( xMessage.xMessageID < ( BaseType_t ) 0 )
700a2bc0: 9808         	ldr	r0, [sp, #0x20]
700a2bc2: f1b0 3fff    	cmp.w	r0, #0xffffffff
700a2bc6: dc09         	bgt	0x700a2bdc <prvProcessReceivedCommands+0x3c> @ imm = #0x12
700a2bc8: e7ff         	b	0x700a2bca <prvProcessReceivedCommands+0x2a> @ imm = #-0x2
700a2bca: a808         	add	r0, sp, #0x20
;                         const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
700a2bcc: 3004         	adds	r0, #0x4
700a2bce: 9003         	str	r0, [sp, #0xc]
;                         pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
700a2bd0: 9903         	ldr	r1, [sp, #0xc]
700a2bd2: 680a         	ldr	r2, [r1]
700a2bd4: 6848         	ldr	r0, [r1, #0x4]
700a2bd6: 6889         	ldr	r1, [r1, #0x8]
700a2bd8: 4790         	blx	r2
;                     }
700a2bda: e000         	b	0x700a2bde <prvProcessReceivedCommands+0x3e> @ imm = #0x0
700a2bdc: e7ff         	b	0x700a2bde <prvProcessReceivedCommands+0x3e> @ imm = #-0x2
;             if( xMessage.xMessageID >= ( BaseType_t ) 0 )
700a2bde: 9808         	ldr	r0, [sp, #0x20]
700a2be0: 2800         	cmp	r0, #0x0
700a2be2: f100 8077    	bmi.w	0x700a2cd4 <prvProcessReceivedCommands+0x134> @ imm = #0xee
700a2be6: e7ff         	b	0x700a2be8 <prvProcessReceivedCommands+0x48> @ imm = #-0x2
;                 pxTimer = xMessage.u.xTimerParameters.pxTimer;
700a2be8: 980a         	ldr	r0, [sp, #0x28]
700a2bea: 9007         	str	r0, [sp, #0x1c]
;                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
700a2bec: 9807         	ldr	r0, [sp, #0x1c]
700a2bee: 6940         	ldr	r0, [r0, #0x14]
700a2bf0: b128         	cbz	r0, 0x700a2bfe <prvProcessReceivedCommands+0x5e> @ imm = #0xa
700a2bf2: e7ff         	b	0x700a2bf4 <prvProcessReceivedCommands+0x54> @ imm = #-0x2
;                     ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a2bf4: 9807         	ldr	r0, [sp, #0x1c]
700a2bf6: 3004         	adds	r0, #0x4
700a2bf8: f00a fd92    	bl	0x700ad720 <uxListRemove> @ imm = #0xab24
;                 }
700a2bfc: e000         	b	0x700a2c00 <prvProcessReceivedCommands+0x60> @ imm = #0x0
700a2bfe: e7ff         	b	0x700a2c00 <prvProcessReceivedCommands+0x60> @ imm = #-0x2
700a2c00: a806         	add	r0, sp, #0x18
;                 xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
700a2c02: f00a fef5    	bl	0x700ad9f0 <prvSampleTimeNow> @ imm = #0xadea
700a2c06: 9004         	str	r0, [sp, #0x10]
;                 switch( xMessage.xMessageID )
700a2c08: 9808         	ldr	r0, [sp, #0x20]
700a2c0a: 9002         	str	r0, [sp, #0x8]
700a2c0c: 2809         	cmp	r0, #0x9
700a2c0e: d85f         	bhi	0x700a2cd0 <prvProcessReceivedCommands+0x130> @ imm = #0xbe
700a2c10: 9902         	ldr	r1, [sp, #0x8]
700a2c12: e8df f001    	tbb	[pc, r1]
700a2c16: 05 05 05 2f  	.word	0x2f050505
700a2c1a: 37 49 05 05  	.word	0x05054937
700a2c1e: 2f 37        	.short	0x372f
;                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
700a2c20: 9907         	ldr	r1, [sp, #0x1c]
700a2c22: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2c26: f040 0001    	orr	r0, r0, #0x1
700a2c2a: f881 0028    	strb.w	r0, [r1, #0x28]
;                         if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
700a2c2e: 9807         	ldr	r0, [sp, #0x1c]
700a2c30: 9b09         	ldr	r3, [sp, #0x24]
700a2c32: 6981         	ldr	r1, [r0, #0x18]
700a2c34: 4419         	add	r1, r3
700a2c36: 9a04         	ldr	r2, [sp, #0x10]
700a2c38: f007 fcb2    	bl	0x700aa5a0 <prvInsertTimerInActiveList> @ imm = #0x7964
700a2c3c: b1c0         	cbz	r0, 0x700a2c70 <prvProcessReceivedCommands+0xd0> @ imm = #0x30
700a2c3e: e7ff         	b	0x700a2c40 <prvProcessReceivedCommands+0xa0> @ imm = #-0x2
;                             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a2c40: 9807         	ldr	r0, [sp, #0x1c]
700a2c42: 6a01         	ldr	r1, [r0, #0x20]
700a2c44: 4788         	blx	r1
;                             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a2c46: 9807         	ldr	r0, [sp, #0x1c]
700a2c48: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a2c4c: 0740         	lsls	r0, r0, #0x1d
700a2c4e: 2800         	cmp	r0, #0x0
700a2c50: d50c         	bpl	0x700a2c6c <prvProcessReceivedCommands+0xcc> @ imm = #0x18
700a2c52: e7ff         	b	0x700a2c54 <prvProcessReceivedCommands+0xb4> @ imm = #-0x2
;                                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
700a2c54: 9807         	ldr	r0, [sp, #0x1c]
700a2c56: 9909         	ldr	r1, [sp, #0x24]
700a2c58: 6982         	ldr	r2, [r0, #0x18]
700a2c5a: 440a         	add	r2, r1
700a2c5c: 4669         	mov	r1, sp
700a2c5e: 2300         	movs	r3, #0x0
700a2c60: 600b         	str	r3, [r1]
700a2c62: 4619         	mov	r1, r3
700a2c64: f006 ff6c    	bl	0x700a9b40 <xTimerGenericCommand> @ imm = #0x6ed8
700a2c68: 9005         	str	r0, [sp, #0x14]
;                             }
700a2c6a: e000         	b	0x700a2c6e <prvProcessReceivedCommands+0xce> @ imm = #0x0
700a2c6c: e7ff         	b	0x700a2c6e <prvProcessReceivedCommands+0xce> @ imm = #-0x2
;                         }
700a2c6e: e000         	b	0x700a2c72 <prvProcessReceivedCommands+0xd2> @ imm = #0x0
700a2c70: e7ff         	b	0x700a2c72 <prvProcessReceivedCommands+0xd2> @ imm = #-0x2
;                         break;
700a2c72: e02e         	b	0x700a2cd2 <prvProcessReceivedCommands+0x132> @ imm = #0x5c
;                         pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a2c74: 9907         	ldr	r1, [sp, #0x1c]
700a2c76: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2c7a: f000 00fe    	and	r0, r0, #0xfe
700a2c7e: f881 0028    	strb.w	r0, [r1, #0x28]
;                         break;
700a2c82: e026         	b	0x700a2cd2 <prvProcessReceivedCommands+0x132> @ imm = #0x4c
;                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
700a2c84: 9907         	ldr	r1, [sp, #0x1c]
700a2c86: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2c8a: f040 0001    	orr	r0, r0, #0x1
700a2c8e: f881 0028    	strb.w	r0, [r1, #0x28]
;                         pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
700a2c92: 9809         	ldr	r0, [sp, #0x24]
700a2c94: 9907         	ldr	r1, [sp, #0x1c]
700a2c96: 6188         	str	r0, [r1, #0x18]
;                         ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
700a2c98: 9807         	ldr	r0, [sp, #0x1c]
700a2c9a: 9b04         	ldr	r3, [sp, #0x10]
700a2c9c: 6981         	ldr	r1, [r0, #0x18]
700a2c9e: 4419         	add	r1, r3
700a2ca0: 461a         	mov	r2, r3
700a2ca2: f007 fc7d    	bl	0x700aa5a0 <prvInsertTimerInActiveList> @ imm = #0x78fa
;                         break;
700a2ca6: e014         	b	0x700a2cd2 <prvProcessReceivedCommands+0x132> @ imm = #0x28
;                                 if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
700a2ca8: 9807         	ldr	r0, [sp, #0x1c]
700a2caa: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a2cae: 0780         	lsls	r0, r0, #0x1e
700a2cb0: 2800         	cmp	r0, #0x0
700a2cb2: d404         	bmi	0x700a2cbe <prvProcessReceivedCommands+0x11e> @ imm = #0x8
700a2cb4: e7ff         	b	0x700a2cb6 <prvProcessReceivedCommands+0x116> @ imm = #-0x2
;                                     vPortFree( pxTimer );
700a2cb6: 9807         	ldr	r0, [sp, #0x1c]
700a2cb8: f00c fb7a    	bl	0x700af3b0 <vPortFree>  @ imm = #0xc6f4
;                                 }
700a2cbc: e007         	b	0x700a2cce <prvProcessReceivedCommands+0x12e> @ imm = #0xe
;                                     pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a2cbe: 9907         	ldr	r1, [sp, #0x1c]
700a2cc0: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2cc4: f000 00fe    	and	r0, r0, #0xfe
700a2cc8: f881 0028    	strb.w	r0, [r1, #0x28]
700a2ccc: e7ff         	b	0x700a2cce <prvProcessReceivedCommands+0x12e> @ imm = #-0x2
;                         break;
700a2cce: e000         	b	0x700a2cd2 <prvProcessReceivedCommands+0x132> @ imm = #0x0
;                         break;
700a2cd0: e7ff         	b	0x700a2cd2 <prvProcessReceivedCommands+0x132> @ imm = #-0x2
;             }
700a2cd2: e7ff         	b	0x700a2cd4 <prvProcessReceivedCommands+0x134> @ imm = #-0x2
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
700a2cd4: e767         	b	0x700a2ba6 <prvProcessReceivedCommands+0x6> @ imm = #-0x132
;     }
700a2cd6: b00c         	add	sp, #0x30
700a2cd8: bd80         	pop	{r7, pc}
700a2cda: 0000         	movs	r0, r0
700a2cdc: 0000         	movs	r0, r0
700a2cde: 0000         	movs	r0, r0

700a2ce0 <_ntoa_long_long>:
; {
700a2ce0: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
700a2ce4: b09e         	sub	sp, #0x78
700a2ce6: 469e         	mov	lr, r3
700a2ce8: 4614         	mov	r4, r2
700a2cea: 460d         	mov	r5, r1
700a2cec: 4606         	mov	r6, r0
700a2cee: 9929         	ldr	r1, [sp, #0xa4]
700a2cf0: 9828         	ldr	r0, [sp, #0xa0]
700a2cf2: f8dd c094    	ldr.w	r12, [sp, #0x94]
700a2cf6: 9b24         	ldr	r3, [sp, #0x90]
700a2cf8: 9a2c         	ldr	r2, [sp, #0xb0]
700a2cfa: 9a2b         	ldr	r2, [sp, #0xac]
700a2cfc: 9a2a         	ldr	r2, [sp, #0xa8]
700a2cfe: 9a26         	ldr	r2, [sp, #0x98]
700a2d00: 961d         	str	r6, [sp, #0x74]
700a2d02: 951c         	str	r5, [sp, #0x70]
700a2d04: 941b         	str	r4, [sp, #0x6c]
700a2d06: f8cd e068    	str.w	lr, [sp, #0x68]
700a2d0a: f8cd c064    	str.w	r12, [sp, #0x64]
700a2d0e: 9318         	str	r3, [sp, #0x60]
700a2d10: f88d 205f    	strb.w	r2, [sp, #0x5f]
700a2d14: 9115         	str	r1, [sp, #0x54]
700a2d16: 9014         	str	r0, [sp, #0x50]
700a2d18: 2000         	movs	r0, #0x0
;   size_t len = 0U;
700a2d1a: 900b         	str	r0, [sp, #0x2c]
;   if (!value) {
700a2d1c: 9818         	ldr	r0, [sp, #0x60]
700a2d1e: 9919         	ldr	r1, [sp, #0x64]
700a2d20: 4308         	orrs	r0, r1
700a2d22: b928         	cbnz	r0, 0x700a2d30 <_ntoa_long_long+0x50> @ imm = #0xa
700a2d24: e7ff         	b	0x700a2d26 <_ntoa_long_long+0x46> @ imm = #-0x2
;     flags &= ~FLAGS_HASH;
700a2d26: 982c         	ldr	r0, [sp, #0xb0]
700a2d28: f020 0010    	bic	r0, r0, #0x10
700a2d2c: 902c         	str	r0, [sp, #0xb0]
;   }
700a2d2e: e7ff         	b	0x700a2d30 <_ntoa_long_long+0x50> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION) || value) {
700a2d30: f89d 00b1    	ldrb.w	r0, [sp, #0xb1]
700a2d34: 0740         	lsls	r0, r0, #0x1d
700a2d36: 2800         	cmp	r0, #0x0
700a2d38: d506         	bpl	0x700a2d48 <_ntoa_long_long+0x68> @ imm = #0xc
700a2d3a: e7ff         	b	0x700a2d3c <_ntoa_long_long+0x5c> @ imm = #-0x2
700a2d3c: 9818         	ldr	r0, [sp, #0x60]
700a2d3e: 9919         	ldr	r1, [sp, #0x64]
700a2d40: 4308         	orrs	r0, r1
700a2d42: 2800         	cmp	r0, #0x0
700a2d44: d043         	beq	0x700a2dce <_ntoa_long_long+0xee> @ imm = #0x86
700a2d46: e7ff         	b	0x700a2d48 <_ntoa_long_long+0x68> @ imm = #-0x2
;     do {
700a2d48: e7ff         	b	0x700a2d4a <_ntoa_long_long+0x6a> @ imm = #-0x2
;       const char digit = (char)(value % base);
700a2d4a: 9818         	ldr	r0, [sp, #0x60]
700a2d4c: 9919         	ldr	r1, [sp, #0x64]
700a2d4e: 9a14         	ldr	r2, [sp, #0x50]
700a2d50: 9b15         	ldr	r3, [sp, #0x54]
700a2d52: f00c ea48    	blx	0x700af1e4 <__aeabi_uldivmod> @ imm = #0xc490
700a2d56: f88d 202b    	strb.w	r2, [sp, #0x2b]
;       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
700a2d5a: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
700a2d5e: 2809         	cmp	r0, #0x9
700a2d60: dc05         	bgt	0x700a2d6e <_ntoa_long_long+0x8e> @ imm = #0xa
700a2d62: e7ff         	b	0x700a2d64 <_ntoa_long_long+0x84> @ imm = #-0x2
700a2d64: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
700a2d68: 3030         	adds	r0, #0x30
700a2d6a: 9009         	str	r0, [sp, #0x24]
700a2d6c: e00c         	b	0x700a2d88 <_ntoa_long_long+0xa8> @ imm = #0x18
700a2d6e: f89d 00b0    	ldrb.w	r0, [sp, #0xb0]
700a2d72: 0681         	lsls	r1, r0, #0x1a
700a2d74: 2061         	movs	r0, #0x61
700a2d76: 2900         	cmp	r1, #0x0
700a2d78: bf48         	it	mi
700a2d7a: 2041         	movmi	r0, #0x41
700a2d7c: f89d 102b    	ldrb.w	r1, [sp, #0x2b]
700a2d80: 4408         	add	r0, r1
700a2d82: 380a         	subs	r0, #0xa
700a2d84: 9009         	str	r0, [sp, #0x24]
700a2d86: e7ff         	b	0x700a2d88 <_ntoa_long_long+0xa8> @ imm = #-0x2
700a2d88: 9809         	ldr	r0, [sp, #0x24]
700a2d8a: 9a0b         	ldr	r2, [sp, #0x2c]
700a2d8c: 1c51         	adds	r1, r2, #0x1
700a2d8e: 910b         	str	r1, [sp, #0x2c]
700a2d90: a90c         	add	r1, sp, #0x30
700a2d92: 5488         	strb	r0, [r1, r2]
;       value /= base;
700a2d94: 9a14         	ldr	r2, [sp, #0x50]
700a2d96: 9b15         	ldr	r3, [sp, #0x54]
700a2d98: 9818         	ldr	r0, [sp, #0x60]
700a2d9a: 9919         	ldr	r1, [sp, #0x64]
700a2d9c: f00c ea22    	blx	0x700af1e4 <__aeabi_uldivmod> @ imm = #0xc444
700a2da0: 9119         	str	r1, [sp, #0x64]
700a2da2: 9018         	str	r0, [sp, #0x60]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a2da4: e7ff         	b	0x700a2da6 <_ntoa_long_long+0xc6> @ imm = #-0x2
700a2da6: 9818         	ldr	r0, [sp, #0x60]
700a2da8: 9919         	ldr	r1, [sp, #0x64]
700a2daa: 4301         	orrs	r1, r0
700a2dac: 2000         	movs	r0, #0x0
700a2dae: 9008         	str	r0, [sp, #0x20]
700a2db0: b139         	cbz	r1, 0x700a2dc2 <_ntoa_long_long+0xe2> @ imm = #0xe
700a2db2: e7ff         	b	0x700a2db4 <_ntoa_long_long+0xd4> @ imm = #-0x2
700a2db4: 990b         	ldr	r1, [sp, #0x2c]
700a2db6: 2000         	movs	r0, #0x0
700a2db8: 2920         	cmp	r1, #0x20
700a2dba: bf38         	it	lo
700a2dbc: 2001         	movlo	r0, #0x1
700a2dbe: 9008         	str	r0, [sp, #0x20]
700a2dc0: e7ff         	b	0x700a2dc2 <_ntoa_long_long+0xe2> @ imm = #-0x2
700a2dc2: 9808         	ldr	r0, [sp, #0x20]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a2dc4: 07c0         	lsls	r0, r0, #0x1f
700a2dc6: 2800         	cmp	r0, #0x0
700a2dc8: d1bf         	bne	0x700a2d4a <_ntoa_long_long+0x6a> @ imm = #-0x82
700a2dca: e7ff         	b	0x700a2dcc <_ntoa_long_long+0xec> @ imm = #-0x2
;   }
700a2dcc: e7ff         	b	0x700a2dce <_ntoa_long_long+0xee> @ imm = #-0x2
;   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
700a2dce: 981d         	ldr	r0, [sp, #0x74]
700a2dd0: 991c         	ldr	r1, [sp, #0x70]
700a2dd2: 9a1b         	ldr	r2, [sp, #0x6c]
700a2dd4: 9b1a         	ldr	r3, [sp, #0x68]
700a2dd6: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a2dda: 9d14         	ldr	r5, [sp, #0x50]
700a2ddc: 9e2a         	ldr	r6, [sp, #0xa8]
700a2dde: 9f2b         	ldr	r7, [sp, #0xac]
700a2de0: f8dd 80b0    	ldr.w	r8, [sp, #0xb0]
700a2de4: f89d 405f    	ldrb.w	r4, [sp, #0x5f]
700a2de8: 46ee         	mov	lr, sp
700a2dea: f8ce 8018    	str.w	r8, [lr, #0x18]
700a2dee: f8ce 7014    	str.w	r7, [lr, #0x14]
700a2df2: f8ce 6010    	str.w	r6, [lr, #0x10]
700a2df6: f8ce 500c    	str.w	r5, [lr, #0xc]
700a2dfa: f004 0401    	and	r4, r4, #0x1
700a2dfe: f8ce 4008    	str.w	r4, [lr, #0x8]
700a2e02: f8ce c004    	str.w	r12, [lr, #0x4]
700a2e06: f10d 0c30    	add.w	r12, sp, #0x30
700a2e0a: f8ce c000    	str.w	r12, [lr]
700a2e0e: f7fb fdff    	bl	0x7009ea10 <_ntoa_format> @ imm = #-0x4402
700a2e12: b01e         	add	sp, #0x78
700a2e14: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
		...

700a2e20 <Sciclient_rmIrqVintDelete>:
; {
700a2e20: b580         	push	{r7, lr}
700a2e22: b08c         	sub	sp, #0x30
700a2e24: 900b         	str	r0, [sp, #0x2c]
700a2e26: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a2e28: 900a         	str	r0, [sp, #0x28]
;     bool del_mapping = false;
700a2e2a: f88d 0026    	strb.w	r0, [sp, #0x26]
;     bool del_whole_route = false;
700a2e2e: f88d 0025    	strb.w	r0, [sp, #0x25]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a2e32: 9008         	str	r0, [sp, #0x20]
;     if (r == SystemP_SUCCESS) {
700a2e34: 980a         	ldr	r0, [sp, #0x28]
700a2e36: b948         	cbnz	r0, 0x700a2e4c <Sciclient_rmIrqVintDelete+0x2c> @ imm = #0x12
700a2e38: e7ff         	b	0x700a2e3a <Sciclient_rmIrqVintDelete+0x1a> @ imm = #-0x2
;         r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700a2e3a: 990b         	ldr	r1, [sp, #0x2c]
700a2e3c: 8a08         	ldrh	r0, [r1, #0x10]
700a2e3e: 8a49         	ldrh	r1, [r1, #0x12]
700a2e40: f10d 0227    	add.w	r2, sp, #0x27
700a2e44: f008 fbc4    	bl	0x700ab5d0 <Sciclient_rmIaVintGetInfo> @ imm = #0x8788
700a2e48: 900a         	str	r0, [sp, #0x28]
;     }
700a2e4a: e7ff         	b	0x700a2e4c <Sciclient_rmIrqVintDelete+0x2c> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a2e4c: 980a         	ldr	r0, [sp, #0x28]
700a2e4e: b9e8         	cbnz	r0, 0x700a2e8c <Sciclient_rmIrqVintDelete+0x6c> @ imm = #0x3a
700a2e50: e7ff         	b	0x700a2e52 <Sciclient_rmIrqVintDelete+0x32> @ imm = #-0x2
;         if (num_evts == 0u) {
700a2e52: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a2e56: b920         	cbnz	r0, 0x700a2e62 <Sciclient_rmIrqVintDelete+0x42> @ imm = #0x8
700a2e58: e7ff         	b	0x700a2e5a <Sciclient_rmIrqVintDelete+0x3a> @ imm = #-0x2
700a2e5a: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a2e5e: 900a         	str	r0, [sp, #0x28]
;         } else if ((num_evts > 1u) ||
700a2e60: e013         	b	0x700a2e8a <Sciclient_rmIrqVintDelete+0x6a> @ imm = #0x26
700a2e62: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a2e66: 2801         	cmp	r0, #0x1
700a2e68: d806         	bhi	0x700a2e78 <Sciclient_rmIrqVintDelete+0x58> @ imm = #0xc
700a2e6a: e7ff         	b	0x700a2e6c <Sciclient_rmIrqVintDelete+0x4c> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg->valid_params) ==
700a2e6c: 980b         	ldr	r0, [sp, #0x2c]
700a2e6e: 6800         	ldr	r0, [r0]
700a2e70: f008 fd6e    	bl	0x700ab950 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0x8adc
;         } else if ((num_evts > 1u) ||
700a2e74: b120         	cbz	r0, 0x700a2e80 <Sciclient_rmIrqVintDelete+0x60> @ imm = #0x8
700a2e76: e7ff         	b	0x700a2e78 <Sciclient_rmIrqVintDelete+0x58> @ imm = #-0x2
700a2e78: 2001         	movs	r0, #0x1
;             del_mapping = true;
700a2e7a: f88d 0026    	strb.w	r0, [sp, #0x26]
;         } else {
700a2e7e: e003         	b	0x700a2e88 <Sciclient_rmIrqVintDelete+0x68> @ imm = #0x6
700a2e80: 2001         	movs	r0, #0x1
;             del_whole_route = true;
700a2e82: f88d 0025    	strb.w	r0, [sp, #0x25]
700a2e86: e7ff         	b	0x700a2e88 <Sciclient_rmIrqVintDelete+0x68> @ imm = #-0x2
700a2e88: e7ff         	b	0x700a2e8a <Sciclient_rmIrqVintDelete+0x6a> @ imm = #-0x2
;     }
700a2e8a: e7ff         	b	0x700a2e8c <Sciclient_rmIrqVintDelete+0x6c> @ imm = #-0x2
;     if (del_mapping == true) {
700a2e8c: f89d 0026    	ldrb.w	r0, [sp, #0x26]
700a2e90: 07c0         	lsls	r0, r0, #0x1f
700a2e92: 2800         	cmp	r0, #0x0
700a2e94: d049         	beq	0x700a2f2a <Sciclient_rmIrqVintDelete+0x10a> @ imm = #0x92
700a2e96: e7ff         	b	0x700a2e98 <Sciclient_rmIrqVintDelete+0x78> @ imm = #-0x2
700a2e98: 203c         	movs	r0, #0x3c
700a2e9a: f2c8 0000    	movt	r0, #0x8000
;         req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a2e9e: 9003         	str	r0, [sp, #0xc]
;         req.secondary_host = cfg->host;
700a2ea0: 980b         	ldr	r0, [sp, #0x2c]
700a2ea2: 7900         	ldrb	r0, [r0, #0x4]
700a2ea4: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         req.src_id = cfg->s_id;
700a2ea8: 980b         	ldr	r0, [sp, #0x2c]
700a2eaa: 88c0         	ldrh	r0, [r0, #0x6]
700a2eac: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         req.src_index = cfg->s_idx;
700a2eb0: 980b         	ldr	r0, [sp, #0x2c]
700a2eb2: 8900         	ldrh	r0, [r0, #0x8]
700a2eb4: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         req.ia_id = cfg->s_ia;
700a2eb8: 980b         	ldr	r0, [sp, #0x2c]
700a2eba: 8a00         	ldrh	r0, [r0, #0x10]
700a2ebc: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         req.vint = cfg->vint;
700a2ec0: 980b         	ldr	r0, [sp, #0x2c]
700a2ec2: 8a40         	ldrh	r0, [r0, #0x12]
700a2ec4: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         req.global_event = cfg->global_evt;
700a2ec8: 980b         	ldr	r0, [sp, #0x2c]
700a2eca: 89c0         	ldrh	r0, [r0, #0xe]
700a2ecc: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         req.vint_status_bit_index = cfg->vint_sb;
700a2ed0: 980b         	ldr	r0, [sp, #0x2c]
700a2ed2: 7d00         	ldrb	r0, [r0, #0x14]
700a2ed4: f88d 001e    	strb.w	r0, [sp, #0x1e]
700a2ed8: a801         	add	r0, sp, #0x4
700a2eda: f04f 31ff    	mov.w	r1, #0xffffffff
;         r = Sciclient_rmIrqReleaseRaw(&req,
700a2ede: f009 fe87    	bl	0x700acbf0 <Sciclient_rmIrqReleaseRaw> @ imm = #0x9d0e
700a2ee2: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a2ee4: 980a         	ldr	r0, [sp, #0x28]
700a2ee6: b9f8         	cbnz	r0, 0x700a2f28 <Sciclient_rmIrqVintDelete+0x108> @ imm = #0x3e
700a2ee8: e7ff         	b	0x700a2eea <Sciclient_rmIrqVintDelete+0xca> @ imm = #-0x2
;             ia_inst = Sciclient_rmIaGetInst(cfg->s_ia);
700a2eea: 980b         	ldr	r0, [sp, #0x2c]
700a2eec: 8a00         	ldrh	r0, [r0, #0x10]
700a2eee: f009 fb2f    	bl	0x700ac550 <Sciclient_rmIaGetInst> @ imm = #0x965e
700a2ef2: 9008         	str	r0, [sp, #0x20]
;             if (ia_inst != NULL) {
700a2ef4: 9808         	ldr	r0, [sp, #0x20]
700a2ef6: b1b0         	cbz	r0, 0x700a2f26 <Sciclient_rmIrqVintDelete+0x106> @ imm = #0x2c
700a2ef8: e7ff         	b	0x700a2efa <Sciclient_rmIrqVintDelete+0xda> @ imm = #-0x2
;                 ia_inst->vint_usage_count[cfg->vint]--;
700a2efa: 9808         	ldr	r0, [sp, #0x20]
700a2efc: 6901         	ldr	r1, [r0, #0x10]
700a2efe: 980b         	ldr	r0, [sp, #0x2c]
700a2f00: 8a42         	ldrh	r2, [r0, #0x12]
700a2f02: 5c88         	ldrb	r0, [r1, r2]
700a2f04: 3801         	subs	r0, #0x1
700a2f06: 5488         	strb	r0, [r1, r2]
;                 if (ia_inst->v0_b0_evt == cfg->global_evt - ia_inst->sevt_offset) {
700a2f08: 9a08         	ldr	r2, [sp, #0x20]
700a2f0a: 8a90         	ldrh	r0, [r2, #0x14]
700a2f0c: 990b         	ldr	r1, [sp, #0x2c]
700a2f0e: 89c9         	ldrh	r1, [r1, #0xe]
700a2f10: 8912         	ldrh	r2, [r2, #0x8]
700a2f12: 1a89         	subs	r1, r1, r2
700a2f14: 4288         	cmp	r0, r1
700a2f16: d105         	bne	0x700a2f24 <Sciclient_rmIrqVintDelete+0x104> @ imm = #0xa
700a2f18: e7ff         	b	0x700a2f1a <Sciclient_rmIrqVintDelete+0xfa> @ imm = #-0x2
;                     ia_inst->v0_b0_evt = SCICLIENT_RM_IA_GENERIC_EVT_RESETVAL;
700a2f1a: 9908         	ldr	r1, [sp, #0x20]
700a2f1c: f64f 70ff    	movw	r0, #0xffff
700a2f20: 8288         	strh	r0, [r1, #0x14]
;                 }
700a2f22: e7ff         	b	0x700a2f24 <Sciclient_rmIrqVintDelete+0x104> @ imm = #-0x2
;             }
700a2f24: e7ff         	b	0x700a2f26 <Sciclient_rmIrqVintDelete+0x106> @ imm = #-0x2
;         }
700a2f26: e7ff         	b	0x700a2f28 <Sciclient_rmIrqVintDelete+0x108> @ imm = #-0x2
;     }
700a2f28: e7ff         	b	0x700a2f2a <Sciclient_rmIrqVintDelete+0x10a> @ imm = #-0x2
;     if (del_whole_route == true) {
700a2f2a: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a2f2e: 07c0         	lsls	r0, r0, #0x1f
700a2f30: b170         	cbz	r0, 0x700a2f50 <Sciclient_rmIrqVintDelete+0x130> @ imm = #0x1c
700a2f32: e7ff         	b	0x700a2f34 <Sciclient_rmIrqVintDelete+0x114> @ imm = #-0x2
;         r = Sciclient_rmIrqGetRoute(cfg);
700a2f34: 980b         	ldr	r0, [sp, #0x2c]
700a2f36: f7f9 fedb    	bl	0x7009ccf0 <Sciclient_rmIrqGetRoute> @ imm = #-0x624a
700a2f3a: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a2f3c: 980a         	ldr	r0, [sp, #0x28]
700a2f3e: b930         	cbnz	r0, 0x700a2f4e <Sciclient_rmIrqVintDelete+0x12e> @ imm = #0xc
700a2f40: e7ff         	b	0x700a2f42 <Sciclient_rmIrqVintDelete+0x122> @ imm = #-0x2
;             r = Sciclient_rmIrqDeleteRoute(cfg, true);
700a2f42: 980b         	ldr	r0, [sp, #0x2c]
700a2f44: 2101         	movs	r1, #0x1
700a2f46: f7fd fdf3    	bl	0x700a0b30 <Sciclient_rmIrqDeleteRoute> @ imm = #-0x241a
700a2f4a: 900a         	str	r0, [sp, #0x28]
;         }
700a2f4c: e7ff         	b	0x700a2f4e <Sciclient_rmIrqVintDelete+0x12e> @ imm = #-0x2
;     }
700a2f4e: e7ff         	b	0x700a2f50 <Sciclient_rmIrqVintDelete+0x130> @ imm = #-0x2
;     return r;
700a2f50: 980a         	ldr	r0, [sp, #0x28]
700a2f52: b00c         	add	sp, #0x30
700a2f54: bd80         	pop	{r7, pc}
		...
700a2f5e: 0000         	movs	r0, r0

700a2f60 <UART_writePolling>:
; {
700a2f60: b580         	push	{r7, lr}
700a2f62: b08c         	sub	sp, #0x30
700a2f64: 900b         	str	r0, [sp, #0x2c]
700a2f66: 910a         	str	r1, [sp, #0x28]
700a2f68: 2000         	movs	r0, #0x0
;     int32_t             retVal          = UART_TRANSFER_STATUS_SUCCESS;
700a2f6a: 9007         	str	r0, [sp, #0x1c]
;     uint32_t            timeoutElapsed  = FALSE;
700a2f6c: 9006         	str	r0, [sp, #0x18]
;     uint32_t            baseAddr        = hUart->baseAddr;
700a2f6e: 990b         	ldr	r1, [sp, #0x2c]
700a2f70: 6809         	ldr	r1, [r1]
700a2f72: 9105         	str	r1, [sp, #0x14]
;     uint32_t            lineStatus      = 0U;
700a2f74: 9004         	str	r0, [sp, #0x10]
;     hUartInit = hUart->hUartInit;
700a2f76: 980b         	ldr	r0, [sp, #0x2c]
700a2f78: 6840         	ldr	r0, [r0, #0x4]
700a2f7a: 9003         	str	r0, [sp, #0xc]
;     hUart->writeSizeRemaining = trans->count;
700a2f7c: 980a         	ldr	r0, [sp, #0x28]
700a2f7e: 6840         	ldr	r0, [r0, #0x4]
700a2f80: 990b         	ldr	r1, [sp, #0x2c]
700a2f82: 6108         	str	r0, [r1, #0x10]
;     startTicks = hUartInit->clockP_get();
700a2f84: 9803         	ldr	r0, [sp, #0xc]
700a2f86: 6d40         	ldr	r0, [r0, #0x54]
700a2f88: 4780         	blx	r0
700a2f8a: 9009         	str	r0, [sp, #0x24]
;     while ((FALSE == timeoutElapsed)
700a2f8c: e7ff         	b	0x700a2f8e <UART_writePolling+0x2e> @ imm = #-0x2
700a2f8e: 9906         	ldr	r1, [sp, #0x18]
700a2f90: 2000         	movs	r0, #0x0
;            && (0U != hUart->writeSizeRemaining))
700a2f92: 9002         	str	r0, [sp, #0x8]
700a2f94: b939         	cbnz	r1, 0x700a2fa6 <UART_writePolling+0x46> @ imm = #0xe
700a2f96: e7ff         	b	0x700a2f98 <UART_writePolling+0x38> @ imm = #-0x2
700a2f98: 980b         	ldr	r0, [sp, #0x2c]
700a2f9a: 6900         	ldr	r0, [r0, #0x10]
700a2f9c: 2800         	cmp	r0, #0x0
700a2f9e: bf18         	it	ne
700a2fa0: 2001         	movne	r0, #0x1
700a2fa2: 9002         	str	r0, [sp, #0x8]
700a2fa4: e7ff         	b	0x700a2fa6 <UART_writePolling+0x46> @ imm = #-0x2
700a2fa6: 9802         	ldr	r0, [sp, #0x8]
;     while ((FALSE == timeoutElapsed)
700a2fa8: 07c0         	lsls	r0, r0, #0x1f
700a2faa: b198         	cbz	r0, 0x700a2fd4 <UART_writePolling+0x74> @ imm = #0x26
700a2fac: e7ff         	b	0x700a2fae <UART_writePolling+0x4e> @ imm = #-0x2
;         UART_writeDataPolling(hUart);
700a2fae: 980b         	ldr	r0, [sp, #0x2c]
700a2fb0: f00b f9ee    	bl	0x700ae390 <UART_writeDataPolling> @ imm = #0xb3dc
;         elapsedTicks = hUartInit->clockP_get() - startTicks;
700a2fb4: 9803         	ldr	r0, [sp, #0xc]
700a2fb6: 6d40         	ldr	r0, [r0, #0x54]
700a2fb8: 4780         	blx	r0
700a2fba: 9909         	ldr	r1, [sp, #0x24]
700a2fbc: 1a40         	subs	r0, r0, r1
700a2fbe: 9008         	str	r0, [sp, #0x20]
;         if (elapsedTicks >= trans->timeout)
700a2fc0: 9808         	ldr	r0, [sp, #0x20]
700a2fc2: 990a         	ldr	r1, [sp, #0x28]
700a2fc4: 6889         	ldr	r1, [r1, #0x8]
700a2fc6: 4288         	cmp	r0, r1
700a2fc8: d303         	blo	0x700a2fd2 <UART_writePolling+0x72> @ imm = #0x6
700a2fca: e7ff         	b	0x700a2fcc <UART_writePolling+0x6c> @ imm = #-0x2
700a2fcc: 2001         	movs	r0, #0x1
;             timeoutElapsed = TRUE;
700a2fce: 9006         	str	r0, [sp, #0x18]
;         }
700a2fd0: e7ff         	b	0x700a2fd2 <UART_writePolling+0x72> @ imm = #-0x2
;     while ((FALSE == timeoutElapsed)
700a2fd2: e7dc         	b	0x700a2f8e <UART_writePolling+0x2e> @ imm = #-0x48
;     if (0U == hUart->writeSizeRemaining)
700a2fd4: 980b         	ldr	r0, [sp, #0x2c]
700a2fd6: 6900         	ldr	r0, [r0, #0x10]
700a2fd8: 2800         	cmp	r0, #0x0
700a2fda: d149         	bne	0x700a3070 <UART_writePolling+0x110> @ imm = #0x92
700a2fdc: e7ff         	b	0x700a2fde <UART_writePolling+0x7e> @ imm = #-0x2
;         do
700a2fde: e7ff         	b	0x700a2fe0 <UART_writePolling+0x80> @ imm = #-0x2
;             lineStatus = UART_readLineStatus(baseAddr);
700a2fe0: 9805         	ldr	r0, [sp, #0x14]
700a2fe2: f00a fc65    	bl	0x700ad8b0 <UART_readLineStatus> @ imm = #0xa8ca
700a2fe6: 9004         	str	r0, [sp, #0x10]
;             elapsedTicks = hUartInit->clockP_get() - startTicks;
700a2fe8: 9803         	ldr	r0, [sp, #0xc]
700a2fea: 6d40         	ldr	r0, [r0, #0x54]
700a2fec: 4780         	blx	r0
700a2fee: 9909         	ldr	r1, [sp, #0x24]
700a2ff0: 1a40         	subs	r0, r0, r1
700a2ff2: 9008         	str	r0, [sp, #0x20]
;         }
700a2ff4: e7ff         	b	0x700a2ff6 <UART_writePolling+0x96> @ imm = #-0x2
;                (lineStatus & (uint32_t) (UART_LSR_TX_FIFO_E_MASK |
700a2ff6: 9804         	ldr	r0, [sp, #0x10]
700a2ff8: f000 0160    	and	r1, r0, #0x60
700a2ffc: 2000         	movs	r0, #0x0
;                 && (elapsedTicks < hUart->lineStatusTimeout));
700a2ffe: 2960         	cmp	r1, #0x60
700a3000: 9001         	str	r0, [sp, #0x4]
700a3002: d00d         	beq	0x700a3020 <UART_writePolling+0xc0> @ imm = #0x1a
700a3004: e7ff         	b	0x700a3006 <UART_writePolling+0xa6> @ imm = #-0x2
700a3006: 9808         	ldr	r0, [sp, #0x20]
700a3008: 990b         	ldr	r1, [sp, #0x2c]
700a300a: 6e8a         	ldr	r2, [r1, #0x68]
700a300c: 6ec9         	ldr	r1, [r1, #0x6c]
700a300e: 1a80         	subs	r0, r0, r2
700a3010: f04f 0000    	mov.w	r0, #0x0
700a3014: eb70 0101    	sbcs.w	r1, r0, r1
700a3018: bf38         	it	lo
700a301a: 2001         	movlo	r0, #0x1
700a301c: 9001         	str	r0, [sp, #0x4]
700a301e: e7ff         	b	0x700a3020 <UART_writePolling+0xc0> @ imm = #-0x2
700a3020: 9801         	ldr	r0, [sp, #0x4]
;         }
700a3022: 07c0         	lsls	r0, r0, #0x1f
700a3024: 2800         	cmp	r0, #0x0
700a3026: d1db         	bne	0x700a2fe0 <UART_writePolling+0x80> @ imm = #-0x4a
700a3028: e7ff         	b	0x700a302a <UART_writePolling+0xca> @ imm = #-0x2
;         if(elapsedTicks >= hUart->lineStatusTimeout)
700a302a: 9808         	ldr	r0, [sp, #0x20]
700a302c: 990b         	ldr	r1, [sp, #0x2c]
700a302e: 6e8a         	ldr	r2, [r1, #0x68]
700a3030: 6ec9         	ldr	r1, [r1, #0x6c]
700a3032: 1a80         	subs	r0, r0, r2
700a3034: f04f 0000    	mov.w	r0, #0x0
700a3038: 4188         	sbcs	r0, r1
700a303a: d30f         	blo	0x700a305c <UART_writePolling+0xfc> @ imm = #0x1e
700a303c: e7ff         	b	0x700a303e <UART_writePolling+0xde> @ imm = #-0x2
700a303e: f06f 0001    	mvn	r0, #0x1
;             retVal             = UART_TRANSFER_TIMEOUT;
700a3042: 9007         	str	r0, [sp, #0x1c]
;             trans->status      = UART_TRANSFER_STATUS_TIMEOUT;
700a3044: 990a         	ldr	r1, [sp, #0x28]
700a3046: 2001         	movs	r0, #0x1
700a3048: 60c8         	str	r0, [r1, #0xc]
;             trans->count       = hUart->writeCount;
700a304a: 980b         	ldr	r0, [sp, #0x2c]
700a304c: 68c0         	ldr	r0, [r0, #0xc]
700a304e: 990a         	ldr	r1, [sp, #0x28]
700a3050: 6048         	str	r0, [r1, #0x4]
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a3052: 980b         	ldr	r0, [sp, #0x2c]
700a3054: 303c         	adds	r0, #0x3c
700a3056: f00c fa1b    	bl	0x700af490 <UART_lld_Transaction_deInit> @ imm = #0xc436
;         }
700a305a: e008         	b	0x700a306e <UART_writePolling+0x10e> @ imm = #0x10
700a305c: 2000         	movs	r0, #0x0
;             retVal             = UART_TRANSFER_STATUS_SUCCESS;
700a305e: 9007         	str	r0, [sp, #0x1c]
;             trans->status      = UART_TRANSFER_STATUS_SUCCESS;
700a3060: 990a         	ldr	r1, [sp, #0x28]
700a3062: 60c8         	str	r0, [r1, #0xc]
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a3064: 980b         	ldr	r0, [sp, #0x2c]
700a3066: 303c         	adds	r0, #0x3c
700a3068: f00c fa12    	bl	0x700af490 <UART_lld_Transaction_deInit> @ imm = #0xc424
700a306c: e7ff         	b	0x700a306e <UART_writePolling+0x10e> @ imm = #-0x2
;     }
700a306e: e00e         	b	0x700a308e <UART_writePolling+0x12e> @ imm = #0x1c
700a3070: f06f 0001    	mvn	r0, #0x1
;         retVal             = UART_TRANSFER_TIMEOUT;
700a3074: 9007         	str	r0, [sp, #0x1c]
;         trans->status      = UART_TRANSFER_STATUS_TIMEOUT;
700a3076: 990a         	ldr	r1, [sp, #0x28]
700a3078: 2001         	movs	r0, #0x1
700a307a: 60c8         	str	r0, [r1, #0xc]
;         trans->count       = hUart->writeCount;
700a307c: 980b         	ldr	r0, [sp, #0x2c]
700a307e: 68c0         	ldr	r0, [r0, #0xc]
700a3080: 990a         	ldr	r1, [sp, #0x28]
700a3082: 6048         	str	r0, [r1, #0x4]
;         UART_lld_Transaction_deInit(&hUart->writeTrans);
700a3084: 980b         	ldr	r0, [sp, #0x2c]
700a3086: 303c         	adds	r0, #0x3c
700a3088: f00c fa02    	bl	0x700af490 <UART_lld_Transaction_deInit> @ imm = #0xc404
700a308c: e7ff         	b	0x700a308e <UART_writePolling+0x12e> @ imm = #-0x2
;     return (retVal);
700a308e: 9807         	ldr	r0, [sp, #0x1c]
700a3090: b00c         	add	sp, #0x30
700a3092: bd80         	pop	{r7, pc}
		...

700a30a0 <Sciclient_recvMessage>:
; {
700a30a0: b580         	push	{r7, lr}
700a30a2: b08e         	sub	sp, #0x38
700a30a4: 900d         	str	r0, [sp, #0x34]
700a30a6: 910c         	str	r1, [sp, #0x30]
700a30a8: 920b         	str	r2, [sp, #0x2c]
700a30aa: 2000         	movs	r0, #0x0
;     uint8_t  trailBytes = 0U;
700a30ac: f88d 0023    	strb.w	r0, [sp, #0x23]
;     numWords   = (uint32_t) (rxPayloadSize / 4U);
700a30b0: 990b         	ldr	r1, [sp, #0x2c]
700a30b2: ea4f 0191    	lsr.w	r1, r1, #0x2
700a30b6: 910a         	str	r1, [sp, #0x28]
;     trailBytes = (uint8_t) (rxPayloadSize - (numWords * 4U));
700a30b8: 990b         	ldr	r1, [sp, #0x2c]
700a30ba: 9a0a         	ldr	r2, [sp, #0x28]
700a30bc: eba1 0182    	sub.w	r1, r1, r2, lsl #2
700a30c0: f88d 1023    	strb.w	r1, [sp, #0x23]
;     for (i = 0; i < numWords; i++)
700a30c4: 9009         	str	r0, [sp, #0x24]
700a30c6: e7ff         	b	0x700a30c8 <Sciclient_recvMessage+0x28> @ imm = #-0x2
700a30c8: 9809         	ldr	r0, [sp, #0x24]
700a30ca: 990a         	ldr	r1, [sp, #0x28]
700a30cc: 4288         	cmp	r0, r1
700a30ce: d22c         	bhs	0x700a312a <Sciclient_recvMessage+0x8a> @ imm = #0x58
700a30d0: e7ff         	b	0x700a30d2 <Sciclient_recvMessage+0x32> @ imm = #-0x2
;             rxThread,
700a30d2: 980d         	ldr	r0, [sp, #0x34]
;             ((uint8_t) i +
700a30d4: 9909         	ldr	r1, [sp, #0x24]
;                 SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a30d6: f642 2264    	movw	r2, #0x2a64
700a30da: f2c7 020b    	movt	r2, #0x700b
700a30de: 7812         	ldrb	r2, [r2]
;             ((uint8_t) i +
700a30e0: 4411         	add	r1, r2
;                 SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a30e2: 3102         	adds	r1, #0x2
;         uint32_t tempWord = Sciclient_secProxyReadThread32(
700a30e4: b2c9         	uxtb	r1, r1
700a30e6: f00b fc4b    	bl	0x700ae980 <Sciclient_secProxyReadThread32> @ imm = #0xb896
700a30ea: 9007         	str	r0, [sp, #0x1c]
700a30ec: a807         	add	r0, sp, #0x1c
;         uint8_t * tempWordPtr = (uint8_t*) & tempWord;
700a30ee: 9006         	str	r0, [sp, #0x18]
700a30f0: 2000         	movs	r0, #0x0
;         uint32_t j = 0U;
700a30f2: 9005         	str	r0, [sp, #0x14]
;         for (j = 0U; j < 4U; j++)
700a30f4: 9005         	str	r0, [sp, #0x14]
700a30f6: e7ff         	b	0x700a30f8 <Sciclient_recvMessage+0x58> @ imm = #-0x2
700a30f8: 9805         	ldr	r0, [sp, #0x14]
700a30fa: 2803         	cmp	r0, #0x3
700a30fc: d810         	bhi	0x700a3120 <Sciclient_recvMessage+0x80> @ imm = #0x20
700a30fe: e7ff         	b	0x700a3100 <Sciclient_recvMessage+0x60> @ imm = #-0x2
;             *(pLocalRespPayload + i * 4 + j) = *tempWordPtr;
700a3100: 9806         	ldr	r0, [sp, #0x18]
700a3102: 7800         	ldrb	r0, [r0]
700a3104: 990c         	ldr	r1, [sp, #0x30]
700a3106: 9a09         	ldr	r2, [sp, #0x24]
700a3108: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a310c: 9a05         	ldr	r2, [sp, #0x14]
700a310e: 5488         	strb	r0, [r1, r2]
;             tempWordPtr++;
700a3110: 9806         	ldr	r0, [sp, #0x18]
700a3112: 3001         	adds	r0, #0x1
700a3114: 9006         	str	r0, [sp, #0x18]
;         }
700a3116: e7ff         	b	0x700a3118 <Sciclient_recvMessage+0x78> @ imm = #-0x2
;         for (j = 0U; j < 4U; j++)
700a3118: 9805         	ldr	r0, [sp, #0x14]
700a311a: 3001         	adds	r0, #0x1
700a311c: 9005         	str	r0, [sp, #0x14]
700a311e: e7eb         	b	0x700a30f8 <Sciclient_recvMessage+0x58> @ imm = #-0x2a
;     }
700a3120: e7ff         	b	0x700a3122 <Sciclient_recvMessage+0x82> @ imm = #-0x2
;     for (i = 0; i < numWords; i++)
700a3122: 9809         	ldr	r0, [sp, #0x24]
700a3124: 3001         	adds	r0, #0x1
700a3126: 9009         	str	r0, [sp, #0x24]
700a3128: e7ce         	b	0x700a30c8 <Sciclient_recvMessage+0x28> @ imm = #-0x64
;     if (trailBytes > 0U)
700a312a: f89d 0023    	ldrb.w	r0, [sp, #0x23]
700a312e: b368         	cbz	r0, 0x700a318c <Sciclient_recvMessage+0xec> @ imm = #0x5a
700a3130: e7ff         	b	0x700a3132 <Sciclient_recvMessage+0x92> @ imm = #-0x2
;                 rxThread,
700a3132: 980d         	ldr	r0, [sp, #0x34]
;                 ((uint8_t)i +
700a3134: 9909         	ldr	r1, [sp, #0x24]
;                     SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a3136: f642 2264    	movw	r2, #0x2a64
700a313a: f2c7 020b    	movt	r2, #0x700b
700a313e: 7812         	ldrb	r2, [r2]
;                 ((uint8_t)i +
700a3140: 4411         	add	r1, r2
;                     SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a3142: 3102         	adds	r1, #0x2
;         uint32_t tempWord = Sciclient_secProxyReadThread32(
700a3144: b2c9         	uxtb	r1, r1
700a3146: f00b fc1b    	bl	0x700ae980 <Sciclient_secProxyReadThread32> @ imm = #0xb836
700a314a: 9004         	str	r0, [sp, #0x10]
700a314c: a804         	add	r0, sp, #0x10
;         uint8_t * pTempWord = (uint8_t*) &tempWord;
700a314e: 9003         	str	r0, [sp, #0xc]
700a3150: 2000         	movs	r0, #0x0
;         for (bytes = 0U; bytes < trailBytes; bytes++)
700a3152: 9002         	str	r0, [sp, #0x8]
700a3154: e7ff         	b	0x700a3156 <Sciclient_recvMessage+0xb6> @ imm = #-0x2
700a3156: 9802         	ldr	r0, [sp, #0x8]
700a3158: f89d 1023    	ldrb.w	r1, [sp, #0x23]
700a315c: 4288         	cmp	r0, r1
700a315e: d214         	bhs	0x700a318a <Sciclient_recvMessage+0xea> @ imm = #0x28
700a3160: e7ff         	b	0x700a3162 <Sciclient_recvMessage+0xc2> @ imm = #-0x2
;             uint8_t * address = (uint8_t*)pLocalRespPayload;
700a3162: 980c         	ldr	r0, [sp, #0x30]
700a3164: 9001         	str	r0, [sp, #0x4]
;             uint8_t value = *(uint8_t*)(pTempWord + bytes);
700a3166: 9803         	ldr	r0, [sp, #0xc]
700a3168: 9902         	ldr	r1, [sp, #0x8]
700a316a: 5c40         	ldrb	r0, [r0, r1]
700a316c: f88d 0003    	strb.w	r0, [sp, #0x3]
;             *(uint8_t*)(address + i*4 + bytes) = value;
700a3170: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a3174: 9901         	ldr	r1, [sp, #0x4]
700a3176: 9a09         	ldr	r2, [sp, #0x24]
700a3178: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a317c: 9a02         	ldr	r2, [sp, #0x8]
700a317e: 5488         	strb	r0, [r1, r2]
;         }
700a3180: e7ff         	b	0x700a3182 <Sciclient_recvMessage+0xe2> @ imm = #-0x2
;         for (bytes = 0U; bytes < trailBytes; bytes++)
700a3182: 9802         	ldr	r0, [sp, #0x8]
700a3184: 3001         	adds	r0, #0x1
700a3186: 9002         	str	r0, [sp, #0x8]
700a3188: e7e5         	b	0x700a3156 <Sciclient_recvMessage+0xb6> @ imm = #-0x36
;     }
700a318a: e7ff         	b	0x700a318c <Sciclient_recvMessage+0xec> @ imm = #-0x2
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a318c: f642 2064    	movw	r0, #0x2a64
700a3190: f2c7 000b    	movt	r0, #0x700b
700a3194: 7801         	ldrb	r1, [r0]
;         rxPayloadSize) <=
700a3196: 980b         	ldr	r0, [sp, #0x2c]
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a3198: eb00 0081    	add.w	r0, r0, r1, lsl #2
;         (SCICLIENT_HEADER_SIZE_IN_WORDS*4U) +
700a319c: 3008         	adds	r0, #0x8
;         (gSciclientHandle.maxMsgSizeBytes - 4U))
700a319e: f642 1158    	movw	r1, #0x2958
700a31a2: f2c7 010b    	movt	r1, #0x700b
700a31a6: 6949         	ldr	r1, [r1, #0x14]
700a31a8: 3904         	subs	r1, #0x4
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a31aa: 4288         	cmp	r0, r1
700a31ac: d80e         	bhi	0x700a31cc <Sciclient_recvMessage+0x12c> @ imm = #0x1c
700a31ae: e7ff         	b	0x700a31b0 <Sciclient_recvMessage+0x110> @ imm = #-0x2
;         (void) Sciclient_secProxyReadThread32(rxThread,
700a31b0: 980d         	ldr	r0, [sp, #0x34]
;                         (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U) - 1U));
700a31b2: f642 1158    	movw	r1, #0x2958
700a31b6: f2c7 010b    	movt	r1, #0x700b
700a31ba: 694a         	ldr	r2, [r1, #0x14]
700a31bc: f04f 31ff    	mov.w	r1, #0xffffffff
700a31c0: eb01 0192    	add.w	r1, r1, r2, lsr #2
;         (void) Sciclient_secProxyReadThread32(rxThread,
700a31c4: b2c9         	uxtb	r1, r1
700a31c6: f00b fbdb    	bl	0x700ae980 <Sciclient_secProxyReadThread32> @ imm = #0xb7b6
;     }
700a31ca: e7ff         	b	0x700a31cc <Sciclient_recvMessage+0x12c> @ imm = #-0x2
; }
700a31cc: b00e         	add	sp, #0x38
700a31ce: bd80         	pop	{r7, pc}

700a31d0 <Udma_rmAllocIrIntr>:
; {
700a31d0: b580         	push	{r7, lr}
700a31d2: b088         	sub	sp, #0x20
700a31d4: 9007         	str	r0, [sp, #0x1c]
700a31d6: 9106         	str	r1, [sp, #0x18]
700a31d8: 2000         	movs	r0, #0x0
700a31da: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            irIntrNum = UDMA_INTR_INVALID;
700a31de: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a31e0: 9806         	ldr	r0, [sp, #0x18]
700a31e2: f500 70ea    	add.w	r0, r0, #0x1d4
700a31e6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a31e8: 9806         	ldr	r0, [sp, #0x18]
700a31ea: f500 609f    	add.w	r0, r0, #0x4f8
700a31ee: f04f 31ff    	mov.w	r1, #0xffffffff
700a31f2: f007 faf5    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x75ea
;     if(UDMA_CORE_INTR_ANY == preferredIrIntrNum)
700a31f6: 9807         	ldr	r0, [sp, #0x1c]
700a31f8: 2101         	movs	r1, #0x1
700a31fa: f6cf 71ff    	movt	r1, #0xffff
700a31fe: 4288         	cmp	r0, r1
700a3200: d138         	bne	0x700a3274 <Udma_rmAllocIrIntr+0xa4> @ imm = #0x70
700a3202: e7ff         	b	0x700a3204 <Udma_rmAllocIrIntr+0x34> @ imm = #-0x2
700a3204: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numIrIntr; i++)
700a3206: 9005         	str	r0, [sp, #0x14]
700a3208: e7ff         	b	0x700a320a <Udma_rmAllocIrIntr+0x3a> @ imm = #-0x2
700a320a: 9805         	ldr	r0, [sp, #0x14]
700a320c: 9900         	ldr	r1, [sp]
700a320e: f8d1 10ec    	ldr.w	r1, [r1, #0xec]
700a3212: 4288         	cmp	r0, r1
700a3214: d22d         	bhs	0x700a3272 <Udma_rmAllocIrIntr+0xa2> @ imm = #0x5a
700a3216: e7ff         	b	0x700a3218 <Udma_rmAllocIrIntr+0x48> @ imm = #-0x2
;             offset = i >> 5U;
700a3218: 9805         	ldr	r0, [sp, #0x14]
700a321a: 0940         	lsrs	r0, r0, #0x5
700a321c: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a321e: 9805         	ldr	r0, [sp, #0x14]
700a3220: 9904         	ldr	r1, [sp, #0x10]
700a3222: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3226: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3228: 9903         	ldr	r1, [sp, #0xc]
700a322a: 2001         	movs	r0, #0x1
700a322c: 4088         	lsls	r0, r1
700a322e: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->irIntrFlag[offset] & bitMask) == bitMask)
700a3230: 9806         	ldr	r0, [sp, #0x18]
700a3232: 9904         	ldr	r1, [sp, #0x10]
700a3234: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3238: f8d0 04e4    	ldr.w	r0, [r0, #0x4e4]
700a323c: 9902         	ldr	r1, [sp, #0x8]
700a323e: 4008         	ands	r0, r1
700a3240: 4288         	cmp	r0, r1
700a3242: d111         	bne	0x700a3268 <Udma_rmAllocIrIntr+0x98> @ imm = #0x22
700a3244: e7ff         	b	0x700a3246 <Udma_rmAllocIrIntr+0x76> @ imm = #-0x2
;                 drvHandle->irIntrFlag[offset] &= ~bitMask;
700a3246: 9a02         	ldr	r2, [sp, #0x8]
700a3248: 9806         	ldr	r0, [sp, #0x18]
700a324a: 9904         	ldr	r1, [sp, #0x10]
700a324c: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3250: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a3254: 4390         	bics	r0, r2
700a3256: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;                 irIntrNum = i + rmInitPrms->startIrIntr;    /* Add start offset */
700a325a: 9805         	ldr	r0, [sp, #0x14]
700a325c: 9900         	ldr	r1, [sp]
700a325e: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a3262: 4408         	add	r0, r1
700a3264: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3266: e004         	b	0x700a3272 <Udma_rmAllocIrIntr+0xa2> @ imm = #0x8
;         }
700a3268: e7ff         	b	0x700a326a <Udma_rmAllocIrIntr+0x9a> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numIrIntr; i++)
700a326a: 9805         	ldr	r0, [sp, #0x14]
700a326c: 3001         	adds	r0, #0x1
700a326e: 9005         	str	r0, [sp, #0x14]
700a3270: e7cb         	b	0x700a320a <Udma_rmAllocIrIntr+0x3a> @ imm = #-0x6a
;     }
700a3272: e03c         	b	0x700a32ee <Udma_rmAllocIrIntr+0x11e> @ imm = #0x78
;         if((preferredIrIntrNum >= rmInitPrms->startIrIntr) &&
700a3274: 9807         	ldr	r0, [sp, #0x1c]
700a3276: 9900         	ldr	r1, [sp]
700a3278: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a327c: 4288         	cmp	r0, r1
700a327e: d335         	blo	0x700a32ec <Udma_rmAllocIrIntr+0x11c> @ imm = #0x6a
700a3280: e7ff         	b	0x700a3282 <Udma_rmAllocIrIntr+0xb2> @ imm = #-0x2
;            (preferredIrIntrNum < (rmInitPrms->startIrIntr + rmInitPrms->numIrIntr)))
700a3282: 9807         	ldr	r0, [sp, #0x1c]
700a3284: 9a00         	ldr	r2, [sp]
700a3286: f8d2 10e8    	ldr.w	r1, [r2, #0xe8]
700a328a: f8d2 20ec    	ldr.w	r2, [r2, #0xec]
700a328e: 4411         	add	r1, r2
;         if((preferredIrIntrNum >= rmInitPrms->startIrIntr) &&
700a3290: 4288         	cmp	r0, r1
700a3292: d22b         	bhs	0x700a32ec <Udma_rmAllocIrIntr+0x11c> @ imm = #0x56
700a3294: e7ff         	b	0x700a3296 <Udma_rmAllocIrIntr+0xc6> @ imm = #-0x2
;             i = preferredIrIntrNum - rmInitPrms->startIrIntr;
700a3296: 9807         	ldr	r0, [sp, #0x1c]
700a3298: 9900         	ldr	r1, [sp]
700a329a: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a329e: 1a40         	subs	r0, r0, r1
700a32a0: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a32a2: 9805         	ldr	r0, [sp, #0x14]
700a32a4: 0940         	lsrs	r0, r0, #0x5
700a32a6: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a32a8: 9805         	ldr	r0, [sp, #0x14]
700a32aa: 9904         	ldr	r1, [sp, #0x10]
700a32ac: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a32b0: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a32b2: 9903         	ldr	r1, [sp, #0xc]
700a32b4: 2001         	movs	r0, #0x1
700a32b6: 4088         	lsls	r0, r1
700a32b8: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->irIntrFlag[offset] & bitMask) == bitMask)
700a32ba: 9806         	ldr	r0, [sp, #0x18]
700a32bc: 9904         	ldr	r1, [sp, #0x10]
700a32be: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a32c2: f8d0 04e4    	ldr.w	r0, [r0, #0x4e4]
700a32c6: 9902         	ldr	r1, [sp, #0x8]
700a32c8: 4008         	ands	r0, r1
700a32ca: 4288         	cmp	r0, r1
700a32cc: d10d         	bne	0x700a32ea <Udma_rmAllocIrIntr+0x11a> @ imm = #0x1a
700a32ce: e7ff         	b	0x700a32d0 <Udma_rmAllocIrIntr+0x100> @ imm = #-0x2
;                 drvHandle->irIntrFlag[offset] &= ~bitMask;
700a32d0: 9a02         	ldr	r2, [sp, #0x8]
700a32d2: 9806         	ldr	r0, [sp, #0x18]
700a32d4: 9904         	ldr	r1, [sp, #0x10]
700a32d6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a32da: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a32de: 4390         	bics	r0, r2
700a32e0: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;                 irIntrNum = preferredIrIntrNum;
700a32e4: 9807         	ldr	r0, [sp, #0x1c]
700a32e6: 9001         	str	r0, [sp, #0x4]
;             }
700a32e8: e7ff         	b	0x700a32ea <Udma_rmAllocIrIntr+0x11a> @ imm = #-0x2
;         }
700a32ea: e7ff         	b	0x700a32ec <Udma_rmAllocIrIntr+0x11c> @ imm = #-0x2
700a32ec: e7ff         	b	0x700a32ee <Udma_rmAllocIrIntr+0x11e> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a32ee: 9806         	ldr	r0, [sp, #0x18]
700a32f0: f500 609f    	add.w	r0, r0, #0x4f8
700a32f4: f008 fe04    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x8c08
;     return (irIntrNum);
700a32f8: 9801         	ldr	r0, [sp, #0x4]
700a32fa: b008         	add	sp, #0x20
700a32fc: bd80         	pop	{r7, pc}
700a32fe: 0000         	movs	r0, r0

700a3300 <xQueueGenericSend>:
; {
700a3300: b580         	push	{r7, lr}
700a3302: b08a         	sub	sp, #0x28
700a3304: 9008         	str	r0, [sp, #0x20]
700a3306: 9107         	str	r1, [sp, #0x1c]
700a3308: 9206         	str	r2, [sp, #0x18]
700a330a: 9305         	str	r3, [sp, #0x14]
700a330c: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
700a330e: 9004         	str	r0, [sp, #0x10]
;     Queue_t * const pxQueue = xQueue;
700a3310: 9808         	ldr	r0, [sp, #0x20]
700a3312: 9000         	str	r0, [sp]
;     for( ; ; )
700a3314: e7ff         	b	0x700a3316 <xQueueGenericSend+0x16> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a3316: f00b fa33    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0xb466
;             if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
700a331a: 9800         	ldr	r0, [sp]
700a331c: 6b80         	ldr	r0, [r0, #0x38]
700a331e: 9900         	ldr	r1, [sp]
700a3320: 6bc9         	ldr	r1, [r1, #0x3c]
700a3322: 4288         	cmp	r0, r1
700a3324: d304         	blo	0x700a3330 <xQueueGenericSend+0x30> @ imm = #0x8
700a3326: e7ff         	b	0x700a3328 <xQueueGenericSend+0x28> @ imm = #-0x2
700a3328: 9805         	ldr	r0, [sp, #0x14]
700a332a: 2802         	cmp	r0, #0x2
700a332c: d120         	bne	0x700a3370 <xQueueGenericSend+0x70> @ imm = #0x40
700a332e: e7ff         	b	0x700a3330 <xQueueGenericSend+0x30> @ imm = #-0x2
;                         xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
700a3330: 9800         	ldr	r0, [sp]
700a3332: 9907         	ldr	r1, [sp, #0x1c]
700a3334: 9a05         	ldr	r2, [sp, #0x14]
700a3336: f003 fc6b    	bl	0x700a6c10 <prvCopyDataToQueue> @ imm = #0x38d6
700a333a: 9003         	str	r0, [sp, #0xc]
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a333c: 9800         	ldr	r0, [sp]
700a333e: 6a40         	ldr	r0, [r0, #0x24]
700a3340: b150         	cbz	r0, 0x700a3358 <xQueueGenericSend+0x58> @ imm = #0x14
700a3342: e7ff         	b	0x700a3344 <xQueueGenericSend+0x44> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a3344: 9800         	ldr	r0, [sp]
700a3346: 3024         	adds	r0, #0x24
700a3348: f004 fbe2    	bl	0x700a7b10 <xTaskRemoveFromEventList> @ imm = #0x47c4
700a334c: b110         	cbz	r0, 0x700a3354 <xQueueGenericSend+0x54> @ imm = #0x4
700a334e: e7ff         	b	0x700a3350 <xQueueGenericSend+0x50> @ imm = #-0x2
;                                 queueYIELD_IF_USING_PREEMPTION();
700a3350: df00         	svc	#0x0
;                             }
700a3352: e000         	b	0x700a3356 <xQueueGenericSend+0x56> @ imm = #0x0
700a3354: e7ff         	b	0x700a3356 <xQueueGenericSend+0x56> @ imm = #-0x2
;                         }
700a3356: e006         	b	0x700a3366 <xQueueGenericSend+0x66> @ imm = #0xc
;                         else if( xYieldRequired != pdFALSE )
700a3358: 9803         	ldr	r0, [sp, #0xc]
700a335a: b110         	cbz	r0, 0x700a3362 <xQueueGenericSend+0x62> @ imm = #0x4
700a335c: e7ff         	b	0x700a335e <xQueueGenericSend+0x5e> @ imm = #-0x2
;                             queueYIELD_IF_USING_PREEMPTION();
700a335e: df00         	svc	#0x0
;                         }
700a3360: e000         	b	0x700a3364 <xQueueGenericSend+0x64> @ imm = #0x0
700a3362: e7ff         	b	0x700a3364 <xQueueGenericSend+0x64> @ imm = #-0x2
700a3364: e7ff         	b	0x700a3366 <xQueueGenericSend+0x66> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a3366: f00a facb    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xa596
700a336a: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a336c: 9009         	str	r0, [sp, #0x24]
700a336e: e05b         	b	0x700a3428 <xQueueGenericSend+0x128> @ imm = #0xb6
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a3370: 9806         	ldr	r0, [sp, #0x18]
700a3372: b928         	cbnz	r0, 0x700a3380 <xQueueGenericSend+0x80> @ imm = #0xa
700a3374: e7ff         	b	0x700a3376 <xQueueGenericSend+0x76> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a3376: f00a fac3    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xa586
700a337a: 2000         	movs	r0, #0x0
;                     return errQUEUE_FULL;
700a337c: 9009         	str	r0, [sp, #0x24]
700a337e: e053         	b	0x700a3428 <xQueueGenericSend+0x128> @ imm = #0xa6
;                 else if( xEntryTimeSet == pdFALSE )
700a3380: 9804         	ldr	r0, [sp, #0x10]
700a3382: b930         	cbnz	r0, 0x700a3392 <xQueueGenericSend+0x92> @ imm = #0xc
700a3384: e7ff         	b	0x700a3386 <xQueueGenericSend+0x86> @ imm = #-0x2
700a3386: a801         	add	r0, sp, #0x4
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a3388: f00b ff72    	bl	0x700af270 <vTaskInternalSetTimeOutState> @ imm = #0xbee4
700a338c: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a338e: 9004         	str	r0, [sp, #0x10]
;                 }
700a3390: e000         	b	0x700a3394 <xQueueGenericSend+0x94> @ imm = #0x0
700a3392: e7ff         	b	0x700a3394 <xQueueGenericSend+0x94> @ imm = #-0x2
700a3394: e7ff         	b	0x700a3396 <xQueueGenericSend+0x96> @ imm = #-0x2
700a3396: e7ff         	b	0x700a3398 <xQueueGenericSend+0x98> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a3398: f00a fab2    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xa564
;         vTaskSuspendAll();
700a339c: f00c fc18    	bl	0x700afbd0 <vTaskSuspendAll> @ imm = #0xc830
;         prvLockQueue( pxQueue );
700a33a0: f00b f9ee    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0xb3dc
700a33a4: 9800         	ldr	r0, [sp]
700a33a6: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a33aa: 3001         	adds	r0, #0x1
700a33ac: b928         	cbnz	r0, 0x700a33ba <xQueueGenericSend+0xba> @ imm = #0xa
700a33ae: e7ff         	b	0x700a33b0 <xQueueGenericSend+0xb0> @ imm = #-0x2
700a33b0: 9900         	ldr	r1, [sp]
700a33b2: 2000         	movs	r0, #0x0
700a33b4: f881 0044    	strb.w	r0, [r1, #0x44]
700a33b8: e7ff         	b	0x700a33ba <xQueueGenericSend+0xba> @ imm = #-0x2
700a33ba: 9800         	ldr	r0, [sp]
700a33bc: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a33c0: 3001         	adds	r0, #0x1
700a33c2: b928         	cbnz	r0, 0x700a33d0 <xQueueGenericSend+0xd0> @ imm = #0xa
700a33c4: e7ff         	b	0x700a33c6 <xQueueGenericSend+0xc6> @ imm = #-0x2
700a33c6: 9900         	ldr	r1, [sp]
700a33c8: 2000         	movs	r0, #0x0
700a33ca: f881 0045    	strb.w	r0, [r1, #0x45]
700a33ce: e7ff         	b	0x700a33d0 <xQueueGenericSend+0xd0> @ imm = #-0x2
700a33d0: f00a fa96    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xa52c
700a33d4: a801         	add	r0, sp, #0x4
700a33d6: a906         	add	r1, sp, #0x18
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a33d8: f005 ff52    	bl	0x700a9280 <xTaskCheckForTimeOut> @ imm = #0x5ea4
700a33dc: b9d8         	cbnz	r0, 0x700a3416 <xQueueGenericSend+0x116> @ imm = #0x36
700a33de: e7ff         	b	0x700a33e0 <xQueueGenericSend+0xe0> @ imm = #-0x2
;             if( prvIsQueueFull( pxQueue ) != pdFALSE )
700a33e0: 9800         	ldr	r0, [sp]
700a33e2: f00b fb15    	bl	0x700aea10 <prvIsQueueFull> @ imm = #0xb62a
700a33e6: b178         	cbz	r0, 0x700a3408 <xQueueGenericSend+0x108> @ imm = #0x1e
700a33e8: e7ff         	b	0x700a33ea <xQueueGenericSend+0xea> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
700a33ea: 9800         	ldr	r0, [sp]
700a33ec: 3010         	adds	r0, #0x10
700a33ee: 9906         	ldr	r1, [sp, #0x18]
700a33f0: f00b fe3e    	bl	0x700af070 <vTaskPlaceOnEventList> @ imm = #0xbc7c
;                 prvUnlockQueue( pxQueue );
700a33f4: 9800         	ldr	r0, [sp]
700a33f6: f004 fd53    	bl	0x700a7ea0 <prvUnlockQueue> @ imm = #0x4aa6
;                 if( xTaskResumeAll() == pdFALSE )
700a33fa: f7fe ff51    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0x115e
700a33fe: b910         	cbnz	r0, 0x700a3406 <xQueueGenericSend+0x106> @ imm = #0x4
700a3400: e7ff         	b	0x700a3402 <xQueueGenericSend+0x102> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a3402: df00         	svc	#0x0
;                 }
700a3404: e7ff         	b	0x700a3406 <xQueueGenericSend+0x106> @ imm = #-0x2
;             }
700a3406: e005         	b	0x700a3414 <xQueueGenericSend+0x114> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a3408: 9800         	ldr	r0, [sp]
700a340a: f004 fd49    	bl	0x700a7ea0 <prvUnlockQueue> @ imm = #0x4a92
;                 ( void ) xTaskResumeAll();
700a340e: f7fe ff47    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0x1172
700a3412: e7ff         	b	0x700a3414 <xQueueGenericSend+0x114> @ imm = #-0x2
;         }
700a3414: e007         	b	0x700a3426 <xQueueGenericSend+0x126> @ imm = #0xe
;             prvUnlockQueue( pxQueue );
700a3416: 9800         	ldr	r0, [sp]
700a3418: f004 fd42    	bl	0x700a7ea0 <prvUnlockQueue> @ imm = #0x4a84
;             ( void ) xTaskResumeAll();
700a341c: f7fe ff40    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0x1180
700a3420: 2000         	movs	r0, #0x0
;             return errQUEUE_FULL;
700a3422: 9009         	str	r0, [sp, #0x24]
700a3424: e000         	b	0x700a3428 <xQueueGenericSend+0x128> @ imm = #0x0
;     for( ; ; )
700a3426: e776         	b	0x700a3316 <xQueueGenericSend+0x16> @ imm = #-0x114
; }
700a3428: 9809         	ldr	r0, [sp, #0x24]
700a342a: b00a         	add	sp, #0x28
700a342c: bd80         	pop	{r7, pc}
700a342e: 0000         	movs	r0, r0

700a3430 <UART_lld_init>:
; {
700a3430: b580         	push	{r7, lr}
700a3432: b084         	sub	sp, #0x10
700a3434: 9003         	str	r0, [sp, #0xc]
700a3436: 2000         	movs	r0, #0x0
;     int32_t                status = UART_STATUS_SUCCESS;
700a3438: 9002         	str	r0, [sp, #0x8]
;     if((hUart != NULL_PTR) && (hUart->hUartInit != NULL_PTR))
700a343a: 9803         	ldr	r0, [sp, #0xc]
700a343c: b168         	cbz	r0, 0x700a345a <UART_lld_init+0x2a> @ imm = #0x1a
700a343e: e7ff         	b	0x700a3440 <UART_lld_init+0x10> @ imm = #-0x2
700a3440: 9803         	ldr	r0, [sp, #0xc]
700a3442: 6840         	ldr	r0, [r0, #0x4]
700a3444: b148         	cbz	r0, 0x700a345a <UART_lld_init+0x2a> @ imm = #0x12
700a3446: e7ff         	b	0x700a3448 <UART_lld_init+0x18> @ imm = #-0x2
;         if(hUart->state != UART_STATE_RESET)
700a3448: 9803         	ldr	r0, [sp, #0xc]
700a344a: 6d40         	ldr	r0, [r0, #0x54]
700a344c: b120         	cbz	r0, 0x700a3458 <UART_lld_init+0x28> @ imm = #0x8
700a344e: e7ff         	b	0x700a3450 <UART_lld_init+0x20> @ imm = #-0x2
700a3450: f06f 0004    	mvn	r0, #0x4
;             status = UART_TRANSFER_INVALID_STATE;
700a3454: 9002         	str	r0, [sp, #0x8]
;         }
700a3456: e7ff         	b	0x700a3458 <UART_lld_init+0x28> @ imm = #-0x2
;     }
700a3458: e003         	b	0x700a3462 <UART_lld_init+0x32> @ imm = #0x6
700a345a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a345e: 9002         	str	r0, [sp, #0x8]
700a3460: e7ff         	b	0x700a3462 <UART_lld_init+0x32> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a3462: 9802         	ldr	r0, [sp, #0x8]
700a3464: 2800         	cmp	r0, #0x0
700a3466: d176         	bne	0x700a3556 <UART_lld_init+0x126> @ imm = #0xec
700a3468: e7ff         	b	0x700a346a <UART_lld_init+0x3a> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a346a: 9903         	ldr	r1, [sp, #0xc]
700a346c: 2002         	movs	r0, #0x2
700a346e: 6548         	str	r0, [r1, #0x54]
;         hUartInit = hUart->hUartInit;
700a3470: 9803         	ldr	r0, [sp, #0xc]
700a3472: 6840         	ldr	r0, [r0, #0x4]
700a3474: 9001         	str	r0, [sp, #0x4]
;         hUart->lineStatusTimeout = hUartInit->clockP_usecToTick(UART_READ_LINE_STATUS_TIMEOUT_IN_US);
700a3476: 9801         	ldr	r0, [sp, #0x4]
700a3478: 6d82         	ldr	r2, [r0, #0x58]
700a347a: f244 2040    	movw	r0, #0x4240
700a347e: f2c0 000f    	movt	r0, #0xf
700a3482: 2100         	movs	r1, #0x0
700a3484: 9100         	str	r1, [sp]
700a3486: 4790         	blx	r2
700a3488: 9a00         	ldr	r2, [sp]
700a348a: 9903         	ldr	r1, [sp, #0xc]
700a348c: 66ca         	str	r2, [r1, #0x6c]
700a348e: 6688         	str	r0, [r1, #0x68]
;         status += UART_IsBaseAddrValid(hUart->baseAddr);
700a3490: 9803         	ldr	r0, [sp, #0xc]
700a3492: 6800         	ldr	r0, [r0]
700a3494: f005 f9d4    	bl	0x700a8840 <UART_IsBaseAddrValid> @ imm = #0x53a8
700a3498: 4601         	mov	r1, r0
700a349a: 9802         	ldr	r0, [sp, #0x8]
700a349c: 4408         	add	r0, r1
700a349e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->inputClkFreq);
700a34a0: 9801         	ldr	r0, [sp, #0x4]
700a34a2: 6800         	ldr	r0, [r0]
700a34a4: f00c f874    	bl	0x700af590 <UART_IsParameter> @ imm = #0xc0e8
700a34a8: 4601         	mov	r1, r0
700a34aa: 9802         	ldr	r0, [sp, #0x8]
700a34ac: 4408         	add	r0, r1
700a34ae: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->baudRate);
700a34b0: 9801         	ldr	r0, [sp, #0x4]
700a34b2: 6840         	ldr	r0, [r0, #0x4]
700a34b4: f00c f86c    	bl	0x700af590 <UART_IsParameter> @ imm = #0xc0d8
700a34b8: 4601         	mov	r1, r0
700a34ba: 9802         	ldr	r0, [sp, #0x8]
700a34bc: 4408         	add	r0, r1
700a34be: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsDataLengthValid(hUartInit->dataLength);
700a34c0: 9801         	ldr	r0, [sp, #0x4]
700a34c2: 6880         	ldr	r0, [r0, #0x8]
700a34c4: f00b f864    	bl	0x700ae590 <UART_IsDataLengthValid> @ imm = #0xb0c8
700a34c8: 4601         	mov	r1, r0
700a34ca: 9802         	ldr	r0, [sp, #0x8]
700a34cc: 4408         	add	r0, r1
700a34ce: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsStopBitsValid(hUartInit->stopBits);
700a34d0: 9801         	ldr	r0, [sp, #0x4]
700a34d2: 68c0         	ldr	r0, [r0, #0xc]
700a34d4: f00b fe74    	bl	0x700af1c0 <UART_IsStopBitsValid> @ imm = #0xbce8
700a34d8: 4601         	mov	r1, r0
700a34da: 9802         	ldr	r0, [sp, #0x8]
700a34dc: 4408         	add	r0, r1
700a34de: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParityTypeValid(hUartInit->parityType);
700a34e0: 9801         	ldr	r0, [sp, #0x4]
700a34e2: 6900         	ldr	r0, [r0, #0x10]
700a34e4: f00a fdb4    	bl	0x700ae050 <UART_IsParityTypeValid> @ imm = #0xab68
700a34e8: 4601         	mov	r1, r0
700a34ea: 9802         	ldr	r0, [sp, #0x8]
700a34ec: 4408         	add	r0, r1
700a34ee: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsHWFlowCtrlValid(hUartInit->hwFlowControlThr);
700a34f0: 9801         	ldr	r0, [sp, #0x4]
700a34f2: 69c0         	ldr	r0, [r0, #0x1c]
700a34f4: f00a fc6c    	bl	0x700addd0 <UART_IsHWFlowCtrlValid> @ imm = #0xa8d8
700a34f8: 4601         	mov	r1, r0
700a34fa: 9802         	ldr	r0, [sp, #0x8]
700a34fc: 4408         	add	r0, r1
700a34fe: 9002         	str	r0, [sp, #0x8]
;         status += UART_OperModeValid(hUartInit->operMode);
700a3500: 9801         	ldr	r0, [sp, #0x4]
700a3502: 6ac0         	ldr	r0, [r0, #0x2c]
700a3504: f009 fcc4    	bl	0x700ace90 <UART_OperModeValid> @ imm = #0x9988
700a3508: 4601         	mov	r1, r0
700a350a: 9802         	ldr	r0, [sp, #0x8]
700a350c: 4408         	add	r0, r1
700a350e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsRxTrigLvlValid(hUartInit->rxTrigLvl);
700a3510: 9801         	ldr	r0, [sp, #0x4]
700a3512: 6b80         	ldr	r0, [r0, #0x38]
700a3514: f00a fc7c    	bl	0x700ade10 <UART_IsRxTrigLvlValid> @ imm = #0xa8f8
700a3518: 4601         	mov	r1, r0
700a351a: 9802         	ldr	r0, [sp, #0x8]
700a351c: 4408         	add	r0, r1
700a351e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsTxTrigLvlValid(hUartInit->txTrigLvl);
700a3520: 9801         	ldr	r0, [sp, #0x4]
700a3522: 6bc0         	ldr	r0, [r0, #0x3c]
700a3524: f00a fc94    	bl	0x700ade50 <UART_IsTxTrigLvlValid> @ imm = #0xa928
700a3528: 4601         	mov	r1, r0
700a352a: 9802         	ldr	r0, [sp, #0x8]
700a352c: 4408         	add	r0, r1
700a352e: 9002         	str	r0, [sp, #0x8]
;         if(UART_STATUS_SUCCESS == status)
700a3530: 9802         	ldr	r0, [sp, #0x8]
700a3532: b938         	cbnz	r0, 0x700a3544 <UART_lld_init+0x114> @ imm = #0xe
700a3534: e7ff         	b	0x700a3536 <UART_lld_init+0x106> @ imm = #-0x2
;             UART_configInstance(hUart);
700a3536: 9803         	ldr	r0, [sp, #0xc]
700a3538: f002 f882    	bl	0x700a5640 <UART_configInstance> @ imm = #0x2104
;             hUart->state = UART_STATE_READY;
700a353c: 9903         	ldr	r1, [sp, #0xc]
700a353e: 2001         	movs	r0, #0x1
700a3540: 6548         	str	r0, [r1, #0x54]
;         }
700a3542: e007         	b	0x700a3554 <UART_lld_init+0x124> @ imm = #0xe
;             status += UART_lld_deInit(hUart);
700a3544: 9803         	ldr	r0, [sp, #0xc]
700a3546: f009 f863    	bl	0x700ac610 <UART_lld_deInit> @ imm = #0x90c6
700a354a: 4601         	mov	r1, r0
700a354c: 9802         	ldr	r0, [sp, #0x8]
700a354e: 4408         	add	r0, r1
700a3550: 9002         	str	r0, [sp, #0x8]
700a3552: e7ff         	b	0x700a3554 <UART_lld_init+0x124> @ imm = #-0x2
;     }
700a3554: e7ff         	b	0x700a3556 <UART_lld_init+0x126> @ imm = #-0x2
;     return status;
700a3556: 9802         	ldr	r0, [sp, #0x8]
700a3558: b004         	add	sp, #0x10
700a355a: bd80         	pop	{r7, pc}
700a355c: 0000         	movs	r0, r0
700a355e: 0000         	movs	r0, r0

700a3560 <Sciclient_pmQueryModuleClkFreq>:
; {
700a3560: b580         	push	{r7, lr}
700a3562: b09e         	sub	sp, #0x78
700a3564: f8dd c084    	ldr.w	r12, [sp, #0x84]
700a3568: f8dd c080    	ldr.w	r12, [sp, #0x80]
700a356c: 901d         	str	r0, [sp, #0x74]
700a356e: 911c         	str	r1, [sp, #0x70]
700a3570: 931b         	str	r3, [sp, #0x6c]
700a3572: 921a         	str	r2, [sp, #0x68]
700a3574: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a3576: 9019         	str	r0, [sp, #0x64]
;     request.device         = (uint32_t) moduleId;
700a3578: 981d         	ldr	r0, [sp, #0x74]
700a357a: 9010         	str	r0, [sp, #0x40]
;     request.min_freq_hz    = (uint64_t) reqFreqHz;
700a357c: 981a         	ldr	r0, [sp, #0x68]
700a357e: 991b         	ldr	r1, [sp, #0x6c]
700a3580: 9112         	str	r1, [sp, #0x48]
700a3582: 9011         	str	r0, [sp, #0x44]
;     request.target_freq_hz = (uint64_t) reqFreqHz;
700a3584: 981a         	ldr	r0, [sp, #0x68]
700a3586: 991b         	ldr	r1, [sp, #0x6c]
700a3588: 9114         	str	r1, [sp, #0x50]
700a358a: 9013         	str	r0, [sp, #0x4c]
;     request.max_freq_hz    = (uint64_t) reqFreqHz;
700a358c: 981a         	ldr	r0, [sp, #0x68]
700a358e: 991b         	ldr	r1, [sp, #0x6c]
700a3590: 9116         	str	r1, [sp, #0x58]
700a3592: 9015         	str	r0, [sp, #0x54]
;     if((reqFreqHz%10U) != 0U)
700a3594: 9b1a         	ldr	r3, [sp, #0x68]
700a3596: 981b         	ldr	r0, [sp, #0x6c]
700a3598: f64c 41cd    	movw	r1, #0xcccd
700a359c: f6cc 41cc    	movt	r1, #0xcccc
700a35a0: fba3 2e01    	umull	r2, lr, r3, r1
700a35a4: f04f 3ccc    	mov.w	r12, #0xcccccccc
700a35a8: fb03 e30c    	mla	r3, r3, r12, lr
700a35ac: fb00 3101    	mla	r1, r0, r1, r3
700a35b0: ea4f 70c2    	lsl.w	r0, r2, #0x1f
700a35b4: ea40 0051    	orr.w	r0, r0, r1, lsr #1
700a35b8: ea4f 71c1    	lsl.w	r1, r1, #0x1f
700a35bc: ea41 0152    	orr.w	r1, r1, r2, lsr #1
700a35c0: f649 129a    	movw	r2, #0x999a
700a35c4: f6c9 1299    	movt	r2, #0x9999
700a35c8: 1a89         	subs	r1, r1, r2
700a35ca: f649 1199    	movw	r1, #0x9999
700a35ce: f6c1 1199    	movt	r1, #0x1999
700a35d2: 4188         	sbcs	r0, r1
700a35d4: d316         	blo	0x700a3604 <Sciclient_pmQueryModuleClkFreq+0xa4> @ imm = #0x2c
700a35d6: e7ff         	b	0x700a35d8 <Sciclient_pmQueryModuleClkFreq+0x78> @ imm = #-0x2
;         request.min_freq_hz = (uint64_t)(reqFreqHz-(reqFreqHz%10U));
700a35d8: 981a         	ldr	r0, [sp, #0x68]
700a35da: 9001         	str	r0, [sp, #0x4]
700a35dc: 991b         	ldr	r1, [sp, #0x6c]
700a35de: 9100         	str	r1, [sp]
700a35e0: 220a         	movs	r2, #0xa
700a35e2: 2300         	movs	r3, #0x0
700a35e4: f00b edfe    	blx	0x700af1e4 <__aeabi_uldivmod> @ imm = #0xbbfc
700a35e8: 9800         	ldr	r0, [sp]
700a35ea: 9901         	ldr	r1, [sp, #0x4]
700a35ec: 1a89         	subs	r1, r1, r2
700a35ee: 4198         	sbcs	r0, r3
700a35f0: 9111         	str	r1, [sp, #0x44]
700a35f2: 9012         	str	r0, [sp, #0x48]
;         request.max_freq_hz = (uint64_t)(request.min_freq_hz + 10UL);
700a35f4: 9911         	ldr	r1, [sp, #0x44]
700a35f6: 9812         	ldr	r0, [sp, #0x48]
700a35f8: 310a         	adds	r1, #0xa
700a35fa: f140 0000    	adc	r0, r0, #0x0
700a35fe: 9115         	str	r1, [sp, #0x54]
700a3600: 9016         	str	r0, [sp, #0x58]
;     }
700a3602: e7ff         	b	0x700a3604 <Sciclient_pmQueryModuleClkFreq+0xa4> @ imm = #-0x2
;     if (clockId >= 255U)
700a3604: 981c         	ldr	r0, [sp, #0x70]
700a3606: 28ff         	cmp	r0, #0xff
700a3608: d307         	blo	0x700a361a <Sciclient_pmQueryModuleClkFreq+0xba> @ imm = #0xe
700a360a: e7ff         	b	0x700a360c <Sciclient_pmQueryModuleClkFreq+0xac> @ imm = #-0x2
;         request.clk32 = clockId;
700a360c: 981c         	ldr	r0, [sp, #0x70]
700a360e: f8cd 005d    	str.w	r0, [sp, #0x5d]
700a3612: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a3614: f88d 005c    	strb.w	r0, [sp, #0x5c]
;     }
700a3618: e003         	b	0x700a3622 <Sciclient_pmQueryModuleClkFreq+0xc2> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a361a: 981c         	ldr	r0, [sp, #0x70]
700a361c: f88d 005c    	strb.w	r0, [sp, #0x5c]
700a3620: e7ff         	b	0x700a3622 <Sciclient_pmQueryModuleClkFreq+0xc2> @ imm = #-0x2
700a3622: 2000         	movs	r0, #0x0
;     struct tisci_msg_query_freq_resp response = {{0}};
700a3624: 900d         	str	r0, [sp, #0x34]
700a3626: 900c         	str	r0, [sp, #0x30]
700a3628: 900b         	str	r0, [sp, #0x2c]
700a362a: 900a         	str	r0, [sp, #0x28]
700a362c: f240 110d    	movw	r1, #0x10d
;     reqParam.messageType    = (uint16_t) TISCI_MSG_QUERY_FREQ;
700a3630: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a3634: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a3636: 9106         	str	r1, [sp, #0x18]
700a3638: a90e         	add	r1, sp, #0x38
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a363a: 9107         	str	r1, [sp, #0x1c]
700a363c: 2129         	movs	r1, #0x29
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a363e: 9108         	str	r1, [sp, #0x20]
;     reqParam.timeout        = (uint32_t) timeout;
700a3640: 9921         	ldr	r1, [sp, #0x84]
700a3642: 9109         	str	r1, [sp, #0x24]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a3644: 9002         	str	r0, [sp, #0x8]
700a3646: a80a         	add	r0, sp, #0x28
;     respParam.pRespPayload    = (uint8_t *) &response;
700a3648: 9003         	str	r0, [sp, #0xc]
700a364a: 2010         	movs	r0, #0x10
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a364c: 9004         	str	r0, [sp, #0x10]
700a364e: a805         	add	r0, sp, #0x14
700a3650: a902         	add	r1, sp, #0x8
;     retVal = Sciclient_service(&reqParam, &respParam);
700a3652: f7f9 ffcd    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0x6066
700a3656: 9019         	str	r0, [sp, #0x64]
;     if((retVal != SystemP_SUCCESS) ||
700a3658: 9819         	ldr	r0, [sp, #0x64]
700a365a: b930         	cbnz	r0, 0x700a366a <Sciclient_pmQueryModuleClkFreq+0x10a> @ imm = #0xc
700a365c: e7ff         	b	0x700a365e <Sciclient_pmQueryModuleClkFreq+0xfe> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a365e: 9802         	ldr	r0, [sp, #0x8]
700a3660: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a3664: 2802         	cmp	r0, #0x2
700a3666: d004         	beq	0x700a3672 <Sciclient_pmQueryModuleClkFreq+0x112> @ imm = #0x8
700a3668: e7ff         	b	0x700a366a <Sciclient_pmQueryModuleClkFreq+0x10a> @ imm = #-0x2
700a366a: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a366e: 9019         	str	r0, [sp, #0x64]
;     }
700a3670: e7ff         	b	0x700a3672 <Sciclient_pmQueryModuleClkFreq+0x112> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a3672: 9819         	ldr	r0, [sp, #0x64]
700a3674: b930         	cbnz	r0, 0x700a3684 <Sciclient_pmQueryModuleClkFreq+0x124> @ imm = #0xc
700a3676: e7ff         	b	0x700a3678 <Sciclient_pmQueryModuleClkFreq+0x118> @ imm = #-0x2
;         *respFreqHz = (uint64_t) response.freq_hz;
700a3678: 980c         	ldr	r0, [sp, #0x30]
700a367a: 9a0d         	ldr	r2, [sp, #0x34]
700a367c: 9920         	ldr	r1, [sp, #0x80]
700a367e: 604a         	str	r2, [r1, #0x4]
700a3680: 6008         	str	r0, [r1]
;     }
700a3682: e7ff         	b	0x700a3684 <Sciclient_pmQueryModuleClkFreq+0x124> @ imm = #-0x2
;     return retVal;
700a3684: 9819         	ldr	r0, [sp, #0x64]
700a3686: b01e         	add	sp, #0x78
700a3688: bd80         	pop	{r7, pc}
700a368a: 0000         	movs	r0, r0
700a368c: 0000         	movs	r0, r0
700a368e: 0000         	movs	r0, r0

700a3690 <xQueueReceive>:
; {
700a3690: b580         	push	{r7, lr}
700a3692: b08a         	sub	sp, #0x28
700a3694: 9008         	str	r0, [sp, #0x20]
700a3696: 9107         	str	r1, [sp, #0x1c]
700a3698: 9206         	str	r2, [sp, #0x18]
700a369a: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
700a369c: 9005         	str	r0, [sp, #0x14]
;     Queue_t * const pxQueue = xQueue;
700a369e: 9808         	ldr	r0, [sp, #0x20]
700a36a0: 9002         	str	r0, [sp, #0x8]
;     for( ; ; )
700a36a2: e7ff         	b	0x700a36a4 <xQueueReceive+0x14> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a36a4: f00b f86c    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0xb0d8
;             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a36a8: 9802         	ldr	r0, [sp, #0x8]
700a36aa: 6b80         	ldr	r0, [r0, #0x38]
700a36ac: 9001         	str	r0, [sp, #0x4]
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a36ae: 9801         	ldr	r0, [sp, #0x4]
700a36b0: b1e0         	cbz	r0, 0x700a36ec <xQueueReceive+0x5c> @ imm = #0x38
700a36b2: e7ff         	b	0x700a36b4 <xQueueReceive+0x24> @ imm = #-0x2
;                 prvCopyDataFromQueue( pxQueue, pvBuffer );
700a36b4: 9802         	ldr	r0, [sp, #0x8]
700a36b6: 9907         	ldr	r1, [sp, #0x1c]
700a36b8: f00a fa62    	bl	0x700adb80 <prvCopyDataFromQueue> @ imm = #0xa4c4
;                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
700a36bc: 9801         	ldr	r0, [sp, #0x4]
700a36be: 3801         	subs	r0, #0x1
700a36c0: 9902         	ldr	r1, [sp, #0x8]
700a36c2: 6388         	str	r0, [r1, #0x38]
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a36c4: 9802         	ldr	r0, [sp, #0x8]
700a36c6: 6900         	ldr	r0, [r0, #0x10]
700a36c8: b150         	cbz	r0, 0x700a36e0 <xQueueReceive+0x50> @ imm = #0x14
700a36ca: e7ff         	b	0x700a36cc <xQueueReceive+0x3c> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a36cc: 9802         	ldr	r0, [sp, #0x8]
700a36ce: 3010         	adds	r0, #0x10
700a36d0: f004 fa1e    	bl	0x700a7b10 <xTaskRemoveFromEventList> @ imm = #0x443c
700a36d4: b110         	cbz	r0, 0x700a36dc <xQueueReceive+0x4c> @ imm = #0x4
700a36d6: e7ff         	b	0x700a36d8 <xQueueReceive+0x48> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
700a36d8: df00         	svc	#0x0
;                     }
700a36da: e000         	b	0x700a36de <xQueueReceive+0x4e> @ imm = #0x0
700a36dc: e7ff         	b	0x700a36de <xQueueReceive+0x4e> @ imm = #-0x2
;                 }
700a36de: e000         	b	0x700a36e2 <xQueueReceive+0x52> @ imm = #0x0
700a36e0: e7ff         	b	0x700a36e2 <xQueueReceive+0x52> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a36e2: f00a f90d    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xa21a
700a36e6: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a36e8: 9009         	str	r0, [sp, #0x24]
700a36ea: e063         	b	0x700a37b4 <xQueueReceive+0x124> @ imm = #0xc6
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a36ec: 9806         	ldr	r0, [sp, #0x18]
700a36ee: b928         	cbnz	r0, 0x700a36fc <xQueueReceive+0x6c> @ imm = #0xa
700a36f0: e7ff         	b	0x700a36f2 <xQueueReceive+0x62> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a36f2: f00a f905    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xa20a
700a36f6: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
700a36f8: 9009         	str	r0, [sp, #0x24]
700a36fa: e05b         	b	0x700a37b4 <xQueueReceive+0x124> @ imm = #0xb6
;                 else if( xEntryTimeSet == pdFALSE )
700a36fc: 9805         	ldr	r0, [sp, #0x14]
700a36fe: b930         	cbnz	r0, 0x700a370e <xQueueReceive+0x7e> @ imm = #0xc
700a3700: e7ff         	b	0x700a3702 <xQueueReceive+0x72> @ imm = #-0x2
700a3702: a803         	add	r0, sp, #0xc
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a3704: f00b fdb4    	bl	0x700af270 <vTaskInternalSetTimeOutState> @ imm = #0xbb68
700a3708: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a370a: 9005         	str	r0, [sp, #0x14]
;                 }
700a370c: e000         	b	0x700a3710 <xQueueReceive+0x80> @ imm = #0x0
700a370e: e7ff         	b	0x700a3710 <xQueueReceive+0x80> @ imm = #-0x2
700a3710: e7ff         	b	0x700a3712 <xQueueReceive+0x82> @ imm = #-0x2
700a3712: e7ff         	b	0x700a3714 <xQueueReceive+0x84> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a3714: f00a f8f4    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xa1e8
;         vTaskSuspendAll();
700a3718: f00c fa5a    	bl	0x700afbd0 <vTaskSuspendAll> @ imm = #0xc4b4
;         prvLockQueue( pxQueue );
700a371c: f00b f830    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0xb060
700a3720: 9802         	ldr	r0, [sp, #0x8]
700a3722: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a3726: 3001         	adds	r0, #0x1
700a3728: b928         	cbnz	r0, 0x700a3736 <xQueueReceive+0xa6> @ imm = #0xa
700a372a: e7ff         	b	0x700a372c <xQueueReceive+0x9c> @ imm = #-0x2
700a372c: 9902         	ldr	r1, [sp, #0x8]
700a372e: 2000         	movs	r0, #0x0
700a3730: f881 0044    	strb.w	r0, [r1, #0x44]
700a3734: e7ff         	b	0x700a3736 <xQueueReceive+0xa6> @ imm = #-0x2
700a3736: 9802         	ldr	r0, [sp, #0x8]
700a3738: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a373c: 3001         	adds	r0, #0x1
700a373e: b928         	cbnz	r0, 0x700a374c <xQueueReceive+0xbc> @ imm = #0xa
700a3740: e7ff         	b	0x700a3742 <xQueueReceive+0xb2> @ imm = #-0x2
700a3742: 9902         	ldr	r1, [sp, #0x8]
700a3744: 2000         	movs	r0, #0x0
700a3746: f881 0045    	strb.w	r0, [r1, #0x45]
700a374a: e7ff         	b	0x700a374c <xQueueReceive+0xbc> @ imm = #-0x2
700a374c: f00a f8d8    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0xa1b0
700a3750: a803         	add	r0, sp, #0xc
700a3752: a906         	add	r1, sp, #0x18
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a3754: f005 fd94    	bl	0x700a9280 <xTaskCheckForTimeOut> @ imm = #0x5b28
700a3758: b9e0         	cbnz	r0, 0x700a3794 <xQueueReceive+0x104> @ imm = #0x38
700a375a: e7ff         	b	0x700a375c <xQueueReceive+0xcc> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a375c: 9802         	ldr	r0, [sp, #0x8]
700a375e: f00b fbc7    	bl	0x700aeef0 <prvIsQueueEmpty> @ imm = #0xb78e
700a3762: b180         	cbz	r0, 0x700a3786 <xQueueReceive+0xf6> @ imm = #0x20
700a3764: e7ff         	b	0x700a3766 <xQueueReceive+0xd6> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
700a3766: 9802         	ldr	r0, [sp, #0x8]
700a3768: 3024         	adds	r0, #0x24
700a376a: 9906         	ldr	r1, [sp, #0x18]
700a376c: f00b fc80    	bl	0x700af070 <vTaskPlaceOnEventList> @ imm = #0xb900
;                 prvUnlockQueue( pxQueue );
700a3770: 9802         	ldr	r0, [sp, #0x8]
700a3772: f004 fb95    	bl	0x700a7ea0 <prvUnlockQueue> @ imm = #0x472a
;                 if( xTaskResumeAll() == pdFALSE )
700a3776: f7fe fd93    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0x14da
700a377a: b910         	cbnz	r0, 0x700a3782 <xQueueReceive+0xf2> @ imm = #0x4
700a377c: e7ff         	b	0x700a377e <xQueueReceive+0xee> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a377e: df00         	svc	#0x0
;                 }
700a3780: e000         	b	0x700a3784 <xQueueReceive+0xf4> @ imm = #0x0
700a3782: e7ff         	b	0x700a3784 <xQueueReceive+0xf4> @ imm = #-0x2
;             }
700a3784: e005         	b	0x700a3792 <xQueueReceive+0x102> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a3786: 9802         	ldr	r0, [sp, #0x8]
700a3788: f004 fb8a    	bl	0x700a7ea0 <prvUnlockQueue> @ imm = #0x4714
;                 ( void ) xTaskResumeAll();
700a378c: f7fe fd88    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0x14f0
700a3790: e7ff         	b	0x700a3792 <xQueueReceive+0x102> @ imm = #-0x2
;         }
700a3792: e00e         	b	0x700a37b2 <xQueueReceive+0x122> @ imm = #0x1c
;             prvUnlockQueue( pxQueue );
700a3794: 9802         	ldr	r0, [sp, #0x8]
700a3796: f004 fb83    	bl	0x700a7ea0 <prvUnlockQueue> @ imm = #0x4706
;             ( void ) xTaskResumeAll();
700a379a: f7fe fd81    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0x14fe
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a379e: 9802         	ldr	r0, [sp, #0x8]
700a37a0: f00b fba6    	bl	0x700aeef0 <prvIsQueueEmpty> @ imm = #0xb74c
700a37a4: b118         	cbz	r0, 0x700a37ae <xQueueReceive+0x11e> @ imm = #0x6
700a37a6: e7ff         	b	0x700a37a8 <xQueueReceive+0x118> @ imm = #-0x2
700a37a8: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
700a37aa: 9009         	str	r0, [sp, #0x24]
700a37ac: e002         	b	0x700a37b4 <xQueueReceive+0x124> @ imm = #0x4
700a37ae: e7ff         	b	0x700a37b0 <xQueueReceive+0x120> @ imm = #-0x2
700a37b0: e7ff         	b	0x700a37b2 <xQueueReceive+0x122> @ imm = #-0x2
;     for( ; ; )
700a37b2: e777         	b	0x700a36a4 <xQueueReceive+0x14> @ imm = #-0x112
; }
700a37b4: 9809         	ldr	r0, [sp, #0x24]
700a37b6: b00a         	add	sp, #0x28
700a37b8: bd80         	pop	{r7, pc}
700a37ba: 0000         	movs	r0, r0
700a37bc: 0000         	movs	r0, r0
700a37be: 0000         	movs	r0, r0

700a37c0 <pxPortInitialiseStack>:
;                                    TaskFunction_t pxCode, void *pvParameters) {
700a37c0: b083         	sub	sp, #0xc
700a37c2: 9002         	str	r0, [sp, #0x8]
700a37c4: 9101         	str	r1, [sp, #0x4]
700a37c6: 9200         	str	r2, [sp]
;   *pxTopOfStack = (StackType_t)NULL;
700a37c8: 9902         	ldr	r1, [sp, #0x8]
700a37ca: 2000         	movs	r0, #0x0
700a37cc: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a37ce: 9902         	ldr	r1, [sp, #0x8]
700a37d0: 3904         	subs	r1, #0x4
700a37d2: 9102         	str	r1, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)NULL;
700a37d4: 9902         	ldr	r1, [sp, #0x8]
700a37d6: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a37d8: 9902         	ldr	r1, [sp, #0x8]
700a37da: 3904         	subs	r1, #0x4
700a37dc: 9102         	str	r1, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)NULL;
700a37de: 9902         	ldr	r1, [sp, #0x8]
700a37e0: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a37e2: 9802         	ldr	r0, [sp, #0x8]
700a37e4: 3804         	subs	r0, #0x4
700a37e6: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)portINITIAL_SPSR;
700a37e8: 9902         	ldr	r1, [sp, #0x8]
700a37ea: 201f         	movs	r0, #0x1f
700a37ec: 6008         	str	r0, [r1]
;   if (((uint32_t)pxCode & portTHUMB_MODE_ADDRESS) != 0x00UL) {
700a37ee: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a37f2: 07c0         	lsls	r0, r0, #0x1f
700a37f4: b130         	cbz	r0, 0x700a3804 <pxPortInitialiseStack+0x44> @ imm = #0xc
700a37f6: e7ff         	b	0x700a37f8 <pxPortInitialiseStack+0x38> @ imm = #-0x2
;     *pxTopOfStack |= portTHUMB_MODE_BIT;
700a37f8: 9902         	ldr	r1, [sp, #0x8]
700a37fa: 6808         	ldr	r0, [r1]
700a37fc: f040 0020    	orr	r0, r0, #0x20
700a3800: 6008         	str	r0, [r1]
;   }
700a3802: e7ff         	b	0x700a3804 <pxPortInitialiseStack+0x44> @ imm = #-0x2
;   pxTopOfStack--;
700a3804: 9802         	ldr	r0, [sp, #0x8]
700a3806: 3804         	subs	r0, #0x4
700a3808: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)pxCode;
700a380a: 9801         	ldr	r0, [sp, #0x4]
700a380c: 9902         	ldr	r1, [sp, #0x8]
700a380e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3810: 9802         	ldr	r0, [sp, #0x8]
700a3812: 3804         	subs	r0, #0x4
700a3814: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* R14 */
700a3816: 9902         	ldr	r1, [sp, #0x8]
700a3818: f64f 40e1    	movw	r0, #0xfce1
700a381c: f2c7 000a    	movt	r0, #0x700a
700a3820: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3822: 9802         	ldr	r0, [sp, #0x8]
700a3824: 3804         	subs	r0, #0x4
700a3826: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x12121212; /* R12 */
700a3828: 9902         	ldr	r1, [sp, #0x8]
700a382a: f04f 3012    	mov.w	r0, #0x12121212
700a382e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3830: 9802         	ldr	r0, [sp, #0x8]
700a3832: 3804         	subs	r0, #0x4
700a3834: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x11111111; /* R11 */
700a3836: 9902         	ldr	r1, [sp, #0x8]
700a3838: f04f 3011    	mov.w	r0, #0x11111111
700a383c: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a383e: 9802         	ldr	r0, [sp, #0x8]
700a3840: 3804         	subs	r0, #0x4
700a3842: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x10101010; /* R10 */
700a3844: 9902         	ldr	r1, [sp, #0x8]
700a3846: f04f 3010    	mov.w	r0, #0x10101010
700a384a: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a384c: 9802         	ldr	r0, [sp, #0x8]
700a384e: 3804         	subs	r0, #0x4
700a3850: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x09090909; /* R9 */
700a3852: 9902         	ldr	r1, [sp, #0x8]
700a3854: f04f 3009    	mov.w	r0, #0x9090909
700a3858: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a385a: 9802         	ldr	r0, [sp, #0x8]
700a385c: 3804         	subs	r0, #0x4
700a385e: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x08080808; /* R8 */
700a3860: 9902         	ldr	r1, [sp, #0x8]
700a3862: f04f 3008    	mov.w	r0, #0x8080808
700a3866: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3868: 9802         	ldr	r0, [sp, #0x8]
700a386a: 3804         	subs	r0, #0x4
700a386c: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x07070707; /* R7 */
700a386e: 9902         	ldr	r1, [sp, #0x8]
700a3870: f04f 3007    	mov.w	r0, #0x7070707
700a3874: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3876: 9802         	ldr	r0, [sp, #0x8]
700a3878: 3804         	subs	r0, #0x4
700a387a: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x06060606; /* R6 */
700a387c: 9902         	ldr	r1, [sp, #0x8]
700a387e: f04f 3006    	mov.w	r0, #0x6060606
700a3882: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3884: 9802         	ldr	r0, [sp, #0x8]
700a3886: 3804         	subs	r0, #0x4
700a3888: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x05050505; /* R5 */
700a388a: 9902         	ldr	r1, [sp, #0x8]
700a388c: f04f 3005    	mov.w	r0, #0x5050505
700a3890: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3892: 9802         	ldr	r0, [sp, #0x8]
700a3894: 3804         	subs	r0, #0x4
700a3896: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x04040404; /* R4 */
700a3898: 9902         	ldr	r1, [sp, #0x8]
700a389a: f04f 3004    	mov.w	r0, #0x4040404
700a389e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a38a0: 9802         	ldr	r0, [sp, #0x8]
700a38a2: 3804         	subs	r0, #0x4
700a38a4: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x03030303; /* R3 */
700a38a6: 9902         	ldr	r1, [sp, #0x8]
700a38a8: f04f 3003    	mov.w	r0, #0x3030303
700a38ac: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a38ae: 9802         	ldr	r0, [sp, #0x8]
700a38b0: 3804         	subs	r0, #0x4
700a38b2: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x02020202; /* R2 */
700a38b4: 9902         	ldr	r1, [sp, #0x8]
700a38b6: f04f 3002    	mov.w	r0, #0x2020202
700a38ba: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a38bc: 9802         	ldr	r0, [sp, #0x8]
700a38be: 3804         	subs	r0, #0x4
700a38c0: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x01010101; /* R1 */
700a38c2: 9902         	ldr	r1, [sp, #0x8]
700a38c4: f04f 3001    	mov.w	r0, #0x1010101
700a38c8: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a38ca: 9802         	ldr	r0, [sp, #0x8]
700a38cc: 3804         	subs	r0, #0x4
700a38ce: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)pvParameters; /* R0 */
700a38d0: 9800         	ldr	r0, [sp]
700a38d2: 9902         	ldr	r1, [sp, #0x8]
700a38d4: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a38d6: 9802         	ldr	r0, [sp, #0x8]
700a38d8: 3804         	subs	r0, #0x4
700a38da: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = portNO_FLOATING_POINT_CONTEXT;
700a38dc: 9902         	ldr	r1, [sp, #0x8]
700a38de: 2000         	movs	r0, #0x0
700a38e0: 6008         	str	r0, [r1]
;   return pxTopOfStack;
700a38e2: 9802         	ldr	r0, [sp, #0x8]
700a38e4: b003         	add	sp, #0xc
700a38e6: 4770         	bx	lr
		...

700a38f0 <Udma_rmAllocBlkCopyCh>:
; {
700a38f0: b580         	push	{r7, lr}
700a38f2: b088         	sub	sp, #0x20
700a38f4: 9007         	str	r0, [sp, #0x1c]
700a38f6: 9106         	str	r1, [sp, #0x18]
700a38f8: 2000         	movs	r0, #0x0
700a38fa: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a38fe: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3900: 9806         	ldr	r0, [sp, #0x18]
700a3902: f500 70ea    	add.w	r0, r0, #0x1d4
700a3906: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3908: 9806         	ldr	r0, [sp, #0x18]
700a390a: f500 609f    	add.w	r0, r0, #0x4f8
700a390e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3912: f006 ff65    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x6eca
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3916: 9807         	ldr	r0, [sp, #0x1c]
700a3918: 2101         	movs	r1, #0x1
700a391a: f6cf 71ff    	movt	r1, #0xffff
700a391e: 4288         	cmp	r0, r1
700a3920: d136         	bne	0x700a3990 <Udma_rmAllocBlkCopyCh+0xa0> @ imm = #0x6c
700a3922: e7ff         	b	0x700a3924 <Udma_rmAllocBlkCopyCh+0x34> @ imm = #-0x2
700a3924: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyCh; i++)
700a3926: 9005         	str	r0, [sp, #0x14]
700a3928: e7ff         	b	0x700a392a <Udma_rmAllocBlkCopyCh+0x3a> @ imm = #-0x2
700a392a: 9805         	ldr	r0, [sp, #0x14]
700a392c: 9900         	ldr	r1, [sp]
700a392e: 6949         	ldr	r1, [r1, #0x14]
700a3930: 4288         	cmp	r0, r1
700a3932: d22c         	bhs	0x700a398e <Udma_rmAllocBlkCopyCh+0x9e> @ imm = #0x58
700a3934: e7ff         	b	0x700a3936 <Udma_rmAllocBlkCopyCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3936: 9805         	ldr	r0, [sp, #0x14]
700a3938: 0940         	lsrs	r0, r0, #0x5
700a393a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a393c: 9805         	ldr	r0, [sp, #0x14]
700a393e: 9904         	ldr	r1, [sp, #0x10]
700a3940: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3944: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3946: 9903         	ldr	r1, [sp, #0xc]
700a3948: 2001         	movs	r0, #0x1
700a394a: 4088         	lsls	r0, r1
700a394c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyChFlag[offset] & bitMask) == bitMask)
700a394e: 9806         	ldr	r0, [sp, #0x18]
700a3950: 9904         	ldr	r1, [sp, #0x10]
700a3952: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3956: f8d0 02c8    	ldr.w	r0, [r0, #0x2c8]
700a395a: 9902         	ldr	r1, [sp, #0x8]
700a395c: 4008         	ands	r0, r1
700a395e: 4288         	cmp	r0, r1
700a3960: d110         	bne	0x700a3984 <Udma_rmAllocBlkCopyCh+0x94> @ imm = #0x20
700a3962: e7ff         	b	0x700a3964 <Udma_rmAllocBlkCopyCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyChFlag[offset] &= ~bitMask;
700a3964: 9a02         	ldr	r2, [sp, #0x8]
700a3966: 9806         	ldr	r0, [sp, #0x18]
700a3968: 9904         	ldr	r1, [sp, #0x10]
700a396a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a396e: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a3972: 4390         	bics	r0, r2
700a3974: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;                 chNum = i + rmInitPrms->startBlkCopyCh;  /* Add start offset */
700a3978: 9805         	ldr	r0, [sp, #0x14]
700a397a: 9900         	ldr	r1, [sp]
700a397c: 6909         	ldr	r1, [r1, #0x10]
700a397e: 4408         	add	r0, r1
700a3980: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3982: e004         	b	0x700a398e <Udma_rmAllocBlkCopyCh+0x9e> @ imm = #0x8
;         }
700a3984: e7ff         	b	0x700a3986 <Udma_rmAllocBlkCopyCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyCh; i++)
700a3986: 9805         	ldr	r0, [sp, #0x14]
700a3988: 3001         	adds	r0, #0x1
700a398a: 9005         	str	r0, [sp, #0x14]
700a398c: e7cd         	b	0x700a392a <Udma_rmAllocBlkCopyCh+0x3a> @ imm = #-0x66
;     }
700a398e: e038         	b	0x700a3a02 <Udma_rmAllocBlkCopyCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyCh) &&
700a3990: 9807         	ldr	r0, [sp, #0x1c]
700a3992: 9900         	ldr	r1, [sp]
700a3994: 6909         	ldr	r1, [r1, #0x10]
700a3996: 4288         	cmp	r0, r1
700a3998: d332         	blo	0x700a3a00 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #0x64
700a399a: e7ff         	b	0x700a399c <Udma_rmAllocBlkCopyCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyCh + rmInitPrms->numBlkCopyCh)))
700a399c: 9807         	ldr	r0, [sp, #0x1c]
700a399e: 9a00         	ldr	r2, [sp]
700a39a0: 6911         	ldr	r1, [r2, #0x10]
700a39a2: 6952         	ldr	r2, [r2, #0x14]
700a39a4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyCh) &&
700a39a6: 4288         	cmp	r0, r1
700a39a8: d22a         	bhs	0x700a3a00 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #0x54
700a39aa: e7ff         	b	0x700a39ac <Udma_rmAllocBlkCopyCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyCh;
700a39ac: 9807         	ldr	r0, [sp, #0x1c]
700a39ae: 9900         	ldr	r1, [sp]
700a39b0: 6909         	ldr	r1, [r1, #0x10]
700a39b2: 1a40         	subs	r0, r0, r1
700a39b4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a39b6: 9805         	ldr	r0, [sp, #0x14]
700a39b8: 0940         	lsrs	r0, r0, #0x5
700a39ba: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a39bc: 9805         	ldr	r0, [sp, #0x14]
700a39be: 9904         	ldr	r1, [sp, #0x10]
700a39c0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a39c4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a39c6: 9903         	ldr	r1, [sp, #0xc]
700a39c8: 2001         	movs	r0, #0x1
700a39ca: 4088         	lsls	r0, r1
700a39cc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyChFlag[offset] & bitMask) == bitMask)
700a39ce: 9806         	ldr	r0, [sp, #0x18]
700a39d0: 9904         	ldr	r1, [sp, #0x10]
700a39d2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a39d6: f8d0 02c8    	ldr.w	r0, [r0, #0x2c8]
700a39da: 9902         	ldr	r1, [sp, #0x8]
700a39dc: 4008         	ands	r0, r1
700a39de: 4288         	cmp	r0, r1
700a39e0: d10d         	bne	0x700a39fe <Udma_rmAllocBlkCopyCh+0x10e> @ imm = #0x1a
700a39e2: e7ff         	b	0x700a39e4 <Udma_rmAllocBlkCopyCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyChFlag[offset] &= ~bitMask;
700a39e4: 9a02         	ldr	r2, [sp, #0x8]
700a39e6: 9806         	ldr	r0, [sp, #0x18]
700a39e8: 9904         	ldr	r1, [sp, #0x10]
700a39ea: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a39ee: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a39f2: 4390         	bics	r0, r2
700a39f4: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;                 chNum = preferredChNum;
700a39f8: 9807         	ldr	r0, [sp, #0x1c]
700a39fa: 9001         	str	r0, [sp, #0x4]
;             }
700a39fc: e7ff         	b	0x700a39fe <Udma_rmAllocBlkCopyCh+0x10e> @ imm = #-0x2
;         }
700a39fe: e7ff         	b	0x700a3a00 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #-0x2
700a3a00: e7ff         	b	0x700a3a02 <Udma_rmAllocBlkCopyCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3a02: 9806         	ldr	r0, [sp, #0x18]
700a3a04: f500 609f    	add.w	r0, r0, #0x4f8
700a3a08: f008 fa7a    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x84f4
;     return (chNum);
700a3a0c: 9801         	ldr	r0, [sp, #0x4]
700a3a0e: b008         	add	sp, #0x20
700a3a10: bd80         	pop	{r7, pc}
		...
700a3a1e: 0000         	movs	r0, r0

700a3a20 <Udma_rmAllocBlkCopyHcCh>:
; {
700a3a20: b580         	push	{r7, lr}
700a3a22: b088         	sub	sp, #0x20
700a3a24: 9007         	str	r0, [sp, #0x1c]
700a3a26: 9106         	str	r1, [sp, #0x18]
700a3a28: 2000         	movs	r0, #0x0
700a3a2a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3a2e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3a30: 9806         	ldr	r0, [sp, #0x18]
700a3a32: f500 70ea    	add.w	r0, r0, #0x1d4
700a3a36: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3a38: 9806         	ldr	r0, [sp, #0x18]
700a3a3a: f500 609f    	add.w	r0, r0, #0x4f8
700a3a3e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3a42: f006 fecd    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x6d9a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3a46: 9807         	ldr	r0, [sp, #0x1c]
700a3a48: 2101         	movs	r1, #0x1
700a3a4a: f6cf 71ff    	movt	r1, #0xffff
700a3a4e: 4288         	cmp	r0, r1
700a3a50: d136         	bne	0x700a3ac0 <Udma_rmAllocBlkCopyHcCh+0xa0> @ imm = #0x6c
700a3a52: e7ff         	b	0x700a3a54 <Udma_rmAllocBlkCopyHcCh+0x34> @ imm = #-0x2
700a3a54: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyHcCh; i++)
700a3a56: 9005         	str	r0, [sp, #0x14]
700a3a58: e7ff         	b	0x700a3a5a <Udma_rmAllocBlkCopyHcCh+0x3a> @ imm = #-0x2
700a3a5a: 9805         	ldr	r0, [sp, #0x14]
700a3a5c: 9900         	ldr	r1, [sp]
700a3a5e: 68c9         	ldr	r1, [r1, #0xc]
700a3a60: 4288         	cmp	r0, r1
700a3a62: d22c         	bhs	0x700a3abe <Udma_rmAllocBlkCopyHcCh+0x9e> @ imm = #0x58
700a3a64: e7ff         	b	0x700a3a66 <Udma_rmAllocBlkCopyHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3a66: 9805         	ldr	r0, [sp, #0x14]
700a3a68: 0940         	lsrs	r0, r0, #0x5
700a3a6a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3a6c: 9805         	ldr	r0, [sp, #0x14]
700a3a6e: 9904         	ldr	r1, [sp, #0x10]
700a3a70: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3a74: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3a76: 9903         	ldr	r1, [sp, #0xc]
700a3a78: 2001         	movs	r0, #0x1
700a3a7a: 4088         	lsls	r0, r1
700a3a7c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyHcChFlag[offset] & bitMask) == bitMask)
700a3a7e: 9806         	ldr	r0, [sp, #0x18]
700a3a80: 9904         	ldr	r1, [sp, #0x10]
700a3a82: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3a86: f8d0 02cc    	ldr.w	r0, [r0, #0x2cc]
700a3a8a: 9902         	ldr	r1, [sp, #0x8]
700a3a8c: 4008         	ands	r0, r1
700a3a8e: 4288         	cmp	r0, r1
700a3a90: d110         	bne	0x700a3ab4 <Udma_rmAllocBlkCopyHcCh+0x94> @ imm = #0x20
700a3a92: e7ff         	b	0x700a3a94 <Udma_rmAllocBlkCopyHcCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyHcChFlag[offset] &= ~bitMask;
700a3a94: 9a02         	ldr	r2, [sp, #0x8]
700a3a96: 9806         	ldr	r0, [sp, #0x18]
700a3a98: 9904         	ldr	r1, [sp, #0x10]
700a3a9a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3a9e: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a3aa2: 4390         	bics	r0, r2
700a3aa4: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;                 chNum = i + rmInitPrms->startBlkCopyHcCh;  /* Add start offset */
700a3aa8: 9805         	ldr	r0, [sp, #0x14]
700a3aaa: 9900         	ldr	r1, [sp]
700a3aac: 6889         	ldr	r1, [r1, #0x8]
700a3aae: 4408         	add	r0, r1
700a3ab0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3ab2: e004         	b	0x700a3abe <Udma_rmAllocBlkCopyHcCh+0x9e> @ imm = #0x8
;         }
700a3ab4: e7ff         	b	0x700a3ab6 <Udma_rmAllocBlkCopyHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyHcCh; i++)
700a3ab6: 9805         	ldr	r0, [sp, #0x14]
700a3ab8: 3001         	adds	r0, #0x1
700a3aba: 9005         	str	r0, [sp, #0x14]
700a3abc: e7cd         	b	0x700a3a5a <Udma_rmAllocBlkCopyHcCh+0x3a> @ imm = #-0x66
;     }
700a3abe: e038         	b	0x700a3b32 <Udma_rmAllocBlkCopyHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyHcCh) &&
700a3ac0: 9807         	ldr	r0, [sp, #0x1c]
700a3ac2: 9900         	ldr	r1, [sp]
700a3ac4: 6889         	ldr	r1, [r1, #0x8]
700a3ac6: 4288         	cmp	r0, r1
700a3ac8: d332         	blo	0x700a3b30 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #0x64
700a3aca: e7ff         	b	0x700a3acc <Udma_rmAllocBlkCopyHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyHcCh + rmInitPrms->numBlkCopyHcCh)))
700a3acc: 9807         	ldr	r0, [sp, #0x1c]
700a3ace: 9a00         	ldr	r2, [sp]
700a3ad0: 6891         	ldr	r1, [r2, #0x8]
700a3ad2: 68d2         	ldr	r2, [r2, #0xc]
700a3ad4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyHcCh) &&
700a3ad6: 4288         	cmp	r0, r1
700a3ad8: d22a         	bhs	0x700a3b30 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #0x54
700a3ada: e7ff         	b	0x700a3adc <Udma_rmAllocBlkCopyHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyHcCh;
700a3adc: 9807         	ldr	r0, [sp, #0x1c]
700a3ade: 9900         	ldr	r1, [sp]
700a3ae0: 6889         	ldr	r1, [r1, #0x8]
700a3ae2: 1a40         	subs	r0, r0, r1
700a3ae4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3ae6: 9805         	ldr	r0, [sp, #0x14]
700a3ae8: 0940         	lsrs	r0, r0, #0x5
700a3aea: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3aec: 9805         	ldr	r0, [sp, #0x14]
700a3aee: 9904         	ldr	r1, [sp, #0x10]
700a3af0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3af4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3af6: 9903         	ldr	r1, [sp, #0xc]
700a3af8: 2001         	movs	r0, #0x1
700a3afa: 4088         	lsls	r0, r1
700a3afc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyHcChFlag[offset] & bitMask) == bitMask)
700a3afe: 9806         	ldr	r0, [sp, #0x18]
700a3b00: 9904         	ldr	r1, [sp, #0x10]
700a3b02: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3b06: f8d0 02cc    	ldr.w	r0, [r0, #0x2cc]
700a3b0a: 9902         	ldr	r1, [sp, #0x8]
700a3b0c: 4008         	ands	r0, r1
700a3b0e: 4288         	cmp	r0, r1
700a3b10: d10d         	bne	0x700a3b2e <Udma_rmAllocBlkCopyHcCh+0x10e> @ imm = #0x1a
700a3b12: e7ff         	b	0x700a3b14 <Udma_rmAllocBlkCopyHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyHcChFlag[offset] &= ~bitMask;
700a3b14: 9a02         	ldr	r2, [sp, #0x8]
700a3b16: 9806         	ldr	r0, [sp, #0x18]
700a3b18: 9904         	ldr	r1, [sp, #0x10]
700a3b1a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3b1e: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a3b22: 4390         	bics	r0, r2
700a3b24: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;                 chNum = preferredChNum;
700a3b28: 9807         	ldr	r0, [sp, #0x1c]
700a3b2a: 9001         	str	r0, [sp, #0x4]
;             }
700a3b2c: e7ff         	b	0x700a3b2e <Udma_rmAllocBlkCopyHcCh+0x10e> @ imm = #-0x2
;         }
700a3b2e: e7ff         	b	0x700a3b30 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #-0x2
700a3b30: e7ff         	b	0x700a3b32 <Udma_rmAllocBlkCopyHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3b32: 9806         	ldr	r0, [sp, #0x18]
700a3b34: f500 609f    	add.w	r0, r0, #0x4f8
700a3b38: f008 f9e2    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x83c4
;     return (chNum);
700a3b3c: 9801         	ldr	r0, [sp, #0x4]
700a3b3e: b008         	add	sp, #0x20
700a3b40: bd80         	pop	{r7, pc}
		...
700a3b4e: 0000         	movs	r0, r0

700a3b50 <Udma_rmAllocBlkCopyUhcCh>:
; {
700a3b50: b580         	push	{r7, lr}
700a3b52: b088         	sub	sp, #0x20
700a3b54: 9007         	str	r0, [sp, #0x1c]
700a3b56: 9106         	str	r1, [sp, #0x18]
700a3b58: 2000         	movs	r0, #0x0
700a3b5a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3b5e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3b60: 9806         	ldr	r0, [sp, #0x18]
700a3b62: f500 70ea    	add.w	r0, r0, #0x1d4
700a3b66: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3b68: 9806         	ldr	r0, [sp, #0x18]
700a3b6a: f500 609f    	add.w	r0, r0, #0x4f8
700a3b6e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3b72: f006 fe35    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x6c6a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3b76: 9807         	ldr	r0, [sp, #0x1c]
700a3b78: 2101         	movs	r1, #0x1
700a3b7a: f6cf 71ff    	movt	r1, #0xffff
700a3b7e: 4288         	cmp	r0, r1
700a3b80: d136         	bne	0x700a3bf0 <Udma_rmAllocBlkCopyUhcCh+0xa0> @ imm = #0x6c
700a3b82: e7ff         	b	0x700a3b84 <Udma_rmAllocBlkCopyUhcCh+0x34> @ imm = #-0x2
700a3b84: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyUhcCh; i++)
700a3b86: 9005         	str	r0, [sp, #0x14]
700a3b88: e7ff         	b	0x700a3b8a <Udma_rmAllocBlkCopyUhcCh+0x3a> @ imm = #-0x2
700a3b8a: 9805         	ldr	r0, [sp, #0x14]
700a3b8c: 9900         	ldr	r1, [sp]
700a3b8e: 6849         	ldr	r1, [r1, #0x4]
700a3b90: 4288         	cmp	r0, r1
700a3b92: d22c         	bhs	0x700a3bee <Udma_rmAllocBlkCopyUhcCh+0x9e> @ imm = #0x58
700a3b94: e7ff         	b	0x700a3b96 <Udma_rmAllocBlkCopyUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3b96: 9805         	ldr	r0, [sp, #0x14]
700a3b98: 0940         	lsrs	r0, r0, #0x5
700a3b9a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3b9c: 9805         	ldr	r0, [sp, #0x14]
700a3b9e: 9904         	ldr	r1, [sp, #0x10]
700a3ba0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3ba4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3ba6: 9903         	ldr	r1, [sp, #0xc]
700a3ba8: 2001         	movs	r0, #0x1
700a3baa: 4088         	lsls	r0, r1
700a3bac: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyUhcChFlag[offset] & bitMask) == bitMask)
700a3bae: 9806         	ldr	r0, [sp, #0x18]
700a3bb0: 9904         	ldr	r1, [sp, #0x10]
700a3bb2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3bb6: f8d0 02d0    	ldr.w	r0, [r0, #0x2d0]
700a3bba: 9902         	ldr	r1, [sp, #0x8]
700a3bbc: 4008         	ands	r0, r1
700a3bbe: 4288         	cmp	r0, r1
700a3bc0: d110         	bne	0x700a3be4 <Udma_rmAllocBlkCopyUhcCh+0x94> @ imm = #0x20
700a3bc2: e7ff         	b	0x700a3bc4 <Udma_rmAllocBlkCopyUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyUhcChFlag[offset] &= ~bitMask;
700a3bc4: 9a02         	ldr	r2, [sp, #0x8]
700a3bc6: 9806         	ldr	r0, [sp, #0x18]
700a3bc8: 9904         	ldr	r1, [sp, #0x10]
700a3bca: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3bce: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a3bd2: 4390         	bics	r0, r2
700a3bd4: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;                 chNum = i + rmInitPrms->startBlkCopyUhcCh;  /* Add start offset */
700a3bd8: 9805         	ldr	r0, [sp, #0x14]
700a3bda: 9900         	ldr	r1, [sp]
700a3bdc: 6809         	ldr	r1, [r1]
700a3bde: 4408         	add	r0, r1
700a3be0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3be2: e004         	b	0x700a3bee <Udma_rmAllocBlkCopyUhcCh+0x9e> @ imm = #0x8
;         }
700a3be4: e7ff         	b	0x700a3be6 <Udma_rmAllocBlkCopyUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyUhcCh; i++)
700a3be6: 9805         	ldr	r0, [sp, #0x14]
700a3be8: 3001         	adds	r0, #0x1
700a3bea: 9005         	str	r0, [sp, #0x14]
700a3bec: e7cd         	b	0x700a3b8a <Udma_rmAllocBlkCopyUhcCh+0x3a> @ imm = #-0x66
;     }
700a3bee: e038         	b	0x700a3c62 <Udma_rmAllocBlkCopyUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyUhcCh) &&
700a3bf0: 9807         	ldr	r0, [sp, #0x1c]
700a3bf2: 9900         	ldr	r1, [sp]
700a3bf4: 6809         	ldr	r1, [r1]
700a3bf6: 4288         	cmp	r0, r1
700a3bf8: d332         	blo	0x700a3c60 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #0x64
700a3bfa: e7ff         	b	0x700a3bfc <Udma_rmAllocBlkCopyUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyUhcCh + rmInitPrms->numBlkCopyUhcCh)))
700a3bfc: 9807         	ldr	r0, [sp, #0x1c]
700a3bfe: 9a00         	ldr	r2, [sp]
700a3c00: 6811         	ldr	r1, [r2]
700a3c02: 6852         	ldr	r2, [r2, #0x4]
700a3c04: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyUhcCh) &&
700a3c06: 4288         	cmp	r0, r1
700a3c08: d22a         	bhs	0x700a3c60 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #0x54
700a3c0a: e7ff         	b	0x700a3c0c <Udma_rmAllocBlkCopyUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyUhcCh;
700a3c0c: 9807         	ldr	r0, [sp, #0x1c]
700a3c0e: 9900         	ldr	r1, [sp]
700a3c10: 6809         	ldr	r1, [r1]
700a3c12: 1a40         	subs	r0, r0, r1
700a3c14: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3c16: 9805         	ldr	r0, [sp, #0x14]
700a3c18: 0940         	lsrs	r0, r0, #0x5
700a3c1a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3c1c: 9805         	ldr	r0, [sp, #0x14]
700a3c1e: 9904         	ldr	r1, [sp, #0x10]
700a3c20: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3c24: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3c26: 9903         	ldr	r1, [sp, #0xc]
700a3c28: 2001         	movs	r0, #0x1
700a3c2a: 4088         	lsls	r0, r1
700a3c2c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyUhcChFlag[offset] & bitMask) == bitMask)
700a3c2e: 9806         	ldr	r0, [sp, #0x18]
700a3c30: 9904         	ldr	r1, [sp, #0x10]
700a3c32: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3c36: f8d0 02d0    	ldr.w	r0, [r0, #0x2d0]
700a3c3a: 9902         	ldr	r1, [sp, #0x8]
700a3c3c: 4008         	ands	r0, r1
700a3c3e: 4288         	cmp	r0, r1
700a3c40: d10d         	bne	0x700a3c5e <Udma_rmAllocBlkCopyUhcCh+0x10e> @ imm = #0x1a
700a3c42: e7ff         	b	0x700a3c44 <Udma_rmAllocBlkCopyUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyUhcChFlag[offset] &= ~bitMask;
700a3c44: 9a02         	ldr	r2, [sp, #0x8]
700a3c46: 9806         	ldr	r0, [sp, #0x18]
700a3c48: 9904         	ldr	r1, [sp, #0x10]
700a3c4a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3c4e: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a3c52: 4390         	bics	r0, r2
700a3c54: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;                 chNum = preferredChNum;
700a3c58: 9807         	ldr	r0, [sp, #0x1c]
700a3c5a: 9001         	str	r0, [sp, #0x4]
;             }
700a3c5c: e7ff         	b	0x700a3c5e <Udma_rmAllocBlkCopyUhcCh+0x10e> @ imm = #-0x2
;         }
700a3c5e: e7ff         	b	0x700a3c60 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #-0x2
700a3c60: e7ff         	b	0x700a3c62 <Udma_rmAllocBlkCopyUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3c62: 9806         	ldr	r0, [sp, #0x18]
700a3c64: f500 609f    	add.w	r0, r0, #0x4f8
700a3c68: f008 f94a    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x8294
;     return (chNum);
700a3c6c: 9801         	ldr	r0, [sp, #0x4]
700a3c6e: b008         	add	sp, #0x20
700a3c70: bd80         	pop	{r7, pc}
		...
700a3c7e: 0000         	movs	r0, r0

700a3c80 <Udma_rmAllocRxCh>:
; {
700a3c80: b580         	push	{r7, lr}
700a3c82: b088         	sub	sp, #0x20
700a3c84: 9007         	str	r0, [sp, #0x1c]
700a3c86: 9106         	str	r1, [sp, #0x18]
700a3c88: 2000         	movs	r0, #0x0
700a3c8a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3c8e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3c90: 9806         	ldr	r0, [sp, #0x18]
700a3c92: f500 70ea    	add.w	r0, r0, #0x1d4
700a3c96: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3c98: 9806         	ldr	r0, [sp, #0x18]
700a3c9a: f500 609f    	add.w	r0, r0, #0x4f8
700a3c9e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3ca2: f006 fd9d    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x6b3a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3ca6: 9807         	ldr	r0, [sp, #0x1c]
700a3ca8: 2101         	movs	r1, #0x1
700a3caa: f6cf 71ff    	movt	r1, #0xffff
700a3cae: 4288         	cmp	r0, r1
700a3cb0: d136         	bne	0x700a3d20 <Udma_rmAllocRxCh+0xa0> @ imm = #0x6c
700a3cb2: e7ff         	b	0x700a3cb4 <Udma_rmAllocRxCh+0x34> @ imm = #-0x2
700a3cb4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxCh; i++)
700a3cb6: 9005         	str	r0, [sp, #0x14]
700a3cb8: e7ff         	b	0x700a3cba <Udma_rmAllocRxCh+0x3a> @ imm = #-0x2
700a3cba: 9805         	ldr	r0, [sp, #0x14]
700a3cbc: 9900         	ldr	r1, [sp]
700a3cbe: 6c49         	ldr	r1, [r1, #0x44]
700a3cc0: 4288         	cmp	r0, r1
700a3cc2: d22c         	bhs	0x700a3d1e <Udma_rmAllocRxCh+0x9e> @ imm = #0x58
700a3cc4: e7ff         	b	0x700a3cc6 <Udma_rmAllocRxCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3cc6: 9805         	ldr	r0, [sp, #0x14]
700a3cc8: 0940         	lsrs	r0, r0, #0x5
700a3cca: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3ccc: 9805         	ldr	r0, [sp, #0x14]
700a3cce: 9904         	ldr	r1, [sp, #0x10]
700a3cd0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3cd4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3cd6: 9903         	ldr	r1, [sp, #0xc]
700a3cd8: 2001         	movs	r0, #0x1
700a3cda: 4088         	lsls	r0, r1
700a3cdc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxChFlag[offset] & bitMask) == bitMask)
700a3cde: 9806         	ldr	r0, [sp, #0x18]
700a3ce0: 9904         	ldr	r1, [sp, #0x10]
700a3ce2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3ce6: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
700a3cea: 9902         	ldr	r1, [sp, #0x8]
700a3cec: 4008         	ands	r0, r1
700a3cee: 4288         	cmp	r0, r1
700a3cf0: d110         	bne	0x700a3d14 <Udma_rmAllocRxCh+0x94> @ imm = #0x20
700a3cf2: e7ff         	b	0x700a3cf4 <Udma_rmAllocRxCh+0x74> @ imm = #-0x2
;                 drvHandle->rxChFlag[offset] &= ~bitMask;
700a3cf4: 9a02         	ldr	r2, [sp, #0x8]
700a3cf6: 9806         	ldr	r0, [sp, #0x18]
700a3cf8: 9904         	ldr	r1, [sp, #0x10]
700a3cfa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3cfe: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700a3d02: 4390         	bics	r0, r2
700a3d04: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;                 chNum = i + rmInitPrms->startRxCh;  /* Add start offset */
700a3d08: 9805         	ldr	r0, [sp, #0x14]
700a3d0a: 9900         	ldr	r1, [sp]
700a3d0c: 6c09         	ldr	r1, [r1, #0x40]
700a3d0e: 4408         	add	r0, r1
700a3d10: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3d12: e004         	b	0x700a3d1e <Udma_rmAllocRxCh+0x9e> @ imm = #0x8
;         }
700a3d14: e7ff         	b	0x700a3d16 <Udma_rmAllocRxCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxCh; i++)
700a3d16: 9805         	ldr	r0, [sp, #0x14]
700a3d18: 3001         	adds	r0, #0x1
700a3d1a: 9005         	str	r0, [sp, #0x14]
700a3d1c: e7cd         	b	0x700a3cba <Udma_rmAllocRxCh+0x3a> @ imm = #-0x66
;     }
700a3d1e: e038         	b	0x700a3d92 <Udma_rmAllocRxCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxCh) &&
700a3d20: 9807         	ldr	r0, [sp, #0x1c]
700a3d22: 9900         	ldr	r1, [sp]
700a3d24: 6c09         	ldr	r1, [r1, #0x40]
700a3d26: 4288         	cmp	r0, r1
700a3d28: d332         	blo	0x700a3d90 <Udma_rmAllocRxCh+0x110> @ imm = #0x64
700a3d2a: e7ff         	b	0x700a3d2c <Udma_rmAllocRxCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxCh + rmInitPrms->numRxCh)))
700a3d2c: 9807         	ldr	r0, [sp, #0x1c]
700a3d2e: 9a00         	ldr	r2, [sp]
700a3d30: 6c11         	ldr	r1, [r2, #0x40]
700a3d32: 6c52         	ldr	r2, [r2, #0x44]
700a3d34: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxCh) &&
700a3d36: 4288         	cmp	r0, r1
700a3d38: d22a         	bhs	0x700a3d90 <Udma_rmAllocRxCh+0x110> @ imm = #0x54
700a3d3a: e7ff         	b	0x700a3d3c <Udma_rmAllocRxCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxCh;
700a3d3c: 9807         	ldr	r0, [sp, #0x1c]
700a3d3e: 9900         	ldr	r1, [sp]
700a3d40: 6c09         	ldr	r1, [r1, #0x40]
700a3d42: 1a40         	subs	r0, r0, r1
700a3d44: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3d46: 9805         	ldr	r0, [sp, #0x14]
700a3d48: 0940         	lsrs	r0, r0, #0x5
700a3d4a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3d4c: 9805         	ldr	r0, [sp, #0x14]
700a3d4e: 9904         	ldr	r1, [sp, #0x10]
700a3d50: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3d54: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3d56: 9903         	ldr	r1, [sp, #0xc]
700a3d58: 2001         	movs	r0, #0x1
700a3d5a: 4088         	lsls	r0, r1
700a3d5c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxChFlag[offset] & bitMask) == bitMask)
700a3d5e: 9806         	ldr	r0, [sp, #0x18]
700a3d60: 9904         	ldr	r1, [sp, #0x10]
700a3d62: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3d66: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
700a3d6a: 9902         	ldr	r1, [sp, #0x8]
700a3d6c: 4008         	ands	r0, r1
700a3d6e: 4288         	cmp	r0, r1
700a3d70: d10d         	bne	0x700a3d8e <Udma_rmAllocRxCh+0x10e> @ imm = #0x1a
700a3d72: e7ff         	b	0x700a3d74 <Udma_rmAllocRxCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxChFlag[offset] &= ~bitMask;
700a3d74: 9a02         	ldr	r2, [sp, #0x8]
700a3d76: 9806         	ldr	r0, [sp, #0x18]
700a3d78: 9904         	ldr	r1, [sp, #0x10]
700a3d7a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3d7e: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700a3d82: 4390         	bics	r0, r2
700a3d84: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;                 chNum = preferredChNum;
700a3d88: 9807         	ldr	r0, [sp, #0x1c]
700a3d8a: 9001         	str	r0, [sp, #0x4]
;             }
700a3d8c: e7ff         	b	0x700a3d8e <Udma_rmAllocRxCh+0x10e> @ imm = #-0x2
;         }
700a3d8e: e7ff         	b	0x700a3d90 <Udma_rmAllocRxCh+0x110> @ imm = #-0x2
700a3d90: e7ff         	b	0x700a3d92 <Udma_rmAllocRxCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3d92: 9806         	ldr	r0, [sp, #0x18]
700a3d94: f500 609f    	add.w	r0, r0, #0x4f8
700a3d98: f008 f8b2    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x8164
;     return (chNum);
700a3d9c: 9801         	ldr	r0, [sp, #0x4]
700a3d9e: b008         	add	sp, #0x20
700a3da0: bd80         	pop	{r7, pc}
		...
700a3dae: 0000         	movs	r0, r0

700a3db0 <Udma_rmAllocRxHcCh>:
; {
700a3db0: b580         	push	{r7, lr}
700a3db2: b088         	sub	sp, #0x20
700a3db4: 9007         	str	r0, [sp, #0x1c]
700a3db6: 9106         	str	r1, [sp, #0x18]
700a3db8: 2000         	movs	r0, #0x0
700a3dba: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3dbe: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3dc0: 9806         	ldr	r0, [sp, #0x18]
700a3dc2: f500 70ea    	add.w	r0, r0, #0x1d4
700a3dc6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3dc8: 9806         	ldr	r0, [sp, #0x18]
700a3dca: f500 609f    	add.w	r0, r0, #0x4f8
700a3dce: f04f 31ff    	mov.w	r1, #0xffffffff
700a3dd2: f006 fd05    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x6a0a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3dd6: 9807         	ldr	r0, [sp, #0x1c]
700a3dd8: 2101         	movs	r1, #0x1
700a3dda: f6cf 71ff    	movt	r1, #0xffff
700a3dde: 4288         	cmp	r0, r1
700a3de0: d136         	bne	0x700a3e50 <Udma_rmAllocRxHcCh+0xa0> @ imm = #0x6c
700a3de2: e7ff         	b	0x700a3de4 <Udma_rmAllocRxHcCh+0x34> @ imm = #-0x2
700a3de4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxHcCh; i++)
700a3de6: 9005         	str	r0, [sp, #0x14]
700a3de8: e7ff         	b	0x700a3dea <Udma_rmAllocRxHcCh+0x3a> @ imm = #-0x2
700a3dea: 9805         	ldr	r0, [sp, #0x14]
700a3dec: 9900         	ldr	r1, [sp]
700a3dee: 6bc9         	ldr	r1, [r1, #0x3c]
700a3df0: 4288         	cmp	r0, r1
700a3df2: d22c         	bhs	0x700a3e4e <Udma_rmAllocRxHcCh+0x9e> @ imm = #0x58
700a3df4: e7ff         	b	0x700a3df6 <Udma_rmAllocRxHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3df6: 9805         	ldr	r0, [sp, #0x14]
700a3df8: 0940         	lsrs	r0, r0, #0x5
700a3dfa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3dfc: 9805         	ldr	r0, [sp, #0x14]
700a3dfe: 9904         	ldr	r1, [sp, #0x10]
700a3e00: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3e04: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3e06: 9903         	ldr	r1, [sp, #0xc]
700a3e08: 2001         	movs	r0, #0x1
700a3e0a: 4088         	lsls	r0, r1
700a3e0c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxHcChFlag[offset] & bitMask) == bitMask)
700a3e0e: 9806         	ldr	r0, [sp, #0x18]
700a3e10: 9904         	ldr	r1, [sp, #0x10]
700a3e12: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3e16: f8d0 031c    	ldr.w	r0, [r0, #0x31c]
700a3e1a: 9902         	ldr	r1, [sp, #0x8]
700a3e1c: 4008         	ands	r0, r1
700a3e1e: 4288         	cmp	r0, r1
700a3e20: d110         	bne	0x700a3e44 <Udma_rmAllocRxHcCh+0x94> @ imm = #0x20
700a3e22: e7ff         	b	0x700a3e24 <Udma_rmAllocRxHcCh+0x74> @ imm = #-0x2
;                 drvHandle->rxHcChFlag[offset] &= ~bitMask;
700a3e24: 9a02         	ldr	r2, [sp, #0x8]
700a3e26: 9806         	ldr	r0, [sp, #0x18]
700a3e28: 9904         	ldr	r1, [sp, #0x10]
700a3e2a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3e2e: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700a3e32: 4390         	bics	r0, r2
700a3e34: f8c1 031c    	str.w	r0, [r1, #0x31c]
;                 chNum = i + rmInitPrms->startRxHcCh;  /* Add start offset */
700a3e38: 9805         	ldr	r0, [sp, #0x14]
700a3e3a: 9900         	ldr	r1, [sp]
700a3e3c: 6b89         	ldr	r1, [r1, #0x38]
700a3e3e: 4408         	add	r0, r1
700a3e40: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3e42: e004         	b	0x700a3e4e <Udma_rmAllocRxHcCh+0x9e> @ imm = #0x8
;         }
700a3e44: e7ff         	b	0x700a3e46 <Udma_rmAllocRxHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxHcCh; i++)
700a3e46: 9805         	ldr	r0, [sp, #0x14]
700a3e48: 3001         	adds	r0, #0x1
700a3e4a: 9005         	str	r0, [sp, #0x14]
700a3e4c: e7cd         	b	0x700a3dea <Udma_rmAllocRxHcCh+0x3a> @ imm = #-0x66
;     }
700a3e4e: e038         	b	0x700a3ec2 <Udma_rmAllocRxHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxHcCh) &&
700a3e50: 9807         	ldr	r0, [sp, #0x1c]
700a3e52: 9900         	ldr	r1, [sp]
700a3e54: 6b89         	ldr	r1, [r1, #0x38]
700a3e56: 4288         	cmp	r0, r1
700a3e58: d332         	blo	0x700a3ec0 <Udma_rmAllocRxHcCh+0x110> @ imm = #0x64
700a3e5a: e7ff         	b	0x700a3e5c <Udma_rmAllocRxHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxHcCh + rmInitPrms->numRxHcCh)))
700a3e5c: 9807         	ldr	r0, [sp, #0x1c]
700a3e5e: 9a00         	ldr	r2, [sp]
700a3e60: 6b91         	ldr	r1, [r2, #0x38]
700a3e62: 6bd2         	ldr	r2, [r2, #0x3c]
700a3e64: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxHcCh) &&
700a3e66: 4288         	cmp	r0, r1
700a3e68: d22a         	bhs	0x700a3ec0 <Udma_rmAllocRxHcCh+0x110> @ imm = #0x54
700a3e6a: e7ff         	b	0x700a3e6c <Udma_rmAllocRxHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxHcCh;
700a3e6c: 9807         	ldr	r0, [sp, #0x1c]
700a3e6e: 9900         	ldr	r1, [sp]
700a3e70: 6b89         	ldr	r1, [r1, #0x38]
700a3e72: 1a40         	subs	r0, r0, r1
700a3e74: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3e76: 9805         	ldr	r0, [sp, #0x14]
700a3e78: 0940         	lsrs	r0, r0, #0x5
700a3e7a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3e7c: 9805         	ldr	r0, [sp, #0x14]
700a3e7e: 9904         	ldr	r1, [sp, #0x10]
700a3e80: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3e84: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3e86: 9903         	ldr	r1, [sp, #0xc]
700a3e88: 2001         	movs	r0, #0x1
700a3e8a: 4088         	lsls	r0, r1
700a3e8c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxHcChFlag[offset] & bitMask) == bitMask)
700a3e8e: 9806         	ldr	r0, [sp, #0x18]
700a3e90: 9904         	ldr	r1, [sp, #0x10]
700a3e92: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3e96: f8d0 031c    	ldr.w	r0, [r0, #0x31c]
700a3e9a: 9902         	ldr	r1, [sp, #0x8]
700a3e9c: 4008         	ands	r0, r1
700a3e9e: 4288         	cmp	r0, r1
700a3ea0: d10d         	bne	0x700a3ebe <Udma_rmAllocRxHcCh+0x10e> @ imm = #0x1a
700a3ea2: e7ff         	b	0x700a3ea4 <Udma_rmAllocRxHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxHcChFlag[offset] &= ~bitMask;
700a3ea4: 9a02         	ldr	r2, [sp, #0x8]
700a3ea6: 9806         	ldr	r0, [sp, #0x18]
700a3ea8: 9904         	ldr	r1, [sp, #0x10]
700a3eaa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3eae: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700a3eb2: 4390         	bics	r0, r2
700a3eb4: f8c1 031c    	str.w	r0, [r1, #0x31c]
;                 chNum = preferredChNum;
700a3eb8: 9807         	ldr	r0, [sp, #0x1c]
700a3eba: 9001         	str	r0, [sp, #0x4]
;             }
700a3ebc: e7ff         	b	0x700a3ebe <Udma_rmAllocRxHcCh+0x10e> @ imm = #-0x2
;         }
700a3ebe: e7ff         	b	0x700a3ec0 <Udma_rmAllocRxHcCh+0x110> @ imm = #-0x2
700a3ec0: e7ff         	b	0x700a3ec2 <Udma_rmAllocRxHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3ec2: 9806         	ldr	r0, [sp, #0x18]
700a3ec4: f500 609f    	add.w	r0, r0, #0x4f8
700a3ec8: f008 f81a    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x8034
;     return (chNum);
700a3ecc: 9801         	ldr	r0, [sp, #0x4]
700a3ece: b008         	add	sp, #0x20
700a3ed0: bd80         	pop	{r7, pc}
		...
700a3ede: 0000         	movs	r0, r0

700a3ee0 <Udma_rmAllocRxUhcCh>:
; {
700a3ee0: b580         	push	{r7, lr}
700a3ee2: b088         	sub	sp, #0x20
700a3ee4: 9007         	str	r0, [sp, #0x1c]
700a3ee6: 9106         	str	r1, [sp, #0x18]
700a3ee8: 2000         	movs	r0, #0x0
700a3eea: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3eee: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3ef0: 9806         	ldr	r0, [sp, #0x18]
700a3ef2: f500 70ea    	add.w	r0, r0, #0x1d4
700a3ef6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3ef8: 9806         	ldr	r0, [sp, #0x18]
700a3efa: f500 609f    	add.w	r0, r0, #0x4f8
700a3efe: f04f 31ff    	mov.w	r1, #0xffffffff
700a3f02: f006 fc6d    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x68da
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3f06: 9807         	ldr	r0, [sp, #0x1c]
700a3f08: 2101         	movs	r1, #0x1
700a3f0a: f6cf 71ff    	movt	r1, #0xffff
700a3f0e: 4288         	cmp	r0, r1
700a3f10: d136         	bne	0x700a3f80 <Udma_rmAllocRxUhcCh+0xa0> @ imm = #0x6c
700a3f12: e7ff         	b	0x700a3f14 <Udma_rmAllocRxUhcCh+0x34> @ imm = #-0x2
700a3f14: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxUhcCh; i++)
700a3f16: 9005         	str	r0, [sp, #0x14]
700a3f18: e7ff         	b	0x700a3f1a <Udma_rmAllocRxUhcCh+0x3a> @ imm = #-0x2
700a3f1a: 9805         	ldr	r0, [sp, #0x14]
700a3f1c: 9900         	ldr	r1, [sp]
700a3f1e: 6b49         	ldr	r1, [r1, #0x34]
700a3f20: 4288         	cmp	r0, r1
700a3f22: d22c         	bhs	0x700a3f7e <Udma_rmAllocRxUhcCh+0x9e> @ imm = #0x58
700a3f24: e7ff         	b	0x700a3f26 <Udma_rmAllocRxUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3f26: 9805         	ldr	r0, [sp, #0x14]
700a3f28: 0940         	lsrs	r0, r0, #0x5
700a3f2a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3f2c: 9805         	ldr	r0, [sp, #0x14]
700a3f2e: 9904         	ldr	r1, [sp, #0x10]
700a3f30: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3f34: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3f36: 9903         	ldr	r1, [sp, #0xc]
700a3f38: 2001         	movs	r0, #0x1
700a3f3a: 4088         	lsls	r0, r1
700a3f3c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxUhcChFlag[offset] & bitMask) == bitMask)
700a3f3e: 9806         	ldr	r0, [sp, #0x18]
700a3f40: 9904         	ldr	r1, [sp, #0x10]
700a3f42: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3f46: f8d0 0320    	ldr.w	r0, [r0, #0x320]
700a3f4a: 9902         	ldr	r1, [sp, #0x8]
700a3f4c: 4008         	ands	r0, r1
700a3f4e: 4288         	cmp	r0, r1
700a3f50: d110         	bne	0x700a3f74 <Udma_rmAllocRxUhcCh+0x94> @ imm = #0x20
700a3f52: e7ff         	b	0x700a3f54 <Udma_rmAllocRxUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->rxUhcChFlag[offset] &= ~bitMask;
700a3f54: 9a02         	ldr	r2, [sp, #0x8]
700a3f56: 9806         	ldr	r0, [sp, #0x18]
700a3f58: 9904         	ldr	r1, [sp, #0x10]
700a3f5a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3f5e: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700a3f62: 4390         	bics	r0, r2
700a3f64: f8c1 0320    	str.w	r0, [r1, #0x320]
;                 chNum = i + rmInitPrms->startRxUhcCh;  /* Add start offset */
700a3f68: 9805         	ldr	r0, [sp, #0x14]
700a3f6a: 9900         	ldr	r1, [sp]
700a3f6c: 6b09         	ldr	r1, [r1, #0x30]
700a3f6e: 4408         	add	r0, r1
700a3f70: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3f72: e004         	b	0x700a3f7e <Udma_rmAllocRxUhcCh+0x9e> @ imm = #0x8
;         }
700a3f74: e7ff         	b	0x700a3f76 <Udma_rmAllocRxUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxUhcCh; i++)
700a3f76: 9805         	ldr	r0, [sp, #0x14]
700a3f78: 3001         	adds	r0, #0x1
700a3f7a: 9005         	str	r0, [sp, #0x14]
700a3f7c: e7cd         	b	0x700a3f1a <Udma_rmAllocRxUhcCh+0x3a> @ imm = #-0x66
;     }
700a3f7e: e038         	b	0x700a3ff2 <Udma_rmAllocRxUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxUhcCh) &&
700a3f80: 9807         	ldr	r0, [sp, #0x1c]
700a3f82: 9900         	ldr	r1, [sp]
700a3f84: 6b09         	ldr	r1, [r1, #0x30]
700a3f86: 4288         	cmp	r0, r1
700a3f88: d332         	blo	0x700a3ff0 <Udma_rmAllocRxUhcCh+0x110> @ imm = #0x64
700a3f8a: e7ff         	b	0x700a3f8c <Udma_rmAllocRxUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxUhcCh + rmInitPrms->numRxUhcCh)))
700a3f8c: 9807         	ldr	r0, [sp, #0x1c]
700a3f8e: 9a00         	ldr	r2, [sp]
700a3f90: 6b11         	ldr	r1, [r2, #0x30]
700a3f92: 6b52         	ldr	r2, [r2, #0x34]
700a3f94: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxUhcCh) &&
700a3f96: 4288         	cmp	r0, r1
700a3f98: d22a         	bhs	0x700a3ff0 <Udma_rmAllocRxUhcCh+0x110> @ imm = #0x54
700a3f9a: e7ff         	b	0x700a3f9c <Udma_rmAllocRxUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxUhcCh;
700a3f9c: 9807         	ldr	r0, [sp, #0x1c]
700a3f9e: 9900         	ldr	r1, [sp]
700a3fa0: 6b09         	ldr	r1, [r1, #0x30]
700a3fa2: 1a40         	subs	r0, r0, r1
700a3fa4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3fa6: 9805         	ldr	r0, [sp, #0x14]
700a3fa8: 0940         	lsrs	r0, r0, #0x5
700a3faa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3fac: 9805         	ldr	r0, [sp, #0x14]
700a3fae: 9904         	ldr	r1, [sp, #0x10]
700a3fb0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3fb4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3fb6: 9903         	ldr	r1, [sp, #0xc]
700a3fb8: 2001         	movs	r0, #0x1
700a3fba: 4088         	lsls	r0, r1
700a3fbc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxUhcChFlag[offset] & bitMask) == bitMask)
700a3fbe: 9806         	ldr	r0, [sp, #0x18]
700a3fc0: 9904         	ldr	r1, [sp, #0x10]
700a3fc2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3fc6: f8d0 0320    	ldr.w	r0, [r0, #0x320]
700a3fca: 9902         	ldr	r1, [sp, #0x8]
700a3fcc: 4008         	ands	r0, r1
700a3fce: 4288         	cmp	r0, r1
700a3fd0: d10d         	bne	0x700a3fee <Udma_rmAllocRxUhcCh+0x10e> @ imm = #0x1a
700a3fd2: e7ff         	b	0x700a3fd4 <Udma_rmAllocRxUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxUhcChFlag[offset] &= ~bitMask;
700a3fd4: 9a02         	ldr	r2, [sp, #0x8]
700a3fd6: 9806         	ldr	r0, [sp, #0x18]
700a3fd8: 9904         	ldr	r1, [sp, #0x10]
700a3fda: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3fde: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700a3fe2: 4390         	bics	r0, r2
700a3fe4: f8c1 0320    	str.w	r0, [r1, #0x320]
;                 chNum = preferredChNum;
700a3fe8: 9807         	ldr	r0, [sp, #0x1c]
700a3fea: 9001         	str	r0, [sp, #0x4]
;             }
700a3fec: e7ff         	b	0x700a3fee <Udma_rmAllocRxUhcCh+0x10e> @ imm = #-0x2
;         }
700a3fee: e7ff         	b	0x700a3ff0 <Udma_rmAllocRxUhcCh+0x110> @ imm = #-0x2
700a3ff0: e7ff         	b	0x700a3ff2 <Udma_rmAllocRxUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3ff2: 9806         	ldr	r0, [sp, #0x18]
700a3ff4: f500 609f    	add.w	r0, r0, #0x4f8
700a3ff8: f007 ff82    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x7f04
;     return (chNum);
700a3ffc: 9801         	ldr	r0, [sp, #0x4]
700a3ffe: b008         	add	sp, #0x20
700a4000: bd80         	pop	{r7, pc}
		...
700a400e: 0000         	movs	r0, r0

700a4010 <Udma_rmAllocTxCh>:
; {
700a4010: b580         	push	{r7, lr}
700a4012: b088         	sub	sp, #0x20
700a4014: 9007         	str	r0, [sp, #0x1c]
700a4016: 9106         	str	r1, [sp, #0x18]
700a4018: 2000         	movs	r0, #0x0
700a401a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a401e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a4020: 9806         	ldr	r0, [sp, #0x18]
700a4022: f500 70ea    	add.w	r0, r0, #0x1d4
700a4026: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a4028: 9806         	ldr	r0, [sp, #0x18]
700a402a: f500 609f    	add.w	r0, r0, #0x4f8
700a402e: f04f 31ff    	mov.w	r1, #0xffffffff
700a4032: f006 fbd5    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x67aa
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a4036: 9807         	ldr	r0, [sp, #0x1c]
700a4038: 2101         	movs	r1, #0x1
700a403a: f6cf 71ff    	movt	r1, #0xffff
700a403e: 4288         	cmp	r0, r1
700a4040: d136         	bne	0x700a40b0 <Udma_rmAllocTxCh+0xa0> @ imm = #0x6c
700a4042: e7ff         	b	0x700a4044 <Udma_rmAllocTxCh+0x34> @ imm = #-0x2
700a4044: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxCh; i++)
700a4046: 9005         	str	r0, [sp, #0x14]
700a4048: e7ff         	b	0x700a404a <Udma_rmAllocTxCh+0x3a> @ imm = #-0x2
700a404a: 9805         	ldr	r0, [sp, #0x14]
700a404c: 9900         	ldr	r1, [sp]
700a404e: 6ac9         	ldr	r1, [r1, #0x2c]
700a4050: 4288         	cmp	r0, r1
700a4052: d22c         	bhs	0x700a40ae <Udma_rmAllocTxCh+0x9e> @ imm = #0x58
700a4054: e7ff         	b	0x700a4056 <Udma_rmAllocTxCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a4056: 9805         	ldr	r0, [sp, #0x14]
700a4058: 0940         	lsrs	r0, r0, #0x5
700a405a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a405c: 9805         	ldr	r0, [sp, #0x14]
700a405e: 9904         	ldr	r1, [sp, #0x10]
700a4060: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a4064: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a4066: 9903         	ldr	r1, [sp, #0xc]
700a4068: 2001         	movs	r0, #0x1
700a406a: 4088         	lsls	r0, r1
700a406c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txChFlag[offset] & bitMask) == bitMask)
700a406e: 9806         	ldr	r0, [sp, #0x18]
700a4070: 9904         	ldr	r1, [sp, #0x10]
700a4072: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4076: f8d0 02d4    	ldr.w	r0, [r0, #0x2d4]
700a407a: 9902         	ldr	r1, [sp, #0x8]
700a407c: 4008         	ands	r0, r1
700a407e: 4288         	cmp	r0, r1
700a4080: d110         	bne	0x700a40a4 <Udma_rmAllocTxCh+0x94> @ imm = #0x20
700a4082: e7ff         	b	0x700a4084 <Udma_rmAllocTxCh+0x74> @ imm = #-0x2
;                 drvHandle->txChFlag[offset] &= ~bitMask;
700a4084: 9a02         	ldr	r2, [sp, #0x8]
700a4086: 9806         	ldr	r0, [sp, #0x18]
700a4088: 9904         	ldr	r1, [sp, #0x10]
700a408a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a408e: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700a4092: 4390         	bics	r0, r2
700a4094: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;                 chNum = i + rmInitPrms->startTxCh;  /* Add start offset */
700a4098: 9805         	ldr	r0, [sp, #0x14]
700a409a: 9900         	ldr	r1, [sp]
700a409c: 6a89         	ldr	r1, [r1, #0x28]
700a409e: 4408         	add	r0, r1
700a40a0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a40a2: e004         	b	0x700a40ae <Udma_rmAllocTxCh+0x9e> @ imm = #0x8
;         }
700a40a4: e7ff         	b	0x700a40a6 <Udma_rmAllocTxCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxCh; i++)
700a40a6: 9805         	ldr	r0, [sp, #0x14]
700a40a8: 3001         	adds	r0, #0x1
700a40aa: 9005         	str	r0, [sp, #0x14]
700a40ac: e7cd         	b	0x700a404a <Udma_rmAllocTxCh+0x3a> @ imm = #-0x66
;     }
700a40ae: e038         	b	0x700a4122 <Udma_rmAllocTxCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxCh) &&
700a40b0: 9807         	ldr	r0, [sp, #0x1c]
700a40b2: 9900         	ldr	r1, [sp]
700a40b4: 6a89         	ldr	r1, [r1, #0x28]
700a40b6: 4288         	cmp	r0, r1
700a40b8: d332         	blo	0x700a4120 <Udma_rmAllocTxCh+0x110> @ imm = #0x64
700a40ba: e7ff         	b	0x700a40bc <Udma_rmAllocTxCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxCh + rmInitPrms->numTxCh)))
700a40bc: 9807         	ldr	r0, [sp, #0x1c]
700a40be: 9a00         	ldr	r2, [sp]
700a40c0: 6a91         	ldr	r1, [r2, #0x28]
700a40c2: 6ad2         	ldr	r2, [r2, #0x2c]
700a40c4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxCh) &&
700a40c6: 4288         	cmp	r0, r1
700a40c8: d22a         	bhs	0x700a4120 <Udma_rmAllocTxCh+0x110> @ imm = #0x54
700a40ca: e7ff         	b	0x700a40cc <Udma_rmAllocTxCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxCh;
700a40cc: 9807         	ldr	r0, [sp, #0x1c]
700a40ce: 9900         	ldr	r1, [sp]
700a40d0: 6a89         	ldr	r1, [r1, #0x28]
700a40d2: 1a40         	subs	r0, r0, r1
700a40d4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a40d6: 9805         	ldr	r0, [sp, #0x14]
700a40d8: 0940         	lsrs	r0, r0, #0x5
700a40da: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a40dc: 9805         	ldr	r0, [sp, #0x14]
700a40de: 9904         	ldr	r1, [sp, #0x10]
700a40e0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a40e4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a40e6: 9903         	ldr	r1, [sp, #0xc]
700a40e8: 2001         	movs	r0, #0x1
700a40ea: 4088         	lsls	r0, r1
700a40ec: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txChFlag[offset] & bitMask) == bitMask)
700a40ee: 9806         	ldr	r0, [sp, #0x18]
700a40f0: 9904         	ldr	r1, [sp, #0x10]
700a40f2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a40f6: f8d0 02d4    	ldr.w	r0, [r0, #0x2d4]
700a40fa: 9902         	ldr	r1, [sp, #0x8]
700a40fc: 4008         	ands	r0, r1
700a40fe: 4288         	cmp	r0, r1
700a4100: d10d         	bne	0x700a411e <Udma_rmAllocTxCh+0x10e> @ imm = #0x1a
700a4102: e7ff         	b	0x700a4104 <Udma_rmAllocTxCh+0xf4> @ imm = #-0x2
;                 drvHandle->txChFlag[offset] &= ~bitMask;
700a4104: 9a02         	ldr	r2, [sp, #0x8]
700a4106: 9806         	ldr	r0, [sp, #0x18]
700a4108: 9904         	ldr	r1, [sp, #0x10]
700a410a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a410e: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700a4112: 4390         	bics	r0, r2
700a4114: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;                 chNum = preferredChNum;
700a4118: 9807         	ldr	r0, [sp, #0x1c]
700a411a: 9001         	str	r0, [sp, #0x4]
;             }
700a411c: e7ff         	b	0x700a411e <Udma_rmAllocTxCh+0x10e> @ imm = #-0x2
;         }
700a411e: e7ff         	b	0x700a4120 <Udma_rmAllocTxCh+0x110> @ imm = #-0x2
700a4120: e7ff         	b	0x700a4122 <Udma_rmAllocTxCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a4122: 9806         	ldr	r0, [sp, #0x18]
700a4124: f500 609f    	add.w	r0, r0, #0x4f8
700a4128: f007 feea    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x7dd4
;     return (chNum);
700a412c: 9801         	ldr	r0, [sp, #0x4]
700a412e: b008         	add	sp, #0x20
700a4130: bd80         	pop	{r7, pc}
		...
700a413e: 0000         	movs	r0, r0

700a4140 <Udma_rmAllocTxHcCh>:
; {
700a4140: b580         	push	{r7, lr}
700a4142: b088         	sub	sp, #0x20
700a4144: 9007         	str	r0, [sp, #0x1c]
700a4146: 9106         	str	r1, [sp, #0x18]
700a4148: 2000         	movs	r0, #0x0
700a414a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a414e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a4150: 9806         	ldr	r0, [sp, #0x18]
700a4152: f500 70ea    	add.w	r0, r0, #0x1d4
700a4156: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a4158: 9806         	ldr	r0, [sp, #0x18]
700a415a: f500 609f    	add.w	r0, r0, #0x4f8
700a415e: f04f 31ff    	mov.w	r1, #0xffffffff
700a4162: f006 fb3d    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x667a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a4166: 9807         	ldr	r0, [sp, #0x1c]
700a4168: 2101         	movs	r1, #0x1
700a416a: f6cf 71ff    	movt	r1, #0xffff
700a416e: 4288         	cmp	r0, r1
700a4170: d136         	bne	0x700a41e0 <Udma_rmAllocTxHcCh+0xa0> @ imm = #0x6c
700a4172: e7ff         	b	0x700a4174 <Udma_rmAllocTxHcCh+0x34> @ imm = #-0x2
700a4174: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxHcCh; i++)
700a4176: 9005         	str	r0, [sp, #0x14]
700a4178: e7ff         	b	0x700a417a <Udma_rmAllocTxHcCh+0x3a> @ imm = #-0x2
700a417a: 9805         	ldr	r0, [sp, #0x14]
700a417c: 9900         	ldr	r1, [sp]
700a417e: 6a49         	ldr	r1, [r1, #0x24]
700a4180: 4288         	cmp	r0, r1
700a4182: d22c         	bhs	0x700a41de <Udma_rmAllocTxHcCh+0x9e> @ imm = #0x58
700a4184: e7ff         	b	0x700a4186 <Udma_rmAllocTxHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a4186: 9805         	ldr	r0, [sp, #0x14]
700a4188: 0940         	lsrs	r0, r0, #0x5
700a418a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a418c: 9805         	ldr	r0, [sp, #0x14]
700a418e: 9904         	ldr	r1, [sp, #0x10]
700a4190: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a4194: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a4196: 9903         	ldr	r1, [sp, #0xc]
700a4198: 2001         	movs	r0, #0x1
700a419a: 4088         	lsls	r0, r1
700a419c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txHcChFlag[offset] & bitMask) == bitMask)
700a419e: 9806         	ldr	r0, [sp, #0x18]
700a41a0: 9904         	ldr	r1, [sp, #0x10]
700a41a2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a41a6: f8d0 02f4    	ldr.w	r0, [r0, #0x2f4]
700a41aa: 9902         	ldr	r1, [sp, #0x8]
700a41ac: 4008         	ands	r0, r1
700a41ae: 4288         	cmp	r0, r1
700a41b0: d110         	bne	0x700a41d4 <Udma_rmAllocTxHcCh+0x94> @ imm = #0x20
700a41b2: e7ff         	b	0x700a41b4 <Udma_rmAllocTxHcCh+0x74> @ imm = #-0x2
;                 drvHandle->txHcChFlag[offset] &= ~bitMask;
700a41b4: 9a02         	ldr	r2, [sp, #0x8]
700a41b6: 9806         	ldr	r0, [sp, #0x18]
700a41b8: 9904         	ldr	r1, [sp, #0x10]
700a41ba: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a41be: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700a41c2: 4390         	bics	r0, r2
700a41c4: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;                 chNum = i + rmInitPrms->startTxHcCh;  /* Add start offset */
700a41c8: 9805         	ldr	r0, [sp, #0x14]
700a41ca: 9900         	ldr	r1, [sp]
700a41cc: 6a09         	ldr	r1, [r1, #0x20]
700a41ce: 4408         	add	r0, r1
700a41d0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a41d2: e004         	b	0x700a41de <Udma_rmAllocTxHcCh+0x9e> @ imm = #0x8
;         }
700a41d4: e7ff         	b	0x700a41d6 <Udma_rmAllocTxHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxHcCh; i++)
700a41d6: 9805         	ldr	r0, [sp, #0x14]
700a41d8: 3001         	adds	r0, #0x1
700a41da: 9005         	str	r0, [sp, #0x14]
700a41dc: e7cd         	b	0x700a417a <Udma_rmAllocTxHcCh+0x3a> @ imm = #-0x66
;     }
700a41de: e038         	b	0x700a4252 <Udma_rmAllocTxHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxHcCh) &&
700a41e0: 9807         	ldr	r0, [sp, #0x1c]
700a41e2: 9900         	ldr	r1, [sp]
700a41e4: 6a09         	ldr	r1, [r1, #0x20]
700a41e6: 4288         	cmp	r0, r1
700a41e8: d332         	blo	0x700a4250 <Udma_rmAllocTxHcCh+0x110> @ imm = #0x64
700a41ea: e7ff         	b	0x700a41ec <Udma_rmAllocTxHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxHcCh + rmInitPrms->numTxHcCh)))
700a41ec: 9807         	ldr	r0, [sp, #0x1c]
700a41ee: 9a00         	ldr	r2, [sp]
700a41f0: 6a11         	ldr	r1, [r2, #0x20]
700a41f2: 6a52         	ldr	r2, [r2, #0x24]
700a41f4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxHcCh) &&
700a41f6: 4288         	cmp	r0, r1
700a41f8: d22a         	bhs	0x700a4250 <Udma_rmAllocTxHcCh+0x110> @ imm = #0x54
700a41fa: e7ff         	b	0x700a41fc <Udma_rmAllocTxHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxHcCh;
700a41fc: 9807         	ldr	r0, [sp, #0x1c]
700a41fe: 9900         	ldr	r1, [sp]
700a4200: 6a09         	ldr	r1, [r1, #0x20]
700a4202: 1a40         	subs	r0, r0, r1
700a4204: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a4206: 9805         	ldr	r0, [sp, #0x14]
700a4208: 0940         	lsrs	r0, r0, #0x5
700a420a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a420c: 9805         	ldr	r0, [sp, #0x14]
700a420e: 9904         	ldr	r1, [sp, #0x10]
700a4210: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a4214: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a4216: 9903         	ldr	r1, [sp, #0xc]
700a4218: 2001         	movs	r0, #0x1
700a421a: 4088         	lsls	r0, r1
700a421c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txHcChFlag[offset] & bitMask) == bitMask)
700a421e: 9806         	ldr	r0, [sp, #0x18]
700a4220: 9904         	ldr	r1, [sp, #0x10]
700a4222: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4226: f8d0 02f4    	ldr.w	r0, [r0, #0x2f4]
700a422a: 9902         	ldr	r1, [sp, #0x8]
700a422c: 4008         	ands	r0, r1
700a422e: 4288         	cmp	r0, r1
700a4230: d10d         	bne	0x700a424e <Udma_rmAllocTxHcCh+0x10e> @ imm = #0x1a
700a4232: e7ff         	b	0x700a4234 <Udma_rmAllocTxHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->txHcChFlag[offset] &= ~bitMask;
700a4234: 9a02         	ldr	r2, [sp, #0x8]
700a4236: 9806         	ldr	r0, [sp, #0x18]
700a4238: 9904         	ldr	r1, [sp, #0x10]
700a423a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a423e: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700a4242: 4390         	bics	r0, r2
700a4244: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;                 chNum = preferredChNum;
700a4248: 9807         	ldr	r0, [sp, #0x1c]
700a424a: 9001         	str	r0, [sp, #0x4]
;             }
700a424c: e7ff         	b	0x700a424e <Udma_rmAllocTxHcCh+0x10e> @ imm = #-0x2
;         }
700a424e: e7ff         	b	0x700a4250 <Udma_rmAllocTxHcCh+0x110> @ imm = #-0x2
700a4250: e7ff         	b	0x700a4252 <Udma_rmAllocTxHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a4252: 9806         	ldr	r0, [sp, #0x18]
700a4254: f500 609f    	add.w	r0, r0, #0x4f8
700a4258: f007 fe52    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x7ca4
;     return (chNum);
700a425c: 9801         	ldr	r0, [sp, #0x4]
700a425e: b008         	add	sp, #0x20
700a4260: bd80         	pop	{r7, pc}
		...
700a426e: 0000         	movs	r0, r0

700a4270 <Udma_rmAllocTxUhcCh>:
; {
700a4270: b580         	push	{r7, lr}
700a4272: b088         	sub	sp, #0x20
700a4274: 9007         	str	r0, [sp, #0x1c]
700a4276: 9106         	str	r1, [sp, #0x18]
700a4278: 2000         	movs	r0, #0x0
700a427a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a427e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a4280: 9806         	ldr	r0, [sp, #0x18]
700a4282: f500 70ea    	add.w	r0, r0, #0x1d4
700a4286: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a4288: 9806         	ldr	r0, [sp, #0x18]
700a428a: f500 609f    	add.w	r0, r0, #0x4f8
700a428e: f04f 31ff    	mov.w	r1, #0xffffffff
700a4292: f006 faa5    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x654a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a4296: 9807         	ldr	r0, [sp, #0x1c]
700a4298: 2101         	movs	r1, #0x1
700a429a: f6cf 71ff    	movt	r1, #0xffff
700a429e: 4288         	cmp	r0, r1
700a42a0: d136         	bne	0x700a4310 <Udma_rmAllocTxUhcCh+0xa0> @ imm = #0x6c
700a42a2: e7ff         	b	0x700a42a4 <Udma_rmAllocTxUhcCh+0x34> @ imm = #-0x2
700a42a4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxUhcCh; i++)
700a42a6: 9005         	str	r0, [sp, #0x14]
700a42a8: e7ff         	b	0x700a42aa <Udma_rmAllocTxUhcCh+0x3a> @ imm = #-0x2
700a42aa: 9805         	ldr	r0, [sp, #0x14]
700a42ac: 9900         	ldr	r1, [sp]
700a42ae: 69c9         	ldr	r1, [r1, #0x1c]
700a42b0: 4288         	cmp	r0, r1
700a42b2: d22c         	bhs	0x700a430e <Udma_rmAllocTxUhcCh+0x9e> @ imm = #0x58
700a42b4: e7ff         	b	0x700a42b6 <Udma_rmAllocTxUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a42b6: 9805         	ldr	r0, [sp, #0x14]
700a42b8: 0940         	lsrs	r0, r0, #0x5
700a42ba: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a42bc: 9805         	ldr	r0, [sp, #0x14]
700a42be: 9904         	ldr	r1, [sp, #0x10]
700a42c0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a42c4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a42c6: 9903         	ldr	r1, [sp, #0xc]
700a42c8: 2001         	movs	r0, #0x1
700a42ca: 4088         	lsls	r0, r1
700a42cc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txUhcChFlag[offset] & bitMask) == bitMask)
700a42ce: 9806         	ldr	r0, [sp, #0x18]
700a42d0: 9904         	ldr	r1, [sp, #0x10]
700a42d2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a42d6: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a42da: 9902         	ldr	r1, [sp, #0x8]
700a42dc: 4008         	ands	r0, r1
700a42de: 4288         	cmp	r0, r1
700a42e0: d110         	bne	0x700a4304 <Udma_rmAllocTxUhcCh+0x94> @ imm = #0x20
700a42e2: e7ff         	b	0x700a42e4 <Udma_rmAllocTxUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->txUhcChFlag[offset] &= ~bitMask;
700a42e4: 9a02         	ldr	r2, [sp, #0x8]
700a42e6: 9806         	ldr	r0, [sp, #0x18]
700a42e8: 9904         	ldr	r1, [sp, #0x10]
700a42ea: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a42ee: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700a42f2: 4390         	bics	r0, r2
700a42f4: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;                 chNum = i + rmInitPrms->startTxUhcCh;  /* Add start offset */
700a42f8: 9805         	ldr	r0, [sp, #0x14]
700a42fa: 9900         	ldr	r1, [sp]
700a42fc: 6989         	ldr	r1, [r1, #0x18]
700a42fe: 4408         	add	r0, r1
700a4300: 9001         	str	r0, [sp, #0x4]
;                 break;
700a4302: e004         	b	0x700a430e <Udma_rmAllocTxUhcCh+0x9e> @ imm = #0x8
;         }
700a4304: e7ff         	b	0x700a4306 <Udma_rmAllocTxUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxUhcCh; i++)
700a4306: 9805         	ldr	r0, [sp, #0x14]
700a4308: 3001         	adds	r0, #0x1
700a430a: 9005         	str	r0, [sp, #0x14]
700a430c: e7cd         	b	0x700a42aa <Udma_rmAllocTxUhcCh+0x3a> @ imm = #-0x66
;     }
700a430e: e038         	b	0x700a4382 <Udma_rmAllocTxUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxUhcCh) &&
700a4310: 9807         	ldr	r0, [sp, #0x1c]
700a4312: 9900         	ldr	r1, [sp]
700a4314: 6989         	ldr	r1, [r1, #0x18]
700a4316: 4288         	cmp	r0, r1
700a4318: d332         	blo	0x700a4380 <Udma_rmAllocTxUhcCh+0x110> @ imm = #0x64
700a431a: e7ff         	b	0x700a431c <Udma_rmAllocTxUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxUhcCh + rmInitPrms->numTxUhcCh)))
700a431c: 9807         	ldr	r0, [sp, #0x1c]
700a431e: 9a00         	ldr	r2, [sp]
700a4320: 6991         	ldr	r1, [r2, #0x18]
700a4322: 69d2         	ldr	r2, [r2, #0x1c]
700a4324: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxUhcCh) &&
700a4326: 4288         	cmp	r0, r1
700a4328: d22a         	bhs	0x700a4380 <Udma_rmAllocTxUhcCh+0x110> @ imm = #0x54
700a432a: e7ff         	b	0x700a432c <Udma_rmAllocTxUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxUhcCh;
700a432c: 9807         	ldr	r0, [sp, #0x1c]
700a432e: 9900         	ldr	r1, [sp]
700a4330: 6989         	ldr	r1, [r1, #0x18]
700a4332: 1a40         	subs	r0, r0, r1
700a4334: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a4336: 9805         	ldr	r0, [sp, #0x14]
700a4338: 0940         	lsrs	r0, r0, #0x5
700a433a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a433c: 9805         	ldr	r0, [sp, #0x14]
700a433e: 9904         	ldr	r1, [sp, #0x10]
700a4340: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a4344: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a4346: 9903         	ldr	r1, [sp, #0xc]
700a4348: 2001         	movs	r0, #0x1
700a434a: 4088         	lsls	r0, r1
700a434c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txUhcChFlag[offset] & bitMask) == bitMask)
700a434e: 9806         	ldr	r0, [sp, #0x18]
700a4350: 9904         	ldr	r1, [sp, #0x10]
700a4352: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4356: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a435a: 9902         	ldr	r1, [sp, #0x8]
700a435c: 4008         	ands	r0, r1
700a435e: 4288         	cmp	r0, r1
700a4360: d10d         	bne	0x700a437e <Udma_rmAllocTxUhcCh+0x10e> @ imm = #0x1a
700a4362: e7ff         	b	0x700a4364 <Udma_rmAllocTxUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->txUhcChFlag[offset] &= ~bitMask;
700a4364: 9a02         	ldr	r2, [sp, #0x8]
700a4366: 9806         	ldr	r0, [sp, #0x18]
700a4368: 9904         	ldr	r1, [sp, #0x10]
700a436a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a436e: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700a4372: 4390         	bics	r0, r2
700a4374: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;                 chNum = preferredChNum;
700a4378: 9807         	ldr	r0, [sp, #0x1c]
700a437a: 9001         	str	r0, [sp, #0x4]
;             }
700a437c: e7ff         	b	0x700a437e <Udma_rmAllocTxUhcCh+0x10e> @ imm = #-0x2
;         }
700a437e: e7ff         	b	0x700a4380 <Udma_rmAllocTxUhcCh+0x110> @ imm = #-0x2
700a4380: e7ff         	b	0x700a4382 <Udma_rmAllocTxUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a4382: 9806         	ldr	r0, [sp, #0x18]
700a4384: f500 609f    	add.w	r0, r0, #0x4f8
700a4388: f007 fdba    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x7b74
;     return (chNum);
700a438c: 9801         	ldr	r0, [sp, #0x4]
700a438e: b008         	add	sp, #0x20
700a4390: bd80         	pop	{r7, pc}
		...
700a439e: 0000         	movs	r0, r0

700a43a0 <UART_udmaInitRxCh>:
; {
700a43a0: b580         	push	{r7, lr}
700a43a2: b0be         	sub	sp, #0xf8
700a43a4: 903d         	str	r0, [sp, #0xf4]
700a43a6: 913c         	str	r1, [sp, #0xf0]
700a43a8: 200a         	movs	r0, #0xa
;     chType = UDMA_CH_TYPE_PDMA_RX;
700a43aa: 903a         	str	r0, [sp, #0xe8]
;     UdmaChPrms_init(&chPrms, chType);
700a43ac: 993a         	ldr	r1, [sp, #0xe8]
700a43ae: a821         	add	r0, sp, #0x84
700a43b0: f007 f97e    	bl	0x700ab6b0 <UdmaChPrms_init> @ imm = #0x72fc
;     chPrms.peerChNum                = hUart->hUartInit->rxEvtNum;
700a43b4: 983d         	ldr	r0, [sp, #0xf4]
700a43b6: 6840         	ldr	r0, [r0, #0x4]
700a43b8: 6c00         	ldr	r0, [r0, #0x40]
700a43ba: 9022         	str	r0, [sp, #0x88]
;     chPrms.fqRingPrms.ringMem       = udmaChCfg->rxRingMem;
700a43bc: 983c         	ldr	r0, [sp, #0xf0]
700a43be: 6a80         	ldr	r0, [r0, #0x28]
700a43c0: 9025         	str	r0, [sp, #0x94]
;     chPrms.fqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a43c2: 983c         	ldr	r0, [sp, #0xf0]
700a43c4: 6b00         	ldr	r0, [r0, #0x30]
700a43c6: 9026         	str	r0, [sp, #0x98]
;     chPrms.fqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a43c8: 983c         	ldr	r0, [sp, #0xf0]
700a43ca: 6b40         	ldr	r0, [r0, #0x34]
700a43cc: 9028         	str	r0, [sp, #0xa0]
;     if(udmaChCfg->isCqRingMem == UDMA_COMP_QUEUE_RING_MEM_ENABLED){
700a43ce: 983c         	ldr	r0, [sp, #0xf0]
700a43d0: 6bc0         	ldr	r0, [r0, #0x3c]
700a43d2: 2801         	cmp	r0, #0x1
700a43d4: d10a         	bne	0x700a43ec <UART_udmaInitRxCh+0x4c> @ imm = #0x14
700a43d6: e7ff         	b	0x700a43d8 <UART_udmaInitRxCh+0x38> @ imm = #-0x2
;         chPrms.cqRingPrms.ringMem       = udmaChCfg->cqRxRingMem;
700a43d8: 983c         	ldr	r0, [sp, #0xf0]
700a43da: 6ac0         	ldr	r0, [r0, #0x2c]
700a43dc: 902c         	str	r0, [sp, #0xb0]
;         chPrms.cqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a43de: 983c         	ldr	r0, [sp, #0xf0]
700a43e0: 6b00         	ldr	r0, [r0, #0x30]
700a43e2: 902d         	str	r0, [sp, #0xb4]
;         chPrms.cqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a43e4: 983c         	ldr	r0, [sp, #0xf0]
700a43e6: 6b40         	ldr	r0, [r0, #0x34]
700a43e8: 902f         	str	r0, [sp, #0xbc]
;     }
700a43ea: e7ff         	b	0x700a43ec <UART_udmaInitRxCh+0x4c> @ imm = #-0x2
;     rxChHandle                      = udmaChCfg->rxChHandle;
700a43ec: 983c         	ldr	r0, [sp, #0xf0]
700a43ee: 6880         	ldr	r0, [r0, #0x8]
700a43f0: 9006         	str	r0, [sp, #0x18]
;     drvHandle                       = udmaChCfg->drvHandle;
700a43f2: 983c         	ldr	r0, [sp, #0xf0]
700a43f4: 6800         	ldr	r0, [r0]
700a43f6: 9007         	str	r0, [sp, #0x1c]
;     retVal = Udma_chOpen(drvHandle, rxChHandle, chType, &chPrms);
700a43f8: 9807         	ldr	r0, [sp, #0x1c]
700a43fa: 9906         	ldr	r1, [sp, #0x18]
700a43fc: 9a3a         	ldr	r2, [sp, #0xe8]
700a43fe: ab21         	add	r3, sp, #0x84
700a4400: f7fd fb2e    	bl	0x700a1a60 <Udma_chOpen> @ imm = #-0x29a4
700a4404: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a4406: 983b         	ldr	r0, [sp, #0xec]
700a4408: fab0 f080    	clz	r0, r0
700a440c: 0940         	lsrs	r0, r0, #0x5
700a440e: f641 716f    	movw	r1, #0x1f6f
700a4412: f2c7 010b    	movt	r1, #0x700b
700a4416: 9103         	str	r1, [sp, #0xc]
700a4418: 466a         	mov	r2, sp
700a441a: 6011         	str	r1, [r2]
700a441c: f641 316c    	movw	r1, #0x1b6c
700a4420: f2c7 010b    	movt	r1, #0x700b
700a4424: 9104         	str	r1, [sp, #0x10]
700a4426: f641 72f3    	movw	r2, #0x1ff3
700a442a: f2c7 020b    	movt	r2, #0x700b
700a442e: 9205         	str	r2, [sp, #0x14]
700a4430: 2366         	movs	r3, #0x66
700a4432: f006 fc2d    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x685a
;     UdmaChRxPrms_init(&rxPrms, chType);
700a4436: 993a         	ldr	r1, [sp, #0xe8]
700a4438: a81a         	add	r0, sp, #0x68
700a443a: 9001         	str	r0, [sp, #0x4]
700a443c: f003 fde0    	bl	0x700a8000 <UdmaChRxPrms_init> @ imm = #0x3bc0
700a4440: 9901         	ldr	r1, [sp, #0x4]
;     retVal = Udma_chConfigRx(rxChHandle, &rxPrms);
700a4442: 9806         	ldr	r0, [sp, #0x18]
700a4444: f7f9 fe34    	bl	0x7009e0b0 <Udma_chConfigRx> @ imm = #-0x6398
700a4448: 9b03         	ldr	r3, [sp, #0xc]
700a444a: 9904         	ldr	r1, [sp, #0x10]
700a444c: 9a05         	ldr	r2, [sp, #0x14]
700a444e: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a4450: 983b         	ldr	r0, [sp, #0xec]
700a4452: fab0 f080    	clz	r0, r0
700a4456: 0940         	lsrs	r0, r0, #0x5
700a4458: 46ec         	mov	r12, sp
700a445a: f8cc 3000    	str.w	r3, [r12]
700a445e: 236b         	movs	r3, #0x6b
700a4460: f006 fc16    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x682c
;     eventHandle = udmaChCfg->cqRxEvtHandle;
700a4464: 983c         	ldr	r0, [sp, #0xf0]
700a4466: 6900         	ldr	r0, [r0, #0x10]
700a4468: 9019         	str	r0, [sp, #0x64]
700a446a: a808         	add	r0, sp, #0x20
;     UdmaEventPrms_init(&eventPrms);
700a446c: 9002         	str	r0, [sp, #0x8]
700a446e: f007 fd7f    	bl	0x700abf70 <UdmaEventPrms_init> @ imm = #0x7afe
700a4472: 2001         	movs	r0, #0x1
;     eventPrms.eventType         = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a4474: 9008         	str	r0, [sp, #0x20]
700a4476: 2002         	movs	r0, #0x2
;     eventPrms.eventMode         = UDMA_EVENT_MODE_SHARED;
700a4478: 9009         	str	r0, [sp, #0x24]
;     eventPrms.chHandle          = rxChHandle;
700a447a: 9806         	ldr	r0, [sp, #0x18]
700a447c: 900a         	str	r0, [sp, #0x28]
;     eventPrms.controllerEventHandle = Udma_eventGetGlobalHandle(drvHandle);
700a447e: 9807         	ldr	r0, [sp, #0x1c]
700a4480: f008 fc76    	bl	0x700acd70 <Udma_eventGetGlobalHandle> @ imm = #0x88ec
700a4484: 9a02         	ldr	r2, [sp, #0x8]
700a4486: 900c         	str	r0, [sp, #0x30]
;     eventPrms.eventCb           = &UART_udmaIsrRx;
700a4488: f249 7081    	movw	r0, #0x9781
700a448c: f2c7 000a    	movt	r0, #0x700a
700a4490: 900d         	str	r0, [sp, #0x34]
;     eventPrms.appData           = (void *) hUart;
700a4492: 983d         	ldr	r0, [sp, #0xf4]
700a4494: 900f         	str	r0, [sp, #0x3c]
;     retVal = Udma_eventRegister(drvHandle, eventHandle, &eventPrms);
700a4496: 9807         	ldr	r0, [sp, #0x1c]
700a4498: 9919         	ldr	r1, [sp, #0x64]
700a449a: f7fa fbd9    	bl	0x7009ec50 <Udma_eventRegister> @ imm = #-0x584e
700a449e: 9b03         	ldr	r3, [sp, #0xc]
700a44a0: 9904         	ldr	r1, [sp, #0x10]
700a44a2: 9a05         	ldr	r2, [sp, #0x14]
700a44a4: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a44a6: 983b         	ldr	r0, [sp, #0xec]
700a44a8: fab0 f080    	clz	r0, r0
700a44ac: 0940         	lsrs	r0, r0, #0x5
700a44ae: 46ec         	mov	r12, sp
700a44b0: f8cc 3000    	str.w	r3, [r12]
700a44b4: 2377         	movs	r3, #0x77
700a44b6: f006 fbeb    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x67d6
;     return retVal;
700a44ba: 983b         	ldr	r0, [sp, #0xec]
700a44bc: b03e         	add	sp, #0xf8
700a44be: bd80         	pop	{r7, pc}

700a44c0 <UART_udmaInitTxCh>:
; {
700a44c0: b580         	push	{r7, lr}
700a44c2: b0bc         	sub	sp, #0xf0
700a44c4: 903b         	str	r0, [sp, #0xec]
700a44c6: 913a         	str	r1, [sp, #0xe8]
700a44c8: 2009         	movs	r0, #0x9
;     chType = UDMA_CH_TYPE_PDMA_TX;
700a44ca: 9038         	str	r0, [sp, #0xe0]
;     UdmaChPrms_init(&chPrms, chType);
700a44cc: 9938         	ldr	r1, [sp, #0xe0]
700a44ce: a81f         	add	r0, sp, #0x7c
700a44d0: f007 f8ee    	bl	0x700ab6b0 <UdmaChPrms_init> @ imm = #0x71dc
;     chPrms.peerChNum                = hUart->hUartInit->txEvtNum;
700a44d4: 983b         	ldr	r0, [sp, #0xec]
700a44d6: 6840         	ldr	r0, [r0, #0x4]
700a44d8: 6c40         	ldr	r0, [r0, #0x44]
700a44da: 9020         	str	r0, [sp, #0x80]
;     chPrms.fqRingPrms.ringMem       = udmaChCfg->txRingMem;
700a44dc: 983a         	ldr	r0, [sp, #0xe8]
700a44de: 6a00         	ldr	r0, [r0, #0x20]
700a44e0: 9023         	str	r0, [sp, #0x8c]
;     chPrms.fqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a44e2: 983a         	ldr	r0, [sp, #0xe8]
700a44e4: 6b00         	ldr	r0, [r0, #0x30]
700a44e6: 9024         	str	r0, [sp, #0x90]
;     chPrms.fqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a44e8: 983a         	ldr	r0, [sp, #0xe8]
700a44ea: 6b40         	ldr	r0, [r0, #0x34]
700a44ec: 9026         	str	r0, [sp, #0x98]
;     if(udmaChCfg->isCqRingMem == UDMA_COMP_QUEUE_RING_MEM_ENABLED){
700a44ee: 983a         	ldr	r0, [sp, #0xe8]
700a44f0: 6bc0         	ldr	r0, [r0, #0x3c]
700a44f2: 2801         	cmp	r0, #0x1
700a44f4: d10a         	bne	0x700a450c <UART_udmaInitTxCh+0x4c> @ imm = #0x14
700a44f6: e7ff         	b	0x700a44f8 <UART_udmaInitTxCh+0x38> @ imm = #-0x2
;         chPrms.cqRingPrms.ringMem       = udmaChCfg->cqTxRingMem;
700a44f8: 983a         	ldr	r0, [sp, #0xe8]
700a44fa: 6a40         	ldr	r0, [r0, #0x24]
700a44fc: 902a         	str	r0, [sp, #0xa8]
;         chPrms.cqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a44fe: 983a         	ldr	r0, [sp, #0xe8]
700a4500: 6b00         	ldr	r0, [r0, #0x30]
700a4502: 902b         	str	r0, [sp, #0xac]
;         chPrms.cqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a4504: 983a         	ldr	r0, [sp, #0xe8]
700a4506: 6b40         	ldr	r0, [r0, #0x34]
700a4508: 902d         	str	r0, [sp, #0xb4]
;     }
700a450a: e7ff         	b	0x700a450c <UART_udmaInitTxCh+0x4c> @ imm = #-0x2
;     txChHandle                      = udmaChCfg->txChHandle;
700a450c: 983a         	ldr	r0, [sp, #0xe8]
700a450e: 6840         	ldr	r0, [r0, #0x4]
700a4510: 9006         	str	r0, [sp, #0x18]
;     drvHandle                       = udmaChCfg->drvHandle;
700a4512: 983a         	ldr	r0, [sp, #0xe8]
700a4514: 6800         	ldr	r0, [r0]
700a4516: 9007         	str	r0, [sp, #0x1c]
;     retVal = Udma_chOpen(drvHandle, txChHandle, chType, &chPrms);
700a4518: 9807         	ldr	r0, [sp, #0x1c]
700a451a: 9906         	ldr	r1, [sp, #0x18]
700a451c: 9a38         	ldr	r2, [sp, #0xe0]
700a451e: ab1f         	add	r3, sp, #0x7c
700a4520: f7fd fa9e    	bl	0x700a1a60 <Udma_chOpen> @ imm = #-0x2ac4
700a4524: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a4526: 9839         	ldr	r0, [sp, #0xe4]
700a4528: fab0 f080    	clz	r0, r0
700a452c: 0940         	lsrs	r0, r0, #0x5
700a452e: f641 716f    	movw	r1, #0x1f6f
700a4532: f2c7 010b    	movt	r1, #0x700b
700a4536: 9103         	str	r1, [sp, #0xc]
700a4538: 466a         	mov	r2, sp
700a453a: 6011         	str	r1, [r2]
700a453c: f641 316c    	movw	r1, #0x1b6c
700a4540: f2c7 010b    	movt	r1, #0x700b
700a4544: 9104         	str	r1, [sp, #0x10]
700a4546: f242 023b    	movw	r2, #0x203b
700a454a: f2c7 020b    	movt	r2, #0x700b
700a454e: 9205         	str	r2, [sp, #0x14]
700a4550: 2398         	movs	r3, #0x98
700a4552: f006 fb9d    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x673a
;     UdmaChTxPrms_init(&txPrms, chType);
700a4556: 9938         	ldr	r1, [sp, #0xe0]
700a4558: a81a         	add	r0, sp, #0x68
700a455a: 9001         	str	r0, [sp, #0x4]
700a455c: f003 fda8    	bl	0x700a80b0 <UdmaChTxPrms_init> @ imm = #0x3b50
700a4560: 9901         	ldr	r1, [sp, #0x4]
;     retVal = Udma_chConfigTx(txChHandle, &txPrms);
700a4562: 9806         	ldr	r0, [sp, #0x18]
700a4564: f7fc f94c    	bl	0x700a0800 <Udma_chConfigTx> @ imm = #-0x3d68
700a4568: 9b03         	ldr	r3, [sp, #0xc]
700a456a: 9904         	ldr	r1, [sp, #0x10]
700a456c: 9a05         	ldr	r2, [sp, #0x14]
700a456e: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a4570: 9839         	ldr	r0, [sp, #0xe4]
700a4572: fab0 f080    	clz	r0, r0
700a4576: 0940         	lsrs	r0, r0, #0x5
700a4578: 46ec         	mov	r12, sp
700a457a: f8cc 3000    	str.w	r3, [r12]
700a457e: 239d         	movs	r3, #0x9d
700a4580: f006 fb86    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x670c
;     eventHandle = udmaChCfg->cqTxEvtHandle;
700a4584: 983a         	ldr	r0, [sp, #0xe8]
700a4586: 68c0         	ldr	r0, [r0, #0xc]
700a4588: 9019         	str	r0, [sp, #0x64]
700a458a: a808         	add	r0, sp, #0x20
;     UdmaEventPrms_init(&eventPrms);
700a458c: 9002         	str	r0, [sp, #0x8]
700a458e: f007 fcef    	bl	0x700abf70 <UdmaEventPrms_init> @ imm = #0x79de
700a4592: 2001         	movs	r0, #0x1
;     eventPrms.eventType         = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a4594: 9008         	str	r0, [sp, #0x20]
700a4596: 2002         	movs	r0, #0x2
;     eventPrms.eventMode         = UDMA_EVENT_MODE_SHARED;
700a4598: 9009         	str	r0, [sp, #0x24]
;     eventPrms.chHandle          = txChHandle;
700a459a: 9806         	ldr	r0, [sp, #0x18]
700a459c: 900a         	str	r0, [sp, #0x28]
;     eventPrms.controllerEventHandle = Udma_eventGetGlobalHandle(drvHandle);
700a459e: 9807         	ldr	r0, [sp, #0x1c]
700a45a0: f008 fbe6    	bl	0x700acd70 <Udma_eventGetGlobalHandle> @ imm = #0x87cc
700a45a4: 9a02         	ldr	r2, [sp, #0x8]
700a45a6: 900c         	str	r0, [sp, #0x30]
;     eventPrms.eventCb           = &UART_udmaIsrTx;
700a45a8: f649 0021    	movw	r0, #0x9821
700a45ac: f2c7 000a    	movt	r0, #0x700a
700a45b0: 900d         	str	r0, [sp, #0x34]
;     eventPrms.appData           = (void *) hUart;
700a45b2: 983b         	ldr	r0, [sp, #0xec]
700a45b4: 900f         	str	r0, [sp, #0x3c]
;     retVal = Udma_eventRegister(drvHandle, eventHandle, &eventPrms);
700a45b6: 9807         	ldr	r0, [sp, #0x1c]
700a45b8: 9919         	ldr	r1, [sp, #0x64]
700a45ba: f7fa fb49    	bl	0x7009ec50 <Udma_eventRegister> @ imm = #-0x596e
700a45be: 9b03         	ldr	r3, [sp, #0xc]
700a45c0: 9904         	ldr	r1, [sp, #0x10]
700a45c2: 9a05         	ldr	r2, [sp, #0x14]
700a45c4: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a45c6: 9839         	ldr	r0, [sp, #0xe4]
700a45c8: fab0 f080    	clz	r0, r0
700a45cc: 0940         	lsrs	r0, r0, #0x5
700a45ce: 46ec         	mov	r12, sp
700a45d0: f8cc 3000    	str.w	r3, [r12]
700a45d4: 23a9         	movs	r3, #0xa9
700a45d6: f006 fb5b    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x66b6
;     return retVal;
700a45da: 9839         	ldr	r0, [sp, #0xe4]
700a45dc: b03c         	add	sp, #0xf0
700a45de: bd80         	pop	{r7, pc}

700a45e0 <Sciclient_rmIaValidateEvt>:
; {
700a45e0: b580         	push	{r7, lr}
700a45e2: b086         	sub	sp, #0x18
700a45e4: 4684         	mov	r12, r0
700a45e6: 9808         	ldr	r0, [sp, #0x20]
700a45e8: f8cd c014    	str.w	r12, [sp, #0x14]
700a45ec: f8ad 1012    	strh.w	r1, [sp, #0x12]
700a45f0: f8ad 2010    	strh.w	r2, [sp, #0x10]
700a45f4: f88d 300f    	strb.w	r3, [sp, #0xf]
700a45f8: f88d 000e    	strb.w	r0, [sp, #0xe]
700a45fc: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a45fe: 9002         	str	r0, [sp, #0x8]
;     if (evt >= inst->n_sevt) {
700a4600: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a4604: 9905         	ldr	r1, [sp, #0x14]
700a4606: 8949         	ldrh	r1, [r1, #0xa]
700a4608: 4288         	cmp	r0, r1
700a460a: db04         	blt	0x700a4616 <Sciclient_rmIaValidateEvt+0x36> @ imm = #0x8
700a460c: e7ff         	b	0x700a460e <Sciclient_rmIaValidateEvt+0x2e> @ imm = #-0x2
700a460e: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a4612: 9002         	str	r0, [sp, #0x8]
;     }
700a4614: e7ff         	b	0x700a4616 <Sciclient_rmIaValidateEvt+0x36> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a4616: 9802         	ldr	r0, [sp, #0x8]
700a4618: 2800         	cmp	r0, #0x0
700a461a: d16d         	bne	0x700a46f8 <Sciclient_rmIaValidateEvt+0x118> @ imm = #0xda
700a461c: e7ff         	b	0x700a461e <Sciclient_rmIaValidateEvt+0x3e> @ imm = #-0x2
;         entry_int_map_lo = (volatile uint32_t *)(inst->imap + SCICLIENT_IA_ENTRY_INTMAP_LO(evt));
700a461e: 9805         	ldr	r0, [sp, #0x14]
700a4620: 6840         	ldr	r0, [r0, #0x4]
700a4622: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a4626: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a462a: 9001         	str	r0, [sp, #0x4]
;         if (in_use == true) {
700a462c: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700a4630: 07c0         	lsls	r0, r0, #0x1f
700a4632: 2800         	cmp	r0, #0x0
700a4634: d047         	beq	0x700a46c6 <Sciclient_rmIaValidateEvt+0xe6> @ imm = #0x8e
700a4636: e7ff         	b	0x700a4638 <Sciclient_rmIaValidateEvt+0x58> @ imm = #-0x2
;             reg_vint = CSL_REG32_FEXT(entry_int_map_lo,
700a4638: 9801         	ldr	r0, [sp, #0x4]
700a463a: f64f 7100    	movw	r1, #0xff00
700a463e: f2c0 0101    	movt	r1, #0x1
700a4642: 2208         	movs	r2, #0x8
700a4644: f00a fd8c    	bl	0x700af160 <CSL_REG32_FEXT_RAW> @ imm = #0xab18
700a4648: f8ad 0002    	strh.w	r0, [sp, #0x2]
;             reg_sb = CSL_REG32_FEXT(entry_int_map_lo,
700a464c: 9801         	ldr	r0, [sp, #0x4]
700a464e: 213f         	movs	r1, #0x3f
700a4650: 2200         	movs	r2, #0x0
700a4652: f00a fd85    	bl	0x700af160 <CSL_REG32_FEXT_RAW> @ imm = #0xab0a
700a4656: f8ad 0000    	strh.w	r0, [sp]
;             if ((reg_vint == 0u) && (reg_sb == 0u)) {
700a465a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a465e: b9f0         	cbnz	r0, 0x700a469e <Sciclient_rmIaValidateEvt+0xbe> @ imm = #0x3c
700a4660: e7ff         	b	0x700a4662 <Sciclient_rmIaValidateEvt+0x82> @ imm = #-0x2
700a4662: f8bd 0000    	ldrh.w	r0, [sp]
700a4666: b9d0         	cbnz	r0, 0x700a469e <Sciclient_rmIaValidateEvt+0xbe> @ imm = #0x34
700a4668: e7ff         	b	0x700a466a <Sciclient_rmIaValidateEvt+0x8a> @ imm = #-0x2
;                 if ((vint != reg_vint) &&
700a466a: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a466e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a4672: 4288         	cmp	r0, r1
700a4674: d012         	beq	0x700a469c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x24
700a4676: e7ff         	b	0x700a4678 <Sciclient_rmIaValidateEvt+0x98> @ imm = #-0x2
;                     (vint_sb_index != reg_sb) &&
700a4678: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a467c: f8bd 1000    	ldrh.w	r1, [sp]
700a4680: 4288         	cmp	r0, r1
700a4682: d00b         	beq	0x700a469c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x16
700a4684: e7ff         	b	0x700a4686 <Sciclient_rmIaValidateEvt+0xa6> @ imm = #-0x2
;                     (evt != inst->v0_b0_evt)) {
700a4686: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a468a: 9905         	ldr	r1, [sp, #0x14]
700a468c: 8a89         	ldrh	r1, [r1, #0x14]
;                 if ((vint != reg_vint) &&
700a468e: 4288         	cmp	r0, r1
700a4690: d004         	beq	0x700a469c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x8
700a4692: e7ff         	b	0x700a4694 <Sciclient_rmIaValidateEvt+0xb4> @ imm = #-0x2
700a4694: f06f 0001    	mvn	r0, #0x1
;                     r = CSL_EBADARGS;
700a4698: 9002         	str	r0, [sp, #0x8]
;                 }
700a469a: e7ff         	b	0x700a469c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #-0x2
;             } else {
700a469c: e012         	b	0x700a46c4 <Sciclient_rmIaValidateEvt+0xe4> @ imm = #0x24
;                 if ((vint != reg_vint) &&
700a469e: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a46a2: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a46a6: 4288         	cmp	r0, r1
700a46a8: d00b         	beq	0x700a46c2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #0x16
700a46aa: e7ff         	b	0x700a46ac <Sciclient_rmIaValidateEvt+0xcc> @ imm = #-0x2
;                     (vint_sb_index != reg_sb)) {
700a46ac: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a46b0: f8bd 1000    	ldrh.w	r1, [sp]
;                 if ((vint != reg_vint) &&
700a46b4: 4288         	cmp	r0, r1
700a46b6: d004         	beq	0x700a46c2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #0x8
700a46b8: e7ff         	b	0x700a46ba <Sciclient_rmIaValidateEvt+0xda> @ imm = #-0x2
700a46ba: f06f 0001    	mvn	r0, #0x1
;                     r = CSL_EBADARGS;
700a46be: 9002         	str	r0, [sp, #0x8]
;                 }
700a46c0: e7ff         	b	0x700a46c2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #-0x2
700a46c2: e7ff         	b	0x700a46c4 <Sciclient_rmIaValidateEvt+0xe4> @ imm = #-0x2
;         } else {
700a46c4: e017         	b	0x700a46f6 <Sciclient_rmIaValidateEvt+0x116> @ imm = #0x2e
;             if (((CSL_REG32_RD(entry_int_map_lo) != 0u) &&
700a46c6: 9801         	ldr	r0, [sp, #0x4]
700a46c8: f00b fac2    	bl	0x700afc50 <CSL_REG32_RD_RAW> @ imm = #0xb584
700a46cc: b138         	cbz	r0, 0x700a46de <Sciclient_rmIaValidateEvt+0xfe> @ imm = #0xe
700a46ce: e7ff         	b	0x700a46d0 <Sciclient_rmIaValidateEvt+0xf0> @ imm = #-0x2
;                  (Sciclient_rmIaEvtRomMapped(inst, evt) == false)) ||
700a46d0: 9805         	ldr	r0, [sp, #0x14]
700a46d2: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a46d6: f005 fcdb    	bl	0x700aa090 <Sciclient_rmIaEvtRomMapped> @ imm = #0x59b6
700a46da: b138         	cbz	r0, 0x700a46ec <Sciclient_rmIaValidateEvt+0x10c> @ imm = #0xe
700a46dc: e7ff         	b	0x700a46de <Sciclient_rmIaValidateEvt+0xfe> @ imm = #-0x2
;                 (evt == inst->v0_b0_evt)) {
700a46de: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a46e2: 9905         	ldr	r1, [sp, #0x14]
700a46e4: 8a89         	ldrh	r1, [r1, #0x14]
;             if (((CSL_REG32_RD(entry_int_map_lo) != 0u) &&
700a46e6: 4288         	cmp	r0, r1
700a46e8: d104         	bne	0x700a46f4 <Sciclient_rmIaValidateEvt+0x114> @ imm = #0x8
700a46ea: e7ff         	b	0x700a46ec <Sciclient_rmIaValidateEvt+0x10c> @ imm = #-0x2
700a46ec: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a46f0: 9002         	str	r0, [sp, #0x8]
;             }
700a46f2: e7ff         	b	0x700a46f4 <Sciclient_rmIaValidateEvt+0x114> @ imm = #-0x2
700a46f4: e7ff         	b	0x700a46f6 <Sciclient_rmIaValidateEvt+0x116> @ imm = #-0x2
;     }
700a46f6: e7ff         	b	0x700a46f8 <Sciclient_rmIaValidateEvt+0x118> @ imm = #-0x2
;     return r;
700a46f8: 9802         	ldr	r0, [sp, #0x8]
700a46fa: b006         	add	sp, #0x18
700a46fc: bd80         	pop	{r7, pc}
700a46fe: 0000         	movs	r0, r0

700a4700 <Sciclient_rmIrqVintAdd>:
; {
700a4700: b580         	push	{r7, lr}
700a4702: b08c         	sub	sp, #0x30
700a4704: 900b         	str	r0, [sp, #0x2c]
700a4706: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a4708: 900a         	str	r0, [sp, #0x28]
;     bool cfg_new_mapping = false;
700a470a: f88d 0026    	strb.w	r0, [sp, #0x26]
;     bool cfg_whole_route = false;
700a470e: f88d 0025    	strb.w	r0, [sp, #0x25]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a4712: 9008         	str	r0, [sp, #0x20]
;     r = Sciclient_rmIrqIsVintRouteSet(cfg, &vint_used);
700a4714: 980b         	ldr	r0, [sp, #0x2c]
700a4716: f10d 0127    	add.w	r1, sp, #0x27
700a471a: f002 fe21    	bl	0x700a7360 <Sciclient_rmIrqIsVintRouteSet> @ imm = #0x2c42
700a471e: 900a         	str	r0, [sp, #0x28]
;     if (r == SystemP_SUCCESS) {
700a4720: 980a         	ldr	r0, [sp, #0x28]
700a4722: b9a0         	cbnz	r0, 0x700a474e <Sciclient_rmIrqVintAdd+0x4e> @ imm = #0x28
700a4724: e7ff         	b	0x700a4726 <Sciclient_rmIrqVintAdd+0x26> @ imm = #-0x2
;         if ((vint_used == true) ||
700a4726: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a472a: 07c0         	lsls	r0, r0, #0x1f
700a472c: b930         	cbnz	r0, 0x700a473c <Sciclient_rmIrqVintAdd+0x3c> @ imm = #0xc
700a472e: e7ff         	b	0x700a4730 <Sciclient_rmIrqVintAdd+0x30> @ imm = #-0x2
;             (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg->valid_params) ==
700a4730: 980b         	ldr	r0, [sp, #0x2c]
700a4732: 6800         	ldr	r0, [r0]
700a4734: f007 f90c    	bl	0x700ab950 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0x7218
;         if ((vint_used == true) ||
700a4738: b120         	cbz	r0, 0x700a4744 <Sciclient_rmIrqVintAdd+0x44> @ imm = #0x8
700a473a: e7ff         	b	0x700a473c <Sciclient_rmIrqVintAdd+0x3c> @ imm = #-0x2
700a473c: 2001         	movs	r0, #0x1
;             cfg_new_mapping = true;
700a473e: f88d 0026    	strb.w	r0, [sp, #0x26]
;         } else {
700a4742: e003         	b	0x700a474c <Sciclient_rmIrqVintAdd+0x4c> @ imm = #0x6
700a4744: 2001         	movs	r0, #0x1
;             cfg_whole_route = true;
700a4746: f88d 0025    	strb.w	r0, [sp, #0x25]
700a474a: e7ff         	b	0x700a474c <Sciclient_rmIrqVintAdd+0x4c> @ imm = #-0x2
;     }
700a474c: e7ff         	b	0x700a474e <Sciclient_rmIrqVintAdd+0x4e> @ imm = #-0x2
;     if (cfg_new_mapping == true) {
700a474e: f89d 0026    	ldrb.w	r0, [sp, #0x26]
700a4752: 07c0         	lsls	r0, r0, #0x1f
700a4754: 2800         	cmp	r0, #0x0
700a4756: d04c         	beq	0x700a47f2 <Sciclient_rmIrqVintAdd+0xf2> @ imm = #0x98
700a4758: e7ff         	b	0x700a475a <Sciclient_rmIrqVintAdd+0x5a> @ imm = #-0x2
700a475a: 203c         	movs	r0, #0x3c
700a475c: f2c8 0000    	movt	r0, #0x8000
;         req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a4760: 9003         	str	r0, [sp, #0xc]
;         req.secondary_host = cfg->host;
700a4762: 980b         	ldr	r0, [sp, #0x2c]
700a4764: 7900         	ldrb	r0, [r0, #0x4]
700a4766: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         req.src_id = cfg->s_id;
700a476a: 980b         	ldr	r0, [sp, #0x2c]
700a476c: 88c0         	ldrh	r0, [r0, #0x6]
700a476e: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         req.src_index = cfg->s_idx;
700a4772: 980b         	ldr	r0, [sp, #0x2c]
700a4774: 8900         	ldrh	r0, [r0, #0x8]
700a4776: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         req.ia_id = cfg->s_ia;
700a477a: 980b         	ldr	r0, [sp, #0x2c]
700a477c: 8a00         	ldrh	r0, [r0, #0x10]
700a477e: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         req.vint = cfg->vint;
700a4782: 980b         	ldr	r0, [sp, #0x2c]
700a4784: 8a40         	ldrh	r0, [r0, #0x12]
700a4786: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         req.global_event = cfg->global_evt;
700a478a: 980b         	ldr	r0, [sp, #0x2c]
700a478c: 89c0         	ldrh	r0, [r0, #0xe]
700a478e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         req.vint_status_bit_index = cfg->vint_sb;
700a4792: 980b         	ldr	r0, [sp, #0x2c]
700a4794: 7d00         	ldrb	r0, [r0, #0x14]
700a4796: f88d 001e    	strb.w	r0, [sp, #0x1e]
;                                   cfg->set_resp,
700a479a: 980b         	ldr	r0, [sp, #0x2c]
700a479c: 6981         	ldr	r1, [r0, #0x18]
700a479e: a801         	add	r0, sp, #0x4
700a47a0: f04f 32ff    	mov.w	r2, #0xffffffff
;         r = Sciclient_rmIrqSetRaw(&req,
700a47a4: f008 f854    	bl	0x700ac850 <Sciclient_rmIrqSetRaw> @ imm = #0x80a8
700a47a8: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a47aa: 980a         	ldr	r0, [sp, #0x28]
700a47ac: bb00         	cbnz	r0, 0x700a47f0 <Sciclient_rmIrqVintAdd+0xf0> @ imm = #0x40
700a47ae: e7ff         	b	0x700a47b0 <Sciclient_rmIrqVintAdd+0xb0> @ imm = #-0x2
;             ia_inst = Sciclient_rmIaGetInst(cfg->s_ia);
700a47b0: 980b         	ldr	r0, [sp, #0x2c]
700a47b2: 8a00         	ldrh	r0, [r0, #0x10]
700a47b4: f007 fecc    	bl	0x700ac550 <Sciclient_rmIaGetInst> @ imm = #0x7d98
700a47b8: 9008         	str	r0, [sp, #0x20]
;             if (ia_inst != NULL) {
700a47ba: 9808         	ldr	r0, [sp, #0x20]
700a47bc: b1b8         	cbz	r0, 0x700a47ee <Sciclient_rmIrqVintAdd+0xee> @ imm = #0x2e
700a47be: e7ff         	b	0x700a47c0 <Sciclient_rmIrqVintAdd+0xc0> @ imm = #-0x2
;                 ia_inst->vint_usage_count[cfg->vint]++;
700a47c0: 9808         	ldr	r0, [sp, #0x20]
700a47c2: 6901         	ldr	r1, [r0, #0x10]
700a47c4: 980b         	ldr	r0, [sp, #0x2c]
700a47c6: 8a42         	ldrh	r2, [r0, #0x12]
700a47c8: 5c88         	ldrb	r0, [r1, r2]
700a47ca: 3001         	adds	r0, #0x1
700a47cc: 5488         	strb	r0, [r1, r2]
;                 if ((cfg->vint == 0) && (cfg->vint_sb == 0)) {
700a47ce: 980b         	ldr	r0, [sp, #0x2c]
700a47d0: 8a40         	ldrh	r0, [r0, #0x12]
700a47d2: b958         	cbnz	r0, 0x700a47ec <Sciclient_rmIrqVintAdd+0xec> @ imm = #0x16
700a47d4: e7ff         	b	0x700a47d6 <Sciclient_rmIrqVintAdd+0xd6> @ imm = #-0x2
700a47d6: 980b         	ldr	r0, [sp, #0x2c]
700a47d8: 7d00         	ldrb	r0, [r0, #0x14]
700a47da: b938         	cbnz	r0, 0x700a47ec <Sciclient_rmIrqVintAdd+0xec> @ imm = #0xe
700a47dc: e7ff         	b	0x700a47de <Sciclient_rmIrqVintAdd+0xde> @ imm = #-0x2
;                     ia_inst->v0_b0_evt = cfg->global_evt - ia_inst->sevt_offset;
700a47de: 980b         	ldr	r0, [sp, #0x2c]
700a47e0: 89c0         	ldrh	r0, [r0, #0xe]
700a47e2: 9908         	ldr	r1, [sp, #0x20]
700a47e4: 890a         	ldrh	r2, [r1, #0x8]
700a47e6: 1a80         	subs	r0, r0, r2
700a47e8: 8288         	strh	r0, [r1, #0x14]
;                 }
700a47ea: e7ff         	b	0x700a47ec <Sciclient_rmIrqVintAdd+0xec> @ imm = #-0x2
;             }
700a47ec: e7ff         	b	0x700a47ee <Sciclient_rmIrqVintAdd+0xee> @ imm = #-0x2
;         }
700a47ee: e7ff         	b	0x700a47f0 <Sciclient_rmIrqVintAdd+0xf0> @ imm = #-0x2
;     }
700a47f0: e7ff         	b	0x700a47f2 <Sciclient_rmIrqVintAdd+0xf2> @ imm = #-0x2
;     if (cfg_whole_route == true) {
700a47f2: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a47f6: 07c0         	lsls	r0, r0, #0x1f
700a47f8: b170         	cbz	r0, 0x700a4818 <Sciclient_rmIrqVintAdd+0x118> @ imm = #0x1c
700a47fa: e7ff         	b	0x700a47fc <Sciclient_rmIrqVintAdd+0xfc> @ imm = #-0x2
;         r = Sciclient_rmIrqFindRoute(cfg);
700a47fc: 980b         	ldr	r0, [sp, #0x2c]
700a47fe: f7f9 feb7    	bl	0x7009e570 <Sciclient_rmIrqFindRoute> @ imm = #-0x6292
700a4802: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a4804: 980a         	ldr	r0, [sp, #0x28]
700a4806: b930         	cbnz	r0, 0x700a4816 <Sciclient_rmIrqVintAdd+0x116> @ imm = #0xc
700a4808: e7ff         	b	0x700a480a <Sciclient_rmIrqVintAdd+0x10a> @ imm = #-0x2
;             r = Sciclient_rmIrqProgramRoute(cfg, true);
700a480a: 980b         	ldr	r0, [sp, #0x2c]
700a480c: 2101         	movs	r1, #0x1
700a480e: f7fc fbe7    	bl	0x700a0fe0 <Sciclient_rmIrqProgramRoute> @ imm = #-0x3832
700a4812: 900a         	str	r0, [sp, #0x28]
;         }
700a4814: e7ff         	b	0x700a4816 <Sciclient_rmIrqVintAdd+0x116> @ imm = #-0x2
;     }
700a4816: e7ff         	b	0x700a4818 <Sciclient_rmIrqVintAdd+0x118> @ imm = #-0x2
;     return r;
700a4818: 980a         	ldr	r0, [sp, #0x28]
700a481a: b00c         	add	sp, #0x30
700a481c: bd80         	pop	{r7, pc}
700a481e: 0000         	movs	r0, r0

700a4820 <TaskP_loadUpdateAll>:
; {
700a4820: b580         	push	{r7, lr}
700a4822: b090         	sub	sp, #0x40
;     vTaskSuspendAll();
700a4824: f00b f9d4    	bl	0x700afbd0 <vTaskSuspendAll> @ imm = #0xb3a8
700a4828: 2000         	movs	r0, #0x0
;     for(i=0; i<TaskP_REGISTRY_MAX_ENTRIES; i++)
700a482a: 9005         	str	r0, [sp, #0x14]
700a482c: e7ff         	b	0x700a482e <TaskP_loadUpdateAll+0xe> @ imm = #-0x2
700a482e: 9805         	ldr	r0, [sp, #0x14]
700a4830: 281f         	cmp	r0, #0x1f
700a4832: d837         	bhi	0x700a48a4 <TaskP_loadUpdateAll+0x84> @ imm = #0x6e
700a4834: e7ff         	b	0x700a4836 <TaskP_loadUpdateAll+0x16> @ imm = #-0x2
;         if(gTaskP_ctrl.taskRegistry[i]!=NULL)
700a4836: 9905         	ldr	r1, [sp, #0x14]
700a4838: f644 5078    	movw	r0, #0x4d78
700a483c: f2c7 0008    	movt	r0, #0x7008
700a4840: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a4844: b348         	cbz	r0, 0x700a489a <TaskP_loadUpdateAll+0x7a> @ imm = #0x52
700a4846: e7ff         	b	0x700a4848 <TaskP_loadUpdateAll+0x28> @ imm = #-0x2
;             taskObj = gTaskP_ctrl.taskRegistry[i];
700a4848: 9905         	ldr	r1, [sp, #0x14]
700a484a: f644 5078    	movw	r0, #0x4d78
700a484e: f2c7 0008    	movt	r0, #0x7008
700a4852: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a4856: 900f         	str	r0, [sp, #0x3c]
;             vTaskGetInfo(taskObj->taskHndl, &taskStatus, pdFALSE, eReady);
700a4858: 980f         	ldr	r0, [sp, #0x3c]
700a485a: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a485e: a906         	add	r1, sp, #0x18
700a4860: 2200         	movs	r2, #0x0
700a4862: 2301         	movs	r3, #0x1
700a4864: f001 fbbc    	bl	0x700a5fe0 <vTaskGetInfo> @ imm = #0x1778
;             delta = TaskP_calcCounterDiff(taskStatus.ulRunTimeCounter, taskObj->lastRunTime);
700a4868: 980c         	ldr	r0, [sp, #0x30]
700a486a: 990f         	ldr	r1, [sp, #0x3c]
700a486c: f8d1 108c    	ldr.w	r1, [r1, #0x8c]
700a4870: f00a f9be    	bl	0x700aebf0 <TaskP_calcCounterDiff> @ imm = #0xa37c
700a4874: 9004         	str	r0, [sp, #0x10]
;             taskObj->accRunTime += delta;
700a4876: 9b04         	ldr	r3, [sp, #0x10]
700a4878: 990f         	ldr	r1, [sp, #0x3c]
700a487a: f8d1 2090    	ldr.w	r2, [r1, #0x90]
700a487e: f8d1 0094    	ldr.w	r0, [r1, #0x94]
700a4882: 18d2         	adds	r2, r2, r3
700a4884: f140 0000    	adc	r0, r0, #0x0
700a4888: f8c1 2090    	str.w	r2, [r1, #0x90]
700a488c: f8c1 0094    	str.w	r0, [r1, #0x94]
;             taskObj->lastRunTime = taskStatus.ulRunTimeCounter;
700a4890: 980c         	ldr	r0, [sp, #0x30]
700a4892: 990f         	ldr	r1, [sp, #0x3c]
700a4894: f8c1 008c    	str.w	r0, [r1, #0x8c]
;         }
700a4898: e7ff         	b	0x700a489a <TaskP_loadUpdateAll+0x7a> @ imm = #-0x2
;     }
700a489a: e7ff         	b	0x700a489c <TaskP_loadUpdateAll+0x7c> @ imm = #-0x2
;     for(i=0; i<TaskP_REGISTRY_MAX_ENTRIES; i++)
700a489c: 9805         	ldr	r0, [sp, #0x14]
700a489e: 3001         	adds	r0, #0x1
700a48a0: 9005         	str	r0, [sp, #0x14]
700a48a2: e7c4         	b	0x700a482e <TaskP_loadUpdateAll+0xe> @ imm = #-0x78
;     idleTskHndl = xTaskGetIdleTaskHandle();
700a48a4: f00b fa04    	bl	0x700afcb0 <xTaskGetIdleTaskHandle> @ imm = #0xb408
700a48a8: 9002         	str	r0, [sp, #0x8]
;     if(idleTskHndl != NULL)
700a48aa: 9802         	ldr	r0, [sp, #0x8]
700a48ac: b310         	cbz	r0, 0x700a48f4 <TaskP_loadUpdateAll+0xd4> @ imm = #0x44
700a48ae: e7ff         	b	0x700a48b0 <TaskP_loadUpdateAll+0x90> @ imm = #-0x2
;         vTaskGetInfo(idleTskHndl, &taskStatus, pdFALSE, eReady);
700a48b0: 9802         	ldr	r0, [sp, #0x8]
700a48b2: a906         	add	r1, sp, #0x18
700a48b4: 2200         	movs	r2, #0x0
700a48b6: 2301         	movs	r3, #0x1
700a48b8: f001 fb92    	bl	0x700a5fe0 <vTaskGetInfo> @ imm = #0x1724
;         delta = TaskP_calcCounterDiff(taskStatus.ulRunTimeCounter, gTaskP_ctrl.idleTskLastRunTime);
700a48bc: 980c         	ldr	r0, [sp, #0x30]
700a48be: f644 5178    	movw	r1, #0x4d78
700a48c2: f2c7 0108    	movt	r1, #0x7008
700a48c6: 9101         	str	r1, [sp, #0x4]
700a48c8: f8d1 1090    	ldr.w	r1, [r1, #0x90]
700a48cc: f00a f990    	bl	0x700aebf0 <TaskP_calcCounterDiff> @ imm = #0xa320
700a48d0: 9901         	ldr	r1, [sp, #0x4]
700a48d2: 9004         	str	r0, [sp, #0x10]
;         gTaskP_ctrl.idleTskAccRunTime += delta;
700a48d4: 9b04         	ldr	r3, [sp, #0x10]
700a48d6: f8d1 2098    	ldr.w	r2, [r1, #0x98]
700a48da: f8d1 009c    	ldr.w	r0, [r1, #0x9c]
700a48de: 18d2         	adds	r2, r2, r3
700a48e0: f140 0000    	adc	r0, r0, #0x0
700a48e4: f8c1 2098    	str.w	r2, [r1, #0x98]
700a48e8: f8c1 009c    	str.w	r0, [r1, #0x9c]
;         gTaskP_ctrl.idleTskLastRunTime = taskStatus.ulRunTimeCounter;
700a48ec: 980c         	ldr	r0, [sp, #0x30]
700a48ee: f8c1 0090    	str.w	r0, [r1, #0x90]
;     }
700a48f2: e7ff         	b	0x700a48f4 <TaskP_loadUpdateAll+0xd4> @ imm = #-0x2
;     curTotalTime = portGET_RUN_TIME_COUNTER_VALUE();
700a48f4: f00b f8e4    	bl	0x700afac0 <uiPortGetRunTimeCounterValue> @ imm = #0xb1c8
700a48f8: 9003         	str	r0, [sp, #0xc]
;     delta = TaskP_calcCounterDiff(curTotalTime, gTaskP_ctrl.lastTotalTime);
700a48fa: 9803         	ldr	r0, [sp, #0xc]
700a48fc: f644 5178    	movw	r1, #0x4d78
700a4900: f2c7 0108    	movt	r1, #0x7008
700a4904: 9100         	str	r1, [sp]
700a4906: f8d1 1080    	ldr.w	r1, [r1, #0x80]
700a490a: f00a f971    	bl	0x700aebf0 <TaskP_calcCounterDiff> @ imm = #0xa2e2
700a490e: 9900         	ldr	r1, [sp]
700a4910: 9004         	str	r0, [sp, #0x10]
;     gTaskP_ctrl.accTotalTime += delta;
700a4912: 9b04         	ldr	r3, [sp, #0x10]
700a4914: f8d1 2088    	ldr.w	r2, [r1, #0x88]
700a4918: f8d1 008c    	ldr.w	r0, [r1, #0x8c]
700a491c: 18d2         	adds	r2, r2, r3
700a491e: f140 0000    	adc	r0, r0, #0x0
700a4922: f8c1 2088    	str.w	r2, [r1, #0x88]
700a4926: f8c1 008c    	str.w	r0, [r1, #0x8c]
;     gTaskP_ctrl.lastTotalTime = curTotalTime;
700a492a: 9803         	ldr	r0, [sp, #0xc]
700a492c: f8c1 0080    	str.w	r0, [r1, #0x80]
;     (void)xTaskResumeAll();
700a4930: f7fd fcb6    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0x2694
; }
700a4934: b010         	add	sp, #0x40
700a4936: bd80         	pop	{r7, pc}

700a4938 <__udivmoddi4>:
700a4938: e1530001     	cmp	r3, r1
700a493c: 01520000     	cmpeq	r2, r0
700a4940: 9a000007     	bls	0x700a4964 <__udivmoddi4+0x2c> @ imm = #0x1c
700a4944: e59d2000     	ldr	r2, [sp]
700a4948: e3520000     	cmp	r2, #0
700a494c: 0a000001     	beq	0x700a4958 <__udivmoddi4+0x20> @ imm = #0x4
700a4950: e5820000     	str	r0, [r2]
700a4954: e5821004     	str	r1, [r2, #0x4]
700a4958: e3b01000     	movs	r1, #0
700a495c: e3b00000     	movs	r0, #0
700a4960: e12fff1e     	bx	lr
700a4964: e3530000     	cmp	r3, #0
700a4968: 03520000     	cmpeq	r2, #0
700a496c: 1a00000d     	bne	0x700a49a8 <__udivmoddi4+0x70> @ imm = #0x34
700a4970: e59d2000     	ldr	r2, [sp]
700a4974: e3520000     	cmp	r2, #0
700a4978: 0a000001     	beq	0x700a4984 <__udivmoddi4+0x4c> @ imm = #0x4
700a497c: e5820000     	str	r0, [r2]
700a4980: e5821004     	str	r1, [r2, #0x4]
700a4984: e1b02000     	movs	r2, r0
700a4988: e1b03001     	movs	r3, r1
700a498c: e3b01000     	movs	r1, #0
700a4990: e3b00000     	movs	r0, #0
700a4994: e3530000     	cmp	r3, #0
700a4998: 03520000     	cmpeq	r2, #0
700a499c: 11e01001     	mvnne	r1, r1
700a49a0: 11e00000     	mvnne	r0, r0
700a49a4: ea002cf5     	b	0x700afd80 <__aeabi_ldiv0> @ imm = #0xb3d4
700a49a8: e92d40f0     	push	{r4, r5, r6, r7, lr}
700a49ac: e1a04003     	mov	r4, r3
700a49b0: e1a05002     	mov	r5, r2
700a49b4: e1a03001     	mov	r3, r1
700a49b8: e1a02000     	mov	r2, r0
700a49bc: e3b00000     	movs	r0, #0
700a49c0: e3b01000     	movs	r1, #0
700a49c4: e16f6f14     	clz	r6, r4
700a49c8: e3560020     	cmp	r6, #32
700a49cc: 016f6f15     	clzeq	r6, r5
700a49d0: 02866020     	addeq	r6, r6, #32
700a49d4: e16f7f13     	clz	r7, r3
700a49d8: e3570020     	cmp	r7, #32
700a49dc: 016f7f12     	clzeq	r7, r2
700a49e0: 02877020     	addeq	r7, r7, #32
700a49e4: e0566007     	subs	r6, r6, r7
700a49e8: e2567020     	subs	r7, r6, #32
700a49ec: 21a04715     	lslhs	r4, r5, r7
700a49f0: 23a05000     	movhs	r5, #0
700a49f4: 32677000     	rsblo	r7, r7, #0
700a49f8: 31a04614     	lsllo	r4, r4, r6
700a49fc: 31a07735     	lsrlo	r7, r5, r7
700a4a00: 31844007     	orrlo	r4, r4, r7
700a4a04: 31a05615     	lsllo	r5, r5, r6
700a4a08: e1530004     	cmp	r3, r4
700a4a0c: 01520005     	cmpeq	r2, r5
700a4a10: 3a000001     	blo	0x700a4a1c <__udivmoddi4+0xe4> @ imm = #0x4
700a4a14: e0522005     	subs	r2, r2, r5
700a4a18: e0d33004     	sbcs	r3, r3, r4
700a4a1c: e0b00000     	adcs	r0, r0, r0
700a4a20: e0b11001     	adcs	r1, r1, r1
700a4a24: e1b050a5     	lsrs	r5, r5, #1
700a4a28: e1855f84     	orr	r5, r5, r4, lsl #31
700a4a2c: e1b040a4     	lsrs	r4, r4, #1
700a4a30: e2566001     	subs	r6, r6, #1
700a4a34: 5afffff3     	bpl	0x700a4a08 <__udivmoddi4+0xd0> @ imm = #-0x34
700a4a38: e59d7014     	ldr	r7, [sp, #0x14]
700a4a3c: e3570000     	cmp	r7, #0
700a4a40: 0a000001     	beq	0x700a4a4c <__udivmoddi4+0x114> @ imm = #0x4
700a4a44: e5872000     	str	r2, [r7]
700a4a48: e5873004     	str	r3, [r7, #0x4]
700a4a4c: e8bd80f0     	pop	{r4, r5, r6, r7, pc}

700a4a50 <CSL_bcdmaChanOpDecChanStats>:
; {
700a4a50: b580         	push	{r7, lr}
700a4a52: b088         	sub	sp, #0x20
700a4a54: 9007         	str	r0, [sp, #0x1c]
700a4a56: 9106         	str	r1, [sp, #0x18]
700a4a58: 9205         	str	r2, [sp, #0x14]
700a4a5a: 9304         	str	r3, [sp, #0x10]
700a4a5c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a4a5e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a4a60: 9804         	ldr	r0, [sp, #0x10]
700a4a62: b920         	cbnz	r0, 0x700a4a6e <CSL_bcdmaChanOpDecChanStats+0x1e> @ imm = #0x8
700a4a64: e7ff         	b	0x700a4a66 <CSL_bcdmaChanOpDecChanStats+0x16> @ imm = #-0x2
700a4a66: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a4a6a: 9003         	str	r0, [sp, #0xc]
;     }
700a4a6c: e078         	b	0x700a4b60 <CSL_bcdmaChanOpDecChanStats+0x110> @ imm = #0xf0
;         CSL_BcdmaChanStats *pChanStats = (CSL_BcdmaChanStats *)pOpData;
700a4a6e: 9804         	ldr	r0, [sp, #0x10]
700a4a70: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a4a72: 9806         	ldr	r0, [sp, #0x18]
700a4a74: 9001         	str	r0, [sp, #0x4]
700a4a76: b140         	cbz	r0, 0x700a4a8a <CSL_bcdmaChanOpDecChanStats+0x3a> @ imm = #0x10
700a4a78: e7ff         	b	0x700a4a7a <CSL_bcdmaChanOpDecChanStats+0x2a> @ imm = #-0x2
700a4a7a: 9801         	ldr	r0, [sp, #0x4]
700a4a7c: 2801         	cmp	r0, #0x1
700a4a7e: d026         	beq	0x700a4ace <CSL_bcdmaChanOpDecChanStats+0x7e> @ imm = #0x4c
700a4a80: e7ff         	b	0x700a4a82 <CSL_bcdmaChanOpDecChanStats+0x32> @ imm = #-0x2
700a4a82: 9801         	ldr	r0, [sp, #0x4]
700a4a84: 2802         	cmp	r0, #0x2
700a4a86: d044         	beq	0x700a4b12 <CSL_bcdmaChanOpDecChanStats+0xc2> @ imm = #0x88
700a4a88: e065         	b	0x700a4b56 <CSL_bcdmaChanOpDecChanStats+0x106> @ imm = #0xca
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a4a8a: 9807         	ldr	r0, [sp, #0x1c]
700a4a8c: 6880         	ldr	r0, [r0, #0x8]
700a4a8e: 9905         	ldr	r1, [sp, #0x14]
700a4a90: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4a94: f500 6080    	add.w	r0, r0, #0x400
700a4a98: 9902         	ldr	r1, [sp, #0x8]
700a4a9a: 6809         	ldr	r1, [r1]
700a4a9c: f7f7 fbf8    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x8810
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->txPayloadByteCnt );
700a4aa0: 9807         	ldr	r0, [sp, #0x1c]
700a4aa2: 6880         	ldr	r0, [r0, #0x8]
700a4aa4: 9905         	ldr	r1, [sp, #0x14]
700a4aa6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4aaa: f500 6081    	add.w	r0, r0, #0x408
700a4aae: 9902         	ldr	r1, [sp, #0x8]
700a4ab0: 6849         	ldr	r1, [r1, #0x4]
700a4ab2: f7f7 fbed    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x8826
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->txStartedByteCnt );
700a4ab6: 9807         	ldr	r0, [sp, #0x1c]
700a4ab8: 6880         	ldr	r0, [r0, #0x8]
700a4aba: 9905         	ldr	r1, [sp, #0x14]
700a4abc: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4ac0: f500 6082    	add.w	r0, r0, #0x410
700a4ac4: 9902         	ldr	r1, [sp, #0x8]
700a4ac6: 6889         	ldr	r1, [r1, #0x8]
700a4ac8: f7f7 fbe2    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x883c
;                 break;
700a4acc: e047         	b	0x700a4b5e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x8e
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a4ace: 9807         	ldr	r0, [sp, #0x1c]
700a4ad0: 6900         	ldr	r0, [r0, #0x10]
700a4ad2: 9905         	ldr	r1, [sp, #0x14]
700a4ad4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4ad8: f500 6080    	add.w	r0, r0, #0x400
700a4adc: 9902         	ldr	r1, [sp, #0x8]
700a4ade: 6809         	ldr	r1, [r1]
700a4ae0: f7f7 fbd6    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x8854
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->txPayloadByteCnt );
700a4ae4: 9807         	ldr	r0, [sp, #0x1c]
700a4ae6: 6900         	ldr	r0, [r0, #0x10]
700a4ae8: 9905         	ldr	r1, [sp, #0x14]
700a4aea: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4aee: f500 6081    	add.w	r0, r0, #0x408
700a4af2: 9902         	ldr	r1, [sp, #0x8]
700a4af4: 6849         	ldr	r1, [r1, #0x4]
700a4af6: f7f7 fbcb    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x886a
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->txStartedByteCnt );
700a4afa: 9807         	ldr	r0, [sp, #0x1c]
700a4afc: 6900         	ldr	r0, [r0, #0x10]
700a4afe: 9905         	ldr	r1, [sp, #0x14]
700a4b00: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4b04: f500 6082    	add.w	r0, r0, #0x410
700a4b08: 9902         	ldr	r1, [sp, #0x8]
700a4b0a: 6889         	ldr	r1, [r1, #0x8]
700a4b0c: f7f7 fbc0    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x8880
;                 break;
700a4b10: e025         	b	0x700a4b5e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x4a
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a4b12: 9807         	ldr	r0, [sp, #0x1c]
700a4b14: 6980         	ldr	r0, [r0, #0x18]
700a4b16: 9905         	ldr	r1, [sp, #0x14]
700a4b18: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4b1c: f500 6080    	add.w	r0, r0, #0x400
700a4b20: 9902         	ldr	r1, [sp, #0x8]
700a4b22: 6809         	ldr	r1, [r1]
700a4b24: f7f7 fbb4    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x8898
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->rxPayloadByteCnt );
700a4b28: 9807         	ldr	r0, [sp, #0x1c]
700a4b2a: 6980         	ldr	r0, [r0, #0x18]
700a4b2c: 9905         	ldr	r1, [sp, #0x14]
700a4b2e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4b32: f500 6081    	add.w	r0, r0, #0x408
700a4b36: 9902         	ldr	r1, [sp, #0x8]
700a4b38: 68c9         	ldr	r1, [r1, #0xc]
700a4b3a: f7f7 fba9    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x88ae
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->rxStartedByteCnt );
700a4b3e: 9807         	ldr	r0, [sp, #0x1c]
700a4b40: 6980         	ldr	r0, [r0, #0x18]
700a4b42: 9905         	ldr	r1, [sp, #0x14]
700a4b44: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4b48: f500 6082    	add.w	r0, r0, #0x410
700a4b4c: 9902         	ldr	r1, [sp, #0x8]
700a4b4e: 6909         	ldr	r1, [r1, #0x10]
700a4b50: f7f7 fb9e    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x88c4
;                 break;
700a4b54: e003         	b	0x700a4b5e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x6
700a4b56: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a4b5a: 9003         	str	r0, [sp, #0xc]
;                 break;
700a4b5c: e7ff         	b	0x700a4b5e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #-0x2
700a4b5e: e7ff         	b	0x700a4b60 <CSL_bcdmaChanOpDecChanStats+0x110> @ imm = #-0x2
;     return retVal;
700a4b60: 9803         	ldr	r0, [sp, #0xc]
700a4b62: b008         	add	sp, #0x20
700a4b64: bd80         	pop	{r7, pc}
		...
700a4b6e: 0000         	movs	r0, r0

700a4b70 <UART_divisorLatchWrite>:
; {
700a4b70: b580         	push	{r7, lr}
700a4b72: b08c         	sub	sp, #0x30
700a4b74: 900b         	str	r0, [sp, #0x2c]
700a4b76: 910a         	str	r1, [sp, #0x28]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a4b78: 980b         	ldr	r0, [sp, #0x2c]
700a4b7a: 21bf         	movs	r1, #0xbf
700a4b7c: 9102         	str	r1, [sp, #0x8]
700a4b7e: f007 fe07    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #0x7c0e
700a4b82: 9007         	str	r0, [sp, #0x1c]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a4b84: 980b         	ldr	r0, [sp, #0x2c]
700a4b86: 3008         	adds	r0, #0x8
700a4b88: 2110         	movs	r1, #0x10
700a4b8a: 9103         	str	r1, [sp, #0xc]
700a4b8c: 2204         	movs	r2, #0x4
700a4b8e: 9204         	str	r2, [sp, #0x10]
700a4b90: f00a fbde    	bl	0x700af350 <HW_RD_FIELD32_RAW> @ imm = #0xa7bc
700a4b94: 9903         	ldr	r1, [sp, #0xc]
700a4b96: 9a04         	ldr	r2, [sp, #0x10]
700a4b98: 9009         	str	r0, [sp, #0x24]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a4b9a: 980b         	ldr	r0, [sp, #0x2c]
700a4b9c: 3008         	adds	r0, #0x8
700a4b9e: 2301         	movs	r3, #0x1
700a4ba0: f009 fd8e    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x9b1c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4ba4: 980b         	ldr	r0, [sp, #0x2c]
700a4ba6: 300c         	adds	r0, #0xc
700a4ba8: 9907         	ldr	r1, [sp, #0x1c]
700a4baa: f00a fff1    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0xafe2
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700a4bae: 980b         	ldr	r0, [sp, #0x2c]
700a4bb0: 217f         	movs	r1, #0x7f
700a4bb2: 9101         	str	r1, [sp, #0x4]
700a4bb4: f007 fdec    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #0x7bd8
700a4bb8: 9903         	ldr	r1, [sp, #0xc]
700a4bba: 9a04         	ldr	r2, [sp, #0x10]
700a4bbc: 9007         	str	r0, [sp, #0x1c]
;     sleepMdBitVal = HW_RD_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE);
700a4bbe: 980b         	ldr	r0, [sp, #0x2c]
700a4bc0: 3004         	adds	r0, #0x4
700a4bc2: f00a fbc5    	bl	0x700af350 <HW_RD_FIELD32_RAW> @ imm = #0xa78a
700a4bc6: 9903         	ldr	r1, [sp, #0xc]
700a4bc8: 9a04         	ldr	r2, [sp, #0x10]
700a4bca: 9008         	str	r0, [sp, #0x20]
;     HW_WR_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE, 0U);
700a4bcc: 980b         	ldr	r0, [sp, #0x2c]
700a4bce: 3004         	adds	r0, #0x4
700a4bd0: 2300         	movs	r3, #0x0
700a4bd2: f009 fd75    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x9aea
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4bd6: 980b         	ldr	r0, [sp, #0x2c]
700a4bd8: 300c         	adds	r0, #0xc
700a4bda: 9907         	ldr	r1, [sp, #0x1c]
700a4bdc: f00a ffd8    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0xafb0
700a4be0: 9902         	ldr	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a4be2: 980b         	ldr	r0, [sp, #0x2c]
700a4be4: f007 fdd4    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #0x7ba8
700a4be8: 9007         	str	r0, [sp, #0x1c]
;     divRegVal  = HW_RD_REG32(baseAddr + UART_DLL) & 0xFFU;
700a4bea: 980b         	ldr	r0, [sp, #0x2c]
700a4bec: f00a ffc8    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0xaf90
700a4bf0: b2c0         	uxtb	r0, r0
700a4bf2: 9005         	str	r0, [sp, #0x14]
;     divRegVal |= (HW_RD_REG32(baseAddr + UART_DLH) & 0x3FU) << 8;
700a4bf4: 980b         	ldr	r0, [sp, #0x2c]
700a4bf6: 3004         	adds	r0, #0x4
700a4bf8: f00a ffc2    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0xaf84
700a4bfc: f000 013f    	and	r1, r0, #0x3f
700a4c00: 9805         	ldr	r0, [sp, #0x14]
700a4c02: ea40 2001    	orr.w	r0, r0, r1, lsl #8
700a4c06: 9005         	str	r0, [sp, #0x14]
;     operMode = UART_operatingModeSelect(baseAddr,
700a4c08: 980b         	ldr	r0, [sp, #0x2c]
700a4c0a: 2107         	movs	r1, #0x7
700a4c0c: f00a f910    	bl	0x700aee30 <UART_operatingModeSelect> @ imm = #0xa220
700a4c10: 9006         	str	r0, [sp, #0x18]
;     HW_WR_REG32(baseAddr + UART_DLL, divisorValue & 0x00FFU);
700a4c12: 980b         	ldr	r0, [sp, #0x2c]
700a4c14: f89d 1028    	ldrb.w	r1, [sp, #0x28]
700a4c18: f00a ffba    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0xaf74
;     HW_WR_REG32(baseAddr + UART_DLH, (divisorValue & 0x3F00U) >> 8);
700a4c1c: 980b         	ldr	r0, [sp, #0x2c]
700a4c1e: 3004         	adds	r0, #0x4
700a4c20: 990a         	ldr	r1, [sp, #0x28]
700a4c22: f3c1 2105    	ubfx	r1, r1, #0x8, #0x6
700a4c26: f00a ffb3    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0xaf66
;     (void) UART_operatingModeSelect(baseAddr, operMode);
700a4c2a: 980b         	ldr	r0, [sp, #0x2c]
700a4c2c: 9906         	ldr	r1, [sp, #0x18]
700a4c2e: f00a f8ff    	bl	0x700aee30 <UART_operatingModeSelect> @ imm = #0xa1fe
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4c32: 980b         	ldr	r0, [sp, #0x2c]
700a4c34: 300c         	adds	r0, #0xc
700a4c36: 9907         	ldr	r1, [sp, #0x1c]
700a4c38: f00a ffaa    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0xaf54
700a4c3c: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700a4c3e: 980b         	ldr	r0, [sp, #0x2c]
700a4c40: f007 fda6    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #0x7b4c
700a4c44: 9903         	ldr	r1, [sp, #0xc]
700a4c46: 9a04         	ldr	r2, [sp, #0x10]
700a4c48: 9007         	str	r0, [sp, #0x1c]
;     HW_WR_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE, sleepMdBitVal);
700a4c4a: 980b         	ldr	r0, [sp, #0x2c]
700a4c4c: 3004         	adds	r0, #0x4
700a4c4e: 9b08         	ldr	r3, [sp, #0x20]
700a4c50: f009 fd36    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x9a6c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4c54: 980b         	ldr	r0, [sp, #0x2c]
700a4c56: 300c         	adds	r0, #0xc
700a4c58: 9907         	ldr	r1, [sp, #0x1c]
700a4c5a: f00a ff99    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0xaf32
700a4c5e: 9902         	ldr	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a4c60: 980b         	ldr	r0, [sp, #0x2c]
700a4c62: f007 fd95    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #0x7b2a
700a4c66: 9903         	ldr	r1, [sp, #0xc]
700a4c68: 9a04         	ldr	r2, [sp, #0x10]
700a4c6a: 9007         	str	r0, [sp, #0x1c]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a4c6c: 980b         	ldr	r0, [sp, #0x2c]
700a4c6e: 3008         	adds	r0, #0x8
700a4c70: 9b09         	ldr	r3, [sp, #0x24]
700a4c72: f009 fd25    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x9a4a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4c76: 980b         	ldr	r0, [sp, #0x2c]
700a4c78: 300c         	adds	r0, #0xc
700a4c7a: 9907         	ldr	r1, [sp, #0x1c]
700a4c7c: f00a ff88    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0xaf10
;     return divRegVal;
700a4c80: 9805         	ldr	r0, [sp, #0x14]
700a4c82: b00c         	add	sp, #0x30
700a4c84: bd80         	pop	{r7, pc}
		...
700a4c8e: 0000         	movs	r0, r0

700a4c90 <_ntoa_long>:
; {
700a4c90: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
700a4c94: b098         	sub	sp, #0x60
700a4c96: 4684         	mov	r12, r0
700a4c98: 9823         	ldr	r0, [sp, #0x8c]
700a4c9a: 9822         	ldr	r0, [sp, #0x88]
700a4c9c: 9821         	ldr	r0, [sp, #0x84]
700a4c9e: 9820         	ldr	r0, [sp, #0x80]
700a4ca0: 981f         	ldr	r0, [sp, #0x7c]
700a4ca2: f8dd e078    	ldr.w	lr, [sp, #0x78]
700a4ca6: f8cd c05c    	str.w	r12, [sp, #0x5c]
700a4caa: 9116         	str	r1, [sp, #0x58]
700a4cac: 9215         	str	r2, [sp, #0x54]
700a4cae: 9314         	str	r3, [sp, #0x50]
700a4cb0: f88d 004f    	strb.w	r0, [sp, #0x4f]
700a4cb4: 2000         	movs	r0, #0x0
;   size_t len = 0U;
700a4cb6: 900a         	str	r0, [sp, #0x28]
;   if (!value) {
700a4cb8: 981e         	ldr	r0, [sp, #0x78]
700a4cba: b928         	cbnz	r0, 0x700a4cc8 <_ntoa_long+0x38> @ imm = #0xa
700a4cbc: e7ff         	b	0x700a4cbe <_ntoa_long+0x2e> @ imm = #-0x2
;     flags &= ~FLAGS_HASH;
700a4cbe: 9823         	ldr	r0, [sp, #0x8c]
700a4cc0: f020 0010    	bic	r0, r0, #0x10
700a4cc4: 9023         	str	r0, [sp, #0x8c]
;   }
700a4cc6: e7ff         	b	0x700a4cc8 <_ntoa_long+0x38> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION) || value) {
700a4cc8: f89d 008d    	ldrb.w	r0, [sp, #0x8d]
700a4ccc: 0740         	lsls	r0, r0, #0x1d
700a4cce: 2800         	cmp	r0, #0x0
700a4cd0: d504         	bpl	0x700a4cdc <_ntoa_long+0x4c> @ imm = #0x8
700a4cd2: e7ff         	b	0x700a4cd4 <_ntoa_long+0x44> @ imm = #-0x2
700a4cd4: 981e         	ldr	r0, [sp, #0x78]
700a4cd6: 2800         	cmp	r0, #0x0
700a4cd8: d03f         	beq	0x700a4d5a <_ntoa_long+0xca> @ imm = #0x7e
700a4cda: e7ff         	b	0x700a4cdc <_ntoa_long+0x4c> @ imm = #-0x2
;     do {
700a4cdc: e7ff         	b	0x700a4cde <_ntoa_long+0x4e> @ imm = #-0x2
;       const char digit = (char)(value % base);
700a4cde: 9a1e         	ldr	r2, [sp, #0x78]
700a4ce0: 9920         	ldr	r1, [sp, #0x80]
700a4ce2: fbb2 f0f1    	udiv	r0, r2, r1
700a4ce6: fb00 2011    	mls	r0, r0, r1, r2
700a4cea: f88d 0027    	strb.w	r0, [sp, #0x27]
;       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
700a4cee: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a4cf2: 2809         	cmp	r0, #0x9
700a4cf4: dc05         	bgt	0x700a4d02 <_ntoa_long+0x72> @ imm = #0xa
700a4cf6: e7ff         	b	0x700a4cf8 <_ntoa_long+0x68> @ imm = #-0x2
700a4cf8: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a4cfc: 3030         	adds	r0, #0x30
700a4cfe: 9008         	str	r0, [sp, #0x20]
700a4d00: e00c         	b	0x700a4d1c <_ntoa_long+0x8c> @ imm = #0x18
700a4d02: f89d 008c    	ldrb.w	r0, [sp, #0x8c]
700a4d06: 0681         	lsls	r1, r0, #0x1a
700a4d08: 2061         	movs	r0, #0x61
700a4d0a: 2900         	cmp	r1, #0x0
700a4d0c: bf48         	it	mi
700a4d0e: 2041         	movmi	r0, #0x41
700a4d10: f89d 1027    	ldrb.w	r1, [sp, #0x27]
700a4d14: 4408         	add	r0, r1
700a4d16: 380a         	subs	r0, #0xa
700a4d18: 9008         	str	r0, [sp, #0x20]
700a4d1a: e7ff         	b	0x700a4d1c <_ntoa_long+0x8c> @ imm = #-0x2
700a4d1c: 9808         	ldr	r0, [sp, #0x20]
700a4d1e: 9a0a         	ldr	r2, [sp, #0x28]
700a4d20: 1c51         	adds	r1, r2, #0x1
700a4d22: 910a         	str	r1, [sp, #0x28]
700a4d24: f10d 012f    	add.w	r1, sp, #0x2f
700a4d28: 5488         	strb	r0, [r1, r2]
;       value /= base;
700a4d2a: 9920         	ldr	r1, [sp, #0x80]
700a4d2c: 981e         	ldr	r0, [sp, #0x78]
700a4d2e: fbb0 f0f1    	udiv	r0, r0, r1
700a4d32: 901e         	str	r0, [sp, #0x78]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a4d34: e7ff         	b	0x700a4d36 <_ntoa_long+0xa6> @ imm = #-0x2
700a4d36: 991e         	ldr	r1, [sp, #0x78]
700a4d38: 2000         	movs	r0, #0x0
700a4d3a: 9007         	str	r0, [sp, #0x1c]
700a4d3c: b139         	cbz	r1, 0x700a4d4e <_ntoa_long+0xbe> @ imm = #0xe
700a4d3e: e7ff         	b	0x700a4d40 <_ntoa_long+0xb0> @ imm = #-0x2
700a4d40: 990a         	ldr	r1, [sp, #0x28]
700a4d42: 2000         	movs	r0, #0x0
700a4d44: 2920         	cmp	r1, #0x20
700a4d46: bf38         	it	lo
700a4d48: 2001         	movlo	r0, #0x1
700a4d4a: 9007         	str	r0, [sp, #0x1c]
700a4d4c: e7ff         	b	0x700a4d4e <_ntoa_long+0xbe> @ imm = #-0x2
700a4d4e: 9807         	ldr	r0, [sp, #0x1c]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a4d50: 07c0         	lsls	r0, r0, #0x1f
700a4d52: 2800         	cmp	r0, #0x0
700a4d54: d1c3         	bne	0x700a4cde <_ntoa_long+0x4e> @ imm = #-0x7a
700a4d56: e7ff         	b	0x700a4d58 <_ntoa_long+0xc8> @ imm = #-0x2
;   }
700a4d58: e7ff         	b	0x700a4d5a <_ntoa_long+0xca> @ imm = #-0x2
;   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
700a4d5a: 9817         	ldr	r0, [sp, #0x5c]
700a4d5c: 9916         	ldr	r1, [sp, #0x58]
700a4d5e: 9a15         	ldr	r2, [sp, #0x54]
700a4d60: 9b14         	ldr	r3, [sp, #0x50]
700a4d62: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a4d66: 9d20         	ldr	r5, [sp, #0x80]
700a4d68: 9e21         	ldr	r6, [sp, #0x84]
700a4d6a: 9f22         	ldr	r7, [sp, #0x88]
700a4d6c: f8dd 808c    	ldr.w	r8, [sp, #0x8c]
700a4d70: f89d 404f    	ldrb.w	r4, [sp, #0x4f]
700a4d74: 46ee         	mov	lr, sp
700a4d76: f8ce 8018    	str.w	r8, [lr, #0x18]
700a4d7a: f8ce 7014    	str.w	r7, [lr, #0x14]
700a4d7e: f8ce 6010    	str.w	r6, [lr, #0x10]
700a4d82: f8ce 500c    	str.w	r5, [lr, #0xc]
700a4d86: f004 0401    	and	r4, r4, #0x1
700a4d8a: f8ce 4008    	str.w	r4, [lr, #0x8]
700a4d8e: f8ce c004    	str.w	r12, [lr, #0x4]
700a4d92: f10d 0c2f    	add.w	r12, sp, #0x2f
700a4d96: f8ce c000    	str.w	r12, [lr]
700a4d9a: f7f9 fe39    	bl	0x7009ea10 <_ntoa_format> @ imm = #-0x638e
700a4d9e: b018         	add	sp, #0x60
700a4da0: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
		...

700a4db0 <prvInitialiseNewTask>:
;     const MemoryRegion_t *const xRegions) {
700a4db0: b580         	push	{r7, lr}
700a4db2: b088         	sub	sp, #0x20
700a4db4: f8dd c034    	ldr.w	r12, [sp, #0x34]
700a4db8: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a4dbc: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a4dc0: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a4dc4: 9007         	str	r0, [sp, #0x1c]
700a4dc6: 9106         	str	r1, [sp, #0x18]
700a4dc8: 9205         	str	r2, [sp, #0x14]
700a4dca: 9304         	str	r3, [sp, #0x10]
;     (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE,
700a4dcc: 980c         	ldr	r0, [sp, #0x30]
700a4dce: 6b00         	ldr	r0, [r0, #0x30]
;                  (size_t)ulStackDepth * sizeof(StackType_t));
700a4dd0: 9905         	ldr	r1, [sp, #0x14]
700a4dd2: 0089         	lsls	r1, r1, #0x2
700a4dd4: 22a5         	movs	r2, #0xa5
;     (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE,
700a4dd6: f00a eeec    	blx	0x700afbb0 <__aeabi_memset8> @ imm = #0xadd8
;     pxTopOfStack = &(pxNewTCB->pxStack[ulStackDepth - (uint32_t)1]);
700a4dda: 980c         	ldr	r0, [sp, #0x30]
700a4ddc: 6b00         	ldr	r0, [r0, #0x30]
700a4dde: 9905         	ldr	r1, [sp, #0x14]
700a4de0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4de4: 3804         	subs	r0, #0x4
700a4de6: 9003         	str	r0, [sp, #0xc]
;              *)(((portPOINTER_SIZE_TYPE)pxTopOfStack) &
700a4de8: 9803         	ldr	r0, [sp, #0xc]
700a4dea: f020 0007    	bic	r0, r0, #0x7
;     pxTopOfStack =
700a4dee: 9003         	str	r0, [sp, #0xc]
;   if (pcName != NULL) {
700a4df0: 9806         	ldr	r0, [sp, #0x18]
700a4df2: b1f8         	cbz	r0, 0x700a4e34 <prvInitialiseNewTask+0x84> @ imm = #0x3e
700a4df4: e7ff         	b	0x700a4df6 <prvInitialiseNewTask+0x46> @ imm = #-0x2
700a4df6: 2000         	movs	r0, #0x0
;     for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
700a4df8: 9002         	str	r0, [sp, #0x8]
700a4dfa: e7ff         	b	0x700a4dfc <prvInitialiseNewTask+0x4c> @ imm = #-0x2
700a4dfc: 9802         	ldr	r0, [sp, #0x8]
700a4dfe: 281f         	cmp	r0, #0x1f
700a4e00: d813         	bhi	0x700a4e2a <prvInitialiseNewTask+0x7a> @ imm = #0x26
700a4e02: e7ff         	b	0x700a4e04 <prvInitialiseNewTask+0x54> @ imm = #-0x2
;       pxNewTCB->pcTaskName[x] = pcName[x];
700a4e04: 9806         	ldr	r0, [sp, #0x18]
700a4e06: 9a02         	ldr	r2, [sp, #0x8]
700a4e08: 5c80         	ldrb	r0, [r0, r2]
700a4e0a: 990c         	ldr	r1, [sp, #0x30]
700a4e0c: 4411         	add	r1, r2
700a4e0e: f881 0034    	strb.w	r0, [r1, #0x34]
;       if (pcName[x] == (char)0x00) {
700a4e12: 9806         	ldr	r0, [sp, #0x18]
700a4e14: 9902         	ldr	r1, [sp, #0x8]
700a4e16: 5c40         	ldrb	r0, [r0, r1]
700a4e18: b908         	cbnz	r0, 0x700a4e1e <prvInitialiseNewTask+0x6e> @ imm = #0x2
700a4e1a: e7ff         	b	0x700a4e1c <prvInitialiseNewTask+0x6c> @ imm = #-0x2
;         break;
700a4e1c: e005         	b	0x700a4e2a <prvInitialiseNewTask+0x7a> @ imm = #0xa
700a4e1e: e7ff         	b	0x700a4e20 <prvInitialiseNewTask+0x70> @ imm = #-0x2
;     }
700a4e20: e7ff         	b	0x700a4e22 <prvInitialiseNewTask+0x72> @ imm = #-0x2
;     for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
700a4e22: 9802         	ldr	r0, [sp, #0x8]
700a4e24: 3001         	adds	r0, #0x1
700a4e26: 9002         	str	r0, [sp, #0x8]
700a4e28: e7e8         	b	0x700a4dfc <prvInitialiseNewTask+0x4c> @ imm = #-0x30
;     pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
700a4e2a: 990c         	ldr	r1, [sp, #0x30]
700a4e2c: 2000         	movs	r0, #0x0
700a4e2e: f881 0053    	strb.w	r0, [r1, #0x53]
;   } else {
700a4e32: e004         	b	0x700a4e3e <prvInitialiseNewTask+0x8e> @ imm = #0x8
;     pxNewTCB->pcTaskName[0] = 0x00;
700a4e34: 990c         	ldr	r1, [sp, #0x30]
700a4e36: 2000         	movs	r0, #0x0
700a4e38: f881 0034    	strb.w	r0, [r1, #0x34]
700a4e3c: e7ff         	b	0x700a4e3e <prvInitialiseNewTask+0x8e> @ imm = #-0x2
;   if (uxPriority >= (UBaseType_t)configMAX_PRIORITIES) {
700a4e3e: 980a         	ldr	r0, [sp, #0x28]
700a4e40: 2820         	cmp	r0, #0x20
700a4e42: d303         	blo	0x700a4e4c <prvInitialiseNewTask+0x9c> @ imm = #0x6
700a4e44: e7ff         	b	0x700a4e46 <prvInitialiseNewTask+0x96> @ imm = #-0x2
700a4e46: 201f         	movs	r0, #0x1f
;     uxPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
700a4e48: 900a         	str	r0, [sp, #0x28]
;   } else {
700a4e4a: e000         	b	0x700a4e4e <prvInitialiseNewTask+0x9e> @ imm = #0x0
700a4e4c: e7ff         	b	0x700a4e4e <prvInitialiseNewTask+0x9e> @ imm = #-0x2
;   pxNewTCB->uxPriority = uxPriority;
700a4e4e: 980a         	ldr	r0, [sp, #0x28]
700a4e50: 990c         	ldr	r1, [sp, #0x30]
700a4e52: 62c8         	str	r0, [r1, #0x2c]
;     pxNewTCB->uxBasePriority = uxPriority;
700a4e54: 980a         	ldr	r0, [sp, #0x28]
700a4e56: 990c         	ldr	r1, [sp, #0x30]
700a4e58: 6608         	str	r0, [r1, #0x60]
;     pxNewTCB->uxMutexesHeld = 0;
700a4e5a: 990c         	ldr	r1, [sp, #0x30]
700a4e5c: 2000         	movs	r0, #0x0
700a4e5e: 9001         	str	r0, [sp, #0x4]
700a4e60: 6648         	str	r0, [r1, #0x64]
;   vListInitialiseItem(&(pxNewTCB->xStateListItem));
700a4e62: 980c         	ldr	r0, [sp, #0x30]
700a4e64: 3004         	adds	r0, #0x4
700a4e66: f00a fec3    	bl	0x700afbf0 <vListInitialiseItem> @ imm = #0xad86
;   vListInitialiseItem(&(pxNewTCB->xEventListItem));
700a4e6a: 980c         	ldr	r0, [sp, #0x30]
700a4e6c: 3018         	adds	r0, #0x18
700a4e6e: f00a febf    	bl	0x700afbf0 <vListInitialiseItem> @ imm = #0xad7e
700a4e72: 9801         	ldr	r0, [sp, #0x4]
;   listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
700a4e74: 990c         	ldr	r1, [sp, #0x30]
700a4e76: 6109         	str	r1, [r1, #0x10]
;   listSET_LIST_ITEM_VALUE(
700a4e78: 990a         	ldr	r1, [sp, #0x28]
700a4e7a: f1c1 0120    	rsb.w	r1, r1, #0x20
700a4e7e: 9a0c         	ldr	r2, [sp, #0x30]
700a4e80: 6191         	str	r1, [r2, #0x18]
;   listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
700a4e82: 990c         	ldr	r1, [sp, #0x30]
700a4e84: 6249         	str	r1, [r1, #0x24]
;     pxNewTCB->uxCriticalNesting = (UBaseType_t)0U;
700a4e86: 990c         	ldr	r1, [sp, #0x30]
700a4e88: 6548         	str	r0, [r1, #0x54]
;     pxNewTCB->pxTaskTag = NULL;
700a4e8a: 990c         	ldr	r1, [sp, #0x30]
700a4e8c: 6688         	str	r0, [r1, #0x68]
;     memset((void *)&(pxNewTCB->pvThreadLocalStoragePointers[0]), 0x00,
700a4e8e: 990c         	ldr	r1, [sp, #0x30]
700a4e90: 6788         	str	r0, [r1, #0x78]
700a4e92: 6748         	str	r0, [r1, #0x74]
700a4e94: 6708         	str	r0, [r1, #0x70]
700a4e96: 66c8         	str	r0, [r1, #0x6c]
;     memset((void *)&(pxNewTCB->ulNotifiedValue[0]), 0x00,
700a4e98: 990c         	ldr	r1, [sp, #0x30]
700a4e9a: 67c8         	str	r0, [r1, #0x7c]
;     memset((void *)&(pxNewTCB->ucNotifyState[0]), 0x00,
700a4e9c: 990c         	ldr	r1, [sp, #0x30]
700a4e9e: f881 0080    	strb.w	r0, [r1, #0x80]
;           pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
700a4ea2: 9803         	ldr	r0, [sp, #0xc]
700a4ea4: 9907         	ldr	r1, [sp, #0x1c]
700a4ea6: 9a04         	ldr	r2, [sp, #0x10]
700a4ea8: f7fe fc8a    	bl	0x700a37c0 <pxPortInitialiseStack> @ imm = #-0x16ec
;       pxNewTCB->pxTopOfStack =
700a4eac: 990c         	ldr	r1, [sp, #0x30]
700a4eae: 6008         	str	r0, [r1]
;   if (pxCreatedTask != NULL) {
700a4eb0: 980b         	ldr	r0, [sp, #0x2c]
700a4eb2: b120         	cbz	r0, 0x700a4ebe <prvInitialiseNewTask+0x10e> @ imm = #0x8
700a4eb4: e7ff         	b	0x700a4eb6 <prvInitialiseNewTask+0x106> @ imm = #-0x2
;     *pxCreatedTask = (TaskHandle_t)pxNewTCB;
700a4eb6: 980c         	ldr	r0, [sp, #0x30]
700a4eb8: 990b         	ldr	r1, [sp, #0x2c]
700a4eba: 6008         	str	r0, [r1]
;   } else {
700a4ebc: e000         	b	0x700a4ec0 <prvInitialiseNewTask+0x110> @ imm = #0x0
700a4ebe: e7ff         	b	0x700a4ec0 <prvInitialiseNewTask+0x110> @ imm = #-0x2
; }
700a4ec0: b008         	add	sp, #0x20
700a4ec2: bd80         	pop	{r7, pc}
		...

700a4ed0 <Sciclient_pmSetModuleClkFreq>:
; {
700a4ed0: b580         	push	{r7, lr}
700a4ed2: b09a         	sub	sp, #0x68
700a4ed4: f8dd c074    	ldr.w	r12, [sp, #0x74]
700a4ed8: f8dd c070    	ldr.w	r12, [sp, #0x70]
700a4edc: 9019         	str	r0, [sp, #0x64]
700a4ede: 9118         	str	r1, [sp, #0x60]
700a4ee0: 9317         	str	r3, [sp, #0x5c]
700a4ee2: 9216         	str	r2, [sp, #0x58]
700a4ee4: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a4ee6: 9015         	str	r0, [sp, #0x54]
;     request.device         = (uint32_t) moduleId;
700a4ee8: 9819         	ldr	r0, [sp, #0x64]
700a4eea: 900c         	str	r0, [sp, #0x30]
;     request.min_freq_hz    = (uint64_t) freqHz;
700a4eec: 9816         	ldr	r0, [sp, #0x58]
700a4eee: 9917         	ldr	r1, [sp, #0x5c]
700a4ef0: 910e         	str	r1, [sp, #0x38]
700a4ef2: 900d         	str	r0, [sp, #0x34]
;     request.target_freq_hz = (uint64_t) freqHz;
700a4ef4: 9816         	ldr	r0, [sp, #0x58]
700a4ef6: 9917         	ldr	r1, [sp, #0x5c]
700a4ef8: 9110         	str	r1, [sp, #0x40]
700a4efa: 900f         	str	r0, [sp, #0x3c]
;     request.max_freq_hz    = (uint64_t) freqHz;
700a4efc: 9816         	ldr	r0, [sp, #0x58]
700a4efe: 9917         	ldr	r1, [sp, #0x5c]
700a4f00: 9112         	str	r1, [sp, #0x48]
700a4f02: 9011         	str	r0, [sp, #0x44]
;     if((freqHz%10U) != 0U)
700a4f04: 9b16         	ldr	r3, [sp, #0x58]
700a4f06: 9817         	ldr	r0, [sp, #0x5c]
700a4f08: f64c 41cd    	movw	r1, #0xcccd
700a4f0c: f6cc 41cc    	movt	r1, #0xcccc
700a4f10: fba3 2e01    	umull	r2, lr, r3, r1
700a4f14: f04f 3ccc    	mov.w	r12, #0xcccccccc
700a4f18: fb03 e30c    	mla	r3, r3, r12, lr
700a4f1c: fb00 3101    	mla	r1, r0, r1, r3
700a4f20: ea4f 70c2    	lsl.w	r0, r2, #0x1f
700a4f24: ea40 0051    	orr.w	r0, r0, r1, lsr #1
700a4f28: ea4f 71c1    	lsl.w	r1, r1, #0x1f
700a4f2c: ea41 0152    	orr.w	r1, r1, r2, lsr #1
700a4f30: f649 129a    	movw	r2, #0x999a
700a4f34: f6c9 1299    	movt	r2, #0x9999
700a4f38: 1a89         	subs	r1, r1, r2
700a4f3a: f649 1199    	movw	r1, #0x9999
700a4f3e: f6c1 1199    	movt	r1, #0x1999
700a4f42: 4188         	sbcs	r0, r1
700a4f44: d316         	blo	0x700a4f74 <Sciclient_pmSetModuleClkFreq+0xa4> @ imm = #0x2c
700a4f46: e7ff         	b	0x700a4f48 <Sciclient_pmSetModuleClkFreq+0x78> @ imm = #-0x2
;         request.min_freq_hz = (uint64_t)(freqHz-(freqHz%10U));
700a4f48: 9816         	ldr	r0, [sp, #0x58]
700a4f4a: 9001         	str	r0, [sp, #0x4]
700a4f4c: 9917         	ldr	r1, [sp, #0x5c]
700a4f4e: 9100         	str	r1, [sp]
700a4f50: 220a         	movs	r2, #0xa
700a4f52: 2300         	movs	r3, #0x0
700a4f54: f00a e946    	blx	0x700af1e4 <__aeabi_uldivmod> @ imm = #0xa28c
700a4f58: 9800         	ldr	r0, [sp]
700a4f5a: 9901         	ldr	r1, [sp, #0x4]
700a4f5c: 1a89         	subs	r1, r1, r2
700a4f5e: 4198         	sbcs	r0, r3
700a4f60: 910d         	str	r1, [sp, #0x34]
700a4f62: 900e         	str	r0, [sp, #0x38]
;         request.max_freq_hz = (uint64_t)(request.min_freq_hz + 10UL);
700a4f64: 990d         	ldr	r1, [sp, #0x34]
700a4f66: 980e         	ldr	r0, [sp, #0x38]
700a4f68: 310a         	adds	r1, #0xa
700a4f6a: f140 0000    	adc	r0, r0, #0x0
700a4f6e: 9111         	str	r1, [sp, #0x44]
700a4f70: 9012         	str	r0, [sp, #0x48]
;     }
700a4f72: e7ff         	b	0x700a4f74 <Sciclient_pmSetModuleClkFreq+0xa4> @ imm = #-0x2
;     if (clockId >= 255U)
700a4f74: 9818         	ldr	r0, [sp, #0x60]
700a4f76: 28ff         	cmp	r0, #0xff
700a4f78: d307         	blo	0x700a4f8a <Sciclient_pmSetModuleClkFreq+0xba> @ imm = #0xe
700a4f7a: e7ff         	b	0x700a4f7c <Sciclient_pmSetModuleClkFreq+0xac> @ imm = #-0x2
;         request.clk32 = clockId;
700a4f7c: 9818         	ldr	r0, [sp, #0x60]
700a4f7e: f8cd 004d    	str.w	r0, [sp, #0x4d]
700a4f82: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a4f84: f88d 004c    	strb.w	r0, [sp, #0x4c]
;     }
700a4f88: e003         	b	0x700a4f92 <Sciclient_pmSetModuleClkFreq+0xc2> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a4f8a: 9818         	ldr	r0, [sp, #0x60]
700a4f8c: f88d 004c    	strb.w	r0, [sp, #0x4c]
700a4f90: e7ff         	b	0x700a4f92 <Sciclient_pmSetModuleClkFreq+0xc2> @ imm = #-0x2
700a4f92: f44f 7086    	mov.w	r0, #0x10c
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_FREQ;
700a4f96: f8ad 0014    	strh.w	r0, [sp, #0x14]
;     reqParam.flags          = (uint32_t)(TISCI_MSG_FLAG_AOP | additionalFlag);
700a4f9a: 981c         	ldr	r0, [sp, #0x70]
700a4f9c: f040 0002    	orr	r0, r0, #0x2
700a4fa0: 9006         	str	r0, [sp, #0x18]
700a4fa2: a80a         	add	r0, sp, #0x28
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a4fa4: 9007         	str	r0, [sp, #0x1c]
700a4fa6: 2029         	movs	r0, #0x29
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a4fa8: 9008         	str	r0, [sp, #0x20]
;     reqParam.timeout        = (uint32_t) timeout;
700a4faa: 981d         	ldr	r0, [sp, #0x74]
700a4fac: 9009         	str	r0, [sp, #0x24]
700a4fae: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a4fb0: 9002         	str	r0, [sp, #0x8]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a4fb2: 9003         	str	r0, [sp, #0xc]
;     respParam.respPayloadSize = (uint32_t) 0;
700a4fb4: 9004         	str	r0, [sp, #0x10]
700a4fb6: a805         	add	r0, sp, #0x14
700a4fb8: a902         	add	r1, sp, #0x8
;     retVal = Sciclient_service(&reqParam, &respParam);
700a4fba: f7f8 fb19    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0x79ce
700a4fbe: 9015         	str	r0, [sp, #0x54]
;     if((retVal != SystemP_SUCCESS) ||
700a4fc0: 9815         	ldr	r0, [sp, #0x54]
700a4fc2: b930         	cbnz	r0, 0x700a4fd2 <Sciclient_pmSetModuleClkFreq+0x102> @ imm = #0xc
700a4fc4: e7ff         	b	0x700a4fc6 <Sciclient_pmSetModuleClkFreq+0xf6> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a4fc6: 9802         	ldr	r0, [sp, #0x8]
700a4fc8: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a4fcc: 2802         	cmp	r0, #0x2
700a4fce: d004         	beq	0x700a4fda <Sciclient_pmSetModuleClkFreq+0x10a> @ imm = #0x8
700a4fd0: e7ff         	b	0x700a4fd2 <Sciclient_pmSetModuleClkFreq+0x102> @ imm = #-0x2
700a4fd2: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a4fd6: 9015         	str	r0, [sp, #0x54]
;     }
700a4fd8: e7ff         	b	0x700a4fda <Sciclient_pmSetModuleClkFreq+0x10a> @ imm = #-0x2
;     return retVal;
700a4fda: 9815         	ldr	r0, [sp, #0x54]
700a4fdc: b01a         	add	sp, #0x68
700a4fde: bd80         	pop	{r7, pc}

700a4fe0 <vTaskSuspend>:
; void vTaskSuspend(TaskHandle_t xTaskToSuspend) {
700a4fe0: b580         	push	{r7, lr}
700a4fe2: b084         	sub	sp, #0x10
700a4fe4: 9003         	str	r0, [sp, #0xc]
;   taskENTER_CRITICAL();
700a4fe6: f009 fbcb    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0x9796
;     pxTCB = prvGetTCBFromHandle(xTaskToSuspend);
700a4fea: 9803         	ldr	r0, [sp, #0xc]
700a4fec: b938         	cbnz	r0, 0x700a4ffe <vTaskSuspend+0x1e> @ imm = #0xe
700a4fee: e7ff         	b	0x700a4ff0 <vTaskSuspend+0x10> @ imm = #-0x2
700a4ff0: f642 200c    	movw	r0, #0x2a0c
700a4ff4: f2c7 000b    	movt	r0, #0x700b
700a4ff8: 6800         	ldr	r0, [r0]
700a4ffa: 9000         	str	r0, [sp]
700a4ffc: e002         	b	0x700a5004 <vTaskSuspend+0x24> @ imm = #0x4
700a4ffe: 9803         	ldr	r0, [sp, #0xc]
700a5000: 9000         	str	r0, [sp]
700a5002: e7ff         	b	0x700a5004 <vTaskSuspend+0x24> @ imm = #-0x2
700a5004: 9800         	ldr	r0, [sp]
700a5006: 9002         	str	r0, [sp, #0x8]
;     if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a5008: 9802         	ldr	r0, [sp, #0x8]
700a500a: 3004         	adds	r0, #0x4
700a500c: f008 fb88    	bl	0x700ad720 <uxListRemove> @ imm = #0x8710
700a5010: b908         	cbnz	r0, 0x700a5016 <vTaskSuspend+0x36> @ imm = #0x2
700a5012: e7ff         	b	0x700a5014 <vTaskSuspend+0x34> @ imm = #-0x2
;     } else {
700a5014: e000         	b	0x700a5018 <vTaskSuspend+0x38> @ imm = #0x0
700a5016: e7ff         	b	0x700a5018 <vTaskSuspend+0x38> @ imm = #-0x2
;     if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a5018: 9802         	ldr	r0, [sp, #0x8]
700a501a: 6a80         	ldr	r0, [r0, #0x28]
700a501c: b128         	cbz	r0, 0x700a502a <vTaskSuspend+0x4a> @ imm = #0xa
700a501e: e7ff         	b	0x700a5020 <vTaskSuspend+0x40> @ imm = #-0x2
;       (void)uxListRemove(&(pxTCB->xEventListItem));
700a5020: 9802         	ldr	r0, [sp, #0x8]
700a5022: 3018         	adds	r0, #0x18
700a5024: f008 fb7c    	bl	0x700ad720 <uxListRemove> @ imm = #0x86f8
;     } else {
700a5028: e000         	b	0x700a502c <vTaskSuspend+0x4c> @ imm = #0x0
700a502a: e7ff         	b	0x700a502c <vTaskSuspend+0x4c> @ imm = #-0x2
;     vListInsertEnd(&xSuspendedTaskList, &(pxTCB->xStateListItem));
700a502c: 9802         	ldr	r0, [sp, #0x8]
700a502e: 1d01         	adds	r1, r0, #0x4
700a5030: f245 2074    	movw	r0, #0x5274
700a5034: f2c7 0008    	movt	r0, #0x7008
700a5038: f009 f92a    	bl	0x700ae290 <vListInsertEnd> @ imm = #0x9254
700a503c: 2000         	movs	r0, #0x0
;       for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a503e: 9001         	str	r0, [sp, #0x4]
700a5040: e7ff         	b	0x700a5042 <vTaskSuspend+0x62> @ imm = #-0x2
700a5042: 9801         	ldr	r0, [sp, #0x4]
700a5044: 2800         	cmp	r0, #0x0
700a5046: dc14         	bgt	0x700a5072 <vTaskSuspend+0x92> @ imm = #0x28
700a5048: e7ff         	b	0x700a504a <vTaskSuspend+0x6a> @ imm = #-0x2
;         if (pxTCB->ucNotifyState[x] == taskWAITING_NOTIFICATION) {
700a504a: 9802         	ldr	r0, [sp, #0x8]
700a504c: 9901         	ldr	r1, [sp, #0x4]
700a504e: 4408         	add	r0, r1
700a5050: f890 0080    	ldrb.w	r0, [r0, #0x80]
700a5054: 2801         	cmp	r0, #0x1
700a5056: d107         	bne	0x700a5068 <vTaskSuspend+0x88> @ imm = #0xe
700a5058: e7ff         	b	0x700a505a <vTaskSuspend+0x7a> @ imm = #-0x2
;           pxTCB->ucNotifyState[x] = taskNOT_WAITING_NOTIFICATION;
700a505a: 9802         	ldr	r0, [sp, #0x8]
700a505c: 9901         	ldr	r1, [sp, #0x4]
700a505e: 4401         	add	r1, r0
700a5060: 2000         	movs	r0, #0x0
700a5062: f881 0080    	strb.w	r0, [r1, #0x80]
;         }
700a5066: e7ff         	b	0x700a5068 <vTaskSuspend+0x88> @ imm = #-0x2
;       }
700a5068: e7ff         	b	0x700a506a <vTaskSuspend+0x8a> @ imm = #-0x2
;       for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a506a: 9801         	ldr	r0, [sp, #0x4]
700a506c: 3001         	adds	r0, #0x1
700a506e: 9001         	str	r0, [sp, #0x4]
700a5070: e7e7         	b	0x700a5042 <vTaskSuspend+0x62> @ imm = #-0x32
;   taskEXIT_CRITICAL();
700a5072: f008 fc45    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0x888a
;   if (xSchedulerRunning != pdFALSE) {
700a5076: f642 2050    	movw	r0, #0x2a50
700a507a: f2c7 000b    	movt	r0, #0x700b
700a507e: 6800         	ldr	r0, [r0]
700a5080: b138         	cbz	r0, 0x700a5092 <vTaskSuspend+0xb2> @ imm = #0xe
700a5082: e7ff         	b	0x700a5084 <vTaskSuspend+0xa4> @ imm = #-0x2
;     taskENTER_CRITICAL();
700a5084: f009 fb7c    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0x96f8
;       prvResetNextTaskUnblockTime();
700a5088: f009 f882    	bl	0x700ae190 <prvResetNextTaskUnblockTime> @ imm = #0x9104
;     taskEXIT_CRITICAL();
700a508c: f008 fc38    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0x8870
;   } else {
700a5090: e000         	b	0x700a5094 <vTaskSuspend+0xb4> @ imm = #0x0
700a5092: e7ff         	b	0x700a5094 <vTaskSuspend+0xb4> @ imm = #-0x2
;   if (pxTCB == pxCurrentTCB) {
700a5094: 9802         	ldr	r0, [sp, #0x8]
700a5096: f642 210c    	movw	r1, #0x2a0c
700a509a: f2c7 010b    	movt	r1, #0x700b
700a509e: 6809         	ldr	r1, [r1]
700a50a0: 4288         	cmp	r0, r1
700a50a2: d122         	bne	0x700a50ea <vTaskSuspend+0x10a> @ imm = #0x44
700a50a4: e7ff         	b	0x700a50a6 <vTaskSuspend+0xc6> @ imm = #-0x2
;     if (xSchedulerRunning != pdFALSE) {
700a50a6: f642 2050    	movw	r0, #0x2a50
700a50aa: f2c7 000b    	movt	r0, #0x700b
700a50ae: 6800         	ldr	r0, [r0]
700a50b0: b110         	cbz	r0, 0x700a50b8 <vTaskSuspend+0xd8> @ imm = #0x4
700a50b2: e7ff         	b	0x700a50b4 <vTaskSuspend+0xd4> @ imm = #-0x2
;       portYIELD_WITHIN_API();
700a50b4: df00         	svc	#0x0
;     } else {
700a50b6: e017         	b	0x700a50e8 <vTaskSuspend+0x108> @ imm = #0x2e
;       if (listCURRENT_LIST_LENGTH(&xSuspendedTaskList) ==
700a50b8: f245 2074    	movw	r0, #0x5274
700a50bc: f2c7 0008    	movt	r0, #0x7008
700a50c0: 6800         	ldr	r0, [r0]
;           uxCurrentNumberOfTasks) /*lint !e931 Right has no side effect, just
700a50c2: f642 212c    	movw	r1, #0x2a2c
700a50c6: f2c7 010b    	movt	r1, #0x700b
700a50ca: 6809         	ldr	r1, [r1]
;       if (listCURRENT_LIST_LENGTH(&xSuspendedTaskList) ==
700a50cc: 4288         	cmp	r0, r1
700a50ce: d107         	bne	0x700a50e0 <vTaskSuspend+0x100> @ imm = #0xe
700a50d0: e7ff         	b	0x700a50d2 <vTaskSuspend+0xf2> @ imm = #-0x2
;         pxCurrentTCB = NULL;
700a50d2: f642 210c    	movw	r1, #0x2a0c
700a50d6: f2c7 010b    	movt	r1, #0x700b
700a50da: 2000         	movs	r0, #0x0
700a50dc: 6008         	str	r0, [r1]
;       } else {
700a50de: e002         	b	0x700a50e6 <vTaskSuspend+0x106> @ imm = #0x4
;         vTaskSwitchContext();
700a50e0: f001 fcbe    	bl	0x700a6a60 <vTaskSwitchContext> @ imm = #0x197c
700a50e4: e7ff         	b	0x700a50e6 <vTaskSuspend+0x106> @ imm = #-0x2
700a50e6: e7ff         	b	0x700a50e8 <vTaskSuspend+0x108> @ imm = #-0x2
;   } else {
700a50e8: e000         	b	0x700a50ec <vTaskSuspend+0x10c> @ imm = #0x0
700a50ea: e7ff         	b	0x700a50ec <vTaskSuspend+0x10c> @ imm = #-0x2
; }
700a50ec: b004         	add	sp, #0x10
700a50ee: bd80         	pop	{r7, pc}

700a50f0 <prvAddNewTaskToReadyList>:
; static void prvAddNewTaskToReadyList(TCB_t *pxNewTCB) {
700a50f0: b580         	push	{r7, lr}
700a50f2: b082         	sub	sp, #0x8
700a50f4: 9001         	str	r0, [sp, #0x4]
;   taskENTER_CRITICAL();
700a50f6: f009 fb43    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0x9686
;     uxCurrentNumberOfTasks++;
700a50fa: f642 212c    	movw	r1, #0x2a2c
700a50fe: f2c7 010b    	movt	r1, #0x700b
700a5102: 6808         	ldr	r0, [r1]
700a5104: 3001         	adds	r0, #0x1
700a5106: 6008         	str	r0, [r1]
;     if (pxCurrentTCB == NULL) {
700a5108: f642 200c    	movw	r0, #0x2a0c
700a510c: f2c7 000b    	movt	r0, #0x700b
700a5110: 6800         	ldr	r0, [r0]
700a5112: b998         	cbnz	r0, 0x700a513c <prvAddNewTaskToReadyList+0x4c> @ imm = #0x26
700a5114: e7ff         	b	0x700a5116 <prvAddNewTaskToReadyList+0x26> @ imm = #-0x2
;       pxCurrentTCB = pxNewTCB;
700a5116: 9801         	ldr	r0, [sp, #0x4]
700a5118: f642 210c    	movw	r1, #0x2a0c
700a511c: f2c7 010b    	movt	r1, #0x700b
700a5120: 6008         	str	r0, [r1]
;       if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
700a5122: f642 202c    	movw	r0, #0x2a2c
700a5126: f2c7 000b    	movt	r0, #0x700b
700a512a: 6800         	ldr	r0, [r0]
700a512c: 2801         	cmp	r0, #0x1
700a512e: d103         	bne	0x700a5138 <prvAddNewTaskToReadyList+0x48> @ imm = #0x6
700a5130: e7ff         	b	0x700a5132 <prvAddNewTaskToReadyList+0x42> @ imm = #-0x2
;         prvInitialiseTaskLists();
700a5132: f004 fe8d    	bl	0x700a9e50 <prvInitialiseTaskLists> @ imm = #0x4d1a
;       } else {
700a5136: e000         	b	0x700a513a <prvAddNewTaskToReadyList+0x4a> @ imm = #0x0
700a5138: e7ff         	b	0x700a513a <prvAddNewTaskToReadyList+0x4a> @ imm = #-0x2
;     } else {
700a513a: e01c         	b	0x700a5176 <prvAddNewTaskToReadyList+0x86> @ imm = #0x38
;       if (xSchedulerRunning == pdFALSE) {
700a513c: f642 2050    	movw	r0, #0x2a50
700a5140: f2c7 000b    	movt	r0, #0x700b
700a5144: 6800         	ldr	r0, [r0]
700a5146: b9a0         	cbnz	r0, 0x700a5172 <prvAddNewTaskToReadyList+0x82> @ imm = #0x28
700a5148: e7ff         	b	0x700a514a <prvAddNewTaskToReadyList+0x5a> @ imm = #-0x2
;         if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
700a514a: f642 200c    	movw	r0, #0x2a0c
700a514e: f2c7 000b    	movt	r0, #0x700b
700a5152: 6800         	ldr	r0, [r0]
700a5154: 6ac0         	ldr	r0, [r0, #0x2c]
700a5156: 9901         	ldr	r1, [sp, #0x4]
700a5158: 6ac9         	ldr	r1, [r1, #0x2c]
700a515a: 4288         	cmp	r0, r1
700a515c: d807         	bhi	0x700a516e <prvAddNewTaskToReadyList+0x7e> @ imm = #0xe
700a515e: e7ff         	b	0x700a5160 <prvAddNewTaskToReadyList+0x70> @ imm = #-0x2
;           pxCurrentTCB = pxNewTCB;
700a5160: 9801         	ldr	r0, [sp, #0x4]
700a5162: f642 210c    	movw	r1, #0x2a0c
700a5166: f2c7 010b    	movt	r1, #0x700b
700a516a: 6008         	str	r0, [r1]
;         } else {
700a516c: e000         	b	0x700a5170 <prvAddNewTaskToReadyList+0x80> @ imm = #0x0
700a516e: e7ff         	b	0x700a5170 <prvAddNewTaskToReadyList+0x80> @ imm = #-0x2
;       } else {
700a5170: e000         	b	0x700a5174 <prvAddNewTaskToReadyList+0x84> @ imm = #0x0
700a5172: e7ff         	b	0x700a5174 <prvAddNewTaskToReadyList+0x84> @ imm = #-0x2
700a5174: e7ff         	b	0x700a5176 <prvAddNewTaskToReadyList+0x86> @ imm = #-0x2
;     uxTaskNumber++;
700a5176: f642 2038    	movw	r0, #0x2a38
700a517a: f2c7 000b    	movt	r0, #0x700b
700a517e: 6801         	ldr	r1, [r0]
700a5180: 3101         	adds	r1, #0x1
700a5182: 6001         	str	r1, [r0]
;       pxNewTCB->uxTCBNumber = uxTaskNumber;
700a5184: 6800         	ldr	r0, [r0]
700a5186: 9901         	ldr	r1, [sp, #0x4]
700a5188: 6588         	str	r0, [r1, #0x58]
;     prvAddTaskToReadyList(pxNewTCB);
700a518a: 9801         	ldr	r0, [sp, #0x4]
700a518c: 6ac0         	ldr	r0, [r0, #0x2c]
700a518e: f642 213c    	movw	r1, #0x2a3c
700a5192: f2c7 010b    	movt	r1, #0x700b
700a5196: 6809         	ldr	r1, [r1]
700a5198: 4288         	cmp	r0, r1
700a519a: d908         	bls	0x700a51ae <prvAddNewTaskToReadyList+0xbe> @ imm = #0x10
700a519c: e7ff         	b	0x700a519e <prvAddNewTaskToReadyList+0xae> @ imm = #-0x2
700a519e: 9801         	ldr	r0, [sp, #0x4]
700a51a0: 6ac0         	ldr	r0, [r0, #0x2c]
700a51a2: f642 213c    	movw	r1, #0x2a3c
700a51a6: f2c7 010b    	movt	r1, #0x700b
700a51aa: 6008         	str	r0, [r1]
700a51ac: e7ff         	b	0x700a51ae <prvAddNewTaskToReadyList+0xbe> @ imm = #-0x2
700a51ae: 9901         	ldr	r1, [sp, #0x4]
700a51b0: 6ac8         	ldr	r0, [r1, #0x2c]
700a51b2: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a51b6: f244 40f8    	movw	r0, #0x44f8
700a51ba: f2c7 0008    	movt	r0, #0x7008
700a51be: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a51c2: 3104         	adds	r1, #0x4
700a51c4: f009 f864    	bl	0x700ae290 <vListInsertEnd> @ imm = #0x90c8
;   taskEXIT_CRITICAL();
700a51c8: f008 fb9a    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0x8734
;   if (xSchedulerRunning != pdFALSE) {
700a51cc: f642 2050    	movw	r0, #0x2a50
700a51d0: f2c7 000b    	movt	r0, #0x700b
700a51d4: 6800         	ldr	r0, [r0]
700a51d6: b178         	cbz	r0, 0x700a51f8 <prvAddNewTaskToReadyList+0x108> @ imm = #0x1e
700a51d8: e7ff         	b	0x700a51da <prvAddNewTaskToReadyList+0xea> @ imm = #-0x2
;     if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
700a51da: f642 200c    	movw	r0, #0x2a0c
700a51de: f2c7 000b    	movt	r0, #0x700b
700a51e2: 6800         	ldr	r0, [r0]
700a51e4: 6ac0         	ldr	r0, [r0, #0x2c]
700a51e6: 9901         	ldr	r1, [sp, #0x4]
700a51e8: 6ac9         	ldr	r1, [r1, #0x2c]
700a51ea: 4288         	cmp	r0, r1
700a51ec: d202         	bhs	0x700a51f4 <prvAddNewTaskToReadyList+0x104> @ imm = #0x4
700a51ee: e7ff         	b	0x700a51f0 <prvAddNewTaskToReadyList+0x100> @ imm = #-0x2
;       taskYIELD_IF_USING_PREEMPTION();
700a51f0: df00         	svc	#0x0
;     } else {
700a51f2: e000         	b	0x700a51f6 <prvAddNewTaskToReadyList+0x106> @ imm = #0x0
700a51f4: e7ff         	b	0x700a51f6 <prvAddNewTaskToReadyList+0x106> @ imm = #-0x2
;   } else {
700a51f6: e000         	b	0x700a51fa <prvAddNewTaskToReadyList+0x10a> @ imm = #0x0
700a51f8: e7ff         	b	0x700a51fa <prvAddNewTaskToReadyList+0x10a> @ imm = #-0x2
; }
700a51fa: b002         	add	sp, #0x8
700a51fc: bd80         	pop	{r7, pc}
700a51fe: 0000         	movs	r0, r0

700a5200 <xTaskPriorityInherit>:
; BaseType_t xTaskPriorityInherit(TaskHandle_t const pxMutexHolder) {
700a5200: b580         	push	{r7, lr}
700a5202: b084         	sub	sp, #0x10
700a5204: 9003         	str	r0, [sp, #0xc]
;   TCB_t *const pxMutexHolderTCB = pxMutexHolder;
700a5206: 9803         	ldr	r0, [sp, #0xc]
700a5208: 9002         	str	r0, [sp, #0x8]
700a520a: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700a520c: 9001         	str	r0, [sp, #0x4]
;   if (pxMutexHolder != NULL) {
700a520e: 9803         	ldr	r0, [sp, #0xc]
700a5210: 2800         	cmp	r0, #0x0
700a5212: d078         	beq	0x700a5306 <xTaskPriorityInherit+0x106> @ imm = #0xf0
700a5214: e7ff         	b	0x700a5216 <xTaskPriorityInherit+0x16> @ imm = #-0x2
;     if (pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority) {
700a5216: 9802         	ldr	r0, [sp, #0x8]
700a5218: 6ac0         	ldr	r0, [r0, #0x2c]
700a521a: f642 210c    	movw	r1, #0x2a0c
700a521e: f2c7 010b    	movt	r1, #0x700b
700a5222: 6809         	ldr	r1, [r1]
700a5224: 6ac9         	ldr	r1, [r1, #0x2c]
700a5226: 4288         	cmp	r0, r1
700a5228: d25c         	bhs	0x700a52e4 <xTaskPriorityInherit+0xe4> @ imm = #0xb8
700a522a: e7ff         	b	0x700a522c <xTaskPriorityInherit+0x2c> @ imm = #-0x2
;       if ((listGET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem)) &
700a522c: 9802         	ldr	r0, [sp, #0x8]
700a522e: 7ec0         	ldrb	r0, [r0, #0x1b]
700a5230: 0600         	lsls	r0, r0, #0x18
700a5232: 2800         	cmp	r0, #0x0
700a5234: d40b         	bmi	0x700a524e <xTaskPriorityInherit+0x4e> @ imm = #0x16
700a5236: e7ff         	b	0x700a5238 <xTaskPriorityInherit+0x38> @ imm = #-0x2
;         listSET_LIST_ITEM_VALUE(
700a5238: f642 200c    	movw	r0, #0x2a0c
700a523c: f2c7 000b    	movt	r0, #0x700b
700a5240: 6800         	ldr	r0, [r0]
700a5242: 6ac0         	ldr	r0, [r0, #0x2c]
700a5244: f1c0 0020    	rsb.w	r0, r0, #0x20
700a5248: 9902         	ldr	r1, [sp, #0x8]
700a524a: 6188         	str	r0, [r1, #0x18]
;       } else {
700a524c: e000         	b	0x700a5250 <xTaskPriorityInherit+0x50> @ imm = #0x0
700a524e: e7ff         	b	0x700a5250 <xTaskPriorityInherit+0x50> @ imm = #-0x2
;       if (listIS_CONTAINED_WITHIN(
700a5250: 9902         	ldr	r1, [sp, #0x8]
700a5252: 6948         	ldr	r0, [r1, #0x14]
700a5254: 6ac9         	ldr	r1, [r1, #0x2c]
700a5256: eb01 0281    	add.w	r2, r1, r1, lsl #2
700a525a: f244 41f8    	movw	r1, #0x44f8
700a525e: f2c7 0108    	movt	r1, #0x7008
700a5262: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a5266: 4288         	cmp	r0, r1
700a5268: d130         	bne	0x700a52cc <xTaskPriorityInherit+0xcc> @ imm = #0x60
700a526a: e7ff         	b	0x700a526c <xTaskPriorityInherit+0x6c> @ imm = #-0x2
;         if (uxListRemove(&(pxMutexHolderTCB->xStateListItem)) ==
700a526c: 9802         	ldr	r0, [sp, #0x8]
700a526e: 3004         	adds	r0, #0x4
700a5270: f008 fa56    	bl	0x700ad720 <uxListRemove> @ imm = #0x84ac
700a5274: b908         	cbnz	r0, 0x700a527a <xTaskPriorityInherit+0x7a> @ imm = #0x2
700a5276: e7ff         	b	0x700a5278 <xTaskPriorityInherit+0x78> @ imm = #-0x2
;         } else {
700a5278: e000         	b	0x700a527c <xTaskPriorityInherit+0x7c> @ imm = #0x0
700a527a: e7ff         	b	0x700a527c <xTaskPriorityInherit+0x7c> @ imm = #-0x2
;         pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
700a527c: f642 200c    	movw	r0, #0x2a0c
700a5280: f2c7 000b    	movt	r0, #0x700b
700a5284: 6800         	ldr	r0, [r0]
700a5286: 6ac0         	ldr	r0, [r0, #0x2c]
700a5288: 9902         	ldr	r1, [sp, #0x8]
700a528a: 62c8         	str	r0, [r1, #0x2c]
;         prvAddTaskToReadyList(pxMutexHolderTCB);
700a528c: 9802         	ldr	r0, [sp, #0x8]
700a528e: 6ac0         	ldr	r0, [r0, #0x2c]
700a5290: f642 213c    	movw	r1, #0x2a3c
700a5294: f2c7 010b    	movt	r1, #0x700b
700a5298: 6809         	ldr	r1, [r1]
700a529a: 4288         	cmp	r0, r1
700a529c: d908         	bls	0x700a52b0 <xTaskPriorityInherit+0xb0> @ imm = #0x10
700a529e: e7ff         	b	0x700a52a0 <xTaskPriorityInherit+0xa0> @ imm = #-0x2
700a52a0: 9802         	ldr	r0, [sp, #0x8]
700a52a2: 6ac0         	ldr	r0, [r0, #0x2c]
700a52a4: f642 213c    	movw	r1, #0x2a3c
700a52a8: f2c7 010b    	movt	r1, #0x700b
700a52ac: 6008         	str	r0, [r1]
700a52ae: e7ff         	b	0x700a52b0 <xTaskPriorityInherit+0xb0> @ imm = #-0x2
700a52b0: 9902         	ldr	r1, [sp, #0x8]
700a52b2: 6ac8         	ldr	r0, [r1, #0x2c]
700a52b4: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a52b8: f244 40f8    	movw	r0, #0x44f8
700a52bc: f2c7 0008    	movt	r0, #0x7008
700a52c0: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a52c4: 3104         	adds	r1, #0x4
700a52c6: f008 ffe3    	bl	0x700ae290 <vListInsertEnd> @ imm = #0x8fc6
;       } else {
700a52ca: e008         	b	0x700a52de <xTaskPriorityInherit+0xde> @ imm = #0x10
;         pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
700a52cc: f642 200c    	movw	r0, #0x2a0c
700a52d0: f2c7 000b    	movt	r0, #0x700b
700a52d4: 6800         	ldr	r0, [r0]
700a52d6: 6ac0         	ldr	r0, [r0, #0x2c]
700a52d8: 9902         	ldr	r1, [sp, #0x8]
700a52da: 62c8         	str	r0, [r1, #0x2c]
700a52dc: e7ff         	b	0x700a52de <xTaskPriorityInherit+0xde> @ imm = #-0x2
700a52de: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a52e0: 9001         	str	r0, [sp, #0x4]
;     } else {
700a52e2: e00f         	b	0x700a5304 <xTaskPriorityInherit+0x104> @ imm = #0x1e
;       if (pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority) {
700a52e4: 9802         	ldr	r0, [sp, #0x8]
700a52e6: 6e00         	ldr	r0, [r0, #0x60]
700a52e8: f642 210c    	movw	r1, #0x2a0c
700a52ec: f2c7 010b    	movt	r1, #0x700b
700a52f0: 6809         	ldr	r1, [r1]
700a52f2: 6ac9         	ldr	r1, [r1, #0x2c]
700a52f4: 4288         	cmp	r0, r1
700a52f6: d203         	bhs	0x700a5300 <xTaskPriorityInherit+0x100> @ imm = #0x6
700a52f8: e7ff         	b	0x700a52fa <xTaskPriorityInherit+0xfa> @ imm = #-0x2
700a52fa: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700a52fc: 9001         	str	r0, [sp, #0x4]
;       } else {
700a52fe: e000         	b	0x700a5302 <xTaskPriorityInherit+0x102> @ imm = #0x0
700a5300: e7ff         	b	0x700a5302 <xTaskPriorityInherit+0x102> @ imm = #-0x2
700a5302: e7ff         	b	0x700a5304 <xTaskPriorityInherit+0x104> @ imm = #-0x2
;   } else {
700a5304: e000         	b	0x700a5308 <xTaskPriorityInherit+0x108> @ imm = #0x0
700a5306: e7ff         	b	0x700a5308 <xTaskPriorityInherit+0x108> @ imm = #-0x2
;   return xReturn;
700a5308: 9801         	ldr	r0, [sp, #0x4]
700a530a: b004         	add	sp, #0x10
700a530c: bd80         	pop	{r7, pc}
700a530e: 0000         	movs	r0, r0

700a5310 <tm_isr_message_handler>:
; {
700a5310: b570         	push	{r4, r5, r6, lr}
;    tm_isr_counter++;
700a5312: f642 2014    	movw	r0, #0x2a14
;    message[1] = isr_message_counter;
700a5316: f642 2504    	movw	r5, #0x2a04
;    tm_isr_counter++;
700a531a: f2c7 000b    	movt	r0, #0x700b
;    message[1] = isr_message_counter;
700a531e: f2c7 050b    	movt	r5, #0x700b
;    message[0] = 1;
700a5322: f644 76c0    	movw	r6, #0x4fc0
700a5326: f2c7 0608    	movt	r6, #0x7008
;    tm_isr_counter++;
700a532a: 6801         	ldr	r1, [r0]
700a532c: 3101         	adds	r1, #0x1
700a532e: 6001         	str	r1, [r0]
700a5330: 2001         	movs	r0, #0x1
;    message[1] = isr_message_counter;
700a5332: 6829         	ldr	r1, [r5]
;    message[0] = 1;
700a5334: 6030         	str	r0, [r6]
700a5336: 2000         	movs	r0, #0x0
;    message[1] = isr_message_counter;
700a5338: 6071         	str	r1, [r6, #0x4]
700a533a: bf00         	nop
700a533c: bf00         	nop
700a533e: bf00         	nop
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700a5340: 6829         	ldr	r1, [r5]
700a5342: f200 33eb    	addw	r3, r0, #0x3eb
700a5346: 682a         	ldr	r2, [r5]
;    for (i = 2; i < MESSAGE_SIZE - 1; i++)
700a5348: 281b         	cmp	r0, #0x1b
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700a534a: eb01 0181    	add.w	r1, r1, r1, lsl #2
700a534e: eb02 0282    	add.w	r2, r2, r2, lsl #2
700a5352: eb03 0141    	add.w	r1, r3, r1, lsl #1
700a5356: f1a1 0401    	sub.w	r4, r1, #0x1
700a535a: eb06 0180    	add.w	r1, r6, r0, lsl #2
700a535e: eb03 0242    	add.w	r2, r3, r2, lsl #1
700a5362: e9c1 4202    	strd	r4, r2, [r1, #8]
;    for (i = 2; i < MESSAGE_SIZE - 1; i++)
700a5366: d009         	beq	0x700a537c <tm_isr_message_handler+0x6c> @ imm = #0x12
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700a5368: 682a         	ldr	r2, [r5]
700a536a: eb02 0282    	add.w	r2, r2, r2, lsl #2
700a536e: eb00 0242    	add.w	r2, r0, r2, lsl #1
700a5372: 3003         	adds	r0, #0x3
700a5374: f502 727b    	add.w	r2, r2, #0x3ec
700a5378: 610a         	str	r2, [r1, #0x10]
700a537a: e7e1         	b	0x700a5340 <tm_isr_message_handler+0x30> @ imm = #-0x3e
;       checksum += msg[i];
700a537c: e896 0007    	ldm.w	r6, {r0, r1, r2}
700a5380: 4408         	add	r0, r1
700a5382: 68f1         	ldr	r1, [r6, #0xc]
700a5384: 4410         	add	r0, r2
700a5386: 6932         	ldr	r2, [r6, #0x10]
700a5388: 4408         	add	r0, r1
700a538a: 6971         	ldr	r1, [r6, #0x14]
700a538c: 4410         	add	r0, r2
700a538e: 69b2         	ldr	r2, [r6, #0x18]
700a5390: 4408         	add	r0, r1
700a5392: 69f1         	ldr	r1, [r6, #0x1c]
700a5394: 4410         	add	r0, r2
700a5396: 6a32         	ldr	r2, [r6, #0x20]
700a5398: 4408         	add	r0, r1
700a539a: 6a71         	ldr	r1, [r6, #0x24]
700a539c: 4410         	add	r0, r2
700a539e: 6ab2         	ldr	r2, [r6, #0x28]
700a53a0: 4408         	add	r0, r1
700a53a2: 6af1         	ldr	r1, [r6, #0x2c]
700a53a4: 4410         	add	r0, r2
700a53a6: 6b32         	ldr	r2, [r6, #0x30]
700a53a8: 4408         	add	r0, r1
700a53aa: 6b71         	ldr	r1, [r6, #0x34]
700a53ac: 4410         	add	r0, r2
700a53ae: 6bb2         	ldr	r2, [r6, #0x38]
700a53b0: 4408         	add	r0, r1
700a53b2: 6bf1         	ldr	r1, [r6, #0x3c]
700a53b4: 4410         	add	r0, r2
700a53b6: 6c32         	ldr	r2, [r6, #0x40]
700a53b8: 4408         	add	r0, r1
700a53ba: 6c71         	ldr	r1, [r6, #0x44]
700a53bc: 4410         	add	r0, r2
700a53be: 6cb2         	ldr	r2, [r6, #0x48]
700a53c0: 4408         	add	r0, r1
700a53c2: 6cf1         	ldr	r1, [r6, #0x4c]
700a53c4: 4410         	add	r0, r2
700a53c6: 6d32         	ldr	r2, [r6, #0x50]
700a53c8: 4408         	add	r0, r1
700a53ca: 6d71         	ldr	r1, [r6, #0x54]
700a53cc: 4410         	add	r0, r2
700a53ce: 6db2         	ldr	r2, [r6, #0x58]
700a53d0: 4408         	add	r0, r1
700a53d2: 6df1         	ldr	r1, [r6, #0x5c]
700a53d4: 4410         	add	r0, r2
700a53d6: 6e32         	ldr	r2, [r6, #0x60]
700a53d8: 4408         	add	r0, r1
700a53da: 6e71         	ldr	r1, [r6, #0x64]
700a53dc: 4410         	add	r0, r2
700a53de: 6eb2         	ldr	r2, [r6, #0x68]
700a53e0: 4408         	add	r0, r1
700a53e2: 6ef1         	ldr	r1, [r6, #0x6c]
700a53e4: 4410         	add	r0, r2
700a53e6: 6f32         	ldr	r2, [r6, #0x70]
700a53e8: 4408         	add	r0, r1
700a53ea: 6f71         	ldr	r1, [r6, #0x74]
700a53ec: 4410         	add	r0, r2
700a53ee: 6fb2         	ldr	r2, [r6, #0x78]
700a53f0: 4408         	add	r0, r1
;    tm_pmu_profile_start(pmu_send_names[isr_message_counter]);
700a53f2: f644 1178    	movw	r1, #0x4978
700a53f6: f2c7 0108    	movt	r1, #0x7008
;       checksum += msg[i];
700a53fa: 4410         	add	r0, r2
;    message[MESSAGE_SIZE - 1] = compute_checksum(message, MESSAGE_SIZE - 1);
700a53fc: 67f0         	str	r0, [r6, #0x7c]
;    tm_pmu_profile_start(pmu_send_names[isr_message_counter]);
700a53fe: 6828         	ldr	r0, [r5]
700a5400: eb01 1000    	add.w	r0, r1, r0, lsl #4
700a5404: f00a fcdc    	bl	0x700afdc0 <tm_pmu_profile_start> @ imm = #0xa9b8
;    tm_queue_send_from_isr(0, message);
700a5408: 4631         	mov	r1, r6
700a540a: 2000         	movs	r0, #0x0
700a540c: f009 fb30    	bl	0x700aea70 <tm_queue_send_from_isr> @ imm = #0x9660
;    isr_message_counter++; /* Prepare for next iteration */
700a5410: 6828         	ldr	r0, [r5]
700a5412: 3001         	adds	r0, #0x1
700a5414: 6028         	str	r0, [r5]
; }
700a5416: bd70         	pop	{r4, r5, r6, pc}
		...

700a5420 <Udma_eventCheckParams>:
; {
700a5420: b084         	sub	sp, #0x10
700a5422: 9003         	str	r0, [sp, #0xc]
700a5424: 9102         	str	r1, [sp, #0x8]
700a5426: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a5428: 9001         	str	r0, [sp, #0x4]
;     if(UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode)
700a542a: 9802         	ldr	r0, [sp, #0x8]
700a542c: 6840         	ldr	r0, [r0, #0x4]
700a542e: 2801         	cmp	r0, #0x1
700a5430: d109         	bne	0x700a5446 <Udma_eventCheckParams+0x26> @ imm = #0x12
700a5432: e7ff         	b	0x700a5434 <Udma_eventCheckParams+0x14> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a5434: 9802         	ldr	r0, [sp, #0x8]
700a5436: 6900         	ldr	r0, [r0, #0x10]
700a5438: b120         	cbz	r0, 0x700a5444 <Udma_eventCheckParams+0x24> @ imm = #0x8
700a543a: e7ff         	b	0x700a543c <Udma_eventCheckParams+0x1c> @ imm = #-0x2
700a543c: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a5440: 9001         	str	r0, [sp, #0x4]
;         }
700a5442: e7ff         	b	0x700a5444 <Udma_eventCheckParams+0x24> @ imm = #-0x2
;     }
700a5444: e7ff         	b	0x700a5446 <Udma_eventCheckParams+0x26> @ imm = #-0x2
;     if(UDMA_EVENT_MODE_SHARED == eventPrms->eventMode)
700a5446: 9802         	ldr	r0, [sp, #0x8]
700a5448: 6840         	ldr	r0, [r0, #0x4]
700a544a: 2802         	cmp	r0, #0x2
700a544c: d126         	bne	0x700a549c <Udma_eventCheckParams+0x7c> @ imm = #0x4c
700a544e: e7ff         	b	0x700a5450 <Udma_eventCheckParams+0x30> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a5450: 9802         	ldr	r0, [sp, #0x8]
700a5452: 6900         	ldr	r0, [r0, #0x10]
700a5454: b308         	cbz	r0, 0x700a549a <Udma_eventCheckParams+0x7a> @ imm = #0x42
700a5456: e7ff         	b	0x700a5458 <Udma_eventCheckParams+0x38> @ imm = #-0x2
;             controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a5458: 9802         	ldr	r0, [sp, #0x8]
700a545a: 6900         	ldr	r0, [r0, #0x10]
700a545c: 9000         	str	r0, [sp]
;             if(((Udma_EventCallback) NULL_PTR != controllerEventHandle->eventPrms.eventCb) &&
700a545e: 9800         	ldr	r0, [sp]
700a5460: 69c0         	ldr	r0, [r0, #0x1c]
700a5462: b140         	cbz	r0, 0x700a5476 <Udma_eventCheckParams+0x56> @ imm = #0x10
700a5464: e7ff         	b	0x700a5466 <Udma_eventCheckParams+0x46> @ imm = #-0x2
;                ((Udma_EventCallback) NULL_PTR == eventPrms->eventCb))
700a5466: 9802         	ldr	r0, [sp, #0x8]
700a5468: 6940         	ldr	r0, [r0, #0x14]
;             if(((Udma_EventCallback) NULL_PTR != controllerEventHandle->eventPrms.eventCb) &&
700a546a: b920         	cbnz	r0, 0x700a5476 <Udma_eventCheckParams+0x56> @ imm = #0x8
700a546c: e7ff         	b	0x700a546e <Udma_eventCheckParams+0x4e> @ imm = #-0x2
700a546e: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a5472: 9001         	str	r0, [sp, #0x4]
;             }
700a5474: e7ff         	b	0x700a5476 <Udma_eventCheckParams+0x56> @ imm = #-0x2
;             if(((Udma_EventCallback) NULL_PTR == controllerEventHandle->eventPrms.eventCb) &&
700a5476: 9800         	ldr	r0, [sp]
700a5478: 69c0         	ldr	r0, [r0, #0x1c]
700a547a: b968         	cbnz	r0, 0x700a5498 <Udma_eventCheckParams+0x78> @ imm = #0x1a
700a547c: e7ff         	b	0x700a547e <Udma_eventCheckParams+0x5e> @ imm = #-0x2
;                ((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
700a547e: 9802         	ldr	r0, [sp, #0x8]
700a5480: 6940         	ldr	r0, [r0, #0x14]
700a5482: b148         	cbz	r0, 0x700a5498 <Udma_eventCheckParams+0x78> @ imm = #0x12
700a5484: e7ff         	b	0x700a5486 <Udma_eventCheckParams+0x66> @ imm = #-0x2
;                (UDMA_EVENT_TYPE_MASTER != controllerEventHandle->eventPrms.eventType))
700a5486: 9800         	ldr	r0, [sp]
700a5488: 6880         	ldr	r0, [r0, #0x8]
;             if(((Udma_EventCallback) NULL_PTR == controllerEventHandle->eventPrms.eventCb) &&
700a548a: 2805         	cmp	r0, #0x5
700a548c: d004         	beq	0x700a5498 <Udma_eventCheckParams+0x78> @ imm = #0x8
700a548e: e7ff         	b	0x700a5490 <Udma_eventCheckParams+0x70> @ imm = #-0x2
700a5490: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a5494: 9001         	str	r0, [sp, #0x4]
;             }
700a5496: e7ff         	b	0x700a5498 <Udma_eventCheckParams+0x78> @ imm = #-0x2
;         }
700a5498: e7ff         	b	0x700a549a <Udma_eventCheckParams+0x7a> @ imm = #-0x2
;     }
700a549a: e7ff         	b	0x700a549c <Udma_eventCheckParams+0x7c> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a549c: 9802         	ldr	r0, [sp, #0x8]
700a549e: 6800         	ldr	r0, [r0]
700a54a0: 2801         	cmp	r0, #0x1
700a54a2: d00f         	beq	0x700a54c4 <Udma_eventCheckParams+0xa4> @ imm = #0x1e
700a54a4: e7ff         	b	0x700a54a6 <Udma_eventCheckParams+0x86> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType) ||
700a54a6: 9802         	ldr	r0, [sp, #0x8]
700a54a8: 6800         	ldr	r0, [r0]
700a54aa: 2806         	cmp	r0, #0x6
700a54ac: d00a         	beq	0x700a54c4 <Udma_eventCheckParams+0xa4> @ imm = #0x14
700a54ae: e7ff         	b	0x700a54b0 <Udma_eventCheckParams+0x90> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType) ||
700a54b0: 9802         	ldr	r0, [sp, #0x8]
700a54b2: 6800         	ldr	r0, [r0]
700a54b4: 2802         	cmp	r0, #0x2
700a54b6: d005         	beq	0x700a54c4 <Udma_eventCheckParams+0xa4> @ imm = #0xa
700a54b8: e7ff         	b	0x700a54ba <Udma_eventCheckParams+0x9a> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TR == eventPrms->eventType))
700a54ba: 9802         	ldr	r0, [sp, #0x8]
700a54bc: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a54be: 2803         	cmp	r0, #0x3
700a54c0: d109         	bne	0x700a54d6 <Udma_eventCheckParams+0xb6> @ imm = #0x12
700a54c2: e7ff         	b	0x700a54c4 <Udma_eventCheckParams+0xa4> @ imm = #-0x2
;         if(NULL_PTR == eventPrms->chHandle)
700a54c4: 9802         	ldr	r0, [sp, #0x8]
700a54c6: 6880         	ldr	r0, [r0, #0x8]
700a54c8: b920         	cbnz	r0, 0x700a54d4 <Udma_eventCheckParams+0xb4> @ imm = #0x8
700a54ca: e7ff         	b	0x700a54cc <Udma_eventCheckParams+0xac> @ imm = #-0x2
700a54cc: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a54d0: 9001         	str	r0, [sp, #0x4]
;         }
700a54d2: e7ff         	b	0x700a54d4 <Udma_eventCheckParams+0xb4> @ imm = #-0x2
;     }
700a54d4: e7ff         	b	0x700a54d6 <Udma_eventCheckParams+0xb6> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
700a54d6: 9802         	ldr	r0, [sp, #0x8]
700a54d8: 6800         	ldr	r0, [r0]
700a54da: 2804         	cmp	r0, #0x4
700a54dc: d109         	bne	0x700a54f2 <Udma_eventCheckParams+0xd2> @ imm = #0x12
700a54de: e7ff         	b	0x700a54e0 <Udma_eventCheckParams+0xc0> @ imm = #-0x2
;         if(NULL_PTR == eventPrms->ringHandle)
700a54e0: 9802         	ldr	r0, [sp, #0x8]
700a54e2: 68c0         	ldr	r0, [r0, #0xc]
700a54e4: b920         	cbnz	r0, 0x700a54f0 <Udma_eventCheckParams+0xd0> @ imm = #0x8
700a54e6: e7ff         	b	0x700a54e8 <Udma_eventCheckParams+0xc8> @ imm = #-0x2
700a54e8: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a54ec: 9001         	str	r0, [sp, #0x4]
;         }
700a54ee: e7ff         	b	0x700a54f0 <Udma_eventCheckParams+0xd0> @ imm = #-0x2
;     }
700a54f0: e7ff         	b	0x700a54f2 <Udma_eventCheckParams+0xd2> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_MASTER == eventPrms->eventType)
700a54f2: 9802         	ldr	r0, [sp, #0x8]
700a54f4: 6800         	ldr	r0, [r0]
700a54f6: 2805         	cmp	r0, #0x5
700a54f8: d112         	bne	0x700a5520 <Udma_eventCheckParams+0x100> @ imm = #0x24
700a54fa: e7ff         	b	0x700a54fc <Udma_eventCheckParams+0xdc> @ imm = #-0x2
;         if(UDMA_EVENT_MODE_SHARED != eventPrms->eventMode)
700a54fc: 9802         	ldr	r0, [sp, #0x8]
700a54fe: 6840         	ldr	r0, [r0, #0x4]
700a5500: 2802         	cmp	r0, #0x2
700a5502: d004         	beq	0x700a550e <Udma_eventCheckParams+0xee> @ imm = #0x8
700a5504: e7ff         	b	0x700a5506 <Udma_eventCheckParams+0xe6> @ imm = #-0x2
700a5506: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a550a: 9001         	str	r0, [sp, #0x4]
;         }
700a550c: e7ff         	b	0x700a550e <Udma_eventCheckParams+0xee> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a550e: 9802         	ldr	r0, [sp, #0x8]
700a5510: 6900         	ldr	r0, [r0, #0x10]
700a5512: b120         	cbz	r0, 0x700a551e <Udma_eventCheckParams+0xfe> @ imm = #0x8
700a5514: e7ff         	b	0x700a5516 <Udma_eventCheckParams+0xf6> @ imm = #-0x2
700a5516: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a551a: 9001         	str	r0, [sp, #0x4]
;         }
700a551c: e7ff         	b	0x700a551e <Udma_eventCheckParams+0xfe> @ imm = #-0x2
;     }
700a551e: e7ff         	b	0x700a5520 <Udma_eventCheckParams+0x100> @ imm = #-0x2
;     return (retVal);
700a5520: 9801         	ldr	r0, [sp, #0x4]
700a5522: b004         	add	sp, #0x10
700a5524: 4770         	bx	lr
		...
700a552e: 0000         	movs	r0, r0

700a5530 <CSL_pktdmaTeardownChan>:
; {
700a5530: b580         	push	{r7, lr}
700a5532: b088         	sub	sp, #0x20
700a5534: 4684         	mov	r12, r0
700a5536: 980a         	ldr	r0, [sp, #0x28]
700a5538: f8cd c01c    	str.w	r12, [sp, #0x1c]
700a553c: 9106         	str	r1, [sp, #0x18]
700a553e: 9205         	str	r2, [sp, #0x14]
700a5540: f88d 3013    	strb.w	r3, [sp, #0x13]
700a5544: f88d 0012    	strb.w	r0, [sp, #0x12]
700a5548: 2000         	movs	r0, #0x0
;     int32_t  retVal = CSL_PASS;
700a554a: 9003         	str	r0, [sp, #0xc]
;     if( (pCfg == NULL) || (CSL_pktdmaIsValidChanIdx( pCfg, chanIdx, chanDir) == (bool)false) )
700a554c: 9807         	ldr	r0, [sp, #0x1c]
700a554e: b138         	cbz	r0, 0x700a5560 <CSL_pktdmaTeardownChan+0x30> @ imm = #0xe
700a5550: e7ff         	b	0x700a5552 <CSL_pktdmaTeardownChan+0x22> @ imm = #-0x2
700a5552: 9807         	ldr	r0, [sp, #0x1c]
700a5554: 9906         	ldr	r1, [sp, #0x18]
700a5556: 9a05         	ldr	r2, [sp, #0x14]
700a5558: f007 fc3a    	bl	0x700acdd0 <CSL_pktdmaIsValidChanIdx> @ imm = #0x7874
700a555c: b920         	cbnz	r0, 0x700a5568 <CSL_pktdmaTeardownChan+0x38> @ imm = #0x8
700a555e: e7ff         	b	0x700a5560 <CSL_pktdmaTeardownChan+0x30> @ imm = #-0x2
700a5560: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a5564: 9003         	str	r0, [sp, #0xc]
;     }
700a5566: e062         	b	0x700a562e <CSL_pktdmaTeardownChan+0xfe> @ imm = #0xc4
;         if( CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true )
700a5568: 9807         	ldr	r0, [sp, #0x1c]
700a556a: 9906         	ldr	r1, [sp, #0x18]
700a556c: 9a05         	ldr	r2, [sp, #0x14]
700a556e: f007 fe5f    	bl	0x700ad230 <CSL_pktdmaIsChanEnabled> @ imm = #0x7cbe
700a5572: 2800         	cmp	r0, #0x0
700a5574: d056         	beq	0x700a5624 <CSL_pktdmaTeardownChan+0xf4> @ imm = #0xac
700a5576: e7ff         	b	0x700a5578 <CSL_pktdmaTeardownChan+0x48> @ imm = #-0x2
;             if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700a5578: 9805         	ldr	r0, [sp, #0x14]
700a557a: b9a8         	cbnz	r0, 0x700a55a8 <CSL_pktdmaTeardownChan+0x78> @ imm = #0x2a
700a557c: e7ff         	b	0x700a557e <CSL_pktdmaTeardownChan+0x4e> @ imm = #-0x2
;                 regVal = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a557e: 9807         	ldr	r0, [sp, #0x1c]
700a5580: 6900         	ldr	r0, [r0, #0x10]
700a5582: 9906         	ldr	r1, [sp, #0x18]
700a5584: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a5588: f00a fb52    	bl	0x700afc30 <CSL_REG32_RD_RAW> @ imm = #0xa6a4
700a558c: 9002         	str	r0, [sp, #0x8]
;                 CSL_FINS( regVal, PKTDMA_TXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a558e: 9802         	ldr	r0, [sp, #0x8]
700a5590: f040 4080    	orr	r0, r0, #0x40000000
700a5594: 9002         	str	r0, [sp, #0x8]
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a5596: 9807         	ldr	r0, [sp, #0x1c]
700a5598: 6900         	ldr	r0, [r0, #0x10]
700a559a: 9906         	ldr	r1, [sp, #0x18]
700a559c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a55a0: 9902         	ldr	r1, [sp, #0x8]
700a55a2: f00a fa9d    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0xa53a
;             }
700a55a6: e014         	b	0x700a55d2 <CSL_pktdmaTeardownChan+0xa2> @ imm = #0x28
;                 regVal = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a55a8: 9807         	ldr	r0, [sp, #0x1c]
700a55aa: 6940         	ldr	r0, [r0, #0x14]
700a55ac: 9906         	ldr	r1, [sp, #0x18]
700a55ae: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a55b2: f00a fb3d    	bl	0x700afc30 <CSL_REG32_RD_RAW> @ imm = #0xa67a
700a55b6: 9002         	str	r0, [sp, #0x8]
;                 CSL_FINS( regVal, PKTDMA_RXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a55b8: 9802         	ldr	r0, [sp, #0x8]
700a55ba: f040 4080    	orr	r0, r0, #0x40000000
700a55be: 9002         	str	r0, [sp, #0x8]
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a55c0: 9807         	ldr	r0, [sp, #0x1c]
700a55c2: 6940         	ldr	r0, [r0, #0x14]
700a55c4: 9906         	ldr	r1, [sp, #0x18]
700a55c6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a55ca: 9902         	ldr	r1, [sp, #0x8]
700a55cc: f00a fa88    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0xa510
700a55d0: e7ff         	b	0x700a55d2 <CSL_pktdmaTeardownChan+0xa2> @ imm = #-0x2
;             if( bWait == (bool)true )
700a55d2: f89d 0012    	ldrb.w	r0, [sp, #0x12]
700a55d6: 07c0         	lsls	r0, r0, #0x1f
700a55d8: b318         	cbz	r0, 0x700a5622 <CSL_pktdmaTeardownChan+0xf2> @ imm = #0x46
700a55da: e7ff         	b	0x700a55dc <CSL_pktdmaTeardownChan+0xac> @ imm = #-0x2
700a55dc: 2080         	movs	r0, #0x80
;                 uint32_t retryCnt = CSL_PKTDMA_TEARDOWN_COMPLETE_WAIT_MAX_CNT;
700a55de: 9001         	str	r0, [sp, #0x4]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a55e0: e7ff         	b	0x700a55e2 <CSL_pktdmaTeardownChan+0xb2> @ imm = #-0x2
700a55e2: 9807         	ldr	r0, [sp, #0x1c]
700a55e4: 9906         	ldr	r1, [sp, #0x18]
700a55e6: 9a05         	ldr	r2, [sp, #0x14]
700a55e8: f007 fe22    	bl	0x700ad230 <CSL_pktdmaIsChanEnabled> @ imm = #0x7c44
700a55ec: 4601         	mov	r1, r0
700a55ee: 2000         	movs	r0, #0x0
700a55f0: 9000         	str	r0, [sp]
700a55f2: b131         	cbz	r1, 0x700a5602 <CSL_pktdmaTeardownChan+0xd2> @ imm = #0xc
700a55f4: e7ff         	b	0x700a55f6 <CSL_pktdmaTeardownChan+0xc6> @ imm = #-0x2
700a55f6: 9801         	ldr	r0, [sp, #0x4]
700a55f8: 2800         	cmp	r0, #0x0
700a55fa: bf18         	it	ne
700a55fc: 2001         	movne	r0, #0x1
700a55fe: 9000         	str	r0, [sp]
700a5600: e7ff         	b	0x700a5602 <CSL_pktdmaTeardownChan+0xd2> @ imm = #-0x2
700a5602: 9800         	ldr	r0, [sp]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a5604: 07c0         	lsls	r0, r0, #0x1f
700a5606: b120         	cbz	r0, 0x700a5612 <CSL_pktdmaTeardownChan+0xe2> @ imm = #0x8
700a5608: e7ff         	b	0x700a560a <CSL_pktdmaTeardownChan+0xda> @ imm = #-0x2
;                     retryCnt--;
700a560a: 9801         	ldr	r0, [sp, #0x4]
700a560c: 3801         	subs	r0, #0x1
700a560e: 9001         	str	r0, [sp, #0x4]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a5610: e7e7         	b	0x700a55e2 <CSL_pktdmaTeardownChan+0xb2> @ imm = #-0x32
;                 if( retryCnt == (uint32_t)0U ) {
700a5612: 9801         	ldr	r0, [sp, #0x4]
700a5614: b920         	cbnz	r0, 0x700a5620 <CSL_pktdmaTeardownChan+0xf0> @ imm = #0x8
700a5616: e7ff         	b	0x700a5618 <CSL_pktdmaTeardownChan+0xe8> @ imm = #-0x2
700a5618: f04f 30ff    	mov.w	r0, #0xffffffff
;                     retVal = CSL_EFAIL;
700a561c: 9003         	str	r0, [sp, #0xc]
;                 }
700a561e: e7ff         	b	0x700a5620 <CSL_pktdmaTeardownChan+0xf0> @ imm = #-0x2
;             }
700a5620: e7ff         	b	0x700a5622 <CSL_pktdmaTeardownChan+0xf2> @ imm = #-0x2
;         }
700a5622: e003         	b	0x700a562c <CSL_pktdmaTeardownChan+0xfc> @ imm = #0x6
700a5624: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = CSL_EFAIL;
700a5628: 9003         	str	r0, [sp, #0xc]
700a562a: e7ff         	b	0x700a562c <CSL_pktdmaTeardownChan+0xfc> @ imm = #-0x2
700a562c: e7ff         	b	0x700a562e <CSL_pktdmaTeardownChan+0xfe> @ imm = #-0x2
;     return retVal;
700a562e: 9803         	ldr	r0, [sp, #0xc]
700a5630: b008         	add	sp, #0x20
700a5632: bd80         	pop	{r7, pc}
		...

700a5640 <UART_configInstance>:
; {
700a5640: b580         	push	{r7, lr}
700a5642: b088         	sub	sp, #0x20
700a5644: 9007         	str	r0, [sp, #0x1c]
;     baseAddr = hUart->baseAddr;
700a5646: 9807         	ldr	r0, [sp, #0x1c]
700a5648: 6800         	ldr	r0, [r0]
700a564a: 9006         	str	r0, [sp, #0x18]
;     hUartInit = hUart->hUartInit;
700a564c: 9807         	ldr	r0, [sp, #0x1c]
700a564e: 6840         	ldr	r0, [r0, #0x4]
700a5650: 9001         	str	r0, [sp, #0x4]
;     UART_resetModule(hUart);
700a5652: 9807         	ldr	r0, [sp, #0x1c]
700a5654: f007 fff4    	bl	0x700ad640 <UART_resetModule> @ imm = #0x7fe8
;     if(UART_CONFIG_MODE_DMA == hUartInit->transferMode)
700a5658: 9801         	ldr	r0, [sp, #0x4]
700a565a: 6a00         	ldr	r0, [r0, #0x20]
700a565c: 2803         	cmp	r0, #0x3
700a565e: d10e         	bne	0x700a567e <UART_configInstance+0x3e> @ imm = #0x1c
700a5660: e7ff         	b	0x700a5662 <UART_configInstance+0x22> @ imm = #-0x2
;         regVal = UART_FIFO_CONFIG(UART_TRIG_LVL_GRANULARITY_1,
700a5662: 9801         	ldr	r0, [sp, #0x4]
700a5664: f890 1038    	ldrb.w	r1, [r0, #0x38]
700a5668: f890 003c    	ldrb.w	r0, [r0, #0x3c]
700a566c: 0380         	lsls	r0, r0, #0xe
700a566e: ea40 1081    	orr.w	r0, r0, r1, lsl #6
700a5672: 2131         	movs	r1, #0x31
700a5674: f2c0 4140    	movt	r1, #0x440
700a5678: 4308         	orrs	r0, r1
700a567a: 9005         	str	r0, [sp, #0x14]
;     }
700a567c: e00d         	b	0x700a569a <UART_configInstance+0x5a> @ imm = #0x1a
;         regVal = UART_FIFO_CONFIG(UART_TRIG_LVL_GRANULARITY_1,
700a567e: 9801         	ldr	r0, [sp, #0x4]
700a5680: f890 1038    	ldrb.w	r1, [r0, #0x38]
700a5684: f890 003c    	ldrb.w	r0, [r0, #0x3c]
700a5688: 0380         	lsls	r0, r0, #0xe
700a568a: ea40 1081    	orr.w	r0, r0, r1, lsl #6
700a568e: 2130         	movs	r1, #0x30
700a5690: f2c0 4140    	movt	r1, #0x440
700a5694: 4308         	orrs	r0, r1
700a5696: 9005         	str	r0, [sp, #0x14]
700a5698: e7ff         	b	0x700a569a <UART_configInstance+0x5a> @ imm = #-0x2
;     (void)UART_fifoConfig(baseAddr, regVal);
700a569a: 9806         	ldr	r0, [sp, #0x18]
700a569c: 9905         	ldr	r1, [sp, #0x14]
700a569e: f7f9 f88f    	bl	0x7009e7c0 <UART_fifoConfig> @ imm = #-0x6ee2
;     UART_timeGuardConfig(baseAddr, hUartInit->timeGuardVal);
700a56a2: 9806         	ldr	r0, [sp, #0x18]
700a56a4: 9901         	ldr	r1, [sp, #0x4]
700a56a6: 6d09         	ldr	r1, [r1, #0x50]
700a56a8: f009 ffe2    	bl	0x700af670 <UART_timeGuardConfig> @ imm = #0x9fc4
;     divisorVal = UART_divisorValCompute(hUartInit->inputClkFreq,
700a56ac: 9a01         	ldr	r2, [sp, #0x4]
700a56ae: 6810         	ldr	r0, [r2]
;                                     hUartInit->baudRate,
700a56b0: 6851         	ldr	r1, [r2, #0x4]
;                                     hUartInit->operMode,
700a56b2: 6ad2         	ldr	r2, [r2, #0x2c]
700a56b4: 232a         	movs	r3, #0x2a
;     divisorVal = UART_divisorValCompute(hUartInit->inputClkFreq,
700a56b6: f006 f9f3    	bl	0x700abaa0 <UART_divisorValCompute> @ imm = #0x63e6
700a56ba: 9004         	str	r0, [sp, #0x10]
;     (void)UART_divisorLatchWrite(baseAddr, divisorVal);
700a56bc: 9806         	ldr	r0, [sp, #0x18]
700a56be: 9904         	ldr	r1, [sp, #0x10]
700a56c0: f7ff fa56    	bl	0x700a4b70 <UART_divisorLatchWrite> @ imm = #-0xb54
;     (void)UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a56c4: 9806         	ldr	r0, [sp, #0x18]
700a56c6: 21bf         	movs	r1, #0xbf
700a56c8: f007 f862    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #0x70c4
;     wLenStbFlag = (hUartInit->dataLength << UART_LCR_CHAR_LENGTH_SHIFT);
700a56cc: 9801         	ldr	r0, [sp, #0x4]
700a56ce: 6880         	ldr	r0, [r0, #0x8]
700a56d0: 9003         	str	r0, [sp, #0xc]
;     wLenStbFlag |= (hUartInit->stopBits << UART_LCR_NB_STOP_SHIFT);
700a56d2: 9801         	ldr	r0, [sp, #0x4]
700a56d4: 68c1         	ldr	r1, [r0, #0xc]
700a56d6: 9803         	ldr	r0, [sp, #0xc]
700a56d8: ea40 0081    	orr.w	r0, r0, r1, lsl #2
700a56dc: 9003         	str	r0, [sp, #0xc]
;     parityFlag = (hUartInit->parityType << UART_LCR_PARITY_EN_SHIFT);
700a56de: 9801         	ldr	r0, [sp, #0x4]
700a56e0: 6900         	ldr	r0, [r0, #0x10]
700a56e2: 00c0         	lsls	r0, r0, #0x3
700a56e4: 9002         	str	r0, [sp, #0x8]
;     UART_lineCharConfig(baseAddr, wLenStbFlag, parityFlag);
700a56e6: 9806         	ldr	r0, [sp, #0x18]
700a56e8: 9903         	ldr	r1, [sp, #0xc]
700a56ea: 9a02         	ldr	r2, [sp, #0x8]
700a56ec: f007 ff30    	bl	0x700ad550 <UART_lineCharConfig> @ imm = #0x7e60
;     UART_divisorLatchDisable(baseAddr);
700a56f0: 9806         	ldr	r0, [sp, #0x18]
700a56f2: f00a f81d    	bl	0x700af730 <UART_divisorLatchDisable> @ imm = #0xa03a
;     UART_breakCtl(baseAddr, UART_BREAK_COND_DISABLE);
700a56f6: 9806         	ldr	r0, [sp, #0x18]
700a56f8: 2100         	movs	r1, #0x0
700a56fa: f009 feb9    	bl	0x700af470 <UART_breakCtl> @ imm = #0x9d72
;     (void)UART_operatingModeSelect(baseAddr, hUartInit->operMode);
700a56fe: 9806         	ldr	r0, [sp, #0x18]
700a5700: 9901         	ldr	r1, [sp, #0x4]
700a5702: 6ac9         	ldr	r1, [r1, #0x2c]
700a5704: f009 fb94    	bl	0x700aee30 <UART_operatingModeSelect> @ imm = #0x9728
;     if (hUartInit->hwFlowControl == (uint32_t)TRUE)
700a5708: 9801         	ldr	r0, [sp, #0x4]
700a570a: 6980         	ldr	r0, [r0, #0x18]
700a570c: 2801         	cmp	r0, #0x1
700a570e: d112         	bne	0x700a5736 <UART_configInstance+0xf6> @ imm = #0x24
700a5710: e7ff         	b	0x700a5712 <UART_configInstance+0xd2> @ imm = #-0x2
;         UART_hardwareFlowCtrlOptSet(baseAddr, UART_RTS_CTS_ENABLE);
700a5712: 9806         	ldr	r0, [sp, #0x18]
700a5714: 2103         	movs	r1, #0x3
700a5716: f009 f813    	bl	0x700ae740 <UART_hardwareFlowCtrlOptSet> @ imm = #0x9026
;         if (hUartInit->hwFlowControlThr >= hUartInit->rxTrigLvl)
700a571a: 9901         	ldr	r1, [sp, #0x4]
700a571c: 69c8         	ldr	r0, [r1, #0x1c]
700a571e: 6b89         	ldr	r1, [r1, #0x38]
700a5720: 4288         	cmp	r0, r1
700a5722: d307         	blo	0x700a5734 <UART_configInstance+0xf4> @ imm = #0xe
700a5724: e7ff         	b	0x700a5726 <UART_configInstance+0xe6> @ imm = #-0x2
;             UART_flowCtrlTrigLvlConfig(baseAddr,
700a5726: 9806         	ldr	r0, [sp, #0x18]
;                                     hUartInit->hwFlowControlThr,
700a5728: 9a01         	ldr	r2, [sp, #0x4]
700a572a: 69d1         	ldr	r1, [r2, #0x1c]
;                                     hUartInit->rxTrigLvl);
700a572c: 6b92         	ldr	r2, [r2, #0x38]
;             UART_flowCtrlTrigLvlConfig(baseAddr,
700a572e: f009 f897    	bl	0x700ae860 <UART_flowCtrlTrigLvlConfig> @ imm = #0x912e
;         }
700a5732: e7ff         	b	0x700a5734 <UART_configInstance+0xf4> @ imm = #-0x2
;     }
700a5734: e004         	b	0x700a5740 <UART_configInstance+0x100> @ imm = #0x8
;         UART_hardwareFlowCtrlOptSet(baseAddr, UART_NO_HARDWARE_FLOW_CONTROL);
700a5736: 9806         	ldr	r0, [sp, #0x18]
700a5738: 2100         	movs	r1, #0x0
700a573a: f009 f801    	bl	0x700ae740 <UART_hardwareFlowCtrlOptSet> @ imm = #0x9002
700a573e: e7ff         	b	0x700a5740 <UART_configInstance+0x100> @ imm = #-0x2
;     return;
700a5740: b008         	add	sp, #0x20
700a5742: bd80         	pop	{r7, pc}
		...

700a5750 <Sciclient_rmIrGetOutp>:
; {
700a5750: b580         	push	{r7, lr}
700a5752: b088         	sub	sp, #0x20
700a5754: f8ad 001e    	strh.w	r0, [sp, #0x1e]
700a5758: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a575c: 9206         	str	r2, [sp, #0x18]
700a575e: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a5760: 9005         	str	r0, [sp, #0x14]
;     const struct Sciclient_rmIrInst *inst = NULL;
700a5762: 9004         	str	r0, [sp, #0x10]
;     if (outp == NULL) {
700a5764: 9806         	ldr	r0, [sp, #0x18]
700a5766: b920         	cbnz	r0, 0x700a5772 <Sciclient_rmIrGetOutp+0x22> @ imm = #0x8
700a5768: e7ff         	b	0x700a576a <Sciclient_rmIrGetOutp+0x1a> @ imm = #-0x2
700a576a: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a576e: 9005         	str	r0, [sp, #0x14]
;     } else {
700a5770: e018         	b	0x700a57a4 <Sciclient_rmIrGetOutp+0x54> @ imm = #0x30
;         inst = Sciclient_rmIrGetInst(id);
700a5772: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
700a5776: f006 fa03    	bl	0x700abb80 <Sciclient_rmIrGetInst> @ imm = #0x6406
700a577a: 9004         	str	r0, [sp, #0x10]
;         if (inst == NULL) {
700a577c: 9804         	ldr	r0, [sp, #0x10]
700a577e: b920         	cbnz	r0, 0x700a578a <Sciclient_rmIrGetOutp+0x3a> @ imm = #0x8
700a5780: e7ff         	b	0x700a5782 <Sciclient_rmIrGetOutp+0x32> @ imm = #-0x2
700a5782: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a5786: 9005         	str	r0, [sp, #0x14]
;         } else {
700a5788: e00b         	b	0x700a57a2 <Sciclient_rmIrGetOutp+0x52> @ imm = #0x16
;             if (inp >= inst->n_inp) {
700a578a: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a578e: 9904         	ldr	r1, [sp, #0x10]
700a5790: 8909         	ldrh	r1, [r1, #0x8]
700a5792: 4288         	cmp	r0, r1
700a5794: db04         	blt	0x700a57a0 <Sciclient_rmIrGetOutp+0x50> @ imm = #0x8
700a5796: e7ff         	b	0x700a5798 <Sciclient_rmIrGetOutp+0x48> @ imm = #-0x2
700a5798: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a579c: 9005         	str	r0, [sp, #0x14]
;             }
700a579e: e7ff         	b	0x700a57a0 <Sciclient_rmIrGetOutp+0x50> @ imm = #-0x2
700a57a0: e7ff         	b	0x700a57a2 <Sciclient_rmIrGetOutp+0x52> @ imm = #-0x2
700a57a2: e7ff         	b	0x700a57a4 <Sciclient_rmIrGetOutp+0x54> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (inp == 0u)) {
700a57a4: 9805         	ldr	r0, [sp, #0x14]
700a57a6: b9a8         	cbnz	r0, 0x700a57d4 <Sciclient_rmIrGetOutp+0x84> @ imm = #0x2a
700a57a8: e7ff         	b	0x700a57aa <Sciclient_rmIrGetOutp+0x5a> @ imm = #-0x2
700a57aa: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a57ae: b988         	cbnz	r0, 0x700a57d4 <Sciclient_rmIrGetOutp+0x84> @ imm = #0x22
700a57b0: e7ff         	b	0x700a57b2 <Sciclient_rmIrGetOutp+0x62> @ imm = #-0x2
;         if (inst->inp0_mapping != SCICLIENT_RM_IR_MAPPING_FREE) {
700a57b2: 9804         	ldr	r0, [sp, #0x10]
700a57b4: 8980         	ldrh	r0, [r0, #0xc]
700a57b6: f64f 71ff    	movw	r1, #0xffff
700a57ba: 4288         	cmp	r0, r1
700a57bc: d005         	beq	0x700a57ca <Sciclient_rmIrGetOutp+0x7a> @ imm = #0xa
700a57be: e7ff         	b	0x700a57c0 <Sciclient_rmIrGetOutp+0x70> @ imm = #-0x2
;             *outp = inst->inp0_mapping;
700a57c0: 9804         	ldr	r0, [sp, #0x10]
700a57c2: 8980         	ldrh	r0, [r0, #0xc]
700a57c4: 9906         	ldr	r1, [sp, #0x18]
700a57c6: 8008         	strh	r0, [r1]
;         } else {
700a57c8: e003         	b	0x700a57d2 <Sciclient_rmIrGetOutp+0x82> @ imm = #0x6
700a57ca: f04f 30ff    	mov.w	r0, #0xffffffff
;             r = SystemP_FAILURE;
700a57ce: 9005         	str	r0, [sp, #0x14]
700a57d0: e7ff         	b	0x700a57d2 <Sciclient_rmIrGetOutp+0x82> @ imm = #-0x2
;     }
700a57d2: e7ff         	b	0x700a57d4 <Sciclient_rmIrGetOutp+0x84> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (inp != 0u)) {
700a57d4: 9805         	ldr	r0, [sp, #0x14]
700a57d6: bbb8         	cbnz	r0, 0x700a5848 <Sciclient_rmIrGetOutp+0xf8> @ imm = #0x6e
700a57d8: e7ff         	b	0x700a57da <Sciclient_rmIrGetOutp+0x8a> @ imm = #-0x2
700a57da: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a57de: b398         	cbz	r0, 0x700a5848 <Sciclient_rmIrGetOutp+0xf8> @ imm = #0x66
700a57e0: e7ff         	b	0x700a57e2 <Sciclient_rmIrGetOutp+0x92> @ imm = #-0x2
700a57e2: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a57e6: 9005         	str	r0, [sp, #0x14]
700a57e8: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_outp; i++) {
700a57ea: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a57ee: e7ff         	b	0x700a57f0 <Sciclient_rmIrGetOutp+0xa0> @ imm = #-0x2
700a57f0: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a57f4: 9904         	ldr	r1, [sp, #0x10]
700a57f6: 8949         	ldrh	r1, [r1, #0xa]
700a57f8: 4288         	cmp	r0, r1
700a57fa: da24         	bge	0x700a5846 <Sciclient_rmIrGetOutp+0xf6> @ imm = #0x48
700a57fc: e7ff         	b	0x700a57fe <Sciclient_rmIrGetOutp+0xae> @ imm = #-0x2
;             int_ctrl_reg = (volatile uint32_t *) Sciclient_getIrAddr (inst->cfg, i);
700a57fe: 9804         	ldr	r0, [sp, #0x10]
700a5800: 6840         	ldr	r0, [r0, #0x4]
700a5802: f8bd 100e    	ldrh.w	r1, [sp, #0xe]
700a5806: f009 f9db    	bl	0x700aebc0 <Sciclient_getIrAddr> @ imm = #0x93b6
700a580a: 9002         	str	r0, [sp, #0x8]
;             extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a580c: 9802         	ldr	r0, [sp, #0x8]
700a580e: f240 31ff    	movw	r1, #0x3ff
700a5812: 2200         	movs	r2, #0x0
700a5814: f009 fca4    	bl	0x700af160 <CSL_REG32_FEXT_RAW> @ imm = #0x9948
700a5818: f8ad 0006    	strh.w	r0, [sp, #0x6]
;             if (inp == extracted_inp) {
700a581c: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a5820: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700a5824: 4288         	cmp	r0, r1
700a5826: d107         	bne	0x700a5838 <Sciclient_rmIrGetOutp+0xe8> @ imm = #0xe
700a5828: e7ff         	b	0x700a582a <Sciclient_rmIrGetOutp+0xda> @ imm = #-0x2
;                 *outp = i;
700a582a: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a582e: 9906         	ldr	r1, [sp, #0x18]
700a5830: 8008         	strh	r0, [r1]
700a5832: 2000         	movs	r0, #0x0
;                 r = SystemP_SUCCESS;
700a5834: 9005         	str	r0, [sp, #0x14]
;                 break;
700a5836: e006         	b	0x700a5846 <Sciclient_rmIrGetOutp+0xf6> @ imm = #0xc
;         }
700a5838: e7ff         	b	0x700a583a <Sciclient_rmIrGetOutp+0xea> @ imm = #-0x2
;         for (i = 0u; i < inst->n_outp; i++) {
700a583a: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a583e: 3001         	adds	r0, #0x1
700a5840: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a5844: e7d4         	b	0x700a57f0 <Sciclient_rmIrGetOutp+0xa0> @ imm = #-0x58
;     }
700a5846: e7ff         	b	0x700a5848 <Sciclient_rmIrGetOutp+0xf8> @ imm = #-0x2
;     return r;
700a5848: 9805         	ldr	r0, [sp, #0x14]
700a584a: b008         	add	sp, #0x20
700a584c: bd80         	pop	{r7, pc}
700a584e: 0000         	movs	r0, r0

700a5850 <eTaskGetState>:
; eTaskState eTaskGetState(TaskHandle_t xTask) {
700a5850: b580         	push	{r7, lr}
700a5852: b088         	sub	sp, #0x20
700a5854: 9007         	str	r0, [sp, #0x1c]
;   const TCB_t *const pxTCB = xTask;
700a5856: 9807         	ldr	r0, [sp, #0x1c]
700a5858: 9002         	str	r0, [sp, #0x8]
;   if (pxTCB == pxCurrentTCB) {
700a585a: 9802         	ldr	r0, [sp, #0x8]
700a585c: f642 210c    	movw	r1, #0x2a0c
700a5860: f2c7 010b    	movt	r1, #0x700b
700a5864: 6809         	ldr	r1, [r1]
700a5866: 4288         	cmp	r0, r1
700a5868: d104         	bne	0x700a5874 <eTaskGetState+0x24> @ imm = #0x8
700a586a: e7ff         	b	0x700a586c <eTaskGetState+0x1c> @ imm = #-0x2
700a586c: 2000         	movs	r0, #0x0
;     eReturn = eRunning;
700a586e: f88d 001b    	strb.w	r0, [sp, #0x1b]
;   } else {
700a5872: e063         	b	0x700a593c <eTaskGetState+0xec> @ imm = #0xc6
;     taskENTER_CRITICAL();
700a5874: f008 ff84    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0x8f08
;       pxStateList = listLIST_ITEM_CONTAINER(&(pxTCB->xStateListItem));
700a5878: 9802         	ldr	r0, [sp, #0x8]
700a587a: 6940         	ldr	r0, [r0, #0x14]
700a587c: 9005         	str	r0, [sp, #0x14]
;       pxDelayedList = pxDelayedTaskList;
700a587e: f245 20a0    	movw	r0, #0x52a0
700a5882: f2c7 0008    	movt	r0, #0x7008
700a5886: 6800         	ldr	r0, [r0]
700a5888: 9004         	str	r0, [sp, #0x10]
;       pxOverflowedDelayedList = pxOverflowDelayedTaskList;
700a588a: f245 20a4    	movw	r0, #0x52a4
700a588e: f2c7 0008    	movt	r0, #0x7008
700a5892: 6800         	ldr	r0, [r0]
700a5894: 9003         	str	r0, [sp, #0xc]
;     taskEXIT_CRITICAL();
700a5896: f008 f833    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0x8066
;     if ((pxStateList == pxDelayedList) ||
700a589a: 9805         	ldr	r0, [sp, #0x14]
700a589c: 9904         	ldr	r1, [sp, #0x10]
700a589e: 4288         	cmp	r0, r1
700a58a0: d005         	beq	0x700a58ae <eTaskGetState+0x5e> @ imm = #0xa
700a58a2: e7ff         	b	0x700a58a4 <eTaskGetState+0x54> @ imm = #-0x2
;         (pxStateList == pxOverflowedDelayedList)) {
700a58a4: 9805         	ldr	r0, [sp, #0x14]
700a58a6: 9903         	ldr	r1, [sp, #0xc]
;     if ((pxStateList == pxDelayedList) ||
700a58a8: 4288         	cmp	r0, r1
700a58aa: d104         	bne	0x700a58b6 <eTaskGetState+0x66> @ imm = #0x8
700a58ac: e7ff         	b	0x700a58ae <eTaskGetState+0x5e> @ imm = #-0x2
700a58ae: 2002         	movs	r0, #0x2
;       eReturn = eBlocked;
700a58b0: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     }
700a58b4: e041         	b	0x700a593a <eTaskGetState+0xea> @ imm = #0x82
;     else if (pxStateList == &xSuspendedTaskList) {
700a58b6: 9805         	ldr	r0, [sp, #0x14]
700a58b8: f245 2174    	movw	r1, #0x5274
700a58bc: f2c7 0108    	movt	r1, #0x7008
700a58c0: 4288         	cmp	r0, r1
700a58c2: d125         	bne	0x700a5910 <eTaskGetState+0xc0> @ imm = #0x4a
700a58c4: e7ff         	b	0x700a58c6 <eTaskGetState+0x76> @ imm = #-0x2
;       if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL) {
700a58c6: 9802         	ldr	r0, [sp, #0x8]
700a58c8: 6a80         	ldr	r0, [r0, #0x28]
700a58ca: b9e0         	cbnz	r0, 0x700a5906 <eTaskGetState+0xb6> @ imm = #0x38
700a58cc: e7ff         	b	0x700a58ce <eTaskGetState+0x7e> @ imm = #-0x2
700a58ce: 2003         	movs	r0, #0x3
;           eReturn = eSuspended;
700a58d0: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a58d4: 2000         	movs	r0, #0x0
;           for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a58d6: 9001         	str	r0, [sp, #0x4]
700a58d8: e7ff         	b	0x700a58da <eTaskGetState+0x8a> @ imm = #-0x2
700a58da: 9801         	ldr	r0, [sp, #0x4]
700a58dc: 2800         	cmp	r0, #0x0
700a58de: dc11         	bgt	0x700a5904 <eTaskGetState+0xb4> @ imm = #0x22
700a58e0: e7ff         	b	0x700a58e2 <eTaskGetState+0x92> @ imm = #-0x2
;             if (pxTCB->ucNotifyState[x] == taskWAITING_NOTIFICATION) {
700a58e2: 9802         	ldr	r0, [sp, #0x8]
700a58e4: 9901         	ldr	r1, [sp, #0x4]
700a58e6: 4408         	add	r0, r1
700a58e8: f890 0080    	ldrb.w	r0, [r0, #0x80]
700a58ec: 2801         	cmp	r0, #0x1
700a58ee: d104         	bne	0x700a58fa <eTaskGetState+0xaa> @ imm = #0x8
700a58f0: e7ff         	b	0x700a58f2 <eTaskGetState+0xa2> @ imm = #-0x2
700a58f2: 2002         	movs	r0, #0x2
;               eReturn = eBlocked;
700a58f4: f88d 001b    	strb.w	r0, [sp, #0x1b]
;               break;
700a58f8: e004         	b	0x700a5904 <eTaskGetState+0xb4> @ imm = #0x8
;           }
700a58fa: e7ff         	b	0x700a58fc <eTaskGetState+0xac> @ imm = #-0x2
;           for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a58fc: 9801         	ldr	r0, [sp, #0x4]
700a58fe: 3001         	adds	r0, #0x1
700a5900: 9001         	str	r0, [sp, #0x4]
700a5902: e7ea         	b	0x700a58da <eTaskGetState+0x8a> @ imm = #-0x2c
;       } else {
700a5904: e003         	b	0x700a590e <eTaskGetState+0xbe> @ imm = #0x6
700a5906: 2002         	movs	r0, #0x2
;         eReturn = eBlocked;
700a5908: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a590c: e7ff         	b	0x700a590e <eTaskGetState+0xbe> @ imm = #-0x2
;     }
700a590e: e013         	b	0x700a5938 <eTaskGetState+0xe8> @ imm = #0x26
;     else if ((pxStateList == &xTasksWaitingTermination) ||
700a5910: 9805         	ldr	r0, [sp, #0x14]
700a5912: f245 2188    	movw	r1, #0x5288
700a5916: f2c7 0108    	movt	r1, #0x7008
700a591a: 4288         	cmp	r0, r1
700a591c: d003         	beq	0x700a5926 <eTaskGetState+0xd6> @ imm = #0x6
700a591e: e7ff         	b	0x700a5920 <eTaskGetState+0xd0> @ imm = #-0x2
;              (pxStateList == NULL)) {
700a5920: 9805         	ldr	r0, [sp, #0x14]
;     else if ((pxStateList == &xTasksWaitingTermination) ||
700a5922: b920         	cbnz	r0, 0x700a592e <eTaskGetState+0xde> @ imm = #0x8
700a5924: e7ff         	b	0x700a5926 <eTaskGetState+0xd6> @ imm = #-0x2
700a5926: 2004         	movs	r0, #0x4
;       eReturn = eDeleted;
700a5928: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     }
700a592c: e003         	b	0x700a5936 <eTaskGetState+0xe6> @ imm = #0x6
700a592e: 2001         	movs	r0, #0x1
;       eReturn = eReady;
700a5930: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a5934: e7ff         	b	0x700a5936 <eTaskGetState+0xe6> @ imm = #-0x2
700a5936: e7ff         	b	0x700a5938 <eTaskGetState+0xe8> @ imm = #-0x2
700a5938: e7ff         	b	0x700a593a <eTaskGetState+0xea> @ imm = #-0x2
700a593a: e7ff         	b	0x700a593c <eTaskGetState+0xec> @ imm = #-0x2
;   return eReturn;
700a593c: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a5940: b008         	add	sp, #0x20
700a5942: bd80         	pop	{r7, pc}
		...

700a5950 <PMU_profileEnd>:
; int32_t PMU_profileEnd(const char *name) {
700a5950: b580         	push	{r7, lr}
700a5952: b090         	sub	sp, #0x40
700a5954: 900e         	str	r0, [sp, #0x38]
;   if (gProfileObject.logIndex >= PMU_MAX_LOG_ENTRIES) {
700a5956: f243 0080    	movw	r0, #0x3080
700a595a: f2c7 0008    	movt	r0, #0x7008
700a595e: 6800         	ldr	r0, [r0]
700a5960: 2840         	cmp	r0, #0x40
700a5962: d304         	blo	0x700a596e <PMU_profileEnd+0x1e> @ imm = #0x8
700a5964: e7ff         	b	0x700a5966 <PMU_profileEnd+0x16> @ imm = #-0x2
700a5966: f04f 30ff    	mov.w	r0, #0xffffffff
;     return SystemP_FAILURE; /* Log is full */
700a596a: 900f         	str	r0, [sp, #0x3c]
700a596c: e065         	b	0x700a5a3a <PMU_profileEnd+0xea> @ imm = #0xca
700a596e: 2000         	movs	r0, #0x0
;   int32_t status = SystemP_SUCCESS;
700a5970: 9000         	str	r0, [sp]
700a5972: 900d         	str	r0, [sp, #0x34]
700a5974: 201f         	movs	r0, #0x1f
;   uint32_t ccount = CSL_armR5PmuReadCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM);
700a5976: f7fc ec52    	blx	0x700a221c <CSL_armR5PmuReadCntr> @ imm = #-0x375c
700a597a: 4601         	mov	r1, r0
700a597c: 9800         	ldr	r0, [sp]
700a597e: 910c         	str	r1, [sp, #0x30]
;   uint32_t count0 = CSL_armR5PmuReadCntr(0);
700a5980: f7fc ec4c    	blx	0x700a221c <CSL_armR5PmuReadCntr> @ imm = #-0x3768
700a5984: 900b         	str	r0, [sp, #0x2c]
700a5986: 2001         	movs	r0, #0x1
;   uint32_t count1 = CSL_armR5PmuReadCntr(1);
700a5988: f7fc ec48    	blx	0x700a221c <CSL_armR5PmuReadCntr> @ imm = #-0x3770
700a598c: 900a         	str	r0, [sp, #0x28]
700a598e: 2002         	movs	r0, #0x2
;   uint32_t count2 = CSL_armR5PmuReadCntr(2);
700a5990: f7fc ec44    	blx	0x700a221c <CSL_armR5PmuReadCntr> @ imm = #-0x3778
700a5994: 9009         	str	r0, [sp, #0x24]
;   uint32_t counts[3] = {count0, count1, count2};
700a5996: 980b         	ldr	r0, [sp, #0x2c]
700a5998: 9006         	str	r0, [sp, #0x18]
700a599a: 980a         	ldr	r0, [sp, #0x28]
700a599c: 9007         	str	r0, [sp, #0x1c]
700a599e: 9809         	ldr	r0, [sp, #0x24]
700a59a0: 9008         	str	r0, [sp, #0x20]
;   uint32_t i = gProfileObject.logIndex;
700a59a2: f243 0280    	movw	r2, #0x3080
700a59a6: f2c7 0208    	movt	r2, #0x7008
700a59aa: 6810         	ldr	r0, [r2]
700a59ac: 9005         	str	r0, [sp, #0x14]
;   uint32_t numEvents = gProfileObject.numEvents;
700a59ae: 6890         	ldr	r0, [r2, #0x8]
700a59b0: 9003         	str	r0, [sp, #0xc]
;   uint32_t bCCnt = gProfileObject.bCycleCounter;
700a59b2: 6850         	ldr	r0, [r2, #0x4]
700a59b4: 9002         	str	r0, [sp, #0x8]
;   PMU_ProfilePoint *p = &gProfileObject.point[i];
700a59b6: 9805         	ldr	r0, [sp, #0x14]
700a59b8: 2134         	movs	r1, #0x34
700a59ba: fb00 2001    	mla	r0, r0, r1, r2
700a59be: 300c         	adds	r0, #0xc
700a59c0: 9001         	str	r0, [sp, #0x4]
;   if (strcmp(name, p->name) != 0) {
700a59c2: 980e         	ldr	r0, [sp, #0x38]
700a59c4: 9901         	ldr	r1, [sp, #0x4]
700a59c6: 6b09         	ldr	r1, [r1, #0x30]
700a59c8: f7f6 ec6a    	blx	0x7009c2a0 <strcmp>     @ imm = #-0x972c
700a59cc: b120         	cbz	r0, 0x700a59d8 <PMU_profileEnd+0x88> @ imm = #0x8
700a59ce: e7ff         	b	0x700a59d0 <PMU_profileEnd+0x80> @ imm = #-0x2
700a59d0: f04f 30ff    	mov.w	r0, #0xffffffff
;     status = SystemP_FAILURE;
700a59d4: 900d         	str	r0, [sp, #0x34]
;   }
700a59d6: e7ff         	b	0x700a59d8 <PMU_profileEnd+0x88> @ imm = #-0x2
;   if (status == SystemP_SUCCESS) {
700a59d8: 980d         	ldr	r0, [sp, #0x34]
700a59da: bb58         	cbnz	r0, 0x700a5a34 <PMU_profileEnd+0xe4> @ imm = #0x56
700a59dc: e7ff         	b	0x700a59de <PMU_profileEnd+0x8e> @ imm = #-0x2
;     if (bCCnt == TRUE) {
700a59de: 9802         	ldr	r0, [sp, #0x8]
700a59e0: 2801         	cmp	r0, #0x1
700a59e2: d106         	bne	0x700a59f2 <PMU_profileEnd+0xa2> @ imm = #0xc
700a59e4: e7ff         	b	0x700a59e6 <PMU_profileEnd+0x96> @ imm = #-0x2
;       p->cycleCount.value = ccount - p->cycleCount.value;
700a59e6: 980c         	ldr	r0, [sp, #0x30]
700a59e8: 9901         	ldr	r1, [sp, #0x4]
700a59ea: 6aca         	ldr	r2, [r1, #0x2c]
700a59ec: 1a80         	subs	r0, r0, r2
700a59ee: 62c8         	str	r0, [r1, #0x2c]
;     }
700a59f0: e7ff         	b	0x700a59f2 <PMU_profileEnd+0xa2> @ imm = #-0x2
700a59f2: 2000         	movs	r0, #0x0
;     for (j = 0; j < numEvents; j++) {
700a59f4: 9004         	str	r0, [sp, #0x10]
700a59f6: e7ff         	b	0x700a59f8 <PMU_profileEnd+0xa8> @ imm = #-0x2
700a59f8: 9804         	ldr	r0, [sp, #0x10]
700a59fa: 9903         	ldr	r1, [sp, #0xc]
700a59fc: 4288         	cmp	r0, r1
700a59fe: d211         	bhs	0x700a5a24 <PMU_profileEnd+0xd4> @ imm = #0x22
700a5a00: e7ff         	b	0x700a5a02 <PMU_profileEnd+0xb2> @ imm = #-0x2
;       p->events[j].value = counts[j] - p->events[j].value;
700a5a02: 9a04         	ldr	r2, [sp, #0x10]
700a5a04: a806         	add	r0, sp, #0x18
700a5a06: f850 0022    	ldr.w	r0, [r0, r2, lsl #2]
700a5a0a: 9901         	ldr	r1, [sp, #0x4]
700a5a0c: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a5a10: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a5a14: 688a         	ldr	r2, [r1, #0x8]
700a5a16: 1a80         	subs	r0, r0, r2
700a5a18: 6088         	str	r0, [r1, #0x8]
;     }
700a5a1a: e7ff         	b	0x700a5a1c <PMU_profileEnd+0xcc> @ imm = #-0x2
;     for (j = 0; j < numEvents; j++) {
700a5a1c: 9804         	ldr	r0, [sp, #0x10]
700a5a1e: 3001         	adds	r0, #0x1
700a5a20: 9004         	str	r0, [sp, #0x10]
700a5a22: e7e9         	b	0x700a59f8 <PMU_profileEnd+0xa8> @ imm = #-0x2e
;     gProfileObject.logIndex++;
700a5a24: f243 0180    	movw	r1, #0x3080
700a5a28: f2c7 0108    	movt	r1, #0x7008
700a5a2c: 6808         	ldr	r0, [r1]
700a5a2e: 3001         	adds	r0, #0x1
700a5a30: 6008         	str	r0, [r1]
;   }
700a5a32: e7ff         	b	0x700a5a34 <PMU_profileEnd+0xe4> @ imm = #-0x2
;   return status;
700a5a34: 980d         	ldr	r0, [sp, #0x34]
700a5a36: 900f         	str	r0, [sp, #0x3c]
700a5a38: e7ff         	b	0x700a5a3a <PMU_profileEnd+0xea> @ imm = #-0x2
; }
700a5a3a: 980f         	ldr	r0, [sp, #0x3c]
700a5a3c: b010         	add	sp, #0x40
700a5a3e: bd80         	pop	{r7, pc}

700a5a40 <Udma_eventIsrFxn>:
; {
700a5a40: b580         	push	{r7, lr}
700a5a42: b088         	sub	sp, #0x20
700a5a44: 9007         	str	r0, [sp, #0x1c]
;     Udma_EventHandleInt eventHandle = (Udma_EventHandleInt) args;
700a5a46: 9807         	ldr	r0, [sp, #0x1c]
700a5a48: 9003         	str	r0, [sp, #0xc]
700a5a4a: 2001         	movs	r0, #0x1
;     teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_NA;
700a5a4c: 9004         	str	r0, [sp, #0x10]
700a5a4e: 2000         	movs	r0, #0x0
;     ringHandle = NULL;
700a5a50: 9000         	str	r0, [sp]
;     drvHandle = eventHandle->drvHandle;
700a5a52: 9803         	ldr	r0, [sp, #0xc]
700a5a54: 6800         	ldr	r0, [r0]
700a5a56: 9002         	str	r0, [sp, #0x8]
;     vintrNum = eventHandle->vintrNum;
700a5a58: 9803         	ldr	r0, [sp, #0xc]
700a5a5a: 6cc0         	ldr	r0, [r0, #0x4c]
700a5a5c: 9005         	str	r0, [sp, #0x14]
;     while(eventHandle != NULL_PTR)
700a5a5e: e7ff         	b	0x700a5a60 <Udma_eventIsrFxn+0x20> @ imm = #-0x2
700a5a60: 9803         	ldr	r0, [sp, #0xc]
700a5a62: 2800         	cmp	r0, #0x0
700a5a64: d060         	beq	0x700a5b28 <Udma_eventIsrFxn+0xe8> @ imm = #0xc0
700a5a66: e7ff         	b	0x700a5a68 <Udma_eventIsrFxn+0x28> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_MASTER != eventHandle->eventPrms.eventType)
700a5a68: 9803         	ldr	r0, [sp, #0xc]
700a5a6a: 6880         	ldr	r0, [r0, #0x8]
700a5a6c: 2805         	cmp	r0, #0x5
700a5a6e: d057         	beq	0x700a5b20 <Udma_eventIsrFxn+0xe0> @ imm = #0xae
700a5a70: e7ff         	b	0x700a5a72 <Udma_eventIsrFxn+0x32> @ imm = #-0x2
;             vintrBitNum = vintrNum * UDMA_MAX_EVENTS_PER_VINTR;
700a5a72: 9805         	ldr	r0, [sp, #0x14]
700a5a74: 0180         	lsls	r0, r0, #0x6
700a5a76: 9006         	str	r0, [sp, #0x18]
;             vintrBitNum += eventHandle->vintrBitNum;
700a5a78: 9803         	ldr	r0, [sp, #0xc]
700a5a7a: 6d01         	ldr	r1, [r0, #0x50]
700a5a7c: 9806         	ldr	r0, [sp, #0x18]
700a5a7e: 4408         	add	r0, r1
700a5a80: 9006         	str	r0, [sp, #0x18]
;             if((bool)true == CSL_intaggrIsIntrPending(&drvHandle->iaRegs, vintrBitNum, (bool)true))
700a5a82: 9802         	ldr	r0, [sp, #0x8]
700a5a84: 309c         	adds	r0, #0x9c
700a5a86: 9906         	ldr	r1, [sp, #0x18]
700a5a88: 2201         	movs	r2, #0x1
700a5a8a: f002 fe29    	bl	0x700a86e0 <CSL_intaggrIsIntrPending> @ imm = #0x2c52
700a5a8e: 2800         	cmp	r0, #0x0
700a5a90: d045         	beq	0x700a5b1e <Udma_eventIsrFxn+0xde> @ imm = #0x8a
700a5a92: e7ff         	b	0x700a5a94 <Udma_eventIsrFxn+0x54> @ imm = #-0x2
;                 (void) CSL_intaggrClrIntr(&drvHandle->iaRegs, vintrBitNum);
700a5a94: 9802         	ldr	r0, [sp, #0x8]
700a5a96: 309c         	adds	r0, #0x9c
700a5a98: 9906         	ldr	r1, [sp, #0x18]
700a5a9a: f005 fcb9    	bl	0x700ab410 <CSL_intaggrClrIntr> @ imm = #0x5972
;                 eventPrms = &eventHandle->eventPrms;
700a5a9e: 9803         	ldr	r0, [sp, #0xc]
700a5aa0: 3008         	adds	r0, #0x8
700a5aa2: 9001         	str	r0, [sp, #0x4]
;                 if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a5aa4: 9801         	ldr	r0, [sp, #0x4]
700a5aa6: 6800         	ldr	r0, [r0]
700a5aa8: 2801         	cmp	r0, #0x1
700a5aaa: d005         	beq	0x700a5ab8 <Udma_eventIsrFxn+0x78> @ imm = #0xa
700a5aac: e7ff         	b	0x700a5aae <Udma_eventIsrFxn+0x6e> @ imm = #-0x2
;                    (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
700a5aae: 9801         	ldr	r0, [sp, #0x4]
700a5ab0: 6800         	ldr	r0, [r0]
;                 if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a5ab2: 2806         	cmp	r0, #0x6
700a5ab4: d114         	bne	0x700a5ae0 <Udma_eventIsrFxn+0xa0> @ imm = #0x28
700a5ab6: e7ff         	b	0x700a5ab8 <Udma_eventIsrFxn+0x78> @ imm = #-0x2
;                     ringHandle = ((Udma_ChHandleInt) (eventPrms->chHandle))->cqRing;
700a5ab8: 9801         	ldr	r0, [sp, #0x4]
700a5aba: 6880         	ldr	r0, [r0, #0x8]
700a5abc: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a5ac0: 9000         	str	r0, [sp]
;                     if( CSL_lcdma_ringaccIsTeardownComplete(&ringHandle->drvHandle->lcdmaRaRegs, ringHandle->ringNum) == TRUE )
700a5ac2: 9900         	ldr	r1, [sp]
700a5ac4: 6808         	ldr	r0, [r1]
700a5ac6: 308c         	adds	r0, #0x8c
700a5ac8: 8889         	ldrh	r1, [r1, #0x4]
700a5aca: f008 f881    	bl	0x700adbd0 <CSL_lcdma_ringaccIsTeardownComplete> @ imm = #0x8102
700a5ace: b118         	cbz	r0, 0x700a5ad8 <Udma_eventIsrFxn+0x98> @ imm = #0x6
700a5ad0: e7ff         	b	0x700a5ad2 <Udma_eventIsrFxn+0x92> @ imm = #-0x2
700a5ad2: 2002         	movs	r0, #0x2
;                         teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE;
700a5ad4: 9004         	str	r0, [sp, #0x10]
;                     }
700a5ad6: e002         	b	0x700a5ade <Udma_eventIsrFxn+0x9e> @ imm = #0x4
700a5ad8: 2003         	movs	r0, #0x3
;                         teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_INCOMPLETE;
700a5ada: 9004         	str	r0, [sp, #0x10]
700a5adc: e7ff         	b	0x700a5ade <Udma_eventIsrFxn+0x9e> @ imm = #-0x2
;                 }
700a5ade: e7ff         	b	0x700a5ae0 <Udma_eventIsrFxn+0xa0> @ imm = #-0x2
;                 if(!(((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_DMA_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE)) ||
700a5ae0: 9803         	ldr	r0, [sp, #0xc]
700a5ae2: 6880         	ldr	r0, [r0, #0x8]
700a5ae4: 2801         	cmp	r0, #0x1
700a5ae6: d104         	bne	0x700a5af2 <Udma_eventIsrFxn+0xb2> @ imm = #0x8
700a5ae8: e7ff         	b	0x700a5aea <Udma_eventIsrFxn+0xaa> @ imm = #-0x2
700a5aea: 9804         	ldr	r0, [sp, #0x10]
700a5aec: 2802         	cmp	r0, #0x2
700a5aee: d015         	beq	0x700a5b1c <Udma_eventIsrFxn+0xdc> @ imm = #0x2a
700a5af0: e7ff         	b	0x700a5af2 <Udma_eventIsrFxn+0xb2> @ imm = #-0x2
;                  ((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_TEARDOWN_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_INCOMPLETE))))
700a5af2: 9803         	ldr	r0, [sp, #0xc]
700a5af4: 6880         	ldr	r0, [r0, #0x8]
700a5af6: 2806         	cmp	r0, #0x6
700a5af8: d104         	bne	0x700a5b04 <Udma_eventIsrFxn+0xc4> @ imm = #0x8
700a5afa: e7ff         	b	0x700a5afc <Udma_eventIsrFxn+0xbc> @ imm = #-0x2
700a5afc: 9804         	ldr	r0, [sp, #0x10]
;                 if(!(((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_DMA_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE)) ||
700a5afe: 2803         	cmp	r0, #0x3
700a5b00: d00c         	beq	0x700a5b1c <Udma_eventIsrFxn+0xdc> @ imm = #0x18
700a5b02: e7ff         	b	0x700a5b04 <Udma_eventIsrFxn+0xc4> @ imm = #-0x2
;                     if((Udma_EventCallback) NULL_PTR != eventPrms->eventCb)
700a5b04: 9801         	ldr	r0, [sp, #0x4]
700a5b06: 6940         	ldr	r0, [r0, #0x14]
700a5b08: b138         	cbz	r0, 0x700a5b1a <Udma_eventIsrFxn+0xda> @ imm = #0xe
700a5b0a: e7ff         	b	0x700a5b0c <Udma_eventIsrFxn+0xcc> @ imm = #-0x2
;                         eventPrms->eventCb(
700a5b0c: 9a01         	ldr	r2, [sp, #0x4]
;                             eventHandle, eventPrms->eventType, eventPrms->appData);
700a5b0e: 9803         	ldr	r0, [sp, #0xc]
700a5b10: 6811         	ldr	r1, [r2]
;                         eventPrms->eventCb(
700a5b12: 6953         	ldr	r3, [r2, #0x14]
;                             eventHandle, eventPrms->eventType, eventPrms->appData);
700a5b14: 69d2         	ldr	r2, [r2, #0x1c]
;                         eventPrms->eventCb(
700a5b16: 4798         	blx	r3
;                     }
700a5b18: e7ff         	b	0x700a5b1a <Udma_eventIsrFxn+0xda> @ imm = #-0x2
;                 }
700a5b1a: e7ff         	b	0x700a5b1c <Udma_eventIsrFxn+0xdc> @ imm = #-0x2
;             }
700a5b1c: e7ff         	b	0x700a5b1e <Udma_eventIsrFxn+0xde> @ imm = #-0x2
;         }
700a5b1e: e7ff         	b	0x700a5b20 <Udma_eventIsrFxn+0xe0> @ imm = #-0x2
;         eventHandle = eventHandle->nextEvent;
700a5b20: 9803         	ldr	r0, [sp, #0xc]
700a5b22: 6dc0         	ldr	r0, [r0, #0x5c]
700a5b24: 9003         	str	r0, [sp, #0xc]
;     while(eventHandle != NULL_PTR)
700a5b26: e79b         	b	0x700a5a60 <Udma_eventIsrFxn+0x20> @ imm = #-0xca
;     return;
700a5b28: b008         	add	sp, #0x20
700a5b2a: bd80         	pop	{r7, pc}
700a5b2c: 0000         	movs	r0, r0
700a5b2e: 0000         	movs	r0, r0

700a5b30 <vTaskPriorityDisinheritAfterTimeout>:
;     UBaseType_t uxHighestPriorityWaitingTask) {
700a5b30: b580         	push	{r7, lr}
700a5b32: b086         	sub	sp, #0x18
700a5b34: 9005         	str	r0, [sp, #0x14]
700a5b36: 9104         	str	r1, [sp, #0x10]
;   TCB_t *const pxTCB = pxMutexHolder;
700a5b38: 9805         	ldr	r0, [sp, #0x14]
700a5b3a: 9003         	str	r0, [sp, #0xc]
700a5b3c: 2001         	movs	r0, #0x1
;   const UBaseType_t uxOnlyOneMutexHeld = (UBaseType_t)1;
700a5b3e: 9000         	str	r0, [sp]
;   if (pxMutexHolder != NULL) {
700a5b40: 9805         	ldr	r0, [sp, #0x14]
700a5b42: 2800         	cmp	r0, #0x0
700a5b44: d067         	beq	0x700a5c16 <vTaskPriorityDisinheritAfterTimeout+0xe6> @ imm = #0xce
700a5b46: e7ff         	b	0x700a5b48 <vTaskPriorityDisinheritAfterTimeout+0x18> @ imm = #-0x2
;     if (pxTCB->uxBasePriority < uxHighestPriorityWaitingTask) {
700a5b48: 9803         	ldr	r0, [sp, #0xc]
700a5b4a: 6e00         	ldr	r0, [r0, #0x60]
700a5b4c: 9904         	ldr	r1, [sp, #0x10]
700a5b4e: 4288         	cmp	r0, r1
700a5b50: d203         	bhs	0x700a5b5a <vTaskPriorityDisinheritAfterTimeout+0x2a> @ imm = #0x6
700a5b52: e7ff         	b	0x700a5b54 <vTaskPriorityDisinheritAfterTimeout+0x24> @ imm = #-0x2
;       uxPriorityToUse = uxHighestPriorityWaitingTask;
700a5b54: 9804         	ldr	r0, [sp, #0x10]
700a5b56: 9001         	str	r0, [sp, #0x4]
;     } else {
700a5b58: e003         	b	0x700a5b62 <vTaskPriorityDisinheritAfterTimeout+0x32> @ imm = #0x6
;       uxPriorityToUse = pxTCB->uxBasePriority;
700a5b5a: 9803         	ldr	r0, [sp, #0xc]
700a5b5c: 6e00         	ldr	r0, [r0, #0x60]
700a5b5e: 9001         	str	r0, [sp, #0x4]
700a5b60: e7ff         	b	0x700a5b62 <vTaskPriorityDisinheritAfterTimeout+0x32> @ imm = #-0x2
;     if (pxTCB->uxPriority != uxPriorityToUse) {
700a5b62: 9803         	ldr	r0, [sp, #0xc]
700a5b64: 6ac0         	ldr	r0, [r0, #0x2c]
700a5b66: 9901         	ldr	r1, [sp, #0x4]
700a5b68: 4288         	cmp	r0, r1
700a5b6a: d052         	beq	0x700a5c12 <vTaskPriorityDisinheritAfterTimeout+0xe2> @ imm = #0xa4
700a5b6c: e7ff         	b	0x700a5b6e <vTaskPriorityDisinheritAfterTimeout+0x3e> @ imm = #-0x2
;       if (pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld) {
700a5b6e: 9803         	ldr	r0, [sp, #0xc]
700a5b70: 6e40         	ldr	r0, [r0, #0x64]
700a5b72: 2801         	cmp	r0, #0x1
700a5b74: d14b         	bne	0x700a5c0e <vTaskPriorityDisinheritAfterTimeout+0xde> @ imm = #0x96
700a5b76: e7ff         	b	0x700a5b78 <vTaskPriorityDisinheritAfterTimeout+0x48> @ imm = #-0x2
;         uxPriorityUsedOnEntry = pxTCB->uxPriority;
700a5b78: 9803         	ldr	r0, [sp, #0xc]
700a5b7a: 6ac0         	ldr	r0, [r0, #0x2c]
700a5b7c: 9002         	str	r0, [sp, #0x8]
;         pxTCB->uxPriority = uxPriorityToUse;
700a5b7e: 9801         	ldr	r0, [sp, #0x4]
700a5b80: 9903         	ldr	r1, [sp, #0xc]
700a5b82: 62c8         	str	r0, [r1, #0x2c]
;         if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) &
700a5b84: 9803         	ldr	r0, [sp, #0xc]
700a5b86: 7ec0         	ldrb	r0, [r0, #0x1b]
700a5b88: 0600         	lsls	r0, r0, #0x18
700a5b8a: 2800         	cmp	r0, #0x0
700a5b8c: d406         	bmi	0x700a5b9c <vTaskPriorityDisinheritAfterTimeout+0x6c> @ imm = #0xc
700a5b8e: e7ff         	b	0x700a5b90 <vTaskPriorityDisinheritAfterTimeout+0x60> @ imm = #-0x2
;           listSET_LIST_ITEM_VALUE(
700a5b90: 9801         	ldr	r0, [sp, #0x4]
700a5b92: f1c0 0020    	rsb.w	r0, r0, #0x20
700a5b96: 9903         	ldr	r1, [sp, #0xc]
700a5b98: 6188         	str	r0, [r1, #0x18]
;         } else {
700a5b9a: e000         	b	0x700a5b9e <vTaskPriorityDisinheritAfterTimeout+0x6e> @ imm = #0x0
700a5b9c: e7ff         	b	0x700a5b9e <vTaskPriorityDisinheritAfterTimeout+0x6e> @ imm = #-0x2
;         if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]),
700a5b9e: 9803         	ldr	r0, [sp, #0xc]
700a5ba0: 6940         	ldr	r0, [r0, #0x14]
700a5ba2: 9902         	ldr	r1, [sp, #0x8]
700a5ba4: eb01 0281    	add.w	r2, r1, r1, lsl #2
700a5ba8: f244 41f8    	movw	r1, #0x44f8
700a5bac: f2c7 0108    	movt	r1, #0x7008
700a5bb0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a5bb4: 4288         	cmp	r0, r1
700a5bb6: d128         	bne	0x700a5c0a <vTaskPriorityDisinheritAfterTimeout+0xda> @ imm = #0x50
700a5bb8: e7ff         	b	0x700a5bba <vTaskPriorityDisinheritAfterTimeout+0x8a> @ imm = #-0x2
;           if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a5bba: 9803         	ldr	r0, [sp, #0xc]
700a5bbc: 3004         	adds	r0, #0x4
700a5bbe: f007 fdaf    	bl	0x700ad720 <uxListRemove> @ imm = #0x7b5e
700a5bc2: b908         	cbnz	r0, 0x700a5bc8 <vTaskPriorityDisinheritAfterTimeout+0x98> @ imm = #0x2
700a5bc4: e7ff         	b	0x700a5bc6 <vTaskPriorityDisinheritAfterTimeout+0x96> @ imm = #-0x2
;           } else {
700a5bc6: e000         	b	0x700a5bca <vTaskPriorityDisinheritAfterTimeout+0x9a> @ imm = #0x0
700a5bc8: e7ff         	b	0x700a5bca <vTaskPriorityDisinheritAfterTimeout+0x9a> @ imm = #-0x2
;           prvAddTaskToReadyList(pxTCB);
700a5bca: 9803         	ldr	r0, [sp, #0xc]
700a5bcc: 6ac0         	ldr	r0, [r0, #0x2c]
700a5bce: f642 213c    	movw	r1, #0x2a3c
700a5bd2: f2c7 010b    	movt	r1, #0x700b
700a5bd6: 6809         	ldr	r1, [r1]
700a5bd8: 4288         	cmp	r0, r1
700a5bda: d908         	bls	0x700a5bee <vTaskPriorityDisinheritAfterTimeout+0xbe> @ imm = #0x10
700a5bdc: e7ff         	b	0x700a5bde <vTaskPriorityDisinheritAfterTimeout+0xae> @ imm = #-0x2
700a5bde: 9803         	ldr	r0, [sp, #0xc]
700a5be0: 6ac0         	ldr	r0, [r0, #0x2c]
700a5be2: f642 213c    	movw	r1, #0x2a3c
700a5be6: f2c7 010b    	movt	r1, #0x700b
700a5bea: 6008         	str	r0, [r1]
700a5bec: e7ff         	b	0x700a5bee <vTaskPriorityDisinheritAfterTimeout+0xbe> @ imm = #-0x2
700a5bee: 9903         	ldr	r1, [sp, #0xc]
700a5bf0: 6ac8         	ldr	r0, [r1, #0x2c]
700a5bf2: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a5bf6: f244 40f8    	movw	r0, #0x44f8
700a5bfa: f2c7 0008    	movt	r0, #0x7008
700a5bfe: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a5c02: 3104         	adds	r1, #0x4
700a5c04: f008 fb44    	bl	0x700ae290 <vListInsertEnd> @ imm = #0x8688
;         } else {
700a5c08: e000         	b	0x700a5c0c <vTaskPriorityDisinheritAfterTimeout+0xdc> @ imm = #0x0
700a5c0a: e7ff         	b	0x700a5c0c <vTaskPriorityDisinheritAfterTimeout+0xdc> @ imm = #-0x2
;       } else {
700a5c0c: e000         	b	0x700a5c10 <vTaskPriorityDisinheritAfterTimeout+0xe0> @ imm = #0x0
700a5c0e: e7ff         	b	0x700a5c10 <vTaskPriorityDisinheritAfterTimeout+0xe0> @ imm = #-0x2
;     } else {
700a5c10: e000         	b	0x700a5c14 <vTaskPriorityDisinheritAfterTimeout+0xe4> @ imm = #0x0
700a5c12: e7ff         	b	0x700a5c14 <vTaskPriorityDisinheritAfterTimeout+0xe4> @ imm = #-0x2
;   } else {
700a5c14: e000         	b	0x700a5c18 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #0x0
700a5c16: e7ff         	b	0x700a5c18 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #-0x2
; }
700a5c18: b006         	add	sp, #0x18
700a5c1a: bd80         	pop	{r7, pc}
700a5c1c: 0000         	movs	r0, r0
700a5c1e: 0000         	movs	r0, r0

700a5c20 <AddrTranslateP_getLocalAddr>:
; {
700a5c20: b580         	push	{r7, lr}
700a5c22: b08e         	sub	sp, #0x38
700a5c24: 910d         	str	r1, [sp, #0x34]
700a5c26: 900c         	str	r0, [sp, #0x30]
;     DebugP_assertNoLog(gAddrTranslateConfig.numRegions<AddrTranslateP_MAX_REGIONS);
700a5c28: f642 1084    	movw	r0, #0x2984
700a5c2c: f2c7 000b    	movt	r0, #0x700b
700a5c30: 6801         	ldr	r1, [r0]
700a5c32: 2000         	movs	r0, #0x0
700a5c34: 9001         	str	r0, [sp, #0x4]
700a5c36: 2910         	cmp	r1, #0x10
700a5c38: bf38         	it	lo
700a5c3a: 2001         	movlo	r0, #0x1
700a5c3c: f00b fb50    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0xb6a0
700a5c40: 9801         	ldr	r0, [sp, #0x4]
;     found = 0;
700a5c42: 900b         	str	r0, [sp, #0x2c]
;     for(regionId=0; regionId<gAddrTranslateConfig.numRegions; regionId++)
700a5c44: 900a         	str	r0, [sp, #0x28]
700a5c46: e7ff         	b	0x700a5c48 <AddrTranslateP_getLocalAddr+0x28> @ imm = #-0x2
700a5c48: 980a         	ldr	r0, [sp, #0x28]
700a5c4a: f642 1184    	movw	r1, #0x2984
700a5c4e: f2c7 010b    	movt	r1, #0x700b
700a5c52: 6809         	ldr	r1, [r1]
700a5c54: 4288         	cmp	r0, r1
700a5c56: d23b         	bhs	0x700a5cd0 <AddrTranslateP_getLocalAddr+0xb0> @ imm = #0x76
700a5c58: e7ff         	b	0x700a5c5a <AddrTranslateP_getLocalAddr+0x3a> @ imm = #-0x2
;         sizeMask = ( (uint32_t)( ((uint64_t)1U << gAddrTranslateConfig.regionConfig[regionId].size) - 1U) );
700a5c5a: f642 1084    	movw	r0, #0x2984
700a5c5e: f2c7 000b    	movt	r0, #0x700b
700a5c62: 6881         	ldr	r1, [r0, #0x8]
700a5c64: 9a0a         	ldr	r2, [sp, #0x28]
700a5c66: eb01 1102    	add.w	r1, r1, r2, lsl #4
700a5c6a: 68ca         	ldr	r2, [r1, #0xc]
700a5c6c: 2101         	movs	r1, #0x1
700a5c6e: 4091         	lsls	r1, r2
700a5c70: 3a20         	subs	r2, #0x20
700a5c72: 2a00         	cmp	r2, #0x0
700a5c74: bf58         	it	pl
700a5c76: 2100         	movpl	r1, #0x0
700a5c78: 3901         	subs	r1, #0x1
700a5c7a: 9103         	str	r1, [sp, #0xc]
;         startAddr = gAddrTranslateConfig.regionConfig[regionId].systemAddr;
700a5c7c: 6880         	ldr	r0, [r0, #0x8]
700a5c7e: 9a0a         	ldr	r2, [sp, #0x28]
700a5c80: eb00 1102    	add.w	r1, r0, r2, lsl #4
700a5c84: ea4f 1202    	lsl.w	r2, r2, #0x4
700a5c88: 5880         	ldr	r0, [r0, r2]
700a5c8a: 6849         	ldr	r1, [r1, #0x4]
700a5c8c: 9107         	str	r1, [sp, #0x1c]
700a5c8e: 9006         	str	r0, [sp, #0x18]
;         endAddr = startAddr + sizeMask;
700a5c90: 9906         	ldr	r1, [sp, #0x18]
700a5c92: 9807         	ldr	r0, [sp, #0x1c]
700a5c94: 9a03         	ldr	r2, [sp, #0xc]
700a5c96: 1889         	adds	r1, r1, r2
700a5c98: f140 0000    	adc	r0, r0, #0x0
700a5c9c: 9104         	str	r1, [sp, #0x10]
700a5c9e: 9005         	str	r0, [sp, #0x14]
;         if((systemAddr >= startAddr) && (systemAddr <= endAddr))
700a5ca0: 9a0c         	ldr	r2, [sp, #0x30]
700a5ca2: 980d         	ldr	r0, [sp, #0x34]
700a5ca4: 9b06         	ldr	r3, [sp, #0x18]
700a5ca6: 9907         	ldr	r1, [sp, #0x1c]
700a5ca8: 1ad2         	subs	r2, r2, r3
700a5caa: 4188         	sbcs	r0, r1
700a5cac: d30b         	blo	0x700a5cc6 <AddrTranslateP_getLocalAddr+0xa6> @ imm = #0x16
700a5cae: e7ff         	b	0x700a5cb0 <AddrTranslateP_getLocalAddr+0x90> @ imm = #-0x2
700a5cb0: 9b0c         	ldr	r3, [sp, #0x30]
700a5cb2: 990d         	ldr	r1, [sp, #0x34]
700a5cb4: 9a04         	ldr	r2, [sp, #0x10]
700a5cb6: 9805         	ldr	r0, [sp, #0x14]
700a5cb8: 1ad2         	subs	r2, r2, r3
700a5cba: 4188         	sbcs	r0, r1
700a5cbc: d303         	blo	0x700a5cc6 <AddrTranslateP_getLocalAddr+0xa6> @ imm = #0x6
700a5cbe: e7ff         	b	0x700a5cc0 <AddrTranslateP_getLocalAddr+0xa0> @ imm = #-0x2
700a5cc0: 2001         	movs	r0, #0x1
;             found = 1;
700a5cc2: 900b         	str	r0, [sp, #0x2c]
;             break;
700a5cc4: e004         	b	0x700a5cd0 <AddrTranslateP_getLocalAddr+0xb0> @ imm = #0x8
;     }
700a5cc6: e7ff         	b	0x700a5cc8 <AddrTranslateP_getLocalAddr+0xa8> @ imm = #-0x2
;     for(regionId=0; regionId<gAddrTranslateConfig.numRegions; regionId++)
700a5cc8: 980a         	ldr	r0, [sp, #0x28]
700a5cca: 3001         	adds	r0, #0x1
700a5ccc: 900a         	str	r0, [sp, #0x28]
700a5cce: e7bb         	b	0x700a5c48 <AddrTranslateP_getLocalAddr+0x28> @ imm = #-0x8a
;     if(found != 0U)
700a5cd0: 980b         	ldr	r0, [sp, #0x2c]
700a5cd2: b1a0         	cbz	r0, 0x700a5cfe <AddrTranslateP_getLocalAddr+0xde> @ imm = #0x28
700a5cd4: e7ff         	b	0x700a5cd6 <AddrTranslateP_getLocalAddr+0xb6> @ imm = #-0x2
;         uint32_t offset = systemAddr - gAddrTranslateConfig.regionConfig[regionId].systemAddr;
700a5cd6: 990c         	ldr	r1, [sp, #0x30]
700a5cd8: f642 1084    	movw	r0, #0x2984
700a5cdc: f2c7 000b    	movt	r0, #0x700b
700a5ce0: 6882         	ldr	r2, [r0, #0x8]
700a5ce2: 9b0a         	ldr	r3, [sp, #0x28]
700a5ce4: 011b         	lsls	r3, r3, #0x4
700a5ce6: 58d2         	ldr	r2, [r2, r3]
700a5ce8: 1a89         	subs	r1, r1, r2
700a5cea: 9102         	str	r1, [sp, #0x8]
;         localAddr = (void *) (gAddrTranslateConfig.regionConfig[regionId].localAddr + offset);
700a5cec: 6880         	ldr	r0, [r0, #0x8]
700a5cee: 990a         	ldr	r1, [sp, #0x28]
700a5cf0: eb00 1001    	add.w	r0, r0, r1, lsl #4
700a5cf4: 6880         	ldr	r0, [r0, #0x8]
700a5cf6: 9902         	ldr	r1, [sp, #0x8]
700a5cf8: 4408         	add	r0, r1
700a5cfa: 9009         	str	r0, [sp, #0x24]
;     }
700a5cfc: e002         	b	0x700a5d04 <AddrTranslateP_getLocalAddr+0xe4> @ imm = #0x4
;         localAddr = (void *) systemAddr;
700a5cfe: 980c         	ldr	r0, [sp, #0x30]
700a5d00: 9009         	str	r0, [sp, #0x24]
700a5d02: e7ff         	b	0x700a5d04 <AddrTranslateP_getLocalAddr+0xe4> @ imm = #-0x2
;     return localAddr;
700a5d04: 9809         	ldr	r0, [sp, #0x24]
700a5d06: b00e         	add	sp, #0x38
700a5d08: bd80         	pop	{r7, pc}
700a5d0a: 0000         	movs	r0, r0
700a5d0c: 0000         	movs	r0, r0
700a5d0e: 0000         	movs	r0, r0

700a5d10 <Udma_eventFreeResource>:
; {
700a5d10: b580         	push	{r7, lr}
700a5d12: b084         	sub	sp, #0x10
700a5d14: 9003         	str	r0, [sp, #0xc]
700a5d16: 9102         	str	r1, [sp, #0x8]
;     cookie = HwiP_disable();
700a5d18: f00a ee22    	blx	0x700b0960 <HwiP_disable> @ imm = #0xac44
700a5d1c: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != eventHandle->prevEvent)
700a5d1e: 9802         	ldr	r0, [sp, #0x8]
700a5d20: 6e00         	ldr	r0, [r0, #0x60]
700a5d22: b128         	cbz	r0, 0x700a5d30 <Udma_eventFreeResource+0x20> @ imm = #0xa
700a5d24: e7ff         	b	0x700a5d26 <Udma_eventFreeResource+0x16> @ imm = #-0x2
;         eventHandle->prevEvent->nextEvent = eventHandle->nextEvent;
700a5d26: 9902         	ldr	r1, [sp, #0x8]
700a5d28: 6dc8         	ldr	r0, [r1, #0x5c]
700a5d2a: 6e09         	ldr	r1, [r1, #0x60]
700a5d2c: 65c8         	str	r0, [r1, #0x5c]
;     }
700a5d2e: e7ff         	b	0x700a5d30 <Udma_eventFreeResource+0x20> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->nextEvent)
700a5d30: 9802         	ldr	r0, [sp, #0x8]
700a5d32: 6dc0         	ldr	r0, [r0, #0x5c]
700a5d34: b128         	cbz	r0, 0x700a5d42 <Udma_eventFreeResource+0x32> @ imm = #0xa
700a5d36: e7ff         	b	0x700a5d38 <Udma_eventFreeResource+0x28> @ imm = #-0x2
;         eventHandle->nextEvent->prevEvent = eventHandle->prevEvent;
700a5d38: 9802         	ldr	r0, [sp, #0x8]
700a5d3a: 6dc1         	ldr	r1, [r0, #0x5c]
700a5d3c: 6e00         	ldr	r0, [r0, #0x60]
700a5d3e: 6608         	str	r0, [r1, #0x60]
;     }
700a5d40: e7ff         	b	0x700a5d42 <Udma_eventFreeResource+0x32> @ imm = #-0x2
;     HwiP_restore(cookie);
700a5d42: 9801         	ldr	r0, [sp, #0x4]
700a5d44: f00a ee2c    	blx	0x700b09a0 <HwiP_restore> @ imm = #0xac58
;     if(NULL_PTR != eventHandle->hwiHandle)
700a5d48: 9802         	ldr	r0, [sp, #0x8]
700a5d4a: 6e40         	ldr	r0, [r0, #0x64]
700a5d4c: b140         	cbz	r0, 0x700a5d60 <Udma_eventFreeResource+0x50> @ imm = #0x10
700a5d4e: e7ff         	b	0x700a5d50 <Udma_eventFreeResource+0x40> @ imm = #-0x2
;         HwiP_destruct(&eventHandle->hwiObject);
700a5d50: 9802         	ldr	r0, [sp, #0x8]
700a5d52: 3068         	adds	r0, #0x68
700a5d54: f00a fa14    	bl	0x700b0180 <HwiP_destruct> @ imm = #0xa428
;         eventHandle->hwiHandle = NULL_PTR;
700a5d58: 9902         	ldr	r1, [sp, #0x8]
700a5d5a: 2000         	movs	r0, #0x0
700a5d5c: 6648         	str	r0, [r1, #0x64]
;     }
700a5d5e: e7ff         	b	0x700a5d60 <Udma_eventFreeResource+0x50> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->irIntrNum)
700a5d60: 9802         	ldr	r0, [sp, #0x8]
700a5d62: 6d40         	ldr	r0, [r0, #0x54]
700a5d64: f510 3f80    	cmn.w	r0, #0x10000
700a5d68: d00d         	beq	0x700a5d86 <Udma_eventFreeResource+0x76> @ imm = #0x1a
700a5d6a: e7ff         	b	0x700a5d6c <Udma_eventFreeResource+0x5c> @ imm = #-0x2
;         Udma_rmFreeIrIntr(eventHandle->irIntrNum, drvHandle);
700a5d6c: 9802         	ldr	r0, [sp, #0x8]
700a5d6e: 6d40         	ldr	r0, [r0, #0x54]
700a5d70: 9903         	ldr	r1, [sp, #0xc]
700a5d72: f005 ffe5    	bl	0x700abd40 <Udma_rmFreeIrIntr> @ imm = #0x5fca
;         eventHandle->irIntrNum = UDMA_INTR_INVALID;
700a5d76: 9902         	ldr	r1, [sp, #0x8]
700a5d78: 2000         	movs	r0, #0x0
700a5d7a: f6cf 70ff    	movt	r0, #0xffff
700a5d7e: 6548         	str	r0, [r1, #0x54]
;         eventHandle->coreIntrNum = UDMA_INTR_INVALID;
700a5d80: 9902         	ldr	r1, [sp, #0x8]
700a5d82: 6588         	str	r0, [r1, #0x58]
;     }
700a5d84: e7ff         	b	0x700a5d86 <Udma_eventFreeResource+0x76> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->globalEvent)
700a5d86: 9802         	ldr	r0, [sp, #0x8]
700a5d88: 6c80         	ldr	r0, [r0, #0x48]
700a5d8a: f64f 71ff    	movw	r1, #0xffff
700a5d8e: 4288         	cmp	r0, r1
700a5d90: d00e         	beq	0x700a5db0 <Udma_eventFreeResource+0xa0> @ imm = #0x1c
700a5d92: e7ff         	b	0x700a5d94 <Udma_eventFreeResource+0x84> @ imm = #-0x2
;         Udma_eventResetSteering(drvHandle, eventHandle);
700a5d94: 9803         	ldr	r0, [sp, #0xc]
700a5d96: 9902         	ldr	r1, [sp, #0x8]
700a5d98: f009 f87a    	bl	0x700aee90 <Udma_eventResetSteering> @ imm = #0x90f4
;         Udma_rmFreeEvent(eventHandle->globalEvent, drvHandle);
700a5d9c: 9802         	ldr	r0, [sp, #0x8]
700a5d9e: 6c80         	ldr	r0, [r0, #0x48]
700a5da0: 9903         	ldr	r1, [sp, #0xc]
700a5da2: f005 ff95    	bl	0x700abcd0 <Udma_rmFreeEvent> @ imm = #0x5f2a
;         eventHandle->globalEvent = UDMA_EVENT_INVALID;
700a5da6: 9902         	ldr	r1, [sp, #0x8]
700a5da8: f64f 70ff    	movw	r0, #0xffff
700a5dac: 6488         	str	r0, [r1, #0x48]
;     }
700a5dae: e7ff         	b	0x700a5db0 <Udma_eventFreeResource+0xa0> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
700a5db0: 9802         	ldr	r0, [sp, #0x8]
700a5db2: 6d00         	ldr	r0, [r0, #0x50]
700a5db4: f64f 71ff    	movw	r1, #0xffff
700a5db8: 4288         	cmp	r0, r1
700a5dba: d00a         	beq	0x700a5dd2 <Udma_eventFreeResource+0xc2> @ imm = #0x14
700a5dbc: e7ff         	b	0x700a5dbe <Udma_eventFreeResource+0xae> @ imm = #-0x2
;         Udma_rmFreeVintrBit(eventHandle->vintrBitNum, drvHandle, eventHandle);
700a5dbe: 9a02         	ldr	r2, [sp, #0x8]
700a5dc0: 6d10         	ldr	r0, [r2, #0x50]
700a5dc2: 9903         	ldr	r1, [sp, #0xc]
700a5dc4: f004 facc    	bl	0x700aa360 <Udma_rmFreeVintrBit> @ imm = #0x4598
;         eventHandle->vintrBitNum = UDMA_EVENT_INVALID;
700a5dc8: 9902         	ldr	r1, [sp, #0x8]
700a5dca: f64f 70ff    	movw	r0, #0xffff
700a5dce: 6508         	str	r0, [r1, #0x50]
;     }
700a5dd0: e7ff         	b	0x700a5dd2 <Udma_eventFreeResource+0xc2> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->vintrNum)
700a5dd2: 9802         	ldr	r0, [sp, #0x8]
700a5dd4: 6cc0         	ldr	r0, [r0, #0x4c]
700a5dd6: f64f 71ff    	movw	r1, #0xffff
700a5dda: 4288         	cmp	r0, r1
700a5ddc: d00a         	beq	0x700a5df4 <Udma_eventFreeResource+0xe4> @ imm = #0x14
700a5dde: e7ff         	b	0x700a5de0 <Udma_eventFreeResource+0xd0> @ imm = #-0x2
;         Udma_rmFreeVintr(eventHandle->vintrNum, drvHandle);
700a5de0: 9802         	ldr	r0, [sp, #0x8]
700a5de2: 6cc0         	ldr	r0, [r0, #0x4c]
700a5de4: 9903         	ldr	r1, [sp, #0xc]
700a5de6: f005 ffe3    	bl	0x700abdb0 <Udma_rmFreeVintr> @ imm = #0x5fc6
;         eventHandle->vintrNum = UDMA_EVENT_INVALID;
700a5dea: 9902         	ldr	r1, [sp, #0x8]
700a5dec: f64f 70ff    	movw	r0, #0xffff
700a5df0: 64c8         	str	r0, [r1, #0x4c]
;     }
700a5df2: e7ff         	b	0x700a5df4 <Udma_eventFreeResource+0xe4> @ imm = #-0x2
;     return;
700a5df4: b004         	add	sp, #0x10
700a5df6: bd80         	pop	{r7, pc}
		...

700a5e00 <DebugP_memTraceLogWriterPutLine>:
; {
700a5e00: b580         	push	{r7, lr}
700a5e02: b08a         	sub	sp, #0x28
700a5e04: 9009         	str	r0, [sp, #0x24]
700a5e06: f8ad 1022    	strh.w	r1, [sp, #0x22]
700a5e0a: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700a5e0c: 9007         	str	r0, [sp, #0x1c]
;     if (gDebugMemLogSize == 0U)
700a5e0e: f642 10e8    	movw	r0, #0x29e8
700a5e12: f2c7 000b    	movt	r0, #0x700b
700a5e16: 6800         	ldr	r0, [r0]
700a5e18: b920         	cbnz	r0, 0x700a5e24 <DebugP_memTraceLogWriterPutLine+0x24> @ imm = #0x8
700a5e1a: e7ff         	b	0x700a5e1c <DebugP_memTraceLogWriterPutLine+0x1c> @ imm = #-0x2
700a5e1c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700a5e20: 9007         	str	r0, [sp, #0x1c]
;     }
700a5e22: e7ff         	b	0x700a5e24 <DebugP_memTraceLogWriterPutLine+0x24> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
700a5e24: 9807         	ldr	r0, [sp, #0x1c]
700a5e26: 2800         	cmp	r0, #0x0
700a5e28: d15a         	bne	0x700a5ee0 <DebugP_memTraceLogWriterPutLine+0xe0> @ imm = #0xb4
700a5e2a: e7ff         	b	0x700a5e2c <DebugP_memTraceLogWriterPutLine+0x2c> @ imm = #-0x2
;         wr_idx = gDebugMemLogWriteIndex;
700a5e2c: f642 10ec    	movw	r0, #0x29ec
700a5e30: f2c7 000b    	movt	r0, #0x700b
700a5e34: 6800         	ldr	r0, [r0]
700a5e36: 9006         	str	r0, [sp, #0x18]
;         dst = (uint8_t*)&gDebugMemLog[0];
700a5e38: f241 0080    	movw	r0, #0x1080
700a5e3c: f2c7 0008    	movt	r0, #0x7008
700a5e40: 9003         	str	r0, [sp, #0xc]
700a5e42: 2000         	movs	r0, #0x0
;         idx = 0;
700a5e44: 9004         	str	r0, [sp, #0x10]
;         for (copy_bytes = 0; copy_bytes < num_bytes; copy_bytes++)
700a5e46: 9005         	str	r0, [sp, #0x14]
700a5e48: e7ff         	b	0x700a5e4a <DebugP_memTraceLogWriterPutLine+0x4a> @ imm = #-0x2
700a5e4a: 9805         	ldr	r0, [sp, #0x14]
700a5e4c: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a5e50: 4288         	cmp	r0, r1
700a5e52: d233         	bhs	0x700a5ebc <DebugP_memTraceLogWriterPutLine+0xbc> @ imm = #0x66
700a5e54: e7ff         	b	0x700a5e56 <DebugP_memTraceLogWriterPutLine+0x56> @ imm = #-0x2
;             dst[wr_idx] = buf[idx];
700a5e56: 9809         	ldr	r0, [sp, #0x24]
700a5e58: 9904         	ldr	r1, [sp, #0x10]
700a5e5a: 5c40         	ldrb	r0, [r0, r1]
700a5e5c: 9903         	ldr	r1, [sp, #0xc]
700a5e5e: 9a06         	ldr	r2, [sp, #0x18]
700a5e60: 5488         	strb	r0, [r1, r2]
;             wr_idx = wr_idx + 1U;
700a5e62: 9806         	ldr	r0, [sp, #0x18]
700a5e64: 3001         	adds	r0, #0x1
700a5e66: 9006         	str	r0, [sp, #0x18]
;             if (wr_idx >= gDebugMemLogSize)
700a5e68: 9806         	ldr	r0, [sp, #0x18]
700a5e6a: f642 11e8    	movw	r1, #0x29e8
700a5e6e: f2c7 010b    	movt	r1, #0x700b
700a5e72: 6809         	ldr	r1, [r1]
700a5e74: 4288         	cmp	r0, r1
700a5e76: d319         	blo	0x700a5eac <DebugP_memTraceLogWriterPutLine+0xac> @ imm = #0x32
700a5e78: e7ff         	b	0x700a5e7a <DebugP_memTraceLogWriterPutLine+0x7a> @ imm = #-0x2
;                         &dst[gDebugMemLogWriteIndex],
700a5e7a: 9803         	ldr	r0, [sp, #0xc]
700a5e7c: f642 12ec    	movw	r2, #0x29ec
700a5e80: f2c7 020b    	movt	r2, #0x700b
700a5e84: 9202         	str	r2, [sp, #0x8]
700a5e86: 6811         	ldr	r1, [r2]
700a5e88: 4408         	add	r0, r1
;                         (wr_idx - gDebugMemLogWriteIndex),
700a5e8a: 9906         	ldr	r1, [sp, #0x18]
700a5e8c: 6812         	ldr	r2, [r2]
700a5e8e: 1a89         	subs	r1, r1, r2
700a5e90: 220f         	movs	r2, #0xf
;                 CacheP_wbInv(
700a5e92: f00a ee5e    	blx	0x700b0b50 <CacheP_wbInv> @ imm = #0xacbc
700a5e96: 9902         	ldr	r1, [sp, #0x8]
700a5e98: 2000         	movs	r0, #0x0
;                 wr_idx = 0;
700a5e9a: 9006         	str	r0, [sp, #0x18]
;                 gDebugMemLogWriteIndex = 0;
700a5e9c: 6008         	str	r0, [r1]
;                 gDebugMemLogIsWrapAround = 1;
700a5e9e: f642 11e4    	movw	r1, #0x29e4
700a5ea2: f2c7 010b    	movt	r1, #0x700b
700a5ea6: 2001         	movs	r0, #0x1
700a5ea8: 6008         	str	r0, [r1]
;             }
700a5eaa: e7ff         	b	0x700a5eac <DebugP_memTraceLogWriterPutLine+0xac> @ imm = #-0x2
;             idx ++;
700a5eac: 9804         	ldr	r0, [sp, #0x10]
700a5eae: 3001         	adds	r0, #0x1
700a5eb0: 9004         	str	r0, [sp, #0x10]
;         }
700a5eb2: e7ff         	b	0x700a5eb4 <DebugP_memTraceLogWriterPutLine+0xb4> @ imm = #-0x2
;         for (copy_bytes = 0; copy_bytes < num_bytes; copy_bytes++)
700a5eb4: 9805         	ldr	r0, [sp, #0x14]
700a5eb6: 3001         	adds	r0, #0x1
700a5eb8: 9005         	str	r0, [sp, #0x14]
700a5eba: e7c6         	b	0x700a5e4a <DebugP_memTraceLogWriterPutLine+0x4a> @ imm = #-0x74
;                 &dst[gDebugMemLogWriteIndex],
700a5ebc: 9803         	ldr	r0, [sp, #0xc]
700a5ebe: f642 12ec    	movw	r2, #0x29ec
700a5ec2: f2c7 020b    	movt	r2, #0x700b
700a5ec6: 9201         	str	r2, [sp, #0x4]
700a5ec8: 6811         	ldr	r1, [r2]
700a5eca: 4408         	add	r0, r1
;                 (wr_idx - gDebugMemLogWriteIndex),
700a5ecc: 9906         	ldr	r1, [sp, #0x18]
700a5ece: 6812         	ldr	r2, [r2]
700a5ed0: 1a89         	subs	r1, r1, r2
700a5ed2: 220f         	movs	r2, #0xf
;         CacheP_wbInv(
700a5ed4: f00a ee3c    	blx	0x700b0b50 <CacheP_wbInv> @ imm = #0xac78
700a5ed8: 9901         	ldr	r1, [sp, #0x4]
;         gDebugMemLogWriteIndex = wr_idx;
700a5eda: 9806         	ldr	r0, [sp, #0x18]
700a5edc: 6008         	str	r0, [r1]
;     }
700a5ede: e7ff         	b	0x700a5ee0 <DebugP_memTraceLogWriterPutLine+0xe0> @ imm = #-0x2
; }
700a5ee0: b00a         	add	sp, #0x28
700a5ee2: bd80         	pop	{r7, pc}
		...

700a5ef0 <Sciclient_rmIrqGetNode>:
; {
700a5ef0: b089         	sub	sp, #0x24
700a5ef2: f8ad 0022    	strh.w	r0, [sp, #0x22]
700a5ef6: 9107         	str	r1, [sp, #0x1c]
700a5ef8: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700a5efc: 9006         	str	r0, [sp, #0x18]
700a5efe: 2000         	movs	r0, #0x0
;     lower = 0u;
700a5f00: 9004         	str	r0, [sp, #0x10]
;     upper = gRmIrqTreeCount - 1u;
700a5f02: f242 6140    	movw	r1, #0x2640
700a5f06: f2c7 010b    	movt	r1, #0x700b
700a5f0a: 680a         	ldr	r2, [r1]
700a5f0c: 3a01         	subs	r2, #0x1
700a5f0e: 9203         	str	r2, [sp, #0xc]
;     count = gRmIrqTreeCount;
700a5f10: 6809         	ldr	r1, [r1]
700a5f12: f8ad 1006    	strh.w	r1, [sp, #0x6]
;     *found_n = NULL;
700a5f16: 9907         	ldr	r1, [sp, #0x1c]
700a5f18: 6008         	str	r0, [r1]
;     while ((lower <= upper) &&
700a5f1a: e7ff         	b	0x700a5f1c <Sciclient_rmIrqGetNode+0x2c> @ imm = #-0x2
700a5f1c: 9904         	ldr	r1, [sp, #0x10]
700a5f1e: 9a03         	ldr	r2, [sp, #0xc]
700a5f20: 2000         	movs	r0, #0x0
700a5f22: 4291         	cmp	r1, r2
700a5f24: 9000         	str	r0, [sp]
700a5f26: d81d         	bhi	0x700a5f64 <Sciclient_rmIrqGetNode+0x74> @ imm = #0x3a
700a5f28: e7ff         	b	0x700a5f2a <Sciclient_rmIrqGetNode+0x3a> @ imm = #-0x2
;            (lower < gRmIrqTreeCount) &&
700a5f2a: 9904         	ldr	r1, [sp, #0x10]
700a5f2c: f242 6040    	movw	r0, #0x2640
700a5f30: f2c7 000b    	movt	r0, #0x700b
700a5f34: 6802         	ldr	r2, [r0]
700a5f36: 2000         	movs	r0, #0x0
700a5f38: 4291         	cmp	r1, r2
700a5f3a: 9000         	str	r0, [sp]
700a5f3c: d212         	bhs	0x700a5f64 <Sciclient_rmIrqGetNode+0x74> @ imm = #0x24
700a5f3e: e7ff         	b	0x700a5f40 <Sciclient_rmIrqGetNode+0x50> @ imm = #-0x2
;            (upper < gRmIrqTreeCount) &&
700a5f40: 9903         	ldr	r1, [sp, #0xc]
700a5f42: f242 6040    	movw	r0, #0x2640
700a5f46: f2c7 000b    	movt	r0, #0x700b
700a5f4a: 6802         	ldr	r2, [r0]
700a5f4c: 2000         	movs	r0, #0x0
700a5f4e: 4291         	cmp	r1, r2
700a5f50: 9000         	str	r0, [sp]
700a5f52: d207         	bhs	0x700a5f64 <Sciclient_rmIrqGetNode+0x74> @ imm = #0xe
700a5f54: e7ff         	b	0x700a5f56 <Sciclient_rmIrqGetNode+0x66> @ imm = #-0x2
;            (count > 0u)) {
700a5f56: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5f5a: 2800         	cmp	r0, #0x0
700a5f5c: bf18         	it	ne
700a5f5e: 2001         	movne	r0, #0x1
700a5f60: 9000         	str	r0, [sp]
700a5f62: e7ff         	b	0x700a5f64 <Sciclient_rmIrqGetNode+0x74> @ imm = #-0x2
700a5f64: 9800         	ldr	r0, [sp]
;     while ((lower <= upper) &&
700a5f66: 07c0         	lsls	r0, r0, #0x1f
700a5f68: b380         	cbz	r0, 0x700a5fcc <Sciclient_rmIrqGetNode+0xdc> @ imm = #0x60
700a5f6a: e7ff         	b	0x700a5f6c <Sciclient_rmIrqGetNode+0x7c> @ imm = #-0x2
;         current = (lower + upper) / (2u);
700a5f6c: 9804         	ldr	r0, [sp, #0x10]
700a5f6e: 9903         	ldr	r1, [sp, #0xc]
700a5f70: 4408         	add	r0, r1
700a5f72: 0840         	lsrs	r0, r0, #0x1
700a5f74: 9002         	str	r0, [sp, #0x8]
;         cur_n = (const struct Sciclient_rmIrqNode *) gRmIrqTree[current];
700a5f76: 9902         	ldr	r1, [sp, #0x8]
700a5f78: f641 00c8    	movw	r0, #0x18c8
700a5f7c: f2c7 000b    	movt	r0, #0x700b
700a5f80: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a5f84: 9005         	str	r0, [sp, #0x14]
;         if (cur_n->id == id) {
700a5f86: 9805         	ldr	r0, [sp, #0x14]
700a5f88: 8800         	ldrh	r0, [r0]
700a5f8a: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a5f8e: 4288         	cmp	r0, r1
700a5f90: d106         	bne	0x700a5fa0 <Sciclient_rmIrqGetNode+0xb0> @ imm = #0xc
700a5f92: e7ff         	b	0x700a5f94 <Sciclient_rmIrqGetNode+0xa4> @ imm = #-0x2
;             *found_n = cur_n;
700a5f94: 9805         	ldr	r0, [sp, #0x14]
700a5f96: 9907         	ldr	r1, [sp, #0x1c]
700a5f98: 6008         	str	r0, [r1]
700a5f9a: 2000         	movs	r0, #0x0
;             r = SystemP_SUCCESS;
700a5f9c: 9006         	str	r0, [sp, #0x18]
;             break;
700a5f9e: e015         	b	0x700a5fcc <Sciclient_rmIrqGetNode+0xdc> @ imm = #0x2a
;             if (cur_n->id < id) {
700a5fa0: 9805         	ldr	r0, [sp, #0x14]
700a5fa2: 8800         	ldrh	r0, [r0]
700a5fa4: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a5fa8: 4288         	cmp	r0, r1
700a5faa: da04         	bge	0x700a5fb6 <Sciclient_rmIrqGetNode+0xc6> @ imm = #0x8
700a5fac: e7ff         	b	0x700a5fae <Sciclient_rmIrqGetNode+0xbe> @ imm = #-0x2
;                 lower = current + (1u);
700a5fae: 9802         	ldr	r0, [sp, #0x8]
700a5fb0: 3001         	adds	r0, #0x1
700a5fb2: 9004         	str	r0, [sp, #0x10]
;             } else {
700a5fb4: e003         	b	0x700a5fbe <Sciclient_rmIrqGetNode+0xce> @ imm = #0x6
;                 upper = current - (1u);
700a5fb6: 9802         	ldr	r0, [sp, #0x8]
700a5fb8: 3801         	subs	r0, #0x1
700a5fba: 9003         	str	r0, [sp, #0xc]
700a5fbc: e7ff         	b	0x700a5fbe <Sciclient_rmIrqGetNode+0xce> @ imm = #-0x2
700a5fbe: e7ff         	b	0x700a5fc0 <Sciclient_rmIrqGetNode+0xd0> @ imm = #-0x2
;         count--;
700a5fc0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5fc4: 3801         	subs	r0, #0x1
700a5fc6: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     while ((lower <= upper) &&
700a5fca: e7a7         	b	0x700a5f1c <Sciclient_rmIrqGetNode+0x2c> @ imm = #-0xb2
;     return r;
700a5fcc: 9806         	ldr	r0, [sp, #0x18]
700a5fce: b009         	add	sp, #0x24
700a5fd0: 4770         	bx	lr
		...
700a5fde: 0000         	movs	r0, r0

700a5fe0 <vTaskGetInfo>:
;                   BaseType_t xGetFreeStackSpace, eTaskState eState) {
700a5fe0: b580         	push	{r7, lr}
700a5fe2: b086         	sub	sp, #0x18
700a5fe4: 9005         	str	r0, [sp, #0x14]
700a5fe6: 9104         	str	r1, [sp, #0x10]
700a5fe8: 9203         	str	r2, [sp, #0xc]
700a5fea: f88d 300b    	strb.w	r3, [sp, #0xb]
;   pxTCB = prvGetTCBFromHandle(xTask);
700a5fee: 9805         	ldr	r0, [sp, #0x14]
700a5ff0: b938         	cbnz	r0, 0x700a6002 <vTaskGetInfo+0x22> @ imm = #0xe
700a5ff2: e7ff         	b	0x700a5ff4 <vTaskGetInfo+0x14> @ imm = #-0x2
700a5ff4: f642 200c    	movw	r0, #0x2a0c
700a5ff8: f2c7 000b    	movt	r0, #0x700b
700a5ffc: 6800         	ldr	r0, [r0]
700a5ffe: 9000         	str	r0, [sp]
700a6000: e002         	b	0x700a6008 <vTaskGetInfo+0x28> @ imm = #0x4
700a6002: 9805         	ldr	r0, [sp, #0x14]
700a6004: 9000         	str	r0, [sp]
700a6006: e7ff         	b	0x700a6008 <vTaskGetInfo+0x28> @ imm = #-0x2
700a6008: 9800         	ldr	r0, [sp]
700a600a: 9001         	str	r0, [sp, #0x4]
;   pxTaskStatus->xHandle = (TaskHandle_t)pxTCB;
700a600c: 9801         	ldr	r0, [sp, #0x4]
700a600e: 9904         	ldr	r1, [sp, #0x10]
700a6010: 6008         	str	r0, [r1]
;   pxTaskStatus->pcTaskName = (const char *)&(pxTCB->pcTaskName[0]);
700a6012: 9801         	ldr	r0, [sp, #0x4]
700a6014: 3034         	adds	r0, #0x34
700a6016: 9904         	ldr	r1, [sp, #0x10]
700a6018: 6048         	str	r0, [r1, #0x4]
;   pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
700a601a: 9801         	ldr	r0, [sp, #0x4]
700a601c: 6ac0         	ldr	r0, [r0, #0x2c]
700a601e: 9904         	ldr	r1, [sp, #0x10]
700a6020: 6108         	str	r0, [r1, #0x10]
;   pxTaskStatus->pxStackBase = pxTCB->pxStack;
700a6022: 9801         	ldr	r0, [sp, #0x4]
700a6024: 6b00         	ldr	r0, [r0, #0x30]
700a6026: 9904         	ldr	r1, [sp, #0x10]
700a6028: 61c8         	str	r0, [r1, #0x1c]
;   pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
700a602a: 9801         	ldr	r0, [sp, #0x4]
700a602c: 6d80         	ldr	r0, [r0, #0x58]
700a602e: 9904         	ldr	r1, [sp, #0x10]
700a6030: 6088         	str	r0, [r1, #0x8]
;     pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
700a6032: 9801         	ldr	r0, [sp, #0x4]
700a6034: 6e00         	ldr	r0, [r0, #0x60]
700a6036: 9904         	ldr	r1, [sp, #0x10]
700a6038: 6148         	str	r0, [r1, #0x14]
;     pxTaskStatus->ulRunTimeCounter = 0;
700a603a: 9904         	ldr	r1, [sp, #0x10]
700a603c: 2000         	movs	r0, #0x0
700a603e: 6188         	str	r0, [r1, #0x18]
;   if (eState != eInvalid) {
700a6040: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a6044: 2805         	cmp	r0, #0x5
700a6046: d025         	beq	0x700a6094 <vTaskGetInfo+0xb4> @ imm = #0x4a
700a6048: e7ff         	b	0x700a604a <vTaskGetInfo+0x6a> @ imm = #-0x2
;     if (pxTCB == pxCurrentTCB) {
700a604a: 9801         	ldr	r0, [sp, #0x4]
700a604c: f642 210c    	movw	r1, #0x2a0c
700a6050: f2c7 010b    	movt	r1, #0x700b
700a6054: 6809         	ldr	r1, [r1]
700a6056: 4288         	cmp	r0, r1
700a6058: d104         	bne	0x700a6064 <vTaskGetInfo+0x84> @ imm = #0x8
700a605a: e7ff         	b	0x700a605c <vTaskGetInfo+0x7c> @ imm = #-0x2
;       pxTaskStatus->eCurrentState = eRunning;
700a605c: 9904         	ldr	r1, [sp, #0x10]
700a605e: 2000         	movs	r0, #0x0
700a6060: 7308         	strb	r0, [r1, #0xc]
;     } else {
700a6062: e016         	b	0x700a6092 <vTaskGetInfo+0xb2> @ imm = #0x2c
;       pxTaskStatus->eCurrentState = eState;
700a6064: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a6068: 9904         	ldr	r1, [sp, #0x10]
700a606a: 7308         	strb	r0, [r1, #0xc]
;         if (eState == eSuspended) {
700a606c: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a6070: 2803         	cmp	r0, #0x3
700a6072: d10d         	bne	0x700a6090 <vTaskGetInfo+0xb0> @ imm = #0x1a
700a6074: e7ff         	b	0x700a6076 <vTaskGetInfo+0x96> @ imm = #-0x2
;           vTaskSuspendAll();
700a6076: f009 fdab    	bl	0x700afbd0 <vTaskSuspendAll> @ imm = #0x9b56
;             if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a607a: 9801         	ldr	r0, [sp, #0x4]
700a607c: 6a80         	ldr	r0, [r0, #0x28]
700a607e: b120         	cbz	r0, 0x700a608a <vTaskGetInfo+0xaa> @ imm = #0x8
700a6080: e7ff         	b	0x700a6082 <vTaskGetInfo+0xa2> @ imm = #-0x2
;               pxTaskStatus->eCurrentState = eBlocked;
700a6082: 9904         	ldr	r1, [sp, #0x10]
700a6084: 2002         	movs	r0, #0x2
700a6086: 7308         	strb	r0, [r1, #0xc]
;             }
700a6088: e7ff         	b	0x700a608a <vTaskGetInfo+0xaa> @ imm = #-0x2
;           (void)xTaskResumeAll();
700a608a: f7fc f909    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0x3dee
;         }
700a608e: e7ff         	b	0x700a6090 <vTaskGetInfo+0xb0> @ imm = #-0x2
700a6090: e7ff         	b	0x700a6092 <vTaskGetInfo+0xb2> @ imm = #-0x2
;   } else {
700a6092: e005         	b	0x700a60a0 <vTaskGetInfo+0xc0> @ imm = #0xa
;     pxTaskStatus->eCurrentState = eTaskGetState(pxTCB);
700a6094: 9801         	ldr	r0, [sp, #0x4]
700a6096: f7ff fbdb    	bl	0x700a5850 <eTaskGetState> @ imm = #-0x84a
700a609a: 9904         	ldr	r1, [sp, #0x10]
700a609c: 7308         	strb	r0, [r1, #0xc]
700a609e: e7ff         	b	0x700a60a0 <vTaskGetInfo+0xc0> @ imm = #-0x2
;   if (xGetFreeStackSpace != pdFALSE) {
700a60a0: 9803         	ldr	r0, [sp, #0xc]
700a60a2: b138         	cbz	r0, 0x700a60b4 <vTaskGetInfo+0xd4> @ imm = #0xe
700a60a4: e7ff         	b	0x700a60a6 <vTaskGetInfo+0xc6> @ imm = #-0x2
;           prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxStack);
700a60a6: 9801         	ldr	r0, [sp, #0x4]
700a60a8: 6b00         	ldr	r0, [r0, #0x30]
700a60aa: f008 fcc9    	bl	0x700aea40 <prvTaskCheckFreeStackSpace> @ imm = #0x8992
;       pxTaskStatus->usStackHighWaterMark =
700a60ae: 9904         	ldr	r1, [sp, #0x10]
700a60b0: 6208         	str	r0, [r1, #0x20]
;   } else {
700a60b2: e003         	b	0x700a60bc <vTaskGetInfo+0xdc> @ imm = #0x6
;     pxTaskStatus->usStackHighWaterMark = 0;
700a60b4: 9904         	ldr	r1, [sp, #0x10]
700a60b6: 2000         	movs	r0, #0x0
700a60b8: 6208         	str	r0, [r1, #0x20]
700a60ba: e7ff         	b	0x700a60bc <vTaskGetInfo+0xdc> @ imm = #-0x2
; }
700a60bc: b006         	add	sp, #0x18
700a60be: bd80         	pop	{r7, pc}

700a60c0 <Sciclient_waitForMessage>:
; {
700a60c0: b580         	push	{r7, lr}
700a60c2: b088         	sub	sp, #0x20
700a60c4: 9007         	str	r0, [sp, #0x1c]
700a60c6: 9106         	str	r1, [sp, #0x18]
700a60c8: 9205         	str	r2, [sp, #0x14]
700a60ca: f88d 3013    	strb.w	r3, [sp, #0x13]
;     uint32_t timeToWait = timeout;
700a60ce: 9806         	ldr	r0, [sp, #0x18]
700a60d0: 9002         	str	r0, [sp, #0x8]
700a60d2: 2200         	movs	r2, #0x0
;     int32_t status = SystemP_SUCCESS;
700a60d4: 9201         	str	r2, [sp, #0x4]
;                                         &gSciclientSecProxyCfg, rxThread, 0U)
700a60d6: 9907         	ldr	r1, [sp, #0x1c]
;         (struct tisci_header *)(CSL_secProxyGetDataAddr(
700a60d8: f642 00d0    	movw	r0, #0x28d0
700a60dc: f2c7 000b    	movt	r0, #0x700b
700a60e0: f009 fa46    	bl	0x700af570 <CSL_secProxyGetDataAddr> @ imm = #0x948c
;                                 + ((uintptr_t) gSecHeaderSizeWords * (uintptr_t) 4U));
700a60e4: f642 2164    	movw	r1, #0x2a64
700a60e8: f2c7 010b    	movt	r1, #0x700b
700a60ec: 7809         	ldrb	r1, [r1]
700a60ee: eb00 0081    	add.w	r0, r0, r1, lsl #2
;     pLocalRespHdr =
700a60f2: 9003         	str	r0, [sp, #0xc]
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a60f4: e7ff         	b	0x700a60f6 <Sciclient_waitForMessage+0x36> @ imm = #-0x2
700a60f6: 9807         	ldr	r0, [sp, #0x1c]
700a60f8: f009 faea    	bl	0x700af6d0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x95d4
700a60fc: f009 fda0    	bl	0x700afc40 <CSL_REG32_RD_RAW> @ imm = #0x9b40
700a6100: b2c0         	uxtb	r0, r0
;             CSL_SEC_PROXY_RT_THREAD_STATUS_CUR_CNT_MASK) - initialCount) <= 0U)
700a6102: 9905         	ldr	r1, [sp, #0x14]
700a6104: 1a40         	subs	r0, r0, r1
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a6106: b960         	cbnz	r0, 0x700a6122 <Sciclient_waitForMessage+0x62> @ imm = #0x18
700a6108: e7ff         	b	0x700a610a <Sciclient_waitForMessage+0x4a> @ imm = #-0x2
;         if (timeToWait != 0U)
700a610a: 9802         	ldr	r0, [sp, #0x8]
700a610c: b120         	cbz	r0, 0x700a6118 <Sciclient_waitForMessage+0x58> @ imm = #0x8
700a610e: e7ff         	b	0x700a6110 <Sciclient_waitForMessage+0x50> @ imm = #-0x2
;             timeToWait--;
700a6110: 9802         	ldr	r0, [sp, #0x8]
700a6112: 3801         	subs	r0, #0x1
700a6114: 9002         	str	r0, [sp, #0x8]
;         }
700a6116: e003         	b	0x700a6120 <Sciclient_waitForMessage+0x60> @ imm = #0x6
700a6118: f06f 0001    	mvn	r0, #0x1
;             status = SystemP_TIMEOUT;
700a611c: 9001         	str	r0, [sp, #0x4]
;             break;
700a611e: e000         	b	0x700a6122 <Sciclient_waitForMessage+0x62> @ imm = #0x0
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a6120: e7e9         	b	0x700a60f6 <Sciclient_waitForMessage+0x36> @ imm = #-0x2e
;     if (status == SystemP_SUCCESS)
700a6122: 9801         	ldr	r0, [sp, #0x4]
700a6124: bbc0         	cbnz	r0, 0x700a6198 <Sciclient_waitForMessage+0xd8> @ imm = #0x70
700a6126: e7ff         	b	0x700a6128 <Sciclient_waitForMessage+0x68> @ imm = #-0x2
700a6128: f06f 0001    	mvn	r0, #0x1
;         status = SystemP_TIMEOUT;
700a612c: 9001         	str	r0, [sp, #0x4]
;         timeToWait =  timeout;
700a612e: 9806         	ldr	r0, [sp, #0x18]
700a6130: 9002         	str	r0, [sp, #0x8]
;         while(1)
700a6132: e7ff         	b	0x700a6134 <Sciclient_waitForMessage+0x74> @ imm = #-0x2
;             uint32_t numCurrentMsgs = (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a6134: 9807         	ldr	r0, [sp, #0x1c]
700a6136: f009 facb    	bl	0x700af6d0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x9596
700a613a: f009 fd81    	bl	0x700afc40 <CSL_REG32_RD_RAW> @ imm = #0x9b02
700a613e: b2c0         	uxtb	r0, r0
;                     CSL_SEC_PROXY_RT_THREAD_STATUS_CUR_CNT_MASK) - initialCount;
700a6140: 9905         	ldr	r1, [sp, #0x14]
700a6142: 1a40         	subs	r0, r0, r1
;             uint32_t numCurrentMsgs = (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a6144: 9000         	str	r0, [sp]
;             if (pLocalRespHdr->seq == (uint32_t)localSeqId)
700a6146: 9803         	ldr	r0, [sp, #0xc]
700a6148: 78c0         	ldrb	r0, [r0, #0x3]
700a614a: f89d 1013    	ldrb.w	r1, [sp, #0x13]
700a614e: 4288         	cmp	r0, r1
700a6150: d103         	bne	0x700a615a <Sciclient_waitForMessage+0x9a> @ imm = #0x6
700a6152: e7ff         	b	0x700a6154 <Sciclient_waitForMessage+0x94> @ imm = #-0x2
700a6154: 2000         	movs	r0, #0x0
;                 status = SystemP_SUCCESS;
700a6156: 9001         	str	r0, [sp, #0x4]
;                 break;
700a6158: e01d         	b	0x700a6196 <Sciclient_waitForMessage+0xd6> @ imm = #0x3a
;             if (numCurrentMsgs > 1U)
700a615a: 9800         	ldr	r0, [sp]
700a615c: 2802         	cmp	r0, #0x2
700a615e: d30e         	blo	0x700a617e <Sciclient_waitForMessage+0xbe> @ imm = #0x1c
700a6160: e7ff         	b	0x700a6162 <Sciclient_waitForMessage+0xa2> @ imm = #-0x2
;                 (void) Sciclient_secProxyReadThread32(rxThread,
700a6162: 9807         	ldr	r0, [sp, #0x1c]
;                                             (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U) - 1U));
700a6164: f642 1158    	movw	r1, #0x2958
700a6168: f2c7 010b    	movt	r1, #0x700b
700a616c: 694a         	ldr	r2, [r1, #0x14]
700a616e: f04f 31ff    	mov.w	r1, #0xffffffff
700a6172: eb01 0192    	add.w	r1, r1, r2, lsr #2
;                 (void) Sciclient_secProxyReadThread32(rxThread,
700a6176: b2c9         	uxtb	r1, r1
700a6178: f008 fc02    	bl	0x700ae980 <Sciclient_secProxyReadThread32> @ imm = #0x8804
;             }
700a617c: e7ff         	b	0x700a617e <Sciclient_waitForMessage+0xbe> @ imm = #-0x2
;             if (timeToWait != 0U)
700a617e: 9802         	ldr	r0, [sp, #0x8]
700a6180: b120         	cbz	r0, 0x700a618c <Sciclient_waitForMessage+0xcc> @ imm = #0x8
700a6182: e7ff         	b	0x700a6184 <Sciclient_waitForMessage+0xc4> @ imm = #-0x2
;                 timeToWait--;
700a6184: 9802         	ldr	r0, [sp, #0x8]
700a6186: 3801         	subs	r0, #0x1
700a6188: 9002         	str	r0, [sp, #0x8]
;             }
700a618a: e003         	b	0x700a6194 <Sciclient_waitForMessage+0xd4> @ imm = #0x6
700a618c: f06f 0001    	mvn	r0, #0x1
;                 status = SystemP_TIMEOUT;
700a6190: 9001         	str	r0, [sp, #0x4]
;                 break;
700a6192: e000         	b	0x700a6196 <Sciclient_waitForMessage+0xd6> @ imm = #0x0
;         while(1)
700a6194: e7ce         	b	0x700a6134 <Sciclient_waitForMessage+0x74> @ imm = #-0x64
;     }
700a6196: e7ff         	b	0x700a6198 <Sciclient_waitForMessage+0xd8> @ imm = #-0x2
;     return status;
700a6198: 9801         	ldr	r0, [sp, #0x4]
700a619a: b008         	add	sp, #0x20
700a619c: bd80         	pop	{r7, pc}
700a619e: 0000         	movs	r0, r0

700a61a0 <UART_intrEnable>:
; {
700a61a0: b580         	push	{r7, lr}
700a61a2: b08a         	sub	sp, #0x28
700a61a4: 9009         	str	r0, [sp, #0x24]
700a61a6: 9108         	str	r1, [sp, #0x20]
700a61a8: 2000         	movs	r0, #0x0
;     uint32_t enhanFnBitVal = 0U;
700a61aa: 9007         	str	r0, [sp, #0x1c]
;     uint32_t lcrRegValue   = 0U;
700a61ac: 9006         	str	r0, [sp, #0x18]
;     if ((intrFlag & 0xF0U) > 0U)
700a61ae: f89d 0020    	ldrb.w	r0, [sp, #0x20]
700a61b2: f010 0ff0    	tst.w	r0, #0xf0
700a61b6: d053         	beq	0x700a6260 <UART_intrEnable+0xc0> @ imm = #0xa6
700a61b8: e7ff         	b	0x700a61ba <UART_intrEnable+0x1a> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a61ba: 9809         	ldr	r0, [sp, #0x24]
700a61bc: 300c         	adds	r0, #0xc
700a61be: f009 fcdf    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x99be
700a61c2: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a61c4: 9809         	ldr	r0, [sp, #0x24]
700a61c6: 300c         	adds	r0, #0xc
700a61c8: 21bf         	movs	r1, #0xbf
700a61ca: 9103         	str	r1, [sp, #0xc]
700a61cc: f009 fce0    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x99c0
;         enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a61d0: 9809         	ldr	r0, [sp, #0x24]
700a61d2: 3008         	adds	r0, #0x8
700a61d4: 2110         	movs	r1, #0x10
700a61d6: 9104         	str	r1, [sp, #0x10]
700a61d8: 2204         	movs	r2, #0x4
700a61da: 9205         	str	r2, [sp, #0x14]
700a61dc: f009 f8b8    	bl	0x700af350 <HW_RD_FIELD32_RAW> @ imm = #0x9170
700a61e0: 9904         	ldr	r1, [sp, #0x10]
700a61e2: 9a05         	ldr	r2, [sp, #0x14]
700a61e4: 9007         	str	r0, [sp, #0x1c]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a61e6: 9809         	ldr	r0, [sp, #0x24]
700a61e8: 3008         	adds	r0, #0x8
700a61ea: 2301         	movs	r3, #0x1
700a61ec: f008 fa68    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x84d0
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a61f0: 9809         	ldr	r0, [sp, #0x24]
700a61f2: 300c         	adds	r0, #0xc
700a61f4: 9906         	ldr	r1, [sp, #0x18]
700a61f6: f009 fccb    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x9996
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a61fa: 9809         	ldr	r0, [sp, #0x24]
700a61fc: 300c         	adds	r0, #0xc
700a61fe: f009 fcbf    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x997e
700a6202: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700a6204: 9809         	ldr	r0, [sp, #0x24]
700a6206: 300c         	adds	r0, #0xc
700a6208: 9002         	str	r0, [sp, #0x8]
700a620a: f009 fcb9    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x9972
700a620e: 4601         	mov	r1, r0
700a6210: 9802         	ldr	r0, [sp, #0x8]
700a6212: f001 017f    	and	r1, r1, #0x7f
700a6216: f009 fcbb    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x9976
;         HW_WR_REG32(baseAddr + UART_IER, intrFlag & 0xF0U);
700a621a: 9809         	ldr	r0, [sp, #0x24]
700a621c: 3004         	adds	r0, #0x4
700a621e: 9908         	ldr	r1, [sp, #0x20]
700a6220: f001 01f0    	and	r1, r1, #0xf0
700a6224: f009 fcb4    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x9968
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a6228: 9809         	ldr	r0, [sp, #0x24]
700a622a: 300c         	adds	r0, #0xc
700a622c: 9906         	ldr	r1, [sp, #0x18]
700a622e: f009 fcaf    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x995e
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a6232: 9809         	ldr	r0, [sp, #0x24]
700a6234: 300c         	adds	r0, #0xc
700a6236: f009 fca3    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x9946
700a623a: 9903         	ldr	r1, [sp, #0xc]
700a623c: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a623e: 9809         	ldr	r0, [sp, #0x24]
700a6240: 300c         	adds	r0, #0xc
700a6242: f009 fca5    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x994a
700a6246: 9904         	ldr	r1, [sp, #0x10]
700a6248: 9a05         	ldr	r2, [sp, #0x14]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a624a: 9809         	ldr	r0, [sp, #0x24]
700a624c: 3008         	adds	r0, #0x8
700a624e: 9b07         	ldr	r3, [sp, #0x1c]
700a6250: f008 fa36    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x846c
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a6254: 9809         	ldr	r0, [sp, #0x24]
700a6256: 300c         	adds	r0, #0xc
700a6258: 9906         	ldr	r1, [sp, #0x18]
700a625a: f009 fc99    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x9932
;     }
700a625e: e7ff         	b	0x700a6260 <UART_intrEnable+0xc0> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_IER, HW_RD_REG32(baseAddr + UART_IER) |
700a6260: 9809         	ldr	r0, [sp, #0x24]
700a6262: 3004         	adds	r0, #0x4
700a6264: 9001         	str	r0, [sp, #0x4]
700a6266: f009 fc8b    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x9916
700a626a: 4601         	mov	r1, r0
700a626c: 9801         	ldr	r0, [sp, #0x4]
700a626e: 9a08         	ldr	r2, [sp, #0x20]
700a6270: f002 020f    	and	r2, r2, #0xf
700a6274: 4311         	orrs	r1, r2
700a6276: f009 fc8b    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x9916
; }
700a627a: b00a         	add	sp, #0x28
700a627c: bd80         	pop	{r7, pc}
700a627e: 0000         	movs	r0, r0

700a6280 <Sciclient_rmIrInpIsFree>:
; {
700a6280: b580         	push	{r7, lr}
700a6282: b086         	sub	sp, #0x18
700a6284: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a6288: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a628c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a628e: 9004         	str	r0, [sp, #0x10]
;     const struct Sciclient_rmIrInst *inst = NULL;
700a6290: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIrGetInst(id);
700a6292: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a6296: f005 fc73    	bl	0x700abb80 <Sciclient_rmIrGetInst> @ imm = #0x58e6
700a629a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a629c: 9803         	ldr	r0, [sp, #0xc]
700a629e: b920         	cbnz	r0, 0x700a62aa <Sciclient_rmIrInpIsFree+0x2a> @ imm = #0x8
700a62a0: e7ff         	b	0x700a62a2 <Sciclient_rmIrInpIsFree+0x22> @ imm = #-0x2
700a62a2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a62a6: 9004         	str	r0, [sp, #0x10]
;     } else {
700a62a8: e00b         	b	0x700a62c2 <Sciclient_rmIrInpIsFree+0x42> @ imm = #0x16
;         if (inp >= inst->n_inp) {
700a62aa: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a62ae: 9903         	ldr	r1, [sp, #0xc]
700a62b0: 8909         	ldrh	r1, [r1, #0x8]
700a62b2: 4288         	cmp	r0, r1
700a62b4: db04         	blt	0x700a62c0 <Sciclient_rmIrInpIsFree+0x40> @ imm = #0x8
700a62b6: e7ff         	b	0x700a62b8 <Sciclient_rmIrInpIsFree+0x38> @ imm = #-0x2
700a62b8: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a62bc: 9004         	str	r0, [sp, #0x10]
;         }
700a62be: e7ff         	b	0x700a62c0 <Sciclient_rmIrInpIsFree+0x40> @ imm = #-0x2
700a62c0: e7ff         	b	0x700a62c2 <Sciclient_rmIrInpIsFree+0x42> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a62c2: 9804         	ldr	r0, [sp, #0x10]
700a62c4: 2800         	cmp	r0, #0x0
700a62c6: d145         	bne	0x700a6354 <Sciclient_rmIrInpIsFree+0xd4> @ imm = #0x8a
700a62c8: e7ff         	b	0x700a62ca <Sciclient_rmIrInpIsFree+0x4a> @ imm = #-0x2
;         if (inp == 0u) {
700a62ca: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a62ce: b960         	cbnz	r0, 0x700a62ea <Sciclient_rmIrInpIsFree+0x6a> @ imm = #0x18
700a62d0: e7ff         	b	0x700a62d2 <Sciclient_rmIrInpIsFree+0x52> @ imm = #-0x2
;             if (inst->inp0_mapping != SCICLIENT_RM_IR_MAPPING_FREE) {
700a62d2: 9803         	ldr	r0, [sp, #0xc]
700a62d4: 8980         	ldrh	r0, [r0, #0xc]
700a62d6: f64f 71ff    	movw	r1, #0xffff
700a62da: 4288         	cmp	r0, r1
700a62dc: d004         	beq	0x700a62e8 <Sciclient_rmIrInpIsFree+0x68> @ imm = #0x8
700a62de: e7ff         	b	0x700a62e0 <Sciclient_rmIrInpIsFree+0x60> @ imm = #-0x2
700a62e0: f04f 30ff    	mov.w	r0, #0xffffffff
;                 r = SystemP_FAILURE;
700a62e4: 9004         	str	r0, [sp, #0x10]
;             }
700a62e6: e7ff         	b	0x700a62e8 <Sciclient_rmIrInpIsFree+0x68> @ imm = #-0x2
;         } else {
700a62e8: e033         	b	0x700a6352 <Sciclient_rmIrInpIsFree+0xd2> @ imm = #0x66
700a62ea: 2000         	movs	r0, #0x0
;             for (i = 0u; i < inst->n_outp; i++) {
700a62ec: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a62f0: e7ff         	b	0x700a62f2 <Sciclient_rmIrInpIsFree+0x72> @ imm = #-0x2
700a62f2: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a62f6: 9903         	ldr	r1, [sp, #0xc]
700a62f8: 8949         	ldrh	r1, [r1, #0xa]
700a62fa: 4288         	cmp	r0, r1
700a62fc: da28         	bge	0x700a6350 <Sciclient_rmIrInpIsFree+0xd0> @ imm = #0x50
700a62fe: e7ff         	b	0x700a6300 <Sciclient_rmIrInpIsFree+0x80> @ imm = #-0x2
;                 int_ctrl_reg = (volatile uint32_t *)Sciclient_getIrAddr(inst->cfg, i);
700a6300: 9803         	ldr	r0, [sp, #0xc]
700a6302: 6840         	ldr	r0, [r0, #0x4]
700a6304: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700a6308: f008 fc5a    	bl	0x700aebc0 <Sciclient_getIrAddr> @ imm = #0x88b4
700a630c: 9001         	str	r0, [sp, #0x4]
;                 extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a630e: 9801         	ldr	r0, [sp, #0x4]
700a6310: f240 31ff    	movw	r1, #0x3ff
700a6314: 2200         	movs	r2, #0x0
700a6316: f008 ff23    	bl	0x700af160 <CSL_REG32_FEXT_RAW> @ imm = #0x8e46
700a631a: f8ad 0002    	strh.w	r0, [sp, #0x2]
;                 if ((extracted_inp == inp) &&
700a631e: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a6322: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a6326: 4288         	cmp	r0, r1
700a6328: d10b         	bne	0x700a6342 <Sciclient_rmIrInpIsFree+0xc2> @ imm = #0x16
700a632a: e7ff         	b	0x700a632c <Sciclient_rmIrInpIsFree+0xac> @ imm = #-0x2
;                     (Sciclient_rmIrInpRomMapped(inst, inp) == false)) {
700a632c: 9803         	ldr	r0, [sp, #0xc]
700a632e: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a6332: f002 f81d    	bl	0x700a8370 <Sciclient_rmIrInpRomMapped> @ imm = #0x203a
;                 if ((extracted_inp == inp) &&
700a6336: b920         	cbnz	r0, 0x700a6342 <Sciclient_rmIrInpIsFree+0xc2> @ imm = #0x8
700a6338: e7ff         	b	0x700a633a <Sciclient_rmIrInpIsFree+0xba> @ imm = #-0x2
700a633a: f04f 30ff    	mov.w	r0, #0xffffffff
;                     r = SystemP_FAILURE;
700a633e: 9004         	str	r0, [sp, #0x10]
;                     break;
700a6340: e006         	b	0x700a6350 <Sciclient_rmIrInpIsFree+0xd0> @ imm = #0xc
;             }
700a6342: e7ff         	b	0x700a6344 <Sciclient_rmIrInpIsFree+0xc4> @ imm = #-0x2
;             for (i = 0u; i < inst->n_outp; i++) {
700a6344: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a6348: 3001         	adds	r0, #0x1
700a634a: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a634e: e7d0         	b	0x700a62f2 <Sciclient_rmIrInpIsFree+0x72> @ imm = #-0x60
700a6350: e7ff         	b	0x700a6352 <Sciclient_rmIrInpIsFree+0xd2> @ imm = #-0x2
;     }
700a6352: e7ff         	b	0x700a6354 <Sciclient_rmIrInpIsFree+0xd4> @ imm = #-0x2
;     return r;
700a6354: 9804         	ldr	r0, [sp, #0x10]
700a6356: b006         	add	sp, #0x18
700a6358: bd80         	pop	{r7, pc}
700a635a: 0000         	movs	r0, r0
700a635c: 0000         	movs	r0, r0
700a635e: 0000         	movs	r0, r0

700a6360 <UART_intrDisable>:
; {
700a6360: b580         	push	{r7, lr}
700a6362: b088         	sub	sp, #0x20
700a6364: 9007         	str	r0, [sp, #0x1c]
700a6366: 9106         	str	r1, [sp, #0x18]
;     if((intrFlag & 0xF0U) > 0U)
700a6368: f89d 0018    	ldrb.w	r0, [sp, #0x18]
700a636c: f010 0ff0    	tst.w	r0, #0xf0
700a6370: d020         	beq	0x700a63b4 <UART_intrDisable+0x54> @ imm = #0x40
700a6372: e7ff         	b	0x700a6374 <UART_intrDisable+0x14> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a6374: 9807         	ldr	r0, [sp, #0x1c]
700a6376: 300c         	adds	r0, #0xc
700a6378: f009 fc02    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x9804
700a637c: 9004         	str	r0, [sp, #0x10]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a637e: 9807         	ldr	r0, [sp, #0x1c]
700a6380: 300c         	adds	r0, #0xc
700a6382: 21bf         	movs	r1, #0xbf
700a6384: f009 fc04    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x9808
;         enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a6388: 9807         	ldr	r0, [sp, #0x1c]
700a638a: 3008         	adds	r0, #0x8
700a638c: 2110         	movs	r1, #0x10
700a638e: 9102         	str	r1, [sp, #0x8]
700a6390: 2204         	movs	r2, #0x4
700a6392: 9203         	str	r2, [sp, #0xc]
700a6394: f008 ffdc    	bl	0x700af350 <HW_RD_FIELD32_RAW> @ imm = #0x8fb8
700a6398: 9902         	ldr	r1, [sp, #0x8]
700a639a: 9a03         	ldr	r2, [sp, #0xc]
700a639c: 9005         	str	r0, [sp, #0x14]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a639e: 9807         	ldr	r0, [sp, #0x1c]
700a63a0: 3008         	adds	r0, #0x8
700a63a2: 2301         	movs	r3, #0x1
700a63a4: f008 f98c    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x8318
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a63a8: 9807         	ldr	r0, [sp, #0x1c]
700a63aa: 300c         	adds	r0, #0xc
700a63ac: 9904         	ldr	r1, [sp, #0x10]
700a63ae: f009 fbef    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x97de
;     }
700a63b2: e7ff         	b	0x700a63b4 <UART_intrDisable+0x54> @ imm = #-0x2
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a63b4: 9807         	ldr	r0, [sp, #0x1c]
700a63b6: 300c         	adds	r0, #0xc
700a63b8: f009 fbe2    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x97c4
700a63bc: 9004         	str	r0, [sp, #0x10]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700a63be: 9807         	ldr	r0, [sp, #0x1c]
700a63c0: 300c         	adds	r0, #0xc
700a63c2: 9000         	str	r0, [sp]
700a63c4: f009 fbdc    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x97b8
700a63c8: 4601         	mov	r1, r0
700a63ca: 9800         	ldr	r0, [sp]
700a63cc: f001 017f    	and	r1, r1, #0x7f
700a63d0: f009 fbde    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x97bc
;     HW_WR_REG32(baseAddr + UART_IER, HW_RD_REG32(baseAddr + UART_IER) &
700a63d4: 9807         	ldr	r0, [sp, #0x1c]
700a63d6: 3004         	adds	r0, #0x4
700a63d8: 9001         	str	r0, [sp, #0x4]
700a63da: f009 fbd1    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x97a2
700a63de: 4601         	mov	r1, r0
700a63e0: 9801         	ldr	r0, [sp, #0x4]
700a63e2: 9b06         	ldr	r3, [sp, #0x18]
700a63e4: f06f 02ff    	mvn	r2, #0xff
700a63e8: ea62 0203    	orn	r2, r2, r3
700a63ec: 4011         	ands	r1, r2
700a63ee: f009 fbcf    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x979e
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a63f2: 9807         	ldr	r0, [sp, #0x1c]
700a63f4: 300c         	adds	r0, #0xc
700a63f6: 9904         	ldr	r1, [sp, #0x10]
700a63f8: f009 fbca    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x9794
;     if((intrFlag & 0xF0U) > 0U)
700a63fc: f89d 0018    	ldrb.w	r0, [sp, #0x18]
700a6400: f010 0ff0    	tst.w	r0, #0xf0
700a6404: d017         	beq	0x700a6436 <UART_intrDisable+0xd6> @ imm = #0x2e
700a6406: e7ff         	b	0x700a6408 <UART_intrDisable+0xa8> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a6408: 9807         	ldr	r0, [sp, #0x1c]
700a640a: 300c         	adds	r0, #0xc
700a640c: f009 fbb8    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x9770
700a6410: 9004         	str	r0, [sp, #0x10]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a6412: 9807         	ldr	r0, [sp, #0x1c]
700a6414: 300c         	adds	r0, #0xc
700a6416: 21bf         	movs	r1, #0xbf
700a6418: f009 fbba    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x9774
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a641c: 9807         	ldr	r0, [sp, #0x1c]
700a641e: 3008         	adds	r0, #0x8
700a6420: 9b05         	ldr	r3, [sp, #0x14]
700a6422: 2110         	movs	r1, #0x10
700a6424: 2204         	movs	r2, #0x4
700a6426: f008 f94b    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x8296
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a642a: 9807         	ldr	r0, [sp, #0x1c]
700a642c: 300c         	adds	r0, #0xc
700a642e: 9904         	ldr	r1, [sp, #0x10]
700a6430: f009 fbae    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x975c
;     }
700a6434: e7ff         	b	0x700a6436 <UART_intrDisable+0xd6> @ imm = #-0x2
; }
700a6436: b008         	add	sp, #0x20
700a6438: bd80         	pop	{r7, pc}
700a643a: 0000         	movs	r0, r0
700a643c: 0000         	movs	r0, r0
700a643e: 0000         	movs	r0, r0

700a6440 <UART_udmaConfigPdmaTx>:
; {
700a6440: b580         	push	{r7, lr}
700a6442: b090         	sub	sp, #0x40
700a6444: 900f         	str	r0, [sp, #0x3c]
700a6446: 910e         	str	r1, [sp, #0x38]
;     udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a6448: 980f         	ldr	r0, [sp, #0x3c]
700a644a: 6840         	ldr	r0, [r0, #0x4]
700a644c: 6cc0         	ldr	r0, [r0, #0x4c]
700a644e: 9008         	str	r0, [sp, #0x20]
;     txChHandle  = udmaChCfg->txChHandle;
700a6450: 9808         	ldr	r0, [sp, #0x20]
700a6452: 6840         	ldr	r0, [r0, #0x4]
700a6454: 9009         	str	r0, [sp, #0x24]
700a6456: a80a         	add	r0, sp, #0x28
;     UdmaChPdmaPrms_init(&pdmaPrms);
700a6458: 9002         	str	r0, [sp, #0x8]
700a645a: f009 f839    	bl	0x700af4d0 <UdmaChPdmaPrms_init> @ imm = #0x9072
700a645e: 9902         	ldr	r1, [sp, #0x8]
700a6460: 2000         	movs	r0, #0x0
;     pdmaPrms.elemSize = UDMA_PDMA_ES_8BITS;
700a6462: 9003         	str	r0, [sp, #0xc]
700a6464: 900a         	str	r0, [sp, #0x28]
700a6466: 2201         	movs	r2, #0x1
;     pdmaPrms.elemCnt  = 1U;
700a6468: 920b         	str	r2, [sp, #0x2c]
;     pdmaPrms.fifoCnt  = 0U;
700a646a: 900c         	str	r0, [sp, #0x30]
;     retVal = Udma_chConfigPdma(txChHandle, &pdmaPrms);
700a646c: 9809         	ldr	r0, [sp, #0x24]
700a646e: f7fa ff47    	bl	0x700a1300 <Udma_chConfigPdma> @ imm = #-0x5172
700a6472: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a6474: 980d         	ldr	r0, [sp, #0x34]
700a6476: fab0 f080    	clz	r0, r0
700a647a: 0940         	lsrs	r0, r0, #0x5
700a647c: f641 716f    	movw	r1, #0x1f6f
700a6480: f2c7 010b    	movt	r1, #0x700b
700a6484: 9105         	str	r1, [sp, #0x14]
700a6486: 466a         	mov	r2, sp
700a6488: 6011         	str	r1, [r2]
700a648a: f641 316c    	movw	r1, #0x1b6c
700a648e: f2c7 010b    	movt	r1, #0x700b
700a6492: 9106         	str	r1, [sp, #0x18]
700a6494: f641 7232    	movw	r2, #0x1f32
700a6498: f2c7 020b    	movt	r2, #0x700b
700a649c: 9207         	str	r2, [sp, #0x1c]
700a649e: 23ee         	movs	r3, #0xee
700a64a0: f004 fbf6    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x47ec
;     retVal = Udma_chEnable(txChHandle);
700a64a4: 9809         	ldr	r0, [sp, #0x24]
700a64a6: f004 feb3    	bl	0x700ab210 <Udma_chEnable> @ imm = #0x4d66
700a64aa: 9b05         	ldr	r3, [sp, #0x14]
700a64ac: 9906         	ldr	r1, [sp, #0x18]
700a64ae: 9a07         	ldr	r2, [sp, #0x1c]
700a64b0: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a64b2: 980d         	ldr	r0, [sp, #0x34]
700a64b4: fab0 f080    	clz	r0, r0
700a64b8: 0940         	lsrs	r0, r0, #0x5
700a64ba: 46ec         	mov	r12, sp
700a64bc: f8cc 3000    	str.w	r3, [r12]
700a64c0: 23f1         	movs	r3, #0xf1
700a64c2: f004 fbe5    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x47ca
;     UART_udmaHpdInit(txChHandle, (uint8_t *) udmaChCfg->txHpdMem, hUart->writeBuf, transaction->count);
700a64c6: 9809         	ldr	r0, [sp, #0x24]
700a64c8: 9908         	ldr	r1, [sp, #0x20]
700a64ca: 6949         	ldr	r1, [r1, #0x14]
700a64cc: 9a0f         	ldr	r2, [sp, #0x3c]
700a64ce: 6892         	ldr	r2, [r2, #0x8]
700a64d0: 9b0e         	ldr	r3, [sp, #0x38]
700a64d2: 685b         	ldr	r3, [r3, #0x4]
700a64d4: f000 fd3c    	bl	0x700a6f50 <UART_udmaHpdInit> @ imm = #0xa78
;                  Udma_chGetFqRingHandle(txChHandle),
700a64d8: 9809         	ldr	r0, [sp, #0x24]
700a64da: f004 fdd9    	bl	0x700ab090 <Udma_chGetFqRingHandle> @ imm = #0x4bb2
700a64de: 9a03         	ldr	r2, [sp, #0xc]
;                  (uint64_t) Udma_defaultVirtToPhyFxn(udmaChCfg->txHpdMem, 0U, NULL));
700a64e0: 9004         	str	r0, [sp, #0x10]
700a64e2: 9808         	ldr	r0, [sp, #0x20]
700a64e4: 6940         	ldr	r0, [r0, #0x14]
700a64e6: 4611         	mov	r1, r2
700a64e8: f009 fb5a    	bl	0x700afba0 <Udma_defaultVirtToPhyFxn> @ imm = #0x96b4
700a64ec: 4602         	mov	r2, r0
700a64ee: 9804         	ldr	r0, [sp, #0x10]
700a64f0: 460b         	mov	r3, r1
;     retVal = Udma_ringQueueRaw(
700a64f2: f002 fe75    	bl	0x700a91e0 <Udma_ringQueueRaw> @ imm = #0x2cea
700a64f6: 9b05         	ldr	r3, [sp, #0x14]
700a64f8: 9906         	ldr	r1, [sp, #0x18]
700a64fa: 9a07         	ldr	r2, [sp, #0x1c]
700a64fc: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a64fe: 980d         	ldr	r0, [sp, #0x34]
700a6500: fab0 f080    	clz	r0, r0
700a6504: 0940         	lsrs	r0, r0, #0x5
700a6506: 46ec         	mov	r12, sp
700a6508: f8cc 3000    	str.w	r3, [r12]
700a650c: 23f9         	movs	r3, #0xf9
700a650e: f004 fbbf    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x477e
;     return (retVal);
700a6512: 980d         	ldr	r0, [sp, #0x34]
700a6514: b010         	add	sp, #0x40
700a6516: bd80         	pop	{r7, pc}
		...

700a6520 <vTaskDelete>:
; void vTaskDelete(TaskHandle_t xTaskToDelete) {
700a6520: b580         	push	{r7, lr}
700a6522: b084         	sub	sp, #0x10
700a6524: 9003         	str	r0, [sp, #0xc]
;   taskENTER_CRITICAL();
700a6526: f008 f92b    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0x8256
;     pxTCB = prvGetTCBFromHandle(xTaskToDelete);
700a652a: 9803         	ldr	r0, [sp, #0xc]
700a652c: b938         	cbnz	r0, 0x700a653e <vTaskDelete+0x1e> @ imm = #0xe
700a652e: e7ff         	b	0x700a6530 <vTaskDelete+0x10> @ imm = #-0x2
700a6530: f642 200c    	movw	r0, #0x2a0c
700a6534: f2c7 000b    	movt	r0, #0x700b
700a6538: 6800         	ldr	r0, [r0]
700a653a: 9001         	str	r0, [sp, #0x4]
700a653c: e002         	b	0x700a6544 <vTaskDelete+0x24> @ imm = #0x4
700a653e: 9803         	ldr	r0, [sp, #0xc]
700a6540: 9001         	str	r0, [sp, #0x4]
700a6542: e7ff         	b	0x700a6544 <vTaskDelete+0x24> @ imm = #-0x2
700a6544: 9801         	ldr	r0, [sp, #0x4]
700a6546: 9002         	str	r0, [sp, #0x8]
;     if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a6548: 9802         	ldr	r0, [sp, #0x8]
700a654a: 3004         	adds	r0, #0x4
700a654c: f007 f8e8    	bl	0x700ad720 <uxListRemove> @ imm = #0x71d0
700a6550: b908         	cbnz	r0, 0x700a6556 <vTaskDelete+0x36> @ imm = #0x2
700a6552: e7ff         	b	0x700a6554 <vTaskDelete+0x34> @ imm = #-0x2
;     } else {
700a6554: e000         	b	0x700a6558 <vTaskDelete+0x38> @ imm = #0x0
700a6556: e7ff         	b	0x700a6558 <vTaskDelete+0x38> @ imm = #-0x2
;     if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a6558: 9802         	ldr	r0, [sp, #0x8]
700a655a: 6a80         	ldr	r0, [r0, #0x28]
700a655c: b128         	cbz	r0, 0x700a656a <vTaskDelete+0x4a> @ imm = #0xa
700a655e: e7ff         	b	0x700a6560 <vTaskDelete+0x40> @ imm = #-0x2
;       (void)uxListRemove(&(pxTCB->xEventListItem));
700a6560: 9802         	ldr	r0, [sp, #0x8]
700a6562: 3018         	adds	r0, #0x18
700a6564: f007 f8dc    	bl	0x700ad720 <uxListRemove> @ imm = #0x71b8
;     } else {
700a6568: e000         	b	0x700a656c <vTaskDelete+0x4c> @ imm = #0x0
700a656a: e7ff         	b	0x700a656c <vTaskDelete+0x4c> @ imm = #-0x2
;     uxTaskNumber++;
700a656c: f642 2138    	movw	r1, #0x2a38
700a6570: f2c7 010b    	movt	r1, #0x700b
700a6574: 6808         	ldr	r0, [r1]
700a6576: 3001         	adds	r0, #0x1
700a6578: 6008         	str	r0, [r1]
;     if (pxTCB == pxCurrentTCB) {
700a657a: 9802         	ldr	r0, [sp, #0x8]
700a657c: f642 210c    	movw	r1, #0x2a0c
700a6580: f2c7 010b    	movt	r1, #0x700b
700a6584: 6809         	ldr	r1, [r1]
700a6586: 4288         	cmp	r0, r1
700a6588: d110         	bne	0x700a65ac <vTaskDelete+0x8c> @ imm = #0x20
700a658a: e7ff         	b	0x700a658c <vTaskDelete+0x6c> @ imm = #-0x2
;       vListInsertEnd(&xTasksWaitingTermination, &(pxTCB->xStateListItem));
700a658c: 9802         	ldr	r0, [sp, #0x8]
700a658e: 1d01         	adds	r1, r0, #0x4
700a6590: f245 2088    	movw	r0, #0x5288
700a6594: f2c7 0008    	movt	r0, #0x7008
700a6598: f007 fe7a    	bl	0x700ae290 <vListInsertEnd> @ imm = #0x7cf4
;       ++uxDeletedTasksWaitingCleanUp;
700a659c: f642 2130    	movw	r1, #0x2a30
700a65a0: f2c7 010b    	movt	r1, #0x700b
700a65a4: 6808         	ldr	r0, [r1]
700a65a6: 3001         	adds	r0, #0x1
700a65a8: 6008         	str	r0, [r1]
;     } else {
700a65aa: e00c         	b	0x700a65c6 <vTaskDelete+0xa6> @ imm = #0x18
;       --uxCurrentNumberOfTasks;
700a65ac: f642 212c    	movw	r1, #0x2a2c
700a65b0: f2c7 010b    	movt	r1, #0x700b
700a65b4: 6808         	ldr	r0, [r1]
700a65b6: 3801         	subs	r0, #0x1
700a65b8: 6008         	str	r0, [r1]
;       prvDeleteTCB(pxTCB);
700a65ba: 9802         	ldr	r0, [sp, #0x8]
700a65bc: f007 fdc8    	bl	0x700ae150 <prvDeleteTCB> @ imm = #0x7b90
;       prvResetNextTaskUnblockTime();
700a65c0: f007 fde6    	bl	0x700ae190 <prvResetNextTaskUnblockTime> @ imm = #0x7bcc
700a65c4: e7ff         	b	0x700a65c6 <vTaskDelete+0xa6> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a65c6: f007 f99b    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0x7336
;   if (xSchedulerRunning != pdFALSE) {
700a65ca: f642 2050    	movw	r0, #0x2a50
700a65ce: f2c7 000b    	movt	r0, #0x700b
700a65d2: 6800         	ldr	r0, [r0]
700a65d4: b168         	cbz	r0, 0x700a65f2 <vTaskDelete+0xd2> @ imm = #0x1a
700a65d6: e7ff         	b	0x700a65d8 <vTaskDelete+0xb8> @ imm = #-0x2
;     if (pxTCB == pxCurrentTCB) {
700a65d8: 9802         	ldr	r0, [sp, #0x8]
700a65da: f642 210c    	movw	r1, #0x2a0c
700a65de: f2c7 010b    	movt	r1, #0x700b
700a65e2: 6809         	ldr	r1, [r1]
700a65e4: 4288         	cmp	r0, r1
700a65e6: d102         	bne	0x700a65ee <vTaskDelete+0xce> @ imm = #0x4
700a65e8: e7ff         	b	0x700a65ea <vTaskDelete+0xca> @ imm = #-0x2
;       portYIELD_WITHIN_API();
700a65ea: df00         	svc	#0x0
;     } else {
700a65ec: e000         	b	0x700a65f0 <vTaskDelete+0xd0> @ imm = #0x0
700a65ee: e7ff         	b	0x700a65f0 <vTaskDelete+0xd0> @ imm = #-0x2
;   }
700a65f0: e7ff         	b	0x700a65f2 <vTaskDelete+0xd2> @ imm = #-0x2
; }
700a65f2: b004         	add	sp, #0x10
700a65f4: bd80         	pop	{r7, pc}
		...
700a65fe: 0000         	movs	r0, r0

700a6600 <CSL_bcdmaChanOpGetChanRT>:
; {
700a6600: b580         	push	{r7, lr}
700a6602: b088         	sub	sp, #0x20
700a6604: 9007         	str	r0, [sp, #0x1c]
700a6606: 9106         	str	r1, [sp, #0x18]
700a6608: 9205         	str	r2, [sp, #0x14]
700a660a: 9304         	str	r3, [sp, #0x10]
700a660c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a660e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a6610: 9804         	ldr	r0, [sp, #0x10]
700a6612: b920         	cbnz	r0, 0x700a661e <CSL_bcdmaChanOpGetChanRT+0x1e> @ imm = #0x8
700a6614: e7ff         	b	0x700a6616 <CSL_bcdmaChanOpGetChanRT+0x16> @ imm = #-0x2
700a6616: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a661a: 9003         	str	r0, [sp, #0xc]
;     }
700a661c: e057         	b	0x700a66ce <CSL_bcdmaChanOpGetChanRT+0xce> @ imm = #0xae
;         switch( chanType )
700a661e: 9806         	ldr	r0, [sp, #0x18]
700a6620: 9000         	str	r0, [sp]
700a6622: b140         	cbz	r0, 0x700a6636 <CSL_bcdmaChanOpGetChanRT+0x36> @ imm = #0x10
700a6624: e7ff         	b	0x700a6626 <CSL_bcdmaChanOpGetChanRT+0x26> @ imm = #-0x2
700a6626: 9800         	ldr	r0, [sp]
700a6628: 2801         	cmp	r0, #0x1
700a662a: d00d         	beq	0x700a6648 <CSL_bcdmaChanOpGetChanRT+0x48> @ imm = #0x1a
700a662c: e7ff         	b	0x700a662e <CSL_bcdmaChanOpGetChanRT+0x2e> @ imm = #-0x2
700a662e: 9800         	ldr	r0, [sp]
700a6630: 2802         	cmp	r0, #0x2
700a6632: d012         	beq	0x700a665a <CSL_bcdmaChanOpGetChanRT+0x5a> @ imm = #0x24
700a6634: e01a         	b	0x700a666c <CSL_bcdmaChanOpGetChanRT+0x6c> @ imm = #0x34
;                 val = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL );
700a6636: 9807         	ldr	r0, [sp, #0x1c]
700a6638: 6880         	ldr	r0, [r0, #0x8]
700a663a: 9905         	ldr	r1, [sp, #0x14]
700a663c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6640: f009 fae6    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0x95cc
700a6644: 9002         	str	r0, [sp, #0x8]
;                 break;
700a6646: e015         	b	0x700a6674 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x2a
;                 val = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a6648: 9807         	ldr	r0, [sp, #0x1c]
700a664a: 6900         	ldr	r0, [r0, #0x10]
700a664c: 9905         	ldr	r1, [sp, #0x14]
700a664e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6652: f009 fadd    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0x95ba
700a6656: 9002         	str	r0, [sp, #0x8]
;                 break;
700a6658: e00c         	b	0x700a6674 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x18
;                 val = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a665a: 9807         	ldr	r0, [sp, #0x1c]
700a665c: 6980         	ldr	r0, [r0, #0x18]
700a665e: 9905         	ldr	r1, [sp, #0x14]
700a6660: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6664: f009 fad4    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0x95a8
700a6668: 9002         	str	r0, [sp, #0x8]
;                 break;
700a666a: e003         	b	0x700a6674 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x6
700a666c: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a6670: 9003         	str	r0, [sp, #0xc]
;                 break;
700a6672: e7ff         	b	0x700a6674 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #-0x2
;         if( retVal == CSL_PASS )
700a6674: 9803         	ldr	r0, [sp, #0xc]
700a6676: bb48         	cbnz	r0, 0x700a66cc <CSL_bcdmaChanOpGetChanRT+0xcc> @ imm = #0x52
700a6678: e7ff         	b	0x700a667a <CSL_bcdmaChanOpGetChanRT+0x7a> @ imm = #-0x2
;             CSL_BcdmaRT *pRT = (CSL_BcdmaRT *)pOpData;
700a667a: 9804         	ldr	r0, [sp, #0x10]
700a667c: 9001         	str	r0, [sp, #0x4]
;             pRT->enable         = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_EN );
700a667e: 9802         	ldr	r0, [sp, #0x8]
700a6680: 0fc0         	lsrs	r0, r0, #0x1f
700a6682: 9901         	ldr	r1, [sp, #0x4]
700a6684: 6008         	str	r0, [r1]
;             pRT->teardown       = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_TDOWN );
700a6686: 9802         	ldr	r0, [sp, #0x8]
700a6688: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700a668c: 9901         	ldr	r1, [sp, #0x4]
700a668e: 6048         	str	r0, [r1, #0x4]
;             pRT->forcedTeardown = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_FTDOWN );
700a6690: 9802         	ldr	r0, [sp, #0x8]
700a6692: f3c0 7000    	ubfx	r0, r0, #0x1c, #0x1
700a6696: 9901         	ldr	r1, [sp, #0x4]
700a6698: 6108         	str	r0, [r1, #0x10]
;             pRT->pause          = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_PAUSE );
700a669a: 9802         	ldr	r0, [sp, #0x8]
700a669c: f3c0 7040    	ubfx	r0, r0, #0x1d, #0x1
700a66a0: 9901         	ldr	r1, [sp, #0x4]
700a66a2: 6088         	str	r0, [r1, #0x8]
;             pRT->error          = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_ERROR );
700a66a4: 9802         	ldr	r0, [sp, #0x8]
700a66a6: f000 0001    	and	r0, r0, #0x1
700a66aa: 9901         	ldr	r1, [sp, #0x4]
700a66ac: 60c8         	str	r0, [r1, #0xc]
;             if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700a66ae: 9806         	ldr	r0, [sp, #0x18]
700a66b0: 2802         	cmp	r0, #0x2
700a66b2: d106         	bne	0x700a66c2 <CSL_bcdmaChanOpGetChanRT+0xc2> @ imm = #0xc
700a66b4: e7ff         	b	0x700a66b6 <CSL_bcdmaChanOpGetChanRT+0xb6> @ imm = #-0x2
;                 pRT->starvation = CSL_FEXT( val, BCDMA_RXCRT_CHAN_CTL_STARVATION );
700a66b6: 9802         	ldr	r0, [sp, #0x8]
700a66b8: f3c0 0040    	ubfx	r0, r0, #0x1, #0x1
700a66bc: 9901         	ldr	r1, [sp, #0x4]
700a66be: 6148         	str	r0, [r1, #0x14]
;             }
700a66c0: e003         	b	0x700a66ca <CSL_bcdmaChanOpGetChanRT+0xca> @ imm = #0x6
;                 pRT->starvation = (uint32_t)0U;
700a66c2: 9901         	ldr	r1, [sp, #0x4]
700a66c4: 2000         	movs	r0, #0x0
700a66c6: 6148         	str	r0, [r1, #0x14]
700a66c8: e7ff         	b	0x700a66ca <CSL_bcdmaChanOpGetChanRT+0xca> @ imm = #-0x2
;         }
700a66ca: e7ff         	b	0x700a66cc <CSL_bcdmaChanOpGetChanRT+0xcc> @ imm = #-0x2
700a66cc: e7ff         	b	0x700a66ce <CSL_bcdmaChanOpGetChanRT+0xce> @ imm = #-0x2
;     return retVal;
700a66ce: 9803         	ldr	r0, [sp, #0xc]
700a66d0: b008         	add	sp, #0x20
700a66d2: bd80         	pop	{r7, pc}
		...

700a66e0 <Pinmux_unlockMMR>:
; {
700a66e0: b580         	push	{r7, lr}
700a66e2: b088         	sub	sp, #0x20
700a66e4: 9007         	str	r0, [sp, #0x1c]
;     if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a66e6: 9807         	ldr	r0, [sp, #0x1c]
700a66e8: bb78         	cbnz	r0, 0x700a674a <Pinmux_unlockMMR+0x6a> @ imm = #0x5e
700a66ea: e7ff         	b	0x700a66ec <Pinmux_unlockMMR+0xc> @ imm = #-0x2
700a66ec: f44f 2070    	mov.w	r0, #0xf0000
700a66f0: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_PADCFG_CTRL0_CFG0_BASE);
700a66f2: f7ff fa95    	bl	0x700a5c20 <AddrTranslateP_getLocalAddr> @ imm = #-0xad6
700a66f6: 9006         	str	r0, [sp, #0x18]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_PADCONFIG_LOCK0_KICK0_OFFSET);
700a66f8: 9806         	ldr	r0, [sp, #0x18]
700a66fa: f241 0108    	movw	r1, #0x1008
700a66fe: 4408         	add	r0, r1
700a6700: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a6702: 9805         	ldr	r0, [sp, #0x14]
700a6704: f243 4190    	movw	r1, #0x3490
700a6708: f6c6 01ef    	movt	r1, #0x68ef
700a670c: 9103         	str	r1, [sp, #0xc]
700a670e: f009 f9ef    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0x93de
;         kickAddr++;
700a6712: 9805         	ldr	r0, [sp, #0x14]
700a6714: 3004         	adds	r0, #0x4
700a6716: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a6718: 9805         	ldr	r0, [sp, #0x14]
700a671a: f64b 415a    	movw	r1, #0xbc5a
700a671e: f2cd 1172    	movt	r1, #0xd172
700a6722: 9104         	str	r1, [sp, #0x10]
700a6724: f009 f9e4    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0x93c8
700a6728: 9903         	ldr	r1, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_PADCONFIG_LOCK1_KICK0_OFFSET);
700a672a: 9806         	ldr	r0, [sp, #0x18]
700a672c: f245 0208    	movw	r2, #0x5008
700a6730: 4410         	add	r0, r2
700a6732: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a6734: 9805         	ldr	r0, [sp, #0x14]
700a6736: f009 f9db    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0x93b6
700a673a: 9904         	ldr	r1, [sp, #0x10]
;         kickAddr++;
700a673c: 9805         	ldr	r0, [sp, #0x14]
700a673e: 3004         	adds	r0, #0x4
700a6740: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a6742: 9805         	ldr	r0, [sp, #0x14]
700a6744: f009 f9d4    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0x93a8
;     }
700a6748: e7ff         	b	0x700a674a <Pinmux_unlockMMR+0x6a> @ imm = #-0x2
;     if(PINMUX_DOMAIN_ID_MCU == domainId)
700a674a: 9807         	ldr	r0, [sp, #0x1c]
700a674c: 2801         	cmp	r0, #0x1
700a674e: d12f         	bne	0x700a67b0 <Pinmux_unlockMMR+0xd0> @ imm = #0x5e
700a6750: e7ff         	b	0x700a6752 <Pinmux_unlockMMR+0x72> @ imm = #-0x2
700a6752: f04f 6081    	mov.w	r0, #0x4080000
700a6756: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_PADCFG_CTRL0_CFG0_BASE);
700a6758: f7ff fa62    	bl	0x700a5c20 <AddrTranslateP_getLocalAddr> @ imm = #-0xb3c
700a675c: 9006         	str	r0, [sp, #0x18]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK0_KICK0_OFFSET);
700a675e: 9806         	ldr	r0, [sp, #0x18]
700a6760: f241 0108    	movw	r1, #0x1008
700a6764: 4408         	add	r0, r1
700a6766: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a6768: 9805         	ldr	r0, [sp, #0x14]
700a676a: f243 4190    	movw	r1, #0x3490
700a676e: f6c6 01ef    	movt	r1, #0x68ef
700a6772: 9101         	str	r1, [sp, #0x4]
700a6774: f009 f9bc    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0x9378
;         kickAddr++;
700a6778: 9805         	ldr	r0, [sp, #0x14]
700a677a: 3004         	adds	r0, #0x4
700a677c: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a677e: 9805         	ldr	r0, [sp, #0x14]
700a6780: f64b 415a    	movw	r1, #0xbc5a
700a6784: f2cd 1172    	movt	r1, #0xd172
700a6788: 9102         	str	r1, [sp, #0x8]
700a678a: f009 f9b1    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0x9362
700a678e: 9901         	ldr	r1, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK1_KICK0_OFFSET);
700a6790: 9806         	ldr	r0, [sp, #0x18]
700a6792: f245 0208    	movw	r2, #0x5008
700a6796: 4410         	add	r0, r2
700a6798: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a679a: 9805         	ldr	r0, [sp, #0x14]
700a679c: f009 f9a8    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0x9350
700a67a0: 9902         	ldr	r1, [sp, #0x8]
;         kickAddr++;
700a67a2: 9805         	ldr	r0, [sp, #0x14]
700a67a4: 3004         	adds	r0, #0x4
700a67a6: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a67a8: 9805         	ldr	r0, [sp, #0x14]
700a67aa: f009 f9a1    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0x9342
;     }
700a67ae: e7ff         	b	0x700a67b0 <Pinmux_unlockMMR+0xd0> @ imm = #-0x2
;     return;
700a67b0: b008         	add	sp, #0x20
700a67b2: bd80         	pop	{r7, pc}
		...

700a67c0 <prvAddCurrentTaskToDelayedList>:
;                                const BaseType_t xCanBlockIndefinitely) {
700a67c0: b580         	push	{r7, lr}
700a67c2: b084         	sub	sp, #0x10
700a67c4: 9003         	str	r0, [sp, #0xc]
700a67c6: 9102         	str	r1, [sp, #0x8]
;   const TickType_t xConstTickCount = xTickCount;
700a67c8: f642 2054    	movw	r0, #0x2a54
700a67cc: f2c7 000b    	movt	r0, #0x700b
700a67d0: 6800         	ldr	r0, [r0]
700a67d2: 9000         	str	r0, [sp]
;   if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
700a67d4: f642 200c    	movw	r0, #0x2a0c
700a67d8: f2c7 000b    	movt	r0, #0x700b
700a67dc: 6800         	ldr	r0, [r0]
700a67de: 3004         	adds	r0, #0x4
700a67e0: f006 ff9e    	bl	0x700ad720 <uxListRemove> @ imm = #0x6f3c
700a67e4: b908         	cbnz	r0, 0x700a67ea <prvAddCurrentTaskToDelayedList+0x2a> @ imm = #0x2
700a67e6: e7ff         	b	0x700a67e8 <prvAddCurrentTaskToDelayedList+0x28> @ imm = #-0x2
;   } else {
700a67e8: e000         	b	0x700a67ec <prvAddCurrentTaskToDelayedList+0x2c> @ imm = #0x0
700a67ea: e7ff         	b	0x700a67ec <prvAddCurrentTaskToDelayedList+0x2c> @ imm = #-0x2
;     if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
700a67ec: 9803         	ldr	r0, [sp, #0xc]
700a67ee: 3001         	adds	r0, #0x1
700a67f0: b980         	cbnz	r0, 0x700a6814 <prvAddCurrentTaskToDelayedList+0x54> @ imm = #0x20
700a67f2: e7ff         	b	0x700a67f4 <prvAddCurrentTaskToDelayedList+0x34> @ imm = #-0x2
700a67f4: 9802         	ldr	r0, [sp, #0x8]
700a67f6: b168         	cbz	r0, 0x700a6814 <prvAddCurrentTaskToDelayedList+0x54> @ imm = #0x1a
700a67f8: e7ff         	b	0x700a67fa <prvAddCurrentTaskToDelayedList+0x3a> @ imm = #-0x2
;       vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
700a67fa: f642 200c    	movw	r0, #0x2a0c
700a67fe: f2c7 000b    	movt	r0, #0x700b
700a6802: 6800         	ldr	r0, [r0]
700a6804: 1d01         	adds	r1, r0, #0x4
700a6806: f245 2074    	movw	r0, #0x5274
700a680a: f2c7 0008    	movt	r0, #0x7008
700a680e: f007 fd3f    	bl	0x700ae290 <vListInsertEnd> @ imm = #0x7a7e
;     } else {
700a6812: e03d         	b	0x700a6890 <prvAddCurrentTaskToDelayedList+0xd0> @ imm = #0x7a
;       xTimeToWake = xConstTickCount + xTicksToWait;
700a6814: 9800         	ldr	r0, [sp]
700a6816: 9903         	ldr	r1, [sp, #0xc]
700a6818: 4408         	add	r0, r1
700a681a: 9001         	str	r0, [sp, #0x4]
;       listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
700a681c: 9801         	ldr	r0, [sp, #0x4]
700a681e: f642 210c    	movw	r1, #0x2a0c
700a6822: f2c7 010b    	movt	r1, #0x700b
700a6826: 6809         	ldr	r1, [r1]
700a6828: 6048         	str	r0, [r1, #0x4]
;       if (xTimeToWake < xConstTickCount) {
700a682a: 9801         	ldr	r0, [sp, #0x4]
700a682c: 9900         	ldr	r1, [sp]
700a682e: 4288         	cmp	r0, r1
700a6830: d20e         	bhs	0x700a6850 <prvAddCurrentTaskToDelayedList+0x90> @ imm = #0x1c
700a6832: e7ff         	b	0x700a6834 <prvAddCurrentTaskToDelayedList+0x74> @ imm = #-0x2
;         vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
700a6834: f245 20a4    	movw	r0, #0x52a4
700a6838: f2c7 0008    	movt	r0, #0x7008
700a683c: 6800         	ldr	r0, [r0]
700a683e: f642 210c    	movw	r1, #0x2a0c
700a6842: f2c7 010b    	movt	r1, #0x700b
700a6846: 6809         	ldr	r1, [r1]
700a6848: 3104         	adds	r1, #0x4
700a684a: f004 ffd9    	bl	0x700ab800 <vListInsert> @ imm = #0x4fb2
;       } else {
700a684e: e01e         	b	0x700a688e <prvAddCurrentTaskToDelayedList+0xce> @ imm = #0x3c
;         vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
700a6850: f245 20a0    	movw	r0, #0x52a0
700a6854: f2c7 0008    	movt	r0, #0x7008
700a6858: 6800         	ldr	r0, [r0]
700a685a: f642 210c    	movw	r1, #0x2a0c
700a685e: f2c7 010b    	movt	r1, #0x700b
700a6862: 6809         	ldr	r1, [r1]
700a6864: 3104         	adds	r1, #0x4
700a6866: f004 ffcb    	bl	0x700ab800 <vListInsert> @ imm = #0x4f96
;         if (xTimeToWake < xNextTaskUnblockTime) {
700a686a: 9801         	ldr	r0, [sp, #0x4]
700a686c: f642 2144    	movw	r1, #0x2a44
700a6870: f2c7 010b    	movt	r1, #0x700b
700a6874: 6809         	ldr	r1, [r1]
700a6876: 4288         	cmp	r0, r1
700a6878: d207         	bhs	0x700a688a <prvAddCurrentTaskToDelayedList+0xca> @ imm = #0xe
700a687a: e7ff         	b	0x700a687c <prvAddCurrentTaskToDelayedList+0xbc> @ imm = #-0x2
;           xNextTaskUnblockTime = xTimeToWake;
700a687c: 9801         	ldr	r0, [sp, #0x4]
700a687e: f642 2144    	movw	r1, #0x2a44
700a6882: f2c7 010b    	movt	r1, #0x700b
700a6886: 6008         	str	r0, [r1]
;         } else {
700a6888: e000         	b	0x700a688c <prvAddCurrentTaskToDelayedList+0xcc> @ imm = #0x0
700a688a: e7ff         	b	0x700a688c <prvAddCurrentTaskToDelayedList+0xcc> @ imm = #-0x2
700a688c: e7ff         	b	0x700a688e <prvAddCurrentTaskToDelayedList+0xce> @ imm = #-0x2
700a688e: e7ff         	b	0x700a6890 <prvAddCurrentTaskToDelayedList+0xd0> @ imm = #-0x2
; }
700a6890: b004         	add	sp, #0x10
700a6892: bd80         	pop	{r7, pc}
		...

700a68a0 <UART_lld_write>:
; {
700a68a0: b580         	push	{r7, lr}
700a68a2: b086         	sub	sp, #0x18
700a68a4: f8dd c020    	ldr.w	r12, [sp, #0x20]
700a68a8: 9005         	str	r0, [sp, #0x14]
700a68aa: 9104         	str	r1, [sp, #0x10]
700a68ac: 9203         	str	r2, [sp, #0xc]
700a68ae: 9302         	str	r3, [sp, #0x8]
700a68b0: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a68b2: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a68b4: 9805         	ldr	r0, [sp, #0x14]
700a68b6: 2800         	cmp	r0, #0x0
700a68b8: d054         	beq	0x700a6964 <UART_lld_write+0xc4> @ imm = #0xa8
700a68ba: e7ff         	b	0x700a68bc <UART_lld_write+0x1c> @ imm = #-0x2
;          trans = &hUart->writeTrans;
700a68bc: 9805         	ldr	r0, [sp, #0x14]
700a68be: 303c         	adds	r0, #0x3c
700a68c0: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a68c2: 9800         	ldr	r0, [sp]
700a68c4: 6800         	ldr	r0, [r0]
700a68c6: b138         	cbz	r0, 0x700a68d8 <UART_lld_write+0x38> @ imm = #0xe
700a68c8: e7ff         	b	0x700a68ca <UART_lld_write+0x2a> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a68ca: 9900         	ldr	r1, [sp]
700a68cc: 2009         	movs	r0, #0x9
700a68ce: 60c8         	str	r0, [r1, #0xc]
700a68d0: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a68d4: 9001         	str	r0, [sp, #0x4]
;         }
700a68d6: e044         	b	0x700a6962 <UART_lld_write+0xc2> @ imm = #0x88
;             UART_lld_Transaction_init(trans);
700a68d8: 9800         	ldr	r0, [sp]
700a68da: f008 fa79    	bl	0x700aedd0 <UART_lld_Transaction_init> @ imm = #0x84f2
;             if(extendedParams != NULL)
700a68de: 9808         	ldr	r0, [sp, #0x20]
700a68e0: b128         	cbz	r0, 0x700a68ee <UART_lld_write+0x4e> @ imm = #0xa
700a68e2: e7ff         	b	0x700a68e4 <UART_lld_write+0x44> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a68e4: 9808         	ldr	r0, [sp, #0x20]
700a68e6: 6800         	ldr	r0, [r0]
700a68e8: 9900         	ldr	r1, [sp]
700a68ea: 6108         	str	r0, [r1, #0x10]
;             }
700a68ec: e003         	b	0x700a68f6 <UART_lld_write+0x56> @ imm = #0x6
;                 trans->args = NULL;
700a68ee: 9900         	ldr	r1, [sp]
700a68f0: 2000         	movs	r0, #0x0
700a68f2: 6108         	str	r0, [r1, #0x10]
700a68f4: e7ff         	b	0x700a68f6 <UART_lld_write+0x56> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a68f6: 9804         	ldr	r0, [sp, #0x10]
700a68f8: 9900         	ldr	r1, [sp]
700a68fa: 6008         	str	r0, [r1]
;             trans->count = size;
700a68fc: 9803         	ldr	r0, [sp, #0xc]
700a68fe: 9900         	ldr	r1, [sp]
700a6900: 6048         	str	r0, [r1, #0x4]
;             trans->timeout = timeout;
700a6902: 9802         	ldr	r0, [sp, #0x8]
700a6904: 9900         	ldr	r1, [sp]
700a6906: 6088         	str	r0, [r1, #0x8]
;             if(hUart->state == UART_STATE_READY)
700a6908: 9805         	ldr	r0, [sp, #0x14]
700a690a: 6d40         	ldr	r0, [r0, #0x54]
700a690c: 2801         	cmp	r0, #0x1
700a690e: d105         	bne	0x700a691c <UART_lld_write+0x7c> @ imm = #0xa
700a6910: e7ff         	b	0x700a6912 <UART_lld_write+0x72> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a6912: 9800         	ldr	r0, [sp]
700a6914: f007 fe5c    	bl	0x700ae5d0 <UART_checkTransaction> @ imm = #0x7cb8
700a6918: 9001         	str	r0, [sp, #0x4]
;             }
700a691a: e003         	b	0x700a6924 <UART_lld_write+0x84> @ imm = #0x6
700a691c: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a6920: 9001         	str	r0, [sp, #0x4]
700a6922: e7ff         	b	0x700a6924 <UART_lld_write+0x84> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a6924: 9801         	ldr	r0, [sp, #0x4]
700a6926: b980         	cbnz	r0, 0x700a694a <UART_lld_write+0xaa> @ imm = #0x20
700a6928: e7ff         	b	0x700a692a <UART_lld_write+0x8a> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a692a: 9800         	ldr	r0, [sp]
700a692c: 6800         	ldr	r0, [r0]
700a692e: 9905         	ldr	r1, [sp, #0x14]
700a6930: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a6932: 9800         	ldr	r0, [sp]
700a6934: 6880         	ldr	r0, [r0, #0x8]
700a6936: 9905         	ldr	r1, [sp, #0x14]
700a6938: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a693a: 9905         	ldr	r1, [sp, #0x14]
700a693c: 2000         	movs	r0, #0x0
700a693e: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a6940: 9800         	ldr	r0, [sp]
700a6942: 6840         	ldr	r0, [r0, #0x4]
700a6944: 9905         	ldr	r1, [sp, #0x14]
700a6946: 6108         	str	r0, [r1, #0x10]
;             }
700a6948: e7ff         	b	0x700a694a <UART_lld_write+0xaa> @ imm = #-0x2
;             hUart->state = UART_STATE_BUSY;
700a694a: 9905         	ldr	r1, [sp, #0x14]
700a694c: 2002         	movs	r0, #0x2
700a694e: 6548         	str	r0, [r1, #0x54]
;             status = UART_writePolling(hUart, trans);
700a6950: 9805         	ldr	r0, [sp, #0x14]
700a6952: 9900         	ldr	r1, [sp]
700a6954: f7fc fb04    	bl	0x700a2f60 <UART_writePolling> @ imm = #-0x39f8
700a6958: 9001         	str	r0, [sp, #0x4]
;             hUart->state = UART_STATE_READY;
700a695a: 9905         	ldr	r1, [sp, #0x14]
700a695c: 2001         	movs	r0, #0x1
700a695e: 6548         	str	r0, [r1, #0x54]
700a6960: e7ff         	b	0x700a6962 <UART_lld_write+0xc2> @ imm = #-0x2
;     }
700a6962: e003         	b	0x700a696c <UART_lld_write+0xcc> @ imm = #0x6
700a6964: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a6968: 9001         	str	r0, [sp, #0x4]
700a696a: e7ff         	b	0x700a696c <UART_lld_write+0xcc> @ imm = #-0x2
;     return status;
700a696c: 9801         	ldr	r0, [sp, #0x4]
700a696e: b006         	add	sp, #0x18
700a6970: bd80         	pop	{r7, pc}
		...
700a697e: 0000         	movs	r0, r0

700a6980 <UART_udmaDeInitCh>:
; {
700a6980: b580         	push	{r7, lr}
700a6982: b08c         	sub	sp, #0x30
700a6984: 900b         	str	r0, [sp, #0x2c]
700a6986: 910a         	str	r1, [sp, #0x28]
700a6988: 2000         	movs	r0, #0x0
;     int32_t status = UDMA_SOK;
700a698a: 9009         	str	r0, [sp, #0x24]
700a698c: 2001         	movs	r0, #0x1
;     uint32_t temp = TRUE;
700a698e: 9008         	str	r0, [sp, #0x20]
;     status = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
700a6990: 980b         	ldr	r0, [sp, #0x2c]
700a6992: 2164         	movs	r1, #0x64
700a6994: f001 fbe4    	bl	0x700a8160 <Udma_chDisable> @ imm = #0x17c8
700a6998: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a699a: 9809         	ldr	r0, [sp, #0x24]
700a699c: fab0 f080    	clz	r0, r0
700a69a0: 0940         	lsrs	r0, r0, #0x5
700a69a2: f641 71bb    	movw	r1, #0x1fbb
700a69a6: f2c7 010b    	movt	r1, #0x700b
700a69aa: 9102         	str	r1, [sp, #0x8]
700a69ac: 466a         	mov	r2, sp
700a69ae: 6011         	str	r1, [r2]
700a69b0: f641 316c    	movw	r1, #0x1b6c
700a69b4: f2c7 010b    	movt	r1, #0x700b
700a69b8: 9103         	str	r1, [sp, #0xc]
700a69ba: f242 0205    	movw	r2, #0x2005
700a69be: f2c7 020b    	movt	r2, #0x700b
700a69c2: 9204         	str	r2, [sp, #0x10]
700a69c4: f240 134b    	movw	r3, #0x14b
700a69c8: f004 f962    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x42c4
;     status = Udma_eventUnRegister(eventHandle);
700a69cc: 980a         	ldr	r0, [sp, #0x28]
700a69ce: f000 fc5f    	bl	0x700a7290 <Udma_eventUnRegister> @ imm = #0x8be
700a69d2: 9b02         	ldr	r3, [sp, #0x8]
700a69d4: 9903         	ldr	r1, [sp, #0xc]
700a69d6: 9a04         	ldr	r2, [sp, #0x10]
700a69d8: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a69da: 9809         	ldr	r0, [sp, #0x24]
700a69dc: fab0 f080    	clz	r0, r0
700a69e0: 0940         	lsrs	r0, r0, #0x5
700a69e2: 46ec         	mov	r12, sp
700a69e4: f8cc 3000    	str.w	r3, [r12]
700a69e8: f240 134f    	movw	r3, #0x14f
700a69ec: f004 f950    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x42a0
;     while(temp == TRUE)
700a69f0: e7ff         	b	0x700a69f2 <UART_udmaDeInitCh+0x72> @ imm = #-0x2
700a69f2: 9808         	ldr	r0, [sp, #0x20]
700a69f4: 2801         	cmp	r0, #0x1
700a69f6: d10f         	bne	0x700a6a18 <UART_udmaDeInitCh+0x98> @ imm = #0x1e
700a69f8: e7ff         	b	0x700a69fa <UART_udmaDeInitCh+0x7a> @ imm = #-0x2
;                          Udma_chGetFqRingHandle(chHandle), &pDesc);
700a69fa: 980b         	ldr	r0, [sp, #0x2c]
700a69fc: f004 fb48    	bl	0x700ab090 <Udma_chGetFqRingHandle> @ imm = #0x4690
700a6a00: a906         	add	r1, sp, #0x18
;         tempRetVal = Udma_ringFlushRaw(
700a6a02: f003 fbd5    	bl	0x700aa1b0 <Udma_ringFlushRaw> @ imm = #0x37aa
700a6a06: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_ETIMEOUT == tempRetVal)
700a6a08: 9805         	ldr	r0, [sp, #0x14]
700a6a0a: 3004         	adds	r0, #0x4
700a6a0c: b918         	cbnz	r0, 0x700a6a16 <UART_udmaDeInitCh+0x96> @ imm = #0x6
700a6a0e: e7ff         	b	0x700a6a10 <UART_udmaDeInitCh+0x90> @ imm = #-0x2
700a6a10: 2000         	movs	r0, #0x0
;             temp = FALSE;
700a6a12: 9008         	str	r0, [sp, #0x20]
;         }
700a6a14: e7ff         	b	0x700a6a16 <UART_udmaDeInitCh+0x96> @ imm = #-0x2
;     while(temp == TRUE)
700a6a16: e7ec         	b	0x700a69f2 <UART_udmaDeInitCh+0x72> @ imm = #-0x28
;     status = Udma_chClose(chHandle);
700a6a18: 980b         	ldr	r0, [sp, #0x2c]
700a6a1a: f000 fd71    	bl	0x700a7500 <Udma_chClose> @ imm = #0xae2
700a6a1e: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a6a20: 9809         	ldr	r0, [sp, #0x24]
700a6a22: fab0 f080    	clz	r0, r0
700a6a26: 0940         	lsrs	r0, r0, #0x5
700a6a28: f641 71bb    	movw	r1, #0x1fbb
700a6a2c: f2c7 010b    	movt	r1, #0x700b
700a6a30: 466a         	mov	r2, sp
700a6a32: 6011         	str	r1, [r2]
700a6a34: f641 316c    	movw	r1, #0x1b6c
700a6a38: f2c7 010b    	movt	r1, #0x700b
700a6a3c: f242 0205    	movw	r2, #0x2005
700a6a40: f2c7 020b    	movt	r2, #0x700b
700a6a44: f240 1361    	movw	r3, #0x161
700a6a48: f004 f922    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x4244
;     return status;
700a6a4c: 9809         	ldr	r0, [sp, #0x24]
700a6a4e: b00c         	add	sp, #0x30
700a6a50: bd80         	pop	{r7, pc}
		...
700a6a5e: 0000         	movs	r0, r0

700a6a60 <vTaskSwitchContext>:
; void vTaskSwitchContext(void) {
700a6a60: b082         	sub	sp, #0x8
;   if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
700a6a62: f642 2034    	movw	r0, #0x2a34
700a6a66: f2c7 000b    	movt	r0, #0x700b
700a6a6a: 6800         	ldr	r0, [r0]
700a6a6c: b138         	cbz	r0, 0x700a6a7e <vTaskSwitchContext+0x1e> @ imm = #0xe
700a6a6e: e7ff         	b	0x700a6a70 <vTaskSwitchContext+0x10> @ imm = #-0x2
;     xYieldPending = pdTRUE;
700a6a70: f642 2160    	movw	r1, #0x2a60
700a6a74: f2c7 010b    	movt	r1, #0x700b
700a6a78: 2001         	movs	r0, #0x1
700a6a7a: 6008         	str	r0, [r1]
;   } else {
700a6a7c: e057         	b	0x700a6b2e <vTaskSwitchContext+0xce> @ imm = #0xae
;     xYieldPending = pdFALSE;
700a6a7e: f642 2160    	movw	r1, #0x2a60
700a6a82: f2c7 010b    	movt	r1, #0x700b
700a6a86: 2000         	movs	r0, #0x0
700a6a88: 6008         	str	r0, [r1]
;       pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
700a6a8a: f642 10bc    	movw	r0, #0x29bc
700a6a8e: f2c7 000b    	movt	r0, #0x700b
700a6a92: 6800         	ldr	r0, [r0]
700a6a94: f642 210c    	movw	r1, #0x2a0c
700a6a98: f2c7 010b    	movt	r1, #0x700b
700a6a9c: 6809         	ldr	r1, [r1]
700a6a9e: f8c1 0084    	str.w	r0, [r1, #0x84]
;     taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this
700a6aa2: f642 203c    	movw	r0, #0x2a3c
700a6aa6: f2c7 000b    	movt	r0, #0x700b
700a6aaa: 6800         	ldr	r0, [r0]
700a6aac: 9001         	str	r0, [sp, #0x4]
700a6aae: e7ff         	b	0x700a6ab0 <vTaskSwitchContext+0x50> @ imm = #-0x2
700a6ab0: 9801         	ldr	r0, [sp, #0x4]
700a6ab2: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a6ab6: f244 40f8    	movw	r0, #0x44f8
700a6aba: f2c7 0008    	movt	r0, #0x7008
700a6abe: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a6ac2: b920         	cbnz	r0, 0x700a6ace <vTaskSwitchContext+0x6e> @ imm = #0x8
700a6ac4: e7ff         	b	0x700a6ac6 <vTaskSwitchContext+0x66> @ imm = #-0x2
700a6ac6: 9801         	ldr	r0, [sp, #0x4]
700a6ac8: 3801         	subs	r0, #0x1
700a6aca: 9001         	str	r0, [sp, #0x4]
700a6acc: e7f0         	b	0x700a6ab0 <vTaskSwitchContext+0x50> @ imm = #-0x20
700a6ace: 9801         	ldr	r0, [sp, #0x4]
700a6ad0: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a6ad4: f244 40f8    	movw	r0, #0x44f8
700a6ad8: f2c7 0008    	movt	r0, #0x7008
700a6adc: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a6ae0: 9000         	str	r0, [sp]
700a6ae2: 9900         	ldr	r1, [sp]
700a6ae4: 6848         	ldr	r0, [r1, #0x4]
700a6ae6: 6840         	ldr	r0, [r0, #0x4]
700a6ae8: 6048         	str	r0, [r1, #0x4]
700a6aea: 9900         	ldr	r1, [sp]
700a6aec: 6848         	ldr	r0, [r1, #0x4]
700a6aee: 3108         	adds	r1, #0x8
700a6af0: 4288         	cmp	r0, r1
700a6af2: d105         	bne	0x700a6b00 <vTaskSwitchContext+0xa0> @ imm = #0xa
700a6af4: e7ff         	b	0x700a6af6 <vTaskSwitchContext+0x96> @ imm = #-0x2
700a6af6: 9900         	ldr	r1, [sp]
700a6af8: 6848         	ldr	r0, [r1, #0x4]
700a6afa: 6840         	ldr	r0, [r0, #0x4]
700a6afc: 6048         	str	r0, [r1, #0x4]
700a6afe: e7ff         	b	0x700a6b00 <vTaskSwitchContext+0xa0> @ imm = #-0x2
700a6b00: 9800         	ldr	r0, [sp]
700a6b02: 6840         	ldr	r0, [r0, #0x4]
700a6b04: 68c1         	ldr	r1, [r0, #0xc]
700a6b06: f642 200c    	movw	r0, #0x2a0c
700a6b0a: f2c7 000b    	movt	r0, #0x700b
700a6b0e: 6001         	str	r1, [r0]
700a6b10: 9901         	ldr	r1, [sp, #0x4]
700a6b12: f642 223c    	movw	r2, #0x2a3c
700a6b16: f2c7 020b    	movt	r2, #0x700b
700a6b1a: 6011         	str	r1, [r2]
;       FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
700a6b1c: 6800         	ldr	r0, [r0]
700a6b1e: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a6b22: f642 11bc    	movw	r1, #0x29bc
700a6b26: f2c7 010b    	movt	r1, #0x700b
700a6b2a: 6008         	str	r0, [r1]
700a6b2c: e7ff         	b	0x700a6b2e <vTaskSwitchContext+0xce> @ imm = #-0x2
; }
700a6b2e: b002         	add	sp, #0x8
700a6b30: 4770         	bx	lr
		...
700a6b3e: 0000         	movs	r0, r0

700a6b40 <Udma_rmAllocVintrBit>:
; {
700a6b40: b580         	push	{r7, lr}
700a6b42: b08a         	sub	sp, #0x28
700a6b44: 9009         	str	r0, [sp, #0x24]
700a6b46: f64f 70ff    	movw	r0, #0xffff
;     uint32_t                vintrBitNum = UDMA_EVENT_INVALID;
700a6b4a: 9007         	str	r0, [sp, #0x1c]
;     Udma_DrvHandleInt       drvHandle = eventHandle->drvHandle;
700a6b4c: 9809         	ldr	r0, [sp, #0x24]
700a6b4e: 6800         	ldr	r0, [r0]
700a6b50: 9001         	str	r0, [sp, #0x4]
;     controllerEventHandle = eventHandle;
700a6b52: 9809         	ldr	r0, [sp, #0x24]
700a6b54: 9003         	str	r0, [sp, #0xc]
;     eventPrms = &eventHandle->eventPrms;
700a6b56: 9809         	ldr	r0, [sp, #0x24]
700a6b58: 3008         	adds	r0, #0x8
700a6b5a: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != eventPrms->controllerEventHandle)
700a6b5c: 9802         	ldr	r0, [sp, #0x8]
700a6b5e: 6900         	ldr	r0, [r0, #0x10]
700a6b60: b120         	cbz	r0, 0x700a6b6c <Udma_rmAllocVintrBit+0x2c> @ imm = #0x8
700a6b62: e7ff         	b	0x700a6b64 <Udma_rmAllocVintrBit+0x24> @ imm = #-0x2
;         controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a6b64: 9802         	ldr	r0, [sp, #0x8]
700a6b66: 6900         	ldr	r0, [r0, #0x10]
700a6b68: 9003         	str	r0, [sp, #0xc]
;     }
700a6b6a: e7ff         	b	0x700a6b6c <Udma_rmAllocVintrBit+0x2c> @ imm = #-0x2
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a6b6c: 9801         	ldr	r0, [sp, #0x4]
700a6b6e: f500 609f    	add.w	r0, r0, #0x4f8
700a6b72: f04f 31ff    	mov.w	r1, #0xffffffff
700a6b76: f003 fe33    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x3c66
700a6b7a: 2000         	movs	r0, #0x0
;     for(i = 0U; i < UDMA_MAX_EVENTS_PER_VINTR; i++)
700a6b7c: 9008         	str	r0, [sp, #0x20]
700a6b7e: e7ff         	b	0x700a6b80 <Udma_rmAllocVintrBit+0x40> @ imm = #-0x2
700a6b80: 9808         	ldr	r0, [sp, #0x20]
700a6b82: 283f         	cmp	r0, #0x3f
700a6b84: d83a         	bhi	0x700a6bfc <Udma_rmAllocVintrBit+0xbc> @ imm = #0x74
700a6b86: e7ff         	b	0x700a6b88 <Udma_rmAllocVintrBit+0x48> @ imm = #-0x2
;         bitMask = ((uint64_t) 1U << i);
700a6b88: 9b08         	ldr	r3, [sp, #0x20]
700a6b8a: f1a3 0220    	sub.w	r2, r3, #0x20
700a6b8e: 2101         	movs	r1, #0x1
700a6b90: fa01 fc02    	lsl.w	r12, r1, r2
700a6b94: f1c3 0020    	rsb.w	r0, r3, #0x20
700a6b98: fa21 f000    	lsr.w	r0, r1, r0
700a6b9c: 2a00         	cmp	r2, #0x0
700a6b9e: bf58         	it	pl
700a6ba0: 4660         	movpl	r0, r12
700a6ba2: fa01 f103    	lsl.w	r1, r1, r3
700a6ba6: 2a00         	cmp	r2, #0x0
700a6ba8: bf58         	it	pl
700a6baa: 2100         	movpl	r1, #0x0
700a6bac: 9104         	str	r1, [sp, #0x10]
700a6bae: 9005         	str	r0, [sp, #0x14]
;         if((controllerEventHandle->vintrBitAllocFlag & bitMask) == 0U)
700a6bb0: 9903         	ldr	r1, [sp, #0xc]
700a6bb2: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a6bb6: f8d1 108c    	ldr.w	r1, [r1, #0x8c]
700a6bba: 9a04         	ldr	r2, [sp, #0x10]
700a6bbc: 9b05         	ldr	r3, [sp, #0x14]
700a6bbe: ea01 0103    	and.w	r1, r1, r3
700a6bc2: ea00 0002    	and.w	r0, r0, r2
700a6bc6: ea40 0001    	orr.w	r0, r0, r1
700a6bca: b990         	cbnz	r0, 0x700a6bf2 <Udma_rmAllocVintrBit+0xb2> @ imm = #0x24
700a6bcc: e7ff         	b	0x700a6bce <Udma_rmAllocVintrBit+0x8e> @ imm = #-0x2
;             controllerEventHandle->vintrBitAllocFlag |= bitMask;
700a6bce: f8dd c010    	ldr.w	r12, [sp, #0x10]
700a6bd2: 9b05         	ldr	r3, [sp, #0x14]
700a6bd4: 9903         	ldr	r1, [sp, #0xc]
700a6bd6: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a6bda: f8d1 208c    	ldr.w	r2, [r1, #0x8c]
700a6bde: ea40 000c    	orr.w	r0, r0, r12
700a6be2: 431a         	orrs	r2, r3
700a6be4: f8c1 208c    	str.w	r2, [r1, #0x8c]
700a6be8: f8c1 0088    	str.w	r0, [r1, #0x88]
;             vintrBitNum = i;
700a6bec: 9808         	ldr	r0, [sp, #0x20]
700a6bee: 9007         	str	r0, [sp, #0x1c]
;             break;
700a6bf0: e004         	b	0x700a6bfc <Udma_rmAllocVintrBit+0xbc> @ imm = #0x8
;     }
700a6bf2: e7ff         	b	0x700a6bf4 <Udma_rmAllocVintrBit+0xb4> @ imm = #-0x2
;     for(i = 0U; i < UDMA_MAX_EVENTS_PER_VINTR; i++)
700a6bf4: 9808         	ldr	r0, [sp, #0x20]
700a6bf6: 3001         	adds	r0, #0x1
700a6bf8: 9008         	str	r0, [sp, #0x20]
700a6bfa: e7c1         	b	0x700a6b80 <Udma_rmAllocVintrBit+0x40> @ imm = #-0x7e
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a6bfc: 9801         	ldr	r0, [sp, #0x4]
700a6bfe: f500 609f    	add.w	r0, r0, #0x4f8
700a6c02: f005 f97d    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x52fa
;     return (vintrBitNum);
700a6c06: 9807         	ldr	r0, [sp, #0x1c]
700a6c08: b00a         	add	sp, #0x28
700a6c0a: bd80         	pop	{r7, pc}
700a6c0c: 0000         	movs	r0, r0
700a6c0e: 0000         	movs	r0, r0

700a6c10 <prvCopyDataToQueue>:
; {
700a6c10: b580         	push	{r7, lr}
700a6c12: b086         	sub	sp, #0x18
700a6c14: 9005         	str	r0, [sp, #0x14]
700a6c16: 9104         	str	r1, [sp, #0x10]
700a6c18: 9203         	str	r2, [sp, #0xc]
700a6c1a: 2000         	movs	r0, #0x0
;     BaseType_t xReturn = pdFALSE;
700a6c1c: 9002         	str	r0, [sp, #0x8]
;     uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a6c1e: 9805         	ldr	r0, [sp, #0x14]
700a6c20: 6b80         	ldr	r0, [r0, #0x38]
700a6c22: 9001         	str	r0, [sp, #0x4]
;     if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
700a6c24: 9805         	ldr	r0, [sp, #0x14]
700a6c26: 6c00         	ldr	r0, [r0, #0x40]
700a6c28: b978         	cbnz	r0, 0x700a6c4a <prvCopyDataToQueue+0x3a> @ imm = #0x1e
700a6c2a: e7ff         	b	0x700a6c2c <prvCopyDataToQueue+0x1c> @ imm = #-0x2
;                 if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a6c2c: 9805         	ldr	r0, [sp, #0x14]
700a6c2e: 6800         	ldr	r0, [r0]
700a6c30: b948         	cbnz	r0, 0x700a6c46 <prvCopyDataToQueue+0x36> @ imm = #0x12
700a6c32: e7ff         	b	0x700a6c34 <prvCopyDataToQueue+0x24> @ imm = #-0x2
;                     xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
700a6c34: 9805         	ldr	r0, [sp, #0x14]
700a6c36: 6880         	ldr	r0, [r0, #0x8]
700a6c38: f001 fcfa    	bl	0x700a8630 <xTaskPriorityDisinherit> @ imm = #0x19f4
700a6c3c: 9002         	str	r0, [sp, #0x8]
;                     pxQueue->u.xSemaphore.xMutexHolder = NULL;
700a6c3e: 9905         	ldr	r1, [sp, #0x14]
700a6c40: 2000         	movs	r0, #0x0
700a6c42: 6088         	str	r0, [r1, #0x8]
;                 }
700a6c44: e000         	b	0x700a6c48 <prvCopyDataToQueue+0x38> @ imm = #0x0
700a6c46: e7ff         	b	0x700a6c48 <prvCopyDataToQueue+0x38> @ imm = #-0x2
;     }
700a6c48: e041         	b	0x700a6cce <prvCopyDataToQueue+0xbe> @ imm = #0x82
;     else if( xPosition == queueSEND_TO_BACK )
700a6c4a: 9803         	ldr	r0, [sp, #0xc]
700a6c4c: b9b8         	cbnz	r0, 0x700a6c7e <prvCopyDataToQueue+0x6e> @ imm = #0x2e
700a6c4e: e7ff         	b	0x700a6c50 <prvCopyDataToQueue+0x40> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
700a6c50: 9a05         	ldr	r2, [sp, #0x14]
700a6c52: 9904         	ldr	r1, [sp, #0x10]
700a6c54: 6850         	ldr	r0, [r2, #0x4]
700a6c56: 6c12         	ldr	r2, [r2, #0x40]
700a6c58: f7f3 ea40    	blx	0x7009a0dc <__aeabi_memcpy8> @ imm = #-0xcb80
;         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
700a6c5c: 9905         	ldr	r1, [sp, #0x14]
700a6c5e: 6848         	ldr	r0, [r1, #0x4]
700a6c60: 6c0a         	ldr	r2, [r1, #0x40]
700a6c62: 4410         	add	r0, r2
700a6c64: 6048         	str	r0, [r1, #0x4]
;         if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
700a6c66: 9905         	ldr	r1, [sp, #0x14]
700a6c68: 6848         	ldr	r0, [r1, #0x4]
700a6c6a: 6889         	ldr	r1, [r1, #0x8]
700a6c6c: 4288         	cmp	r0, r1
700a6c6e: d304         	blo	0x700a6c7a <prvCopyDataToQueue+0x6a> @ imm = #0x8
700a6c70: e7ff         	b	0x700a6c72 <prvCopyDataToQueue+0x62> @ imm = #-0x2
;             pxQueue->pcWriteTo = pxQueue->pcHead;
700a6c72: 9905         	ldr	r1, [sp, #0x14]
700a6c74: 6808         	ldr	r0, [r1]
700a6c76: 6048         	str	r0, [r1, #0x4]
;         }
700a6c78: e000         	b	0x700a6c7c <prvCopyDataToQueue+0x6c> @ imm = #0x0
700a6c7a: e7ff         	b	0x700a6c7c <prvCopyDataToQueue+0x6c> @ imm = #-0x2
;     }
700a6c7c: e026         	b	0x700a6ccc <prvCopyDataToQueue+0xbc> @ imm = #0x4c
;         ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
700a6c7e: 9a05         	ldr	r2, [sp, #0x14]
700a6c80: 9904         	ldr	r1, [sp, #0x10]
700a6c82: 68d0         	ldr	r0, [r2, #0xc]
700a6c84: 6c12         	ldr	r2, [r2, #0x40]
700a6c86: f7f3 ea2a    	blx	0x7009a0dc <__aeabi_memcpy8> @ imm = #-0xcbac
;         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
700a6c8a: 9905         	ldr	r1, [sp, #0x14]
700a6c8c: 68c8         	ldr	r0, [r1, #0xc]
700a6c8e: 6c0a         	ldr	r2, [r1, #0x40]
700a6c90: 1a80         	subs	r0, r0, r2
700a6c92: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
700a6c94: 9805         	ldr	r0, [sp, #0x14]
700a6c96: 6801         	ldr	r1, [r0]
700a6c98: 68c0         	ldr	r0, [r0, #0xc]
700a6c9a: 4288         	cmp	r0, r1
700a6c9c: d206         	bhs	0x700a6cac <prvCopyDataToQueue+0x9c> @ imm = #0xc
700a6c9e: e7ff         	b	0x700a6ca0 <prvCopyDataToQueue+0x90> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
700a6ca0: 9905         	ldr	r1, [sp, #0x14]
700a6ca2: 6888         	ldr	r0, [r1, #0x8]
700a6ca4: 6c0a         	ldr	r2, [r1, #0x40]
700a6ca6: 1a80         	subs	r0, r0, r2
700a6ca8: 60c8         	str	r0, [r1, #0xc]
;         }
700a6caa: e000         	b	0x700a6cae <prvCopyDataToQueue+0x9e> @ imm = #0x0
700a6cac: e7ff         	b	0x700a6cae <prvCopyDataToQueue+0x9e> @ imm = #-0x2
;         if( xPosition == queueOVERWRITE )
700a6cae: 9803         	ldr	r0, [sp, #0xc]
700a6cb0: 2802         	cmp	r0, #0x2
700a6cb2: d109         	bne	0x700a6cc8 <prvCopyDataToQueue+0xb8> @ imm = #0x12
700a6cb4: e7ff         	b	0x700a6cb6 <prvCopyDataToQueue+0xa6> @ imm = #-0x2
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a6cb6: 9801         	ldr	r0, [sp, #0x4]
700a6cb8: b120         	cbz	r0, 0x700a6cc4 <prvCopyDataToQueue+0xb4> @ imm = #0x8
700a6cba: e7ff         	b	0x700a6cbc <prvCopyDataToQueue+0xac> @ imm = #-0x2
;                 --uxMessagesWaiting;
700a6cbc: 9801         	ldr	r0, [sp, #0x4]
700a6cbe: 3801         	subs	r0, #0x1
700a6cc0: 9001         	str	r0, [sp, #0x4]
;             }
700a6cc2: e000         	b	0x700a6cc6 <prvCopyDataToQueue+0xb6> @ imm = #0x0
700a6cc4: e7ff         	b	0x700a6cc6 <prvCopyDataToQueue+0xb6> @ imm = #-0x2
;         }
700a6cc6: e000         	b	0x700a6cca <prvCopyDataToQueue+0xba> @ imm = #0x0
700a6cc8: e7ff         	b	0x700a6cca <prvCopyDataToQueue+0xba> @ imm = #-0x2
700a6cca: e7ff         	b	0x700a6ccc <prvCopyDataToQueue+0xbc> @ imm = #-0x2
700a6ccc: e7ff         	b	0x700a6cce <prvCopyDataToQueue+0xbe> @ imm = #-0x2
;     pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
700a6cce: 9801         	ldr	r0, [sp, #0x4]
700a6cd0: 3001         	adds	r0, #0x1
700a6cd2: 9905         	ldr	r1, [sp, #0x14]
700a6cd4: 6388         	str	r0, [r1, #0x38]
;     return xReturn;
700a6cd6: 9802         	ldr	r0, [sp, #0x8]
700a6cd8: b006         	add	sp, #0x18
700a6cda: bd80         	pop	{r7, pc}
700a6cdc: 0000         	movs	r0, r0
700a6cde: 0000         	movs	r0, r0

700a6ce0 <CSL_bcdmaChanOpSetBurstSize>:
; {
700a6ce0: b580         	push	{r7, lr}
700a6ce2: b088         	sub	sp, #0x20
700a6ce4: 9007         	str	r0, [sp, #0x1c]
700a6ce6: 9106         	str	r1, [sp, #0x18]
700a6ce8: 9205         	str	r2, [sp, #0x14]
700a6cea: 9304         	str	r3, [sp, #0x10]
700a6cec: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a6cee: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a6cf0: 9804         	ldr	r0, [sp, #0x10]
700a6cf2: b920         	cbnz	r0, 0x700a6cfe <CSL_bcdmaChanOpSetBurstSize+0x1e> @ imm = #0x8
700a6cf4: e7ff         	b	0x700a6cf6 <CSL_bcdmaChanOpSetBurstSize+0x16> @ imm = #-0x2
700a6cf6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a6cfa: 9003         	str	r0, [sp, #0xc]
;     }
700a6cfc: e052         	b	0x700a6da4 <CSL_bcdmaChanOpSetBurstSize+0xc4> @ imm = #0xa4
;         CSL_BcdmaChanBurstSize burstSize = *(CSL_BcdmaChanBurstSize *)pOpData;
700a6cfe: 9804         	ldr	r0, [sp, #0x10]
700a6d00: 6800         	ldr	r0, [r0]
700a6d02: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a6d04: 9806         	ldr	r0, [sp, #0x18]
700a6d06: 9001         	str	r0, [sp, #0x4]
700a6d08: b140         	cbz	r0, 0x700a6d1c <CSL_bcdmaChanOpSetBurstSize+0x3c> @ imm = #0x10
700a6d0a: e7ff         	b	0x700a6d0c <CSL_bcdmaChanOpSetBurstSize+0x2c> @ imm = #-0x2
700a6d0c: 9801         	ldr	r0, [sp, #0x4]
700a6d0e: 2801         	cmp	r0, #0x1
700a6d10: d019         	beq	0x700a6d46 <CSL_bcdmaChanOpSetBurstSize+0x66> @ imm = #0x32
700a6d12: e7ff         	b	0x700a6d14 <CSL_bcdmaChanOpSetBurstSize+0x34> @ imm = #-0x2
700a6d14: 9801         	ldr	r0, [sp, #0x4]
700a6d16: 2802         	cmp	r0, #0x2
700a6d18: d02a         	beq	0x700a6d70 <CSL_bcdmaChanOpSetBurstSize+0x90> @ imm = #0x54
700a6d1a: e03e         	b	0x700a6d9a <CSL_bcdmaChanOpSetBurstSize+0xba> @ imm = #0x7c
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES )   /* Block-copy supports 32, 64, and 128-byte bursts */
700a6d1c: 9802         	ldr	r0, [sp, #0x8]
700a6d1e: 2803         	cmp	r0, #0x3
700a6d20: d304         	blo	0x700a6d2c <CSL_bcdmaChanOpSetBurstSize+0x4c> @ imm = #0x8
700a6d22: e7ff         	b	0x700a6d24 <CSL_bcdmaChanOpSetBurstSize+0x44> @ imm = #-0x2
700a6d24: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a6d28: 9003         	str	r0, [sp, #0xc]
;                 }
700a6d2a: e00b         	b	0x700a6d44 <CSL_bcdmaChanOpSetBurstSize+0x64> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG, BCDMA_BCCFG_CHAN_CFG_BURST_SIZE, burstSize );
700a6d2c: 9807         	ldr	r0, [sp, #0x1c]
700a6d2e: 6840         	ldr	r0, [r0, #0x4]
700a6d30: 9905         	ldr	r1, [sp, #0x14]
700a6d32: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a6d36: 9b02         	ldr	r3, [sp, #0x8]
700a6d38: f44f 6140    	mov.w	r1, #0xc00
700a6d3c: 220a         	movs	r2, #0xa
700a6d3e: f007 fac7    	bl	0x700ae2d0 <CSL_REG32_FINS_RAW> @ imm = #0x758e
700a6d42: e7ff         	b	0x700a6d44 <CSL_bcdmaChanOpSetBurstSize+0x64> @ imm = #-0x2
;                 break;
700a6d44: e02d         	b	0x700a6da2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x5a
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES )    /* Split-tx supports 32, and 64-byte bursts */
700a6d46: 9802         	ldr	r0, [sp, #0x8]
700a6d48: 2802         	cmp	r0, #0x2
700a6d4a: d304         	blo	0x700a6d56 <CSL_bcdmaChanOpSetBurstSize+0x76> @ imm = #0x8
700a6d4c: e7ff         	b	0x700a6d4e <CSL_bcdmaChanOpSetBurstSize+0x6e> @ imm = #-0x2
700a6d4e: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a6d52: 9003         	str	r0, [sp, #0xc]
;                 }
700a6d54: e00b         	b	0x700a6d6e <CSL_bcdmaChanOpSetBurstSize+0x8e> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG, BCDMA_TXCCFG_CHAN_TCFG_BURST_SIZE, burstSize );
700a6d56: 9807         	ldr	r0, [sp, #0x1c]
700a6d58: 68c0         	ldr	r0, [r0, #0xc]
700a6d5a: 9905         	ldr	r1, [sp, #0x14]
700a6d5c: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a6d60: 9b02         	ldr	r3, [sp, #0x8]
700a6d62: f44f 6140    	mov.w	r1, #0xc00
700a6d66: 220a         	movs	r2, #0xa
700a6d68: f007 fab2    	bl	0x700ae2d0 <CSL_REG32_FINS_RAW> @ imm = #0x7564
700a6d6c: e7ff         	b	0x700a6d6e <CSL_bcdmaChanOpSetBurstSize+0x8e> @ imm = #-0x2
;                 break;
700a6d6e: e018         	b	0x700a6da2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x30
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES )    /* Split-rx supports 32, and 64-byte bursts */
700a6d70: 9802         	ldr	r0, [sp, #0x8]
700a6d72: 2802         	cmp	r0, #0x2
700a6d74: d304         	blo	0x700a6d80 <CSL_bcdmaChanOpSetBurstSize+0xa0> @ imm = #0x8
700a6d76: e7ff         	b	0x700a6d78 <CSL_bcdmaChanOpSetBurstSize+0x98> @ imm = #-0x2
700a6d78: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a6d7c: 9003         	str	r0, [sp, #0xc]
;                 }
700a6d7e: e00b         	b	0x700a6d98 <CSL_bcdmaChanOpSetBurstSize+0xb8> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG, BCDMA_RXCCFG_CHAN_RCFG_BURST_SIZE, burstSize );
700a6d80: 9807         	ldr	r0, [sp, #0x1c]
700a6d82: 6940         	ldr	r0, [r0, #0x14]
700a6d84: 9905         	ldr	r1, [sp, #0x14]
700a6d86: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a6d8a: 9b02         	ldr	r3, [sp, #0x8]
700a6d8c: f44f 6140    	mov.w	r1, #0xc00
700a6d90: 220a         	movs	r2, #0xa
700a6d92: f007 fa9d    	bl	0x700ae2d0 <CSL_REG32_FINS_RAW> @ imm = #0x753a
700a6d96: e7ff         	b	0x700a6d98 <CSL_bcdmaChanOpSetBurstSize+0xb8> @ imm = #-0x2
;                 break;
700a6d98: e003         	b	0x700a6da2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x6
700a6d9a: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a6d9e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a6da0: e7ff         	b	0x700a6da2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #-0x2
700a6da2: e7ff         	b	0x700a6da4 <CSL_bcdmaChanOpSetBurstSize+0xc4> @ imm = #-0x2
;     return retVal;
700a6da4: 9803         	ldr	r0, [sp, #0xc]
700a6da6: b008         	add	sp, #0x20
700a6da8: bd80         	pop	{r7, pc}
700a6daa: 0000         	movs	r0, r0
700a6dac: 0000         	movs	r0, r0
700a6dae: 0000         	movs	r0, r0

700a6db0 <Udma_ringCheckParams>:
; {
700a6db0: b580         	push	{r7, lr}
700a6db2: b084         	sub	sp, #0x10
700a6db4: 9003         	str	r0, [sp, #0xc]
700a6db6: 9102         	str	r1, [sp, #0x8]
700a6db8: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a6dba: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR == ringPrms->ringMem)
700a6dbc: 9802         	ldr	r0, [sp, #0x8]
700a6dbe: 6800         	ldr	r0, [r0]
700a6dc0: b920         	cbnz	r0, 0x700a6dcc <Udma_ringCheckParams+0x1c> @ imm = #0x8
700a6dc2: e7ff         	b	0x700a6dc4 <Udma_ringCheckParams+0x14> @ imm = #-0x2
700a6dc4: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6dc8: 9001         	str	r0, [sp, #0x4]
;     }
700a6dca: e009         	b	0x700a6de0 <Udma_ringCheckParams+0x30> @ imm = #0x12
;         if(((uintptr_t)ringPrms->ringMem & (UDMA_CACHELINE_ALIGNMENT - 1U)) != 0U)
700a6dcc: 9802         	ldr	r0, [sp, #0x8]
700a6dce: 7800         	ldrb	r0, [r0]
700a6dd0: 0640         	lsls	r0, r0, #0x19
700a6dd2: b120         	cbz	r0, 0x700a6dde <Udma_ringCheckParams+0x2e> @ imm = #0x8
700a6dd4: e7ff         	b	0x700a6dd6 <Udma_ringCheckParams+0x26> @ imm = #-0x2
700a6dd6: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a6dda: 9001         	str	r0, [sp, #0x4]
;         }
700a6ddc: e7ff         	b	0x700a6dde <Udma_ringCheckParams+0x2e> @ imm = #-0x2
700a6dde: e7ff         	b	0x700a6de0 <Udma_ringCheckParams+0x30> @ imm = #-0x2
;     if(0U == ringPrms->elemCnt)
700a6de0: 9802         	ldr	r0, [sp, #0x8]
700a6de2: 68c0         	ldr	r0, [r0, #0xc]
700a6de4: b920         	cbnz	r0, 0x700a6df0 <Udma_ringCheckParams+0x40> @ imm = #0x8
700a6de6: e7ff         	b	0x700a6de8 <Udma_ringCheckParams+0x38> @ imm = #-0x2
700a6de8: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6dec: 9001         	str	r0, [sp, #0x4]
;     }
700a6dee: e7ff         	b	0x700a6df0 <Udma_ringCheckParams+0x40> @ imm = #-0x2
;     if(UDMA_INST_TYPE_NORMAL != drvHandle->instType)
700a6df0: 9803         	ldr	r0, [sp, #0xc]
700a6df2: 6800         	ldr	r0, [r0]
700a6df4: b148         	cbz	r0, 0x700a6e0a <Udma_ringCheckParams+0x5a> @ imm = #0x12
700a6df6: e7ff         	b	0x700a6df8 <Udma_ringCheckParams+0x48> @ imm = #-0x2
;         if(TISCI_MSG_VALUE_RM_RING_MODE_RING != ringPrms->mode)
700a6df8: 9802         	ldr	r0, [sp, #0x8]
700a6dfa: 7a00         	ldrb	r0, [r0, #0x8]
700a6dfc: b120         	cbz	r0, 0x700a6e08 <Udma_ringCheckParams+0x58> @ imm = #0x8
700a6dfe: e7ff         	b	0x700a6e00 <Udma_ringCheckParams+0x50> @ imm = #-0x2
700a6e00: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a6e04: 9001         	str	r0, [sp, #0x4]
;         }
700a6e06: e7ff         	b	0x700a6e08 <Udma_ringCheckParams+0x58> @ imm = #-0x2
;     }
700a6e08: e7ff         	b	0x700a6e0a <Udma_ringCheckParams+0x5a> @ imm = #-0x2
;     if(UDMA_RING_SIZE_CHECK_SKIP != ringPrms->ringMemSize)
700a6e0a: 9802         	ldr	r0, [sp, #0x8]
700a6e0c: 6840         	ldr	r0, [r0, #0x4]
700a6e0e: f64a 31cd    	movw	r1, #0xabcd
700a6e12: f6ca 31dc    	movt	r1, #0xabdc
700a6e16: 4288         	cmp	r0, r1
700a6e18: d012         	beq	0x700a6e40 <Udma_ringCheckParams+0x90> @ imm = #0x24
700a6e1a: e7ff         	b	0x700a6e1c <Udma_ringCheckParams+0x6c> @ imm = #-0x2
;                           ringPrms->mode,
700a6e1c: 9a02         	ldr	r2, [sp, #0x8]
700a6e1e: 7a10         	ldrb	r0, [r2, #0x8]
;                           ringPrms->elemCnt,
700a6e20: 68d1         	ldr	r1, [r2, #0xc]
;                           ringPrms->elemSize);
700a6e22: 7c12         	ldrb	r2, [r2, #0x10]
;         ringMemSize = UdmaUtils_getRingMemSize(
700a6e24: f006 fe84    	bl	0x700adb30 <UdmaUtils_getRingMemSize> @ imm = #0x6d08
700a6e28: 9000         	str	r0, [sp]
;         if(ringPrms->ringMemSize < ringMemSize)
700a6e2a: 9802         	ldr	r0, [sp, #0x8]
700a6e2c: 6840         	ldr	r0, [r0, #0x4]
700a6e2e: 9900         	ldr	r1, [sp]
700a6e30: 4288         	cmp	r0, r1
700a6e32: d204         	bhs	0x700a6e3e <Udma_ringCheckParams+0x8e> @ imm = #0x8
700a6e34: e7ff         	b	0x700a6e36 <Udma_ringCheckParams+0x86> @ imm = #-0x2
700a6e36: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
700a6e3a: 9001         	str	r0, [sp, #0x4]
;         }
700a6e3c: e7ff         	b	0x700a6e3e <Udma_ringCheckParams+0x8e> @ imm = #-0x2
;     }
700a6e3e: e7ff         	b	0x700a6e40 <Udma_ringCheckParams+0x90> @ imm = #-0x2
;     if (UDMA_RING_ORDERID_MAX < ringPrms->orderId)
700a6e40: 9802         	ldr	r0, [sp, #0x8]
700a6e42: 7c40         	ldrb	r0, [r0, #0x11]
700a6e44: 2810         	cmp	r0, #0x10
700a6e46: d304         	blo	0x700a6e52 <Udma_ringCheckParams+0xa2> @ imm = #0x8
700a6e48: e7ff         	b	0x700a6e4a <Udma_ringCheckParams+0x9a> @ imm = #-0x2
700a6e4a: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6e4e: 9001         	str	r0, [sp, #0x4]
;     }
700a6e50: e7ff         	b	0x700a6e52 <Udma_ringCheckParams+0xa2> @ imm = #-0x2
;     if((UDMA_MAPPED_GROUP_INVALID != ringPrms->mappedRingGrp) &&
700a6e52: 9802         	ldr	r0, [sp, #0x8]
700a6e54: 6940         	ldr	r0, [r0, #0x14]
700a6e56: 2104         	movs	r1, #0x4
700a6e58: f6cf 71ff    	movt	r1, #0xffff
700a6e5c: 4288         	cmp	r0, r1
700a6e5e: d009         	beq	0x700a6e74 <Udma_ringCheckParams+0xc4> @ imm = #0x12
700a6e60: e7ff         	b	0x700a6e62 <Udma_ringCheckParams+0xb2> @ imm = #-0x2
;        (ringPrms->mappedRingGrp >= (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
700a6e62: 9802         	ldr	r0, [sp, #0x8]
700a6e64: 6940         	ldr	r0, [r0, #0x14]
;     if((UDMA_MAPPED_GROUP_INVALID != ringPrms->mappedRingGrp) &&
700a6e66: 2808         	cmp	r0, #0x8
700a6e68: d304         	blo	0x700a6e74 <Udma_ringCheckParams+0xc4> @ imm = #0x8
700a6e6a: e7ff         	b	0x700a6e6c <Udma_ringCheckParams+0xbc> @ imm = #-0x2
700a6e6c: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6e70: 9001         	str	r0, [sp, #0x4]
;     }
700a6e72: e7ff         	b	0x700a6e74 <Udma_ringCheckParams+0xc4> @ imm = #-0x2
;     return (retVal);
700a6e74: 9801         	ldr	r0, [sp, #0x4]
700a6e76: b004         	add	sp, #0x10
700a6e78: bd80         	pop	{r7, pc}
700a6e7a: 0000         	movs	r0, r0
700a6e7c: 0000         	movs	r0, r0
700a6e7e: 0000         	movs	r0, r0

700a6e80 <UART_lld_writeDma>:
; {
700a6e80: b580         	push	{r7, lr}
700a6e82: b086         	sub	sp, #0x18
700a6e84: 9005         	str	r0, [sp, #0x14]
700a6e86: 9104         	str	r1, [sp, #0x10]
700a6e88: 9203         	str	r2, [sp, #0xc]
700a6e8a: 9302         	str	r3, [sp, #0x8]
700a6e8c: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a6e8e: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a6e90: 9805         	ldr	r0, [sp, #0x14]
700a6e92: 2800         	cmp	r0, #0x0
700a6e94: d051         	beq	0x700a6f3a <UART_lld_writeDma+0xba> @ imm = #0xa2
700a6e96: e7ff         	b	0x700a6e98 <UART_lld_writeDma+0x18> @ imm = #-0x2
;         trans = &hUart->writeTrans;
700a6e98: 9805         	ldr	r0, [sp, #0x14]
700a6e9a: 303c         	adds	r0, #0x3c
700a6e9c: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a6e9e: 9800         	ldr	r0, [sp]
700a6ea0: 6800         	ldr	r0, [r0]
700a6ea2: b138         	cbz	r0, 0x700a6eb4 <UART_lld_writeDma+0x34> @ imm = #0xe
700a6ea4: e7ff         	b	0x700a6ea6 <UART_lld_writeDma+0x26> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a6ea6: 9900         	ldr	r1, [sp]
700a6ea8: 2009         	movs	r0, #0x9
700a6eaa: 60c8         	str	r0, [r1, #0xc]
700a6eac: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a6eb0: 9001         	str	r0, [sp, #0x4]
;         }
700a6eb2: e041         	b	0x700a6f38 <UART_lld_writeDma+0xb8> @ imm = #0x82
;             UART_lld_Transaction_init(trans);
700a6eb4: 9800         	ldr	r0, [sp]
700a6eb6: f007 ff8b    	bl	0x700aedd0 <UART_lld_Transaction_init> @ imm = #0x7f16
;             if(extendedParams != NULL)
700a6eba: 9802         	ldr	r0, [sp, #0x8]
700a6ebc: b128         	cbz	r0, 0x700a6eca <UART_lld_writeDma+0x4a> @ imm = #0xa
700a6ebe: e7ff         	b	0x700a6ec0 <UART_lld_writeDma+0x40> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a6ec0: 9802         	ldr	r0, [sp, #0x8]
700a6ec2: 6800         	ldr	r0, [r0]
700a6ec4: 9900         	ldr	r1, [sp]
700a6ec6: 6108         	str	r0, [r1, #0x10]
;             }
700a6ec8: e003         	b	0x700a6ed2 <UART_lld_writeDma+0x52> @ imm = #0x6
;                 trans->args = NULL;
700a6eca: 9900         	ldr	r1, [sp]
700a6ecc: 2000         	movs	r0, #0x0
700a6ece: 6108         	str	r0, [r1, #0x10]
700a6ed0: e7ff         	b	0x700a6ed2 <UART_lld_writeDma+0x52> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a6ed2: 9804         	ldr	r0, [sp, #0x10]
700a6ed4: 9900         	ldr	r1, [sp]
700a6ed6: 6008         	str	r0, [r1]
;             trans->count = size;
700a6ed8: 9803         	ldr	r0, [sp, #0xc]
700a6eda: 9900         	ldr	r1, [sp]
700a6edc: 6048         	str	r0, [r1, #0x4]
;             if(hUart->state == UART_STATE_READY)
700a6ede: 9805         	ldr	r0, [sp, #0x14]
700a6ee0: 6d40         	ldr	r0, [r0, #0x54]
700a6ee2: 2801         	cmp	r0, #0x1
700a6ee4: d105         	bne	0x700a6ef2 <UART_lld_writeDma+0x72> @ imm = #0xa
700a6ee6: e7ff         	b	0x700a6ee8 <UART_lld_writeDma+0x68> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a6ee8: 9800         	ldr	r0, [sp]
700a6eea: f007 fb71    	bl	0x700ae5d0 <UART_checkTransaction> @ imm = #0x76e2
700a6eee: 9001         	str	r0, [sp, #0x4]
;             }
700a6ef0: e003         	b	0x700a6efa <UART_lld_writeDma+0x7a> @ imm = #0x6
700a6ef2: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a6ef6: 9001         	str	r0, [sp, #0x4]
700a6ef8: e7ff         	b	0x700a6efa <UART_lld_writeDma+0x7a> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a6efa: 9801         	ldr	r0, [sp, #0x4]
700a6efc: b9d8         	cbnz	r0, 0x700a6f36 <UART_lld_writeDma+0xb6> @ imm = #0x36
700a6efe: e7ff         	b	0x700a6f00 <UART_lld_writeDma+0x80> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a6f00: 9800         	ldr	r0, [sp]
700a6f02: 6800         	ldr	r0, [r0]
700a6f04: 9905         	ldr	r1, [sp, #0x14]
700a6f06: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a6f08: 9800         	ldr	r0, [sp]
700a6f0a: 6880         	ldr	r0, [r0, #0x8]
700a6f0c: 9905         	ldr	r1, [sp, #0x14]
700a6f0e: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a6f10: 9905         	ldr	r1, [sp, #0x14]
700a6f12: 2000         	movs	r0, #0x0
700a6f14: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a6f16: 9800         	ldr	r0, [sp]
700a6f18: 6840         	ldr	r0, [r0, #0x4]
700a6f1a: 9905         	ldr	r1, [sp, #0x14]
700a6f1c: 6108         	str	r0, [r1, #0x10]
;                 hUart->state = UART_STATE_BUSY;
700a6f1e: 9905         	ldr	r1, [sp, #0x14]
700a6f20: 2002         	movs	r0, #0x2
700a6f22: 6548         	str	r0, [r1, #0x54]
;                 status = UART_lld_dmaWrite(hUart, trans);
700a6f24: 9805         	ldr	r0, [sp, #0x14]
700a6f26: 9900         	ldr	r1, [sp]
700a6f28: f007 ff6a    	bl	0x700aee00 <UART_lld_dmaWrite> @ imm = #0x7ed4
700a6f2c: 9001         	str	r0, [sp, #0x4]
;                 hUart->state = UART_STATE_READY;
700a6f2e: 9905         	ldr	r1, [sp, #0x14]
700a6f30: 2001         	movs	r0, #0x1
700a6f32: 6548         	str	r0, [r1, #0x54]
;             }
700a6f34: e7ff         	b	0x700a6f36 <UART_lld_writeDma+0xb6> @ imm = #-0x2
700a6f36: e7ff         	b	0x700a6f38 <UART_lld_writeDma+0xb8> @ imm = #-0x2
;     }
700a6f38: e003         	b	0x700a6f42 <UART_lld_writeDma+0xc2> @ imm = #0x6
700a6f3a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a6f3e: 9001         	str	r0, [sp, #0x4]
700a6f40: e7ff         	b	0x700a6f42 <UART_lld_writeDma+0xc2> @ imm = #-0x2
;     return status;
700a6f42: 9801         	ldr	r0, [sp, #0x4]
700a6f44: b006         	add	sp, #0x18
700a6f46: bd80         	pop	{r7, pc}
		...

700a6f50 <UART_udmaHpdInit>:
; {
700a6f50: b580         	push	{r7, lr}
700a6f52: b08a         	sub	sp, #0x28
700a6f54: 9009         	str	r0, [sp, #0x24]
700a6f56: 9108         	str	r1, [sp, #0x20]
700a6f58: 9207         	str	r2, [sp, #0x1c]
700a6f5a: 9306         	str	r3, [sp, #0x18]
;     CSL_UdmapCppi5HMPD *pHpd = (CSL_UdmapCppi5HMPD *) pHpdMem;
700a6f5c: 9808         	ldr	r0, [sp, #0x20]
700a6f5e: 9005         	str	r0, [sp, #0x14]
700a6f60: 2001         	movs	r0, #0x1
;     uint32_t descType = (uint32_t)CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST;
700a6f62: 9004         	str	r0, [sp, #0x10]
;     CSL_udmapCppi5SetDescType(pHpd, descType);
700a6f64: 9805         	ldr	r0, [sp, #0x14]
700a6f66: 9904         	ldr	r1, [sp, #0x10]
700a6f68: f008 fb62    	bl	0x700af630 <CSL_udmapCppi5SetDescType> @ imm = #0x86c4
;     CSL_udmapCppi5SetEpiDataPresent(pHpd, FALSE);
700a6f6c: 9805         	ldr	r0, [sp, #0x14]
700a6f6e: 2100         	movs	r1, #0x0
700a6f70: 9102         	str	r1, [sp, #0x8]
700a6f72: f008 fa3d    	bl	0x700af3f0 <CSL_udmapCppi5SetEpiDataPresent> @ imm = #0x847a
700a6f76: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsDataLoc(pHpd, 0U);
700a6f78: 9805         	ldr	r0, [sp, #0x14]
700a6f7a: f008 fc61    	bl	0x700af840 <CSL_udmapCppi5SetPsDataLoc> @ imm = #0x88c2
700a6f7e: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsDataLen(pHpd, 0U);
700a6f80: 9805         	ldr	r0, [sp, #0x14]
700a6f82: f008 fb85    	bl	0x700af690 <CSL_udmapCppi5SetPsDataLen> @ imm = #0x870a
;     CSL_udmapCppi5SetPktLen(pHpd, descType, length);
700a6f86: 9805         	ldr	r0, [sp, #0x14]
700a6f88: 9904         	ldr	r1, [sp, #0x10]
700a6f8a: 9a06         	ldr	r2, [sp, #0x18]
700a6f8c: f006 fd58    	bl	0x700ada40 <CSL_udmapCppi5SetPktLen> @ imm = #0x6ab0
700a6f90: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsFlags(pHpd, 0U);
700a6f92: 9805         	ldr	r0, [sp, #0x14]
700a6f94: f008 fc64    	bl	0x700af860 <CSL_udmapCppi5SetPsFlags> @ imm = #0x88c8
;     CSL_udmapCppi5SetIds(pHpd, descType, 0x321, UDMA_DEFAULT_FLOW_ID);
700a6f98: 9805         	ldr	r0, [sp, #0x14]
700a6f9a: 9904         	ldr	r1, [sp, #0x10]
700a6f9c: f240 3221    	movw	r2, #0x321
700a6fa0: f643 73ff    	movw	r3, #0x3fff
700a6fa4: f004 fdb4    	bl	0x700abb10 <CSL_udmapCppi5SetIds> @ imm = #0x4b68
700a6fa8: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetSrcTag(pHpd, 0x0000);     /* Not used */
700a6faa: 9805         	ldr	r0, [sp, #0x14]
700a6fac: f008 fd18    	bl	0x700af9e0 <CSL_udmapCppi5SetSrcTag> @ imm = #0x8a30
700a6fb0: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetDstTag(pHpd, 0x0000);     /* Not used */
700a6fb2: 9805         	ldr	r0, [sp, #0x14]
700a6fb4: f008 fdbc    	bl	0x700afb30 <CSL_udmapCppi5SetDstTag> @ imm = #0x8b78
;     UART_udmapSetReturnPolicy(chHandle, pHpdMem);
700a6fb8: 9809         	ldr	r0, [sp, #0x24]
700a6fba: 9908         	ldr	r1, [sp, #0x20]
700a6fbc: f007 ffe0    	bl	0x700aef80 <UART_udmapSetReturnPolicy> @ imm = #0x7fc0
700a6fc0: 9b02         	ldr	r3, [sp, #0x8]
;     CSL_udmapCppi5LinkDesc(pHpd, 0U);
700a6fc2: 9805         	ldr	r0, [sp, #0x14]
700a6fc4: 461a         	mov	r2, r3
700a6fc6: f008 fbfb    	bl	0x700af7c0 <CSL_udmapCppi5LinkDesc> @ imm = #0x87f6
700a6fca: 9a02         	ldr	r2, [sp, #0x8]
;     CSL_udmapCppi5SetBufferAddr(pHpd, (uint64_t) Udma_defaultVirtToPhyFxn(destBuf, 0U, NULL));
700a6fcc: 9805         	ldr	r0, [sp, #0x14]
700a6fce: 9001         	str	r0, [sp, #0x4]
700a6fd0: 9807         	ldr	r0, [sp, #0x1c]
700a6fd2: 4611         	mov	r1, r2
700a6fd4: f008 fde4    	bl	0x700afba0 <Udma_defaultVirtToPhyFxn> @ imm = #0x8bc8
700a6fd8: 4602         	mov	r2, r0
700a6fda: 9801         	ldr	r0, [sp, #0x4]
700a6fdc: 460b         	mov	r3, r1
700a6fde: f008 fbff    	bl	0x700af7e0 <CSL_udmapCppi5SetBufferAddr> @ imm = #0x87fe
;     CSL_udmapCppi5SetBufferLen(pHpd, length);
700a6fe2: 9805         	ldr	r0, [sp, #0x14]
700a6fe4: 9906         	ldr	r1, [sp, #0x18]
700a6fe6: f008 fc0b    	bl	0x700af800 <CSL_udmapCppi5SetBufferLen> @ imm = #0x8816
700a6fea: 9a02         	ldr	r2, [sp, #0x8]
;     CSL_udmapCppi5SetOrgBufferAddr(pHpd, (uint64_t) Udma_defaultVirtToPhyFxn(destBuf, 0U, NULL));
700a6fec: 9805         	ldr	r0, [sp, #0x14]
700a6fee: 9003         	str	r0, [sp, #0xc]
700a6ff0: 9807         	ldr	r0, [sp, #0x1c]
700a6ff2: 4611         	mov	r1, r2
700a6ff4: f008 fdd4    	bl	0x700afba0 <Udma_defaultVirtToPhyFxn> @ imm = #0x8ba8
700a6ff8: 4602         	mov	r2, r0
700a6ffa: 9803         	ldr	r0, [sp, #0xc]
700a6ffc: 460b         	mov	r3, r1
700a6ffe: f008 fc0f    	bl	0x700af820 <CSL_udmapCppi5SetOrgBufferAddr> @ imm = #0x881e
;     CSL_udmapCppi5SetOrgBufferLen(pHpd, length);
700a7002: 9805         	ldr	r0, [sp, #0x14]
700a7004: 9906         	ldr	r1, [sp, #0x18]
700a7006: f008 fd9b    	bl	0x700afb40 <CSL_udmapCppi5SetOrgBufferLen> @ imm = #0x8b36
;     CacheP_wb(pHpdMem, sizeof(CSL_UdmapCppi5HMPD), CacheP_TYPE_ALLD);
700a700a: 9808         	ldr	r0, [sp, #0x20]
700a700c: 2130         	movs	r1, #0x30
700a700e: 220a         	movs	r2, #0xa
700a7010: f009 ed80    	blx	0x700b0b14 <CacheP_wb>  @ imm = #0x9b00
;     return;
700a7014: b00a         	add	sp, #0x28
700a7016: bd80         	pop	{r7, pc}
		...

700a7020 <Udma_eventCheckUnRegister>:
; {
700a7020: b580         	push	{r7, lr}
700a7022: b088         	sub	sp, #0x20
700a7024: 9007         	str	r0, [sp, #0x1c]
700a7026: 9106         	str	r1, [sp, #0x18]
700a7028: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a702a: 9005         	str	r0, [sp, #0x14]
;     eventPrms = &eventHandle->eventPrms;
700a702c: 9806         	ldr	r0, [sp, #0x18]
700a702e: 3008         	adds	r0, #0x8
700a7030: 9004         	str	r0, [sp, #0x10]
;     if(eventHandle->eventInitDone != UDMA_INIT_DONE)
700a7032: 9806         	ldr	r0, [sp, #0x18]
700a7034: f8d0 0098    	ldr.w	r0, [r0, #0x98]
700a7038: f64a 31cd    	movw	r1, #0xabcd
700a703c: f6ca 31dc    	movt	r1, #0xabdc
700a7040: 4288         	cmp	r0, r1
700a7042: d004         	beq	0x700a704e <Udma_eventCheckUnRegister+0x2e> @ imm = #0x8
700a7044: e7ff         	b	0x700a7046 <Udma_eventCheckUnRegister+0x26> @ imm = #-0x2
700a7046: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = UDMA_EFAIL;
700a704a: 9005         	str	r0, [sp, #0x14]
;     }
700a704c: e7ff         	b	0x700a704e <Udma_eventCheckUnRegister+0x2e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a704e: 9805         	ldr	r0, [sp, #0x14]
700a7050: b968         	cbnz	r0, 0x700a706e <Udma_eventCheckUnRegister+0x4e> @ imm = #0x1a
700a7052: e7ff         	b	0x700a7054 <Udma_eventCheckUnRegister+0x34> @ imm = #-0x2
;         if((NULL_PTR == eventPrms->controllerEventHandle) &&
700a7054: 9804         	ldr	r0, [sp, #0x10]
700a7056: 6900         	ldr	r0, [r0, #0x10]
700a7058: b940         	cbnz	r0, 0x700a706c <Udma_eventCheckUnRegister+0x4c> @ imm = #0x10
700a705a: e7ff         	b	0x700a705c <Udma_eventCheckUnRegister+0x3c> @ imm = #-0x2
;            (NULL_PTR != eventHandle->nextEvent))
700a705c: 9806         	ldr	r0, [sp, #0x18]
700a705e: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((NULL_PTR == eventPrms->controllerEventHandle) &&
700a7060: b120         	cbz	r0, 0x700a706c <Udma_eventCheckUnRegister+0x4c> @ imm = #0x8
700a7062: e7ff         	b	0x700a7064 <Udma_eventCheckUnRegister+0x44> @ imm = #-0x2
700a7064: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7068: 9005         	str	r0, [sp, #0x14]
;         }
700a706a: e7ff         	b	0x700a706c <Udma_eventCheckUnRegister+0x4c> @ imm = #-0x2
;     }
700a706c: e7ff         	b	0x700a706e <Udma_eventCheckUnRegister+0x4e> @ imm = #-0x2
;      if(UDMA_SOK == retVal)
700a706e: 9805         	ldr	r0, [sp, #0x14]
700a7070: bbb8         	cbnz	r0, 0x700a70e2 <Udma_eventCheckUnRegister+0xc2> @ imm = #0x6e
700a7072: e7ff         	b	0x700a7074 <Udma_eventCheckUnRegister+0x54> @ imm = #-0x2
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a7074: 9804         	ldr	r0, [sp, #0x10]
700a7076: 6800         	ldr	r0, [r0]
700a7078: 2801         	cmp	r0, #0x1
700a707a: d00a         	beq	0x700a7092 <Udma_eventCheckUnRegister+0x72> @ imm = #0x14
700a707c: e7ff         	b	0x700a707e <Udma_eventCheckUnRegister+0x5e> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType) ||
700a707e: 9804         	ldr	r0, [sp, #0x10]
700a7080: 6800         	ldr	r0, [r0]
700a7082: 2806         	cmp	r0, #0x6
700a7084: d005         	beq	0x700a7092 <Udma_eventCheckUnRegister+0x72> @ imm = #0xa
700a7086: e7ff         	b	0x700a7088 <Udma_eventCheckUnRegister+0x68> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_RING == eventPrms->eventType))
700a7088: 9804         	ldr	r0, [sp, #0x10]
700a708a: 6800         	ldr	r0, [r0]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a708c: 2804         	cmp	r0, #0x4
700a708e: d127         	bne	0x700a70e0 <Udma_eventCheckUnRegister+0xc0> @ imm = #0x4e
700a7090: e7ff         	b	0x700a7092 <Udma_eventCheckUnRegister+0x72> @ imm = #-0x2
;             if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
700a7092: 9804         	ldr	r0, [sp, #0x10]
700a7094: 6800         	ldr	r0, [r0]
700a7096: 2801         	cmp	r0, #0x1
700a7098: d005         	beq	0x700a70a6 <Udma_eventCheckUnRegister+0x86> @ imm = #0xa
700a709a: e7ff         	b	0x700a709c <Udma_eventCheckUnRegister+0x7c> @ imm = #-0x2
700a709c: 9804         	ldr	r0, [sp, #0x10]
700a709e: 6800         	ldr	r0, [r0]
700a70a0: 2806         	cmp	r0, #0x6
700a70a2: d106         	bne	0x700a70b2 <Udma_eventCheckUnRegister+0x92> @ imm = #0xc
700a70a4: e7ff         	b	0x700a70a6 <Udma_eventCheckUnRegister+0x86> @ imm = #-0x2
;                 ringHandle = ((Udma_ChHandleInt) (eventPrms->chHandle))->cqRing;
700a70a6: 9804         	ldr	r0, [sp, #0x10]
700a70a8: 6880         	ldr	r0, [r0, #0x8]
700a70aa: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a70ae: 9003         	str	r0, [sp, #0xc]
;             }
700a70b0: e003         	b	0x700a70ba <Udma_eventCheckUnRegister+0x9a> @ imm = #0x6
;                 ringHandle = eventPrms->ringHandle;
700a70b2: 9804         	ldr	r0, [sp, #0x10]
700a70b4: 68c0         	ldr	r0, [r0, #0xc]
700a70b6: 9003         	str	r0, [sp, #0xc]
700a70b8: e7ff         	b	0x700a70ba <Udma_eventCheckUnRegister+0x9a> @ imm = #-0x2
;             fOcc = Udma_ringGetForwardRingOcc(ringHandle);
700a70ba: 9803         	ldr	r0, [sp, #0xc]
700a70bc: f007 ff78    	bl	0x700aefb0 <Udma_ringGetForwardRingOcc> @ imm = #0x7ef0
700a70c0: 9002         	str	r0, [sp, #0x8]
;             rOcc = Udma_ringGetReverseRingOcc(ringHandle);
700a70c2: 9803         	ldr	r0, [sp, #0xc]
700a70c4: f007 ff8c    	bl	0x700aefe0 <Udma_ringGetReverseRingOcc> @ imm = #0x7f18
700a70c8: 9001         	str	r0, [sp, #0x4]
;             if((0U != fOcc) || (0U != rOcc))
700a70ca: 9802         	ldr	r0, [sp, #0x8]
700a70cc: b918         	cbnz	r0, 0x700a70d6 <Udma_eventCheckUnRegister+0xb6> @ imm = #0x6
700a70ce: e7ff         	b	0x700a70d0 <Udma_eventCheckUnRegister+0xb0> @ imm = #-0x2
700a70d0: 9801         	ldr	r0, [sp, #0x4]
700a70d2: b120         	cbz	r0, 0x700a70de <Udma_eventCheckUnRegister+0xbe> @ imm = #0x8
700a70d4: e7ff         	b	0x700a70d6 <Udma_eventCheckUnRegister+0xb6> @ imm = #-0x2
700a70d6: f04f 30ff    	mov.w	r0, #0xffffffff
;                 retVal = UDMA_EFAIL;
700a70da: 9005         	str	r0, [sp, #0x14]
;             }
700a70dc: e7ff         	b	0x700a70de <Udma_eventCheckUnRegister+0xbe> @ imm = #-0x2
;         }
700a70de: e7ff         	b	0x700a70e0 <Udma_eventCheckUnRegister+0xc0> @ imm = #-0x2
;     }
700a70e0: e7ff         	b	0x700a70e2 <Udma_eventCheckUnRegister+0xc2> @ imm = #-0x2
;     return (retVal);
700a70e2: 9805         	ldr	r0, [sp, #0x14]
700a70e4: b008         	add	sp, #0x20
700a70e6: bd80         	pop	{r7, pc}
		...

700a70f0 <Udma_ringFree>:
; {
700a70f0: b580         	push	{r7, lr}
700a70f2: b086         	sub	sp, #0x18
700a70f4: 9005         	str	r0, [sp, #0x14]
700a70f6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a70f8: 9004         	str	r0, [sp, #0x10]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a70fa: 9805         	ldr	r0, [sp, #0x14]
700a70fc: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == ringHandleInt)
700a70fe: 9802         	ldr	r0, [sp, #0x8]
700a7100: b920         	cbnz	r0, 0x700a710c <Udma_ringFree+0x1c> @ imm = #0x8
700a7102: e7ff         	b	0x700a7104 <Udma_ringFree+0x14> @ imm = #-0x2
700a7104: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a7108: 9004         	str	r0, [sp, #0x10]
;     }
700a710a: e7ff         	b	0x700a710c <Udma_ringFree+0x1c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a710c: 9804         	ldr	r0, [sp, #0x10]
700a710e: b970         	cbnz	r0, 0x700a712e <Udma_ringFree+0x3e> @ imm = #0x1c
700a7110: e7ff         	b	0x700a7112 <Udma_ringFree+0x22> @ imm = #-0x2
;         if(ringHandleInt->ringInitDone != UDMA_INIT_DONE)
700a7112: 9802         	ldr	r0, [sp, #0x8]
700a7114: 6d80         	ldr	r0, [r0, #0x58]
700a7116: f64a 31cd    	movw	r1, #0xabcd
700a711a: f6ca 31dc    	movt	r1, #0xabdc
700a711e: 4288         	cmp	r0, r1
700a7120: d004         	beq	0x700a712c <Udma_ringFree+0x3c> @ imm = #0x8
700a7122: e7ff         	b	0x700a7124 <Udma_ringFree+0x34> @ imm = #-0x2
700a7124: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7128: 9004         	str	r0, [sp, #0x10]
;         }
700a712a: e7ff         	b	0x700a712c <Udma_ringFree+0x3c> @ imm = #-0x2
;     }
700a712c: e7ff         	b	0x700a712e <Udma_ringFree+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a712e: 9804         	ldr	r0, [sp, #0x10]
700a7130: b9a8         	cbnz	r0, 0x700a715e <Udma_ringFree+0x6e> @ imm = #0x2a
700a7132: e7ff         	b	0x700a7134 <Udma_ringFree+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a7134: 9802         	ldr	r0, [sp, #0x8]
700a7136: 6800         	ldr	r0, [r0]
700a7138: 9003         	str	r0, [sp, #0xc]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a713a: 9803         	ldr	r0, [sp, #0xc]
700a713c: b150         	cbz	r0, 0x700a7154 <Udma_ringFree+0x64> @ imm = #0x14
700a713e: e7ff         	b	0x700a7140 <Udma_ringFree+0x50> @ imm = #-0x2
700a7140: 9803         	ldr	r0, [sp, #0xc]
700a7142: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a7146: f64a 31cd    	movw	r1, #0xabcd
700a714a: f6ca 31dc    	movt	r1, #0xabdc
700a714e: 4288         	cmp	r0, r1
700a7150: d004         	beq	0x700a715c <Udma_ringFree+0x6c> @ imm = #0x8
700a7152: e7ff         	b	0x700a7154 <Udma_ringFree+0x64> @ imm = #-0x2
700a7154: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7158: 9004         	str	r0, [sp, #0x10]
;         }
700a715a: e7ff         	b	0x700a715c <Udma_ringFree+0x6c> @ imm = #-0x2
;     }
700a715c: e7ff         	b	0x700a715e <Udma_ringFree+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a715e: 9804         	ldr	r0, [sp, #0x10]
700a7160: bb38         	cbnz	r0, 0x700a71b2 <Udma_ringFree+0xc2> @ imm = #0x4e
700a7162: e7ff         	b	0x700a7164 <Udma_ringFree+0x74> @ imm = #-0x2
;         if(UDMA_MAPPED_GROUP_INVALID == ringHandleInt->mappedRingGrp)
700a7164: 9802         	ldr	r0, [sp, #0x8]
700a7166: 6dc0         	ldr	r0, [r0, #0x5c]
700a7168: 2104         	movs	r1, #0x4
700a716a: f6cf 71ff    	movt	r1, #0xffff
700a716e: 4288         	cmp	r0, r1
700a7170: d106         	bne	0x700a7180 <Udma_ringFree+0x90> @ imm = #0xc
700a7172: e7ff         	b	0x700a7174 <Udma_ringFree+0x84> @ imm = #-0x2
;             Udma_rmFreeFreeRing(ringHandleInt->ringNum, drvHandle);
700a7174: 9802         	ldr	r0, [sp, #0x8]
700a7176: 8880         	ldrh	r0, [r0, #0x4]
700a7178: 9903         	ldr	r1, [sp, #0xc]
700a717a: f008 fd91    	bl	0x700afca0 <Udma_rmFreeFreeRing> @ imm = #0x8b22
;         }
700a717e: e007         	b	0x700a7190 <Udma_ringFree+0xa0> @ imm = #0xe
;                 ringHandleInt->ringNum,
700a7180: 9b02         	ldr	r3, [sp, #0x8]
700a7182: 8898         	ldrh	r0, [r3, #0x4]
;                 drvHandle,
700a7184: 9903         	ldr	r1, [sp, #0xc]
;                 ringHandleInt->mappedRingGrp,
700a7186: 6dda         	ldr	r2, [r3, #0x5c]
;                 ringHandleInt->mappedChNum);
700a7188: 6e1b         	ldr	r3, [r3, #0x60]
;             Udma_rmFreeMappedRing(
700a718a: f002 fe19    	bl	0x700a9dc0 <Udma_rmFreeMappedRing> @ imm = #0x2c32
700a718e: e7ff         	b	0x700a7190 <Udma_ringFree+0xa0> @ imm = #-0x2
;         ringHandleInt->ringNum         = UDMA_RING_INVALID;
700a7190: 9902         	ldr	r1, [sp, #0x8]
700a7192: f64f 70ff    	movw	r0, #0xffff
700a7196: 8088         	strh	r0, [r1, #0x4]
;         ringHandleInt->ringInitDone    = UDMA_DEINIT_DONE;
700a7198: 9902         	ldr	r1, [sp, #0x8]
700a719a: 2000         	movs	r0, #0x0
700a719c: 9001         	str	r0, [sp, #0x4]
700a719e: 6588         	str	r0, [r1, #0x58]
;         drvHandle->ringHandleClearRegs(ringHandleInt);
700a71a0: 9803         	ldr	r0, [sp, #0xc]
700a71a2: f8d0 15c8    	ldr.w	r1, [r0, #0x5c8]
700a71a6: 9802         	ldr	r0, [sp, #0x8]
700a71a8: 4788         	blx	r1
700a71aa: 9801         	ldr	r0, [sp, #0x4]
;         ringHandleInt->drvHandle       = (Udma_DrvHandleInt) NULL_PTR;
700a71ac: 9902         	ldr	r1, [sp, #0x8]
700a71ae: 6008         	str	r0, [r1]
;     }
700a71b0: e7ff         	b	0x700a71b2 <Udma_ringFree+0xc2> @ imm = #-0x2
;     return (retVal);
700a71b2: 9804         	ldr	r0, [sp, #0x10]
700a71b4: b006         	add	sp, #0x18
700a71b6: bd80         	pop	{r7, pc}
		...

700a71c0 <UART_lld_writeIntr>:
; {
700a71c0: b580         	push	{r7, lr}
700a71c2: b086         	sub	sp, #0x18
700a71c4: 9005         	str	r0, [sp, #0x14]
700a71c6: 9104         	str	r1, [sp, #0x10]
700a71c8: 9203         	str	r2, [sp, #0xc]
700a71ca: 9302         	str	r3, [sp, #0x8]
700a71cc: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a71ce: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a71d0: 9805         	ldr	r0, [sp, #0x14]
700a71d2: 2800         	cmp	r0, #0x0
700a71d4: d050         	beq	0x700a7278 <UART_lld_writeIntr+0xb8> @ imm = #0xa0
700a71d6: e7ff         	b	0x700a71d8 <UART_lld_writeIntr+0x18> @ imm = #-0x2
;         trans = &hUart->writeTrans;
700a71d8: 9805         	ldr	r0, [sp, #0x14]
700a71da: 303c         	adds	r0, #0x3c
700a71dc: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a71de: 9800         	ldr	r0, [sp]
700a71e0: 6800         	ldr	r0, [r0]
700a71e2: b138         	cbz	r0, 0x700a71f4 <UART_lld_writeIntr+0x34> @ imm = #0xe
700a71e4: e7ff         	b	0x700a71e6 <UART_lld_writeIntr+0x26> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a71e6: 9900         	ldr	r1, [sp]
700a71e8: 2009         	movs	r0, #0x9
700a71ea: 60c8         	str	r0, [r1, #0xc]
700a71ec: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a71f0: 9001         	str	r0, [sp, #0x4]
;         }
700a71f2: e040         	b	0x700a7276 <UART_lld_writeIntr+0xb6> @ imm = #0x80
;             UART_lld_Transaction_init(trans);
700a71f4: 9800         	ldr	r0, [sp]
700a71f6: f007 fdeb    	bl	0x700aedd0 <UART_lld_Transaction_init> @ imm = #0x7bd6
;             if(extendedParams != NULL)
700a71fa: 9802         	ldr	r0, [sp, #0x8]
700a71fc: b128         	cbz	r0, 0x700a720a <UART_lld_writeIntr+0x4a> @ imm = #0xa
700a71fe: e7ff         	b	0x700a7200 <UART_lld_writeIntr+0x40> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a7200: 9802         	ldr	r0, [sp, #0x8]
700a7202: 6800         	ldr	r0, [r0]
700a7204: 9900         	ldr	r1, [sp]
700a7206: 6108         	str	r0, [r1, #0x10]
;             }
700a7208: e003         	b	0x700a7212 <UART_lld_writeIntr+0x52> @ imm = #0x6
;                 trans->args = NULL;
700a720a: 9900         	ldr	r1, [sp]
700a720c: 2000         	movs	r0, #0x0
700a720e: 6108         	str	r0, [r1, #0x10]
700a7210: e7ff         	b	0x700a7212 <UART_lld_writeIntr+0x52> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a7212: 9804         	ldr	r0, [sp, #0x10]
700a7214: 9900         	ldr	r1, [sp]
700a7216: 6008         	str	r0, [r1]
;             trans->count = size;
700a7218: 9803         	ldr	r0, [sp, #0xc]
700a721a: 9900         	ldr	r1, [sp]
700a721c: 6048         	str	r0, [r1, #0x4]
;             if(hUart->state == UART_STATE_READY)
700a721e: 9805         	ldr	r0, [sp, #0x14]
700a7220: 6d40         	ldr	r0, [r0, #0x54]
700a7222: 2801         	cmp	r0, #0x1
700a7224: d105         	bne	0x700a7232 <UART_lld_writeIntr+0x72> @ imm = #0xa
700a7226: e7ff         	b	0x700a7228 <UART_lld_writeIntr+0x68> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a7228: 9800         	ldr	r0, [sp]
700a722a: f007 f9d1    	bl	0x700ae5d0 <UART_checkTransaction> @ imm = #0x73a2
700a722e: 9001         	str	r0, [sp, #0x4]
;             }
700a7230: e003         	b	0x700a723a <UART_lld_writeIntr+0x7a> @ imm = #0x6
700a7232: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a7236: 9001         	str	r0, [sp, #0x4]
700a7238: e7ff         	b	0x700a723a <UART_lld_writeIntr+0x7a> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a723a: 9801         	ldr	r0, [sp, #0x4]
700a723c: b9d0         	cbnz	r0, 0x700a7274 <UART_lld_writeIntr+0xb4> @ imm = #0x34
700a723e: e7ff         	b	0x700a7240 <UART_lld_writeIntr+0x80> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a7240: 9800         	ldr	r0, [sp]
700a7242: 6800         	ldr	r0, [r0]
700a7244: 9905         	ldr	r1, [sp, #0x14]
700a7246: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a7248: 9800         	ldr	r0, [sp]
700a724a: 6880         	ldr	r0, [r0, #0x8]
700a724c: 9905         	ldr	r1, [sp, #0x14]
700a724e: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a7250: 9905         	ldr	r1, [sp, #0x14]
700a7252: 2000         	movs	r0, #0x0
700a7254: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a7256: 9800         	ldr	r0, [sp]
700a7258: 6840         	ldr	r0, [r0, #0x4]
700a725a: 9905         	ldr	r1, [sp, #0x14]
700a725c: 6108         	str	r0, [r1, #0x10]
;                 hUart->state = UART_STATE_BUSY;
700a725e: 9905         	ldr	r1, [sp, #0x14]
700a7260: 2002         	movs	r0, #0x2
700a7262: 6548         	str	r0, [r1, #0x54]
;                 status = UART_writeInterrupt(hUart);
700a7264: 9805         	ldr	r0, [sp, #0x14]
700a7266: f008 f923    	bl	0x700af4b0 <UART_writeInterrupt> @ imm = #0x8246
700a726a: 9001         	str	r0, [sp, #0x4]
;                 hUart->state = UART_STATE_READY;
700a726c: 9905         	ldr	r1, [sp, #0x14]
700a726e: 2001         	movs	r0, #0x1
700a7270: 6548         	str	r0, [r1, #0x54]
;             }
700a7272: e7ff         	b	0x700a7274 <UART_lld_writeIntr+0xb4> @ imm = #-0x2
700a7274: e7ff         	b	0x700a7276 <UART_lld_writeIntr+0xb6> @ imm = #-0x2
;     }
700a7276: e003         	b	0x700a7280 <UART_lld_writeIntr+0xc0> @ imm = #0x6
700a7278: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a727c: 9001         	str	r0, [sp, #0x4]
700a727e: e7ff         	b	0x700a7280 <UART_lld_writeIntr+0xc0> @ imm = #-0x2
;     return status;
700a7280: 9801         	ldr	r0, [sp, #0x4]
700a7282: b006         	add	sp, #0x18
700a7284: bd80         	pop	{r7, pc}
		...
700a728e: 0000         	movs	r0, r0

700a7290 <Udma_eventUnRegister>:
; {
700a7290: b580         	push	{r7, lr}
700a7292: b084         	sub	sp, #0x10
700a7294: 9003         	str	r0, [sp, #0xc]
700a7296: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a7298: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == eventHandle)
700a729a: 9803         	ldr	r0, [sp, #0xc]
700a729c: b920         	cbnz	r0, 0x700a72a8 <Udma_eventUnRegister+0x18> @ imm = #0x8
700a729e: e7ff         	b	0x700a72a0 <Udma_eventUnRegister+0x10> @ imm = #-0x2
700a72a0: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a72a4: 9002         	str	r0, [sp, #0x8]
;     }
700a72a6: e7ff         	b	0x700a72a8 <Udma_eventUnRegister+0x18> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a72a8: 9802         	ldr	r0, [sp, #0x8]
700a72aa: b9b8         	cbnz	r0, 0x700a72dc <Udma_eventUnRegister+0x4c> @ imm = #0x2e
700a72ac: e7ff         	b	0x700a72ae <Udma_eventUnRegister+0x1e> @ imm = #-0x2
;         eventHandleInt = (Udma_EventHandleInt) eventHandle;
700a72ae: 9803         	ldr	r0, [sp, #0xc]
700a72b0: 9000         	str	r0, [sp]
;         drvHandle = eventHandleInt->drvHandle;
700a72b2: 9800         	ldr	r0, [sp]
700a72b4: 6800         	ldr	r0, [r0]
700a72b6: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a72b8: 9801         	ldr	r0, [sp, #0x4]
700a72ba: b150         	cbz	r0, 0x700a72d2 <Udma_eventUnRegister+0x42> @ imm = #0x14
700a72bc: e7ff         	b	0x700a72be <Udma_eventUnRegister+0x2e> @ imm = #-0x2
700a72be: 9801         	ldr	r0, [sp, #0x4]
700a72c0: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a72c4: f64a 31cd    	movw	r1, #0xabcd
700a72c8: f6ca 31dc    	movt	r1, #0xabdc
700a72cc: 4288         	cmp	r0, r1
700a72ce: d004         	beq	0x700a72da <Udma_eventUnRegister+0x4a> @ imm = #0x8
700a72d0: e7ff         	b	0x700a72d2 <Udma_eventUnRegister+0x42> @ imm = #-0x2
700a72d2: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a72d6: 9002         	str	r0, [sp, #0x8]
;         }
700a72d8: e7ff         	b	0x700a72da <Udma_eventUnRegister+0x4a> @ imm = #-0x2
;     }
700a72da: e7ff         	b	0x700a72dc <Udma_eventUnRegister+0x4c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a72dc: 9802         	ldr	r0, [sp, #0x8]
700a72de: bbb8         	cbnz	r0, 0x700a7350 <Udma_eventUnRegister+0xc0> @ imm = #0x6e
700a72e0: e7ff         	b	0x700a72e2 <Udma_eventUnRegister+0x52> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandle->instType) &&
700a72e2: 9801         	ldr	r0, [sp, #0x4]
700a72e4: 6800         	ldr	r0, [r0]
700a72e6: b130         	cbz	r0, 0x700a72f6 <Udma_eventUnRegister+0x66> @ imm = #0xc
700a72e8: e7ff         	b	0x700a72ea <Udma_eventUnRegister+0x5a> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventHandleInt->eventPrms.eventType))
700a72ea: 9800         	ldr	r0, [sp]
700a72ec: 6880         	ldr	r0, [r0, #0x8]
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandle->instType) &&
700a72ee: 2802         	cmp	r0, #0x2
700a72f0: d101         	bne	0x700a72f6 <Udma_eventUnRegister+0x66> @ imm = #0x2
700a72f2: e7ff         	b	0x700a72f4 <Udma_eventUnRegister+0x64> @ imm = #-0x2
;         }
700a72f4: e02b         	b	0x700a734e <Udma_eventUnRegister+0xbe> @ imm = #0x56
;             retVal = Udma_eventCheckUnRegister(drvHandle, eventHandleInt);
700a72f6: 9801         	ldr	r0, [sp, #0x4]
700a72f8: 9900         	ldr	r1, [sp]
700a72fa: f7ff fe91    	bl	0x700a7020 <Udma_eventCheckUnRegister> @ imm = #-0x2de
700a72fe: 9002         	str	r0, [sp, #0x8]
;             if(UDMA_SOK == retVal)
700a7300: 9802         	ldr	r0, [sp, #0x8]
700a7302: bb18         	cbnz	r0, 0x700a734c <Udma_eventUnRegister+0xbc> @ imm = #0x46
700a7304: e7ff         	b	0x700a7306 <Udma_eventUnRegister+0x76> @ imm = #-0x2
;                 if(NULL_PTR != eventHandleInt->hwiHandle)
700a7306: 9800         	ldr	r0, [sp]
700a7308: 6e40         	ldr	r0, [r0, #0x64]
700a730a: b128         	cbz	r0, 0x700a7318 <Udma_eventUnRegister+0x88> @ imm = #0xa
700a730c: e7ff         	b	0x700a730e <Udma_eventUnRegister+0x7e> @ imm = #-0x2
;                     HwiP_disableInt(eventHandleInt->coreIntrNum);
700a730e: 9800         	ldr	r0, [sp]
700a7310: 6d80         	ldr	r0, [r0, #0x58]
700a7312: f008 fd95    	bl	0x700afe40 <HwiP_disableInt> @ imm = #0x8b2a
;                 }
700a7316: e7ff         	b	0x700a7318 <Udma_eventUnRegister+0x88> @ imm = #-0x2
;                 retVal = Udma_eventReset(drvHandle, eventHandleInt);
700a7318: 9801         	ldr	r0, [sp, #0x4]
700a731a: 9900         	ldr	r1, [sp]
700a731c: f7f5 fe70    	bl	0x7009d000 <Udma_eventReset> @ imm = #-0xa320
700a7320: 9002         	str	r0, [sp, #0x8]
;                 if(UDMA_SOK != retVal)
700a7322: 9802         	ldr	r0, [sp, #0x8]
700a7324: b108         	cbz	r0, 0x700a732a <Udma_eventUnRegister+0x9a> @ imm = #0x2
700a7326: e7ff         	b	0x700a7328 <Udma_eventUnRegister+0x98> @ imm = #-0x2
;                 }
700a7328: e7ff         	b	0x700a732a <Udma_eventUnRegister+0x9a> @ imm = #-0x2
;                 Udma_eventFreeResource(drvHandle, eventHandleInt);
700a732a: 9801         	ldr	r0, [sp, #0x4]
700a732c: 9900         	ldr	r1, [sp]
700a732e: f7fe fcef    	bl	0x700a5d10 <Udma_eventFreeResource> @ imm = #-0x1622
;                 eventHandleInt->eventInitDone  = UDMA_DEINIT_DONE;
700a7332: 9900         	ldr	r1, [sp]
700a7334: 2000         	movs	r0, #0x0
700a7336: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 eventHandleInt->pIaGeviRegs    = (volatile CSL_intaggr_imapRegs_gevi *) NULL_PTR;
700a733a: 9900         	ldr	r1, [sp]
700a733c: f8c1 0090    	str.w	r0, [r1, #0x90]
;                 eventHandleInt->pIaVintrRegs   = (volatile CSL_intaggr_intrRegs_vint *) NULL_PTR;
700a7340: 9900         	ldr	r1, [sp]
700a7342: f8c1 0094    	str.w	r0, [r1, #0x94]
;                 eventHandleInt->drvHandle      = (Udma_DrvHandleInt) NULL_PTR;
700a7346: 9900         	ldr	r1, [sp]
700a7348: 6008         	str	r0, [r1]
;             }
700a734a: e7ff         	b	0x700a734c <Udma_eventUnRegister+0xbc> @ imm = #-0x2
700a734c: e7ff         	b	0x700a734e <Udma_eventUnRegister+0xbe> @ imm = #-0x2
;     }
700a734e: e7ff         	b	0x700a7350 <Udma_eventUnRegister+0xc0> @ imm = #-0x2
;     return (retVal);
700a7350: 9802         	ldr	r0, [sp, #0x8]
700a7352: b004         	add	sp, #0x10
700a7354: bd80         	pop	{r7, pc}
		...
700a735e: 0000         	movs	r0, r0

700a7360 <Sciclient_rmIrqIsVintRouteSet>:
; {
700a7360: b580         	push	{r7, lr}
700a7362: b088         	sub	sp, #0x20
700a7364: 9007         	str	r0, [sp, #0x1c]
700a7366: 9106         	str	r1, [sp, #0x18]
700a7368: 2000         	movs	r0, #0x0
;     bool found_iface = false;
700a736a: f88d 0007    	strb.w	r0, [sp, #0x7]
;     *vint_used = false;
700a736e: 9906         	ldr	r1, [sp, #0x18]
700a7370: 7008         	strb	r0, [r1]
;     r = Sciclient_rmIrqGetNode(cfg->s_ia, &ia_node);
700a7372: 9807         	ldr	r0, [sp, #0x1c]
700a7374: 8a00         	ldrh	r0, [r0, #0x10]
700a7376: a903         	add	r1, sp, #0xc
700a7378: f7fe fdba    	bl	0x700a5ef0 <Sciclient_rmIrqGetNode> @ imm = #-0x148c
700a737c: 9005         	str	r0, [sp, #0x14]
;     if (r == SystemP_SUCCESS) {
700a737e: 9805         	ldr	r0, [sp, #0x14]
700a7380: bb90         	cbnz	r0, 0x700a73e8 <Sciclient_rmIrqIsVintRouteSet+0x88> @ imm = #0x64
700a7382: e7ff         	b	0x700a7384 <Sciclient_rmIrqIsVintRouteSet+0x24> @ imm = #-0x2
700a7384: 2000         	movs	r0, #0x0
;         for (i = 0U; i < ia_node->n_if; i++) {
700a7386: f8ad 0012    	strh.w	r0, [sp, #0x12]
700a738a: e7ff         	b	0x700a738c <Sciclient_rmIrqIsVintRouteSet+0x2c> @ imm = #-0x2
700a738c: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a7390: 9903         	ldr	r1, [sp, #0xc]
700a7392: 8849         	ldrh	r1, [r1, #0x2]
700a7394: 4288         	cmp	r0, r1
700a7396: da26         	bge	0x700a73e6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0x4c
700a7398: e7ff         	b	0x700a739a <Sciclient_rmIrqIsVintRouteSet+0x3a> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(ia_node, i, &iface);
700a739a: 9803         	ldr	r0, [sp, #0xc]
700a739c: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a73a0: aa02         	add	r2, sp, #0x8
700a73a2: f006 fb75    	bl	0x700ada90 <Sciclient_rmIrqGetNodeItf> @ imm = #0x66ea
700a73a6: 9005         	str	r0, [sp, #0x14]
;             if (r != SystemP_SUCCESS) {
700a73a8: 9805         	ldr	r0, [sp, #0x14]
700a73aa: b108         	cbz	r0, 0x700a73b0 <Sciclient_rmIrqIsVintRouteSet+0x50> @ imm = #0x2
700a73ac: e7ff         	b	0x700a73ae <Sciclient_rmIrqIsVintRouteSet+0x4e> @ imm = #-0x2
;                 break;
700a73ae: e01a         	b	0x700a73e6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0x34
;             if ((cfg->vint >= iface->lbase) &&
700a73b0: 9807         	ldr	r0, [sp, #0x1c]
700a73b2: 8a40         	ldrh	r0, [r0, #0x12]
700a73b4: 9902         	ldr	r1, [sp, #0x8]
700a73b6: 8809         	ldrh	r1, [r1]
700a73b8: 4288         	cmp	r0, r1
700a73ba: db0d         	blt	0x700a73d8 <Sciclient_rmIrqIsVintRouteSet+0x78> @ imm = #0x1a
700a73bc: e7ff         	b	0x700a73be <Sciclient_rmIrqIsVintRouteSet+0x5e> @ imm = #-0x2
;                 (cfg->vint < (iface->lbase + iface->len))) {
700a73be: 9807         	ldr	r0, [sp, #0x1c]
700a73c0: 8a40         	ldrh	r0, [r0, #0x12]
700a73c2: 9a02         	ldr	r2, [sp, #0x8]
700a73c4: 8811         	ldrh	r1, [r2]
700a73c6: 8892         	ldrh	r2, [r2, #0x4]
700a73c8: 4411         	add	r1, r2
;             if ((cfg->vint >= iface->lbase) &&
700a73ca: 4288         	cmp	r0, r1
700a73cc: da04         	bge	0x700a73d8 <Sciclient_rmIrqIsVintRouteSet+0x78> @ imm = #0x8
700a73ce: e7ff         	b	0x700a73d0 <Sciclient_rmIrqIsVintRouteSet+0x70> @ imm = #-0x2
700a73d0: 2001         	movs	r0, #0x1
;                 found_iface = true;
700a73d2: f88d 0007    	strb.w	r0, [sp, #0x7]
;                 break;
700a73d6: e006         	b	0x700a73e6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0xc
;         }
700a73d8: e7ff         	b	0x700a73da <Sciclient_rmIrqIsVintRouteSet+0x7a> @ imm = #-0x2
;         for (i = 0U; i < ia_node->n_if; i++) {
700a73da: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a73de: 3001         	adds	r0, #0x1
700a73e0: f8ad 0012    	strh.w	r0, [sp, #0x12]
700a73e4: e7d2         	b	0x700a738c <Sciclient_rmIrqIsVintRouteSet+0x2c> @ imm = #-0x5c
;     }
700a73e6: e7ff         	b	0x700a73e8 <Sciclient_rmIrqIsVintRouteSet+0x88> @ imm = #-0x2
;     if (found_iface) {
700a73e8: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700a73ec: 07c0         	lsls	r0, r0, #0x1f
700a73ee: b1b0         	cbz	r0, 0x700a741e <Sciclient_rmIrqIsVintRouteSet+0xbe> @ imm = #0x2c
700a73f0: e7ff         	b	0x700a73f2 <Sciclient_rmIrqIsVintRouteSet+0x92> @ imm = #-0x2
;         ir_inp = SCICLIENT_OUTP_TO_INP(cfg->vint, iface->lbase, iface->rbase);
700a73f2: 9a02         	ldr	r2, [sp, #0x8]
700a73f4: 8850         	ldrh	r0, [r2, #0x2]
700a73f6: 9907         	ldr	r1, [sp, #0x1c]
700a73f8: 8a49         	ldrh	r1, [r1, #0x12]
700a73fa: 8812         	ldrh	r2, [r2]
700a73fc: 1a89         	subs	r1, r1, r2
700a73fe: 4408         	add	r0, r1
700a7400: f8ad 0004    	strh.w	r0, [sp, #0x4]
;         if (Sciclient_rmIrInpIsFree(iface->rid, ir_inp) != SystemP_SUCCESS) {
700a7404: 9802         	ldr	r0, [sp, #0x8]
700a7406: 88c0         	ldrh	r0, [r0, #0x6]
700a7408: f8bd 1004    	ldrh.w	r1, [sp, #0x4]
700a740c: f7fe ff38    	bl	0x700a6280 <Sciclient_rmIrInpIsFree> @ imm = #-0x1190
700a7410: b120         	cbz	r0, 0x700a741c <Sciclient_rmIrqIsVintRouteSet+0xbc> @ imm = #0x8
700a7412: e7ff         	b	0x700a7414 <Sciclient_rmIrqIsVintRouteSet+0xb4> @ imm = #-0x2
;             *vint_used = true;
700a7414: 9906         	ldr	r1, [sp, #0x18]
700a7416: 2001         	movs	r0, #0x1
700a7418: 7008         	strb	r0, [r1]
;         }
700a741a: e7ff         	b	0x700a741c <Sciclient_rmIrqIsVintRouteSet+0xbc> @ imm = #-0x2
;     }
700a741c: e7ff         	b	0x700a741e <Sciclient_rmIrqIsVintRouteSet+0xbe> @ imm = #-0x2
;     return r;
700a741e: 9805         	ldr	r0, [sp, #0x14]
700a7420: b008         	add	sp, #0x20
700a7422: bd80         	pop	{r7, pc}
		...

700a7430 <UART_flushTxFifo>:
; {
700a7430: b580         	push	{r7, lr}
700a7432: b08a         	sub	sp, #0x28
700a7434: 9009         	str	r0, [sp, #0x24]
700a7436: f640 30b8    	movw	r0, #0xbb8
;     uint32_t            timeout = UART_TRANSMITEMPTY_TRIALCOUNT;
700a743a: 9003         	str	r0, [sp, #0xc]
700a743c: 2000         	movs	r0, #0x0
;     uint32_t            timeoutElapsed  = FALSE;
700a743e: 9002         	str	r0, [sp, #0x8]
;     config = (UART_Config *) handle;
700a7440: 9809         	ldr	r0, [sp, #0x24]
700a7442: 9008         	str	r0, [sp, #0x20]
;     if (NULL != config)
700a7444: 9808         	ldr	r0, [sp, #0x20]
700a7446: 2800         	cmp	r0, #0x0
700a7448: d052         	beq	0x700a74f0 <UART_flushTxFifo+0xc0> @ imm = #0xa4
700a744a: e7ff         	b	0x700a744c <UART_flushTxFifo+0x1c> @ imm = #-0x2
;         attrs = config->attrs;
700a744c: 9808         	ldr	r0, [sp, #0x20]
700a744e: 6800         	ldr	r0, [r0]
700a7450: 9007         	str	r0, [sp, #0x1c]
;         DebugP_assert(NULL_PTR != attrs);
700a7452: 9807         	ldr	r0, [sp, #0x1c]
700a7454: 2800         	cmp	r0, #0x0
700a7456: bf18         	it	ne
700a7458: 2001         	movne	r0, #0x1
700a745a: f242 0129    	movw	r1, #0x2029
700a745e: f2c7 010b    	movt	r1, #0x700b
700a7462: 466a         	mov	r2, sp
700a7464: 6011         	str	r1, [r2]
700a7466: f641 71e1    	movw	r1, #0x1fe1
700a746a: f2c7 010b    	movt	r1, #0x700b
700a746e: f242 0280    	movw	r2, #0x2080
700a7472: f2c7 020b    	movt	r2, #0x700b
700a7476: f240 3355    	movw	r3, #0x355
700a747a: f003 fc09    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x3812
;         startTicks = ClockP_getTicks();
700a747e: f008 fc37    	bl	0x700afcf0 <ClockP_getTicks> @ imm = #0x886e
700a7482: 9005         	str	r0, [sp, #0x14]
;         while (FALSE == timeoutElapsed)
700a7484: e7ff         	b	0x700a7486 <UART_flushTxFifo+0x56> @ imm = #-0x2
700a7486: 9802         	ldr	r0, [sp, #0x8]
700a7488: b9d8         	cbnz	r0, 0x700a74c2 <UART_flushTxFifo+0x92> @ imm = #0x36
700a748a: e7ff         	b	0x700a748c <UART_flushTxFifo+0x5c> @ imm = #-0x2
;             isTxFifoEmpty = UART_spaceAvail(attrs->baseAddr);
700a748c: 9807         	ldr	r0, [sp, #0x1c]
700a748e: 6800         	ldr	r0, [r0]
700a7490: f006 fd1e    	bl	0x700aded0 <UART_spaceAvail> @ imm = #0x6a3c
700a7494: 9006         	str	r0, [sp, #0x18]
;             if (TRUE == isTxFifoEmpty)
700a7496: 9806         	ldr	r0, [sp, #0x18]
700a7498: 2801         	cmp	r0, #0x1
700a749a: d101         	bne	0x700a74a0 <UART_flushTxFifo+0x70> @ imm = #0x2
700a749c: e7ff         	b	0x700a749e <UART_flushTxFifo+0x6e> @ imm = #-0x2
;                 break;
700a749e: e010         	b	0x700a74c2 <UART_flushTxFifo+0x92> @ imm = #0x20
;             elapsedTicks = ClockP_getTicks() - startTicks;
700a74a0: f008 fc26    	bl	0x700afcf0 <ClockP_getTicks> @ imm = #0x884c
700a74a4: 9905         	ldr	r1, [sp, #0x14]
700a74a6: 1a40         	subs	r0, r0, r1
700a74a8: 9004         	str	r0, [sp, #0x10]
;             if (elapsedTicks >= timeout)
700a74aa: 9804         	ldr	r0, [sp, #0x10]
700a74ac: 9903         	ldr	r1, [sp, #0xc]
700a74ae: 4288         	cmp	r0, r1
700a74b0: d303         	blo	0x700a74ba <UART_flushTxFifo+0x8a> @ imm = #0x6
700a74b2: e7ff         	b	0x700a74b4 <UART_flushTxFifo+0x84> @ imm = #-0x2
700a74b4: 2001         	movs	r0, #0x1
;                 timeoutElapsed = TRUE;
700a74b6: 9002         	str	r0, [sp, #0x8]
;             }
700a74b8: e002         	b	0x700a74c0 <UART_flushTxFifo+0x90> @ imm = #0x4
;                 TaskP_yield();
700a74ba: f008 fc51    	bl	0x700afd60 <TaskP_yield> @ imm = #0x88a2
700a74be: e7ff         	b	0x700a74c0 <UART_flushTxFifo+0x90> @ imm = #-0x2
;         while (FALSE == timeoutElapsed)
700a74c0: e7e1         	b	0x700a7486 <UART_flushTxFifo+0x56> @ imm = #-0x3e
;         DebugP_assert(FALSE == timeoutElapsed);
700a74c2: 9802         	ldr	r0, [sp, #0x8]
700a74c4: fab0 f080    	clz	r0, r0
700a74c8: 0940         	lsrs	r0, r0, #0x5
700a74ca: f641 61d3    	movw	r1, #0x1ed3
700a74ce: f2c7 010b    	movt	r1, #0x700b
700a74d2: 466a         	mov	r2, sp
700a74d4: 6011         	str	r1, [r2]
700a74d6: f641 71e1    	movw	r1, #0x1fe1
700a74da: f2c7 010b    	movt	r1, #0x700b
700a74de: f242 0280    	movw	r2, #0x2080
700a74e2: f2c7 020b    	movt	r2, #0x700b
700a74e6: f240 336f    	movw	r3, #0x36f
700a74ea: f003 fbd1    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x37a2
;     }
700a74ee: e7ff         	b	0x700a74f0 <UART_flushTxFifo+0xc0> @ imm = #-0x2
;     return;
700a74f0: b00a         	add	sp, #0x28
700a74f2: bd80         	pop	{r7, pc}
		...

700a7500 <Udma_chClose>:
; {
700a7500: b580         	push	{r7, lr}
700a7502: b084         	sub	sp, #0x10
700a7504: 9003         	str	r0, [sp, #0xc]
700a7506: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a7508: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a750a: 9803         	ldr	r0, [sp, #0xc]
700a750c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a750e: 9800         	ldr	r0, [sp]
700a7510: b150         	cbz	r0, 0x700a7528 <Udma_chClose+0x28> @ imm = #0x14
700a7512: e7ff         	b	0x700a7514 <Udma_chClose+0x14> @ imm = #-0x2
700a7514: 9800         	ldr	r0, [sp]
700a7516: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a751a: f64a 31cd    	movw	r1, #0xabcd
700a751e: f6ca 31dc    	movt	r1, #0xabdc
700a7522: 4288         	cmp	r0, r1
700a7524: d004         	beq	0x700a7530 <Udma_chClose+0x30> @ imm = #0x8
700a7526: e7ff         	b	0x700a7528 <Udma_chClose+0x28> @ imm = #-0x2
700a7528: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a752c: 9002         	str	r0, [sp, #0x8]
;     }
700a752e: e7ff         	b	0x700a7530 <Udma_chClose+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7530: 9802         	ldr	r0, [sp, #0x8]
700a7532: b9a8         	cbnz	r0, 0x700a7560 <Udma_chClose+0x60> @ imm = #0x2a
700a7534: e7ff         	b	0x700a7536 <Udma_chClose+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a7536: 9800         	ldr	r0, [sp]
700a7538: 6e80         	ldr	r0, [r0, #0x68]
700a753a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a753c: 9801         	ldr	r0, [sp, #0x4]
700a753e: b150         	cbz	r0, 0x700a7556 <Udma_chClose+0x56> @ imm = #0x14
700a7540: e7ff         	b	0x700a7542 <Udma_chClose+0x42> @ imm = #-0x2
700a7542: 9801         	ldr	r0, [sp, #0x4]
700a7544: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a7548: f64a 31cd    	movw	r1, #0xabcd
700a754c: f6ca 31dc    	movt	r1, #0xabdc
700a7550: 4288         	cmp	r0, r1
700a7552: d004         	beq	0x700a755e <Udma_chClose+0x5e> @ imm = #0x8
700a7554: e7ff         	b	0x700a7556 <Udma_chClose+0x56> @ imm = #-0x2
700a7556: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a755a: 9002         	str	r0, [sp, #0x8]
;         }
700a755c: e7ff         	b	0x700a755e <Udma_chClose+0x5e> @ imm = #-0x2
;     }
700a755e: e7ff         	b	0x700a7560 <Udma_chClose+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7560: 9802         	ldr	r0, [sp, #0x8]
700a7562: b958         	cbnz	r0, 0x700a757c <Udma_chClose+0x7c> @ imm = #0x16
700a7564: e7ff         	b	0x700a7566 <Udma_chClose+0x66> @ imm = #-0x2
;         if(TRUE == chHandleInt->chOesAllocDone)
700a7566: 9800         	ldr	r0, [sp]
700a7568: f8d0 0248    	ldr.w	r0, [r0, #0x248]
700a756c: 2801         	cmp	r0, #0x1
700a756e: d104         	bne	0x700a757a <Udma_chClose+0x7a> @ imm = #0x8
700a7570: e7ff         	b	0x700a7572 <Udma_chClose+0x72> @ imm = #-0x2
700a7572: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7576: 9002         	str	r0, [sp, #0x8]
;         }
700a7578: e7ff         	b	0x700a757a <Udma_chClose+0x7a> @ imm = #-0x2
;     }
700a757a: e7ff         	b	0x700a757c <Udma_chClose+0x7c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a757c: 9802         	ldr	r0, [sp, #0x8]
700a757e: b9e8         	cbnz	r0, 0x700a75bc <Udma_chClose+0xbc> @ imm = #0x3a
700a7580: e7ff         	b	0x700a7582 <Udma_chClose+0x82> @ imm = #-0x2
;         retVal = Udma_chUnpair(chHandleInt);
700a7582: 9800         	ldr	r0, [sp]
700a7584: f003 f9bc    	bl	0x700aa900 <Udma_chUnpair> @ imm = #0x3378
700a7588: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
700a758a: 9802         	ldr	r0, [sp, #0x8]
700a758c: b108         	cbz	r0, 0x700a7592 <Udma_chClose+0x92> @ imm = #0x2
700a758e: e7ff         	b	0x700a7590 <Udma_chClose+0x90> @ imm = #-0x2
;         }
700a7590: e7ff         	b	0x700a7592 <Udma_chClose+0x92> @ imm = #-0x2
;         retVal += Udma_chFreeResource(chHandleInt);
700a7592: 9800         	ldr	r0, [sp]
700a7594: f7f7 fd84    	bl	0x7009f0a0 <Udma_chFreeResource> @ imm = #-0x84f8
700a7598: 4601         	mov	r1, r0
700a759a: 9802         	ldr	r0, [sp, #0x8]
700a759c: 4408         	add	r0, r1
700a759e: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
700a75a0: 9802         	ldr	r0, [sp, #0x8]
700a75a2: b108         	cbz	r0, 0x700a75a8 <Udma_chClose+0xa8> @ imm = #0x2
700a75a4: e7ff         	b	0x700a75a6 <Udma_chClose+0xa6> @ imm = #-0x2
;         }
700a75a6: e7ff         	b	0x700a75a8 <Udma_chClose+0xa8> @ imm = #-0x2
;         (void) memset(chHandleInt, 0, sizeof(*chHandleInt));
700a75a8: 9800         	ldr	r0, [sp]
700a75aa: f44f 7114    	mov.w	r1, #0x250
700a75ae: f7f3 edb2    	blx	0x7009b114 <__aeabi_memclr8> @ imm = #-0xc49c
;         chHandleInt->chInitDone = UDMA_DEINIT_DONE;
700a75b2: 9900         	ldr	r1, [sp]
700a75b4: 2000         	movs	r0, #0x0
700a75b6: f8c1 0244    	str.w	r0, [r1, #0x244]
;     }
700a75ba: e7ff         	b	0x700a75bc <Udma_chClose+0xbc> @ imm = #-0x2
;     return (retVal);
700a75bc: 9802         	ldr	r0, [sp, #0x8]
700a75be: b004         	add	sp, #0x10
700a75c0: bd80         	pop	{r7, pc}
		...
700a75ce: 0000         	movs	r0, r0

700a75d0 <CSL_bcdmaChanOpAccessRemotePeerReg>:
; {
700a75d0: b580         	push	{r7, lr}
700a75d2: b08a         	sub	sp, #0x28
700a75d4: 4684         	mov	r12, r0
700a75d6: 980c         	ldr	r0, [sp, #0x30]
700a75d8: f8cd c024    	str.w	r12, [sp, #0x24]
700a75dc: 9108         	str	r1, [sp, #0x20]
700a75de: 9207         	str	r2, [sp, #0x1c]
700a75e0: 9306         	str	r3, [sp, #0x18]
700a75e2: f88d 0017    	strb.w	r0, [sp, #0x17]
700a75e6: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a75e8: 9004         	str	r0, [sp, #0x10]
;     if( pOpData == NULL )
700a75ea: 9806         	ldr	r0, [sp, #0x18]
700a75ec: b920         	cbnz	r0, 0x700a75f8 <CSL_bcdmaChanOpAccessRemotePeerReg+0x28> @ imm = #0x8
700a75ee: e7ff         	b	0x700a75f0 <CSL_bcdmaChanOpAccessRemotePeerReg+0x20> @ imm = #-0x2
700a75f0: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a75f4: 9004         	str	r0, [sp, #0x10]
;     }
700a75f6: e048         	b	0x700a768a <CSL_bcdmaChanOpAccessRemotePeerReg+0xba> @ imm = #0x90
700a75f8: 2000         	movs	r0, #0x0
;         uint32_t *pRemotePeerReg = NULL;
700a75fa: 9003         	str	r0, [sp, #0xc]
;         switch( chanType )
700a75fc: 9808         	ldr	r0, [sp, #0x20]
700a75fe: 9001         	str	r0, [sp, #0x4]
700a7600: 2801         	cmp	r0, #0x1
700a7602: d004         	beq	0x700a760e <CSL_bcdmaChanOpAccessRemotePeerReg+0x3e> @ imm = #0x8
700a7604: e7ff         	b	0x700a7606 <CSL_bcdmaChanOpAccessRemotePeerReg+0x36> @ imm = #-0x2
700a7606: 9801         	ldr	r0, [sp, #0x4]
700a7608: 2802         	cmp	r0, #0x2
700a760a: d009         	beq	0x700a7620 <CSL_bcdmaChanOpAccessRemotePeerReg+0x50> @ imm = #0x12
700a760c: e011         	b	0x700a7632 <CSL_bcdmaChanOpAccessRemotePeerReg+0x62> @ imm = #0x22
;                 pRemotePeerReg = (uint32_t *)&pCfg->pTxChanRtRegs->CHAN[chanIdx].PEER0;
700a760e: 9809         	ldr	r0, [sp, #0x24]
700a7610: 6900         	ldr	r0, [r0, #0x10]
700a7612: 9907         	ldr	r1, [sp, #0x1c]
700a7614: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a7618: f500 7000    	add.w	r0, r0, #0x200
700a761c: 9003         	str	r0, [sp, #0xc]
;                 break;
700a761e: e00c         	b	0x700a763a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #0x18
;                 pRemotePeerReg = (uint32_t *)&pCfg->pRxChanRtRegs->CHAN[chanIdx].PEER0;
700a7620: 9809         	ldr	r0, [sp, #0x24]
700a7622: 6980         	ldr	r0, [r0, #0x18]
700a7624: 9907         	ldr	r1, [sp, #0x1c]
700a7626: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a762a: f500 7000    	add.w	r0, r0, #0x200
700a762e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a7630: e003         	b	0x700a763a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #0x6
700a7632: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a7636: 9004         	str	r0, [sp, #0x10]
;                 break;
700a7638: e7ff         	b	0x700a763a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #-0x2
;         if( pRemotePeerReg != NULL )
700a763a: 9803         	ldr	r0, [sp, #0xc]
700a763c: b320         	cbz	r0, 0x700a7688 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb8> @ imm = #0x48
700a763e: e7ff         	b	0x700a7640 <CSL_bcdmaChanOpAccessRemotePeerReg+0x70> @ imm = #-0x2
;             CSL_BcdmaRemotePeerOpts *pPeerOpts = (CSL_BcdmaRemotePeerOpts *)pOpData;
700a7640: 9806         	ldr	r0, [sp, #0x18]
700a7642: 9002         	str	r0, [sp, #0x8]
;             if( pPeerOpts->regIdx >= (uint32_t)16u )
700a7644: 9802         	ldr	r0, [sp, #0x8]
700a7646: 6800         	ldr	r0, [r0]
700a7648: 2810         	cmp	r0, #0x10
700a764a: d304         	blo	0x700a7656 <CSL_bcdmaChanOpAccessRemotePeerReg+0x86> @ imm = #0x8
700a764c: e7ff         	b	0x700a764e <CSL_bcdmaChanOpAccessRemotePeerReg+0x7e> @ imm = #-0x2
700a764e: f06f 0002    	mvn	r0, #0x2
;                 retVal = CSL_EINVALID_PARAMS;
700a7652: 9004         	str	r0, [sp, #0x10]
;             }
700a7654: e017         	b	0x700a7686 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb6> @ imm = #0x2e
;                 pRemotePeerReg += pPeerOpts->regIdx;    /* Increment to specified peer register */
700a7656: 9802         	ldr	r0, [sp, #0x8]
700a7658: 6801         	ldr	r1, [r0]
700a765a: 9803         	ldr	r0, [sp, #0xc]
700a765c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7660: 9003         	str	r0, [sp, #0xc]
;                 if( bRead == (bool)true )
700a7662: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a7666: 07c0         	lsls	r0, r0, #0x1f
700a7668: b130         	cbz	r0, 0x700a7678 <CSL_bcdmaChanOpAccessRemotePeerReg+0xa8> @ imm = #0xc
700a766a: e7ff         	b	0x700a766c <CSL_bcdmaChanOpAccessRemotePeerReg+0x9c> @ imm = #-0x2
;                     pPeerOpts->regVal = CSL_REG32_RD( pRemotePeerReg );
700a766c: 9803         	ldr	r0, [sp, #0xc]
700a766e: f008 facf    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0x859e
700a7672: 9902         	ldr	r1, [sp, #0x8]
700a7674: 6048         	str	r0, [r1, #0x4]
;                 }
700a7676: e005         	b	0x700a7684 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb4> @ imm = #0xa
;                     CSL_REG32_WR( pRemotePeerReg, pPeerOpts->regVal );
700a7678: 9803         	ldr	r0, [sp, #0xc]
700a767a: 9902         	ldr	r1, [sp, #0x8]
700a767c: 6849         	ldr	r1, [r1, #0x4]
700a767e: f7f4 fe07    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xb3f2
700a7682: e7ff         	b	0x700a7684 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb4> @ imm = #-0x2
700a7684: e7ff         	b	0x700a7686 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb6> @ imm = #-0x2
;         }
700a7686: e7ff         	b	0x700a7688 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb8> @ imm = #-0x2
700a7688: e7ff         	b	0x700a768a <CSL_bcdmaChanOpAccessRemotePeerReg+0xba> @ imm = #-0x2
;     return retVal;
700a768a: 9804         	ldr	r0, [sp, #0x10]
700a768c: b00a         	add	sp, #0x28
700a768e: bd80         	pop	{r7, pc}

700a7690 <_out_rev>:
; {
700a7690: b580         	push	{r7, lr}
700a7692: b086         	sub	sp, #0x18
700a7694: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a7698: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a769c: f8dd c024    	ldr.w	r12, [sp, #0x24]
700a76a0: f8dd c020    	ldr.w	r12, [sp, #0x20]
700a76a4: 9005         	str	r0, [sp, #0x14]
700a76a6: 9104         	str	r1, [sp, #0x10]
700a76a8: 9203         	str	r2, [sp, #0xc]
700a76aa: 9302         	str	r3, [sp, #0x8]
;   const size_t start_idx = idx;
700a76ac: 9803         	ldr	r0, [sp, #0xc]
700a76ae: 9001         	str	r0, [sp, #0x4]
;   if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
700a76b0: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a76b4: 0780         	lsls	r0, r0, #0x1e
700a76b6: 2800         	cmp	r0, #0x0
700a76b8: d41c         	bmi	0x700a76f4 <_out_rev+0x64> @ imm = #0x38
700a76ba: e7ff         	b	0x700a76bc <_out_rev+0x2c> @ imm = #-0x2
700a76bc: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a76c0: 07c0         	lsls	r0, r0, #0x1f
700a76c2: b9b8         	cbnz	r0, 0x700a76f4 <_out_rev+0x64> @ imm = #0x2e
700a76c4: e7ff         	b	0x700a76c6 <_out_rev+0x36> @ imm = #-0x2
;     for (i = len; i < width; i++) {
700a76c6: 9809         	ldr	r0, [sp, #0x24]
700a76c8: 9000         	str	r0, [sp]
700a76ca: e7ff         	b	0x700a76cc <_out_rev+0x3c> @ imm = #-0x2
700a76cc: 9800         	ldr	r0, [sp]
700a76ce: 990a         	ldr	r1, [sp, #0x28]
700a76d0: 4288         	cmp	r0, r1
700a76d2: d20e         	bhs	0x700a76f2 <_out_rev+0x62> @ imm = #0x1c
700a76d4: e7ff         	b	0x700a76d6 <_out_rev+0x46> @ imm = #-0x2
;       out(' ', buffer, idx++, maxlen);
700a76d6: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a76da: 9904         	ldr	r1, [sp, #0x10]
700a76dc: 9a03         	ldr	r2, [sp, #0xc]
700a76de: 1c50         	adds	r0, r2, #0x1
700a76e0: 9003         	str	r0, [sp, #0xc]
700a76e2: 9b02         	ldr	r3, [sp, #0x8]
700a76e4: 2020         	movs	r0, #0x20
700a76e6: 47e0         	blx	r12
;     }
700a76e8: e7ff         	b	0x700a76ea <_out_rev+0x5a> @ imm = #-0x2
;     for (i = len; i < width; i++) {
700a76ea: 9800         	ldr	r0, [sp]
700a76ec: 3001         	adds	r0, #0x1
700a76ee: 9000         	str	r0, [sp]
700a76f0: e7ec         	b	0x700a76cc <_out_rev+0x3c> @ imm = #-0x28
;   }
700a76f2: e7ff         	b	0x700a76f4 <_out_rev+0x64> @ imm = #-0x2
;   while (len) {
700a76f4: e7ff         	b	0x700a76f6 <_out_rev+0x66> @ imm = #-0x2
700a76f6: 9809         	ldr	r0, [sp, #0x24]
700a76f8: b170         	cbz	r0, 0x700a7718 <_out_rev+0x88> @ imm = #0x1c
700a76fa: e7ff         	b	0x700a76fc <_out_rev+0x6c> @ imm = #-0x2
;     out(buf[--len], buffer, idx++, maxlen);
700a76fc: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a7700: 9808         	ldr	r0, [sp, #0x20]
700a7702: 9909         	ldr	r1, [sp, #0x24]
700a7704: 3901         	subs	r1, #0x1
700a7706: 9109         	str	r1, [sp, #0x24]
700a7708: 5c40         	ldrb	r0, [r0, r1]
700a770a: 9904         	ldr	r1, [sp, #0x10]
700a770c: 9a03         	ldr	r2, [sp, #0xc]
700a770e: 1c53         	adds	r3, r2, #0x1
700a7710: 9303         	str	r3, [sp, #0xc]
700a7712: 9b02         	ldr	r3, [sp, #0x8]
700a7714: 47e0         	blx	r12
;   while (len) {
700a7716: e7ee         	b	0x700a76f6 <_out_rev+0x66> @ imm = #-0x24
;   if (flags & FLAGS_LEFT) {
700a7718: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a771c: 0780         	lsls	r0, r0, #0x1e
700a771e: 2800         	cmp	r0, #0x0
700a7720: d513         	bpl	0x700a774a <_out_rev+0xba> @ imm = #0x26
700a7722: e7ff         	b	0x700a7724 <_out_rev+0x94> @ imm = #-0x2
;     while (idx - start_idx < width) {
700a7724: e7ff         	b	0x700a7726 <_out_rev+0x96> @ imm = #-0x2
700a7726: 9803         	ldr	r0, [sp, #0xc]
700a7728: 9901         	ldr	r1, [sp, #0x4]
700a772a: 1a40         	subs	r0, r0, r1
700a772c: 990a         	ldr	r1, [sp, #0x28]
700a772e: 4288         	cmp	r0, r1
700a7730: d20a         	bhs	0x700a7748 <_out_rev+0xb8> @ imm = #0x14
700a7732: e7ff         	b	0x700a7734 <_out_rev+0xa4> @ imm = #-0x2
;       out(' ', buffer, idx++, maxlen);
700a7734: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a7738: 9904         	ldr	r1, [sp, #0x10]
700a773a: 9a03         	ldr	r2, [sp, #0xc]
700a773c: 1c50         	adds	r0, r2, #0x1
700a773e: 9003         	str	r0, [sp, #0xc]
700a7740: 9b02         	ldr	r3, [sp, #0x8]
700a7742: 2020         	movs	r0, #0x20
700a7744: 47e0         	blx	r12
;     while (idx - start_idx < width) {
700a7746: e7ee         	b	0x700a7726 <_out_rev+0x96> @ imm = #-0x24
;   }
700a7748: e7ff         	b	0x700a774a <_out_rev+0xba> @ imm = #-0x2
;   return idx;
700a774a: 9803         	ldr	r0, [sp, #0xc]
700a774c: b006         	add	sp, #0x18
700a774e: bd80         	pop	{r7, pc}

700a7750 <vTaskStartScheduler>:
; void vTaskStartScheduler(void) {
700a7750: b580         	push	{r7, lr}
700a7752: b088         	sub	sp, #0x20
700a7754: 2000         	movs	r0, #0x0
;     StaticTask_t *pxIdleTaskTCBBuffer = NULL;
700a7756: 9003         	str	r0, [sp, #0xc]
700a7758: 9006         	str	r0, [sp, #0x18]
;     StackType_t *pxIdleTaskStackBuffer = NULL;
700a775a: 9005         	str	r0, [sp, #0x14]
700a775c: a806         	add	r0, sp, #0x18
700a775e: a905         	add	r1, sp, #0x14
700a7760: aa04         	add	r2, sp, #0x10
;     vApplicationGetIdleTaskMemory(&pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer,
700a7762: f007 faa5    	bl	0x700aecb0 <vApplicationGetIdleTaskMemory> @ imm = #0x754a
700a7766: 9b03         	ldr	r3, [sp, #0xc]
;         prvIdleTask, configIDLE_TASK_NAME, ulIdleTaskStackSize,
700a7768: 9a04         	ldr	r2, [sp, #0x10]
;         pxIdleTaskStackBuffer,
700a776a: 9905         	ldr	r1, [sp, #0x14]
;         pxIdleTaskTCBBuffer); /*lint !e961 MISRA exception, justified as it is
700a776c: f8dd c018    	ldr.w	r12, [sp, #0x18]
;     xIdleTaskHandle = xTaskCreateStatic(
700a7770: 4668         	mov	r0, sp
700a7772: f8c0 c008    	str.w	r12, [r0, #0x8]
700a7776: 6041         	str	r1, [r0, #0x4]
700a7778: 6003         	str	r3, [r0]
700a777a: f64c 7051    	movw	r0, #0xcf51
700a777e: f2c7 000a    	movt	r0, #0x700a
700a7782: f242 6130    	movw	r1, #0x2630
700a7786: f2c7 010b    	movt	r1, #0x700b
700a778a: f003 fe01    	bl	0x700ab390 <xTaskCreateStatic> @ imm = #0x3c02
700a778e: 4601         	mov	r1, r0
700a7790: f642 2040    	movw	r0, #0x2a40
700a7794: f2c7 000b    	movt	r0, #0x700b
700a7798: 6001         	str	r1, [r0]
;     if (xIdleTaskHandle != NULL) {
700a779a: 6800         	ldr	r0, [r0]
700a779c: b118         	cbz	r0, 0x700a77a6 <vTaskStartScheduler+0x56> @ imm = #0x6
700a779e: e7ff         	b	0x700a77a0 <vTaskStartScheduler+0x50> @ imm = #-0x2
700a77a0: 2001         	movs	r0, #0x1
;       xReturn = pdPASS;
700a77a2: 9007         	str	r0, [sp, #0x1c]
;     } else {
700a77a4: e002         	b	0x700a77ac <vTaskStartScheduler+0x5c> @ imm = #0x4
700a77a6: 2000         	movs	r0, #0x0
;       xReturn = pdFAIL;
700a77a8: 9007         	str	r0, [sp, #0x1c]
700a77aa: e7ff         	b	0x700a77ac <vTaskStartScheduler+0x5c> @ imm = #-0x2
;     if (xReturn == pdPASS) {
700a77ac: 9807         	ldr	r0, [sp, #0x1c]
700a77ae: 2801         	cmp	r0, #0x1
700a77b0: d104         	bne	0x700a77bc <vTaskStartScheduler+0x6c> @ imm = #0x8
700a77b2: e7ff         	b	0x700a77b4 <vTaskStartScheduler+0x64> @ imm = #-0x2
;       xReturn = xTimerCreateTimerTask();
700a77b4: f003 fb6c    	bl	0x700aae90 <xTimerCreateTimerTask> @ imm = #0x36d8
700a77b8: 9007         	str	r0, [sp, #0x1c]
;     } else {
700a77ba: e000         	b	0x700a77be <vTaskStartScheduler+0x6e> @ imm = #0x0
700a77bc: e7ff         	b	0x700a77be <vTaskStartScheduler+0x6e> @ imm = #-0x2
;   if (xReturn == pdPASS) {
700a77be: 9807         	ldr	r0, [sp, #0x1c]
700a77c0: 2801         	cmp	r0, #0x1
700a77c2: d11d         	bne	0x700a7800 <vTaskStartScheduler+0xb0> @ imm = #0x3a
700a77c4: e7ff         	b	0x700a77c6 <vTaskStartScheduler+0x76> @ imm = #-0x2
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700a77c6: b672         	cpsid i
;     xNextTaskUnblockTime = portMAX_DELAY;
700a77c8: f642 2144    	movw	r1, #0x2a44
700a77cc: f2c7 010b    	movt	r1, #0x700b
700a77d0: f04f 30ff    	mov.w	r0, #0xffffffff
700a77d4: 6008         	str	r0, [r1]
;     xSchedulerRunning = pdTRUE;
700a77d6: f642 2150    	movw	r1, #0x2a50
700a77da: f2c7 010b    	movt	r1, #0x700b
700a77de: 2001         	movs	r0, #0x1
700a77e0: 6008         	str	r0, [r1]
;     xTickCount = (TickType_t)configINITIAL_TICK_COUNT;
700a77e2: f642 2154    	movw	r1, #0x2a54
700a77e6: f2c7 010b    	movt	r1, #0x700b
700a77ea: 2000         	movs	r0, #0x0
700a77ec: 6008         	str	r0, [r1]
;     portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
700a77ee: f008 faff    	bl	0x700afdf0 <vPortConfigTimerForRunTimeStats> @ imm = #0x85fe
;     if (xPortStartScheduler() != pdFALSE) {
700a77f2: f007 fe9d    	bl	0x700af530 <xPortStartScheduler> @ imm = #0x7d3a
700a77f6: b108         	cbz	r0, 0x700a77fc <vTaskStartScheduler+0xac> @ imm = #0x2
700a77f8: e7ff         	b	0x700a77fa <vTaskStartScheduler+0xaa> @ imm = #-0x2
;     } else {
700a77fa: e000         	b	0x700a77fe <vTaskStartScheduler+0xae> @ imm = #0x0
700a77fc: e7ff         	b	0x700a77fe <vTaskStartScheduler+0xae> @ imm = #-0x2
;   } else {
700a77fe: e000         	b	0x700a7802 <vTaskStartScheduler+0xb2> @ imm = #0x0
700a7800: e7ff         	b	0x700a7802 <vTaskStartScheduler+0xb2> @ imm = #-0x2
;   (void)uxTopUsedPriority;
700a7802: f242 6070    	movw	r0, #0x2670
700a7806: f2c7 000b    	movt	r0, #0x700b
700a780a: 6800         	ldr	r0, [r0]
; }
700a780c: b008         	add	sp, #0x20
700a780e: bd80         	pop	{r7, pc}

700a7810 <PMU_profilePrintEntry>:
; void PMU_profilePrintEntry(const char *name) {
700a7810: b580         	push	{r7, lr}
700a7812: b086         	sub	sp, #0x18
700a7814: 9005         	str	r0, [sp, #0x14]
700a7816: 2000         	movs	r0, #0x0
;   for (i = 0; i < gProfileObject.logIndex; i++) {
700a7818: 9004         	str	r0, [sp, #0x10]
700a781a: e7ff         	b	0x700a781c <PMU_profilePrintEntry+0xc> @ imm = #-0x2
700a781c: 9804         	ldr	r0, [sp, #0x10]
700a781e: f243 0180    	movw	r1, #0x3080
700a7822: f2c7 0108    	movt	r1, #0x7008
700a7826: 6809         	ldr	r1, [r1]
700a7828: 4288         	cmp	r0, r1
700a782a: d24d         	bhs	0x700a78c8 <PMU_profilePrintEntry+0xb8> @ imm = #0x9a
700a782c: e7ff         	b	0x700a782e <PMU_profilePrintEntry+0x1e> @ imm = #-0x2
;     PMU_ProfilePoint *p = &gProfileObject.point[i];
700a782e: 9804         	ldr	r0, [sp, #0x10]
700a7830: f243 0280    	movw	r2, #0x3080
700a7834: f2c7 0208    	movt	r2, #0x7008
700a7838: 2134         	movs	r1, #0x34
700a783a: fb00 2001    	mla	r0, r0, r1, r2
700a783e: 300c         	adds	r0, #0xc
700a7840: 9002         	str	r0, [sp, #0x8]
;     if (strcmp(name, p->name) == 0) {
700a7842: 9805         	ldr	r0, [sp, #0x14]
700a7844: 9902         	ldr	r1, [sp, #0x8]
700a7846: 6b09         	ldr	r1, [r1, #0x30]
700a7848: f7f4 ed2a    	blx	0x7009c2a0 <strcmp>     @ imm = #-0xb5ac
700a784c: bbb8         	cbnz	r0, 0x700a78be <PMU_profilePrintEntry+0xae> @ imm = #0x6e
700a784e: e7ff         	b	0x700a7850 <PMU_profilePrintEntry+0x40> @ imm = #-0x2
;       DebugP_log("Profile Point: %-32s\r\n", p->name);
700a7850: 9802         	ldr	r0, [sp, #0x8]
700a7852: 6b02         	ldr	r2, [r0, #0x30]
700a7854: f641 711b    	movw	r1, #0x1f1b
700a7858: f2c7 010b    	movt	r1, #0x700b
700a785c: 2001         	movs	r0, #0x1
700a785e: 9001         	str	r0, [sp, #0x4]
700a7860: f002 fa5e    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0x24bc
700a7864: 9801         	ldr	r0, [sp, #0x4]
;       DebugP_log("Cycle Count: %lu\r\n", p->cycleCount.value);
700a7866: 9902         	ldr	r1, [sp, #0x8]
700a7868: 6aca         	ldr	r2, [r1, #0x2c]
700a786a: f641 7195    	movw	r1, #0x1f95
700a786e: f2c7 010b    	movt	r1, #0x700b
700a7872: f002 fa55    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0x24aa
700a7876: 2000         	movs	r0, #0x0
;       for (j = 0; j < PMU_MAX_EVENT_COUNTERS; j++) {
700a7878: 9003         	str	r0, [sp, #0xc]
700a787a: e7ff         	b	0x700a787c <PMU_profilePrintEntry+0x6c> @ imm = #-0x2
700a787c: 9803         	ldr	r0, [sp, #0xc]
700a787e: 2802         	cmp	r0, #0x2
700a7880: d815         	bhi	0x700a78ae <PMU_profilePrintEntry+0x9e> @ imm = #0x2a
700a7882: e7ff         	b	0x700a7884 <PMU_profilePrintEntry+0x74> @ imm = #-0x2
;         DebugP_log("%s Count: %lu\r\n", p->events[j].name, p->events[j].value);
700a7884: 9902         	ldr	r1, [sp, #0x8]
700a7886: 9803         	ldr	r0, [sp, #0xc]
700a7888: eb00 0240    	add.w	r2, r0, r0, lsl #1
700a788c: eb01 0082    	add.w	r0, r1, r2, lsl #2
700a7890: f851 2022    	ldr.w	r2, [r1, r2, lsl #2]
700a7894: 6883         	ldr	r3, [r0, #0x8]
700a7896: f242 01b3    	movw	r1, #0x20b3
700a789a: f2c7 010b    	movt	r1, #0x700b
700a789e: 2001         	movs	r0, #0x1
700a78a0: f002 fa3e    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0x247c
;       }
700a78a4: e7ff         	b	0x700a78a6 <PMU_profilePrintEntry+0x96> @ imm = #-0x2
;       for (j = 0; j < PMU_MAX_EVENT_COUNTERS; j++) {
700a78a6: 9803         	ldr	r0, [sp, #0xc]
700a78a8: 3001         	adds	r0, #0x1
700a78aa: 9003         	str	r0, [sp, #0xc]
700a78ac: e7e6         	b	0x700a787c <PMU_profilePrintEntry+0x6c> @ imm = #-0x34
;       DebugP_log("\r\n");
700a78ae: f241 7101    	movw	r1, #0x1701
700a78b2: f2c7 010b    	movt	r1, #0x700b
700a78b6: 2001         	movs	r0, #0x1
700a78b8: f002 fa32    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0x2464
;       break;
700a78bc: e004         	b	0x700a78c8 <PMU_profilePrintEntry+0xb8> @ imm = #0x8
;   }
700a78be: e7ff         	b	0x700a78c0 <PMU_profilePrintEntry+0xb0> @ imm = #-0x2
;   for (i = 0; i < gProfileObject.logIndex; i++) {
700a78c0: 9804         	ldr	r0, [sp, #0x10]
700a78c2: 3001         	adds	r0, #0x1
700a78c4: 9004         	str	r0, [sp, #0x10]
700a78c6: e7a9         	b	0x700a781c <PMU_profilePrintEntry+0xc> @ imm = #-0xae
; }
700a78c8: b006         	add	sp, #0x18
700a78ca: bd80         	pop	{r7, pc}
700a78cc: 0000         	movs	r0, r0
700a78ce: 0000         	movs	r0, r0

700a78d0 <prvSwitchTimerLists>:
;     {
700a78d0: b580         	push	{r7, lr}
700a78d2: b086         	sub	sp, #0x18
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
700a78d4: e7ff         	b	0x700a78d6 <prvSwitchTimerLists+0x6> @ imm = #-0x2
700a78d6: f245 209c    	movw	r0, #0x529c
700a78da: f2c7 0008    	movt	r0, #0x7008
700a78de: 6800         	ldr	r0, [r0]
700a78e0: 6800         	ldr	r0, [r0]
700a78e2: 2800         	cmp	r0, #0x0
700a78e4: d040         	beq	0x700a7968 <prvSwitchTimerLists+0x98> @ imm = #0x80
700a78e6: e7ff         	b	0x700a78e8 <prvSwitchTimerLists+0x18> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
700a78e8: f245 209c    	movw	r0, #0x529c
700a78ec: f2c7 0008    	movt	r0, #0x7008
700a78f0: 6801         	ldr	r1, [r0]
700a78f2: 68c9         	ldr	r1, [r1, #0xc]
700a78f4: 6809         	ldr	r1, [r1]
700a78f6: 9105         	str	r1, [sp, #0x14]
;             pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
700a78f8: 6800         	ldr	r0, [r0]
700a78fa: 68c0         	ldr	r0, [r0, #0xc]
700a78fc: 68c0         	ldr	r0, [r0, #0xc]
700a78fe: 9002         	str	r0, [sp, #0x8]
;             ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a7900: 9802         	ldr	r0, [sp, #0x8]
700a7902: 3004         	adds	r0, #0x4
700a7904: f005 ff0c    	bl	0x700ad720 <uxListRemove> @ imm = #0x5e18
;             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a7908: 9802         	ldr	r0, [sp, #0x8]
700a790a: 6a01         	ldr	r1, [r0, #0x20]
700a790c: 4788         	blx	r1
;             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a790e: 9802         	ldr	r0, [sp, #0x8]
700a7910: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a7914: 0740         	lsls	r0, r0, #0x1d
700a7916: 2800         	cmp	r0, #0x0
700a7918: d524         	bpl	0x700a7964 <prvSwitchTimerLists+0x94> @ imm = #0x48
700a791a: e7ff         	b	0x700a791c <prvSwitchTimerLists+0x4c> @ imm = #-0x2
;                 xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
700a791c: 9805         	ldr	r0, [sp, #0x14]
700a791e: 9902         	ldr	r1, [sp, #0x8]
700a7920: 6989         	ldr	r1, [r1, #0x18]
700a7922: 4408         	add	r0, r1
700a7924: 9004         	str	r0, [sp, #0x10]
;                 if( xReloadTime > xNextExpireTime )
700a7926: 9804         	ldr	r0, [sp, #0x10]
700a7928: 9905         	ldr	r1, [sp, #0x14]
700a792a: 4288         	cmp	r0, r1
700a792c: d90f         	bls	0x700a794e <prvSwitchTimerLists+0x7e> @ imm = #0x1e
700a792e: e7ff         	b	0x700a7930 <prvSwitchTimerLists+0x60> @ imm = #-0x2
;                     listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
700a7930: 9804         	ldr	r0, [sp, #0x10]
700a7932: 9902         	ldr	r1, [sp, #0x8]
700a7934: 6048         	str	r0, [r1, #0x4]
;                     listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
700a7936: 9802         	ldr	r0, [sp, #0x8]
700a7938: 6100         	str	r0, [r0, #0x10]
;                     vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
700a793a: f245 209c    	movw	r0, #0x529c
700a793e: f2c7 0008    	movt	r0, #0x7008
700a7942: 6800         	ldr	r0, [r0]
700a7944: 9902         	ldr	r1, [sp, #0x8]
700a7946: 3104         	adds	r1, #0x4
700a7948: f003 ff5a    	bl	0x700ab800 <vListInsert> @ imm = #0x3eb4
;                 }
700a794c: e009         	b	0x700a7962 <prvSwitchTimerLists+0x92> @ imm = #0x12
;                     xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
700a794e: 9802         	ldr	r0, [sp, #0x8]
700a7950: 9a05         	ldr	r2, [sp, #0x14]
700a7952: 4669         	mov	r1, sp
700a7954: 2300         	movs	r3, #0x0
700a7956: 600b         	str	r3, [r1]
700a7958: 4619         	mov	r1, r3
700a795a: f002 f8f1    	bl	0x700a9b40 <xTimerGenericCommand> @ imm = #0x21e2
700a795e: 9001         	str	r0, [sp, #0x4]
700a7960: e7ff         	b	0x700a7962 <prvSwitchTimerLists+0x92> @ imm = #-0x2
;             }
700a7962: e000         	b	0x700a7966 <prvSwitchTimerLists+0x96> @ imm = #0x0
700a7964: e7ff         	b	0x700a7966 <prvSwitchTimerLists+0x96> @ imm = #-0x2
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
700a7966: e7b6         	b	0x700a78d6 <prvSwitchTimerLists+0x6> @ imm = #-0x94
;         pxTemp = pxCurrentTimerList;
700a7968: f245 229c    	movw	r2, #0x529c
700a796c: f2c7 0208    	movt	r2, #0x7008
700a7970: 6810         	ldr	r0, [r2]
700a7972: 9003         	str	r0, [sp, #0xc]
;         pxCurrentTimerList = pxOverflowTimerList;
700a7974: f245 21a8    	movw	r1, #0x52a8
700a7978: f2c7 0108    	movt	r1, #0x7008
700a797c: 6808         	ldr	r0, [r1]
700a797e: 6010         	str	r0, [r2]
;         pxOverflowTimerList = pxTemp;
700a7980: 9803         	ldr	r0, [sp, #0xc]
700a7982: 6008         	str	r0, [r1]
;     }
700a7984: b006         	add	sp, #0x18
700a7986: bd80         	pop	{r7, pc}
		...

700a7990 <CSL_pktdmaAccessChanPeerReg>:
; {
700a7990: b580         	push	{r7, lr}
700a7992: b088         	sub	sp, #0x20
700a7994: 4684         	mov	r12, r0
700a7996: 980b         	ldr	r0, [sp, #0x2c]
700a7998: f8dd e028    	ldr.w	lr, [sp, #0x28]
700a799c: f8cd c01c    	str.w	r12, [sp, #0x1c]
700a79a0: 9106         	str	r1, [sp, #0x18]
700a79a2: 9205         	str	r2, [sp, #0x14]
700a79a4: 9304         	str	r3, [sp, #0x10]
700a79a6: f88d 000f    	strb.w	r0, [sp, #0xf]
700a79aa: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a79ac: 9002         	str	r0, [sp, #0x8]
;     if( (pCfg == NULL) || (pVal == NULL) || (CSL_pktdmaIsValidChanIdx( pCfg, chanIdx, chanDir) == (bool)false) )
700a79ae: 9807         	ldr	r0, [sp, #0x1c]
700a79b0: b150         	cbz	r0, 0x700a79c8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #0x14
700a79b2: e7ff         	b	0x700a79b4 <CSL_pktdmaAccessChanPeerReg+0x24> @ imm = #-0x2
700a79b4: 9804         	ldr	r0, [sp, #0x10]
700a79b6: b138         	cbz	r0, 0x700a79c8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #0xe
700a79b8: e7ff         	b	0x700a79ba <CSL_pktdmaAccessChanPeerReg+0x2a> @ imm = #-0x2
700a79ba: 9807         	ldr	r0, [sp, #0x1c]
700a79bc: 9906         	ldr	r1, [sp, #0x18]
700a79be: 9a0a         	ldr	r2, [sp, #0x28]
700a79c0: f005 fa06    	bl	0x700acdd0 <CSL_pktdmaIsValidChanIdx> @ imm = #0x540c
700a79c4: b920         	cbnz	r0, 0x700a79d0 <CSL_pktdmaAccessChanPeerReg+0x40> @ imm = #0x8
700a79c6: e7ff         	b	0x700a79c8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #-0x2
700a79c8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a79cc: 9002         	str	r0, [sp, #0x8]
;     }
700a79ce: e037         	b	0x700a7a40 <CSL_pktdmaAccessChanPeerReg+0xb0> @ imm = #0x6e
;         if( regIdx < CSL_PKTDMA_NUM_PEER_REGS )
700a79d0: 9805         	ldr	r0, [sp, #0x14]
700a79d2: 280f         	cmp	r0, #0xf
700a79d4: d82f         	bhi	0x700a7a36 <CSL_pktdmaAccessChanPeerReg+0xa6> @ imm = #0x5e
700a79d6: e7ff         	b	0x700a79d8 <CSL_pktdmaAccessChanPeerReg+0x48> @ imm = #-0x2
;             if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700a79d8: 980a         	ldr	r0, [sp, #0x28]
700a79da: b960         	cbnz	r0, 0x700a79f6 <CSL_pktdmaAccessChanPeerReg+0x66> @ imm = #0x18
700a79dc: e7ff         	b	0x700a79de <CSL_pktdmaAccessChanPeerReg+0x4e> @ imm = #-0x2
;                 pPeerReg = (uint32_t *)(((uintptr_t)pCfg->pTxChanRtRegs) + (uintptr_t)CSL_PKTDMA_TXCRT_CHAN_PEER0(chanIdx) + ((uintptr_t)regIdx * 0x4U));
700a79de: 9807         	ldr	r0, [sp, #0x1c]
700a79e0: 6900         	ldr	r0, [r0, #0x10]
700a79e2: 9906         	ldr	r1, [sp, #0x18]
700a79e4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a79e8: 9905         	ldr	r1, [sp, #0x14]
700a79ea: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a79ee: f500 7000    	add.w	r0, r0, #0x200
700a79f2: 9001         	str	r0, [sp, #0x4]
;             }
700a79f4: e00b         	b	0x700a7a0e <CSL_pktdmaAccessChanPeerReg+0x7e> @ imm = #0x16
;                 pPeerReg = (uint32_t *)(((uintptr_t)pCfg->pRxChanRtRegs) + (uintptr_t)CSL_PKTDMA_RXCRT_CHAN_PEER0(chanIdx) + ((uintptr_t)regIdx * 0x4U));
700a79f6: 9807         	ldr	r0, [sp, #0x1c]
700a79f8: 6940         	ldr	r0, [r0, #0x14]
700a79fa: 9906         	ldr	r1, [sp, #0x18]
700a79fc: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a7a00: 9905         	ldr	r1, [sp, #0x14]
700a7a02: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7a06: f500 7000    	add.w	r0, r0, #0x200
700a7a0a: 9001         	str	r0, [sp, #0x4]
700a7a0c: e7ff         	b	0x700a7a0e <CSL_pktdmaAccessChanPeerReg+0x7e> @ imm = #-0x2
;             if( bRdAccess == (bool)true )
700a7a0e: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a7a12: 07c0         	lsls	r0, r0, #0x1f
700a7a14: b130         	cbz	r0, 0x700a7a24 <CSL_pktdmaAccessChanPeerReg+0x94> @ imm = #0xc
700a7a16: e7ff         	b	0x700a7a18 <CSL_pktdmaAccessChanPeerReg+0x88> @ imm = #-0x2
;                 *pVal = CSL_REG32_RD( pPeerReg );
700a7a18: 9801         	ldr	r0, [sp, #0x4]
700a7a1a: f008 f909    	bl	0x700afc30 <CSL_REG32_RD_RAW> @ imm = #0x8212
700a7a1e: 9904         	ldr	r1, [sp, #0x10]
700a7a20: 6008         	str	r0, [r1]
;             }
700a7a22: e005         	b	0x700a7a30 <CSL_pktdmaAccessChanPeerReg+0xa0> @ imm = #0xa
;                 CSL_REG32_WR( pPeerReg, *pVal );
700a7a24: 9801         	ldr	r0, [sp, #0x4]
700a7a26: 9904         	ldr	r1, [sp, #0x10]
700a7a28: 6809         	ldr	r1, [r1]
700a7a2a: f008 f859    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x80b2
700a7a2e: e7ff         	b	0x700a7a30 <CSL_pktdmaAccessChanPeerReg+0xa0> @ imm = #-0x2
700a7a30: 2000         	movs	r0, #0x0
;             retVal = CSL_PASS;
700a7a32: 9002         	str	r0, [sp, #0x8]
;         }
700a7a34: e003         	b	0x700a7a3e <CSL_pktdmaAccessChanPeerReg+0xae> @ imm = #0x6
700a7a36: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = CSL_EFAIL;
700a7a3a: 9002         	str	r0, [sp, #0x8]
700a7a3c: e7ff         	b	0x700a7a3e <CSL_pktdmaAccessChanPeerReg+0xae> @ imm = #-0x2
700a7a3e: e7ff         	b	0x700a7a40 <CSL_pktdmaAccessChanPeerReg+0xb0> @ imm = #-0x2
;     return retVal;
700a7a40: 9802         	ldr	r0, [sp, #0x8]
700a7a42: b008         	add	sp, #0x20
700a7a44: bd80         	pop	{r7, pc}
		...
700a7a4e: 0000         	movs	r0, r0

700a7a50 <UART_fifoWrite>:
; {
700a7a50: b580         	push	{r7, lr}
700a7a52: b08c         	sub	sp, #0x30
700a7a54: 900b         	str	r0, [sp, #0x2c]
700a7a56: 910a         	str	r1, [sp, #0x28]
700a7a58: 9209         	str	r2, [sp, #0x24]
;     uint32_t tempWriteSizeRemaining = writeSizeRemaining;
700a7a5a: 9809         	ldr	r0, [sp, #0x24]
700a7a5c: 9008         	str	r0, [sp, #0x20]
;     uint32_t size                  = tempWriteSizeRemaining;
700a7a5e: 9808         	ldr	r0, [sp, #0x20]
700a7a60: 9007         	str	r0, [sp, #0x1c]
;     const uint8_t *tempBuffer = buffer;
700a7a62: 980a         	ldr	r0, [sp, #0x28]
700a7a64: 9006         	str	r0, [sp, #0x18]
700a7a66: 2000         	movs	r0, #0x0
;     uint32_t lineStatus            = 0U;
700a7a68: 9005         	str	r0, [sp, #0x14]
;     uint32_t tempChunksize         = 0U;
700a7a6a: 9004         	str	r0, [sp, #0x10]
700a7a6c: f640 30b8    	movw	r0, #0xbb8
;     int32_t  maxTrialCount         = (int32_t) UART_TRANSMITEMPTY_TRIALCOUNT;
700a7a70: 9003         	str	r0, [sp, #0xc]
700a7a72: 2040         	movs	r0, #0x40
;     tempChunksize = UART_FIFO_SIZE;
700a7a74: 9004         	str	r0, [sp, #0x10]
;     do
700a7a76: e7ff         	b	0x700a7a78 <UART_fifoWrite+0x28> @ imm = #-0x2
;         lineStatus = (uint32_t) UART_readLineStatus(hUart->baseAddr);
700a7a78: 980b         	ldr	r0, [sp, #0x2c]
700a7a7a: 6800         	ldr	r0, [r0]
700a7a7c: f005 ff18    	bl	0x700ad8b0 <UART_readLineStatus> @ imm = #0x5e30
700a7a80: 9005         	str	r0, [sp, #0x14]
;         maxTrialCount--;
700a7a82: 9803         	ldr	r0, [sp, #0xc]
700a7a84: 3801         	subs	r0, #0x1
700a7a86: 9003         	str	r0, [sp, #0xc]
;     }
700a7a88: e7ff         	b	0x700a7a8a <UART_fifoWrite+0x3a> @ imm = #-0x2
;                        UART_LSR_TX_FIFO_E_MASK) & lineStatus))
700a7a8a: 9805         	ldr	r0, [sp, #0x14]
700a7a8c: f000 0160    	and	r1, r0, #0x60
700a7a90: 2000         	movs	r0, #0x0
;            && (0 < maxTrialCount));
700a7a92: 2960         	cmp	r1, #0x60
700a7a94: 9002         	str	r0, [sp, #0x8]
700a7a96: d007         	beq	0x700a7aa8 <UART_fifoWrite+0x58> @ imm = #0xe
700a7a98: e7ff         	b	0x700a7a9a <UART_fifoWrite+0x4a> @ imm = #-0x2
700a7a9a: 9903         	ldr	r1, [sp, #0xc]
700a7a9c: 2000         	movs	r0, #0x0
700a7a9e: 2900         	cmp	r1, #0x0
700a7aa0: bfc8         	it	gt
700a7aa2: 2001         	movgt	r0, #0x1
700a7aa4: 9002         	str	r0, [sp, #0x8]
700a7aa6: e7ff         	b	0x700a7aa8 <UART_fifoWrite+0x58> @ imm = #-0x2
700a7aa8: 9802         	ldr	r0, [sp, #0x8]
;     }
700a7aaa: 07c0         	lsls	r0, r0, #0x1f
700a7aac: 2800         	cmp	r0, #0x0
700a7aae: d1e3         	bne	0x700a7a78 <UART_fifoWrite+0x28> @ imm = #-0x3a
700a7ab0: e7ff         	b	0x700a7ab2 <UART_fifoWrite+0x62> @ imm = #-0x2
;     if (maxTrialCount > 0)
700a7ab2: 9803         	ldr	r0, [sp, #0xc]
700a7ab4: 2801         	cmp	r0, #0x1
700a7ab6: db21         	blt	0x700a7afc <UART_fifoWrite+0xac> @ imm = #0x42
700a7ab8: e7ff         	b	0x700a7aba <UART_fifoWrite+0x6a> @ imm = #-0x2
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a7aba: e7ff         	b	0x700a7abc <UART_fifoWrite+0x6c> @ imm = #-0x2
700a7abc: 9904         	ldr	r1, [sp, #0x10]
700a7abe: 2000         	movs	r0, #0x0
700a7ac0: 9001         	str	r0, [sp, #0x4]
700a7ac2: b131         	cbz	r1, 0x700a7ad2 <UART_fifoWrite+0x82> @ imm = #0xc
700a7ac4: e7ff         	b	0x700a7ac6 <UART_fifoWrite+0x76> @ imm = #-0x2
700a7ac6: 9808         	ldr	r0, [sp, #0x20]
700a7ac8: 2800         	cmp	r0, #0x0
700a7aca: bf18         	it	ne
700a7acc: 2001         	movne	r0, #0x1
700a7ace: 9001         	str	r0, [sp, #0x4]
700a7ad0: e7ff         	b	0x700a7ad2 <UART_fifoWrite+0x82> @ imm = #-0x2
700a7ad2: 9801         	ldr	r0, [sp, #0x4]
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a7ad4: 07c0         	lsls	r0, r0, #0x1f
700a7ad6: b180         	cbz	r0, 0x700a7afa <UART_fifoWrite+0xaa> @ imm = #0x20
700a7ad8: e7ff         	b	0x700a7ada <UART_fifoWrite+0x8a> @ imm = #-0x2
;             UART_putChar(hUart->baseAddr, (*tempBuffer));
700a7ada: 980b         	ldr	r0, [sp, #0x2c]
700a7adc: 6800         	ldr	r0, [r0]
700a7ade: 9906         	ldr	r1, [sp, #0x18]
700a7ae0: 7809         	ldrb	r1, [r1]
700a7ae2: f007 fe45    	bl	0x700af770 <UART_putChar> @ imm = #0x7c8a
;             tempBuffer++;
700a7ae6: 9806         	ldr	r0, [sp, #0x18]
700a7ae8: 3001         	adds	r0, #0x1
700a7aea: 9006         	str	r0, [sp, #0x18]
;             tempWriteSizeRemaining--;
700a7aec: 9808         	ldr	r0, [sp, #0x20]
700a7aee: 3801         	subs	r0, #0x1
700a7af0: 9008         	str	r0, [sp, #0x20]
;             tempChunksize--;
700a7af2: 9804         	ldr	r0, [sp, #0x10]
700a7af4: 3801         	subs	r0, #0x1
700a7af6: 9004         	str	r0, [sp, #0x10]
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a7af8: e7e0         	b	0x700a7abc <UART_fifoWrite+0x6c> @ imm = #-0x40
;     }
700a7afa: e7ff         	b	0x700a7afc <UART_fifoWrite+0xac> @ imm = #-0x2
;     return (size - tempWriteSizeRemaining);
700a7afc: 9807         	ldr	r0, [sp, #0x1c]
700a7afe: 9908         	ldr	r1, [sp, #0x20]
700a7b00: 1a40         	subs	r0, r0, r1
700a7b02: b00c         	add	sp, #0x30
700a7b04: bd80         	pop	{r7, pc}
		...
700a7b0e: 0000         	movs	r0, r0

700a7b10 <xTaskRemoveFromEventList>:
; BaseType_t xTaskRemoveFromEventList(const List_t *const pxEventList) {
700a7b10: b580         	push	{r7, lr}
700a7b12: b084         	sub	sp, #0x10
700a7b14: 9003         	str	r0, [sp, #0xc]
;   pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a7b16: 9803         	ldr	r0, [sp, #0xc]
700a7b18: 68c0         	ldr	r0, [r0, #0xc]
700a7b1a: 68c0         	ldr	r0, [r0, #0xc]
700a7b1c: 9002         	str	r0, [sp, #0x8]
;   (void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
700a7b1e: 9802         	ldr	r0, [sp, #0x8]
700a7b20: 3018         	adds	r0, #0x18
700a7b22: f005 fdfd    	bl	0x700ad720 <uxListRemove> @ imm = #0x5bfa
;   if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a7b26: f642 2034    	movw	r0, #0x2a34
700a7b2a: f2c7 000b    	movt	r0, #0x700b
700a7b2e: 6800         	ldr	r0, [r0]
700a7b30: bb30         	cbnz	r0, 0x700a7b80 <xTaskRemoveFromEventList+0x70> @ imm = #0x4c
700a7b32: e7ff         	b	0x700a7b34 <xTaskRemoveFromEventList+0x24> @ imm = #-0x2
;     (void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
700a7b34: 9802         	ldr	r0, [sp, #0x8]
700a7b36: 3004         	adds	r0, #0x4
700a7b38: f005 fdf2    	bl	0x700ad720 <uxListRemove> @ imm = #0x5be4
;     prvAddTaskToReadyList(pxUnblockedTCB);
700a7b3c: 9802         	ldr	r0, [sp, #0x8]
700a7b3e: 6ac0         	ldr	r0, [r0, #0x2c]
700a7b40: f642 213c    	movw	r1, #0x2a3c
700a7b44: f2c7 010b    	movt	r1, #0x700b
700a7b48: 6809         	ldr	r1, [r1]
700a7b4a: 4288         	cmp	r0, r1
700a7b4c: d908         	bls	0x700a7b60 <xTaskRemoveFromEventList+0x50> @ imm = #0x10
700a7b4e: e7ff         	b	0x700a7b50 <xTaskRemoveFromEventList+0x40> @ imm = #-0x2
700a7b50: 9802         	ldr	r0, [sp, #0x8]
700a7b52: 6ac0         	ldr	r0, [r0, #0x2c]
700a7b54: f642 213c    	movw	r1, #0x2a3c
700a7b58: f2c7 010b    	movt	r1, #0x700b
700a7b5c: 6008         	str	r0, [r1]
700a7b5e: e7ff         	b	0x700a7b60 <xTaskRemoveFromEventList+0x50> @ imm = #-0x2
700a7b60: 9902         	ldr	r1, [sp, #0x8]
700a7b62: 6ac8         	ldr	r0, [r1, #0x2c]
700a7b64: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a7b68: f244 40f8    	movw	r0, #0x44f8
700a7b6c: f2c7 0008    	movt	r0, #0x7008
700a7b70: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a7b74: 3104         	adds	r1, #0x4
700a7b76: f006 fb8b    	bl	0x700ae290 <vListInsertEnd> @ imm = #0x6716
;       prvResetNextTaskUnblockTime();
700a7b7a: f006 fb09    	bl	0x700ae190 <prvResetNextTaskUnblockTime> @ imm = #0x6612
;   } else {
700a7b7e: e009         	b	0x700a7b94 <xTaskRemoveFromEventList+0x84> @ imm = #0x12
;     vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
700a7b80: 9802         	ldr	r0, [sp, #0x8]
700a7b82: f100 0118    	add.w	r1, r0, #0x18
700a7b86: f245 2060    	movw	r0, #0x5260
700a7b8a: f2c7 0008    	movt	r0, #0x7008
700a7b8e: f006 fb7f    	bl	0x700ae290 <vListInsertEnd> @ imm = #0x66fe
700a7b92: e7ff         	b	0x700a7b94 <xTaskRemoveFromEventList+0x84> @ imm = #-0x2
;   if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
700a7b94: 9802         	ldr	r0, [sp, #0x8]
700a7b96: 6ac0         	ldr	r0, [r0, #0x2c]
700a7b98: f642 210c    	movw	r1, #0x2a0c
700a7b9c: f2c7 010b    	movt	r1, #0x700b
700a7ba0: 6809         	ldr	r1, [r1]
700a7ba2: 6ac9         	ldr	r1, [r1, #0x2c]
700a7ba4: 4288         	cmp	r0, r1
700a7ba6: d908         	bls	0x700a7bba <xTaskRemoveFromEventList+0xaa> @ imm = #0x10
700a7ba8: e7ff         	b	0x700a7baa <xTaskRemoveFromEventList+0x9a> @ imm = #-0x2
700a7baa: 2001         	movs	r0, #0x1
;     xReturn = pdTRUE;
700a7bac: 9001         	str	r0, [sp, #0x4]
;     xYieldPending = pdTRUE;
700a7bae: f642 2160    	movw	r1, #0x2a60
700a7bb2: f2c7 010b    	movt	r1, #0x700b
700a7bb6: 6008         	str	r0, [r1]
;   } else {
700a7bb8: e002         	b	0x700a7bc0 <xTaskRemoveFromEventList+0xb0> @ imm = #0x4
700a7bba: 2000         	movs	r0, #0x0
;     xReturn = pdFALSE;
700a7bbc: 9001         	str	r0, [sp, #0x4]
700a7bbe: e7ff         	b	0x700a7bc0 <xTaskRemoveFromEventList+0xb0> @ imm = #-0x2
;   return xReturn;
700a7bc0: 9801         	ldr	r0, [sp, #0x4]
700a7bc2: b004         	add	sp, #0x10
700a7bc4: bd80         	pop	{r7, pc}
		...
700a7bce: 0000         	movs	r0, r0

700a7bd0 <Sciclient_getCurrentContext>:
; {
700a7bd0: b082         	sub	sp, #0x8
700a7bd2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700a7bd6: 200f         	movs	r0, #0xf
;     uint32_t retVal = SCICLIENT_CONTEXT_MAX_NUM;
700a7bd8: 9000         	str	r0, [sp]
;     if((TISCI_MSG_BOOT_NOTIFICATION == messageType) ||
700a7bda: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7bde: 280a         	cmp	r0, #0xa
700a7be0: d03e         	beq	0x700a7c60 <Sciclient_getCurrentContext+0x90> @ imm = #0x7c
700a7be2: e7ff         	b	0x700a7be4 <Sciclient_getCurrentContext+0x14> @ imm = #-0x2
;        (TISCI_MSG_SEC_HANDOVER == messageType) ||
700a7be4: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7be8: f249 0130    	movw	r1, #0x9030
700a7bec: 4288         	cmp	r0, r1
700a7bee: d037         	beq	0x700a7c60 <Sciclient_getCurrentContext+0x90> @ imm = #0x6e
700a7bf0: e7ff         	b	0x700a7bf2 <Sciclient_getCurrentContext+0x22> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG == messageType) ||
700a7bf2: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7bf6: 280b         	cmp	r0, #0xb
700a7bf8: d032         	beq	0x700a7c60 <Sciclient_getCurrentContext+0x90> @ imm = #0x64
700a7bfa: e7ff         	b	0x700a7bfc <Sciclient_getCurrentContext+0x2c> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_RM == messageType) ||
700a7bfc: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7c00: 280c         	cmp	r0, #0xc
700a7c02: d02d         	beq	0x700a7c60 <Sciclient_getCurrentContext+0x90> @ imm = #0x5a
700a7c04: e7ff         	b	0x700a7c06 <Sciclient_getCurrentContext+0x36> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_SECURITY == messageType) ||
700a7c06: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7c0a: 280d         	cmp	r0, #0xd
700a7c0c: d028         	beq	0x700a7c60 <Sciclient_getCurrentContext+0x90> @ imm = #0x50
700a7c0e: e7ff         	b	0x700a7c10 <Sciclient_getCurrentContext+0x40> @ imm = #-0x2
;        (TISCI_MSG_KEY_WRITER == messageType) ||
700a7c10: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7c14: f249 0131    	movw	r1, #0x9031
700a7c18: 4288         	cmp	r0, r1
700a7c1a: d021         	beq	0x700a7c60 <Sciclient_getCurrentContext+0x90> @ imm = #0x42
700a7c1c: e7ff         	b	0x700a7c1e <Sciclient_getCurrentContext+0x4e> @ imm = #-0x2
;        (TISCI_MSG_READ_OTP_MMR == messageType) ||
700a7c1e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7c22: f249 0122    	movw	r1, #0x9022
700a7c26: 4288         	cmp	r0, r1
700a7c28: d01a         	beq	0x700a7c60 <Sciclient_getCurrentContext+0x90> @ imm = #0x34
700a7c2a: e7ff         	b	0x700a7c2c <Sciclient_getCurrentContext+0x5c> @ imm = #-0x2
;        (TISCI_MSG_WRITE_OTP_ROW == messageType) ||
700a7c2c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7c30: f249 0123    	movw	r1, #0x9023
700a7c34: 4288         	cmp	r0, r1
700a7c36: d013         	beq	0x700a7c60 <Sciclient_getCurrentContext+0x90> @ imm = #0x26
700a7c38: e7ff         	b	0x700a7c3a <Sciclient_getCurrentContext+0x6a> @ imm = #-0x2
;        (TISCI_MSG_READ_SWREV == messageType) ||
700a7c3a: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7c3e: f249 0133    	movw	r1, #0x9033
700a7c42: 4288         	cmp	r0, r1
700a7c44: d00c         	beq	0x700a7c60 <Sciclient_getCurrentContext+0x90> @ imm = #0x18
700a7c46: e7ff         	b	0x700a7c48 <Sciclient_getCurrentContext+0x78> @ imm = #-0x2
;        (TISCI_MSG_WRITE_SWREV == messageType) ||
700a7c48: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7c4c: f249 0132    	movw	r1, #0x9032
700a7c50: 4288         	cmp	r0, r1
700a7c52: d005         	beq	0x700a7c60 <Sciclient_getCurrentContext+0x90> @ imm = #0xa
700a7c54: e7ff         	b	0x700a7c56 <Sciclient_getCurrentContext+0x86> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_PM == messageType))
700a7c56: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
;     if((TISCI_MSG_BOOT_NOTIFICATION == messageType) ||
700a7c5a: 280e         	cmp	r0, #0xe
700a7c5c: d107         	bne	0x700a7c6e <Sciclient_getCurrentContext+0x9e> @ imm = #0xe
700a7c5e: e7ff         	b	0x700a7c60 <Sciclient_getCurrentContext+0x90> @ imm = #-0x2
;         retVal = gSciclientHandle.secureContextId;
700a7c60: f642 1058    	movw	r0, #0x2958
700a7c64: f2c7 000b    	movt	r0, #0x700b
700a7c68: 68c0         	ldr	r0, [r0, #0xc]
700a7c6a: 9000         	str	r0, [sp]
;     }
700a7c6c: e006         	b	0x700a7c7c <Sciclient_getCurrentContext+0xac> @ imm = #0xc
;         retVal = gSciclientHandle.nonSecureContextId;
700a7c6e: f642 1058    	movw	r0, #0x2958
700a7c72: f2c7 000b    	movt	r0, #0x700b
700a7c76: 6900         	ldr	r0, [r0, #0x10]
700a7c78: 9000         	str	r0, [sp]
700a7c7a: e7ff         	b	0x700a7c7c <Sciclient_getCurrentContext+0xac> @ imm = #-0x2
;     return retVal;
700a7c7c: 9800         	ldr	r0, [sp]
700a7c7e: b002         	add	sp, #0x8
700a7c80: 4770         	bx	lr
		...
700a7c8e: 0000         	movs	r0, r0

700a7c90 <UART_init>:
; {
700a7c90: b580         	push	{r7, lr}
700a7c92: b086         	sub	sp, #0x18
700a7c94: 2000         	movs	r0, #0x0
;     for (cnt = 0U; cnt < gUartConfigNum; cnt++)
700a7c96: 9004         	str	r0, [sp, #0x10]
700a7c98: e7ff         	b	0x700a7c9a <UART_init+0xa> @ imm = #-0x2
700a7c9a: 9804         	ldr	r0, [sp, #0x10]
700a7c9c: f642 11fc    	movw	r1, #0x29fc
700a7ca0: f2c7 010b    	movt	r1, #0x700b
700a7ca4: 6809         	ldr	r1, [r1]
700a7ca6: 4288         	cmp	r0, r1
700a7ca8: d236         	bhs	0x700a7d18 <UART_init+0x88> @ imm = #0x6c
700a7caa: e7ff         	b	0x700a7cac <UART_init+0x1c> @ imm = #-0x2
;         object = gUartConfig[cnt].object;
700a7cac: 9904         	ldr	r1, [sp, #0x10]
700a7cae: f642 10b4    	movw	r0, #0x29b4
700a7cb2: f2c7 000b    	movt	r0, #0x700b
700a7cb6: 9002         	str	r0, [sp, #0x8]
700a7cb8: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a7cbc: 6840         	ldr	r0, [r0, #0x4]
700a7cbe: 9003         	str	r0, [sp, #0xc]
;         DebugP_assert(NULL_PTR != object);
700a7cc0: 9803         	ldr	r0, [sp, #0xc]
700a7cc2: 2800         	cmp	r0, #0x0
700a7cc4: bf18         	it	ne
700a7cc6: 2001         	movne	r0, #0x1
700a7cc8: f641 71ce    	movw	r1, #0x1fce
700a7ccc: f2c7 010b    	movt	r1, #0x700b
700a7cd0: 466a         	mov	r2, sp
700a7cd2: 6011         	str	r1, [r2]
700a7cd4: f641 71e1    	movw	r1, #0x1fe1
700a7cd8: f2c7 010b    	movt	r1, #0x700b
700a7cdc: f242 1251    	movw	r2, #0x2151
700a7ce0: f2c7 020b    	movt	r2, #0x700b
700a7ce4: 23bf         	movs	r3, #0xbf
700a7ce6: f002 ffd3    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x2fa6
;         (void)memset(object, 0, sizeof(UART_Object));
700a7cea: 9803         	ldr	r0, [sp, #0xc]
700a7cec: f44f 715a    	mov.w	r1, #0x368
700a7cf0: f7f3 ea10    	blx	0x7009b114 <__aeabi_memclr8> @ imm = #-0xcbe0
700a7cf4: 9802         	ldr	r0, [sp, #0x8]
;         gUartConfig[cnt].attrs->baseAddr = (uint32_t) AddrTranslateP_getLocalAddr((uint64_t)gUartConfig[cnt].attrs->baseAddr);
700a7cf6: 9904         	ldr	r1, [sp, #0x10]
700a7cf8: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
700a7cfc: 6800         	ldr	r0, [r0]
700a7cfe: 2100         	movs	r1, #0x0
700a7d00: f7fd ff8e    	bl	0x700a5c20 <AddrTranslateP_getLocalAddr> @ imm = #-0x20e4
700a7d04: 9902         	ldr	r1, [sp, #0x8]
700a7d06: 9a04         	ldr	r2, [sp, #0x10]
700a7d08: f851 1032    	ldr.w	r1, [r1, r2, lsl #3]
700a7d0c: 6008         	str	r0, [r1]
;     }
700a7d0e: e7ff         	b	0x700a7d10 <UART_init+0x80> @ imm = #-0x2
;     for (cnt = 0U; cnt < gUartConfigNum; cnt++)
700a7d10: 9804         	ldr	r0, [sp, #0x10]
700a7d12: 3001         	adds	r0, #0x1
700a7d14: 9004         	str	r0, [sp, #0x10]
700a7d16: e7c0         	b	0x700a7c9a <UART_init+0xa> @ imm = #-0x80
;     status = SemaphoreP_constructMutex(&gUartDrvObj.lockObj);
700a7d18: f242 7038    	movw	r0, #0x2738
700a7d1c: f2c7 000b    	movt	r0, #0x700b
700a7d20: 3004         	adds	r0, #0x4
700a7d22: f003 fc8d    	bl	0x700ab640 <SemaphoreP_constructMutex> @ imm = #0x391a
700a7d26: 9005         	str	r0, [sp, #0x14]
;     if(SystemP_SUCCESS == status)
700a7d28: 9805         	ldr	r0, [sp, #0x14]
700a7d2a: b938         	cbnz	r0, 0x700a7d3c <UART_init+0xac> @ imm = #0xe
700a7d2c: e7ff         	b	0x700a7d2e <UART_init+0x9e> @ imm = #-0x2
;         gUartDrvObj.lock = &gUartDrvObj.lockObj;
700a7d2e: f242 7138    	movw	r1, #0x2738
700a7d32: f2c7 010b    	movt	r1, #0x700b
700a7d36: 1d08         	adds	r0, r1, #0x4
700a7d38: 6008         	str	r0, [r1]
;     }
700a7d3a: e7ff         	b	0x700a7d3c <UART_init+0xac> @ imm = #-0x2
;     return;
700a7d3c: b006         	add	sp, #0x18
700a7d3e: bd80         	pop	{r7, pc}

700a7d40 <Udma_chCheckParams>:
; {
700a7d40: b084         	sub	sp, #0x10
700a7d42: 9003         	str	r0, [sp, #0xc]
700a7d44: 9102         	str	r1, [sp, #0x8]
700a7d46: 9201         	str	r2, [sp, #0x4]
700a7d48: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a7d4a: 9000         	str	r0, [sp]
;     if((chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA)
700a7d4c: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a7d50: 0700         	lsls	r0, r0, #0x1c
700a7d52: 2800         	cmp	r0, #0x0
700a7d54: d513         	bpl	0x700a7d7e <Udma_chCheckParams+0x3e> @ imm = #0x26
700a7d56: e7ff         	b	0x700a7d58 <Udma_chCheckParams+0x18> @ imm = #-0x2
;         if((UDMA_DMA_CH_INVALID == chPrms->peerChNum) ||
700a7d58: 9801         	ldr	r0, [sp, #0x4]
700a7d5a: 6840         	ldr	r0, [r0, #0x4]
700a7d5c: f510 3f80    	cmn.w	r0, #0x10000
700a7d60: d008         	beq	0x700a7d74 <Udma_chCheckParams+0x34> @ imm = #0x10
700a7d62: e7ff         	b	0x700a7d64 <Udma_chCheckParams+0x24> @ imm = #-0x2
;            (UDMA_DMA_CH_NA == chPrms->peerChNum))
700a7d64: 9801         	ldr	r0, [sp, #0x4]
700a7d66: 6840         	ldr	r0, [r0, #0x4]
700a7d68: 2102         	movs	r1, #0x2
700a7d6a: f6cf 71ff    	movt	r1, #0xffff
;         if((UDMA_DMA_CH_INVALID == chPrms->peerChNum) ||
700a7d6e: 4288         	cmp	r0, r1
700a7d70: d104         	bne	0x700a7d7c <Udma_chCheckParams+0x3c> @ imm = #0x8
700a7d72: e7ff         	b	0x700a7d74 <Udma_chCheckParams+0x34> @ imm = #-0x2
700a7d74: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7d78: 9000         	str	r0, [sp]
;         }
700a7d7a: e7ff         	b	0x700a7d7c <Udma_chCheckParams+0x3c> @ imm = #-0x2
;     }
700a7d7c: e7ff         	b	0x700a7d7e <Udma_chCheckParams+0x3e> @ imm = #-0x2
;     if((chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
700a7d7e: f89d 0009    	ldrb.w	r0, [sp, #0x9]
700a7d82: 07c0         	lsls	r0, r0, #0x1f
700a7d84: b388         	cbz	r0, 0x700a7dea <Udma_chCheckParams+0xaa> @ imm = #0x62
700a7d86: e7ff         	b	0x700a7d88 <Udma_chCheckParams+0x48> @ imm = #-0x2
;         if(UDMA_MAPPED_GROUP_INVALID == chPrms->mappedChGrp)
700a7d88: 9801         	ldr	r0, [sp, #0x4]
700a7d8a: 6880         	ldr	r0, [r0, #0x8]
700a7d8c: 2104         	movs	r1, #0x4
700a7d8e: f6cf 71ff    	movt	r1, #0xffff
700a7d92: 4288         	cmp	r0, r1
700a7d94: d104         	bne	0x700a7da0 <Udma_chCheckParams+0x60> @ imm = #0x8
700a7d96: e7ff         	b	0x700a7d98 <Udma_chCheckParams+0x58> @ imm = #-0x2
700a7d98: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7d9c: 9000         	str	r0, [sp]
;         }
700a7d9e: e7ff         	b	0x700a7da0 <Udma_chCheckParams+0x60> @ imm = #-0x2
;         if((chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a7da0: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a7da4: 07c0         	lsls	r0, r0, #0x1f
700a7da6: b150         	cbz	r0, 0x700a7dbe <Udma_chCheckParams+0x7e> @ imm = #0x14
700a7da8: e7ff         	b	0x700a7daa <Udma_chCheckParams+0x6a> @ imm = #-0x2
;             if(chPrms->mappedChGrp >= UDMA_NUM_MAPPED_TX_GROUP)
700a7daa: 9801         	ldr	r0, [sp, #0x4]
700a7dac: 6880         	ldr	r0, [r0, #0x8]
700a7dae: 2804         	cmp	r0, #0x4
700a7db0: d304         	blo	0x700a7dbc <Udma_chCheckParams+0x7c> @ imm = #0x8
700a7db2: e7ff         	b	0x700a7db4 <Udma_chCheckParams+0x74> @ imm = #-0x2
700a7db4: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a7db8: 9000         	str	r0, [sp]
;             }
700a7dba: e7ff         	b	0x700a7dbc <Udma_chCheckParams+0x7c> @ imm = #-0x2
;         }
700a7dbc: e7ff         	b	0x700a7dbe <Udma_chCheckParams+0x7e> @ imm = #-0x2
;         if((chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a7dbe: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a7dc2: 0780         	lsls	r0, r0, #0x1e
700a7dc4: 2800         	cmp	r0, #0x0
700a7dc6: d50f         	bpl	0x700a7de8 <Udma_chCheckParams+0xa8> @ imm = #0x1e
700a7dc8: e7ff         	b	0x700a7dca <Udma_chCheckParams+0x8a> @ imm = #-0x2
;             if((chPrms->mappedChGrp < UDMA_NUM_MAPPED_TX_GROUP) ||
700a7dca: 9801         	ldr	r0, [sp, #0x4]
700a7dcc: 6880         	ldr	r0, [r0, #0x8]
700a7dce: 2804         	cmp	r0, #0x4
700a7dd0: d305         	blo	0x700a7dde <Udma_chCheckParams+0x9e> @ imm = #0xa
700a7dd2: e7ff         	b	0x700a7dd4 <Udma_chCheckParams+0x94> @ imm = #-0x2
;                (chPrms->mappedChGrp >= (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
700a7dd4: 9801         	ldr	r0, [sp, #0x4]
700a7dd6: 6880         	ldr	r0, [r0, #0x8]
;             if((chPrms->mappedChGrp < UDMA_NUM_MAPPED_TX_GROUP) ||
700a7dd8: 2808         	cmp	r0, #0x8
700a7dda: d304         	blo	0x700a7de6 <Udma_chCheckParams+0xa6> @ imm = #0x8
700a7ddc: e7ff         	b	0x700a7dde <Udma_chCheckParams+0x9e> @ imm = #-0x2
700a7dde: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a7de2: 9000         	str	r0, [sp]
;             }
700a7de4: e7ff         	b	0x700a7de6 <Udma_chCheckParams+0xa6> @ imm = #-0x2
;         }
700a7de6: e7ff         	b	0x700a7de8 <Udma_chCheckParams+0xa8> @ imm = #-0x2
;     }
700a7de8: e7ff         	b	0x700a7dea <Udma_chCheckParams+0xaa> @ imm = #-0x2
;     return (retVal);
700a7dea: 9800         	ldr	r0, [sp]
700a7dec: b004         	add	sp, #0x10
700a7dee: 4770         	bx	lr

700a7df0 <Udma_getMappedChRingAttributes>:
; {
700a7df0: b087         	sub	sp, #0x1c
700a7df2: 9006         	str	r0, [sp, #0x18]
700a7df4: 9105         	str	r1, [sp, #0x14]
700a7df6: 9204         	str	r2, [sp, #0x10]
700a7df8: 9303         	str	r3, [sp, #0xc]
700a7dfa: 2000         	movs	r0, #0x0
;     uint32_t index = 0U;
700a7dfc: 9001         	str	r0, [sp, #0x4]
;     int32_t retVal = UDMA_SOK;
700a7dfe: 9000         	str	r0, [sp]
;     if(mappedGrp < UDMA_NUM_MAPPED_TX_GROUP) /* Mapped TX Channel */
700a7e00: 9805         	ldr	r0, [sp, #0x14]
700a7e02: 2803         	cmp	r0, #0x3
700a7e04: d81e         	bhi	0x700a7e44 <Udma_getMappedChRingAttributes+0x54> @ imm = #0x3c
700a7e06: e7ff         	b	0x700a7e08 <Udma_getMappedChRingAttributes+0x18> @ imm = #-0x2
;         if((chNum < CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START) ||
700a7e08: 9804         	ldr	r0, [sp, #0x10]
700a7e0a: 2810         	cmp	r0, #0x10
700a7e0c: d304         	blo	0x700a7e18 <Udma_getMappedChRingAttributes+0x28> @ imm = #0x8
700a7e0e: e7ff         	b	0x700a7e10 <Udma_getMappedChRingAttributes+0x20> @ imm = #-0x2
;            (chNum >= CSL_DMSS_PKTDMA_NUM_TX_CHANS))
700a7e10: 9804         	ldr	r0, [sp, #0x10]
;         if((chNum < CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START) ||
700a7e12: 282a         	cmp	r0, #0x2a
700a7e14: d304         	blo	0x700a7e20 <Udma_getMappedChRingAttributes+0x30> @ imm = #0x8
700a7e16: e7ff         	b	0x700a7e18 <Udma_getMappedChRingAttributes+0x28> @ imm = #-0x2
700a7e18: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7e1c: 9000         	str	r0, [sp]
;         }
700a7e1e: e7ff         	b	0x700a7e20 <Udma_getMappedChRingAttributes+0x30> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
700a7e20: 9800         	ldr	r0, [sp]
700a7e22: b970         	cbnz	r0, 0x700a7e42 <Udma_getMappedChRingAttributes+0x52> @ imm = #0x1c
700a7e24: e7ff         	b	0x700a7e26 <Udma_getMappedChRingAttributes+0x36> @ imm = #-0x2
;             index = chNum - CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START;
700a7e26: 9804         	ldr	r0, [sp, #0x10]
700a7e28: 3810         	subs	r0, #0x10
700a7e2a: 9001         	str	r0, [sp, #0x4]
;             mappedChRingAttributes = &gUdmaTxMappedChRingAttributes[index];
700a7e2c: 9801         	ldr	r0, [sp, #0x4]
700a7e2e: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a7e32: f241 40c8    	movw	r0, #0x14c8
700a7e36: f2c7 000b    	movt	r0, #0x700b
700a7e3a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7e3e: 9002         	str	r0, [sp, #0x8]
;         }
700a7e40: e7ff         	b	0x700a7e42 <Udma_getMappedChRingAttributes+0x52> @ imm = #-0x2
;     }
700a7e42: e01d         	b	0x700a7e80 <Udma_getMappedChRingAttributes+0x90> @ imm = #0x3a
;         if((chNum < CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START) ||
700a7e44: 9804         	ldr	r0, [sp, #0x10]
700a7e46: 2810         	cmp	r0, #0x10
700a7e48: d304         	blo	0x700a7e54 <Udma_getMappedChRingAttributes+0x64> @ imm = #0x8
700a7e4a: e7ff         	b	0x700a7e4c <Udma_getMappedChRingAttributes+0x5c> @ imm = #-0x2
;            (chNum >= CSL_DMSS_PKTDMA_NUM_RX_CHANS))
700a7e4c: 9804         	ldr	r0, [sp, #0x10]
;         if((chNum < CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START) ||
700a7e4e: 281d         	cmp	r0, #0x1d
700a7e50: d304         	blo	0x700a7e5c <Udma_getMappedChRingAttributes+0x6c> @ imm = #0x8
700a7e52: e7ff         	b	0x700a7e54 <Udma_getMappedChRingAttributes+0x64> @ imm = #-0x2
700a7e54: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7e58: 9000         	str	r0, [sp]
;         }
700a7e5a: e7ff         	b	0x700a7e5c <Udma_getMappedChRingAttributes+0x6c> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
700a7e5c: 9800         	ldr	r0, [sp]
700a7e5e: b970         	cbnz	r0, 0x700a7e7e <Udma_getMappedChRingAttributes+0x8e> @ imm = #0x1c
700a7e60: e7ff         	b	0x700a7e62 <Udma_getMappedChRingAttributes+0x72> @ imm = #-0x2
;             index = chNum - CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START;
700a7e62: 9804         	ldr	r0, [sp, #0x10]
700a7e64: 3810         	subs	r0, #0x10
700a7e66: 9001         	str	r0, [sp, #0x4]
;             mappedChRingAttributes = &gUdmaRxMappedChRingAttributes[index];
700a7e68: 9801         	ldr	r0, [sp, #0x4]
700a7e6a: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a7e6e: f241 7004    	movw	r0, #0x1704
700a7e72: f2c7 000b    	movt	r0, #0x700b
700a7e76: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7e7a: 9002         	str	r0, [sp, #0x8]
;         }
700a7e7c: e7ff         	b	0x700a7e7e <Udma_getMappedChRingAttributes+0x8e> @ imm = #-0x2
700a7e7e: e7ff         	b	0x700a7e80 <Udma_getMappedChRingAttributes+0x90> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7e80: 9800         	ldr	r0, [sp]
700a7e82: b948         	cbnz	r0, 0x700a7e98 <Udma_getMappedChRingAttributes+0xa8> @ imm = #0x12
700a7e84: e7ff         	b	0x700a7e86 <Udma_getMappedChRingAttributes+0x96> @ imm = #-0x2
;         (void) memcpy(chAttr, mappedChRingAttributes, sizeof (Udma_MappedChRingAttributes));
700a7e86: 9903         	ldr	r1, [sp, #0xc]
700a7e88: 9b02         	ldr	r3, [sp, #0x8]
700a7e8a: 6818         	ldr	r0, [r3]
700a7e8c: 685a         	ldr	r2, [r3, #0x4]
700a7e8e: 689b         	ldr	r3, [r3, #0x8]
700a7e90: 608b         	str	r3, [r1, #0x8]
700a7e92: 604a         	str	r2, [r1, #0x4]
700a7e94: 6008         	str	r0, [r1]
;     }
700a7e96: e7ff         	b	0x700a7e98 <Udma_getMappedChRingAttributes+0xa8> @ imm = #-0x2
;     return(retVal);
700a7e98: 9800         	ldr	r0, [sp]
700a7e9a: b007         	add	sp, #0x1c
700a7e9c: 4770         	bx	lr
700a7e9e: 0000         	movs	r0, r0

700a7ea0 <prvUnlockQueue>:
; {
700a7ea0: b580         	push	{r7, lr}
700a7ea2: b082         	sub	sp, #0x8
700a7ea4: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700a7ea6: f006 fc6b    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0x68d6
;         int8_t cTxLock = pxQueue->cTxLock;
700a7eaa: 9801         	ldr	r0, [sp, #0x4]
700a7eac: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a7eb0: f88d 0003    	strb.w	r0, [sp, #0x3]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
700a7eb4: e7ff         	b	0x700a7eb6 <prvUnlockQueue+0x16> @ imm = #-0x2
700a7eb6: f99d 0003    	ldrsb.w	r0, [sp, #0x3]
700a7eba: 2801         	cmp	r0, #0x1
700a7ebc: db16         	blt	0x700a7eec <prvUnlockQueue+0x4c> @ imm = #0x2c
700a7ebe: e7ff         	b	0x700a7ec0 <prvUnlockQueue+0x20> @ imm = #-0x2
;                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a7ec0: 9801         	ldr	r0, [sp, #0x4]
700a7ec2: 6a40         	ldr	r0, [r0, #0x24]
700a7ec4: b158         	cbz	r0, 0x700a7ede <prvUnlockQueue+0x3e> @ imm = #0x16
700a7ec6: e7ff         	b	0x700a7ec8 <prvUnlockQueue+0x28> @ imm = #-0x2
;                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a7ec8: 9801         	ldr	r0, [sp, #0x4]
700a7eca: 3024         	adds	r0, #0x24
700a7ecc: f7ff fe20    	bl	0x700a7b10 <xTaskRemoveFromEventList> @ imm = #-0x3c0
700a7ed0: b118         	cbz	r0, 0x700a7eda <prvUnlockQueue+0x3a> @ imm = #0x6
700a7ed2: e7ff         	b	0x700a7ed4 <prvUnlockQueue+0x34> @ imm = #-0x2
;                             vTaskMissedYield();
700a7ed4: f007 fe94    	bl	0x700afc00 <vTaskMissedYield> @ imm = #0x7d28
;                         }
700a7ed8: e000         	b	0x700a7edc <prvUnlockQueue+0x3c> @ imm = #0x0
700a7eda: e7ff         	b	0x700a7edc <prvUnlockQueue+0x3c> @ imm = #-0x2
;                     }
700a7edc: e000         	b	0x700a7ee0 <prvUnlockQueue+0x40> @ imm = #0x0
;                         break;
700a7ede: e005         	b	0x700a7eec <prvUnlockQueue+0x4c> @ imm = #0xa
;             --cTxLock;
700a7ee0: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a7ee4: 3801         	subs	r0, #0x1
700a7ee6: f88d 0003    	strb.w	r0, [sp, #0x3]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
700a7eea: e7e4         	b	0x700a7eb6 <prvUnlockQueue+0x16> @ imm = #-0x38
;         pxQueue->cTxLock = queueUNLOCKED;
700a7eec: 9901         	ldr	r1, [sp, #0x4]
700a7eee: 20ff         	movs	r0, #0xff
700a7ef0: f881 0045    	strb.w	r0, [r1, #0x45]
;     taskEXIT_CRITICAL();
700a7ef4: f005 fd04    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0x5a08
;     taskENTER_CRITICAL();
700a7ef8: f006 fc42    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0x6884
;         int8_t cRxLock = pxQueue->cRxLock;
700a7efc: 9801         	ldr	r0, [sp, #0x4]
700a7efe: f890 0044    	ldrb.w	r0, [r0, #0x44]
700a7f02: f88d 0002    	strb.w	r0, [sp, #0x2]
;         while( cRxLock > queueLOCKED_UNMODIFIED )
700a7f06: e7ff         	b	0x700a7f08 <prvUnlockQueue+0x68> @ imm = #-0x2
700a7f08: f99d 0002    	ldrsb.w	r0, [sp, #0x2]
700a7f0c: 2801         	cmp	r0, #0x1
700a7f0e: db16         	blt	0x700a7f3e <prvUnlockQueue+0x9e> @ imm = #0x2c
700a7f10: e7ff         	b	0x700a7f12 <prvUnlockQueue+0x72> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a7f12: 9801         	ldr	r0, [sp, #0x4]
700a7f14: 6900         	ldr	r0, [r0, #0x10]
700a7f16: b180         	cbz	r0, 0x700a7f3a <prvUnlockQueue+0x9a> @ imm = #0x20
700a7f18: e7ff         	b	0x700a7f1a <prvUnlockQueue+0x7a> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a7f1a: 9801         	ldr	r0, [sp, #0x4]
700a7f1c: 3010         	adds	r0, #0x10
700a7f1e: f7ff fdf7    	bl	0x700a7b10 <xTaskRemoveFromEventList> @ imm = #-0x412
700a7f22: b118         	cbz	r0, 0x700a7f2c <prvUnlockQueue+0x8c> @ imm = #0x6
700a7f24: e7ff         	b	0x700a7f26 <prvUnlockQueue+0x86> @ imm = #-0x2
;                     vTaskMissedYield();
700a7f26: f007 fe6b    	bl	0x700afc00 <vTaskMissedYield> @ imm = #0x7cd6
;                 }
700a7f2a: e000         	b	0x700a7f2e <prvUnlockQueue+0x8e> @ imm = #0x0
700a7f2c: e7ff         	b	0x700a7f2e <prvUnlockQueue+0x8e> @ imm = #-0x2
;                 --cRxLock;
700a7f2e: f89d 0002    	ldrb.w	r0, [sp, #0x2]
700a7f32: 3801         	subs	r0, #0x1
700a7f34: f88d 0002    	strb.w	r0, [sp, #0x2]
;             }
700a7f38: e000         	b	0x700a7f3c <prvUnlockQueue+0x9c> @ imm = #0x0
;                 break;
700a7f3a: e000         	b	0x700a7f3e <prvUnlockQueue+0x9e> @ imm = #0x0
;         while( cRxLock > queueLOCKED_UNMODIFIED )
700a7f3c: e7e4         	b	0x700a7f08 <prvUnlockQueue+0x68> @ imm = #-0x38
;         pxQueue->cRxLock = queueUNLOCKED;
700a7f3e: 9901         	ldr	r1, [sp, #0x4]
700a7f40: 20ff         	movs	r0, #0xff
700a7f42: f881 0044    	strb.w	r0, [r1, #0x44]
;     taskEXIT_CRITICAL();
700a7f46: f005 fcdb    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0x59b6
; }
700a7f4a: b002         	add	sp, #0x8
700a7f4c: bd80         	pop	{r7, pc}
700a7f4e: 0000         	movs	r0, r0

700a7f50 <SemaphoreP_constructBinary>:
; {
700a7f50: b580         	push	{r7, lr}
700a7f52: b086         	sub	sp, #0x18
700a7f54: 9005         	str	r0, [sp, #0x14]
700a7f56: 9104         	str	r1, [sp, #0x10]
700a7f58: 2000         	movs	r0, #0x0
;     SemaphoreP_Struct *pSemaphore = NULL;
700a7f5a: 9003         	str	r0, [sp, #0xc]
700a7f5c: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700a7f60: 9002         	str	r0, [sp, #0x8]
;     DebugP_assert(sizeof(SemaphoreP_Struct) <= sizeof(SemaphoreP_Object) );
700a7f62: f641 10eb    	movw	r0, #0x19eb
700a7f66: f2c7 000b    	movt	r0, #0x700b
700a7f6a: 4669         	mov	r1, sp
700a7f6c: 6008         	str	r0, [r1]
700a7f6e: f641 41a6    	movw	r1, #0x1ca6
700a7f72: f2c7 010b    	movt	r1, #0x700b
700a7f76: f641 6250    	movw	r2, #0x1e50
700a7f7a: f2c7 020b    	movt	r2, #0x700b
700a7f7e: 2001         	movs	r0, #0x1
700a7f80: 2332         	movs	r3, #0x32
700a7f82: f002 fe85    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x2d0a
;     if(obj != NULL)
700a7f86: 9805         	ldr	r0, [sp, #0x14]
700a7f88: b128         	cbz	r0, 0x700a7f96 <SemaphoreP_constructBinary+0x46> @ imm = #0xa
700a7f8a: e7ff         	b	0x700a7f8c <SemaphoreP_constructBinary+0x3c> @ imm = #-0x2
;         pSemaphore = (SemaphoreP_Struct *)obj;
700a7f8c: 9805         	ldr	r0, [sp, #0x14]
700a7f8e: 9003         	str	r0, [sp, #0xc]
700a7f90: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700a7f92: 9002         	str	r0, [sp, #0x8]
;     }
700a7f94: e7ff         	b	0x700a7f96 <SemaphoreP_constructBinary+0x46> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
700a7f96: 9802         	ldr	r0, [sp, #0x8]
700a7f98: bb68         	cbnz	r0, 0x700a7ff6 <SemaphoreP_constructBinary+0xa6> @ imm = #0x5a
700a7f9a: e7ff         	b	0x700a7f9c <SemaphoreP_constructBinary+0x4c> @ imm = #-0x2
;         pSemaphore->isRecursiveMutex = 0;
700a7f9c: 9803         	ldr	r0, [sp, #0xc]
700a7f9e: 2200         	movs	r2, #0x0
700a7fa0: 6542         	str	r2, [r0, #0x54]
;         pSemaphore->semHndl = xSemaphoreCreateBinaryStatic(&pSemaphore->semObj);
700a7fa2: 9b03         	ldr	r3, [sp, #0xc]
700a7fa4: 4669         	mov	r1, sp
700a7fa6: 2003         	movs	r0, #0x3
700a7fa8: 6008         	str	r0, [r1]
700a7faa: 2001         	movs	r0, #0x1
700a7fac: 4611         	mov	r1, r2
700a7fae: f005 fb1f    	bl	0x700ad5f0 <xQueueGenericCreateStatic> @ imm = #0x563e
700a7fb2: 9903         	ldr	r1, [sp, #0xc]
700a7fb4: 6508         	str	r0, [r1, #0x50]
;         if( pSemaphore->semHndl == NULL )
700a7fb6: 9803         	ldr	r0, [sp, #0xc]
700a7fb8: 6d00         	ldr	r0, [r0, #0x50]
700a7fba: b920         	cbnz	r0, 0x700a7fc6 <SemaphoreP_constructBinary+0x76> @ imm = #0x8
700a7fbc: e7ff         	b	0x700a7fbe <SemaphoreP_constructBinary+0x6e> @ imm = #-0x2
700a7fbe: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
700a7fc2: 9002         	str	r0, [sp, #0x8]
;         }
700a7fc4: e016         	b	0x700a7ff4 <SemaphoreP_constructBinary+0xa4> @ imm = #0x2c
;             vQueueAddToRegistry(pSemaphore->semHndl, "Binary Sem (DPL)");
700a7fc6: 9803         	ldr	r0, [sp, #0xc]
700a7fc8: 6d00         	ldr	r0, [r0, #0x50]
700a7fca: f242 01a2    	movw	r1, #0x20a2
700a7fce: f2c7 010b    	movt	r1, #0x700b
700a7fd2: f005 f87d    	bl	0x700ad0d0 <vQueueAddToRegistry> @ imm = #0x50fa
;             if(initCount == 1U)
700a7fd6: 9804         	ldr	r0, [sp, #0x10]
700a7fd8: 2801         	cmp	r0, #0x1
700a7fda: d108         	bne	0x700a7fee <SemaphoreP_constructBinary+0x9e> @ imm = #0x10
700a7fdc: e7ff         	b	0x700a7fde <SemaphoreP_constructBinary+0x8e> @ imm = #-0x2
;                 (void)xSemaphoreGive(pSemaphore->semHndl);
700a7fde: 9803         	ldr	r0, [sp, #0xc]
700a7fe0: 6d00         	ldr	r0, [r0, #0x50]
700a7fe2: 2300         	movs	r3, #0x0
700a7fe4: 4619         	mov	r1, r3
700a7fe6: 461a         	mov	r2, r3
700a7fe8: f7fb f98a    	bl	0x700a3300 <xQueueGenericSend> @ imm = #-0x4cec
;             }
700a7fec: e7ff         	b	0x700a7fee <SemaphoreP_constructBinary+0x9e> @ imm = #-0x2
700a7fee: 2000         	movs	r0, #0x0
;             status = SystemP_SUCCESS;
700a7ff0: 9002         	str	r0, [sp, #0x8]
700a7ff2: e7ff         	b	0x700a7ff4 <SemaphoreP_constructBinary+0xa4> @ imm = #-0x2
;     }
700a7ff4: e7ff         	b	0x700a7ff6 <SemaphoreP_constructBinary+0xa6> @ imm = #-0x2
;     return status;
700a7ff6: 9802         	ldr	r0, [sp, #0x8]
700a7ff8: b006         	add	sp, #0x18
700a7ffa: bd80         	pop	{r7, pc}
700a7ffc: 0000         	movs	r0, r0
700a7ffe: 0000         	movs	r0, r0

700a8000 <UdmaChRxPrms_init>:
; {
700a8000: b083         	sub	sp, #0xc
700a8002: 9002         	str	r0, [sp, #0x8]
700a8004: 9101         	str	r1, [sp, #0x4]
;     if(NULL_PTR != rxPrms)
700a8006: 9802         	ldr	r0, [sp, #0x8]
700a8008: 2800         	cmp	r0, #0x0
700a800a: d04d         	beq	0x700a80a8 <UdmaChRxPrms_init+0xa8> @ imm = #0x9a
700a800c: e7ff         	b	0x700a800e <UdmaChRxPrms_init+0xe> @ imm = #-0x2
;         rxPrms->pauseOnError        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERROR_DISABLED;
700a800e: 9902         	ldr	r1, [sp, #0x8]
700a8010: 2000         	movs	r0, #0x0
700a8012: 7008         	strb	r0, [r1]
;         rxPrms->addrType            = TISCI_MSG_VALUE_RM_UDMAP_CH_ATYPE_PHYS;
700a8014: 9902         	ldr	r1, [sp, #0x8]
700a8016: 7048         	strb	r0, [r1, #0x1]
;         rxPrms->chanType            = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_PACKET;
700a8018: 9902         	ldr	r1, [sp, #0x8]
700a801a: 2002         	movs	r0, #0x2
700a801c: 7088         	strb	r0, [r1, #0x2]
;         if((chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a801e: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a8022: 0740         	lsls	r0, r0, #0x1d
700a8024: 2800         	cmp	r0, #0x0
700a8026: d504         	bpl	0x700a8032 <UdmaChRxPrms_init+0x32> @ imm = #0x8
700a8028: e7ff         	b	0x700a802a <UdmaChRxPrms_init+0x2a> @ imm = #-0x2
;             rxPrms->chanType        = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_3P_BLOCK_REF;
700a802a: 9902         	ldr	r1, [sp, #0x8]
700a802c: 200c         	movs	r0, #0xc
700a802e: 7088         	strb	r0, [r1, #0x2]
;         }
700a8030: e7ff         	b	0x700a8032 <UdmaChRxPrms_init+0x32> @ imm = #-0x2
;         rxPrms->fetchWordSize       = 16U;  /* sizeof(CSL_UdmapTR15) / sizeof(uint32_t) */
700a8032: 9902         	ldr	r1, [sp, #0x8]
700a8034: 2010         	movs	r0, #0x10
700a8036: 8088         	strh	r0, [r1, #0x4]
;         rxPrms->busPriority         = UDMA_DEFAULT_RX_CH_BUS_PRIORITY;
700a8038: 9902         	ldr	r1, [sp, #0x8]
700a803a: 2004         	movs	r0, #0x4
700a803c: 7188         	strb	r0, [r1, #0x6]
;         rxPrms->busQos              = UDMA_DEFAULT_RX_CH_BUS_QOS;
700a803e: 9902         	ldr	r1, [sp, #0x8]
700a8040: 71c8         	strb	r0, [r1, #0x7]
;         rxPrms->busOrderId          = UDMA_DEFAULT_RX_CH_BUS_ORDERID;
700a8042: 9802         	ldr	r0, [sp, #0x8]
700a8044: 2100         	movs	r1, #0x0
700a8046: 9100         	str	r1, [sp]
700a8048: 7201         	strb	r1, [r0, #0x8]
;         rxPrms->dmaPriority         = UDMA_DEFAULT_RX_CH_DMA_PRIORITY;
700a804a: 9a02         	ldr	r2, [sp, #0x8]
700a804c: 2001         	movs	r0, #0x1
700a804e: 7250         	strb	r0, [r2, #0x9]
;         rxPrms->flowIdFwRangeStart  = 0U;       /* Reset value - to use default flow */
700a8050: 9a02         	ldr	r2, [sp, #0x8]
700a8052: 8151         	strh	r1, [r2, #0xa]
;         rxPrms->flowIdFwRangeCnt    = 0U;       /* Reset value - to use default flow */
700a8054: 9a02         	ldr	r2, [sp, #0x8]
700a8056: 8191         	strh	r1, [r2, #0xc]
;         rxPrms->flowEInfoPresent    = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_EINFO_NOT_PRESENT;       /* Default no EINFO */
700a8058: 9a02         	ldr	r2, [sp, #0x8]
700a805a: 7391         	strb	r1, [r2, #0xe]
;         rxPrms->flowPsInfoPresent   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PSINFO_NOT_PRESENT;      /* Default no PSINFO */
700a805c: 9a02         	ldr	r2, [sp, #0x8]
700a805e: 73d1         	strb	r1, [r2, #0xf]
;         rxPrms->flowErrorHandling   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_ERR_RETRY;       /* Default Re-try descriptor allocation operation on starvation error */
700a8060: 9a02         	ldr	r2, [sp, #0x8]
700a8062: 7410         	strb	r0, [r2, #0x10]
;         rxPrms->flowSopOffset       = 0U;      /* Default SOP offset is 0 */
700a8064: 9a02         	ldr	r2, [sp, #0x8]
700a8066: 7451         	strb	r1, [r2, #0x11]
;         rxPrms->ignoreShortPkts     = TISCI_MSG_VALUE_RM_UDMAP_RX_CH_PACKET_EXCEPTION;
700a8068: 9a02         	ldr	r2, [sp, #0x8]
700a806a: 7491         	strb	r1, [r2, #0x12]
;         rxPrms->ignoreLongPkts      = TISCI_MSG_VALUE_RM_UDMAP_RX_CH_PACKET_EXCEPTION;
700a806c: 9a02         	ldr	r2, [sp, #0x8]
700a806e: 74d1         	strb	r1, [r2, #0x13]
;         rxPrms->configDefaultFlow   = TRUE;
700a8070: 9902         	ldr	r1, [sp, #0x8]
700a8072: 6148         	str	r0, [r1, #0x14]
;         if((chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
700a8074: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a8078: 0600         	lsls	r0, r0, #0x18
700a807a: 2800         	cmp	r0, #0x0
700a807c: d504         	bpl	0x700a8088 <UdmaChRxPrms_init+0x88> @ imm = #0x8
700a807e: e7ff         	b	0x700a8080 <UdmaChRxPrms_init+0x80> @ imm = #-0x2
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a8080: 9902         	ldr	r1, [sp, #0x8]
700a8082: 2003         	movs	r0, #0x3
700a8084: 7608         	strb	r0, [r1, #0x18]
;         }
700a8086: e00e         	b	0x700a80a6 <UdmaChRxPrms_init+0xa6> @ imm = #0x1c
;         else if((chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
700a8088: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a808c: 0640         	lsls	r0, r0, #0x19
700a808e: 2800         	cmp	r0, #0x0
700a8090: d504         	bpl	0x700a809c <UdmaChRxPrms_init+0x9c> @ imm = #0x8
700a8092: e7ff         	b	0x700a8094 <UdmaChRxPrms_init+0x94> @ imm = #-0x2
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a8094: 9902         	ldr	r1, [sp, #0x8]
700a8096: 2003         	movs	r0, #0x3
700a8098: 7608         	strb	r0, [r1, #0x18]
;         }
700a809a: e003         	b	0x700a80a4 <UdmaChRxPrms_init+0xa4> @ imm = #0x6
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_64_BYTES;
700a809c: 9902         	ldr	r1, [sp, #0x8]
700a809e: 2001         	movs	r0, #0x1
700a80a0: 7608         	strb	r0, [r1, #0x18]
700a80a2: e7ff         	b	0x700a80a4 <UdmaChRxPrms_init+0xa4> @ imm = #-0x2
700a80a4: e7ff         	b	0x700a80a6 <UdmaChRxPrms_init+0xa6> @ imm = #-0x2
;     }
700a80a6: e7ff         	b	0x700a80a8 <UdmaChRxPrms_init+0xa8> @ imm = #-0x2
;     return;
700a80a8: b003         	add	sp, #0xc
700a80aa: 4770         	bx	lr
700a80ac: 0000         	movs	r0, r0
700a80ae: 0000         	movs	r0, r0

700a80b0 <UdmaChTxPrms_init>:
; {
700a80b0: b082         	sub	sp, #0x8
700a80b2: 9001         	str	r0, [sp, #0x4]
700a80b4: 9100         	str	r1, [sp]
;     if(NULL_PTR != txPrms)
700a80b6: 9801         	ldr	r0, [sp, #0x4]
700a80b8: 2800         	cmp	r0, #0x0
700a80ba: d04d         	beq	0x700a8158 <UdmaChTxPrms_init+0xa8> @ imm = #0x9a
700a80bc: e7ff         	b	0x700a80be <UdmaChTxPrms_init+0xe> @ imm = #-0x2
;         txPrms->pauseOnError    = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERROR_DISABLED;
700a80be: 9901         	ldr	r1, [sp, #0x4]
700a80c0: 2000         	movs	r0, #0x0
700a80c2: 7008         	strb	r0, [r1]
;         txPrms->filterEinfo     = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_FILT_EINFO_DISABLED;
700a80c4: 9901         	ldr	r1, [sp, #0x4]
700a80c6: 7048         	strb	r0, [r1, #0x1]
;         txPrms->filterPsWords   = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_FILT_PSWORDS_DISABLED;
700a80c8: 9901         	ldr	r1, [sp, #0x4]
700a80ca: 7088         	strb	r0, [r1, #0x2]
;         txPrms->addrType        = TISCI_MSG_VALUE_RM_UDMAP_CH_ATYPE_PHYS;
700a80cc: 9901         	ldr	r1, [sp, #0x4]
700a80ce: 70c8         	strb	r0, [r1, #0x3]
;         txPrms->chanType        = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_PACKET;
700a80d0: 9901         	ldr	r1, [sp, #0x4]
700a80d2: 2002         	movs	r0, #0x2
700a80d4: 7108         	strb	r0, [r1, #0x4]
;         if((chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a80d6: f89d 0000    	ldrb.w	r0, [sp]
700a80da: 0740         	lsls	r0, r0, #0x1d
700a80dc: 2800         	cmp	r0, #0x0
700a80de: d504         	bpl	0x700a80ea <UdmaChTxPrms_init+0x3a> @ imm = #0x8
700a80e0: e7ff         	b	0x700a80e2 <UdmaChTxPrms_init+0x32> @ imm = #-0x2
;             txPrms->chanType    = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_3P_BLOCK_REF;
700a80e2: 9901         	ldr	r1, [sp, #0x4]
700a80e4: 200c         	movs	r0, #0xc
700a80e6: 7108         	strb	r0, [r1, #0x4]
;         }
700a80e8: e7ff         	b	0x700a80ea <UdmaChTxPrms_init+0x3a> @ imm = #-0x2
;         txPrms->fetchWordSize   = 16U;  /* sizeof(CSL_UdmapTR15) / sizeof(uint32_t) */
700a80ea: 9901         	ldr	r1, [sp, #0x4]
700a80ec: 2010         	movs	r0, #0x10
700a80ee: 80c8         	strh	r0, [r1, #0x6]
;         txPrms->busPriority     = UDMA_DEFAULT_TX_CH_BUS_PRIORITY;
700a80f0: 9901         	ldr	r1, [sp, #0x4]
700a80f2: 2004         	movs	r0, #0x4
700a80f4: 7208         	strb	r0, [r1, #0x8]
;         txPrms->busQos          = UDMA_DEFAULT_TX_CH_BUS_QOS;
700a80f6: 9901         	ldr	r1, [sp, #0x4]
700a80f8: 7248         	strb	r0, [r1, #0x9]
;         txPrms->busOrderId      = UDMA_DEFAULT_TX_CH_BUS_ORDERID;
700a80fa: 9901         	ldr	r1, [sp, #0x4]
700a80fc: 2000         	movs	r0, #0x0
700a80fe: 7288         	strb	r0, [r1, #0xa]
;         txPrms->dmaPriority     = UDMA_DEFAULT_TX_CH_DMA_PRIORITY;
700a8100: 9a01         	ldr	r2, [sp, #0x4]
700a8102: 2101         	movs	r1, #0x1
700a8104: 72d1         	strb	r1, [r2, #0xb]
;         txPrms->txCredit        = 0U;
700a8106: 9901         	ldr	r1, [sp, #0x4]
700a8108: 7308         	strb	r0, [r1, #0xc]
;         if((chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
700a810a: f89d 0000    	ldrb.w	r0, [sp]
700a810e: ea4f 6000    	lsl.w	r0, r0, #0x18
700a8112: 2800         	cmp	r0, #0x0
700a8114: d507         	bpl	0x700a8126 <UdmaChTxPrms_init+0x76> @ imm = #0xe
700a8116: e7ff         	b	0x700a8118 <UdmaChTxPrms_init+0x68> @ imm = #-0x2
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_UHC_CHANS_FDEPTH;
700a8118: 9901         	ldr	r1, [sp, #0x4]
700a811a: 2000         	movs	r0, #0x0
700a811c: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a811e: 9901         	ldr	r1, [sp, #0x4]
700a8120: 2003         	movs	r0, #0x3
700a8122: 7408         	strb	r0, [r1, #0x10]
;         }
700a8124: e014         	b	0x700a8150 <UdmaChTxPrms_init+0xa0> @ imm = #0x28
;         else if((chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
700a8126: f89d 0000    	ldrb.w	r0, [sp]
700a812a: 0640         	lsls	r0, r0, #0x19
700a812c: 2800         	cmp	r0, #0x0
700a812e: d507         	bpl	0x700a8140 <UdmaChTxPrms_init+0x90> @ imm = #0xe
700a8130: e7ff         	b	0x700a8132 <UdmaChTxPrms_init+0x82> @ imm = #-0x2
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_HC_CHANS_FDEPTH;
700a8132: 9901         	ldr	r1, [sp, #0x4]
700a8134: 2000         	movs	r0, #0x0
700a8136: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a8138: 9901         	ldr	r1, [sp, #0x4]
700a813a: 2003         	movs	r0, #0x3
700a813c: 7408         	strb	r0, [r1, #0x10]
;         }
700a813e: e006         	b	0x700a814e <UdmaChTxPrms_init+0x9e> @ imm = #0xc
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_CHANS_FDEPTH;
700a8140: 9901         	ldr	r1, [sp, #0x4]
700a8142: 20c0         	movs	r0, #0xc0
700a8144: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_64_BYTES;
700a8146: 9901         	ldr	r1, [sp, #0x4]
700a8148: 2001         	movs	r0, #0x1
700a814a: 7408         	strb	r0, [r1, #0x10]
700a814c: e7ff         	b	0x700a814e <UdmaChTxPrms_init+0x9e> @ imm = #-0x2
700a814e: e7ff         	b	0x700a8150 <UdmaChTxPrms_init+0xa0> @ imm = #-0x2
;         txPrms->supressTdCqPkt  = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_SUPPRESS_TD_DISABLED;
700a8150: 9901         	ldr	r1, [sp, #0x4]
700a8152: 2000         	movs	r0, #0x0
700a8154: 7448         	strb	r0, [r1, #0x11]
;     }
700a8156: e7ff         	b	0x700a8158 <UdmaChTxPrms_init+0xa8> @ imm = #-0x2
;     return;
700a8158: b002         	add	sp, #0x8
700a815a: 4770         	bx	lr
700a815c: 0000         	movs	r0, r0
700a815e: 0000         	movs	r0, r0

700a8160 <Udma_chDisable>:
; {
700a8160: b580         	push	{r7, lr}
700a8162: b086         	sub	sp, #0x18
700a8164: 9005         	str	r0, [sp, #0x14]
700a8166: 9104         	str	r1, [sp, #0x10]
700a8168: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a816a: 9003         	str	r0, [sp, #0xc]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a816c: 9805         	ldr	r0, [sp, #0x14]
700a816e: 9001         	str	r0, [sp, #0x4]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a8170: 9801         	ldr	r0, [sp, #0x4]
700a8172: b150         	cbz	r0, 0x700a818a <Udma_chDisable+0x2a> @ imm = #0x14
700a8174: e7ff         	b	0x700a8176 <Udma_chDisable+0x16> @ imm = #-0x2
700a8176: 9801         	ldr	r0, [sp, #0x4]
700a8178: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a817c: f64a 31cd    	movw	r1, #0xabcd
700a8180: f6ca 31dc    	movt	r1, #0xabdc
700a8184: 4288         	cmp	r0, r1
700a8186: d004         	beq	0x700a8192 <Udma_chDisable+0x32> @ imm = #0x8
700a8188: e7ff         	b	0x700a818a <Udma_chDisable+0x2a> @ imm = #-0x2
700a818a: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a818e: 9003         	str	r0, [sp, #0xc]
;     }
700a8190: e7ff         	b	0x700a8192 <Udma_chDisable+0x32> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a8192: 9803         	ldr	r0, [sp, #0xc]
700a8194: b9a8         	cbnz	r0, 0x700a81c2 <Udma_chDisable+0x62> @ imm = #0x2a
700a8196: e7ff         	b	0x700a8198 <Udma_chDisable+0x38> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a8198: 9801         	ldr	r0, [sp, #0x4]
700a819a: 6e80         	ldr	r0, [r0, #0x68]
700a819c: 9002         	str	r0, [sp, #0x8]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a819e: 9802         	ldr	r0, [sp, #0x8]
700a81a0: b150         	cbz	r0, 0x700a81b8 <Udma_chDisable+0x58> @ imm = #0x14
700a81a2: e7ff         	b	0x700a81a4 <Udma_chDisable+0x44> @ imm = #-0x2
700a81a4: 9802         	ldr	r0, [sp, #0x8]
700a81a6: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a81aa: f64a 31cd    	movw	r1, #0xabcd
700a81ae: f6ca 31dc    	movt	r1, #0xabdc
700a81b2: 4288         	cmp	r0, r1
700a81b4: d004         	beq	0x700a81c0 <Udma_chDisable+0x60> @ imm = #0x8
700a81b6: e7ff         	b	0x700a81b8 <Udma_chDisable+0x58> @ imm = #-0x2
700a81b8: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a81bc: 9003         	str	r0, [sp, #0xc]
;         }
700a81be: e7ff         	b	0x700a81c0 <Udma_chDisable+0x60> @ imm = #-0x2
;     }
700a81c0: e7ff         	b	0x700a81c2 <Udma_chDisable+0x62> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a81c2: 9803         	ldr	r0, [sp, #0xc]
700a81c4: b9f8         	cbnz	r0, 0x700a8206 <Udma_chDisable+0xa6> @ imm = #0x3e
700a81c6: e7ff         	b	0x700a81c8 <Udma_chDisable+0x68> @ imm = #-0x2
;         if((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a81c8: 9801         	ldr	r0, [sp, #0x4]
700a81ca: 7800         	ldrb	r0, [r0]
700a81cc: 0740         	lsls	r0, r0, #0x1d
700a81ce: 2800         	cmp	r0, #0x0
700a81d0: d506         	bpl	0x700a81e0 <Udma_chDisable+0x80> @ imm = #0xc
700a81d2: e7ff         	b	0x700a81d4 <Udma_chDisable+0x74> @ imm = #-0x2
;             retVal = Udma_chDisableBlkCpyChan(chHandleInt, timeout);
700a81d4: 9801         	ldr	r0, [sp, #0x4]
700a81d6: 9904         	ldr	r1, [sp, #0x10]
700a81d8: f7f7 f972    	bl	0x7009f4c0 <Udma_chDisableBlkCpyChan> @ imm = #-0x8d1c
700a81dc: 9003         	str	r0, [sp, #0xc]
;         }
700a81de: e011         	b	0x700a8204 <Udma_chDisable+0xa4> @ imm = #0x22
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a81e0: 9801         	ldr	r0, [sp, #0x4]
700a81e2: 7800         	ldrb	r0, [r0]
700a81e4: 07c0         	lsls	r0, r0, #0x1f
700a81e6: b130         	cbz	r0, 0x700a81f6 <Udma_chDisable+0x96> @ imm = #0xc
700a81e8: e7ff         	b	0x700a81ea <Udma_chDisable+0x8a> @ imm = #-0x2
;                 retVal = Udma_chDisableTxChan(chHandleInt, timeout);
700a81ea: 9801         	ldr	r0, [sp, #0x4]
700a81ec: 9904         	ldr	r1, [sp, #0x10]
700a81ee: f7f4 fa1f    	bl	0x7009c630 <Udma_chDisableTxChan> @ imm = #-0xbbc2
700a81f2: 9003         	str	r0, [sp, #0xc]
;             }
700a81f4: e005         	b	0x700a8202 <Udma_chDisable+0xa2> @ imm = #0xa
;                 retVal = Udma_chDisableRxChan(chHandleInt, timeout);
700a81f6: 9801         	ldr	r0, [sp, #0x4]
700a81f8: 9904         	ldr	r1, [sp, #0x10]
700a81fa: f7f5 fb61    	bl	0x7009d8c0 <Udma_chDisableRxChan> @ imm = #-0xa93e
700a81fe: 9003         	str	r0, [sp, #0xc]
700a8200: e7ff         	b	0x700a8202 <Udma_chDisable+0xa2> @ imm = #-0x2
700a8202: e7ff         	b	0x700a8204 <Udma_chDisable+0xa4> @ imm = #-0x2
;     }
700a8204: e7ff         	b	0x700a8206 <Udma_chDisable+0xa6> @ imm = #-0x2
;     return (retVal);
700a8206: 9803         	ldr	r0, [sp, #0xc]
700a8208: b006         	add	sp, #0x18
700a820a: bd80         	pop	{r7, pc}
700a820c: 0000         	movs	r0, r0
700a820e: 0000         	movs	r0, r0

700a8210 <CSL_bcdmaChanOpSetChanPause>:
; {
700a8210: b580         	push	{r7, lr}
700a8212: b086         	sub	sp, #0x18
700a8214: 9005         	str	r0, [sp, #0x14]
700a8216: 9104         	str	r1, [sp, #0x10]
700a8218: 9203         	str	r2, [sp, #0xc]
700a821a: f88d 300b    	strb.w	r3, [sp, #0xb]
700a821e: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a8220: 9001         	str	r0, [sp, #0x4]
;     if( CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)false )
700a8222: 9805         	ldr	r0, [sp, #0x14]
700a8224: 9904         	ldr	r1, [sp, #0x10]
700a8226: 9a03         	ldr	r2, [sp, #0xc]
700a8228: f002 fbf2    	bl	0x700aaa10 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x27e4
700a822c: b920         	cbnz	r0, 0x700a8238 <CSL_bcdmaChanOpSetChanPause+0x28> @ imm = #0x8
700a822e: e7ff         	b	0x700a8230 <CSL_bcdmaChanOpSetChanPause+0x20> @ imm = #-0x2
700a8230: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a8234: 9001         	str	r0, [sp, #0x4]
;     }
700a8236: e03d         	b	0x700a82b4 <CSL_bcdmaChanOpSetChanPause+0xa4> @ imm = #0x7a
;         switch( chanType )
700a8238: 9804         	ldr	r0, [sp, #0x10]
700a823a: 9000         	str	r0, [sp]
700a823c: b140         	cbz	r0, 0x700a8250 <CSL_bcdmaChanOpSetChanPause+0x40> @ imm = #0x10
700a823e: e7ff         	b	0x700a8240 <CSL_bcdmaChanOpSetChanPause+0x30> @ imm = #-0x2
700a8240: 9800         	ldr	r0, [sp]
700a8242: 2801         	cmp	r0, #0x1
700a8244: d013         	beq	0x700a826e <CSL_bcdmaChanOpSetChanPause+0x5e> @ imm = #0x26
700a8246: e7ff         	b	0x700a8248 <CSL_bcdmaChanOpSetChanPause+0x38> @ imm = #-0x2
700a8248: 9800         	ldr	r0, [sp]
700a824a: 2802         	cmp	r0, #0x2
700a824c: d01e         	beq	0x700a828c <CSL_bcdmaChanOpSetChanPause+0x7c> @ imm = #0x3c
700a824e: e02c         	b	0x700a82aa <CSL_bcdmaChanOpSetChanPause+0x9a> @ imm = #0x58
;                 CSL_REG32_FINS( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a8250: 9805         	ldr	r0, [sp, #0x14]
700a8252: 6880         	ldr	r0, [r0, #0x8]
700a8254: 9903         	ldr	r1, [sp, #0xc]
700a8256: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a825a: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a825e: f001 0301    	and	r3, r1, #0x1
700a8262: f04f 5100    	mov.w	r1, #0x20000000
700a8266: 221d         	movs	r2, #0x1d
700a8268: f006 f832    	bl	0x700ae2d0 <CSL_REG32_FINS_RAW> @ imm = #0x6064
;                 break;
700a826c: e021         	b	0x700a82b2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x42
;                 CSL_REG32_FINS( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a826e: 9805         	ldr	r0, [sp, #0x14]
700a8270: 6900         	ldr	r0, [r0, #0x10]
700a8272: 9903         	ldr	r1, [sp, #0xc]
700a8274: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8278: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a827c: f001 0301    	and	r3, r1, #0x1
700a8280: f04f 5100    	mov.w	r1, #0x20000000
700a8284: 221d         	movs	r2, #0x1d
700a8286: f006 f823    	bl	0x700ae2d0 <CSL_REG32_FINS_RAW> @ imm = #0x6046
;                 break;
700a828a: e012         	b	0x700a82b2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x24
;                 CSL_REG32_FINS( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a828c: 9805         	ldr	r0, [sp, #0x14]
700a828e: 6980         	ldr	r0, [r0, #0x18]
700a8290: 9903         	ldr	r1, [sp, #0xc]
700a8292: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8296: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a829a: f001 0301    	and	r3, r1, #0x1
700a829e: f04f 5100    	mov.w	r1, #0x20000000
700a82a2: 221d         	movs	r2, #0x1d
700a82a4: f006 f814    	bl	0x700ae2d0 <CSL_REG32_FINS_RAW> @ imm = #0x6028
;                 break;
700a82a8: e003         	b	0x700a82b2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x6
700a82aa: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a82ae: 9001         	str	r0, [sp, #0x4]
;                 break;
700a82b0: e7ff         	b	0x700a82b2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #-0x2
700a82b2: e7ff         	b	0x700a82b4 <CSL_bcdmaChanOpSetChanPause+0xa4> @ imm = #-0x2
;     return retVal;
700a82b4: 9801         	ldr	r0, [sp, #0x4]
700a82b6: b006         	add	sp, #0x18
700a82b8: bd80         	pop	{r7, pc}
700a82ba: 0000         	movs	r0, r0
700a82bc: 0000         	movs	r0, r0
700a82be: 0000         	movs	r0, r0

700a82c0 <CSL_bcdmaChanOpSetChanRT>:
; {
700a82c0: b580         	push	{r7, lr}
700a82c2: b088         	sub	sp, #0x20
700a82c4: 9007         	str	r0, [sp, #0x1c]
700a82c6: 9106         	str	r1, [sp, #0x18]
700a82c8: 9205         	str	r2, [sp, #0x14]
700a82ca: 9304         	str	r3, [sp, #0x10]
700a82cc: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a82ce: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a82d0: 9804         	ldr	r0, [sp, #0x10]
700a82d2: b920         	cbnz	r0, 0x700a82de <CSL_bcdmaChanOpSetChanRT+0x1e> @ imm = #0x8
700a82d4: e7ff         	b	0x700a82d6 <CSL_bcdmaChanOpSetChanRT+0x16> @ imm = #-0x2
700a82d6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a82da: 9003         	str	r0, [sp, #0xc]
;     }
700a82dc: e042         	b	0x700a8364 <CSL_bcdmaChanOpSetChanRT+0xa4> @ imm = #0x84
;         CSL_BcdmaRT *pRT = (CSL_BcdmaRT *)pOpData;
700a82de: 9804         	ldr	r0, [sp, #0x10]
700a82e0: 9001         	str	r0, [sp, #0x4]
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a82e2: 9801         	ldr	r0, [sp, #0x4]
700a82e4: 6803         	ldr	r3, [r0]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a82e6: f8d0 c004    	ldr.w	r12, [r0, #0x4]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_PAUSE,        pRT->pause);
700a82ea: 6881         	ldr	r1, [r0, #0x8]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a82ec: 6902         	ldr	r2, [r0, #0x10]
700a82ee: f04f 4080    	mov.w	r0, #0x40000000
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a82f2: ea00 708c    	and.w	r0, r0, r12, lsl #30
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a82f6: ea40 70c3    	orr.w	r0, r0, r3, lsl #31
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a82fa: f002 0201    	and	r2, r2, #0x1
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a82fe: ea40 7002    	orr.w	r0, r0, r2, lsl #28
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_PAUSE,        pRT->pause);
700a8302: f001 0101    	and	r1, r1, #0x1
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a8306: ea40 7041    	orr.w	r0, r0, r1, lsl #29
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a830a: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a830c: 9806         	ldr	r0, [sp, #0x18]
700a830e: 9000         	str	r0, [sp]
700a8310: b140         	cbz	r0, 0x700a8324 <CSL_bcdmaChanOpSetChanRT+0x64> @ imm = #0x10
700a8312: e7ff         	b	0x700a8314 <CSL_bcdmaChanOpSetChanRT+0x54> @ imm = #-0x2
700a8314: 9800         	ldr	r0, [sp]
700a8316: 2801         	cmp	r0, #0x1
700a8318: d00d         	beq	0x700a8336 <CSL_bcdmaChanOpSetChanRT+0x76> @ imm = #0x1a
700a831a: e7ff         	b	0x700a831c <CSL_bcdmaChanOpSetChanRT+0x5c> @ imm = #-0x2
700a831c: 9800         	ldr	r0, [sp]
700a831e: 2802         	cmp	r0, #0x2
700a8320: d012         	beq	0x700a8348 <CSL_bcdmaChanOpSetChanRT+0x88> @ imm = #0x24
700a8322: e01a         	b	0x700a835a <CSL_bcdmaChanOpSetChanRT+0x9a> @ imm = #0x34
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, val );
700a8324: 9807         	ldr	r0, [sp, #0x1c]
700a8326: 6880         	ldr	r0, [r0, #0x8]
700a8328: 9905         	ldr	r1, [sp, #0x14]
700a832a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a832e: 9902         	ldr	r1, [sp, #0x8]
700a8330: f7f3 ffae    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xc0a4
;                 break;
700a8334: e015         	b	0x700a8362 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x2a
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, val );
700a8336: 9807         	ldr	r0, [sp, #0x1c]
700a8338: 6900         	ldr	r0, [r0, #0x10]
700a833a: 9905         	ldr	r1, [sp, #0x14]
700a833c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8340: 9902         	ldr	r1, [sp, #0x8]
700a8342: f7f3 ffa5    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xc0b6
;                 break;
700a8346: e00c         	b	0x700a8362 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x18
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, val );
700a8348: 9807         	ldr	r0, [sp, #0x1c]
700a834a: 6980         	ldr	r0, [r0, #0x18]
700a834c: 9905         	ldr	r1, [sp, #0x14]
700a834e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8352: 9902         	ldr	r1, [sp, #0x8]
700a8354: f7f3 ff9c    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xc0c8
;                 break;
700a8358: e003         	b	0x700a8362 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x6
700a835a: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a835e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a8360: e7ff         	b	0x700a8362 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #-0x2
700a8362: e7ff         	b	0x700a8364 <CSL_bcdmaChanOpSetChanRT+0xa4> @ imm = #-0x2
;     return retVal;
700a8364: 9803         	ldr	r0, [sp, #0xc]
700a8366: b008         	add	sp, #0x20
700a8368: bd80         	pop	{r7, pc}
700a836a: 0000         	movs	r0, r0
700a836c: 0000         	movs	r0, r0
700a836e: 0000         	movs	r0, r0

700a8370 <Sciclient_rmIrInpRomMapped>:
; {
700a8370: b082         	sub	sp, #0x8
700a8372: 9001         	str	r0, [sp, #0x4]
700a8374: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a8378: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a837a: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a837e: 9801         	ldr	r0, [sp, #0x4]
700a8380: 6900         	ldr	r0, [r0, #0x10]
700a8382: 2800         	cmp	r0, #0x0
700a8384: d042         	beq	0x700a840c <Sciclient_rmIrInpRomMapped+0x9c> @ imm = #0x84
700a8386: e7ff         	b	0x700a8388 <Sciclient_rmIrInpRomMapped+0x18> @ imm = #-0x2
700a8388: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a838a: f88d 0000    	strb.w	r0, [sp]
700a838e: e7ff         	b	0x700a8390 <Sciclient_rmIrInpRomMapped+0x20> @ imm = #-0x2
700a8390: f89d 0000    	ldrb.w	r0, [sp]
700a8394: 9901         	ldr	r1, [sp, #0x4]
700a8396: 7d09         	ldrb	r1, [r1, #0x14]
700a8398: 4288         	cmp	r0, r1
700a839a: da36         	bge	0x700a840a <Sciclient_rmIrInpRomMapped+0x9a> @ imm = #0x6c
700a839c: e7ff         	b	0x700a839e <Sciclient_rmIrInpRomMapped+0x2e> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a839e: 9801         	ldr	r0, [sp, #0x4]
700a83a0: 6900         	ldr	r0, [r0, #0x10]
700a83a2: f89d 1000    	ldrb.w	r1, [sp]
700a83a6: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a83aa: 7980         	ldrb	r0, [r0, #0x6]
700a83ac: 07c0         	lsls	r0, r0, #0x1f
700a83ae: bb28         	cbnz	r0, 0x700a83fc <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x4a
700a83b0: e7ff         	b	0x700a83b2 <Sciclient_rmIrInpRomMapped+0x42> @ imm = #-0x2
;                 (inp >= inst->rom_usage[i].inp_start) &&
700a83b2: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a83b6: 9901         	ldr	r1, [sp, #0x4]
700a83b8: 6909         	ldr	r1, [r1, #0x10]
700a83ba: f89d 2000    	ldrb.w	r2, [sp]
700a83be: f831 1032    	ldrh.w	r1, [r1, r2, lsl #3]
700a83c2: 4288         	cmp	r0, r1
700a83c4: db1a         	blt	0x700a83fc <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x34
700a83c6: e7ff         	b	0x700a83c8 <Sciclient_rmIrInpRomMapped+0x58> @ imm = #-0x2
;                 (inp < (inst->rom_usage[i].inp_start +
700a83c8: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a83cc: 9901         	ldr	r1, [sp, #0x4]
700a83ce: 6909         	ldr	r1, [r1, #0x10]
700a83d0: f89d 3000    	ldrb.w	r3, [sp]
700a83d4: eb01 02c3    	add.w	r2, r1, r3, lsl #3
700a83d8: f831 1033    	ldrh.w	r1, [r1, r3, lsl #3]
;                         inst->rom_usage[i].length))) {
700a83dc: 8892         	ldrh	r2, [r2, #0x4]
;                 (inp < (inst->rom_usage[i].inp_start +
700a83de: 4411         	add	r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a83e0: 4288         	cmp	r0, r1
700a83e2: da0b         	bge	0x700a83fc <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x16
700a83e4: e7ff         	b	0x700a83e6 <Sciclient_rmIrInpRomMapped+0x76> @ imm = #-0x2
700a83e6: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a83e8: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a83ec: 9901         	ldr	r1, [sp, #0x4]
700a83ee: 6909         	ldr	r1, [r1, #0x10]
700a83f0: f89d 2000    	ldrb.w	r2, [sp]
700a83f4: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a83f8: 7188         	strb	r0, [r1, #0x6]
;                 break;
700a83fa: e006         	b	0x700a840a <Sciclient_rmIrInpRomMapped+0x9a> @ imm = #0xc
;         }
700a83fc: e7ff         	b	0x700a83fe <Sciclient_rmIrInpRomMapped+0x8e> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a83fe: f89d 0000    	ldrb.w	r0, [sp]
700a8402: 3001         	adds	r0, #0x1
700a8404: f88d 0000    	strb.w	r0, [sp]
700a8408: e7c2         	b	0x700a8390 <Sciclient_rmIrInpRomMapped+0x20> @ imm = #-0x7c
;     }
700a840a: e7ff         	b	0x700a840c <Sciclient_rmIrInpRomMapped+0x9c> @ imm = #-0x2
;     return rom_mapped;
700a840c: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a8410: f000 0001    	and	r0, r0, #0x1
700a8414: b002         	add	sp, #0x8
700a8416: 4770         	bx	lr
		...

700a8420 <Sciclient_rmIrOutpRomMapped>:
; {
700a8420: b082         	sub	sp, #0x8
700a8422: 9001         	str	r0, [sp, #0x4]
700a8424: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a8428: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a842a: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a842e: 9801         	ldr	r0, [sp, #0x4]
700a8430: 6900         	ldr	r0, [r0, #0x10]
700a8432: 2800         	cmp	r0, #0x0
700a8434: d042         	beq	0x700a84bc <Sciclient_rmIrOutpRomMapped+0x9c> @ imm = #0x84
700a8436: e7ff         	b	0x700a8438 <Sciclient_rmIrOutpRomMapped+0x18> @ imm = #-0x2
700a8438: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a843a: f88d 0000    	strb.w	r0, [sp]
700a843e: e7ff         	b	0x700a8440 <Sciclient_rmIrOutpRomMapped+0x20> @ imm = #-0x2
700a8440: f89d 0000    	ldrb.w	r0, [sp]
700a8444: 9901         	ldr	r1, [sp, #0x4]
700a8446: 7d09         	ldrb	r1, [r1, #0x14]
700a8448: 4288         	cmp	r0, r1
700a844a: da36         	bge	0x700a84ba <Sciclient_rmIrOutpRomMapped+0x9a> @ imm = #0x6c
700a844c: e7ff         	b	0x700a844e <Sciclient_rmIrOutpRomMapped+0x2e> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a844e: 9801         	ldr	r0, [sp, #0x4]
700a8450: 6900         	ldr	r0, [r0, #0x10]
700a8452: f89d 1000    	ldrb.w	r1, [sp]
700a8456: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a845a: 7980         	ldrb	r0, [r0, #0x6]
700a845c: 07c0         	lsls	r0, r0, #0x1f
700a845e: bb28         	cbnz	r0, 0x700a84ac <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x4a
700a8460: e7ff         	b	0x700a8462 <Sciclient_rmIrOutpRomMapped+0x42> @ imm = #-0x2
;                 (outp >= inst->rom_usage[i].outp_start) &&
700a8462: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a8466: 9901         	ldr	r1, [sp, #0x4]
700a8468: 6909         	ldr	r1, [r1, #0x10]
700a846a: f89d 2000    	ldrb.w	r2, [sp]
700a846e: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a8472: 8849         	ldrh	r1, [r1, #0x2]
700a8474: 4288         	cmp	r0, r1
700a8476: db19         	blt	0x700a84ac <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x32
700a8478: e7ff         	b	0x700a847a <Sciclient_rmIrOutpRomMapped+0x5a> @ imm = #-0x2
;                 (outp < (inst->rom_usage[i].outp_start +
700a847a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a847e: 9901         	ldr	r1, [sp, #0x4]
700a8480: 6909         	ldr	r1, [r1, #0x10]
700a8482: f89d 2000    	ldrb.w	r2, [sp]
700a8486: eb01 02c2    	add.w	r2, r1, r2, lsl #3
700a848a: 8851         	ldrh	r1, [r2, #0x2]
;                         inst->rom_usage[i].length))) {
700a848c: 8892         	ldrh	r2, [r2, #0x4]
;                 (outp < (inst->rom_usage[i].outp_start +
700a848e: 4411         	add	r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a8490: 4288         	cmp	r0, r1
700a8492: da0b         	bge	0x700a84ac <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x16
700a8494: e7ff         	b	0x700a8496 <Sciclient_rmIrOutpRomMapped+0x76> @ imm = #-0x2
700a8496: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a8498: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a849c: 9901         	ldr	r1, [sp, #0x4]
700a849e: 6909         	ldr	r1, [r1, #0x10]
700a84a0: f89d 2000    	ldrb.w	r2, [sp]
700a84a4: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a84a8: 7188         	strb	r0, [r1, #0x6]
;                 break;
700a84aa: e006         	b	0x700a84ba <Sciclient_rmIrOutpRomMapped+0x9a> @ imm = #0xc
;         }
700a84ac: e7ff         	b	0x700a84ae <Sciclient_rmIrOutpRomMapped+0x8e> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a84ae: f89d 0000    	ldrb.w	r0, [sp]
700a84b2: 3001         	adds	r0, #0x1
700a84b4: f88d 0000    	strb.w	r0, [sp]
700a84b8: e7c2         	b	0x700a8440 <Sciclient_rmIrOutpRomMapped+0x20> @ imm = #-0x7c
;     }
700a84ba: e7ff         	b	0x700a84bc <Sciclient_rmIrOutpRomMapped+0x9c> @ imm = #-0x2
;     return rom_mapped;
700a84bc: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a84c0: f000 0001    	and	r0, r0, #0x1
700a84c4: b002         	add	sp, #0x8
700a84c6: 4770         	bx	lr
		...

700a84d0 <CycleCounterP_init>:
; {
700a84d0: b580         	push	{r7, lr}
700a84d2: b082         	sub	sp, #0x8
700a84d4: 9101         	str	r1, [sp, #0x4]
700a84d6: 9000         	str	r0, [sp]
;     gCounterFreqHz = cpuFreqHz/PmuP_SETUP_COUNTER_DIVIDER_VAL;
700a84d8: 9800         	ldr	r0, [sp]
700a84da: 9a01         	ldr	r2, [sp, #0x4]
700a84dc: f642 11c0    	movw	r1, #0x29c0
700a84e0: f2c7 010b    	movt	r1, #0x700b
700a84e4: 604a         	str	r2, [r1, #0x4]
700a84e6: 6008         	str	r0, [r1]
;     CycleCounterP_reset();
700a84e8: f000 f802    	bl	0x700a84f0 <CycleCounterP_reset> @ imm = #0x4
; }
700a84ec: b002         	add	sp, #0x8
700a84ee: bd80         	pop	{r7, pc}

700a84f0 <CycleCounterP_reset>:
; {
700a84f0: b580         	push	{r7, lr}
700a84f2: b082         	sub	sp, #0x8
700a84f4: 2000         	movs	r0, #0x0
;     uint32_t setupFlags = 0;
700a84f6: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_CYCLE_COUNTER_RESET;
700a84f8: 9801         	ldr	r0, [sp, #0x4]
700a84fa: f040 0004    	orr	r0, r0, #0x4
700a84fe: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_EVENT_COUNTER_RESET;
700a8500: 9801         	ldr	r0, [sp, #0x4]
700a8502: f040 0002    	orr	r0, r0, #0x2
700a8506: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_ENABLE_ALL_COUNTERS;
700a8508: 9801         	ldr	r0, [sp, #0x4]
700a850a: f040 0001    	orr	r0, r0, #0x1
700a850e: 9001         	str	r0, [sp, #0x4]
700a8510: f04f 30ff    	mov.w	r0, #0xffffffff
;     PmuP_disableCounters(PmuP_COUNTER_MASK_ALL_COUNTERS); /* disable all counters */
700a8514: 9000         	str	r0, [sp]
700a8516: f006 e9e0    	blx	0x700ae8d8 <PmuP_disableCounters> @ imm = #0x63c0
700a851a: 9800         	ldr	r0, [sp]
;     PmuP_clearOverflowStatus(PmuP_COUNTER_MASK_ALL_COUNTERS); /* clear all overflow flags */
700a851c: f006 e9e4    	blx	0x700ae8e8 <PmuP_clearOverflowStatus> @ imm = #0x63c8
;     PmuP_setup(setupFlags); /* setup counters */
700a8520: 9801         	ldr	r0, [sp, #0x4]
700a8522: f006 e9d2    	blx	0x700ae8c8 <PmuP_setup> @ imm = #0x63a4
700a8526: f04f 4000    	mov.w	r0, #0x80000000
;     PmuP_enableCounters(PmuP_COUNTER_MASK_CYCLE_COUNTER); /* enable cycle counter only */
700a852a: f006 e9d2    	blx	0x700ae8d0 <PmuP_enableCounters> @ imm = #0x63a4
; }
700a852e: b002         	add	sp, #0x8
700a8530: bd80         	pop	{r7, pc}
700a8532: bf00         	nop
700a8534: bf00         	nop
700a8536: bf00         	nop
700a8538: bf00         	nop
700a853a: bf00         	nop
700a853c: bf00         	nop
700a853e: bf00         	nop

700a8540 <CycleCounterP_nsToTicks>:
; {
700a8540: b580         	push	{r7, lr}
700a8542: b082         	sub	sp, #0x8
700a8544: 9101         	str	r1, [sp, #0x4]
700a8546: 9000         	str	r0, [sp]
;     return (((uint64_t)nanosecs*gCounterFreqHz)/PmuP_SEC_TO_NANOSEC);
700a8548: 9b00         	ldr	r3, [sp]
700a854a: 9901         	ldr	r1, [sp, #0x4]
700a854c: f642 10c0    	movw	r0, #0x29c0
700a8550: f2c7 000b    	movt	r0, #0x700b
700a8554: 6802         	ldr	r2, [r0]
700a8556: f8d0 c004    	ldr.w	r12, [r0, #0x4]
700a855a: fba3 0e02    	umull	r0, lr, r3, r2
700a855e: fb03 e30c    	mla	r3, r3, r12, lr
700a8562: fb01 3102    	mla	r1, r1, r2, r3
700a8566: f64c 2200    	movw	r2, #0xca00
700a856a: f6c3 329a    	movt	r2, #0x3b9a
700a856e: 2300         	movs	r3, #0x0
700a8570: f006 ee38    	blx	0x700af1e4 <__aeabi_uldivmod> @ imm = #0x6c70
700a8574: b002         	add	sp, #0x8
700a8576: bd80         	pop	{r7, pc}
		...

700a8580 <Sciclient_pmGetModuleClkNumParent>:
; {
700a8580: b580         	push	{r7, lr}
700a8582: b096         	sub	sp, #0x58
700a8584: 9015         	str	r0, [sp, #0x54]
700a8586: 9114         	str	r1, [sp, #0x50]
700a8588: 9213         	str	r2, [sp, #0x4c]
700a858a: 9312         	str	r3, [sp, #0x48]
700a858c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a858e: 9011         	str	r0, [sp, #0x44]
;     struct tisci_msg_get_num_clock_parents_req request = {{0}};
700a8590: f88d 0040    	strb.w	r0, [sp, #0x40]
700a8594: 900f         	str	r0, [sp, #0x3c]
700a8596: 900e         	str	r0, [sp, #0x38]
700a8598: 900d         	str	r0, [sp, #0x34]
700a859a: 900c         	str	r0, [sp, #0x30]
;     request.device = (uint32_t) moduleId;
700a859c: 9815         	ldr	r0, [sp, #0x54]
700a859e: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a85a0: 9814         	ldr	r0, [sp, #0x50]
700a85a2: 28ff         	cmp	r0, #0xff
700a85a4: d307         	blo	0x700a85b6 <Sciclient_pmGetModuleClkNumParent+0x36> @ imm = #0xe
700a85a6: e7ff         	b	0x700a85a8 <Sciclient_pmGetModuleClkNumParent+0x28> @ imm = #-0x2
;         request.clk32 = clockId;
700a85a8: 9814         	ldr	r0, [sp, #0x50]
700a85aa: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a85ae: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a85b0: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a85b4: e003         	b	0x700a85be <Sciclient_pmGetModuleClkNumParent+0x3e> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a85b6: 9814         	ldr	r0, [sp, #0x50]
700a85b8: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a85bc: e7ff         	b	0x700a85be <Sciclient_pmGetModuleClkNumParent+0x3e> @ imm = #-0x2
700a85be: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_num_clock_parents_resp response = {{0}};
700a85c0: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a85c4: 900a         	str	r0, [sp, #0x28]
700a85c6: 9009         	str	r0, [sp, #0x24]
700a85c8: 9008         	str	r0, [sp, #0x20]
700a85ca: f44f 7182    	mov.w	r1, #0x104
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_NUM_CLOCK_PARENTS;
700a85ce: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a85d2: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a85d4: 9104         	str	r1, [sp, #0x10]
700a85d6: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a85d8: 9105         	str	r1, [sp, #0x14]
700a85da: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a85dc: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a85de: 9912         	ldr	r1, [sp, #0x48]
700a85e0: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a85e2: 9000         	str	r0, [sp]
700a85e4: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a85e6: 9001         	str	r0, [sp, #0x4]
700a85e8: 200d         	movs	r0, #0xd
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a85ea: 9002         	str	r0, [sp, #0x8]
700a85ec: a803         	add	r0, sp, #0xc
700a85ee: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a85f0: f7f4 fffe    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xb004
700a85f4: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a85f6: 9811         	ldr	r0, [sp, #0x44]
700a85f8: b930         	cbnz	r0, 0x700a8608 <Sciclient_pmGetModuleClkNumParent+0x88> @ imm = #0xc
700a85fa: e7ff         	b	0x700a85fc <Sciclient_pmGetModuleClkNumParent+0x7c> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a85fc: 9800         	ldr	r0, [sp]
700a85fe: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a8602: 2802         	cmp	r0, #0x2
700a8604: d004         	beq	0x700a8610 <Sciclient_pmGetModuleClkNumParent+0x90> @ imm = #0x8
700a8606: e7ff         	b	0x700a8608 <Sciclient_pmGetModuleClkNumParent+0x88> @ imm = #-0x2
700a8608: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a860c: 9011         	str	r0, [sp, #0x44]
;     }
700a860e: e7ff         	b	0x700a8610 <Sciclient_pmGetModuleClkNumParent+0x90> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a8610: 9811         	ldr	r0, [sp, #0x44]
700a8612: b928         	cbnz	r0, 0x700a8620 <Sciclient_pmGetModuleClkNumParent+0xa0> @ imm = #0xa
700a8614: e7ff         	b	0x700a8616 <Sciclient_pmGetModuleClkNumParent+0x96> @ imm = #-0x2
;         *numParent = (uint32_t) response.num_parents;
700a8616: f89d 0028    	ldrb.w	r0, [sp, #0x28]
700a861a: 9913         	ldr	r1, [sp, #0x4c]
700a861c: 6008         	str	r0, [r1]
;     }
700a861e: e7ff         	b	0x700a8620 <Sciclient_pmGetModuleClkNumParent+0xa0> @ imm = #-0x2
;     return retVal;
700a8620: 9811         	ldr	r0, [sp, #0x44]
700a8622: b016         	add	sp, #0x58
700a8624: bd80         	pop	{r7, pc}
		...
700a862e: 0000         	movs	r0, r0

700a8630 <xTaskPriorityDisinherit>:
; BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder) {
700a8630: b580         	push	{r7, lr}
700a8632: b084         	sub	sp, #0x10
700a8634: 9003         	str	r0, [sp, #0xc]
;   TCB_t *const pxTCB = pxMutexHolder;
700a8636: 9803         	ldr	r0, [sp, #0xc]
700a8638: 9002         	str	r0, [sp, #0x8]
700a863a: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700a863c: 9001         	str	r0, [sp, #0x4]
;   if (pxMutexHolder != NULL) {
700a863e: 9803         	ldr	r0, [sp, #0xc]
700a8640: 2800         	cmp	r0, #0x0
700a8642: d044         	beq	0x700a86ce <xTaskPriorityDisinherit+0x9e> @ imm = #0x88
700a8644: e7ff         	b	0x700a8646 <xTaskPriorityDisinherit+0x16> @ imm = #-0x2
;     (pxTCB->uxMutexesHeld)--;
700a8646: 9902         	ldr	r1, [sp, #0x8]
700a8648: 6e48         	ldr	r0, [r1, #0x64]
700a864a: 3801         	subs	r0, #0x1
700a864c: 6648         	str	r0, [r1, #0x64]
;     if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
700a864e: 9902         	ldr	r1, [sp, #0x8]
700a8650: 6ac8         	ldr	r0, [r1, #0x2c]
700a8652: 6e09         	ldr	r1, [r1, #0x60]
700a8654: 4288         	cmp	r0, r1
700a8656: d038         	beq	0x700a86ca <xTaskPriorityDisinherit+0x9a> @ imm = #0x70
700a8658: e7ff         	b	0x700a865a <xTaskPriorityDisinherit+0x2a> @ imm = #-0x2
;       if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
700a865a: 9802         	ldr	r0, [sp, #0x8]
700a865c: 6e40         	ldr	r0, [r0, #0x64]
700a865e: bb90         	cbnz	r0, 0x700a86c6 <xTaskPriorityDisinherit+0x96> @ imm = #0x64
700a8660: e7ff         	b	0x700a8662 <xTaskPriorityDisinherit+0x32> @ imm = #-0x2
;         if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a8662: 9802         	ldr	r0, [sp, #0x8]
700a8664: 3004         	adds	r0, #0x4
700a8666: f005 f85b    	bl	0x700ad720 <uxListRemove> @ imm = #0x50b6
700a866a: b908         	cbnz	r0, 0x700a8670 <xTaskPriorityDisinherit+0x40> @ imm = #0x2
700a866c: e7ff         	b	0x700a866e <xTaskPriorityDisinherit+0x3e> @ imm = #-0x2
;         } else {
700a866e: e000         	b	0x700a8672 <xTaskPriorityDisinherit+0x42> @ imm = #0x0
700a8670: e7ff         	b	0x700a8672 <xTaskPriorityDisinherit+0x42> @ imm = #-0x2
;         pxTCB->uxPriority = pxTCB->uxBasePriority;
700a8672: 9902         	ldr	r1, [sp, #0x8]
700a8674: 6e08         	ldr	r0, [r1, #0x60]
700a8676: 62c8         	str	r0, [r1, #0x2c]
;         listSET_LIST_ITEM_VALUE(
700a8678: 9902         	ldr	r1, [sp, #0x8]
700a867a: 6ac8         	ldr	r0, [r1, #0x2c]
700a867c: f1c0 0020    	rsb.w	r0, r0, #0x20
700a8680: 6188         	str	r0, [r1, #0x18]
;         prvAddTaskToReadyList(pxTCB);
700a8682: 9802         	ldr	r0, [sp, #0x8]
700a8684: 6ac0         	ldr	r0, [r0, #0x2c]
700a8686: f642 213c    	movw	r1, #0x2a3c
700a868a: f2c7 010b    	movt	r1, #0x700b
700a868e: 6809         	ldr	r1, [r1]
700a8690: 4288         	cmp	r0, r1
700a8692: d908         	bls	0x700a86a6 <xTaskPriorityDisinherit+0x76> @ imm = #0x10
700a8694: e7ff         	b	0x700a8696 <xTaskPriorityDisinherit+0x66> @ imm = #-0x2
700a8696: 9802         	ldr	r0, [sp, #0x8]
700a8698: 6ac0         	ldr	r0, [r0, #0x2c]
700a869a: f642 213c    	movw	r1, #0x2a3c
700a869e: f2c7 010b    	movt	r1, #0x700b
700a86a2: 6008         	str	r0, [r1]
700a86a4: e7ff         	b	0x700a86a6 <xTaskPriorityDisinherit+0x76> @ imm = #-0x2
700a86a6: 9902         	ldr	r1, [sp, #0x8]
700a86a8: 6ac8         	ldr	r0, [r1, #0x2c]
700a86aa: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a86ae: f244 40f8    	movw	r0, #0x44f8
700a86b2: f2c7 0008    	movt	r0, #0x7008
700a86b6: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a86ba: 3104         	adds	r1, #0x4
700a86bc: f005 fde8    	bl	0x700ae290 <vListInsertEnd> @ imm = #0x5bd0
700a86c0: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700a86c2: 9001         	str	r0, [sp, #0x4]
;       } else {
700a86c4: e000         	b	0x700a86c8 <xTaskPriorityDisinherit+0x98> @ imm = #0x0
700a86c6: e7ff         	b	0x700a86c8 <xTaskPriorityDisinherit+0x98> @ imm = #-0x2
;     } else {
700a86c8: e000         	b	0x700a86cc <xTaskPriorityDisinherit+0x9c> @ imm = #0x0
700a86ca: e7ff         	b	0x700a86cc <xTaskPriorityDisinherit+0x9c> @ imm = #-0x2
;   } else {
700a86cc: e000         	b	0x700a86d0 <xTaskPriorityDisinherit+0xa0> @ imm = #0x0
700a86ce: e7ff         	b	0x700a86d0 <xTaskPriorityDisinherit+0xa0> @ imm = #-0x2
;   return xReturn;
700a86d0: 9801         	ldr	r0, [sp, #0x4]
700a86d2: b004         	add	sp, #0x10
700a86d4: bd80         	pop	{r7, pc}
		...
700a86de: 0000         	movs	r0, r0

700a86e0 <CSL_intaggrIsIntrPending>:
; {
700a86e0: b580         	push	{r7, lr}
700a86e2: b088         	sub	sp, #0x20
700a86e4: 9007         	str	r0, [sp, #0x1c]
700a86e6: 9106         	str	r1, [sp, #0x18]
700a86e8: f88d 2017    	strb.w	r2, [sp, #0x17]
700a86ec: 2000         	movs	r0, #0x0
;     bool     retVal = (bool)false;
700a86ee: f88d 0016    	strb.w	r0, [sp, #0x16]
;     if( CSL_intaggrIsValidStatusBitNum(pCfg, statusBitNum) )
700a86f2: 9807         	ldr	r0, [sp, #0x1c]
700a86f4: 9906         	ldr	r1, [sp, #0x18]
700a86f6: f005 fc2b    	bl	0x700adf50 <CSL_intaggrIsValidStatusBitNum> @ imm = #0x5856
700a86fa: b3e8         	cbz	r0, 0x700a8778 <CSL_intaggrIsIntrPending+0x98> @ imm = #0x7a
700a86fc: e7ff         	b	0x700a86fe <CSL_intaggrIsIntrPending+0x1e> @ imm = #-0x2
;         regNum = statusBitNum >> 6U;
700a86fe: 9806         	ldr	r0, [sp, #0x18]
700a8700: 0980         	lsrs	r0, r0, #0x6
700a8702: 9001         	str	r0, [sp, #0x4]
;         bitNum = statusBitNum & (uint32_t)0x003FU;
700a8704: 9806         	ldr	r0, [sp, #0x18]
700a8706: f000 003f    	and	r0, r0, #0x3f
700a870a: 9000         	str	r0, [sp]
;         if( bMaskedStatus == (bool)true )
700a870c: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a8710: 07c0         	lsls	r0, r0, #0x1f
700a8712: b158         	cbz	r0, 0x700a872c <CSL_intaggrIsIntrPending+0x4c> @ imm = #0x16
700a8714: e7ff         	b	0x700a8716 <CSL_intaggrIsIntrPending+0x36> @ imm = #-0x2
;             regVal = CSL_REG64_RD( &pCfg->pIntrRegs->VINT[regNum].STATUSM );
700a8716: 9807         	ldr	r0, [sp, #0x1c]
700a8718: 6880         	ldr	r0, [r0, #0x8]
700a871a: 9901         	ldr	r1, [sp, #0x4]
700a871c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8720: 3020         	adds	r0, #0x20
700a8722: f007 fa5d    	bl	0x700afbe0 <CSL_REG64_RD_RAW> @ imm = #0x74ba
700a8726: 9103         	str	r1, [sp, #0xc]
700a8728: 9002         	str	r0, [sp, #0x8]
;         }
700a872a: e00a         	b	0x700a8742 <CSL_intaggrIsIntrPending+0x62> @ imm = #0x14
;             regVal = CSL_REG64_RD( &pCfg->pIntrRegs->VINT[regNum].STATUS_SET );
700a872c: 9807         	ldr	r0, [sp, #0x1c]
700a872e: 6880         	ldr	r0, [r0, #0x8]
700a8730: 9901         	ldr	r1, [sp, #0x4]
700a8732: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8736: 3010         	adds	r0, #0x10
700a8738: f007 fa52    	bl	0x700afbe0 <CSL_REG64_RD_RAW> @ imm = #0x74a4
700a873c: 9103         	str	r1, [sp, #0xc]
700a873e: 9002         	str	r0, [sp, #0x8]
700a8740: e7ff         	b	0x700a8742 <CSL_intaggrIsIntrPending+0x62> @ imm = #-0x2
;         if( (regVal & (((uint64_t)1U) << bitNum)) == 0U )
700a8742: 9802         	ldr	r0, [sp, #0x8]
700a8744: 9903         	ldr	r1, [sp, #0xc]
700a8746: 9a00         	ldr	r2, [sp]
700a8748: 40d0         	lsrs	r0, r2
700a874a: f1c2 0320    	rsb.w	r3, r2, #0x20
700a874e: fa01 f303    	lsl.w	r3, r1, r3
700a8752: 4318         	orrs	r0, r3
700a8754: 3a20         	subs	r2, #0x20
700a8756: 40d1         	lsrs	r1, r2
700a8758: 2a00         	cmp	r2, #0x0
700a875a: bf58         	it	pl
700a875c: 4608         	movpl	r0, r1
700a875e: ea4f 70c0    	lsl.w	r0, r0, #0x1f
700a8762: b920         	cbnz	r0, 0x700a876e <CSL_intaggrIsIntrPending+0x8e> @ imm = #0x8
700a8764: e7ff         	b	0x700a8766 <CSL_intaggrIsIntrPending+0x86> @ imm = #-0x2
700a8766: 2000         	movs	r0, #0x0
;             retVal = (bool)false; /* Interrupt is not pending */
700a8768: f88d 0016    	strb.w	r0, [sp, #0x16]
;         }
700a876c: e003         	b	0x700a8776 <CSL_intaggrIsIntrPending+0x96> @ imm = #0x6
700a876e: 2001         	movs	r0, #0x1
;             retVal = (bool)true;  /* Interrupt is pending */
700a8770: f88d 0016    	strb.w	r0, [sp, #0x16]
700a8774: e7ff         	b	0x700a8776 <CSL_intaggrIsIntrPending+0x96> @ imm = #-0x2
;     }
700a8776: e7ff         	b	0x700a8778 <CSL_intaggrIsIntrPending+0x98> @ imm = #-0x2
;     return retVal;
700a8778: f89d 0016    	ldrb.w	r0, [sp, #0x16]
700a877c: f000 0001    	and	r0, r0, #0x1
700a8780: b008         	add	sp, #0x20
700a8782: bd80         	pop	{r7, pc}
		...

700a8790 <Sciclient_rmIrqCheckLoop>:
; {
700a8790: b580         	push	{r7, lr}
700a8792: b088         	sub	sp, #0x20
700a8794: 9007         	str	r0, [sp, #0x1c]
700a8796: 2000         	movs	r0, #0x0
;     bool loop = false;
700a8798: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a879c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a87a0: e7ff         	b	0x700a87a2 <Sciclient_rmIrqCheckLoop+0x12> @ imm = #-0x2
700a87a2: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a87a6: 9002         	str	r0, [sp, #0x8]
700a87a8: f007 fa72    	bl	0x700afc90 <Sciclient_rmPsGetPsp> @ imm = #0x74e4
700a87ac: 4601         	mov	r1, r0
700a87ae: 9802         	ldr	r0, [sp, #0x8]
700a87b0: 4288         	cmp	r0, r1
700a87b2: da39         	bge	0x700a8828 <Sciclient_rmIrqCheckLoop+0x98> @ imm = #0x72
700a87b4: e7ff         	b	0x700a87b6 <Sciclient_rmIrqCheckLoop+0x26> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a87b6: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a87ba: f006 fe39    	bl	0x700af430 <Sciclient_rmPsGetIrqNode> @ imm = #0x6c72
700a87be: 9004         	str	r0, [sp, #0x10]
;         for (j = i + 1u; j < Sciclient_rmPsGetPsp(); j++) {
700a87c0: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a87c4: 3001         	adds	r0, #0x1
700a87c6: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a87ca: e7ff         	b	0x700a87cc <Sciclient_rmIrqCheckLoop+0x3c> @ imm = #-0x2
700a87cc: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a87d0: 9001         	str	r0, [sp, #0x4]
700a87d2: f007 fa5d    	bl	0x700afc90 <Sciclient_rmPsGetPsp> @ imm = #0x74ba
700a87d6: 4601         	mov	r1, r0
700a87d8: 9801         	ldr	r0, [sp, #0x4]
700a87da: 4288         	cmp	r0, r1
700a87dc: da17         	bge	0x700a880e <Sciclient_rmIrqCheckLoop+0x7e> @ imm = #0x2e
700a87de: e7ff         	b	0x700a87e0 <Sciclient_rmIrqCheckLoop+0x50> @ imm = #-0x2
;             future_n = Sciclient_rmPsGetIrqNode(j);
700a87e0: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a87e4: f006 fe24    	bl	0x700af430 <Sciclient_rmPsGetIrqNode> @ imm = #0x6c48
700a87e8: 9003         	str	r0, [sp, #0xc]
;             if (cur_n->id == future_n->id) {
700a87ea: 9804         	ldr	r0, [sp, #0x10]
700a87ec: 8800         	ldrh	r0, [r0]
700a87ee: 9903         	ldr	r1, [sp, #0xc]
700a87f0: 8809         	ldrh	r1, [r1]
700a87f2: 4288         	cmp	r0, r1
700a87f4: d104         	bne	0x700a8800 <Sciclient_rmIrqCheckLoop+0x70> @ imm = #0x8
700a87f6: e7ff         	b	0x700a87f8 <Sciclient_rmIrqCheckLoop+0x68> @ imm = #-0x2
700a87f8: 2001         	movs	r0, #0x1
;                 loop = true;
700a87fa: f88d 001b    	strb.w	r0, [sp, #0x1b]
;                 break;
700a87fe: e006         	b	0x700a880e <Sciclient_rmIrqCheckLoop+0x7e> @ imm = #0xc
;         }
700a8800: e7ff         	b	0x700a8802 <Sciclient_rmIrqCheckLoop+0x72> @ imm = #-0x2
;         for (j = i + 1u; j < Sciclient_rmPsGetPsp(); j++) {
700a8802: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a8806: 3001         	adds	r0, #0x1
700a8808: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a880c: e7de         	b	0x700a87cc <Sciclient_rmIrqCheckLoop+0x3c> @ imm = #-0x44
;         if (loop == true) {
700a880e: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a8812: 07c0         	lsls	r0, r0, #0x1f
700a8814: b108         	cbz	r0, 0x700a881a <Sciclient_rmIrqCheckLoop+0x8a> @ imm = #0x2
700a8816: e7ff         	b	0x700a8818 <Sciclient_rmIrqCheckLoop+0x88> @ imm = #-0x2
;             break;
700a8818: e006         	b	0x700a8828 <Sciclient_rmIrqCheckLoop+0x98> @ imm = #0xc
;     }
700a881a: e7ff         	b	0x700a881c <Sciclient_rmIrqCheckLoop+0x8c> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a881c: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a8820: 3001         	adds	r0, #0x1
700a8822: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a8826: e7bc         	b	0x700a87a2 <Sciclient_rmIrqCheckLoop+0x12> @ imm = #-0x88
;     return loop;
700a8828: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a882c: f000 0001    	and	r0, r0, #0x1
700a8830: b008         	add	sp, #0x20
700a8832: bd80         	pop	{r7, pc}
		...

700a8840 <UART_IsBaseAddrValid>:
; {
700a8840: b082         	sub	sp, #0x8
700a8842: 9001         	str	r0, [sp, #0x4]
700a8844: f06f 0002    	mvn	r0, #0x2
;     int32_t status = (int32_t)-3;
700a8848: 9000         	str	r0, [sp]
;     if ((baseAddr == CSL_UART0_BASE) ||
700a884a: 9801         	ldr	r0, [sp, #0x4]
700a884c: f1b0 7f20    	cmp.w	r0, #0x2800000
700a8850: d042         	beq	0x700a88d8 <UART_IsBaseAddrValid+0x98> @ imm = #0x84
700a8852: e7ff         	b	0x700a8854 <UART_IsBaseAddrValid+0x14> @ imm = #-0x2
;         (baseAddr == CSL_UART1_BASE) ||
700a8854: 9801         	ldr	r0, [sp, #0x4]
700a8856: 2100         	movs	r1, #0x0
700a8858: f2c0 2181    	movt	r1, #0x281
700a885c: 4288         	cmp	r0, r1
700a885e: d03b         	beq	0x700a88d8 <UART_IsBaseAddrValid+0x98> @ imm = #0x76
700a8860: e7ff         	b	0x700a8862 <UART_IsBaseAddrValid+0x22> @ imm = #-0x2
;         (baseAddr == CSL_UART2_BASE) ||
700a8862: 9801         	ldr	r0, [sp, #0x4]
700a8864: 2100         	movs	r1, #0x0
700a8866: f2c0 2182    	movt	r1, #0x282
700a886a: 4288         	cmp	r0, r1
700a886c: d034         	beq	0x700a88d8 <UART_IsBaseAddrValid+0x98> @ imm = #0x68
700a886e: e7ff         	b	0x700a8870 <UART_IsBaseAddrValid+0x30> @ imm = #-0x2
;         (baseAddr == CSL_UART3_BASE) ||
700a8870: 9801         	ldr	r0, [sp, #0x4]
700a8872: 2100         	movs	r1, #0x0
700a8874: f2c0 2183    	movt	r1, #0x283
700a8878: 4288         	cmp	r0, r1
700a887a: d02d         	beq	0x700a88d8 <UART_IsBaseAddrValid+0x98> @ imm = #0x5a
700a887c: e7ff         	b	0x700a887e <UART_IsBaseAddrValid+0x3e> @ imm = #-0x2
;         (baseAddr == CSL_UART4_BASE) ||
700a887e: 9801         	ldr	r0, [sp, #0x4]
700a8880: f1b0 7f21    	cmp.w	r0, #0x2840000
700a8884: d028         	beq	0x700a88d8 <UART_IsBaseAddrValid+0x98> @ imm = #0x50
700a8886: e7ff         	b	0x700a8888 <UART_IsBaseAddrValid+0x48> @ imm = #-0x2
;         (baseAddr == CSL_UART5_BASE) ||
700a8888: 9801         	ldr	r0, [sp, #0x4]
700a888a: 2100         	movs	r1, #0x0
700a888c: f2c0 2185    	movt	r1, #0x285
700a8890: 4288         	cmp	r0, r1
700a8892: d021         	beq	0x700a88d8 <UART_IsBaseAddrValid+0x98> @ imm = #0x42
700a8894: e7ff         	b	0x700a8896 <UART_IsBaseAddrValid+0x56> @ imm = #-0x2
;         (baseAddr == CSL_UART6_BASE) ||
700a8896: 9801         	ldr	r0, [sp, #0x4]
700a8898: 2100         	movs	r1, #0x0
700a889a: f2c0 2186    	movt	r1, #0x286
700a889e: 4288         	cmp	r0, r1
700a88a0: d01a         	beq	0x700a88d8 <UART_IsBaseAddrValid+0x98> @ imm = #0x34
700a88a2: e7ff         	b	0x700a88a4 <UART_IsBaseAddrValid+0x64> @ imm = #-0x2
;         (baseAddr == CSL_MCU_UART0_BASE) ||
700a88a4: 9801         	ldr	r0, [sp, #0x4]
700a88a6: f1b0 6f94    	cmp.w	r0, #0x4a00000
700a88aa: d015         	beq	0x700a88d8 <UART_IsBaseAddrValid+0x98> @ imm = #0x2a
700a88ac: e7ff         	b	0x700a88ae <UART_IsBaseAddrValid+0x6e> @ imm = #-0x2
;         (baseAddr == CSL_MCU_UART1_BASE) ||
700a88ae: 9801         	ldr	r0, [sp, #0x4]
700a88b0: 2100         	movs	r1, #0x0
700a88b2: f2c0 41a1    	movt	r1, #0x4a1
700a88b6: 4288         	cmp	r0, r1
700a88b8: d00e         	beq	0x700a88d8 <UART_IsBaseAddrValid+0x98> @ imm = #0x1c
700a88ba: e7ff         	b	0x700a88bc <UART_IsBaseAddrValid+0x7c> @ imm = #-0x2
;         (baseAddr == MCU_UART0_BASE_AFTER_ADDR_TRANSLATE) ||
700a88bc: 9801         	ldr	r0, [sp, #0x4]
700a88be: 2100         	movs	r1, #0x0
700a88c0: f2c8 41a0    	movt	r1, #0x84a0
700a88c4: 4288         	cmp	r0, r1
700a88c6: d007         	beq	0x700a88d8 <UART_IsBaseAddrValid+0x98> @ imm = #0xe
700a88c8: e7ff         	b	0x700a88ca <UART_IsBaseAddrValid+0x8a> @ imm = #-0x2
;         (baseAddr == MCU_UART1_BASE_AFTER_ADDR_TRANSLATE))
700a88ca: 9801         	ldr	r0, [sp, #0x4]
700a88cc: 2100         	movs	r1, #0x0
700a88ce: f2c8 41a1    	movt	r1, #0x84a1
;     if ((baseAddr == CSL_UART0_BASE) ||
700a88d2: 4288         	cmp	r0, r1
700a88d4: d103         	bne	0x700a88de <UART_IsBaseAddrValid+0x9e> @ imm = #0x6
700a88d6: e7ff         	b	0x700a88d8 <UART_IsBaseAddrValid+0x98> @ imm = #-0x2
700a88d8: 2000         	movs	r0, #0x0
;         status = 0;
700a88da: 9000         	str	r0, [sp]
;     }
700a88dc: e7ff         	b	0x700a88de <UART_IsBaseAddrValid+0x9e> @ imm = #-0x2
;     return status;
700a88de: 9800         	ldr	r0, [sp]
700a88e0: b002         	add	sp, #0x8
700a88e2: 4770         	bx	lr

700a88e4 <split>:
700a88e4: e92d48f0     	push	{r4, r5, r6, r7, r11, lr}
700a88e8: e1a04000     	mov	r4, r0
700a88ec: e5900000     	ldr	r0, [r0]
700a88f0: e1a05001     	mov	r5, r1
700a88f4: e3c01001     	bic	r1, r0, #1
700a88f8: e0411005     	sub	r1, r1, r5
700a88fc: e3510010     	cmp	r1, #16
700a8900: 3a00001b     	blo	0x700a8974 <split+0x90> @ imm = #0x6c
700a8904: e2410008     	sub	r0, r1, #8
700a8908: e0846005     	add	r6, r4, r5
700a890c: e59f106c     	ldr	r1, [pc, #0x6c]         @ 0x700a8980 <split+0x9c>
700a8910: e59f206c     	ldr	r2, [pc, #0x6c]         @ 0x700a8984 <split+0xa0>
700a8914: e5a60008     	str	r0, [r6, #0x8]!
700a8918: e3c00001     	bic	r0, r0, #1
700a891c: e3520007     	cmp	r2, #7
700a8920: e0860000     	add	r0, r6, r0
700a8924: e2807008     	add	r7, r0, #8
700a8928: e0820001     	add	r0, r2, r1
700a892c: 82401008     	subhi	r1, r0, #8
700a8930: e1570001     	cmp	r7, r1
700a8934: 2a00000b     	bhs	0x700a8968 <split+0x84> @ imm = #0x2c
700a8938: e5d70000     	ldrb	r0, [r7]
700a893c: e3100001     	tst	r0, #1
700a8940: 1a000008     	bne	0x700a8968 <split+0x84> @ imm = #0x20
700a8944: e1a00007     	mov	r0, r7
700a8948: eb00172d     	bl	0x700ae604 <free_list_remove> @ imm = #0x5cb4
700a894c: e5960000     	ldr	r0, [r6]
700a8950: e5971000     	ldr	r1, [r7]
700a8954: e2800008     	add	r0, r0, #8
700a8958: e3c11001     	bic	r1, r1, #1
700a895c: e3c00001     	bic	r0, r0, #1
700a8960: e0800001     	add	r0, r0, r1
700a8964: e5860000     	str	r0, [r6]
700a8968: e1a00006     	mov	r0, r6
700a896c: eb0014e7     	bl	0x700add10 <free_list_insert> @ imm = #0x539c
700a8970: e1a00005     	mov	r0, r5
700a8974: e3800001     	orr	r0, r0, #1
700a8978: e5840000     	str	r0, [r4]
700a897c: e8bd88f0     	pop	{r4, r5, r6, r7, r11, pc}
700a8980: 00 53 08 70  	.word	0x70085300
700a8984: 00 00 01 00  	.word	0x00010000
700a8988: 00 00 00 00  	.word	0x00000000
700a898c: 00 00 00 00  	.word	0x00000000

700a8990 <vTaskResume>:
; void vTaskResume(TaskHandle_t xTaskToResume) {
700a8990: b580         	push	{r7, lr}
700a8992: b082         	sub	sp, #0x8
700a8994: 9001         	str	r0, [sp, #0x4]
;   TCB_t *const pxTCB = xTaskToResume;
700a8996: 9801         	ldr	r0, [sp, #0x4]
700a8998: 9000         	str	r0, [sp]
;   if ((pxTCB != pxCurrentTCB) && (pxTCB != NULL)) {
700a899a: 9800         	ldr	r0, [sp]
700a899c: f642 210c    	movw	r1, #0x2a0c
700a89a0: f2c7 010b    	movt	r1, #0x700b
700a89a4: 6809         	ldr	r1, [r1]
700a89a6: 4288         	cmp	r0, r1
700a89a8: d041         	beq	0x700a8a2e <vTaskResume+0x9e> @ imm = #0x82
700a89aa: e7ff         	b	0x700a89ac <vTaskResume+0x1c> @ imm = #-0x2
700a89ac: 9800         	ldr	r0, [sp]
700a89ae: 2800         	cmp	r0, #0x0
700a89b0: d03d         	beq	0x700a8a2e <vTaskResume+0x9e> @ imm = #0x7a
700a89b2: e7ff         	b	0x700a89b4 <vTaskResume+0x24> @ imm = #-0x2
;     taskENTER_CRITICAL();
700a89b4: f005 fee4    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0x5dc8
;       if (prvTaskIsTaskSuspended(pxTCB) != pdFALSE) {
700a89b8: 9800         	ldr	r0, [sp]
700a89ba: f004 fc89    	bl	0x700ad2d0 <prvTaskIsTaskSuspended> @ imm = #0x4912
700a89be: b390         	cbz	r0, 0x700a8a26 <vTaskResume+0x96> @ imm = #0x64
700a89c0: e7ff         	b	0x700a89c2 <vTaskResume+0x32> @ imm = #-0x2
;         (void)uxListRemove(&(pxTCB->xStateListItem));
700a89c2: 9800         	ldr	r0, [sp]
700a89c4: 3004         	adds	r0, #0x4
700a89c6: f004 feab    	bl	0x700ad720 <uxListRemove> @ imm = #0x4d56
;         prvAddTaskToReadyList(pxTCB);
700a89ca: 9800         	ldr	r0, [sp]
700a89cc: 6ac0         	ldr	r0, [r0, #0x2c]
700a89ce: f642 213c    	movw	r1, #0x2a3c
700a89d2: f2c7 010b    	movt	r1, #0x700b
700a89d6: 6809         	ldr	r1, [r1]
700a89d8: 4288         	cmp	r0, r1
700a89da: d908         	bls	0x700a89ee <vTaskResume+0x5e> @ imm = #0x10
700a89dc: e7ff         	b	0x700a89de <vTaskResume+0x4e> @ imm = #-0x2
700a89de: 9800         	ldr	r0, [sp]
700a89e0: 6ac0         	ldr	r0, [r0, #0x2c]
700a89e2: f642 213c    	movw	r1, #0x2a3c
700a89e6: f2c7 010b    	movt	r1, #0x700b
700a89ea: 6008         	str	r0, [r1]
700a89ec: e7ff         	b	0x700a89ee <vTaskResume+0x5e> @ imm = #-0x2
700a89ee: 9900         	ldr	r1, [sp]
700a89f0: 6ac8         	ldr	r0, [r1, #0x2c]
700a89f2: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a89f6: f244 40f8    	movw	r0, #0x44f8
700a89fa: f2c7 0008    	movt	r0, #0x7008
700a89fe: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a8a02: 3104         	adds	r1, #0x4
700a8a04: f005 fc44    	bl	0x700ae290 <vListInsertEnd> @ imm = #0x5888
;         if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a8a08: 9800         	ldr	r0, [sp]
700a8a0a: 6ac0         	ldr	r0, [r0, #0x2c]
700a8a0c: f642 210c    	movw	r1, #0x2a0c
700a8a10: f2c7 010b    	movt	r1, #0x700b
700a8a14: 6809         	ldr	r1, [r1]
700a8a16: 6ac9         	ldr	r1, [r1, #0x2c]
700a8a18: 4288         	cmp	r0, r1
700a8a1a: d302         	blo	0x700a8a22 <vTaskResume+0x92> @ imm = #0x4
700a8a1c: e7ff         	b	0x700a8a1e <vTaskResume+0x8e> @ imm = #-0x2
;           taskYIELD_IF_USING_PREEMPTION();
700a8a1e: df00         	svc	#0x0
;         } else {
700a8a20: e000         	b	0x700a8a24 <vTaskResume+0x94> @ imm = #0x0
700a8a22: e7ff         	b	0x700a8a24 <vTaskResume+0x94> @ imm = #-0x2
;       } else {
700a8a24: e000         	b	0x700a8a28 <vTaskResume+0x98> @ imm = #0x0
700a8a26: e7ff         	b	0x700a8a28 <vTaskResume+0x98> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700a8a28: f004 ff6a    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0x4ed4
;   } else {
700a8a2c: e000         	b	0x700a8a30 <vTaskResume+0xa0> @ imm = #0x0
700a8a2e: e7ff         	b	0x700a8a30 <vTaskResume+0xa0> @ imm = #-0x2
; }
700a8a30: b002         	add	sp, #0x8
700a8a32: bd80         	pop	{r7, pc}
		...

700a8a40 <xQueueGenericSendFromISR>:
; {
700a8a40: b580         	push	{r7, lr}
700a8a42: b08a         	sub	sp, #0x28
700a8a44: 9009         	str	r0, [sp, #0x24]
700a8a46: 9108         	str	r1, [sp, #0x20]
700a8a48: 9207         	str	r2, [sp, #0x1c]
700a8a4a: 9306         	str	r3, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a8a4c: 9809         	ldr	r0, [sp, #0x24]
700a8a4e: 9003         	str	r0, [sp, #0xc]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a8a50: f007 ef86    	blx	0x700b0960 <HwiP_disable> @ imm = #0x7f0c
700a8a54: 9004         	str	r0, [sp, #0x10]
;         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
700a8a56: 9803         	ldr	r0, [sp, #0xc]
700a8a58: 6b80         	ldr	r0, [r0, #0x38]
700a8a5a: 9903         	ldr	r1, [sp, #0xc]
700a8a5c: 6bc9         	ldr	r1, [r1, #0x3c]
700a8a5e: 4288         	cmp	r0, r1
700a8a60: d304         	blo	0x700a8a6c <xQueueGenericSendFromISR+0x2c> @ imm = #0x8
700a8a62: e7ff         	b	0x700a8a64 <xQueueGenericSendFromISR+0x24> @ imm = #-0x2
700a8a64: 9806         	ldr	r0, [sp, #0x18]
700a8a66: 2802         	cmp	r0, #0x2
700a8a68: d133         	bne	0x700a8ad2 <xQueueGenericSendFromISR+0x92> @ imm = #0x66
700a8a6a: e7ff         	b	0x700a8a6c <xQueueGenericSendFromISR+0x2c> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
700a8a6c: 9803         	ldr	r0, [sp, #0xc]
700a8a6e: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a8a72: f88d 000b    	strb.w	r0, [sp, #0xb]
;             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
700a8a76: 9803         	ldr	r0, [sp, #0xc]
700a8a78: 6b80         	ldr	r0, [r0, #0x38]
700a8a7a: 9001         	str	r0, [sp, #0x4]
;             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
700a8a7c: 9803         	ldr	r0, [sp, #0xc]
700a8a7e: 9908         	ldr	r1, [sp, #0x20]
700a8a80: 9a06         	ldr	r2, [sp, #0x18]
700a8a82: f7fe f8c5    	bl	0x700a6c10 <prvCopyDataToQueue> @ imm = #-0x1e76
;             if( cTxLock == queueUNLOCKED )
700a8a86: f99d 000b    	ldrsb.w	r0, [sp, #0xb]
700a8a8a: 3001         	adds	r0, #0x1
700a8a8c: b9b8         	cbnz	r0, 0x700a8abe <xQueueGenericSendFromISR+0x7e> @ imm = #0x2e
700a8a8e: e7ff         	b	0x700a8a90 <xQueueGenericSendFromISR+0x50> @ imm = #-0x2
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a8a90: 9803         	ldr	r0, [sp, #0xc]
700a8a92: 6a40         	ldr	r0, [r0, #0x24]
700a8a94: b188         	cbz	r0, 0x700a8aba <xQueueGenericSendFromISR+0x7a> @ imm = #0x22
700a8a96: e7ff         	b	0x700a8a98 <xQueueGenericSendFromISR+0x58> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a8a98: 9803         	ldr	r0, [sp, #0xc]
700a8a9a: 3024         	adds	r0, #0x24
700a8a9c: f7ff f838    	bl	0x700a7b10 <xTaskRemoveFromEventList> @ imm = #-0xf90
700a8aa0: b148         	cbz	r0, 0x700a8ab6 <xQueueGenericSendFromISR+0x76> @ imm = #0x12
700a8aa2: e7ff         	b	0x700a8aa4 <xQueueGenericSendFromISR+0x64> @ imm = #-0x2
;                                 if( pxHigherPriorityTaskWoken != NULL )
700a8aa4: 9807         	ldr	r0, [sp, #0x1c]
700a8aa6: b120         	cbz	r0, 0x700a8ab2 <xQueueGenericSendFromISR+0x72> @ imm = #0x8
700a8aa8: e7ff         	b	0x700a8aaa <xQueueGenericSendFromISR+0x6a> @ imm = #-0x2
;                                     *pxHigherPriorityTaskWoken = pdTRUE;
700a8aaa: 9907         	ldr	r1, [sp, #0x1c]
700a8aac: 2001         	movs	r0, #0x1
700a8aae: 6008         	str	r0, [r1]
;                                 }
700a8ab0: e000         	b	0x700a8ab4 <xQueueGenericSendFromISR+0x74> @ imm = #0x0
700a8ab2: e7ff         	b	0x700a8ab4 <xQueueGenericSendFromISR+0x74> @ imm = #-0x2
;                             }
700a8ab4: e000         	b	0x700a8ab8 <xQueueGenericSendFromISR+0x78> @ imm = #0x0
700a8ab6: e7ff         	b	0x700a8ab8 <xQueueGenericSendFromISR+0x78> @ imm = #-0x2
;                         }
700a8ab8: e000         	b	0x700a8abc <xQueueGenericSendFromISR+0x7c> @ imm = #0x0
700a8aba: e7ff         	b	0x700a8abc <xQueueGenericSendFromISR+0x7c> @ imm = #-0x2
;             }
700a8abc: e006         	b	0x700a8acc <xQueueGenericSendFromISR+0x8c> @ imm = #0xc
;                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
700a8abe: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a8ac2: 3001         	adds	r0, #0x1
700a8ac4: 9903         	ldr	r1, [sp, #0xc]
700a8ac6: f881 0045    	strb.w	r0, [r1, #0x45]
700a8aca: e7ff         	b	0x700a8acc <xQueueGenericSendFromISR+0x8c> @ imm = #-0x2
700a8acc: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a8ace: 9005         	str	r0, [sp, #0x14]
;         }
700a8ad0: e002         	b	0x700a8ad8 <xQueueGenericSendFromISR+0x98> @ imm = #0x4
700a8ad2: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
700a8ad4: 9005         	str	r0, [sp, #0x14]
700a8ad6: e7ff         	b	0x700a8ad8 <xQueueGenericSendFromISR+0x98> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a8ad8: 9804         	ldr	r0, [sp, #0x10]
700a8ada: f007 ef62    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x7ec4
;     return xReturn;
700a8ade: 9805         	ldr	r0, [sp, #0x14]
700a8ae0: b00a         	add	sp, #0x28
700a8ae2: bd80         	pop	{r7, pc}
		...

700a8af0 <prvCheckForValidListAndQueue>:
;     {
700a8af0: b580         	push	{r7, lr}
700a8af2: b084         	sub	sp, #0x10
;         taskENTER_CRITICAL();
700a8af4: f005 fe44    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0x5c88
;             if( xTimerQueue == NULL )
700a8af8: f642 2058    	movw	r0, #0x2a58
700a8afc: f2c7 000b    	movt	r0, #0x700b
700a8b00: 6800         	ldr	r0, [r0]
700a8b02: 2800         	cmp	r0, #0x0
700a8b04: d140         	bne	0x700a8b88 <prvCheckForValidListAndQueue+0x98> @ imm = #0x80
700a8b06: e7ff         	b	0x700a8b08 <prvCheckForValidListAndQueue+0x18> @ imm = #-0x2
;                 vListInitialise( &xActiveTimerList1 );
700a8b08: f245 2010    	movw	r0, #0x5210
700a8b0c: f2c7 0008    	movt	r0, #0x7008
700a8b10: 9002         	str	r0, [sp, #0x8]
700a8b12: f005 ffc5    	bl	0x700aeaa0 <vListInitialise> @ imm = #0x5f8a
;                 vListInitialise( &xActiveTimerList2 );
700a8b16: f245 2024    	movw	r0, #0x5224
700a8b1a: f2c7 0008    	movt	r0, #0x7008
700a8b1e: 9003         	str	r0, [sp, #0xc]
700a8b20: f005 ffbe    	bl	0x700aeaa0 <vListInitialise> @ imm = #0x5f7c
700a8b24: 9902         	ldr	r1, [sp, #0x8]
700a8b26: 9803         	ldr	r0, [sp, #0xc]
;                 pxCurrentTimerList = &xActiveTimerList1;
700a8b28: f245 229c    	movw	r2, #0x529c
700a8b2c: f2c7 0208    	movt	r2, #0x7008
700a8b30: 6011         	str	r1, [r2]
;                 pxOverflowTimerList = &xActiveTimerList2;
700a8b32: f245 21a8    	movw	r1, #0x52a8
700a8b36: f2c7 0108    	movt	r1, #0x7008
700a8b3a: 6008         	str	r0, [r1]
;                         xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
700a8b3c: 4669         	mov	r1, sp
700a8b3e: 2000         	movs	r0, #0x0
700a8b40: 6008         	str	r0, [r1]
700a8b42: f644 3278    	movw	r2, #0x4b78
700a8b46: f2c7 0208    	movt	r2, #0x7008
700a8b4a: f241 0308    	movw	r3, #0x1008
700a8b4e: f2c7 0308    	movt	r3, #0x7008
700a8b52: 2110         	movs	r1, #0x10
700a8b54: 4608         	mov	r0, r1
700a8b56: f004 fd4b    	bl	0x700ad5f0 <xQueueGenericCreateStatic> @ imm = #0x4a96
700a8b5a: 4601         	mov	r1, r0
700a8b5c: f642 2058    	movw	r0, #0x2a58
700a8b60: f2c7 000b    	movt	r0, #0x700b
700a8b64: 6001         	str	r1, [r0]
;                         if( xTimerQueue != NULL )
700a8b66: 6800         	ldr	r0, [r0]
700a8b68: b160         	cbz	r0, 0x700a8b84 <prvCheckForValidListAndQueue+0x94> @ imm = #0x18
700a8b6a: e7ff         	b	0x700a8b6c <prvCheckForValidListAndQueue+0x7c> @ imm = #-0x2
;                             vQueueAddToRegistry( xTimerQueue, "TmrQ" );
700a8b6c: f642 2058    	movw	r0, #0x2a58
700a8b70: f2c7 000b    	movt	r0, #0x700b
700a8b74: 6800         	ldr	r0, [r0]
700a8b76: f242 6126    	movw	r1, #0x2626
700a8b7a: f2c7 010b    	movt	r1, #0x700b
700a8b7e: f004 faa7    	bl	0x700ad0d0 <vQueueAddToRegistry> @ imm = #0x454e
;                         }
700a8b82: e000         	b	0x700a8b86 <prvCheckForValidListAndQueue+0x96> @ imm = #0x0
700a8b84: e7ff         	b	0x700a8b86 <prvCheckForValidListAndQueue+0x96> @ imm = #-0x2
;             }
700a8b86: e000         	b	0x700a8b8a <prvCheckForValidListAndQueue+0x9a> @ imm = #0x0
700a8b88: e7ff         	b	0x700a8b8a <prvCheckForValidListAndQueue+0x9a> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a8b8a: f004 feb9    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0x4d72
;     }
700a8b8e: b004         	add	sp, #0x10
700a8b90: bd80         	pop	{r7, pc}
		...
700a8b9e: 0000         	movs	r0, r0

700a8ba0 <Udma_rmAllocEvent>:
; {
700a8ba0: b580         	push	{r7, lr}
700a8ba2: b088         	sub	sp, #0x20
700a8ba4: 9007         	str	r0, [sp, #0x1c]
700a8ba6: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            globalEvent = UDMA_EVENT_INVALID;
700a8baa: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a8bac: 9807         	ldr	r0, [sp, #0x1c]
700a8bae: f500 70ea    	add.w	r0, r0, #0x1d4
700a8bb2: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a8bb4: 9807         	ldr	r0, [sp, #0x1c]
700a8bb6: f500 609f    	add.w	r0, r0, #0x4f8
700a8bba: f04f 31ff    	mov.w	r1, #0xffffffff
700a8bbe: f001 fe0f    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x1c1e
700a8bc2: 2000         	movs	r0, #0x0
;     for(i = 0U; i < rmInitPrms->numGlobalEvent; i++)
700a8bc4: 9005         	str	r0, [sp, #0x14]
700a8bc6: e7ff         	b	0x700a8bc8 <Udma_rmAllocEvent+0x28> @ imm = #-0x2
700a8bc8: 9805         	ldr	r0, [sp, #0x14]
700a8bca: 9901         	ldr	r1, [sp, #0x4]
700a8bcc: f8d1 10dc    	ldr.w	r1, [r1, #0xdc]
700a8bd0: 4288         	cmp	r0, r1
700a8bd2: d22d         	bhs	0x700a8c30 <Udma_rmAllocEvent+0x90> @ imm = #0x5a
700a8bd4: e7ff         	b	0x700a8bd6 <Udma_rmAllocEvent+0x36> @ imm = #-0x2
;         offset = i >> 5U;
700a8bd6: 9805         	ldr	r0, [sp, #0x14]
700a8bd8: 0940         	lsrs	r0, r0, #0x5
700a8bda: 9004         	str	r0, [sp, #0x10]
;         bitPos = i - (offset << 5U);
700a8bdc: 9805         	ldr	r0, [sp, #0x14]
700a8bde: 9904         	ldr	r1, [sp, #0x10]
700a8be0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a8be4: 9003         	str	r0, [sp, #0xc]
;         bitMask = (uint32_t) 1U << bitPos;
700a8be6: 9903         	ldr	r1, [sp, #0xc]
700a8be8: 2001         	movs	r0, #0x1
700a8bea: 4088         	lsls	r0, r1
700a8bec: 9002         	str	r0, [sp, #0x8]
;         if((drvHandle->globalEventFlag[offset] & bitMask) == bitMask)
700a8bee: 9807         	ldr	r0, [sp, #0x1c]
700a8bf0: 9904         	ldr	r1, [sp, #0x10]
700a8bf2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a8bf6: f8d0 0424    	ldr.w	r0, [r0, #0x424]
700a8bfa: 9902         	ldr	r1, [sp, #0x8]
700a8bfc: 4008         	ands	r0, r1
700a8bfe: 4288         	cmp	r0, r1
700a8c00: d111         	bne	0x700a8c26 <Udma_rmAllocEvent+0x86> @ imm = #0x22
700a8c02: e7ff         	b	0x700a8c04 <Udma_rmAllocEvent+0x64> @ imm = #-0x2
;             drvHandle->globalEventFlag[offset] &= ~bitMask;
700a8c04: 9a02         	ldr	r2, [sp, #0x8]
700a8c06: 9807         	ldr	r0, [sp, #0x1c]
700a8c08: 9904         	ldr	r1, [sp, #0x10]
700a8c0a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a8c0e: f8d1 0424    	ldr.w	r0, [r1, #0x424]
700a8c12: 4390         	bics	r0, r2
700a8c14: f8c1 0424    	str.w	r0, [r1, #0x424]
;             globalEvent = i + rmInitPrms->startGlobalEvent;  /* Add start offset */
700a8c18: 9805         	ldr	r0, [sp, #0x14]
700a8c1a: 9901         	ldr	r1, [sp, #0x4]
700a8c1c: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a8c20: 4408         	add	r0, r1
700a8c22: 9006         	str	r0, [sp, #0x18]
;             break;
700a8c24: e004         	b	0x700a8c30 <Udma_rmAllocEvent+0x90> @ imm = #0x8
;     }
700a8c26: e7ff         	b	0x700a8c28 <Udma_rmAllocEvent+0x88> @ imm = #-0x2
;     for(i = 0U; i < rmInitPrms->numGlobalEvent; i++)
700a8c28: 9805         	ldr	r0, [sp, #0x14]
700a8c2a: 3001         	adds	r0, #0x1
700a8c2c: 9005         	str	r0, [sp, #0x14]
700a8c2e: e7cb         	b	0x700a8bc8 <Udma_rmAllocEvent+0x28> @ imm = #-0x6a
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a8c30: 9807         	ldr	r0, [sp, #0x1c]
700a8c32: f500 609f    	add.w	r0, r0, #0x4f8
700a8c36: f003 f963    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x32c6
;     return (globalEvent);
700a8c3a: 9806         	ldr	r0, [sp, #0x18]
700a8c3c: b008         	add	sp, #0x20
700a8c3e: bd80         	pop	{r7, pc}

700a8c40 <Udma_rmAllocVintr>:
; {
700a8c40: b580         	push	{r7, lr}
700a8c42: b088         	sub	sp, #0x20
700a8c44: 9007         	str	r0, [sp, #0x1c]
700a8c46: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            vintrNum = UDMA_EVENT_INVALID;
700a8c4a: 9002         	str	r0, [sp, #0x8]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a8c4c: 9807         	ldr	r0, [sp, #0x1c]
700a8c4e: f500 70ea    	add.w	r0, r0, #0x1d4
700a8c52: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a8c54: 9807         	ldr	r0, [sp, #0x1c]
700a8c56: f500 609f    	add.w	r0, r0, #0x4f8
700a8c5a: f04f 31ff    	mov.w	r1, #0xffffffff
700a8c5e: f001 fdbf    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x1b7e
700a8c62: 2000         	movs	r0, #0x0
;     for(i = 0U; i < rmInitPrms->numVintr; i++)
700a8c64: 9006         	str	r0, [sp, #0x18]
700a8c66: e7ff         	b	0x700a8c68 <Udma_rmAllocVintr+0x28> @ imm = #-0x2
700a8c68: 9806         	ldr	r0, [sp, #0x18]
700a8c6a: 9901         	ldr	r1, [sp, #0x4]
700a8c6c: f8d1 10e4    	ldr.w	r1, [r1, #0xe4]
700a8c70: 4288         	cmp	r0, r1
700a8c72: d22d         	bhs	0x700a8cd0 <Udma_rmAllocVintr+0x90> @ imm = #0x5a
700a8c74: e7ff         	b	0x700a8c76 <Udma_rmAllocVintr+0x36> @ imm = #-0x2
;         offset = i >> 5U;
700a8c76: 9806         	ldr	r0, [sp, #0x18]
700a8c78: 0940         	lsrs	r0, r0, #0x5
700a8c7a: 9005         	str	r0, [sp, #0x14]
;         bitPos = i - (offset << 5U);
700a8c7c: 9806         	ldr	r0, [sp, #0x18]
700a8c7e: 9905         	ldr	r1, [sp, #0x14]
700a8c80: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a8c84: 9004         	str	r0, [sp, #0x10]
;         bitMask = (uint32_t) 1U << bitPos;
700a8c86: 9904         	ldr	r1, [sp, #0x10]
700a8c88: 2001         	movs	r0, #0x1
700a8c8a: 4088         	lsls	r0, r1
700a8c8c: 9003         	str	r0, [sp, #0xc]
;         if((drvHandle->vintrFlag[offset] & bitMask) == bitMask)
700a8c8e: 9807         	ldr	r0, [sp, #0x1c]
700a8c90: 9905         	ldr	r1, [sp, #0x14]
700a8c92: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a8c96: f8d0 04a4    	ldr.w	r0, [r0, #0x4a4]
700a8c9a: 9903         	ldr	r1, [sp, #0xc]
700a8c9c: 4008         	ands	r0, r1
700a8c9e: 4288         	cmp	r0, r1
700a8ca0: d111         	bne	0x700a8cc6 <Udma_rmAllocVintr+0x86> @ imm = #0x22
700a8ca2: e7ff         	b	0x700a8ca4 <Udma_rmAllocVintr+0x64> @ imm = #-0x2
;             drvHandle->vintrFlag[offset] &= ~bitMask;
700a8ca4: 9a03         	ldr	r2, [sp, #0xc]
700a8ca6: 9807         	ldr	r0, [sp, #0x1c]
700a8ca8: 9905         	ldr	r1, [sp, #0x14]
700a8caa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a8cae: f8d1 04a4    	ldr.w	r0, [r1, #0x4a4]
700a8cb2: 4390         	bics	r0, r2
700a8cb4: f8c1 04a4    	str.w	r0, [r1, #0x4a4]
;             vintrNum = i + rmInitPrms->startVintr;  /* Add start offset */
700a8cb8: 9806         	ldr	r0, [sp, #0x18]
700a8cba: 9901         	ldr	r1, [sp, #0x4]
700a8cbc: f8d1 10e0    	ldr.w	r1, [r1, #0xe0]
700a8cc0: 4408         	add	r0, r1
700a8cc2: 9002         	str	r0, [sp, #0x8]
;             break;
700a8cc4: e004         	b	0x700a8cd0 <Udma_rmAllocVintr+0x90> @ imm = #0x8
;     }
700a8cc6: e7ff         	b	0x700a8cc8 <Udma_rmAllocVintr+0x88> @ imm = #-0x2
;     for(i = 0U; i < rmInitPrms->numVintr; i++)
700a8cc8: 9806         	ldr	r0, [sp, #0x18]
700a8cca: 3001         	adds	r0, #0x1
700a8ccc: 9006         	str	r0, [sp, #0x18]
700a8cce: e7cb         	b	0x700a8c68 <Udma_rmAllocVintr+0x28> @ imm = #-0x6a
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a8cd0: 9807         	ldr	r0, [sp, #0x1c]
700a8cd2: f500 609f    	add.w	r0, r0, #0x4f8
700a8cd6: f003 f913    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x3226
;     return (vintrNum);
700a8cda: 9802         	ldr	r0, [sp, #0x8]
700a8cdc: b008         	add	sp, #0x20
700a8cde: bd80         	pop	{r7, pc}

700a8ce0 <Sciclient_getContext>:
; {
700a8ce0: b084         	sub	sp, #0x10
700a8ce2: 9003         	str	r0, [sp, #0xc]
700a8ce4: 9102         	str	r1, [sp, #0x8]
700a8ce6: 200f         	movs	r0, #0xf
;     uint32_t retVal = SCICLIENT_CONTEXT_MAX_NUM;
700a8ce8: 9001         	str	r0, [sp, #0x4]
;     switch (coreId)
700a8cea: 9802         	ldr	r0, [sp, #0x8]
700a8cec: 9000         	str	r0, [sp]
700a8cee: 2805         	cmp	r0, #0x5
700a8cf0: d841         	bhi	0x700a8d76 <Sciclient_getContext+0x96> @ imm = #0x82
700a8cf2: 9900         	ldr	r1, [sp]
700a8cf4: e8df f001    	tbb	[pc, r1]
700a8cf8: 03 0d 17 21  	.word	0x21170d03
700a8cfc: 2b 35        	.short	0x352b
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8cfe: 9803         	ldr	r0, [sp, #0xc]
700a8d00: b918         	cbnz	r0, 0x700a8d0a <Sciclient_getContext+0x2a> @ imm = #0x6
700a8d02: e7ff         	b	0x700a8d04 <Sciclient_getContext+0x24> @ imm = #-0x2
700a8d04: 200e         	movs	r0, #0xe
;             retVal = SCICLIENT_CONTEXT_M4_SEC_0;
700a8d06: 9001         	str	r0, [sp, #0x4]
;         }
700a8d08: e002         	b	0x700a8d10 <Sciclient_getContext+0x30> @ imm = #0x4
700a8d0a: 2008         	movs	r0, #0x8
;             retVal = SCICLIENT_CONTEXT_M4_NONSEC_0;
700a8d0c: 9001         	str	r0, [sp, #0x4]
700a8d0e: e7ff         	b	0x700a8d10 <Sciclient_getContext+0x30> @ imm = #-0x2
;         break;
700a8d10: e032         	b	0x700a8d78 <Sciclient_getContext+0x98> @ imm = #0x64
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8d12: 9803         	ldr	r0, [sp, #0xc]
700a8d14: b918         	cbnz	r0, 0x700a8d1e <Sciclient_getContext+0x3e> @ imm = #0x6
700a8d16: e7ff         	b	0x700a8d18 <Sciclient_getContext+0x38> @ imm = #-0x2
700a8d18: 2000         	movs	r0, #0x0
;             retVal = SCICLIENT_CONTEXT_R5_0_SEC_0;
700a8d1a: 9001         	str	r0, [sp, #0x4]
;         }
700a8d1c: e002         	b	0x700a8d24 <Sciclient_getContext+0x44> @ imm = #0x4
700a8d1e: 2001         	movs	r0, #0x1
;             retVal = SCICLIENT_CONTEXT_R5_0_NONSEC_0;
700a8d20: 9001         	str	r0, [sp, #0x4]
700a8d22: e7ff         	b	0x700a8d24 <Sciclient_getContext+0x44> @ imm = #-0x2
;         break;
700a8d24: e028         	b	0x700a8d78 <Sciclient_getContext+0x98> @ imm = #0x50
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8d26: 9803         	ldr	r0, [sp, #0xc]
700a8d28: b918         	cbnz	r0, 0x700a8d32 <Sciclient_getContext+0x52> @ imm = #0x6
700a8d2a: e7ff         	b	0x700a8d2c <Sciclient_getContext+0x4c> @ imm = #-0x2
700a8d2c: 2002         	movs	r0, #0x2
;             retVal = SCICLIENT_CONTEXT_R5_0_SEC_1;
700a8d2e: 9001         	str	r0, [sp, #0x4]
;         }
700a8d30: e002         	b	0x700a8d38 <Sciclient_getContext+0x58> @ imm = #0x4
700a8d32: 2003         	movs	r0, #0x3
;             retVal = SCICLIENT_CONTEXT_R5_0_NONSEC_1;
700a8d34: 9001         	str	r0, [sp, #0x4]
700a8d36: e7ff         	b	0x700a8d38 <Sciclient_getContext+0x58> @ imm = #-0x2
;         break;
700a8d38: e01e         	b	0x700a8d78 <Sciclient_getContext+0x98> @ imm = #0x3c
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8d3a: 9803         	ldr	r0, [sp, #0xc]
700a8d3c: b918         	cbnz	r0, 0x700a8d46 <Sciclient_getContext+0x66> @ imm = #0x6
700a8d3e: e7ff         	b	0x700a8d40 <Sciclient_getContext+0x60> @ imm = #-0x2
700a8d40: 2009         	movs	r0, #0x9
;             retVal = SCICLIENT_CONTEXT_R5_1_SEC_0;
700a8d42: 9001         	str	r0, [sp, #0x4]
;         }
700a8d44: e002         	b	0x700a8d4c <Sciclient_getContext+0x6c> @ imm = #0x4
700a8d46: 200a         	movs	r0, #0xa
;             retVal = SCICLIENT_CONTEXT_R5_1_NONSEC_0;
700a8d48: 9001         	str	r0, [sp, #0x4]
700a8d4a: e7ff         	b	0x700a8d4c <Sciclient_getContext+0x6c> @ imm = #-0x2
;         break;
700a8d4c: e014         	b	0x700a8d78 <Sciclient_getContext+0x98> @ imm = #0x28
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8d4e: 9803         	ldr	r0, [sp, #0xc]
700a8d50: b918         	cbnz	r0, 0x700a8d5a <Sciclient_getContext+0x7a> @ imm = #0x6
700a8d52: e7ff         	b	0x700a8d54 <Sciclient_getContext+0x74> @ imm = #-0x2
700a8d54: 200b         	movs	r0, #0xb
;             retVal = SCICLIENT_CONTEXT_R5_1_SEC_1;
700a8d56: 9001         	str	r0, [sp, #0x4]
;         }
700a8d58: e002         	b	0x700a8d60 <Sciclient_getContext+0x80> @ imm = #0x4
700a8d5a: 200c         	movs	r0, #0xc
;             retVal = SCICLIENT_CONTEXT_R5_1_NONSEC_1;
700a8d5c: 9001         	str	r0, [sp, #0x4]
700a8d5e: e7ff         	b	0x700a8d60 <Sciclient_getContext+0x80> @ imm = #-0x2
;         break;
700a8d60: e00a         	b	0x700a8d78 <Sciclient_getContext+0x98> @ imm = #0x14
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8d62: 9803         	ldr	r0, [sp, #0xc]
700a8d64: b918         	cbnz	r0, 0x700a8d6e <Sciclient_getContext+0x8e> @ imm = #0x6
700a8d66: e7ff         	b	0x700a8d68 <Sciclient_getContext+0x88> @ imm = #-0x2
700a8d68: 2004         	movs	r0, #0x4
;             retVal = SCICLIENT_CONTEXT_A53_SEC_0;
700a8d6a: 9001         	str	r0, [sp, #0x4]
;         }
700a8d6c: e002         	b	0x700a8d74 <Sciclient_getContext+0x94> @ imm = #0x4
700a8d6e: 2006         	movs	r0, #0x6
;             retVal = SCICLIENT_CONTEXT_A53_NONSEC_1;
700a8d70: 9001         	str	r0, [sp, #0x4]
700a8d72: e7ff         	b	0x700a8d74 <Sciclient_getContext+0x94> @ imm = #-0x2
;         break;
700a8d74: e000         	b	0x700a8d78 <Sciclient_getContext+0x98> @ imm = #0x0
;         break;
700a8d76: e7ff         	b	0x700a8d78 <Sciclient_getContext+0x98> @ imm = #-0x2
;     return retVal;
700a8d78: 9801         	ldr	r0, [sp, #0x4]
700a8d7a: b004         	add	sp, #0x10
700a8d7c: 4770         	bx	lr
700a8d7e: 0000         	movs	r0, r0

700a8d80 <Pinmux_config>:
; {
700a8d80: b580         	push	{r7, lr}
700a8d82: b086         	sub	sp, #0x18
700a8d84: 9005         	str	r0, [sp, #0x14]
700a8d86: 9104         	str	r1, [sp, #0x10]
700a8d88: 2000         	movs	r0, #0x0
;     uint32_t            isUnlocked = 0;
700a8d8a: 9001         	str	r0, [sp, #0x4]
;     if((NULL != pinmuxCfg) && (pinmuxCfg->offset != PINMUX_END))
700a8d8c: 9805         	ldr	r0, [sp, #0x14]
700a8d8e: 2800         	cmp	r0, #0x0
700a8d90: d042         	beq	0x700a8e18 <Pinmux_config+0x98> @ imm = #0x84
700a8d92: e7ff         	b	0x700a8d94 <Pinmux_config+0x14> @ imm = #-0x2
700a8d94: 9805         	ldr	r0, [sp, #0x14]
700a8d96: f9b0 0000    	ldrsh.w	r0, [r0]
700a8d9a: 3001         	adds	r0, #0x1
700a8d9c: b3e0         	cbz	r0, 0x700a8e18 <Pinmux_config+0x98> @ imm = #0x78
700a8d9e: e7ff         	b	0x700a8da0 <Pinmux_config+0x20> @ imm = #-0x2
;         if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a8da0: 9804         	ldr	r0, [sp, #0x10]
700a8da2: b920         	cbnz	r0, 0x700a8dae <Pinmux_config+0x2e> @ imm = #0x8
700a8da4: e7ff         	b	0x700a8da6 <Pinmux_config+0x26> @ imm = #-0x2
700a8da6: f44f 2074    	mov.w	r0, #0xf4000
;             baseAddr = CSL_PADCFG_CTRL0_CFG0_BASE + PADCFG_PMUX_OFFSET;
700a8daa: 9003         	str	r0, [sp, #0xc]
;         }
700a8dac: e005         	b	0x700a8dba <Pinmux_config+0x3a> @ imm = #0xa
700a8dae: f244 0000    	movw	r0, #0x4000
700a8db2: f2c0 4008    	movt	r0, #0x408
;             baseAddr = CSL_MCU_PADCFG_CTRL0_CFG0_BASE + PADCFG_PMUX_OFFSET;
700a8db6: 9003         	str	r0, [sp, #0xc]
700a8db8: e7ff         	b	0x700a8dba <Pinmux_config+0x3a> @ imm = #-0x2
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(baseAddr);
700a8dba: 9803         	ldr	r0, [sp, #0xc]
700a8dbc: 2100         	movs	r1, #0x0
700a8dbe: f7fc ff2f    	bl	0x700a5c20 <AddrTranslateP_getLocalAddr> @ imm = #-0x31a2
700a8dc2: 9003         	str	r0, [sp, #0xc]
;         if (pinmuxCfg->offset != PINMUX_END)
700a8dc4: 9805         	ldr	r0, [sp, #0x14]
700a8dc6: f9b0 0000    	ldrsh.w	r0, [r0]
700a8dca: 3001         	adds	r0, #0x1
700a8dcc: b130         	cbz	r0, 0x700a8ddc <Pinmux_config+0x5c> @ imm = #0xc
700a8dce: e7ff         	b	0x700a8dd0 <Pinmux_config+0x50> @ imm = #-0x2
700a8dd0: 2001         	movs	r0, #0x1
;             isUnlocked = 1;
700a8dd2: 9001         	str	r0, [sp, #0x4]
;             Pinmux_unlockMMR(domainId);
700a8dd4: 9804         	ldr	r0, [sp, #0x10]
700a8dd6: f7fd fc83    	bl	0x700a66e0 <Pinmux_unlockMMR> @ imm = #-0x26fa
;         }
700a8dda: e7ff         	b	0x700a8ddc <Pinmux_config+0x5c> @ imm = #-0x2
;         while( pinmuxCfg->offset != PINMUX_END )
700a8ddc: e7ff         	b	0x700a8dde <Pinmux_config+0x5e> @ imm = #-0x2
700a8dde: 9805         	ldr	r0, [sp, #0x14]
700a8de0: f9b0 0000    	ldrsh.w	r0, [r0]
700a8de4: 3001         	adds	r0, #0x1
700a8de6: b178         	cbz	r0, 0x700a8e08 <Pinmux_config+0x88> @ imm = #0x1e
700a8de8: e7ff         	b	0x700a8dea <Pinmux_config+0x6a> @ imm = #-0x2
;             regAddr = (volatile uint32_t *)(baseAddr + pinmuxCfg->offset);
700a8dea: 9803         	ldr	r0, [sp, #0xc]
700a8dec: 9905         	ldr	r1, [sp, #0x14]
700a8dee: f9b1 1000    	ldrsh.w	r1, [r1]
700a8df2: 4408         	add	r0, r1
700a8df4: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(regAddr, pinmuxCfg->settings);
700a8df6: 9802         	ldr	r0, [sp, #0x8]
700a8df8: 9905         	ldr	r1, [sp, #0x14]
700a8dfa: 6849         	ldr	r1, [r1, #0x4]
700a8dfc: f006 fe78    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0x6cf0
;             pinmuxCfg++;
700a8e00: 9805         	ldr	r0, [sp, #0x14]
700a8e02: 3008         	adds	r0, #0x8
700a8e04: 9005         	str	r0, [sp, #0x14]
;         while( pinmuxCfg->offset != PINMUX_END )
700a8e06: e7ea         	b	0x700a8dde <Pinmux_config+0x5e> @ imm = #-0x2c
;         if (isUnlocked)
700a8e08: 9801         	ldr	r0, [sp, #0x4]
700a8e0a: b120         	cbz	r0, 0x700a8e16 <Pinmux_config+0x96> @ imm = #0x8
700a8e0c: e7ff         	b	0x700a8e0e <Pinmux_config+0x8e> @ imm = #-0x2
;             Pinmux_lockMMR(domainId);
700a8e0e: 9804         	ldr	r0, [sp, #0x10]
700a8e10: f002 fcbe    	bl	0x700ab790 <Pinmux_lockMMR> @ imm = #0x297c
;         }
700a8e14: e7ff         	b	0x700a8e16 <Pinmux_config+0x96> @ imm = #-0x2
;     }
700a8e16: e7ff         	b	0x700a8e18 <Pinmux_config+0x98> @ imm = #-0x2
;     return;
700a8e18: b006         	add	sp, #0x18
700a8e1a: bd80         	pop	{r7, pc}
700a8e1c: 0000         	movs	r0, r0
700a8e1e: 0000         	movs	r0, r0

700a8e20 <rtos_main_freertos>:
; {
700a8e20: b082         	sub	sp, #0x8
;    System_init();
700a8e22: f005 fdc5    	bl	0x700ae9b0 <System_init> @ imm = #0x5b8a
;    Board_init();
700a8e26: f006 ffd3    	bl	0x700afdd0 <Board_init> @ imm = #0x6fa6
;    Drivers_open();
700a8e2a: f004 f8f1    	bl	0x700ad010 <Drivers_open> @ imm = #0x41e2
;    Board_driversOpen();
700a8e2e: f006 ff87    	bl	0x700afd40 <Board_driversOpen> @ imm = #0x6f0e
;    printf("Initializing FreeRTOS system...\r\n");
700a8e32: f641 4163    	movw	r1, #0x1c63
700a8e36: 2001         	movs	r0, #0x1
700a8e38: f2c7 010b    	movt	r1, #0x700b
700a8e3c: f000 ff70    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xee0
;    BaseType_t status = xTaskCreate(main_task, "MainTask", MAIN_TASK_STACK_SIZE, NULL, MAIN_TASK_PRI, NULL);
700a8e40: f64a 5091    	movw	r0, #0xad91
700a8e44: f242 1178    	movw	r1, #0x2178
700a8e48: f2c7 000a    	movt	r0, #0x700a
700a8e4c: f2c7 010b    	movt	r1, #0x700b
700a8e50: 241e         	movs	r4, #0x1e
700a8e52: f44f 5200    	mov.w	r2, #0x2000
700a8e56: 2300         	movs	r3, #0x0
700a8e58: f04f 0c00    	mov.w	r12, #0x0
700a8e5c: e9cd 4c00    	strd	r4, r12, [sp]
700a8e60: f000 fb4e    	bl	0x700a9500 <xTaskCreate> @ imm = #0x69c
;    if (status != pdPASS)
700a8e64: 2801         	cmp	r0, #0x1
700a8e66: d010         	beq	0x700a8e8a <rtos_main_freertos+0x6a> @ imm = #0x20
;       DebugP_assert(status == pdPASS);
700a8e68: f641 7104    	movw	r1, #0x1f04
700a8e6c: f641 725c    	movw	r2, #0x1f5c
700a8e70: f242 046f    	movw	r4, #0x206f
700a8e74: f2c7 010b    	movt	r1, #0x700b
700a8e78: f2c7 020b    	movt	r2, #0x700b
700a8e7c: f2c7 040b    	movt	r4, #0x700b
700a8e80: 2000         	movs	r0, #0x0
700a8e82: 2381         	movs	r3, #0x81
700a8e84: 9400         	str	r4, [sp]
700a8e86: f001 ff03    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x1e06
;    vTaskStartScheduler();
700a8e8a: f7fe fc61    	bl	0x700a7750 <vTaskStartScheduler> @ imm = #-0x173e
700a8e8e: f641 34fd    	movw	r4, #0x1bfd
700a8e92: f2c7 040b    	movt	r4, #0x700b
700a8e96: bf00         	nop
700a8e98: bf00         	nop
700a8e9a: bf00         	nop
700a8e9c: bf00         	nop
700a8e9e: bf00         	nop
;       printf("Scheduler returned unexpectedly\r\n");
700a8ea0: 4621         	mov	r1, r4
700a8ea2: f04f 0001    	mov.w	r0, #0x1
700a8ea6: f000 ff3b    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xe76
700a8eaa: 4621         	mov	r1, r4
700a8eac: 2001         	movs	r0, #0x1
700a8eae: f000 ff37    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xe6e
700a8eb2: 4621         	mov	r1, r4
700a8eb4: 2001         	movs	r0, #0x1
700a8eb6: f000 ff33    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #0xe66
;    for (;;)
700a8eba: e7f1         	b	0x700a8ea0 <rtos_main_freertos+0x80> @ imm = #-0x1e
700a8ebc: 0000         	movs	r0, r0
700a8ebe: 0000         	movs	r0, r0

700a8ec0 <SOC_controlModuleUnlockMMR>:
; {
700a8ec0: b580         	push	{r7, lr}
700a8ec2: b084         	sub	sp, #0x10
700a8ec4: 9003         	str	r0, [sp, #0xc]
700a8ec6: 9102         	str	r1, [sp, #0x8]
;     if(SOC_DOMAIN_ID_MAIN == domainId)
700a8ec8: 9803         	ldr	r0, [sp, #0xc]
700a8eca: bb00         	cbnz	r0, 0x700a8f0e <SOC_controlModuleUnlockMMR+0x4e> @ imm = #0x40
700a8ecc: e7ff         	b	0x700a8ece <SOC_controlModuleUnlockMMR+0xe> @ imm = #-0x2
700a8ece: f04f 4086    	mov.w	r0, #0x43000000
700a8ed2: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_CTRL_MMR0_CFG0_BASE);
700a8ed4: f7fc fea4    	bl	0x700a5c20 <AddrTranslateP_getLocalAddr> @ imm = #-0x32b8
700a8ed8: 9001         	str	r0, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a8eda: 9801         	ldr	r0, [sp, #0x4]
700a8edc: 9902         	ldr	r1, [sp, #0x8]
700a8ede: eb00 3081    	add.w	r0, r0, r1, lsl #14
700a8ee2: f241 0108    	movw	r1, #0x1008
700a8ee6: 4408         	add	r0, r1
700a8ee8: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a8eea: 9800         	ldr	r0, [sp]
700a8eec: f243 4190    	movw	r1, #0x3490
700a8ef0: f6c6 01ef    	movt	r1, #0x68ef
700a8ef4: f006 fe0c    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0x6c18
;         kickAddr++;
700a8ef8: 9800         	ldr	r0, [sp]
700a8efa: 3004         	adds	r0, #0x4
700a8efc: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a8efe: 9800         	ldr	r0, [sp]
700a8f00: f64b 415a    	movw	r1, #0xbc5a
700a8f04: f2cd 1172    	movt	r1, #0xd172
700a8f08: f006 fe02    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0x6c04
;     }
700a8f0c: e7ff         	b	0x700a8f0e <SOC_controlModuleUnlockMMR+0x4e> @ imm = #-0x2
;     if(SOC_DOMAIN_ID_MCU == domainId)
700a8f0e: 9803         	ldr	r0, [sp, #0xc]
700a8f10: 2801         	cmp	r0, #0x1
700a8f12: d120         	bne	0x700a8f56 <SOC_controlModuleUnlockMMR+0x96> @ imm = #0x40
700a8f14: e7ff         	b	0x700a8f16 <SOC_controlModuleUnlockMMR+0x56> @ imm = #-0x2
700a8f16: f04f 608a    	mov.w	r0, #0x4500000
700a8f1a: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_CTRL_MMR0_CFG0_BASE);
700a8f1c: f7fc fe80    	bl	0x700a5c20 <AddrTranslateP_getLocalAddr> @ imm = #-0x3300
700a8f20: 9001         	str	r0, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a8f22: 9801         	ldr	r0, [sp, #0x4]
700a8f24: 9902         	ldr	r1, [sp, #0x8]
700a8f26: eb00 3081    	add.w	r0, r0, r1, lsl #14
700a8f2a: f241 0108    	movw	r1, #0x1008
700a8f2e: 4408         	add	r0, r1
700a8f30: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a8f32: 9800         	ldr	r0, [sp]
700a8f34: f243 4190    	movw	r1, #0x3490
700a8f38: f6c6 01ef    	movt	r1, #0x68ef
700a8f3c: f006 fde8    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0x6bd0
;         kickAddr++;
700a8f40: 9800         	ldr	r0, [sp]
700a8f42: 3004         	adds	r0, #0x4
700a8f44: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a8f46: 9800         	ldr	r0, [sp]
700a8f48: f64b 415a    	movw	r1, #0xbc5a
700a8f4c: f2cd 1172    	movt	r1, #0xd172
700a8f50: f006 fdde    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0x6bbc
;     }
700a8f54: e7ff         	b	0x700a8f56 <SOC_controlModuleUnlockMMR+0x96> @ imm = #-0x2
;     return;
700a8f56: b004         	add	sp, #0x10
700a8f58: bd80         	pop	{r7, pc}
700a8f5a: 0000         	movs	r0, r0
700a8f5c: 0000         	movs	r0, r0
700a8f5e: 0000         	movs	r0, r0

700a8f60 <Sciclient_pmGetModuleClkFreq>:
; {
700a8f60: b580         	push	{r7, lr}
700a8f62: b096         	sub	sp, #0x58
700a8f64: 9015         	str	r0, [sp, #0x54]
700a8f66: 9114         	str	r1, [sp, #0x50]
700a8f68: 9213         	str	r2, [sp, #0x4c]
700a8f6a: 9312         	str	r3, [sp, #0x48]
700a8f6c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a8f6e: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a8f70: 9815         	ldr	r0, [sp, #0x54]
700a8f72: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a8f74: 9814         	ldr	r0, [sp, #0x50]
700a8f76: 28ff         	cmp	r0, #0xff
700a8f78: d307         	blo	0x700a8f8a <Sciclient_pmGetModuleClkFreq+0x2a> @ imm = #0xe
700a8f7a: e7ff         	b	0x700a8f7c <Sciclient_pmGetModuleClkFreq+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a8f7c: 9814         	ldr	r0, [sp, #0x50]
700a8f7e: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a8f82: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a8f84: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a8f88: e003         	b	0x700a8f92 <Sciclient_pmGetModuleClkFreq+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a8f8a: 9814         	ldr	r0, [sp, #0x50]
700a8f8c: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a8f90: e7ff         	b	0x700a8f92 <Sciclient_pmGetModuleClkFreq+0x32> @ imm = #-0x2
700a8f92: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_freq_resp response = {{0}};
700a8f94: 900b         	str	r0, [sp, #0x2c]
700a8f96: 900a         	str	r0, [sp, #0x28]
700a8f98: 9009         	str	r0, [sp, #0x24]
700a8f9a: 9008         	str	r0, [sp, #0x20]
700a8f9c: f44f 7187    	mov.w	r1, #0x10e
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_FREQ;
700a8fa0: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a8fa4: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a8fa6: 9104         	str	r1, [sp, #0x10]
700a8fa8: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a8faa: 9105         	str	r1, [sp, #0x14]
700a8fac: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a8fae: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a8fb0: 9912         	ldr	r1, [sp, #0x48]
700a8fb2: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a8fb4: 9000         	str	r0, [sp]
700a8fb6: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a8fb8: 9001         	str	r0, [sp, #0x4]
700a8fba: 2010         	movs	r0, #0x10
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a8fbc: 9002         	str	r0, [sp, #0x8]
700a8fbe: a803         	add	r0, sp, #0xc
700a8fc0: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a8fc2: f7f4 fb15    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xb9d6
700a8fc6: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a8fc8: 9811         	ldr	r0, [sp, #0x44]
700a8fca: b930         	cbnz	r0, 0x700a8fda <Sciclient_pmGetModuleClkFreq+0x7a> @ imm = #0xc
700a8fcc: e7ff         	b	0x700a8fce <Sciclient_pmGetModuleClkFreq+0x6e> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a8fce: 9800         	ldr	r0, [sp]
700a8fd0: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a8fd4: 2802         	cmp	r0, #0x2
700a8fd6: d004         	beq	0x700a8fe2 <Sciclient_pmGetModuleClkFreq+0x82> @ imm = #0x8
700a8fd8: e7ff         	b	0x700a8fda <Sciclient_pmGetModuleClkFreq+0x7a> @ imm = #-0x2
700a8fda: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a8fde: 9011         	str	r0, [sp, #0x44]
;     }
700a8fe0: e7ff         	b	0x700a8fe2 <Sciclient_pmGetModuleClkFreq+0x82> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a8fe2: 9811         	ldr	r0, [sp, #0x44]
700a8fe4: b930         	cbnz	r0, 0x700a8ff4 <Sciclient_pmGetModuleClkFreq+0x94> @ imm = #0xc
700a8fe6: e7ff         	b	0x700a8fe8 <Sciclient_pmGetModuleClkFreq+0x88> @ imm = #-0x2
;         *freqHz = (uint64_t) response.freq_hz;
700a8fe8: 980a         	ldr	r0, [sp, #0x28]
700a8fea: 9a0b         	ldr	r2, [sp, #0x2c]
700a8fec: 9913         	ldr	r1, [sp, #0x4c]
700a8fee: 604a         	str	r2, [r1, #0x4]
700a8ff0: 6008         	str	r0, [r1]
;     }
700a8ff2: e7ff         	b	0x700a8ff4 <Sciclient_pmGetModuleClkFreq+0x94> @ imm = #-0x2
;     return retVal;
700a8ff4: 9811         	ldr	r0, [sp, #0x44]
700a8ff6: b016         	add	sp, #0x58
700a8ff8: bd80         	pop	{r7, pc}
700a8ffa: 0000         	movs	r0, r0
700a8ffc: 0000         	movs	r0, r0
700a8ffe: 0000         	movs	r0, r0

700a9000 <Sciclient_pmGetModuleClkParent>:
; {
700a9000: b580         	push	{r7, lr}
700a9002: b096         	sub	sp, #0x58
700a9004: 9015         	str	r0, [sp, #0x54]
700a9006: 9114         	str	r1, [sp, #0x50]
700a9008: 9213         	str	r2, [sp, #0x4c]
700a900a: 9312         	str	r3, [sp, #0x48]
700a900c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a900e: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a9010: 9815         	ldr	r0, [sp, #0x54]
700a9012: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a9014: 9814         	ldr	r0, [sp, #0x50]
700a9016: 28ff         	cmp	r0, #0xff
700a9018: d307         	blo	0x700a902a <Sciclient_pmGetModuleClkParent+0x2a> @ imm = #0xe
700a901a: e7ff         	b	0x700a901c <Sciclient_pmGetModuleClkParent+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a901c: 9814         	ldr	r0, [sp, #0x50]
700a901e: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a9022: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a9024: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a9028: e003         	b	0x700a9032 <Sciclient_pmGetModuleClkParent+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a902a: 9814         	ldr	r0, [sp, #0x50]
700a902c: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a9030: e7ff         	b	0x700a9032 <Sciclient_pmGetModuleClkParent+0x32> @ imm = #-0x2
700a9032: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_clock_parent_resp response = {{0}};
700a9034: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a9038: 900a         	str	r0, [sp, #0x28]
700a903a: 9009         	str	r0, [sp, #0x24]
700a903c: 9008         	str	r0, [sp, #0x20]
700a903e: f240 1103    	movw	r1, #0x103
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_CLOCK_PARENT;
700a9042: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a9046: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a9048: 9104         	str	r1, [sp, #0x10]
700a904a: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a904c: 9105         	str	r1, [sp, #0x14]
700a904e: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a9050: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a9052: 9912         	ldr	r1, [sp, #0x48]
700a9054: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9056: 9000         	str	r0, [sp]
700a9058: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a905a: 9001         	str	r0, [sp, #0x4]
700a905c: 200d         	movs	r0, #0xd
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a905e: 9002         	str	r0, [sp, #0x8]
700a9060: a803         	add	r0, sp, #0xc
700a9062: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9064: f7f4 fac4    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xba78
700a9068: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a906a: 9811         	ldr	r0, [sp, #0x44]
700a906c: b930         	cbnz	r0, 0x700a907c <Sciclient_pmGetModuleClkParent+0x7c> @ imm = #0xc
700a906e: e7ff         	b	0x700a9070 <Sciclient_pmGetModuleClkParent+0x70> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a9070: 9800         	ldr	r0, [sp]
700a9072: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9076: 2802         	cmp	r0, #0x2
700a9078: d004         	beq	0x700a9084 <Sciclient_pmGetModuleClkParent+0x84> @ imm = #0x8
700a907a: e7ff         	b	0x700a907c <Sciclient_pmGetModuleClkParent+0x7c> @ imm = #-0x2
700a907c: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9080: 9011         	str	r0, [sp, #0x44]
;     }
700a9082: e7ff         	b	0x700a9084 <Sciclient_pmGetModuleClkParent+0x84> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a9084: 9811         	ldr	r0, [sp, #0x44]
700a9086: b928         	cbnz	r0, 0x700a9094 <Sciclient_pmGetModuleClkParent+0x94> @ imm = #0xa
700a9088: e7ff         	b	0x700a908a <Sciclient_pmGetModuleClkParent+0x8a> @ imm = #-0x2
;         *parent = (uint32_t) response.parent;
700a908a: f89d 0028    	ldrb.w	r0, [sp, #0x28]
700a908e: 9913         	ldr	r1, [sp, #0x4c]
700a9090: 6008         	str	r0, [r1]
;     }
700a9092: e7ff         	b	0x700a9094 <Sciclient_pmGetModuleClkParent+0x94> @ imm = #-0x2
;     return retVal;
700a9094: 9811         	ldr	r0, [sp, #0x44]
700a9096: b016         	add	sp, #0x58
700a9098: bd80         	pop	{r7, pc}
700a909a: 0000         	movs	r0, r0
700a909c: 0000         	movs	r0, r0
700a909e: 0000         	movs	r0, r0

700a90a0 <Sciclient_pmSetModuleClkParent>:
; {
700a90a0: b580         	push	{r7, lr}
700a90a2: b094         	sub	sp, #0x50
700a90a4: 9013         	str	r0, [sp, #0x4c]
700a90a6: 9112         	str	r1, [sp, #0x48]
700a90a8: 9211         	str	r2, [sp, #0x44]
700a90aa: 9310         	str	r3, [sp, #0x40]
700a90ac: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a90ae: 900f         	str	r0, [sp, #0x3c]
;     request.device = (uint32_t) moduleId;
700a90b0: 9813         	ldr	r0, [sp, #0x4c]
700a90b2: 900b         	str	r0, [sp, #0x2c]
;     if (clockId >= 255U)
700a90b4: 9812         	ldr	r0, [sp, #0x48]
700a90b6: 28ff         	cmp	r0, #0xff
700a90b8: d307         	blo	0x700a90ca <Sciclient_pmSetModuleClkParent+0x2a> @ imm = #0xe
700a90ba: e7ff         	b	0x700a90bc <Sciclient_pmSetModuleClkParent+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a90bc: 9812         	ldr	r0, [sp, #0x48]
700a90be: f8cd 0032    	str.w	r0, [sp, #0x32]
700a90c2: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a90c4: f88d 0030    	strb.w	r0, [sp, #0x30]
;     }
700a90c8: e003         	b	0x700a90d2 <Sciclient_pmSetModuleClkParent+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a90ca: 9812         	ldr	r0, [sp, #0x48]
700a90cc: f88d 0030    	strb.w	r0, [sp, #0x30]
700a90d0: e7ff         	b	0x700a90d2 <Sciclient_pmSetModuleClkParent+0x32> @ imm = #-0x2
;     if (parent >= 255U)
700a90d2: 9811         	ldr	r0, [sp, #0x44]
700a90d4: 28ff         	cmp	r0, #0xff
700a90d6: d307         	blo	0x700a90e8 <Sciclient_pmSetModuleClkParent+0x48> @ imm = #0xe
700a90d8: e7ff         	b	0x700a90da <Sciclient_pmSetModuleClkParent+0x3a> @ imm = #-0x2
;         request.parent32 = parent;
700a90da: 9811         	ldr	r0, [sp, #0x44]
700a90dc: f8cd 0036    	str.w	r0, [sp, #0x36]
700a90e0: 20ff         	movs	r0, #0xff
;         request.parent   = (uint8_t) 255U;
700a90e2: f88d 0031    	strb.w	r0, [sp, #0x31]
;     }
700a90e6: e003         	b	0x700a90f0 <Sciclient_pmSetModuleClkParent+0x50> @ imm = #0x6
;         request.parent = (uint8_t) parent;
700a90e8: 9811         	ldr	r0, [sp, #0x44]
700a90ea: f88d 0031    	strb.w	r0, [sp, #0x31]
700a90ee: e7ff         	b	0x700a90f0 <Sciclient_pmSetModuleClkParent+0x50> @ imm = #-0x2
700a90f0: f44f 7081    	mov.w	r0, #0x102
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_CLOCK_PARENT;
700a90f4: f8ad 0010    	strh.w	r0, [sp, #0x10]
700a90f8: 2002         	movs	r0, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a90fa: 9005         	str	r0, [sp, #0x14]
700a90fc: a809         	add	r0, sp, #0x24
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a90fe: 9006         	str	r0, [sp, #0x18]
700a9100: 2016         	movs	r0, #0x16
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a9102: 9007         	str	r0, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a9104: 9810         	ldr	r0, [sp, #0x40]
700a9106: 9008         	str	r0, [sp, #0x20]
700a9108: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a910a: 9001         	str	r0, [sp, #0x4]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a910c: 9002         	str	r0, [sp, #0x8]
;     respParam.respPayloadSize = (uint32_t) 0;
700a910e: 9003         	str	r0, [sp, #0xc]
700a9110: a804         	add	r0, sp, #0x10
700a9112: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9114: f7f4 fa6c    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xbb28
700a9118: 900f         	str	r0, [sp, #0x3c]
;     if((retVal != SystemP_SUCCESS) ||
700a911a: 980f         	ldr	r0, [sp, #0x3c]
700a911c: b930         	cbnz	r0, 0x700a912c <Sciclient_pmSetModuleClkParent+0x8c> @ imm = #0xc
700a911e: e7ff         	b	0x700a9120 <Sciclient_pmSetModuleClkParent+0x80> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a9120: 9801         	ldr	r0, [sp, #0x4]
700a9122: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9126: 2802         	cmp	r0, #0x2
700a9128: d004         	beq	0x700a9134 <Sciclient_pmSetModuleClkParent+0x94> @ imm = #0x8
700a912a: e7ff         	b	0x700a912c <Sciclient_pmSetModuleClkParent+0x8c> @ imm = #-0x2
700a912c: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9130: 900f         	str	r0, [sp, #0x3c]
;     }
700a9132: e7ff         	b	0x700a9134 <Sciclient_pmSetModuleClkParent+0x94> @ imm = #-0x2
;     return retVal;
700a9134: 980f         	ldr	r0, [sp, #0x3c]
700a9136: b014         	add	sp, #0x50
700a9138: bd80         	pop	{r7, pc}
700a913a: 0000         	movs	r0, r0
700a913c: 0000         	movs	r0, r0
700a913e: 0000         	movs	r0, r0

700a9140 <Sciclient_rmIrOutpIsFree>:
; {
700a9140: b580         	push	{r7, lr}
700a9142: b086         	sub	sp, #0x18
700a9144: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a9148: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a914c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a914e: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIrInst *inst = NULL;
700a9150: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIrGetInst(id);
700a9152: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a9156: f002 fd13    	bl	0x700abb80 <Sciclient_rmIrGetInst> @ imm = #0x2a26
700a915a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a915c: 9803         	ldr	r0, [sp, #0xc]
700a915e: b920         	cbnz	r0, 0x700a916a <Sciclient_rmIrOutpIsFree+0x2a> @ imm = #0x8
700a9160: e7ff         	b	0x700a9162 <Sciclient_rmIrOutpIsFree+0x22> @ imm = #-0x2
700a9162: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a9166: 9004         	str	r0, [sp, #0x10]
;     } else {
700a9168: e00b         	b	0x700a9182 <Sciclient_rmIrOutpIsFree+0x42> @ imm = #0x16
;         if (outp >= inst->n_outp) {
700a916a: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a916e: 9903         	ldr	r1, [sp, #0xc]
700a9170: 8949         	ldrh	r1, [r1, #0xa]
700a9172: 4288         	cmp	r0, r1
700a9174: db04         	blt	0x700a9180 <Sciclient_rmIrOutpIsFree+0x40> @ imm = #0x8
700a9176: e7ff         	b	0x700a9178 <Sciclient_rmIrOutpIsFree+0x38> @ imm = #-0x2
700a9178: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a917c: 9004         	str	r0, [sp, #0x10]
;         }
700a917e: e7ff         	b	0x700a9180 <Sciclient_rmIrOutpIsFree+0x40> @ imm = #-0x2
700a9180: e7ff         	b	0x700a9182 <Sciclient_rmIrOutpIsFree+0x42> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a9182: 9804         	ldr	r0, [sp, #0x10]
700a9184: bb30         	cbnz	r0, 0x700a91d4 <Sciclient_rmIrOutpIsFree+0x94> @ imm = #0x4c
700a9186: e7ff         	b	0x700a9188 <Sciclient_rmIrOutpIsFree+0x48> @ imm = #-0x2
;         int_ctrl_reg = (volatile uint32_t *) Sciclient_getIrAddr (inst->cfg, outp);
700a9188: 9803         	ldr	r0, [sp, #0xc]
700a918a: 6840         	ldr	r0, [r0, #0x4]
700a918c: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a9190: f005 fd16    	bl	0x700aebc0 <Sciclient_getIrAddr> @ imm = #0x5a2c
700a9194: 9002         	str	r0, [sp, #0x8]
;         extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a9196: 9802         	ldr	r0, [sp, #0x8]
700a9198: f240 31ff    	movw	r1, #0x3ff
700a919c: 2200         	movs	r2, #0x0
700a919e: f005 ffdf    	bl	0x700af160 <CSL_REG32_FEXT_RAW> @ imm = #0x5fbe
700a91a2: f8ad 0006    	strh.w	r0, [sp, #0x6]
;         if (((extracted_inp != 0u) &&
700a91a6: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a91aa: b138         	cbz	r0, 0x700a91bc <Sciclient_rmIrOutpIsFree+0x7c> @ imm = #0xe
700a91ac: e7ff         	b	0x700a91ae <Sciclient_rmIrOutpIsFree+0x6e> @ imm = #-0x2
;              (Sciclient_rmIrOutpRomMapped(inst, outp) == false)) ||
700a91ae: 9803         	ldr	r0, [sp, #0xc]
700a91b0: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a91b4: f7ff f934    	bl	0x700a8420 <Sciclient_rmIrOutpRomMapped> @ imm = #-0xd98
700a91b8: b138         	cbz	r0, 0x700a91ca <Sciclient_rmIrOutpIsFree+0x8a> @ imm = #0xe
700a91ba: e7ff         	b	0x700a91bc <Sciclient_rmIrOutpIsFree+0x7c> @ imm = #-0x2
;             (outp == inst->inp0_mapping)) {
700a91bc: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a91c0: 9903         	ldr	r1, [sp, #0xc]
700a91c2: 8989         	ldrh	r1, [r1, #0xc]
;         if (((extracted_inp != 0u) &&
700a91c4: 4288         	cmp	r0, r1
700a91c6: d104         	bne	0x700a91d2 <Sciclient_rmIrOutpIsFree+0x92> @ imm = #0x8
700a91c8: e7ff         	b	0x700a91ca <Sciclient_rmIrOutpIsFree+0x8a> @ imm = #-0x2
700a91ca: f04f 30ff    	mov.w	r0, #0xffffffff
;             r = SystemP_FAILURE;
700a91ce: 9004         	str	r0, [sp, #0x10]
;         }
700a91d0: e7ff         	b	0x700a91d2 <Sciclient_rmIrOutpIsFree+0x92> @ imm = #-0x2
;     }
700a91d2: e7ff         	b	0x700a91d4 <Sciclient_rmIrOutpIsFree+0x94> @ imm = #-0x2
;     return r;
700a91d4: 9804         	ldr	r0, [sp, #0x10]
700a91d6: b006         	add	sp, #0x18
700a91d8: bd80         	pop	{r7, pc}
700a91da: 0000         	movs	r0, r0
700a91dc: 0000         	movs	r0, r0
700a91de: 0000         	movs	r0, r0

700a91e0 <Udma_ringQueueRaw>:
; {
700a91e0: b580         	push	{r7, lr}
700a91e2: b088         	sub	sp, #0x20
700a91e4: 9007         	str	r0, [sp, #0x1c]
700a91e6: 9305         	str	r3, [sp, #0x14]
700a91e8: 9204         	str	r2, [sp, #0x10]
700a91ea: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a91ec: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a91ee: 9807         	ldr	r0, [sp, #0x1c]
700a91f0: 9000         	str	r0, [sp]
;     if((NULL_PTR == ringHandleInt) ||
700a91f2: 9800         	ldr	r0, [sp]
700a91f4: b180         	cbz	r0, 0x700a9218 <Udma_ringQueueRaw+0x38> @ imm = #0x20
700a91f6: e7ff         	b	0x700a91f8 <Udma_ringQueueRaw+0x18> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a91f8: 9800         	ldr	r0, [sp]
700a91fa: 6d80         	ldr	r0, [r0, #0x58]
700a91fc: f64a 31cd    	movw	r1, #0xabcd
700a9200: f6ca 31dc    	movt	r1, #0xabdc
700a9204: 4288         	cmp	r0, r1
700a9206: d107         	bne	0x700a9218 <Udma_ringQueueRaw+0x38> @ imm = #0xe
700a9208: e7ff         	b	0x700a920a <Udma_ringQueueRaw+0x2a> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a920a: 9800         	ldr	r0, [sp]
700a920c: 8880         	ldrh	r0, [r0, #0x4]
700a920e: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a9212: 4288         	cmp	r0, r1
700a9214: d104         	bne	0x700a9220 <Udma_ringQueueRaw+0x40> @ imm = #0x8
700a9216: e7ff         	b	0x700a9218 <Udma_ringQueueRaw+0x38> @ imm = #-0x2
700a9218: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a921c: 9003         	str	r0, [sp, #0xc]
;     }
700a921e: e7ff         	b	0x700a9220 <Udma_ringQueueRaw+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9220: 9803         	ldr	r0, [sp, #0xc]
700a9222: b9a8         	cbnz	r0, 0x700a9250 <Udma_ringQueueRaw+0x70> @ imm = #0x2a
700a9224: e7ff         	b	0x700a9226 <Udma_ringQueueRaw+0x46> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a9226: 9800         	ldr	r0, [sp]
700a9228: 6800         	ldr	r0, [r0]
700a922a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) ||
700a922c: 9801         	ldr	r0, [sp, #0x4]
700a922e: b150         	cbz	r0, 0x700a9246 <Udma_ringQueueRaw+0x66> @ imm = #0x14
700a9230: e7ff         	b	0x700a9232 <Udma_ringQueueRaw+0x52> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a9232: 9801         	ldr	r0, [sp, #0x4]
700a9234: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a9238: f64a 31cd    	movw	r1, #0xabcd
700a923c: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a9240: 4288         	cmp	r0, r1
700a9242: d004         	beq	0x700a924e <Udma_ringQueueRaw+0x6e> @ imm = #0x8
700a9244: e7ff         	b	0x700a9246 <Udma_ringQueueRaw+0x66> @ imm = #-0x2
700a9246: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a924a: 9003         	str	r0, [sp, #0xc]
;         }
700a924c: e7ff         	b	0x700a924e <Udma_ringQueueRaw+0x6e> @ imm = #-0x2
;     }
700a924e: e7ff         	b	0x700a9250 <Udma_ringQueueRaw+0x70> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9250: 9803         	ldr	r0, [sp, #0xc]
700a9252: b978         	cbnz	r0, 0x700a9274 <Udma_ringQueueRaw+0x94> @ imm = #0x1e
700a9254: e7ff         	b	0x700a9256 <Udma_ringQueueRaw+0x76> @ imm = #-0x2
;         cookie = HwiP_disable();
700a9256: f007 eb84    	blx	0x700b0960 <HwiP_disable> @ imm = #0x7708
700a925a: 9002         	str	r0, [sp, #0x8]
;         retVal = drvHandle->ringQueueRaw(drvHandle, ringHandleInt, phyDescMem);
700a925c: 9801         	ldr	r0, [sp, #0x4]
700a925e: f8d0 c594    	ldr.w	r12, [r0, #0x594]
700a9262: 9900         	ldr	r1, [sp]
700a9264: 9a04         	ldr	r2, [sp, #0x10]
700a9266: 9b05         	ldr	r3, [sp, #0x14]
700a9268: 47e0         	blx	r12
700a926a: 9003         	str	r0, [sp, #0xc]
;         HwiP_restore(cookie);
700a926c: 9802         	ldr	r0, [sp, #0x8]
700a926e: f007 eb98    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x7730
;     }
700a9272: e7ff         	b	0x700a9274 <Udma_ringQueueRaw+0x94> @ imm = #-0x2
;     return (retVal);
700a9274: 9803         	ldr	r0, [sp, #0xc]
700a9276: b008         	add	sp, #0x20
700a9278: bd80         	pop	{r7, pc}
700a927a: 0000         	movs	r0, r0
700a927c: 0000         	movs	r0, r0
700a927e: 0000         	movs	r0, r0

700a9280 <xTaskCheckForTimeOut>:
;                                 TickType_t *const pxTicksToWait) {
700a9280: b580         	push	{r7, lr}
700a9282: b086         	sub	sp, #0x18
700a9284: 9005         	str	r0, [sp, #0x14]
700a9286: 9104         	str	r1, [sp, #0x10]
;   taskENTER_CRITICAL();
700a9288: f005 fa7a    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0x54f4
;     const TickType_t xConstTickCount = xTickCount;
700a928c: f642 2054    	movw	r0, #0x2a54
700a9290: f2c7 000b    	movt	r0, #0x700b
700a9294: 6800         	ldr	r0, [r0]
700a9296: 9002         	str	r0, [sp, #0x8]
;         xConstTickCount - pxTimeOut->xTimeOnEntering;
700a9298: 9802         	ldr	r0, [sp, #0x8]
700a929a: 9905         	ldr	r1, [sp, #0x14]
700a929c: 6849         	ldr	r1, [r1, #0x4]
700a929e: 1a40         	subs	r0, r0, r1
;     const TickType_t xElapsedTime =
700a92a0: 9001         	str	r0, [sp, #0x4]
;         if (*pxTicksToWait == portMAX_DELAY) {
700a92a2: 9804         	ldr	r0, [sp, #0x10]
700a92a4: 6800         	ldr	r0, [r0]
700a92a6: 3001         	adds	r0, #0x1
700a92a8: b918         	cbnz	r0, 0x700a92b2 <xTaskCheckForTimeOut+0x32> @ imm = #0x6
700a92aa: e7ff         	b	0x700a92ac <xTaskCheckForTimeOut+0x2c> @ imm = #-0x2
700a92ac: 2000         	movs	r0, #0x0
;       xReturn = pdFALSE;
700a92ae: 9003         	str	r0, [sp, #0xc]
;     } else
700a92b0: e02e         	b	0x700a9310 <xTaskCheckForTimeOut+0x90> @ imm = #0x5c
;         if ((xNumOfOverflows != pxTimeOut->xOverflowCount) &&
700a92b2: f642 2048    	movw	r0, #0x2a48
700a92b6: f2c7 000b    	movt	r0, #0x700b
700a92ba: 6800         	ldr	r0, [r0]
700a92bc: 9905         	ldr	r1, [sp, #0x14]
700a92be: 6809         	ldr	r1, [r1]
700a92c0: 4288         	cmp	r0, r1
700a92c2: d00c         	beq	0x700a92de <xTaskCheckForTimeOut+0x5e> @ imm = #0x18
700a92c4: e7ff         	b	0x700a92c6 <xTaskCheckForTimeOut+0x46> @ imm = #-0x2
;             (xConstTickCount >=
700a92c6: 9802         	ldr	r0, [sp, #0x8]
;              pxTimeOut
700a92c8: 9905         	ldr	r1, [sp, #0x14]
;                  ->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to
700a92ca: 6849         	ldr	r1, [r1, #0x4]
;         if ((xNumOfOverflows != pxTimeOut->xOverflowCount) &&
700a92cc: 4288         	cmp	r0, r1
700a92ce: d306         	blo	0x700a92de <xTaskCheckForTimeOut+0x5e> @ imm = #0xc
700a92d0: e7ff         	b	0x700a92d2 <xTaskCheckForTimeOut+0x52> @ imm = #-0x2
700a92d2: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a92d4: 9003         	str	r0, [sp, #0xc]
;       *pxTicksToWait = (TickType_t)0;
700a92d6: 9904         	ldr	r1, [sp, #0x10]
700a92d8: 2000         	movs	r0, #0x0
700a92da: 6008         	str	r0, [r1]
;     } else if (xElapsedTime <
700a92dc: e017         	b	0x700a930e <xTaskCheckForTimeOut+0x8e> @ imm = #0x2e
700a92de: 9801         	ldr	r0, [sp, #0x4]
;                *pxTicksToWait) /*lint !e961 Explicit casting is only redundant
700a92e0: 9904         	ldr	r1, [sp, #0x10]
700a92e2: 6809         	ldr	r1, [r1]
;     } else if (xElapsedTime <
700a92e4: 4288         	cmp	r0, r1
700a92e6: d20b         	bhs	0x700a9300 <xTaskCheckForTimeOut+0x80> @ imm = #0x16
700a92e8: e7ff         	b	0x700a92ea <xTaskCheckForTimeOut+0x6a> @ imm = #-0x2
;       *pxTicksToWait -= xElapsedTime;
700a92ea: 9a01         	ldr	r2, [sp, #0x4]
700a92ec: 9904         	ldr	r1, [sp, #0x10]
700a92ee: 6808         	ldr	r0, [r1]
700a92f0: 1a80         	subs	r0, r0, r2
700a92f2: 6008         	str	r0, [r1]
;       vTaskInternalSetTimeOutState(pxTimeOut);
700a92f4: 9805         	ldr	r0, [sp, #0x14]
700a92f6: f005 ffbb    	bl	0x700af270 <vTaskInternalSetTimeOutState> @ imm = #0x5f76
700a92fa: 2000         	movs	r0, #0x0
;       xReturn = pdFALSE;
700a92fc: 9003         	str	r0, [sp, #0xc]
;     } else {
700a92fe: e005         	b	0x700a930c <xTaskCheckForTimeOut+0x8c> @ imm = #0xa
;       *pxTicksToWait = (TickType_t)0;
700a9300: 9904         	ldr	r1, [sp, #0x10]
700a9302: 2000         	movs	r0, #0x0
700a9304: 6008         	str	r0, [r1]
700a9306: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a9308: 9003         	str	r0, [sp, #0xc]
700a930a: e7ff         	b	0x700a930c <xTaskCheckForTimeOut+0x8c> @ imm = #-0x2
700a930c: e7ff         	b	0x700a930e <xTaskCheckForTimeOut+0x8e> @ imm = #-0x2
700a930e: e7ff         	b	0x700a9310 <xTaskCheckForTimeOut+0x90> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a9310: f004 faf6    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0x45ec
;   return xReturn;
700a9314: 9803         	ldr	r0, [sp, #0xc]
700a9316: b006         	add	sp, #0x18
700a9318: bd80         	pop	{r7, pc}
700a931a: 0000         	movs	r0, r0
700a931c: 0000         	movs	r0, r0
700a931e: 0000         	movs	r0, r0

700a9320 <CSL_bcdmaChanOpSetChanEnable>:
; {
700a9320: b580         	push	{r7, lr}
700a9322: b086         	sub	sp, #0x18
700a9324: 9005         	str	r0, [sp, #0x14]
700a9326: 9104         	str	r1, [sp, #0x10]
700a9328: 9203         	str	r2, [sp, #0xc]
700a932a: f88d 300b    	strb.w	r3, [sp, #0xb]
700a932e: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a9330: 9001         	str	r0, [sp, #0x4]
;     switch( chanType )
700a9332: 9804         	ldr	r0, [sp, #0x10]
700a9334: 9000         	str	r0, [sp]
700a9336: b140         	cbz	r0, 0x700a934a <CSL_bcdmaChanOpSetChanEnable+0x2a> @ imm = #0x10
700a9338: e7ff         	b	0x700a933a <CSL_bcdmaChanOpSetChanEnable+0x1a> @ imm = #-0x2
700a933a: 9800         	ldr	r0, [sp]
700a933c: 2801         	cmp	r0, #0x1
700a933e: d014         	beq	0x700a936a <CSL_bcdmaChanOpSetChanEnable+0x4a> @ imm = #0x28
700a9340: e7ff         	b	0x700a9342 <CSL_bcdmaChanOpSetChanEnable+0x22> @ imm = #-0x2
700a9342: 9800         	ldr	r0, [sp]
700a9344: 2802         	cmp	r0, #0x2
700a9346: d020         	beq	0x700a938a <CSL_bcdmaChanOpSetChanEnable+0x6a> @ imm = #0x40
700a9348: e02f         	b	0x700a93aa <CSL_bcdmaChanOpSetChanEnable+0x8a> @ imm = #0x5e
;             CSL_REG32_WR(&pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_BCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a934a: 9805         	ldr	r0, [sp, #0x14]
700a934c: 6880         	ldr	r0, [r0, #0x8]
700a934e: 9903         	ldr	r1, [sp, #0xc]
700a9350: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a9354: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a9358: f001 0101    	and	r1, r1, #0x1
700a935c: 2900         	cmp	r1, #0x0
700a935e: bf18         	it	ne
700a9360: f04f 4100    	movne.w	r1, #0x80000000
700a9364: f7f2 ff94    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xd0d8
;             break;
700a9368: e023         	b	0x700a93b2 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x46
;             CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a936a: 9805         	ldr	r0, [sp, #0x14]
700a936c: 6900         	ldr	r0, [r0, #0x10]
700a936e: 9903         	ldr	r1, [sp, #0xc]
700a9370: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a9374: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a9378: f001 0101    	and	r1, r1, #0x1
700a937c: 2900         	cmp	r1, #0x0
700a937e: bf18         	it	ne
700a9380: f04f 4100    	movne.w	r1, #0x80000000
700a9384: f7f2 ff84    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xd0f8
;             break;
700a9388: e013         	b	0x700a93b2 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x26
;             CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_RXCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a938a: 9805         	ldr	r0, [sp, #0x14]
700a938c: 6980         	ldr	r0, [r0, #0x18]
700a938e: 9903         	ldr	r1, [sp, #0xc]
700a9390: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a9394: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a9398: f001 0101    	and	r1, r1, #0x1
700a939c: 2900         	cmp	r1, #0x0
700a939e: bf18         	it	ne
700a93a0: f04f 4100    	movne.w	r1, #0x80000000
700a93a4: f7f2 ff74    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xd118
;             break;
700a93a8: e003         	b	0x700a93b2 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x6
700a93aa: f06f 0001    	mvn	r0, #0x1
;             retVal = CSL_EBADARGS;
700a93ae: 9001         	str	r0, [sp, #0x4]
;             break;
700a93b0: e7ff         	b	0x700a93b2 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #-0x2
;     return retVal;
700a93b2: 9801         	ldr	r0, [sp, #0x4]
700a93b4: b006         	add	sp, #0x18
700a93b6: bd80         	pop	{r7, pc}
		...

700a93c0 <Sciclient_pmModuleGetClkStatus>:
; {
700a93c0: b580         	push	{r7, lr}
700a93c2: b096         	sub	sp, #0x58
700a93c4: 9015         	str	r0, [sp, #0x54]
700a93c6: 9114         	str	r1, [sp, #0x50]
700a93c8: 9213         	str	r2, [sp, #0x4c]
700a93ca: 9312         	str	r3, [sp, #0x48]
700a93cc: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a93ce: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a93d0: 9815         	ldr	r0, [sp, #0x54]
700a93d2: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a93d4: 9814         	ldr	r0, [sp, #0x50]
700a93d6: 28ff         	cmp	r0, #0xff
700a93d8: d307         	blo	0x700a93ea <Sciclient_pmModuleGetClkStatus+0x2a> @ imm = #0xe
700a93da: e7ff         	b	0x700a93dc <Sciclient_pmModuleGetClkStatus+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a93dc: 9814         	ldr	r0, [sp, #0x50]
700a93de: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a93e2: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a93e4: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a93e8: e003         	b	0x700a93f2 <Sciclient_pmModuleGetClkStatus+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a93ea: 9814         	ldr	r0, [sp, #0x50]
700a93ec: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a93f0: e7ff         	b	0x700a93f2 <Sciclient_pmModuleGetClkStatus+0x32> @ imm = #-0x2
700a93f2: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_clock_resp response = {{0}};
700a93f4: f8ad 002c    	strh.w	r0, [sp, #0x2c]
700a93f8: 900a         	str	r0, [sp, #0x28]
700a93fa: 9009         	str	r0, [sp, #0x24]
700a93fc: f240 1101    	movw	r1, #0x101
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_CLOCK;
700a9400: f8ad 1010    	strh.w	r1, [sp, #0x10]
700a9404: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a9406: 9105         	str	r1, [sp, #0x14]
700a9408: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a940a: 9106         	str	r1, [sp, #0x18]
700a940c: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a940e: 9107         	str	r1, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a9410: 9912         	ldr	r1, [sp, #0x48]
700a9412: 9108         	str	r1, [sp, #0x20]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9414: 9001         	str	r0, [sp, #0x4]
700a9416: a809         	add	r0, sp, #0x24
;     respParam.pRespPayload    = (uint8_t *) &response;
700a9418: 9002         	str	r0, [sp, #0x8]
700a941a: 200a         	movs	r0, #0xa
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a941c: 9003         	str	r0, [sp, #0xc]
700a941e: a804         	add	r0, sp, #0x10
700a9420: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9422: f7f4 f8e5    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xbe36
700a9426: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a9428: 9811         	ldr	r0, [sp, #0x44]
700a942a: b930         	cbnz	r0, 0x700a943a <Sciclient_pmModuleGetClkStatus+0x7a> @ imm = #0xc
700a942c: e7ff         	b	0x700a942e <Sciclient_pmModuleGetClkStatus+0x6e> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a942e: 9801         	ldr	r0, [sp, #0x4]
700a9430: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9434: 2802         	cmp	r0, #0x2
700a9436: d004         	beq	0x700a9442 <Sciclient_pmModuleGetClkStatus+0x82> @ imm = #0x8
700a9438: e7ff         	b	0x700a943a <Sciclient_pmModuleGetClkStatus+0x7a> @ imm = #-0x2
700a943a: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a943e: 9011         	str	r0, [sp, #0x44]
;     }
700a9440: e7ff         	b	0x700a9442 <Sciclient_pmModuleGetClkStatus+0x82> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a9442: 9811         	ldr	r0, [sp, #0x44]
700a9444: b928         	cbnz	r0, 0x700a9452 <Sciclient_pmModuleGetClkStatus+0x92> @ imm = #0xa
700a9446: e7ff         	b	0x700a9448 <Sciclient_pmModuleGetClkStatus+0x88> @ imm = #-0x2
;         *state = (uint32_t) response.current_state;
700a9448: f89d 002d    	ldrb.w	r0, [sp, #0x2d]
700a944c: 9913         	ldr	r1, [sp, #0x4c]
700a944e: 6008         	str	r0, [r1]
;     }
700a9450: e7ff         	b	0x700a9452 <Sciclient_pmModuleGetClkStatus+0x92> @ imm = #-0x2
;     return retVal;
700a9452: 9811         	ldr	r0, [sp, #0x44]
700a9454: b016         	add	sp, #0x58
700a9456: bd80         	pop	{r7, pc}
		...

700a9460 <xQueueReceiveFromISR>:
; {
700a9460: b580         	push	{r7, lr}
700a9462: b088         	sub	sp, #0x20
700a9464: 9007         	str	r0, [sp, #0x1c]
700a9466: 9106         	str	r1, [sp, #0x18]
700a9468: 9205         	str	r2, [sp, #0x14]
;     Queue_t * const pxQueue = xQueue;
700a946a: 9807         	ldr	r0, [sp, #0x1c]
700a946c: 9002         	str	r0, [sp, #0x8]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a946e: f007 ea78    	blx	0x700b0960 <HwiP_disable> @ imm = #0x74f0
700a9472: 9003         	str	r0, [sp, #0xc]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a9474: 9802         	ldr	r0, [sp, #0x8]
700a9476: 6b80         	ldr	r0, [r0, #0x38]
700a9478: 9001         	str	r0, [sp, #0x4]
;         if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a947a: 9801         	ldr	r0, [sp, #0x4]
700a947c: b398         	cbz	r0, 0x700a94e6 <xQueueReceiveFromISR+0x86> @ imm = #0x66
700a947e: e7ff         	b	0x700a9480 <xQueueReceiveFromISR+0x20> @ imm = #-0x2
;             const int8_t cRxLock = pxQueue->cRxLock;
700a9480: 9802         	ldr	r0, [sp, #0x8]
700a9482: f890 0044    	ldrb.w	r0, [r0, #0x44]
700a9486: f88d 0003    	strb.w	r0, [sp, #0x3]
;             prvCopyDataFromQueue( pxQueue, pvBuffer );
700a948a: 9802         	ldr	r0, [sp, #0x8]
700a948c: 9906         	ldr	r1, [sp, #0x18]
700a948e: f004 fb77    	bl	0x700adb80 <prvCopyDataFromQueue> @ imm = #0x46ee
;             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
700a9492: 9801         	ldr	r0, [sp, #0x4]
700a9494: 3801         	subs	r0, #0x1
700a9496: 9902         	ldr	r1, [sp, #0x8]
700a9498: 6388         	str	r0, [r1, #0x38]
;             if( cRxLock == queueUNLOCKED )
700a949a: f99d 0003    	ldrsb.w	r0, [sp, #0x3]
700a949e: 3001         	adds	r0, #0x1
700a94a0: b9b8         	cbnz	r0, 0x700a94d2 <xQueueReceiveFromISR+0x72> @ imm = #0x2e
700a94a2: e7ff         	b	0x700a94a4 <xQueueReceiveFromISR+0x44> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a94a4: 9802         	ldr	r0, [sp, #0x8]
700a94a6: 6900         	ldr	r0, [r0, #0x10]
700a94a8: b188         	cbz	r0, 0x700a94ce <xQueueReceiveFromISR+0x6e> @ imm = #0x22
700a94aa: e7ff         	b	0x700a94ac <xQueueReceiveFromISR+0x4c> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a94ac: 9802         	ldr	r0, [sp, #0x8]
700a94ae: 3010         	adds	r0, #0x10
700a94b0: f7fe fb2e    	bl	0x700a7b10 <xTaskRemoveFromEventList> @ imm = #-0x19a4
700a94b4: b148         	cbz	r0, 0x700a94ca <xQueueReceiveFromISR+0x6a> @ imm = #0x12
700a94b6: e7ff         	b	0x700a94b8 <xQueueReceiveFromISR+0x58> @ imm = #-0x2
;                         if( pxHigherPriorityTaskWoken != NULL )
700a94b8: 9805         	ldr	r0, [sp, #0x14]
700a94ba: b120         	cbz	r0, 0x700a94c6 <xQueueReceiveFromISR+0x66> @ imm = #0x8
700a94bc: e7ff         	b	0x700a94be <xQueueReceiveFromISR+0x5e> @ imm = #-0x2
;                             *pxHigherPriorityTaskWoken = pdTRUE;
700a94be: 9905         	ldr	r1, [sp, #0x14]
700a94c0: 2001         	movs	r0, #0x1
700a94c2: 6008         	str	r0, [r1]
;                         }
700a94c4: e000         	b	0x700a94c8 <xQueueReceiveFromISR+0x68> @ imm = #0x0
700a94c6: e7ff         	b	0x700a94c8 <xQueueReceiveFromISR+0x68> @ imm = #-0x2
;                     }
700a94c8: e000         	b	0x700a94cc <xQueueReceiveFromISR+0x6c> @ imm = #0x0
700a94ca: e7ff         	b	0x700a94cc <xQueueReceiveFromISR+0x6c> @ imm = #-0x2
;                 }
700a94cc: e000         	b	0x700a94d0 <xQueueReceiveFromISR+0x70> @ imm = #0x0
700a94ce: e7ff         	b	0x700a94d0 <xQueueReceiveFromISR+0x70> @ imm = #-0x2
;             }
700a94d0: e006         	b	0x700a94e0 <xQueueReceiveFromISR+0x80> @ imm = #0xc
;                 pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
700a94d2: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a94d6: 3001         	adds	r0, #0x1
700a94d8: 9902         	ldr	r1, [sp, #0x8]
700a94da: f881 0044    	strb.w	r0, [r1, #0x44]
700a94de: e7ff         	b	0x700a94e0 <xQueueReceiveFromISR+0x80> @ imm = #-0x2
700a94e0: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a94e2: 9004         	str	r0, [sp, #0x10]
;         }
700a94e4: e002         	b	0x700a94ec <xQueueReceiveFromISR+0x8c> @ imm = #0x4
700a94e6: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
700a94e8: 9004         	str	r0, [sp, #0x10]
700a94ea: e7ff         	b	0x700a94ec <xQueueReceiveFromISR+0x8c> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a94ec: 9803         	ldr	r0, [sp, #0xc]
700a94ee: f007 ea58    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x74b0
;     return xReturn;
700a94f2: 9804         	ldr	r0, [sp, #0x10]
700a94f4: b008         	add	sp, #0x20
700a94f6: bd80         	pop	{r7, pc}
		...

700a9500 <xTaskCreate>:
;     UBaseType_t uxPriority, TaskHandle_t *const pxCreatedTask) {
700a9500: b570         	push	{r4, r5, r6, lr}
700a9502: b08c         	sub	sp, #0x30
700a9504: f8dd c044    	ldr.w	r12, [sp, #0x44]
700a9508: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a950c: 900b         	str	r0, [sp, #0x2c]
700a950e: 910a         	str	r1, [sp, #0x28]
700a9510: 9209         	str	r2, [sp, #0x24]
700a9512: 9308         	str	r3, [sp, #0x20]
;         (((size_t)usStackDepth) *
700a9514: 9809         	ldr	r0, [sp, #0x24]
700a9516: 0080         	lsls	r0, r0, #0x2
;     pxStack = (StackType_t *)pvPortMalloc(
700a9518: f006 f84a    	bl	0x700af5b0 <pvPortMalloc> @ imm = #0x6094
700a951c: 9005         	str	r0, [sp, #0x14]
;     if (pxStack != NULL) {
700a951e: 9805         	ldr	r0, [sp, #0x14]
700a9520: b180         	cbz	r0, 0x700a9544 <xTaskCreate+0x44> @ imm = #0x20
700a9522: e7ff         	b	0x700a9524 <xTaskCreate+0x24> @ imm = #-0x2
700a9524: 2088         	movs	r0, #0x88
;       pxNewTCB = (TCB_t *)pvPortMalloc(
700a9526: f006 f843    	bl	0x700af5b0 <pvPortMalloc> @ imm = #0x6086
700a952a: 9007         	str	r0, [sp, #0x1c]
;       if (pxNewTCB != NULL) {
700a952c: 9807         	ldr	r0, [sp, #0x1c]
700a952e: b120         	cbz	r0, 0x700a953a <xTaskCreate+0x3a> @ imm = #0x8
700a9530: e7ff         	b	0x700a9532 <xTaskCreate+0x32> @ imm = #-0x2
;         pxNewTCB->pxStack = pxStack;
700a9532: 9805         	ldr	r0, [sp, #0x14]
700a9534: 9907         	ldr	r1, [sp, #0x1c]
700a9536: 6308         	str	r0, [r1, #0x30]
;       } else {
700a9538: e003         	b	0x700a9542 <xTaskCreate+0x42> @ imm = #0x6
;         vPortFree(pxStack);
700a953a: 9805         	ldr	r0, [sp, #0x14]
700a953c: f005 ff38    	bl	0x700af3b0 <vPortFree>  @ imm = #0x5e70
700a9540: e7ff         	b	0x700a9542 <xTaskCreate+0x42> @ imm = #-0x2
;     } else {
700a9542: e002         	b	0x700a954a <xTaskCreate+0x4a> @ imm = #0x4
700a9544: 2000         	movs	r0, #0x0
;       pxNewTCB = NULL;
700a9546: 9007         	str	r0, [sp, #0x1c]
700a9548: e7ff         	b	0x700a954a <xTaskCreate+0x4a> @ imm = #-0x2
;   if (pxNewTCB != NULL) {
700a954a: 9807         	ldr	r0, [sp, #0x1c]
700a954c: b1e8         	cbz	r0, 0x700a958a <xTaskCreate+0x8a> @ imm = #0x3a
700a954e: e7ff         	b	0x700a9550 <xTaskCreate+0x50> @ imm = #-0x2
;       pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
700a9550: 9807         	ldr	r0, [sp, #0x1c]
700a9552: 2600         	movs	r6, #0x0
700a9554: f880 6081    	strb.w	r6, [r0, #0x81]
;     prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth,
700a9558: 980b         	ldr	r0, [sp, #0x2c]
700a955a: 990a         	ldr	r1, [sp, #0x28]
700a955c: 9a09         	ldr	r2, [sp, #0x24]
;                          pvParameters, uxPriority, pxCreatedTask, pxNewTCB,
700a955e: 9b08         	ldr	r3, [sp, #0x20]
700a9560: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a9564: 9c11         	ldr	r4, [sp, #0x44]
700a9566: 9d07         	ldr	r5, [sp, #0x1c]
;     prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth,
700a9568: 46ee         	mov	lr, sp
700a956a: f8ce 600c    	str.w	r6, [lr, #0xc]
700a956e: f8ce 5008    	str.w	r5, [lr, #0x8]
700a9572: f8ce 4004    	str.w	r4, [lr, #0x4]
700a9576: f8ce c000    	str.w	r12, [lr]
700a957a: f7fb fc19    	bl	0x700a4db0 <prvInitialiseNewTask> @ imm = #-0x47ce
;     prvAddNewTaskToReadyList(pxNewTCB);
700a957e: 9807         	ldr	r0, [sp, #0x1c]
700a9580: f7fb fdb6    	bl	0x700a50f0 <prvAddNewTaskToReadyList> @ imm = #-0x4494
700a9584: 2001         	movs	r0, #0x1
;     xReturn = pdPASS;
700a9586: 9006         	str	r0, [sp, #0x18]
;   } else {
700a9588: e003         	b	0x700a9592 <xTaskCreate+0x92> @ imm = #0x6
700a958a: f04f 30ff    	mov.w	r0, #0xffffffff
;     xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
700a958e: 9006         	str	r0, [sp, #0x18]
700a9590: e7ff         	b	0x700a9592 <xTaskCreate+0x92> @ imm = #-0x2
;   return xReturn;
700a9592: 9806         	ldr	r0, [sp, #0x18]
700a9594: b00c         	add	sp, #0x30
700a9596: bd70         	pop	{r4, r5, r6, pc}
		...

700a95a0 <PMU_profileStart>:
; int32_t PMU_profileStart(const char *name) {
700a95a0: b580         	push	{r7, lr}
700a95a2: b088         	sub	sp, #0x20
700a95a4: 9006         	str	r0, [sp, #0x18]
;   if (gProfileObject.logIndex >= PMU_MAX_LOG_ENTRIES) {
700a95a6: f243 0080    	movw	r0, #0x3080
700a95aa: f2c7 0008    	movt	r0, #0x7008
700a95ae: 6800         	ldr	r0, [r0]
700a95b0: 2840         	cmp	r0, #0x40
700a95b2: d304         	blo	0x700a95be <PMU_profileStart+0x1e> @ imm = #0x8
700a95b4: e7ff         	b	0x700a95b6 <PMU_profileStart+0x16> @ imm = #-0x2
700a95b6: f04f 30ff    	mov.w	r0, #0xffffffff
;     return SystemP_FAILURE; /* Log is full */
700a95ba: 9007         	str	r0, [sp, #0x1c]
700a95bc: e038         	b	0x700a9630 <PMU_profileStart+0x90> @ imm = #0x70
;   uint32_t i = gProfileObject.logIndex;
700a95be: f243 0280    	movw	r2, #0x3080
700a95c2: f2c7 0208    	movt	r2, #0x7008
700a95c6: 6810         	ldr	r0, [r2]
700a95c8: 9005         	str	r0, [sp, #0x14]
;   uint32_t numEvents = gProfileObject.numEvents;
700a95ca: 6890         	ldr	r0, [r2, #0x8]
700a95cc: 9003         	str	r0, [sp, #0xc]
;   uint32_t bCCnt = gProfileObject.bCycleCounter;
700a95ce: 6850         	ldr	r0, [r2, #0x4]
700a95d0: 9002         	str	r0, [sp, #0x8]
;   PMU_ProfilePoint *p = &gProfileObject.point[i];
700a95d2: 9805         	ldr	r0, [sp, #0x14]
700a95d4: 2134         	movs	r1, #0x34
700a95d6: fb00 2001    	mla	r0, r0, r1, r2
700a95da: 300c         	adds	r0, #0xc
700a95dc: 9001         	str	r0, [sp, #0x4]
;   p->name = name;
700a95de: 9806         	ldr	r0, [sp, #0x18]
700a95e0: 9901         	ldr	r1, [sp, #0x4]
700a95e2: 6308         	str	r0, [r1, #0x30]
;   PMU_resetCounters();
700a95e4: f006 fb44    	bl	0x700afc70 <PMU_resetCounters> @ imm = #0x6688
;   if (bCCnt == TRUE) {
700a95e8: 9802         	ldr	r0, [sp, #0x8]
700a95ea: 2801         	cmp	r0, #0x1
700a95ec: d106         	bne	0x700a95fc <PMU_profileStart+0x5c> @ imm = #0xc
700a95ee: e7ff         	b	0x700a95f0 <PMU_profileStart+0x50> @ imm = #-0x2
700a95f0: 201f         	movs	r0, #0x1f
;         CSL_armR5PmuReadCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM);
700a95f2: f7f8 ee14    	blx	0x700a221c <CSL_armR5PmuReadCntr> @ imm = #-0x73d8
;     p->cycleCount.value =
700a95f6: 9901         	ldr	r1, [sp, #0x4]
700a95f8: 62c8         	str	r0, [r1, #0x2c]
;   }
700a95fa: e7ff         	b	0x700a95fc <PMU_profileStart+0x5c> @ imm = #-0x2
700a95fc: 2000         	movs	r0, #0x0
;   for (j = 0; j < numEvents; j++) {
700a95fe: 9004         	str	r0, [sp, #0x10]
700a9600: e7ff         	b	0x700a9602 <PMU_profileStart+0x62> @ imm = #-0x2
700a9602: 9804         	ldr	r0, [sp, #0x10]
700a9604: 9903         	ldr	r1, [sp, #0xc]
700a9606: 4288         	cmp	r0, r1
700a9608: d20f         	bhs	0x700a962a <PMU_profileStart+0x8a> @ imm = #0x1e
700a960a: e7ff         	b	0x700a960c <PMU_profileStart+0x6c> @ imm = #-0x2
;     p->events[j].value = CSL_armR5PmuReadCntr(j);
700a960c: 9804         	ldr	r0, [sp, #0x10]
700a960e: f7f8 ee06    	blx	0x700a221c <CSL_armR5PmuReadCntr> @ imm = #-0x73f4
700a9612: 9901         	ldr	r1, [sp, #0x4]
700a9614: 9a04         	ldr	r2, [sp, #0x10]
700a9616: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a961a: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a961e: 6088         	str	r0, [r1, #0x8]
;   }
700a9620: e7ff         	b	0x700a9622 <PMU_profileStart+0x82> @ imm = #-0x2
;   for (j = 0; j < numEvents; j++) {
700a9622: 9804         	ldr	r0, [sp, #0x10]
700a9624: 3001         	adds	r0, #0x1
700a9626: 9004         	str	r0, [sp, #0x10]
700a9628: e7eb         	b	0x700a9602 <PMU_profileStart+0x62> @ imm = #-0x2a
700a962a: 2000         	movs	r0, #0x0
;   return SystemP_SUCCESS;
700a962c: 9007         	str	r0, [sp, #0x1c]
700a962e: e7ff         	b	0x700a9630 <PMU_profileStart+0x90> @ imm = #-0x2
; }
700a9630: 9807         	ldr	r0, [sp, #0x1c]
700a9632: b008         	add	sp, #0x20
700a9634: bd80         	pop	{r7, pc}
		...
700a963e: 0000         	movs	r0, r0

700a9640 <Sciclient_init>:
; {
700a9640: b580         	push	{r7, lr}
700a9642: b086         	sub	sp, #0x18
700a9644: 9005         	str	r0, [sp, #0x14]
700a9646: 2100         	movs	r1, #0x0
;     int32_t   status = SystemP_SUCCESS;
700a9648: 9101         	str	r1, [sp, #0x4]
700a964a: 9104         	str	r1, [sp, #0x10]
;         = (CSL_sec_proxyRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyRegs);
700a964c: f642 00d0    	movw	r0, #0x28d0
700a9650: f2c7 000b    	movt	r0, #0x700b
700a9654: 9002         	str	r0, [sp, #0x8]
700a9656: 6800         	ldr	r0, [r0]
700a9658: f7fc fae2    	bl	0x700a5c20 <AddrTranslateP_getLocalAddr> @ imm = #-0x3a3c
700a965c: 9901         	ldr	r1, [sp, #0x4]
700a965e: 4602         	mov	r2, r0
700a9660: 9802         	ldr	r0, [sp, #0x8]
700a9662: 6002         	str	r2, [r0]
;         = (CSL_sec_proxy_scfgRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyScfgRegs);
700a9664: 6840         	ldr	r0, [r0, #0x4]
700a9666: f7fc fadb    	bl	0x700a5c20 <AddrTranslateP_getLocalAddr> @ imm = #-0x3a4a
700a966a: 9901         	ldr	r1, [sp, #0x4]
700a966c: 4602         	mov	r2, r0
700a966e: 9802         	ldr	r0, [sp, #0x8]
700a9670: 6042         	str	r2, [r0, #0x4]
;         = (CSL_sec_proxy_rtRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyRtRegs);
700a9672: 6880         	ldr	r0, [r0, #0x8]
700a9674: f7fc fad4    	bl	0x700a5c20 <AddrTranslateP_getLocalAddr> @ imm = #-0x3a58
700a9678: 9902         	ldr	r1, [sp, #0x8]
700a967a: 6088         	str	r0, [r1, #0x8]
;         = (uint64_t)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.proxyTargetAddr);
700a967c: 6908         	ldr	r0, [r1, #0x10]
700a967e: 6949         	ldr	r1, [r1, #0x14]
700a9680: f7fc face    	bl	0x700a5c20 <AddrTranslateP_getLocalAddr> @ imm = #-0x3a64
700a9684: 9a02         	ldr	r2, [sp, #0x8]
700a9686: 4601         	mov	r1, r0
700a9688: 9801         	ldr	r0, [sp, #0x4]
700a968a: 6150         	str	r0, [r2, #0x14]
700a968c: 6111         	str	r1, [r2, #0x10]
;     gSciclientHandle.currSeqId = 0;
700a968e: f642 1158    	movw	r1, #0x2958
700a9692: f2c7 010b    	movt	r1, #0x700b
700a9696: 9103         	str	r1, [sp, #0xc]
700a9698: 6008         	str	r0, [r1]
;     gSciclientHandle.coreId = coreId;
700a969a: 9805         	ldr	r0, [sp, #0x14]
700a969c: 6048         	str	r0, [r1, #0x4]
;     gSciclientHandle.devIdCore = Sciclient_getDevId(coreId);
700a969e: 9805         	ldr	r0, [sp, #0x14]
700a96a0: f003 ff06    	bl	0x700ad4b0 <Sciclient_getDevId> @ imm = #0x3e0c
700a96a4: 9a03         	ldr	r2, [sp, #0xc]
700a96a6: 4601         	mov	r1, r0
700a96a8: 9801         	ldr	r0, [sp, #0x4]
700a96aa: 6091         	str	r1, [r2, #0x8]
;     gSciclientHandle.secureContextId = Sciclient_getContext(SCICLIENT_SECURE_CONTEXT, coreId);
700a96ac: 9905         	ldr	r1, [sp, #0x14]
700a96ae: f7ff fb17    	bl	0x700a8ce0 <Sciclient_getContext> @ imm = #-0x9d2
700a96b2: 9903         	ldr	r1, [sp, #0xc]
700a96b4: 60c8         	str	r0, [r1, #0xc]
;     gSciclientHandle.nonSecureContextId = Sciclient_getContext(SCICLIENT_NON_SECURE_CONTEXT, coreId);
700a96b6: 9905         	ldr	r1, [sp, #0x14]
700a96b8: 2001         	movs	r0, #0x1
700a96ba: f7ff fb11    	bl	0x700a8ce0 <Sciclient_getContext> @ imm = #-0x9de
700a96be: 9a03         	ldr	r2, [sp, #0xc]
700a96c0: 4601         	mov	r1, r0
700a96c2: 9802         	ldr	r0, [sp, #0x8]
700a96c4: 6111         	str	r1, [r2, #0x10]
;     gSciclientHandle.maxMsgSizeBytes = CSL_secProxyGetMaxMsgSize(&gSciclientSecProxyCfg) -
700a96c6: f005 f913    	bl	0x700ae8f0 <CSL_secProxyGetMaxMsgSize> @ imm = #0x5226
700a96ca: 9903         	ldr	r1, [sp, #0xc]
700a96cc: 3804         	subs	r0, #0x4
700a96ce: 6148         	str	r0, [r1, #0x14]
;     return status;
700a96d0: 9804         	ldr	r0, [sp, #0x10]
700a96d2: b006         	add	sp, #0x18
700a96d4: bd80         	pop	{r7, pc}
		...
700a96de: 0000         	movs	r0, r0

700a96e0 <UART_subConfigTCRTLRModeEn>:
; {
700a96e0: b580         	push	{r7, lr}
700a96e2: b088         	sub	sp, #0x20
700a96e4: 9007         	str	r0, [sp, #0x1c]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a96e6: 9807         	ldr	r0, [sp, #0x1c]
700a96e8: 21bf         	movs	r1, #0xbf
700a96ea: 9101         	str	r1, [sp, #0x4]
700a96ec: f003 f850    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #0x30a0
700a96f0: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a96f2: 9807         	ldr	r0, [sp, #0x1c]
700a96f4: 3008         	adds	r0, #0x8
700a96f6: 2110         	movs	r1, #0x10
700a96f8: 9102         	str	r1, [sp, #0x8]
700a96fa: 2204         	movs	r2, #0x4
700a96fc: 9203         	str	r2, [sp, #0xc]
700a96fe: f005 fe27    	bl	0x700af350 <HW_RD_FIELD32_RAW> @ imm = #0x5c4e
700a9702: 9902         	ldr	r1, [sp, #0x8]
700a9704: 9a03         	ldr	r2, [sp, #0xc]
700a9706: 9006         	str	r0, [sp, #0x18]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a9708: 9807         	ldr	r0, [sp, #0x1c]
700a970a: 3008         	adds	r0, #0x8
700a970c: 2301         	movs	r3, #0x1
700a970e: 9300         	str	r3, [sp]
700a9710: f004 ffd6    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x4fac
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a9714: 9807         	ldr	r0, [sp, #0x1c]
700a9716: 300c         	adds	r0, #0xc
700a9718: 9904         	ldr	r1, [sp, #0x10]
700a971a: f006 fa39    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x6472
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700a971e: 9807         	ldr	r0, [sp, #0x1c]
700a9720: 2180         	movs	r1, #0x80
700a9722: f003 f835    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #0x306a
700a9726: 9004         	str	r0, [sp, #0x10]
;     tcrTlrValue = HW_RD_REG32(baseAddr + UART_MCR) & UART_MCR_TCR_TLR_MASK;
700a9728: 9807         	ldr	r0, [sp, #0x1c]
700a972a: 3010         	adds	r0, #0x10
700a972c: f006 fa28    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x6450
700a9730: 9b00         	ldr	r3, [sp]
700a9732: f000 0040    	and	r0, r0, #0x40
700a9736: 9005         	str	r0, [sp, #0x14]
;     HW_WR_FIELD32(baseAddr + UART_MCR, UART_MCR_TCR_TLR,
700a9738: 9807         	ldr	r0, [sp, #0x1c]
700a973a: 3010         	adds	r0, #0x10
700a973c: 2140         	movs	r1, #0x40
700a973e: 2206         	movs	r2, #0x6
700a9740: f004 ffbe    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x4f7c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a9744: 9807         	ldr	r0, [sp, #0x1c]
700a9746: 300c         	adds	r0, #0xc
700a9748: 9904         	ldr	r1, [sp, #0x10]
700a974a: f006 fa21    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x6442
700a974e: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a9750: 9807         	ldr	r0, [sp, #0x1c]
700a9752: f003 f81d    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #0x303a
700a9756: 9902         	ldr	r1, [sp, #0x8]
700a9758: 9a03         	ldr	r2, [sp, #0xc]
700a975a: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a975c: 9807         	ldr	r0, [sp, #0x1c]
700a975e: 3008         	adds	r0, #0x8
700a9760: 9b06         	ldr	r3, [sp, #0x18]
700a9762: f004 ffad    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x4f5a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a9766: 9807         	ldr	r0, [sp, #0x1c]
700a9768: 300c         	adds	r0, #0xc
700a976a: 9904         	ldr	r1, [sp, #0x10]
700a976c: f006 fa10    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x6420
;     return tcrTlrValue;
700a9770: 9805         	ldr	r0, [sp, #0x14]
700a9772: b008         	add	sp, #0x20
700a9774: bd80         	pop	{r7, pc}
		...
700a977e: 0000         	movs	r0, r0

700a9780 <UART_udmaIsrRx>:
; {
700a9780: b580         	push	{r7, lr}
700a9782: b08a         	sub	sp, #0x28
700a9784: 9009         	str	r0, [sp, #0x24]
700a9786: 9108         	str	r1, [sp, #0x20]
700a9788: 9207         	str	r2, [sp, #0x1c]
;     if(NULL != args)
700a978a: 9807         	ldr	r0, [sp, #0x1c]
700a978c: 2800         	cmp	r0, #0x0
700a978e: d040         	beq	0x700a9812 <UART_udmaIsrRx+0x92> @ imm = #0x80
700a9790: e7ff         	b	0x700a9792 <UART_udmaIsrRx+0x12> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a9792: 9807         	ldr	r0, [sp, #0x1c]
700a9794: 9000         	str	r0, [sp]
;         udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a9796: 9800         	ldr	r0, [sp]
700a9798: 6840         	ldr	r0, [r0, #0x4]
700a979a: 6cc0         	ldr	r0, [r0, #0x4c]
700a979c: 9001         	str	r0, [sp, #0x4]
;         rxChHandle  = udmaChCfg->rxChHandle;
700a979e: 9801         	ldr	r0, [sp, #0x4]
700a97a0: 6880         	ldr	r0, [r0, #0x8]
700a97a2: 9002         	str	r0, [sp, #0x8]
;         if (eventType == UDMA_EVENT_TYPE_DMA_COMPLETION)
700a97a4: 9808         	ldr	r0, [sp, #0x20]
700a97a6: 2801         	cmp	r0, #0x1
700a97a8: d12e         	bne	0x700a9808 <UART_udmaIsrRx+0x88> @ imm = #0x5c
700a97aa: e7ff         	b	0x700a97ac <UART_udmaIsrRx+0x2c> @ imm = #-0x2
;             CacheP_inv(udmaChCfg->rxHpdMem, udmaChCfg->hpdMemSize, CacheP_TYPE_ALLD);
700a97ac: 9901         	ldr	r1, [sp, #0x4]
700a97ae: 6988         	ldr	r0, [r1, #0x18]
700a97b0: 69c9         	ldr	r1, [r1, #0x1c]
700a97b2: 220a         	movs	r2, #0xa
700a97b4: f007 fb64    	bl	0x700b0e80 <CacheP_inv> @ imm = #0x76c8
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(rxChHandle), &pDesc);
700a97b8: 9802         	ldr	r0, [sp, #0x8]
700a97ba: f001 fc29    	bl	0x700ab010 <Udma_chGetCqRingHandle> @ imm = #0x1852
700a97be: a904         	add	r1, sp, #0x10
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(rxChHandle), &pDesc);
700a97c0: f000 f8ce    	bl	0x700a9960 <Udma_ringDequeueRaw> @ imm = #0x19c
700a97c4: 9006         	str	r0, [sp, #0x18]
;             if ((retVal == UDMA_SOK) && (pDesc != 0UL))
700a97c6: 9806         	ldr	r0, [sp, #0x18]
700a97c8: b988         	cbnz	r0, 0x700a97ee <UART_udmaIsrRx+0x6e> @ imm = #0x22
700a97ca: e7ff         	b	0x700a97cc <UART_udmaIsrRx+0x4c> @ imm = #-0x2
700a97cc: 9804         	ldr	r0, [sp, #0x10]
700a97ce: 9905         	ldr	r1, [sp, #0x14]
700a97d0: 4308         	orrs	r0, r1
700a97d2: b160         	cbz	r0, 0x700a97ee <UART_udmaIsrRx+0x6e> @ imm = #0x18
700a97d4: e7ff         	b	0x700a97d6 <UART_udmaIsrRx+0x56> @ imm = #-0x2
;                 pHpd = (CSL_UdmapCppi5HMPD *)(uintptr_t)pDesc;
700a97d6: 9804         	ldr	r0, [sp, #0x10]
700a97d8: 9003         	str	r0, [sp, #0xc]
;                 hUart->readTrans.count = (pHpd->descInfo & CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_MASK) >> CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_SHIFT;
700a97da: 9803         	ldr	r0, [sp, #0xc]
700a97dc: 6800         	ldr	r0, [r0]
700a97de: f36f 509f    	bfc	r0, #22, #10
700a97e2: 9900         	ldr	r1, [sp]
700a97e4: 62c8         	str	r0, [r1, #0x2c]
;                 hUart->readTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a97e6: 9900         	ldr	r1, [sp]
700a97e8: 2000         	movs	r0, #0x0
700a97ea: 6348         	str	r0, [r1, #0x34]
;             }
700a97ec: e003         	b	0x700a97f6 <UART_udmaIsrRx+0x76> @ imm = #0x6
;                 hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a97ee: 9900         	ldr	r1, [sp]
700a97f0: 200a         	movs	r0, #0xa
700a97f2: 6348         	str	r0, [r1, #0x34]
700a97f4: e7ff         	b	0x700a97f6 <UART_udmaIsrRx+0x76> @ imm = #-0x2
;             hUart->hUartInit->readCompleteCallbackFxn(hUart);
700a97f6: 9800         	ldr	r0, [sp]
700a97f8: 6841         	ldr	r1, [r0, #0x4]
700a97fa: 6dc9         	ldr	r1, [r1, #0x5c]
700a97fc: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->readTrans);
700a97fe: 9800         	ldr	r0, [sp]
700a9800: 3028         	adds	r0, #0x28
700a9802: f005 fe45    	bl	0x700af490 <UART_lld_Transaction_deInit> @ imm = #0x5c8a
;         }
700a9806: e003         	b	0x700a9810 <UART_udmaIsrRx+0x90> @ imm = #0x6
;             hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a9808: 9900         	ldr	r1, [sp]
700a980a: 200a         	movs	r0, #0xa
700a980c: 6488         	str	r0, [r1, #0x48]
700a980e: e7ff         	b	0x700a9810 <UART_udmaIsrRx+0x90> @ imm = #-0x2
;     }
700a9810: e7ff         	b	0x700a9812 <UART_udmaIsrRx+0x92> @ imm = #-0x2
;     return;
700a9812: b00a         	add	sp, #0x28
700a9814: bd80         	pop	{r7, pc}
		...
700a981e: 0000         	movs	r0, r0

700a9820 <UART_udmaIsrTx>:
; {
700a9820: b580         	push	{r7, lr}
700a9822: b08a         	sub	sp, #0x28
700a9824: 9009         	str	r0, [sp, #0x24]
700a9826: 9108         	str	r1, [sp, #0x20]
700a9828: 9207         	str	r2, [sp, #0x1c]
;     if(NULL != args)
700a982a: 9807         	ldr	r0, [sp, #0x1c]
700a982c: 2800         	cmp	r0, #0x0
700a982e: d040         	beq	0x700a98b2 <UART_udmaIsrTx+0x92> @ imm = #0x80
700a9830: e7ff         	b	0x700a9832 <UART_udmaIsrTx+0x12> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a9832: 9807         	ldr	r0, [sp, #0x1c]
700a9834: 9000         	str	r0, [sp]
;         udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a9836: 9800         	ldr	r0, [sp]
700a9838: 6840         	ldr	r0, [r0, #0x4]
700a983a: 6cc0         	ldr	r0, [r0, #0x4c]
700a983c: 9001         	str	r0, [sp, #0x4]
;         txChHandle  = udmaChCfg->txChHandle;
700a983e: 9801         	ldr	r0, [sp, #0x4]
700a9840: 6840         	ldr	r0, [r0, #0x4]
700a9842: 9002         	str	r0, [sp, #0x8]
;         if (eventType == UDMA_EVENT_TYPE_DMA_COMPLETION)
700a9844: 9808         	ldr	r0, [sp, #0x20]
700a9846: 2801         	cmp	r0, #0x1
700a9848: d12e         	bne	0x700a98a8 <UART_udmaIsrTx+0x88> @ imm = #0x5c
700a984a: e7ff         	b	0x700a984c <UART_udmaIsrTx+0x2c> @ imm = #-0x2
;             CacheP_inv(udmaChCfg->txHpdMem, udmaChCfg->hpdMemSize, CacheP_TYPE_ALLD);
700a984c: 9901         	ldr	r1, [sp, #0x4]
700a984e: 6948         	ldr	r0, [r1, #0x14]
700a9850: 69c9         	ldr	r1, [r1, #0x1c]
700a9852: 220a         	movs	r2, #0xa
700a9854: f007 fb14    	bl	0x700b0e80 <CacheP_inv> @ imm = #0x7628
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(txChHandle), &pDesc);
700a9858: 9802         	ldr	r0, [sp, #0x8]
700a985a: f001 fbd9    	bl	0x700ab010 <Udma_chGetCqRingHandle> @ imm = #0x17b2
700a985e: a904         	add	r1, sp, #0x10
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(txChHandle), &pDesc);
700a9860: f000 f87e    	bl	0x700a9960 <Udma_ringDequeueRaw> @ imm = #0xfc
700a9864: 9006         	str	r0, [sp, #0x18]
;             if ((retVal == UDMA_SOK) && (pDesc != 0UL))
700a9866: 9806         	ldr	r0, [sp, #0x18]
700a9868: b988         	cbnz	r0, 0x700a988e <UART_udmaIsrTx+0x6e> @ imm = #0x22
700a986a: e7ff         	b	0x700a986c <UART_udmaIsrTx+0x4c> @ imm = #-0x2
700a986c: 9804         	ldr	r0, [sp, #0x10]
700a986e: 9905         	ldr	r1, [sp, #0x14]
700a9870: 4308         	orrs	r0, r1
700a9872: b160         	cbz	r0, 0x700a988e <UART_udmaIsrTx+0x6e> @ imm = #0x18
700a9874: e7ff         	b	0x700a9876 <UART_udmaIsrTx+0x56> @ imm = #-0x2
;                 pHpd = (CSL_UdmapCppi5HMPD *)(uintptr_t)pDesc;
700a9876: 9804         	ldr	r0, [sp, #0x10]
700a9878: 9003         	str	r0, [sp, #0xc]
;                 hUart->writeTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a987a: 9900         	ldr	r1, [sp]
700a987c: 2000         	movs	r0, #0x0
700a987e: 6488         	str	r0, [r1, #0x48]
;                 hUart->writeTrans.count = (pHpd->descInfo & CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_MASK) >> CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_SHIFT;
700a9880: 9803         	ldr	r0, [sp, #0xc]
700a9882: 6800         	ldr	r0, [r0]
700a9884: f36f 509f    	bfc	r0, #22, #10
700a9888: 9900         	ldr	r1, [sp]
700a988a: 6408         	str	r0, [r1, #0x40]
;             }
700a988c: e003         	b	0x700a9896 <UART_udmaIsrTx+0x76> @ imm = #0x6
;                 hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a988e: 9900         	ldr	r1, [sp]
700a9890: 200a         	movs	r0, #0xa
700a9892: 6488         	str	r0, [r1, #0x48]
700a9894: e7ff         	b	0x700a9896 <UART_udmaIsrTx+0x76> @ imm = #-0x2
;             hUart->hUartInit->writeCompleteCallbackFxn(hUart);
700a9896: 9800         	ldr	r0, [sp]
700a9898: 6841         	ldr	r1, [r0, #0x4]
700a989a: 6e09         	ldr	r1, [r1, #0x60]
700a989c: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a989e: 9800         	ldr	r0, [sp]
700a98a0: 303c         	adds	r0, #0x3c
700a98a2: f005 fdf5    	bl	0x700af490 <UART_lld_Transaction_deInit> @ imm = #0x5bea
;         }
700a98a6: e003         	b	0x700a98b0 <UART_udmaIsrTx+0x90> @ imm = #0x6
;             hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a98a8: 9900         	ldr	r1, [sp]
700a98aa: 200a         	movs	r0, #0xa
700a98ac: 6488         	str	r0, [r1, #0x48]
700a98ae: e7ff         	b	0x700a98b0 <UART_udmaIsrTx+0x90> @ imm = #-0x2
;     }
700a98b0: e7ff         	b	0x700a98b2 <UART_udmaIsrTx+0x92> @ imm = #-0x2
;     return;
700a98b2: b00a         	add	sp, #0x28
700a98b4: bd80         	pop	{r7, pc}
		...
700a98be: 0000         	movs	r0, r0

700a98c0 <UdmaFlowPrms_init>:
; {
700a98c0: b084         	sub	sp, #0x10
700a98c2: 9003         	str	r0, [sp, #0xc]
700a98c4: 9102         	str	r1, [sp, #0x8]
;     if(NULL_PTR != flowPrms)
700a98c6: 9803         	ldr	r0, [sp, #0xc]
700a98c8: 2800         	cmp	r0, #0x0
700a98ca: d042         	beq	0x700a9952 <UdmaFlowPrms_init+0x92> @ imm = #0x84
700a98cc: e7ff         	b	0x700a98ce <UdmaFlowPrms_init+0xe> @ imm = #-0x2
;         flowPrms->rxChHandle    = (Udma_ChHandle) NULL_PTR;
700a98ce: 9803         	ldr	r0, [sp, #0xc]
700a98d0: 2100         	movs	r1, #0x0
700a98d2: 9100         	str	r1, [sp]
700a98d4: 6001         	str	r1, [r0]
;         flowPrms->einfoPresent  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_EINFO_NOT_PRESENT;
700a98d6: 9803         	ldr	r0, [sp, #0xc]
700a98d8: 7101         	strb	r1, [r0, #0x4]
;         flowPrms->psInfoPresent = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PSINFO_NOT_PRESENT;
700a98da: 9803         	ldr	r0, [sp, #0xc]
700a98dc: 7141         	strb	r1, [r0, #0x5]
;         flowPrms->errorHandling = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_ERR_RETRY;
700a98de: 9a03         	ldr	r2, [sp, #0xc]
700a98e0: 2001         	movs	r0, #0x1
700a98e2: 7190         	strb	r0, [r2, #0x6]
;         flowPrms->descType      = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DESC_HOST;
700a98e4: 9803         	ldr	r0, [sp, #0xc]
700a98e6: 71c1         	strb	r1, [r0, #0x7]
;         flowPrms->psLocation    = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PS_END_PD;
700a98e8: 9803         	ldr	r0, [sp, #0xc]
700a98ea: 7201         	strb	r1, [r0, #0x8]
;         flowPrms->sopOffset     = 0U;
700a98ec: 9803         	ldr	r0, [sp, #0xc]
700a98ee: 8141         	strh	r1, [r0, #0xa]
;         flowPrms->defaultRxCQ   = UDMA_RING_INVALID;
700a98f0: 9a03         	ldr	r2, [sp, #0xc]
700a98f2: f64f 70ff    	movw	r0, #0xffff
700a98f6: 9001         	str	r0, [sp, #0x4]
700a98f8: 8190         	strh	r0, [r2, #0xc]
;         flowPrms->srcTagLo      = 0U;
700a98fa: 9a03         	ldr	r2, [sp, #0xc]
700a98fc: 73d1         	strb	r1, [r2, #0xf]
;         flowPrms->srcTagLoSel   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_SRC_SELECT_SRC_TAG;
700a98fe: 9b03         	ldr	r3, [sp, #0xc]
700a9900: 2204         	movs	r2, #0x4
700a9902: 745a         	strb	r2, [r3, #0x11]
;         flowPrms->srcTagHi      = 0U;
700a9904: 9b03         	ldr	r3, [sp, #0xc]
700a9906: 7399         	strb	r1, [r3, #0xe]
;         flowPrms->srcTagHiSel   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_SRC_SELECT_FLOW_ID;
700a9908: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700a990c: 2302         	movs	r3, #0x2
700a990e: f88c 3010    	strb.w	r3, [r12, #0x10]
;         flowPrms->destTagLo     = 0U;
700a9912: 9b03         	ldr	r3, [sp, #0xc]
700a9914: 74d9         	strb	r1, [r3, #0x13]
;         flowPrms->destTagLoSel  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DEST_SELECT_DEST_TAG_LO;
700a9916: 9b03         	ldr	r3, [sp, #0xc]
700a9918: 755a         	strb	r2, [r3, #0x15]
;         flowPrms->destTagHi     = 0U;
700a991a: 9a03         	ldr	r2, [sp, #0xc]
700a991c: 7491         	strb	r1, [r2, #0x12]
;         flowPrms->destTagHiSel  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DEST_SELECT_DEST_TAG_HI;
700a991e: 9b03         	ldr	r3, [sp, #0xc]
700a9920: 2205         	movs	r2, #0x5
700a9922: 751a         	strb	r2, [r3, #0x14]
;         flowPrms->sizeThreshEn  = 0U;
700a9924: 9a03         	ldr	r2, [sp, #0xc]
700a9926: 7591         	strb	r1, [r2, #0x16]
;         flowPrms->fdq0Sz0Qnum   = UDMA_RING_INVALID;
700a9928: 9a03         	ldr	r2, [sp, #0xc]
700a992a: 8310         	strh	r0, [r2, #0x18]
;         flowPrms->fdq1Qnum      = UDMA_RING_INVALID;
700a992c: 9a03         	ldr	r2, [sp, #0xc]
700a992e: 8350         	strh	r0, [r2, #0x1a]
;         flowPrms->fdq2Qnum      = UDMA_RING_INVALID;
700a9930: 9a03         	ldr	r2, [sp, #0xc]
700a9932: 8390         	strh	r0, [r2, #0x1c]
;         flowPrms->fdq3Qnum      = UDMA_RING_INVALID;
700a9934: 9a03         	ldr	r2, [sp, #0xc]
700a9936: 83d0         	strh	r0, [r2, #0x1e]
;         flowPrms->sizeThresh0   = 0U;
700a9938: 9a03         	ldr	r2, [sp, #0xc]
700a993a: 8411         	strh	r1, [r2, #0x20]
;         flowPrms->sizeThresh1   = 0U;
700a993c: 9a03         	ldr	r2, [sp, #0xc]
700a993e: 8451         	strh	r1, [r2, #0x22]
;         flowPrms->sizeThresh2   = 0U;
700a9940: 9a03         	ldr	r2, [sp, #0xc]
700a9942: 8491         	strh	r1, [r2, #0x24]
;         flowPrms->fdq0Sz1Qnum   = UDMA_RING_INVALID;
700a9944: 9903         	ldr	r1, [sp, #0xc]
700a9946: 84c8         	strh	r0, [r1, #0x26]
;         flowPrms->fdq0Sz2Qnum   = UDMA_RING_INVALID;
700a9948: 9903         	ldr	r1, [sp, #0xc]
700a994a: 8508         	strh	r0, [r1, #0x28]
;         flowPrms->fdq0Sz3Qnum   = UDMA_RING_INVALID;
700a994c: 9903         	ldr	r1, [sp, #0xc]
700a994e: 8548         	strh	r0, [r1, #0x2a]
;     }
700a9950: e7ff         	b	0x700a9952 <UdmaFlowPrms_init+0x92> @ imm = #-0x2
;     return;
700a9952: b004         	add	sp, #0x10
700a9954: 4770         	bx	lr
		...
700a995e: 0000         	movs	r0, r0

700a9960 <Udma_ringDequeueRaw>:
; {
700a9960: b580         	push	{r7, lr}
700a9962: b086         	sub	sp, #0x18
700a9964: 9005         	str	r0, [sp, #0x14]
700a9966: 9104         	str	r1, [sp, #0x10]
700a9968: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a996a: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a996c: 9805         	ldr	r0, [sp, #0x14]
700a996e: 9000         	str	r0, [sp]
;     if((NULL_PTR == ringHandleInt) ||
700a9970: 9800         	ldr	r0, [sp]
700a9972: b180         	cbz	r0, 0x700a9996 <Udma_ringDequeueRaw+0x36> @ imm = #0x20
700a9974: e7ff         	b	0x700a9976 <Udma_ringDequeueRaw+0x16> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a9976: 9800         	ldr	r0, [sp]
700a9978: 6d80         	ldr	r0, [r0, #0x58]
700a997a: f64a 31cd    	movw	r1, #0xabcd
700a997e: f6ca 31dc    	movt	r1, #0xabdc
700a9982: 4288         	cmp	r0, r1
700a9984: d107         	bne	0x700a9996 <Udma_ringDequeueRaw+0x36> @ imm = #0xe
700a9986: e7ff         	b	0x700a9988 <Udma_ringDequeueRaw+0x28> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a9988: 9800         	ldr	r0, [sp]
700a998a: 8880         	ldrh	r0, [r0, #0x4]
700a998c: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a9990: 4288         	cmp	r0, r1
700a9992: d104         	bne	0x700a999e <Udma_ringDequeueRaw+0x3e> @ imm = #0x8
700a9994: e7ff         	b	0x700a9996 <Udma_ringDequeueRaw+0x36> @ imm = #-0x2
700a9996: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a999a: 9003         	str	r0, [sp, #0xc]
;     }
700a999c: e7ff         	b	0x700a999e <Udma_ringDequeueRaw+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a999e: 9803         	ldr	r0, [sp, #0xc]
700a99a0: b9a8         	cbnz	r0, 0x700a99ce <Udma_ringDequeueRaw+0x6e> @ imm = #0x2a
700a99a2: e7ff         	b	0x700a99a4 <Udma_ringDequeueRaw+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a99a4: 9800         	ldr	r0, [sp]
700a99a6: 6800         	ldr	r0, [r0]
700a99a8: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) ||
700a99aa: 9801         	ldr	r0, [sp, #0x4]
700a99ac: b150         	cbz	r0, 0x700a99c4 <Udma_ringDequeueRaw+0x64> @ imm = #0x14
700a99ae: e7ff         	b	0x700a99b0 <Udma_ringDequeueRaw+0x50> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a99b0: 9801         	ldr	r0, [sp, #0x4]
700a99b2: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a99b6: f64a 31cd    	movw	r1, #0xabcd
700a99ba: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a99be: 4288         	cmp	r0, r1
700a99c0: d004         	beq	0x700a99cc <Udma_ringDequeueRaw+0x6c> @ imm = #0x8
700a99c2: e7ff         	b	0x700a99c4 <Udma_ringDequeueRaw+0x64> @ imm = #-0x2
700a99c4: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a99c8: 9003         	str	r0, [sp, #0xc]
;         }
700a99ca: e7ff         	b	0x700a99cc <Udma_ringDequeueRaw+0x6c> @ imm = #-0x2
;     }
700a99cc: e7ff         	b	0x700a99ce <Udma_ringDequeueRaw+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a99ce: 9803         	ldr	r0, [sp, #0xc]
700a99d0: b970         	cbnz	r0, 0x700a99f0 <Udma_ringDequeueRaw+0x90> @ imm = #0x1c
700a99d2: e7ff         	b	0x700a99d4 <Udma_ringDequeueRaw+0x74> @ imm = #-0x2
;         cookie = HwiP_disable();
700a99d4: f006 efc4    	blx	0x700b0960 <HwiP_disable> @ imm = #0x6f88
700a99d8: 9002         	str	r0, [sp, #0x8]
;         retVal = drvHandle->ringDequeueRaw(drvHandle, ringHandleInt, phyDescMem);
700a99da: 9801         	ldr	r0, [sp, #0x4]
700a99dc: f8d0 3590    	ldr.w	r3, [r0, #0x590]
700a99e0: 9900         	ldr	r1, [sp]
700a99e2: 9a04         	ldr	r2, [sp, #0x10]
700a99e4: 4798         	blx	r3
700a99e6: 9003         	str	r0, [sp, #0xc]
;         HwiP_restore(cookie);
700a99e8: 9802         	ldr	r0, [sp, #0x8]
700a99ea: f006 efda    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x6fb4
;     }
700a99ee: e7ff         	b	0x700a99f0 <Udma_ringDequeueRaw+0x90> @ imm = #-0x2
;     return (retVal);
700a99f0: 9803         	ldr	r0, [sp, #0xc]
700a99f2: b006         	add	sp, #0x18
700a99f4: bd80         	pop	{r7, pc}
		...
700a99fe: 0000         	movs	r0, r0

700a9a00 <UART_lld_dmaDisableChannel>:
; {
700a9a00: b580         	push	{r7, lr}
700a9a02: b08a         	sub	sp, #0x28
700a9a04: 9009         	str	r0, [sp, #0x24]
700a9a06: 9108         	str	r1, [sp, #0x20]
700a9a08: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a9a0a: 9007         	str	r0, [sp, #0x1c]
700a9a0c: 2001         	movs	r0, #0x1
;     uint32_t temp = TRUE;
700a9a0e: 9006         	str	r0, [sp, #0x18]
;     udmaChCfg   = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a9a10: 9809         	ldr	r0, [sp, #0x24]
700a9a12: 6840         	ldr	r0, [r0, #0x4]
700a9a14: 6cc0         	ldr	r0, [r0, #0x4c]
700a9a16: 9005         	str	r0, [sp, #0x14]
;     if (isChannelTx == TRUE)
700a9a18: 9808         	ldr	r0, [sp, #0x20]
700a9a1a: 2801         	cmp	r0, #0x1
700a9a1c: d104         	bne	0x700a9a28 <UART_lld_dmaDisableChannel+0x28> @ imm = #0x8
700a9a1e: e7ff         	b	0x700a9a20 <UART_lld_dmaDisableChannel+0x20> @ imm = #-0x2
;         chHandle = udmaChCfg->txChHandle;
700a9a20: 9805         	ldr	r0, [sp, #0x14]
700a9a22: 6840         	ldr	r0, [r0, #0x4]
700a9a24: 9004         	str	r0, [sp, #0x10]
;     }
700a9a26: e003         	b	0x700a9a30 <UART_lld_dmaDisableChannel+0x30> @ imm = #0x6
;         chHandle = udmaChCfg->rxChHandle;
700a9a28: 9805         	ldr	r0, [sp, #0x14]
700a9a2a: 6880         	ldr	r0, [r0, #0x8]
700a9a2c: 9004         	str	r0, [sp, #0x10]
700a9a2e: e7ff         	b	0x700a9a30 <UART_lld_dmaDisableChannel+0x30> @ imm = #-0x2
;     status = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
700a9a30: 9804         	ldr	r0, [sp, #0x10]
700a9a32: 2164         	movs	r1, #0x64
700a9a34: f7fe fb94    	bl	0x700a8160 <Udma_chDisable> @ imm = #-0x18d8
700a9a38: 9007         	str	r0, [sp, #0x1c]
;     DebugP_assert(UDMA_SOK == status);
700a9a3a: 9807         	ldr	r0, [sp, #0x1c]
700a9a3c: fab0 f080    	clz	r0, r0
700a9a40: 0940         	lsrs	r0, r0, #0x5
700a9a42: f641 71bb    	movw	r1, #0x1fbb
700a9a46: f2c7 010b    	movt	r1, #0x700b
700a9a4a: 466a         	mov	r2, sp
700a9a4c: 6011         	str	r1, [r2]
700a9a4e: f641 316c    	movw	r1, #0x1b6c
700a9a52: f2c7 010b    	movt	r1, #0x700b
700a9a56: f641 626b    	movw	r2, #0x1e6b
700a9a5a: f2c7 020b    	movt	r2, #0x700b
700a9a5e: f240 137b    	movw	r3, #0x17b
700a9a62: f001 f915    	bl	0x700aac90 <_DebugP_assert> @ imm = #0x122a
;     while(temp == TRUE)
700a9a66: e7ff         	b	0x700a9a68 <UART_lld_dmaDisableChannel+0x68> @ imm = #-0x2
700a9a68: 9806         	ldr	r0, [sp, #0x18]
700a9a6a: 2801         	cmp	r0, #0x1
700a9a6c: d10f         	bne	0x700a9a8e <UART_lld_dmaDisableChannel+0x8e> @ imm = #0x1e
700a9a6e: e7ff         	b	0x700a9a70 <UART_lld_dmaDisableChannel+0x70> @ imm = #-0x2
;                          Udma_chGetFqRingHandle(chHandle), &pDesc);
700a9a70: 9804         	ldr	r0, [sp, #0x10]
700a9a72: f001 fb0d    	bl	0x700ab090 <Udma_chGetFqRingHandle> @ imm = #0x161a
700a9a76: a902         	add	r1, sp, #0x8
;         tempRetVal = Udma_ringFlushRaw(
700a9a78: f000 fb9a    	bl	0x700aa1b0 <Udma_ringFlushRaw> @ imm = #0x734
700a9a7c: 9001         	str	r0, [sp, #0x4]
;         if(UDMA_ETIMEOUT == tempRetVal)
700a9a7e: 9801         	ldr	r0, [sp, #0x4]
700a9a80: 3004         	adds	r0, #0x4
700a9a82: b918         	cbnz	r0, 0x700a9a8c <UART_lld_dmaDisableChannel+0x8c> @ imm = #0x6
700a9a84: e7ff         	b	0x700a9a86 <UART_lld_dmaDisableChannel+0x86> @ imm = #-0x2
700a9a86: 2000         	movs	r0, #0x0
;             temp = FALSE;
700a9a88: 9006         	str	r0, [sp, #0x18]
;         }
700a9a8a: e7ff         	b	0x700a9a8c <UART_lld_dmaDisableChannel+0x8c> @ imm = #-0x2
;     while(temp == TRUE)
700a9a8c: e7ec         	b	0x700a9a68 <UART_lld_dmaDisableChannel+0x68> @ imm = #-0x28
;     return status;
700a9a8e: 9807         	ldr	r0, [sp, #0x1c]
700a9a90: b00a         	add	sp, #0x28
700a9a92: bd80         	pop	{r7, pc}
		...

700a9aa0 <xQueueGiveFromISR>:
; {
700a9aa0: b580         	push	{r7, lr}
700a9aa2: b088         	sub	sp, #0x20
700a9aa4: 9007         	str	r0, [sp, #0x1c]
700a9aa6: 9106         	str	r1, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a9aa8: 9807         	ldr	r0, [sp, #0x1c]
700a9aaa: 9003         	str	r0, [sp, #0xc]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a9aac: f006 ef58    	blx	0x700b0960 <HwiP_disable> @ imm = #0x6eb0
700a9ab0: 9004         	str	r0, [sp, #0x10]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a9ab2: 9803         	ldr	r0, [sp, #0xc]
700a9ab4: 6b80         	ldr	r0, [r0, #0x38]
700a9ab6: 9002         	str	r0, [sp, #0x8]
;         if( uxMessagesWaiting < pxQueue->uxLength )
700a9ab8: 9802         	ldr	r0, [sp, #0x8]
700a9aba: 9903         	ldr	r1, [sp, #0xc]
700a9abc: 6bc9         	ldr	r1, [r1, #0x3c]
700a9abe: 4288         	cmp	r0, r1
700a9ac0: d22f         	bhs	0x700a9b22 <xQueueGiveFromISR+0x82> @ imm = #0x5e
700a9ac2: e7ff         	b	0x700a9ac4 <xQueueGiveFromISR+0x24> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
700a9ac4: 9803         	ldr	r0, [sp, #0xc]
700a9ac6: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a9aca: f88d 0007    	strb.w	r0, [sp, #0x7]
;             pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
700a9ace: 9802         	ldr	r0, [sp, #0x8]
700a9ad0: 3001         	adds	r0, #0x1
700a9ad2: 9903         	ldr	r1, [sp, #0xc]
700a9ad4: 6388         	str	r0, [r1, #0x38]
;             if( cTxLock == queueUNLOCKED )
700a9ad6: f99d 0007    	ldrsb.w	r0, [sp, #0x7]
700a9ada: 3001         	adds	r0, #0x1
700a9adc: b9b8         	cbnz	r0, 0x700a9b0e <xQueueGiveFromISR+0x6e> @ imm = #0x2e
700a9ade: e7ff         	b	0x700a9ae0 <xQueueGiveFromISR+0x40> @ imm = #-0x2
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a9ae0: 9803         	ldr	r0, [sp, #0xc]
700a9ae2: 6a40         	ldr	r0, [r0, #0x24]
700a9ae4: b188         	cbz	r0, 0x700a9b0a <xQueueGiveFromISR+0x6a> @ imm = #0x22
700a9ae6: e7ff         	b	0x700a9ae8 <xQueueGiveFromISR+0x48> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a9ae8: 9803         	ldr	r0, [sp, #0xc]
700a9aea: 3024         	adds	r0, #0x24
700a9aec: f7fe f810    	bl	0x700a7b10 <xTaskRemoveFromEventList> @ imm = #-0x1fe0
700a9af0: b148         	cbz	r0, 0x700a9b06 <xQueueGiveFromISR+0x66> @ imm = #0x12
700a9af2: e7ff         	b	0x700a9af4 <xQueueGiveFromISR+0x54> @ imm = #-0x2
;                                 if( pxHigherPriorityTaskWoken != NULL )
700a9af4: 9806         	ldr	r0, [sp, #0x18]
700a9af6: b120         	cbz	r0, 0x700a9b02 <xQueueGiveFromISR+0x62> @ imm = #0x8
700a9af8: e7ff         	b	0x700a9afa <xQueueGiveFromISR+0x5a> @ imm = #-0x2
;                                     *pxHigherPriorityTaskWoken = pdTRUE;
700a9afa: 9906         	ldr	r1, [sp, #0x18]
700a9afc: 2001         	movs	r0, #0x1
700a9afe: 6008         	str	r0, [r1]
;                                 }
700a9b00: e000         	b	0x700a9b04 <xQueueGiveFromISR+0x64> @ imm = #0x0
700a9b02: e7ff         	b	0x700a9b04 <xQueueGiveFromISR+0x64> @ imm = #-0x2
;                             }
700a9b04: e000         	b	0x700a9b08 <xQueueGiveFromISR+0x68> @ imm = #0x0
700a9b06: e7ff         	b	0x700a9b08 <xQueueGiveFromISR+0x68> @ imm = #-0x2
;                         }
700a9b08: e000         	b	0x700a9b0c <xQueueGiveFromISR+0x6c> @ imm = #0x0
700a9b0a: e7ff         	b	0x700a9b0c <xQueueGiveFromISR+0x6c> @ imm = #-0x2
;             }
700a9b0c: e006         	b	0x700a9b1c <xQueueGiveFromISR+0x7c> @ imm = #0xc
;                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
700a9b0e: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700a9b12: 3001         	adds	r0, #0x1
700a9b14: 9903         	ldr	r1, [sp, #0xc]
700a9b16: f881 0045    	strb.w	r0, [r1, #0x45]
700a9b1a: e7ff         	b	0x700a9b1c <xQueueGiveFromISR+0x7c> @ imm = #-0x2
700a9b1c: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a9b1e: 9005         	str	r0, [sp, #0x14]
;         }
700a9b20: e002         	b	0x700a9b28 <xQueueGiveFromISR+0x88> @ imm = #0x4
700a9b22: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
700a9b24: 9005         	str	r0, [sp, #0x14]
700a9b26: e7ff         	b	0x700a9b28 <xQueueGiveFromISR+0x88> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a9b28: 9804         	ldr	r0, [sp, #0x10]
700a9b2a: f006 ef3a    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x6e74
;     return xReturn;
700a9b2e: 9805         	ldr	r0, [sp, #0x14]
700a9b30: b008         	add	sp, #0x20
700a9b32: bd80         	pop	{r7, pc}
		...

700a9b40 <xTimerGenericCommand>:
;     {
700a9b40: b580         	push	{r7, lr}
700a9b42: b08a         	sub	sp, #0x28
700a9b44: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a9b48: 9009         	str	r0, [sp, #0x24]
700a9b4a: 9108         	str	r1, [sp, #0x20]
700a9b4c: 9207         	str	r2, [sp, #0x1c]
700a9b4e: 9306         	str	r3, [sp, #0x18]
700a9b50: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
700a9b52: 9005         	str	r0, [sp, #0x14]
;         if( xTimerQueue != NULL )
700a9b54: f642 2058    	movw	r0, #0x2a58
700a9b58: f2c7 000b    	movt	r0, #0x700b
700a9b5c: 6800         	ldr	r0, [r0]
700a9b5e: b3a8         	cbz	r0, 0x700a9bcc <xTimerGenericCommand+0x8c> @ imm = #0x6a
700a9b60: e7ff         	b	0x700a9b62 <xTimerGenericCommand+0x22> @ imm = #-0x2
;             xMessage.xMessageID = xCommandID;
700a9b62: 9808         	ldr	r0, [sp, #0x20]
700a9b64: 9001         	str	r0, [sp, #0x4]
;             xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
700a9b66: 9807         	ldr	r0, [sp, #0x1c]
700a9b68: 9002         	str	r0, [sp, #0x8]
;             xMessage.u.xTimerParameters.pxTimer = xTimer;
700a9b6a: 9809         	ldr	r0, [sp, #0x24]
700a9b6c: 9003         	str	r0, [sp, #0xc]
;             if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
700a9b6e: 9808         	ldr	r0, [sp, #0x20]
700a9b70: 2805         	cmp	r0, #0x5
700a9b72: dc1e         	bgt	0x700a9bb2 <xTimerGenericCommand+0x72> @ imm = #0x3c
700a9b74: e7ff         	b	0x700a9b76 <xTimerGenericCommand+0x36> @ imm = #-0x2
;                 if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
700a9b76: f004 fc2b    	bl	0x700ae3d0 <xTaskGetSchedulerState> @ imm = #0x4856
700a9b7a: 2802         	cmp	r0, #0x2
700a9b7c: d10c         	bne	0x700a9b98 <xTimerGenericCommand+0x58> @ imm = #0x18
700a9b7e: e7ff         	b	0x700a9b80 <xTimerGenericCommand+0x40> @ imm = #-0x2
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
700a9b80: f642 2058    	movw	r0, #0x2a58
700a9b84: f2c7 000b    	movt	r0, #0x700b
700a9b88: 6800         	ldr	r0, [r0]
700a9b8a: 9a0c         	ldr	r2, [sp, #0x30]
700a9b8c: a901         	add	r1, sp, #0x4
700a9b8e: 2300         	movs	r3, #0x0
700a9b90: f7f9 fbb6    	bl	0x700a3300 <xQueueGenericSend> @ imm = #-0x6894
700a9b94: 9005         	str	r0, [sp, #0x14]
;                 }
700a9b96: e00b         	b	0x700a9bb0 <xTimerGenericCommand+0x70> @ imm = #0x16
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
700a9b98: f642 2058    	movw	r0, #0x2a58
700a9b9c: f2c7 000b    	movt	r0, #0x700b
700a9ba0: 6800         	ldr	r0, [r0]
700a9ba2: a901         	add	r1, sp, #0x4
700a9ba4: 2300         	movs	r3, #0x0
700a9ba6: 461a         	mov	r2, r3
700a9ba8: f7f9 fbaa    	bl	0x700a3300 <xQueueGenericSend> @ imm = #-0x68ac
700a9bac: 9005         	str	r0, [sp, #0x14]
700a9bae: e7ff         	b	0x700a9bb0 <xTimerGenericCommand+0x70> @ imm = #-0x2
;             }
700a9bb0: e00b         	b	0x700a9bca <xTimerGenericCommand+0x8a> @ imm = #0x16
;                 xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
700a9bb2: f642 2058    	movw	r0, #0x2a58
700a9bb6: f2c7 000b    	movt	r0, #0x700b
700a9bba: 6800         	ldr	r0, [r0]
700a9bbc: 9a06         	ldr	r2, [sp, #0x18]
700a9bbe: a901         	add	r1, sp, #0x4
700a9bc0: 2300         	movs	r3, #0x0
700a9bc2: f7fe ff3d    	bl	0x700a8a40 <xQueueGenericSendFromISR> @ imm = #-0x1186
700a9bc6: 9005         	str	r0, [sp, #0x14]
700a9bc8: e7ff         	b	0x700a9bca <xTimerGenericCommand+0x8a> @ imm = #-0x2
;         }
700a9bca: e000         	b	0x700a9bce <xTimerGenericCommand+0x8e> @ imm = #0x0
700a9bcc: e7ff         	b	0x700a9bce <xTimerGenericCommand+0x8e> @ imm = #-0x2
;         return xReturn;
700a9bce: 9805         	ldr	r0, [sp, #0x14]
700a9bd0: b00a         	add	sp, #0x28
700a9bd2: bd80         	pop	{r7, pc}
		...

700a9be0 <SOC_moduleClockEnable>:
; {
700a9be0: b580         	push	{r7, lr}
700a9be2: b088         	sub	sp, #0x20
700a9be4: 9007         	str	r0, [sp, #0x1c]
700a9be6: 9106         	str	r1, [sp, #0x18]
700a9be8: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700a9bea: 9005         	str	r0, [sp, #0x14]
700a9bec: 2102         	movs	r1, #0x2
;     uint32_t moduleState = TISCI_MSG_VALUE_DEVICE_HW_STATE_TRANS;
700a9bee: 9104         	str	r1, [sp, #0x10]
;     uint32_t resetState = 0U;
700a9bf0: 9003         	str	r0, [sp, #0xc]
;     uint32_t contextLossState = 0U;
700a9bf2: 9002         	str	r0, [sp, #0x8]
;     status = Sciclient_pmGetModuleState(moduleId,
700a9bf4: 9807         	ldr	r0, [sp, #0x1c]
700a9bf6: 466a         	mov	r2, sp
700a9bf8: f04f 31ff    	mov.w	r1, #0xffffffff
700a9bfc: 6011         	str	r1, [r2]
700a9bfe: a904         	add	r1, sp, #0x10
700a9c00: aa03         	add	r2, sp, #0xc
700a9c02: ab02         	add	r3, sp, #0x8
700a9c04: f000 f96c    	bl	0x700a9ee0 <Sciclient_pmGetModuleState> @ imm = #0x2d8
700a9c08: 9005         	str	r0, [sp, #0x14]
;     if(status == SystemP_SUCCESS)
700a9c0a: 9805         	ldr	r0, [sp, #0x14]
700a9c0c: bb70         	cbnz	r0, 0x700a9c6c <SOC_moduleClockEnable+0x8c> @ imm = #0x5c
700a9c0e: e7ff         	b	0x700a9c10 <SOC_moduleClockEnable+0x30> @ imm = #-0x2
;         if(moduleState == TISCI_MSG_VALUE_DEVICE_HW_STATE_OFF && (enable == 1))
700a9c10: 9804         	ldr	r0, [sp, #0x10]
700a9c12: b9c8         	cbnz	r0, 0x700a9c48 <SOC_moduleClockEnable+0x68> @ imm = #0x32
700a9c14: e7ff         	b	0x700a9c16 <SOC_moduleClockEnable+0x36> @ imm = #-0x2
700a9c16: 9806         	ldr	r0, [sp, #0x18]
700a9c18: 2801         	cmp	r0, #0x1
700a9c1a: d115         	bne	0x700a9c48 <SOC_moduleClockEnable+0x68> @ imm = #0x2a
700a9c1c: e7ff         	b	0x700a9c1e <SOC_moduleClockEnable+0x3e> @ imm = #-0x2
;             status = Sciclient_pmSetModuleState(moduleId,
700a9c1e: 9807         	ldr	r0, [sp, #0x1c]
700a9c20: 2102         	movs	r1, #0x2
700a9c22: f240 2202    	movw	r2, #0x202
700a9c26: f04f 33ff    	mov.w	r3, #0xffffffff
700a9c2a: f000 f9e9    	bl	0x700aa000 <Sciclient_pmSetModuleState> @ imm = #0x3d2
700a9c2e: 9005         	str	r0, [sp, #0x14]
;             if (status == SystemP_SUCCESS)
700a9c30: 9805         	ldr	r0, [sp, #0x14]
700a9c32: b940         	cbnz	r0, 0x700a9c46 <SOC_moduleClockEnable+0x66> @ imm = #0x10
700a9c34: e7ff         	b	0x700a9c36 <SOC_moduleClockEnable+0x56> @ imm = #-0x2
;                 status = Sciclient_pmSetModuleRst(moduleId,
700a9c36: 9807         	ldr	r0, [sp, #0x1c]
700a9c38: 2100         	movs	r1, #0x0
700a9c3a: f04f 32ff    	mov.w	r2, #0xffffffff
700a9c3e: f002 fc57    	bl	0x700ac4f0 <Sciclient_pmSetModuleRst> @ imm = #0x28ae
700a9c42: 9005         	str	r0, [sp, #0x14]
;             }
700a9c44: e7ff         	b	0x700a9c46 <SOC_moduleClockEnable+0x66> @ imm = #-0x2
;         }
700a9c46: e010         	b	0x700a9c6a <SOC_moduleClockEnable+0x8a> @ imm = #0x20
;         if(moduleState == TISCI_MSG_VALUE_DEVICE_HW_STATE_ON && (enable == 0))
700a9c48: 9804         	ldr	r0, [sp, #0x10]
700a9c4a: 2801         	cmp	r0, #0x1
700a9c4c: d10c         	bne	0x700a9c68 <SOC_moduleClockEnable+0x88> @ imm = #0x18
700a9c4e: e7ff         	b	0x700a9c50 <SOC_moduleClockEnable+0x70> @ imm = #-0x2
700a9c50: 9806         	ldr	r0, [sp, #0x18]
700a9c52: b948         	cbnz	r0, 0x700a9c68 <SOC_moduleClockEnable+0x88> @ imm = #0x12
700a9c54: e7ff         	b	0x700a9c56 <SOC_moduleClockEnable+0x76> @ imm = #-0x2
;             status = Sciclient_pmSetModuleState(moduleId,
700a9c56: 9807         	ldr	r0, [sp, #0x1c]
700a9c58: 2100         	movs	r1, #0x0
700a9c5a: 2202         	movs	r2, #0x2
700a9c5c: f04f 33ff    	mov.w	r3, #0xffffffff
700a9c60: f000 f9ce    	bl	0x700aa000 <Sciclient_pmSetModuleState> @ imm = #0x39c
700a9c64: 9005         	str	r0, [sp, #0x14]
;         }
700a9c66: e7ff         	b	0x700a9c68 <SOC_moduleClockEnable+0x88> @ imm = #-0x2
700a9c68: e7ff         	b	0x700a9c6a <SOC_moduleClockEnable+0x8a> @ imm = #-0x2
;     }
700a9c6a: e7ff         	b	0x700a9c6c <SOC_moduleClockEnable+0x8c> @ imm = #-0x2
;     return status;
700a9c6c: 9805         	ldr	r0, [sp, #0x14]
700a9c6e: b008         	add	sp, #0x20
700a9c70: bd80         	pop	{r7, pc}
		...
700a9c7e: 0000         	movs	r0, r0

700a9c80 <Sciclient_rmPsPop>:
; {
700a9c80: b084         	sub	sp, #0x10
700a9c82: 9003         	str	r0, [sp, #0xc]
700a9c84: 9102         	str	r1, [sp, #0x8]
700a9c86: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a9c88: 9001         	str	r0, [sp, #0x4]
;     if ((gPstack.psp > (0u)) && (n != NULL) && (if_idx != NULL)) {
700a9c8a: f241 0058    	movw	r0, #0x1058
700a9c8e: f2c7 0008    	movt	r0, #0x7008
700a9c92: 8c80         	ldrh	r0, [r0, #0x24]
700a9c94: b3b0         	cbz	r0, 0x700a9d04 <Sciclient_rmPsPop+0x84> @ imm = #0x6c
700a9c96: e7ff         	b	0x700a9c98 <Sciclient_rmPsPop+0x18> @ imm = #-0x2
700a9c98: 9803         	ldr	r0, [sp, #0xc]
700a9c9a: b398         	cbz	r0, 0x700a9d04 <Sciclient_rmPsPop+0x84> @ imm = #0x66
700a9c9c: e7ff         	b	0x700a9c9e <Sciclient_rmPsPop+0x1e> @ imm = #-0x2
700a9c9e: 9802         	ldr	r0, [sp, #0x8]
700a9ca0: b380         	cbz	r0, 0x700a9d04 <Sciclient_rmPsPop+0x84> @ imm = #0x60
700a9ca2: e7ff         	b	0x700a9ca4 <Sciclient_rmPsPop+0x24> @ imm = #-0x2
;         gPstack.psp--;
700a9ca4: f241 0158    	movw	r1, #0x1058
700a9ca8: f2c7 0108    	movt	r1, #0x7008
700a9cac: 9100         	str	r1, [sp]
700a9cae: 8c88         	ldrh	r0, [r1, #0x24]
700a9cb0: 3801         	subs	r0, #0x1
700a9cb2: 8488         	strh	r0, [r1, #0x24]
;         *n = gPstack.ps[gPstack.psp].p_n;
700a9cb4: 8c88         	ldrh	r0, [r1, #0x24]
700a9cb6: eb00 0040    	add.w	r0, r0, r0, lsl #1
700a9cba: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700a9cbe: 9a03         	ldr	r2, [sp, #0xc]
700a9cc0: 6010         	str	r0, [r2]
;         *if_idx = gPstack.ps[gPstack.psp].if_idx;
700a9cc2: 8c88         	ldrh	r0, [r1, #0x24]
700a9cc4: eb00 0040    	add.w	r0, r0, r0, lsl #1
700a9cc8: eb01 0080    	add.w	r0, r1, r0, lsl #2
700a9ccc: 8880         	ldrh	r0, [r0, #0x4]
700a9cce: 9a02         	ldr	r2, [sp, #0x8]
700a9cd0: 8010         	strh	r0, [r2]
;         gPstack.ps[gPstack.psp].p_n = NULL;
700a9cd2: 8c88         	ldrh	r0, [r1, #0x24]
700a9cd4: eb00 0240    	add.w	r2, r0, r0, lsl #1
700a9cd8: 2000         	movs	r0, #0x0
700a9cda: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gPstack.ps[gPstack.psp].if_idx = 0;
700a9cde: 8c8a         	ldrh	r2, [r1, #0x24]
700a9ce0: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a9ce4: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a9ce8: 8090         	strh	r0, [r2, #0x4]
;         gPstack.ps[gPstack.psp].inp = 0;
700a9cea: 8c8a         	ldrh	r2, [r1, #0x24]
700a9cec: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a9cf0: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a9cf4: 80d0         	strh	r0, [r2, #0x6]
;         gPstack.ps[gPstack.psp].outp = 0;
700a9cf6: 8c8a         	ldrh	r2, [r1, #0x24]
700a9cf8: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a9cfc: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a9d00: 8108         	strh	r0, [r1, #0x8]
;     } else {
700a9d02: e003         	b	0x700a9d0c <Sciclient_rmPsPop+0x8c> @ imm = #0x6
700a9d04: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a9d08: 9001         	str	r0, [sp, #0x4]
700a9d0a: e7ff         	b	0x700a9d0c <Sciclient_rmPsPop+0x8c> @ imm = #-0x2
;     return r;
700a9d0c: 9801         	ldr	r0, [sp, #0x4]
700a9d0e: b004         	add	sp, #0x10
700a9d10: 4770         	bx	lr
		...
700a9d1e: 0000         	movs	r0, r0

700a9d20 <_DebugP_logZone>:
; {
700a9d20: b082         	sub	sp, #0x8
700a9d22: b580         	push	{r7, lr}
700a9d24: b086         	sub	sp, #0x18
700a9d26: 9309         	str	r3, [sp, #0x24]
700a9d28: 9208         	str	r2, [sp, #0x20]
700a9d2a: 9005         	str	r0, [sp, #0x14]
700a9d2c: 9104         	str	r1, [sp, #0x10]
;     if((HwiP_inISR()) == 0U )
700a9d2e: f006 fb37    	bl	0x700b03a0 <HwiP_inISR> @ imm = #0x666e
700a9d32: bbc8         	cbnz	r0, 0x700a9da8 <_DebugP_logZone+0x88> @ imm = #0x72
700a9d34: e7ff         	b	0x700a9d36 <_DebugP_logZone+0x16> @ imm = #-0x2
;         if(gDebugLogIsInitDone == 0U)
700a9d36: f642 10dc    	movw	r0, #0x29dc
700a9d3a: f2c7 000b    	movt	r0, #0x700b
700a9d3e: 6800         	ldr	r0, [r0]
700a9d40: b9a0         	cbnz	r0, 0x700a9d6c <_DebugP_logZone+0x4c> @ imm = #0x28
700a9d42: e7ff         	b	0x700a9d44 <_DebugP_logZone+0x24> @ imm = #-0x2
;             status = SemaphoreP_constructMutex(&gDebugLogLockObj);
700a9d44: f644 6018    	movw	r0, #0x4e18
700a9d48: f2c7 0008    	movt	r0, #0x7008
700a9d4c: f001 fc78    	bl	0x700ab640 <SemaphoreP_constructMutex> @ imm = #0x18f0
700a9d50: 9003         	str	r0, [sp, #0xc]
;             DebugP_assertNoLog(status == SystemP_SUCCESS);
700a9d52: 9803         	ldr	r0, [sp, #0xc]
700a9d54: fab0 f080    	clz	r0, r0
700a9d58: 0940         	lsrs	r0, r0, #0x5
700a9d5a: f007 fac1    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x7582
;             gDebugLogIsInitDone = 1;
700a9d5e: f642 11dc    	movw	r1, #0x29dc
700a9d62: f2c7 010b    	movt	r1, #0x700b
700a9d66: 2001         	movs	r0, #0x1
700a9d68: 6008         	str	r0, [r1]
;         }
700a9d6a: e7ff         	b	0x700a9d6c <_DebugP_logZone+0x4c> @ imm = #-0x2
;         if( ( gDebugLogZone & logZone ) == logZone )
700a9d6c: f642 10e0    	movw	r0, #0x29e0
700a9d70: f2c7 000b    	movt	r0, #0x700b
700a9d74: 6800         	ldr	r0, [r0]
700a9d76: 9905         	ldr	r1, [sp, #0x14]
700a9d78: 4008         	ands	r0, r1
700a9d7a: 4288         	cmp	r0, r1
700a9d7c: d113         	bne	0x700a9da6 <_DebugP_logZone+0x86> @ imm = #0x26
700a9d7e: e7ff         	b	0x700a9d80 <_DebugP_logZone+0x60> @ imm = #-0x2
;             SemaphoreP_pend(&gDebugLogLockObj, SystemP_WAIT_FOREVER);
700a9d80: f644 6018    	movw	r0, #0x4e18
700a9d84: f2c7 0008    	movt	r0, #0x7008
700a9d88: 9001         	str	r0, [sp, #0x4]
700a9d8a: f04f 31ff    	mov.w	r1, #0xffffffff
700a9d8e: f000 fd27    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0xa4e
700a9d92: a808         	add	r0, sp, #0x20
;             va_start(va, format);
700a9d94: 9002         	str	r0, [sp, #0x8]
;             vprintf_(format, va);
700a9d96: 9804         	ldr	r0, [sp, #0x10]
700a9d98: 9902         	ldr	r1, [sp, #0x8]
700a9d9a: f005 f8d9    	bl	0x700aef50 <vprintf_>   @ imm = #0x51b2
;             SemaphoreP_post(&gDebugLogLockObj);
700a9d9e: 9801         	ldr	r0, [sp, #0x4]
700a9da0: f002 f8ae    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x215c
;         }
700a9da4: e7ff         	b	0x700a9da6 <_DebugP_logZone+0x86> @ imm = #-0x2
;     }
700a9da6: e7ff         	b	0x700a9da8 <_DebugP_logZone+0x88> @ imm = #-0x2
; }
700a9da8: b006         	add	sp, #0x18
700a9daa: e8bd 4080    	pop.w	{r7, lr}
700a9dae: b002         	add	sp, #0x8
700a9db0: 4770         	bx	lr
		...
700a9dbe: 0000         	movs	r0, r0

700a9dc0 <Udma_rmFreeMappedRing>:
; {
700a9dc0: b580         	push	{r7, lr}
700a9dc2: b08e         	sub	sp, #0x38
700a9dc4: 900d         	str	r0, [sp, #0x34]
700a9dc6: 910c         	str	r1, [sp, #0x30]
700a9dc8: 920b         	str	r2, [sp, #0x2c]
700a9dca: 930a         	str	r3, [sp, #0x28]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9dcc: 980c         	ldr	r0, [sp, #0x30]
700a9dce: f500 70ea    	add.w	r0, r0, #0x1d4
700a9dd2: 9005         	str	r0, [sp, #0x14]
;     retVal = Udma_getMappedChRingAttributes(drvHandle, mappedRingGrp, mappedChNum, &chAttr);
700a9dd4: 980c         	ldr	r0, [sp, #0x30]
700a9dd6: 990b         	ldr	r1, [sp, #0x2c]
700a9dd8: 9a0a         	ldr	r2, [sp, #0x28]
700a9dda: ab02         	add	r3, sp, #0x8
700a9ddc: f7fe f808    	bl	0x700a7df0 <Udma_getMappedChRingAttributes> @ imm = #-0x1ff0
700a9de0: 9001         	str	r0, [sp, #0x4]
;     if(ringNum != chAttr.defaultRing)
700a9de2: 980d         	ldr	r0, [sp, #0x34]
700a9de4: 9902         	ldr	r1, [sp, #0x8]
700a9de6: 4288         	cmp	r0, r1
700a9de8: d02f         	beq	0x700a9e4a <Udma_rmFreeMappedRing+0x8a> @ imm = #0x5e
700a9dea: e7ff         	b	0x700a9dec <Udma_rmFreeMappedRing+0x2c> @ imm = #-0x2
;         SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9dec: 980c         	ldr	r0, [sp, #0x30]
700a9dee: f500 609f    	add.w	r0, r0, #0x4f8
700a9df2: f04f 31ff    	mov.w	r1, #0xffffffff
700a9df6: f000 fcf3    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x9e6
;         i = ringNum - rmInitPrms->startMappedRing[mappedRingGrp];
700a9dfa: 980d         	ldr	r0, [sp, #0x34]
700a9dfc: 9905         	ldr	r1, [sp, #0x14]
700a9dfe: 9a0b         	ldr	r2, [sp, #0x2c]
700a9e00: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a9e04: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a9e08: 1a40         	subs	r0, r0, r1
700a9e0a: 9009         	str	r0, [sp, #0x24]
;         offset = i >> 5U;
700a9e0c: 9809         	ldr	r0, [sp, #0x24]
700a9e0e: 0940         	lsrs	r0, r0, #0x5
700a9e10: 9008         	str	r0, [sp, #0x20]
;         bitPos = i - (offset << 5U);
700a9e12: 9809         	ldr	r0, [sp, #0x24]
700a9e14: 9908         	ldr	r1, [sp, #0x20]
700a9e16: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9e1a: 9007         	str	r0, [sp, #0x1c]
;         bitMask = (uint32_t) 1U << bitPos;
700a9e1c: 9907         	ldr	r1, [sp, #0x1c]
700a9e1e: 2001         	movs	r0, #0x1
700a9e20: 4088         	lsls	r0, r1
700a9e22: 9006         	str	r0, [sp, #0x18]
;         drvHandle->mappedRingFlag[mappedRingGrp][offset] |= bitMask;
700a9e24: 9a06         	ldr	r2, [sp, #0x18]
700a9e26: 980c         	ldr	r0, [sp, #0x30]
700a9e28: 990b         	ldr	r1, [sp, #0x2c]
700a9e2a: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a9e2e: 9908         	ldr	r1, [sp, #0x20]
700a9e30: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9e34: f8d1 0344    	ldr.w	r0, [r1, #0x344]
700a9e38: 4310         	orrs	r0, r2
700a9e3a: f8c1 0344    	str.w	r0, [r1, #0x344]
;         SemaphoreP_post(&drvHandle->rmLockObj);
700a9e3e: 980c         	ldr	r0, [sp, #0x30]
700a9e40: f500 609f    	add.w	r0, r0, #0x4f8
700a9e44: f002 f85c    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x20b8
;     }
700a9e48: e7ff         	b	0x700a9e4a <Udma_rmFreeMappedRing+0x8a> @ imm = #-0x2
;     return;
700a9e4a: b00e         	add	sp, #0x38
700a9e4c: bd80         	pop	{r7, pc}
700a9e4e: 0000         	movs	r0, r0

700a9e50 <prvInitialiseTaskLists>:
; static void prvInitialiseTaskLists(void) {
700a9e50: b580         	push	{r7, lr}
700a9e52: b084         	sub	sp, #0x10
700a9e54: 2000         	movs	r0, #0x0
;   for (uxPriority = (UBaseType_t)0U;
700a9e56: 9003         	str	r0, [sp, #0xc]
700a9e58: e7ff         	b	0x700a9e5a <prvInitialiseTaskLists+0xa> @ imm = #-0x2
;        uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
700a9e5a: 9803         	ldr	r0, [sp, #0xc]
;   for (uxPriority = (UBaseType_t)0U;
700a9e5c: 281f         	cmp	r0, #0x1f
700a9e5e: d810         	bhi	0x700a9e82 <prvInitialiseTaskLists+0x32> @ imm = #0x20
700a9e60: e7ff         	b	0x700a9e62 <prvInitialiseTaskLists+0x12> @ imm = #-0x2
;     vListInitialise(&(pxReadyTasksLists[uxPriority]));
700a9e62: 9803         	ldr	r0, [sp, #0xc]
700a9e64: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a9e68: f244 40f8    	movw	r0, #0x44f8
700a9e6c: f2c7 0008    	movt	r0, #0x7008
700a9e70: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a9e74: f004 fe14    	bl	0x700aeaa0 <vListInitialise> @ imm = #0x4c28
;   }
700a9e78: e7ff         	b	0x700a9e7a <prvInitialiseTaskLists+0x2a> @ imm = #-0x2
;        uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
700a9e7a: 9803         	ldr	r0, [sp, #0xc]
700a9e7c: 3001         	adds	r0, #0x1
700a9e7e: 9003         	str	r0, [sp, #0xc]
;   for (uxPriority = (UBaseType_t)0U;
700a9e80: e7eb         	b	0x700a9e5a <prvInitialiseTaskLists+0xa> @ imm = #-0x2a
;   vListInitialise(&xDelayedTaskList1);
700a9e82: f245 2038    	movw	r0, #0x5238
700a9e86: f2c7 0008    	movt	r0, #0x7008
700a9e8a: 9001         	str	r0, [sp, #0x4]
700a9e8c: f004 fe08    	bl	0x700aeaa0 <vListInitialise> @ imm = #0x4c10
;   vListInitialise(&xDelayedTaskList2);
700a9e90: f245 204c    	movw	r0, #0x524c
700a9e94: f2c7 0008    	movt	r0, #0x7008
700a9e98: 9002         	str	r0, [sp, #0x8]
700a9e9a: f004 fe01    	bl	0x700aeaa0 <vListInitialise> @ imm = #0x4c02
;   vListInitialise(&xPendingReadyList);
700a9e9e: f245 2060    	movw	r0, #0x5260
700a9ea2: f2c7 0008    	movt	r0, #0x7008
700a9ea6: f004 fdfb    	bl	0x700aeaa0 <vListInitialise> @ imm = #0x4bf6
;     vListInitialise(&xTasksWaitingTermination);
700a9eaa: f245 2088    	movw	r0, #0x5288
700a9eae: f2c7 0008    	movt	r0, #0x7008
700a9eb2: f004 fdf5    	bl	0x700aeaa0 <vListInitialise> @ imm = #0x4bea
;     vListInitialise(&xSuspendedTaskList);
700a9eb6: f245 2074    	movw	r0, #0x5274
700a9eba: f2c7 0008    	movt	r0, #0x7008
700a9ebe: f004 fdef    	bl	0x700aeaa0 <vListInitialise> @ imm = #0x4bde
700a9ec2: 9901         	ldr	r1, [sp, #0x4]
700a9ec4: 9802         	ldr	r0, [sp, #0x8]
;   pxDelayedTaskList = &xDelayedTaskList1;
700a9ec6: f245 22a0    	movw	r2, #0x52a0
700a9eca: f2c7 0208    	movt	r2, #0x7008
700a9ece: 6011         	str	r1, [r2]
;   pxOverflowDelayedTaskList = &xDelayedTaskList2;
700a9ed0: f245 21a4    	movw	r1, #0x52a4
700a9ed4: f2c7 0108    	movt	r1, #0x7008
700a9ed8: 6008         	str	r0, [r1]
; }
700a9eda: b004         	add	sp, #0x10
700a9edc: bd80         	pop	{r7, pc}
700a9ede: 0000         	movs	r0, r0

700a9ee0 <Sciclient_pmGetModuleState>:
; {
700a9ee0: b580         	push	{r7, lr}
700a9ee2: b096         	sub	sp, #0x58
700a9ee4: f8dd c060    	ldr.w	r12, [sp, #0x60]
700a9ee8: 9015         	str	r0, [sp, #0x54]
700a9eea: 9114         	str	r1, [sp, #0x50]
700a9eec: 9213         	str	r2, [sp, #0x4c]
700a9eee: 9312         	str	r3, [sp, #0x48]
700a9ef0: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a9ef2: 9011         	str	r0, [sp, #0x44]
;     struct tisci_msg_get_device_resp response = {{0}};
700a9ef4: f8ad 0034    	strh.w	r0, [sp, #0x34]
700a9ef8: 900c         	str	r0, [sp, #0x30]
700a9efa: 900b         	str	r0, [sp, #0x2c]
700a9efc: 900a         	str	r0, [sp, #0x28]
700a9efe: 9009         	str	r0, [sp, #0x24]
;     request.id = (uint32_t) moduleId;
700a9f00: 9915         	ldr	r1, [sp, #0x54]
700a9f02: 9110         	str	r1, [sp, #0x40]
700a9f04: f240 2101    	movw	r1, #0x201
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_DEVICE;
700a9f08: f8ad 1010    	strh.w	r1, [sp, #0x10]
700a9f0c: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a9f0e: 9105         	str	r1, [sp, #0x14]
700a9f10: a90e         	add	r1, sp, #0x38
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a9f12: 9106         	str	r1, [sp, #0x18]
700a9f14: 210c         	movs	r1, #0xc
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a9f16: 9107         	str	r1, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a9f18: 9918         	ldr	r1, [sp, #0x60]
700a9f1a: 9108         	str	r1, [sp, #0x20]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9f1c: 9001         	str	r0, [sp, #0x4]
700a9f1e: a809         	add	r0, sp, #0x24
;     respParam.pRespPayload    = (uint8_t *) &response;
700a9f20: 9002         	str	r0, [sp, #0x8]
700a9f22: 2012         	movs	r0, #0x12
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a9f24: 9003         	str	r0, [sp, #0xc]
700a9f26: a804         	add	r0, sp, #0x10
700a9f28: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9f2a: f7f3 fb61    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xc93e
700a9f2e: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a9f30: 9811         	ldr	r0, [sp, #0x44]
700a9f32: b930         	cbnz	r0, 0x700a9f42 <Sciclient_pmGetModuleState+0x62> @ imm = #0xc
700a9f34: e7ff         	b	0x700a9f36 <Sciclient_pmGetModuleState+0x56> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a9f36: 9801         	ldr	r0, [sp, #0x4]
700a9f38: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9f3c: 2802         	cmp	r0, #0x2
700a9f3e: d004         	beq	0x700a9f4a <Sciclient_pmGetModuleState+0x6a> @ imm = #0x8
700a9f40: e7ff         	b	0x700a9f42 <Sciclient_pmGetModuleState+0x62> @ imm = #-0x2
700a9f42: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9f46: 9011         	str	r0, [sp, #0x44]
;     }
700a9f48: e7ff         	b	0x700a9f4a <Sciclient_pmGetModuleState+0x6a> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a9f4a: 9811         	ldr	r0, [sp, #0x44]
700a9f4c: b958         	cbnz	r0, 0x700a9f66 <Sciclient_pmGetModuleState+0x86> @ imm = #0x16
700a9f4e: e7ff         	b	0x700a9f50 <Sciclient_pmGetModuleState+0x70> @ imm = #-0x2
;         *moduleState = (uint32_t) response.current_state;
700a9f50: f89d 0035    	ldrb.w	r0, [sp, #0x35]
700a9f54: 9914         	ldr	r1, [sp, #0x50]
700a9f56: 6008         	str	r0, [r1]
;         *resetState = (uint32_t) response.resets;
700a9f58: 980c         	ldr	r0, [sp, #0x30]
700a9f5a: 9913         	ldr	r1, [sp, #0x4c]
700a9f5c: 6008         	str	r0, [r1]
;         *contextLossState = (uint32_t) response.context_loss_count;
700a9f5e: 980b         	ldr	r0, [sp, #0x2c]
700a9f60: 9912         	ldr	r1, [sp, #0x48]
700a9f62: 6008         	str	r0, [r1]
;     }
700a9f64: e7ff         	b	0x700a9f66 <Sciclient_pmGetModuleState+0x86> @ imm = #-0x2
;     return retVal;
700a9f66: 9811         	ldr	r0, [sp, #0x44]
700a9f68: b016         	add	sp, #0x58
700a9f6a: bd80         	pop	{r7, pc}
700a9f6c: 0000         	movs	r0, r0
700a9f6e: 0000         	movs	r0, r0

700a9f70 <Sciclient_pmModuleClkRequest>:
; {
700a9f70: b580         	push	{r7, lr}
700a9f72: b092         	sub	sp, #0x48
700a9f74: f8dd c050    	ldr.w	r12, [sp, #0x50]
700a9f78: 9011         	str	r0, [sp, #0x44]
700a9f7a: 9110         	str	r1, [sp, #0x40]
700a9f7c: 920f         	str	r2, [sp, #0x3c]
700a9f7e: 930e         	str	r3, [sp, #0x38]
700a9f80: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a9f82: 900d         	str	r0, [sp, #0x34]
;     request.device = (uint32_t) moduleId;
700a9f84: 9811         	ldr	r0, [sp, #0x44]
700a9f86: 900a         	str	r0, [sp, #0x28]
;     if(clockId > (uint32_t)(255U))
700a9f88: 9810         	ldr	r0, [sp, #0x40]
700a9f8a: f5b0 7f80    	cmp.w	r0, #0x100
700a9f8e: d307         	blo	0x700a9fa0 <Sciclient_pmModuleClkRequest+0x30> @ imm = #0xe
700a9f90: e7ff         	b	0x700a9f92 <Sciclient_pmModuleClkRequest+0x22> @ imm = #-0x2
700a9f92: 20ff         	movs	r0, #0xff
;         request.clk = (uint8_t)(255U);
700a9f94: f88d 002c    	strb.w	r0, [sp, #0x2c]
;         request.clk32 = clockId;
700a9f98: 9810         	ldr	r0, [sp, #0x40]
700a9f9a: f8cd 002e    	str.w	r0, [sp, #0x2e]
;     }
700a9f9e: e003         	b	0x700a9fa8 <Sciclient_pmModuleClkRequest+0x38> @ imm = #0x6
;         request.clk    = (uint8_t)clockId;
700a9fa0: 9810         	ldr	r0, [sp, #0x40]
700a9fa2: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a9fa6: e7ff         	b	0x700a9fa8 <Sciclient_pmModuleClkRequest+0x38> @ imm = #-0x2
;     request.state  = (uint8_t) state;
700a9fa8: 980f         	ldr	r0, [sp, #0x3c]
700a9faa: f88d 002d    	strb.w	r0, [sp, #0x2d]
700a9fae: f44f 7080    	mov.w	r0, #0x100
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_CLOCK;
700a9fb2: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP | additionalFlag;
700a9fb6: 980e         	ldr	r0, [sp, #0x38]
700a9fb8: f040 0002    	orr	r0, r0, #0x2
700a9fbc: 9004         	str	r0, [sp, #0x10]
700a9fbe: a808         	add	r0, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a9fc0: 9005         	str	r0, [sp, #0x14]
700a9fc2: 2012         	movs	r0, #0x12
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a9fc4: 9006         	str	r0, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a9fc6: 9814         	ldr	r0, [sp, #0x50]
700a9fc8: 9007         	str	r0, [sp, #0x1c]
700a9fca: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9fcc: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a9fce: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700a9fd0: 9002         	str	r0, [sp, #0x8]
700a9fd2: a803         	add	r0, sp, #0xc
700a9fd4: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9fd6: f7f3 fb0b    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xc9ea
700a9fda: 900d         	str	r0, [sp, #0x34]
;     if((retVal != SystemP_SUCCESS) ||
700a9fdc: 980d         	ldr	r0, [sp, #0x34]
700a9fde: b930         	cbnz	r0, 0x700a9fee <Sciclient_pmModuleClkRequest+0x7e> @ imm = #0xc
700a9fe0: e7ff         	b	0x700a9fe2 <Sciclient_pmModuleClkRequest+0x72> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a9fe2: 9800         	ldr	r0, [sp]
700a9fe4: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9fe8: 2802         	cmp	r0, #0x2
700a9fea: d004         	beq	0x700a9ff6 <Sciclient_pmModuleClkRequest+0x86> @ imm = #0x8
700a9fec: e7ff         	b	0x700a9fee <Sciclient_pmModuleClkRequest+0x7e> @ imm = #-0x2
700a9fee: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9ff2: 900d         	str	r0, [sp, #0x34]
;     }
700a9ff4: e7ff         	b	0x700a9ff6 <Sciclient_pmModuleClkRequest+0x86> @ imm = #-0x2
;     return retVal;
700a9ff6: 980d         	ldr	r0, [sp, #0x34]
700a9ff8: b012         	add	sp, #0x48
700a9ffa: bd80         	pop	{r7, pc}
700a9ffc: 0000         	movs	r0, r0
700a9ffe: 0000         	movs	r0, r0

700aa000 <Sciclient_pmSetModuleState>:
; {
700aa000: b580         	push	{r7, lr}
700aa002: b092         	sub	sp, #0x48
700aa004: 9011         	str	r0, [sp, #0x44]
700aa006: 9110         	str	r1, [sp, #0x40]
700aa008: 920f         	str	r2, [sp, #0x3c]
700aa00a: 930e         	str	r3, [sp, #0x38]
700aa00c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700aa00e: 900d         	str	r0, [sp, #0x34]
;     request.id       = (uint32_t) moduleId;
700aa010: 9911         	ldr	r1, [sp, #0x44]
700aa012: 910a         	str	r1, [sp, #0x28]
;     request.reserved = (uint32_t) 0;
700aa014: 900b         	str	r0, [sp, #0x2c]
;     request.state    = (uint8_t) state;
700aa016: 9910         	ldr	r1, [sp, #0x40]
700aa018: f88d 1030    	strb.w	r1, [sp, #0x30]
700aa01c: f44f 7100    	mov.w	r1, #0x200
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_DEVICE;
700aa020: f8ad 100c    	strh.w	r1, [sp, #0xc]
;     reqParam.flags          = (uint32_t) reqFlag;
700aa024: 990f         	ldr	r1, [sp, #0x3c]
700aa026: 9104         	str	r1, [sp, #0x10]
700aa028: a908         	add	r1, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700aa02a: 9105         	str	r1, [sp, #0x14]
700aa02c: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700aa02e: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700aa030: 990e         	ldr	r1, [sp, #0x38]
700aa032: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700aa034: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700aa036: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700aa038: 9002         	str	r0, [sp, #0x8]
;     if (((reqFlag & TISCI_MSG_FLAG_AOP) != TISCI_MSG_FLAG_AOP)&&
700aa03a: 980f         	ldr	r0, [sp, #0x3c]
700aa03c: f000 0002    	and	r0, r0, #0x2
700aa040: 2802         	cmp	r0, #0x2
700aa042: d007         	beq	0x700aa054 <Sciclient_pmSetModuleState+0x54> @ imm = #0xe
700aa044: e7ff         	b	0x700aa046 <Sciclient_pmSetModuleState+0x46> @ imm = #-0x2
;         (reqFlag != 0U))
700aa046: 980f         	ldr	r0, [sp, #0x3c]
;     if (((reqFlag & TISCI_MSG_FLAG_AOP) != TISCI_MSG_FLAG_AOP)&&
700aa048: b120         	cbz	r0, 0x700aa054 <Sciclient_pmSetModuleState+0x54> @ imm = #0x8
700aa04a: e7ff         	b	0x700aa04c <Sciclient_pmSetModuleState+0x4c> @ imm = #-0x2
700aa04c: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700aa050: 900d         	str	r0, [sp, #0x34]
;     }
700aa052: e7ff         	b	0x700aa054 <Sciclient_pmSetModuleState+0x54> @ imm = #-0x2
;     if(retVal == SystemP_SUCCESS)
700aa054: 980d         	ldr	r0, [sp, #0x34]
700aa056: b930         	cbnz	r0, 0x700aa066 <Sciclient_pmSetModuleState+0x66> @ imm = #0xc
700aa058: e7ff         	b	0x700aa05a <Sciclient_pmSetModuleState+0x5a> @ imm = #-0x2
700aa05a: a803         	add	r0, sp, #0xc
700aa05c: 4669         	mov	r1, sp
;         retVal = Sciclient_service(&reqParam, &respParam);
700aa05e: f7f3 fac7    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xca72
700aa062: 900d         	str	r0, [sp, #0x34]
;     }
700aa064: e7ff         	b	0x700aa066 <Sciclient_pmSetModuleState+0x66> @ imm = #-0x2
;     if((retVal != SystemP_SUCCESS) ||
700aa066: 980d         	ldr	r0, [sp, #0x34]
700aa068: b948         	cbnz	r0, 0x700aa07e <Sciclient_pmSetModuleState+0x7e> @ imm = #0x12
700aa06a: e7ff         	b	0x700aa06c <Sciclient_pmSetModuleState+0x6c> @ imm = #-0x2
;         ((reqFlag != 0U) &&
700aa06c: 980f         	ldr	r0, [sp, #0x3c]
700aa06e: b150         	cbz	r0, 0x700aa086 <Sciclient_pmSetModuleState+0x86> @ imm = #0x14
700aa070: e7ff         	b	0x700aa072 <Sciclient_pmSetModuleState+0x72> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)))
700aa072: 9800         	ldr	r0, [sp]
700aa074: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700aa078: 2802         	cmp	r0, #0x2
700aa07a: d004         	beq	0x700aa086 <Sciclient_pmSetModuleState+0x86> @ imm = #0x8
700aa07c: e7ff         	b	0x700aa07e <Sciclient_pmSetModuleState+0x7e> @ imm = #-0x2
700aa07e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700aa082: 900d         	str	r0, [sp, #0x34]
;     }
700aa084: e7ff         	b	0x700aa086 <Sciclient_pmSetModuleState+0x86> @ imm = #-0x2
;     return retVal;
700aa086: 980d         	ldr	r0, [sp, #0x34]
700aa088: b012         	add	sp, #0x48
700aa08a: bd80         	pop	{r7, pc}
700aa08c: 0000         	movs	r0, r0
700aa08e: 0000         	movs	r0, r0

700aa090 <Sciclient_rmIaEvtRomMapped>:
; {
700aa090: b082         	sub	sp, #0x8
700aa092: 9001         	str	r0, [sp, #0x4]
700aa094: f8ad 1002    	strh.w	r1, [sp, #0x2]
700aa098: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700aa09a: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700aa09e: 9801         	ldr	r0, [sp, #0x4]
700aa0a0: 6980         	ldr	r0, [r0, #0x18]
700aa0a2: b3a8         	cbz	r0, 0x700aa110 <Sciclient_rmIaEvtRomMapped+0x80> @ imm = #0x6a
700aa0a4: e7ff         	b	0x700aa0a6 <Sciclient_rmIaEvtRomMapped+0x16> @ imm = #-0x2
700aa0a6: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700aa0a8: f88d 0000    	strb.w	r0, [sp]
700aa0ac: e7ff         	b	0x700aa0ae <Sciclient_rmIaEvtRomMapped+0x1e> @ imm = #-0x2
700aa0ae: f89d 0000    	ldrb.w	r0, [sp]
700aa0b2: 9901         	ldr	r1, [sp, #0x4]
700aa0b4: 7f09         	ldrb	r1, [r1, #0x1c]
700aa0b6: 4288         	cmp	r0, r1
700aa0b8: da29         	bge	0x700aa10e <Sciclient_rmIaEvtRomMapped+0x7e> @ imm = #0x52
700aa0ba: e7ff         	b	0x700aa0bc <Sciclient_rmIaEvtRomMapped+0x2c> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700aa0bc: 9801         	ldr	r0, [sp, #0x4]
700aa0be: 6980         	ldr	r0, [r0, #0x18]
700aa0c0: f89d 1000    	ldrb.w	r1, [sp]
700aa0c4: eb00 0081    	add.w	r0, r0, r1, lsl #2
700aa0c8: 7880         	ldrb	r0, [r0, #0x2]
700aa0ca: 07c0         	lsls	r0, r0, #0x1f
700aa0cc: b9c0         	cbnz	r0, 0x700aa100 <Sciclient_rmIaEvtRomMapped+0x70> @ imm = #0x30
700aa0ce: e7ff         	b	0x700aa0d0 <Sciclient_rmIaEvtRomMapped+0x40> @ imm = #-0x2
;                 (evt == (inst->rom_usage[i].event - inst->sevt_offset))) {
700aa0d0: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700aa0d4: 9a01         	ldr	r2, [sp, #0x4]
700aa0d6: 6991         	ldr	r1, [r2, #0x18]
700aa0d8: f89d 3000    	ldrb.w	r3, [sp]
700aa0dc: f831 1023    	ldrh.w	r1, [r1, r3, lsl #2]
700aa0e0: 8912         	ldrh	r2, [r2, #0x8]
700aa0e2: 1a89         	subs	r1, r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700aa0e4: 4288         	cmp	r0, r1
700aa0e6: d10b         	bne	0x700aa100 <Sciclient_rmIaEvtRomMapped+0x70> @ imm = #0x16
700aa0e8: e7ff         	b	0x700aa0ea <Sciclient_rmIaEvtRomMapped+0x5a> @ imm = #-0x2
700aa0ea: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700aa0ec: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700aa0f0: 9901         	ldr	r1, [sp, #0x4]
700aa0f2: 6989         	ldr	r1, [r1, #0x18]
700aa0f4: f89d 2000    	ldrb.w	r2, [sp]
700aa0f8: eb01 0182    	add.w	r1, r1, r2, lsl #2
700aa0fc: 7088         	strb	r0, [r1, #0x2]
;                 break;
700aa0fe: e006         	b	0x700aa10e <Sciclient_rmIaEvtRomMapped+0x7e> @ imm = #0xc
;         }
700aa100: e7ff         	b	0x700aa102 <Sciclient_rmIaEvtRomMapped+0x72> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700aa102: f89d 0000    	ldrb.w	r0, [sp]
700aa106: 3001         	adds	r0, #0x1
700aa108: f88d 0000    	strb.w	r0, [sp]
700aa10c: e7cf         	b	0x700aa0ae <Sciclient_rmIaEvtRomMapped+0x1e> @ imm = #-0x62
;     }
700aa10e: e7ff         	b	0x700aa110 <Sciclient_rmIaEvtRomMapped+0x80> @ imm = #-0x2
;     return rom_mapped;
700aa110: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700aa114: f000 0001    	and	r0, r0, #0x1
700aa118: b002         	add	sp, #0x8
700aa11a: 4770         	bx	lr
700aa11c: 0000         	movs	r0, r0
700aa11e: 0000         	movs	r0, r0

700aa120 <UART_writeCancelNoCB>:
; {
700aa120: b580         	push	{r7, lr}
700aa122: b084         	sub	sp, #0x10
700aa124: 9003         	str	r0, [sp, #0xc]
700aa126: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700aa128: 9001         	str	r0, [sp, #0x4]
;     hUartInit = hUart->hUartInit;
700aa12a: 9803         	ldr	r0, [sp, #0xc]
700aa12c: 6840         	ldr	r0, [r0, #0x4]
700aa12e: 9000         	str	r0, [sp]
;     UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
700aa130: 9803         	ldr	r0, [sp, #0xc]
700aa132: 6800         	ldr	r0, [r0]
700aa134: 2102         	movs	r1, #0x2
700aa136: f7fc f913    	bl	0x700a6360 <UART_intrDisable> @ imm = #-0x3dda
;     key = HwiP_disable();
700aa13a: f006 ec12    	blx	0x700b0960 <HwiP_disable> @ imm = #0x6824
700aa13e: 9002         	str	r0, [sp, #0x8]
;     if ((hUart->writeSizeRemaining) == 0U)
700aa140: 9803         	ldr	r0, [sp, #0xc]
700aa142: 6900         	ldr	r0, [r0, #0x10]
700aa144: b920         	cbnz	r0, 0x700aa150 <UART_writeCancelNoCB+0x30> @ imm = #0x8
700aa146: e7ff         	b	0x700aa148 <UART_writeCancelNoCB+0x28> @ imm = #-0x2
700aa148: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700aa14c: 9001         	str	r0, [sp, #0x4]
;     }
700aa14e: e027         	b	0x700aa1a0 <UART_writeCancelNoCB+0x80> @ imm = #0x4e
;         if (hUartInit->transferMode == UART_CONFIG_MODE_DMA)
700aa150: 9800         	ldr	r0, [sp]
700aa152: 6a00         	ldr	r0, [r0, #0x20]
700aa154: 2803         	cmp	r0, #0x3
700aa156: d111         	bne	0x700aa17c <UART_writeCancelNoCB+0x5c> @ imm = #0x22
700aa158: e7ff         	b	0x700aa15a <UART_writeCancelNoCB+0x3a> @ imm = #-0x2
;             UART_lld_dmaDisableChannel(hUart, (Bool)TRUE);
700aa15a: 9803         	ldr	r0, [sp, #0xc]
700aa15c: 2101         	movs	r1, #0x1
700aa15e: f7ff fc4f    	bl	0x700a9a00 <UART_lld_dmaDisableChannel> @ imm = #-0x762
;             if (hUart->writeTrans.buf != NULL)
700aa162: 9803         	ldr	r0, [sp, #0xc]
700aa164: 6bc0         	ldr	r0, [r0, #0x3c]
700aa166: b120         	cbz	r0, 0x700aa172 <UART_writeCancelNoCB+0x52> @ imm = #0x8
700aa168: e7ff         	b	0x700aa16a <UART_writeCancelNoCB+0x4a> @ imm = #-0x2
;                 hUart->writeTrans.count = 0;
700aa16a: 9903         	ldr	r1, [sp, #0xc]
700aa16c: 2000         	movs	r0, #0x0
700aa16e: 6408         	str	r0, [r1, #0x40]
;             }
700aa170: e003         	b	0x700aa17a <UART_writeCancelNoCB+0x5a> @ imm = #0x6
;                 hUart->writeCount = 0;
700aa172: 9903         	ldr	r1, [sp, #0xc]
700aa174: 2000         	movs	r0, #0x0
700aa176: 60c8         	str	r0, [r1, #0xc]
700aa178: e7ff         	b	0x700aa17a <UART_writeCancelNoCB+0x5a> @ imm = #-0x2
;         }
700aa17a: e010         	b	0x700aa19e <UART_writeCancelNoCB+0x7e> @ imm = #0x20
;             hUart->writeBuf = (const uint8_t *)hUart->writeBuf - hUart->writeCount;
700aa17c: 9903         	ldr	r1, [sp, #0xc]
700aa17e: 6888         	ldr	r0, [r1, #0x8]
700aa180: 68ca         	ldr	r2, [r1, #0xc]
700aa182: 1a80         	subs	r0, r0, r2
700aa184: 6088         	str	r0, [r1, #0x8]
;             if (hUart->writeTrans.buf != NULL)
700aa186: 9803         	ldr	r0, [sp, #0xc]
700aa188: 6bc0         	ldr	r0, [r0, #0x3c]
700aa18a: b120         	cbz	r0, 0x700aa196 <UART_writeCancelNoCB+0x76> @ imm = #0x8
700aa18c: e7ff         	b	0x700aa18e <UART_writeCancelNoCB+0x6e> @ imm = #-0x2
;                 hUart->writeTrans.count = (uint32_t)(hUart->writeCount);
700aa18e: 9903         	ldr	r1, [sp, #0xc]
700aa190: 68c8         	ldr	r0, [r1, #0xc]
700aa192: 6408         	str	r0, [r1, #0x40]
;             }
700aa194: e7ff         	b	0x700aa196 <UART_writeCancelNoCB+0x76> @ imm = #-0x2
;             hUart->writeSizeRemaining = 0;
700aa196: 9903         	ldr	r1, [sp, #0xc]
700aa198: 2000         	movs	r0, #0x0
700aa19a: 6108         	str	r0, [r1, #0x10]
700aa19c: e7ff         	b	0x700aa19e <UART_writeCancelNoCB+0x7e> @ imm = #-0x2
700aa19e: e7ff         	b	0x700aa1a0 <UART_writeCancelNoCB+0x80> @ imm = #-0x2
;     HwiP_restore(key);
700aa1a0: 9802         	ldr	r0, [sp, #0x8]
700aa1a2: f006 ebfe    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x67fc
;     return (status);
700aa1a6: 9801         	ldr	r0, [sp, #0x4]
700aa1a8: b004         	add	sp, #0x10
700aa1aa: bd80         	pop	{r7, pc}
700aa1ac: 0000         	movs	r0, r0
700aa1ae: 0000         	movs	r0, r0

700aa1b0 <Udma_ringFlushRaw>:
; {
700aa1b0: b580         	push	{r7, lr}
700aa1b2: b086         	sub	sp, #0x18
700aa1b4: 9005         	str	r0, [sp, #0x14]
700aa1b6: 9104         	str	r1, [sp, #0x10]
700aa1b8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700aa1ba: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700aa1bc: 9805         	ldr	r0, [sp, #0x14]
700aa1be: 9001         	str	r0, [sp, #0x4]
;     if((NULL_PTR == ringHandleInt) ||
700aa1c0: 9801         	ldr	r0, [sp, #0x4]
700aa1c2: b180         	cbz	r0, 0x700aa1e6 <Udma_ringFlushRaw+0x36> @ imm = #0x20
700aa1c4: e7ff         	b	0x700aa1c6 <Udma_ringFlushRaw+0x16> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700aa1c6: 9801         	ldr	r0, [sp, #0x4]
700aa1c8: 6d80         	ldr	r0, [r0, #0x58]
700aa1ca: f64a 31cd    	movw	r1, #0xabcd
700aa1ce: f6ca 31dc    	movt	r1, #0xabdc
700aa1d2: 4288         	cmp	r0, r1
700aa1d4: d107         	bne	0x700aa1e6 <Udma_ringFlushRaw+0x36> @ imm = #0xe
700aa1d6: e7ff         	b	0x700aa1d8 <Udma_ringFlushRaw+0x28> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700aa1d8: 9801         	ldr	r0, [sp, #0x4]
700aa1da: 8880         	ldrh	r0, [r0, #0x4]
700aa1dc: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700aa1e0: 4288         	cmp	r0, r1
700aa1e2: d104         	bne	0x700aa1ee <Udma_ringFlushRaw+0x3e> @ imm = #0x8
700aa1e4: e7ff         	b	0x700aa1e6 <Udma_ringFlushRaw+0x36> @ imm = #-0x2
700aa1e6: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700aa1ea: 9003         	str	r0, [sp, #0xc]
;     }
700aa1ec: e7ff         	b	0x700aa1ee <Udma_ringFlushRaw+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aa1ee: 9803         	ldr	r0, [sp, #0xc]
700aa1f0: b9a8         	cbnz	r0, 0x700aa21e <Udma_ringFlushRaw+0x6e> @ imm = #0x2a
700aa1f2: e7ff         	b	0x700aa1f4 <Udma_ringFlushRaw+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700aa1f4: 9801         	ldr	r0, [sp, #0x4]
700aa1f6: 6800         	ldr	r0, [r0]
700aa1f8: 9002         	str	r0, [sp, #0x8]
;         if((NULL_PTR == drvHandle) ||
700aa1fa: 9802         	ldr	r0, [sp, #0x8]
700aa1fc: b150         	cbz	r0, 0x700aa214 <Udma_ringFlushRaw+0x64> @ imm = #0x14
700aa1fe: e7ff         	b	0x700aa200 <Udma_ringFlushRaw+0x50> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700aa200: 9802         	ldr	r0, [sp, #0x8]
700aa202: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700aa206: f64a 31cd    	movw	r1, #0xabcd
700aa20a: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700aa20e: 4288         	cmp	r0, r1
700aa210: d004         	beq	0x700aa21c <Udma_ringFlushRaw+0x6c> @ imm = #0x8
700aa212: e7ff         	b	0x700aa214 <Udma_ringFlushRaw+0x64> @ imm = #-0x2
700aa214: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700aa218: 9003         	str	r0, [sp, #0xc]
;         }
700aa21a: e7ff         	b	0x700aa21c <Udma_ringFlushRaw+0x6c> @ imm = #-0x2
;     }
700aa21c: e7ff         	b	0x700aa21e <Udma_ringFlushRaw+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aa21e: 9803         	ldr	r0, [sp, #0xc]
700aa220: b940         	cbnz	r0, 0x700aa234 <Udma_ringFlushRaw+0x84> @ imm = #0x10
700aa222: e7ff         	b	0x700aa224 <Udma_ringFlushRaw+0x74> @ imm = #-0x2
;         retVal = drvHandle->ringFlushRaw(drvHandle, ringHandleInt, phyDescMem);
700aa224: 9802         	ldr	r0, [sp, #0x8]
700aa226: f8d0 3598    	ldr.w	r3, [r0, #0x598]
700aa22a: 9901         	ldr	r1, [sp, #0x4]
700aa22c: 9a04         	ldr	r2, [sp, #0x10]
700aa22e: 4798         	blx	r3
700aa230: 9003         	str	r0, [sp, #0xc]
;     }
700aa232: e7ff         	b	0x700aa234 <Udma_ringFlushRaw+0x84> @ imm = #-0x2
;     return (retVal);
700aa234: 9803         	ldr	r0, [sp, #0xc]
700aa236: b006         	add	sp, #0x18
700aa238: bd80         	pop	{r7, pc}
700aa23a: 0000         	movs	r0, r0
700aa23c: 0000         	movs	r0, r0
700aa23e: 0000         	movs	r0, r0

700aa240 <xQueueGenericReset>:
; {
700aa240: b580         	push	{r7, lr}
700aa242: b084         	sub	sp, #0x10
700aa244: 9003         	str	r0, [sp, #0xc]
700aa246: 9102         	str	r1, [sp, #0x8]
;     Queue_t * const pxQueue = xQueue;
700aa248: 9803         	ldr	r0, [sp, #0xc]
700aa24a: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700aa24c: f004 fa98    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0x4530
;         pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700aa250: 9901         	ldr	r1, [sp, #0x4]
700aa252: 680b         	ldr	r3, [r1]
700aa254: 6bc8         	ldr	r0, [r1, #0x3c]
700aa256: 6c0a         	ldr	r2, [r1, #0x40]
700aa258: fb00 3002    	mla	r0, r0, r2, r3
700aa25c: 6088         	str	r0, [r1, #0x8]
;         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
700aa25e: 9901         	ldr	r1, [sp, #0x4]
700aa260: 2000         	movs	r0, #0x0
700aa262: 6388         	str	r0, [r1, #0x38]
;         pxQueue->pcWriteTo = pxQueue->pcHead;
700aa264: 9901         	ldr	r1, [sp, #0x4]
700aa266: 6808         	ldr	r0, [r1]
700aa268: 6048         	str	r0, [r1, #0x4]
;         pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700aa26a: 9901         	ldr	r1, [sp, #0x4]
700aa26c: 680b         	ldr	r3, [r1]
700aa26e: 6bc8         	ldr	r0, [r1, #0x3c]
700aa270: 6c0a         	ldr	r2, [r1, #0x40]
700aa272: 3801         	subs	r0, #0x1
700aa274: fb00 3002    	mla	r0, r0, r2, r3
700aa278: 60c8         	str	r0, [r1, #0xc]
;         pxQueue->cRxLock = queueUNLOCKED;
700aa27a: 9901         	ldr	r1, [sp, #0x4]
700aa27c: 20ff         	movs	r0, #0xff
700aa27e: f881 0044    	strb.w	r0, [r1, #0x44]
;         pxQueue->cTxLock = queueUNLOCKED;
700aa282: 9901         	ldr	r1, [sp, #0x4]
700aa284: f881 0045    	strb.w	r0, [r1, #0x45]
;         if( xNewQueue == pdFALSE )
700aa288: 9802         	ldr	r0, [sp, #0x8]
700aa28a: b980         	cbnz	r0, 0x700aa2ae <xQueueGenericReset+0x6e> @ imm = #0x20
700aa28c: e7ff         	b	0x700aa28e <xQueueGenericReset+0x4e> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700aa28e: 9801         	ldr	r0, [sp, #0x4]
700aa290: 6900         	ldr	r0, [r0, #0x10]
700aa292: b150         	cbz	r0, 0x700aa2aa <xQueueGenericReset+0x6a> @ imm = #0x14
700aa294: e7ff         	b	0x700aa296 <xQueueGenericReset+0x56> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700aa296: 9801         	ldr	r0, [sp, #0x4]
700aa298: 3010         	adds	r0, #0x10
700aa29a: f7fd fc39    	bl	0x700a7b10 <xTaskRemoveFromEventList> @ imm = #-0x278e
700aa29e: b110         	cbz	r0, 0x700aa2a6 <xQueueGenericReset+0x66> @ imm = #0x4
700aa2a0: e7ff         	b	0x700aa2a2 <xQueueGenericReset+0x62> @ imm = #-0x2
;                     queueYIELD_IF_USING_PREEMPTION();
700aa2a2: df00         	svc	#0x0
;                 }
700aa2a4: e000         	b	0x700aa2a8 <xQueueGenericReset+0x68> @ imm = #0x0
700aa2a6: e7ff         	b	0x700aa2a8 <xQueueGenericReset+0x68> @ imm = #-0x2
;             }
700aa2a8: e000         	b	0x700aa2ac <xQueueGenericReset+0x6c> @ imm = #0x0
700aa2aa: e7ff         	b	0x700aa2ac <xQueueGenericReset+0x6c> @ imm = #-0x2
;         }
700aa2ac: e008         	b	0x700aa2c0 <xQueueGenericReset+0x80> @ imm = #0x10
;             vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
700aa2ae: 9801         	ldr	r0, [sp, #0x4]
700aa2b0: 3010         	adds	r0, #0x10
700aa2b2: f004 fbf5    	bl	0x700aeaa0 <vListInitialise> @ imm = #0x47ea
;             vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
700aa2b6: 9801         	ldr	r0, [sp, #0x4]
700aa2b8: 3024         	adds	r0, #0x24
700aa2ba: f004 fbf1    	bl	0x700aeaa0 <vListInitialise> @ imm = #0x47e2
700aa2be: e7ff         	b	0x700aa2c0 <xQueueGenericReset+0x80> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700aa2c0: f003 fb1e    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0x363c
700aa2c4: 2001         	movs	r0, #0x1
;     return pdPASS;
700aa2c6: b004         	add	sp, #0x10
700aa2c8: bd80         	pop	{r7, pc}
700aa2ca: 0000         	movs	r0, r0
700aa2cc: 0000         	movs	r0, r0
700aa2ce: 0000         	movs	r0, r0

700aa2d0 <CSL_bcdmaGetCfg>:
; {
700aa2d0: b580         	push	{r7, lr}
700aa2d2: b082         	sub	sp, #0x8
700aa2d4: 9001         	str	r0, [sp, #0x4]
;     if( ! ((pCfg == NULL) || (pCfg->pGenCfgRegs == NULL)) )
700aa2d6: 9801         	ldr	r0, [sp, #0x4]
700aa2d8: b3e0         	cbz	r0, 0x700aa354 <CSL_bcdmaGetCfg+0x84> @ imm = #0x78
700aa2da: e7ff         	b	0x700aa2dc <CSL_bcdmaGetCfg+0xc> @ imm = #-0x2
700aa2dc: 9801         	ldr	r0, [sp, #0x4]
700aa2de: 6800         	ldr	r0, [r0]
700aa2e0: b3c0         	cbz	r0, 0x700aa354 <CSL_bcdmaGetCfg+0x84> @ imm = #0x70
700aa2e2: e7ff         	b	0x700aa2e4 <CSL_bcdmaGetCfg+0x14> @ imm = #-0x2
;         pCfg->cap0 = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP0 );
700aa2e4: 9801         	ldr	r0, [sp, #0x4]
700aa2e6: 6800         	ldr	r0, [r0]
700aa2e8: 3020         	adds	r0, #0x20
700aa2ea: f005 fc91    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0x5922
700aa2ee: 9901         	ldr	r1, [sp, #0x4]
700aa2f0: 61c8         	str	r0, [r1, #0x1c]
;         pCfg->cap1 = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP1 );
700aa2f2: 9801         	ldr	r0, [sp, #0x4]
700aa2f4: 6800         	ldr	r0, [r0]
700aa2f6: 3024         	adds	r0, #0x24
700aa2f8: f005 fc8a    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0x5914
700aa2fc: 9901         	ldr	r1, [sp, #0x4]
700aa2fe: 6208         	str	r0, [r1, #0x20]
;         regVal = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP2 );
700aa300: 9801         	ldr	r0, [sp, #0x4]
700aa302: 6800         	ldr	r0, [r0]
700aa304: 3028         	adds	r0, #0x28
700aa306: f005 fc83    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0x5906
700aa30a: 9000         	str	r0, [sp]
;         pCfg->bcChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_CHAN_CNT );
700aa30c: 9800         	ldr	r0, [sp]
700aa30e: f36f 205f    	bfc	r0, #9, #23
700aa312: 9901         	ldr	r1, [sp, #0x4]
700aa314: 6248         	str	r0, [r1, #0x24]
;         pCfg->splitTxChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_TCHAN_CNT );
700aa316: 9800         	ldr	r0, [sp]
700aa318: f3c0 2048    	ubfx	r0, r0, #0x9, #0x9
700aa31c: 9901         	ldr	r1, [sp, #0x4]
700aa31e: 62c8         	str	r0, [r1, #0x2c]
;         pCfg->splitRxChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_RCHAN_CNT );
700aa320: 9800         	ldr	r0, [sp]
700aa322: f3c0 4088    	ubfx	r0, r0, #0x12, #0x9
700aa326: 9901         	ldr	r1, [sp, #0x4]
700aa328: 6288         	str	r0, [r1, #0x28]
;         pCfg->flowCnt = (uint32_t)0U;
700aa32a: 9901         	ldr	r1, [sp, #0x4]
700aa32c: 2000         	movs	r0, #0x0
700aa32e: 6308         	str	r0, [r1, #0x30]
;         pCfg->txChanCnt                     = pCfg->bcChanCnt + pCfg->splitTxChanCnt;
700aa330: 9a01         	ldr	r2, [sp, #0x4]
700aa332: 6a51         	ldr	r1, [r2, #0x24]
700aa334: 6ad3         	ldr	r3, [r2, #0x2c]
700aa336: 4419         	add	r1, r3
700aa338: 6351         	str	r1, [r2, #0x34]
;         pCfg->rxChanCnt                     = pCfg->splitRxChanCnt;
700aa33a: 9a01         	ldr	r2, [sp, #0x4]
700aa33c: 6a91         	ldr	r1, [r2, #0x28]
700aa33e: 6391         	str	r1, [r2, #0x38]
;         pCfg->rxFlowCnt                     = pCfg->flowCnt;
700aa340: 9a01         	ldr	r2, [sp, #0x4]
700aa342: 6b11         	ldr	r1, [r2, #0x30]
700aa344: 63d1         	str	r1, [r2, #0x3c]
;         pCfg->txExtUtcChanCnt               = (uint32_t)0U;
700aa346: 9901         	ldr	r1, [sp, #0x4]
700aa348: 6408         	str	r0, [r1, #0x40]
;         pCfg->txHighCapacityChanCnt         = (uint32_t)0U;
700aa34a: 9901         	ldr	r1, [sp, #0x4]
700aa34c: 6448         	str	r0, [r1, #0x44]
;         pCfg->txUltraHighCapacityChanCnt    = (uint32_t)0U;
700aa34e: 9901         	ldr	r1, [sp, #0x4]
700aa350: 6488         	str	r0, [r1, #0x48]
;     }
700aa352: e7ff         	b	0x700aa354 <CSL_bcdmaGetCfg+0x84> @ imm = #-0x2
; }
700aa354: b002         	add	sp, #0x8
700aa356: bd80         	pop	{r7, pc}
		...

700aa360 <Udma_rmFreeVintrBit>:
; {
700aa360: b580         	push	{r7, lr}
700aa362: b088         	sub	sp, #0x20
700aa364: 9007         	str	r0, [sp, #0x1c]
700aa366: 9106         	str	r1, [sp, #0x18]
700aa368: 9205         	str	r2, [sp, #0x14]
;     controllerEventHandle = eventHandle;
700aa36a: 9805         	ldr	r0, [sp, #0x14]
700aa36c: 9001         	str	r0, [sp, #0x4]
;     eventPrms = &eventHandle->eventPrms;
700aa36e: 9805         	ldr	r0, [sp, #0x14]
700aa370: 3008         	adds	r0, #0x8
700aa372: 9000         	str	r0, [sp]
;     if(NULL_PTR != eventPrms->controllerEventHandle)
700aa374: 9800         	ldr	r0, [sp]
700aa376: 6900         	ldr	r0, [r0, #0x10]
700aa378: b120         	cbz	r0, 0x700aa384 <Udma_rmFreeVintrBit+0x24> @ imm = #0x8
700aa37a: e7ff         	b	0x700aa37c <Udma_rmFreeVintrBit+0x1c> @ imm = #-0x2
;         controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700aa37c: 9800         	ldr	r0, [sp]
700aa37e: 6900         	ldr	r0, [r0, #0x10]
700aa380: 9001         	str	r0, [sp, #0x4]
;     }
700aa382: e7ff         	b	0x700aa384 <Udma_rmFreeVintrBit+0x24> @ imm = #-0x2
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa384: 9806         	ldr	r0, [sp, #0x18]
700aa386: f500 609f    	add.w	r0, r0, #0x4f8
700aa38a: f04f 31ff    	mov.w	r1, #0xffffffff
700aa38e: f000 fa27    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #0x44e
;     bitMask = ((uint64_t) 1U << vintrBitNum);
700aa392: 9b07         	ldr	r3, [sp, #0x1c]
700aa394: f1a3 0220    	sub.w	r2, r3, #0x20
700aa398: 2101         	movs	r1, #0x1
700aa39a: fa01 fc02    	lsl.w	r12, r1, r2
700aa39e: f1c3 0020    	rsb.w	r0, r3, #0x20
700aa3a2: fa21 f000    	lsr.w	r0, r1, r0
700aa3a6: 2a00         	cmp	r2, #0x0
700aa3a8: bf58         	it	pl
700aa3aa: 4660         	movpl	r0, r12
700aa3ac: fa01 f103    	lsl.w	r1, r1, r3
700aa3b0: 2a00         	cmp	r2, #0x0
700aa3b2: bf58         	it	pl
700aa3b4: 2100         	movpl	r1, #0x0
700aa3b6: 9102         	str	r1, [sp, #0x8]
700aa3b8: 9003         	str	r0, [sp, #0xc]
;     controllerEventHandle->vintrBitAllocFlag &= ~bitMask;
700aa3ba: f8dd c008    	ldr.w	r12, [sp, #0x8]
700aa3be: 9b03         	ldr	r3, [sp, #0xc]
700aa3c0: 9901         	ldr	r1, [sp, #0x4]
700aa3c2: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700aa3c6: f8d1 208c    	ldr.w	r2, [r1, #0x8c]
700aa3ca: ea20 000c    	bic.w	r0, r0, r12
700aa3ce: ea22 0203    	bic.w	r2, r2, r3
700aa3d2: f8c1 208c    	str.w	r2, [r1, #0x8c]
700aa3d6: f8c1 0088    	str.w	r0, [r1, #0x88]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa3da: 9806         	ldr	r0, [sp, #0x18]
700aa3dc: f500 609f    	add.w	r0, r0, #0x4f8
700aa3e0: f001 fd8e    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x1b1c
;     return;
700aa3e4: b008         	add	sp, #0x20
700aa3e6: bd80         	pop	{r7, pc}
		...

700aa3f0 <SOC_controlModuleLockMMR>:
; {
700aa3f0: b580         	push	{r7, lr}
700aa3f2: b086         	sub	sp, #0x18
700aa3f4: 9005         	str	r0, [sp, #0x14]
700aa3f6: 9104         	str	r1, [sp, #0x10]
;     if(SOC_DOMAIN_ID_MAIN == domainId)
700aa3f8: 9805         	ldr	r0, [sp, #0x14]
700aa3fa: b9d8         	cbnz	r0, 0x700aa434 <SOC_controlModuleLockMMR+0x44> @ imm = #0x36
700aa3fc: e7ff         	b	0x700aa3fe <SOC_controlModuleLockMMR+0xe> @ imm = #-0x2
700aa3fe: f04f 4086    	mov.w	r0, #0x43000000
700aa402: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_CTRL_MMR0_CFG0_BASE);
700aa404: 9101         	str	r1, [sp, #0x4]
700aa406: f7fb fc0b    	bl	0x700a5c20 <AddrTranslateP_getLocalAddr> @ imm = #-0x47ea
700aa40a: 9901         	ldr	r1, [sp, #0x4]
700aa40c: 9003         	str	r0, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700aa40e: 9803         	ldr	r0, [sp, #0xc]
700aa410: 9a04         	ldr	r2, [sp, #0x10]
700aa412: eb00 3082    	add.w	r0, r0, r2, lsl #14
700aa416: f241 0208    	movw	r2, #0x1008
700aa41a: 4410         	add	r0, r2
700aa41c: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700aa41e: 9802         	ldr	r0, [sp, #0x8]
700aa420: f005 fb76    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0x56ec
700aa424: 9901         	ldr	r1, [sp, #0x4]
;         kickAddr++;
700aa426: 9802         	ldr	r0, [sp, #0x8]
700aa428: 3004         	adds	r0, #0x4
700aa42a: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700aa42c: 9802         	ldr	r0, [sp, #0x8]
700aa42e: f005 fb6f    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0x56de
;     }
700aa432: e7ff         	b	0x700aa434 <SOC_controlModuleLockMMR+0x44> @ imm = #-0x2
;     if(SOC_DOMAIN_ID_MCU == domainId)
700aa434: 9805         	ldr	r0, [sp, #0x14]
700aa436: 2801         	cmp	r0, #0x1
700aa438: d11b         	bne	0x700aa472 <SOC_controlModuleLockMMR+0x82> @ imm = #0x36
700aa43a: e7ff         	b	0x700aa43c <SOC_controlModuleLockMMR+0x4c> @ imm = #-0x2
700aa43c: f04f 608a    	mov.w	r0, #0x4500000
700aa440: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_CTRL_MMR0_CFG0_BASE);
700aa442: 9100         	str	r1, [sp]
700aa444: f7fb fbec    	bl	0x700a5c20 <AddrTranslateP_getLocalAddr> @ imm = #-0x4828
700aa448: 9900         	ldr	r1, [sp]
700aa44a: 9003         	str	r0, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700aa44c: 9803         	ldr	r0, [sp, #0xc]
700aa44e: 9a04         	ldr	r2, [sp, #0x10]
700aa450: eb00 3082    	add.w	r0, r0, r2, lsl #14
700aa454: f241 0208    	movw	r2, #0x1008
700aa458: 4410         	add	r0, r2
700aa45a: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700aa45c: 9802         	ldr	r0, [sp, #0x8]
700aa45e: f005 fb57    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0x56ae
700aa462: 9900         	ldr	r1, [sp]
;         kickAddr++;
700aa464: 9802         	ldr	r0, [sp, #0x8]
700aa466: 3004         	adds	r0, #0x4
700aa468: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700aa46a: 9802         	ldr	r0, [sp, #0x8]
700aa46c: f005 fb50    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0x56a0
;     }
700aa470: e7ff         	b	0x700aa472 <SOC_controlModuleLockMMR+0x82> @ imm = #-0x2
;     return;
700aa472: b006         	add	sp, #0x18
700aa474: bd80         	pop	{r7, pc}
		...
700aa47e: 0000         	movs	r0, r0

700aa480 <UART_lld_flushTxFifo>:
; {
700aa480: b580         	push	{r7, lr}
700aa482: b088         	sub	sp, #0x20
700aa484: 9007         	str	r0, [sp, #0x1c]
700aa486: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700aa488: 9006         	str	r0, [sp, #0x18]
700aa48a: f640 31b8    	movw	r1, #0xbb8
;     uint32_t            timeout = UART_TRANSMITEMPTY_TRIALCOUNT;
700aa48e: 9102         	str	r1, [sp, #0x8]
;     uint32_t            timeoutElapsed  = FALSE;
700aa490: 9001         	str	r0, [sp, #0x4]
;     if (NULL_PTR != hUart)
700aa492: 9807         	ldr	r0, [sp, #0x1c]
700aa494: b380         	cbz	r0, 0x700aa4f8 <UART_lld_flushTxFifo+0x78> @ imm = #0x60
700aa496: e7ff         	b	0x700aa498 <UART_lld_flushTxFifo+0x18> @ imm = #-0x2
;         hUartInit = hUart->hUartInit;
700aa498: 9807         	ldr	r0, [sp, #0x1c]
700aa49a: 6840         	ldr	r0, [r0, #0x4]
700aa49c: 9000         	str	r0, [sp]
;         startTicks = hUartInit->clockP_get();
700aa49e: 9800         	ldr	r0, [sp]
700aa4a0: 6d40         	ldr	r0, [r0, #0x54]
700aa4a2: 4780         	blx	r0
700aa4a4: 9004         	str	r0, [sp, #0x10]
;         while (FALSE == timeoutElapsed)
700aa4a6: e7ff         	b	0x700aa4a8 <UART_lld_flushTxFifo+0x28> @ imm = #-0x2
700aa4a8: 9801         	ldr	r0, [sp, #0x4]
700aa4aa: b9e0         	cbnz	r0, 0x700aa4e6 <UART_lld_flushTxFifo+0x66> @ imm = #0x38
700aa4ac: e7ff         	b	0x700aa4ae <UART_lld_flushTxFifo+0x2e> @ imm = #-0x2
;             isTxFifoEmpty = UART_spaceAvail(hUart->baseAddr);
700aa4ae: 9807         	ldr	r0, [sp, #0x1c]
700aa4b0: 6800         	ldr	r0, [r0]
700aa4b2: f003 fd0d    	bl	0x700aded0 <UART_spaceAvail> @ imm = #0x3a1a
700aa4b6: 9005         	str	r0, [sp, #0x14]
;             if ((uint32_t) TRUE == isTxFifoEmpty)
700aa4b8: 9805         	ldr	r0, [sp, #0x14]
700aa4ba: 2801         	cmp	r0, #0x1
700aa4bc: d101         	bne	0x700aa4c2 <UART_lld_flushTxFifo+0x42> @ imm = #0x2
700aa4be: e7ff         	b	0x700aa4c0 <UART_lld_flushTxFifo+0x40> @ imm = #-0x2
;                 break;
700aa4c0: e011         	b	0x700aa4e6 <UART_lld_flushTxFifo+0x66> @ imm = #0x22
;             elapsedTicks = hUartInit->clockP_get() - startTicks;
700aa4c2: 9800         	ldr	r0, [sp]
700aa4c4: 6d40         	ldr	r0, [r0, #0x54]
700aa4c6: 4780         	blx	r0
700aa4c8: 9904         	ldr	r1, [sp, #0x10]
700aa4ca: 1a40         	subs	r0, r0, r1
700aa4cc: 9003         	str	r0, [sp, #0xc]
;             if (elapsedTicks >= timeout)
700aa4ce: 9803         	ldr	r0, [sp, #0xc]
700aa4d0: 9902         	ldr	r1, [sp, #0x8]
700aa4d2: 4288         	cmp	r0, r1
700aa4d4: d303         	blo	0x700aa4de <UART_lld_flushTxFifo+0x5e> @ imm = #0x6
700aa4d6: e7ff         	b	0x700aa4d8 <UART_lld_flushTxFifo+0x58> @ imm = #-0x2
700aa4d8: 2001         	movs	r0, #0x1
;                 timeoutElapsed = TRUE;
700aa4da: 9001         	str	r0, [sp, #0x4]
;             }
700aa4dc: e002         	b	0x700aa4e4 <UART_lld_flushTxFifo+0x64> @ imm = #0x4
;                 TaskP_yield();
700aa4de: f005 fc3f    	bl	0x700afd60 <TaskP_yield> @ imm = #0x587e
700aa4e2: e7ff         	b	0x700aa4e4 <UART_lld_flushTxFifo+0x64> @ imm = #-0x2
;         while (FALSE == timeoutElapsed)
700aa4e4: e7e0         	b	0x700aa4a8 <UART_lld_flushTxFifo+0x28> @ imm = #-0x40
;         if(TRUE == timeoutElapsed)
700aa4e6: 9801         	ldr	r0, [sp, #0x4]
700aa4e8: 2801         	cmp	r0, #0x1
700aa4ea: d104         	bne	0x700aa4f6 <UART_lld_flushTxFifo+0x76> @ imm = #0x8
700aa4ec: e7ff         	b	0x700aa4ee <UART_lld_flushTxFifo+0x6e> @ imm = #-0x2
700aa4ee: f06f 0001    	mvn	r0, #0x1
;             status = UART_TRANSFER_TIMEOUT;
700aa4f2: 9006         	str	r0, [sp, #0x18]
;         }
700aa4f4: e7ff         	b	0x700aa4f6 <UART_lld_flushTxFifo+0x76> @ imm = #-0x2
;     }
700aa4f6: e003         	b	0x700aa500 <UART_lld_flushTxFifo+0x80> @ imm = #0x6
700aa4f8: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700aa4fc: 9006         	str	r0, [sp, #0x18]
700aa4fe: e7ff         	b	0x700aa500 <UART_lld_flushTxFifo+0x80> @ imm = #-0x2
;     return status;
700aa500: 9806         	ldr	r0, [sp, #0x18]
700aa502: b008         	add	sp, #0x20
700aa504: bd80         	pop	{r7, pc}
		...
700aa50e: 0000         	movs	r0, r0

700aa510 <UART_tcrTlrBitValRestore>:
; {
700aa510: b580         	push	{r7, lr}
700aa512: b088         	sub	sp, #0x20
700aa514: 9007         	str	r0, [sp, #0x1c]
700aa516: 9106         	str	r1, [sp, #0x18]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700aa518: 9807         	ldr	r0, [sp, #0x1c]
700aa51a: 21bf         	movs	r1, #0xbf
700aa51c: 9101         	str	r1, [sp, #0x4]
700aa51e: f002 f937    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #0x226e
700aa522: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700aa524: 9807         	ldr	r0, [sp, #0x1c]
700aa526: 3008         	adds	r0, #0x8
700aa528: 2110         	movs	r1, #0x10
700aa52a: 9102         	str	r1, [sp, #0x8]
700aa52c: 2204         	movs	r2, #0x4
700aa52e: 9203         	str	r2, [sp, #0xc]
700aa530: f004 ff0e    	bl	0x700af350 <HW_RD_FIELD32_RAW> @ imm = #0x4e1c
700aa534: 9902         	ldr	r1, [sp, #0x8]
700aa536: 9a03         	ldr	r2, [sp, #0xc]
700aa538: 9005         	str	r0, [sp, #0x14]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700aa53a: 9807         	ldr	r0, [sp, #0x1c]
700aa53c: 3008         	adds	r0, #0x8
700aa53e: 2301         	movs	r3, #0x1
700aa540: f004 f8be    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x417c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa544: 9807         	ldr	r0, [sp, #0x1c]
700aa546: 300c         	adds	r0, #0xc
700aa548: 9904         	ldr	r1, [sp, #0x10]
700aa54a: f005 fb21    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x5642
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700aa54e: 9807         	ldr	r0, [sp, #0x1c]
700aa550: 2180         	movs	r1, #0x80
700aa552: f002 f91d    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #0x223a
700aa556: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_MCR, UART_MCR_TCR_TLR, tcrTlrBitVal);
700aa558: 9807         	ldr	r0, [sp, #0x1c]
700aa55a: 3010         	adds	r0, #0x10
700aa55c: 9b06         	ldr	r3, [sp, #0x18]
700aa55e: 2140         	movs	r1, #0x40
700aa560: 2206         	movs	r2, #0x6
700aa562: f004 f8ad    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x415a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa566: 9807         	ldr	r0, [sp, #0x1c]
700aa568: 300c         	adds	r0, #0xc
700aa56a: 9904         	ldr	r1, [sp, #0x10]
700aa56c: f005 fb10    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x5620
700aa570: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700aa572: 9807         	ldr	r0, [sp, #0x1c]
700aa574: f002 f90c    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #0x2218
700aa578: 9902         	ldr	r1, [sp, #0x8]
700aa57a: 9a03         	ldr	r2, [sp, #0xc]
700aa57c: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700aa57e: 9807         	ldr	r0, [sp, #0x1c]
700aa580: 3008         	adds	r0, #0x8
700aa582: 9b05         	ldr	r3, [sp, #0x14]
700aa584: f004 f89c    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x4138
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa588: 9807         	ldr	r0, [sp, #0x1c]
700aa58a: 300c         	adds	r0, #0xc
700aa58c: 9904         	ldr	r1, [sp, #0x10]
700aa58e: f005 faff    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x55fe
; }
700aa592: b008         	add	sp, #0x20
700aa594: bd80         	pop	{r7, pc}
		...
700aa59e: 0000         	movs	r0, r0

700aa5a0 <prvInsertTimerInActiveList>:
;     {
700aa5a0: b580         	push	{r7, lr}
700aa5a2: b086         	sub	sp, #0x18
700aa5a4: 9005         	str	r0, [sp, #0x14]
700aa5a6: 9104         	str	r1, [sp, #0x10]
700aa5a8: 9203         	str	r2, [sp, #0xc]
700aa5aa: 9302         	str	r3, [sp, #0x8]
700aa5ac: 2000         	movs	r0, #0x0
;         BaseType_t xProcessTimerNow = pdFALSE;
700aa5ae: 9001         	str	r0, [sp, #0x4]
;         listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
700aa5b0: 9804         	ldr	r0, [sp, #0x10]
700aa5b2: 9905         	ldr	r1, [sp, #0x14]
700aa5b4: 6048         	str	r0, [r1, #0x4]
;         listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
700aa5b6: 9805         	ldr	r0, [sp, #0x14]
700aa5b8: 6100         	str	r0, [r0, #0x10]
;         if( xNextExpiryTime <= xTimeNow )
700aa5ba: 9804         	ldr	r0, [sp, #0x10]
700aa5bc: 9903         	ldr	r1, [sp, #0xc]
700aa5be: 4288         	cmp	r0, r1
700aa5c0: d816         	bhi	0x700aa5f0 <prvInsertTimerInActiveList+0x50> @ imm = #0x2c
700aa5c2: e7ff         	b	0x700aa5c4 <prvInsertTimerInActiveList+0x24> @ imm = #-0x2
;             if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
700aa5c4: 9803         	ldr	r0, [sp, #0xc]
700aa5c6: 9902         	ldr	r1, [sp, #0x8]
700aa5c8: 1a40         	subs	r0, r0, r1
700aa5ca: 9905         	ldr	r1, [sp, #0x14]
700aa5cc: 6989         	ldr	r1, [r1, #0x18]
700aa5ce: 4288         	cmp	r0, r1
700aa5d0: d303         	blo	0x700aa5da <prvInsertTimerInActiveList+0x3a> @ imm = #0x6
700aa5d2: e7ff         	b	0x700aa5d4 <prvInsertTimerInActiveList+0x34> @ imm = #-0x2
700aa5d4: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
700aa5d6: 9001         	str	r0, [sp, #0x4]
;             }
700aa5d8: e009         	b	0x700aa5ee <prvInsertTimerInActiveList+0x4e> @ imm = #0x12
;                 vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
700aa5da: f245 20a8    	movw	r0, #0x52a8
700aa5de: f2c7 0008    	movt	r0, #0x7008
700aa5e2: 6800         	ldr	r0, [r0]
700aa5e4: 9905         	ldr	r1, [sp, #0x14]
700aa5e6: 3104         	adds	r1, #0x4
700aa5e8: f001 f90a    	bl	0x700ab800 <vListInsert> @ imm = #0x1214
700aa5ec: e7ff         	b	0x700aa5ee <prvInsertTimerInActiveList+0x4e> @ imm = #-0x2
;         }
700aa5ee: e017         	b	0x700aa620 <prvInsertTimerInActiveList+0x80> @ imm = #0x2e
;             if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
700aa5f0: 9803         	ldr	r0, [sp, #0xc]
700aa5f2: 9902         	ldr	r1, [sp, #0x8]
700aa5f4: 4288         	cmp	r0, r1
700aa5f6: d208         	bhs	0x700aa60a <prvInsertTimerInActiveList+0x6a> @ imm = #0x10
700aa5f8: e7ff         	b	0x700aa5fa <prvInsertTimerInActiveList+0x5a> @ imm = #-0x2
700aa5fa: 9804         	ldr	r0, [sp, #0x10]
700aa5fc: 9902         	ldr	r1, [sp, #0x8]
700aa5fe: 4288         	cmp	r0, r1
700aa600: d303         	blo	0x700aa60a <prvInsertTimerInActiveList+0x6a> @ imm = #0x6
700aa602: e7ff         	b	0x700aa604 <prvInsertTimerInActiveList+0x64> @ imm = #-0x2
700aa604: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
700aa606: 9001         	str	r0, [sp, #0x4]
;             }
700aa608: e009         	b	0x700aa61e <prvInsertTimerInActiveList+0x7e> @ imm = #0x12
;                 vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
700aa60a: f245 209c    	movw	r0, #0x529c
700aa60e: f2c7 0008    	movt	r0, #0x7008
700aa612: 6800         	ldr	r0, [r0]
700aa614: 9905         	ldr	r1, [sp, #0x14]
700aa616: 3104         	adds	r1, #0x4
700aa618: f001 f8f2    	bl	0x700ab800 <vListInsert> @ imm = #0x11e4
700aa61c: e7ff         	b	0x700aa61e <prvInsertTimerInActiveList+0x7e> @ imm = #-0x2
700aa61e: e7ff         	b	0x700aa620 <prvInsertTimerInActiveList+0x80> @ imm = #-0x2
;         return xProcessTimerNow;
700aa620: 9801         	ldr	r0, [sp, #0x4]
700aa622: b006         	add	sp, #0x18
700aa624: bd80         	pop	{r7, pc}
		...
700aa62e: 0000         	movs	r0, r0

700aa630 <prvProcessTimerOrBlockTask>:
;     {
700aa630: b580         	push	{r7, lr}
700aa632: b084         	sub	sp, #0x10
700aa634: 9003         	str	r0, [sp, #0xc]
700aa636: 9102         	str	r1, [sp, #0x8]
;         vTaskSuspendAll();
700aa638: f005 faca    	bl	0x700afbd0 <vTaskSuspendAll> @ imm = #0x5594
700aa63c: 4668         	mov	r0, sp
;             xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
700aa63e: f003 f9d7    	bl	0x700ad9f0 <prvSampleTimeNow> @ imm = #0x33ae
700aa642: 9001         	str	r0, [sp, #0x4]
;             if( xTimerListsWereSwitched == pdFALSE )
700aa644: 9800         	ldr	r0, [sp]
700aa646: bb88         	cbnz	r0, 0x700aa6ac <prvProcessTimerOrBlockTask+0x7c> @ imm = #0x62
700aa648: e7ff         	b	0x700aa64a <prvProcessTimerOrBlockTask+0x1a> @ imm = #-0x2
;                 if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
700aa64a: 9802         	ldr	r0, [sp, #0x8]
700aa64c: b960         	cbnz	r0, 0x700aa668 <prvProcessTimerOrBlockTask+0x38> @ imm = #0x18
700aa64e: e7ff         	b	0x700aa650 <prvProcessTimerOrBlockTask+0x20> @ imm = #-0x2
700aa650: 9803         	ldr	r0, [sp, #0xc]
700aa652: 9901         	ldr	r1, [sp, #0x4]
700aa654: 4288         	cmp	r0, r1
700aa656: d807         	bhi	0x700aa668 <prvProcessTimerOrBlockTask+0x38> @ imm = #0xe
700aa658: e7ff         	b	0x700aa65a <prvProcessTimerOrBlockTask+0x2a> @ imm = #-0x2
;                     ( void ) xTaskResumeAll();
700aa65a: f7f7 fe21    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0x83be
;                     prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
700aa65e: 9803         	ldr	r0, [sp, #0xc]
700aa660: 9901         	ldr	r1, [sp, #0x4]
700aa662: f000 fe55    	bl	0x700ab310 <prvProcessExpiredTimer> @ imm = #0xcaa
;                 }
700aa666: e020         	b	0x700aa6aa <prvProcessTimerOrBlockTask+0x7a> @ imm = #0x40
;                     if( xListWasEmpty != pdFALSE )
700aa668: 9802         	ldr	r0, [sp, #0x8]
700aa66a: b158         	cbz	r0, 0x700aa684 <prvProcessTimerOrBlockTask+0x54> @ imm = #0x16
700aa66c: e7ff         	b	0x700aa66e <prvProcessTimerOrBlockTask+0x3e> @ imm = #-0x2
;                         xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
700aa66e: f245 20a8    	movw	r0, #0x52a8
700aa672: f2c7 0008    	movt	r0, #0x7008
700aa676: 6800         	ldr	r0, [r0]
700aa678: 6800         	ldr	r0, [r0]
700aa67a: fab0 f080    	clz	r0, r0
700aa67e: 0940         	lsrs	r0, r0, #0x5
700aa680: 9002         	str	r0, [sp, #0x8]
;                     }
700aa682: e7ff         	b	0x700aa684 <prvProcessTimerOrBlockTask+0x54> @ imm = #-0x2
;                     vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
700aa684: f642 2058    	movw	r0, #0x2a58
700aa688: f2c7 000b    	movt	r0, #0x700b
700aa68c: 6800         	ldr	r0, [r0]
700aa68e: 9903         	ldr	r1, [sp, #0xc]
700aa690: 9a01         	ldr	r2, [sp, #0x4]
700aa692: 1a89         	subs	r1, r1, r2
700aa694: 9a02         	ldr	r2, [sp, #0x8]
700aa696: f001 fbfb    	bl	0x700abe90 <vQueueWaitForMessageRestricted> @ imm = #0x17f6
;                     if( xTaskResumeAll() == pdFALSE )
700aa69a: f7f7 fe01    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0x83fe
700aa69e: b910         	cbnz	r0, 0x700aa6a6 <prvProcessTimerOrBlockTask+0x76> @ imm = #0x4
700aa6a0: e7ff         	b	0x700aa6a2 <prvProcessTimerOrBlockTask+0x72> @ imm = #-0x2
;                         portYIELD_WITHIN_API();
700aa6a2: df00         	svc	#0x0
;                     }
700aa6a4: e000         	b	0x700aa6a8 <prvProcessTimerOrBlockTask+0x78> @ imm = #0x0
700aa6a6: e7ff         	b	0x700aa6a8 <prvProcessTimerOrBlockTask+0x78> @ imm = #-0x2
700aa6a8: e7ff         	b	0x700aa6aa <prvProcessTimerOrBlockTask+0x7a> @ imm = #-0x2
;             }
700aa6aa: e002         	b	0x700aa6b2 <prvProcessTimerOrBlockTask+0x82> @ imm = #0x4
;                 ( void ) xTaskResumeAll();
700aa6ac: f7f7 fdf8    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0x8410
700aa6b0: e7ff         	b	0x700aa6b2 <prvProcessTimerOrBlockTask+0x82> @ imm = #-0x2
;     }
700aa6b2: b004         	add	sp, #0x10
700aa6b4: bd80         	pop	{r7, pc}
		...
700aa6be: 0000         	movs	r0, r0

700aa6c0 <PowerClock_init>:
; {
700aa6c0: b570         	push	{r4, r5, r6, lr}
700aa6c2: b082         	sub	sp, #0x8
;     while(gSocModules[i]!=SOC_MODULES_END)
700aa6c4: f642 11a4    	movw	r1, #0x29a4
700aa6c8: f2c7 010b    	movt	r1, #0x700b
700aa6cc: 6808         	ldr	r0, [r1]
700aa6ce: 1c42         	adds	r2, r0, #0x1
700aa6d0: d013         	beq	0x700aa6fa <PowerClock_init+0x3a> @ imm = #0x26
700aa6d2: 1d0c         	adds	r4, r1, #0x4
700aa6d4: bf00         	nop
700aa6d6: bf00         	nop
700aa6d8: bf00         	nop
700aa6da: bf00         	nop
700aa6dc: bf00         	nop
700aa6de: bf00         	nop
;         status = SOC_moduleClockEnable(gSocModules[i], 1);
700aa6e0: f04f 0101    	mov.w	r1, #0x1
700aa6e4: f7ff fa7c    	bl	0x700a9be0 <SOC_moduleClockEnable> @ imm = #-0xb08
;         DebugP_assertNoLog(status == SystemP_SUCCESS);
700aa6e8: fab0 f080    	clz	r0, r0
700aa6ec: 0940         	lsrs	r0, r0, #0x5
700aa6ee: f006 fdf7    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x6bee
;     while(gSocModules[i]!=SOC_MODULES_END)
700aa6f2: f854 0b04    	ldr	r0, [r4], #4
700aa6f6: 1c41         	adds	r1, r0, #0x1
700aa6f8: d1f2         	bne	0x700aa6e0 <PowerClock_init+0x20> @ imm = #-0x1c
;     while(gSocModulesClockFrequency[i].moduleId!=SOC_MODULES_END)
700aa6fa: f642 01f0    	movw	r1, #0x28f0
700aa6fe: f2c7 010b    	movt	r1, #0x700b
700aa702: 6808         	ldr	r0, [r1]
700aa704: 1c42         	adds	r2, r0, #0x1
700aa706: d01b         	beq	0x700aa740 <PowerClock_init+0x80> @ imm = #0x36
700aa708: f101 0408    	add.w	r4, r1, #0x8
700aa70c: 2600         	movs	r6, #0x0
700aa70e: e00c         	b	0x700aa72a <PowerClock_init+0x6a> @ imm = #0x18
;             status = SOC_moduleSetClockFrequency(
700aa710: 461a         	mov	r2, r3
700aa712: 2300         	movs	r3, #0x0
700aa714: f7f5 f9a4    	bl	0x7009fa60 <SOC_moduleSetClockFrequency> @ imm = #-0xacb8
;         DebugP_assertNoLog(status == SystemP_SUCCESS);
700aa718: fab0 f080    	clz	r0, r0
700aa71c: 0940         	lsrs	r0, r0, #0x5
700aa71e: f006 fddf    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x6bbe
;     while(gSocModulesClockFrequency[i].moduleId!=SOC_MODULES_END)
700aa722: 68a0         	ldr	r0, [r4, #0x8]
700aa724: 3410         	adds	r4, #0x10
700aa726: 1c41         	adds	r1, r0, #0x1
700aa728: d00a         	beq	0x700aa740 <PowerClock_init+0x80> @ imm = #0x14
;         if (gSocModulesClockFrequency[i].clkParentId != -1)
700aa72a: 6862         	ldr	r2, [r4, #0x4]
700aa72c: f854 1c04    	ldr	r1, [r4, #-4]
700aa730: 6823         	ldr	r3, [r4]
;         if (gSocModulesClockFrequency[i].clkParentId != -1)
700aa732: 1c55         	adds	r5, r2, #0x1
700aa734: d0ec         	beq	0x700aa710 <PowerClock_init+0x50> @ imm = #-0x28
;             status = SOC_moduleSetClockFrequencyWithParent(
700aa736: e9cd 3600    	strd	r3, r6, [sp]
700aa73a: f7f5 fa71    	bl	0x7009fc20 <SOC_moduleSetClockFrequencyWithParent> @ imm = #-0xab1e
700aa73e: e7eb         	b	0x700aa718 <PowerClock_init+0x58> @ imm = #-0x2a
; }
700aa740: b002         	add	sp, #0x8
700aa742: bd70         	pop	{r4, r5, r6, pc}
		...

700aa750 <CSL_udmapCppi5SetReturnPolicy>:
; {
700aa750: b085         	sub	sp, #0x14
700aa752: f8dd c018    	ldr.w	r12, [sp, #0x18]
700aa756: f8dd c014    	ldr.w	r12, [sp, #0x14]
700aa75a: 9004         	str	r0, [sp, #0x10]
700aa75c: 9103         	str	r1, [sp, #0xc]
700aa75e: 9202         	str	r2, [sp, #0x8]
700aa760: 9301         	str	r3, [sp, #0x4]
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700aa762: 9803         	ldr	r0, [sp, #0xc]
700aa764: 2803         	cmp	r0, #0x3
700aa766: d108         	bne	0x700aa77a <CSL_udmapCppi5SetReturnPolicy+0x2a> @ imm = #0x10
700aa768: e7ff         	b	0x700aa76a <CSL_udmapCppi5SetReturnPolicy+0x1a> @ imm = #-0x2
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETPOLICY, retPushPolicy )    |
700aa76a: 9905         	ldr	r1, [sp, #0x14]
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETQ, retQnum ) ;
700aa76c: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETPOLICY, retPushPolicy )    |
700aa770: f361 4010    	bfi	r0, r1, #16, #1
;         ((CSL_UdmapCppi5TRPD *)pDesc)->retInfo =
700aa774: 9904         	ldr	r1, [sp, #0x10]
700aa776: 6088         	str	r0, [r1, #0x8]
;     }
700aa778: e029         	b	0x700aa7ce <CSL_udmapCppi5SetReturnPolicy+0x7e> @ imm = #0x52
;         v = ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo2;
700aa77a: 9804         	ldr	r0, [sp, #0x10]
700aa77c: 6880         	ldr	r0, [r0, #0x8]
700aa77e: 9000         	str	r0, [sp]
;         if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_MONO )
700aa780: 9803         	ldr	r0, [sp, #0xc]
700aa782: 2802         	cmp	r0, #0x2
700aa784: d105         	bne	0x700aa792 <CSL_udmapCppi5SetReturnPolicy+0x42> @ imm = #0xa
700aa786: e7ff         	b	0x700aa788 <CSL_udmapCppi5SetReturnPolicy+0x38> @ imm = #-0x2
;             v &= (CSL_UDMAP_CPPI5_PD_PKTINFO2_PKTTYPE_MASK | CSL_UDMAP_CPPI5_PD_PKTINFO2_DATA_OFFSET_MASK);
700aa788: 9800         	ldr	r0, [sp]
700aa78a: f36f 0011    	bfc	r0, #0, #18
700aa78e: 9000         	str	r0, [sp]
;         }
700aa790: e00b         	b	0x700aa7aa <CSL_udmapCppi5SetReturnPolicy+0x5a> @ imm = #0x16
;             v &= CSL_UDMAP_CPPI5_PD_PKTINFO2_PKTTYPE_MASK;
700aa792: 9800         	ldr	r0, [sp]
700aa794: f000 4078    	and	r0, r0, #0xf8000000
700aa798: 9000         	str	r0, [sp]
;             v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPOLICY, retPolicy );
700aa79a: 9802         	ldr	r0, [sp, #0x8]
700aa79c: f000 0101    	and	r1, r0, #0x1
700aa7a0: 9800         	ldr	r0, [sp]
700aa7a2: ea40 4081    	orr.w	r0, r0, r1, lsl #18
700aa7a6: 9000         	str	r0, [sp]
700aa7a8: e7ff         	b	0x700aa7aa <CSL_udmapCppi5SetReturnPolicy+0x5a> @ imm = #-0x2
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700aa7aa: 9901         	ldr	r1, [sp, #0x4]
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPUSHPOLICY, retPushPolicy ) |
700aa7ac: 9a05         	ldr	r2, [sp, #0x14]
700aa7ae: f44f 3080    	mov.w	r0, #0x10000
700aa7b2: ea00 4002    	and.w	r0, r0, r2, lsl #16
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700aa7b6: f361 4051    	bfi	r0, r1, #17, #1
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETQ, retQnum );
700aa7ba: f8bd 1018    	ldrh.w	r1, [sp, #0x18]
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPUSHPOLICY, retPushPolicy ) |
700aa7be: 4401         	add	r1, r0
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700aa7c0: 9800         	ldr	r0, [sp]
700aa7c2: 4308         	orrs	r0, r1
700aa7c4: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo2 = v;
700aa7c6: 9800         	ldr	r0, [sp]
700aa7c8: 9904         	ldr	r1, [sp, #0x10]
700aa7ca: 6088         	str	r0, [r1, #0x8]
700aa7cc: e7ff         	b	0x700aa7ce <CSL_udmapCppi5SetReturnPolicy+0x7e> @ imm = #-0x2
; }
700aa7ce: b005         	add	sp, #0x14
700aa7d0: 4770         	bx	lr
		...
700aa7de: 0000         	movs	r0, r0

700aa7e0 <SemaphoreP_pend>:
; {
700aa7e0: b580         	push	{r7, lr}
700aa7e2: b086         	sub	sp, #0x18
700aa7e4: 9005         	str	r0, [sp, #0x14]
700aa7e6: 9104         	str	r1, [sp, #0x10]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700aa7e8: 9805         	ldr	r0, [sp, #0x14]
700aa7ea: 9003         	str	r0, [sp, #0xc]
700aa7ec: 2000         	movs	r0, #0x0
;     uint32_t isSemTaken = 0U;
700aa7ee: 9002         	str	r0, [sp, #0x8]
;     if(pSemaphore->isRecursiveMutex != 0U)
700aa7f0: 9803         	ldr	r0, [sp, #0xc]
700aa7f2: 6d40         	ldr	r0, [r0, #0x54]
700aa7f4: b180         	cbz	r0, 0x700aa818 <SemaphoreP_pend+0x38> @ imm = #0x20
700aa7f6: e7ff         	b	0x700aa7f8 <SemaphoreP_pend+0x18> @ imm = #-0x2
;         if(HwiP_inISR() == 0U )
700aa7f8: f005 fdd2    	bl	0x700b03a0 <HwiP_inISR> @ imm = #0x5ba4
700aa7fc: b938         	cbnz	r0, 0x700aa80e <SemaphoreP_pend+0x2e> @ imm = #0xe
700aa7fe: e7ff         	b	0x700aa800 <SemaphoreP_pend+0x20> @ imm = #-0x2
;             isSemTaken =(uint32_t) xSemaphoreTakeRecursive(pSemaphore->semHndl, timeout);
700aa800: 9803         	ldr	r0, [sp, #0xc]
700aa802: 6d00         	ldr	r0, [r0, #0x50]
700aa804: 9904         	ldr	r1, [sp, #0x10]
700aa806: f002 fc93    	bl	0x700ad130 <xQueueTakeMutexRecursive> @ imm = #0x2926
700aa80a: 9002         	str	r0, [sp, #0x8]
;         }
700aa80c: e003         	b	0x700aa816 <SemaphoreP_pend+0x36> @ imm = #0x6
700aa80e: 2000         	movs	r0, #0x0
;             DebugP_assertNoLog(0);
700aa810: f006 fd66    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x6acc
700aa814: e7ff         	b	0x700aa816 <SemaphoreP_pend+0x36> @ imm = #-0x2
;     }
700aa816: e017         	b	0x700aa848 <SemaphoreP_pend+0x68> @ imm = #0x2e
;         if( HwiP_inISR() != 0U )
700aa818: f005 fdc2    	bl	0x700b03a0 <HwiP_inISR> @ imm = #0x5b84
700aa81c: b160         	cbz	r0, 0x700aa838 <SemaphoreP_pend+0x58> @ imm = #0x18
700aa81e: e7ff         	b	0x700aa820 <SemaphoreP_pend+0x40> @ imm = #-0x2
700aa820: 2100         	movs	r1, #0x0
;             BaseType_t xHigherPriorityTaskWoken = 0;
700aa822: 9100         	str	r1, [sp]
;             isSemTaken = (uint32_t) xSemaphoreTakeFromISR(pSemaphore->semHndl, &xHigherPriorityTaskWoken);
700aa824: 9803         	ldr	r0, [sp, #0xc]
700aa826: 6d00         	ldr	r0, [r0, #0x50]
700aa828: 466a         	mov	r2, sp
700aa82a: f7fe fe19    	bl	0x700a9460 <xQueueReceiveFromISR> @ imm = #-0x13ce
700aa82e: 9002         	str	r0, [sp, #0x8]
;             portYIELD_FROM_ISR((uint32_t)xHigherPriorityTaskWoken);
700aa830: 9800         	ldr	r0, [sp]
700aa832: f004 fedd    	bl	0x700af5f0 <vPortYeildFromISR> @ imm = #0x4dba
;         }
700aa836: e006         	b	0x700aa846 <SemaphoreP_pend+0x66> @ imm = #0xc
;             isSemTaken = (uint32_t) xSemaphoreTake(pSemaphore->semHndl, timeout);
700aa838: 9803         	ldr	r0, [sp, #0xc]
700aa83a: 6d00         	ldr	r0, [r0, #0x50]
700aa83c: 9904         	ldr	r1, [sp, #0x10]
700aa83e: f7f6 fe1f    	bl	0x700a1480 <xQueueSemaphoreTake> @ imm = #-0x93c2
700aa842: 9002         	str	r0, [sp, #0x8]
700aa844: e7ff         	b	0x700aa846 <SemaphoreP_pend+0x66> @ imm = #-0x2
700aa846: e7ff         	b	0x700aa848 <SemaphoreP_pend+0x68> @ imm = #-0x2
;     if(isSemTaken != 0U)
700aa848: 9802         	ldr	r0, [sp, #0x8]
700aa84a: b118         	cbz	r0, 0x700aa854 <SemaphoreP_pend+0x74> @ imm = #0x6
700aa84c: e7ff         	b	0x700aa84e <SemaphoreP_pend+0x6e> @ imm = #-0x2
700aa84e: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700aa850: 9001         	str	r0, [sp, #0x4]
;     }
700aa852: e003         	b	0x700aa85c <SemaphoreP_pend+0x7c> @ imm = #0x6
700aa854: f06f 0001    	mvn	r0, #0x1
;         status = SystemP_TIMEOUT;
700aa858: 9001         	str	r0, [sp, #0x4]
700aa85a: e7ff         	b	0x700aa85c <SemaphoreP_pend+0x7c> @ imm = #-0x2
;     return status;
700aa85c: 9801         	ldr	r0, [sp, #0x4]
700aa85e: b006         	add	sp, #0x18
700aa860: bd80         	pop	{r7, pc}
		...
700aa86e: 0000         	movs	r0, r0

700aa870 <Udma_chPair>:
; {
700aa870: b580         	push	{r7, lr}
700aa872: b088         	sub	sp, #0x20
700aa874: 9007         	str	r0, [sp, #0x1c]
700aa876: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
700aa878: 9006         	str	r0, [sp, #0x18]
;     drvHandle = chHandle->drvHandle;
700aa87a: 9807         	ldr	r0, [sp, #0x1c]
700aa87c: 6e80         	ldr	r0, [r0, #0x68]
700aa87e: 9005         	str	r0, [sp, #0x14]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa880: 9805         	ldr	r0, [sp, #0x14]
700aa882: 6800         	ldr	r0, [r0]
700aa884: 2801         	cmp	r0, #0x1
700aa886: d107         	bne	0x700aa898 <Udma_chPair+0x28> @ imm = #0xe
700aa888: e7ff         	b	0x700aa88a <Udma_chPair+0x1a> @ imm = #-0x2
;        ((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
700aa88a: 9807         	ldr	r0, [sp, #0x1c]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa88c: 7800         	ldrb	r0, [r0]
700aa88e: 0740         	lsls	r0, r0, #0x1d
700aa890: 2800         	cmp	r0, #0x0
700aa892: d501         	bpl	0x700aa898 <Udma_chPair+0x28> @ imm = #0x2
700aa894: e7ff         	b	0x700aa896 <Udma_chPair+0x26> @ imm = #-0x2
;     }
700aa896: e029         	b	0x700aa8ec <Udma_chPair+0x7c> @ imm = #0x52
;         rmPairReq.nav_id = drvHandle->devIdPsil;
700aa898: 9805         	ldr	r0, [sp, #0x14]
700aa89a: f8b0 00e4    	ldrh.w	r0, [r0, #0xe4]
700aa89e: 9002         	str	r0, [sp, #0x8]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700aa8a0: 9807         	ldr	r0, [sp, #0x1c]
700aa8a2: 7800         	ldrb	r0, [r0]
700aa8a4: 07c0         	lsls	r0, r0, #0x1f
700aa8a6: b158         	cbz	r0, 0x700aa8c0 <Udma_chPair+0x50> @ imm = #0x16
700aa8a8: e7ff         	b	0x700aa8aa <Udma_chPair+0x3a> @ imm = #-0x2
;             rmPairReq.src_thread = chHandle->txChNum + drvHandle->udmapSrcThreadOffset;
700aa8aa: 9807         	ldr	r0, [sp, #0x1c]
700aa8ac: 6ec0         	ldr	r0, [r0, #0x6c]
700aa8ae: 9905         	ldr	r1, [sp, #0x14]
700aa8b0: f8d1 10d4    	ldr.w	r1, [r1, #0xd4]
700aa8b4: 4408         	add	r0, r1
700aa8b6: 9003         	str	r0, [sp, #0xc]
;             rmPairReq.dst_thread = chHandle->peerThreadId;
700aa8b8: 9807         	ldr	r0, [sp, #0x1c]
700aa8ba: 6fc0         	ldr	r0, [r0, #0x7c]
700aa8bc: 9004         	str	r0, [sp, #0x10]
;         }
700aa8be: e00a         	b	0x700aa8d6 <Udma_chPair+0x66> @ imm = #0x14
;             rmPairReq.src_thread = chHandle->peerThreadId;
700aa8c0: 9807         	ldr	r0, [sp, #0x1c]
700aa8c2: 6fc0         	ldr	r0, [r0, #0x7c]
700aa8c4: 9003         	str	r0, [sp, #0xc]
;             rmPairReq.dst_thread = chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
700aa8c6: 9807         	ldr	r0, [sp, #0x1c]
700aa8c8: 6f00         	ldr	r0, [r0, #0x70]
700aa8ca: 9905         	ldr	r1, [sp, #0x14]
700aa8cc: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700aa8d0: 4408         	add	r0, r1
700aa8d2: 9004         	str	r0, [sp, #0x10]
700aa8d4: e7ff         	b	0x700aa8d6 <Udma_chPair+0x66> @ imm = #-0x2
700aa8d6: 4668         	mov	r0, sp
700aa8d8: f04f 31ff    	mov.w	r1, #0xffffffff
;         retVal = Sciclient_rmPsilPair(&rmPairReq, UDMA_SCICLIENT_TIMEOUT);
700aa8dc: f002 f9b8    	bl	0x700acc50 <Sciclient_rmPsilPair> @ imm = #0x2370
700aa8e0: 9006         	str	r0, [sp, #0x18]
;         if(CSL_PASS != retVal)
700aa8e2: 9806         	ldr	r0, [sp, #0x18]
700aa8e4: b108         	cbz	r0, 0x700aa8ea <Udma_chPair+0x7a> @ imm = #0x2
700aa8e6: e7ff         	b	0x700aa8e8 <Udma_chPair+0x78> @ imm = #-0x2
;         }
700aa8e8: e7ff         	b	0x700aa8ea <Udma_chPair+0x7a> @ imm = #-0x2
700aa8ea: e7ff         	b	0x700aa8ec <Udma_chPair+0x7c> @ imm = #-0x2
;     return (retVal);
700aa8ec: 9806         	ldr	r0, [sp, #0x18]
700aa8ee: b008         	add	sp, #0x20
700aa8f0: bd80         	pop	{r7, pc}
		...
700aa8fe: 0000         	movs	r0, r0

700aa900 <Udma_chUnpair>:
; {
700aa900: b580         	push	{r7, lr}
700aa902: b088         	sub	sp, #0x20
700aa904: 9007         	str	r0, [sp, #0x1c]
700aa906: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700aa908: 9006         	str	r0, [sp, #0x18]
;     drvHandle = chHandle->drvHandle;
700aa90a: 9807         	ldr	r0, [sp, #0x1c]
700aa90c: 6e80         	ldr	r0, [r0, #0x68]
700aa90e: 9005         	str	r0, [sp, #0x14]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa910: 9805         	ldr	r0, [sp, #0x14]
700aa912: 6800         	ldr	r0, [r0]
700aa914: 2801         	cmp	r0, #0x1
700aa916: d107         	bne	0x700aa928 <Udma_chUnpair+0x28> @ imm = #0xe
700aa918: e7ff         	b	0x700aa91a <Udma_chUnpair+0x1a> @ imm = #-0x2
;        ((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
700aa91a: 9807         	ldr	r0, [sp, #0x1c]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa91c: 7800         	ldrb	r0, [r0]
700aa91e: 0740         	lsls	r0, r0, #0x1d
700aa920: 2800         	cmp	r0, #0x0
700aa922: d501         	bpl	0x700aa928 <Udma_chUnpair+0x28> @ imm = #0x2
700aa924: e7ff         	b	0x700aa926 <Udma_chUnpair+0x26> @ imm = #-0x2
;     }
700aa926: e029         	b	0x700aa97c <Udma_chUnpair+0x7c> @ imm = #0x52
;         rmUnpairReq.nav_id = drvHandle->devIdPsil;
700aa928: 9805         	ldr	r0, [sp, #0x14]
700aa92a: f8b0 00e4    	ldrh.w	r0, [r0, #0xe4]
700aa92e: 9002         	str	r0, [sp, #0x8]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700aa930: 9807         	ldr	r0, [sp, #0x1c]
700aa932: 7800         	ldrb	r0, [r0]
700aa934: 07c0         	lsls	r0, r0, #0x1f
700aa936: b158         	cbz	r0, 0x700aa950 <Udma_chUnpair+0x50> @ imm = #0x16
700aa938: e7ff         	b	0x700aa93a <Udma_chUnpair+0x3a> @ imm = #-0x2
;             rmUnpairReq.src_thread = chHandle->txChNum + drvHandle->udmapSrcThreadOffset;
700aa93a: 9807         	ldr	r0, [sp, #0x1c]
700aa93c: 6ec0         	ldr	r0, [r0, #0x6c]
700aa93e: 9905         	ldr	r1, [sp, #0x14]
700aa940: f8d1 10d4    	ldr.w	r1, [r1, #0xd4]
700aa944: 4408         	add	r0, r1
700aa946: 9003         	str	r0, [sp, #0xc]
;             rmUnpairReq.dst_thread = chHandle->peerThreadId;
700aa948: 9807         	ldr	r0, [sp, #0x1c]
700aa94a: 6fc0         	ldr	r0, [r0, #0x7c]
700aa94c: 9004         	str	r0, [sp, #0x10]
;         }
700aa94e: e00a         	b	0x700aa966 <Udma_chUnpair+0x66> @ imm = #0x14
;             rmUnpairReq.src_thread = chHandle->peerThreadId;
700aa950: 9807         	ldr	r0, [sp, #0x1c]
700aa952: 6fc0         	ldr	r0, [r0, #0x7c]
700aa954: 9003         	str	r0, [sp, #0xc]
;             rmUnpairReq.dst_thread = chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
700aa956: 9807         	ldr	r0, [sp, #0x1c]
700aa958: 6f00         	ldr	r0, [r0, #0x70]
700aa95a: 9905         	ldr	r1, [sp, #0x14]
700aa95c: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700aa960: 4408         	add	r0, r1
700aa962: 9004         	str	r0, [sp, #0x10]
700aa964: e7ff         	b	0x700aa966 <Udma_chUnpair+0x66> @ imm = #-0x2
700aa966: 4668         	mov	r0, sp
700aa968: f04f 31ff    	mov.w	r1, #0xffffffff
;         retVal = Sciclient_rmPsilUnpair(&rmUnpairReq, UDMA_SCICLIENT_TIMEOUT);
700aa96c: f002 f9a0    	bl	0x700accb0 <Sciclient_rmPsilUnpair> @ imm = #0x2340
700aa970: 9006         	str	r0, [sp, #0x18]
;         if(CSL_PASS != retVal)
700aa972: 9806         	ldr	r0, [sp, #0x18]
700aa974: b108         	cbz	r0, 0x700aa97a <Udma_chUnpair+0x7a> @ imm = #0x2
700aa976: e7ff         	b	0x700aa978 <Udma_chUnpair+0x78> @ imm = #-0x2
;         }
700aa978: e7ff         	b	0x700aa97a <Udma_chUnpair+0x7a> @ imm = #-0x2
700aa97a: e7ff         	b	0x700aa97c <Udma_chUnpair+0x7c> @ imm = #-0x2
;     return (retVal);
700aa97c: 9806         	ldr	r0, [sp, #0x18]
700aa97e: b008         	add	sp, #0x20
700aa980: bd80         	pop	{r7, pc}
		...
700aa98e: 0000         	movs	r0, r0

700aa990 <UART_moduleReset>:
; {
700aa990: b580         	push	{r7, lr}
700aa992: b088         	sub	sp, #0x20
700aa994: 9007         	str	r0, [sp, #0x1c]
700aa996: 2000         	movs	r0, #0x0
;     uint32_t startTicks, elapsedTicks = 0;
700aa998: 9005         	str	r0, [sp, #0x14]
;     hUartInit = hUart->hUartInit;
700aa99a: 9807         	ldr	r0, [sp, #0x1c]
700aa99c: 6840         	ldr	r0, [r0, #0x4]
700aa99e: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(hUart->baseAddr + UART_SYSC, UART_SYSC_SOFTRESET,
700aa9a0: 9807         	ldr	r0, [sp, #0x1c]
700aa9a2: 6800         	ldr	r0, [r0]
700aa9a4: 3054         	adds	r0, #0x54
700aa9a6: 2102         	movs	r1, #0x2
700aa9a8: 2301         	movs	r3, #0x1
700aa9aa: 461a         	mov	r2, r3
700aa9ac: f003 fe88    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x3d10
;     startTicks = hUartInit->clockP_get();
700aa9b0: 9804         	ldr	r0, [sp, #0x10]
700aa9b2: 6d40         	ldr	r0, [r0, #0x54]
700aa9b4: 4780         	blx	r0
700aa9b6: 9006         	str	r0, [sp, #0x18]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700aa9b8: e7ff         	b	0x700aa9ba <UART_moduleReset+0x2a> @ imm = #-0x2
700aa9ba: 9807         	ldr	r0, [sp, #0x1c]
700aa9bc: 6800         	ldr	r0, [r0]
700aa9be: 3058         	adds	r0, #0x58
700aa9c0: 2101         	movs	r1, #0x1
700aa9c2: 2200         	movs	r2, #0x0
700aa9c4: 9202         	str	r2, [sp, #0x8]
700aa9c6: f004 fcc3    	bl	0x700af350 <HW_RD_FIELD32_RAW> @ imm = #0x4986
700aa9ca: 4601         	mov	r1, r0
700aa9cc: 9802         	ldr	r0, [sp, #0x8]
700aa9ce: 9003         	str	r0, [sp, #0xc]
700aa9d0: b989         	cbnz	r1, 0x700aa9f6 <UART_moduleReset+0x66> @ imm = #0x22
700aa9d2: e7ff         	b	0x700aa9d4 <UART_moduleReset+0x44> @ imm = #-0x2
700aa9d4: 9805         	ldr	r0, [sp, #0x14]
700aa9d6: 9000         	str	r0, [sp]
700aa9d8: 9804         	ldr	r0, [sp, #0x10]
700aa9da: 6d82         	ldr	r2, [r0, #0x58]
700aa9dc: f44f 70fa    	mov.w	r0, #0x1f4
700aa9e0: 2100         	movs	r1, #0x0
700aa9e2: 9101         	str	r1, [sp, #0x4]
700aa9e4: 4790         	blx	r2
700aa9e6: 9900         	ldr	r1, [sp]
700aa9e8: 4602         	mov	r2, r0
700aa9ea: 9801         	ldr	r0, [sp, #0x4]
700aa9ec: 4291         	cmp	r1, r2
700aa9ee: bf38         	it	lo
700aa9f0: 2001         	movlo	r0, #0x1
700aa9f2: 9003         	str	r0, [sp, #0xc]
700aa9f4: e7ff         	b	0x700aa9f6 <UART_moduleReset+0x66> @ imm = #-0x2
700aa9f6: 9803         	ldr	r0, [sp, #0xc]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700aa9f8: 07c0         	lsls	r0, r0, #0x1f
700aa9fa: b138         	cbz	r0, 0x700aaa0c <UART_moduleReset+0x7c> @ imm = #0xe
700aa9fc: e7ff         	b	0x700aa9fe <UART_moduleReset+0x6e> @ imm = #-0x2
;         elapsedTicks = hUartInit->clockP_get() - startTicks;
700aa9fe: 9804         	ldr	r0, [sp, #0x10]
700aaa00: 6d40         	ldr	r0, [r0, #0x54]
700aaa02: 4780         	blx	r0
700aaa04: 9906         	ldr	r1, [sp, #0x18]
700aaa06: 1a40         	subs	r0, r0, r1
700aaa08: 9005         	str	r0, [sp, #0x14]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700aaa0a: e7d6         	b	0x700aa9ba <UART_moduleReset+0x2a> @ imm = #-0x54
; }
700aaa0c: b008         	add	sp, #0x20
700aaa0e: bd80         	pop	{r7, pc}

700aaa10 <CSL_bcdmaChanOpIsChanEnabled>:
; {
700aaa10: b580         	push	{r7, lr}
700aaa12: b086         	sub	sp, #0x18
700aaa14: 9005         	str	r0, [sp, #0x14]
700aaa16: 9104         	str	r1, [sp, #0x10]
700aaa18: 9203         	str	r2, [sp, #0xc]
;     switch( chanType )
700aaa1a: 9804         	ldr	r0, [sp, #0x10]
700aaa1c: 9001         	str	r0, [sp, #0x4]
700aaa1e: b140         	cbz	r0, 0x700aaa32 <CSL_bcdmaChanOpIsChanEnabled+0x22> @ imm = #0x10
700aaa20: e7ff         	b	0x700aaa22 <CSL_bcdmaChanOpIsChanEnabled+0x12> @ imm = #-0x2
700aaa22: 9801         	ldr	r0, [sp, #0x4]
700aaa24: 2801         	cmp	r0, #0x1
700aaa26: d010         	beq	0x700aaa4a <CSL_bcdmaChanOpIsChanEnabled+0x3a> @ imm = #0x20
700aaa28: e7ff         	b	0x700aaa2a <CSL_bcdmaChanOpIsChanEnabled+0x1a> @ imm = #-0x2
700aaa2a: 9801         	ldr	r0, [sp, #0x4]
700aaa2c: 2802         	cmp	r0, #0x2
700aaa2e: d018         	beq	0x700aaa62 <CSL_bcdmaChanOpIsChanEnabled+0x52> @ imm = #0x30
700aaa30: e023         	b	0x700aaa7a <CSL_bcdmaChanOpIsChanEnabled+0x6a> @ imm = #0x46
;             regVal = CSL_REG32_FEXT( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_EN );
700aaa32: 9805         	ldr	r0, [sp, #0x14]
700aaa34: 6880         	ldr	r0, [r0, #0x8]
700aaa36: 9903         	ldr	r1, [sp, #0xc]
700aaa38: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aaa3c: f04f 4100    	mov.w	r1, #0x80000000
700aaa40: 221f         	movs	r2, #0x1f
700aaa42: f004 fb2d    	bl	0x700af0a0 <CSL_REG32_FEXT_RAW> @ imm = #0x465a
700aaa46: 9002         	str	r0, [sp, #0x8]
;             break;
700aaa48: e01a         	b	0x700aaa80 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x34
;             regVal = CSL_REG32_FEXT( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_EN );
700aaa4a: 9805         	ldr	r0, [sp, #0x14]
700aaa4c: 6900         	ldr	r0, [r0, #0x10]
700aaa4e: 9903         	ldr	r1, [sp, #0xc]
700aaa50: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aaa54: f04f 4100    	mov.w	r1, #0x80000000
700aaa58: 221f         	movs	r2, #0x1f
700aaa5a: f004 fb21    	bl	0x700af0a0 <CSL_REG32_FEXT_RAW> @ imm = #0x4642
700aaa5e: 9002         	str	r0, [sp, #0x8]
;             break;
700aaa60: e00e         	b	0x700aaa80 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x1c
;             regVal = CSL_REG32_FEXT( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_EN );
700aaa62: 9805         	ldr	r0, [sp, #0x14]
700aaa64: 6980         	ldr	r0, [r0, #0x18]
700aaa66: 9903         	ldr	r1, [sp, #0xc]
700aaa68: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aaa6c: f04f 4100    	mov.w	r1, #0x80000000
700aaa70: 221f         	movs	r2, #0x1f
700aaa72: f004 fb15    	bl	0x700af0a0 <CSL_REG32_FEXT_RAW> @ imm = #0x462a
700aaa76: 9002         	str	r0, [sp, #0x8]
;             break;
700aaa78: e002         	b	0x700aaa80 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x4
700aaa7a: 2000         	movs	r0, #0x0
;             regVal = 0U;
700aaa7c: 9002         	str	r0, [sp, #0x8]
;             break;
700aaa7e: e7ff         	b	0x700aaa80 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #-0x2
;     return ((regVal == 1U) ? (bool)true : (bool)false);
700aaa80: 9802         	ldr	r0, [sp, #0x8]
700aaa82: 3801         	subs	r0, #0x1
700aaa84: fab0 f080    	clz	r0, r0
700aaa88: 0940         	lsrs	r0, r0, #0x5
700aaa8a: b006         	add	sp, #0x18
700aaa8c: bd80         	pop	{r7, pc}
700aaa8e: 0000         	movs	r0, r0

700aaa90 <CSL_bcdmaChanOpIsValidChanIdx>:
; {
700aaa90: b084         	sub	sp, #0x10
700aaa92: 9003         	str	r0, [sp, #0xc]
700aaa94: 9102         	str	r1, [sp, #0x8]
700aaa96: 9201         	str	r2, [sp, #0x4]
700aaa98: 2001         	movs	r0, #0x1
;     bool retVal = (bool)true;
700aaa9a: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if( chanType == CSL_BCDMA_CHAN_TYPE_BLOCK_COPY )
700aaa9e: 9802         	ldr	r0, [sp, #0x8]
700aaaa0: b958         	cbnz	r0, 0x700aaaba <CSL_bcdmaChanOpIsValidChanIdx+0x2a> @ imm = #0x16
700aaaa2: e7ff         	b	0x700aaaa4 <CSL_bcdmaChanOpIsValidChanIdx+0x14> @ imm = #-0x2
;         if( chanIdx > pCfg->bcChanCnt )
700aaaa4: 9801         	ldr	r0, [sp, #0x4]
700aaaa6: 9903         	ldr	r1, [sp, #0xc]
700aaaa8: 6a49         	ldr	r1, [r1, #0x24]
700aaaaa: 4288         	cmp	r0, r1
700aaaac: d904         	bls	0x700aaab8 <CSL_bcdmaChanOpIsValidChanIdx+0x28> @ imm = #0x8
700aaaae: e7ff         	b	0x700aaab0 <CSL_bcdmaChanOpIsValidChanIdx+0x20> @ imm = #-0x2
700aaab0: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700aaab2: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700aaab6: e7ff         	b	0x700aaab8 <CSL_bcdmaChanOpIsValidChanIdx+0x28> @ imm = #-0x2
;     }
700aaab8: e023         	b	0x700aab02 <CSL_bcdmaChanOpIsValidChanIdx+0x72> @ imm = #0x46
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700aaaba: 9802         	ldr	r0, [sp, #0x8]
700aaabc: 2802         	cmp	r0, #0x2
700aaabe: d10b         	bne	0x700aaad8 <CSL_bcdmaChanOpIsValidChanIdx+0x48> @ imm = #0x16
700aaac0: e7ff         	b	0x700aaac2 <CSL_bcdmaChanOpIsValidChanIdx+0x32> @ imm = #-0x2
;         if( chanIdx > pCfg->splitRxChanCnt )
700aaac2: 9801         	ldr	r0, [sp, #0x4]
700aaac4: 9903         	ldr	r1, [sp, #0xc]
700aaac6: 6a89         	ldr	r1, [r1, #0x28]
700aaac8: 4288         	cmp	r0, r1
700aaaca: d904         	bls	0x700aaad6 <CSL_bcdmaChanOpIsValidChanIdx+0x46> @ imm = #0x8
700aaacc: e7ff         	b	0x700aaace <CSL_bcdmaChanOpIsValidChanIdx+0x3e> @ imm = #-0x2
700aaace: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700aaad0: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700aaad4: e7ff         	b	0x700aaad6 <CSL_bcdmaChanOpIsValidChanIdx+0x46> @ imm = #-0x2
;     }
700aaad6: e013         	b	0x700aab00 <CSL_bcdmaChanOpIsValidChanIdx+0x70> @ imm = #0x26
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_TX )
700aaad8: 9802         	ldr	r0, [sp, #0x8]
700aaada: 2801         	cmp	r0, #0x1
700aaadc: d10b         	bne	0x700aaaf6 <CSL_bcdmaChanOpIsValidChanIdx+0x66> @ imm = #0x16
700aaade: e7ff         	b	0x700aaae0 <CSL_bcdmaChanOpIsValidChanIdx+0x50> @ imm = #-0x2
;         if( chanIdx > pCfg->splitTxChanCnt )
700aaae0: 9801         	ldr	r0, [sp, #0x4]
700aaae2: 9903         	ldr	r1, [sp, #0xc]
700aaae4: 6ac9         	ldr	r1, [r1, #0x2c]
700aaae6: 4288         	cmp	r0, r1
700aaae8: d904         	bls	0x700aaaf4 <CSL_bcdmaChanOpIsValidChanIdx+0x64> @ imm = #0x8
700aaaea: e7ff         	b	0x700aaaec <CSL_bcdmaChanOpIsValidChanIdx+0x5c> @ imm = #-0x2
700aaaec: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700aaaee: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700aaaf2: e7ff         	b	0x700aaaf4 <CSL_bcdmaChanOpIsValidChanIdx+0x64> @ imm = #-0x2
;     }
700aaaf4: e003         	b	0x700aaafe <CSL_bcdmaChanOpIsValidChanIdx+0x6e> @ imm = #0x6
700aaaf6: 2000         	movs	r0, #0x0
;         retVal = (bool)false;
700aaaf8: f88d 0003    	strb.w	r0, [sp, #0x3]
700aaafc: e7ff         	b	0x700aaafe <CSL_bcdmaChanOpIsValidChanIdx+0x6e> @ imm = #-0x2
700aaafe: e7ff         	b	0x700aab00 <CSL_bcdmaChanOpIsValidChanIdx+0x70> @ imm = #-0x2
700aab00: e7ff         	b	0x700aab02 <CSL_bcdmaChanOpIsValidChanIdx+0x72> @ imm = #-0x2
;     return retVal;
700aab02: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aab06: f000 0001    	and	r0, r0, #0x1
700aab0a: b004         	add	sp, #0x10
700aab0c: 4770         	bx	lr
700aab0e: 0000         	movs	r0, r0

700aab10 <CSL_bcdmaMapChanIdx>:
; {
700aab10: b084         	sub	sp, #0x10
700aab12: 9003         	str	r0, [sp, #0xc]
700aab14: 9102         	str	r1, [sp, #0x8]
700aab16: 9201         	str	r2, [sp, #0x4]
;     if( chanIdx < pCfg->bcChanCnt )
700aab18: 9802         	ldr	r0, [sp, #0x8]
700aab1a: 9903         	ldr	r1, [sp, #0xc]
700aab1c: 6a49         	ldr	r1, [r1, #0x24]
700aab1e: 4288         	cmp	r0, r1
700aab20: d206         	bhs	0x700aab30 <CSL_bcdmaMapChanIdx+0x20> @ imm = #0xc
700aab22: e7ff         	b	0x700aab24 <CSL_bcdmaMapChanIdx+0x14> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_BLOCK_COPY;
700aab24: 9901         	ldr	r1, [sp, #0x4]
700aab26: 2000         	movs	r0, #0x0
700aab28: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx;
700aab2a: 9802         	ldr	r0, [sp, #0x8]
700aab2c: 9000         	str	r0, [sp]
;     }
700aab2e: e02b         	b	0x700aab88 <CSL_bcdmaMapChanIdx+0x78> @ imm = #0x56
;     else if( chanIdx < (pCfg->bcChanCnt + pCfg->splitTxChanCnt) )
700aab30: 9802         	ldr	r0, [sp, #0x8]
700aab32: 9a03         	ldr	r2, [sp, #0xc]
700aab34: 6a51         	ldr	r1, [r2, #0x24]
700aab36: 6ad2         	ldr	r2, [r2, #0x2c]
700aab38: 4411         	add	r1, r2
700aab3a: 4288         	cmp	r0, r1
700aab3c: d209         	bhs	0x700aab52 <CSL_bcdmaMapChanIdx+0x42> @ imm = #0x12
700aab3e: e7ff         	b	0x700aab40 <CSL_bcdmaMapChanIdx+0x30> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_SPLIT_TX;
700aab40: 9901         	ldr	r1, [sp, #0x4]
700aab42: 2001         	movs	r0, #0x1
700aab44: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx - pCfg->bcChanCnt;
700aab46: 9802         	ldr	r0, [sp, #0x8]
700aab48: 9903         	ldr	r1, [sp, #0xc]
700aab4a: 6a49         	ldr	r1, [r1, #0x24]
700aab4c: 1a40         	subs	r0, r0, r1
700aab4e: 9000         	str	r0, [sp]
;     }
700aab50: e019         	b	0x700aab86 <CSL_bcdmaMapChanIdx+0x76> @ imm = #0x32
;     else if( chanIdx < (pCfg->bcChanCnt + pCfg->splitTxChanCnt + pCfg->splitRxChanCnt) )
700aab52: 9802         	ldr	r0, [sp, #0x8]
700aab54: 9b03         	ldr	r3, [sp, #0xc]
700aab56: 6a59         	ldr	r1, [r3, #0x24]
700aab58: 6a9a         	ldr	r2, [r3, #0x28]
700aab5a: 6adb         	ldr	r3, [r3, #0x2c]
700aab5c: 4419         	add	r1, r3
700aab5e: 4411         	add	r1, r2
700aab60: 4288         	cmp	r0, r1
700aab62: d20b         	bhs	0x700aab7c <CSL_bcdmaMapChanIdx+0x6c> @ imm = #0x16
700aab64: e7ff         	b	0x700aab66 <CSL_bcdmaMapChanIdx+0x56> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_SPLIT_RX;
700aab66: 9901         	ldr	r1, [sp, #0x4]
700aab68: 2002         	movs	r0, #0x2
700aab6a: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx - pCfg->bcChanCnt - pCfg->splitTxChanCnt;
700aab6c: 9802         	ldr	r0, [sp, #0x8]
700aab6e: 9903         	ldr	r1, [sp, #0xc]
700aab70: 6a4a         	ldr	r2, [r1, #0x24]
700aab72: 6ac9         	ldr	r1, [r1, #0x2c]
700aab74: 1a80         	subs	r0, r0, r2
700aab76: 1a40         	subs	r0, r0, r1
700aab78: 9000         	str	r0, [sp]
;     }
700aab7a: e003         	b	0x700aab84 <CSL_bcdmaMapChanIdx+0x74> @ imm = #0x6
700aab7c: f04f 30ff    	mov.w	r0, #0xffffffff
;         base0chanIdx = CSL_BCDMA_INVALID_CHANNEL_INDEX;
700aab80: 9000         	str	r0, [sp]
700aab82: e7ff         	b	0x700aab84 <CSL_bcdmaMapChanIdx+0x74> @ imm = #-0x2
700aab84: e7ff         	b	0x700aab86 <CSL_bcdmaMapChanIdx+0x76> @ imm = #-0x2
700aab86: e7ff         	b	0x700aab88 <CSL_bcdmaMapChanIdx+0x78> @ imm = #-0x2
;     return base0chanIdx;
700aab88: 9800         	ldr	r0, [sp]
700aab8a: b004         	add	sp, #0x10
700aab8c: 4770         	bx	lr
700aab8e: 0000         	movs	r0, r0

700aab90 <ClockP_getTimeUsec>:
; {
700aab90: b580         	push	{r7, lr}
700aab92: b08a         	sub	sp, #0x28
700aab94: 2000         	movs	r0, #0x0
;     uint64_t ts = 0U;
700aab96: 9009         	str	r0, [sp, #0x24]
700aab98: 9008         	str	r0, [sp, #0x20]
;     do {
700aab9a: e7ff         	b	0x700aab9c <ClockP_getTimeUsec+0xc> @ imm = #-0x2
;         ticks1 = gClockCtrl.ticks;
700aab9c: f245 1090    	movw	r0, #0x5190
700aaba0: f2c7 0008    	movt	r0, #0x7008
700aaba4: 9001         	str	r0, [sp, #0x4]
700aaba6: 6801         	ldr	r1, [r0]
700aaba8: 6842         	ldr	r2, [r0, #0x4]
700aabaa: 9205         	str	r2, [sp, #0x14]
700aabac: 9104         	str	r1, [sp, #0x10]
;         timerCount = ClockP_getTimerCount(gClockCtrl.timerBaseAddr);
700aabae: 6ac0         	ldr	r0, [r0, #0x2c]
700aabb0: f004 ffce    	bl	0x700afb50 <ClockP_getTimerCount> @ imm = #0x4f9c
700aabb4: 9901         	ldr	r1, [sp, #0x4]
700aabb6: 9007         	str	r0, [sp, #0x1c]
;         ticks2 = gClockCtrl.ticks;
700aabb8: 6808         	ldr	r0, [r1]
700aabba: 6849         	ldr	r1, [r1, #0x4]
700aabbc: 9103         	str	r1, [sp, #0xc]
700aabbe: 9002         	str	r0, [sp, #0x8]
;     } while (ticks1 != ticks2);
700aabc0: e7ff         	b	0x700aabc2 <ClockP_getTimeUsec+0x32> @ imm = #-0x2
700aabc2: 9804         	ldr	r0, [sp, #0x10]
700aabc4: 9905         	ldr	r1, [sp, #0x14]
700aabc6: 9a02         	ldr	r2, [sp, #0x8]
700aabc8: 9b03         	ldr	r3, [sp, #0xc]
700aabca: 4059         	eors	r1, r3
700aabcc: ea80 0002    	eor.w	r0, r0, r2
700aabd0: 4308         	orrs	r0, r1
700aabd2: 2800         	cmp	r0, #0x0
700aabd4: d1e2         	bne	0x700aab9c <ClockP_getTimeUsec+0xc> @ imm = #-0x3c
700aabd6: e7ff         	b	0x700aabd8 <ClockP_getTimeUsec+0x48> @ imm = #-0x2
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700aabd8: 9a02         	ldr	r2, [sp, #0x8]
700aabda: 9803         	ldr	r0, [sp, #0xc]
700aabdc: f245 1190    	movw	r1, #0x5190
700aabe0: f2c7 0108    	movt	r1, #0x7008
700aabe4: 688b         	ldr	r3, [r1, #0x8]
;                 (uint64_t)(((timerCount - gClockCtrl.timerReloadCount)*gClockCtrl.usecPerTick)/(MAX_TIMER_COUNT_VALUE - gClockCtrl.timerReloadCount))
700aabe6: f8d1 c030    	ldr.w	r12, [r1, #0x30]
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700aabea: fb00 f103    	mul	r1, r0, r3
;                 (uint64_t)(((timerCount - gClockCtrl.timerReloadCount)*gClockCtrl.usecPerTick)/(MAX_TIMER_COUNT_VALUE - gClockCtrl.timerReloadCount))
700aabee: 9807         	ldr	r0, [sp, #0x1c]
700aabf0: eba0 000c    	sub.w	r0, r0, r12
700aabf4: 4358         	muls	r0, r3, r0
700aabf6: ea6f 0c0c    	mvn.w	r12, r12
700aabfa: fbb0 f0fc    	udiv	r0, r0, r12
;              + (uint64_t) ( /* convert timer count to usecs */
700aabfe: fbe2 0103    	umlal	r0, r1, r2, r3
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700aac02: 9109         	str	r1, [sp, #0x24]
700aac04: 9008         	str	r0, [sp, #0x20]
;     return (ts);
700aac06: 9808         	ldr	r0, [sp, #0x20]
700aac08: 9909         	ldr	r1, [sp, #0x24]
700aac0a: b00a         	add	sp, #0x28
700aac0c: bd80         	pop	{r7, pc}
700aac0e: 0000         	movs	r0, r0

700aac10 <UART_readData>:
; {
700aac10: b580         	push	{r7, lr}
700aac12: b086         	sub	sp, #0x18
700aac14: 9005         	str	r0, [sp, #0x14]
700aac16: 9104         	str	r1, [sp, #0x10]
700aac18: 2000         	movs	r0, #0x0
;     uint8_t             readIn = 0;
700aac1a: f88d 000f    	strb.w	r0, [sp, #0xf]
;     uint32_t             rdSize = size;
700aac1e: 9804         	ldr	r0, [sp, #0x10]
700aac20: 9001         	str	r0, [sp, #0x4]
;     readSuccess = UART_getChar(hUart->baseAddr, &readIn);
700aac22: 9805         	ldr	r0, [sp, #0x14]
700aac24: 6800         	ldr	r0, [r0]
700aac26: f10d 010f    	add.w	r1, sp, #0xf
700aac2a: f001 fbd1    	bl	0x700ac3d0 <UART_getChar> @ imm = #0x17a2
700aac2e: 9002         	str	r0, [sp, #0x8]
;     while ((rdSize != 0U) && (readSuccess != 0U))
700aac30: e7ff         	b	0x700aac32 <UART_readData+0x22> @ imm = #-0x2
700aac32: 9901         	ldr	r1, [sp, #0x4]
700aac34: 2000         	movs	r0, #0x0
700aac36: 9000         	str	r0, [sp]
700aac38: b131         	cbz	r1, 0x700aac48 <UART_readData+0x38> @ imm = #0xc
700aac3a: e7ff         	b	0x700aac3c <UART_readData+0x2c> @ imm = #-0x2
700aac3c: 9802         	ldr	r0, [sp, #0x8]
700aac3e: 2800         	cmp	r0, #0x0
700aac40: bf18         	it	ne
700aac42: 2001         	movne	r0, #0x1
700aac44: 9000         	str	r0, [sp]
700aac46: e7ff         	b	0x700aac48 <UART_readData+0x38> @ imm = #-0x2
700aac48: 9800         	ldr	r0, [sp]
;     while ((rdSize != 0U) && (readSuccess != 0U))
700aac4a: 07c0         	lsls	r0, r0, #0x1f
700aac4c: b1e0         	cbz	r0, 0x700aac88 <UART_readData+0x78> @ imm = #0x38
700aac4e: e7ff         	b	0x700aac50 <UART_readData+0x40> @ imm = #-0x2
;         *(uint8_t *)hUart->readBuf = readIn;
700aac50: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700aac54: 9905         	ldr	r1, [sp, #0x14]
700aac56: 6949         	ldr	r1, [r1, #0x14]
700aac58: 7008         	strb	r0, [r1]
;         hUart->readBuf = (uint8_t *)hUart->readBuf + 1U;
700aac5a: 9905         	ldr	r1, [sp, #0x14]
700aac5c: 6948         	ldr	r0, [r1, #0x14]
700aac5e: 3001         	adds	r0, #0x1
700aac60: 6148         	str	r0, [r1, #0x14]
;         hUart->readCount++;
700aac62: 9905         	ldr	r1, [sp, #0x14]
700aac64: 6988         	ldr	r0, [r1, #0x18]
700aac66: 3001         	adds	r0, #0x1
700aac68: 6188         	str	r0, [r1, #0x18]
;         rdSize--;
700aac6a: 9801         	ldr	r0, [sp, #0x4]
700aac6c: 3801         	subs	r0, #0x1
700aac6e: 9001         	str	r0, [sp, #0x4]
;         if (rdSize != 0U)
700aac70: 9801         	ldr	r0, [sp, #0x4]
700aac72: b140         	cbz	r0, 0x700aac86 <UART_readData+0x76> @ imm = #0x10
700aac74: e7ff         	b	0x700aac76 <UART_readData+0x66> @ imm = #-0x2
;             readSuccess = UART_getChar(hUart->baseAddr, &readIn);
700aac76: 9805         	ldr	r0, [sp, #0x14]
700aac78: 6800         	ldr	r0, [r0]
700aac7a: f10d 010f    	add.w	r1, sp, #0xf
700aac7e: f001 fba7    	bl	0x700ac3d0 <UART_getChar> @ imm = #0x174e
700aac82: 9002         	str	r0, [sp, #0x8]
;         }
700aac84: e7ff         	b	0x700aac86 <UART_readData+0x76> @ imm = #-0x2
;     while ((rdSize != 0U) && (readSuccess != 0U))
700aac86: e7d4         	b	0x700aac32 <UART_readData+0x22> @ imm = #-0x58
;     return (rdSize);
700aac88: 9801         	ldr	r0, [sp, #0x4]
700aac8a: b006         	add	sp, #0x18
700aac8c: bd80         	pop	{r7, pc}
700aac8e: 0000         	movs	r0, r0

700aac90 <_DebugP_assert>:
; {
700aac90: b5b0         	push	{r4, r5, r7, lr}
700aac92: b08e         	sub	sp, #0x38
700aac94: f8dd c048    	ldr.w	r12, [sp, #0x48]
700aac98: 900d         	str	r0, [sp, #0x34]
700aac9a: 910c         	str	r1, [sp, #0x30]
700aac9c: 920b         	str	r2, [sp, #0x2c]
700aac9e: 930a         	str	r3, [sp, #0x28]
;     if(expression==0)
700aaca0: 980d         	ldr	r0, [sp, #0x34]
700aaca2: bb88         	cbnz	r0, 0x700aad08 <_DebugP_assert+0x78> @ imm = #0x62
700aaca4: e7ff         	b	0x700aaca6 <_DebugP_assert+0x16> @ imm = #-0x2
700aaca6: 2001         	movs	r0, #0x1
;         volatile uint32_t assert_loop = 1;
700aaca8: 9004         	str	r0, [sp, #0x10]
700aacaa: 9009         	str	r0, [sp, #0x24]
;         uint64_t curTime = ClockP_getTimeUsec();
700aacac: f7ff ff70    	bl	0x700aab90 <ClockP_getTimeUsec> @ imm = #-0x120
700aacb0: 9107         	str	r1, [sp, #0x1c]
700aacb2: 9006         	str	r0, [sp, #0x18]
;         DebugP_log("ASSERT: %d.%ds: %s:%s:%d: %s failed !!!\r\n",
700aacb4: 9806         	ldr	r0, [sp, #0x18]
700aacb6: 9907         	ldr	r1, [sp, #0x1c]
700aacb8: f244 2240    	movw	r2, #0x4240
700aacbc: f2c0 020f    	movt	r2, #0xf
700aacc0: 2300         	movs	r3, #0x0
700aacc2: f004 ea90    	blx	0x700af1e4 <__aeabi_uldivmod> @ imm = #0x4520
700aacc6: 4603         	mov	r3, r0
700aacc8: 9804         	ldr	r0, [sp, #0x10]
700aacca: 9305         	str	r3, [sp, #0x14]
700aaccc: 4613         	mov	r3, r2
700aacce: 9a05         	ldr	r2, [sp, #0x14]
700aacd0: 990c         	ldr	r1, [sp, #0x30]
700aacd2: f8dd e02c    	ldr.w	lr, [sp, #0x2c]
700aacd6: 9c0a         	ldr	r4, [sp, #0x28]
700aacd8: 9d12         	ldr	r5, [sp, #0x48]
700aacda: 46ec         	mov	r12, sp
700aacdc: f8cc 500c    	str.w	r5, [r12, #0xc]
700aace0: f8cc 4008    	str.w	r4, [r12, #0x8]
700aace4: f8cc e004    	str.w	lr, [r12, #0x4]
700aace8: f8cc 1000    	str.w	r1, [r12]
700aacec: f641 311b    	movw	r1, #0x1b1b
700aacf0: f2c7 010b    	movt	r1, #0x700b
700aacf4: f7ff f814    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #-0xfd8
;         (void) HwiP_disable();
700aacf8: f005 ee32    	blx	0x700b0960 <HwiP_disable> @ imm = #0x5c64
;         while(assert_loop!= 0U)
700aacfc: e7ff         	b	0x700aacfe <_DebugP_assert+0x6e> @ imm = #-0x2
700aacfe: 9809         	ldr	r0, [sp, #0x24]
700aad00: b108         	cbz	r0, 0x700aad06 <_DebugP_assert+0x76> @ imm = #0x2
700aad02: e7ff         	b	0x700aad04 <_DebugP_assert+0x74> @ imm = #-0x2
700aad04: e7fb         	b	0x700aacfe <_DebugP_assert+0x6e> @ imm = #-0xa
;     }
700aad06: e7ff         	b	0x700aad08 <_DebugP_assert+0x78> @ imm = #-0x2
; }
700aad08: b00e         	add	sp, #0x38
700aad0a: bdb0         	pop	{r4, r5, r7, pc}
700aad0c: 0000         	movs	r0, r0
700aad0e: 0000         	movs	r0, r0

700aad10 <UART_Params_init>:
; {
700aad10: b082         	sub	sp, #0x8
700aad12: 9001         	str	r0, [sp, #0x4]
;     if(prms != NULL)
700aad14: 9801         	ldr	r0, [sp, #0x4]
700aad16: b3b0         	cbz	r0, 0x700aad86 <UART_Params_init+0x76> @ imm = #0x6c
700aad18: e7ff         	b	0x700aad1a <UART_Params_init+0xa> @ imm = #-0x2
;         prms->baudRate           = 115200U;
700aad1a: 9901         	ldr	r1, [sp, #0x4]
700aad1c: f44f 30e1    	mov.w	r0, #0x1c200
700aad20: 6008         	str	r0, [r1]
;         prms->dataLength         = UART_LEN_8;
700aad22: 9901         	ldr	r1, [sp, #0x4]
700aad24: 2003         	movs	r0, #0x3
700aad26: 6048         	str	r0, [r1, #0x4]
;         prms->stopBits           = UART_STOPBITS_1;
700aad28: 9901         	ldr	r1, [sp, #0x4]
700aad2a: 2000         	movs	r0, #0x0
700aad2c: 9000         	str	r0, [sp]
700aad2e: 6088         	str	r0, [r1, #0x8]
;         prms->parityType         = UART_PARITY_NONE;
700aad30: 9901         	ldr	r1, [sp, #0x4]
700aad32: 60c8         	str	r0, [r1, #0xc]
;         prms->readMode           = UART_TRANSFER_MODE_BLOCKING;
700aad34: 9901         	ldr	r1, [sp, #0x4]
700aad36: 6108         	str	r0, [r1, #0x10]
;         prms->readReturnMode     = UART_READ_RETURN_MODE_FULL;
700aad38: 9901         	ldr	r1, [sp, #0x4]
700aad3a: 6148         	str	r0, [r1, #0x14]
;         prms->writeMode          = UART_TRANSFER_MODE_BLOCKING;
700aad3c: 9901         	ldr	r1, [sp, #0x4]
700aad3e: 6188         	str	r0, [r1, #0x18]
;         prms->readCallbackFxn    = NULL;
700aad40: 9901         	ldr	r1, [sp, #0x4]
700aad42: 61c8         	str	r0, [r1, #0x1c]
;         prms->writeCallbackFxn   = NULL;
700aad44: 9901         	ldr	r1, [sp, #0x4]
700aad46: 6208         	str	r0, [r1, #0x20]
;         prms->hwFlowControl      = FALSE;
700aad48: 9901         	ldr	r1, [sp, #0x4]
700aad4a: 6248         	str	r0, [r1, #0x24]
;         prms->hwFlowControlThr   = UART_RXTRIGLVL_16;
700aad4c: 9a01         	ldr	r2, [sp, #0x4]
700aad4e: 2110         	movs	r1, #0x10
700aad50: 6291         	str	r1, [r2, #0x28]
;         prms->intrNum            = 0xFFFF;
700aad52: 9a01         	ldr	r2, [sp, #0x4]
700aad54: f64f 71ff    	movw	r1, #0xffff
700aad58: 6311         	str	r1, [r2, #0x30]
;         prms->transferMode       = UART_CONFIG_MODE_INTERRUPT;
700aad5a: 9a01         	ldr	r2, [sp, #0x4]
700aad5c: 2101         	movs	r1, #0x1
700aad5e: 62d1         	str	r1, [r2, #0x2c]
;         prms->intrPriority       = 4U;
700aad60: 9a01         	ldr	r2, [sp, #0x4]
700aad62: 2104         	movs	r1, #0x4
700aad64: f882 1034    	strb.w	r1, [r2, #0x34]
;         prms->skipIntrReg        = FALSE;
700aad68: 9901         	ldr	r1, [sp, #0x4]
700aad6a: 6388         	str	r0, [r1, #0x38]
;         prms->uartDmaIndex       = -1;
700aad6c: 9a01         	ldr	r2, [sp, #0x4]
700aad6e: f04f 31ff    	mov.w	r1, #0xffffffff
700aad72: 63d1         	str	r1, [r2, #0x3c]
;         prms->operMode           = UART_OPER_MODE_16X;
700aad74: 9901         	ldr	r1, [sp, #0x4]
700aad76: 6408         	str	r0, [r1, #0x40]
;         prms->rxTrigLvl          = UART_RXTRIGLVL_8;
700aad78: 9901         	ldr	r1, [sp, #0x4]
700aad7a: 2008         	movs	r0, #0x8
700aad7c: 6448         	str	r0, [r1, #0x44]
;         prms->txTrigLvl          = UART_TXTRIGLVL_32;
700aad7e: 9901         	ldr	r1, [sp, #0x4]
700aad80: 2020         	movs	r0, #0x20
700aad82: 6488         	str	r0, [r1, #0x48]
;     }
700aad84: e7ff         	b	0x700aad86 <UART_Params_init+0x76> @ imm = #-0x2
; }
700aad86: b002         	add	sp, #0x8
700aad88: 4770         	bx	lr
700aad8a: 0000         	movs	r0, r0
700aad8c: 0000         	movs	r0, r0
700aad8e: 0000         	movs	r0, r0

700aad90 <main_task>:
; {
700aad90: b5b0         	push	{r4, r5, r7, lr}
700aad92: b086         	sub	sp, #0x18
;    printf("Starting Thread-Metric tests...\r\n");
700aad94: f641 4141    	movw	r1, #0x1c41
700aad98: 2001         	movs	r0, #0x1
700aad9a: f2c7 010b    	movt	r1, #0x700b
700aad9e: 2501         	movs	r5, #0x1
700aada0: f7fe ffbe    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #-0x1084
;    test_interrupt_handler = tm_isr_message_handler;
700aada4: f245 3011    	movw	r0, #0x5311
700aada8: f642 2110    	movw	r1, #0x2a10
700aadac: f2c7 000a    	movt	r0, #0x700a
700aadb0: ac01         	add	r4, sp, #0x4
700aadb2: f2c7 010b    	movt	r1, #0x700b
700aadb6: 6008         	str	r0, [r1]
;    HwiP_Params_init(&hwiParams);
700aadb8: 4620         	mov	r0, r4
700aadba: f005 f8c9    	bl	0x700aff50 <HwiP_Params_init> @ imm = #0x5192
;    hwiParams.callback = tm_interrupt_handler; /* Interrupt handler */
700aadbe: f64f 2181    	movw	r1, #0xfa81
700aadc2: 200a         	movs	r0, #0xa
700aadc4: f2c7 010a    	movt	r1, #0x700a
;    hwiParams.priority = 1;                    /* Set a valid priority (lower is higher priority) */
700aadc8: f8ad 5012    	strh.w	r5, [sp, #0x12]
;    hwiParams.intNum = SOFTWARE_INTERRUPT_ID;  /* Chosen interrupt ID */
700aadcc: e9cd 0101    	strd	r0, r1, [sp, #4]
;    if (HwiP_construct(&hwiObj, &hwiParams) != SystemP_SUCCESS)
700aadd0: f245 10f0    	movw	r0, #0x51f0
700aadd4: f2c7 0008    	movt	r0, #0x7008
700aadd8: 4621         	mov	r1, r4
700aadda: f005 f8d1    	bl	0x700aff80 <HwiP_construct> @ imm = #0x51a2
700aadde: b140         	cbz	r0, 0x700aadf2 <main_task+0x62> @ imm = #0x10
;       printf("Failed to register interrupt\r\n");
700aade0: f641 5166    	movw	r1, #0x1d66
700aade4: 2001         	movs	r0, #0x1
700aade6: f2c7 010b    	movt	r1, #0x700b
700aadea: f7fe ff99    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #-0x10ce
700aadee: bf00         	nop
;       while (1)
700aadf0: e7fe         	b	0x700aadf0 <main_task+0x60> @ imm = #-0x4
;    HwiP_enableInt(SOFTWARE_INTERRUPT_ID);
700aadf2: 200a         	movs	r0, #0xa
700aadf4: f005 f804    	bl	0x700afe00 <HwiP_enableInt> @ imm = #0x5008
;    HwiP_enable();
700aadf8: f005 edc2    	blx	0x700b0980 <HwiP_enable> @ imm = #0x5b84
;    main_message_isr_test();
700aadfc: f004 fe20    	bl	0x700afa40 <main_message_isr_test> @ imm = #0x4c40
;    vTaskDelete(NULL);
700aae00: 2000         	movs	r0, #0x0
700aae02: f7fb fb8d    	bl	0x700a6520 <vTaskDelete> @ imm = #-0x48e6
; }
700aae06: b006         	add	sp, #0x18
700aae08: bdb0         	pop	{r4, r5, r7, pc}
700aae0a: 0000         	movs	r0, r0

700aae0c <snprintf>:
700aae0c: e24dd004     	sub	sp, sp, #4
700aae10: e92d4070     	push	{r4, r5, r6, lr}
700aae14: e24dd01c     	sub	sp, sp, #28
700aae18: e1a04001     	mov	r4, r1
700aae1c: e3510000     	cmp	r1, #0
700aae20: 12411001     	subne	r1, r1, #1
700aae24: e58d302c     	str	r3, [sp, #0x2c]
700aae28: e59f3050     	ldr	r3, [pc, #0x50]         @ 0x700aae80 <snprintf+0x74>
700aae2c: e3a06000     	mov	r6, #0
700aae30: e59f5044     	ldr	r5, [pc, #0x44]         @ 0x700aae7c <snprintf+0x70>
700aae34: e58d2014     	str	r2, [sp, #0x14]
700aae38: e28d2008     	add	r2, sp, #8
700aae3c: e58d100c     	str	r1, [sp, #0xc]
700aae40: e28d102c     	add	r1, sp, #44
700aae44: e58d0008     	str	r0, [sp, #0x8]
700aae48: e28d0014     	add	r0, sp, #20
700aae4c: e58d6010     	str	r6, [sp, #0x10]
700aae50: e58d1018     	str	r1, [sp, #0x18]
700aae54: e58d5000     	str	r5, [sp]
700aae58: ebffb928     	bl	0x70099300 <__TI_printfi_nofloat> @ imm = #-0x11b60
700aae5c: e3540000     	cmp	r4, #0
700aae60: 0a000001     	beq	0x700aae6c <snprintf+0x60> @ imm = #0x4
700aae64: e59d1008     	ldr	r1, [sp, #0x8]
700aae68: e5c16000     	strb	r6, [r1]
700aae6c: e28dd01c     	add	sp, sp, #28
700aae70: e8bd4070     	pop	{r4, r5, r6, lr}
700aae74: e28dd004     	add	sp, sp, #4
700aae78: e12fff1e     	bx	lr
700aae7c: e8 ca 0a 70  	.word	0x700acae8
700aae80: 90 e8 0a 70  	.word	0x700ae890
700aae84: 00 00 00 00  	.word	0x00000000
700aae88: 00 00 00 00  	.word	0x00000000
700aae8c: 00 00 00 00  	.word	0x00000000

700aae90 <xTimerCreateTimerTask>:
;     {
700aae90: b580         	push	{r7, lr}
700aae92: b088         	sub	sp, #0x20
700aae94: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
700aae96: 9007         	str	r0, [sp, #0x1c]
;         prvCheckForValidListAndQueue();
700aae98: f7fd fe2a    	bl	0x700a8af0 <prvCheckForValidListAndQueue> @ imm = #-0x23ac
;         if( xTimerQueue != NULL )
700aae9c: f642 2058    	movw	r0, #0x2a58
700aaea0: f2c7 000b    	movt	r0, #0x700b
700aaea4: 6800         	ldr	r0, [r0]
700aaea6: b358         	cbz	r0, 0x700aaf00 <xTimerCreateTimerTask+0x70> @ imm = #0x56
700aaea8: e7ff         	b	0x700aaeaa <xTimerCreateTimerTask+0x1a> @ imm = #-0x2
700aaeaa: 2000         	movs	r0, #0x0
;                     StaticTask_t * pxTimerTaskTCBBuffer = NULL;
700aaeac: 9003         	str	r0, [sp, #0xc]
700aaeae: 9006         	str	r0, [sp, #0x18]
;                     StackType_t * pxTimerTaskStackBuffer = NULL;
700aaeb0: 9005         	str	r0, [sp, #0x14]
700aaeb2: a806         	add	r0, sp, #0x18
700aaeb4: a905         	add	r1, sp, #0x14
700aaeb6: aa04         	add	r2, sp, #0x10
;                     vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
700aaeb8: f003 ff12    	bl	0x700aece0 <vApplicationGetTimerTaskMemory> @ imm = #0x3e24
700aaebc: 9b03         	ldr	r3, [sp, #0xc]
;                                                           ulTimerTaskStackSize,
700aaebe: 9a04         	ldr	r2, [sp, #0x10]
;                                                           pxTimerTaskStackBuffer,
700aaec0: 9805         	ldr	r0, [sp, #0x14]
;                                                           pxTimerTaskTCBBuffer );
700aaec2: f8dd c018    	ldr.w	r12, [sp, #0x18]
;                     xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,
700aaec6: 4669         	mov	r1, sp
700aaec8: f8c1 c008    	str.w	r12, [r1, #0x8]
700aaecc: 6048         	str	r0, [r1, #0x4]
700aaece: 201f         	movs	r0, #0x1f
700aaed0: 6008         	str	r0, [r1]
700aaed2: f24f 40f1    	movw	r0, #0xf4f1
700aaed6: f2c7 000a    	movt	r0, #0x700a
700aaeda: f242 510a    	movw	r1, #0x250a
700aaede: f2c7 010b    	movt	r1, #0x700b
700aaee2: f000 fa55    	bl	0x700ab390 <xTaskCreateStatic> @ imm = #0x4aa
700aaee6: 4601         	mov	r1, r0
700aaee8: f642 205c    	movw	r0, #0x2a5c
700aaeec: f2c7 000b    	movt	r0, #0x700b
700aaef0: 6001         	str	r1, [r0]
;                     if( xTimerTaskHandle != NULL )
700aaef2: 6800         	ldr	r0, [r0]
700aaef4: b118         	cbz	r0, 0x700aaefe <xTimerCreateTimerTask+0x6e> @ imm = #0x6
700aaef6: e7ff         	b	0x700aaef8 <xTimerCreateTimerTask+0x68> @ imm = #-0x2
700aaef8: 2001         	movs	r0, #0x1
;                         xReturn = pdPASS;
700aaefa: 9007         	str	r0, [sp, #0x1c]
;                     }
700aaefc: e7ff         	b	0x700aaefe <xTimerCreateTimerTask+0x6e> @ imm = #-0x2
;         }
700aaefe: e000         	b	0x700aaf02 <xTimerCreateTimerTask+0x72> @ imm = #0x0
700aaf00: e7ff         	b	0x700aaf02 <xTimerCreateTimerTask+0x72> @ imm = #-0x2
;         return xReturn;
700aaf02: 9807         	ldr	r0, [sp, #0x1c]
700aaf04: b008         	add	sp, #0x20
700aaf06: bd80         	pop	{r7, pc}
		...

700aaf10 <CSL_bcdmaChanOpClearError>:
; {
700aaf10: b580         	push	{r7, lr}
700aaf12: b086         	sub	sp, #0x18
700aaf14: 9005         	str	r0, [sp, #0x14]
700aaf16: 9104         	str	r1, [sp, #0x10]
700aaf18: 9203         	str	r2, [sp, #0xc]
700aaf1a: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700aaf1c: 9002         	str	r0, [sp, #0x8]
;     switch( chanType )
700aaf1e: 9804         	ldr	r0, [sp, #0x10]
700aaf20: 9001         	str	r0, [sp, #0x4]
700aaf22: b140         	cbz	r0, 0x700aaf36 <CSL_bcdmaChanOpClearError+0x26> @ imm = #0x10
700aaf24: e7ff         	b	0x700aaf26 <CSL_bcdmaChanOpClearError+0x16> @ imm = #-0x2
700aaf26: 9801         	ldr	r0, [sp, #0x4]
700aaf28: 2801         	cmp	r0, #0x1
700aaf2a: d00f         	beq	0x700aaf4c <CSL_bcdmaChanOpClearError+0x3c> @ imm = #0x1e
700aaf2c: e7ff         	b	0x700aaf2e <CSL_bcdmaChanOpClearError+0x1e> @ imm = #-0x2
700aaf2e: 9801         	ldr	r0, [sp, #0x4]
700aaf30: 2802         	cmp	r0, #0x2
700aaf32: d016         	beq	0x700aaf62 <CSL_bcdmaChanOpClearError+0x52> @ imm = #0x2c
700aaf34: e020         	b	0x700aaf78 <CSL_bcdmaChanOpClearError+0x68> @ imm = #0x40
;             CSL_REG32_FINS( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700aaf36: 9805         	ldr	r0, [sp, #0x14]
700aaf38: 6880         	ldr	r0, [r0, #0x8]
700aaf3a: 9903         	ldr	r1, [sp, #0xc]
700aaf3c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aaf40: 2101         	movs	r1, #0x1
700aaf42: 2300         	movs	r3, #0x0
700aaf44: 461a         	mov	r2, r3
700aaf46: f003 f9c3    	bl	0x700ae2d0 <CSL_REG32_FINS_RAW> @ imm = #0x3386
;             break;
700aaf4a: e019         	b	0x700aaf80 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x32
;             CSL_REG32_FINS( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700aaf4c: 9805         	ldr	r0, [sp, #0x14]
700aaf4e: 6900         	ldr	r0, [r0, #0x10]
700aaf50: 9903         	ldr	r1, [sp, #0xc]
700aaf52: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aaf56: 2101         	movs	r1, #0x1
700aaf58: 2300         	movs	r3, #0x0
700aaf5a: 461a         	mov	r2, r3
700aaf5c: f003 f9b8    	bl	0x700ae2d0 <CSL_REG32_FINS_RAW> @ imm = #0x3370
;             break;
700aaf60: e00e         	b	0x700aaf80 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x1c
;             CSL_REG32_FINS( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700aaf62: 9805         	ldr	r0, [sp, #0x14]
700aaf64: 6980         	ldr	r0, [r0, #0x18]
700aaf66: 9903         	ldr	r1, [sp, #0xc]
700aaf68: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aaf6c: 2101         	movs	r1, #0x1
700aaf6e: 2300         	movs	r3, #0x0
700aaf70: 461a         	mov	r2, r3
700aaf72: f003 f9ad    	bl	0x700ae2d0 <CSL_REG32_FINS_RAW> @ imm = #0x335a
;             break;
700aaf76: e003         	b	0x700aaf80 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x6
700aaf78: f06f 0001    	mvn	r0, #0x1
;             retVal = CSL_EBADARGS;
700aaf7c: 9002         	str	r0, [sp, #0x8]
;             break;
700aaf7e: e7ff         	b	0x700aaf80 <CSL_bcdmaChanOpClearError+0x70> @ imm = #-0x2
;     return retVal;
700aaf80: 9802         	ldr	r0, [sp, #0x8]
700aaf82: b006         	add	sp, #0x18
700aaf84: bd80         	pop	{r7, pc}
		...
700aaf8e: 0000         	movs	r0, r0

700aaf90 <CSL_bcdmaDoChanOp>:
; {
700aaf90: b580         	push	{r7, lr}
700aaf92: b088         	sub	sp, #0x20
700aaf94: 9007         	str	r0, [sp, #0x1c]
700aaf96: 9106         	str	r1, [sp, #0x18]
700aaf98: 9205         	str	r2, [sp, #0x14]
700aaf9a: 9304         	str	r3, [sp, #0x10]
700aaf9c: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t retVal = CSL_EFAIL;
700aafa0: 9003         	str	r0, [sp, #0xc]
;     if( pCfg == NULL )
700aafa2: 9807         	ldr	r0, [sp, #0x1c]
700aafa4: b920         	cbnz	r0, 0x700aafb0 <CSL_bcdmaDoChanOp+0x20> @ imm = #0x8
700aafa6: e7ff         	b	0x700aafa8 <CSL_bcdmaDoChanOp+0x18> @ imm = #-0x2
700aafa8: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700aafac: 9003         	str	r0, [sp, #0xc]
;     }
700aafae: e027         	b	0x700ab000 <CSL_bcdmaDoChanOp+0x70> @ imm = #0x4e
;         if( (pCfg->bcChanCnt == (uint32_t)0U) || (pCfg->splitTxChanCnt == (uint32_t)0U) || (pCfg->splitRxChanCnt == (uint32_t)0U) ) {
700aafb0: 9807         	ldr	r0, [sp, #0x1c]
700aafb2: 6a40         	ldr	r0, [r0, #0x24]
700aafb4: b140         	cbz	r0, 0x700aafc8 <CSL_bcdmaDoChanOp+0x38> @ imm = #0x10
700aafb6: e7ff         	b	0x700aafb8 <CSL_bcdmaDoChanOp+0x28> @ imm = #-0x2
700aafb8: 9807         	ldr	r0, [sp, #0x1c]
700aafba: 6ac0         	ldr	r0, [r0, #0x2c]
700aafbc: b120         	cbz	r0, 0x700aafc8 <CSL_bcdmaDoChanOp+0x38> @ imm = #0x8
700aafbe: e7ff         	b	0x700aafc0 <CSL_bcdmaDoChanOp+0x30> @ imm = #-0x2
700aafc0: 9807         	ldr	r0, [sp, #0x1c]
700aafc2: 6a80         	ldr	r0, [r0, #0x28]
700aafc4: b920         	cbnz	r0, 0x700aafd0 <CSL_bcdmaDoChanOp+0x40> @ imm = #0x8
700aafc6: e7ff         	b	0x700aafc8 <CSL_bcdmaDoChanOp+0x38> @ imm = #-0x2
;             CSL_bcdmaGetCfg( pCfg );
700aafc8: 9807         	ldr	r0, [sp, #0x1c]
700aafca: f7ff f981    	bl	0x700aa2d0 <CSL_bcdmaGetCfg> @ imm = #-0xcfe
;         }
700aafce: e7ff         	b	0x700aafd0 <CSL_bcdmaDoChanOp+0x40> @ imm = #-0x2
;         base0chanIdx = CSL_bcdmaMapChanIdx( pCfg, chanIdx, &chanType );
700aafd0: 9807         	ldr	r0, [sp, #0x1c]
700aafd2: 9905         	ldr	r1, [sp, #0x14]
700aafd4: aa01         	add	r2, sp, #0x4
700aafd6: f7ff fd9b    	bl	0x700aab10 <CSL_bcdmaMapChanIdx> @ imm = #-0x4ca
700aafda: 9002         	str	r0, [sp, #0x8]
;         if( base0chanIdx != CSL_BCDMA_INVALID_CHANNEL_INDEX )
700aafdc: 9802         	ldr	r0, [sp, #0x8]
700aafde: 3001         	adds	r0, #0x1
700aafe0: b168         	cbz	r0, 0x700aaffe <CSL_bcdmaDoChanOp+0x6e> @ imm = #0x1a
700aafe2: e7ff         	b	0x700aafe4 <CSL_bcdmaDoChanOp+0x54> @ imm = #-0x2
;             retVal = CSL_bcdmaChanOp( pCfg, chanOp, chanType, base0chanIdx, pOpData );
700aafe4: 9807         	ldr	r0, [sp, #0x1c]
700aafe6: 9906         	ldr	r1, [sp, #0x18]
700aafe8: 9a01         	ldr	r2, [sp, #0x4]
700aafea: 9b02         	ldr	r3, [sp, #0x8]
700aafec: f8dd c010    	ldr.w	r12, [sp, #0x10]
700aaff0: 46ee         	mov	lr, sp
700aaff2: f8ce c000    	str.w	r12, [lr]
700aaff6: f7f6 fc7b    	bl	0x700a18f0 <CSL_bcdmaChanOp> @ imm = #-0x970a
700aaffa: 9003         	str	r0, [sp, #0xc]
;         }
700aaffc: e7ff         	b	0x700aaffe <CSL_bcdmaDoChanOp+0x6e> @ imm = #-0x2
700aaffe: e7ff         	b	0x700ab000 <CSL_bcdmaDoChanOp+0x70> @ imm = #-0x2
;     return retVal;
700ab000: 9803         	ldr	r0, [sp, #0xc]
700ab002: b008         	add	sp, #0x20
700ab004: bd80         	pop	{r7, pc}
		...
700ab00e: 0000         	movs	r0, r0

700ab010 <Udma_chGetCqRingHandle>:
; {
700ab010: b085         	sub	sp, #0x14
700ab012: 9004         	str	r0, [sp, #0x10]
700ab014: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700ab016: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandle     cqRing = (Udma_RingHandle) NULL_PTR;
700ab018: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700ab01a: 9804         	ldr	r0, [sp, #0x10]
700ab01c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700ab01e: 9800         	ldr	r0, [sp]
700ab020: b150         	cbz	r0, 0x700ab038 <Udma_chGetCqRingHandle+0x28> @ imm = #0x14
700ab022: e7ff         	b	0x700ab024 <Udma_chGetCqRingHandle+0x14> @ imm = #-0x2
700ab024: 9800         	ldr	r0, [sp]
700ab026: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700ab02a: f64a 31cd    	movw	r1, #0xabcd
700ab02e: f6ca 31dc    	movt	r1, #0xabdc
700ab032: 4288         	cmp	r0, r1
700ab034: d004         	beq	0x700ab040 <Udma_chGetCqRingHandle+0x30> @ imm = #0x8
700ab036: e7ff         	b	0x700ab038 <Udma_chGetCqRingHandle+0x28> @ imm = #-0x2
700ab038: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700ab03c: 9003         	str	r0, [sp, #0xc]
;     }
700ab03e: e7ff         	b	0x700ab040 <Udma_chGetCqRingHandle+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab040: 9803         	ldr	r0, [sp, #0xc]
700ab042: b9a8         	cbnz	r0, 0x700ab070 <Udma_chGetCqRingHandle+0x60> @ imm = #0x2a
700ab044: e7ff         	b	0x700ab046 <Udma_chGetCqRingHandle+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700ab046: 9800         	ldr	r0, [sp]
700ab048: 6e80         	ldr	r0, [r0, #0x68]
700ab04a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700ab04c: 9801         	ldr	r0, [sp, #0x4]
700ab04e: b150         	cbz	r0, 0x700ab066 <Udma_chGetCqRingHandle+0x56> @ imm = #0x14
700ab050: e7ff         	b	0x700ab052 <Udma_chGetCqRingHandle+0x42> @ imm = #-0x2
700ab052: 9801         	ldr	r0, [sp, #0x4]
700ab054: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700ab058: f64a 31cd    	movw	r1, #0xabcd
700ab05c: f6ca 31dc    	movt	r1, #0xabdc
700ab060: 4288         	cmp	r0, r1
700ab062: d004         	beq	0x700ab06e <Udma_chGetCqRingHandle+0x5e> @ imm = #0x8
700ab064: e7ff         	b	0x700ab066 <Udma_chGetCqRingHandle+0x56> @ imm = #-0x2
700ab066: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700ab06a: 9003         	str	r0, [sp, #0xc]
;         }
700ab06c: e7ff         	b	0x700ab06e <Udma_chGetCqRingHandle+0x5e> @ imm = #-0x2
;     }
700ab06e: e7ff         	b	0x700ab070 <Udma_chGetCqRingHandle+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab070: 9803         	ldr	r0, [sp, #0xc]
700ab072: b928         	cbnz	r0, 0x700ab080 <Udma_chGetCqRingHandle+0x70> @ imm = #0xa
700ab074: e7ff         	b	0x700ab076 <Udma_chGetCqRingHandle+0x66> @ imm = #-0x2
;         cqRing = (Udma_RingHandle) chHandleInt->cqRing;
700ab076: 9800         	ldr	r0, [sp]
700ab078: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700ab07c: 9002         	str	r0, [sp, #0x8]
;     }
700ab07e: e7ff         	b	0x700ab080 <Udma_chGetCqRingHandle+0x70> @ imm = #-0x2
;     return (cqRing);
700ab080: 9802         	ldr	r0, [sp, #0x8]
700ab082: b005         	add	sp, #0x14
700ab084: 4770         	bx	lr
		...
700ab08e: 0000         	movs	r0, r0

700ab090 <Udma_chGetFqRingHandle>:
; {
700ab090: b085         	sub	sp, #0x14
700ab092: 9004         	str	r0, [sp, #0x10]
700ab094: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700ab096: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandle     fqRing = (Udma_RingHandle) NULL_PTR;
700ab098: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700ab09a: 9804         	ldr	r0, [sp, #0x10]
700ab09c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700ab09e: 9800         	ldr	r0, [sp]
700ab0a0: b150         	cbz	r0, 0x700ab0b8 <Udma_chGetFqRingHandle+0x28> @ imm = #0x14
700ab0a2: e7ff         	b	0x700ab0a4 <Udma_chGetFqRingHandle+0x14> @ imm = #-0x2
700ab0a4: 9800         	ldr	r0, [sp]
700ab0a6: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700ab0aa: f64a 31cd    	movw	r1, #0xabcd
700ab0ae: f6ca 31dc    	movt	r1, #0xabdc
700ab0b2: 4288         	cmp	r0, r1
700ab0b4: d004         	beq	0x700ab0c0 <Udma_chGetFqRingHandle+0x30> @ imm = #0x8
700ab0b6: e7ff         	b	0x700ab0b8 <Udma_chGetFqRingHandle+0x28> @ imm = #-0x2
700ab0b8: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700ab0bc: 9003         	str	r0, [sp, #0xc]
;     }
700ab0be: e7ff         	b	0x700ab0c0 <Udma_chGetFqRingHandle+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab0c0: 9803         	ldr	r0, [sp, #0xc]
700ab0c2: b9a8         	cbnz	r0, 0x700ab0f0 <Udma_chGetFqRingHandle+0x60> @ imm = #0x2a
700ab0c4: e7ff         	b	0x700ab0c6 <Udma_chGetFqRingHandle+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700ab0c6: 9800         	ldr	r0, [sp]
700ab0c8: 6e80         	ldr	r0, [r0, #0x68]
700ab0ca: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700ab0cc: 9801         	ldr	r0, [sp, #0x4]
700ab0ce: b150         	cbz	r0, 0x700ab0e6 <Udma_chGetFqRingHandle+0x56> @ imm = #0x14
700ab0d0: e7ff         	b	0x700ab0d2 <Udma_chGetFqRingHandle+0x42> @ imm = #-0x2
700ab0d2: 9801         	ldr	r0, [sp, #0x4]
700ab0d4: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700ab0d8: f64a 31cd    	movw	r1, #0xabcd
700ab0dc: f6ca 31dc    	movt	r1, #0xabdc
700ab0e0: 4288         	cmp	r0, r1
700ab0e2: d004         	beq	0x700ab0ee <Udma_chGetFqRingHandle+0x5e> @ imm = #0x8
700ab0e4: e7ff         	b	0x700ab0e6 <Udma_chGetFqRingHandle+0x56> @ imm = #-0x2
700ab0e6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700ab0ea: 9003         	str	r0, [sp, #0xc]
;         }
700ab0ec: e7ff         	b	0x700ab0ee <Udma_chGetFqRingHandle+0x5e> @ imm = #-0x2
;     }
700ab0ee: e7ff         	b	0x700ab0f0 <Udma_chGetFqRingHandle+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab0f0: 9803         	ldr	r0, [sp, #0xc]
700ab0f2: b928         	cbnz	r0, 0x700ab100 <Udma_chGetFqRingHandle+0x70> @ imm = #0xa
700ab0f4: e7ff         	b	0x700ab0f6 <Udma_chGetFqRingHandle+0x66> @ imm = #-0x2
;         fqRing = (Udma_RingHandle) chHandleInt->fqRing;
700ab0f6: 9800         	ldr	r0, [sp]
700ab0f8: f8d0 0080    	ldr.w	r0, [r0, #0x80]
700ab0fc: 9002         	str	r0, [sp, #0x8]
;     }
700ab0fe: e7ff         	b	0x700ab100 <Udma_chGetFqRingHandle+0x70> @ imm = #-0x2
;     return (fqRing);
700ab100: 9802         	ldr	r0, [sp, #0x8]
700ab102: b005         	add	sp, #0x14
700ab104: 4770         	bx	lr
		...
700ab10e: 0000         	movs	r0, r0

700ab110 <prvGetExpectedIdleTime>:
; static TickType_t prvGetExpectedIdleTime(void) {
700ab110: b082         	sub	sp, #0x8
700ab112: 2000         	movs	r0, #0x0
;   UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
700ab114: 9000         	str	r0, [sp]
;     if (uxTopReadyPriority > tskIDLE_PRIORITY) {
700ab116: f642 203c    	movw	r0, #0x2a3c
700ab11a: f2c7 000b    	movt	r0, #0x700b
700ab11e: 6800         	ldr	r0, [r0]
700ab120: b118         	cbz	r0, 0x700ab12a <prvGetExpectedIdleTime+0x1a> @ imm = #0x6
700ab122: e7ff         	b	0x700ab124 <prvGetExpectedIdleTime+0x14> @ imm = #-0x2
700ab124: 2001         	movs	r0, #0x1
;       uxHigherPriorityReadyTasks = pdTRUE;
700ab126: 9000         	str	r0, [sp]
;     }
700ab128: e7ff         	b	0x700ab12a <prvGetExpectedIdleTime+0x1a> @ imm = #-0x2
;   if (pxCurrentTCB->uxPriority > tskIDLE_PRIORITY) {
700ab12a: f642 200c    	movw	r0, #0x2a0c
700ab12e: f2c7 000b    	movt	r0, #0x700b
700ab132: 6800         	ldr	r0, [r0]
700ab134: 6ac0         	ldr	r0, [r0, #0x2c]
700ab136: b118         	cbz	r0, 0x700ab140 <prvGetExpectedIdleTime+0x30> @ imm = #0x6
700ab138: e7ff         	b	0x700ab13a <prvGetExpectedIdleTime+0x2a> @ imm = #-0x2
700ab13a: 2000         	movs	r0, #0x0
;     xReturn = 0;
700ab13c: 9001         	str	r0, [sp, #0x4]
;   } else if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) >
700ab13e: e01f         	b	0x700ab180 <prvGetExpectedIdleTime+0x70> @ imm = #0x3e
700ab140: f244 40f8    	movw	r0, #0x44f8
700ab144: f2c7 0008    	movt	r0, #0x7008
700ab148: 6800         	ldr	r0, [r0]
700ab14a: 2802         	cmp	r0, #0x2
700ab14c: d303         	blo	0x700ab156 <prvGetExpectedIdleTime+0x46> @ imm = #0x6
700ab14e: e7ff         	b	0x700ab150 <prvGetExpectedIdleTime+0x40> @ imm = #-0x2
700ab150: 2000         	movs	r0, #0x0
;     xReturn = 0;
700ab152: 9001         	str	r0, [sp, #0x4]
;   } else if (uxHigherPriorityReadyTasks != pdFALSE) {
700ab154: e013         	b	0x700ab17e <prvGetExpectedIdleTime+0x6e> @ imm = #0x26
700ab156: 9800         	ldr	r0, [sp]
700ab158: b118         	cbz	r0, 0x700ab162 <prvGetExpectedIdleTime+0x52> @ imm = #0x6
700ab15a: e7ff         	b	0x700ab15c <prvGetExpectedIdleTime+0x4c> @ imm = #-0x2
700ab15c: 2000         	movs	r0, #0x0
;     xReturn = 0;
700ab15e: 9001         	str	r0, [sp, #0x4]
;   } else {
700ab160: e00c         	b	0x700ab17c <prvGetExpectedIdleTime+0x6c> @ imm = #0x18
;     xReturn = xNextTaskUnblockTime - xTickCount;
700ab162: f642 2044    	movw	r0, #0x2a44
700ab166: f2c7 000b    	movt	r0, #0x700b
700ab16a: 6800         	ldr	r0, [r0]
700ab16c: f642 2154    	movw	r1, #0x2a54
700ab170: f2c7 010b    	movt	r1, #0x700b
700ab174: 6809         	ldr	r1, [r1]
700ab176: 1a40         	subs	r0, r0, r1
700ab178: 9001         	str	r0, [sp, #0x4]
700ab17a: e7ff         	b	0x700ab17c <prvGetExpectedIdleTime+0x6c> @ imm = #-0x2
700ab17c: e7ff         	b	0x700ab17e <prvGetExpectedIdleTime+0x6e> @ imm = #-0x2
700ab17e: e7ff         	b	0x700ab180 <prvGetExpectedIdleTime+0x70> @ imm = #-0x2
;   return xReturn;
700ab180: 9801         	ldr	r0, [sp, #0x4]
700ab182: b002         	add	sp, #0x8
700ab184: 4770         	bx	lr
		...
700ab18e: 0000         	movs	r0, r0

700ab190 <ClockP_usleep>:
; {
700ab190: b580         	push	{r7, lr}
700ab192: b088         	sub	sp, #0x20
700ab194: 9007         	str	r0, [sp, #0x1c]
;     curTime = ClockP_getTimeUsec();
700ab196: f7ff fcfb    	bl	0x700aab90 <ClockP_getTimeUsec> @ imm = #-0x60a
700ab19a: 9105         	str	r1, [sp, #0x14]
700ab19c: 9004         	str	r0, [sp, #0x10]
;     endTime = curTime + usec;
700ab19e: 9904         	ldr	r1, [sp, #0x10]
700ab1a0: 9805         	ldr	r0, [sp, #0x14]
700ab1a2: 9a07         	ldr	r2, [sp, #0x1c]
700ab1a4: 1889         	adds	r1, r1, r2
700ab1a6: f140 0000    	adc	r0, r0, #0x0
700ab1aa: 9102         	str	r1, [sp, #0x8]
700ab1ac: 9003         	str	r0, [sp, #0xc]
;     if (usec >= gClockCtrl.usecPerTick) {
700ab1ae: 9807         	ldr	r0, [sp, #0x1c]
700ab1b0: f245 1190    	movw	r1, #0x5190
700ab1b4: f2c7 0108    	movt	r1, #0x7008
700ab1b8: 6889         	ldr	r1, [r1, #0x8]
700ab1ba: 4288         	cmp	r0, r1
700ab1bc: d30d         	blo	0x700ab1da <ClockP_usleep+0x4a> @ imm = #0x1a
700ab1be: e7ff         	b	0x700ab1c0 <ClockP_usleep+0x30> @ imm = #-0x2
;         ticksToSleep = usec / gClockCtrl.usecPerTick;
700ab1c0: 9807         	ldr	r0, [sp, #0x1c]
700ab1c2: f245 1190    	movw	r1, #0x5190
700ab1c6: f2c7 0108    	movt	r1, #0x7008
700ab1ca: 6889         	ldr	r1, [r1, #0x8]
700ab1cc: fbb0 f0f1    	udiv	r0, r0, r1
700ab1d0: 9001         	str	r0, [sp, #0x4]
;         ClockP_sleepTicks(ticksToSleep);
700ab1d2: 9801         	ldr	r0, [sp, #0x4]
700ab1d4: f004 fcc4    	bl	0x700afb60 <ClockP_sleepTicks> @ imm = #0x4988
;     }
700ab1d8: e012         	b	0x700ab200 <ClockP_usleep+0x70> @ imm = #0x24
;         curTime = ClockP_getTimeUsec();
700ab1da: f7ff fcd9    	bl	0x700aab90 <ClockP_getTimeUsec> @ imm = #-0x64e
700ab1de: 9105         	str	r1, [sp, #0x14]
700ab1e0: 9004         	str	r0, [sp, #0x10]
;         while (curTime < endTime) {
700ab1e2: e7ff         	b	0x700ab1e4 <ClockP_usleep+0x54> @ imm = #-0x2
700ab1e4: 9a04         	ldr	r2, [sp, #0x10]
700ab1e6: 9805         	ldr	r0, [sp, #0x14]
700ab1e8: 9b02         	ldr	r3, [sp, #0x8]
700ab1ea: 9903         	ldr	r1, [sp, #0xc]
700ab1ec: 1ad2         	subs	r2, r2, r3
700ab1ee: 4188         	sbcs	r0, r1
700ab1f0: d205         	bhs	0x700ab1fe <ClockP_usleep+0x6e> @ imm = #0xa
700ab1f2: e7ff         	b	0x700ab1f4 <ClockP_usleep+0x64> @ imm = #-0x2
;             curTime = ClockP_getTimeUsec();
700ab1f4: f7ff fccc    	bl	0x700aab90 <ClockP_getTimeUsec> @ imm = #-0x668
700ab1f8: 9105         	str	r1, [sp, #0x14]
700ab1fa: 9004         	str	r0, [sp, #0x10]
;         while (curTime < endTime) {
700ab1fc: e7f2         	b	0x700ab1e4 <ClockP_usleep+0x54> @ imm = #-0x1c
700ab1fe: e7ff         	b	0x700ab200 <ClockP_usleep+0x70> @ imm = #-0x2
; }
700ab200: b008         	add	sp, #0x20
700ab202: bd80         	pop	{r7, pc}
		...

700ab210 <Udma_chEnable>:
; {
700ab210: b580         	push	{r7, lr}
700ab212: b084         	sub	sp, #0x10
700ab214: 9003         	str	r0, [sp, #0xc]
700ab216: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700ab218: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700ab21a: 9803         	ldr	r0, [sp, #0xc]
700ab21c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700ab21e: 9800         	ldr	r0, [sp]
700ab220: b150         	cbz	r0, 0x700ab238 <Udma_chEnable+0x28> @ imm = #0x14
700ab222: e7ff         	b	0x700ab224 <Udma_chEnable+0x14> @ imm = #-0x2
700ab224: 9800         	ldr	r0, [sp]
700ab226: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700ab22a: f64a 31cd    	movw	r1, #0xabcd
700ab22e: f6ca 31dc    	movt	r1, #0xabdc
700ab232: 4288         	cmp	r0, r1
700ab234: d004         	beq	0x700ab240 <Udma_chEnable+0x30> @ imm = #0x8
700ab236: e7ff         	b	0x700ab238 <Udma_chEnable+0x28> @ imm = #-0x2
700ab238: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700ab23c: 9002         	str	r0, [sp, #0x8]
;     }
700ab23e: e7ff         	b	0x700ab240 <Udma_chEnable+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab240: 9802         	ldr	r0, [sp, #0x8]
700ab242: b9a8         	cbnz	r0, 0x700ab270 <Udma_chEnable+0x60> @ imm = #0x2a
700ab244: e7ff         	b	0x700ab246 <Udma_chEnable+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700ab246: 9800         	ldr	r0, [sp]
700ab248: 6e80         	ldr	r0, [r0, #0x68]
700ab24a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700ab24c: 9801         	ldr	r0, [sp, #0x4]
700ab24e: b150         	cbz	r0, 0x700ab266 <Udma_chEnable+0x56> @ imm = #0x14
700ab250: e7ff         	b	0x700ab252 <Udma_chEnable+0x42> @ imm = #-0x2
700ab252: 9801         	ldr	r0, [sp, #0x4]
700ab254: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700ab258: f64a 31cd    	movw	r1, #0xabcd
700ab25c: f6ca 31dc    	movt	r1, #0xabdc
700ab260: 4288         	cmp	r0, r1
700ab262: d004         	beq	0x700ab26e <Udma_chEnable+0x5e> @ imm = #0x8
700ab264: e7ff         	b	0x700ab266 <Udma_chEnable+0x56> @ imm = #-0x2
700ab266: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700ab26a: 9002         	str	r0, [sp, #0x8]
;         }
700ab26c: e7ff         	b	0x700ab26e <Udma_chEnable+0x5e> @ imm = #-0x2
;     }
700ab26e: e7ff         	b	0x700ab270 <Udma_chEnable+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab270: 9802         	ldr	r0, [sp, #0x8]
700ab272: b920         	cbnz	r0, 0x700ab27e <Udma_chEnable+0x6e> @ imm = #0x8
700ab274: e7ff         	b	0x700ab276 <Udma_chEnable+0x66> @ imm = #-0x2
;         Udma_chEnableLocal(chHandleInt);
700ab276: 9800         	ldr	r0, [sp]
700ab278: f7f5 ff7a    	bl	0x700a1170 <Udma_chEnableLocal> @ imm = #-0xa10c
;     }
700ab27c: e7ff         	b	0x700ab27e <Udma_chEnable+0x6e> @ imm = #-0x2
;     return (retVal);
700ab27e: 9802         	ldr	r0, [sp, #0x8]
700ab280: b004         	add	sp, #0x10
700ab282: bd80         	pop	{r7, pc}
		...

700ab290 <CSL_bcdmaChanOpTriggerChan>:
; {
700ab290: b580         	push	{r7, lr}
700ab292: b084         	sub	sp, #0x10
700ab294: 9003         	str	r0, [sp, #0xc]
700ab296: 9102         	str	r1, [sp, #0x8]
700ab298: 9201         	str	r2, [sp, #0x4]
700ab29a: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700ab29c: 9000         	str	r0, [sp]
;     if( chanType == CSL_BCDMA_CHAN_TYPE_BLOCK_COPY )
700ab29e: 9802         	ldr	r0, [sp, #0x8]
700ab2a0: b950         	cbnz	r0, 0x700ab2b8 <CSL_bcdmaChanOpTriggerChan+0x28> @ imm = #0x14
700ab2a2: e7ff         	b	0x700ab2a4 <CSL_bcdmaChanOpTriggerChan+0x14> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pBcChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_BCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700ab2a4: 9803         	ldr	r0, [sp, #0xc]
700ab2a6: 6880         	ldr	r0, [r0, #0x8]
700ab2a8: 9901         	ldr	r1, [sp, #0x4]
700ab2aa: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab2ae: 3008         	adds	r0, #0x8
700ab2b0: 2101         	movs	r1, #0x1
700ab2b2: f7f0 ffed    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xf026
;     }
700ab2b6: e021         	b	0x700ab2fc <CSL_bcdmaChanOpTriggerChan+0x6c> @ imm = #0x42
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_TX )
700ab2b8: 9802         	ldr	r0, [sp, #0x8]
700ab2ba: 2801         	cmp	r0, #0x1
700ab2bc: d10a         	bne	0x700ab2d4 <CSL_bcdmaChanOpTriggerChan+0x44> @ imm = #0x14
700ab2be: e7ff         	b	0x700ab2c0 <CSL_bcdmaChanOpTriggerChan+0x30> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_TXCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700ab2c0: 9803         	ldr	r0, [sp, #0xc]
700ab2c2: 6900         	ldr	r0, [r0, #0x10]
700ab2c4: 9901         	ldr	r1, [sp, #0x4]
700ab2c6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab2ca: 3008         	adds	r0, #0x8
700ab2cc: 2101         	movs	r1, #0x1
700ab2ce: f7f0 ffdf    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xf042
;     }
700ab2d2: e012         	b	0x700ab2fa <CSL_bcdmaChanOpTriggerChan+0x6a> @ imm = #0x24
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700ab2d4: 9802         	ldr	r0, [sp, #0x8]
700ab2d6: 2802         	cmp	r0, #0x2
700ab2d8: d10a         	bne	0x700ab2f0 <CSL_bcdmaChanOpTriggerChan+0x60> @ imm = #0x14
700ab2da: e7ff         	b	0x700ab2dc <CSL_bcdmaChanOpTriggerChan+0x4c> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_RXCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700ab2dc: 9803         	ldr	r0, [sp, #0xc]
700ab2de: 6980         	ldr	r0, [r0, #0x18]
700ab2e0: 9901         	ldr	r1, [sp, #0x4]
700ab2e2: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab2e6: 3008         	adds	r0, #0x8
700ab2e8: 2101         	movs	r1, #0x1
700ab2ea: f7f0 ffd1    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xf05e
;     }
700ab2ee: e003         	b	0x700ab2f8 <CSL_bcdmaChanOpTriggerChan+0x68> @ imm = #0x6
700ab2f0: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700ab2f4: 9000         	str	r0, [sp]
700ab2f6: e7ff         	b	0x700ab2f8 <CSL_bcdmaChanOpTriggerChan+0x68> @ imm = #-0x2
700ab2f8: e7ff         	b	0x700ab2fa <CSL_bcdmaChanOpTriggerChan+0x6a> @ imm = #-0x2
700ab2fa: e7ff         	b	0x700ab2fc <CSL_bcdmaChanOpTriggerChan+0x6c> @ imm = #-0x2
;     return retVal;
700ab2fc: 9800         	ldr	r0, [sp]
700ab2fe: b004         	add	sp, #0x10
700ab300: bd80         	pop	{r7, pc}
		...
700ab30e: 0000         	movs	r0, r0

700ab310 <prvProcessExpiredTimer>:
;     {
700ab310: b580         	push	{r7, lr}
700ab312: b086         	sub	sp, #0x18
700ab314: 9005         	str	r0, [sp, #0x14]
700ab316: 9104         	str	r1, [sp, #0x10]
;         Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
700ab318: f245 209c    	movw	r0, #0x529c
700ab31c: f2c7 0008    	movt	r0, #0x7008
700ab320: 6800         	ldr	r0, [r0]
700ab322: 68c0         	ldr	r0, [r0, #0xc]
700ab324: 68c0         	ldr	r0, [r0, #0xc]
700ab326: 9002         	str	r0, [sp, #0x8]
;         ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700ab328: 9802         	ldr	r0, [sp, #0x8]
700ab32a: 3004         	adds	r0, #0x4
700ab32c: f002 f9f8    	bl	0x700ad720 <uxListRemove> @ imm = #0x23f0
;         if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700ab330: 9802         	ldr	r0, [sp, #0x8]
700ab332: f890 0028    	ldrb.w	r0, [r0, #0x28]
700ab336: 0740         	lsls	r0, r0, #0x1d
700ab338: 2800         	cmp	r0, #0x0
700ab33a: d515         	bpl	0x700ab368 <prvProcessExpiredTimer+0x58> @ imm = #0x2a
700ab33c: e7ff         	b	0x700ab33e <prvProcessExpiredTimer+0x2e> @ imm = #-0x2
;             if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
700ab33e: 9802         	ldr	r0, [sp, #0x8]
700ab340: 9b05         	ldr	r3, [sp, #0x14]
700ab342: 6981         	ldr	r1, [r0, #0x18]
700ab344: 4419         	add	r1, r3
700ab346: 9a04         	ldr	r2, [sp, #0x10]
700ab348: f7ff f92a    	bl	0x700aa5a0 <prvInsertTimerInActiveList> @ imm = #-0xdac
700ab34c: b150         	cbz	r0, 0x700ab364 <prvProcessExpiredTimer+0x54> @ imm = #0x14
700ab34e: e7ff         	b	0x700ab350 <prvProcessExpiredTimer+0x40> @ imm = #-0x2
;                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
700ab350: 9802         	ldr	r0, [sp, #0x8]
700ab352: 9a05         	ldr	r2, [sp, #0x14]
700ab354: 4669         	mov	r1, sp
700ab356: 2300         	movs	r3, #0x0
700ab358: 600b         	str	r3, [r1]
700ab35a: 4619         	mov	r1, r3
700ab35c: f7fe fbf0    	bl	0x700a9b40 <xTimerGenericCommand> @ imm = #-0x1820
700ab360: 9003         	str	r0, [sp, #0xc]
;             }
700ab362: e000         	b	0x700ab366 <prvProcessExpiredTimer+0x56> @ imm = #0x0
700ab364: e7ff         	b	0x700ab366 <prvProcessExpiredTimer+0x56> @ imm = #-0x2
;         }
700ab366: e007         	b	0x700ab378 <prvProcessExpiredTimer+0x68> @ imm = #0xe
;             pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700ab368: 9902         	ldr	r1, [sp, #0x8]
700ab36a: f891 0028    	ldrb.w	r0, [r1, #0x28]
700ab36e: f000 00fe    	and	r0, r0, #0xfe
700ab372: f881 0028    	strb.w	r0, [r1, #0x28]
700ab376: e7ff         	b	0x700ab378 <prvProcessExpiredTimer+0x68> @ imm = #-0x2
;         pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700ab378: 9802         	ldr	r0, [sp, #0x8]
700ab37a: 6a01         	ldr	r1, [r0, #0x20]
700ab37c: 4788         	blx	r1
;     }
700ab37e: b006         	add	sp, #0x18
700ab380: bd80         	pop	{r7, pc}
		...
700ab38e: 0000         	movs	r0, r0

700ab390 <xTaskCreateStatic>:
;     StaticTask_t *const pxTaskBuffer) {
700ab390: b5b0         	push	{r4, r5, r7, lr}
700ab392: b08a         	sub	sp, #0x28
700ab394: f8dd c040    	ldr.w	r12, [sp, #0x40]
700ab398: f8dd c03c    	ldr.w	r12, [sp, #0x3c]
700ab39c: f8dd c038    	ldr.w	r12, [sp, #0x38]
700ab3a0: 9009         	str	r0, [sp, #0x24]
700ab3a2: 9108         	str	r1, [sp, #0x20]
700ab3a4: 9207         	str	r2, [sp, #0x1c]
700ab3a6: 9306         	str	r3, [sp, #0x18]
;   if ((pxTaskBuffer != NULL) && (puxStackBuffer != NULL)) {
700ab3a8: 9810         	ldr	r0, [sp, #0x40]
700ab3aa: b320         	cbz	r0, 0x700ab3f6 <xTaskCreateStatic+0x66> @ imm = #0x48
700ab3ac: e7ff         	b	0x700ab3ae <xTaskCreateStatic+0x1e> @ imm = #-0x2
700ab3ae: 980f         	ldr	r0, [sp, #0x3c]
700ab3b0: b308         	cbz	r0, 0x700ab3f6 <xTaskCreateStatic+0x66> @ imm = #0x42
700ab3b2: e7ff         	b	0x700ab3b4 <xTaskCreateStatic+0x24> @ imm = #-0x2
;         pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures
700ab3b4: 9810         	ldr	r0, [sp, #0x40]
;     pxNewTCB = (TCB_t *)
700ab3b6: 9005         	str	r0, [sp, #0x14]
;     pxNewTCB->pxStack = (StackType_t *)puxStackBuffer;
700ab3b8: 980f         	ldr	r0, [sp, #0x3c]
700ab3ba: 9905         	ldr	r1, [sp, #0x14]
700ab3bc: 6308         	str	r0, [r1, #0x30]
;       pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
700ab3be: 9905         	ldr	r1, [sp, #0x14]
700ab3c0: 2002         	movs	r0, #0x2
700ab3c2: f881 0081    	strb.w	r0, [r1, #0x81]
;     prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters,
700ab3c6: 9809         	ldr	r0, [sp, #0x24]
700ab3c8: 9908         	ldr	r1, [sp, #0x20]
700ab3ca: 9a07         	ldr	r2, [sp, #0x1c]
700ab3cc: 9b06         	ldr	r3, [sp, #0x18]
;                          uxPriority, &xReturn, pxNewTCB, NULL);
700ab3ce: f8dd c038    	ldr.w	r12, [sp, #0x38]
700ab3d2: 9c05         	ldr	r4, [sp, #0x14]
;     prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters,
700ab3d4: 46ee         	mov	lr, sp
700ab3d6: 2500         	movs	r5, #0x0
700ab3d8: f8ce 500c    	str.w	r5, [lr, #0xc]
700ab3dc: f8ce 4008    	str.w	r4, [lr, #0x8]
700ab3e0: ac04         	add	r4, sp, #0x10
700ab3e2: f8ce 4004    	str.w	r4, [lr, #0x4]
700ab3e6: f8ce c000    	str.w	r12, [lr]
700ab3ea: f7f9 fce1    	bl	0x700a4db0 <prvInitialiseNewTask> @ imm = #-0x663e
;     prvAddNewTaskToReadyList(pxNewTCB);
700ab3ee: 9805         	ldr	r0, [sp, #0x14]
700ab3f0: f7f9 fe7e    	bl	0x700a50f0 <prvAddNewTaskToReadyList> @ imm = #-0x6304
;   } else {
700ab3f4: e002         	b	0x700ab3fc <xTaskCreateStatic+0x6c> @ imm = #0x4
700ab3f6: 2000         	movs	r0, #0x0
;     xReturn = NULL;
700ab3f8: 9004         	str	r0, [sp, #0x10]
700ab3fa: e7ff         	b	0x700ab3fc <xTaskCreateStatic+0x6c> @ imm = #-0x2
;   return xReturn;
700ab3fc: 9804         	ldr	r0, [sp, #0x10]
700ab3fe: b00a         	add	sp, #0x28
700ab400: bdb0         	pop	{r4, r5, r7, pc}
		...
700ab40e: 0000         	movs	r0, r0

700ab410 <CSL_intaggrClrIntr>:
; {
700ab410: b580         	push	{r7, lr}
700ab412: b088         	sub	sp, #0x20
700ab414: 9007         	str	r0, [sp, #0x1c]
700ab416: 9106         	str	r1, [sp, #0x18]
700ab418: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t  retVal = CSL_EFAIL;
700ab41c: 9005         	str	r0, [sp, #0x14]
;     if( CSL_intaggrIsValidStatusBitNum(pCfg, statusBitNum) )
700ab41e: 9807         	ldr	r0, [sp, #0x1c]
700ab420: 9906         	ldr	r1, [sp, #0x18]
700ab422: f002 fd95    	bl	0x700adf50 <CSL_intaggrIsValidStatusBitNum> @ imm = #0x2b2a
700ab426: b340         	cbz	r0, 0x700ab47a <CSL_intaggrClrIntr+0x6a> @ imm = #0x50
700ab428: e7ff         	b	0x700ab42a <CSL_intaggrClrIntr+0x1a> @ imm = #-0x2
;         regNum = statusBitNum >> 6U;
700ab42a: 9806         	ldr	r0, [sp, #0x18]
700ab42c: 0980         	lsrs	r0, r0, #0x6
700ab42e: 9001         	str	r0, [sp, #0x4]
;         bitNum = statusBitNum & (uint32_t)0x003FU;
700ab430: 9806         	ldr	r0, [sp, #0x18]
700ab432: f000 003f    	and	r0, r0, #0x3f
700ab436: 9000         	str	r0, [sp]
;         regVal = (((uint64_t)1U) << bitNum);
700ab438: 9b00         	ldr	r3, [sp]
700ab43a: f1a3 0220    	sub.w	r2, r3, #0x20
700ab43e: 2101         	movs	r1, #0x1
700ab440: fa01 fc02    	lsl.w	r12, r1, r2
700ab444: f1c3 0020    	rsb.w	r0, r3, #0x20
700ab448: fa21 f000    	lsr.w	r0, r1, r0
700ab44c: 2a00         	cmp	r2, #0x0
700ab44e: bf58         	it	pl
700ab450: 4660         	movpl	r0, r12
700ab452: fa01 f103    	lsl.w	r1, r1, r3
700ab456: 2a00         	cmp	r2, #0x0
700ab458: bf58         	it	pl
700ab45a: 2100         	movpl	r1, #0x0
700ab45c: 9102         	str	r1, [sp, #0x8]
700ab45e: 9003         	str	r0, [sp, #0xc]
;         CSL_REG64_WR( &pCfg->pIntrRegs->VINT[regNum].STATUS_CLEAR, regVal );
700ab460: 9807         	ldr	r0, [sp, #0x1c]
700ab462: 6880         	ldr	r0, [r0, #0x8]
700ab464: 9901         	ldr	r1, [sp, #0x4]
700ab466: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab46a: 3018         	adds	r0, #0x18
700ab46c: 9a02         	ldr	r2, [sp, #0x8]
700ab46e: 9b03         	ldr	r3, [sp, #0xc]
700ab470: f004 f996    	bl	0x700af7a0 <CSL_REG64_WR_RAW> @ imm = #0x432c
700ab474: 2000         	movs	r0, #0x0
;         retVal = CSL_PASS;
700ab476: 9005         	str	r0, [sp, #0x14]
;     }
700ab478: e7ff         	b	0x700ab47a <CSL_intaggrClrIntr+0x6a> @ imm = #-0x2
;     return retVal;
700ab47a: 9805         	ldr	r0, [sp, #0x14]
700ab47c: b008         	add	sp, #0x20
700ab47e: bd80         	pop	{r7, pc}

700ab480 <Sciclient_rmGetResourceRange>:
; {
700ab480: b580         	push	{r7, lr}
700ab482: b090         	sub	sp, #0x40
700ab484: 900f         	str	r0, [sp, #0x3c]
700ab486: 910e         	str	r1, [sp, #0x38]
700ab488: 920d         	str	r2, [sp, #0x34]
700ab48a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab48c: 900c         	str	r0, [sp, #0x30]
700ab48e: f44f 51a8    	mov.w	r1, #0x1500
;     sciReq.messageType    = TISCI_MSG_RM_GET_RESOURCE_RANGE;
700ab492: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700ab496: 2102         	movs	r1, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ab498: 9108         	str	r1, [sp, #0x20]
700ab49a: a904         	add	r1, sp, #0x10
;     sciReq.pReqPayload    = (const uint8_t *) &req_copy;
700ab49c: 9109         	str	r1, [sp, #0x24]
700ab49e: 210c         	movs	r1, #0xc
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ab4a0: 910a         	str	r1, [sp, #0x28]
;     sciReq.timeout        = timeout;
700ab4a2: 990d         	ldr	r1, [sp, #0x34]
700ab4a4: 910b         	str	r1, [sp, #0x2c]
;     sciResp.flags           = 0;
700ab4a6: 9001         	str	r0, [sp, #0x4]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ab4a8: 980e         	ldr	r0, [sp, #0x38]
700ab4aa: 9002         	str	r0, [sp, #0x8]
700ab4ac: 2010         	movs	r0, #0x10
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ab4ae: 9003         	str	r0, [sp, #0xc]
;     memcpy(&req_copy, req, sizeof(struct tisci_msg_rm_get_resource_range_req));
700ab4b0: 9a0f         	ldr	r2, [sp, #0x3c]
700ab4b2: 6810         	ldr	r0, [r2]
700ab4b4: 6851         	ldr	r1, [r2, #0x4]
700ab4b6: 6892         	ldr	r2, [r2, #0x8]
700ab4b8: 9206         	str	r2, [sp, #0x18]
700ab4ba: 9105         	str	r1, [sp, #0x14]
700ab4bc: 9004         	str	r0, [sp, #0x10]
;     if (SystemP_SUCCESS == r)
700ab4be: 980c         	ldr	r0, [sp, #0x30]
700ab4c0: b930         	cbnz	r0, 0x700ab4d0 <Sciclient_rmGetResourceRange+0x50> @ imm = #0xc
700ab4c2: e7ff         	b	0x700ab4c4 <Sciclient_rmGetResourceRange+0x44> @ imm = #-0x2
700ab4c4: a807         	add	r0, sp, #0x1c
700ab4c6: a901         	add	r1, sp, #0x4
;         r = Sciclient_service(&sciReq, &sciResp);
700ab4c8: f7f2 f892    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xdedc
700ab4cc: 900c         	str	r0, [sp, #0x30]
;     }
700ab4ce: e7ff         	b	0x700ab4d0 <Sciclient_rmGetResourceRange+0x50> @ imm = #-0x2
;     if ((r != SystemP_SUCCESS) ||
700ab4d0: 980c         	ldr	r0, [sp, #0x30]
700ab4d2: b930         	cbnz	r0, 0x700ab4e2 <Sciclient_rmGetResourceRange+0x62> @ imm = #0xc
700ab4d4: e7ff         	b	0x700ab4d6 <Sciclient_rmGetResourceRange+0x56> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ab4d6: 9801         	ldr	r0, [sp, #0x4]
700ab4d8: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ab4dc: 2802         	cmp	r0, #0x2
700ab4de: d004         	beq	0x700ab4ea <Sciclient_rmGetResourceRange+0x6a> @ imm = #0x8
700ab4e0: e7ff         	b	0x700ab4e2 <Sciclient_rmGetResourceRange+0x62> @ imm = #-0x2
700ab4e2: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ab4e6: 900c         	str	r0, [sp, #0x30]
;     }
700ab4e8: e7ff         	b	0x700ab4ea <Sciclient_rmGetResourceRange+0x6a> @ imm = #-0x2
;     return r;
700ab4ea: 980c         	ldr	r0, [sp, #0x30]
700ab4ec: b010         	add	sp, #0x40
700ab4ee: bd80         	pop	{r7, pc}

700ab4f0 <Udma_rmFreeMappedRxCh>:
; {
700ab4f0: b580         	push	{r7, lr}
700ab4f2: b088         	sub	sp, #0x20
700ab4f4: 9007         	str	r0, [sp, #0x1c]
700ab4f6: 9106         	str	r1, [sp, #0x18]
700ab4f8: 9205         	str	r2, [sp, #0x14]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ab4fa: 9806         	ldr	r0, [sp, #0x18]
700ab4fc: f500 70ea    	add.w	r0, r0, #0x1d4
700ab500: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ab502: 9806         	ldr	r0, [sp, #0x18]
700ab504: f500 609f    	add.w	r0, r0, #0x4f8
700ab508: f04f 31ff    	mov.w	r1, #0xffffffff
700ab50c: f7ff f968    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #-0xd30
;     i = chNum - rmInitPrms->startMappedRxCh[mappedChGrp];
700ab510: 9807         	ldr	r0, [sp, #0x1c]
700ab512: 9900         	ldr	r1, [sp]
700ab514: 9a05         	ldr	r2, [sp, #0x14]
700ab516: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ab51a: 6e89         	ldr	r1, [r1, #0x68]
700ab51c: 1a40         	subs	r0, r0, r1
700ab51e: 9004         	str	r0, [sp, #0x10]
;     offset = i >> 5U;
700ab520: 9804         	ldr	r0, [sp, #0x10]
700ab522: 0940         	lsrs	r0, r0, #0x5
700ab524: 9003         	str	r0, [sp, #0xc]
;     bitPos = i - (offset << 5U);
700ab526: 9804         	ldr	r0, [sp, #0x10]
700ab528: 9903         	ldr	r1, [sp, #0xc]
700ab52a: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ab52e: 9002         	str	r0, [sp, #0x8]
;     bitMask = (uint32_t) 1U << bitPos;
700ab530: 9902         	ldr	r1, [sp, #0x8]
700ab532: 2001         	movs	r0, #0x1
700ab534: 4088         	lsls	r0, r1
700ab536: 9001         	str	r0, [sp, #0x4]
;     drvHandle->mappedRxChFlag[mappedChGrp][offset] |= bitMask;
700ab538: 9a01         	ldr	r2, [sp, #0x4]
700ab53a: 9806         	ldr	r0, [sp, #0x18]
700ab53c: 9905         	ldr	r1, [sp, #0x14]
700ab53e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ab542: 9903         	ldr	r1, [sp, #0xc]
700ab544: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ab548: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700ab54c: 4310         	orrs	r0, r2
700ab54e: f8c1 0334    	str.w	r0, [r1, #0x334]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ab552: 9806         	ldr	r0, [sp, #0x18]
700ab554: f500 609f    	add.w	r0, r0, #0x4f8
700ab558: f000 fcd2    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x9a4
;     return;
700ab55c: b008         	add	sp, #0x20
700ab55e: bd80         	pop	{r7, pc}

700ab560 <Udma_rmFreeMappedTxCh>:
; {
700ab560: b580         	push	{r7, lr}
700ab562: b088         	sub	sp, #0x20
700ab564: 9007         	str	r0, [sp, #0x1c]
700ab566: 9106         	str	r1, [sp, #0x18]
700ab568: 9205         	str	r2, [sp, #0x14]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ab56a: 9806         	ldr	r0, [sp, #0x18]
700ab56c: f500 70ea    	add.w	r0, r0, #0x1d4
700ab570: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ab572: 9806         	ldr	r0, [sp, #0x18]
700ab574: f500 609f    	add.w	r0, r0, #0x4f8
700ab578: f04f 31ff    	mov.w	r1, #0xffffffff
700ab57c: f7ff f930    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #-0xda0
;     i = chNum - rmInitPrms->startMappedTxCh[mappedChGrp];
700ab580: 9807         	ldr	r0, [sp, #0x1c]
700ab582: 9900         	ldr	r1, [sp]
700ab584: 9a05         	ldr	r2, [sp, #0x14]
700ab586: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ab58a: 6c89         	ldr	r1, [r1, #0x48]
700ab58c: 1a40         	subs	r0, r0, r1
700ab58e: 9004         	str	r0, [sp, #0x10]
;     offset = i >> 5U;
700ab590: 9804         	ldr	r0, [sp, #0x10]
700ab592: 0940         	lsrs	r0, r0, #0x5
700ab594: 9003         	str	r0, [sp, #0xc]
;     bitPos = i - (offset << 5U);
700ab596: 9804         	ldr	r0, [sp, #0x10]
700ab598: 9903         	ldr	r1, [sp, #0xc]
700ab59a: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ab59e: 9002         	str	r0, [sp, #0x8]
;     bitMask = (uint32_t) 1U << bitPos;
700ab5a0: 9902         	ldr	r1, [sp, #0x8]
700ab5a2: 2001         	movs	r0, #0x1
700ab5a4: 4088         	lsls	r0, r1
700ab5a6: 9001         	str	r0, [sp, #0x4]
;     drvHandle->mappedTxChFlag[mappedChGrp][offset] |= bitMask;
700ab5a8: 9a01         	ldr	r2, [sp, #0x4]
700ab5aa: 9806         	ldr	r0, [sp, #0x18]
700ab5ac: 9905         	ldr	r1, [sp, #0x14]
700ab5ae: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ab5b2: 9903         	ldr	r1, [sp, #0xc]
700ab5b4: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ab5b8: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700ab5bc: 4310         	orrs	r0, r2
700ab5be: f8c1 0324    	str.w	r0, [r1, #0x324]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ab5c2: 9806         	ldr	r0, [sp, #0x18]
700ab5c4: f500 609f    	add.w	r0, r0, #0x4f8
700ab5c8: f000 fc9a    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x934
;     return;
700ab5cc: b008         	add	sp, #0x20
700ab5ce: bd80         	pop	{r7, pc}

700ab5d0 <Sciclient_rmIaVintGetInfo>:
; {
700ab5d0: b580         	push	{r7, lr}
700ab5d2: b084         	sub	sp, #0x10
700ab5d4: f8ad 000e    	strh.w	r0, [sp, #0xe]
700ab5d8: f8ad 100c    	strh.w	r1, [sp, #0xc]
700ab5dc: 9202         	str	r2, [sp, #0x8]
700ab5de: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab5e0: 9001         	str	r0, [sp, #0x4]
;     if (n_evts == NULL) {
700ab5e2: 9802         	ldr	r0, [sp, #0x8]
700ab5e4: b920         	cbnz	r0, 0x700ab5f0 <Sciclient_rmIaVintGetInfo+0x20> @ imm = #0x8
700ab5e6: e7ff         	b	0x700ab5e8 <Sciclient_rmIaVintGetInfo+0x18> @ imm = #-0x2
700ab5e8: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ab5ec: 9001         	str	r0, [sp, #0x4]
;     } else {
700ab5ee: e018         	b	0x700ab622 <Sciclient_rmIaVintGetInfo+0x52> @ imm = #0x30
;         inst = Sciclient_rmIaGetInst(id);
700ab5f0: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700ab5f4: f000 ffac    	bl	0x700ac550 <Sciclient_rmIaGetInst> @ imm = #0xf58
700ab5f8: 9000         	str	r0, [sp]
;         if (inst == NULL) {
700ab5fa: 9800         	ldr	r0, [sp]
700ab5fc: b920         	cbnz	r0, 0x700ab608 <Sciclient_rmIaVintGetInfo+0x38> @ imm = #0x8
700ab5fe: e7ff         	b	0x700ab600 <Sciclient_rmIaVintGetInfo+0x30> @ imm = #-0x2
700ab600: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700ab604: 9001         	str	r0, [sp, #0x4]
;         } else {
700ab606: e00b         	b	0x700ab620 <Sciclient_rmIaVintGetInfo+0x50> @ imm = #0x16
;             if (vint >= inst->n_vint) {
700ab608: f8bd 000c    	ldrh.w	r0, [sp, #0xc]
700ab60c: 9900         	ldr	r1, [sp]
700ab60e: 8989         	ldrh	r1, [r1, #0xc]
700ab610: 4288         	cmp	r0, r1
700ab612: db04         	blt	0x700ab61e <Sciclient_rmIaVintGetInfo+0x4e> @ imm = #0x8
700ab614: e7ff         	b	0x700ab616 <Sciclient_rmIaVintGetInfo+0x46> @ imm = #-0x2
700ab616: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700ab61a: 9001         	str	r0, [sp, #0x4]
;             }
700ab61c: e7ff         	b	0x700ab61e <Sciclient_rmIaVintGetInfo+0x4e> @ imm = #-0x2
700ab61e: e7ff         	b	0x700ab620 <Sciclient_rmIaVintGetInfo+0x50> @ imm = #-0x2
700ab620: e7ff         	b	0x700ab622 <Sciclient_rmIaVintGetInfo+0x52> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ab622: 9801         	ldr	r0, [sp, #0x4]
700ab624: b940         	cbnz	r0, 0x700ab638 <Sciclient_rmIaVintGetInfo+0x68> @ imm = #0x10
700ab626: e7ff         	b	0x700ab628 <Sciclient_rmIaVintGetInfo+0x58> @ imm = #-0x2
;         *n_evts = inst->vint_usage_count[vint];
700ab628: 9800         	ldr	r0, [sp]
700ab62a: 6900         	ldr	r0, [r0, #0x10]
700ab62c: f8bd 100c    	ldrh.w	r1, [sp, #0xc]
700ab630: 5c40         	ldrb	r0, [r0, r1]
700ab632: 9902         	ldr	r1, [sp, #0x8]
700ab634: 7008         	strb	r0, [r1]
;     }
700ab636: e7ff         	b	0x700ab638 <Sciclient_rmIaVintGetInfo+0x68> @ imm = #-0x2
;     return r;
700ab638: 9801         	ldr	r0, [sp, #0x4]
700ab63a: b004         	add	sp, #0x10
700ab63c: bd80         	pop	{r7, pc}
700ab63e: 0000         	movs	r0, r0

700ab640 <SemaphoreP_constructMutex>:
; {
700ab640: b580         	push	{r7, lr}
700ab642: b086         	sub	sp, #0x18
700ab644: 9005         	str	r0, [sp, #0x14]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700ab646: 9805         	ldr	r0, [sp, #0x14]
700ab648: 9004         	str	r0, [sp, #0x10]
;     DebugP_assert(sizeof(SemaphoreP_Struct) <= sizeof(SemaphoreP_Object) );
700ab64a: f641 10eb    	movw	r0, #0x19eb
700ab64e: f2c7 000b    	movt	r0, #0x700b
700ab652: 4669         	mov	r1, sp
700ab654: 6008         	str	r0, [r1]
700ab656: f641 41a6    	movw	r1, #0x1ca6
700ab65a: f2c7 010b    	movt	r1, #0x700b
700ab65e: f641 6286    	movw	r2, #0x1e86
700ab662: f2c7 020b    	movt	r2, #0x700b
700ab666: 2001         	movs	r0, #0x1
700ab668: 9002         	str	r0, [sp, #0x8]
700ab66a: 2370         	movs	r3, #0x70
700ab66c: f7ff fb10    	bl	0x700aac90 <_DebugP_assert> @ imm = #-0x9e0
700ab670: 9802         	ldr	r0, [sp, #0x8]
;     pSemaphore->isRecursiveMutex = 1;
700ab672: 9904         	ldr	r1, [sp, #0x10]
700ab674: 6548         	str	r0, [r1, #0x54]
;     pSemaphore->semHndl = xSemaphoreCreateRecursiveMutexStatic(&pSemaphore->semObj);
700ab676: 9904         	ldr	r1, [sp, #0x10]
700ab678: 2004         	movs	r0, #0x4
700ab67a: f003 f8a1    	bl	0x700ae7c0 <xQueueCreateMutexStatic> @ imm = #0x3142
700ab67e: 9904         	ldr	r1, [sp, #0x10]
700ab680: 6508         	str	r0, [r1, #0x50]
;     if( pSemaphore->semHndl == NULL )
700ab682: 9804         	ldr	r0, [sp, #0x10]
700ab684: 6d00         	ldr	r0, [r0, #0x50]
700ab686: b920         	cbnz	r0, 0x700ab692 <SemaphoreP_constructMutex+0x52> @ imm = #0x8
700ab688: e7ff         	b	0x700ab68a <SemaphoreP_constructMutex+0x4a> @ imm = #-0x2
700ab68a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700ab68e: 9003         	str	r0, [sp, #0xc]
;     }
700ab690: e00a         	b	0x700ab6a8 <SemaphoreP_constructMutex+0x68> @ imm = #0x14
;         vQueueAddToRegistry(pSemaphore->semHndl, "Mutex (DPL)");
700ab692: 9804         	ldr	r0, [sp, #0x10]
700ab694: 6d00         	ldr	r0, [r0, #0x50]
700ab696: f242 112f    	movw	r1, #0x212f
700ab69a: f2c7 010b    	movt	r1, #0x700b
700ab69e: f001 fd17    	bl	0x700ad0d0 <vQueueAddToRegistry> @ imm = #0x1a2e
700ab6a2: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700ab6a4: 9003         	str	r0, [sp, #0xc]
700ab6a6: e7ff         	b	0x700ab6a8 <SemaphoreP_constructMutex+0x68> @ imm = #-0x2
;     return status;
700ab6a8: 9803         	ldr	r0, [sp, #0xc]
700ab6aa: b006         	add	sp, #0x18
700ab6ac: bd80         	pop	{r7, pc}
700ab6ae: 0000         	movs	r0, r0

700ab6b0 <UdmaChPrms_init>:
; {
700ab6b0: b580         	push	{r7, lr}
700ab6b2: b082         	sub	sp, #0x8
700ab6b4: 9001         	str	r0, [sp, #0x4]
700ab6b6: 9100         	str	r1, [sp]
;     if(NULL_PTR != chPrms)
700ab6b8: 9801         	ldr	r0, [sp, #0x4]
700ab6ba: b368         	cbz	r0, 0x700ab718 <UdmaChPrms_init+0x68> @ imm = #0x5a
700ab6bc: e7ff         	b	0x700ab6be <UdmaChPrms_init+0xe> @ imm = #-0x2
;         chPrms->chNum       = UDMA_DMA_CH_ANY;
700ab6be: 9901         	ldr	r1, [sp, #0x4]
700ab6c0: 2001         	movs	r0, #0x1
700ab6c2: f6cf 70ff    	movt	r0, #0xffff
700ab6c6: 6008         	str	r0, [r1]
;         chPrms->peerChNum   = UDMA_DMA_CH_INVALID;
700ab6c8: 9901         	ldr	r1, [sp, #0x4]
700ab6ca: 2000         	movs	r0, #0x0
700ab6cc: f6cf 70ff    	movt	r0, #0xffff
700ab6d0: 6048         	str	r0, [r1, #0x4]
;         if(UDMA_CH_TYPE_TR_BLK_COPY == chType)
700ab6d2: 9800         	ldr	r0, [sp]
700ab6d4: 2807         	cmp	r0, #0x7
700ab6d6: d106         	bne	0x700ab6e6 <UdmaChPrms_init+0x36> @ imm = #0xc
700ab6d8: e7ff         	b	0x700ab6da <UdmaChPrms_init+0x2a> @ imm = #-0x2
;             chPrms->peerChNum   = UDMA_DMA_CH_NA;
700ab6da: 9901         	ldr	r1, [sp, #0x4]
700ab6dc: 2002         	movs	r0, #0x2
700ab6de: f6cf 70ff    	movt	r0, #0xffff
700ab6e2: 6048         	str	r0, [r1, #0x4]
;         }
700ab6e4: e7ff         	b	0x700ab6e6 <UdmaChPrms_init+0x36> @ imm = #-0x2
;         chPrms->mappedChGrp = UDMA_MAPPED_GROUP_INVALID;
700ab6e6: 9901         	ldr	r1, [sp, #0x4]
700ab6e8: 2004         	movs	r0, #0x4
700ab6ea: f6cf 70ff    	movt	r0, #0xffff
700ab6ee: 6088         	str	r0, [r1, #0x8]
;         chPrms->appData     = NULL_PTR;
700ab6f0: 9901         	ldr	r1, [sp, #0x4]
700ab6f2: 2000         	movs	r0, #0x0
700ab6f4: 60c8         	str	r0, [r1, #0xc]
;         UdmaRingPrms_init(&chPrms->fqRingPrms);
700ab6f6: 9801         	ldr	r0, [sp, #0x4]
700ab6f8: 3010         	adds	r0, #0x10
700ab6fa: f001 fbf9    	bl	0x700acef0 <UdmaRingPrms_init> @ imm = #0x17f2
;         UdmaRingPrms_init(&chPrms->cqRingPrms);
700ab6fe: 9801         	ldr	r0, [sp, #0x4]
700ab700: 302c         	adds	r0, #0x2c
700ab702: f001 fbf5    	bl	0x700acef0 <UdmaRingPrms_init> @ imm = #0x17ea
;         UdmaRingPrms_init(&chPrms->tdCqRingPrms);
700ab706: 9801         	ldr	r0, [sp, #0x4]
700ab708: 3048         	adds	r0, #0x48
700ab70a: f001 fbf1    	bl	0x700acef0 <UdmaRingPrms_init> @ imm = #0x17e2
;         chPrms->tdCqRingPrms.elemSize = UDMA_RING_ES_8BYTES;
700ab70e: 9901         	ldr	r1, [sp, #0x4]
700ab710: 2001         	movs	r0, #0x1
700ab712: f881 0058    	strb.w	r0, [r1, #0x58]
;     }
700ab716: e7ff         	b	0x700ab718 <UdmaChPrms_init+0x68> @ imm = #-0x2
;     return;
700ab718: b002         	add	sp, #0x8
700ab71a: bd80         	pop	{r7, pc}

700ab71c <atoi>:
700ab71c: e59f1060     	ldr	r1, [pc, #0x60]         @ 0x700ab784 <atoi+0x68>
700ab720: e4d02001     	ldrb	r2, [r0], #1
700ab724: e0813002     	add	r3, r1, r2
700ab728: e5d33001     	ldrb	r3, [r3, #0x1]
700ab72c: e3130010     	tst	r3, #16
700ab730: 1afffffa     	bne	0x700ab720 <atoi+0x4>   @ imm = #-0x18
700ab734: e3a01000     	mov	r1, #0
700ab738: e352002b     	cmp	r2, #43
700ab73c: 1352002d     	cmpne	r2, #45
700ab740: 0a000003     	beq	0x700ab754 <atoi+0x38>  @ imm = #0xc
700ab744: e2400001     	sub	r0, r0, #1
700ab748: e3a01000     	mov	r1, #0
700ab74c: e1a03002     	mov	r3, r2
700ab750: ea000000     	b	0x700ab758 <atoi+0x3c>  @ imm = #0x0
700ab754: e5d03000     	ldrb	r3, [r0]
700ab758: e2433030     	sub	r3, r3, #48
700ab75c: e3530009     	cmp	r3, #9
700ab760: 8a000003     	bhi	0x700ab774 <atoi+0x58>  @ imm = #0xc
700ab764: e0811101     	add	r1, r1, r1, lsl #2
700ab768: e2800001     	add	r0, r0, #1
700ab76c: e0831081     	add	r1, r3, r1, lsl #1
700ab770: eafffff7     	b	0x700ab754 <atoi+0x38>  @ imm = #-0x24
700ab774: e352002d     	cmp	r2, #45
700ab778: 02611000     	rsbeq	r1, r1, #0
700ab77c: e1a00001     	mov	r0, r1
700ab780: e12fff1e     	bx	lr
700ab784: 00 16 0b 70  	.word	0x700b1600
700ab788: 00 00 00 00  	.word	0x00000000
700ab78c: 00 00 00 00  	.word	0x00000000

700ab790 <Pinmux_lockMMR>:
; {
700ab790: b580         	push	{r7, lr}
700ab792: b084         	sub	sp, #0x10
700ab794: 9003         	str	r0, [sp, #0xc]
;     if(PINMUX_DOMAIN_ID_MAIN == domainId)
700ab796: 9803         	ldr	r0, [sp, #0xc]
700ab798: b908         	cbnz	r0, 0x700ab79e <Pinmux_lockMMR+0xe> @ imm = #0x2
700ab79a: e7ff         	b	0x700ab79c <Pinmux_lockMMR+0xc> @ imm = #-0x2
;     }
700ab79c: e7ff         	b	0x700ab79e <Pinmux_lockMMR+0xe> @ imm = #-0x2
;     if(PINMUX_DOMAIN_ID_MCU == domainId)
700ab79e: 9803         	ldr	r0, [sp, #0xc]
700ab7a0: 2801         	cmp	r0, #0x1
700ab7a2: d128         	bne	0x700ab7f6 <Pinmux_lockMMR+0x66> @ imm = #0x50
700ab7a4: e7ff         	b	0x700ab7a6 <Pinmux_lockMMR+0x16> @ imm = #-0x2
700ab7a6: f04f 6081    	mov.w	r0, #0x4080000
700ab7aa: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_PADCFG_CTRL0_CFG0_BASE);
700ab7ac: 9100         	str	r1, [sp]
700ab7ae: f7fa fa37    	bl	0x700a5c20 <AddrTranslateP_getLocalAddr> @ imm = #-0x5b92
700ab7b2: 9900         	ldr	r1, [sp]
700ab7b4: 9002         	str	r0, [sp, #0x8]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK0_KICK0_OFFSET);
700ab7b6: 9802         	ldr	r0, [sp, #0x8]
700ab7b8: f241 0208    	movw	r2, #0x1008
700ab7bc: 4410         	add	r0, r2
700ab7be: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700ab7c0: 9801         	ldr	r0, [sp, #0x4]
700ab7c2: f004 f995    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0x432a
700ab7c6: 9900         	ldr	r1, [sp]
;         kickAddr++;
700ab7c8: 9801         	ldr	r0, [sp, #0x4]
700ab7ca: 3004         	adds	r0, #0x4
700ab7cc: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700ab7ce: 9801         	ldr	r0, [sp, #0x4]
700ab7d0: f004 f98e    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0x431c
700ab7d4: 9900         	ldr	r1, [sp]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK1_KICK0_OFFSET);
700ab7d6: 9802         	ldr	r0, [sp, #0x8]
700ab7d8: f245 0208    	movw	r2, #0x5008
700ab7dc: 4410         	add	r0, r2
700ab7de: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700ab7e0: 9801         	ldr	r0, [sp, #0x4]
700ab7e2: f004 f985    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0x430a
700ab7e6: 9900         	ldr	r1, [sp]
;         kickAddr++;
700ab7e8: 9801         	ldr	r0, [sp, #0x4]
700ab7ea: 3004         	adds	r0, #0x4
700ab7ec: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700ab7ee: 9801         	ldr	r0, [sp, #0x4]
700ab7f0: f004 f97e    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0x42fc
;     }
700ab7f4: e7ff         	b	0x700ab7f6 <Pinmux_lockMMR+0x66> @ imm = #-0x2
;     return;
700ab7f6: b004         	add	sp, #0x10
700ab7f8: bd80         	pop	{r7, pc}
700ab7fa: 0000         	movs	r0, r0
700ab7fc: 0000         	movs	r0, r0
700ab7fe: 0000         	movs	r0, r0

700ab800 <vListInsert>:
; {
700ab800: b084         	sub	sp, #0x10
700ab802: 9003         	str	r0, [sp, #0xc]
700ab804: 9102         	str	r1, [sp, #0x8]
;     const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
700ab806: 9802         	ldr	r0, [sp, #0x8]
700ab808: 6800         	ldr	r0, [r0]
700ab80a: 9000         	str	r0, [sp]
;     if( xValueOfInsertion == portMAX_DELAY )
700ab80c: 9800         	ldr	r0, [sp]
700ab80e: 3001         	adds	r0, #0x1
700ab810: b920         	cbnz	r0, 0x700ab81c <vListInsert+0x1c> @ imm = #0x8
700ab812: e7ff         	b	0x700ab814 <vListInsert+0x14> @ imm = #-0x2
;         pxIterator = pxList->xListEnd.pxPrevious;
700ab814: 9803         	ldr	r0, [sp, #0xc]
700ab816: 6900         	ldr	r0, [r0, #0x10]
700ab818: 9001         	str	r0, [sp, #0x4]
;     }
700ab81a: e010         	b	0x700ab83e <vListInsert+0x3e> @ imm = #0x20
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
700ab81c: 9803         	ldr	r0, [sp, #0xc]
700ab81e: 3008         	adds	r0, #0x8
700ab820: 9001         	str	r0, [sp, #0x4]
700ab822: e7ff         	b	0x700ab824 <vListInsert+0x24> @ imm = #-0x2
700ab824: 9801         	ldr	r0, [sp, #0x4]
700ab826: 6840         	ldr	r0, [r0, #0x4]
700ab828: 6800         	ldr	r0, [r0]
700ab82a: 9900         	ldr	r1, [sp]
700ab82c: 4288         	cmp	r0, r1
700ab82e: d805         	bhi	0x700ab83c <vListInsert+0x3c> @ imm = #0xa
700ab830: e7ff         	b	0x700ab832 <vListInsert+0x32> @ imm = #-0x2
;         }
700ab832: e7ff         	b	0x700ab834 <vListInsert+0x34> @ imm = #-0x2
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
700ab834: 9801         	ldr	r0, [sp, #0x4]
700ab836: 6840         	ldr	r0, [r0, #0x4]
700ab838: 9001         	str	r0, [sp, #0x4]
700ab83a: e7f3         	b	0x700ab824 <vListInsert+0x24> @ imm = #-0x1a
700ab83c: e7ff         	b	0x700ab83e <vListInsert+0x3e> @ imm = #-0x2
;     pxNewListItem->pxNext = pxIterator->pxNext;
700ab83e: 9801         	ldr	r0, [sp, #0x4]
700ab840: 6840         	ldr	r0, [r0, #0x4]
700ab842: 9902         	ldr	r1, [sp, #0x8]
700ab844: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxNext->pxPrevious = pxNewListItem;
700ab846: 9802         	ldr	r0, [sp, #0x8]
700ab848: 6841         	ldr	r1, [r0, #0x4]
700ab84a: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxPrevious = pxIterator;
700ab84c: 9801         	ldr	r0, [sp, #0x4]
700ab84e: 9902         	ldr	r1, [sp, #0x8]
700ab850: 6088         	str	r0, [r1, #0x8]
;     pxIterator->pxNext = pxNewListItem;
700ab852: 9802         	ldr	r0, [sp, #0x8]
700ab854: 9901         	ldr	r1, [sp, #0x4]
700ab856: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxContainer = pxList;
700ab858: 9803         	ldr	r0, [sp, #0xc]
700ab85a: 9902         	ldr	r1, [sp, #0x8]
700ab85c: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
700ab85e: 9903         	ldr	r1, [sp, #0xc]
700ab860: 6808         	ldr	r0, [r1]
700ab862: 3001         	adds	r0, #0x1
700ab864: 6008         	str	r0, [r1]
; }
700ab866: b004         	add	sp, #0x10
700ab868: 4770         	bx	lr
700ab86a: 0000         	movs	r0, r0
700ab86c: 0000         	movs	r0, r0
700ab86e: 0000         	movs	r0, r0

700ab870 <Sciclient_rmIrqCfgIsDirectEvent>:
; {
700ab870: b580         	push	{r7, lr}
700ab872: b082         	sub	sp, #0x8
700ab874: 9001         	str	r0, [sp, #0x4]
700ab876: 2000         	movs	r0, #0x0
;     bool r = false;
700ab878: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab87c: 9801         	ldr	r0, [sp, #0x4]
700ab87e: 2101         	movs	r1, #0x1
700ab880: f003 fa46    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x348c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700ab884: b310         	cbz	r0, 0x700ab8cc <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x44
700ab886: e7ff         	b	0x700ab888 <Sciclient_rmIrqCfgIsDirectEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab888: 9801         	ldr	r0, [sp, #0x4]
700ab88a: 2102         	movs	r1, #0x2
700ab88c: f003 fa40    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x3480
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700ab890: b1e0         	cbz	r0, 0x700ab8cc <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x38
700ab892: e7ff         	b	0x700ab894 <Sciclient_rmIrqCfgIsDirectEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab894: 9801         	ldr	r0, [sp, #0x4]
700ab896: 2104         	movs	r1, #0x4
700ab898: f003 fa3a    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x3474
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700ab89c: b1b0         	cbz	r0, 0x700ab8cc <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x2c
700ab89e: e7ff         	b	0x700ab8a0 <Sciclient_rmIrqCfgIsDirectEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab8a0: 9801         	ldr	r0, [sp, #0x4]
700ab8a2: 2108         	movs	r1, #0x8
700ab8a4: f003 fa34    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x3468
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700ab8a8: b180         	cbz	r0, 0x700ab8cc <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x20
700ab8aa: e7ff         	b	0x700ab8ac <Sciclient_rmIrqCfgIsDirectEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab8ac: 9801         	ldr	r0, [sp, #0x4]
700ab8ae: 2110         	movs	r1, #0x10
700ab8b0: f003 fa2e    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x345c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700ab8b4: b150         	cbz	r0, 0x700ab8cc <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x14
700ab8b6: e7ff         	b	0x700ab8b8 <Sciclient_rmIrqCfgIsDirectEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab8b8: 9801         	ldr	r0, [sp, #0x4]
700ab8ba: 2120         	movs	r1, #0x20
700ab8bc: f003 fa28    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x3450
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab8c0: b120         	cbz	r0, 0x700ab8cc <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x8
700ab8c2: e7ff         	b	0x700ab8c4 <Sciclient_rmIrqCfgIsDirectEvent+0x54> @ imm = #-0x2
700ab8c4: 2001         	movs	r0, #0x1
;         r = true;
700ab8c6: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab8ca: e7ff         	b	0x700ab8cc <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #-0x2
;     return r;
700ab8cc: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab8d0: f000 0001    	and	r0, r0, #0x1
700ab8d4: b002         	add	sp, #0x8
700ab8d6: bd80         	pop	{r7, pc}
		...

700ab8e0 <Sciclient_rmIrqCfgIsDirectNonEvent>:
; {
700ab8e0: b580         	push	{r7, lr}
700ab8e2: b082         	sub	sp, #0x8
700ab8e4: 9001         	str	r0, [sp, #0x4]
700ab8e6: 2000         	movs	r0, #0x0
;     bool r = false;
700ab8e8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab8ec: 9801         	ldr	r0, [sp, #0x4]
700ab8ee: 2101         	movs	r1, #0x1
700ab8f0: f003 fa0e    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x341c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700ab8f4: b310         	cbz	r0, 0x700ab93c <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x44
700ab8f6: e7ff         	b	0x700ab8f8 <Sciclient_rmIrqCfgIsDirectNonEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab8f8: 9801         	ldr	r0, [sp, #0x4]
700ab8fa: 2102         	movs	r1, #0x2
700ab8fc: f003 fa08    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x3410
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700ab900: b1e0         	cbz	r0, 0x700ab93c <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x38
700ab902: e7ff         	b	0x700ab904 <Sciclient_rmIrqCfgIsDirectNonEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab904: 9801         	ldr	r0, [sp, #0x4]
700ab906: 2104         	movs	r1, #0x4
700ab908: f003 fa02    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x3404
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == false) &&
700ab90c: b9b0         	cbnz	r0, 0x700ab93c <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x2c
700ab90e: e7ff         	b	0x700ab910 <Sciclient_rmIrqCfgIsDirectNonEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab910: 9801         	ldr	r0, [sp, #0x4]
700ab912: 2108         	movs	r1, #0x8
700ab914: f003 f9fc    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x33f8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == false) &&
700ab918: b980         	cbnz	r0, 0x700ab93c <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x20
700ab91a: e7ff         	b	0x700ab91c <Sciclient_rmIrqCfgIsDirectNonEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab91c: 9801         	ldr	r0, [sp, #0x4]
700ab91e: 2110         	movs	r1, #0x10
700ab920: f003 f9f6    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x33ec
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == false) &&
700ab924: b950         	cbnz	r0, 0x700ab93c <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x14
700ab926: e7ff         	b	0x700ab928 <Sciclient_rmIrqCfgIsDirectNonEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab928: 9801         	ldr	r0, [sp, #0x4]
700ab92a: 2120         	movs	r1, #0x20
700ab92c: f003 f9f0    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x33e0
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab930: b920         	cbnz	r0, 0x700ab93c <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x8
700ab932: e7ff         	b	0x700ab934 <Sciclient_rmIrqCfgIsDirectNonEvent+0x54> @ imm = #-0x2
700ab934: 2001         	movs	r0, #0x1
;         r = true;
700ab936: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab93a: e7ff         	b	0x700ab93c <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #-0x2
;     return r;
700ab93c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab940: f000 0001    	and	r0, r0, #0x1
700ab944: b002         	add	sp, #0x8
700ab946: bd80         	pop	{r7, pc}
		...

700ab950 <Sciclient_rmIrqCfgIsEventToVintMappingOnly>:
; {
700ab950: b580         	push	{r7, lr}
700ab952: b082         	sub	sp, #0x8
700ab954: 9001         	str	r0, [sp, #0x4]
700ab956: 2000         	movs	r0, #0x0
;     bool r = false;
700ab958: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab95c: 9801         	ldr	r0, [sp, #0x4]
700ab95e: 2101         	movs	r1, #0x1
700ab960: f003 f9d6    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x33ac
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == false) &&
700ab964: bb10         	cbnz	r0, 0x700ab9ac <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x44
700ab966: e7ff         	b	0x700ab968 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab968: 9801         	ldr	r0, [sp, #0x4]
700ab96a: 2102         	movs	r1, #0x2
700ab96c: f003 f9d0    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x33a0
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == false) &&
700ab970: b9e0         	cbnz	r0, 0x700ab9ac <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x38
700ab972: e7ff         	b	0x700ab974 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab974: 9801         	ldr	r0, [sp, #0x4]
700ab976: 2104         	movs	r1, #0x4
700ab978: f003 f9ca    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x3394
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700ab97c: b1b0         	cbz	r0, 0x700ab9ac <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x2c
700ab97e: e7ff         	b	0x700ab980 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab980: 9801         	ldr	r0, [sp, #0x4]
700ab982: 2108         	movs	r1, #0x8
700ab984: f003 f9c4    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x3388
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700ab988: b180         	cbz	r0, 0x700ab9ac <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x20
700ab98a: e7ff         	b	0x700ab98c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab98c: 9801         	ldr	r0, [sp, #0x4]
700ab98e: 2110         	movs	r1, #0x10
700ab990: f003 f9be    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x337c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700ab994: b150         	cbz	r0, 0x700ab9ac <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x14
700ab996: e7ff         	b	0x700ab998 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab998: 9801         	ldr	r0, [sp, #0x4]
700ab99a: 2120         	movs	r1, #0x20
700ab99c: f003 f9b8    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x3370
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab9a0: b120         	cbz	r0, 0x700ab9ac <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x8
700ab9a2: e7ff         	b	0x700ab9a4 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x54> @ imm = #-0x2
700ab9a4: 2001         	movs	r0, #0x1
;         r = true;
700ab9a6: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab9aa: e7ff         	b	0x700ab9ac <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #-0x2
;     return r;
700ab9ac: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab9b0: f000 0001    	and	r0, r0, #0x1
700ab9b4: b002         	add	sp, #0x8
700ab9b6: bd80         	pop	{r7, pc}
		...

700ab9c0 <Sciclient_rmIrqCfgIsOesOnly>:
; {
700ab9c0: b580         	push	{r7, lr}
700ab9c2: b082         	sub	sp, #0x8
700ab9c4: 9001         	str	r0, [sp, #0x4]
700ab9c6: 2000         	movs	r0, #0x0
;     bool r = false;
700ab9c8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab9cc: 9801         	ldr	r0, [sp, #0x4]
700ab9ce: 2101         	movs	r1, #0x1
700ab9d0: f003 f99e    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x333c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == false) &&
700ab9d4: bb10         	cbnz	r0, 0x700aba1c <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x44
700ab9d6: e7ff         	b	0x700ab9d8 <Sciclient_rmIrqCfgIsOesOnly+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab9d8: 9801         	ldr	r0, [sp, #0x4]
700ab9da: 2102         	movs	r1, #0x2
700ab9dc: f003 f998    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x3330
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == false) &&
700ab9e0: b9e0         	cbnz	r0, 0x700aba1c <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x38
700ab9e2: e7ff         	b	0x700ab9e4 <Sciclient_rmIrqCfgIsOesOnly+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab9e4: 9801         	ldr	r0, [sp, #0x4]
700ab9e6: 2104         	movs	r1, #0x4
700ab9e8: f003 f992    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x3324
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == false) &&
700ab9ec: b9b0         	cbnz	r0, 0x700aba1c <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x2c
700ab9ee: e7ff         	b	0x700ab9f0 <Sciclient_rmIrqCfgIsOesOnly+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab9f0: 9801         	ldr	r0, [sp, #0x4]
700ab9f2: 2108         	movs	r1, #0x8
700ab9f4: f003 f98c    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x3318
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == false) &&
700ab9f8: b980         	cbnz	r0, 0x700aba1c <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x20
700ab9fa: e7ff         	b	0x700ab9fc <Sciclient_rmIrqCfgIsOesOnly+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab9fc: 9801         	ldr	r0, [sp, #0x4]
700ab9fe: 2110         	movs	r1, #0x10
700aba00: f003 f986    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x330c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700aba04: b150         	cbz	r0, 0x700aba1c <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x14
700aba06: e7ff         	b	0x700aba08 <Sciclient_rmIrqCfgIsOesOnly+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700aba08: 9801         	ldr	r0, [sp, #0x4]
700aba0a: 2120         	movs	r1, #0x20
700aba0c: f003 f980    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x3300
;     if ((Sciclient_rmParamIsValid(valid_params,
700aba10: b920         	cbnz	r0, 0x700aba1c <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x8
700aba12: e7ff         	b	0x700aba14 <Sciclient_rmIrqCfgIsOesOnly+0x54> @ imm = #-0x2
700aba14: 2001         	movs	r0, #0x1
;         r = true;
700aba16: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aba1a: e7ff         	b	0x700aba1c <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #-0x2
;     return r;
700aba1c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aba20: f000 0001    	and	r0, r0, #0x1
700aba24: b002         	add	sp, #0x8
700aba26: bd80         	pop	{r7, pc}
		...

700aba30 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent>:
; {
700aba30: b580         	push	{r7, lr}
700aba32: b082         	sub	sp, #0x8
700aba34: 9001         	str	r0, [sp, #0x4]
700aba36: 2000         	movs	r0, #0x0
;     bool r = false;
700aba38: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700aba3c: 9801         	ldr	r0, [sp, #0x4]
700aba3e: 2101         	movs	r1, #0x1
700aba40: f003 f966    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x32cc
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700aba44: b310         	cbz	r0, 0x700aba8c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x44
700aba46: e7ff         	b	0x700aba48 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700aba48: 9801         	ldr	r0, [sp, #0x4]
700aba4a: 2102         	movs	r1, #0x2
700aba4c: f003 f960    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x32c0
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700aba50: b1e0         	cbz	r0, 0x700aba8c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x38
700aba52: e7ff         	b	0x700aba54 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700aba54: 9801         	ldr	r0, [sp, #0x4]
700aba56: 2104         	movs	r1, #0x4
700aba58: f003 f95a    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x32b4
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700aba5c: b1b0         	cbz	r0, 0x700aba8c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x2c
700aba5e: e7ff         	b	0x700aba60 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700aba60: 9801         	ldr	r0, [sp, #0x4]
700aba62: 2108         	movs	r1, #0x8
700aba64: f003 f954    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x32a8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700aba68: b180         	cbz	r0, 0x700aba8c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x20
700aba6a: e7ff         	b	0x700aba6c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700aba6c: 9801         	ldr	r0, [sp, #0x4]
700aba6e: 2110         	movs	r1, #0x10
700aba70: f003 f94e    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x329c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == false) &&
700aba74: b950         	cbnz	r0, 0x700aba8c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x14
700aba76: e7ff         	b	0x700aba78 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700aba78: 9801         	ldr	r0, [sp, #0x4]
700aba7a: 2120         	movs	r1, #0x20
700aba7c: f003 f948    	bl	0x700aed10 <Sciclient_rmParamIsValid> @ imm = #0x3290
;     if ((Sciclient_rmParamIsValid(valid_params,
700aba80: b920         	cbnz	r0, 0x700aba8c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x8
700aba82: e7ff         	b	0x700aba84 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x54> @ imm = #-0x2
700aba84: 2001         	movs	r0, #0x1
;         r = true;
700aba86: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aba8a: e7ff         	b	0x700aba8c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #-0x2
;     return r;
700aba8c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aba90: f000 0001    	and	r0, r0, #0x1
700aba94: b002         	add	sp, #0x8
700aba96: bd80         	pop	{r7, pc}
		...

700abaa0 <UART_divisorValCompute>:
; {
700abaa0: b580         	push	{r7, lr}
700abaa2: b088         	sub	sp, #0x20
700abaa4: 9007         	str	r0, [sp, #0x1c]
700abaa6: 9106         	str	r1, [sp, #0x18]
700abaa8: 9205         	str	r2, [sp, #0x14]
700abaaa: 9304         	str	r3, [sp, #0x10]
700abaac: 2000         	movs	r0, #0x0
;     uint32_t divisorValue = 0U;
700abaae: 9003         	str	r0, [sp, #0xc]
;     uint32_t tempModeFlag = modeFlag & UART_MDR1_MODE_SELECT_MASK;
700abab0: 9805         	ldr	r0, [sp, #0x14]
700abab2: f000 0007    	and	r0, r0, #0x7
700abab6: 9002         	str	r0, [sp, #0x8]
;     switch (tempModeFlag)
700abab8: 9802         	ldr	r0, [sp, #0x8]
700ababa: 9001         	str	r0, [sp, #0x4]
700ababc: 2805         	cmp	r0, #0x5
700ababe: d81f         	bhi	0x700abb00 <UART_divisorValCompute+0x60> @ imm = #0x3e
700abac0: 9901         	ldr	r1, [sp, #0x4]
700abac2: e8df f001    	tbb	[pc, r1]
700abac6: 03 03 1d 0a  	.word	0x0a1d0303
700abaca: 12 1a        	.short	0x1a12
;             divisorValue = UART_divideRoundCloset(moduleClk, 16U * baudRate);
700abacc: 9807         	ldr	r0, [sp, #0x1c]
700abace: 9906         	ldr	r1, [sp, #0x18]
700abad0: 0109         	lsls	r1, r1, #0x4
700abad2: f003 ff05    	bl	0x700af8e0 <UART_divideRoundCloset> @ imm = #0x3e0a
700abad6: 9003         	str	r0, [sp, #0xc]
;             break;
700abad8: e013         	b	0x700abb02 <UART_divisorValCompute+0x62> @ imm = #0x26
;             divisorValue = UART_divideRoundCloset(moduleClk, 13U * baudRate);
700abada: 9807         	ldr	r0, [sp, #0x1c]
700abadc: 9906         	ldr	r1, [sp, #0x18]
700abade: 220d         	movs	r2, #0xd
700abae0: 4351         	muls	r1, r2, r1
700abae2: f003 fefd    	bl	0x700af8e0 <UART_divideRoundCloset> @ imm = #0x3dfa
700abae6: 9003         	str	r0, [sp, #0xc]
;             break;
700abae8: e00b         	b	0x700abb02 <UART_divisorValCompute+0x62> @ imm = #0x16
;             divisorValue = UART_divideRoundCloset(moduleClk, mirOverSampRate * baudRate);
700abaea: 9807         	ldr	r0, [sp, #0x1c]
700abaec: 9904         	ldr	r1, [sp, #0x10]
700abaee: 9a06         	ldr	r2, [sp, #0x18]
700abaf0: 4351         	muls	r1, r2, r1
700abaf2: f003 fef5    	bl	0x700af8e0 <UART_divideRoundCloset> @ imm = #0x3dea
700abaf6: 9003         	str	r0, [sp, #0xc]
;             break;
700abaf8: e003         	b	0x700abb02 <UART_divisorValCompute+0x62> @ imm = #0x6
700abafa: 2000         	movs	r0, #0x0
;             divisorValue = 0U;
700abafc: 9003         	str	r0, [sp, #0xc]
;             break;
700abafe: e000         	b	0x700abb02 <UART_divisorValCompute+0x62> @ imm = #0x0
;             break;
700abb00: e7ff         	b	0x700abb02 <UART_divisorValCompute+0x62> @ imm = #-0x2
;     return divisorValue;
700abb02: 9803         	ldr	r0, [sp, #0xc]
700abb04: b008         	add	sp, #0x20
700abb06: bd80         	pop	{r7, pc}
		...

700abb10 <CSL_udmapCppi5SetIds>:
; {
700abb10: b085         	sub	sp, #0x14
700abb12: 9004         	str	r0, [sp, #0x10]
700abb14: 9103         	str	r1, [sp, #0xc]
700abb16: 9202         	str	r2, [sp, #0x8]
700abb18: 9301         	str	r3, [sp, #0x4]
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700abb1a: 9803         	ldr	r0, [sp, #0xc]
700abb1c: 2803         	cmp	r0, #0x3
700abb1e: d114         	bne	0x700abb4a <CSL_udmapCppi5SetIds+0x3a> @ imm = #0x28
700abb20: e7ff         	b	0x700abb22 <CSL_udmapCppi5SetIds+0x12> @ imm = #-0x2
;         v = ((CSL_UdmapCppi5TRPD *)pDesc)->pktInfo;
700abb22: 9804         	ldr	r0, [sp, #0x10]
700abb24: 6840         	ldr	r0, [r0, #0x4]
700abb26: 9000         	str	r0, [sp]
;         v &= ~(CSL_UDMAP_CPPI5_TRPD_PKTINFO_PKTID_MASK | CSL_UDMAP_CPPI5_TRPD_PKTINFO_FLOWID_MASK);
700abb28: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700abb2c: 0600         	lsls	r0, r0, #0x18
700abb2e: 9000         	str	r0, [sp]
;         v |= CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_PKTID, pktId )   |
700abb30: 9802         	ldr	r0, [sp, #0x8]
;              CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_FLOWID, flowId );
700abb32: 9901         	ldr	r1, [sp, #0x4]
700abb34: f36f 319f    	bfc	r1, #14, #18
;         v |= CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_PKTID, pktId )   |
700abb38: f360 3197    	bfi	r1, r0, #14, #10
700abb3c: 9800         	ldr	r0, [sp]
700abb3e: 4308         	orrs	r0, r1
700abb40: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5TRPD *)pDesc)->pktInfo = v;
700abb42: 9800         	ldr	r0, [sp]
700abb44: 9904         	ldr	r1, [sp, #0x10]
700abb46: 6048         	str	r0, [r1, #0x4]
;     }
700abb48: e013         	b	0x700abb72 <CSL_udmapCppi5SetIds+0x62> @ imm = #0x26
;         v = ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1;
700abb4a: 9804         	ldr	r0, [sp, #0x10]
700abb4c: 6840         	ldr	r0, [r0, #0x4]
700abb4e: 9000         	str	r0, [sp]
;         v &= ~(CSL_UDMAP_CPPI5_PD_PKTINFO1_PKTID_MASK | CSL_UDMAP_CPPI5_PD_PKTINFO1_FLOWID_MASK);
700abb50: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700abb54: 0600         	lsls	r0, r0, #0x18
700abb56: 9000         	str	r0, [sp]
;         v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_PKTID, pktId )   |
700abb58: 9802         	ldr	r0, [sp, #0x8]
;              CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_FLOWID, flowId );
700abb5a: 9901         	ldr	r1, [sp, #0x4]
700abb5c: f36f 319f    	bfc	r1, #14, #18
;         v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_PKTID, pktId )   |
700abb60: f360 3197    	bfi	r1, r0, #14, #10
700abb64: 9800         	ldr	r0, [sp]
700abb66: 4308         	orrs	r0, r1
700abb68: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1 = v;
700abb6a: 9800         	ldr	r0, [sp]
700abb6c: 9904         	ldr	r1, [sp, #0x10]
700abb6e: 6048         	str	r0, [r1, #0x4]
700abb70: e7ff         	b	0x700abb72 <CSL_udmapCppi5SetIds+0x62> @ imm = #-0x2
; }
700abb72: b005         	add	sp, #0x14
700abb74: 4770         	bx	lr
		...
700abb7e: 0000         	movs	r0, r0

700abb80 <Sciclient_rmIrGetInst>:
; {
700abb80: b083         	sub	sp, #0xc
700abb82: f8ad 000a    	strh.w	r0, [sp, #0xa]
700abb86: 2000         	movs	r0, #0x0
;     struct Sciclient_rmIrInst *inst = NULL;
700abb88: 9001         	str	r0, [sp, #0x4]
;     for (i = 0; i < SCICLIENT_RM_IR_NUM_INST; i++) {
700abb8a: f8ad 0002    	strh.w	r0, [sp, #0x2]
700abb8e: e7ff         	b	0x700abb90 <Sciclient_rmIrGetInst+0x10> @ imm = #-0x2
700abb90: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700abb94: 2803         	cmp	r0, #0x3
700abb96: dc22         	bgt	0x700abbde <Sciclient_rmIrGetInst+0x5e> @ imm = #0x44
700abb98: e7ff         	b	0x700abb9a <Sciclient_rmIrGetInst+0x1a> @ imm = #-0x2
;         if (id == gRmIrInstances[i].dev_id) {
700abb9a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700abb9e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700abba2: eb01 0241    	add.w	r2, r1, r1, lsl #1
700abba6: f242 71d4    	movw	r1, #0x27d4
700abbaa: f2c7 010b    	movt	r1, #0x700b
700abbae: f831 1032    	ldrh.w	r1, [r1, r2, lsl #3]
700abbb2: 4288         	cmp	r0, r1
700abbb4: d10c         	bne	0x700abbd0 <Sciclient_rmIrGetInst+0x50> @ imm = #0x18
700abbb6: e7ff         	b	0x700abbb8 <Sciclient_rmIrGetInst+0x38> @ imm = #-0x2
;             inst = &gRmIrInstances[i];
700abbb8: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700abbbc: eb00 0140    	add.w	r1, r0, r0, lsl #1
700abbc0: f242 70d4    	movw	r0, #0x27d4
700abbc4: f2c7 000b    	movt	r0, #0x700b
700abbc8: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700abbcc: 9001         	str	r0, [sp, #0x4]
;             break;
700abbce: e006         	b	0x700abbde <Sciclient_rmIrGetInst+0x5e> @ imm = #0xc
;     }
700abbd0: e7ff         	b	0x700abbd2 <Sciclient_rmIrGetInst+0x52> @ imm = #-0x2
;     for (i = 0; i < SCICLIENT_RM_IR_NUM_INST; i++) {
700abbd2: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700abbd6: 3001         	adds	r0, #0x1
700abbd8: f8ad 0002    	strh.w	r0, [sp, #0x2]
700abbdc: e7d8         	b	0x700abb90 <Sciclient_rmIrGetInst+0x10> @ imm = #-0x50
;     return inst;
700abbde: 9801         	ldr	r0, [sp, #0x4]
700abbe0: b003         	add	sp, #0xc
700abbe2: 4770         	bx	lr
		...

700abbf0 <UART_fifoRegisterWrite>:
; {
700abbf0: b580         	push	{r7, lr}
700abbf2: b088         	sub	sp, #0x20
700abbf4: 9007         	str	r0, [sp, #0x1c]
700abbf6: 9106         	str	r1, [sp, #0x18]
700abbf8: 2000         	movs	r0, #0x0
;     uint32_t isTxRxFifoEmpty = FALSE;
700abbfa: 9001         	str	r0, [sp, #0x4]
700abbfc: 9002         	str	r0, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700abbfe: 9807         	ldr	r0, [sp, #0x1c]
700abc00: 2180         	movs	r1, #0x80
700abc02: f000 fdc5    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #0xb8a
700abc06: 9901         	ldr	r1, [sp, #0x4]
700abc08: 9003         	str	r0, [sp, #0xc]
;     divLatchRegVal = UART_divisorLatchWrite(baseAddr, 0x0000U);
700abc0a: 9807         	ldr	r0, [sp, #0x1c]
700abc0c: f7f8 ffb0    	bl	0x700a4b70 <UART_divisorLatchWrite> @ imm = #-0x70a0
700abc10: 9005         	str	r0, [sp, #0x14]
;     enhanFnBitVal = UART_enhanFuncEnable(baseAddr);
700abc12: 9807         	ldr	r0, [sp, #0x1c]
700abc14: f002 fa5c    	bl	0x700ae0d0 <UART_enhanFuncEnable> @ imm = #0x24b8
700abc18: 9004         	str	r0, [sp, #0x10]
;     HW_WR_REG32(baseAddr + UART_FCR, fcrValue);
700abc1a: 9807         	ldr	r0, [sp, #0x1c]
700abc1c: 3008         	adds	r0, #0x8
700abc1e: 9906         	ldr	r1, [sp, #0x18]
700abc20: f003 ffb6    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x3f6c
;     while(isTxRxFifoEmpty == FALSE)
700abc24: e7ff         	b	0x700abc26 <UART_fifoRegisterWrite+0x36> @ imm = #-0x2
700abc26: 9802         	ldr	r0, [sp, #0x8]
700abc28: b928         	cbnz	r0, 0x700abc36 <UART_fifoRegisterWrite+0x46> @ imm = #0xa
700abc2a: e7ff         	b	0x700abc2c <UART_fifoRegisterWrite+0x3c> @ imm = #-0x2
;         isTxRxFifoEmpty = UART_IsTxRxFifoEmpty(baseAddr);
700abc2c: 9807         	ldr	r0, [sp, #0x1c]
700abc2e: f002 fa2f    	bl	0x700ae090 <UART_IsTxRxFifoEmpty> @ imm = #0x245e
700abc32: 9002         	str	r0, [sp, #0x8]
;     while(isTxRxFifoEmpty == FALSE)
700abc34: e7f7         	b	0x700abc26 <UART_fifoRegisterWrite+0x36> @ imm = #-0x12
;     UART_enhanFuncBitValRestore(baseAddr, enhanFnBitVal);
700abc36: 9807         	ldr	r0, [sp, #0x1c]
700abc38: 9904         	ldr	r1, [sp, #0x10]
700abc3a: f002 fd61    	bl	0x700ae700 <UART_enhanFuncBitValRestore> @ imm = #0x2ac2
;     (void) UART_divisorLatchWrite(baseAddr, divLatchRegVal);
700abc3e: 9807         	ldr	r0, [sp, #0x1c]
700abc40: 9905         	ldr	r1, [sp, #0x14]
700abc42: f7f8 ff95    	bl	0x700a4b70 <UART_divisorLatchWrite> @ imm = #-0x70d6
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700abc46: 9807         	ldr	r0, [sp, #0x1c]
700abc48: 300c         	adds	r0, #0xc
700abc4a: 9903         	ldr	r1, [sp, #0xc]
700abc4c: f003 ffa0    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x3f40
; }
700abc50: b008         	add	sp, #0x20
700abc52: bd80         	pop	{r7, pc}
		...

700abc60 <UART_lld_deInitDma>:
; {
700abc60: b580         	push	{r7, lr}
700abc62: b084         	sub	sp, #0x10
700abc64: 9003         	str	r0, [sp, #0xc]
700abc66: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700abc68: 9002         	str	r0, [sp, #0x8]
;     if (NULL_PTR != hUart)
700abc6a: 9803         	ldr	r0, [sp, #0xc]
700abc6c: b318         	cbz	r0, 0x700abcb6 <UART_lld_deInitDma+0x56> @ imm = #0x46
700abc6e: e7ff         	b	0x700abc70 <UART_lld_deInitDma+0x10> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700abc70: 9903         	ldr	r1, [sp, #0xc]
700abc72: 2002         	movs	r0, #0x2
700abc74: 6548         	str	r0, [r1, #0x54]
;        status = UART_lld_flushTxFifo(hUart);
700abc76: 9803         	ldr	r0, [sp, #0xc]
700abc78: f7fe fc02    	bl	0x700aa480 <UART_lld_flushTxFifo> @ imm = #-0x17fc
700abc7c: 9002         	str	r0, [sp, #0x8]
;         if(status == UART_STATUS_SUCCESS)
700abc7e: 9802         	ldr	r0, [sp, #0x8]
700abc80: b9a0         	cbnz	r0, 0x700abcac <UART_lld_deInitDma+0x4c> @ imm = #0x28
700abc82: e7ff         	b	0x700abc84 <UART_lld_deInitDma+0x24> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr,
700abc84: 9803         	ldr	r0, [sp, #0xc]
700abc86: 6800         	ldr	r0, [r0]
700abc88: 2107         	movs	r1, #0x7
700abc8a: 9101         	str	r1, [sp, #0x4]
700abc8c: f7fa fb68    	bl	0x700a6360 <UART_intrDisable> @ imm = #-0x5930
;             UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700abc90: 9803         	ldr	r0, [sp, #0xc]
700abc92: 6800         	ldr	r0, [r0]
700abc94: 2102         	movs	r1, #0x2
700abc96: f003 f883    	bl	0x700aeda0 <UART_intr2Disable> @ imm = #0x3106
700abc9a: 9901         	ldr	r1, [sp, #0x4]
;             (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700abc9c: 9803         	ldr	r0, [sp, #0xc]
700abc9e: 6800         	ldr	r0, [r0]
700abca0: f003 f8c6    	bl	0x700aee30 <UART_operatingModeSelect> @ imm = #0x318c
;             hUart->state = UART_STATE_RESET;
700abca4: 9903         	ldr	r1, [sp, #0xc]
700abca6: 2000         	movs	r0, #0x0
700abca8: 6548         	str	r0, [r1, #0x54]
;         }
700abcaa: e7ff         	b	0x700abcac <UART_lld_deInitDma+0x4c> @ imm = #-0x2
;         status = UART_lld_dmaDeInit(hUart);
700abcac: 9803         	ldr	r0, [sp, #0xc]
700abcae: f002 fa2f    	bl	0x700ae110 <UART_lld_dmaDeInit> @ imm = #0x245e
700abcb2: 9002         	str	r0, [sp, #0x8]
;     }
700abcb4: e003         	b	0x700abcbe <UART_lld_deInitDma+0x5e> @ imm = #0x6
700abcb6: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700abcba: 9002         	str	r0, [sp, #0x8]
700abcbc: e7ff         	b	0x700abcbe <UART_lld_deInitDma+0x5e> @ imm = #-0x2
;     return status;
700abcbe: 9802         	ldr	r0, [sp, #0x8]
700abcc0: b004         	add	sp, #0x10
700abcc2: bd80         	pop	{r7, pc}
		...

700abcd0 <Udma_rmFreeEvent>:
; {
700abcd0: b580         	push	{r7, lr}
700abcd2: b088         	sub	sp, #0x20
700abcd4: 9007         	str	r0, [sp, #0x1c]
700abcd6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abcd8: 9806         	ldr	r0, [sp, #0x18]
700abcda: f500 70ea    	add.w	r0, r0, #0x1d4
700abcde: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abce0: 9806         	ldr	r0, [sp, #0x18]
700abce2: f500 609f    	add.w	r0, r0, #0x4f8
700abce6: f04f 31ff    	mov.w	r1, #0xffffffff
700abcea: f7fe fd79    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #-0x150e
;     i = globalEvent - rmInitPrms->startGlobalEvent;
700abcee: 9807         	ldr	r0, [sp, #0x1c]
700abcf0: 9901         	ldr	r1, [sp, #0x4]
700abcf2: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700abcf6: 1a40         	subs	r0, r0, r1
700abcf8: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abcfa: 9805         	ldr	r0, [sp, #0x14]
700abcfc: 0940         	lsrs	r0, r0, #0x5
700abcfe: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abd00: 9805         	ldr	r0, [sp, #0x14]
700abd02: 9904         	ldr	r1, [sp, #0x10]
700abd04: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abd08: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abd0a: 9903         	ldr	r1, [sp, #0xc]
700abd0c: 2001         	movs	r0, #0x1
700abd0e: 4088         	lsls	r0, r1
700abd10: 9002         	str	r0, [sp, #0x8]
;     drvHandle->globalEventFlag[offset] |= bitMask;
700abd12: 9a02         	ldr	r2, [sp, #0x8]
700abd14: 9806         	ldr	r0, [sp, #0x18]
700abd16: 9904         	ldr	r1, [sp, #0x10]
700abd18: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abd1c: f8d1 0424    	ldr.w	r0, [r1, #0x424]
700abd20: 4310         	orrs	r0, r2
700abd22: f8c1 0424    	str.w	r0, [r1, #0x424]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abd26: 9806         	ldr	r0, [sp, #0x18]
700abd28: f500 609f    	add.w	r0, r0, #0x4f8
700abd2c: f000 f8e8    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x1d0
;     return;
700abd30: b008         	add	sp, #0x20
700abd32: bd80         	pop	{r7, pc}
		...

700abd40 <Udma_rmFreeIrIntr>:
; {
700abd40: b580         	push	{r7, lr}
700abd42: b088         	sub	sp, #0x20
700abd44: 9007         	str	r0, [sp, #0x1c]
700abd46: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abd48: 9806         	ldr	r0, [sp, #0x18]
700abd4a: f500 70ea    	add.w	r0, r0, #0x1d4
700abd4e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abd50: 9806         	ldr	r0, [sp, #0x18]
700abd52: f500 609f    	add.w	r0, r0, #0x4f8
700abd56: f04f 31ff    	mov.w	r1, #0xffffffff
700abd5a: f7fe fd41    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #-0x157e
;     i = irIntrNum - rmInitPrms->startIrIntr;
700abd5e: 9807         	ldr	r0, [sp, #0x1c]
700abd60: 9901         	ldr	r1, [sp, #0x4]
700abd62: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700abd66: 1a40         	subs	r0, r0, r1
700abd68: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abd6a: 9805         	ldr	r0, [sp, #0x14]
700abd6c: 0940         	lsrs	r0, r0, #0x5
700abd6e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abd70: 9805         	ldr	r0, [sp, #0x14]
700abd72: 9904         	ldr	r1, [sp, #0x10]
700abd74: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abd78: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abd7a: 9903         	ldr	r1, [sp, #0xc]
700abd7c: 2001         	movs	r0, #0x1
700abd7e: 4088         	lsls	r0, r1
700abd80: 9002         	str	r0, [sp, #0x8]
;     drvHandle->irIntrFlag[offset] |= bitMask;
700abd82: 9a02         	ldr	r2, [sp, #0x8]
700abd84: 9806         	ldr	r0, [sp, #0x18]
700abd86: 9904         	ldr	r1, [sp, #0x10]
700abd88: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abd8c: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700abd90: 4310         	orrs	r0, r2
700abd92: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abd96: 9806         	ldr	r0, [sp, #0x18]
700abd98: f500 609f    	add.w	r0, r0, #0x4f8
700abd9c: f000 f8b0    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0x160
;     return;
700abda0: b008         	add	sp, #0x20
700abda2: bd80         	pop	{r7, pc}
		...

700abdb0 <Udma_rmFreeVintr>:
; {
700abdb0: b580         	push	{r7, lr}
700abdb2: b088         	sub	sp, #0x20
700abdb4: 9007         	str	r0, [sp, #0x1c]
700abdb6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abdb8: 9806         	ldr	r0, [sp, #0x18]
700abdba: f500 70ea    	add.w	r0, r0, #0x1d4
700abdbe: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abdc0: 9806         	ldr	r0, [sp, #0x18]
700abdc2: f500 609f    	add.w	r0, r0, #0x4f8
700abdc6: f04f 31ff    	mov.w	r1, #0xffffffff
700abdca: f7fe fd09    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #-0x15ee
;     i = vintrNum - rmInitPrms->startVintr;
700abdce: 9807         	ldr	r0, [sp, #0x1c]
700abdd0: 9901         	ldr	r1, [sp, #0x4]
700abdd2: f8d1 10e0    	ldr.w	r1, [r1, #0xe0]
700abdd6: 1a40         	subs	r0, r0, r1
700abdd8: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abdda: 9805         	ldr	r0, [sp, #0x14]
700abddc: 0940         	lsrs	r0, r0, #0x5
700abdde: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abde0: 9805         	ldr	r0, [sp, #0x14]
700abde2: 9904         	ldr	r1, [sp, #0x10]
700abde4: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abde8: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abdea: 9903         	ldr	r1, [sp, #0xc]
700abdec: 2001         	movs	r0, #0x1
700abdee: 4088         	lsls	r0, r1
700abdf0: 9002         	str	r0, [sp, #0x8]
;     drvHandle->vintrFlag[offset] |= bitMask;
700abdf2: 9a02         	ldr	r2, [sp, #0x8]
700abdf4: 9806         	ldr	r0, [sp, #0x18]
700abdf6: 9904         	ldr	r1, [sp, #0x10]
700abdf8: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abdfc: f8d1 04a4    	ldr.w	r0, [r1, #0x4a4]
700abe00: 4310         	orrs	r0, r2
700abe02: f8c1 04a4    	str.w	r0, [r1, #0x4a4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abe06: 9806         	ldr	r0, [sp, #0x18]
700abe08: f500 609f    	add.w	r0, r0, #0x4f8
700abe0c: f000 f878    	bl	0x700abf00 <SemaphoreP_post> @ imm = #0xf0
;     return;
700abe10: b008         	add	sp, #0x20
700abe12: bd80         	pop	{r7, pc}
		...

700abe20 <vApplicationLoadHook>:
; {
700abe20: b580         	push	{r7, lr}
700abe22: b082         	sub	sp, #0x8
;     uint64_t curUpdateTime = ClockP_getTimeUsec();
700abe24: f7fe feb4    	bl	0x700aab90 <ClockP_getTimeUsec> @ imm = #-0x1298
700abe28: 9101         	str	r1, [sp, #0x4]
700abe2a: 9000         	str	r0, [sp]
;     if( (curUpdateTime > lastUpdateTime) && ((curUpdateTime - lastUpdateTime) > (TaskP_LOAD_UPDATE_WINDOW_MSEC*1000u )) )
700abe2c: 9b00         	ldr	r3, [sp]
700abe2e: 9901         	ldr	r1, [sp, #0x4]
700abe30: f642 10c8    	movw	r0, #0x29c8
700abe34: f2c7 000b    	movt	r0, #0x700b
700abe38: 6802         	ldr	r2, [r0]
700abe3a: 6840         	ldr	r0, [r0, #0x4]
700abe3c: 1ad2         	subs	r2, r2, r3
700abe3e: 4188         	sbcs	r0, r1
700abe40: d21e         	bhs	0x700abe80 <vApplicationLoadHook+0x60> @ imm = #0x3c
700abe42: e7ff         	b	0x700abe44 <vApplicationLoadHook+0x24> @ imm = #-0x2
700abe44: 9900         	ldr	r1, [sp]
700abe46: 9801         	ldr	r0, [sp, #0x4]
700abe48: f642 12c8    	movw	r2, #0x29c8
700abe4c: f2c7 020b    	movt	r2, #0x700b
700abe50: 6813         	ldr	r3, [r2]
700abe52: 6852         	ldr	r2, [r2, #0x4]
700abe54: 1ac9         	subs	r1, r1, r3
700abe56: 4190         	sbcs	r0, r2
700abe58: f24a 1221    	movw	r2, #0xa121
700abe5c: f2c0 0207    	movt	r2, #0x7
700abe60: 1a89         	subs	r1, r1, r2
700abe62: f170 0000    	sbcs	r0, r0, #0x0
700abe66: d30b         	blo	0x700abe80 <vApplicationLoadHook+0x60> @ imm = #0x16
700abe68: e7ff         	b	0x700abe6a <vApplicationLoadHook+0x4a> @ imm = #-0x2
;         TaskP_loadUpdateAll();
700abe6a: f7f8 fcd9    	bl	0x700a4820 <TaskP_loadUpdateAll> @ imm = #-0x764e
;         lastUpdateTime = curUpdateTime;
700abe6e: 9800         	ldr	r0, [sp]
700abe70: 9a01         	ldr	r2, [sp, #0x4]
700abe72: f642 11c8    	movw	r1, #0x29c8
700abe76: f2c7 010b    	movt	r1, #0x700b
700abe7a: 604a         	str	r2, [r1, #0x4]
700abe7c: 6008         	str	r0, [r1]
;     }
700abe7e: e7ff         	b	0x700abe80 <vApplicationLoadHook+0x60> @ imm = #-0x2
; }
700abe80: b002         	add	sp, #0x8
700abe82: bd80         	pop	{r7, pc}
		...

700abe90 <vQueueWaitForMessageRestricted>:
;     {
700abe90: b580         	push	{r7, lr}
700abe92: b084         	sub	sp, #0x10
700abe94: 9003         	str	r0, [sp, #0xc]
700abe96: 9102         	str	r1, [sp, #0x8]
700abe98: 9201         	str	r2, [sp, #0x4]
;         Queue_t * const pxQueue = xQueue;
700abe9a: 9803         	ldr	r0, [sp, #0xc]
700abe9c: 9000         	str	r0, [sp]
;         prvLockQueue( pxQueue );
700abe9e: f002 fc6f    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0x28de
700abea2: 9800         	ldr	r0, [sp]
700abea4: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700abea8: 3001         	adds	r0, #0x1
700abeaa: b928         	cbnz	r0, 0x700abeb8 <vQueueWaitForMessageRestricted+0x28> @ imm = #0xa
700abeac: e7ff         	b	0x700abeae <vQueueWaitForMessageRestricted+0x1e> @ imm = #-0x2
700abeae: 9900         	ldr	r1, [sp]
700abeb0: 2000         	movs	r0, #0x0
700abeb2: f881 0044    	strb.w	r0, [r1, #0x44]
700abeb6: e7ff         	b	0x700abeb8 <vQueueWaitForMessageRestricted+0x28> @ imm = #-0x2
700abeb8: 9800         	ldr	r0, [sp]
700abeba: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700abebe: 3001         	adds	r0, #0x1
700abec0: b928         	cbnz	r0, 0x700abece <vQueueWaitForMessageRestricted+0x3e> @ imm = #0xa
700abec2: e7ff         	b	0x700abec4 <vQueueWaitForMessageRestricted+0x34> @ imm = #-0x2
700abec4: 9900         	ldr	r1, [sp]
700abec6: 2000         	movs	r0, #0x0
700abec8: f881 0045    	strb.w	r0, [r1, #0x45]
700abecc: e7ff         	b	0x700abece <vQueueWaitForMessageRestricted+0x3e> @ imm = #-0x2
700abece: f001 fd17    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0x1a2e
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
700abed2: 9800         	ldr	r0, [sp]
700abed4: 6b80         	ldr	r0, [r0, #0x38]
700abed6: b938         	cbnz	r0, 0x700abee8 <vQueueWaitForMessageRestricted+0x58> @ imm = #0xe
700abed8: e7ff         	b	0x700abeda <vQueueWaitForMessageRestricted+0x4a> @ imm = #-0x2
;             vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
700abeda: 9800         	ldr	r0, [sp]
700abedc: 3024         	adds	r0, #0x24
700abede: 9902         	ldr	r1, [sp, #0x8]
700abee0: 9a01         	ldr	r2, [sp, #0x4]
700abee2: f002 fad5    	bl	0x700ae490 <vTaskPlaceOnEventListRestricted> @ imm = #0x25aa
;         }
700abee6: e000         	b	0x700abeea <vQueueWaitForMessageRestricted+0x5a> @ imm = #0x0
700abee8: e7ff         	b	0x700abeea <vQueueWaitForMessageRestricted+0x5a> @ imm = #-0x2
;         prvUnlockQueue( pxQueue );
700abeea: 9800         	ldr	r0, [sp]
700abeec: f7fb ffd8    	bl	0x700a7ea0 <prvUnlockQueue> @ imm = #-0x4050
;     }
700abef0: b004         	add	sp, #0x10
700abef2: bd80         	pop	{r7, pc}
		...

700abf00 <SemaphoreP_post>:
; {
700abf00: b580         	push	{r7, lr}
700abf02: b084         	sub	sp, #0x10
700abf04: 9003         	str	r0, [sp, #0xc]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700abf06: 9803         	ldr	r0, [sp, #0xc]
700abf08: 9002         	str	r0, [sp, #0x8]
;     if(pSemaphore->isRecursiveMutex != 0U)
700abf0a: 9802         	ldr	r0, [sp, #0x8]
700abf0c: 6d40         	ldr	r0, [r0, #0x54]
700abf0e: b170         	cbz	r0, 0x700abf2e <SemaphoreP_post+0x2e> @ imm = #0x1c
700abf10: e7ff         	b	0x700abf12 <SemaphoreP_post+0x12> @ imm = #-0x2
;         if( HwiP_inISR() == 0U)
700abf12: f004 fa45    	bl	0x700b03a0 <HwiP_inISR> @ imm = #0x448a
700abf16: b928         	cbnz	r0, 0x700abf24 <SemaphoreP_post+0x24> @ imm = #0xa
700abf18: e7ff         	b	0x700abf1a <SemaphoreP_post+0x1a> @ imm = #-0x2
;             (void)xSemaphoreGiveRecursive(pSemaphore->semHndl);
700abf1a: 9802         	ldr	r0, [sp, #0x8]
700abf1c: 6d00         	ldr	r0, [r0, #0x50]
700abf1e: f001 f95f    	bl	0x700ad1e0 <xQueueGiveMutexRecursive> @ imm = #0x12be
;         }
700abf22: e003         	b	0x700abf2c <SemaphoreP_post+0x2c> @ imm = #0x6
700abf24: 2000         	movs	r0, #0x0
;             DebugP_assertNoLog(0);
700abf26: f005 f9db    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x53b6
700abf2a: e7ff         	b	0x700abf2c <SemaphoreP_post+0x2c> @ imm = #-0x2
;     }
700abf2c: e017         	b	0x700abf5e <SemaphoreP_post+0x5e> @ imm = #0x2e
;         if( HwiP_inISR() != 0U)
700abf2e: f004 fa37    	bl	0x700b03a0 <HwiP_inISR> @ imm = #0x446e
700abf32: b158         	cbz	r0, 0x700abf4c <SemaphoreP_post+0x4c> @ imm = #0x16
700abf34: e7ff         	b	0x700abf36 <SemaphoreP_post+0x36> @ imm = #-0x2
700abf36: 2000         	movs	r0, #0x0
;             BaseType_t xHigherPriorityTaskWoken = 0;
700abf38: 9001         	str	r0, [sp, #0x4]
;             (void)xSemaphoreGiveFromISR(pSemaphore->semHndl, &xHigherPriorityTaskWoken);
700abf3a: 9802         	ldr	r0, [sp, #0x8]
700abf3c: 6d00         	ldr	r0, [r0, #0x50]
700abf3e: a901         	add	r1, sp, #0x4
700abf40: f7fd fdae    	bl	0x700a9aa0 <xQueueGiveFromISR> @ imm = #-0x24a4
;             portYIELD_FROM_ISR((uint32_t)xHigherPriorityTaskWoken);
700abf44: 9801         	ldr	r0, [sp, #0x4]
700abf46: f003 fb53    	bl	0x700af5f0 <vPortYeildFromISR> @ imm = #0x36a6
;         }
700abf4a: e007         	b	0x700abf5c <SemaphoreP_post+0x5c> @ imm = #0xe
;             (void)xSemaphoreGive(pSemaphore->semHndl);
700abf4c: 9802         	ldr	r0, [sp, #0x8]
700abf4e: 6d00         	ldr	r0, [r0, #0x50]
700abf50: 2300         	movs	r3, #0x0
700abf52: 4619         	mov	r1, r3
700abf54: 461a         	mov	r2, r3
700abf56: f7f7 f9d3    	bl	0x700a3300 <xQueueGenericSend> @ imm = #-0x8c5a
700abf5a: e7ff         	b	0x700abf5c <SemaphoreP_post+0x5c> @ imm = #-0x2
700abf5c: e7ff         	b	0x700abf5e <SemaphoreP_post+0x5e> @ imm = #-0x2
; }
700abf5e: b004         	add	sp, #0x10
700abf60: bd80         	pop	{r7, pc}
		...
700abf6e: 0000         	movs	r0, r0

700abf70 <UdmaEventPrms_init>:
; {
700abf70: b082         	sub	sp, #0x8
700abf72: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != eventPrms)
700abf74: 9801         	ldr	r0, [sp, #0x4]
700abf76: b350         	cbz	r0, 0x700abfce <UdmaEventPrms_init+0x5e> @ imm = #0x54
700abf78: e7ff         	b	0x700abf7a <UdmaEventPrms_init+0xa> @ imm = #-0x2
;         eventPrms->eventType            = UDMA_EVENT_TYPE_DMA_COMPLETION;
700abf7a: 9801         	ldr	r0, [sp, #0x4]
700abf7c: 2101         	movs	r1, #0x1
700abf7e: 6001         	str	r1, [r0]
;         eventPrms->eventMode            = UDMA_EVENT_MODE_SHARED;
700abf80: 9a01         	ldr	r2, [sp, #0x4]
700abf82: 2002         	movs	r0, #0x2
700abf84: 6050         	str	r0, [r2, #0x4]
;         eventPrms->chHandle             = (Udma_ChHandle) NULL_PTR;
700abf86: 9a01         	ldr	r2, [sp, #0x4]
700abf88: 2000         	movs	r0, #0x0
700abf8a: 9000         	str	r0, [sp]
700abf8c: 6090         	str	r0, [r2, #0x8]
;         eventPrms->ringHandle           = (Udma_RingHandle) NULL_PTR;
700abf8e: 9a01         	ldr	r2, [sp, #0x4]
700abf90: 60d0         	str	r0, [r2, #0xc]
;         eventPrms->controllerEventHandle    = (Udma_EventHandle) NULL_PTR;
700abf92: 9a01         	ldr	r2, [sp, #0x4]
700abf94: 6110         	str	r0, [r2, #0x10]
;         eventPrms->eventCb              = (Udma_EventCallback) NULL_PTR;
700abf96: 9a01         	ldr	r2, [sp, #0x4]
700abf98: 6150         	str	r0, [r2, #0x14]
;         eventPrms->intrPriority         = 1U;
700abf9a: 9a01         	ldr	r2, [sp, #0x4]
700abf9c: 6191         	str	r1, [r2, #0x18]
;         eventPrms->appData              = NULL_PTR;
700abf9e: 9901         	ldr	r1, [sp, #0x4]
700abfa0: 61c8         	str	r0, [r1, #0x1c]
;         eventPrms->preferredCoreIntrNum = UDMA_CORE_INTR_ANY;
700abfa2: 9a01         	ldr	r2, [sp, #0x4]
700abfa4: 2101         	movs	r1, #0x1
700abfa6: f6cf 71ff    	movt	r1, #0xffff
700abfaa: 6211         	str	r1, [r2, #0x20]
;         eventPrms->intrStatusReg        = (volatile uint64_t *) NULL_PTR;
700abfac: 9901         	ldr	r1, [sp, #0x4]
700abfae: 6248         	str	r0, [r1, #0x24]
;         eventPrms->intrClearReg         = (volatile uint64_t *) NULL_PTR;
700abfb0: 9901         	ldr	r1, [sp, #0x4]
700abfb2: 6288         	str	r0, [r1, #0x28]
;         eventPrms->intrMask             = 0U;
700abfb4: 9901         	ldr	r1, [sp, #0x4]
700abfb6: 6348         	str	r0, [r1, #0x34]
700abfb8: 6308         	str	r0, [r1, #0x30]
;         eventPrms->vintrNum             = UDMA_EVENT_INVALID;
700abfba: 9901         	ldr	r1, [sp, #0x4]
700abfbc: f64f 70ff    	movw	r0, #0xffff
700abfc0: 6388         	str	r0, [r1, #0x38]
;         eventPrms->coreIntrNum          = UDMA_INTR_INVALID;
700abfc2: 9901         	ldr	r1, [sp, #0x4]
700abfc4: 2000         	movs	r0, #0x0
700abfc6: f6cf 70ff    	movt	r0, #0xffff
700abfca: 63c8         	str	r0, [r1, #0x3c]
;     }
700abfcc: e7ff         	b	0x700abfce <UdmaEventPrms_init+0x5e> @ imm = #-0x2
;     return;
700abfce: b002         	add	sp, #0x8
700abfd0: 4770         	bx	lr
		...
700abfde: 0000         	movs	r0, r0

700abfe0 <Udma_rmFreeBlkCopyCh>:
; {
700abfe0: b580         	push	{r7, lr}
700abfe2: b088         	sub	sp, #0x20
700abfe4: 9007         	str	r0, [sp, #0x1c]
700abfe6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abfe8: 9806         	ldr	r0, [sp, #0x18]
700abfea: f500 70ea    	add.w	r0, r0, #0x1d4
700abfee: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abff0: 9806         	ldr	r0, [sp, #0x18]
700abff2: f500 609f    	add.w	r0, r0, #0x4f8
700abff6: f04f 31ff    	mov.w	r1, #0xffffffff
700abffa: f7fe fbf1    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #-0x181e
;     i = chNum - rmInitPrms->startBlkCopyCh;
700abffe: 9807         	ldr	r0, [sp, #0x1c]
700ac000: 9901         	ldr	r1, [sp, #0x4]
700ac002: 6909         	ldr	r1, [r1, #0x10]
700ac004: 1a40         	subs	r0, r0, r1
700ac006: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac008: 9805         	ldr	r0, [sp, #0x14]
700ac00a: 0940         	lsrs	r0, r0, #0x5
700ac00c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac00e: 9805         	ldr	r0, [sp, #0x14]
700ac010: 9904         	ldr	r1, [sp, #0x10]
700ac012: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac016: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac018: 9903         	ldr	r1, [sp, #0xc]
700ac01a: 2001         	movs	r0, #0x1
700ac01c: 4088         	lsls	r0, r1
700ac01e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyChFlag[offset] |= bitMask;
700ac020: 9a02         	ldr	r2, [sp, #0x8]
700ac022: 9806         	ldr	r0, [sp, #0x18]
700ac024: 9904         	ldr	r1, [sp, #0x10]
700ac026: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac02a: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700ac02e: 4310         	orrs	r0, r2
700ac030: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac034: 9806         	ldr	r0, [sp, #0x18]
700ac036: f500 609f    	add.w	r0, r0, #0x4f8
700ac03a: f7ff ff61    	bl	0x700abf00 <SemaphoreP_post> @ imm = #-0x13e
;     return;
700ac03e: b008         	add	sp, #0x20
700ac040: bd80         	pop	{r7, pc}
		...
700ac04e: 0000         	movs	r0, r0

700ac050 <Udma_rmFreeBlkCopyHcCh>:
; {
700ac050: b580         	push	{r7, lr}
700ac052: b088         	sub	sp, #0x20
700ac054: 9007         	str	r0, [sp, #0x1c]
700ac056: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac058: 9806         	ldr	r0, [sp, #0x18]
700ac05a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac05e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac060: 9806         	ldr	r0, [sp, #0x18]
700ac062: f500 609f    	add.w	r0, r0, #0x4f8
700ac066: f04f 31ff    	mov.w	r1, #0xffffffff
700ac06a: f7fe fbb9    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #-0x188e
;     i = chNum - rmInitPrms->startBlkCopyHcCh;
700ac06e: 9807         	ldr	r0, [sp, #0x1c]
700ac070: 9901         	ldr	r1, [sp, #0x4]
700ac072: 6889         	ldr	r1, [r1, #0x8]
700ac074: 1a40         	subs	r0, r0, r1
700ac076: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac078: 9805         	ldr	r0, [sp, #0x14]
700ac07a: 0940         	lsrs	r0, r0, #0x5
700ac07c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac07e: 9805         	ldr	r0, [sp, #0x14]
700ac080: 9904         	ldr	r1, [sp, #0x10]
700ac082: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac086: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac088: 9903         	ldr	r1, [sp, #0xc]
700ac08a: 2001         	movs	r0, #0x1
700ac08c: 4088         	lsls	r0, r1
700ac08e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyHcChFlag[offset] |= bitMask;
700ac090: 9a02         	ldr	r2, [sp, #0x8]
700ac092: 9806         	ldr	r0, [sp, #0x18]
700ac094: 9904         	ldr	r1, [sp, #0x10]
700ac096: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac09a: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700ac09e: 4310         	orrs	r0, r2
700ac0a0: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac0a4: 9806         	ldr	r0, [sp, #0x18]
700ac0a6: f500 609f    	add.w	r0, r0, #0x4f8
700ac0aa: f7ff ff29    	bl	0x700abf00 <SemaphoreP_post> @ imm = #-0x1ae
;     return;
700ac0ae: b008         	add	sp, #0x20
700ac0b0: bd80         	pop	{r7, pc}
		...
700ac0be: 0000         	movs	r0, r0

700ac0c0 <Udma_rmFreeBlkCopyUhcCh>:
; {
700ac0c0: b580         	push	{r7, lr}
700ac0c2: b088         	sub	sp, #0x20
700ac0c4: 9007         	str	r0, [sp, #0x1c]
700ac0c6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac0c8: 9806         	ldr	r0, [sp, #0x18]
700ac0ca: f500 70ea    	add.w	r0, r0, #0x1d4
700ac0ce: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac0d0: 9806         	ldr	r0, [sp, #0x18]
700ac0d2: f500 609f    	add.w	r0, r0, #0x4f8
700ac0d6: f04f 31ff    	mov.w	r1, #0xffffffff
700ac0da: f7fe fb81    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #-0x18fe
;     i = chNum - rmInitPrms->startBlkCopyUhcCh;
700ac0de: 9807         	ldr	r0, [sp, #0x1c]
700ac0e0: 9901         	ldr	r1, [sp, #0x4]
700ac0e2: 6809         	ldr	r1, [r1]
700ac0e4: 1a40         	subs	r0, r0, r1
700ac0e6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac0e8: 9805         	ldr	r0, [sp, #0x14]
700ac0ea: 0940         	lsrs	r0, r0, #0x5
700ac0ec: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac0ee: 9805         	ldr	r0, [sp, #0x14]
700ac0f0: 9904         	ldr	r1, [sp, #0x10]
700ac0f2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac0f6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac0f8: 9903         	ldr	r1, [sp, #0xc]
700ac0fa: 2001         	movs	r0, #0x1
700ac0fc: 4088         	lsls	r0, r1
700ac0fe: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyUhcChFlag[offset] |= bitMask;
700ac100: 9a02         	ldr	r2, [sp, #0x8]
700ac102: 9806         	ldr	r0, [sp, #0x18]
700ac104: 9904         	ldr	r1, [sp, #0x10]
700ac106: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac10a: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700ac10e: 4310         	orrs	r0, r2
700ac110: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac114: 9806         	ldr	r0, [sp, #0x18]
700ac116: f500 609f    	add.w	r0, r0, #0x4f8
700ac11a: f7ff fef1    	bl	0x700abf00 <SemaphoreP_post> @ imm = #-0x21e
;     return;
700ac11e: b008         	add	sp, #0x20
700ac120: bd80         	pop	{r7, pc}
		...
700ac12e: 0000         	movs	r0, r0

700ac130 <Udma_rmFreeRxCh>:
; {
700ac130: b580         	push	{r7, lr}
700ac132: b088         	sub	sp, #0x20
700ac134: 9007         	str	r0, [sp, #0x1c]
700ac136: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac138: 9806         	ldr	r0, [sp, #0x18]
700ac13a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac13e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac140: 9806         	ldr	r0, [sp, #0x18]
700ac142: f500 609f    	add.w	r0, r0, #0x4f8
700ac146: f04f 31ff    	mov.w	r1, #0xffffffff
700ac14a: f7fe fb49    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #-0x196e
;     i = chNum - rmInitPrms->startRxCh;
700ac14e: 9807         	ldr	r0, [sp, #0x1c]
700ac150: 9901         	ldr	r1, [sp, #0x4]
700ac152: 6c09         	ldr	r1, [r1, #0x40]
700ac154: 1a40         	subs	r0, r0, r1
700ac156: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac158: 9805         	ldr	r0, [sp, #0x14]
700ac15a: 0940         	lsrs	r0, r0, #0x5
700ac15c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac15e: 9805         	ldr	r0, [sp, #0x14]
700ac160: 9904         	ldr	r1, [sp, #0x10]
700ac162: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac166: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac168: 9903         	ldr	r1, [sp, #0xc]
700ac16a: 2001         	movs	r0, #0x1
700ac16c: 4088         	lsls	r0, r1
700ac16e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxChFlag[offset] |= bitMask;
700ac170: 9a02         	ldr	r2, [sp, #0x8]
700ac172: 9806         	ldr	r0, [sp, #0x18]
700ac174: 9904         	ldr	r1, [sp, #0x10]
700ac176: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac17a: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700ac17e: 4310         	orrs	r0, r2
700ac180: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac184: 9806         	ldr	r0, [sp, #0x18]
700ac186: f500 609f    	add.w	r0, r0, #0x4f8
700ac18a: f7ff feb9    	bl	0x700abf00 <SemaphoreP_post> @ imm = #-0x28e
;     return;
700ac18e: b008         	add	sp, #0x20
700ac190: bd80         	pop	{r7, pc}
		...
700ac19e: 0000         	movs	r0, r0

700ac1a0 <Udma_rmFreeRxHcCh>:
; {
700ac1a0: b580         	push	{r7, lr}
700ac1a2: b088         	sub	sp, #0x20
700ac1a4: 9007         	str	r0, [sp, #0x1c]
700ac1a6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac1a8: 9806         	ldr	r0, [sp, #0x18]
700ac1aa: f500 70ea    	add.w	r0, r0, #0x1d4
700ac1ae: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac1b0: 9806         	ldr	r0, [sp, #0x18]
700ac1b2: f500 609f    	add.w	r0, r0, #0x4f8
700ac1b6: f04f 31ff    	mov.w	r1, #0xffffffff
700ac1ba: f7fe fb11    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #-0x19de
;     i = chNum - rmInitPrms->startRxHcCh;
700ac1be: 9807         	ldr	r0, [sp, #0x1c]
700ac1c0: 9901         	ldr	r1, [sp, #0x4]
700ac1c2: 6b89         	ldr	r1, [r1, #0x38]
700ac1c4: 1a40         	subs	r0, r0, r1
700ac1c6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac1c8: 9805         	ldr	r0, [sp, #0x14]
700ac1ca: 0940         	lsrs	r0, r0, #0x5
700ac1cc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac1ce: 9805         	ldr	r0, [sp, #0x14]
700ac1d0: 9904         	ldr	r1, [sp, #0x10]
700ac1d2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac1d6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac1d8: 9903         	ldr	r1, [sp, #0xc]
700ac1da: 2001         	movs	r0, #0x1
700ac1dc: 4088         	lsls	r0, r1
700ac1de: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxHcChFlag[offset] |= bitMask;
700ac1e0: 9a02         	ldr	r2, [sp, #0x8]
700ac1e2: 9806         	ldr	r0, [sp, #0x18]
700ac1e4: 9904         	ldr	r1, [sp, #0x10]
700ac1e6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac1ea: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700ac1ee: 4310         	orrs	r0, r2
700ac1f0: f8c1 031c    	str.w	r0, [r1, #0x31c]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac1f4: 9806         	ldr	r0, [sp, #0x18]
700ac1f6: f500 609f    	add.w	r0, r0, #0x4f8
700ac1fa: f7ff fe81    	bl	0x700abf00 <SemaphoreP_post> @ imm = #-0x2fe
;     return;
700ac1fe: b008         	add	sp, #0x20
700ac200: bd80         	pop	{r7, pc}
		...
700ac20e: 0000         	movs	r0, r0

700ac210 <Udma_rmFreeRxUhcCh>:
; {
700ac210: b580         	push	{r7, lr}
700ac212: b088         	sub	sp, #0x20
700ac214: 9007         	str	r0, [sp, #0x1c]
700ac216: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac218: 9806         	ldr	r0, [sp, #0x18]
700ac21a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac21e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac220: 9806         	ldr	r0, [sp, #0x18]
700ac222: f500 609f    	add.w	r0, r0, #0x4f8
700ac226: f04f 31ff    	mov.w	r1, #0xffffffff
700ac22a: f7fe fad9    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #-0x1a4e
;     i = chNum - rmInitPrms->startRxUhcCh;
700ac22e: 9807         	ldr	r0, [sp, #0x1c]
700ac230: 9901         	ldr	r1, [sp, #0x4]
700ac232: 6b09         	ldr	r1, [r1, #0x30]
700ac234: 1a40         	subs	r0, r0, r1
700ac236: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac238: 9805         	ldr	r0, [sp, #0x14]
700ac23a: 0940         	lsrs	r0, r0, #0x5
700ac23c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac23e: 9805         	ldr	r0, [sp, #0x14]
700ac240: 9904         	ldr	r1, [sp, #0x10]
700ac242: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac246: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac248: 9903         	ldr	r1, [sp, #0xc]
700ac24a: 2001         	movs	r0, #0x1
700ac24c: 4088         	lsls	r0, r1
700ac24e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxUhcChFlag[offset] |= bitMask;
700ac250: 9a02         	ldr	r2, [sp, #0x8]
700ac252: 9806         	ldr	r0, [sp, #0x18]
700ac254: 9904         	ldr	r1, [sp, #0x10]
700ac256: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac25a: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700ac25e: 4310         	orrs	r0, r2
700ac260: f8c1 0320    	str.w	r0, [r1, #0x320]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac264: 9806         	ldr	r0, [sp, #0x18]
700ac266: f500 609f    	add.w	r0, r0, #0x4f8
700ac26a: f7ff fe49    	bl	0x700abf00 <SemaphoreP_post> @ imm = #-0x36e
;     return;
700ac26e: b008         	add	sp, #0x20
700ac270: bd80         	pop	{r7, pc}
		...
700ac27e: 0000         	movs	r0, r0

700ac280 <Udma_rmFreeTxCh>:
; {
700ac280: b580         	push	{r7, lr}
700ac282: b088         	sub	sp, #0x20
700ac284: 9007         	str	r0, [sp, #0x1c]
700ac286: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac288: 9806         	ldr	r0, [sp, #0x18]
700ac28a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac28e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac290: 9806         	ldr	r0, [sp, #0x18]
700ac292: f500 609f    	add.w	r0, r0, #0x4f8
700ac296: f04f 31ff    	mov.w	r1, #0xffffffff
700ac29a: f7fe faa1    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #-0x1abe
;     i = chNum - rmInitPrms->startTxCh;
700ac29e: 9807         	ldr	r0, [sp, #0x1c]
700ac2a0: 9901         	ldr	r1, [sp, #0x4]
700ac2a2: 6a89         	ldr	r1, [r1, #0x28]
700ac2a4: 1a40         	subs	r0, r0, r1
700ac2a6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac2a8: 9805         	ldr	r0, [sp, #0x14]
700ac2aa: 0940         	lsrs	r0, r0, #0x5
700ac2ac: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac2ae: 9805         	ldr	r0, [sp, #0x14]
700ac2b0: 9904         	ldr	r1, [sp, #0x10]
700ac2b2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac2b6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac2b8: 9903         	ldr	r1, [sp, #0xc]
700ac2ba: 2001         	movs	r0, #0x1
700ac2bc: 4088         	lsls	r0, r1
700ac2be: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txChFlag[offset] |= bitMask;
700ac2c0: 9a02         	ldr	r2, [sp, #0x8]
700ac2c2: 9806         	ldr	r0, [sp, #0x18]
700ac2c4: 9904         	ldr	r1, [sp, #0x10]
700ac2c6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac2ca: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700ac2ce: 4310         	orrs	r0, r2
700ac2d0: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac2d4: 9806         	ldr	r0, [sp, #0x18]
700ac2d6: f500 609f    	add.w	r0, r0, #0x4f8
700ac2da: f7ff fe11    	bl	0x700abf00 <SemaphoreP_post> @ imm = #-0x3de
;     return;
700ac2de: b008         	add	sp, #0x20
700ac2e0: bd80         	pop	{r7, pc}
		...
700ac2ee: 0000         	movs	r0, r0

700ac2f0 <Udma_rmFreeTxHcCh>:
; {
700ac2f0: b580         	push	{r7, lr}
700ac2f2: b088         	sub	sp, #0x20
700ac2f4: 9007         	str	r0, [sp, #0x1c]
700ac2f6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac2f8: 9806         	ldr	r0, [sp, #0x18]
700ac2fa: f500 70ea    	add.w	r0, r0, #0x1d4
700ac2fe: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac300: 9806         	ldr	r0, [sp, #0x18]
700ac302: f500 609f    	add.w	r0, r0, #0x4f8
700ac306: f04f 31ff    	mov.w	r1, #0xffffffff
700ac30a: f7fe fa69    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #-0x1b2e
;     i = chNum - rmInitPrms->startTxHcCh;
700ac30e: 9807         	ldr	r0, [sp, #0x1c]
700ac310: 9901         	ldr	r1, [sp, #0x4]
700ac312: 6a09         	ldr	r1, [r1, #0x20]
700ac314: 1a40         	subs	r0, r0, r1
700ac316: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac318: 9805         	ldr	r0, [sp, #0x14]
700ac31a: 0940         	lsrs	r0, r0, #0x5
700ac31c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac31e: 9805         	ldr	r0, [sp, #0x14]
700ac320: 9904         	ldr	r1, [sp, #0x10]
700ac322: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac326: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac328: 9903         	ldr	r1, [sp, #0xc]
700ac32a: 2001         	movs	r0, #0x1
700ac32c: 4088         	lsls	r0, r1
700ac32e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txHcChFlag[offset] |= bitMask;
700ac330: 9a02         	ldr	r2, [sp, #0x8]
700ac332: 9806         	ldr	r0, [sp, #0x18]
700ac334: 9904         	ldr	r1, [sp, #0x10]
700ac336: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac33a: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700ac33e: 4310         	orrs	r0, r2
700ac340: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac344: 9806         	ldr	r0, [sp, #0x18]
700ac346: f500 609f    	add.w	r0, r0, #0x4f8
700ac34a: f7ff fdd9    	bl	0x700abf00 <SemaphoreP_post> @ imm = #-0x44e
;     return;
700ac34e: b008         	add	sp, #0x20
700ac350: bd80         	pop	{r7, pc}
		...
700ac35e: 0000         	movs	r0, r0

700ac360 <Udma_rmFreeTxUhcCh>:
; {
700ac360: b580         	push	{r7, lr}
700ac362: b088         	sub	sp, #0x20
700ac364: 9007         	str	r0, [sp, #0x1c]
700ac366: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac368: 9806         	ldr	r0, [sp, #0x18]
700ac36a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac36e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac370: 9806         	ldr	r0, [sp, #0x18]
700ac372: f500 609f    	add.w	r0, r0, #0x4f8
700ac376: f04f 31ff    	mov.w	r1, #0xffffffff
700ac37a: f7fe fa31    	bl	0x700aa7e0 <SemaphoreP_pend> @ imm = #-0x1b9e
;     i = chNum - rmInitPrms->startTxUhcCh;
700ac37e: 9807         	ldr	r0, [sp, #0x1c]
700ac380: 9901         	ldr	r1, [sp, #0x4]
700ac382: 6989         	ldr	r1, [r1, #0x18]
700ac384: 1a40         	subs	r0, r0, r1
700ac386: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac388: 9805         	ldr	r0, [sp, #0x14]
700ac38a: 0940         	lsrs	r0, r0, #0x5
700ac38c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac38e: 9805         	ldr	r0, [sp, #0x14]
700ac390: 9904         	ldr	r1, [sp, #0x10]
700ac392: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac396: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac398: 9903         	ldr	r1, [sp, #0xc]
700ac39a: 2001         	movs	r0, #0x1
700ac39c: 4088         	lsls	r0, r1
700ac39e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txUhcChFlag[offset] |= bitMask;
700ac3a0: 9a02         	ldr	r2, [sp, #0x8]
700ac3a2: 9806         	ldr	r0, [sp, #0x18]
700ac3a4: 9904         	ldr	r1, [sp, #0x10]
700ac3a6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac3aa: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700ac3ae: 4310         	orrs	r0, r2
700ac3b0: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac3b4: 9806         	ldr	r0, [sp, #0x18]
700ac3b6: f500 609f    	add.w	r0, r0, #0x4f8
700ac3ba: f7ff fda1    	bl	0x700abf00 <SemaphoreP_post> @ imm = #-0x4be
;     return;
700ac3be: b008         	add	sp, #0x20
700ac3c0: bd80         	pop	{r7, pc}
		...
700ac3ce: 0000         	movs	r0, r0

700ac3d0 <UART_getChar>:
; {
700ac3d0: b580         	push	{r7, lr}
700ac3d2: b086         	sub	sp, #0x18
700ac3d4: 9005         	str	r0, [sp, #0x14]
700ac3d6: 9104         	str	r1, [sp, #0x10]
700ac3d8: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ac3da: 9003         	str	r0, [sp, #0xc]
;     uint32_t retVal      = FALSE;
700ac3dc: 9002         	str	r0, [sp, #0x8]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ac3de: 9805         	ldr	r0, [sp, #0x14]
700ac3e0: 300c         	adds	r0, #0xc
700ac3e2: f003 fbcd    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x379a
700ac3e6: 9003         	str	r0, [sp, #0xc]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ac3e8: 9805         	ldr	r0, [sp, #0x14]
700ac3ea: 300c         	adds	r0, #0xc
700ac3ec: 9000         	str	r0, [sp]
700ac3ee: f003 fbc7    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x378e
700ac3f2: 4601         	mov	r1, r0
700ac3f4: 9800         	ldr	r0, [sp]
700ac3f6: f001 017f    	and	r1, r1, #0x7f
700ac3fa: f003 fbc9    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x3792
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700ac3fe: 9805         	ldr	r0, [sp, #0x14]
700ac400: 3014         	adds	r0, #0x14
700ac402: f003 fbbd    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x377a
;     if ((uint32_t) UART_LSR_RX_FIFO_E_RX_FIFO_E_VALUE_0 !=
700ac406: 07c0         	lsls	r0, r0, #0x1f
700ac408: b150         	cbz	r0, 0x700ac420 <UART_getChar+0x50> @ imm = #0x14
700ac40a: e7ff         	b	0x700ac40c <UART_getChar+0x3c> @ imm = #-0x2
;         uint32_t tempRetVal = HW_RD_REG32(baseAddr + UART_RHR);
700ac40c: 9805         	ldr	r0, [sp, #0x14]
700ac40e: f003 fbb7    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x376e
700ac412: 9001         	str	r0, [sp, #0x4]
;         *pChar = (uint8_t)tempRetVal;
700ac414: 9801         	ldr	r0, [sp, #0x4]
700ac416: 9904         	ldr	r1, [sp, #0x10]
700ac418: 7008         	strb	r0, [r1]
700ac41a: 2001         	movs	r0, #0x1
;         retVal = TRUE;
700ac41c: 9002         	str	r0, [sp, #0x8]
;     }
700ac41e: e7ff         	b	0x700ac420 <UART_getChar+0x50> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ac420: 9805         	ldr	r0, [sp, #0x14]
700ac422: 300c         	adds	r0, #0xc
700ac424: 9903         	ldr	r1, [sp, #0xc]
700ac426: f003 fbb3    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x3766
;     return retVal;
700ac42a: 9802         	ldr	r0, [sp, #0x8]
700ac42c: b006         	add	sp, #0x18
700ac42e: bd80         	pop	{r7, pc}

700ac430 <UART_writeData>:
; {
700ac430: b580         	push	{r7, lr}
700ac432: b086         	sub	sp, #0x18
700ac434: 9005         	str	r0, [sp, #0x14]
700ac436: 9104         	str	r1, [sp, #0x10]
;     UARTLLD_InitHandle hUartInit = hUart->hUartInit;
700ac438: 9805         	ldr	r0, [sp, #0x14]
700ac43a: 6840         	ldr	r0, [r0, #0x4]
700ac43c: 9001         	str	r0, [sp, #0x4]
;     numBytesToTransfer = writeSizeRemaining;
700ac43e: 9804         	ldr	r0, [sp, #0x10]
700ac440: 9003         	str	r0, [sp, #0xc]
;     if (numBytesToTransfer >= hUartInit->txTrigLvl)
700ac442: 9803         	ldr	r0, [sp, #0xc]
700ac444: 9901         	ldr	r1, [sp, #0x4]
700ac446: 6bc9         	ldr	r1, [r1, #0x3c]
700ac448: 4288         	cmp	r0, r1
700ac44a: d304         	blo	0x700ac456 <UART_writeData+0x26> @ imm = #0x8
700ac44c: e7ff         	b	0x700ac44e <UART_writeData+0x1e> @ imm = #-0x2
;         numBytesToTransfer = hUartInit->txTrigLvl;
700ac44e: 9801         	ldr	r0, [sp, #0x4]
700ac450: 6bc0         	ldr	r0, [r0, #0x3c]
700ac452: 9003         	str	r0, [sp, #0xc]
;     }
700ac454: e7ff         	b	0x700ac456 <UART_writeData+0x26> @ imm = #-0x2
;     numBytesToTransferred = numBytesToTransfer;
700ac456: 9803         	ldr	r0, [sp, #0xc]
700ac458: 9002         	str	r0, [sp, #0x8]
;     while (numBytesToTransfer != 0U)
700ac45a: e7ff         	b	0x700ac45c <UART_writeData+0x2c> @ imm = #-0x2
700ac45c: 9803         	ldr	r0, [sp, #0xc]
700ac45e: b190         	cbz	r0, 0x700ac486 <UART_writeData+0x56> @ imm = #0x24
700ac460: e7ff         	b	0x700ac462 <UART_writeData+0x32> @ imm = #-0x2
;         UART_putChar(hUart->baseAddr, *(const uint8_t *)hUart->writeBuf);
700ac462: 9905         	ldr	r1, [sp, #0x14]
700ac464: 6808         	ldr	r0, [r1]
700ac466: 6889         	ldr	r1, [r1, #0x8]
700ac468: 7809         	ldrb	r1, [r1]
700ac46a: f003 f981    	bl	0x700af770 <UART_putChar> @ imm = #0x3302
;         hUart->writeBuf = (const uint8_t *)hUart->writeBuf + 1U;
700ac46e: 9905         	ldr	r1, [sp, #0x14]
700ac470: 6888         	ldr	r0, [r1, #0x8]
700ac472: 3001         	adds	r0, #0x1
700ac474: 6088         	str	r0, [r1, #0x8]
;         numBytesToTransfer--;
700ac476: 9803         	ldr	r0, [sp, #0xc]
700ac478: 3801         	subs	r0, #0x1
700ac47a: 9003         	str	r0, [sp, #0xc]
;         hUart->writeCount++;
700ac47c: 9905         	ldr	r1, [sp, #0x14]
700ac47e: 68c8         	ldr	r0, [r1, #0xc]
700ac480: 3001         	adds	r0, #0x1
700ac482: 60c8         	str	r0, [r1, #0xc]
;     while (numBytesToTransfer != 0U)
700ac484: e7ea         	b	0x700ac45c <UART_writeData+0x2c> @ imm = #-0x2c
;     return (writeSizeRemaining - numBytesToTransferred);
700ac486: 9804         	ldr	r0, [sp, #0x10]
700ac488: 9902         	ldr	r1, [sp, #0x8]
700ac48a: 1a40         	subs	r0, r0, r1
700ac48c: b006         	add	sp, #0x18
700ac48e: bd80         	pop	{r7, pc}

700ac490 <Udma_virtToPhyFxn>:
; {
700ac490: b580         	push	{r7, lr}
700ac492: b088         	sub	sp, #0x20
700ac494: 9007         	str	r0, [sp, #0x1c]
700ac496: 9106         	str	r1, [sp, #0x18]
700ac498: 9205         	str	r2, [sp, #0x14]
700ac49a: 2000         	movs	r0, #0x0
700ac49c: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700ac4a0: 9004         	str	r0, [sp, #0x10]
700ac4a2: 2000         	movs	r0, #0x0
;     void               *appData = NULL_PTR;
700ac4a4: 9003         	str	r0, [sp, #0xc]
;     if(NULL_PTR != chHandle)
700ac4a6: 9805         	ldr	r0, [sp, #0x14]
700ac4a8: b138         	cbz	r0, 0x700ac4ba <Udma_virtToPhyFxn+0x2a> @ imm = #0xe
700ac4aa: e7ff         	b	0x700ac4ac <Udma_virtToPhyFxn+0x1c> @ imm = #-0x2
;         chNum   = chHandle->chPrms.chNum;
700ac4ac: 9805         	ldr	r0, [sp, #0x14]
700ac4ae: 6840         	ldr	r0, [r0, #0x4]
700ac4b0: 9004         	str	r0, [sp, #0x10]
;         appData = chHandle->chPrms.appData;
700ac4b2: 9805         	ldr	r0, [sp, #0x14]
700ac4b4: 6900         	ldr	r0, [r0, #0x10]
700ac4b6: 9003         	str	r0, [sp, #0xc]
;     }
700ac4b8: e7ff         	b	0x700ac4ba <Udma_virtToPhyFxn+0x2a> @ imm = #-0x2
;     if((Udma_VirtToPhyFxn) NULL_PTR != drvHandle->initPrms.virtToPhyFxn)
700ac4ba: 9806         	ldr	r0, [sp, #0x18]
700ac4bc: f8d0 01cc    	ldr.w	r0, [r0, #0x1cc]
700ac4c0: b150         	cbz	r0, 0x700ac4d8 <Udma_virtToPhyFxn+0x48> @ imm = #0x14
700ac4c2: e7ff         	b	0x700ac4c4 <Udma_virtToPhyFxn+0x34> @ imm = #-0x2
;         phyAddr = drvHandle->initPrms.virtToPhyFxn(virtAddr, chNum, appData);
700ac4c4: 9806         	ldr	r0, [sp, #0x18]
700ac4c6: f8d0 31cc    	ldr.w	r3, [r0, #0x1cc]
700ac4ca: 9807         	ldr	r0, [sp, #0x1c]
700ac4cc: 9904         	ldr	r1, [sp, #0x10]
700ac4ce: 9a03         	ldr	r2, [sp, #0xc]
700ac4d0: 4798         	blx	r3
700ac4d2: 9101         	str	r1, [sp, #0x4]
700ac4d4: 9000         	str	r0, [sp]
;     }
700ac4d6: e007         	b	0x700ac4e8 <Udma_virtToPhyFxn+0x58> @ imm = #0xe
;         phyAddr = Udma_defaultVirtToPhyFxn(virtAddr, chNum, appData);
700ac4d8: 9807         	ldr	r0, [sp, #0x1c]
700ac4da: 9904         	ldr	r1, [sp, #0x10]
700ac4dc: 9a03         	ldr	r2, [sp, #0xc]
700ac4de: f003 fb5f    	bl	0x700afba0 <Udma_defaultVirtToPhyFxn> @ imm = #0x36be
700ac4e2: 9101         	str	r1, [sp, #0x4]
700ac4e4: 9000         	str	r0, [sp]
700ac4e6: e7ff         	b	0x700ac4e8 <Udma_virtToPhyFxn+0x58> @ imm = #-0x2
;     return (phyAddr);
700ac4e8: 9800         	ldr	r0, [sp]
700ac4ea: 9901         	ldr	r1, [sp, #0x4]
700ac4ec: b008         	add	sp, #0x20
700ac4ee: bd80         	pop	{r7, pc}

700ac4f0 <Sciclient_pmSetModuleRst>:
; {
700ac4f0: b580         	push	{r7, lr}
700ac4f2: b090         	sub	sp, #0x40
700ac4f4: 900f         	str	r0, [sp, #0x3c]
700ac4f6: 910e         	str	r1, [sp, #0x38]
700ac4f8: 920d         	str	r2, [sp, #0x34]
700ac4fa: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700ac4fc: 900c         	str	r0, [sp, #0x30]
;     request.id     = (uint32_t) moduleId;
700ac4fe: 990f         	ldr	r1, [sp, #0x3c]
700ac500: 910a         	str	r1, [sp, #0x28]
;     request.resets = (uint32_t) resetBit;
700ac502: 990e         	ldr	r1, [sp, #0x38]
700ac504: 910b         	str	r1, [sp, #0x2c]
700ac506: f240 2102    	movw	r1, #0x202
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_DEVICE_RESETS;
700ac50a: f8ad 100c    	strh.w	r1, [sp, #0xc]
700ac50e: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700ac510: 9104         	str	r1, [sp, #0x10]
700ac512: a908         	add	r1, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700ac514: 9105         	str	r1, [sp, #0x14]
700ac516: 2110         	movs	r1, #0x10
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700ac518: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700ac51a: 990d         	ldr	r1, [sp, #0x34]
700ac51c: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700ac51e: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700ac520: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700ac522: 9002         	str	r0, [sp, #0x8]
700ac524: a803         	add	r0, sp, #0xc
700ac526: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700ac528: f7f1 f862    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xef3c
700ac52c: 900c         	str	r0, [sp, #0x30]
;     if((retVal != SystemP_SUCCESS) ||
700ac52e: 980c         	ldr	r0, [sp, #0x30]
700ac530: b930         	cbnz	r0, 0x700ac540 <Sciclient_pmSetModuleRst+0x50> @ imm = #0xc
700ac532: e7ff         	b	0x700ac534 <Sciclient_pmSetModuleRst+0x44> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700ac534: 9800         	ldr	r0, [sp]
700ac536: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700ac53a: 2802         	cmp	r0, #0x2
700ac53c: d004         	beq	0x700ac548 <Sciclient_pmSetModuleRst+0x58> @ imm = #0x8
700ac53e: e7ff         	b	0x700ac540 <Sciclient_pmSetModuleRst+0x50> @ imm = #-0x2
700ac540: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700ac544: 900c         	str	r0, [sp, #0x30]
;     }
700ac546: e7ff         	b	0x700ac548 <Sciclient_pmSetModuleRst+0x58> @ imm = #-0x2
;     return retVal;
700ac548: 980c         	ldr	r0, [sp, #0x30]
700ac54a: b010         	add	sp, #0x40
700ac54c: bd80         	pop	{r7, pc}
700ac54e: 0000         	movs	r0, r0

700ac550 <Sciclient_rmIaGetInst>:
; {
700ac550: b083         	sub	sp, #0xc
700ac552: f8ad 000a    	strh.w	r0, [sp, #0xa]
700ac556: 2000         	movs	r0, #0x0
;     struct Sciclient_rmIaInst *inst = NULL;
700ac558: 9001         	str	r0, [sp, #0x4]
;     for (i = 0; i < SCICLIENT_RM_IA_NUM_INST; i++) {
700ac55a: f8ad 0002    	strh.w	r0, [sp, #0x2]
700ac55e: e7ff         	b	0x700ac560 <Sciclient_rmIaGetInst+0x10> @ imm = #-0x2
700ac560: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ac564: 2800         	cmp	r0, #0x0
700ac566: dc1e         	bgt	0x700ac5a6 <Sciclient_rmIaGetInst+0x56> @ imm = #0x3c
700ac568: e7ff         	b	0x700ac56a <Sciclient_rmIaGetInst+0x1a> @ imm = #-0x2
;         if (id == gRmIaInstances[i].dev_id) {
700ac56a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700ac56e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700ac572: 014a         	lsls	r2, r1, #0x5
700ac574: f642 01ac    	movw	r1, #0x28ac
700ac578: f2c7 010b    	movt	r1, #0x700b
700ac57c: 5a89         	ldrh	r1, [r1, r2]
700ac57e: 4288         	cmp	r0, r1
700ac580: d10a         	bne	0x700ac598 <Sciclient_rmIaGetInst+0x48> @ imm = #0x14
700ac582: e7ff         	b	0x700ac584 <Sciclient_rmIaGetInst+0x34> @ imm = #-0x2
;             inst = &gRmIaInstances[i];
700ac584: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700ac588: f642 00ac    	movw	r0, #0x28ac
700ac58c: f2c7 000b    	movt	r0, #0x700b
700ac590: eb00 1041    	add.w	r0, r0, r1, lsl #5
700ac594: 9001         	str	r0, [sp, #0x4]
;             break;
700ac596: e006         	b	0x700ac5a6 <Sciclient_rmIaGetInst+0x56> @ imm = #0xc
;     }
700ac598: e7ff         	b	0x700ac59a <Sciclient_rmIaGetInst+0x4a> @ imm = #-0x2
;     for (i = 0; i < SCICLIENT_RM_IA_NUM_INST; i++) {
700ac59a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ac59e: 3001         	adds	r0, #0x1
700ac5a0: f8ad 0002    	strh.w	r0, [sp, #0x2]
700ac5a4: e7dc         	b	0x700ac560 <Sciclient_rmIaGetInst+0x10> @ imm = #-0x48
;     return inst;
700ac5a6: 9801         	ldr	r0, [sp, #0x4]
700ac5a8: b003         	add	sp, #0xc
700ac5aa: 4770         	bx	lr
700ac5ac: 0000         	movs	r0, r0
700ac5ae: 0000         	movs	r0, r0

700ac5b0 <Sciclient_rmPsPush>:
; {
700ac5b0: b083         	sub	sp, #0xc
700ac5b2: 9002         	str	r0, [sp, #0x8]
700ac5b4: f8ad 1006    	strh.w	r1, [sp, #0x6]
700ac5b8: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ac5ba: 9000         	str	r0, [sp]
;     if ((gPstack.psp < SCICLIENT_PS_MAX_DEPTH) && (n != NULL)) {
700ac5bc: f241 0058    	movw	r0, #0x1058
700ac5c0: f2c7 0008    	movt	r0, #0x7008
700ac5c4: 8c80         	ldrh	r0, [r0, #0x24]
700ac5c6: 2802         	cmp	r0, #0x2
700ac5c8: dc19         	bgt	0x700ac5fe <Sciclient_rmPsPush+0x4e> @ imm = #0x32
700ac5ca: e7ff         	b	0x700ac5cc <Sciclient_rmPsPush+0x1c> @ imm = #-0x2
700ac5cc: 9802         	ldr	r0, [sp, #0x8]
700ac5ce: b1b0         	cbz	r0, 0x700ac5fe <Sciclient_rmPsPush+0x4e> @ imm = #0x2c
700ac5d0: e7ff         	b	0x700ac5d2 <Sciclient_rmPsPush+0x22> @ imm = #-0x2
;         gPstack.ps[gPstack.psp].p_n = n;
700ac5d2: 9802         	ldr	r0, [sp, #0x8]
700ac5d4: f241 0158    	movw	r1, #0x1058
700ac5d8: f2c7 0108    	movt	r1, #0x7008
700ac5dc: 8c8a         	ldrh	r2, [r1, #0x24]
700ac5de: eb02 0242    	add.w	r2, r2, r2, lsl #1
700ac5e2: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gPstack.ps[gPstack.psp].if_idx = if_idx;
700ac5e6: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac5ea: 8c8a         	ldrh	r2, [r1, #0x24]
700ac5ec: eb02 0242    	add.w	r2, r2, r2, lsl #1
700ac5f0: eb01 0282    	add.w	r2, r1, r2, lsl #2
700ac5f4: 8090         	strh	r0, [r2, #0x4]
;         gPstack.psp++;
700ac5f6: 8c88         	ldrh	r0, [r1, #0x24]
700ac5f8: 3001         	adds	r0, #0x1
700ac5fa: 8488         	strh	r0, [r1, #0x24]
;     } else {
700ac5fc: e003         	b	0x700ac606 <Sciclient_rmPsPush+0x56> @ imm = #0x6
700ac5fe: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac602: 9000         	str	r0, [sp]
700ac604: e7ff         	b	0x700ac606 <Sciclient_rmPsPush+0x56> @ imm = #-0x2
;     return r;
700ac606: 9800         	ldr	r0, [sp]
700ac608: b003         	add	sp, #0xc
700ac60a: 4770         	bx	lr
700ac60c: 0000         	movs	r0, r0
700ac60e: 0000         	movs	r0, r0

700ac610 <UART_lld_deInit>:
; {
700ac610: b580         	push	{r7, lr}
700ac612: b084         	sub	sp, #0x10
700ac614: 9003         	str	r0, [sp, #0xc]
700ac616: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700ac618: 9002         	str	r0, [sp, #0x8]
;     if (NULL_PTR != hUart)
700ac61a: 9803         	ldr	r0, [sp, #0xc]
700ac61c: b1f8         	cbz	r0, 0x700ac65e <UART_lld_deInit+0x4e> @ imm = #0x3e
700ac61e: e7ff         	b	0x700ac620 <UART_lld_deInit+0x10> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700ac620: 9903         	ldr	r1, [sp, #0xc]
700ac622: 2002         	movs	r0, #0x2
700ac624: 6548         	str	r0, [r1, #0x54]
;        status = UART_lld_flushTxFifo(hUart);
700ac626: 9803         	ldr	r0, [sp, #0xc]
700ac628: f7fd ff2a    	bl	0x700aa480 <UART_lld_flushTxFifo> @ imm = #-0x21ac
700ac62c: 9002         	str	r0, [sp, #0x8]
;         if(status == UART_STATUS_SUCCESS)
700ac62e: 9802         	ldr	r0, [sp, #0x8]
700ac630: b988         	cbnz	r0, 0x700ac656 <UART_lld_deInit+0x46> @ imm = #0x22
700ac632: e7ff         	b	0x700ac634 <UART_lld_deInit+0x24> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr,
700ac634: 9803         	ldr	r0, [sp, #0xc]
700ac636: 6800         	ldr	r0, [r0]
700ac638: 2107         	movs	r1, #0x7
700ac63a: 9101         	str	r1, [sp, #0x4]
700ac63c: f7f9 fe90    	bl	0x700a6360 <UART_intrDisable> @ imm = #-0x62e0
;             UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700ac640: 9803         	ldr	r0, [sp, #0xc]
700ac642: 6800         	ldr	r0, [r0]
700ac644: 2102         	movs	r1, #0x2
700ac646: f002 fbab    	bl	0x700aeda0 <UART_intr2Disable> @ imm = #0x2756
700ac64a: 9901         	ldr	r1, [sp, #0x4]
;             (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700ac64c: 9803         	ldr	r0, [sp, #0xc]
700ac64e: 6800         	ldr	r0, [r0]
700ac650: f002 fbee    	bl	0x700aee30 <UART_operatingModeSelect> @ imm = #0x27dc
;         }
700ac654: e7ff         	b	0x700ac656 <UART_lld_deInit+0x46> @ imm = #-0x2
;         hUart->state = UART_STATE_RESET;
700ac656: 9903         	ldr	r1, [sp, #0xc]
700ac658: 2000         	movs	r0, #0x0
700ac65a: 6548         	str	r0, [r1, #0x54]
;     }
700ac65c: e003         	b	0x700ac666 <UART_lld_deInit+0x56> @ imm = #0x6
700ac65e: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700ac662: 9002         	str	r0, [sp, #0x8]
700ac664: e7ff         	b	0x700ac666 <UART_lld_deInit+0x56> @ imm = #-0x2
;     return status;
700ac666: 9802         	ldr	r0, [sp, #0x8]
700ac668: b004         	add	sp, #0x10
700ac66a: bd80         	pop	{r7, pc}
700ac66c: 0000         	movs	r0, r0
700ac66e: 0000         	movs	r0, r0

700ac670 <UART_lld_writeCompleteCallback>:
; {
700ac670: b580         	push	{r7, lr}
700ac672: b086         	sub	sp, #0x18
700ac674: 9005         	str	r0, [sp, #0x14]
;     UARTLLD_Handle hUart = (UARTLLD_Handle)args;
700ac676: 9805         	ldr	r0, [sp, #0x14]
700ac678: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != hUart)
700ac67a: 9802         	ldr	r0, [sp, #0x8]
700ac67c: b320         	cbz	r0, 0x700ac6c8 <UART_lld_writeCompleteCallback+0x58> @ imm = #0x48
700ac67e: e7ff         	b	0x700ac680 <UART_lld_writeCompleteCallback+0x10> @ imm = #-0x2
;         UART_Handle handle = (UART_Handle)hUart->args;
700ac680: 9802         	ldr	r0, [sp, #0x8]
700ac682: 6e00         	ldr	r0, [r0, #0x60]
700ac684: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != handle)
700ac686: 9801         	ldr	r0, [sp, #0x4]
700ac688: b1e8         	cbz	r0, 0x700ac6c6 <UART_lld_writeCompleteCallback+0x56> @ imm = #0x3a
700ac68a: e7ff         	b	0x700ac68c <UART_lld_writeCompleteCallback+0x1c> @ imm = #-0x2
;             config = (UART_Config *) handle;
700ac68c: 9801         	ldr	r0, [sp, #0x4]
700ac68e: 9004         	str	r0, [sp, #0x10]
;             obj = config->object;
700ac690: 9804         	ldr	r0, [sp, #0x10]
700ac692: 6840         	ldr	r0, [r0, #0x4]
700ac694: 9003         	str	r0, [sp, #0xc]
;             obj->writeTrans->count = hUart->writeTrans.count;
700ac696: 9802         	ldr	r0, [sp, #0x8]
700ac698: 6c00         	ldr	r0, [r0, #0x40]
700ac69a: 9903         	ldr	r1, [sp, #0xc]
700ac69c: f8d1 1080    	ldr.w	r1, [r1, #0x80]
700ac6a0: 6048         	str	r0, [r1, #0x4]
;             if (obj->prms.writeMode == UART_TRANSFER_MODE_CALLBACK)
700ac6a2: 9803         	ldr	r0, [sp, #0xc]
700ac6a4: 69c0         	ldr	r0, [r0, #0x1c]
700ac6a6: 2801         	cmp	r0, #0x1
700ac6a8: d107         	bne	0x700ac6ba <UART_lld_writeCompleteCallback+0x4a> @ imm = #0xe
700ac6aa: e7ff         	b	0x700ac6ac <UART_lld_writeCompleteCallback+0x3c> @ imm = #-0x2
;                 obj->prms.writeCallbackFxn(hUart, &hUart->writeTrans);
700ac6ac: 9803         	ldr	r0, [sp, #0xc]
700ac6ae: 6a42         	ldr	r2, [r0, #0x24]
700ac6b0: 9802         	ldr	r0, [sp, #0x8]
700ac6b2: f100 013c    	add.w	r1, r0, #0x3c
700ac6b6: 4790         	blx	r2
;             }
700ac6b8: e004         	b	0x700ac6c4 <UART_lld_writeCompleteCallback+0x54> @ imm = #0x8
;                 SemaphoreP_post((SemaphoreP_Object *)hUart->writeTransferMutex);
700ac6ba: 9802         	ldr	r0, [sp, #0x8]
700ac6bc: 6dc0         	ldr	r0, [r0, #0x5c]
700ac6be: f7ff fc1f    	bl	0x700abf00 <SemaphoreP_post> @ imm = #-0x7c2
700ac6c2: e7ff         	b	0x700ac6c4 <UART_lld_writeCompleteCallback+0x54> @ imm = #-0x2
;         }
700ac6c4: e7ff         	b	0x700ac6c6 <UART_lld_writeCompleteCallback+0x56> @ imm = #-0x2
;     }
700ac6c6: e7ff         	b	0x700ac6c8 <UART_lld_writeCompleteCallback+0x58> @ imm = #-0x2
; }
700ac6c8: b006         	add	sp, #0x18
700ac6ca: bd80         	pop	{r7, pc}
700ac6cc: 0000         	movs	r0, r0
700ac6ce: 0000         	movs	r0, r0

700ac6d0 <Sciclient_rmIaValidateGlobalEvt>:
; {
700ac6d0: b580         	push	{r7, lr}
700ac6d2: b086         	sub	sp, #0x18
700ac6d4: f8ad 0016    	strh.w	r0, [sp, #0x16]
700ac6d8: f8ad 1014    	strh.w	r1, [sp, #0x14]
700ac6dc: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ac6de: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIaInst *inst = NULL;
700ac6e0: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIaGetInst(id);
700ac6e2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700ac6e6: f7ff ff33    	bl	0x700ac550 <Sciclient_rmIaGetInst> @ imm = #-0x19a
700ac6ea: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700ac6ec: 9803         	ldr	r0, [sp, #0xc]
700ac6ee: b920         	cbnz	r0, 0x700ac6fa <Sciclient_rmIaValidateGlobalEvt+0x2a> @ imm = #0x8
700ac6f0: e7ff         	b	0x700ac6f2 <Sciclient_rmIaValidateGlobalEvt+0x22> @ imm = #-0x2
700ac6f2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ac6f6: 9004         	str	r0, [sp, #0x10]
;     }
700ac6f8: e7ff         	b	0x700ac6fa <Sciclient_rmIaValidateGlobalEvt+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ac6fa: 9804         	ldr	r0, [sp, #0x10]
700ac6fc: b990         	cbnz	r0, 0x700ac724 <Sciclient_rmIaValidateGlobalEvt+0x54> @ imm = #0x24
700ac6fe: e7ff         	b	0x700ac700 <Sciclient_rmIaValidateGlobalEvt+0x30> @ imm = #-0x2
;         evt = global_evt - inst->sevt_offset;
700ac700: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700ac704: 9903         	ldr	r1, [sp, #0xc]
700ac706: 8909         	ldrh	r1, [r1, #0x8]
700ac708: 1a40         	subs	r0, r0, r1
700ac70a: f8ad 000a    	strh.w	r0, [sp, #0xa]
;         r = Sciclient_rmIaValidateEvt(inst, evt, 0u, 0u, false);
700ac70e: 9803         	ldr	r0, [sp, #0xc]
700ac710: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700ac714: 466a         	mov	r2, sp
700ac716: 2300         	movs	r3, #0x0
700ac718: 6013         	str	r3, [r2]
700ac71a: 461a         	mov	r2, r3
700ac71c: f7f7 ff60    	bl	0x700a45e0 <Sciclient_rmIaValidateEvt> @ imm = #-0x8140
700ac720: 9004         	str	r0, [sp, #0x10]
;     }
700ac722: e7ff         	b	0x700ac724 <Sciclient_rmIaValidateGlobalEvt+0x54> @ imm = #-0x2
;     return r;
700ac724: 9804         	ldr	r0, [sp, #0x10]
700ac726: b006         	add	sp, #0x18
700ac728: bd80         	pop	{r7, pc}
700ac72a: 0000         	movs	r0, r0
700ac72c: 0000         	movs	r0, r0
700ac72e: 0000         	movs	r0, r0

700ac730 <UART_lld_readCompleteCallback>:
; {
700ac730: b580         	push	{r7, lr}
700ac732: b086         	sub	sp, #0x18
700ac734: 9005         	str	r0, [sp, #0x14]
;     UARTLLD_Handle hUart = (UARTLLD_Handle)args;
700ac736: 9805         	ldr	r0, [sp, #0x14]
700ac738: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != hUart)
700ac73a: 9802         	ldr	r0, [sp, #0x8]
700ac73c: b318         	cbz	r0, 0x700ac786 <UART_lld_readCompleteCallback+0x56> @ imm = #0x46
700ac73e: e7ff         	b	0x700ac740 <UART_lld_readCompleteCallback+0x10> @ imm = #-0x2
;         UART_Handle handle = (UART_Handle)hUart->args;
700ac740: 9802         	ldr	r0, [sp, #0x8]
700ac742: 6e00         	ldr	r0, [r0, #0x60]
700ac744: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != handle)
700ac746: 9801         	ldr	r0, [sp, #0x4]
700ac748: b1e0         	cbz	r0, 0x700ac784 <UART_lld_readCompleteCallback+0x54> @ imm = #0x38
700ac74a: e7ff         	b	0x700ac74c <UART_lld_readCompleteCallback+0x1c> @ imm = #-0x2
;             config = (UART_Config *) handle;
700ac74c: 9801         	ldr	r0, [sp, #0x4]
700ac74e: 9004         	str	r0, [sp, #0x10]
;             obj = config->object;
700ac750: 9804         	ldr	r0, [sp, #0x10]
700ac752: 6840         	ldr	r0, [r0, #0x4]
700ac754: 9003         	str	r0, [sp, #0xc]
;             obj->readTrans->count = hUart->readTrans.count;
700ac756: 9802         	ldr	r0, [sp, #0x8]
700ac758: 6ac0         	ldr	r0, [r0, #0x2c]
700ac75a: 9903         	ldr	r1, [sp, #0xc]
700ac75c: 6fc9         	ldr	r1, [r1, #0x7c]
700ac75e: 6048         	str	r0, [r1, #0x4]
;             if (obj->prms.readMode == UART_TRANSFER_MODE_CALLBACK)
700ac760: 9803         	ldr	r0, [sp, #0xc]
700ac762: 6940         	ldr	r0, [r0, #0x14]
700ac764: 2801         	cmp	r0, #0x1
700ac766: d107         	bne	0x700ac778 <UART_lld_readCompleteCallback+0x48> @ imm = #0xe
700ac768: e7ff         	b	0x700ac76a <UART_lld_readCompleteCallback+0x3a> @ imm = #-0x2
;                 obj->prms.readCallbackFxn(hUart, &hUart->readTrans);
700ac76a: 9803         	ldr	r0, [sp, #0xc]
700ac76c: 6a02         	ldr	r2, [r0, #0x20]
700ac76e: 9802         	ldr	r0, [sp, #0x8]
700ac770: f100 0128    	add.w	r1, r0, #0x28
700ac774: 4790         	blx	r2
;             }
700ac776: e004         	b	0x700ac782 <UART_lld_readCompleteCallback+0x52> @ imm = #0x8
;                 SemaphoreP_post((SemaphoreP_Object *)hUart->readTransferMutex);
700ac778: 9802         	ldr	r0, [sp, #0x8]
700ac77a: 6d80         	ldr	r0, [r0, #0x58]
700ac77c: f7ff fbc0    	bl	0x700abf00 <SemaphoreP_post> @ imm = #-0x880
700ac780: e7ff         	b	0x700ac782 <UART_lld_readCompleteCallback+0x52> @ imm = #-0x2
;         }
700ac782: e7ff         	b	0x700ac784 <UART_lld_readCompleteCallback+0x54> @ imm = #-0x2
;     }
700ac784: e7ff         	b	0x700ac786 <UART_lld_readCompleteCallback+0x56> @ imm = #-0x2
; }
700ac786: b006         	add	sp, #0x18
700ac788: bd80         	pop	{r7, pc}
700ac78a: 0000         	movs	r0, r0
700ac78c: 0000         	movs	r0, r0
700ac78e: 0000         	movs	r0, r0

700ac790 <UART_regConfigModeEnable>:
; {
700ac790: b580         	push	{r7, lr}
700ac792: b086         	sub	sp, #0x18
700ac794: 9005         	str	r0, [sp, #0x14]
700ac796: 9104         	str	r1, [sp, #0x10]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ac798: 9805         	ldr	r0, [sp, #0x14]
700ac79a: 300c         	adds	r0, #0xc
700ac79c: f003 f9f0    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x33e0
700ac7a0: 9003         	str	r0, [sp, #0xc]
;     switch (modeFlag)
700ac7a2: 9804         	ldr	r0, [sp, #0x10]
700ac7a4: 9002         	str	r0, [sp, #0x8]
700ac7a6: 287f         	cmp	r0, #0x7f
700ac7a8: d00f         	beq	0x700ac7ca <UART_regConfigModeEnable+0x3a> @ imm = #0x1e
700ac7aa: e7ff         	b	0x700ac7ac <UART_regConfigModeEnable+0x1c> @ imm = #-0x2
700ac7ac: 9802         	ldr	r0, [sp, #0x8]
700ac7ae: 2880         	cmp	r0, #0x80
700ac7b0: d004         	beq	0x700ac7bc <UART_regConfigModeEnable+0x2c> @ imm = #0x8
700ac7b2: e7ff         	b	0x700ac7b4 <UART_regConfigModeEnable+0x24> @ imm = #-0x2
700ac7b4: 9802         	ldr	r0, [sp, #0x8]
700ac7b6: 28bf         	cmp	r0, #0xbf
700ac7b8: d113         	bne	0x700ac7e2 <UART_regConfigModeEnable+0x52> @ imm = #0x26
700ac7ba: e7ff         	b	0x700ac7bc <UART_regConfigModeEnable+0x2c> @ imm = #-0x2
;             HW_WR_REG32(baseAddr + UART_LCR, modeFlag & 0xFFU);
700ac7bc: 9805         	ldr	r0, [sp, #0x14]
700ac7be: 300c         	adds	r0, #0xc
700ac7c0: f89d 1010    	ldrb.w	r1, [sp, #0x10]
700ac7c4: f003 f9e4    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x33c8
;             break;
700ac7c8: e00c         	b	0x700ac7e4 <UART_regConfigModeEnable+0x54> @ imm = #0x18
;             HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ac7ca: 9805         	ldr	r0, [sp, #0x14]
700ac7cc: 300c         	adds	r0, #0xc
700ac7ce: 9001         	str	r0, [sp, #0x4]
700ac7d0: f003 f9d6    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x33ac
700ac7d4: 4601         	mov	r1, r0
700ac7d6: 9801         	ldr	r0, [sp, #0x4]
700ac7d8: f001 017f    	and	r1, r1, #0x7f
700ac7dc: f003 f9d8    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x33b0
;             break;
700ac7e0: e000         	b	0x700ac7e4 <UART_regConfigModeEnable+0x54> @ imm = #0x0
;             break;
700ac7e2: e7ff         	b	0x700ac7e4 <UART_regConfigModeEnable+0x54> @ imm = #-0x2
;     return lcrRegValue;
700ac7e4: 9803         	ldr	r0, [sp, #0xc]
700ac7e6: b006         	add	sp, #0x18
700ac7e8: bd80         	pop	{r7, pc}
700ac7ea: 0000         	movs	r0, r0
700ac7ec: 0000         	movs	r0, r0
700ac7ee: 0000         	movs	r0, r0

700ac7f0 <prvCheckTasksWaitingTermination>:
; static void prvCheckTasksWaitingTermination(void) {
700ac7f0: b580         	push	{r7, lr}
700ac7f2: b082         	sub	sp, #0x8
;     while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
700ac7f4: e7ff         	b	0x700ac7f6 <prvCheckTasksWaitingTermination+0x6> @ imm = #-0x2
700ac7f6: f642 2030    	movw	r0, #0x2a30
700ac7fa: f2c7 000b    	movt	r0, #0x700b
700ac7fe: 6800         	ldr	r0, [r0]
700ac800: b308         	cbz	r0, 0x700ac846 <prvCheckTasksWaitingTermination+0x56> @ imm = #0x42
700ac802: e7ff         	b	0x700ac804 <prvCheckTasksWaitingTermination+0x14> @ imm = #-0x2
;       taskENTER_CRITICAL();
700ac804: f001 ffbc    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0x1f78
;         pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700ac808: f245 2088    	movw	r0, #0x5288
700ac80c: f2c7 0008    	movt	r0, #0x7008
700ac810: 68c0         	ldr	r0, [r0, #0xc]
700ac812: 68c0         	ldr	r0, [r0, #0xc]
700ac814: 9001         	str	r0, [sp, #0x4]
;         (void)uxListRemove(&(pxTCB->xStateListItem));
700ac816: 9801         	ldr	r0, [sp, #0x4]
700ac818: 3004         	adds	r0, #0x4
700ac81a: f000 ff81    	bl	0x700ad720 <uxListRemove> @ imm = #0xf02
;         --uxCurrentNumberOfTasks;
700ac81e: f642 212c    	movw	r1, #0x2a2c
700ac822: f2c7 010b    	movt	r1, #0x700b
700ac826: 6808         	ldr	r0, [r1]
700ac828: 3801         	subs	r0, #0x1
700ac82a: 6008         	str	r0, [r1]
;         --uxDeletedTasksWaitingCleanUp;
700ac82c: f642 2130    	movw	r1, #0x2a30
700ac830: f2c7 010b    	movt	r1, #0x700b
700ac834: 6808         	ldr	r0, [r1]
700ac836: 3801         	subs	r0, #0x1
700ac838: 6008         	str	r0, [r1]
;       taskEXIT_CRITICAL();
700ac83a: f001 f861    	bl	0x700ad900 <vTaskExitCritical> @ imm = #0x10c2
;       prvDeleteTCB(pxTCB);
700ac83e: 9801         	ldr	r0, [sp, #0x4]
700ac840: f001 fc86    	bl	0x700ae150 <prvDeleteTCB> @ imm = #0x190c
;     while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
700ac844: e7d7         	b	0x700ac7f6 <prvCheckTasksWaitingTermination+0x6> @ imm = #-0x52
; }
700ac846: b002         	add	sp, #0x8
700ac848: bd80         	pop	{r7, pc}
700ac84a: 0000         	movs	r0, r0
700ac84c: 0000         	movs	r0, r0
700ac84e: 0000         	movs	r0, r0

700ac850 <Sciclient_rmIrqSetRaw>:
; {
700ac850: b580         	push	{r7, lr}
700ac852: b08c         	sub	sp, #0x30
700ac854: 900b         	str	r0, [sp, #0x2c]
700ac856: 910a         	str	r1, [sp, #0x28]
700ac858: 9209         	str	r2, [sp, #0x24]
700ac85a: f44f 5080    	mov.w	r0, #0x1000
;     sciReq.messageType    = TISCI_MSG_RM_IRQ_SET;
700ac85e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac862: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac864: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac866: 980b         	ldr	r0, [sp, #0x2c]
700ac868: 9005         	str	r0, [sp, #0x14]
700ac86a: 201c         	movs	r0, #0x1c
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac86c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac86e: 9809         	ldr	r0, [sp, #0x24]
700ac870: 9007         	str	r0, [sp, #0x1c]
700ac872: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac874: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac876: 980a         	ldr	r0, [sp, #0x28]
700ac878: 9001         	str	r0, [sp, #0x4]
700ac87a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac87c: 9002         	str	r0, [sp, #0x8]
700ac87e: a803         	add	r0, sp, #0xc
700ac880: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac882: f7f0 feb5    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xf296
700ac886: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac888: 9808         	ldr	r0, [sp, #0x20]
700ac88a: b930         	cbnz	r0, 0x700ac89a <Sciclient_rmIrqSetRaw+0x4a> @ imm = #0xc
700ac88c: e7ff         	b	0x700ac88e <Sciclient_rmIrqSetRaw+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac88e: 9800         	ldr	r0, [sp]
700ac890: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac894: 2802         	cmp	r0, #0x2
700ac896: d004         	beq	0x700ac8a2 <Sciclient_rmIrqSetRaw+0x52> @ imm = #0x8
700ac898: e7ff         	b	0x700ac89a <Sciclient_rmIrqSetRaw+0x4a> @ imm = #-0x2
700ac89a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac89e: 9008         	str	r0, [sp, #0x20]
;     }
700ac8a0: e7ff         	b	0x700ac8a2 <Sciclient_rmIrqSetRaw+0x52> @ imm = #-0x2
;     return r;
700ac8a2: 9808         	ldr	r0, [sp, #0x20]
700ac8a4: b00c         	add	sp, #0x30
700ac8a6: bd80         	pop	{r7, pc}
		...

700ac8b0 <Sciclient_rmIrqUnmappedVintRouteDelete>:
; {
700ac8b0: b580         	push	{r7, lr}
700ac8b2: b084         	sub	sp, #0x10
700ac8b4: 9003         	str	r0, [sp, #0xc]
700ac8b6: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ac8b8: 9002         	str	r0, [sp, #0x8]
;     r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700ac8ba: 9903         	ldr	r1, [sp, #0xc]
700ac8bc: 8a08         	ldrh	r0, [r1, #0x10]
700ac8be: 8a49         	ldrh	r1, [r1, #0x12]
700ac8c0: f10d 0207    	add.w	r2, sp, #0x7
700ac8c4: f7fe fe84    	bl	0x700ab5d0 <Sciclient_rmIaVintGetInfo> @ imm = #-0x12f8
700ac8c8: 9002         	str	r0, [sp, #0x8]
;     if ((r == SystemP_SUCCESS) && (num_evts > 0U)) {
700ac8ca: 9802         	ldr	r0, [sp, #0x8]
700ac8cc: b940         	cbnz	r0, 0x700ac8e0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #0x10
700ac8ce: e7ff         	b	0x700ac8d0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x20> @ imm = #-0x2
700ac8d0: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ac8d4: b120         	cbz	r0, 0x700ac8e0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #0x8
700ac8d6: e7ff         	b	0x700ac8d8 <Sciclient_rmIrqUnmappedVintRouteDelete+0x28> @ imm = #-0x2
700ac8d8: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ac8dc: 9002         	str	r0, [sp, #0x8]
;     }
700ac8de: e7ff         	b	0x700ac8e0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ac8e0: 9802         	ldr	r0, [sp, #0x8]
700ac8e2: b970         	cbnz	r0, 0x700ac902 <Sciclient_rmIrqUnmappedVintRouteDelete+0x52> @ imm = #0x1c
700ac8e4: e7ff         	b	0x700ac8e6 <Sciclient_rmIrqUnmappedVintRouteDelete+0x36> @ imm = #-0x2
;         r = Sciclient_rmIrqGetRoute(cfg);
700ac8e6: 9803         	ldr	r0, [sp, #0xc]
700ac8e8: f7f0 fa02    	bl	0x7009ccf0 <Sciclient_rmIrqGetRoute> @ imm = #-0xfbfc
700ac8ec: 9002         	str	r0, [sp, #0x8]
;         if (r == SystemP_SUCCESS) {
700ac8ee: 9802         	ldr	r0, [sp, #0x8]
700ac8f0: b930         	cbnz	r0, 0x700ac900 <Sciclient_rmIrqUnmappedVintRouteDelete+0x50> @ imm = #0xc
700ac8f2: e7ff         	b	0x700ac8f4 <Sciclient_rmIrqUnmappedVintRouteDelete+0x44> @ imm = #-0x2
;             r = Sciclient_rmIrqDeleteRoute(cfg, false);
700ac8f4: 9803         	ldr	r0, [sp, #0xc]
700ac8f6: 2100         	movs	r1, #0x0
700ac8f8: f7f4 f91a    	bl	0x700a0b30 <Sciclient_rmIrqDeleteRoute> @ imm = #-0xbdcc
700ac8fc: 9002         	str	r0, [sp, #0x8]
;         }
700ac8fe: e7ff         	b	0x700ac900 <Sciclient_rmIrqUnmappedVintRouteDelete+0x50> @ imm = #-0x2
;     }
700ac900: e7ff         	b	0x700ac902 <Sciclient_rmIrqUnmappedVintRouteDelete+0x52> @ imm = #-0x2
;     return r;
700ac902: 9802         	ldr	r0, [sp, #0x8]
700ac904: b004         	add	sp, #0x10
700ac906: bd80         	pop	{r7, pc}
		...

700ac910 <Sciclient_rmRingCfg>:
; {
700ac910: b580         	push	{r7, lr}
700ac912: b08c         	sub	sp, #0x30
700ac914: 900b         	str	r0, [sp, #0x2c]
700ac916: 910a         	str	r1, [sp, #0x28]
700ac918: 9209         	str	r2, [sp, #0x24]
700ac91a: f241 1010    	movw	r0, #0x1110
;     sciReq.messageType    = TISCI_MSG_RM_RING_CFG;
700ac91e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac922: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac924: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac926: 980b         	ldr	r0, [sp, #0x2c]
700ac928: 9005         	str	r0, [sp, #0x14]
700ac92a: 2022         	movs	r0, #0x22
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac92c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac92e: 9809         	ldr	r0, [sp, #0x24]
700ac930: 9007         	str	r0, [sp, #0x1c]
700ac932: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac934: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac936: 980a         	ldr	r0, [sp, #0x28]
700ac938: 9001         	str	r0, [sp, #0x4]
700ac93a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac93c: 9002         	str	r0, [sp, #0x8]
700ac93e: a803         	add	r0, sp, #0xc
700ac940: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac942: f7f0 fe55    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xf356
700ac946: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac948: 9808         	ldr	r0, [sp, #0x20]
700ac94a: b930         	cbnz	r0, 0x700ac95a <Sciclient_rmRingCfg+0x4a> @ imm = #0xc
700ac94c: e7ff         	b	0x700ac94e <Sciclient_rmRingCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac94e: 9800         	ldr	r0, [sp]
700ac950: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac954: 2802         	cmp	r0, #0x2
700ac956: d004         	beq	0x700ac962 <Sciclient_rmRingCfg+0x52> @ imm = #0x8
700ac958: e7ff         	b	0x700ac95a <Sciclient_rmRingCfg+0x4a> @ imm = #-0x2
700ac95a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac95e: 9008         	str	r0, [sp, #0x20]
;     }
700ac960: e7ff         	b	0x700ac962 <Sciclient_rmRingCfg+0x52> @ imm = #-0x2
;     return r;
700ac962: 9808         	ldr	r0, [sp, #0x20]
700ac964: b00c         	add	sp, #0x30
700ac966: bd80         	pop	{r7, pc}
		...

700ac970 <Sciclient_rmUdmapFlowCfg>:
; {
700ac970: b580         	push	{r7, lr}
700ac972: b08c         	sub	sp, #0x30
700ac974: 900b         	str	r0, [sp, #0x2c]
700ac976: 910a         	str	r1, [sp, #0x28]
700ac978: 9209         	str	r2, [sp, #0x24]
700ac97a: f241 2030    	movw	r0, #0x1230
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_FLOW_CFG;
700ac97e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac982: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac984: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac986: 980b         	ldr	r0, [sp, #0x2c]
700ac988: 9005         	str	r0, [sp, #0x14]
700ac98a: 2029         	movs	r0, #0x29
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac98c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac98e: 9809         	ldr	r0, [sp, #0x24]
700ac990: 9007         	str	r0, [sp, #0x1c]
700ac992: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac994: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac996: 980a         	ldr	r0, [sp, #0x28]
700ac998: 9001         	str	r0, [sp, #0x4]
700ac99a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac99c: 9002         	str	r0, [sp, #0x8]
700ac99e: a803         	add	r0, sp, #0xc
700ac9a0: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac9a2: f7f0 fe25    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xf3b6
700ac9a6: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac9a8: 9808         	ldr	r0, [sp, #0x20]
700ac9aa: b930         	cbnz	r0, 0x700ac9ba <Sciclient_rmUdmapFlowCfg+0x4a> @ imm = #0xc
700ac9ac: e7ff         	b	0x700ac9ae <Sciclient_rmUdmapFlowCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac9ae: 9800         	ldr	r0, [sp]
700ac9b0: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac9b4: 2802         	cmp	r0, #0x2
700ac9b6: d004         	beq	0x700ac9c2 <Sciclient_rmUdmapFlowCfg+0x52> @ imm = #0x8
700ac9b8: e7ff         	b	0x700ac9ba <Sciclient_rmUdmapFlowCfg+0x4a> @ imm = #-0x2
700ac9ba: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac9be: 9008         	str	r0, [sp, #0x20]
;     }
700ac9c0: e7ff         	b	0x700ac9c2 <Sciclient_rmUdmapFlowCfg+0x52> @ imm = #-0x2
;     return r;
700ac9c2: 9808         	ldr	r0, [sp, #0x20]
700ac9c4: b00c         	add	sp, #0x30
700ac9c6: bd80         	pop	{r7, pc}
		...

700ac9d0 <Sciclient_rmUdmapFlowSizeThreshCfg>:
; {
700ac9d0: b580         	push	{r7, lr}
700ac9d2: b08c         	sub	sp, #0x30
700ac9d4: 900b         	str	r0, [sp, #0x2c]
700ac9d6: 910a         	str	r1, [sp, #0x28]
700ac9d8: 9209         	str	r2, [sp, #0x24]
700ac9da: f241 2031    	movw	r0, #0x1231
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_FLOW_SIZE_THRESH_CFG;
700ac9de: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac9e2: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac9e4: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac9e6: 980b         	ldr	r0, [sp, #0x2c]
700ac9e8: 9005         	str	r0, [sp, #0x14]
700ac9ea: 201d         	movs	r0, #0x1d
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac9ec: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac9ee: 9809         	ldr	r0, [sp, #0x24]
700ac9f0: 9007         	str	r0, [sp, #0x1c]
700ac9f2: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac9f4: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac9f6: 980a         	ldr	r0, [sp, #0x28]
700ac9f8: 9001         	str	r0, [sp, #0x4]
700ac9fa: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac9fc: 9002         	str	r0, [sp, #0x8]
700ac9fe: a803         	add	r0, sp, #0xc
700aca00: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aca02: f7f0 fdf5    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xf416
700aca06: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aca08: 9808         	ldr	r0, [sp, #0x20]
700aca0a: b930         	cbnz	r0, 0x700aca1a <Sciclient_rmUdmapFlowSizeThreshCfg+0x4a> @ imm = #0xc
700aca0c: e7ff         	b	0x700aca0e <Sciclient_rmUdmapFlowSizeThreshCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aca0e: 9800         	ldr	r0, [sp]
700aca10: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aca14: 2802         	cmp	r0, #0x2
700aca16: d004         	beq	0x700aca22 <Sciclient_rmUdmapFlowSizeThreshCfg+0x52> @ imm = #0x8
700aca18: e7ff         	b	0x700aca1a <Sciclient_rmUdmapFlowSizeThreshCfg+0x4a> @ imm = #-0x2
700aca1a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aca1e: 9008         	str	r0, [sp, #0x20]
;     }
700aca20: e7ff         	b	0x700aca22 <Sciclient_rmUdmapFlowSizeThreshCfg+0x52> @ imm = #-0x2
;     return r;
700aca22: 9808         	ldr	r0, [sp, #0x20]
700aca24: b00c         	add	sp, #0x30
700aca26: bd80         	pop	{r7, pc}
		...

700aca30 <Sciclient_rmUdmapRxChCfg>:
; {
700aca30: b580         	push	{r7, lr}
700aca32: b08c         	sub	sp, #0x30
700aca34: 900b         	str	r0, [sp, #0x2c]
700aca36: 910a         	str	r1, [sp, #0x28]
700aca38: 9209         	str	r2, [sp, #0x24]
700aca3a: f241 2015    	movw	r0, #0x1215
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_RX_CH_CFG;
700aca3e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aca42: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aca44: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aca46: 980b         	ldr	r0, [sp, #0x2c]
700aca48: 9005         	str	r0, [sp, #0x14]
700aca4a: 2022         	movs	r0, #0x22
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aca4c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aca4e: 9809         	ldr	r0, [sp, #0x24]
700aca50: 9007         	str	r0, [sp, #0x1c]
700aca52: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aca54: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aca56: 980a         	ldr	r0, [sp, #0x28]
700aca58: 9001         	str	r0, [sp, #0x4]
700aca5a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aca5c: 9002         	str	r0, [sp, #0x8]
700aca5e: a803         	add	r0, sp, #0xc
700aca60: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aca62: f7f0 fdc5    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xf476
700aca66: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aca68: 9808         	ldr	r0, [sp, #0x20]
700aca6a: b930         	cbnz	r0, 0x700aca7a <Sciclient_rmUdmapRxChCfg+0x4a> @ imm = #0xc
700aca6c: e7ff         	b	0x700aca6e <Sciclient_rmUdmapRxChCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aca6e: 9800         	ldr	r0, [sp]
700aca70: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aca74: 2802         	cmp	r0, #0x2
700aca76: d004         	beq	0x700aca82 <Sciclient_rmUdmapRxChCfg+0x52> @ imm = #0x8
700aca78: e7ff         	b	0x700aca7a <Sciclient_rmUdmapRxChCfg+0x4a> @ imm = #-0x2
700aca7a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aca7e: 9008         	str	r0, [sp, #0x20]
;     }
700aca80: e7ff         	b	0x700aca82 <Sciclient_rmUdmapRxChCfg+0x52> @ imm = #-0x2
;     return r;
700aca82: 9808         	ldr	r0, [sp, #0x20]
700aca84: b00c         	add	sp, #0x30
700aca86: bd80         	pop	{r7, pc}
		...

700aca90 <Sciclient_rmUdmapTxChCfg>:
; {
700aca90: b580         	push	{r7, lr}
700aca92: b08c         	sub	sp, #0x30
700aca94: 900b         	str	r0, [sp, #0x2c]
700aca96: 910a         	str	r1, [sp, #0x28]
700aca98: 9209         	str	r2, [sp, #0x24]
700aca9a: f241 2005    	movw	r0, #0x1205
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_TX_CH_CFG;
700aca9e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700acaa2: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700acaa4: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700acaa6: 980b         	ldr	r0, [sp, #0x2c]
700acaa8: 9005         	str	r0, [sp, #0x14]
700acaaa: 2024         	movs	r0, #0x24
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700acaac: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700acaae: 9809         	ldr	r0, [sp, #0x24]
700acab0: 9007         	str	r0, [sp, #0x1c]
700acab2: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700acab4: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700acab6: 980a         	ldr	r0, [sp, #0x28]
700acab8: 9001         	str	r0, [sp, #0x4]
700acaba: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700acabc: 9002         	str	r0, [sp, #0x8]
700acabe: a803         	add	r0, sp, #0xc
700acac0: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700acac2: f7f0 fd95    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xf4d6
700acac6: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700acac8: 9808         	ldr	r0, [sp, #0x20]
700acaca: b930         	cbnz	r0, 0x700acada <Sciclient_rmUdmapTxChCfg+0x4a> @ imm = #0xc
700acacc: e7ff         	b	0x700acace <Sciclient_rmUdmapTxChCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700acace: 9800         	ldr	r0, [sp]
700acad0: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700acad4: 2802         	cmp	r0, #0x2
700acad6: d004         	beq	0x700acae2 <Sciclient_rmUdmapTxChCfg+0x52> @ imm = #0x8
700acad8: e7ff         	b	0x700acada <Sciclient_rmUdmapTxChCfg+0x4a> @ imm = #-0x2
700acada: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700acade: 9008         	str	r0, [sp, #0x20]
;     }
700acae0: e7ff         	b	0x700acae2 <Sciclient_rmUdmapTxChCfg+0x52> @ imm = #-0x2
;     return r;
700acae2: 9808         	ldr	r0, [sp, #0x20]
700acae4: b00c         	add	sp, #0x30
700acae6: bd80         	pop	{r7, pc}

700acae8 <_outs>:
700acae8: e92d4070     	push	{r4, r5, r6, lr}
700acaec: e5916004     	ldr	r6, [r1, #0x4]
700acaf0: e1a04001     	mov	r4, r1
700acaf4: e5913008     	ldr	r3, [r1, #0x8]
700acaf8: e1a05002     	mov	r5, r2
700acafc: e1560003     	cmp	r6, r3
700acb00: 9a00000a     	bls	0x700acb30 <_outs+0x48> @ imm = #0x28
700acb04: e0466003     	sub	r6, r6, r3
700acb08: e1a01000     	mov	r1, r0
700acb0c: e5940000     	ldr	r0, [r4]
700acb10: e1560005     	cmp	r6, r5
700acb14: 21a06005     	movhs	r6, r5
700acb18: e1a02006     	mov	r2, r6
700acb1c: ebffb56e     	bl	0x7009a0dc <__aeabi_memcpy8> @ imm = #-0x12a48
700acb20: e5940000     	ldr	r0, [r4]
700acb24: e5943008     	ldr	r3, [r4, #0x8]
700acb28: e0800006     	add	r0, r0, r6
700acb2c: e5840000     	str	r0, [r4]
700acb30: e0831005     	add	r1, r3, r5
700acb34: e1a00005     	mov	r0, r5
700acb38: e5841008     	str	r1, [r4, #0x8]
700acb3c: e8bd8070     	pop	{r4, r5, r6, pc}

700acb40 <xQueueGenericCreate>:
;     {
700acb40: b580         	push	{r7, lr}
700acb42: b088         	sub	sp, #0x20
700acb44: 9007         	str	r0, [sp, #0x1c]
700acb46: 9106         	str	r1, [sp, #0x18]
700acb48: f88d 2017    	strb.w	r2, [sp, #0x17]
;         xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
700acb4c: 9807         	ldr	r0, [sp, #0x1c]
700acb4e: 9906         	ldr	r1, [sp, #0x18]
700acb50: 4348         	muls	r0, r1, r0
700acb52: 9003         	str	r0, [sp, #0xc]
;         pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
700acb54: 9803         	ldr	r0, [sp, #0xc]
700acb56: 3050         	adds	r0, #0x50
700acb58: f002 fd2a    	bl	0x700af5b0 <pvPortMalloc> @ imm = #0x2a54
700acb5c: 9004         	str	r0, [sp, #0x10]
;         if( pxNewQueue != NULL )
700acb5e: 9804         	ldr	r0, [sp, #0x10]
700acb60: b1b0         	cbz	r0, 0x700acb90 <xQueueGenericCreate+0x50> @ imm = #0x2c
700acb62: e7ff         	b	0x700acb64 <xQueueGenericCreate+0x24> @ imm = #-0x2
;             pucQueueStorage = ( uint8_t * ) pxNewQueue;
700acb64: 9804         	ldr	r0, [sp, #0x10]
700acb66: 9002         	str	r0, [sp, #0x8]
;             pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700acb68: 9802         	ldr	r0, [sp, #0x8]
700acb6a: 3050         	adds	r0, #0x50
700acb6c: 9002         	str	r0, [sp, #0x8]
;                     pxNewQueue->ucStaticallyAllocated = pdFALSE;
700acb6e: 9904         	ldr	r1, [sp, #0x10]
700acb70: 2000         	movs	r0, #0x0
700acb72: f881 0046    	strb.w	r0, [r1, #0x46]
;             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
700acb76: 9807         	ldr	r0, [sp, #0x1c]
700acb78: 9906         	ldr	r1, [sp, #0x18]
700acb7a: 9a02         	ldr	r2, [sp, #0x8]
700acb7c: f89d 3017    	ldrb.w	r3, [sp, #0x17]
700acb80: f8dd c010    	ldr.w	r12, [sp, #0x10]
700acb84: 46ee         	mov	lr, sp
700acb86: f8ce c000    	str.w	r12, [lr]
700acb8a: f000 fda1    	bl	0x700ad6d0 <prvInitialiseNewQueue> @ imm = #0xb42
;         }
700acb8e: e000         	b	0x700acb92 <xQueueGenericCreate+0x52> @ imm = #0x0
700acb90: e7ff         	b	0x700acb92 <xQueueGenericCreate+0x52> @ imm = #-0x2
;         return pxNewQueue;
700acb92: 9804         	ldr	r0, [sp, #0x10]
700acb94: b008         	add	sp, #0x20
700acb96: bd80         	pop	{r7, pc}

700acb98 <__TI_auto_init_nobinit_nopinit>:
700acb98: e92d4070     	push	{r4, r5, r6, lr}
700acb9c: e59f4040     	ldr	r4, [pc, #0x40]         @ 0x700acbe4 <__TI_auto_init_nobinit_nopinit+0x4c>
700acba0: e59f0038     	ldr	r0, [pc, #0x38]         @ 0x700acbe0 <__TI_auto_init_nobinit_nopinit+0x48>
700acba4: e1540000     	cmp	r4, r0
700acba8: 0a00000a     	beq	0x700acbd8 <__TI_auto_init_nobinit_nopinit+0x40> @ imm = #0x28
700acbac: e59f5034     	ldr	r5, [pc, #0x34]         @ 0x700acbe8 <__TI_auto_init_nobinit_nopinit+0x50>
700acbb0: e59f6034     	ldr	r6, [pc, #0x34]         @ 0x700acbec <__TI_auto_init_nobinit_nopinit+0x54>
700acbb4: e1550006     	cmp	r5, r6
700acbb8: 0a000006     	beq	0x700acbd8 <__TI_auto_init_nobinit_nopinit+0x40> @ imm = #0x18
700acbbc: e5950000     	ldr	r0, [r5]
700acbc0: e5951004     	ldr	r1, [r5, #0x4]
700acbc4: e4d02001     	ldrb	r2, [r0], #1
700acbc8: e7942102     	ldr	r2, [r4, r2, lsl #2]
700acbcc: e12fff32     	blx	r2
700acbd0: e2855008     	add	r5, r5, #8
700acbd4: eafffff6     	b	0x700acbb4 <__TI_auto_init_nobinit_nopinit+0x1c> @ imm = #-0x28
700acbd8: e1a00000     	mov	r0, r0
700acbdc: e8bd8070     	pop	{r4, r5, r6, pc}
700acbe0: 00 00 00 00  	.word	0x00000000
700acbe4: 00 00 00 00  	.word	0x00000000
700acbe8: 00 00 00 00  	.word	0x00000000
700acbec: 00 00 00 00  	.word	0x00000000

700acbf0 <Sciclient_rmIrqReleaseRaw>:
; {
700acbf0: b580         	push	{r7, lr}
700acbf2: b08e         	sub	sp, #0x38
700acbf4: 900d         	str	r0, [sp, #0x34]
700acbf6: 910c         	str	r1, [sp, #0x30]
700acbf8: f241 0001    	movw	r0, #0x1001
;     sciReq.messageType    = TISCI_MSG_RM_IRQ_RELEASE;
700acbfc: f8ad 0018    	strh.w	r0, [sp, #0x18]
700acc00: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700acc02: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700acc04: 980d         	ldr	r0, [sp, #0x34]
700acc06: 9008         	str	r0, [sp, #0x20]
700acc08: 201c         	movs	r0, #0x1c
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700acc0a: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700acc0c: 980c         	ldr	r0, [sp, #0x30]
700acc0e: 900a         	str	r0, [sp, #0x28]
700acc10: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700acc12: 9003         	str	r0, [sp, #0xc]
700acc14: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t *)&resp;
700acc16: 9004         	str	r0, [sp, #0x10]
700acc18: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700acc1a: 9005         	str	r0, [sp, #0x14]
700acc1c: a806         	add	r0, sp, #0x18
700acc1e: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700acc20: f7f0 fce6    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xf634
700acc24: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700acc26: 980b         	ldr	r0, [sp, #0x2c]
700acc28: b930         	cbnz	r0, 0x700acc38 <Sciclient_rmIrqReleaseRaw+0x48> @ imm = #0xc
700acc2a: e7ff         	b	0x700acc2c <Sciclient_rmIrqReleaseRaw+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700acc2c: 9803         	ldr	r0, [sp, #0xc]
700acc2e: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700acc32: 2802         	cmp	r0, #0x2
700acc34: d004         	beq	0x700acc40 <Sciclient_rmIrqReleaseRaw+0x50> @ imm = #0x8
700acc36: e7ff         	b	0x700acc38 <Sciclient_rmIrqReleaseRaw+0x48> @ imm = #-0x2
700acc38: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700acc3c: 900b         	str	r0, [sp, #0x2c]
;     }
700acc3e: e7ff         	b	0x700acc40 <Sciclient_rmIrqReleaseRaw+0x50> @ imm = #-0x2
;     return r;
700acc40: 980b         	ldr	r0, [sp, #0x2c]
700acc42: b00e         	add	sp, #0x38
700acc44: bd80         	pop	{r7, pc}
		...
700acc4e: 0000         	movs	r0, r0

700acc50 <Sciclient_rmPsilPair>:
; {
700acc50: b580         	push	{r7, lr}
700acc52: b08e         	sub	sp, #0x38
700acc54: 900d         	str	r0, [sp, #0x34]
700acc56: 910c         	str	r1, [sp, #0x30]
700acc58: f44f 5094    	mov.w	r0, #0x1280
;     sciReq.messageType    = TISCI_MSG_RM_PSIL_PAIR;
700acc5c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700acc60: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700acc62: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700acc64: 980d         	ldr	r0, [sp, #0x34]
700acc66: 9008         	str	r0, [sp, #0x20]
700acc68: 2014         	movs	r0, #0x14
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700acc6a: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700acc6c: 980c         	ldr	r0, [sp, #0x30]
700acc6e: 900a         	str	r0, [sp, #0x28]
700acc70: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700acc72: 9003         	str	r0, [sp, #0xc]
700acc74: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t*)&resp;
700acc76: 9004         	str	r0, [sp, #0x10]
700acc78: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700acc7a: 9005         	str	r0, [sp, #0x14]
700acc7c: a806         	add	r0, sp, #0x18
700acc7e: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700acc80: f7f0 fcb6    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xf694
700acc84: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700acc86: 980b         	ldr	r0, [sp, #0x2c]
700acc88: b930         	cbnz	r0, 0x700acc98 <Sciclient_rmPsilPair+0x48> @ imm = #0xc
700acc8a: e7ff         	b	0x700acc8c <Sciclient_rmPsilPair+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700acc8c: 9803         	ldr	r0, [sp, #0xc]
700acc8e: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700acc92: 2802         	cmp	r0, #0x2
700acc94: d004         	beq	0x700acca0 <Sciclient_rmPsilPair+0x50> @ imm = #0x8
700acc96: e7ff         	b	0x700acc98 <Sciclient_rmPsilPair+0x48> @ imm = #-0x2
700acc98: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700acc9c: 900b         	str	r0, [sp, #0x2c]
;     }
700acc9e: e7ff         	b	0x700acca0 <Sciclient_rmPsilPair+0x50> @ imm = #-0x2
;     return r;
700acca0: 980b         	ldr	r0, [sp, #0x2c]
700acca2: b00e         	add	sp, #0x38
700acca4: bd80         	pop	{r7, pc}
		...
700accae: 0000         	movs	r0, r0

700accb0 <Sciclient_rmPsilUnpair>:
; {
700accb0: b580         	push	{r7, lr}
700accb2: b08e         	sub	sp, #0x38
700accb4: 900d         	str	r0, [sp, #0x34]
700accb6: 910c         	str	r1, [sp, #0x30]
700accb8: f241 2081    	movw	r0, #0x1281
;     sciReq.messageType    = TISCI_MSG_RM_PSIL_UNPAIR;
700accbc: f8ad 0018    	strh.w	r0, [sp, #0x18]
700accc0: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700accc2: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700accc4: 980d         	ldr	r0, [sp, #0x34]
700accc6: 9008         	str	r0, [sp, #0x20]
700accc8: 2014         	movs	r0, #0x14
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700accca: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700acccc: 980c         	ldr	r0, [sp, #0x30]
700accce: 900a         	str	r0, [sp, #0x28]
700accd0: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700accd2: 9003         	str	r0, [sp, #0xc]
700accd4: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t *)&resp;
700accd6: 9004         	str	r0, [sp, #0x10]
700accd8: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700accda: 9005         	str	r0, [sp, #0x14]
700accdc: a806         	add	r0, sp, #0x18
700accde: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700acce0: f7f0 fc86    	bl	0x7009d5f0 <Sciclient_service> @ imm = #-0xf6f4
700acce4: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700acce6: 980b         	ldr	r0, [sp, #0x2c]
700acce8: b930         	cbnz	r0, 0x700accf8 <Sciclient_rmPsilUnpair+0x48> @ imm = #0xc
700accea: e7ff         	b	0x700accec <Sciclient_rmPsilUnpair+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700accec: 9803         	ldr	r0, [sp, #0xc]
700accee: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700accf2: 2802         	cmp	r0, #0x2
700accf4: d004         	beq	0x700acd00 <Sciclient_rmPsilUnpair+0x50> @ imm = #0x8
700accf6: e7ff         	b	0x700accf8 <Sciclient_rmPsilUnpair+0x48> @ imm = #-0x2
700accf8: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700accfc: 900b         	str	r0, [sp, #0x2c]
;     }
700accfe: e7ff         	b	0x700acd00 <Sciclient_rmPsilUnpair+0x50> @ imm = #-0x2
;     return r;
700acd00: 980b         	ldr	r0, [sp, #0x2c]
700acd02: b00e         	add	sp, #0x38
700acd04: bd80         	pop	{r7, pc}
		...
700acd0e: 0000         	movs	r0, r0

700acd10 <Udma_chSetPeerReg>:
; {
700acd10: b580         	push	{r7, lr}
700acd12: b086         	sub	sp, #0x18
700acd14: f8dd c020    	ldr.w	r12, [sp, #0x20]
700acd18: 9005         	str	r0, [sp, #0x14]
700acd1a: 9104         	str	r1, [sp, #0x10]
700acd1c: 9203         	str	r2, [sp, #0xc]
700acd1e: 9302         	str	r3, [sp, #0x8]
;     regVal = CSL_REG32_RD(PEER8);
700acd20: 9803         	ldr	r0, [sp, #0xc]
700acd22: f002 ff9d    	bl	0x700afc60 <CSL_REG32_RD_RAW> @ imm = #0x2f3a
700acd26: 9001         	str	r0, [sp, #0x4]
;     CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 0U);
700acd28: 9801         	ldr	r0, [sp, #0x4]
700acd2a: f020 4000    	bic	r0, r0, #0x80000000
700acd2e: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER8, regVal);
700acd30: 9803         	ldr	r0, [sp, #0xc]
700acd32: 9901         	ldr	r1, [sp, #0x4]
700acd34: f002 fef4    	bl	0x700afb20 <CSL_REG32_WR_RAW> @ imm = #0x2de8
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_X, pdmaPrms->elemSize) |
700acd38: 9804         	ldr	r0, [sp, #0x10]
700acd3a: 6801         	ldr	r1, [r0]
;                 CSL_FMK(PSILCFG_REG_STATIC_TR_Y, pdmaPrms->elemCnt);
700acd3c: 6840         	ldr	r0, [r0, #0x4]
700acd3e: f36f 301f    	bfc	r0, #12, #20
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_X, pdmaPrms->elemSize) |
700acd42: f361 601a    	bfi	r0, r1, #24, #3
700acd46: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER0, regVal);
700acd48: 9808         	ldr	r0, [sp, #0x20]
700acd4a: 9901         	ldr	r1, [sp, #0x4]
700acd4c: f002 fee8    	bl	0x700afb20 <CSL_REG32_WR_RAW> @ imm = #0x2dd0
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_Z, pdmaPrms->fifoCnt);
700acd50: 9804         	ldr	r0, [sp, #0x10]
700acd52: 6880         	ldr	r0, [r0, #0x8]
700acd54: f36f 301f    	bfc	r0, #12, #20
700acd58: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER1, regVal);
700acd5a: 9802         	ldr	r0, [sp, #0x8]
700acd5c: 9901         	ldr	r1, [sp, #0x4]
700acd5e: f002 fedf    	bl	0x700afb20 <CSL_REG32_WR_RAW> @ imm = #0x2dbe
; }
700acd62: b006         	add	sp, #0x18
700acd64: bd80         	pop	{r7, pc}
		...
700acd6e: 0000         	movs	r0, r0

700acd70 <Udma_eventGetGlobalHandle>:
; {
700acd70: b084         	sub	sp, #0x10
700acd72: 9003         	str	r0, [sp, #0xc]
700acd74: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700acd76: 9002         	str	r0, [sp, #0x8]
;     Udma_EventHandle    eventHandle = (Udma_EventHandle) NULL_PTR;
700acd78: 9000         	str	r0, [sp]
;     if(NULL_PTR == drvHandle)
700acd7a: 9803         	ldr	r0, [sp, #0xc]
700acd7c: b920         	cbnz	r0, 0x700acd88 <Udma_eventGetGlobalHandle+0x18> @ imm = #0x8
700acd7e: e7ff         	b	0x700acd80 <Udma_eventGetGlobalHandle+0x10> @ imm = #-0x2
700acd80: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700acd84: 9002         	str	r0, [sp, #0x8]
;     }
700acd86: e7ff         	b	0x700acd88 <Udma_eventGetGlobalHandle+0x18> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700acd88: 9802         	ldr	r0, [sp, #0x8]
700acd8a: b988         	cbnz	r0, 0x700acdb0 <Udma_eventGetGlobalHandle+0x40> @ imm = #0x22
700acd8c: e7ff         	b	0x700acd8e <Udma_eventGetGlobalHandle+0x1e> @ imm = #-0x2
;         drvHandleInt = (Udma_DrvHandleInt) drvHandle;
700acd8e: 9803         	ldr	r0, [sp, #0xc]
700acd90: 9001         	str	r0, [sp, #0x4]
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
700acd92: 9801         	ldr	r0, [sp, #0x4]
700acd94: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700acd98: f64a 31cd    	movw	r1, #0xabcd
700acd9c: f6ca 31dc    	movt	r1, #0xabdc
700acda0: 4288         	cmp	r0, r1
700acda2: d004         	beq	0x700acdae <Udma_eventGetGlobalHandle+0x3e> @ imm = #0x8
700acda4: e7ff         	b	0x700acda6 <Udma_eventGetGlobalHandle+0x36> @ imm = #-0x2
700acda6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700acdaa: 9002         	str	r0, [sp, #0x8]
;         }
700acdac: e7ff         	b	0x700acdae <Udma_eventGetGlobalHandle+0x3e> @ imm = #-0x2
;     }
700acdae: e7ff         	b	0x700acdb0 <Udma_eventGetGlobalHandle+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700acdb0: 9802         	ldr	r0, [sp, #0x8]
700acdb2: b928         	cbnz	r0, 0x700acdc0 <Udma_eventGetGlobalHandle+0x50> @ imm = #0xa
700acdb4: e7ff         	b	0x700acdb6 <Udma_eventGetGlobalHandle+0x46> @ imm = #-0x2
;         eventHandle = (Udma_EventHandle) drvHandleInt->globalEventHandle;
700acdb6: 9801         	ldr	r0, [sp, #0x4]
700acdb8: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
700acdbc: 9000         	str	r0, [sp]
;     }
700acdbe: e7ff         	b	0x700acdc0 <Udma_eventGetGlobalHandle+0x50> @ imm = #-0x2
;     return (eventHandle);
700acdc0: 9800         	ldr	r0, [sp]
700acdc2: b004         	add	sp, #0x10
700acdc4: 4770         	bx	lr
		...
700acdce: 0000         	movs	r0, r0

700acdd0 <CSL_pktdmaIsValidChanIdx>:
; {
700acdd0: b084         	sub	sp, #0x10
700acdd2: 9003         	str	r0, [sp, #0xc]
700acdd4: 9102         	str	r1, [sp, #0x8]
700acdd6: 9201         	str	r2, [sp, #0x4]
;     if( (chanDir == CSL_PKTDMA_CHAN_DIR_TX) && (chanIdx < pCfg->txChanCnt) )
700acdd8: 9801         	ldr	r0, [sp, #0x4]
700acdda: b950         	cbnz	r0, 0x700acdf2 <CSL_pktdmaIsValidChanIdx+0x22> @ imm = #0x14
700acddc: e7ff         	b	0x700acdde <CSL_pktdmaIsValidChanIdx+0xe> @ imm = #-0x2
700acdde: 9802         	ldr	r0, [sp, #0x8]
700acde0: 9903         	ldr	r1, [sp, #0xc]
700acde2: 6a09         	ldr	r1, [r1, #0x20]
700acde4: 4288         	cmp	r0, r1
700acde6: d204         	bhs	0x700acdf2 <CSL_pktdmaIsValidChanIdx+0x22> @ imm = #0x8
700acde8: e7ff         	b	0x700acdea <CSL_pktdmaIsValidChanIdx+0x1a> @ imm = #-0x2
700acdea: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700acdec: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700acdf0: e012         	b	0x700ace18 <CSL_pktdmaIsValidChanIdx+0x48> @ imm = #0x24
;     else if( (chanDir == CSL_PKTDMA_CHAN_DIR_RX) && (chanIdx < pCfg->rxChanCnt) )
700acdf2: 9801         	ldr	r0, [sp, #0x4]
700acdf4: 2801         	cmp	r0, #0x1
700acdf6: d10a         	bne	0x700ace0e <CSL_pktdmaIsValidChanIdx+0x3e> @ imm = #0x14
700acdf8: e7ff         	b	0x700acdfa <CSL_pktdmaIsValidChanIdx+0x2a> @ imm = #-0x2
700acdfa: 9802         	ldr	r0, [sp, #0x8]
700acdfc: 9903         	ldr	r1, [sp, #0xc]
700acdfe: 6a49         	ldr	r1, [r1, #0x24]
700ace00: 4288         	cmp	r0, r1
700ace02: d204         	bhs	0x700ace0e <CSL_pktdmaIsValidChanIdx+0x3e> @ imm = #0x8
700ace04: e7ff         	b	0x700ace06 <CSL_pktdmaIsValidChanIdx+0x36> @ imm = #-0x2
700ace06: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700ace08: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ace0c: e003         	b	0x700ace16 <CSL_pktdmaIsValidChanIdx+0x46> @ imm = #0x6
700ace0e: 2000         	movs	r0, #0x0
;         bRetVal = (bool)false;
700ace10: f88d 0003    	strb.w	r0, [sp, #0x3]
700ace14: e7ff         	b	0x700ace16 <CSL_pktdmaIsValidChanIdx+0x46> @ imm = #-0x2
700ace16: e7ff         	b	0x700ace18 <CSL_pktdmaIsValidChanIdx+0x48> @ imm = #-0x2
;     return bRetVal;
700ace18: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ace1c: f000 0001    	and	r0, r0, #0x1
700ace20: b004         	add	sp, #0x10
700ace22: 4770         	bx	lr
		...

700ace30 <Sciclient_rmUnmappedVintRouteCreate>:
; {
700ace30: b580         	push	{r7, lr}
700ace32: b084         	sub	sp, #0x10
700ace34: 9003         	str	r0, [sp, #0xc]
;     r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700ace36: 9903         	ldr	r1, [sp, #0xc]
700ace38: 8a08         	ldrh	r0, [r1, #0x10]
700ace3a: 8a49         	ldrh	r1, [r1, #0x12]
700ace3c: f10d 0207    	add.w	r2, sp, #0x7
700ace40: f7fe fbc6    	bl	0x700ab5d0 <Sciclient_rmIaVintGetInfo> @ imm = #-0x1874
700ace44: 9002         	str	r0, [sp, #0x8]
;     if ((r == SystemP_SUCCESS) && (num_evts > 0U)) {
700ace46: 9802         	ldr	r0, [sp, #0x8]
700ace48: b940         	cbnz	r0, 0x700ace5c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #0x10
700ace4a: e7ff         	b	0x700ace4c <Sciclient_rmUnmappedVintRouteCreate+0x1c> @ imm = #-0x2
700ace4c: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ace50: b120         	cbz	r0, 0x700ace5c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #0x8
700ace52: e7ff         	b	0x700ace54 <Sciclient_rmUnmappedVintRouteCreate+0x24> @ imm = #-0x2
700ace54: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ace58: 9002         	str	r0, [sp, #0x8]
;     }
700ace5a: e7ff         	b	0x700ace5c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ace5c: 9802         	ldr	r0, [sp, #0x8]
700ace5e: b970         	cbnz	r0, 0x700ace7e <Sciclient_rmUnmappedVintRouteCreate+0x4e> @ imm = #0x1c
700ace60: e7ff         	b	0x700ace62 <Sciclient_rmUnmappedVintRouteCreate+0x32> @ imm = #-0x2
;         r = Sciclient_rmIrqFindRoute(cfg);
700ace62: 9803         	ldr	r0, [sp, #0xc]
700ace64: f7f1 fb84    	bl	0x7009e570 <Sciclient_rmIrqFindRoute> @ imm = #-0xe8f8
700ace68: 9002         	str	r0, [sp, #0x8]
;         if (r == SystemP_SUCCESS) {
700ace6a: 9802         	ldr	r0, [sp, #0x8]
700ace6c: b930         	cbnz	r0, 0x700ace7c <Sciclient_rmUnmappedVintRouteCreate+0x4c> @ imm = #0xc
700ace6e: e7ff         	b	0x700ace70 <Sciclient_rmUnmappedVintRouteCreate+0x40> @ imm = #-0x2
;             r = Sciclient_rmIrqProgramRoute(cfg, false);
700ace70: 9803         	ldr	r0, [sp, #0xc]
700ace72: 2100         	movs	r1, #0x0
700ace74: f7f4 f8b4    	bl	0x700a0fe0 <Sciclient_rmIrqProgramRoute> @ imm = #-0xbe98
700ace78: 9002         	str	r0, [sp, #0x8]
;         }
700ace7a: e7ff         	b	0x700ace7c <Sciclient_rmUnmappedVintRouteCreate+0x4c> @ imm = #-0x2
;     }
700ace7c: e7ff         	b	0x700ace7e <Sciclient_rmUnmappedVintRouteCreate+0x4e> @ imm = #-0x2
;     return r;
700ace7e: 9802         	ldr	r0, [sp, #0x8]
700ace80: b004         	add	sp, #0x10
700ace82: bd80         	pop	{r7, pc}
		...

700ace90 <UART_OperModeValid>:
; {
700ace90: b082         	sub	sp, #0x8
700ace92: 9001         	str	r0, [sp, #0x4]
700ace94: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ace98: 9000         	str	r0, [sp]
;     if(((operMode == UART_OPER_MODE_16X) ||
700ace9a: 9801         	ldr	r0, [sp, #0x4]
700ace9c: b1e0         	cbz	r0, 0x700aced8 <UART_OperModeValid+0x48> @ imm = #0x38
700ace9e: e7ff         	b	0x700acea0 <UART_OperModeValid+0x10> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_SIR) ||
700acea0: 9801         	ldr	r0, [sp, #0x4]
700acea2: 2801         	cmp	r0, #0x1
700acea4: d018         	beq	0x700aced8 <UART_OperModeValid+0x48> @ imm = #0x30
700acea6: e7ff         	b	0x700acea8 <UART_OperModeValid+0x18> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_16X_AUTO_BAUD) ||
700acea8: 9801         	ldr	r0, [sp, #0x4]
700aceaa: 2802         	cmp	r0, #0x2
700aceac: d014         	beq	0x700aced8 <UART_OperModeValid+0x48> @ imm = #0x28
700aceae: e7ff         	b	0x700aceb0 <UART_OperModeValid+0x20> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_13X) ||
700aceb0: 9801         	ldr	r0, [sp, #0x4]
700aceb2: 2803         	cmp	r0, #0x3
700aceb4: d010         	beq	0x700aced8 <UART_OperModeValid+0x48> @ imm = #0x20
700aceb6: e7ff         	b	0x700aceb8 <UART_OperModeValid+0x28> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_MIR) ||
700aceb8: 9801         	ldr	r0, [sp, #0x4]
700aceba: 2804         	cmp	r0, #0x4
700acebc: d00c         	beq	0x700aced8 <UART_OperModeValid+0x48> @ imm = #0x18
700acebe: e7ff         	b	0x700acec0 <UART_OperModeValid+0x30> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_FIR) ||
700acec0: 9801         	ldr	r0, [sp, #0x4]
700acec2: 2805         	cmp	r0, #0x5
700acec4: d008         	beq	0x700aced8 <UART_OperModeValid+0x48> @ imm = #0x10
700acec6: e7ff         	b	0x700acec8 <UART_OperModeValid+0x38> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_CIR) ||
700acec8: 9801         	ldr	r0, [sp, #0x4]
700aceca: 2806         	cmp	r0, #0x6
700acecc: d004         	beq	0x700aced8 <UART_OperModeValid+0x48> @ imm = #0x8
700acece: e7ff         	b	0x700aced0 <UART_OperModeValid+0x40> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_DISABLED)))
700aced0: 9801         	ldr	r0, [sp, #0x4]
;     if(((operMode == UART_OPER_MODE_16X) ||
700aced2: 2807         	cmp	r0, #0x7
700aced4: d103         	bne	0x700acede <UART_OperModeValid+0x4e> @ imm = #0x6
700aced6: e7ff         	b	0x700aced8 <UART_OperModeValid+0x48> @ imm = #-0x2
700aced8: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700aceda: 9000         	str	r0, [sp]
;     }
700acedc: e7ff         	b	0x700acede <UART_OperModeValid+0x4e> @ imm = #-0x2
;     return status;
700acede: 9800         	ldr	r0, [sp]
700acee0: b002         	add	sp, #0x8
700acee2: 4770         	bx	lr
		...

700acef0 <UdmaRingPrms_init>:
; {
700acef0: b081         	sub	sp, #0x4
700acef2: 9000         	str	r0, [sp]
;     if(NULL_PTR != ringPrms)
700acef4: 9800         	ldr	r0, [sp]
700acef6: b318         	cbz	r0, 0x700acf40 <UdmaRingPrms_init+0x50> @ imm = #0x46
700acef8: e7ff         	b	0x700acefa <UdmaRingPrms_init+0xa> @ imm = #-0x2
;         ringPrms->ringMem       = NULL_PTR;
700acefa: 9900         	ldr	r1, [sp]
700acefc: 2000         	movs	r0, #0x0
700acefe: 6008         	str	r0, [r1]
;         ringPrms->ringMemSize   = UDMA_RING_SIZE_CHECK_SKIP;
700acf00: 9a00         	ldr	r2, [sp]
700acf02: f64a 31cd    	movw	r1, #0xabcd
700acf06: f6ca 31dc    	movt	r1, #0xabdc
700acf0a: 6051         	str	r1, [r2, #0x4]
;         ringPrms->mode          = TISCI_MSG_VALUE_RM_RING_MODE_RING;
700acf0c: 9900         	ldr	r1, [sp]
700acf0e: 7208         	strb	r0, [r1, #0x8]
;         ringPrms->virtId        = UDMA_RING_VIRTID_INVALID;
700acf10: 9a00         	ldr	r2, [sp]
700acf12: f64f 71ff    	movw	r1, #0xffff
700acf16: 8151         	strh	r1, [r2, #0xa]
;         ringPrms->elemCnt       = 0U;
700acf18: 9900         	ldr	r1, [sp]
700acf1a: 60c8         	str	r0, [r1, #0xc]
;         ringPrms->elemSize      = UDMA_RING_ES_8BYTES;
700acf1c: 9a00         	ldr	r2, [sp]
700acf1e: 2101         	movs	r1, #0x1
700acf20: 7411         	strb	r1, [r2, #0x10]
;         ringPrms->orderId       = UDMA_DEFAULT_RING_ORDER_ID;
700acf22: 9900         	ldr	r1, [sp]
700acf24: 7448         	strb	r0, [r1, #0x11]
;         ringPrms->asel          = UDMA_RINGACC_ASEL_ENDPOINT_PHYSADDR;
700acf26: 9900         	ldr	r1, [sp]
700acf28: 7488         	strb	r0, [r1, #0x12]
;         ringPrms->mappedRingGrp = UDMA_MAPPED_GROUP_INVALID;
700acf2a: 9900         	ldr	r1, [sp]
700acf2c: 2004         	movs	r0, #0x4
700acf2e: f6cf 70ff    	movt	r0, #0xffff
700acf32: 6148         	str	r0, [r1, #0x14]
;         ringPrms->mappedChNum   = UDMA_DMA_CH_INVALID;
700acf34: 9900         	ldr	r1, [sp]
700acf36: 2000         	movs	r0, #0x0
700acf38: f6cf 70ff    	movt	r0, #0xffff
700acf3c: 6188         	str	r0, [r1, #0x18]
;     }
700acf3e: e7ff         	b	0x700acf40 <UdmaRingPrms_init+0x50> @ imm = #-0x2
;     return;
700acf40: b001         	add	sp, #0x4
700acf42: 4770         	bx	lr
		...

700acf50 <prvIdleTask>:
; static portTASK_FUNCTION(prvIdleTask, pvParameters) {
700acf50: b580         	push	{r7, lr}
700acf52: b082         	sub	sp, #0x8
700acf54: 9001         	str	r0, [sp, #0x4]
;   for (;;) {
700acf56: e7ff         	b	0x700acf58 <prvIdleTask+0x8> @ imm = #-0x2
;     prvCheckTasksWaitingTermination();
700acf58: f7ff fc4a    	bl	0x700ac7f0 <prvCheckTasksWaitingTermination> @ imm = #-0x76c
;       if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) >
700acf5c: f244 40f8    	movw	r0, #0x44f8
700acf60: f2c7 0008    	movt	r0, #0x7008
700acf64: 6800         	ldr	r0, [r0]
700acf66: 2802         	cmp	r0, #0x2
700acf68: d302         	blo	0x700acf70 <prvIdleTask+0x20> @ imm = #0x4
700acf6a: e7ff         	b	0x700acf6c <prvIdleTask+0x1c> @ imm = #-0x2
;         taskYIELD();
700acf6c: df00         	svc	#0x0
;       } else {
700acf6e: e000         	b	0x700acf72 <prvIdleTask+0x22> @ imm = #0x0
700acf70: e7ff         	b	0x700acf72 <prvIdleTask+0x22> @ imm = #-0x2
;       vApplicationIdleHook();
700acf72: f002 fed5    	bl	0x700afd20 <vApplicationIdleHook> @ imm = #0x2daa
;       xExpectedIdleTime = prvGetExpectedIdleTime();
700acf76: f7fe f8cb    	bl	0x700ab110 <prvGetExpectedIdleTime> @ imm = #-0x1e6a
700acf7a: 9000         	str	r0, [sp]
;       if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP) {
700acf7c: 9800         	ldr	r0, [sp]
700acf7e: 2802         	cmp	r0, #0x2
700acf80: d30e         	blo	0x700acfa0 <prvIdleTask+0x50> @ imm = #0x1c
700acf82: e7ff         	b	0x700acf84 <prvIdleTask+0x34> @ imm = #-0x2
;         vTaskSuspendAll();
700acf84: f002 fe24    	bl	0x700afbd0 <vTaskSuspendAll> @ imm = #0x2c48
;           xExpectedIdleTime = prvGetExpectedIdleTime();
700acf88: f7fe f8c2    	bl	0x700ab110 <prvGetExpectedIdleTime> @ imm = #-0x1e7c
700acf8c: 9000         	str	r0, [sp]
;           if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP) {
700acf8e: 9800         	ldr	r0, [sp]
700acf90: 2802         	cmp	r0, #0x2
700acf92: d301         	blo	0x700acf98 <prvIdleTask+0x48> @ imm = #0x2
700acf94: e7ff         	b	0x700acf96 <prvIdleTask+0x46> @ imm = #-0x2
;           } else {
700acf96: e000         	b	0x700acf9a <prvIdleTask+0x4a> @ imm = #0x0
700acf98: e7ff         	b	0x700acf9a <prvIdleTask+0x4a> @ imm = #-0x2
;         (void)xTaskResumeAll();
700acf9a: f7f5 f981    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0xacfe
;       } else {
700acf9e: e000         	b	0x700acfa2 <prvIdleTask+0x52> @ imm = #0x0
700acfa0: e7ff         	b	0x700acfa2 <prvIdleTask+0x52> @ imm = #-0x2
;   for (;;) {
700acfa2: e7d9         	b	0x700acf58 <prvIdleTask+0x8> @ imm = #-0x4e
		...

700acfb0 <vQueueUnregisterQueue>:
;     {
700acfb0: b082         	sub	sp, #0x8
700acfb2: 9001         	str	r0, [sp, #0x4]
700acfb4: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700acfb6: 9000         	str	r0, [sp]
700acfb8: e7ff         	b	0x700acfba <vQueueUnregisterQueue+0xa> @ imm = #-0x2
700acfba: 9800         	ldr	r0, [sp]
700acfbc: 281f         	cmp	r0, #0x1f
700acfbe: d81f         	bhi	0x700ad000 <vQueueUnregisterQueue+0x50> @ imm = #0x3e
700acfc0: e7ff         	b	0x700acfc2 <vQueueUnregisterQueue+0x12> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].xHandle == xQueue )
700acfc2: 9900         	ldr	r1, [sp]
700acfc4: f644 4078    	movw	r0, #0x4c78
700acfc8: f2c7 0008    	movt	r0, #0x7008
700acfcc: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700acfd0: 6840         	ldr	r0, [r0, #0x4]
700acfd2: 9901         	ldr	r1, [sp, #0x4]
700acfd4: 4288         	cmp	r0, r1
700acfd6: d10d         	bne	0x700acff4 <vQueueUnregisterQueue+0x44> @ imm = #0x1a
700acfd8: e7ff         	b	0x700acfda <vQueueUnregisterQueue+0x2a> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = NULL;
700acfda: 9a00         	ldr	r2, [sp]
700acfdc: f644 4178    	movw	r1, #0x4c78
700acfe0: f2c7 0108    	movt	r1, #0x7008
700acfe4: 2000         	movs	r0, #0x0
700acfe6: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
700acfea: 9a00         	ldr	r2, [sp]
700acfec: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700acff0: 6048         	str	r0, [r1, #0x4]
;                 break;
700acff2: e005         	b	0x700ad000 <vQueueUnregisterQueue+0x50> @ imm = #0xa
700acff4: e7ff         	b	0x700acff6 <vQueueUnregisterQueue+0x46> @ imm = #-0x2
;         }
700acff6: e7ff         	b	0x700acff8 <vQueueUnregisterQueue+0x48> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700acff8: 9800         	ldr	r0, [sp]
700acffa: 3001         	adds	r0, #0x1
700acffc: 9000         	str	r0, [sp]
700acffe: e7dc         	b	0x700acfba <vQueueUnregisterQueue+0xa> @ imm = #-0x48
;     } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
700ad000: b002         	add	sp, #0x8
700ad002: 4770         	bx	lr
		...

700ad010 <Drivers_open>:
; {
700ad010: b5b0         	push	{r4, r5, r7, lr}
700ad012: b082         	sub	sp, #0x8
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700ad014: f642 0134    	movw	r1, #0x2834
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700ad018: f245 24b0    	movw	r4, #0x52b0
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700ad01c: f2c7 010b    	movt	r1, #0x700b
700ad020: 2500         	movs	r5, #0x0
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700ad022: f2c7 0408    	movt	r4, #0x7008
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700ad026: 2000         	movs	r0, #0x0
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700ad028: 6025         	str	r5, [r4]
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700ad02a: f7ee fd49    	bl	0x7009bac0 <UART_open>  @ imm = #-0x1156e
700ad02e: 6020         	str	r0, [r4]
;         if(NULL == gUartHandle[instCnt])
700ad030: b108         	cbz	r0, 0x700ad036 <Drivers_open+0x26> @ imm = #0x2
; }
700ad032: b002         	add	sp, #0x8
700ad034: bdb0         	pop	{r4, r5, r7, pc}
;             DebugP_logError("UART open failed for instance %d !!!\r\n", instCnt);
700ad036: f641 2122    	movw	r1, #0x1a22
700ad03a: f242 0291    	movw	r2, #0x2091
700ad03e: f2c7 010b    	movt	r1, #0x700b
700ad042: f2c7 020b    	movt	r2, #0x700b
700ad046: 2002         	movs	r0, #0x2
700ad048: 236e         	movs	r3, #0x6e
700ad04a: 9500         	str	r5, [sp]
700ad04c: f7fc fe68    	bl	0x700a9d20 <_DebugP_logZone> @ imm = #-0x3330
;         if(gUartHandle[instCnt] != NULL)
700ad050: 6820         	ldr	r0, [r4]
700ad052: 2800         	cmp	r0, #0x0
700ad054: d0ed         	beq	0x700ad032 <Drivers_open+0x22> @ imm = #-0x26
;             UART_close(gUartHandle[instCnt]);
700ad056: f7f2 ff9b    	bl	0x7009ff90 <UART_close> @ imm = #-0xd0ca
700ad05a: 2000         	movs	r0, #0x0
;             gUartHandle[instCnt] = NULL;
700ad05c: 6020         	str	r0, [r4]
; }
700ad05e: b002         	add	sp, #0x8
700ad060: bdb0         	pop	{r4, r5, r7, pc}
		...
700ad06e: 0000         	movs	r0, r0

700ad070 <Udma_chInitRegs>:
; {
700ad070: b081         	sub	sp, #0x4
700ad072: 9000         	str	r0, [sp]
;     chHandle->pBcdmaBcCfgRegs    = (volatile CSL_bcdma_bccfgRegs_chan *) NULL_PTR;
700ad074: 9900         	ldr	r1, [sp]
700ad076: 2000         	movs	r0, #0x0
700ad078: f8c1 0214    	str.w	r0, [r1, #0x214]
;     chHandle->pBcdmaBcRtRegs     = (volatile CSL_bcdma_bcrtRegs_chan *) NULL_PTR;
700ad07c: 9900         	ldr	r1, [sp]
700ad07e: f8c1 0218    	str.w	r0, [r1, #0x218]
;     chHandle->pBcdmaTxCfgRegs   = (volatile CSL_bcdma_txccfgRegs_chan *) NULL_PTR;
700ad082: 9900         	ldr	r1, [sp]
700ad084: f8c1 021c    	str.w	r0, [r1, #0x21c]
;     chHandle->pBcdmaTxRtRegs    = (volatile CSL_bcdma_txcrtRegs_chan *) NULL_PTR;
700ad088: 9900         	ldr	r1, [sp]
700ad08a: f8c1 0220    	str.w	r0, [r1, #0x220]
;     chHandle->pBcdmaRxCfgRegs   = (volatile CSL_bcdma_rxccfgRegs_chan *) NULL_PTR;
700ad08e: 9900         	ldr	r1, [sp]
700ad090: f8c1 0224    	str.w	r0, [r1, #0x224]
;     chHandle->pBcdmaRxRtRegs    = (volatile CSL_bcdma_rxcrtRegs_chan *) NULL_PTR;
700ad094: 9900         	ldr	r1, [sp]
700ad096: f8c1 0228    	str.w	r0, [r1, #0x228]
;     chHandle->pPktdmaTxCfgRegs  = (volatile CSL_pktdma_txccfgRegs_chan *) NULL_PTR;
700ad09a: 9900         	ldr	r1, [sp]
700ad09c: f8c1 022c    	str.w	r0, [r1, #0x22c]
;     chHandle->pPktdmaTxRtRegs   = (volatile CSL_pktdma_txcrtRegs_chan *) NULL_PTR;
700ad0a0: 9900         	ldr	r1, [sp]
700ad0a2: f8c1 0230    	str.w	r0, [r1, #0x230]
;     chHandle->pPktdmaRxCfgRegs  = (volatile CSL_pktdma_rxccfgRegs_chan *) NULL_PTR;
700ad0a6: 9900         	ldr	r1, [sp]
700ad0a8: f8c1 0234    	str.w	r0, [r1, #0x234]
;     chHandle->pPktdmaRxRtRegs   = (volatile CSL_pktdma_rxcrtRegs_chan *) NULL_PTR;
700ad0ac: 9900         	ldr	r1, [sp]
700ad0ae: f8c1 0238    	str.w	r0, [r1, #0x238]
;     chHandle->pPktdmaExtCfgRegs = (volatile CSL_pktdma_txccfgRegs_chan *) NULL_PTR;
700ad0b2: 9900         	ldr	r1, [sp]
700ad0b4: f8c1 023c    	str.w	r0, [r1, #0x23c]
;     chHandle->pPktdmaExtRtRegs  = (volatile CSL_pktdma_txcrtRegs_chan *) NULL_PTR;
700ad0b8: 9900         	ldr	r1, [sp]
700ad0ba: f8c1 0240    	str.w	r0, [r1, #0x240]
; }
700ad0be: b001         	add	sp, #0x4
700ad0c0: 4770         	bx	lr
		...
700ad0ce: 0000         	movs	r0, r0

700ad0d0 <vQueueAddToRegistry>:
;     {
700ad0d0: b083         	sub	sp, #0xc
700ad0d2: 9002         	str	r0, [sp, #0x8]
700ad0d4: 9101         	str	r1, [sp, #0x4]
700ad0d6: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700ad0d8: 9000         	str	r0, [sp]
700ad0da: e7ff         	b	0x700ad0dc <vQueueAddToRegistry+0xc> @ imm = #-0x2
700ad0dc: 9800         	ldr	r0, [sp]
700ad0de: 281f         	cmp	r0, #0x1f
700ad0e0: d81d         	bhi	0x700ad11e <vQueueAddToRegistry+0x4e> @ imm = #0x3a
700ad0e2: e7ff         	b	0x700ad0e4 <vQueueAddToRegistry+0x14> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].pcQueueName == NULL )
700ad0e4: 9900         	ldr	r1, [sp]
700ad0e6: f644 4078    	movw	r0, #0x4c78
700ad0ea: f2c7 0008    	movt	r0, #0x7008
700ad0ee: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
700ad0f2: b970         	cbnz	r0, 0x700ad112 <vQueueAddToRegistry+0x42> @ imm = #0x1c
700ad0f4: e7ff         	b	0x700ad0f6 <vQueueAddToRegistry+0x26> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = pcQueueName;
700ad0f6: 9801         	ldr	r0, [sp, #0x4]
700ad0f8: 9a00         	ldr	r2, [sp]
700ad0fa: f644 4178    	movw	r1, #0x4c78
700ad0fe: f2c7 0108    	movt	r1, #0x7008
700ad102: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = xQueue;
700ad106: 9802         	ldr	r0, [sp, #0x8]
700ad108: 9a00         	ldr	r2, [sp]
700ad10a: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700ad10e: 6048         	str	r0, [r1, #0x4]
;                 break;
700ad110: e005         	b	0x700ad11e <vQueueAddToRegistry+0x4e> @ imm = #0xa
700ad112: e7ff         	b	0x700ad114 <vQueueAddToRegistry+0x44> @ imm = #-0x2
;         }
700ad114: e7ff         	b	0x700ad116 <vQueueAddToRegistry+0x46> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700ad116: 9800         	ldr	r0, [sp]
700ad118: 3001         	adds	r0, #0x1
700ad11a: 9000         	str	r0, [sp]
700ad11c: e7de         	b	0x700ad0dc <vQueueAddToRegistry+0xc> @ imm = #-0x44
;     }
700ad11e: b003         	add	sp, #0xc
700ad120: 4770         	bx	lr
		...
700ad12e: 0000         	movs	r0, r0

700ad130 <xQueueTakeMutexRecursive>:
;     {
700ad130: b580         	push	{r7, lr}
700ad132: b086         	sub	sp, #0x18
700ad134: 9005         	str	r0, [sp, #0x14]
700ad136: 9104         	str	r1, [sp, #0x10]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
700ad138: 9805         	ldr	r0, [sp, #0x14]
700ad13a: 9002         	str	r0, [sp, #0x8]
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
700ad13c: 9802         	ldr	r0, [sp, #0x8]
700ad13e: 6880         	ldr	r0, [r0, #0x8]
700ad140: 9001         	str	r0, [sp, #0x4]
700ad142: f002 fc3d    	bl	0x700af9c0 <xTaskGetCurrentTaskHandle> @ imm = #0x287a
700ad146: 4601         	mov	r1, r0
700ad148: 9801         	ldr	r0, [sp, #0x4]
700ad14a: 4288         	cmp	r0, r1
700ad14c: d107         	bne	0x700ad15e <xQueueTakeMutexRecursive+0x2e> @ imm = #0xe
700ad14e: e7ff         	b	0x700ad150 <xQueueTakeMutexRecursive+0x20> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
700ad150: 9902         	ldr	r1, [sp, #0x8]
700ad152: 68c8         	ldr	r0, [r1, #0xc]
700ad154: 3001         	adds	r0, #0x1
700ad156: 60c8         	str	r0, [r1, #0xc]
700ad158: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700ad15a: 9003         	str	r0, [sp, #0xc]
;         }
700ad15c: e00e         	b	0x700ad17c <xQueueTakeMutexRecursive+0x4c> @ imm = #0x1c
;             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
700ad15e: 9802         	ldr	r0, [sp, #0x8]
700ad160: 9904         	ldr	r1, [sp, #0x10]
700ad162: f7f4 f98d    	bl	0x700a1480 <xQueueSemaphoreTake> @ imm = #-0xbce6
700ad166: 9003         	str	r0, [sp, #0xc]
;             if( xReturn != pdFAIL )
700ad168: 9803         	ldr	r0, [sp, #0xc]
700ad16a: b128         	cbz	r0, 0x700ad178 <xQueueTakeMutexRecursive+0x48> @ imm = #0xa
700ad16c: e7ff         	b	0x700ad16e <xQueueTakeMutexRecursive+0x3e> @ imm = #-0x2
;                 ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
700ad16e: 9902         	ldr	r1, [sp, #0x8]
700ad170: 68c8         	ldr	r0, [r1, #0xc]
700ad172: 3001         	adds	r0, #0x1
700ad174: 60c8         	str	r0, [r1, #0xc]
;             }
700ad176: e000         	b	0x700ad17a <xQueueTakeMutexRecursive+0x4a> @ imm = #0x0
700ad178: e7ff         	b	0x700ad17a <xQueueTakeMutexRecursive+0x4a> @ imm = #-0x2
700ad17a: e7ff         	b	0x700ad17c <xQueueTakeMutexRecursive+0x4c> @ imm = #-0x2
;         return xReturn;
700ad17c: 9803         	ldr	r0, [sp, #0xc]
700ad17e: b006         	add	sp, #0x18
700ad180: bd80         	pop	{r7, pc}
		...
700ad18e: 0000         	movs	r0, r0

700ad190 <UART_checkCharsAvailInFifo>:
; {
700ad190: b580         	push	{r7, lr}
700ad192: b084         	sub	sp, #0x10
700ad194: 9003         	str	r0, [sp, #0xc]
700ad196: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700ad198: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700ad19a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad19c: 9803         	ldr	r0, [sp, #0xc]
700ad19e: 300c         	adds	r0, #0xc
700ad1a0: f002 fcee    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x29dc
700ad1a4: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ad1a6: 9803         	ldr	r0, [sp, #0xc]
700ad1a8: 300c         	adds	r0, #0xc
700ad1aa: 9000         	str	r0, [sp]
700ad1ac: f002 fce8    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x29d0
700ad1b0: 4601         	mov	r1, r0
700ad1b2: 9800         	ldr	r0, [sp]
700ad1b4: f001 017f    	and	r1, r1, #0x7f
700ad1b8: f002 fcea    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x29d4
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700ad1bc: 9803         	ldr	r0, [sp, #0xc]
700ad1be: 3014         	adds	r0, #0x14
700ad1c0: f002 fcde    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x29bc
;     if ((uint32_t) UART_LSR_RX_FIFO_E_RX_FIFO_E_VALUE_0 !=
700ad1c4: 07c0         	lsls	r0, r0, #0x1f
700ad1c6: b118         	cbz	r0, 0x700ad1d0 <UART_checkCharsAvailInFifo+0x40> @ imm = #0x6
700ad1c8: e7ff         	b	0x700ad1ca <UART_checkCharsAvailInFifo+0x3a> @ imm = #-0x2
700ad1ca: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700ad1cc: 9001         	str	r0, [sp, #0x4]
;     }
700ad1ce: e7ff         	b	0x700ad1d0 <UART_checkCharsAvailInFifo+0x40> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad1d0: 9803         	ldr	r0, [sp, #0xc]
700ad1d2: 300c         	adds	r0, #0xc
700ad1d4: 9902         	ldr	r1, [sp, #0x8]
700ad1d6: f002 fcdb    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x29b6
;     return retVal;
700ad1da: 9801         	ldr	r0, [sp, #0x4]
700ad1dc: b004         	add	sp, #0x10
700ad1de: bd80         	pop	{r7, pc}

700ad1e0 <xQueueGiveMutexRecursive>:
;     {
700ad1e0: b580         	push	{r7, lr}
700ad1e2: b084         	sub	sp, #0x10
700ad1e4: 9003         	str	r0, [sp, #0xc]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
700ad1e6: 9803         	ldr	r0, [sp, #0xc]
700ad1e8: 9001         	str	r0, [sp, #0x4]
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
700ad1ea: 9801         	ldr	r0, [sp, #0x4]
700ad1ec: 6880         	ldr	r0, [r0, #0x8]
700ad1ee: 9000         	str	r0, [sp]
700ad1f0: f002 fbe6    	bl	0x700af9c0 <xTaskGetCurrentTaskHandle> @ imm = #0x27cc
700ad1f4: 4601         	mov	r1, r0
700ad1f6: 9800         	ldr	r0, [sp]
700ad1f8: 4288         	cmp	r0, r1
700ad1fa: d113         	bne	0x700ad224 <xQueueGiveMutexRecursive+0x44> @ imm = #0x26
700ad1fc: e7ff         	b	0x700ad1fe <xQueueGiveMutexRecursive+0x1e> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
700ad1fe: 9901         	ldr	r1, [sp, #0x4]
700ad200: 68c8         	ldr	r0, [r1, #0xc]
700ad202: 3801         	subs	r0, #0x1
700ad204: 60c8         	str	r0, [r1, #0xc]
;             if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
700ad206: 9801         	ldr	r0, [sp, #0x4]
700ad208: 68c0         	ldr	r0, [r0, #0xc]
700ad20a: b938         	cbnz	r0, 0x700ad21c <xQueueGiveMutexRecursive+0x3c> @ imm = #0xe
700ad20c: e7ff         	b	0x700ad20e <xQueueGiveMutexRecursive+0x2e> @ imm = #-0x2
;                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
700ad20e: 9801         	ldr	r0, [sp, #0x4]
700ad210: 2300         	movs	r3, #0x0
700ad212: 4619         	mov	r1, r3
700ad214: 461a         	mov	r2, r3
700ad216: f7f6 f873    	bl	0x700a3300 <xQueueGenericSend> @ imm = #-0x9f1a
;             }
700ad21a: e000         	b	0x700ad21e <xQueueGiveMutexRecursive+0x3e> @ imm = #0x0
700ad21c: e7ff         	b	0x700ad21e <xQueueGiveMutexRecursive+0x3e> @ imm = #-0x2
700ad21e: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700ad220: 9002         	str	r0, [sp, #0x8]
;         }
700ad222: e002         	b	0x700ad22a <xQueueGiveMutexRecursive+0x4a> @ imm = #0x4
700ad224: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
700ad226: 9002         	str	r0, [sp, #0x8]
700ad228: e7ff         	b	0x700ad22a <xQueueGiveMutexRecursive+0x4a> @ imm = #-0x2
;         return xReturn;
700ad22a: 9802         	ldr	r0, [sp, #0x8]
700ad22c: b004         	add	sp, #0x10
700ad22e: bd80         	pop	{r7, pc}

700ad230 <CSL_pktdmaIsChanEnabled>:
; {
700ad230: b580         	push	{r7, lr}
700ad232: b084         	sub	sp, #0x10
700ad234: 9003         	str	r0, [sp, #0xc]
700ad236: 9102         	str	r1, [sp, #0x8]
700ad238: 9201         	str	r2, [sp, #0x4]
;     if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700ad23a: 9801         	ldr	r0, [sp, #0x4]
700ad23c: b960         	cbnz	r0, 0x700ad258 <CSL_pktdmaIsChanEnabled+0x28> @ imm = #0x18
700ad23e: e7ff         	b	0x700ad240 <CSL_pktdmaIsChanEnabled+0x10> @ imm = #-0x2
;         regVal = CSL_REG32_FEXT( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, PKTDMA_TXCRT_CHAN_CTL_EN );
700ad240: 9803         	ldr	r0, [sp, #0xc]
700ad242: 6900         	ldr	r0, [r0, #0x10]
700ad244: 9902         	ldr	r1, [sp, #0x8]
700ad246: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad24a: f04f 4100    	mov.w	r1, #0x80000000
700ad24e: 221f         	movs	r2, #0x1f
700ad250: f001 ff56    	bl	0x700af100 <CSL_REG32_FEXT_RAW> @ imm = #0x1eac
700ad254: 9000         	str	r0, [sp]
;     }
700ad256: e00b         	b	0x700ad270 <CSL_pktdmaIsChanEnabled+0x40> @ imm = #0x16
;         regVal = CSL_REG32_FEXT( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, PKTDMA_RXCRT_CHAN_CTL_EN );
700ad258: 9803         	ldr	r0, [sp, #0xc]
700ad25a: 6940         	ldr	r0, [r0, #0x14]
700ad25c: 9902         	ldr	r1, [sp, #0x8]
700ad25e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad262: f04f 4100    	mov.w	r1, #0x80000000
700ad266: 221f         	movs	r2, #0x1f
700ad268: f001 ff4a    	bl	0x700af100 <CSL_REG32_FEXT_RAW> @ imm = #0x1e94
700ad26c: 9000         	str	r0, [sp]
700ad26e: e7ff         	b	0x700ad270 <CSL_pktdmaIsChanEnabled+0x40> @ imm = #-0x2
;     return ((regVal == 1U) ? (bool)true : (bool)false);
700ad270: 9800         	ldr	r0, [sp]
700ad272: 3801         	subs	r0, #0x1
700ad274: fab0 f080    	clz	r0, r0
700ad278: 0940         	lsrs	r0, r0, #0x5
700ad27a: b004         	add	sp, #0x10
700ad27c: bd80         	pop	{r7, pc}
700ad27e: 0000         	movs	r0, r0

700ad280 <UART_getHandle>:
; {
700ad280: b083         	sub	sp, #0xc
700ad282: 9002         	str	r0, [sp, #0x8]
700ad284: 2000         	movs	r0, #0x0
;     UART_Handle         handle = NULL;
700ad286: 9001         	str	r0, [sp, #0x4]
;     if(index < gUartConfigNum)
700ad288: 9802         	ldr	r0, [sp, #0x8]
700ad28a: f642 11fc    	movw	r1, #0x29fc
700ad28e: f2c7 010b    	movt	r1, #0x700b
700ad292: 6809         	ldr	r1, [r1]
700ad294: 4288         	cmp	r0, r1
700ad296: d217         	bhs	0x700ad2c8 <UART_getHandle+0x48> @ imm = #0x2e
700ad298: e7ff         	b	0x700ad29a <UART_getHandle+0x1a> @ imm = #-0x2
;         object = gUartConfig[index].object;
700ad29a: 9902         	ldr	r1, [sp, #0x8]
700ad29c: f642 10b4    	movw	r0, #0x29b4
700ad2a0: f2c7 000b    	movt	r0, #0x700b
700ad2a4: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700ad2a8: 6840         	ldr	r0, [r0, #0x4]
700ad2aa: 9000         	str	r0, [sp]
;         if(object && (TRUE == object->isOpen))
700ad2ac: 9800         	ldr	r0, [sp]
700ad2ae: b150         	cbz	r0, 0x700ad2c6 <UART_getHandle+0x46> @ imm = #0x14
700ad2b0: e7ff         	b	0x700ad2b2 <UART_getHandle+0x32> @ imm = #-0x2
700ad2b2: 9800         	ldr	r0, [sp]
700ad2b4: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700ad2b8: 2801         	cmp	r0, #0x1
700ad2ba: d104         	bne	0x700ad2c6 <UART_getHandle+0x46> @ imm = #0x8
700ad2bc: e7ff         	b	0x700ad2be <UART_getHandle+0x3e> @ imm = #-0x2
;             handle = object->handle;
700ad2be: 9800         	ldr	r0, [sp]
700ad2c0: 6800         	ldr	r0, [r0]
700ad2c2: 9001         	str	r0, [sp, #0x4]
;         }
700ad2c4: e7ff         	b	0x700ad2c6 <UART_getHandle+0x46> @ imm = #-0x2
;     }
700ad2c6: e7ff         	b	0x700ad2c8 <UART_getHandle+0x48> @ imm = #-0x2
;     return handle;
700ad2c8: 9801         	ldr	r0, [sp, #0x4]
700ad2ca: b003         	add	sp, #0xc
700ad2cc: 4770         	bx	lr
700ad2ce: 0000         	movs	r0, r0

700ad2d0 <prvTaskIsTaskSuspended>:
; static BaseType_t prvTaskIsTaskSuspended(const TaskHandle_t xTask) {
700ad2d0: b083         	sub	sp, #0xc
700ad2d2: 9002         	str	r0, [sp, #0x8]
700ad2d4: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700ad2d6: 9001         	str	r0, [sp, #0x4]
;   const TCB_t *const pxTCB = xTask;
700ad2d8: 9802         	ldr	r0, [sp, #0x8]
700ad2da: 9000         	str	r0, [sp]
;   if (listIS_CONTAINED_WITHIN(&xSuspendedTaskList, &(pxTCB->xStateListItem)) !=
700ad2dc: 9800         	ldr	r0, [sp]
700ad2de: 6940         	ldr	r0, [r0, #0x14]
700ad2e0: f245 2174    	movw	r1, #0x5274
700ad2e4: f2c7 0108    	movt	r1, #0x7008
700ad2e8: 4288         	cmp	r0, r1
700ad2ea: d114         	bne	0x700ad316 <prvTaskIsTaskSuspended+0x46> @ imm = #0x28
700ad2ec: e7ff         	b	0x700ad2ee <prvTaskIsTaskSuspended+0x1e> @ imm = #-0x2
;     if (listIS_CONTAINED_WITHIN(&xPendingReadyList, &(pxTCB->xEventListItem)) ==
700ad2ee: 9800         	ldr	r0, [sp]
700ad2f0: 6a80         	ldr	r0, [r0, #0x28]
700ad2f2: f245 2160    	movw	r1, #0x5260
700ad2f6: f2c7 0108    	movt	r1, #0x7008
700ad2fa: 4288         	cmp	r0, r1
700ad2fc: d009         	beq	0x700ad312 <prvTaskIsTaskSuspended+0x42> @ imm = #0x12
700ad2fe: e7ff         	b	0x700ad300 <prvTaskIsTaskSuspended+0x30> @ imm = #-0x2
;       if (listIS_CONTAINED_WITHIN(NULL, &(pxTCB->xEventListItem)) !=
700ad300: 9800         	ldr	r0, [sp]
700ad302: 6a80         	ldr	r0, [r0, #0x28]
700ad304: b918         	cbnz	r0, 0x700ad30e <prvTaskIsTaskSuspended+0x3e> @ imm = #0x6
700ad306: e7ff         	b	0x700ad308 <prvTaskIsTaskSuspended+0x38> @ imm = #-0x2
700ad308: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700ad30a: 9001         	str	r0, [sp, #0x4]
;       } else {
700ad30c: e000         	b	0x700ad310 <prvTaskIsTaskSuspended+0x40> @ imm = #0x0
700ad30e: e7ff         	b	0x700ad310 <prvTaskIsTaskSuspended+0x40> @ imm = #-0x2
;     } else {
700ad310: e000         	b	0x700ad314 <prvTaskIsTaskSuspended+0x44> @ imm = #0x0
700ad312: e7ff         	b	0x700ad314 <prvTaskIsTaskSuspended+0x44> @ imm = #-0x2
;   } else {
700ad314: e000         	b	0x700ad318 <prvTaskIsTaskSuspended+0x48> @ imm = #0x0
700ad316: e7ff         	b	0x700ad318 <prvTaskIsTaskSuspended+0x48> @ imm = #-0x2
;   return xReturn;
700ad318: 9801         	ldr	r0, [sp, #0x4]
700ad31a: b003         	add	sp, #0xc
700ad31c: 4770         	bx	lr
700ad31e: 0000         	movs	r0, r0

700ad320 <Sciclient_rmPsSetInp>:
; {
700ad320: b082         	sub	sp, #0x8
700ad322: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ad326: f8ad 1004    	strh.w	r1, [sp, #0x4]
700ad32a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ad32c: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ad32e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ad332: f241 0158    	movw	r1, #0x1058
700ad336: f2c7 0108    	movt	r1, #0x7008
700ad33a: 8c89         	ldrh	r1, [r1, #0x24]
700ad33c: 4288         	cmp	r0, r1
700ad33e: da0e         	bge	0x700ad35e <Sciclient_rmPsSetInp+0x3e> @ imm = #0x1c
700ad340: e7ff         	b	0x700ad342 <Sciclient_rmPsSetInp+0x22> @ imm = #-0x2
;         gPstack.ps[index].inp = inp;
700ad342: f8bd 0004    	ldrh.w	r0, [sp, #0x4]
700ad346: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ad34a: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ad34e: f241 0158    	movw	r1, #0x1058
700ad352: f2c7 0108    	movt	r1, #0x7008
700ad356: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ad35a: 80c8         	strh	r0, [r1, #0x6]
;     } else {
700ad35c: e003         	b	0x700ad366 <Sciclient_rmPsSetInp+0x46> @ imm = #0x6
700ad35e: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ad362: 9000         	str	r0, [sp]
700ad364: e7ff         	b	0x700ad366 <Sciclient_rmPsSetInp+0x46> @ imm = #-0x2
;     return r;
700ad366: 9800         	ldr	r0, [sp]
700ad368: b002         	add	sp, #0x8
700ad36a: 4770         	bx	lr
700ad36c: 0000         	movs	r0, r0
700ad36e: 0000         	movs	r0, r0

700ad370 <Sciclient_rmPsSetOutp>:
; {
700ad370: b082         	sub	sp, #0x8
700ad372: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ad376: f8ad 1004    	strh.w	r1, [sp, #0x4]
700ad37a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ad37c: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ad37e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ad382: f241 0158    	movw	r1, #0x1058
700ad386: f2c7 0108    	movt	r1, #0x7008
700ad38a: 8c89         	ldrh	r1, [r1, #0x24]
700ad38c: 4288         	cmp	r0, r1
700ad38e: da0e         	bge	0x700ad3ae <Sciclient_rmPsSetOutp+0x3e> @ imm = #0x1c
700ad390: e7ff         	b	0x700ad392 <Sciclient_rmPsSetOutp+0x22> @ imm = #-0x2
;         gPstack.ps[index].outp = outp;
700ad392: f8bd 0004    	ldrh.w	r0, [sp, #0x4]
700ad396: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ad39a: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ad39e: f241 0158    	movw	r1, #0x1058
700ad3a2: f2c7 0108    	movt	r1, #0x7008
700ad3a6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ad3aa: 8108         	strh	r0, [r1, #0x8]
;     } else {
700ad3ac: e003         	b	0x700ad3b6 <Sciclient_rmPsSetOutp+0x46> @ imm = #0x6
700ad3ae: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ad3b2: 9000         	str	r0, [sp]
700ad3b4: e7ff         	b	0x700ad3b6 <Sciclient_rmPsSetOutp+0x46> @ imm = #-0x2
;     return r;
700ad3b6: 9800         	ldr	r0, [sp]
700ad3b8: b002         	add	sp, #0x8
700ad3ba: 4770         	bx	lr
700ad3bc: 0000         	movs	r0, r0
700ad3be: 0000         	movs	r0, r0

700ad3c0 <Udma_eventGetId>:
; {
700ad3c0: b084         	sub	sp, #0x10
700ad3c2: 9003         	str	r0, [sp, #0xc]
700ad3c4: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            evtNum = UDMA_EVENT_INVALID;
700ad3c8: 9002         	str	r0, [sp, #0x8]
;     Udma_EventHandleInt eventHandleInt = (Udma_EventHandleInt) eventHandle;
700ad3ca: 9803         	ldr	r0, [sp, #0xc]
700ad3cc: 9000         	str	r0, [sp]
;     if((NULL_PTR != eventHandleInt) &&
700ad3ce: 9800         	ldr	r0, [sp]
700ad3d0: b1c8         	cbz	r0, 0x700ad406 <Udma_eventGetId+0x46> @ imm = #0x32
700ad3d2: e7ff         	b	0x700ad3d4 <Udma_eventGetId+0x14> @ imm = #-0x2
;        (UDMA_INIT_DONE == eventHandleInt->eventInitDone))
700ad3d4: 9800         	ldr	r0, [sp]
700ad3d6: f8d0 0098    	ldr.w	r0, [r0, #0x98]
700ad3da: f64a 31cd    	movw	r1, #0xabcd
700ad3de: f6ca 31dc    	movt	r1, #0xabdc
;     if((NULL_PTR != eventHandleInt) &&
700ad3e2: 4288         	cmp	r0, r1
700ad3e4: d10f         	bne	0x700ad406 <Udma_eventGetId+0x46> @ imm = #0x1e
700ad3e6: e7ff         	b	0x700ad3e8 <Udma_eventGetId+0x28> @ imm = #-0x2
;         drvHandle = eventHandleInt->drvHandle;
700ad3e8: 9800         	ldr	r0, [sp]
700ad3ea: 6800         	ldr	r0, [r0]
700ad3ec: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != drvHandle)
700ad3ee: 9801         	ldr	r0, [sp, #0x4]
700ad3f0: b140         	cbz	r0, 0x700ad404 <Udma_eventGetId+0x44> @ imm = #0x10
700ad3f2: e7ff         	b	0x700ad3f4 <Udma_eventGetId+0x34> @ imm = #-0x2
;             evtNum = drvHandle->iaGemOffset + eventHandleInt->globalEvent;
700ad3f4: 9801         	ldr	r0, [sp, #0x4]
700ad3f6: f8d0 0118    	ldr.w	r0, [r0, #0x118]
700ad3fa: 9900         	ldr	r1, [sp]
700ad3fc: 6c89         	ldr	r1, [r1, #0x48]
700ad3fe: 4408         	add	r0, r1
700ad400: 9002         	str	r0, [sp, #0x8]
;         }
700ad402: e7ff         	b	0x700ad404 <Udma_eventGetId+0x44> @ imm = #-0x2
;     }
700ad404: e7ff         	b	0x700ad406 <Udma_eventGetId+0x46> @ imm = #-0x2
;     return (evtNum);
700ad406: 9802         	ldr	r0, [sp, #0x8]
700ad408: b004         	add	sp, #0x10
700ad40a: 4770         	bx	lr
700ad40c: 0000         	movs	r0, r0
700ad40e: 0000         	movs	r0, r0

700ad410 <CSL_pktdmaGetRxRT>:
; {
700ad410: b580         	push	{r7, lr}
700ad412: b084         	sub	sp, #0x10
700ad414: 9003         	str	r0, [sp, #0xc]
700ad416: 9102         	str	r1, [sp, #0x8]
700ad418: 9201         	str	r2, [sp, #0x4]
;     val = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700ad41a: 9803         	ldr	r0, [sp, #0xc]
700ad41c: 6940         	ldr	r0, [r0, #0x14]
700ad41e: 9902         	ldr	r1, [sp, #0x8]
700ad420: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad424: f002 fc04    	bl	0x700afc30 <CSL_REG32_RD_RAW> @ imm = #0x2808
700ad428: 9000         	str	r0, [sp]
;     pRT->enable         = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_EN );
700ad42a: 9800         	ldr	r0, [sp]
700ad42c: 0fc0         	lsrs	r0, r0, #0x1f
700ad42e: 9901         	ldr	r1, [sp, #0x4]
700ad430: 6008         	str	r0, [r1]
;     pRT->teardown       = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_TDOWN );
700ad432: 9800         	ldr	r0, [sp]
700ad434: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700ad438: 9901         	ldr	r1, [sp, #0x4]
700ad43a: 6048         	str	r0, [r1, #0x4]
;     pRT->forcedTeardown = (uint32_t)0U;
700ad43c: 9901         	ldr	r1, [sp, #0x4]
700ad43e: 2000         	movs	r0, #0x0
700ad440: 6108         	str	r0, [r1, #0x10]
;     pRT->pause          = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_PAUSE );
700ad442: 9900         	ldr	r1, [sp]
700ad444: f3c1 7140    	ubfx	r1, r1, #0x1d, #0x1
700ad448: 9a01         	ldr	r2, [sp, #0x4]
700ad44a: 6091         	str	r1, [r2, #0x8]
;     pRT->error          = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_ERROR );
700ad44c: 9900         	ldr	r1, [sp]
700ad44e: f001 0101    	and	r1, r1, #0x1
700ad452: 9a01         	ldr	r2, [sp, #0x4]
700ad454: 60d1         	str	r1, [r2, #0xc]
;     return CSL_PASS;
700ad456: b004         	add	sp, #0x10
700ad458: bd80         	pop	{r7, pc}
700ad45a: 0000         	movs	r0, r0
700ad45c: 0000         	movs	r0, r0
700ad45e: 0000         	movs	r0, r0

700ad460 <CSL_pktdmaGetTxRT>:
; {
700ad460: b580         	push	{r7, lr}
700ad462: b084         	sub	sp, #0x10
700ad464: 9003         	str	r0, [sp, #0xc]
700ad466: 9102         	str	r1, [sp, #0x8]
700ad468: 9201         	str	r2, [sp, #0x4]
;     val = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700ad46a: 9803         	ldr	r0, [sp, #0xc]
700ad46c: 6900         	ldr	r0, [r0, #0x10]
700ad46e: 9902         	ldr	r1, [sp, #0x8]
700ad470: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad474: f002 fbdc    	bl	0x700afc30 <CSL_REG32_RD_RAW> @ imm = #0x27b8
700ad478: 9000         	str	r0, [sp]
;     pRT->enable         = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_EN );
700ad47a: 9800         	ldr	r0, [sp]
700ad47c: 0fc0         	lsrs	r0, r0, #0x1f
700ad47e: 9901         	ldr	r1, [sp, #0x4]
700ad480: 6008         	str	r0, [r1]
;     pRT->teardown       = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_TDOWN );
700ad482: 9800         	ldr	r0, [sp]
700ad484: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700ad488: 9901         	ldr	r1, [sp, #0x4]
700ad48a: 6048         	str	r0, [r1, #0x4]
;     pRT->forcedTeardown = (uint32_t)0U;
700ad48c: 9901         	ldr	r1, [sp, #0x4]
700ad48e: 2000         	movs	r0, #0x0
700ad490: 6108         	str	r0, [r1, #0x10]
;     pRT->pause          = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_PAUSE );
700ad492: 9900         	ldr	r1, [sp]
700ad494: f3c1 7140    	ubfx	r1, r1, #0x1d, #0x1
700ad498: 9a01         	ldr	r2, [sp, #0x4]
700ad49a: 6091         	str	r1, [r2, #0x8]
;     pRT->error          = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_ERROR );
700ad49c: 9900         	ldr	r1, [sp]
700ad49e: f001 0101    	and	r1, r1, #0x1
700ad4a2: 9a01         	ldr	r2, [sp, #0x4]
700ad4a4: 60d1         	str	r1, [r2, #0xc]
;     return CSL_PASS;
700ad4a6: b004         	add	sp, #0x10
700ad4a8: bd80         	pop	{r7, pc}
700ad4aa: 0000         	movs	r0, r0
700ad4ac: 0000         	movs	r0, r0
700ad4ae: 0000         	movs	r0, r0

700ad4b0 <Sciclient_getDevId>:
; {
700ad4b0: b083         	sub	sp, #0xc
700ad4b2: 9002         	str	r0, [sp, #0x8]
700ad4b4: f04f 30ff    	mov.w	r0, #0xffffffff
;     uint32_t retVal = UINT32_MAX;
700ad4b8: 9001         	str	r0, [sp, #0x4]
;     switch (coreId)
700ad4ba: 9802         	ldr	r0, [sp, #0x8]
700ad4bc: 9000         	str	r0, [sp]
700ad4be: 2805         	cmp	r0, #0x5
700ad4c0: d817         	bhi	0x700ad4f2 <Sciclient_getDevId+0x42> @ imm = #0x2e
700ad4c2: 9900         	ldr	r1, [sp]
700ad4c4: e8df f001    	tbb	[pc, r1]
700ad4c8: 03 06 09 0c  	.word	0x0c090603
700ad4cc: 0f 12        	.short	0x120f
700ad4ce: 2009         	movs	r0, #0x9
;         retVal = TISCI_DEV_MCU_M4FSS0_CORE0;
700ad4d0: 9001         	str	r0, [sp, #0x4]
;         break;
700ad4d2: e00f         	b	0x700ad4f4 <Sciclient_getDevId+0x44> @ imm = #0x1e
700ad4d4: 2079         	movs	r0, #0x79
;         retVal = TISCI_DEV_R5FSS0_CORE0;
700ad4d6: 9001         	str	r0, [sp, #0x4]
;         break;
700ad4d8: e00c         	b	0x700ad4f4 <Sciclient_getDevId+0x44> @ imm = #0x18
700ad4da: 207a         	movs	r0, #0x7a
;         retVal = TISCI_DEV_R5FSS0_CORE1;
700ad4dc: 9001         	str	r0, [sp, #0x4]
;         break;
700ad4de: e009         	b	0x700ad4f4 <Sciclient_getDevId+0x44> @ imm = #0x12
700ad4e0: 207b         	movs	r0, #0x7b
;         retVal = TISCI_DEV_R5FSS1_CORE0;
700ad4e2: 9001         	str	r0, [sp, #0x4]
;         break;
700ad4e4: e006         	b	0x700ad4f4 <Sciclient_getDevId+0x44> @ imm = #0xc
700ad4e6: 207c         	movs	r0, #0x7c
;         retVal = TISCI_DEV_R5FSS1_CORE1;
700ad4e8: 9001         	str	r0, [sp, #0x4]
;         break;
700ad4ea: e003         	b	0x700ad4f4 <Sciclient_getDevId+0x44> @ imm = #0x6
700ad4ec: 2087         	movs	r0, #0x87
;         retVal = TISCI_DEV_A53SS0_CORE_0;
700ad4ee: 9001         	str	r0, [sp, #0x4]
;         break;
700ad4f0: e000         	b	0x700ad4f4 <Sciclient_getDevId+0x44> @ imm = #0x0
;         break;
700ad4f2: e7ff         	b	0x700ad4f4 <Sciclient_getDevId+0x44> @ imm = #-0x2
;     return retVal;
700ad4f4: 9801         	ldr	r0, [sp, #0x4]
700ad4f6: b003         	add	sp, #0xc
700ad4f8: 4770         	bx	lr
700ad4fa: 0000         	movs	r0, r0
700ad4fc: 0000         	movs	r0, r0
700ad4fe: 0000         	movs	r0, r0

700ad500 <UART_getIntrIdentityStatus>:
; {
700ad500: b580         	push	{r7, lr}
700ad502: b084         	sub	sp, #0x10
700ad504: 9003         	str	r0, [sp, #0xc]
700ad506: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ad508: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = 0U;
700ad50a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad50c: 9803         	ldr	r0, [sp, #0xc]
700ad50e: 300c         	adds	r0, #0xc
700ad510: f002 fb36    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x266c
700ad514: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ad516: 9803         	ldr	r0, [sp, #0xc]
700ad518: 300c         	adds	r0, #0xc
700ad51a: 9000         	str	r0, [sp]
700ad51c: f002 fb30    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x2660
700ad520: 4601         	mov	r1, r0
700ad522: 9800         	ldr	r0, [sp]
700ad524: f001 017f    	and	r1, r1, #0x7f
700ad528: f002 fb32    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x2664
;     retVal = HW_RD_REG32(baseAddr + UART_IIR) & UART_IIR_IT_TYPE_MASK;
700ad52c: 9803         	ldr	r0, [sp, #0xc]
700ad52e: 3008         	adds	r0, #0x8
700ad530: f002 fb26    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x264c
700ad534: f000 003e    	and	r0, r0, #0x3e
700ad538: 9001         	str	r0, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad53a: 9803         	ldr	r0, [sp, #0xc]
700ad53c: 300c         	adds	r0, #0xc
700ad53e: 9902         	ldr	r1, [sp, #0x8]
700ad540: f002 fb26    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x264c
;     return retVal;
700ad544: 9801         	ldr	r0, [sp, #0x4]
700ad546: b004         	add	sp, #0x10
700ad548: bd80         	pop	{r7, pc}
700ad54a: 0000         	movs	r0, r0
700ad54c: 0000         	movs	r0, r0
700ad54e: 0000         	movs	r0, r0

700ad550 <UART_lineCharConfig>:
; {
700ad550: b580         	push	{r7, lr}
700ad552: b084         	sub	sp, #0x10
700ad554: 9003         	str	r0, [sp, #0xc]
700ad556: 9102         	str	r1, [sp, #0x8]
700ad558: 9201         	str	r2, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad55a: 9803         	ldr	r0, [sp, #0xc]
700ad55c: 300c         	adds	r0, #0xc
700ad55e: f002 fb0f    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x261e
700ad562: 9000         	str	r0, [sp]
;     lcrRegValue &= ~((uint32_t) UART_LCR_NB_STOP_MASK | (uint32_t) UART_LCR_CHAR_LENGTH_MASK);
700ad564: 9800         	ldr	r0, [sp]
700ad566: f020 0007    	bic	r0, r0, #0x7
700ad56a: 9000         	str	r0, [sp]
;     lcrRegValue |= wLenStbFlag & (UART_LCR_NB_STOP_MASK |
700ad56c: 9802         	ldr	r0, [sp, #0x8]
700ad56e: f000 0107    	and	r1, r0, #0x7
700ad572: 9800         	ldr	r0, [sp]
700ad574: 4308         	orrs	r0, r1
700ad576: 9000         	str	r0, [sp]
;     lcrRegValue &= ~((uint32_t) UART_LCR_PARITY_TYPE2_MASK |
700ad578: 9800         	ldr	r0, [sp]
700ad57a: f020 0038    	bic	r0, r0, #0x38
700ad57e: 9000         	str	r0, [sp]
;     lcrRegValue |= parityFlag & (UART_LCR_PARITY_TYPE2_MASK |
700ad580: 9801         	ldr	r0, [sp, #0x4]
700ad582: f000 0138    	and	r1, r0, #0x38
700ad586: 9800         	ldr	r0, [sp]
700ad588: 4308         	orrs	r0, r1
700ad58a: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad58c: 9803         	ldr	r0, [sp, #0xc]
700ad58e: 300c         	adds	r0, #0xc
700ad590: 9900         	ldr	r1, [sp]
700ad592: f002 fafd    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x25fa
; }
700ad596: b004         	add	sp, #0x10
700ad598: bd80         	pop	{r7, pc}
700ad59a: 0000         	movs	r0, r0
700ad59c: 0000         	movs	r0, r0
700ad59e: 0000         	movs	r0, r0

700ad5a0 <UART_lld_dmaInit>:
; {
700ad5a0: b580         	push	{r7, lr}
700ad5a2: b084         	sub	sp, #0x10
700ad5a4: 9003         	str	r0, [sp, #0xc]
700ad5a6: 9102         	str	r1, [sp, #0x8]
700ad5a8: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700ad5aa: 9001         	str	r0, [sp, #0x4]
;     UART_UdmaChConfig *udmaChCfg = (UART_UdmaChConfig *)dmaChCfg;
700ad5ac: 9802         	ldr	r0, [sp, #0x8]
700ad5ae: 9000         	str	r0, [sp]
;     status  = UART_udmaInitRxCh(hUart, udmaChCfg);
700ad5b0: 9803         	ldr	r0, [sp, #0xc]
700ad5b2: 9900         	ldr	r1, [sp]
700ad5b4: f7f6 fef4    	bl	0x700a43a0 <UART_udmaInitRxCh> @ imm = #-0x9218
700ad5b8: 9001         	str	r0, [sp, #0x4]
;     status += UART_udmaInitTxCh(hUart, udmaChCfg);
700ad5ba: 9803         	ldr	r0, [sp, #0xc]
700ad5bc: 9900         	ldr	r1, [sp]
700ad5be: f7f6 ff7f    	bl	0x700a44c0 <UART_udmaInitTxCh> @ imm = #-0x9102
700ad5c2: 4601         	mov	r1, r0
700ad5c4: 9801         	ldr	r0, [sp, #0x4]
700ad5c6: 4408         	add	r0, r1
700ad5c8: 9001         	str	r0, [sp, #0x4]
;     if (status == UDMA_SOK)
700ad5ca: 9801         	ldr	r0, [sp, #0x4]
700ad5cc: b930         	cbnz	r0, 0x700ad5dc <UART_lld_dmaInit+0x3c> @ imm = #0xc
700ad5ce: e7ff         	b	0x700ad5d0 <UART_lld_dmaInit+0x30> @ imm = #-0x2
;         udmaChCfg->isOpen = TRUE;
700ad5d0: 9900         	ldr	r1, [sp]
700ad5d2: 2001         	movs	r0, #0x1
700ad5d4: 6388         	str	r0, [r1, #0x38]
700ad5d6: 2000         	movs	r0, #0x0
;         status = UART_TRANSFER_STATUS_SUCCESS;
700ad5d8: 9001         	str	r0, [sp, #0x4]
;     }
700ad5da: e003         	b	0x700ad5e4 <UART_lld_dmaInit+0x44> @ imm = #0x6
700ad5dc: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ad5e0: 9001         	str	r0, [sp, #0x4]
700ad5e2: e7ff         	b	0x700ad5e4 <UART_lld_dmaInit+0x44> @ imm = #-0x2
;     return status;
700ad5e4: 9801         	ldr	r0, [sp, #0x4]
700ad5e6: b004         	add	sp, #0x10
700ad5e8: bd80         	pop	{r7, pc}
700ad5ea: 0000         	movs	r0, r0
700ad5ec: 0000         	movs	r0, r0
700ad5ee: 0000         	movs	r0, r0

700ad5f0 <xQueueGenericCreateStatic>:
;     {
700ad5f0: b580         	push	{r7, lr}
700ad5f2: b088         	sub	sp, #0x20
700ad5f4: 4684         	mov	r12, r0
700ad5f6: 980a         	ldr	r0, [sp, #0x28]
700ad5f8: f8cd c01c    	str.w	r12, [sp, #0x1c]
700ad5fc: 9106         	str	r1, [sp, #0x18]
700ad5fe: 9205         	str	r2, [sp, #0x14]
700ad600: 9304         	str	r3, [sp, #0x10]
700ad602: f88d 000f    	strb.w	r0, [sp, #0xf]
;         pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
700ad606: 9804         	ldr	r0, [sp, #0x10]
700ad608: 9002         	str	r0, [sp, #0x8]
;         if( pxNewQueue != NULL )
700ad60a: 9802         	ldr	r0, [sp, #0x8]
700ad60c: b188         	cbz	r0, 0x700ad632 <xQueueGenericCreateStatic+0x42> @ imm = #0x22
700ad60e: e7ff         	b	0x700ad610 <xQueueGenericCreateStatic+0x20> @ imm = #-0x2
;                     pxNewQueue->ucStaticallyAllocated = pdTRUE;
700ad610: 9902         	ldr	r1, [sp, #0x8]
700ad612: 2001         	movs	r0, #0x1
700ad614: f881 0046    	strb.w	r0, [r1, #0x46]
;             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
700ad618: 9807         	ldr	r0, [sp, #0x1c]
700ad61a: 9906         	ldr	r1, [sp, #0x18]
700ad61c: 9a05         	ldr	r2, [sp, #0x14]
700ad61e: f89d 300f    	ldrb.w	r3, [sp, #0xf]
700ad622: f8dd c008    	ldr.w	r12, [sp, #0x8]
700ad626: 46ee         	mov	lr, sp
700ad628: f8ce c000    	str.w	r12, [lr]
700ad62c: f000 f850    	bl	0x700ad6d0 <prvInitialiseNewQueue> @ imm = #0xa0
;         }
700ad630: e000         	b	0x700ad634 <xQueueGenericCreateStatic+0x44> @ imm = #0x0
700ad632: e7ff         	b	0x700ad634 <xQueueGenericCreateStatic+0x44> @ imm = #-0x2
;         return pxNewQueue;
700ad634: 9802         	ldr	r0, [sp, #0x8]
700ad636: b008         	add	sp, #0x20
700ad638: bd80         	pop	{r7, pc}
700ad63a: 0000         	movs	r0, r0
700ad63c: 0000         	movs	r0, r0
700ad63e: 0000         	movs	r0, r0

700ad640 <UART_resetModule>:
; {
700ad640: b580         	push	{r7, lr}
700ad642: b082         	sub	sp, #0x8
700ad644: 9001         	str	r0, [sp, #0x4]
;     (void)UART_enhanFuncEnable(hUart->baseAddr);
700ad646: 9801         	ldr	r0, [sp, #0x4]
700ad648: 6800         	ldr	r0, [r0]
700ad64a: f000 fd41    	bl	0x700ae0d0 <UART_enhanFuncEnable> @ imm = #0xa82
;     UART_regConfModeRestore(hUart->baseAddr, 0x00U);
700ad64e: 9801         	ldr	r0, [sp, #0x4]
700ad650: 6800         	ldr	r0, [r0]
700ad652: 2100         	movs	r1, #0x0
700ad654: f002 f954    	bl	0x700af900 <UART_regConfModeRestore> @ imm = #0x22a8
;     UART_modemControlReset(hUart->baseAddr);
700ad658: 9801         	ldr	r0, [sp, #0x4]
700ad65a: 6800         	ldr	r0, [r0]
700ad65c: f002 f878    	bl	0x700af750 <UART_modemControlReset> @ imm = #0x20f0
;     UART_intrDisable(hUart->baseAddr, 0xFFU);
700ad660: 9801         	ldr	r0, [sp, #0x4]
700ad662: 6800         	ldr	r0, [r0]
700ad664: 21ff         	movs	r1, #0xff
700ad666: f7f8 fe7b    	bl	0x700a6360 <UART_intrDisable> @ imm = #-0x730a
;     UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700ad66a: 9801         	ldr	r0, [sp, #0x4]
700ad66c: 6800         	ldr	r0, [r0]
700ad66e: 2102         	movs	r1, #0x2
700ad670: f001 fb96    	bl	0x700aeda0 <UART_intr2Disable> @ imm = #0x172c
;     (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700ad674: 9801         	ldr	r0, [sp, #0x4]
700ad676: 6800         	ldr	r0, [r0]
700ad678: 2107         	movs	r1, #0x7
700ad67a: f001 fbd9    	bl	0x700aee30 <UART_operatingModeSelect> @ imm = #0x17b2
;     UART_moduleReset(hUart);
700ad67e: 9801         	ldr	r0, [sp, #0x4]
700ad680: f7fd f986    	bl	0x700aa990 <UART_moduleReset> @ imm = #-0x2cf4
;     return;
700ad684: b002         	add	sp, #0x8
700ad686: bd80         	pop	{r7, pc}

700ad688 <memccpy>:
700ad688: e92d4800     	push	{r11, lr}
700ad68c: e1a0c000     	mov	r12, r0
700ad690: e3a00000     	mov	r0, #0
700ad694: e3530000     	cmp	r3, #0
700ad698: 0a000009     	beq	0x700ad6c4 <memccpy+0x3c> @ imm = #0x24
700ad69c: e28cc001     	add	r12, r12, #1
700ad6a0: e6efe072     	uxtb	lr, r2
700ad6a4: e5d12000     	ldrb	r2, [r1]
700ad6a8: e152000e     	cmp	r2, lr
700ad6ac: e54c2001     	strb	r2, [r12, #-0x1]
700ad6b0: 0a000004     	beq	0x700ad6c8 <memccpy+0x40> @ imm = #0x10
700ad6b4: e2811001     	add	r1, r1, #1
700ad6b8: e2533001     	subs	r3, r3, #1
700ad6bc: e28cc001     	add	r12, r12, #1
700ad6c0: 1afffff7     	bne	0x700ad6a4 <memccpy+0x1c> @ imm = #-0x24
700ad6c4: e8bd8800     	pop	{r11, pc}
700ad6c8: e1a0000c     	mov	r0, r12
700ad6cc: e8bd8800     	pop	{r11, pc}

700ad6d0 <prvInitialiseNewQueue>:
; {
700ad6d0: b580         	push	{r7, lr}
700ad6d2: b084         	sub	sp, #0x10
700ad6d4: f8dd c018    	ldr.w	r12, [sp, #0x18]
700ad6d8: 9003         	str	r0, [sp, #0xc]
700ad6da: 9102         	str	r1, [sp, #0x8]
700ad6dc: 9201         	str	r2, [sp, #0x4]
700ad6de: f88d 3003    	strb.w	r3, [sp, #0x3]
;     if( uxItemSize == ( UBaseType_t ) 0 )
700ad6e2: 9802         	ldr	r0, [sp, #0x8]
700ad6e4: b918         	cbnz	r0, 0x700ad6ee <prvInitialiseNewQueue+0x1e> @ imm = #0x6
700ad6e6: e7ff         	b	0x700ad6e8 <prvInitialiseNewQueue+0x18> @ imm = #-0x2
;         pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
700ad6e8: 9806         	ldr	r0, [sp, #0x18]
700ad6ea: 6000         	str	r0, [r0]
;     }
700ad6ec: e003         	b	0x700ad6f6 <prvInitialiseNewQueue+0x26> @ imm = #0x6
;         pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
700ad6ee: 9801         	ldr	r0, [sp, #0x4]
700ad6f0: 9906         	ldr	r1, [sp, #0x18]
700ad6f2: 6008         	str	r0, [r1]
700ad6f4: e7ff         	b	0x700ad6f6 <prvInitialiseNewQueue+0x26> @ imm = #-0x2
;     pxNewQueue->uxLength = uxQueueLength;
700ad6f6: 9803         	ldr	r0, [sp, #0xc]
700ad6f8: 9906         	ldr	r1, [sp, #0x18]
700ad6fa: 63c8         	str	r0, [r1, #0x3c]
;     pxNewQueue->uxItemSize = uxItemSize;
700ad6fc: 9802         	ldr	r0, [sp, #0x8]
700ad6fe: 9906         	ldr	r1, [sp, #0x18]
700ad700: 6408         	str	r0, [r1, #0x40]
;     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
700ad702: 9806         	ldr	r0, [sp, #0x18]
700ad704: 2101         	movs	r1, #0x1
700ad706: f7fc fd9b    	bl	0x700aa240 <xQueueGenericReset> @ imm = #-0x34ca
;             pxNewQueue->ucQueueType = ucQueueType;
700ad70a: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ad70e: 9906         	ldr	r1, [sp, #0x18]
700ad710: f881 004c    	strb.w	r0, [r1, #0x4c]
; }
700ad714: b004         	add	sp, #0x10
700ad716: bd80         	pop	{r7, pc}
		...

700ad720 <uxListRemove>:
; {
700ad720: b082         	sub	sp, #0x8
700ad722: 9001         	str	r0, [sp, #0x4]
;     List_t * const pxList = pxItemToRemove->pxContainer;
700ad724: 9801         	ldr	r0, [sp, #0x4]
700ad726: 6900         	ldr	r0, [r0, #0x10]
700ad728: 9000         	str	r0, [sp]
;     pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
700ad72a: 9801         	ldr	r0, [sp, #0x4]
700ad72c: 6841         	ldr	r1, [r0, #0x4]
700ad72e: 6880         	ldr	r0, [r0, #0x8]
700ad730: 6088         	str	r0, [r1, #0x8]
;     pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
700ad732: 9901         	ldr	r1, [sp, #0x4]
700ad734: 6848         	ldr	r0, [r1, #0x4]
700ad736: 6889         	ldr	r1, [r1, #0x8]
700ad738: 6048         	str	r0, [r1, #0x4]
;     if( pxList->pxIndex == pxItemToRemove )
700ad73a: 9800         	ldr	r0, [sp]
700ad73c: 6840         	ldr	r0, [r0, #0x4]
700ad73e: 9901         	ldr	r1, [sp, #0x4]
700ad740: 4288         	cmp	r0, r1
700ad742: d105         	bne	0x700ad750 <uxListRemove+0x30> @ imm = #0xa
700ad744: e7ff         	b	0x700ad746 <uxListRemove+0x26> @ imm = #-0x2
;         pxList->pxIndex = pxItemToRemove->pxPrevious;
700ad746: 9801         	ldr	r0, [sp, #0x4]
700ad748: 6880         	ldr	r0, [r0, #0x8]
700ad74a: 9900         	ldr	r1, [sp]
700ad74c: 6048         	str	r0, [r1, #0x4]
;     }
700ad74e: e000         	b	0x700ad752 <uxListRemove+0x32> @ imm = #0x0
700ad750: e7ff         	b	0x700ad752 <uxListRemove+0x32> @ imm = #-0x2
;     pxItemToRemove->pxContainer = NULL;
700ad752: 9901         	ldr	r1, [sp, #0x4]
700ad754: 2000         	movs	r0, #0x0
700ad756: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )--;
700ad758: 9900         	ldr	r1, [sp]
700ad75a: 6808         	ldr	r0, [r1]
700ad75c: 3801         	subs	r0, #0x1
700ad75e: 6008         	str	r0, [r1]
;     return pxList->uxNumberOfItems;
700ad760: 9800         	ldr	r0, [sp]
700ad762: 6800         	ldr	r0, [r0]
700ad764: b002         	add	sp, #0x8
700ad766: 4770         	bx	lr
		...

700ad770 <CSL_bcdmaTeardownRxChan>:
; {
700ad770: b580         	push	{r7, lr}
700ad772: b086         	sub	sp, #0x18
700ad774: 9005         	str	r0, [sp, #0x14]
700ad776: 9104         	str	r1, [sp, #0x10]
700ad778: f88d 200f    	strb.w	r2, [sp, #0xf]
700ad77c: f88d 300e    	strb.w	r3, [sp, #0xe]
;     teardownOpts.force  = (bForce == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad780: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ad784: f000 0001    	and	r0, r0, #0x1
700ad788: 9000         	str	r0, [sp]
;     teardownOpts.wait   = (bWait  == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad78a: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700ad78e: f000 0001    	and	r0, r0, #0x1
700ad792: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_TEARDOWN, chanIdx, (void *)&teardownOpts );
700ad794: 9805         	ldr	r0, [sp, #0x14]
700ad796: 9a04         	ldr	r2, [sp, #0x10]
700ad798: 2105         	movs	r1, #0x5
700ad79a: 466b         	mov	r3, sp
700ad79c: f7fd fbf8    	bl	0x700aaf90 <CSL_bcdmaDoChanOp> @ imm = #-0x2810
700ad7a0: 9002         	str	r0, [sp, #0x8]
;     if( retVal != CSL_PASS )
700ad7a2: 9802         	ldr	r0, [sp, #0x8]
700ad7a4: b120         	cbz	r0, 0x700ad7b0 <CSL_bcdmaTeardownRxChan+0x40> @ imm = #0x8
700ad7a6: e7ff         	b	0x700ad7a8 <CSL_bcdmaTeardownRxChan+0x38> @ imm = #-0x2
700ad7a8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ad7ac: 9002         	str	r0, [sp, #0x8]
;     }
700ad7ae: e7ff         	b	0x700ad7b0 <CSL_bcdmaTeardownRxChan+0x40> @ imm = #-0x2
;     return retVal;
700ad7b0: 9802         	ldr	r0, [sp, #0x8]
700ad7b2: b006         	add	sp, #0x18
700ad7b4: bd80         	pop	{r7, pc}
		...
700ad7be: 0000         	movs	r0, r0

700ad7c0 <CSL_bcdmaTeardownTxChan>:
; {
700ad7c0: b580         	push	{r7, lr}
700ad7c2: b086         	sub	sp, #0x18
700ad7c4: 9005         	str	r0, [sp, #0x14]
700ad7c6: 9104         	str	r1, [sp, #0x10]
700ad7c8: f88d 200f    	strb.w	r2, [sp, #0xf]
700ad7cc: f88d 300e    	strb.w	r3, [sp, #0xe]
;     teardownOpts.force  = (bForce == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad7d0: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ad7d4: f000 0001    	and	r0, r0, #0x1
700ad7d8: 9000         	str	r0, [sp]
;     teardownOpts.wait   = (bWait  == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad7da: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700ad7de: f000 0001    	and	r0, r0, #0x1
700ad7e2: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_TEARDOWN, chanIdx, (void *)&teardownOpts );
700ad7e4: 9805         	ldr	r0, [sp, #0x14]
700ad7e6: 9a04         	ldr	r2, [sp, #0x10]
700ad7e8: 2105         	movs	r1, #0x5
700ad7ea: 466b         	mov	r3, sp
700ad7ec: f7fd fbd0    	bl	0x700aaf90 <CSL_bcdmaDoChanOp> @ imm = #-0x2860
700ad7f0: 9002         	str	r0, [sp, #0x8]
;     if( retVal != CSL_PASS )
700ad7f2: 9802         	ldr	r0, [sp, #0x8]
700ad7f4: b120         	cbz	r0, 0x700ad800 <CSL_bcdmaTeardownTxChan+0x40> @ imm = #0x8
700ad7f6: e7ff         	b	0x700ad7f8 <CSL_bcdmaTeardownTxChan+0x38> @ imm = #-0x2
700ad7f8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ad7fc: 9002         	str	r0, [sp, #0x8]
;     }
700ad7fe: e7ff         	b	0x700ad800 <CSL_bcdmaTeardownTxChan+0x40> @ imm = #-0x2
;     return retVal;
700ad800: 9802         	ldr	r0, [sp, #0x8]
700ad802: b006         	add	sp, #0x18
700ad804: bd80         	pop	{r7, pc}
		...
700ad80e: 0000         	movs	r0, r0

700ad810 <DebugP_uartLogWriterPutChar>:
; {
700ad810: b580         	push	{r7, lr}
700ad812: b088         	sub	sp, #0x20
700ad814: f88d 001f    	strb.w	r0, [sp, #0x1f]
;     char value = character;
700ad818: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700ad81c: f88d 001e    	strb.w	r0, [sp, #0x1e]
;     UART_Handle uartHandle = UART_getHandle(gDebugP_uartDrvIndex);
700ad820: f642 10f4    	movw	r0, #0x29f4
700ad824: f2c7 000b    	movt	r0, #0x700b
700ad828: 6800         	ldr	r0, [r0]
700ad82a: f7ff fd29    	bl	0x700ad280 <UART_getHandle> @ imm = #-0x5ae
700ad82e: 9006         	str	r0, [sp, #0x18]
;     if(uartHandle!=NULL)
700ad830: 9806         	ldr	r0, [sp, #0x18]
700ad832: b170         	cbz	r0, 0x700ad852 <DebugP_uartLogWriterPutChar+0x42> @ imm = #0x1c
700ad834: e7ff         	b	0x700ad836 <DebugP_uartLogWriterPutChar+0x26> @ imm = #-0x2
700ad836: a801         	add	r0, sp, #0x4
;         UART_Transaction_init(&trans);
700ad838: 9000         	str	r0, [sp]
700ad83a: f001 fa99    	bl	0x700aed70 <UART_Transaction_init> @ imm = #0x1532
700ad83e: 9900         	ldr	r1, [sp]
700ad840: f10d 001e    	add.w	r0, sp, #0x1e
;         trans.buf   = &value;
700ad844: 9001         	str	r0, [sp, #0x4]
700ad846: 2001         	movs	r0, #0x1
;         trans.count = 1;
700ad848: 9002         	str	r0, [sp, #0x8]
;         (void) UART_write(uartHandle, &trans);
700ad84a: 9806         	ldr	r0, [sp, #0x18]
700ad84c: f7f2 fe30    	bl	0x700a04b0 <UART_write> @ imm = #-0xd3a0
;     }
700ad850: e7ff         	b	0x700ad852 <DebugP_uartLogWriterPutChar+0x42> @ imm = #-0x2
; }
700ad852: b008         	add	sp, #0x20
700ad854: bd80         	pop	{r7, pc}
		...
700ad85e: 0000         	movs	r0, r0

700ad860 <Dpl_init>:
; {
700ad860: b510         	push	{r4, lr}
;     HwiP_init();
700ad862: f002 fcc5    	bl	0x700b01f0 <HwiP_init>  @ imm = #0x298a
;     DebugP_logZoneEnable(DebugP_LOG_ZONE_ERROR);
700ad866: 2002         	movs	r0, #0x2
700ad868: f001 f992    	bl	0x700aeb90 <DebugP_logZoneEnable> @ imm = #0x1324
;     DebugP_logZoneEnable(DebugP_LOG_ZONE_WARN);
700ad86c: 2004         	movs	r0, #0x4
700ad86e: f001 f98f    	bl	0x700aeb90 <DebugP_logZoneEnable> @ imm = #0x131e
;     DebugP_memLogWriterInit(CSL_CORE_ID_R5FSS0_0);
700ad872: 2001         	movs	r0, #0x1
700ad874: f001 fdcc    	bl	0x700af410 <DebugP_memLogWriterInit> @ imm = #0x1b98
;     DebugP_uartSetDrvIndex(CONFIG_UART_CONSOLE);
700ad878: 2000         	movs	r0, #0x0
700ad87a: 2400         	movs	r4, #0x0
700ad87c: f002 f870    	bl	0x700af960 <DebugP_uartSetDrvIndex> @ imm = #0x20e0
;     SOC_controlModuleUnlockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ad880: 2000         	movs	r0, #0x0
700ad882: 2102         	movs	r1, #0x2
700ad884: f7fb fb1c    	bl	0x700a8ec0 <SOC_controlModuleUnlockMMR> @ imm = #-0x49c8
700ad888: f248 10d0    	movw	r0, #0x81d0
;     SOC_controlModuleLockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ad88c: 2102         	movs	r1, #0x2
700ad88e: f2c4 3000    	movt	r0, #0x4300
;     *(volatile uint32_t*)(TIMER8_CLOCK_SRC_MUX_ADDR) = TIMER8_CLOCK_SRC_MCU_HFOSC0;
700ad892: 6004         	str	r4, [r0]
;     SOC_controlModuleLockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ad894: 2000         	movs	r0, #0x0
700ad896: f7fc fdab    	bl	0x700aa3f0 <SOC_controlModuleLockMMR> @ imm = #-0x34aa
;     ClockP_init();
700ad89a: f7f3 f881    	bl	0x700a09a0 <ClockP_init> @ imm = #-0xcefe
;     HwiP_enable();
700ad89e: e8bd 4010    	pop.w	{r4, lr}
700ad8a2: f7ef bba9    	b.w	0x7009cff8 <$Ven$TA$L$PI$$HwiP_enable> @ imm = #-0x108ae
		...
700ad8ae: 0000         	movs	r0, r0

700ad8b0 <UART_readLineStatus>:
; {
700ad8b0: b580         	push	{r7, lr}
700ad8b2: b084         	sub	sp, #0x10
700ad8b4: 9003         	str	r0, [sp, #0xc]
700ad8b6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ad8b8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = 0U;
700ad8ba: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad8bc: 9803         	ldr	r0, [sp, #0xc]
700ad8be: 300c         	adds	r0, #0xc
700ad8c0: f002 f95e    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x22bc
700ad8c4: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ad8c6: 9803         	ldr	r0, [sp, #0xc]
700ad8c8: 300c         	adds	r0, #0xc
700ad8ca: 9000         	str	r0, [sp]
700ad8cc: f002 f958    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x22b0
700ad8d0: 4601         	mov	r1, r0
700ad8d2: 9800         	ldr	r0, [sp]
700ad8d4: f001 017f    	and	r1, r1, #0x7f
700ad8d8: f002 f95a    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x22b4
;     retVal = HW_RD_REG32(baseAddr + UART_LSR);
700ad8dc: 9803         	ldr	r0, [sp, #0xc]
700ad8de: 3014         	adds	r0, #0x14
700ad8e0: f002 f94e    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x229c
700ad8e4: 9001         	str	r0, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad8e6: 9803         	ldr	r0, [sp, #0xc]
700ad8e8: 300c         	adds	r0, #0xc
700ad8ea: 9902         	ldr	r1, [sp, #0x8]
700ad8ec: f002 f950    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x22a0
;     return retVal;
700ad8f0: 9801         	ldr	r0, [sp, #0x4]
700ad8f2: b004         	add	sp, #0x10
700ad8f4: bd80         	pop	{r7, pc}
		...
700ad8fe: 0000         	movs	r0, r0

700ad900 <vTaskExitCritical>:
;   if (xSchedulerRunning != pdFALSE) {
700ad900: f642 2050    	movw	r0, #0x2a50
700ad904: f2c7 000b    	movt	r0, #0x700b
700ad908: 6800         	ldr	r0, [r0]
700ad90a: b1d0         	cbz	r0, 0x700ad942 <vTaskExitCritical+0x42> @ imm = #0x34
700ad90c: e7ff         	b	0x700ad90e <vTaskExitCritical+0xe> @ imm = #-0x2
;     if (pxCurrentTCB->uxCriticalNesting > 0U) {
700ad90e: f642 200c    	movw	r0, #0x2a0c
700ad912: f2c7 000b    	movt	r0, #0x700b
700ad916: 6800         	ldr	r0, [r0]
700ad918: 6d40         	ldr	r0, [r0, #0x54]
700ad91a: b180         	cbz	r0, 0x700ad93e <vTaskExitCritical+0x3e> @ imm = #0x20
700ad91c: e7ff         	b	0x700ad91e <vTaskExitCritical+0x1e> @ imm = #-0x2
;       (pxCurrentTCB->uxCriticalNesting)--;
700ad91e: f642 200c    	movw	r0, #0x2a0c
700ad922: f2c7 000b    	movt	r0, #0x700b
700ad926: 6802         	ldr	r2, [r0]
700ad928: 6d51         	ldr	r1, [r2, #0x54]
700ad92a: 3901         	subs	r1, #0x1
700ad92c: 6551         	str	r1, [r2, #0x54]
;       if (pxCurrentTCB->uxCriticalNesting == 0U) {
700ad92e: 6800         	ldr	r0, [r0]
700ad930: 6d40         	ldr	r0, [r0, #0x54]
700ad932: b910         	cbnz	r0, 0x700ad93a <vTaskExitCritical+0x3a> @ imm = #0x4
700ad934: e7ff         	b	0x700ad936 <vTaskExitCritical+0x36> @ imm = #-0x2
;     __asm__ volatile ( "CPSIE	i" ::: "cc" );
700ad936: b662         	cpsie i
;       } else {
700ad938: e000         	b	0x700ad93c <vTaskExitCritical+0x3c> @ imm = #0x0
700ad93a: e7ff         	b	0x700ad93c <vTaskExitCritical+0x3c> @ imm = #-0x2
;     } else {
700ad93c: e000         	b	0x700ad940 <vTaskExitCritical+0x40> @ imm = #0x0
700ad93e: e7ff         	b	0x700ad940 <vTaskExitCritical+0x40> @ imm = #-0x2
;   } else {
700ad940: e000         	b	0x700ad944 <vTaskExitCritical+0x44> @ imm = #0x0
700ad942: e7ff         	b	0x700ad944 <vTaskExitCritical+0x44> @ imm = #-0x2
; }
700ad944: 4770         	bx	lr
		...
700ad94e: 0000         	movs	r0, r0

700ad950 <CSL_bcdmaGetChanPeerReg>:
; {
700ad950: b580         	push	{r7, lr}
700ad952: b088         	sub	sp, #0x20
700ad954: f8dd c028    	ldr.w	r12, [sp, #0x28]
700ad958: 9007         	str	r0, [sp, #0x1c]
700ad95a: 9106         	str	r1, [sp, #0x18]
700ad95c: 9205         	str	r2, [sp, #0x14]
700ad95e: 9304         	str	r3, [sp, #0x10]
;     remotePeerOpts.regIdx = regIdx;
700ad960: 9804         	ldr	r0, [sp, #0x10]
700ad962: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_REMOTE_PEER_REG, chanIdx, (void *)&remotePeerOpts );
700ad964: 9807         	ldr	r0, [sp, #0x1c]
700ad966: 9a06         	ldr	r2, [sp, #0x18]
700ad968: 210b         	movs	r1, #0xb
700ad96a: ab01         	add	r3, sp, #0x4
700ad96c: f7fd fb10    	bl	0x700aaf90 <CSL_bcdmaDoChanOp> @ imm = #-0x29e0
700ad970: 9003         	str	r0, [sp, #0xc]
;     if( retVal == CSL_PASS )
700ad972: 9803         	ldr	r0, [sp, #0xc]
700ad974: b920         	cbnz	r0, 0x700ad980 <CSL_bcdmaGetChanPeerReg+0x30> @ imm = #0x8
700ad976: e7ff         	b	0x700ad978 <CSL_bcdmaGetChanPeerReg+0x28> @ imm = #-0x2
;         *pVal = remotePeerOpts.regVal;
700ad978: 9802         	ldr	r0, [sp, #0x8]
700ad97a: 990a         	ldr	r1, [sp, #0x28]
700ad97c: 6008         	str	r0, [r1]
;     }
700ad97e: e006         	b	0x700ad98e <CSL_bcdmaGetChanPeerReg+0x3e> @ imm = #0xc
;         *pVal = (uint32_t)0U;
700ad980: 990a         	ldr	r1, [sp, #0x28]
700ad982: 2000         	movs	r0, #0x0
700ad984: 6008         	str	r0, [r1]
700ad986: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ad98a: 9003         	str	r0, [sp, #0xc]
700ad98c: e7ff         	b	0x700ad98e <CSL_bcdmaGetChanPeerReg+0x3e> @ imm = #-0x2
;     return retVal;
700ad98e: 9803         	ldr	r0, [sp, #0xc]
700ad990: b008         	add	sp, #0x20
700ad992: bd80         	pop	{r7, pc}
		...

700ad9a0 <_strnlen_s>:
; {
700ad9a0: b084         	sub	sp, #0x10
700ad9a2: 9003         	str	r0, [sp, #0xc]
700ad9a4: 9102         	str	r1, [sp, #0x8]
;   for (s = str; *s && maxsize--; ++s);
700ad9a6: 9803         	ldr	r0, [sp, #0xc]
700ad9a8: 9001         	str	r0, [sp, #0x4]
700ad9aa: e7ff         	b	0x700ad9ac <_strnlen_s+0xc> @ imm = #-0x2
700ad9ac: 9801         	ldr	r0, [sp, #0x4]
700ad9ae: 7801         	ldrb	r1, [r0]
700ad9b0: 2000         	movs	r0, #0x0
700ad9b2: 9000         	str	r0, [sp]
700ad9b4: b141         	cbz	r1, 0x700ad9c8 <_strnlen_s+0x28> @ imm = #0x10
700ad9b6: e7ff         	b	0x700ad9b8 <_strnlen_s+0x18> @ imm = #-0x2
700ad9b8: 9802         	ldr	r0, [sp, #0x8]
700ad9ba: 1e41         	subs	r1, r0, #0x1
700ad9bc: 9102         	str	r1, [sp, #0x8]
700ad9be: 2800         	cmp	r0, #0x0
700ad9c0: bf18         	it	ne
700ad9c2: 2001         	movne	r0, #0x1
700ad9c4: 9000         	str	r0, [sp]
700ad9c6: e7ff         	b	0x700ad9c8 <_strnlen_s+0x28> @ imm = #-0x2
700ad9c8: 9800         	ldr	r0, [sp]
;   for (s = str; *s && maxsize--; ++s);
700ad9ca: 07c0         	lsls	r0, r0, #0x1f
700ad9cc: b128         	cbz	r0, 0x700ad9da <_strnlen_s+0x3a> @ imm = #0xa
700ad9ce: e7ff         	b	0x700ad9d0 <_strnlen_s+0x30> @ imm = #-0x2
700ad9d0: e7ff         	b	0x700ad9d2 <_strnlen_s+0x32> @ imm = #-0x2
700ad9d2: 9801         	ldr	r0, [sp, #0x4]
700ad9d4: 3001         	adds	r0, #0x1
700ad9d6: 9001         	str	r0, [sp, #0x4]
700ad9d8: e7e8         	b	0x700ad9ac <_strnlen_s+0xc> @ imm = #-0x30
;   return (unsigned int)(s - str);
700ad9da: 9801         	ldr	r0, [sp, #0x4]
700ad9dc: 9903         	ldr	r1, [sp, #0xc]
700ad9de: 1a40         	subs	r0, r0, r1
700ad9e0: b004         	add	sp, #0x10
700ad9e2: 4770         	bx	lr
		...

700ad9f0 <prvSampleTimeNow>:
;     {
700ad9f0: b580         	push	{r7, lr}
700ad9f2: b082         	sub	sp, #0x8
700ad9f4: 9001         	str	r0, [sp, #0x4]
;         xTimeNow = xTaskGetTickCount();
700ad9f6: f001 fdab    	bl	0x700af550 <xTaskGetTickCount> @ imm = #0x1b56
700ad9fa: 9000         	str	r0, [sp]
;         if( xTimeNow < xLastTime )
700ad9fc: 9800         	ldr	r0, [sp]
700ad9fe: f642 2108    	movw	r1, #0x2a08
700ada02: f2c7 010b    	movt	r1, #0x700b
700ada06: 6809         	ldr	r1, [r1]
700ada08: 4288         	cmp	r0, r1
700ada0a: d206         	bhs	0x700ada1a <prvSampleTimeNow+0x2a> @ imm = #0xc
700ada0c: e7ff         	b	0x700ada0e <prvSampleTimeNow+0x1e> @ imm = #-0x2
;             prvSwitchTimerLists();
700ada0e: f7f9 ff5f    	bl	0x700a78d0 <prvSwitchTimerLists> @ imm = #-0x6142
;             *pxTimerListsWereSwitched = pdTRUE;
700ada12: 9901         	ldr	r1, [sp, #0x4]
700ada14: 2001         	movs	r0, #0x1
700ada16: 6008         	str	r0, [r1]
;         }
700ada18: e003         	b	0x700ada22 <prvSampleTimeNow+0x32> @ imm = #0x6
;             *pxTimerListsWereSwitched = pdFALSE;
700ada1a: 9901         	ldr	r1, [sp, #0x4]
700ada1c: 2000         	movs	r0, #0x0
700ada1e: 6008         	str	r0, [r1]
700ada20: e7ff         	b	0x700ada22 <prvSampleTimeNow+0x32> @ imm = #-0x2
;         xLastTime = xTimeNow;
700ada22: 9800         	ldr	r0, [sp]
700ada24: f642 2108    	movw	r1, #0x2a08
700ada28: f2c7 010b    	movt	r1, #0x700b
700ada2c: 6008         	str	r0, [r1]
;         return xTimeNow;
700ada2e: 9800         	ldr	r0, [sp]
700ada30: b002         	add	sp, #0x8
700ada32: bd80         	pop	{r7, pc}
		...

700ada40 <CSL_udmapCppi5SetPktLen>:
; {
700ada40: b083         	sub	sp, #0xc
700ada42: 9002         	str	r0, [sp, #0x8]
700ada44: 9101         	str	r1, [sp, #0x4]
700ada46: 9200         	str	r2, [sp]
;     if( (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST) ||
700ada48: 9801         	ldr	r0, [sp, #0x4]
700ada4a: 2801         	cmp	r0, #0x1
700ada4c: d004         	beq	0x700ada58 <CSL_udmapCppi5SetPktLen+0x18> @ imm = #0x8
700ada4e: e7ff         	b	0x700ada50 <CSL_udmapCppi5SetPktLen+0x10> @ imm = #-0x2
;         (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_MONO) )
700ada50: 9801         	ldr	r0, [sp, #0x4]
;     if( (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST) ||
700ada52: 2802         	cmp	r0, #0x2
700ada54: d107         	bne	0x700ada66 <CSL_udmapCppi5SetPktLen+0x26> @ imm = #0xe
700ada56: e7ff         	b	0x700ada58 <CSL_udmapCppi5SetPktLen+0x18> @ imm = #-0x2
;         CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PKTLEN, pktLen );
700ada58: 9902         	ldr	r1, [sp, #0x8]
700ada5a: 6808         	ldr	r0, [r1]
700ada5c: 9a00         	ldr	r2, [sp]
700ada5e: f362 0015    	bfi	r0, r2, #0, #22
700ada62: 6008         	str	r0, [r1]
;     }
700ada64: e7ff         	b	0x700ada66 <CSL_udmapCppi5SetPktLen+0x26> @ imm = #-0x2
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700ada66: 9801         	ldr	r0, [sp, #0x4]
700ada68: 2803         	cmp	r0, #0x3
700ada6a: d108         	bne	0x700ada7e <CSL_udmapCppi5SetPktLen+0x3e> @ imm = #0x10
700ada6c: e7ff         	b	0x700ada6e <CSL_udmapCppi5SetPktLen+0x2e> @ imm = #-0x2
;         CSL_FINS( ((CSL_UdmapCppi5TRPD *)pDesc)->descInfo, UDMAP_CPPI5_TRPD_DESCINFO_LASTIDX, pktLen-1U );
700ada6e: 9902         	ldr	r1, [sp, #0x8]
700ada70: 6808         	ldr	r0, [r1]
700ada72: 9a00         	ldr	r2, [sp]
700ada74: 3a01         	subs	r2, #0x1
700ada76: f362 000d    	bfi	r0, r2, #0, #14
700ada7a: 6008         	str	r0, [r1]
;     }
700ada7c: e7ff         	b	0x700ada7e <CSL_udmapCppi5SetPktLen+0x3e> @ imm = #-0x2
; }
700ada7e: b003         	add	sp, #0xc
700ada80: 4770         	bx	lr
		...
700ada8e: 0000         	movs	r0, r0

700ada90 <Sciclient_rmIrqGetNodeItf>:
; {
700ada90: b084         	sub	sp, #0x10
700ada92: 9003         	str	r0, [sp, #0xc]
700ada94: f8ad 100a    	strh.w	r1, [sp, #0xa]
700ada98: 9201         	str	r2, [sp, #0x4]
700ada9a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ada9c: 9000         	str	r0, [sp]
;     if (n_itf < n->n_if) {
700ada9e: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700adaa2: 9903         	ldr	r1, [sp, #0xc]
700adaa4: 8849         	ldrh	r1, [r1, #0x2]
700adaa6: 4288         	cmp	r0, r1
700adaa8: da09         	bge	0x700adabe <Sciclient_rmIrqGetNodeItf+0x2e> @ imm = #0x12
700adaaa: e7ff         	b	0x700adaac <Sciclient_rmIrqGetNodeItf+0x1c> @ imm = #-0x2
;         *itf = n->p_if[n_itf];
700adaac: 9803         	ldr	r0, [sp, #0xc]
700adaae: 6840         	ldr	r0, [r0, #0x4]
700adab0: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700adab4: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700adab8: 9901         	ldr	r1, [sp, #0x4]
700adaba: 6008         	str	r0, [r1]
;     } else {
700adabc: e006         	b	0x700adacc <Sciclient_rmIrqGetNodeItf+0x3c> @ imm = #0xc
;         *itf = NULL;
700adabe: 9901         	ldr	r1, [sp, #0x4]
700adac0: 2000         	movs	r0, #0x0
700adac2: 6008         	str	r0, [r1]
700adac4: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700adac8: 9000         	str	r0, [sp]
700adaca: e7ff         	b	0x700adacc <Sciclient_rmIrqGetNodeItf+0x3c> @ imm = #-0x2
;     return r;
700adacc: 9800         	ldr	r0, [sp]
700adace: b004         	add	sp, #0x10
700adad0: 4770         	bx	lr
		...
700adade: 0000         	movs	r0, r0

700adae0 <UART_checkOpenParams>:
; {
700adae0: b082         	sub	sp, #0x8
700adae2: 9001         	str	r0, [sp, #0x4]
700adae4: 2000         	movs	r0, #0x0
;     int32_t     status = SystemP_SUCCESS;
700adae6: 9000         	str	r0, [sp]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->readMode) &&
700adae8: 9801         	ldr	r0, [sp, #0x4]
700adaea: 6900         	ldr	r0, [r0, #0x10]
700adaec: 2801         	cmp	r0, #0x1
700adaee: d108         	bne	0x700adb02 <UART_checkOpenParams+0x22> @ imm = #0x10
700adaf0: e7ff         	b	0x700adaf2 <UART_checkOpenParams+0x12> @ imm = #-0x2
;        (NULL_PTR == prms->readCallbackFxn))
700adaf2: 9801         	ldr	r0, [sp, #0x4]
700adaf4: 69c0         	ldr	r0, [r0, #0x1c]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->readMode) &&
700adaf6: b920         	cbnz	r0, 0x700adb02 <UART_checkOpenParams+0x22> @ imm = #0x8
700adaf8: e7ff         	b	0x700adafa <UART_checkOpenParams+0x1a> @ imm = #-0x2
700adafa: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700adafe: 9000         	str	r0, [sp]
;     }
700adb00: e7ff         	b	0x700adb02 <UART_checkOpenParams+0x22> @ imm = #-0x2
;     if((UART_TRANSFER_MODE_CALLBACK == prms->writeMode) &&
700adb02: 9801         	ldr	r0, [sp, #0x4]
700adb04: 6980         	ldr	r0, [r0, #0x18]
700adb06: 2801         	cmp	r0, #0x1
700adb08: d108         	bne	0x700adb1c <UART_checkOpenParams+0x3c> @ imm = #0x10
700adb0a: e7ff         	b	0x700adb0c <UART_checkOpenParams+0x2c> @ imm = #-0x2
;        (NULL_PTR == prms->writeCallbackFxn))
700adb0c: 9801         	ldr	r0, [sp, #0x4]
700adb0e: 6a00         	ldr	r0, [r0, #0x20]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->writeMode) &&
700adb10: b920         	cbnz	r0, 0x700adb1c <UART_checkOpenParams+0x3c> @ imm = #0x8
700adb12: e7ff         	b	0x700adb14 <UART_checkOpenParams+0x34> @ imm = #-0x2
700adb14: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700adb18: 9000         	str	r0, [sp]
;     }
700adb1a: e7ff         	b	0x700adb1c <UART_checkOpenParams+0x3c> @ imm = #-0x2
;     return (status);
700adb1c: 9800         	ldr	r0, [sp]
700adb1e: b002         	add	sp, #0x8
700adb20: 4770         	bx	lr
		...
700adb2e: 0000         	movs	r0, r0

700adb30 <UdmaUtils_getRingMemSize>:
; {
700adb30: b084         	sub	sp, #0x10
700adb32: f88d 000f    	strb.w	r0, [sp, #0xf]
700adb36: 9102         	str	r1, [sp, #0x8]
700adb38: f88d 2007    	strb.w	r2, [sp, #0x7]
;     ringMemSize = ((uint32_t) 1U << (elemSize + 2U));   /* Element size in bytes */
700adb3c: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700adb40: 1c81         	adds	r1, r0, #0x2
700adb42: 2001         	movs	r0, #0x1
700adb44: 4088         	lsls	r0, r1
700adb46: 9000         	str	r0, [sp]
;     ringMemSize *= elemCnt;
700adb48: 9902         	ldr	r1, [sp, #0x8]
700adb4a: 9800         	ldr	r0, [sp]
700adb4c: 4348         	muls	r0, r1, r0
700adb4e: 9000         	str	r0, [sp]
;     if((TISCI_MSG_VALUE_RM_RING_MODE_CREDENTIALS == mode) ||
700adb50: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700adb54: 2802         	cmp	r0, #0x2
700adb56: d005         	beq	0x700adb64 <UdmaUtils_getRingMemSize+0x34> @ imm = #0xa
700adb58: e7ff         	b	0x700adb5a <UdmaUtils_getRingMemSize+0x2a> @ imm = #-0x2
;        (TISCI_MSG_VALUE_RM_RING_MODE_QM == mode))
700adb5a: f89d 000f    	ldrb.w	r0, [sp, #0xf]
;     if((TISCI_MSG_VALUE_RM_RING_MODE_CREDENTIALS == mode) ||
700adb5e: 2803         	cmp	r0, #0x3
700adb60: d104         	bne	0x700adb6c <UdmaUtils_getRingMemSize+0x3c> @ imm = #0x8
700adb62: e7ff         	b	0x700adb64 <UdmaUtils_getRingMemSize+0x34> @ imm = #-0x2
;         ringMemSize <<= 1U;
700adb64: 9800         	ldr	r0, [sp]
700adb66: 0040         	lsls	r0, r0, #0x1
700adb68: 9000         	str	r0, [sp]
;     }
700adb6a: e7ff         	b	0x700adb6c <UdmaUtils_getRingMemSize+0x3c> @ imm = #-0x2
;     return (ringMemSize);
700adb6c: 9800         	ldr	r0, [sp]
700adb6e: b004         	add	sp, #0x10
700adb70: 4770         	bx	lr
		...
700adb7e: 0000         	movs	r0, r0

700adb80 <prvCopyDataFromQueue>:
; {
700adb80: b580         	push	{r7, lr}
700adb82: b082         	sub	sp, #0x8
700adb84: 9001         	str	r0, [sp, #0x4]
700adb86: 9100         	str	r1, [sp]
;     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
700adb88: 9801         	ldr	r0, [sp, #0x4]
700adb8a: 6c00         	ldr	r0, [r0, #0x40]
700adb8c: b1b8         	cbz	r0, 0x700adbbe <prvCopyDataFromQueue+0x3e> @ imm = #0x2e
700adb8e: e7ff         	b	0x700adb90 <prvCopyDataFromQueue+0x10> @ imm = #-0x2
;         pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
700adb90: 9901         	ldr	r1, [sp, #0x4]
700adb92: 68c8         	ldr	r0, [r1, #0xc]
700adb94: 6c0a         	ldr	r2, [r1, #0x40]
700adb96: 4410         	add	r0, r2
700adb98: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
700adb9a: 9801         	ldr	r0, [sp, #0x4]
700adb9c: 6881         	ldr	r1, [r0, #0x8]
700adb9e: 68c0         	ldr	r0, [r0, #0xc]
700adba0: 4288         	cmp	r0, r1
700adba2: d304         	blo	0x700adbae <prvCopyDataFromQueue+0x2e> @ imm = #0x8
700adba4: e7ff         	b	0x700adba6 <prvCopyDataFromQueue+0x26> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
700adba6: 9901         	ldr	r1, [sp, #0x4]
700adba8: 6808         	ldr	r0, [r1]
700adbaa: 60c8         	str	r0, [r1, #0xc]
;         }
700adbac: e000         	b	0x700adbb0 <prvCopyDataFromQueue+0x30> @ imm = #0x0
700adbae: e7ff         	b	0x700adbb0 <prvCopyDataFromQueue+0x30> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
700adbb0: 9800         	ldr	r0, [sp]
700adbb2: 9a01         	ldr	r2, [sp, #0x4]
700adbb4: 68d1         	ldr	r1, [r2, #0xc]
700adbb6: 6c12         	ldr	r2, [r2, #0x40]
700adbb8: f7ec ea90    	blx	0x7009a0dc <__aeabi_memcpy8> @ imm = #-0x13ae0
;     }
700adbbc: e7ff         	b	0x700adbbe <prvCopyDataFromQueue+0x3e> @ imm = #-0x2
; }
700adbbe: b002         	add	sp, #0x8
700adbc0: bd80         	pop	{r7, pc}
		...
700adbce: 0000         	movs	r0, r0

700adbd0 <CSL_lcdma_ringaccIsTeardownComplete>:
; {
700adbd0: b580         	push	{r7, lr}
700adbd2: b084         	sub	sp, #0x10
700adbd4: 9003         	str	r0, [sp, #0xc]
700adbd6: 9102         	str	r1, [sp, #0x8]
700adbd8: 2000         	movs	r0, #0x0
;     bool bRetVal = (bool)false;
700adbda: f88d 0007    	strb.w	r0, [sp, #0x7]
;     if( CSL_REG32_FEXT( &pCfg->pRingRtRegs->RING[ringNum].ROCC, LCDMA_RINGACC_RINGRT_RING_ROCC_COMP ) != (uint32_t)0U )
700adbde: 9803         	ldr	r0, [sp, #0xc]
700adbe0: 6840         	ldr	r0, [r0, #0x4]
700adbe2: 9902         	ldr	r1, [sp, #0x8]
700adbe4: eb00 3041    	add.w	r0, r0, r1, lsl #13
700adbe8: f241 0118    	movw	r1, #0x1018
700adbec: 4408         	add	r0, r1
700adbee: f04f 4100    	mov.w	r1, #0x80000000
700adbf2: 221f         	movs	r2, #0x1f
700adbf4: f001 fa6c    	bl	0x700af0d0 <CSL_REG32_FEXT_RAW> @ imm = #0x14d8
700adbf8: b120         	cbz	r0, 0x700adc04 <CSL_lcdma_ringaccIsTeardownComplete+0x34> @ imm = #0x8
700adbfa: e7ff         	b	0x700adbfc <CSL_lcdma_ringaccIsTeardownComplete+0x2c> @ imm = #-0x2
700adbfc: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700adbfe: f88d 0007    	strb.w	r0, [sp, #0x7]
;     }
700adc02: e7ff         	b	0x700adc04 <CSL_lcdma_ringaccIsTeardownComplete+0x34> @ imm = #-0x2
;     return bRetVal;
700adc04: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700adc08: f000 0001    	and	r0, r0, #0x1
700adc0c: b004         	add	sp, #0x10
700adc0e: bd80         	pop	{r7, pc}

700adc10 <Sciclient_rmIrqProgramOesRegister>:
; {
700adc10: b580         	push	{r7, lr}
700adc12: b088         	sub	sp, #0x20
700adc14: 9007         	str	r0, [sp, #0x1c]
700adc16: 2010         	movs	r0, #0x10
700adc18: f2c8 0000    	movt	r0, #0x8000
;     req.valid_params = (TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID |
700adc1c: 9002         	str	r0, [sp, #0x8]
;     req.secondary_host = cfg->host;
700adc1e: 9807         	ldr	r0, [sp, #0x1c]
700adc20: 7900         	ldrb	r0, [r0, #0x4]
700adc22: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     req.src_id = cfg->s_id;
700adc26: 9807         	ldr	r0, [sp, #0x1c]
700adc28: 88c0         	ldrh	r0, [r0, #0x6]
700adc2a: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     req.src_index = cfg->s_idx;
700adc2e: 9807         	ldr	r0, [sp, #0x1c]
700adc30: 8900         	ldrh	r0, [r0, #0x8]
700adc32: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     req.global_event = cfg->global_evt;
700adc36: 9807         	ldr	r0, [sp, #0x1c]
700adc38: 89c0         	ldrh	r0, [r0, #0xe]
700adc3a: f8ad 0018    	strh.w	r0, [sp, #0x18]
;                                  cfg->set_resp,
700adc3e: 9807         	ldr	r0, [sp, #0x1c]
700adc40: 6981         	ldr	r1, [r0, #0x18]
700adc42: 4668         	mov	r0, sp
700adc44: f04f 32ff    	mov.w	r2, #0xffffffff
;     return Sciclient_rmIrqSetRaw(&req,
700adc48: f7fe fe02    	bl	0x700ac850 <Sciclient_rmIrqSetRaw> @ imm = #-0x13fc
700adc4c: b008         	add	sp, #0x20
700adc4e: bd80         	pop	{r7, pc}

700adc50 <Sciclient_rmPsGetIfIdx>:
; {
700adc50: b082         	sub	sp, #0x8
700adc52: f8ad 0006    	strh.w	r0, [sp, #0x6]
700adc56: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700adc5a: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700adc5c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adc60: f241 0158    	movw	r1, #0x1058
700adc64: f2c7 0108    	movt	r1, #0x7008
700adc68: 8c89         	ldrh	r1, [r1, #0x24]
700adc6a: 4288         	cmp	r0, r1
700adc6c: da0d         	bge	0x700adc8a <Sciclient_rmPsGetIfIdx+0x3a> @ imm = #0x1a
700adc6e: e7ff         	b	0x700adc70 <Sciclient_rmPsGetIfIdx+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].if_idx;
700adc70: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adc74: eb00 0140    	add.w	r1, r0, r0, lsl #1
700adc78: f241 0058    	movw	r0, #0x1058
700adc7c: f2c7 0008    	movt	r0, #0x7008
700adc80: eb00 0081    	add.w	r0, r0, r1, lsl #2
700adc84: 8880         	ldrh	r0, [r0, #0x4]
700adc86: 9000         	str	r0, [sp]
;     }
700adc88: e7ff         	b	0x700adc8a <Sciclient_rmPsGetIfIdx+0x3a> @ imm = #-0x2
;     return r;
700adc8a: 9800         	ldr	r0, [sp]
700adc8c: b002         	add	sp, #0x8
700adc8e: 4770         	bx	lr

700adc90 <Sciclient_rmPsGetInp>:
; {
700adc90: b082         	sub	sp, #0x8
700adc92: f8ad 0006    	strh.w	r0, [sp, #0x6]
700adc96: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700adc9a: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700adc9c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adca0: f241 0158    	movw	r1, #0x1058
700adca4: f2c7 0108    	movt	r1, #0x7008
700adca8: 8c89         	ldrh	r1, [r1, #0x24]
700adcaa: 4288         	cmp	r0, r1
700adcac: da0d         	bge	0x700adcca <Sciclient_rmPsGetInp+0x3a> @ imm = #0x1a
700adcae: e7ff         	b	0x700adcb0 <Sciclient_rmPsGetInp+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].inp;
700adcb0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adcb4: eb00 0140    	add.w	r1, r0, r0, lsl #1
700adcb8: f241 0058    	movw	r0, #0x1058
700adcbc: f2c7 0008    	movt	r0, #0x7008
700adcc0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700adcc4: 88c0         	ldrh	r0, [r0, #0x6]
700adcc6: 9000         	str	r0, [sp]
;     }
700adcc8: e7ff         	b	0x700adcca <Sciclient_rmPsGetInp+0x3a> @ imm = #-0x2
;     return r;
700adcca: 9800         	ldr	r0, [sp]
700adccc: b002         	add	sp, #0x8
700adcce: 4770         	bx	lr

700adcd0 <Sciclient_rmPsGetOutp>:
; {
700adcd0: b082         	sub	sp, #0x8
700adcd2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700adcd6: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700adcda: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700adcdc: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adce0: f241 0158    	movw	r1, #0x1058
700adce4: f2c7 0108    	movt	r1, #0x7008
700adce8: 8c89         	ldrh	r1, [r1, #0x24]
700adcea: 4288         	cmp	r0, r1
700adcec: da0d         	bge	0x700add0a <Sciclient_rmPsGetOutp+0x3a> @ imm = #0x1a
700adcee: e7ff         	b	0x700adcf0 <Sciclient_rmPsGetOutp+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].outp;
700adcf0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adcf4: eb00 0140    	add.w	r1, r0, r0, lsl #1
700adcf8: f241 0058    	movw	r0, #0x1058
700adcfc: f2c7 0008    	movt	r0, #0x7008
700add00: eb00 0081    	add.w	r0, r0, r1, lsl #2
700add04: 8900         	ldrh	r0, [r0, #0x8]
700add06: 9000         	str	r0, [sp]
;     }
700add08: e7ff         	b	0x700add0a <Sciclient_rmPsGetOutp+0x3a> @ imm = #-0x2
;     return r;
700add0a: 9800         	ldr	r0, [sp]
700add0c: b002         	add	sp, #0x8
700add0e: 4770         	bx	lr

700add10 <free_list_insert>:
700add10: e5902000     	ldr	r2, [r0]
700add14: e59f1030     	ldr	r1, [pc, #0x30]         @ 0x700add4c <free_list_insert+0x3c>
700add18: e3c2c001     	bic	r12, r2, #1
700add1c: e5913000     	ldr	r3, [r1]
700add20: e3530000     	cmp	r3, #0
700add24: 0a000005     	beq	0x700add40 <free_list_insert+0x30> @ imm = #0x14
700add28: e5932000     	ldr	r2, [r3]
700add2c: e3c22001     	bic	r2, r2, #1
700add30: e152000c     	cmp	r2, r12
700add34: 2a000001     	bhs	0x700add40 <free_list_insert+0x30> @ imm = #0x4
700add38: e2831008     	add	r1, r3, #8
700add3c: eafffff6     	b	0x700add1c <free_list_insert+0xc> @ imm = #-0x28
700add40: e5803008     	str	r3, [r0, #0x8]
700add44: e5810000     	str	r0, [r1]
700add48: e12fff1e     	bx	lr
700add4c: ac 52 08 70  	.word	0x700852ac

700add50 <prvGetNextExpireTime>:
;     {
700add50: b082         	sub	sp, #0x8
700add52: 9001         	str	r0, [sp, #0x4]
;         *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
700add54: f245 209c    	movw	r0, #0x529c
700add58: f2c7 0008    	movt	r0, #0x7008
700add5c: 6800         	ldr	r0, [r0]
700add5e: 6800         	ldr	r0, [r0]
700add60: fab0 f080    	clz	r0, r0
700add64: 0940         	lsrs	r0, r0, #0x5
700add66: 9901         	ldr	r1, [sp, #0x4]
700add68: 6008         	str	r0, [r1]
;         if( *pxListWasEmpty == pdFALSE )
700add6a: 9801         	ldr	r0, [sp, #0x4]
700add6c: 6800         	ldr	r0, [r0]
700add6e: b948         	cbnz	r0, 0x700add84 <prvGetNextExpireTime+0x34> @ imm = #0x12
700add70: e7ff         	b	0x700add72 <prvGetNextExpireTime+0x22> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
700add72: f245 209c    	movw	r0, #0x529c
700add76: f2c7 0008    	movt	r0, #0x7008
700add7a: 6800         	ldr	r0, [r0]
700add7c: 68c0         	ldr	r0, [r0, #0xc]
700add7e: 6800         	ldr	r0, [r0]
700add80: 9000         	str	r0, [sp]
;         }
700add82: e002         	b	0x700add8a <prvGetNextExpireTime+0x3a> @ imm = #0x4
700add84: 2000         	movs	r0, #0x0
;             xNextExpireTime = ( TickType_t ) 0U;
700add86: 9000         	str	r0, [sp]
700add88: e7ff         	b	0x700add8a <prvGetNextExpireTime+0x3a> @ imm = #-0x2
;         return xNextExpireTime;
700add8a: 9800         	ldr	r0, [sp]
700add8c: b002         	add	sp, #0x8
700add8e: 4770         	bx	lr

700add90 <Sciclient_secProxyWaitThread>:
; {
700add90: b580         	push	{r7, lr}
700add92: b084         	sub	sp, #0x10
700add94: 9003         	str	r0, [sp, #0xc]
700add96: 9102         	str	r1, [sp, #0x8]
700add98: f06f 0003    	mvn	r0, #0x3
;     int32_t  status     = CSL_ETIMEOUT;
700add9c: 9001         	str	r0, [sp, #0x4]
;     uint32_t timeToWait = timeout;
700add9e: 9802         	ldr	r0, [sp, #0x8]
700adda0: 9000         	str	r0, [sp]
;     while (timeToWait > 0U)
700adda2: e7ff         	b	0x700adda4 <Sciclient_secProxyWaitThread+0x14> @ imm = #-0x2
700adda4: 9800         	ldr	r0, [sp]
700adda6: b178         	cbz	r0, 0x700addc8 <Sciclient_secProxyWaitThread+0x38> @ imm = #0x1e
700adda8: e7ff         	b	0x700addaa <Sciclient_secProxyWaitThread+0x1a> @ imm = #-0x2
;         if ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700addaa: 9803         	ldr	r0, [sp, #0xc]
700addac: f001 fc90    	bl	0x700af6d0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x1920
700addb0: f001 ff46    	bl	0x700afc40 <CSL_REG32_RD_RAW> @ imm = #0x1e8c
700addb4: 0600         	lsls	r0, r0, #0x18
700addb6: b118         	cbz	r0, 0x700addc0 <Sciclient_secProxyWaitThread+0x30> @ imm = #0x6
700addb8: e7ff         	b	0x700addba <Sciclient_secProxyWaitThread+0x2a> @ imm = #-0x2
700addba: 2000         	movs	r0, #0x0
;             status = SystemP_SUCCESS;
700addbc: 9001         	str	r0, [sp, #0x4]
;             break;
700addbe: e003         	b	0x700addc8 <Sciclient_secProxyWaitThread+0x38> @ imm = #0x6
;         timeToWait--;
700addc0: 9800         	ldr	r0, [sp]
700addc2: 3801         	subs	r0, #0x1
700addc4: 9000         	str	r0, [sp]
;     while (timeToWait > 0U)
700addc6: e7ed         	b	0x700adda4 <Sciclient_secProxyWaitThread+0x14> @ imm = #-0x26
;     return status;
700addc8: 9801         	ldr	r0, [sp, #0x4]
700addca: b004         	add	sp, #0x10
700addcc: bd80         	pop	{r7, pc}
700addce: 0000         	movs	r0, r0

700addd0 <UART_IsHWFlowCtrlValid>:
; {
700addd0: b082         	sub	sp, #0x8
700addd2: 9001         	str	r0, [sp, #0x4]
700addd4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700addd8: 9000         	str	r0, [sp]
;     if(((hwFlowControlThr == UART_RXTRIGLVL_1)  ||
700addda: 9801         	ldr	r0, [sp, #0x4]
700adddc: 2801         	cmp	r0, #0x1
700addde: d010         	beq	0x700ade02 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x20
700adde0: e7ff         	b	0x700adde2 <UART_IsHWFlowCtrlValid+0x12> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_8)  ||
700adde2: 9801         	ldr	r0, [sp, #0x4]
700adde4: 2808         	cmp	r0, #0x8
700adde6: d00c         	beq	0x700ade02 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x18
700adde8: e7ff         	b	0x700addea <UART_IsHWFlowCtrlValid+0x1a> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_16) ||
700addea: 9801         	ldr	r0, [sp, #0x4]
700addec: 2810         	cmp	r0, #0x10
700addee: d008         	beq	0x700ade02 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x10
700addf0: e7ff         	b	0x700addf2 <UART_IsHWFlowCtrlValid+0x22> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_56) ||
700addf2: 9801         	ldr	r0, [sp, #0x4]
700addf4: 2838         	cmp	r0, #0x38
700addf6: d004         	beq	0x700ade02 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x8
700addf8: e7ff         	b	0x700addfa <UART_IsHWFlowCtrlValid+0x2a> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_60)))
700addfa: 9801         	ldr	r0, [sp, #0x4]
;     if(((hwFlowControlThr == UART_RXTRIGLVL_1)  ||
700addfc: 283c         	cmp	r0, #0x3c
700addfe: d103         	bne	0x700ade08 <UART_IsHWFlowCtrlValid+0x38> @ imm = #0x6
700ade00: e7ff         	b	0x700ade02 <UART_IsHWFlowCtrlValid+0x32> @ imm = #-0x2
700ade02: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ade04: 9000         	str	r0, [sp]
;     }
700ade06: e7ff         	b	0x700ade08 <UART_IsHWFlowCtrlValid+0x38> @ imm = #-0x2
;     return status;
700ade08: 9800         	ldr	r0, [sp]
700ade0a: b002         	add	sp, #0x8
700ade0c: 4770         	bx	lr
700ade0e: 0000         	movs	r0, r0

700ade10 <UART_IsRxTrigLvlValid>:
; {
700ade10: b082         	sub	sp, #0x8
700ade12: 9001         	str	r0, [sp, #0x4]
700ade14: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ade18: 9000         	str	r0, [sp]
;     if(((rxTrigLvl == UART_RXTRIGLVL_1)  ||
700ade1a: 9801         	ldr	r0, [sp, #0x4]
700ade1c: 2801         	cmp	r0, #0x1
700ade1e: d010         	beq	0x700ade42 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x20
700ade20: e7ff         	b	0x700ade22 <UART_IsRxTrigLvlValid+0x12> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_8)  ||
700ade22: 9801         	ldr	r0, [sp, #0x4]
700ade24: 2808         	cmp	r0, #0x8
700ade26: d00c         	beq	0x700ade42 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x18
700ade28: e7ff         	b	0x700ade2a <UART_IsRxTrigLvlValid+0x1a> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_16) ||
700ade2a: 9801         	ldr	r0, [sp, #0x4]
700ade2c: 2810         	cmp	r0, #0x10
700ade2e: d008         	beq	0x700ade42 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x10
700ade30: e7ff         	b	0x700ade32 <UART_IsRxTrigLvlValid+0x22> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_56) ||
700ade32: 9801         	ldr	r0, [sp, #0x4]
700ade34: 2838         	cmp	r0, #0x38
700ade36: d004         	beq	0x700ade42 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x8
700ade38: e7ff         	b	0x700ade3a <UART_IsRxTrigLvlValid+0x2a> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_60)))
700ade3a: 9801         	ldr	r0, [sp, #0x4]
;     if(((rxTrigLvl == UART_RXTRIGLVL_1)  ||
700ade3c: 283c         	cmp	r0, #0x3c
700ade3e: d103         	bne	0x700ade48 <UART_IsRxTrigLvlValid+0x38> @ imm = #0x6
700ade40: e7ff         	b	0x700ade42 <UART_IsRxTrigLvlValid+0x32> @ imm = #-0x2
700ade42: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ade44: 9000         	str	r0, [sp]
;     }
700ade46: e7ff         	b	0x700ade48 <UART_IsRxTrigLvlValid+0x38> @ imm = #-0x2
;     return status;
700ade48: 9800         	ldr	r0, [sp]
700ade4a: b002         	add	sp, #0x8
700ade4c: 4770         	bx	lr
700ade4e: 0000         	movs	r0, r0

700ade50 <UART_IsTxTrigLvlValid>:
; {
700ade50: b082         	sub	sp, #0x8
700ade52: 9001         	str	r0, [sp, #0x4]
700ade54: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ade58: 9000         	str	r0, [sp]
;     if(((txTrigLvl == UART_TXTRIGLVL_1)  ||
700ade5a: 9801         	ldr	r0, [sp, #0x4]
700ade5c: 2801         	cmp	r0, #0x1
700ade5e: d010         	beq	0x700ade82 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x20
700ade60: e7ff         	b	0x700ade62 <UART_IsTxTrigLvlValid+0x12> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_8)  ||
700ade62: 9801         	ldr	r0, [sp, #0x4]
700ade64: 2808         	cmp	r0, #0x8
700ade66: d00c         	beq	0x700ade82 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x18
700ade68: e7ff         	b	0x700ade6a <UART_IsTxTrigLvlValid+0x1a> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_16) ||
700ade6a: 9801         	ldr	r0, [sp, #0x4]
700ade6c: 2810         	cmp	r0, #0x10
700ade6e: d008         	beq	0x700ade82 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x10
700ade70: e7ff         	b	0x700ade72 <UART_IsTxTrigLvlValid+0x22> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_32) ||
700ade72: 9801         	ldr	r0, [sp, #0x4]
700ade74: 2820         	cmp	r0, #0x20
700ade76: d004         	beq	0x700ade82 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x8
700ade78: e7ff         	b	0x700ade7a <UART_IsTxTrigLvlValid+0x2a> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_56)))
700ade7a: 9801         	ldr	r0, [sp, #0x4]
;     if(((txTrigLvl == UART_TXTRIGLVL_1)  ||
700ade7c: 2838         	cmp	r0, #0x38
700ade7e: d103         	bne	0x700ade88 <UART_IsTxTrigLvlValid+0x38> @ imm = #0x6
700ade80: e7ff         	b	0x700ade82 <UART_IsTxTrigLvlValid+0x32> @ imm = #-0x2
700ade82: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ade84: 9000         	str	r0, [sp]
;     }
700ade86: e7ff         	b	0x700ade88 <UART_IsTxTrigLvlValid+0x38> @ imm = #-0x2
;     return status;
700ade88: 9800         	ldr	r0, [sp]
700ade8a: b002         	add	sp, #0x8
700ade8c: 4770         	bx	lr
700ade8e: 0000         	movs	r0, r0

700ade90 <UART_i2310WA>:
; {
700ade90: b580         	push	{r7, lr}
700ade92: b084         	sub	sp, #0x10
700ade94: 9003         	str	r0, [sp, #0xc]
;     HW_WR_REG32(baseAddr + UART_TIMEOUTL, 0xFF);
700ade96: 9803         	ldr	r0, [sp, #0xc]
700ade98: 3098         	adds	r0, #0x98
700ade9a: 21ff         	movs	r1, #0xff
700ade9c: 9101         	str	r1, [sp, #0x4]
700ade9e: f001 fe77    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x1cee
700adea2: 9901         	ldr	r1, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_TIMEOUTH, 0xFF);
700adea4: 9803         	ldr	r0, [sp, #0xc]
700adea6: 309c         	adds	r0, #0x9c
700adea8: f001 fe72    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x1ce4
;     HW_WR_FIELD32(baseAddr + UART_EFR2, UART_EFR2_TIMEOUT_BEHAVE, 1);
700adeac: 9803         	ldr	r0, [sp, #0xc]
700adeae: 308c         	adds	r0, #0x8c
700adeb0: 2206         	movs	r2, #0x6
700adeb2: 9202         	str	r2, [sp, #0x8]
700adeb4: 2301         	movs	r3, #0x1
700adeb6: 4611         	mov	r1, r2
700adeb8: f000 fc02    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x804
700adebc: 9a02         	ldr	r2, [sp, #0x8]
;     HW_WR_FIELD32(baseAddr + UART_EFR2, UART_EFR2_TIMEOUT_BEHAVE, 0);
700adebe: 9803         	ldr	r0, [sp, #0xc]
700adec0: 308c         	adds	r0, #0x8c
700adec2: 2300         	movs	r3, #0x0
700adec4: 4611         	mov	r1, r2
700adec6: f000 fbfb    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x7f6
; }
700adeca: b004         	add	sp, #0x10
700adecc: bd80         	pop	{r7, pc}
700adece: 0000         	movs	r0, r0

700aded0 <UART_spaceAvail>:
; {
700aded0: b580         	push	{r7, lr}
700aded2: b084         	sub	sp, #0x10
700aded4: 9003         	str	r0, [sp, #0xc]
700aded6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700aded8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700adeda: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700adedc: 9803         	ldr	r0, [sp, #0xc]
700adede: 217f         	movs	r1, #0x7f
700adee0: f7fe fc56    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #-0x1754
700adee4: 9002         	str	r0, [sp, #0x8]
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700adee6: 9803         	ldr	r0, [sp, #0xc]
700adee8: 3014         	adds	r0, #0x14
700adeea: f001 fe49    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x1c92
700adeee: f000 0060    	and	r0, r0, #0x60
;     if ((UART_LSR_TX_SR_E_MASK | UART_LSR_TX_FIFO_E_MASK) ==
700adef2: 2860         	cmp	r0, #0x60
700adef4: d103         	bne	0x700adefe <UART_spaceAvail+0x2e> @ imm = #0x6
700adef6: e7ff         	b	0x700adef8 <UART_spaceAvail+0x28> @ imm = #-0x2
700adef8: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700adefa: 9001         	str	r0, [sp, #0x4]
;     }
700adefc: e7ff         	b	0x700adefe <UART_spaceAvail+0x2e> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700adefe: 9803         	ldr	r0, [sp, #0xc]
700adf00: 300c         	adds	r0, #0xc
700adf02: 9902         	ldr	r1, [sp, #0x8]
700adf04: f001 fe44    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x1c88
;     return retVal;
700adf08: 9801         	ldr	r0, [sp, #0x4]
700adf0a: b004         	add	sp, #0x10
700adf0c: bd80         	pop	{r7, pc}
700adf0e: 0000         	movs	r0, r0

700adf10 <CSL_bcdmaSetChanPeerReg>:
; {
700adf10: b580         	push	{r7, lr}
700adf12: b088         	sub	sp, #0x20
700adf14: f8dd c028    	ldr.w	r12, [sp, #0x28]
700adf18: 9007         	str	r0, [sp, #0x1c]
700adf1a: 9106         	str	r1, [sp, #0x18]
700adf1c: 9205         	str	r2, [sp, #0x14]
700adf1e: 9304         	str	r3, [sp, #0x10]
;     remotePeerOpts.regIdx = regIdx;
700adf20: 9804         	ldr	r0, [sp, #0x10]
700adf22: 9001         	str	r0, [sp, #0x4]
;     remotePeerOpts.regVal = *pVal;
700adf24: 980a         	ldr	r0, [sp, #0x28]
700adf26: 6800         	ldr	r0, [r0]
700adf28: 9002         	str	r0, [sp, #0x8]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_REMOTE_PEER_REG, chanIdx, (void *)&remotePeerOpts );
700adf2a: 9807         	ldr	r0, [sp, #0x1c]
700adf2c: 9a06         	ldr	r2, [sp, #0x18]
700adf2e: 210c         	movs	r1, #0xc
700adf30: ab01         	add	r3, sp, #0x4
700adf32: f7fd f82d    	bl	0x700aaf90 <CSL_bcdmaDoChanOp> @ imm = #-0x2fa6
700adf36: 9003         	str	r0, [sp, #0xc]
;     if( retVal != CSL_PASS )
700adf38: 9803         	ldr	r0, [sp, #0xc]
700adf3a: b120         	cbz	r0, 0x700adf46 <CSL_bcdmaSetChanPeerReg+0x36> @ imm = #0x8
700adf3c: e7ff         	b	0x700adf3e <CSL_bcdmaSetChanPeerReg+0x2e> @ imm = #-0x2
700adf3e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700adf42: 9003         	str	r0, [sp, #0xc]
;     }
700adf44: e7ff         	b	0x700adf46 <CSL_bcdmaSetChanPeerReg+0x36> @ imm = #-0x2
;     return retVal;
700adf46: 9803         	ldr	r0, [sp, #0xc]
700adf48: b008         	add	sp, #0x20
700adf4a: bd80         	pop	{r7, pc}
700adf4c: 0000         	movs	r0, r0
700adf4e: 0000         	movs	r0, r0

700adf50 <CSL_intaggrIsValidStatusBitNum>:
; {
700adf50: b084         	sub	sp, #0x10
700adf52: 9003         	str	r0, [sp, #0xc]
700adf54: 9102         	str	r1, [sp, #0x8]
;     uint32_t localStatusBitNum = statusBitNum;
700adf56: 9802         	ldr	r0, [sp, #0x8]
700adf58: 9000         	str	r0, [sp]
;     localStatusBitNum &= ~CSL_INTAGGR_INTR_MODE_FLAG;   /* Remove intr mode flag */
700adf5a: 9800         	ldr	r0, [sp]
700adf5c: f020 4000    	bic	r0, r0, #0x80000000
700adf60: 9000         	str	r0, [sp]
;     if( localStatusBitNum < (pCfg->virtIntrCnt << 6U) )
700adf62: 9800         	ldr	r0, [sp]
700adf64: 9903         	ldr	r1, [sp, #0xc]
700adf66: 6a49         	ldr	r1, [r1, #0x24]
700adf68: ebb0 1f81    	cmp.w	r0, r1, lsl #6
700adf6c: d204         	bhs	0x700adf78 <CSL_intaggrIsValidStatusBitNum+0x28> @ imm = #0x8
700adf6e: e7ff         	b	0x700adf70 <CSL_intaggrIsValidStatusBitNum+0x20> @ imm = #-0x2
700adf70: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700adf72: f88d 0007    	strb.w	r0, [sp, #0x7]
;     }
700adf76: e003         	b	0x700adf80 <CSL_intaggrIsValidStatusBitNum+0x30> @ imm = #0x6
700adf78: 2000         	movs	r0, #0x0
;         bRetVal = (bool)false;
700adf7a: f88d 0007    	strb.w	r0, [sp, #0x7]
700adf7e: e7ff         	b	0x700adf80 <CSL_intaggrIsValidStatusBitNum+0x30> @ imm = #-0x2
;     return bRetVal;
700adf80: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700adf84: f000 0001    	and	r0, r0, #0x1
700adf88: b004         	add	sp, #0x10
700adf8a: 4770         	bx	lr
700adf8c: 0000         	movs	r0, r0
700adf8e: 0000         	movs	r0, r0

700adf90 <CSL_pktdmaSetRxRT>:
; {
700adf90: b580         	push	{r7, lr}
700adf92: b084         	sub	sp, #0x10
700adf94: 9003         	str	r0, [sp, #0xc]
700adf96: 9102         	str	r1, [sp, #0x8]
700adf98: 9201         	str	r2, [sp, #0x4]
;     CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL,
700adf9a: 9803         	ldr	r0, [sp, #0xc]
700adf9c: 6940         	ldr	r0, [r0, #0x14]
700adf9e: 9902         	ldr	r1, [sp, #0x8]
700adfa0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700adfa4: 9901         	ldr	r1, [sp, #0x4]
700adfa6: 680b         	ldr	r3, [r1]
700adfa8: f8d1 c004    	ldr.w	r12, [r1, #0x4]
700adfac: 688a         	ldr	r2, [r1, #0x8]
700adfae: f04f 4180    	mov.w	r1, #0x40000000
700adfb2: ea01 718c    	and.w	r1, r1, r12, lsl #30
700adfb6: ea41 71c3    	orr.w	r1, r1, r3, lsl #31
700adfba: f002 0201    	and	r2, r2, #0x1
700adfbe: ea41 7142    	orr.w	r1, r1, r2, lsl #29
700adfc2: f001 fd8d    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x1b1a
700adfc6: 2000         	movs	r0, #0x0
;     return CSL_PASS;
700adfc8: b004         	add	sp, #0x10
700adfca: bd80         	pop	{r7, pc}
700adfcc: 0000         	movs	r0, r0
700adfce: 0000         	movs	r0, r0

700adfd0 <CSL_pktdmaSetTxRT>:
; {
700adfd0: b580         	push	{r7, lr}
700adfd2: b084         	sub	sp, #0x10
700adfd4: 9003         	str	r0, [sp, #0xc]
700adfd6: 9102         	str	r1, [sp, #0x8]
700adfd8: 9201         	str	r2, [sp, #0x4]
;     CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL,
700adfda: 9803         	ldr	r0, [sp, #0xc]
700adfdc: 6900         	ldr	r0, [r0, #0x10]
700adfde: 9902         	ldr	r1, [sp, #0x8]
700adfe0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700adfe4: 9901         	ldr	r1, [sp, #0x4]
700adfe6: 680b         	ldr	r3, [r1]
700adfe8: f8d1 c004    	ldr.w	r12, [r1, #0x4]
700adfec: 688a         	ldr	r2, [r1, #0x8]
700adfee: f04f 4180    	mov.w	r1, #0x40000000
700adff2: ea01 718c    	and.w	r1, r1, r12, lsl #30
700adff6: ea41 71c3    	orr.w	r1, r1, r3, lsl #31
700adffa: f002 0201    	and	r2, r2, #0x1
700adffe: ea41 7142    	orr.w	r1, r1, r2, lsl #29
700ae002: f001 fd6d    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x1ada
700ae006: 2000         	movs	r0, #0x0
;     return CSL_PASS;
700ae008: b004         	add	sp, #0x10
700ae00a: bd80         	pop	{r7, pc}
700ae00c: 0000         	movs	r0, r0
700ae00e: 0000         	movs	r0, r0

700ae010 <Sciclient_rmIrqClearOesRegister>:
; {
700ae010: b580         	push	{r7, lr}
700ae012: b088         	sub	sp, #0x20
700ae014: 9007         	str	r0, [sp, #0x1c]
700ae016: 2010         	movs	r0, #0x10
700ae018: f2c8 0000    	movt	r0, #0x8000
;     req.valid_params = (TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID |
700ae01c: 9002         	str	r0, [sp, #0x8]
;     req.secondary_host = cfg->host;
700ae01e: 9807         	ldr	r0, [sp, #0x1c]
700ae020: 7900         	ldrb	r0, [r0, #0x4]
700ae022: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     req.src_id = cfg->s_id;
700ae026: 9807         	ldr	r0, [sp, #0x1c]
700ae028: 88c0         	ldrh	r0, [r0, #0x6]
700ae02a: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     req.src_index = cfg->s_idx;
700ae02e: 9807         	ldr	r0, [sp, #0x1c]
700ae030: 8900         	ldrh	r0, [r0, #0x8]
700ae032: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     req.global_event = cfg->global_evt;
700ae036: 9807         	ldr	r0, [sp, #0x1c]
700ae038: 89c0         	ldrh	r0, [r0, #0xe]
700ae03a: f8ad 0018    	strh.w	r0, [sp, #0x18]
700ae03e: 4668         	mov	r0, sp
700ae040: f04f 31ff    	mov.w	r1, #0xffffffff
;     return Sciclient_rmIrqReleaseRaw(&req,
700ae044: f7fe fdd4    	bl	0x700acbf0 <Sciclient_rmIrqReleaseRaw> @ imm = #-0x1458
700ae048: b008         	add	sp, #0x20
700ae04a: bd80         	pop	{r7, pc}
700ae04c: 0000         	movs	r0, r0
700ae04e: 0000         	movs	r0, r0

700ae050 <UART_IsParityTypeValid>:
; {
700ae050: b082         	sub	sp, #0x8
700ae052: 9001         	str	r0, [sp, #0x4]
700ae054: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ae058: 9000         	str	r0, [sp]
;     if(((parityType == UART_PARITY_NONE)    ||
700ae05a: 9801         	ldr	r0, [sp, #0x4]
700ae05c: b180         	cbz	r0, 0x700ae080 <UART_IsParityTypeValid+0x30> @ imm = #0x20
700ae05e: e7ff         	b	0x700ae060 <UART_IsParityTypeValid+0x10> @ imm = #-0x2
;         (parityType == UART_PARITY_ODD)     ||
700ae060: 9801         	ldr	r0, [sp, #0x4]
700ae062: 2801         	cmp	r0, #0x1
700ae064: d00c         	beq	0x700ae080 <UART_IsParityTypeValid+0x30> @ imm = #0x18
700ae066: e7ff         	b	0x700ae068 <UART_IsParityTypeValid+0x18> @ imm = #-0x2
;         (parityType == UART_PARITY_EVEN)    ||
700ae068: 9801         	ldr	r0, [sp, #0x4]
700ae06a: 2803         	cmp	r0, #0x3
700ae06c: d008         	beq	0x700ae080 <UART_IsParityTypeValid+0x30> @ imm = #0x10
700ae06e: e7ff         	b	0x700ae070 <UART_IsParityTypeValid+0x20> @ imm = #-0x2
;         (parityType == UART_PARITY_FORCED0) ||
700ae070: 9801         	ldr	r0, [sp, #0x4]
700ae072: 2807         	cmp	r0, #0x7
700ae074: d004         	beq	0x700ae080 <UART_IsParityTypeValid+0x30> @ imm = #0x8
700ae076: e7ff         	b	0x700ae078 <UART_IsParityTypeValid+0x28> @ imm = #-0x2
;         (parityType == UART_PARITY_FORCED1)))
700ae078: 9801         	ldr	r0, [sp, #0x4]
;     if(((parityType == UART_PARITY_NONE)    ||
700ae07a: 2805         	cmp	r0, #0x5
700ae07c: d103         	bne	0x700ae086 <UART_IsParityTypeValid+0x36> @ imm = #0x6
700ae07e: e7ff         	b	0x700ae080 <UART_IsParityTypeValid+0x30> @ imm = #-0x2
700ae080: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ae082: 9000         	str	r0, [sp]
;     }
700ae084: e7ff         	b	0x700ae086 <UART_IsParityTypeValid+0x36> @ imm = #-0x2
;     return status;
700ae086: 9800         	ldr	r0, [sp]
700ae088: b002         	add	sp, #0x8
700ae08a: 4770         	bx	lr
700ae08c: 0000         	movs	r0, r0
700ae08e: 0000         	movs	r0, r0

700ae090 <UART_IsTxRxFifoEmpty>:
; {
700ae090: b580         	push	{r7, lr}
700ae092: b084         	sub	sp, #0x10
700ae094: 9003         	str	r0, [sp, #0xc]
700ae096: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700ae098: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700ae09a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700ae09c: 9803         	ldr	r0, [sp, #0xc]
700ae09e: 217f         	movs	r1, #0x7f
700ae0a0: f7fe fb76    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #-0x1914
700ae0a4: 9002         	str	r0, [sp, #0x8]
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700ae0a6: 9803         	ldr	r0, [sp, #0xc]
700ae0a8: 3014         	adds	r0, #0x14
700ae0aa: f001 fd69    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x1ad2
;     if (((UART_LSR_TX_FIFO_E_TX_FIFO_E_VALUE_1 << UART_LSR_TX_FIFO_E_SHIFT) |
700ae0ae: 0680         	lsls	r0, r0, #0x1a
700ae0b0: 2800         	cmp	r0, #0x0
700ae0b2: d503         	bpl	0x700ae0bc <UART_IsTxRxFifoEmpty+0x2c> @ imm = #0x6
700ae0b4: e7ff         	b	0x700ae0b6 <UART_IsTxRxFifoEmpty+0x26> @ imm = #-0x2
700ae0b6: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700ae0b8: 9001         	str	r0, [sp, #0x4]
;     }
700ae0ba: e7ff         	b	0x700ae0bc <UART_IsTxRxFifoEmpty+0x2c> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ae0bc: 9803         	ldr	r0, [sp, #0xc]
700ae0be: 300c         	adds	r0, #0xc
700ae0c0: 9902         	ldr	r1, [sp, #0x8]
700ae0c2: f001 fd65    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x1aca
;     return retVal;
700ae0c6: 9801         	ldr	r0, [sp, #0x4]
700ae0c8: b004         	add	sp, #0x10
700ae0ca: bd80         	pop	{r7, pc}
700ae0cc: 0000         	movs	r0, r0
700ae0ce: 0000         	movs	r0, r0

700ae0d0 <UART_enhanFuncEnable>:
; {
700ae0d0: b580         	push	{r7, lr}
700ae0d2: b084         	sub	sp, #0x10
700ae0d4: 9003         	str	r0, [sp, #0xc]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ae0d6: 9803         	ldr	r0, [sp, #0xc]
700ae0d8: 21bf         	movs	r1, #0xbf
700ae0da: f7fe fb59    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #-0x194e
700ae0de: 9001         	str	r0, [sp, #0x4]
;     enhanFnBitVal = HW_RD_REG32(baseAddr + UART_EFR) & UART_EFR_ENHANCED_EN_MASK;
700ae0e0: 9803         	ldr	r0, [sp, #0xc]
700ae0e2: 3008         	adds	r0, #0x8
700ae0e4: f001 fd4c    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x1a98
700ae0e8: f000 0010    	and	r0, r0, #0x10
700ae0ec: 9002         	str	r0, [sp, #0x8]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700ae0ee: 9803         	ldr	r0, [sp, #0xc]
700ae0f0: 3008         	adds	r0, #0x8
700ae0f2: 2110         	movs	r1, #0x10
700ae0f4: 2204         	movs	r2, #0x4
700ae0f6: 2301         	movs	r3, #0x1
700ae0f8: f000 fae2    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #0x5c4
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ae0fc: 9803         	ldr	r0, [sp, #0xc]
700ae0fe: 300c         	adds	r0, #0xc
700ae100: 9901         	ldr	r1, [sp, #0x4]
700ae102: f001 fd45    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x1a8a
;     return enhanFnBitVal;
700ae106: 9802         	ldr	r0, [sp, #0x8]
700ae108: b004         	add	sp, #0x10
700ae10a: bd80         	pop	{r7, pc}
700ae10c: 0000         	movs	r0, r0
700ae10e: 0000         	movs	r0, r0

700ae110 <UART_lld_dmaDeInit>:
; {
700ae110: b580         	push	{r7, lr}
700ae112: b084         	sub	sp, #0x10
700ae114: 9003         	str	r0, [sp, #0xc]
700ae116: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700ae118: 9002         	str	r0, [sp, #0x8]
;     udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700ae11a: 9803         	ldr	r0, [sp, #0xc]
700ae11c: 6840         	ldr	r0, [r0, #0x4]
700ae11e: 6cc0         	ldr	r0, [r0, #0x4c]
700ae120: 9001         	str	r0, [sp, #0x4]
;     if (udmaChCfg->isOpen != FALSE)
700ae122: 9801         	ldr	r0, [sp, #0x4]
700ae124: 6b80         	ldr	r0, [r0, #0x38]
700ae126: b170         	cbz	r0, 0x700ae146 <UART_lld_dmaDeInit+0x36> @ imm = #0x1c
700ae128: e7ff         	b	0x700ae12a <UART_lld_dmaDeInit+0x1a> @ imm = #-0x2
;         (void)UART_udmaDeInitCh(udmaChCfg->rxChHandle,
700ae12a: 9901         	ldr	r1, [sp, #0x4]
700ae12c: 6888         	ldr	r0, [r1, #0x8]
;                           udmaChCfg->cqRxEvtHandle);
700ae12e: 6909         	ldr	r1, [r1, #0x10]
;         (void)UART_udmaDeInitCh(udmaChCfg->rxChHandle,
700ae130: f7f8 fc26    	bl	0x700a6980 <UART_udmaDeInitCh> @ imm = #-0x77b4
;         (void)UART_udmaDeInitCh(udmaChCfg->txChHandle,
700ae134: 9901         	ldr	r1, [sp, #0x4]
700ae136: 6848         	ldr	r0, [r1, #0x4]
;                           udmaChCfg->cqTxEvtHandle);
700ae138: 68c9         	ldr	r1, [r1, #0xc]
;         (void)UART_udmaDeInitCh(udmaChCfg->txChHandle,
700ae13a: f7f8 fc21    	bl	0x700a6980 <UART_udmaDeInitCh> @ imm = #-0x77be
;         udmaChCfg->isOpen = FALSE;
700ae13e: 9901         	ldr	r1, [sp, #0x4]
700ae140: 2000         	movs	r0, #0x0
700ae142: 6388         	str	r0, [r1, #0x38]
;     }
700ae144: e7ff         	b	0x700ae146 <UART_lld_dmaDeInit+0x36> @ imm = #-0x2
;     return status;
700ae146: 9802         	ldr	r0, [sp, #0x8]
700ae148: b004         	add	sp, #0x10
700ae14a: bd80         	pop	{r7, pc}
700ae14c: 0000         	movs	r0, r0
700ae14e: 0000         	movs	r0, r0

700ae150 <prvDeleteTCB>:
; static void prvDeleteTCB(TCB_t *pxTCB) {
700ae150: b580         	push	{r7, lr}
700ae152: b082         	sub	sp, #0x8
700ae154: 9001         	str	r0, [sp, #0x4]
;   portCLEAN_UP_TCB(pxTCB);
700ae156: 9801         	ldr	r0, [sp, #0x4]
;     if (pxTCB->ucStaticallyAllocated ==
700ae158: f890 0081    	ldrb.w	r0, [r0, #0x81]
700ae15c: b940         	cbnz	r0, 0x700ae170 <prvDeleteTCB+0x20> @ imm = #0x10
700ae15e: e7ff         	b	0x700ae160 <prvDeleteTCB+0x10> @ imm = #-0x2
;       vPortFree(pxTCB->pxStack);
700ae160: 9801         	ldr	r0, [sp, #0x4]
700ae162: 6b00         	ldr	r0, [r0, #0x30]
700ae164: f001 f924    	bl	0x700af3b0 <vPortFree>  @ imm = #0x1248
;       vPortFree(pxTCB);
700ae168: 9801         	ldr	r0, [sp, #0x4]
700ae16a: f001 f921    	bl	0x700af3b0 <vPortFree>  @ imm = #0x1242
;     } else if (pxTCB->ucStaticallyAllocated ==
700ae16e: e00b         	b	0x700ae188 <prvDeleteTCB+0x38> @ imm = #0x16
700ae170: 9801         	ldr	r0, [sp, #0x4]
700ae172: f890 0081    	ldrb.w	r0, [r0, #0x81]
700ae176: 2801         	cmp	r0, #0x1
700ae178: d104         	bne	0x700ae184 <prvDeleteTCB+0x34> @ imm = #0x8
700ae17a: e7ff         	b	0x700ae17c <prvDeleteTCB+0x2c> @ imm = #-0x2
;       vPortFree(pxTCB);
700ae17c: 9801         	ldr	r0, [sp, #0x4]
700ae17e: f001 f917    	bl	0x700af3b0 <vPortFree>  @ imm = #0x122e
;     } else {
700ae182: e000         	b	0x700ae186 <prvDeleteTCB+0x36> @ imm = #0x0
700ae184: e7ff         	b	0x700ae186 <prvDeleteTCB+0x36> @ imm = #-0x2
700ae186: e7ff         	b	0x700ae188 <prvDeleteTCB+0x38> @ imm = #-0x2
; }
700ae188: b002         	add	sp, #0x8
700ae18a: bd80         	pop	{r7, pc}
700ae18c: 0000         	movs	r0, r0
700ae18e: 0000         	movs	r0, r0

700ae190 <prvResetNextTaskUnblockTime>:
;   if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
700ae190: f245 20a0    	movw	r0, #0x52a0
700ae194: f2c7 0008    	movt	r0, #0x7008
700ae198: 6800         	ldr	r0, [r0]
700ae19a: 6800         	ldr	r0, [r0]
700ae19c: b940         	cbnz	r0, 0x700ae1b0 <prvResetNextTaskUnblockTime+0x20> @ imm = #0x10
700ae19e: e7ff         	b	0x700ae1a0 <prvResetNextTaskUnblockTime+0x10> @ imm = #-0x2
;     xNextTaskUnblockTime = portMAX_DELAY;
700ae1a0: f642 2144    	movw	r1, #0x2a44
700ae1a4: f2c7 010b    	movt	r1, #0x700b
700ae1a8: f04f 30ff    	mov.w	r0, #0xffffffff
700ae1ac: 6008         	str	r0, [r1]
;   } else {
700ae1ae: e00c         	b	0x700ae1ca <prvResetNextTaskUnblockTime+0x3a> @ imm = #0x18
;     xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxDelayedTaskList);
700ae1b0: f245 20a0    	movw	r0, #0x52a0
700ae1b4: f2c7 0008    	movt	r0, #0x7008
700ae1b8: 6800         	ldr	r0, [r0]
700ae1ba: 68c0         	ldr	r0, [r0, #0xc]
700ae1bc: 6800         	ldr	r0, [r0]
700ae1be: f642 2144    	movw	r1, #0x2a44
700ae1c2: f2c7 010b    	movt	r1, #0x700b
700ae1c6: 6008         	str	r0, [r1]
700ae1c8: e7ff         	b	0x700ae1ca <prvResetNextTaskUnblockTime+0x3a> @ imm = #-0x2
; }
700ae1ca: 4770         	bx	lr
700ae1cc: 0000         	movs	r0, r0
700ae1ce: 0000         	movs	r0, r0

700ae1d0 <PMU_enableAllCounters>:
; static void PMU_enableAllCounters(uint32_t numCounters) {
700ae1d0: b580         	push	{r7, lr}
700ae1d2: b082         	sub	sp, #0x8
700ae1d4: 9001         	str	r0, [sp, #0x4]
700ae1d6: 2001         	movs	r0, #0x1
;   CSL_armR5PmuEnableAllCntrs(1);
700ae1d8: f7f3 efd8    	blx	0x700a218c <CSL_armR5PmuEnableAllCntrs> @ imm = #-0xc050
700ae1dc: 2000         	movs	r0, #0x0
;   for (i = 0; i < numCounters; i++) {
700ae1de: 9000         	str	r0, [sp]
700ae1e0: e7ff         	b	0x700ae1e2 <PMU_enableAllCounters+0x12> @ imm = #-0x2
700ae1e2: 9800         	ldr	r0, [sp]
700ae1e4: 9901         	ldr	r1, [sp, #0x4]
700ae1e6: 4288         	cmp	r0, r1
700ae1e8: d209         	bhs	0x700ae1fe <PMU_enableAllCounters+0x2e> @ imm = #0x12
700ae1ea: e7ff         	b	0x700ae1ec <PMU_enableAllCounters+0x1c> @ imm = #-0x2
;     CSL_armR5PmuEnableCntr(i, 1);
700ae1ec: 9800         	ldr	r0, [sp]
700ae1ee: 2101         	movs	r1, #0x1
700ae1f0: f7f4 e802    	blx	0x700a21f8 <CSL_armR5PmuEnableCntr> @ imm = #-0xbffc
;   }
700ae1f4: e7ff         	b	0x700ae1f6 <PMU_enableAllCounters+0x26> @ imm = #-0x2
;   for (i = 0; i < numCounters; i++) {
700ae1f6: 9800         	ldr	r0, [sp]
700ae1f8: 3001         	adds	r0, #0x1
700ae1fa: 9000         	str	r0, [sp]
700ae1fc: e7f1         	b	0x700ae1e2 <PMU_enableAllCounters+0x12> @ imm = #-0x1e
700ae1fe: 201f         	movs	r0, #0x1f
700ae200: 2101         	movs	r1, #0x1
;   CSL_armR5PmuEnableCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM, 1);
700ae202: f7f3 effa    	blx	0x700a21f8 <CSL_armR5PmuEnableCntr> @ imm = #-0xc00c
; }
700ae206: b002         	add	sp, #0x8
700ae208: bd80         	pop	{r7, pc}
700ae20a: 0000         	movs	r0, r0
700ae20c: 0000         	movs	r0, r0
700ae20e: 0000         	movs	r0, r0

700ae210 <_atoi>:
; {
700ae210: b580         	push	{r7, lr}
700ae212: b082         	sub	sp, #0x8
700ae214: 9001         	str	r0, [sp, #0x4]
700ae216: 2000         	movs	r0, #0x0
;   unsigned int i = 0U;
700ae218: 9000         	str	r0, [sp]
;   while (_is_digit(**str)) {
700ae21a: e7ff         	b	0x700ae21c <_atoi+0xc>  @ imm = #-0x2
700ae21c: 9801         	ldr	r0, [sp, #0x4]
700ae21e: 6800         	ldr	r0, [r0]
700ae220: 7800         	ldrb	r0, [r0]
700ae222: f000 fbdd    	bl	0x700ae9e0 <_is_digit>  @ imm = #0x7ba
700ae226: b168         	cbz	r0, 0x700ae244 <_atoi+0x34> @ imm = #0x1a
700ae228: e7ff         	b	0x700ae22a <_atoi+0x1a> @ imm = #-0x2
;     i = i * 10U + (unsigned int)(*((*str)++) - '0');
700ae22a: 9800         	ldr	r0, [sp]
700ae22c: eb00 0180    	add.w	r1, r0, r0, lsl #2
700ae230: 9b01         	ldr	r3, [sp, #0x4]
700ae232: 6818         	ldr	r0, [r3]
700ae234: 1c42         	adds	r2, r0, #0x1
700ae236: 601a         	str	r2, [r3]
700ae238: 7800         	ldrb	r0, [r0]
700ae23a: eb00 0041    	add.w	r0, r0, r1, lsl #1
700ae23e: 3830         	subs	r0, #0x30
700ae240: 9000         	str	r0, [sp]
;   while (_is_digit(**str)) {
700ae242: e7eb         	b	0x700ae21c <_atoi+0xc>  @ imm = #-0x2a
;   return i;
700ae244: 9800         	ldr	r0, [sp]
700ae246: b002         	add	sp, #0x8
700ae248: bd80         	pop	{r7, pc}
700ae24a: 0000         	movs	r0, r0
700ae24c: 0000         	movs	r0, r0
700ae24e: 0000         	movs	r0, r0

700ae250 <snprintf_>:
; {
700ae250: b081         	sub	sp, #0x4
700ae252: b580         	push	{r7, lr}
700ae254: b087         	sub	sp, #0x1c
700ae256: 9309         	str	r3, [sp, #0x24]
700ae258: 9006         	str	r0, [sp, #0x18]
700ae25a: 9105         	str	r1, [sp, #0x14]
700ae25c: 9204         	str	r2, [sp, #0x10]
700ae25e: a809         	add	r0, sp, #0x24
;   va_start(va, format);
700ae260: 9003         	str	r0, [sp, #0xc]
;   const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
700ae262: 9906         	ldr	r1, [sp, #0x18]
700ae264: 9a05         	ldr	r2, [sp, #0x14]
700ae266: 9b04         	ldr	r3, [sp, #0x10]
700ae268: 9803         	ldr	r0, [sp, #0xc]
700ae26a: 46ec         	mov	r12, sp
700ae26c: f8cc 0000    	str.w	r0, [r12]
700ae270: f24f 0011    	movw	r0, #0xf011
700ae274: f2c7 000a    	movt	r0, #0x700a
700ae278: f7eb ff32    	bl	0x7009a0e0 <_vsnprintf> @ imm = #-0x1419c
700ae27c: 9002         	str	r0, [sp, #0x8]
;   return ret;
700ae27e: 9802         	ldr	r0, [sp, #0x8]
700ae280: b007         	add	sp, #0x1c
700ae282: e8bd 4080    	pop.w	{r7, lr}
700ae286: b001         	add	sp, #0x4
700ae288: 4770         	bx	lr
700ae28a: 0000         	movs	r0, r0
700ae28c: 0000         	movs	r0, r0
700ae28e: 0000         	movs	r0, r0

700ae290 <vListInsertEnd>:
; {
700ae290: b083         	sub	sp, #0xc
700ae292: 9002         	str	r0, [sp, #0x8]
700ae294: 9101         	str	r1, [sp, #0x4]
;     ListItem_t * const pxIndex = pxList->pxIndex;
700ae296: 9802         	ldr	r0, [sp, #0x8]
700ae298: 6840         	ldr	r0, [r0, #0x4]
700ae29a: 9000         	str	r0, [sp]
;     pxNewListItem->pxNext = pxIndex;
700ae29c: 9800         	ldr	r0, [sp]
700ae29e: 9901         	ldr	r1, [sp, #0x4]
700ae2a0: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxPrevious = pxIndex->pxPrevious;
700ae2a2: 9800         	ldr	r0, [sp]
700ae2a4: 6880         	ldr	r0, [r0, #0x8]
700ae2a6: 9901         	ldr	r1, [sp, #0x4]
700ae2a8: 6088         	str	r0, [r1, #0x8]
;     pxIndex->pxPrevious->pxNext = pxNewListItem;
700ae2aa: 9801         	ldr	r0, [sp, #0x4]
700ae2ac: 9900         	ldr	r1, [sp]
700ae2ae: 6889         	ldr	r1, [r1, #0x8]
700ae2b0: 6048         	str	r0, [r1, #0x4]
;     pxIndex->pxPrevious = pxNewListItem;
700ae2b2: 9801         	ldr	r0, [sp, #0x4]
700ae2b4: 9900         	ldr	r1, [sp]
700ae2b6: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxContainer = pxList;
700ae2b8: 9802         	ldr	r0, [sp, #0x8]
700ae2ba: 9901         	ldr	r1, [sp, #0x4]
700ae2bc: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
700ae2be: 9902         	ldr	r1, [sp, #0x8]
700ae2c0: 6808         	ldr	r0, [r1]
700ae2c2: 3001         	adds	r0, #0x1
700ae2c4: 6008         	str	r0, [r1]
; }
700ae2c6: b003         	add	sp, #0xc
700ae2c8: 4770         	bx	lr
700ae2ca: 0000         	movs	r0, r0
700ae2cc: 0000         	movs	r0, r0
700ae2ce: 0000         	movs	r0, r0

700ae2d0 <CSL_REG32_FINS_RAW>:
; {
700ae2d0: b580         	push	{r7, lr}
700ae2d2: b086         	sub	sp, #0x18
700ae2d4: 9005         	str	r0, [sp, #0x14]
700ae2d6: 9104         	str	r1, [sp, #0x10]
700ae2d8: 9203         	str	r2, [sp, #0xc]
700ae2da: 9302         	str	r3, [sp, #0x8]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700ae2dc: 9805         	ldr	r0, [sp, #0x14]
700ae2de: f001 fc97    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0x192e
700ae2e2: 9001         	str	r0, [sp, #0x4]
;     regVal = (regVal & ~(mask));
700ae2e4: 9801         	ldr	r0, [sp, #0x4]
700ae2e6: 9904         	ldr	r1, [sp, #0x10]
700ae2e8: 4388         	bics	r0, r1
700ae2ea: 9001         	str	r0, [sp, #0x4]
;     regVal |= (v << shift) & mask;
700ae2ec: 9802         	ldr	r0, [sp, #0x8]
700ae2ee: 9903         	ldr	r1, [sp, #0xc]
700ae2f0: 4088         	lsls	r0, r1
700ae2f2: 9904         	ldr	r1, [sp, #0x10]
700ae2f4: 4001         	ands	r1, r0
700ae2f6: 9801         	ldr	r0, [sp, #0x4]
700ae2f8: 4308         	orrs	r0, r1
700ae2fa: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR_RAW(p, regVal);
700ae2fc: 9805         	ldr	r0, [sp, #0x14]
700ae2fe: 9901         	ldr	r1, [sp, #0x4]
700ae300: f7ed ffc6    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x12074
;     return;
700ae304: b006         	add	sp, #0x18
700ae306: bd80         	pop	{r7, pc}
		...

700ae310 <SOC_getCoreName>:
; {
700ae310: b082         	sub	sp, #0x8
700ae312: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     if(coreId < CSL_CORE_ID_MAX)
700ae316: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ae31a: 2806         	cmp	r0, #0x6
700ae31c: d80a         	bhi	0x700ae334 <SOC_getCoreName+0x24> @ imm = #0x14
700ae31e: e7ff         	b	0x700ae320 <SOC_getCoreName+0x10> @ imm = #-0x2
;         name = coreIdNames[coreId];
700ae320: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ae324: f642 008c    	movw	r0, #0x288c
700ae328: f2c7 000b    	movt	r0, #0x700b
700ae32c: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700ae330: 9000         	str	r0, [sp]
;     }
700ae332: e006         	b	0x700ae342 <SOC_getCoreName+0x32> @ imm = #0xc
;         name = coreIdNames[CSL_CORE_ID_MAX];
700ae334: f642 008c    	movw	r0, #0x288c
700ae338: f2c7 000b    	movt	r0, #0x700b
700ae33c: 69c0         	ldr	r0, [r0, #0x1c]
700ae33e: 9000         	str	r0, [sp]
700ae340: e7ff         	b	0x700ae342 <SOC_getCoreName+0x32> @ imm = #-0x2
;     return name;
700ae342: 9800         	ldr	r0, [sp]
700ae344: b002         	add	sp, #0x8
700ae346: 4770         	bx	lr
		...

700ae350 <Sciclient_secProxyFlush>:
; {
700ae350: b580         	push	{r7, lr}
700ae352: b082         	sub	sp, #0x8
700ae354: 9001         	str	r0, [sp, #0x4]
;     while ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ae356: e7ff         	b	0x700ae358 <Sciclient_secProxyFlush+0x8> @ imm = #-0x2
700ae358: 9801         	ldr	r0, [sp, #0x4]
700ae35a: f001 f9b9    	bl	0x700af6d0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x1372
700ae35e: f001 fc6f    	bl	0x700afc40 <CSL_REG32_RD_RAW> @ imm = #0x18de
700ae362: 0600         	lsls	r0, r0, #0x18
700ae364: b170         	cbz	r0, 0x700ae384 <Sciclient_secProxyFlush+0x34> @ imm = #0x1c
700ae366: e7ff         	b	0x700ae368 <Sciclient_secProxyFlush+0x18> @ imm = #-0x2
;         (void) Sciclient_secProxyReadThread32(thread,
700ae368: 9801         	ldr	r0, [sp, #0x4]
;                         (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U)-1U));
700ae36a: f642 1158    	movw	r1, #0x2958
700ae36e: f2c7 010b    	movt	r1, #0x700b
700ae372: 694a         	ldr	r2, [r1, #0x14]
700ae374: f04f 31ff    	mov.w	r1, #0xffffffff
700ae378: eb01 0192    	add.w	r1, r1, r2, lsr #2
;         (void) Sciclient_secProxyReadThread32(thread,
700ae37c: b2c9         	uxtb	r1, r1
700ae37e: f000 faff    	bl	0x700ae980 <Sciclient_secProxyReadThread32> @ imm = #0x5fe
;     while ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ae382: e7e9         	b	0x700ae358 <Sciclient_secProxyFlush+0x8> @ imm = #-0x2e
;     return ;
700ae384: b002         	add	sp, #0x8
700ae386: bd80         	pop	{r7, pc}
		...

700ae390 <UART_writeDataPolling>:
; {
700ae390: b580         	push	{r7, lr}
700ae392: b082         	sub	sp, #0x8
700ae394: 9001         	str	r0, [sp, #0x4]
700ae396: 2000         	movs	r0, #0x0
;     uint32_t numBytesWritten = 0U;
700ae398: 9000         	str	r0, [sp]
;     numBytesWritten = UART_fifoWrite(hUart,
700ae39a: 9801         	ldr	r0, [sp, #0x4]
;                                      (const uint8_t *) hUart->writeBuf,
700ae39c: 6881         	ldr	r1, [r0, #0x8]
;                                      hUart->writeSizeRemaining);
700ae39e: 6902         	ldr	r2, [r0, #0x10]
;     numBytesWritten = UART_fifoWrite(hUart,
700ae3a0: f7f9 fb56    	bl	0x700a7a50 <UART_fifoWrite> @ imm = #-0x6954
700ae3a4: 9000         	str	r0, [sp]
;     hUart->writeSizeRemaining -= numBytesWritten;
700ae3a6: 9a00         	ldr	r2, [sp]
700ae3a8: 9901         	ldr	r1, [sp, #0x4]
700ae3aa: 6908         	ldr	r0, [r1, #0x10]
700ae3ac: 1a80         	subs	r0, r0, r2
700ae3ae: 6108         	str	r0, [r1, #0x10]
;     hUart->writeBuf           = (const void *)((uint8_t *)hUart->writeBuf + numBytesWritten);
700ae3b0: 9901         	ldr	r1, [sp, #0x4]
700ae3b2: 6888         	ldr	r0, [r1, #0x8]
700ae3b4: 9a00         	ldr	r2, [sp]
700ae3b6: 4410         	add	r0, r2
700ae3b8: 6088         	str	r0, [r1, #0x8]
;     hUart->writeCount         += numBytesWritten;
700ae3ba: 9a00         	ldr	r2, [sp]
700ae3bc: 9901         	ldr	r1, [sp, #0x4]
700ae3be: 68c8         	ldr	r0, [r1, #0xc]
700ae3c0: 4410         	add	r0, r2
700ae3c2: 60c8         	str	r0, [r1, #0xc]
;     return;
700ae3c4: b002         	add	sp, #0x8
700ae3c6: bd80         	pop	{r7, pc}
		...

700ae3d0 <xTaskGetSchedulerState>:
; BaseType_t xTaskGetSchedulerState(void) {
700ae3d0: b081         	sub	sp, #0x4
;   if (xSchedulerRunning == pdFALSE) {
700ae3d2: f642 2050    	movw	r0, #0x2a50
700ae3d6: f2c7 000b    	movt	r0, #0x700b
700ae3da: 6800         	ldr	r0, [r0]
700ae3dc: b918         	cbnz	r0, 0x700ae3e6 <xTaskGetSchedulerState+0x16> @ imm = #0x6
700ae3de: e7ff         	b	0x700ae3e0 <xTaskGetSchedulerState+0x10> @ imm = #-0x2
700ae3e0: 2001         	movs	r0, #0x1
;     xReturn = taskSCHEDULER_NOT_STARTED;
700ae3e2: 9000         	str	r0, [sp]
;   } else {
700ae3e4: e00d         	b	0x700ae402 <xTaskGetSchedulerState+0x32> @ imm = #0x1a
;     if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700ae3e6: f642 2034    	movw	r0, #0x2a34
700ae3ea: f2c7 000b    	movt	r0, #0x700b
700ae3ee: 6800         	ldr	r0, [r0]
700ae3f0: b918         	cbnz	r0, 0x700ae3fa <xTaskGetSchedulerState+0x2a> @ imm = #0x6
700ae3f2: e7ff         	b	0x700ae3f4 <xTaskGetSchedulerState+0x24> @ imm = #-0x2
700ae3f4: 2002         	movs	r0, #0x2
;       xReturn = taskSCHEDULER_RUNNING;
700ae3f6: 9000         	str	r0, [sp]
;     } else {
700ae3f8: e002         	b	0x700ae400 <xTaskGetSchedulerState+0x30> @ imm = #0x4
700ae3fa: 2000         	movs	r0, #0x0
;       xReturn = taskSCHEDULER_SUSPENDED;
700ae3fc: 9000         	str	r0, [sp]
700ae3fe: e7ff         	b	0x700ae400 <xTaskGetSchedulerState+0x30> @ imm = #-0x2
700ae400: e7ff         	b	0x700ae402 <xTaskGetSchedulerState+0x32> @ imm = #-0x2
;   return xReturn;
700ae402: 9800         	ldr	r0, [sp]
700ae404: b001         	add	sp, #0x4
700ae406: 4770         	bx	lr
		...

700ae410 <tm_thread_create>:
; {
700ae410: b580         	push	{r7, lr}
700ae412: b082         	sub	sp, #0x8
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ae414: f245 13c8    	movw	r3, #0x51c8
;    int new_priority = configMAX_PRIORITIES - priority + 1;
700ae418: f1c1 0c21    	rsb.w	r12, r1, #0x21
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ae41c: f2c7 0308    	movt	r3, #0x7008
;    status = xTaskCreate((TaskFunction_t) entry_function, "Thread-Metric test", configMINIMAL_STACK_SIZE, NULL,
700ae420: f641 7182    	movw	r1, #0x1f82
700ae424: f2c7 010b    	movt	r1, #0x700b
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ae428: eb03 0e80    	add.w	lr, r3, r0, lsl #2
;    status = xTaskCreate((TaskFunction_t) entry_function, "Thread-Metric test", configMINIMAL_STACK_SIZE, NULL,
700ae42c: 4610         	mov	r0, r2
700ae42e: f44f 6280    	mov.w	r2, #0x400
700ae432: 2300         	movs	r3, #0x0
700ae434: e9cd ce00    	strd	r12, lr, [sp]
700ae438: f7fb f862    	bl	0x700a9500 <xTaskCreate> @ imm = #-0x4f3c
;    if (status != pdPASS)
700ae43c: 3801         	subs	r0, #0x1
700ae43e: bf18         	it	ne
700ae440: 2001         	movne	r0, #0x1
; }
700ae442: b002         	add	sp, #0x8
700ae444: bd80         	pop	{r7, pc}
		...
700ae44e: 0000         	movs	r0, r0

700ae450 <vTaskDelay>:
; void vTaskDelay(const TickType_t xTicksToDelay) {
700ae450: b580         	push	{r7, lr}
700ae452: b082         	sub	sp, #0x8
700ae454: 9001         	str	r0, [sp, #0x4]
700ae456: 2000         	movs	r0, #0x0
;   BaseType_t xAlreadyYielded = pdFALSE;
700ae458: 9000         	str	r0, [sp]
;   if (xTicksToDelay > (TickType_t)0U) {
700ae45a: 9801         	ldr	r0, [sp, #0x4]
700ae45c: b150         	cbz	r0, 0x700ae474 <vTaskDelay+0x24> @ imm = #0x14
700ae45e: e7ff         	b	0x700ae460 <vTaskDelay+0x10> @ imm = #-0x2
;     vTaskSuspendAll();
700ae460: f001 fbb6    	bl	0x700afbd0 <vTaskSuspendAll> @ imm = #0x176c
;       prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
700ae464: 9801         	ldr	r0, [sp, #0x4]
700ae466: 2100         	movs	r1, #0x0
700ae468: f7f8 f9aa    	bl	0x700a67c0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x7cac
;     xAlreadyYielded = xTaskResumeAll();
700ae46c: f7f3 ff18    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0xc1d0
700ae470: 9000         	str	r0, [sp]
;   } else {
700ae472: e000         	b	0x700ae476 <vTaskDelay+0x26> @ imm = #0x0
700ae474: e7ff         	b	0x700ae476 <vTaskDelay+0x26> @ imm = #-0x2
;   if (xAlreadyYielded == pdFALSE) {
700ae476: 9800         	ldr	r0, [sp]
700ae478: b910         	cbnz	r0, 0x700ae480 <vTaskDelay+0x30> @ imm = #0x4
700ae47a: e7ff         	b	0x700ae47c <vTaskDelay+0x2c> @ imm = #-0x2
;     portYIELD_WITHIN_API();
700ae47c: df00         	svc	#0x0
;   } else {
700ae47e: e000         	b	0x700ae482 <vTaskDelay+0x32> @ imm = #0x0
700ae480: e7ff         	b	0x700ae482 <vTaskDelay+0x32> @ imm = #-0x2
; }
700ae482: b002         	add	sp, #0x8
700ae484: bd80         	pop	{r7, pc}
		...
700ae48e: 0000         	movs	r0, r0

700ae490 <vTaskPlaceOnEventListRestricted>:
;                                      const BaseType_t xWaitIndefinitely) {
700ae490: b580         	push	{r7, lr}
700ae492: b084         	sub	sp, #0x10
700ae494: 9003         	str	r0, [sp, #0xc]
700ae496: 9102         	str	r1, [sp, #0x8]
700ae498: 9201         	str	r2, [sp, #0x4]
;   vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
700ae49a: 9803         	ldr	r0, [sp, #0xc]
700ae49c: f642 210c    	movw	r1, #0x2a0c
700ae4a0: f2c7 010b    	movt	r1, #0x700b
700ae4a4: 6809         	ldr	r1, [r1]
700ae4a6: 3118         	adds	r1, #0x18
700ae4a8: f7ff fef2    	bl	0x700ae290 <vListInsertEnd> @ imm = #-0x21c
;   if (xWaitIndefinitely != pdFALSE) {
700ae4ac: 9801         	ldr	r0, [sp, #0x4]
700ae4ae: b120         	cbz	r0, 0x700ae4ba <vTaskPlaceOnEventListRestricted+0x2a> @ imm = #0x8
700ae4b0: e7ff         	b	0x700ae4b2 <vTaskPlaceOnEventListRestricted+0x22> @ imm = #-0x2
700ae4b2: f04f 30ff    	mov.w	r0, #0xffffffff
;     xTicksToWait = portMAX_DELAY;
700ae4b6: 9002         	str	r0, [sp, #0x8]
;   }
700ae4b8: e7ff         	b	0x700ae4ba <vTaskPlaceOnEventListRestricted+0x2a> @ imm = #-0x2
;   prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
700ae4ba: 9802         	ldr	r0, [sp, #0x8]
700ae4bc: 9901         	ldr	r1, [sp, #0x4]
700ae4be: f7f8 f97f    	bl	0x700a67c0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x7d02
; }
700ae4c2: b004         	add	sp, #0x10
700ae4c4: bd80         	pop	{r7, pc}
		...
700ae4ce: 0000         	movs	r0, r0

700ae4d0 <CSL_pktdmaTeardownRxChan>:
; {
700ae4d0: b580         	push	{r7, lr}
700ae4d2: b084         	sub	sp, #0x10
700ae4d4: 9003         	str	r0, [sp, #0xc]
700ae4d6: 9102         	str	r1, [sp, #0x8]
700ae4d8: f88d 2007    	strb.w	r2, [sp, #0x7]
700ae4dc: f88d 3006    	strb.w	r3, [sp, #0x6]
;     return CSL_pktdmaTeardownChan( pCfg, chanIdx, CSL_PKTDMA_CHAN_DIR_RX, bForce, bWait );
700ae4e0: 9803         	ldr	r0, [sp, #0xc]
700ae4e2: 9902         	ldr	r1, [sp, #0x8]
700ae4e4: f89d 2007    	ldrb.w	r2, [sp, #0x7]
700ae4e8: f89d 3006    	ldrb.w	r3, [sp, #0x6]
700ae4ec: f003 0301    	and	r3, r3, #0x1
700ae4f0: 46ec         	mov	r12, sp
700ae4f2: f8cc 3000    	str.w	r3, [r12]
700ae4f6: f002 0301    	and	r3, r2, #0x1
700ae4fa: 2201         	movs	r2, #0x1
700ae4fc: f7f7 f818    	bl	0x700a5530 <CSL_pktdmaTeardownChan> @ imm = #-0x8fd0
700ae500: b004         	add	sp, #0x10
700ae502: bd80         	pop	{r7, pc}
		...

700ae510 <CSL_pktdmaTeardownTxChan>:
; {
700ae510: b580         	push	{r7, lr}
700ae512: b084         	sub	sp, #0x10
700ae514: 9003         	str	r0, [sp, #0xc]
700ae516: 9102         	str	r1, [sp, #0x8]
700ae518: f88d 2007    	strb.w	r2, [sp, #0x7]
700ae51c: f88d 3006    	strb.w	r3, [sp, #0x6]
;     return CSL_pktdmaTeardownChan( pCfg, chanIdx, CSL_PKTDMA_CHAN_DIR_TX, bForce, bWait );
700ae520: 9803         	ldr	r0, [sp, #0xc]
700ae522: 9902         	ldr	r1, [sp, #0x8]
700ae524: f89d 2007    	ldrb.w	r2, [sp, #0x7]
700ae528: f89d 3006    	ldrb.w	r3, [sp, #0x6]
700ae52c: f003 0301    	and	r3, r3, #0x1
700ae530: 46ec         	mov	r12, sp
700ae532: f8cc 3000    	str.w	r3, [r12]
700ae536: f002 0301    	and	r3, r2, #0x1
700ae53a: 2200         	movs	r2, #0x0
700ae53c: f7f6 fff8    	bl	0x700a5530 <CSL_pktdmaTeardownChan> @ imm = #-0x9010
700ae540: b004         	add	sp, #0x10
700ae542: bd80         	pop	{r7, pc}
		...

700ae550 <TimerP_Params_init>:
; {
700ae550: b081         	sub	sp, #0x4
700ae552: 9000         	str	r0, [sp]
;     params->inputPreScaler = 1;
700ae554: 9800         	ldr	r0, [sp]
700ae556: 2101         	movs	r1, #0x1
700ae558: 6001         	str	r1, [r0]
;     params->inputClkHz = 25*1000000;
700ae55a: 9a00         	ldr	r2, [sp]
700ae55c: f647 0040    	movw	r0, #0x7840
700ae560: f2c0 107d    	movt	r0, #0x17d
700ae564: 6050         	str	r0, [r2, #0x4]
;     params->periodInUsec = 1000;
700ae566: 9a00         	ldr	r2, [sp]
700ae568: f44f 707a    	mov.w	r0, #0x3e8
700ae56c: 6090         	str	r0, [r2, #0x8]
;     params->periodInNsec = 0; /* periodInUsec is used when periodInNsec is 0 */
700ae56e: 9a00         	ldr	r2, [sp]
700ae570: 2000         	movs	r0, #0x0
700ae572: 60d0         	str	r0, [r2, #0xc]
;     params->oneshotMode = 0;
700ae574: 9a00         	ldr	r2, [sp]
700ae576: 6110         	str	r0, [r2, #0x10]
;     params->enableOverflowInt = 1;
700ae578: 9a00         	ldr	r2, [sp]
700ae57a: 6151         	str	r1, [r2, #0x14]
;     params->enableDmaTrigger = 0; /* NOT USED */
700ae57c: 9900         	ldr	r1, [sp]
700ae57e: 6188         	str	r0, [r1, #0x18]
; }
700ae580: b001         	add	sp, #0x4
700ae582: 4770         	bx	lr
		...

700ae590 <UART_IsDataLengthValid>:
; {
700ae590: b082         	sub	sp, #0x8
700ae592: 9001         	str	r0, [sp, #0x4]
700ae594: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ae598: 9000         	str	r0, [sp]
;     if(((dataLength == UART_LEN_5) ||
700ae59a: 9801         	ldr	r0, [sp, #0x4]
700ae59c: b160         	cbz	r0, 0x700ae5b8 <UART_IsDataLengthValid+0x28> @ imm = #0x18
700ae59e: e7ff         	b	0x700ae5a0 <UART_IsDataLengthValid+0x10> @ imm = #-0x2
;         (dataLength == UART_LEN_6) ||
700ae5a0: 9801         	ldr	r0, [sp, #0x4]
700ae5a2: 2801         	cmp	r0, #0x1
700ae5a4: d008         	beq	0x700ae5b8 <UART_IsDataLengthValid+0x28> @ imm = #0x10
700ae5a6: e7ff         	b	0x700ae5a8 <UART_IsDataLengthValid+0x18> @ imm = #-0x2
;         (dataLength == UART_LEN_7) ||
700ae5a8: 9801         	ldr	r0, [sp, #0x4]
700ae5aa: 2802         	cmp	r0, #0x2
700ae5ac: d004         	beq	0x700ae5b8 <UART_IsDataLengthValid+0x28> @ imm = #0x8
700ae5ae: e7ff         	b	0x700ae5b0 <UART_IsDataLengthValid+0x20> @ imm = #-0x2
;         (dataLength == UART_LEN_8)))
700ae5b0: 9801         	ldr	r0, [sp, #0x4]
;     if(((dataLength == UART_LEN_5) ||
700ae5b2: 2803         	cmp	r0, #0x3
700ae5b4: d103         	bne	0x700ae5be <UART_IsDataLengthValid+0x2e> @ imm = #0x6
700ae5b6: e7ff         	b	0x700ae5b8 <UART_IsDataLengthValid+0x28> @ imm = #-0x2
700ae5b8: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ae5ba: 9000         	str	r0, [sp]
;     }
700ae5bc: e7ff         	b	0x700ae5be <UART_IsDataLengthValid+0x2e> @ imm = #-0x2
;     return status;
700ae5be: 9800         	ldr	r0, [sp]
700ae5c0: b002         	add	sp, #0x8
700ae5c2: 4770         	bx	lr
		...

700ae5d0 <UART_checkTransaction>:
; {
700ae5d0: b082         	sub	sp, #0x8
700ae5d2: 9001         	str	r0, [sp, #0x4]
700ae5d4: 2000         	movs	r0, #0x0
;     int32_t     status = UART_TRANSFER_STATUS_SUCCESS;
700ae5d6: 9000         	str	r0, [sp]
;     if(0U == trans->count)
700ae5d8: 9801         	ldr	r0, [sp, #0x4]
700ae5da: 6840         	ldr	r0, [r0, #0x4]
700ae5dc: b938         	cbnz	r0, 0x700ae5ee <UART_checkTransaction+0x1e> @ imm = #0xe
700ae5de: e7ff         	b	0x700ae5e0 <UART_checkTransaction+0x10> @ imm = #-0x2
;         trans->status = UART_TRANSFER_STATUS_ERROR_OTH;
700ae5e0: 9901         	ldr	r1, [sp, #0x4]
700ae5e2: 200a         	movs	r0, #0xa
700ae5e4: 60c8         	str	r0, [r1, #0xc]
700ae5e6: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ae5ea: 9000         	str	r0, [sp]
;     }
700ae5ec: e7ff         	b	0x700ae5ee <UART_checkTransaction+0x1e> @ imm = #-0x2
;     if(NULL == trans->buf)
700ae5ee: 9801         	ldr	r0, [sp, #0x4]
700ae5f0: 6800         	ldr	r0, [r0]
700ae5f2: b920         	cbnz	r0, 0x700ae5fe <UART_checkTransaction+0x2e> @ imm = #0x8
700ae5f4: e7ff         	b	0x700ae5f6 <UART_checkTransaction+0x26> @ imm = #-0x2
700ae5f6: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ae5fa: 9000         	str	r0, [sp]
;     }
700ae5fc: e7ff         	b	0x700ae5fe <UART_checkTransaction+0x2e> @ imm = #-0x2
;     return (status);
700ae5fe: 9800         	ldr	r0, [sp]
700ae600: b002         	add	sp, #0x8
700ae602: 4770         	bx	lr

700ae604 <free_list_remove>:
700ae604: e59f3028     	ldr	r3, [pc, #0x28]         @ 0x700ae634 <free_list_remove+0x30>
700ae608: e5932000     	ldr	r2, [r3]
700ae60c: e1a01003     	mov	r1, r3
700ae610: e3520000     	cmp	r2, #0
700ae614: 12823008     	addne	r3, r2, #8
700ae618: 11520000     	cmpne	r2, r0
700ae61c: 1afffff9     	bne	0x700ae608 <free_list_remove+0x4> @ imm = #-0x1c
700ae620: e3520000     	cmp	r2, #0
700ae624: 012fff1e     	bxeq	lr
700ae628: e5900008     	ldr	r0, [r0, #0x8]
700ae62c: e5810000     	str	r0, [r1]
700ae630: e12fff1e     	bx	lr
700ae634: ac 52 08 70  	.word	0x700852ac
700ae638: 00 00 00 00  	.word	0x00000000
700ae63c: 00 00 00 00  	.word	0x00000000

700ae640 <vPortTimerTickHandler>:
; void vPortTimerTickHandler() {
700ae640: b580         	push	{r7, lr}
;   portENTER_CRITICAL();
700ae642: f000 f89d    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #0x13a
;   if (ulPortSchedularRunning == pdTRUE) {
700ae646: f642 2020    	movw	r0, #0x2a20
700ae64a: f2c7 000b    	movt	r0, #0x700b
700ae64e: 6800         	ldr	r0, [r0]
700ae650: 2801         	cmp	r0, #0x1
700ae652: d10c         	bne	0x700ae66e <vPortTimerTickHandler+0x2e> @ imm = #0x18
700ae654: e7ff         	b	0x700ae656 <vPortTimerTickHandler+0x16> @ imm = #-0x2
;     if (xTaskIncrementTick() != pdFALSE) {
700ae656: f7f2 ffd3    	bl	0x700a1600 <xTaskIncrementTick> @ imm = #-0xd05a
700ae65a: b138         	cbz	r0, 0x700ae66c <vPortTimerTickHandler+0x2c> @ imm = #0xe
700ae65c: e7ff         	b	0x700ae65e <vPortTimerTickHandler+0x1e> @ imm = #-0x2
;       ulPortYieldRequired = pdTRUE;
700ae65e: f642 2128    	movw	r1, #0x2a28
700ae662: f2c7 010b    	movt	r1, #0x700b
700ae666: 2001         	movs	r0, #0x1
700ae668: 6008         	str	r0, [r1]
;     }
700ae66a: e7ff         	b	0x700ae66c <vPortTimerTickHandler+0x2c> @ imm = #-0x2
;   }
700ae66c: e7ff         	b	0x700ae66e <vPortTimerTickHandler+0x2e> @ imm = #-0x2
;   portEXIT_CRITICAL();
700ae66e: f7ff f947    	bl	0x700ad900 <vTaskExitCritical> @ imm = #-0xd72
; }
700ae672: bd80         	pop	{r7, pc}
		...

700ae680 <ClockP_timerTickIsr>:
; {
700ae680: b580         	push	{r7, lr}
700ae682: b082         	sub	sp, #0x8
700ae684: 9001         	str	r0, [sp, #0x4]
;     gClockCtrl.ticks++;
700ae686: f245 1190    	movw	r1, #0x5190
700ae68a: f2c7 0108    	movt	r1, #0x7008
700ae68e: 680a         	ldr	r2, [r1]
700ae690: 6848         	ldr	r0, [r1, #0x4]
700ae692: 3201         	adds	r2, #0x1
700ae694: f140 0000    	adc	r0, r0, #0x0
700ae698: 600a         	str	r2, [r1]
700ae69a: 6048         	str	r0, [r1, #0x4]
;     vPortTimerTickHandler();
700ae69c: f7ff ffd0    	bl	0x700ae640 <vPortTimerTickHandler> @ imm = #-0x60
;     ClockP_timerClearOverflowInt(gClockConfig.timerBaseAddr);
700ae6a0: f642 1010    	movw	r0, #0x2910
700ae6a4: f2c7 000b    	movt	r0, #0x700b
700ae6a8: 6800         	ldr	r0, [r0]
700ae6aa: f001 fa61    	bl	0x700afb70 <ClockP_timerClearOverflowInt> @ imm = #0x14c2
; }
700ae6ae: b002         	add	sp, #0x8
700ae6b0: bd80         	pop	{r7, pc}
		...
700ae6be: 0000         	movs	r0, r0

700ae6c0 <HW_WR_FIELD32_RAW>:
; {
700ae6c0: b085         	sub	sp, #0x14
700ae6c2: 9004         	str	r0, [sp, #0x10]
700ae6c4: 9103         	str	r1, [sp, #0xc]
700ae6c6: 9202         	str	r2, [sp, #0x8]
700ae6c8: 9301         	str	r3, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700ae6ca: 9804         	ldr	r0, [sp, #0x10]
700ae6cc: 6800         	ldr	r0, [r0]
700ae6ce: 9000         	str	r0, [sp]
;     regVal &= (~mask);
700ae6d0: 9903         	ldr	r1, [sp, #0xc]
700ae6d2: 9800         	ldr	r0, [sp]
700ae6d4: 4388         	bics	r0, r1
700ae6d6: 9000         	str	r0, [sp]
;     regVal |= (value << shift) & mask;
700ae6d8: 9801         	ldr	r0, [sp, #0x4]
700ae6da: 9902         	ldr	r1, [sp, #0x8]
700ae6dc: 4088         	lsls	r0, r1
700ae6de: 9903         	ldr	r1, [sp, #0xc]
700ae6e0: 4001         	ands	r1, r0
700ae6e2: 9800         	ldr	r0, [sp]
700ae6e4: 4308         	orrs	r0, r1
700ae6e6: 9000         	str	r0, [sp]
;     *(volatile uint32_t *) ((uintptr_t) addr) = regVal;
700ae6e8: 9800         	ldr	r0, [sp]
700ae6ea: 9904         	ldr	r1, [sp, #0x10]
700ae6ec: 6008         	str	r0, [r1]
;     return;
700ae6ee: b005         	add	sp, #0x14
700ae6f0: 4770         	bx	lr
		...
700ae6fe: 0000         	movs	r0, r0

700ae700 <UART_enhanFuncBitValRestore>:
; {
700ae700: b580         	push	{r7, lr}
700ae702: b084         	sub	sp, #0x10
700ae704: 9003         	str	r0, [sp, #0xc]
700ae706: 9102         	str	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ae708: 9803         	ldr	r0, [sp, #0xc]
700ae70a: 21bf         	movs	r1, #0xbf
700ae70c: f7fe f840    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #-0x1f80
700ae710: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700ae712: 9803         	ldr	r0, [sp, #0xc]
700ae714: 3008         	adds	r0, #0x8
700ae716: 9902         	ldr	r1, [sp, #0x8]
700ae718: ea4f 1311    	lsr.w	r3, r1, #0x4
700ae71c: 2110         	movs	r1, #0x10
700ae71e: 2204         	movs	r2, #0x4
700ae720: f7ff ffce    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #-0x64
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ae724: 9803         	ldr	r0, [sp, #0xc]
700ae726: 300c         	adds	r0, #0xc
700ae728: 9901         	ldr	r1, [sp, #0x4]
700ae72a: f001 fa31    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x1462
; }
700ae72e: b004         	add	sp, #0x10
700ae730: bd80         	pop	{r7, pc}
		...
700ae73e: 0000         	movs	r0, r0

700ae740 <UART_hardwareFlowCtrlOptSet>:
; {
700ae740: b580         	push	{r7, lr}
700ae742: b084         	sub	sp, #0x10
700ae744: 9003         	str	r0, [sp, #0xc]
700ae746: 9102         	str	r1, [sp, #0x8]
700ae748: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700ae74a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ae74c: 9803         	ldr	r0, [sp, #0xc]
700ae74e: 21bf         	movs	r1, #0xbf
700ae750: f7fe f81e    	bl	0x700ac790 <UART_regConfigModeEnable> @ imm = #-0x1fc4
700ae754: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_HW_FLOW_CONTROL, hwFlowCtrl);
700ae756: 9803         	ldr	r0, [sp, #0xc]
700ae758: 3008         	adds	r0, #0x8
700ae75a: 9b02         	ldr	r3, [sp, #0x8]
700ae75c: 21c0         	movs	r1, #0xc0
700ae75e: 2206         	movs	r2, #0x6
700ae760: f7ff ffae    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #-0xa4
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ae764: 9803         	ldr	r0, [sp, #0xc]
700ae766: 300c         	adds	r0, #0xc
700ae768: 9901         	ldr	r1, [sp, #0x4]
700ae76a: f001 fa11    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x1422
; }
700ae76e: b004         	add	sp, #0x10
700ae770: bd80         	pop	{r7, pc}
		...
700ae77e: 0000         	movs	r0, r0

700ae780 <vTaskEnterCritical>:
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700ae780: b672         	cpsid i
;   if (xSchedulerRunning != pdFALSE) {
700ae782: f642 2050    	movw	r0, #0x2a50
700ae786: f2c7 000b    	movt	r0, #0x700b
700ae78a: 6800         	ldr	r0, [r0]
700ae78c: b178         	cbz	r0, 0x700ae7ae <vTaskEnterCritical+0x2e> @ imm = #0x1e
700ae78e: e7ff         	b	0x700ae790 <vTaskEnterCritical+0x10> @ imm = #-0x2
;     (pxCurrentTCB->uxCriticalNesting)++;
700ae790: f642 200c    	movw	r0, #0x2a0c
700ae794: f2c7 000b    	movt	r0, #0x700b
700ae798: 6802         	ldr	r2, [r0]
700ae79a: 6d51         	ldr	r1, [r2, #0x54]
700ae79c: 3101         	adds	r1, #0x1
700ae79e: 6551         	str	r1, [r2, #0x54]
;     if (pxCurrentTCB->uxCriticalNesting == 1) {
700ae7a0: 6800         	ldr	r0, [r0]
700ae7a2: 6d40         	ldr	r0, [r0, #0x54]
700ae7a4: 2801         	cmp	r0, #0x1
700ae7a6: d101         	bne	0x700ae7ac <vTaskEnterCritical+0x2c> @ imm = #0x2
700ae7a8: e7ff         	b	0x700ae7aa <vTaskEnterCritical+0x2a> @ imm = #-0x2
;     }
700ae7aa: e7ff         	b	0x700ae7ac <vTaskEnterCritical+0x2c> @ imm = #-0x2
;   } else {
700ae7ac: e000         	b	0x700ae7b0 <vTaskEnterCritical+0x30> @ imm = #0x0
700ae7ae: e7ff         	b	0x700ae7b0 <vTaskEnterCritical+0x30> @ imm = #-0x2
; }
700ae7b0: 4770         	bx	lr
		...
700ae7be: 0000         	movs	r0, r0

700ae7c0 <xQueueCreateMutexStatic>:
;     {
700ae7c0: b580         	push	{r7, lr}
700ae7c2: b086         	sub	sp, #0x18
700ae7c4: f88d 0017    	strb.w	r0, [sp, #0x17]
700ae7c8: 9104         	str	r1, [sp, #0x10]
700ae7ca: 2001         	movs	r0, #0x1
;         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
700ae7cc: 9002         	str	r0, [sp, #0x8]
700ae7ce: 2200         	movs	r2, #0x0
700ae7d0: 9201         	str	r2, [sp, #0x4]
;         ( void ) ucQueueType;
700ae7d2: f89d 1017    	ldrb.w	r1, [sp, #0x17]
;         xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
700ae7d6: 9b04         	ldr	r3, [sp, #0x10]
700ae7d8: 46ec         	mov	r12, sp
700ae7da: f8cc 1000    	str.w	r1, [r12]
700ae7de: 4611         	mov	r1, r2
700ae7e0: f7fe ff06    	bl	0x700ad5f0 <xQueueGenericCreateStatic> @ imm = #-0x11f4
700ae7e4: 9003         	str	r0, [sp, #0xc]
;         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
700ae7e6: 9803         	ldr	r0, [sp, #0xc]
700ae7e8: f000 fa32    	bl	0x700aec50 <prvInitialiseMutex> @ imm = #0x464
;         return xNewQueue;
700ae7ec: 9803         	ldr	r0, [sp, #0xc]
700ae7ee: b006         	add	sp, #0x18
700ae7f0: bd80         	pop	{r7, pc}
		...
700ae7fe: 0000         	movs	r0, r0

700ae800 <CSL_pktdmaGetChanPeerReg>:
; {
700ae800: b510         	push	{r4, lr}
700ae802: b086         	sub	sp, #0x18
700ae804: f8dd c020    	ldr.w	r12, [sp, #0x20]
700ae808: 9005         	str	r0, [sp, #0x14]
700ae80a: 9104         	str	r1, [sp, #0x10]
700ae80c: 9203         	str	r2, [sp, #0xc]
700ae80e: 9302         	str	r3, [sp, #0x8]
;     return CSL_pktdmaAccessChanPeerReg( pCfg, chanIdx, regIdx, pVal, chanDir, (bool)true );
700ae810: 9805         	ldr	r0, [sp, #0x14]
700ae812: 9904         	ldr	r1, [sp, #0x10]
700ae814: 9a02         	ldr	r2, [sp, #0x8]
700ae816: 9b08         	ldr	r3, [sp, #0x20]
700ae818: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700ae81c: 46ee         	mov	lr, sp
700ae81e: 2401         	movs	r4, #0x1
700ae820: f8ce 4004    	str.w	r4, [lr, #0x4]
700ae824: f8ce c000    	str.w	r12, [lr]
700ae828: f7f9 f8b2    	bl	0x700a7990 <CSL_pktdmaAccessChanPeerReg> @ imm = #-0x6e9c
700ae82c: b006         	add	sp, #0x18
700ae82e: bd10         	pop	{r4, pc}

700ae830 <CSL_pktdmaSetChanPeerReg>:
; {
700ae830: b510         	push	{r4, lr}
700ae832: b086         	sub	sp, #0x18
700ae834: f8dd c020    	ldr.w	r12, [sp, #0x20]
700ae838: 9005         	str	r0, [sp, #0x14]
700ae83a: 9104         	str	r1, [sp, #0x10]
700ae83c: 9203         	str	r2, [sp, #0xc]
700ae83e: 9302         	str	r3, [sp, #0x8]
;     return CSL_pktdmaAccessChanPeerReg( pCfg, chanIdx, regIdx, pVal, chanDir, (bool)false );
700ae840: 9805         	ldr	r0, [sp, #0x14]
700ae842: 9904         	ldr	r1, [sp, #0x10]
700ae844: 9a02         	ldr	r2, [sp, #0x8]
700ae846: 9b08         	ldr	r3, [sp, #0x20]
700ae848: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700ae84c: 46ee         	mov	lr, sp
700ae84e: 2400         	movs	r4, #0x0
700ae850: f8ce 4004    	str.w	r4, [lr, #0x4]
700ae854: f8ce c000    	str.w	r12, [lr]
700ae858: f7f9 f89a    	bl	0x700a7990 <CSL_pktdmaAccessChanPeerReg> @ imm = #-0x6ecc
700ae85c: b006         	add	sp, #0x18
700ae85e: bd10         	pop	{r4, pc}

700ae860 <UART_flowCtrlTrigLvlConfig>:
; {
700ae860: b580         	push	{r7, lr}
700ae862: b084         	sub	sp, #0x10
700ae864: 9003         	str	r0, [sp, #0xc]
700ae866: 9102         	str	r1, [sp, #0x8]
700ae868: 9201         	str	r2, [sp, #0x4]
700ae86a: 2000         	movs	r0, #0x0
;     uint32_t tcrValue = 0;
700ae86c: 9000         	str	r0, [sp]
;     tcrValue = rtsHaltFlag & UART_TCR_RX_FIFO_TRIG_HALT_MASK;
700ae86e: 9802         	ldr	r0, [sp, #0x8]
700ae870: f000 000f    	and	r0, r0, #0xf
700ae874: 9000         	str	r0, [sp]
;     tcrValue |= (rtsStartFlag <<
700ae876: 9801         	ldr	r0, [sp, #0x4]
700ae878: 0100         	lsls	r0, r0, #0x4
;                  UART_TCR_RX_FIFO_TRIG_START_SHIFT) &
700ae87a: b2c1         	uxtb	r1, r0
;     tcrValue |= (rtsStartFlag <<
700ae87c: 9800         	ldr	r0, [sp]
700ae87e: 4308         	orrs	r0, r1
700ae880: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_TCR, tcrValue);
700ae882: 9803         	ldr	r0, [sp, #0xc]
700ae884: 3018         	adds	r0, #0x18
700ae886: 9900         	ldr	r1, [sp]
700ae888: f001 f982    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x1304
; }
700ae88c: b004         	add	sp, #0x10
700ae88e: bd80         	pop	{r7, pc}

700ae890 <_outc>:
700ae890: e5912008     	ldr	r2, [r1, #0x8]
700ae894: e5913004     	ldr	r3, [r1, #0x4]
700ae898: e1520003     	cmp	r2, r3
700ae89c: 2a000004     	bhs	0x700ae8b4 <_outc+0x24> @ imm = #0x10
700ae8a0: e5912000     	ldr	r2, [r1]
700ae8a4: e2823001     	add	r3, r2, #1
700ae8a8: e5813000     	str	r3, [r1]
700ae8ac: e5c20000     	strb	r0, [r2]
700ae8b0: e5912008     	ldr	r2, [r1, #0x8]
700ae8b4: e2822001     	add	r2, r2, #1
700ae8b8: e5812008     	str	r2, [r1, #0x8]
700ae8bc: e12fff1e     	bx	lr

700ae8c0 <CycleCounterP_getCount32>:
;         MRC     p15, #0, r0, c9, c13, 0  // read PMCCNTR
700ae8c0: ee190f1d     	mrc	p15, #0x0, r0, c9, c13, #0x0
;         bx      LR
700ae8c4: e12fff1e     	bx	lr

700ae8c8 <PmuP_setup>:
;         MCR     p15, #0, r0, c9, c12, 0 // write PMCR
700ae8c8: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;         bx      LR
700ae8cc: e12fff1e     	bx	lr

700ae8d0 <PmuP_enableCounters>:
;         MCR     p15, #0, r0, c9, c12, 1  // write PMCNTENSET
700ae8d0: ee090f3c     	mcr	p15, #0x0, r0, c9, c12, #0x1
;         bx      LR
700ae8d4: e12fff1e     	bx	lr

700ae8d8 <PmuP_disableCounters>:
;         MCR     p15, #0, r0, c9, c12, 2  // write PMCNTENCLR
700ae8d8: ee090f5c     	mcr	p15, #0x0, r0, c9, c12, #0x2
;         bx      LR
700ae8dc: e12fff1e     	bx	lr

700ae8e0 <PmuP_getOverflowStatus>:
;         MRC     p15, 0, r0, c9, c12, 3  // read PMOVSR
700ae8e0: ee190f7c     	mrc	p15, #0x0, r0, c9, c12, #0x3
;         bx      LR
700ae8e4: e12fff1e     	bx	lr

700ae8e8 <PmuP_clearOverflowStatus>:
;         MCR     p15, 0, r0, c9, c12, 3  // write PMOVSR
700ae8e8: ee090f7c     	mcr	p15, #0x0, r0, c9, c12, #0x3
;         bx      LR
700ae8ec: e12fff1e     	bx	lr

700ae8f0 <CSL_secProxyGetMaxMsgSize>:
; {
700ae8f0: b580         	push	{r7, lr}
700ae8f2: b082         	sub	sp, #0x8
700ae8f4: 9001         	str	r0, [sp, #0x4]
;     if( pSecProxyCfg->maxMsgSize == (uint32_t)0U )
700ae8f6: 9801         	ldr	r0, [sp, #0x4]
700ae8f8: 6980         	ldr	r0, [r0, #0x18]
700ae8fa: b960         	cbnz	r0, 0x700ae916 <CSL_secProxyGetMaxMsgSize+0x26> @ imm = #0x18
700ae8fc: e7ff         	b	0x700ae8fe <CSL_secProxyGetMaxMsgSize+0xe> @ imm = #-0x2
;         pSecProxyCfg->maxMsgSize = (uint32_t)CSL_REG32_FEXT( &pSecProxyCfg->pSecProxyRegs->CONFIG, SEC_PROXY_CONFIG_MSG_SIZE );
700ae8fe: 9801         	ldr	r0, [sp, #0x4]
700ae900: 6800         	ldr	r0, [r0]
700ae902: 3004         	adds	r0, #0x4
700ae904: 2100         	movs	r1, #0x0
700ae906: f6cf 71ff    	movt	r1, #0xffff
700ae90a: 2210         	movs	r2, #0x10
700ae90c: f000 fc10    	bl	0x700af130 <CSL_REG32_FEXT_RAW> @ imm = #0x820
700ae910: 9901         	ldr	r1, [sp, #0x4]
700ae912: 6188         	str	r0, [r1, #0x18]
;     }
700ae914: e7ff         	b	0x700ae916 <CSL_secProxyGetMaxMsgSize+0x26> @ imm = #-0x2
;     return pSecProxyCfg->maxMsgSize;
700ae916: 9801         	ldr	r0, [sp, #0x4]
700ae918: 6980         	ldr	r0, [r0, #0x18]
700ae91a: b002         	add	sp, #0x8
700ae91c: bd80         	pop	{r7, pc}
700ae91e: 0000         	movs	r0, r0

700ae920 <Sciclient_rmIaIsIa>:
; {
700ae920: b580         	push	{r7, lr}
700ae922: b082         	sub	sp, #0x8
700ae924: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ae928: 2000         	movs	r0, #0x0
;     bool r = false;
700ae92a: f88d 0005    	strb.w	r0, [sp, #0x5]
;     if (Sciclient_rmIaGetInst(id) != NULL) {
700ae92e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ae932: f7fd fe0d    	bl	0x700ac550 <Sciclient_rmIaGetInst> @ imm = #-0x23e6
700ae936: b120         	cbz	r0, 0x700ae942 <Sciclient_rmIaIsIa+0x22> @ imm = #0x8
700ae938: e7ff         	b	0x700ae93a <Sciclient_rmIaIsIa+0x1a> @ imm = #-0x2
700ae93a: 2001         	movs	r0, #0x1
;         r = true;
700ae93c: f88d 0005    	strb.w	r0, [sp, #0x5]
;     }
700ae940: e7ff         	b	0x700ae942 <Sciclient_rmIaIsIa+0x22> @ imm = #-0x2
;     return r;
700ae942: f89d 0005    	ldrb.w	r0, [sp, #0x5]
700ae946: f000 0001    	and	r0, r0, #0x1
700ae94a: b002         	add	sp, #0x8
700ae94c: bd80         	pop	{r7, pc}
700ae94e: 0000         	movs	r0, r0

700ae950 <Sciclient_rmIrIsIr>:
; {
700ae950: b580         	push	{r7, lr}
700ae952: b082         	sub	sp, #0x8
700ae954: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ae958: 2000         	movs	r0, #0x0
;     bool r = false;
700ae95a: f88d 0005    	strb.w	r0, [sp, #0x5]
;     if (Sciclient_rmIrGetInst(id) != NULL) {
700ae95e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ae962: f7fd f90d    	bl	0x700abb80 <Sciclient_rmIrGetInst> @ imm = #-0x2de6
700ae966: b120         	cbz	r0, 0x700ae972 <Sciclient_rmIrIsIr+0x22> @ imm = #0x8
700ae968: e7ff         	b	0x700ae96a <Sciclient_rmIrIsIr+0x1a> @ imm = #-0x2
700ae96a: 2001         	movs	r0, #0x1
;         r = true;
700ae96c: f88d 0005    	strb.w	r0, [sp, #0x5]
;     }
700ae970: e7ff         	b	0x700ae972 <Sciclient_rmIrIsIr+0x22> @ imm = #-0x2
;     return r;
700ae972: f89d 0005    	ldrb.w	r0, [sp, #0x5]
700ae976: f000 0001    	and	r0, r0, #0x1
700ae97a: b002         	add	sp, #0x8
700ae97c: bd80         	pop	{r7, pc}
700ae97e: 0000         	movs	r0, r0

700ae980 <Sciclient_secProxyReadThread32>:
; {
700ae980: b580         	push	{r7, lr}
700ae982: b084         	sub	sp, #0x10
700ae984: 9003         	str	r0, [sp, #0xc]
700ae986: f88d 100b    	strb.w	r1, [sp, #0xb]
;     ret = CSL_REG32_RD(CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg,thread,0U) +
700ae98a: 9903         	ldr	r1, [sp, #0xc]
700ae98c: f642 00d0    	movw	r0, #0x28d0
700ae990: f2c7 000b    	movt	r0, #0x700b
700ae994: 2200         	movs	r2, #0x0
700ae996: f000 fdeb    	bl	0x700af570 <CSL_secProxyGetDataAddr> @ imm = #0xbd6
700ae99a: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700ae99e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ae9a2: f001 f94d    	bl	0x700afc40 <CSL_REG32_RD_RAW> @ imm = #0x129a
700ae9a6: 9001         	str	r0, [sp, #0x4]
;     return ret;
700ae9a8: 9801         	ldr	r0, [sp, #0x4]
700ae9aa: b004         	add	sp, #0x10
700ae9ac: bd80         	pop	{r7, pc}
700ae9ae: 0000         	movs	r0, r0

700ae9b0 <System_init>:
; {
700ae9b0: b580         	push	{r7, lr}
;     Dpl_init();
700ae9b2: f7fe ff55    	bl	0x700ad860 <Dpl_init>   @ imm = #-0x1156
;         retVal = Sciclient_init(CSL_CORE_ID_R5FSS0_0);
700ae9b6: 2001         	movs	r0, #0x1
700ae9b8: f7fa fe42    	bl	0x700a9640 <Sciclient_init> @ imm = #-0x537c
;         DebugP_assertNoLog(SystemP_SUCCESS == retVal);
700ae9bc: fab0 f080    	clz	r0, r0
700ae9c0: 0940         	lsrs	r0, r0, #0x5
700ae9c2: f002 fc8d    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x291a
;     CycleCounterP_init(SOC_getSelfCpuClk());
700ae9c6: f000 fbe3    	bl	0x700af190 <SOC_getSelfCpuClk> @ imm = #0x7c6
700ae9ca: f7f9 fd81    	bl	0x700a84d0 <CycleCounterP_init> @ imm = #-0x64fe
;     PowerClock_init();
700ae9ce: f7fb fe77    	bl	0x700aa6c0 <PowerClock_init> @ imm = #-0x4312
;     Pinmux_init();
700ae9d2: f000 fc65    	bl	0x700af2a0 <Pinmux_init> @ imm = #0x8ca
;     UART_init();
700ae9d6: e8bd 4080    	pop.w	{r7, lr}
700ae9da: f7f9 b959    	b.w	0x700a7c90 <UART_init>  @ imm = #-0x6d4e
700ae9de: 0000         	movs	r0, r0

700ae9e0 <_is_digit>:
; {
700ae9e0: b082         	sub	sp, #0x8
700ae9e2: f88d 0007    	strb.w	r0, [sp, #0x7]
;   return (ch >= '0') && (ch <= '9');
700ae9e6: f89d 1007    	ldrb.w	r1, [sp, #0x7]
700ae9ea: 2000         	movs	r0, #0x0
700ae9ec: 2930         	cmp	r1, #0x30
700ae9ee: 9000         	str	r0, [sp]
700ae9f0: db08         	blt	0x700aea04 <_is_digit+0x24> @ imm = #0x10
700ae9f2: e7ff         	b	0x700ae9f4 <_is_digit+0x14> @ imm = #-0x2
700ae9f4: f89d 1007    	ldrb.w	r1, [sp, #0x7]
700ae9f8: 2000         	movs	r0, #0x0
700ae9fa: 293a         	cmp	r1, #0x3a
700ae9fc: bfb8         	it	lt
700ae9fe: 2001         	movlt	r0, #0x1
700aea00: 9000         	str	r0, [sp]
700aea02: e7ff         	b	0x700aea04 <_is_digit+0x24> @ imm = #-0x2
700aea04: 9800         	ldr	r0, [sp]
;   return (ch >= '0') && (ch <= '9');
700aea06: f000 0001    	and	r0, r0, #0x1
700aea0a: b002         	add	sp, #0x8
700aea0c: 4770         	bx	lr
700aea0e: 0000         	movs	r0, r0

700aea10 <prvIsQueueFull>:
; {
700aea10: b580         	push	{r7, lr}
700aea12: b082         	sub	sp, #0x8
700aea14: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700aea16: f7ff feb3    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #-0x29a
;         if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
700aea1a: 9801         	ldr	r0, [sp, #0x4]
700aea1c: 6b80         	ldr	r0, [r0, #0x38]
700aea1e: 9901         	ldr	r1, [sp, #0x4]
700aea20: 6bc9         	ldr	r1, [r1, #0x3c]
700aea22: 4288         	cmp	r0, r1
700aea24: d103         	bne	0x700aea2e <prvIsQueueFull+0x1e> @ imm = #0x6
700aea26: e7ff         	b	0x700aea28 <prvIsQueueFull+0x18> @ imm = #-0x2
700aea28: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
700aea2a: 9000         	str	r0, [sp]
;         }
700aea2c: e002         	b	0x700aea34 <prvIsQueueFull+0x24> @ imm = #0x4
700aea2e: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
700aea30: 9000         	str	r0, [sp]
700aea32: e7ff         	b	0x700aea34 <prvIsQueueFull+0x24> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700aea34: f7fe ff64    	bl	0x700ad900 <vTaskExitCritical> @ imm = #-0x1138
;     return xReturn;
700aea38: 9800         	ldr	r0, [sp]
700aea3a: b002         	add	sp, #0x8
700aea3c: bd80         	pop	{r7, pc}
700aea3e: 0000         	movs	r0, r0

700aea40 <prvTaskCheckFreeStackSpace>:
; prvTaskCheckFreeStackSpace(const uint8_t *pucStackByte) {
700aea40: b082         	sub	sp, #0x8
700aea42: 9001         	str	r0, [sp, #0x4]
700aea44: 2000         	movs	r0, #0x0
;   uint32_t ulCount = 0U;
700aea46: 9000         	str	r0, [sp]
;   while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
700aea48: e7ff         	b	0x700aea4a <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x2
700aea4a: 9801         	ldr	r0, [sp, #0x4]
700aea4c: 7800         	ldrb	r0, [r0]
700aea4e: 28a5         	cmp	r0, #0xa5
700aea50: d107         	bne	0x700aea62 <prvTaskCheckFreeStackSpace+0x22> @ imm = #0xe
700aea52: e7ff         	b	0x700aea54 <prvTaskCheckFreeStackSpace+0x14> @ imm = #-0x2
;     pucStackByte -= portSTACK_GROWTH;
700aea54: 9801         	ldr	r0, [sp, #0x4]
700aea56: 3001         	adds	r0, #0x1
700aea58: 9001         	str	r0, [sp, #0x4]
;     ulCount++;
700aea5a: 9800         	ldr	r0, [sp]
700aea5c: 3001         	adds	r0, #0x1
700aea5e: 9000         	str	r0, [sp]
;   while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
700aea60: e7f3         	b	0x700aea4a <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x1a
;   ulCount /=
700aea62: 9800         	ldr	r0, [sp]
700aea64: 0880         	lsrs	r0, r0, #0x2
700aea66: 9000         	str	r0, [sp]
;   return (configSTACK_DEPTH_TYPE)ulCount;
700aea68: 9800         	ldr	r0, [sp]
700aea6a: b002         	add	sp, #0x8
700aea6c: 4770         	bx	lr
700aea6e: 0000         	movs	r0, r0

700aea70 <tm_queue_send_from_isr>:
; {
700aea70: b580         	push	{r7, lr}
700aea72: b082         	sub	sp, #0x8
;    status = xQueueSendToBackFromISR(tm_queue_array[queue_id], (const void*) message_ptr, &xHigherPriorityTaskWoken);
700aea74: f245 22b4    	movw	r2, #0x52b4
700aea78: 2300         	movs	r3, #0x0
700aea7a: f2c7 0208    	movt	r2, #0x7008
700aea7e: f852 0020    	ldr.w	r0, [r2, r0, lsl #2]
700aea82: aa01         	add	r2, sp, #0x4
;    status = xQueueSendToBackFromISR(tm_queue_array[queue_id], (const void*) message_ptr, &xHigherPriorityTaskWoken);
700aea84: f7f9 ffdc    	bl	0x700a8a40 <xQueueGenericSendFromISR> @ imm = #-0x6048
;    if (status != pdTRUE)
700aea88: 2801         	cmp	r0, #0x1
700aea8a: d105         	bne	0x700aea98 <tm_queue_send_from_isr+0x28> @ imm = #0xa
;    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
700aea8c: 9801         	ldr	r0, [sp, #0x4]
700aea8e: f000 fdaf    	bl	0x700af5f0 <vPortYeildFromISR> @ imm = #0xb5e
700aea92: 2000         	movs	r0, #0x0
; }
700aea94: b002         	add	sp, #0x8
700aea96: bd80         	pop	{r7, pc}
700aea98: 2001         	movs	r0, #0x1
; }
700aea9a: b002         	add	sp, #0x8
700aea9c: bd80         	pop	{r7, pc}
700aea9e: 0000         	movs	r0, r0

700aeaa0 <vListInitialise>:
; {
700aeaa0: b081         	sub	sp, #0x4
700aeaa2: 9000         	str	r0, [sp]
;     pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700aeaa4: 9900         	ldr	r1, [sp]
700aeaa6: f101 0008    	add.w	r0, r1, #0x8
700aeaaa: 6048         	str	r0, [r1, #0x4]
;     pxList->xListEnd.xItemValue = portMAX_DELAY;
700aeaac: 9900         	ldr	r1, [sp]
700aeaae: f04f 30ff    	mov.w	r0, #0xffffffff
700aeab2: 6088         	str	r0, [r1, #0x8]
;     pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700aeab4: 9900         	ldr	r1, [sp]
700aeab6: f101 0008    	add.w	r0, r1, #0x8
700aeaba: 60c8         	str	r0, [r1, #0xc]
;     pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700aeabc: 9900         	ldr	r1, [sp]
700aeabe: f101 0008    	add.w	r0, r1, #0x8
700aeac2: 6108         	str	r0, [r1, #0x10]
;     pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
700aeac4: 9900         	ldr	r1, [sp]
700aeac6: 2000         	movs	r0, #0x0
700aeac8: 6008         	str	r0, [r1]
; }
700aeaca: b001         	add	sp, #0x4
700aeacc: 4770         	bx	lr
700aeace: 0000         	movs	r0, r0

700aead0 <CSL_bcdmaGetRxRT>:
; {
700aead0: b580         	push	{r7, lr}
700aead2: b084         	sub	sp, #0x10
700aead4: 9003         	str	r0, [sp, #0xc]
700aead6: 9102         	str	r1, [sp, #0x8]
700aead8: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_RT, chanIdx, (void *)pRT );
700aeada: 9803         	ldr	r0, [sp, #0xc]
700aeadc: 9a02         	ldr	r2, [sp, #0x8]
700aeade: 9b01         	ldr	r3, [sp, #0x4]
700aeae0: 2107         	movs	r1, #0x7
700aeae2: f7fc fa55    	bl	0x700aaf90 <CSL_bcdmaDoChanOp> @ imm = #-0x3b56
700aeae6: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700aeae8: 9800         	ldr	r0, [sp]
700aeaea: b120         	cbz	r0, 0x700aeaf6 <CSL_bcdmaGetRxRT+0x26> @ imm = #0x8
700aeaec: e7ff         	b	0x700aeaee <CSL_bcdmaGetRxRT+0x1e> @ imm = #-0x2
700aeaee: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700aeaf2: 9000         	str	r0, [sp]
;     }
700aeaf4: e7ff         	b	0x700aeaf6 <CSL_bcdmaGetRxRT+0x26> @ imm = #-0x2
;     return retVal;
700aeaf6: 9800         	ldr	r0, [sp]
700aeaf8: b004         	add	sp, #0x10
700aeafa: bd80         	pop	{r7, pc}
700aeafc: 0000         	movs	r0, r0
700aeafe: 0000         	movs	r0, r0

700aeb00 <CSL_bcdmaGetTxRT>:
; {
700aeb00: b580         	push	{r7, lr}
700aeb02: b084         	sub	sp, #0x10
700aeb04: 9003         	str	r0, [sp, #0xc]
700aeb06: 9102         	str	r1, [sp, #0x8]
700aeb08: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_RT, chanIdx, (void *)pRT );
700aeb0a: 9803         	ldr	r0, [sp, #0xc]
700aeb0c: 9a02         	ldr	r2, [sp, #0x8]
700aeb0e: 9b01         	ldr	r3, [sp, #0x4]
700aeb10: 2107         	movs	r1, #0x7
700aeb12: f7fc fa3d    	bl	0x700aaf90 <CSL_bcdmaDoChanOp> @ imm = #-0x3b86
700aeb16: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700aeb18: 9800         	ldr	r0, [sp]
700aeb1a: b120         	cbz	r0, 0x700aeb26 <CSL_bcdmaGetTxRT+0x26> @ imm = #0x8
700aeb1c: e7ff         	b	0x700aeb1e <CSL_bcdmaGetTxRT+0x1e> @ imm = #-0x2
700aeb1e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700aeb22: 9000         	str	r0, [sp]
;     }
700aeb24: e7ff         	b	0x700aeb26 <CSL_bcdmaGetTxRT+0x26> @ imm = #-0x2
;     return retVal;
700aeb26: 9800         	ldr	r0, [sp]
700aeb28: b004         	add	sp, #0x10
700aeb2a: bd80         	pop	{r7, pc}
700aeb2c: 0000         	movs	r0, r0
700aeb2e: 0000         	movs	r0, r0

700aeb30 <CSL_bcdmaSetRxRT>:
; {
700aeb30: b580         	push	{r7, lr}
700aeb32: b084         	sub	sp, #0x10
700aeb34: 9003         	str	r0, [sp, #0xc]
700aeb36: 9102         	str	r1, [sp, #0x8]
700aeb38: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_RT, chanIdx, (void *)pRT );
700aeb3a: 9803         	ldr	r0, [sp, #0xc]
700aeb3c: 9a02         	ldr	r2, [sp, #0x8]
700aeb3e: 9b01         	ldr	r3, [sp, #0x4]
700aeb40: 2108         	movs	r1, #0x8
700aeb42: f7fc fa25    	bl	0x700aaf90 <CSL_bcdmaDoChanOp> @ imm = #-0x3bb6
700aeb46: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700aeb48: 9800         	ldr	r0, [sp]
700aeb4a: b120         	cbz	r0, 0x700aeb56 <CSL_bcdmaSetRxRT+0x26> @ imm = #0x8
700aeb4c: e7ff         	b	0x700aeb4e <CSL_bcdmaSetRxRT+0x1e> @ imm = #-0x2
700aeb4e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700aeb52: 9000         	str	r0, [sp]
;     }
700aeb54: e7ff         	b	0x700aeb56 <CSL_bcdmaSetRxRT+0x26> @ imm = #-0x2
;     return retVal;
700aeb56: 9800         	ldr	r0, [sp]
700aeb58: b004         	add	sp, #0x10
700aeb5a: bd80         	pop	{r7, pc}
700aeb5c: 0000         	movs	r0, r0
700aeb5e: 0000         	movs	r0, r0

700aeb60 <CSL_bcdmaSetTxRT>:
; {
700aeb60: b580         	push	{r7, lr}
700aeb62: b084         	sub	sp, #0x10
700aeb64: 9003         	str	r0, [sp, #0xc]
700aeb66: 9102         	str	r1, [sp, #0x8]
700aeb68: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_RT, chanIdx, (void *)pRT );
700aeb6a: 9803         	ldr	r0, [sp, #0xc]
700aeb6c: 9a02         	ldr	r2, [sp, #0x8]
700aeb6e: 9b01         	ldr	r3, [sp, #0x4]
700aeb70: 2108         	movs	r1, #0x8
700aeb72: f7fc fa0d    	bl	0x700aaf90 <CSL_bcdmaDoChanOp> @ imm = #-0x3be6
700aeb76: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700aeb78: 9800         	ldr	r0, [sp]
700aeb7a: b120         	cbz	r0, 0x700aeb86 <CSL_bcdmaSetTxRT+0x26> @ imm = #0x8
700aeb7c: e7ff         	b	0x700aeb7e <CSL_bcdmaSetTxRT+0x1e> @ imm = #-0x2
700aeb7e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700aeb82: 9000         	str	r0, [sp]
;     }
700aeb84: e7ff         	b	0x700aeb86 <CSL_bcdmaSetTxRT+0x26> @ imm = #-0x2
;     return retVal;
700aeb86: 9800         	ldr	r0, [sp]
700aeb88: b004         	add	sp, #0x10
700aeb8a: bd80         	pop	{r7, pc}
700aeb8c: 0000         	movs	r0, r0
700aeb8e: 0000         	movs	r0, r0

700aeb90 <DebugP_logZoneEnable>:
; {
700aeb90: b580         	push	{r7, lr}
700aeb92: b084         	sub	sp, #0x10
700aeb94: 9003         	str	r0, [sp, #0xc]
;     oldIntState = HwiP_disable();
700aeb96: f001 eee4    	blx	0x700b0960 <HwiP_disable> @ imm = #0x1dc8
700aeb9a: 9001         	str	r0, [sp, #0x4]
;     oldZoneMask = gDebugLogZone;
700aeb9c: f642 11e0    	movw	r1, #0x29e0
700aeba0: f2c7 010b    	movt	r1, #0x700b
700aeba4: 6808         	ldr	r0, [r1]
700aeba6: 9002         	str	r0, [sp, #0x8]
;     gDebugLogZone = gDebugLogZone | (logZoneMask);
700aeba8: 6808         	ldr	r0, [r1]
700aebaa: 9a03         	ldr	r2, [sp, #0xc]
700aebac: 4310         	orrs	r0, r2
700aebae: 6008         	str	r0, [r1]
;     HwiP_restore(oldIntState);
700aebb0: 9801         	ldr	r0, [sp, #0x4]
700aebb2: f001 eef6    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x1dec
;     return oldZoneMask;
700aebb6: 9802         	ldr	r0, [sp, #0x8]
700aebb8: b004         	add	sp, #0x10
700aebba: bd80         	pop	{r7, pc}
700aebbc: 0000         	movs	r0, r0
700aebbe: 0000         	movs	r0, r0

700aebc0 <Sciclient_getIrAddr>:
; {
700aebc0: b580         	push	{r7, lr}
700aebc2: b084         	sub	sp, #0x10
700aebc4: 9003         	str	r0, [sp, #0xc]
700aebc6: 9102         	str	r1, [sp, #0x8]
;     int_ctrl_reg = (uint32_t *)(addr + Sciclient_rmIrIntControlReg(i));
700aebc8: 9803         	ldr	r0, [sp, #0xc]
700aebca: 9000         	str	r0, [sp]
700aebcc: f8bd 0008    	ldrh.w	r0, [sp, #0x8]
700aebd0: f000 fed6    	bl	0x700af980 <Sciclient_rmIrIntControlReg> @ imm = #0xdac
700aebd4: 4601         	mov	r1, r0
700aebd6: 9800         	ldr	r0, [sp]
700aebd8: 4408         	add	r0, r1
700aebda: 9001         	str	r0, [sp, #0x4]
;     int_ctrl_reg = (uint32_t *)AddrTranslateP_getLocalAddr( (uint64_t)int_ctrl_reg);
700aebdc: 9801         	ldr	r0, [sp, #0x4]
700aebde: 2100         	movs	r1, #0x0
700aebe0: f7f7 f81e    	bl	0x700a5c20 <AddrTranslateP_getLocalAddr> @ imm = #-0x8fc4
700aebe4: 9001         	str	r0, [sp, #0x4]
;     return int_ctrl_reg;
700aebe6: 9801         	ldr	r0, [sp, #0x4]
700aebe8: b004         	add	sp, #0x10
700aebea: bd80         	pop	{r7, pc}
700aebec: 0000         	movs	r0, r0
700aebee: 0000         	movs	r0, r0

700aebf0 <TaskP_calcCounterDiff>:
; {
700aebf0: b083         	sub	sp, #0xc
700aebf2: 9002         	str	r0, [sp, #0x8]
700aebf4: 9101         	str	r1, [sp, #0x4]
;     if(cur >= last)
700aebf6: 9802         	ldr	r0, [sp, #0x8]
700aebf8: 9901         	ldr	r1, [sp, #0x4]
700aebfa: 4288         	cmp	r0, r1
700aebfc: d305         	blo	0x700aec0a <TaskP_calcCounterDiff+0x1a> @ imm = #0xa
700aebfe: e7ff         	b	0x700aec00 <TaskP_calcCounterDiff+0x10> @ imm = #-0x2
;         delta = cur - last;
700aec00: 9802         	ldr	r0, [sp, #0x8]
700aec02: 9901         	ldr	r1, [sp, #0x4]
700aec04: 1a40         	subs	r0, r0, r1
700aec06: 9000         	str	r0, [sp]
;     }
700aec08: e005         	b	0x700aec16 <TaskP_calcCounterDiff+0x26> @ imm = #0xa
;         delta = (  0xFFFFFFFFU - last ) + cur;
700aec0a: 9801         	ldr	r0, [sp, #0x4]
700aec0c: 9902         	ldr	r1, [sp, #0x8]
700aec0e: 43c0         	mvns	r0, r0
700aec10: 4408         	add	r0, r1
700aec12: 9000         	str	r0, [sp]
700aec14: e7ff         	b	0x700aec16 <TaskP_calcCounterDiff+0x26> @ imm = #-0x2
;     return delta;
700aec16: 9800         	ldr	r0, [sp]
700aec18: b003         	add	sp, #0xc
700aec1a: 4770         	bx	lr
700aec1c: 0000         	movs	r0, r0
700aec1e: 0000         	movs	r0, r0

700aec20 <TimerP_clearOverflowInt>:
; {
700aec20: b083         	sub	sp, #0xc
700aec22: 9002         	str	r0, [sp, #0x8]
700aec24: 2002         	movs	r0, #0x2
;     uint32_t value = (0x1U << TIMER_OVF_INT_SHIFT);
700aec26: 9000         	str	r0, [sp]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_STATUS);
700aec28: 9802         	ldr	r0, [sp, #0x8]
700aec2a: 3028         	adds	r0, #0x28
700aec2c: 9001         	str	r0, [sp, #0x4]
;     *addr = value;
700aec2e: 9800         	ldr	r0, [sp]
700aec30: 9901         	ldr	r1, [sp, #0x4]
700aec32: 6008         	str	r0, [r1]
;     if((*addr & value) != 0U)
700aec34: 9801         	ldr	r0, [sp, #0x4]
700aec36: 6800         	ldr	r0, [r0]
700aec38: 9900         	ldr	r1, [sp]
700aec3a: 4208         	tst	r0, r1
700aec3c: d004         	beq	0x700aec48 <TimerP_clearOverflowInt+0x28> @ imm = #0x8
700aec3e: e7ff         	b	0x700aec40 <TimerP_clearOverflowInt+0x20> @ imm = #-0x2
;         *addr = value;
700aec40: 9800         	ldr	r0, [sp]
700aec42: 9901         	ldr	r1, [sp, #0x4]
700aec44: 6008         	str	r0, [r1]
;     }
700aec46: e7ff         	b	0x700aec48 <TimerP_clearOverflowInt+0x28> @ imm = #-0x2
; }
700aec48: b003         	add	sp, #0xc
700aec4a: 4770         	bx	lr
700aec4c: 0000         	movs	r0, r0
700aec4e: 0000         	movs	r0, r0

700aec50 <prvInitialiseMutex>:
;     {
700aec50: b580         	push	{r7, lr}
700aec52: b082         	sub	sp, #0x8
700aec54: 9001         	str	r0, [sp, #0x4]
;         if( pxNewQueue != NULL )
700aec56: 9801         	ldr	r0, [sp, #0x4]
700aec58: b168         	cbz	r0, 0x700aec76 <prvInitialiseMutex+0x26> @ imm = #0x1a
700aec5a: e7ff         	b	0x700aec5c <prvInitialiseMutex+0xc> @ imm = #-0x2
;             pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
700aec5c: 9801         	ldr	r0, [sp, #0x4]
700aec5e: 2300         	movs	r3, #0x0
700aec60: 6083         	str	r3, [r0, #0x8]
;             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
700aec62: 9801         	ldr	r0, [sp, #0x4]
700aec64: 6003         	str	r3, [r0]
;             pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
700aec66: 9801         	ldr	r0, [sp, #0x4]
700aec68: 60c3         	str	r3, [r0, #0xc]
;             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
700aec6a: 9801         	ldr	r0, [sp, #0x4]
700aec6c: 4619         	mov	r1, r3
700aec6e: 461a         	mov	r2, r3
700aec70: f7f4 fb46    	bl	0x700a3300 <xQueueGenericSend> @ imm = #-0xb974
;         }
700aec74: e000         	b	0x700aec78 <prvInitialiseMutex+0x28> @ imm = #0x0
700aec76: e7ff         	b	0x700aec78 <prvInitialiseMutex+0x28> @ imm = #-0x2
;     }
700aec78: b002         	add	sp, #0x8
700aec7a: bd80         	pop	{r7, pc}
700aec7c: 0000         	movs	r0, r0
700aec7e: 0000         	movs	r0, r0

700aec80 <pvTaskIncrementMutexHeldCount>:
;   if (pxCurrentTCB != NULL) {
700aec80: f642 200c    	movw	r0, #0x2a0c
700aec84: f2c7 000b    	movt	r0, #0x700b
700aec88: 6800         	ldr	r0, [r0]
700aec8a: b148         	cbz	r0, 0x700aeca0 <pvTaskIncrementMutexHeldCount+0x20> @ imm = #0x12
700aec8c: e7ff         	b	0x700aec8e <pvTaskIncrementMutexHeldCount+0xe> @ imm = #-0x2
;     (pxCurrentTCB->uxMutexesHeld)++;
700aec8e: f642 200c    	movw	r0, #0x2a0c
700aec92: f2c7 000b    	movt	r0, #0x700b
700aec96: 6801         	ldr	r1, [r0]
700aec98: 6e48         	ldr	r0, [r1, #0x64]
700aec9a: 3001         	adds	r0, #0x1
700aec9c: 6648         	str	r0, [r1, #0x64]
;   }
700aec9e: e7ff         	b	0x700aeca0 <pvTaskIncrementMutexHeldCount+0x20> @ imm = #-0x2
;   return pxCurrentTCB;
700aeca0: f642 200c    	movw	r0, #0x2a0c
700aeca4: f2c7 000b    	movt	r0, #0x700b
700aeca8: 6800         	ldr	r0, [r0]
700aecaa: 4770         	bx	lr
700aecac: 0000         	movs	r0, r0
700aecae: 0000         	movs	r0, r0

700aecb0 <vApplicationGetIdleTaskMemory>:
;                                    uint32_t *pulIdleTaskStackSize) {
700aecb0: b083         	sub	sp, #0xc
700aecb2: 9002         	str	r0, [sp, #0x8]
700aecb4: 9101         	str	r1, [sp, #0x4]
700aecb6: 9200         	str	r2, [sp]
;   *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
700aecb8: 9902         	ldr	r1, [sp, #0x8]
700aecba: f644 60b0    	movw	r0, #0x4eb0
700aecbe: f2c7 0008    	movt	r0, #0x7008
700aecc2: 6008         	str	r0, [r1]
;   *ppxIdleTaskStackBuffer = uxIdleTaskStack;
700aecc4: 9901         	ldr	r1, [sp, #0x4]
700aecc6: f242 0080    	movw	r0, #0x2080
700aecca: f2c7 0008    	movt	r0, #0x7008
700aecce: 6008         	str	r0, [r1]
;   *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
700aecd0: 9900         	ldr	r1, [sp]
700aecd2: f44f 6080    	mov.w	r0, #0x400
700aecd6: 6008         	str	r0, [r1]
; }
700aecd8: b003         	add	sp, #0xc
700aecda: 4770         	bx	lr
700aecdc: 0000         	movs	r0, r0
700aecde: 0000         	movs	r0, r0

700aece0 <vApplicationGetTimerTaskMemory>:
;                                     uint32_t *pulTimerTaskStackSize) {
700aece0: b083         	sub	sp, #0xc
700aece2: 9002         	str	r0, [sp, #0x8]
700aece4: 9101         	str	r1, [sp, #0x4]
700aece6: 9200         	str	r2, [sp]
;   *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
700aece8: 9902         	ldr	r1, [sp, #0x8]
700aecea: f644 7038    	movw	r0, #0x4f38
700aecee: f2c7 0008    	movt	r0, #0x7008
700aecf2: 6008         	str	r0, [r1]
;   *ppxTimerTaskStackBuffer = uxTimerTaskStack;
700aecf4: 9901         	ldr	r1, [sp, #0x4]
700aecf6: f643 508c    	movw	r0, #0x3d8c
700aecfa: f2c7 0008    	movt	r0, #0x7008
700aecfe: 6008         	str	r0, [r1]
;   *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
700aed00: 9900         	ldr	r1, [sp]
700aed02: f44f 7080    	mov.w	r0, #0x100
700aed06: 6008         	str	r0, [r1]
; }
700aed08: b003         	add	sp, #0xc
700aed0a: 4770         	bx	lr
700aed0c: 0000         	movs	r0, r0
700aed0e: 0000         	movs	r0, r0

700aed10 <Sciclient_rmParamIsValid>:
; {
700aed10: b083         	sub	sp, #0xc
700aed12: 9002         	str	r0, [sp, #0x8]
700aed14: 9101         	str	r1, [sp, #0x4]
700aed16: 2000         	movs	r0, #0x0
;     bool r = false;
700aed18: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((valid_params & param_mask) != 0) {
700aed1c: 9802         	ldr	r0, [sp, #0x8]
700aed1e: 9901         	ldr	r1, [sp, #0x4]
700aed20: 4208         	tst	r0, r1
700aed22: d004         	beq	0x700aed2e <Sciclient_rmParamIsValid+0x1e> @ imm = #0x8
700aed24: e7ff         	b	0x700aed26 <Sciclient_rmParamIsValid+0x16> @ imm = #-0x2
700aed26: 2001         	movs	r0, #0x1
;         r = true;
700aed28: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aed2c: e7ff         	b	0x700aed2e <Sciclient_rmParamIsValid+0x1e> @ imm = #-0x2
;     return r;
700aed2e: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aed32: f000 0001    	and	r0, r0, #0x1
700aed36: b003         	add	sp, #0xc
700aed38: 4770         	bx	lr
700aed3a: 0000         	movs	r0, r0
700aed3c: 0000         	movs	r0, r0
700aed3e: 0000         	movs	r0, r0

700aed40 <Sciclient_rmPsIsEmpty>:
; {
700aed40: b081         	sub	sp, #0x4
700aed42: 2001         	movs	r0, #0x1
;     bool e = true;
700aed44: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if (gPstack.psp != 0) {
700aed48: f241 0058    	movw	r0, #0x1058
700aed4c: f2c7 0008    	movt	r0, #0x7008
700aed50: 8c80         	ldrh	r0, [r0, #0x24]
700aed52: b120         	cbz	r0, 0x700aed5e <Sciclient_rmPsIsEmpty+0x1e> @ imm = #0x8
700aed54: e7ff         	b	0x700aed56 <Sciclient_rmPsIsEmpty+0x16> @ imm = #-0x2
700aed56: 2000         	movs	r0, #0x0
;         e = false;
700aed58: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aed5c: e7ff         	b	0x700aed5e <Sciclient_rmPsIsEmpty+0x1e> @ imm = #-0x2
;     return e;
700aed5e: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aed62: f000 0001    	and	r0, r0, #0x1
700aed66: b001         	add	sp, #0x4
700aed68: 4770         	bx	lr
700aed6a: 0000         	movs	r0, r0
700aed6c: 0000         	movs	r0, r0
700aed6e: 0000         	movs	r0, r0

700aed70 <UART_Transaction_init>:
; {
700aed70: b081         	sub	sp, #0x4
700aed72: 9000         	str	r0, [sp]
;     if(trans != NULL)
700aed74: 9800         	ldr	r0, [sp]
700aed76: b170         	cbz	r0, 0x700aed96 <UART_Transaction_init+0x26> @ imm = #0x1c
700aed78: e7ff         	b	0x700aed7a <UART_Transaction_init+0xa> @ imm = #-0x2
;         trans->buf              = NULL;
700aed7a: 9900         	ldr	r1, [sp]
700aed7c: 2000         	movs	r0, #0x0
700aed7e: 6008         	str	r0, [r1]
;         trans->count            = 0U;
700aed80: 9900         	ldr	r1, [sp]
700aed82: 6048         	str	r0, [r1, #0x4]
;         trans->timeout          = SystemP_WAIT_FOREVER;
700aed84: 9a00         	ldr	r2, [sp]
700aed86: f04f 31ff    	mov.w	r1, #0xffffffff
700aed8a: 6091         	str	r1, [r2, #0x8]
;         trans->status           = UART_STATUS_SUCCESS;
700aed8c: 9900         	ldr	r1, [sp]
700aed8e: 60c8         	str	r0, [r1, #0xc]
;         trans->args             = NULL;
700aed90: 9900         	ldr	r1, [sp]
700aed92: 6108         	str	r0, [r1, #0x10]
;     }
700aed94: e7ff         	b	0x700aed96 <UART_Transaction_init+0x26> @ imm = #-0x2
; }
700aed96: b001         	add	sp, #0x4
700aed98: 4770         	bx	lr
700aed9a: 0000         	movs	r0, r0
700aed9c: 0000         	movs	r0, r0
700aed9e: 0000         	movs	r0, r0

700aeda0 <UART_intr2Disable>:
; {
700aeda0: b580         	push	{r7, lr}
700aeda2: b084         	sub	sp, #0x10
700aeda4: 9003         	str	r0, [sp, #0xc]
700aeda6: 9102         	str	r1, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_IER2, HW_RD_REG32(baseAddr + UART_IER2) &
700aeda8: 9803         	ldr	r0, [sp, #0xc]
700aedaa: 306c         	adds	r0, #0x6c
700aedac: 9001         	str	r0, [sp, #0x4]
700aedae: f000 fee7    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0xdce
700aedb2: 4601         	mov	r1, r0
700aedb4: 9801         	ldr	r0, [sp, #0x4]
700aedb6: 9b02         	ldr	r3, [sp, #0x8]
700aedb8: f06f 0203    	mvn	r2, #0x3
700aedbc: ea62 0203    	orn	r2, r2, r3
700aedc0: 4011         	ands	r1, r2
700aedc2: f000 fee5    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0xdca
; }
700aedc6: b004         	add	sp, #0x10
700aedc8: bd80         	pop	{r7, pc}
700aedca: 0000         	movs	r0, r0
700aedcc: 0000         	movs	r0, r0
700aedce: 0000         	movs	r0, r0

700aedd0 <UART_lld_Transaction_init>:
; {
700aedd0: b081         	sub	sp, #0x4
700aedd2: 9000         	str	r0, [sp]
;     if(trans != NULL)
700aedd4: 9800         	ldr	r0, [sp]
700aedd6: b170         	cbz	r0, 0x700aedf6 <UART_lld_Transaction_init+0x26> @ imm = #0x1c
700aedd8: e7ff         	b	0x700aedda <UART_lld_Transaction_init+0xa> @ imm = #-0x2
;         trans->buf              = NULL;
700aedda: 9900         	ldr	r1, [sp]
700aeddc: 2000         	movs	r0, #0x0
700aedde: 6008         	str	r0, [r1]
;         trans->count            = 0U;
700aede0: 9900         	ldr	r1, [sp]
700aede2: 6048         	str	r0, [r1, #0x4]
;         trans->timeout          = UART_WAIT_FOREVER;
700aede4: 9a00         	ldr	r2, [sp]
700aede6: f04f 31ff    	mov.w	r1, #0xffffffff
700aedea: 6091         	str	r1, [r2, #0x8]
;         trans->status           = UART_STATUS_SUCCESS;
700aedec: 9900         	ldr	r1, [sp]
700aedee: 60c8         	str	r0, [r1, #0xc]
;         trans->args             = NULL;
700aedf0: 9900         	ldr	r1, [sp]
700aedf2: 6108         	str	r0, [r1, #0x10]
;     }
700aedf4: e7ff         	b	0x700aedf6 <UART_lld_Transaction_init+0x26> @ imm = #-0x2
; }
700aedf6: b001         	add	sp, #0x4
700aedf8: 4770         	bx	lr
700aedfa: 0000         	movs	r0, r0
700aedfc: 0000         	movs	r0, r0
700aedfe: 0000         	movs	r0, r0

700aee00 <UART_lld_dmaWrite>:
; {
700aee00: b580         	push	{r7, lr}
700aee02: b084         	sub	sp, #0x10
700aee04: 9003         	str	r0, [sp, #0xc]
700aee06: 9102         	str	r1, [sp, #0x8]
700aee08: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700aee0a: 9001         	str	r0, [sp, #0x4]
;     status = UART_udmaConfigPdmaTx(hUart, transaction);
700aee0c: 9803         	ldr	r0, [sp, #0xc]
700aee0e: 9902         	ldr	r1, [sp, #0x8]
700aee10: f7f7 fb16    	bl	0x700a6440 <UART_udmaConfigPdmaTx> @ imm = #-0x89d4
700aee14: 9001         	str	r0, [sp, #0x4]
;     if (status != UDMA_SOK)
700aee16: 9801         	ldr	r0, [sp, #0x4]
700aee18: b120         	cbz	r0, 0x700aee24 <UART_lld_dmaWrite+0x24> @ imm = #0x8
700aee1a: e7ff         	b	0x700aee1c <UART_lld_dmaWrite+0x1c> @ imm = #-0x2
700aee1c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700aee20: 9001         	str	r0, [sp, #0x4]
;     }
700aee22: e7ff         	b	0x700aee24 <UART_lld_dmaWrite+0x24> @ imm = #-0x2
;     return status;
700aee24: 9801         	ldr	r0, [sp, #0x4]
700aee26: b004         	add	sp, #0x10
700aee28: bd80         	pop	{r7, pc}
700aee2a: 0000         	movs	r0, r0
700aee2c: 0000         	movs	r0, r0
700aee2e: 0000         	movs	r0, r0

700aee30 <UART_operatingModeSelect>:
; {
700aee30: b580         	push	{r7, lr}
700aee32: b084         	sub	sp, #0x10
700aee34: 9003         	str	r0, [sp, #0xc]
700aee36: 9102         	str	r1, [sp, #0x8]
;     operMode = HW_RD_REG32(baseAddr + UART_MDR1) & UART_MDR1_MODE_SELECT_MASK;
700aee38: 9803         	ldr	r0, [sp, #0xc]
700aee3a: 3020         	adds	r0, #0x20
700aee3c: f000 fea0    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0xd40
700aee40: f000 0007    	and	r0, r0, #0x7
700aee44: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_MDR1, UART_MDR1_MODE_SELECT,
700aee46: 9803         	ldr	r0, [sp, #0xc]
700aee48: 3020         	adds	r0, #0x20
700aee4a: 9b02         	ldr	r3, [sp, #0x8]
700aee4c: 2107         	movs	r1, #0x7
700aee4e: 2200         	movs	r2, #0x0
700aee50: f7ff fc36    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #-0x794
;     return operMode;
700aee54: 9801         	ldr	r0, [sp, #0x4]
700aee56: b004         	add	sp, #0x10
700aee58: bd80         	pop	{r7, pc}
700aee5a: 0000         	movs	r0, r0
700aee5c: 0000         	movs	r0, r0
700aee5e: 0000         	movs	r0, r0

700aee60 <Udma_eventProgramSteering>:
; {
700aee60: b084         	sub	sp, #0x10
700aee62: 9003         	str	r0, [sp, #0xc]
700aee64: 9102         	str	r1, [sp, #0x8]
;     eventPrms = &eventHandle->eventPrms;
700aee66: 9802         	ldr	r0, [sp, #0x8]
700aee68: 3008         	adds	r0, #0x8
700aee6a: 9000         	str	r0, [sp]
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
700aee6c: 9800         	ldr	r0, [sp]
700aee6e: 6800         	ldr	r0, [r0]
700aee70: 2803         	cmp	r0, #0x3
700aee72: d108         	bne	0x700aee86 <Udma_eventProgramSteering+0x26> @ imm = #0x10
700aee74: e7ff         	b	0x700aee76 <Udma_eventProgramSteering+0x16> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
700aee76: 9800         	ldr	r0, [sp]
700aee78: 6880         	ldr	r0, [r0, #0x8]
700aee7a: 9001         	str	r0, [sp, #0x4]
;         chHandle->chOesAllocDone = TRUE;
700aee7c: 9901         	ldr	r1, [sp, #0x4]
700aee7e: 2001         	movs	r0, #0x1
700aee80: f8c1 0248    	str.w	r0, [r1, #0x248]
;     }
700aee84: e7ff         	b	0x700aee86 <Udma_eventProgramSteering+0x26> @ imm = #-0x2
;     return;
700aee86: b004         	add	sp, #0x10
700aee88: 4770         	bx	lr
700aee8a: 0000         	movs	r0, r0
700aee8c: 0000         	movs	r0, r0
700aee8e: 0000         	movs	r0, r0

700aee90 <Udma_eventResetSteering>:
; {
700aee90: b084         	sub	sp, #0x10
700aee92: 9003         	str	r0, [sp, #0xc]
700aee94: 9102         	str	r1, [sp, #0x8]
;     eventPrms = &eventHandle->eventPrms;
700aee96: 9802         	ldr	r0, [sp, #0x8]
700aee98: 3008         	adds	r0, #0x8
700aee9a: 9000         	str	r0, [sp]
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
700aee9c: 9800         	ldr	r0, [sp]
700aee9e: 6800         	ldr	r0, [r0]
700aeea0: 2803         	cmp	r0, #0x3
700aeea2: d108         	bne	0x700aeeb6 <Udma_eventResetSteering+0x26> @ imm = #0x10
700aeea4: e7ff         	b	0x700aeea6 <Udma_eventResetSteering+0x16> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
700aeea6: 9800         	ldr	r0, [sp]
700aeea8: 6880         	ldr	r0, [r0, #0x8]
700aeeaa: 9001         	str	r0, [sp, #0x4]
;         chHandle->chOesAllocDone = FALSE;
700aeeac: 9901         	ldr	r1, [sp, #0x4]
700aeeae: 2000         	movs	r0, #0x0
700aeeb0: f8c1 0248    	str.w	r0, [r1, #0x248]
;     }
700aeeb4: e7ff         	b	0x700aeeb6 <Udma_eventResetSteering+0x26> @ imm = #-0x2
;     return;
700aeeb6: b004         	add	sp, #0x10
700aeeb8: 4770         	bx	lr
700aeeba: 0000         	movs	r0, r0
700aeebc: 0000         	movs	r0, r0
700aeebe: 0000         	movs	r0, r0

700aeec0 <Sciclient_secProxyVerifyThread>:
; {
700aeec0: b580         	push	{r7, lr}
700aeec2: b082         	sub	sp, #0x8
700aeec4: 9001         	str	r0, [sp, #0x4]
700aeec6: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700aeec8: 9000         	str	r0, [sp]
;     if ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700aeeca: 9801         	ldr	r0, [sp, #0x4]
700aeecc: f000 fc00    	bl	0x700af6d0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x800
700aeed0: f000 feb6    	bl	0x700afc40 <CSL_REG32_RD_RAW> @ imm = #0xd6c
700aeed4: 0fc0         	lsrs	r0, r0, #0x1f
700aeed6: b120         	cbz	r0, 0x700aeee2 <Sciclient_secProxyVerifyThread+0x22> @ imm = #0x8
700aeed8: e7ff         	b	0x700aeeda <Sciclient_secProxyVerifyThread+0x1a> @ imm = #-0x2
700aeeda: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700aeede: 9000         	str	r0, [sp]
;     }
700aeee0: e7ff         	b	0x700aeee2 <Sciclient_secProxyVerifyThread+0x22> @ imm = #-0x2
;     return status;
700aeee2: 9800         	ldr	r0, [sp]
700aeee4: b002         	add	sp, #0x8
700aeee6: bd80         	pop	{r7, pc}
		...

700aeef0 <prvIsQueueEmpty>:
; {
700aeef0: b580         	push	{r7, lr}
700aeef2: b082         	sub	sp, #0x8
700aeef4: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700aeef6: f7ff fc43    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #-0x77a
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
700aeefa: 9801         	ldr	r0, [sp, #0x4]
700aeefc: 6b80         	ldr	r0, [r0, #0x38]
700aeefe: b918         	cbnz	r0, 0x700aef08 <prvIsQueueEmpty+0x18> @ imm = #0x6
700aef00: e7ff         	b	0x700aef02 <prvIsQueueEmpty+0x12> @ imm = #-0x2
700aef02: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
700aef04: 9000         	str	r0, [sp]
;         }
700aef06: e002         	b	0x700aef0e <prvIsQueueEmpty+0x1e> @ imm = #0x4
700aef08: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
700aef0a: 9000         	str	r0, [sp]
700aef0c: e7ff         	b	0x700aef0e <prvIsQueueEmpty+0x1e> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700aef0e: f7fe fcf7    	bl	0x700ad900 <vTaskExitCritical> @ imm = #-0x1612
;     return xReturn;
700aef12: 9800         	ldr	r0, [sp]
700aef14: b002         	add	sp, #0x8
700aef16: bd80         	pop	{r7, pc}
		...

700aef20 <vQueueDelete>:
; {
700aef20: b580         	push	{r7, lr}
700aef22: b082         	sub	sp, #0x8
700aef24: 9001         	str	r0, [sp, #0x4]
;     Queue_t * const pxQueue = xQueue;
700aef26: 9801         	ldr	r0, [sp, #0x4]
700aef28: 9000         	str	r0, [sp]
;             vQueueUnregisterQueue( pxQueue );
700aef2a: 9800         	ldr	r0, [sp]
700aef2c: f7fe f840    	bl	0x700acfb0 <vQueueUnregisterQueue> @ imm = #-0x1f80
;             if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
700aef30: 9800         	ldr	r0, [sp]
700aef32: f890 0046    	ldrb.w	r0, [r0, #0x46]
700aef36: b920         	cbnz	r0, 0x700aef42 <vQueueDelete+0x22> @ imm = #0x8
700aef38: e7ff         	b	0x700aef3a <vQueueDelete+0x1a> @ imm = #-0x2
;                 vPortFree( pxQueue );
700aef3a: 9800         	ldr	r0, [sp]
700aef3c: f000 fa38    	bl	0x700af3b0 <vPortFree>  @ imm = #0x470
;             }
700aef40: e000         	b	0x700aef44 <vQueueDelete+0x24> @ imm = #0x0
700aef42: e7ff         	b	0x700aef44 <vQueueDelete+0x24> @ imm = #-0x2
; }
700aef44: b002         	add	sp, #0x8
700aef46: bd80         	pop	{r7, pc}
		...

700aef50 <vprintf_>:
; {
700aef50: b580         	push	{r7, lr}
700aef52: b084         	sub	sp, #0x10
700aef54: 9103         	str	r1, [sp, #0xc]
700aef56: 9002         	str	r0, [sp, #0x8]
;   return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
700aef58: 9b02         	ldr	r3, [sp, #0x8]
700aef5a: 9803         	ldr	r0, [sp, #0xc]
700aef5c: 4669         	mov	r1, sp
700aef5e: 6008         	str	r0, [r1]
700aef60: f24f 2011    	movw	r0, #0xf211
700aef64: f2c7 000a    	movt	r0, #0x700a
700aef68: f10d 0107    	add.w	r1, sp, #0x7
700aef6c: f04f 32ff    	mov.w	r2, #0xffffffff
700aef70: f7eb f8b6    	bl	0x7009a0e0 <_vsnprintf> @ imm = #-0x14e94
700aef74: b004         	add	sp, #0x10
700aef76: bd80         	pop	{r7, pc}
		...

700aef80 <UART_udmapSetReturnPolicy>:
; {
700aef80: b580         	push	{r7, lr}
700aef82: b086         	sub	sp, #0x18
700aef84: 9005         	str	r0, [sp, #0x14]
700aef86: 9104         	str	r1, [sp, #0x10]
700aef88: 2001         	movs	r0, #0x1
;         uint32_t descType = (uint32_t)CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST;
700aef8a: 9003         	str	r0, [sp, #0xc]
;         CSL_UdmapCppi5HMPD *pHpd = (CSL_UdmapCppi5HMPD *) pHpdMem;
700aef8c: 9804         	ldr	r0, [sp, #0x10]
700aef8e: 9002         	str	r0, [sp, #0x8]
;         pHpd,
700aef90: 9802         	ldr	r0, [sp, #0x8]
;         descType,
700aef92: 9903         	ldr	r1, [sp, #0xc]
;         CSL_udmapCppi5SetReturnPolicy(
700aef94: 466a         	mov	r2, sp
700aef96: 2300         	movs	r3, #0x0
700aef98: 6053         	str	r3, [r2, #0x4]
700aef9a: 6013         	str	r3, [r2]
700aef9c: 461a         	mov	r2, r3
700aef9e: f7fb fbd7    	bl	0x700aa750 <CSL_udmapCppi5SetReturnPolicy> @ imm = #-0x4852
;         return;
700aefa2: b006         	add	sp, #0x18
700aefa4: bd80         	pop	{r7, pc}
		...
700aefae: 0000         	movs	r0, r0

700aefb0 <Udma_ringGetForwardRingOcc>:
; {
700aefb0: b580         	push	{r7, lr}
700aefb2: b084         	sub	sp, #0x10
700aefb4: 9003         	str	r0, [sp, #0xc]
700aefb6: 2000         	movs	r0, #0x0
;     uint32_t            occ = 0U;
700aefb8: 9002         	str	r0, [sp, #0x8]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700aefba: 9803         	ldr	r0, [sp, #0xc]
700aefbc: 9001         	str	r0, [sp, #0x4]
;     Udma_DrvHandleInt   drvHandle = ringHandleInt->drvHandle;
700aefbe: 9801         	ldr	r0, [sp, #0x4]
700aefc0: 6800         	ldr	r0, [r0]
700aefc2: 9000         	str	r0, [sp]
;     occ = drvHandle->ringGetForwardRingOcc(ringHandleInt);
700aefc4: 9800         	ldr	r0, [sp]
700aefc6: f8d0 15a8    	ldr.w	r1, [r0, #0x5a8]
700aefca: 9801         	ldr	r0, [sp, #0x4]
700aefcc: 4788         	blx	r1
700aefce: 9002         	str	r0, [sp, #0x8]
;     return (occ);
700aefd0: 9802         	ldr	r0, [sp, #0x8]
700aefd2: b004         	add	sp, #0x10
700aefd4: bd80         	pop	{r7, pc}
		...
700aefde: 0000         	movs	r0, r0

700aefe0 <Udma_ringGetReverseRingOcc>:
; {
700aefe0: b580         	push	{r7, lr}
700aefe2: b084         	sub	sp, #0x10
700aefe4: 9003         	str	r0, [sp, #0xc]
700aefe6: 2000         	movs	r0, #0x0
;     uint32_t            occ = 0U;
700aefe8: 9002         	str	r0, [sp, #0x8]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700aefea: 9803         	ldr	r0, [sp, #0xc]
700aefec: 9001         	str	r0, [sp, #0x4]
;     Udma_DrvHandleInt   drvHandle = ringHandleInt->drvHandle;
700aefee: 9801         	ldr	r0, [sp, #0x4]
700aeff0: 6800         	ldr	r0, [r0]
700aeff2: 9000         	str	r0, [sp]
;     occ = drvHandle->ringGetReverseRingOcc(ringHandleInt);
700aeff4: 9800         	ldr	r0, [sp]
700aeff6: f8d0 15ac    	ldr.w	r1, [r0, #0x5ac]
700aeffa: 9801         	ldr	r0, [sp, #0x4]
700aeffc: 4788         	blx	r1
700aeffe: 9002         	str	r0, [sp, #0x8]
;     return (occ);
700af000: 9802         	ldr	r0, [sp, #0x8]
700af002: b004         	add	sp, #0x10
700af004: bd80         	pop	{r7, pc}
		...
700af00e: 0000         	movs	r0, r0

700af010 <_out_buffer>:
; {
700af010: b084         	sub	sp, #0x10
700af012: f88d 000f    	strb.w	r0, [sp, #0xf]
700af016: 9102         	str	r1, [sp, #0x8]
700af018: 9201         	str	r2, [sp, #0x4]
700af01a: 9300         	str	r3, [sp]
;   if (idx < maxlen) {
700af01c: 9801         	ldr	r0, [sp, #0x4]
700af01e: 9900         	ldr	r1, [sp]
700af020: 4288         	cmp	r0, r1
700af022: d206         	bhs	0x700af032 <_out_buffer+0x22> @ imm = #0xc
700af024: e7ff         	b	0x700af026 <_out_buffer+0x16> @ imm = #-0x2
;     ((char*)buffer)[idx] = character;
700af026: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700af02a: 9902         	ldr	r1, [sp, #0x8]
700af02c: 9a01         	ldr	r2, [sp, #0x4]
700af02e: 5488         	strb	r0, [r1, r2]
;   }
700af030: e7ff         	b	0x700af032 <_out_buffer+0x22> @ imm = #-0x2
; }
700af032: b004         	add	sp, #0x10
700af034: 4770         	bx	lr
		...
700af03e: 0000         	movs	r0, r0

700af040 <prvGetDisinheritPriorityAfterTimeout>:
;     {
700af040: b082         	sub	sp, #0x8
700af042: 9001         	str	r0, [sp, #0x4]
;         if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
700af044: 9801         	ldr	r0, [sp, #0x4]
700af046: 6a40         	ldr	r0, [r0, #0x24]
700af048: b138         	cbz	r0, 0x700af05a <prvGetDisinheritPriorityAfterTimeout+0x1a> @ imm = #0xe
700af04a: e7ff         	b	0x700af04c <prvGetDisinheritPriorityAfterTimeout+0xc> @ imm = #-0x2
;             uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
700af04c: 9801         	ldr	r0, [sp, #0x4]
700af04e: 6b00         	ldr	r0, [r0, #0x30]
700af050: 6800         	ldr	r0, [r0]
700af052: f1c0 0020    	rsb.w	r0, r0, #0x20
700af056: 9000         	str	r0, [sp]
;         }
700af058: e002         	b	0x700af060 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #0x4
700af05a: 2000         	movs	r0, #0x0
;             uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
700af05c: 9000         	str	r0, [sp]
700af05e: e7ff         	b	0x700af060 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #-0x2
;         return uxHighestPriorityOfWaitingTasks;
700af060: 9800         	ldr	r0, [sp]
700af062: b002         	add	sp, #0x8
700af064: 4770         	bx	lr
		...
700af06e: 0000         	movs	r0, r0

700af070 <vTaskPlaceOnEventList>:
;                            const TickType_t xTicksToWait) {
700af070: b580         	push	{r7, lr}
700af072: b082         	sub	sp, #0x8
700af074: 9001         	str	r0, [sp, #0x4]
700af076: 9100         	str	r1, [sp]
;   vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
700af078: 9801         	ldr	r0, [sp, #0x4]
700af07a: f642 210c    	movw	r1, #0x2a0c
700af07e: f2c7 010b    	movt	r1, #0x700b
700af082: 6809         	ldr	r1, [r1]
700af084: 3118         	adds	r1, #0x18
700af086: f7fc fbbb    	bl	0x700ab800 <vListInsert> @ imm = #-0x388a
;   prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
700af08a: 9800         	ldr	r0, [sp]
700af08c: 2101         	movs	r1, #0x1
700af08e: f7f7 fb97    	bl	0x700a67c0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x88d2
; }
700af092: b002         	add	sp, #0x8
700af094: bd80         	pop	{r7, pc}
		...
700af09e: 0000         	movs	r0, r0

700af0a0 <CSL_REG32_FEXT_RAW>:
; {
700af0a0: b580         	push	{r7, lr}
700af0a2: b084         	sub	sp, #0x10
700af0a4: 9003         	str	r0, [sp, #0xc]
700af0a6: 9102         	str	r1, [sp, #0x8]
700af0a8: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af0aa: 9803         	ldr	r0, [sp, #0xc]
700af0ac: f000 fdb0    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xb60
700af0b0: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af0b2: 9800         	ldr	r0, [sp]
700af0b4: 9902         	ldr	r1, [sp, #0x8]
700af0b6: 4008         	ands	r0, r1
700af0b8: 9901         	ldr	r1, [sp, #0x4]
700af0ba: 40c8         	lsrs	r0, r1
700af0bc: 9000         	str	r0, [sp]
;     return (regVal);
700af0be: 9800         	ldr	r0, [sp]
700af0c0: b004         	add	sp, #0x10
700af0c2: bd80         	pop	{r7, pc}
		...

700af0d0 <CSL_REG32_FEXT_RAW>:
; {
700af0d0: b580         	push	{r7, lr}
700af0d2: b084         	sub	sp, #0x10
700af0d4: 9003         	str	r0, [sp, #0xc]
700af0d6: 9102         	str	r1, [sp, #0x8]
700af0d8: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af0da: 9803         	ldr	r0, [sp, #0xc]
700af0dc: f000 fda0    	bl	0x700afc20 <CSL_REG32_RD_RAW> @ imm = #0xb40
700af0e0: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af0e2: 9800         	ldr	r0, [sp]
700af0e4: 9902         	ldr	r1, [sp, #0x8]
700af0e6: 4008         	ands	r0, r1
700af0e8: 9901         	ldr	r1, [sp, #0x4]
700af0ea: 40c8         	lsrs	r0, r1
700af0ec: 9000         	str	r0, [sp]
;     return (regVal);
700af0ee: 9800         	ldr	r0, [sp]
700af0f0: b004         	add	sp, #0x10
700af0f2: bd80         	pop	{r7, pc}
		...

700af100 <CSL_REG32_FEXT_RAW>:
; {
700af100: b580         	push	{r7, lr}
700af102: b084         	sub	sp, #0x10
700af104: 9003         	str	r0, [sp, #0xc]
700af106: 9102         	str	r1, [sp, #0x8]
700af108: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af10a: 9803         	ldr	r0, [sp, #0xc]
700af10c: f000 fd90    	bl	0x700afc30 <CSL_REG32_RD_RAW> @ imm = #0xb20
700af110: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af112: 9800         	ldr	r0, [sp]
700af114: 9902         	ldr	r1, [sp, #0x8]
700af116: 4008         	ands	r0, r1
700af118: 9901         	ldr	r1, [sp, #0x4]
700af11a: 40c8         	lsrs	r0, r1
700af11c: 9000         	str	r0, [sp]
;     return (regVal);
700af11e: 9800         	ldr	r0, [sp]
700af120: b004         	add	sp, #0x10
700af122: bd80         	pop	{r7, pc}
		...

700af130 <CSL_REG32_FEXT_RAW>:
; {
700af130: b580         	push	{r7, lr}
700af132: b084         	sub	sp, #0x10
700af134: 9003         	str	r0, [sp, #0xc]
700af136: 9102         	str	r1, [sp, #0x8]
700af138: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af13a: 9803         	ldr	r0, [sp, #0xc]
700af13c: f000 fd80    	bl	0x700afc40 <CSL_REG32_RD_RAW> @ imm = #0xb00
700af140: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af142: 9800         	ldr	r0, [sp]
700af144: 9902         	ldr	r1, [sp, #0x8]
700af146: 4008         	ands	r0, r1
700af148: 9901         	ldr	r1, [sp, #0x4]
700af14a: 40c8         	lsrs	r0, r1
700af14c: 9000         	str	r0, [sp]
;     return (regVal);
700af14e: 9800         	ldr	r0, [sp]
700af150: b004         	add	sp, #0x10
700af152: bd80         	pop	{r7, pc}
		...

700af160 <CSL_REG32_FEXT_RAW>:
; {
700af160: b580         	push	{r7, lr}
700af162: b084         	sub	sp, #0x10
700af164: 9003         	str	r0, [sp, #0xc]
700af166: 9102         	str	r1, [sp, #0x8]
700af168: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af16a: 9803         	ldr	r0, [sp, #0xc]
700af16c: f000 fd70    	bl	0x700afc50 <CSL_REG32_RD_RAW> @ imm = #0xae0
700af170: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af172: 9800         	ldr	r0, [sp]
700af174: 9902         	ldr	r1, [sp, #0x8]
700af176: 4008         	ands	r0, r1
700af178: 9901         	ldr	r1, [sp, #0x4]
700af17a: 40c8         	lsrs	r0, r1
700af17c: 9000         	str	r0, [sp]
;     return (regVal);
700af17e: 9800         	ldr	r0, [sp]
700af180: b004         	add	sp, #0x10
700af182: bd80         	pop	{r7, pc}
		...

700af190 <SOC_getSelfCpuClk>:
; {
700af190: b580         	push	{r7, lr}
700af192: b084         	sub	sp, #0x10
700af194: 2000         	movs	r0, #0x0
;     uint64_t cpuClockRate = 0U;
700af196: 9001         	str	r0, [sp, #0x4]
700af198: 9003         	str	r0, [sp, #0xc]
700af19a: 9002         	str	r0, [sp, #0x8]
;                     Sciclient_getSelfDevIdCore(),
700af19c: f000 fd70    	bl	0x700afc80 <Sciclient_getSelfDevIdCore> @ imm = #0xae0
700af1a0: 9901         	ldr	r1, [sp, #0x4]
700af1a2: aa02         	add	r2, sp, #0x8
700af1a4: f04f 33ff    	mov.w	r3, #0xffffffff
;     Sciclient_pmGetModuleClkFreq(
700af1a8: f7f9 feda    	bl	0x700a8f60 <Sciclient_pmGetModuleClkFreq> @ imm = #-0x624c
;     return cpuClockRate;
700af1ac: 9802         	ldr	r0, [sp, #0x8]
700af1ae: 9903         	ldr	r1, [sp, #0xc]
700af1b0: b004         	add	sp, #0x10
700af1b2: bd80         	pop	{r7, pc}
		...

700af1c0 <UART_IsStopBitsValid>:
; {
700af1c0: b082         	sub	sp, #0x8
700af1c2: 9001         	str	r0, [sp, #0x4]
700af1c4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700af1c8: 9000         	str	r0, [sp]
;     if((stopBits == UART_STOPBITS_1) ||
700af1ca: 9801         	ldr	r0, [sp, #0x4]
700af1cc: b120         	cbz	r0, 0x700af1d8 <UART_IsStopBitsValid+0x18> @ imm = #0x8
700af1ce: e7ff         	b	0x700af1d0 <UART_IsStopBitsValid+0x10> @ imm = #-0x2
;         (stopBits == UART_STOPBITS_2))
700af1d0: 9801         	ldr	r0, [sp, #0x4]
;     if((stopBits == UART_STOPBITS_1) ||
700af1d2: 2801         	cmp	r0, #0x1
700af1d4: d103         	bne	0x700af1de <UART_IsStopBitsValid+0x1e> @ imm = #0x6
700af1d6: e7ff         	b	0x700af1d8 <UART_IsStopBitsValid+0x18> @ imm = #-0x2
700af1d8: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700af1da: 9000         	str	r0, [sp]
;     }
700af1dc: e7ff         	b	0x700af1de <UART_IsStopBitsValid+0x1e> @ imm = #-0x2
;     return status;
700af1de: 9800         	ldr	r0, [sp]
700af1e0: b002         	add	sp, #0x8
700af1e2: 4770         	bx	lr

700af1e4 <__aeabi_uldivmod>:
700af1e4: e92d4040     	push	{r6, lr}
700af1e8: e24dd010     	sub	sp, sp, #16
700af1ec: e28d6008     	add	r6, sp, #8
700af1f0: e58d6000     	str	r6, [sp]
700af1f4: ebffd5cf     	bl	0x700a4938 <__udivmoddi4> @ imm = #-0xa8c4
700af1f8: e59d2008     	ldr	r2, [sp, #0x8]
700af1fc: e59d300c     	ldr	r3, [sp, #0xc]
700af200: e28dd010     	add	sp, sp, #16
700af204: e8bd8040     	pop	{r6, pc}
		...

700af210 <_out_char>:
; {
700af210: b580         	push	{r7, lr}
700af212: b084         	sub	sp, #0x10
700af214: f88d 000f    	strb.w	r0, [sp, #0xf]
700af218: 9102         	str	r1, [sp, #0x8]
700af21a: 9201         	str	r2, [sp, #0x4]
700af21c: 9300         	str	r3, [sp]
;   if (character) {
700af21e: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700af222: b128         	cbz	r0, 0x700af230 <_out_char+0x20> @ imm = #0xa
700af224: e7ff         	b	0x700af226 <_out_char+0x16> @ imm = #-0x2
;     putchar_(character);
700af226: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700af22a: f000 fc19    	bl	0x700afa60 <putchar_>   @ imm = #0x832
;   }
700af22e: e7ff         	b	0x700af230 <_out_char+0x20> @ imm = #-0x2
; }
700af230: b004         	add	sp, #0x10
700af232: bd80         	pop	{r7, pc}
		...

700af240 <tm_queue_create>:
; {
700af240: b510         	push	{r4, lr}
700af242: 4604         	mov	r4, r0
;    tm_queue_array[queue_id] = xQueueCreate(10, MESSAGE_SIZE * sizeof(int32_t));
700af244: 200a         	movs	r0, #0xa
700af246: 2180         	movs	r1, #0x80
700af248: 2200         	movs	r2, #0x0
700af24a: f7fd fc79    	bl	0x700acb40 <xQueueGenericCreate> @ imm = #-0x270e
700af24e: 4601         	mov	r1, r0
;    if (tm_queue_array[queue_id] == NULL)
700af250: fab0 f080    	clz	r0, r0
;    tm_queue_array[queue_id] = xQueueCreate(10, MESSAGE_SIZE * sizeof(int32_t));
700af254: f245 22b4    	movw	r2, #0x52b4
700af258: f2c7 0208    	movt	r2, #0x7008
;    if (tm_queue_array[queue_id] == NULL)
700af25c: 0940         	lsrs	r0, r0, #0x5
;    tm_queue_array[queue_id] = xQueueCreate(10, MESSAGE_SIZE * sizeof(int32_t));
700af25e: f842 1024    	str.w	r1, [r2, r4, lsl #2]
; }
700af262: bd10         	pop	{r4, pc}
		...

700af270 <vTaskInternalSetTimeOutState>:
; void vTaskInternalSetTimeOutState(TimeOut_t *const pxTimeOut) {
700af270: b081         	sub	sp, #0x4
700af272: 9000         	str	r0, [sp]
;   pxTimeOut->xOverflowCount = xNumOfOverflows;
700af274: f642 2048    	movw	r0, #0x2a48
700af278: f2c7 000b    	movt	r0, #0x700b
700af27c: 6800         	ldr	r0, [r0]
700af27e: 9900         	ldr	r1, [sp]
700af280: 6008         	str	r0, [r1]
;   pxTimeOut->xTimeOnEntering = xTickCount;
700af282: f642 2054    	movw	r0, #0x2a54
700af286: f2c7 000b    	movt	r0, #0x700b
700af28a: 6800         	ldr	r0, [r0]
700af28c: 9900         	ldr	r1, [sp]
700af28e: 6048         	str	r0, [r1, #0x4]
; }
700af290: b001         	add	sp, #0x4
700af292: 4770         	bx	lr
		...

700af2a0 <Pinmux_init>:
; {
700af2a0: b580         	push	{r7, lr}
;     Pinmux_config(gPinMuxMainDomainCfg, PINMUX_DOMAIN_ID_MAIN);
700af2a2: f642 1028    	movw	r0, #0x2928
700af2a6: 2100         	movs	r1, #0x0
700af2a8: f2c7 000b    	movt	r0, #0x700b
700af2ac: f7f9 fd68    	bl	0x700a8d80 <Pinmux_config> @ imm = #-0x6530
;     Pinmux_config(gPinMuxMcuDomainCfg, PINMUX_DOMAIN_ID_MCU);
700af2b0: f642 109c    	movw	r0, #0x299c
700af2b4: 2101         	movs	r1, #0x1
700af2b6: f2c7 000b    	movt	r0, #0x700b
700af2ba: e8bd 4080    	pop.w	{r7, lr}
700af2be: f7f9 bd5f    	b.w	0x700a8d80 <Pinmux_config> @ imm = #-0x6542
		...
700af2ce: 0000         	movs	r0, r0

700af2d0 <Udma_rmTranslateCoreIntrInput>:
; {
700af2d0: b083         	sub	sp, #0xc
700af2d2: 9002         	str	r0, [sp, #0x8]
700af2d4: 9101         	str	r1, [sp, #0x4]
700af2d6: 2000         	movs	r0, #0x0
700af2d8: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t    irIntrNum = UDMA_INTR_INVALID;
700af2dc: 9000         	str	r0, [sp]
;     if(drvHandle->instType != UDMA_INST_TYPE_NORMAL)
700af2de: 9802         	ldr	r0, [sp, #0x8]
700af2e0: 6800         	ldr	r0, [r0]
700af2e2: b118         	cbz	r0, 0x700af2ec <Udma_rmTranslateCoreIntrInput+0x1c> @ imm = #0x6
700af2e4: e7ff         	b	0x700af2e6 <Udma_rmTranslateCoreIntrInput+0x16> @ imm = #-0x2
;         irIntrNum = coreIntrNum;
700af2e6: 9801         	ldr	r0, [sp, #0x4]
700af2e8: 9000         	str	r0, [sp]
;     }
700af2ea: e7ff         	b	0x700af2ec <Udma_rmTranslateCoreIntrInput+0x1c> @ imm = #-0x2
;     return (irIntrNum);
700af2ec: 9800         	ldr	r0, [sp]
700af2ee: b003         	add	sp, #0xc
700af2f0: 4770         	bx	lr
		...
700af2fe: 0000         	movs	r0, r0

700af300 <Udma_rmTranslateIrOutput>:
; {
700af300: b083         	sub	sp, #0xc
700af302: 9002         	str	r0, [sp, #0x8]
700af304: 9101         	str	r1, [sp, #0x4]
700af306: 2000         	movs	r0, #0x0
700af308: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t    coreIntrNum = UDMA_INTR_INVALID;
700af30c: 9000         	str	r0, [sp]
;     if(drvHandle->instType != UDMA_INST_TYPE_NORMAL)
700af30e: 9802         	ldr	r0, [sp, #0x8]
700af310: 6800         	ldr	r0, [r0]
700af312: b118         	cbz	r0, 0x700af31c <Udma_rmTranslateIrOutput+0x1c> @ imm = #0x6
700af314: e7ff         	b	0x700af316 <Udma_rmTranslateIrOutput+0x16> @ imm = #-0x2
;         coreIntrNum = irIntrNum;
700af316: 9801         	ldr	r0, [sp, #0x4]
700af318: 9000         	str	r0, [sp]
;     }
700af31a: e7ff         	b	0x700af31c <Udma_rmTranslateIrOutput+0x1c> @ imm = #-0x2
;     return (coreIntrNum);
700af31c: 9800         	ldr	r0, [sp]
700af31e: b003         	add	sp, #0xc
700af320: 4770         	bx	lr
		...
700af32e: 0000         	movs	r0, r0

700af330 <ClockP_usecToTicks>:
; {
700af330: b580         	push	{r7, lr}
700af332: b082         	sub	sp, #0x8
700af334: 9101         	str	r1, [sp, #0x4]
700af336: 9000         	str	r0, [sp]
;     return (uint32_t)(usecs / gClockCtrl.usecPerTick);
700af338: 9800         	ldr	r0, [sp]
700af33a: 9901         	ldr	r1, [sp, #0x4]
700af33c: f245 1290    	movw	r2, #0x5190
700af340: f2c7 0208    	movt	r2, #0x7008
700af344: 6892         	ldr	r2, [r2, #0x8]
700af346: 2300         	movs	r3, #0x0
700af348: f7ff ef4c    	blx	0x700af1e4 <__aeabi_uldivmod> @ imm = #-0x168
700af34c: b002         	add	sp, #0x8
700af34e: bd80         	pop	{r7, pc}

700af350 <HW_RD_FIELD32_RAW>:
; {
700af350: b084         	sub	sp, #0x10
700af352: 9003         	str	r0, [sp, #0xc]
700af354: 9102         	str	r1, [sp, #0x8]
700af356: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700af358: 9803         	ldr	r0, [sp, #0xc]
700af35a: 6800         	ldr	r0, [r0]
700af35c: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af35e: 9800         	ldr	r0, [sp]
700af360: 9902         	ldr	r1, [sp, #0x8]
700af362: 4008         	ands	r0, r1
700af364: 9901         	ldr	r1, [sp, #0x4]
700af366: 40c8         	lsrs	r0, r1
700af368: 9000         	str	r0, [sp]
;     return (regVal);
700af36a: 9800         	ldr	r0, [sp]
700af36c: b004         	add	sp, #0x10
700af36e: 4770         	bx	lr

700af370 <Sciclient_getRxThreadId>:
; {
700af370: b082         	sub	sp, #0x8
700af372: 9001         	str	r0, [sp, #0x4]
;     rxThread = gSciclientMap[contextId].respThreadId;
700af374: 9801         	ldr	r0, [sp, #0x4]
700af376: eb00 0140    	add.w	r1, r0, r0, lsl #1
700af37a: f241 3060    	movw	r0, #0x1360
700af37e: f2c7 000b    	movt	r0, #0x700b
700af382: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700af386: 68c0         	ldr	r0, [r0, #0xc]
700af388: 9000         	str	r0, [sp]
;     return rxThread;
700af38a: 9800         	ldr	r0, [sp]
700af38c: b002         	add	sp, #0x8
700af38e: 4770         	bx	lr

700af390 <Sciclient_getTxThreadId>:
; {
700af390: b082         	sub	sp, #0x8
700af392: 9001         	str	r0, [sp, #0x4]
;     txThread = gSciclientMap[contextId].reqLowPrioThreadId;
700af394: 9801         	ldr	r0, [sp, #0x4]
700af396: eb00 0140    	add.w	r1, r0, r0, lsl #1
700af39a: f241 3060    	movw	r0, #0x1360
700af39e: f2c7 000b    	movt	r0, #0x700b
700af3a2: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700af3a6: 6880         	ldr	r0, [r0, #0x8]
700af3a8: 9000         	str	r0, [sp]
;     return txThread;
700af3aa: 9800         	ldr	r0, [sp]
700af3ac: b002         	add	sp, #0x8
700af3ae: 4770         	bx	lr

700af3b0 <vPortFree>:
; {
700af3b0: b580         	push	{r7, lr}
700af3b2: b082         	sub	sp, #0x8
700af3b4: 9001         	str	r0, [sp, #0x4]
;     if( pv )
700af3b6: 9801         	ldr	r0, [sp, #0x4]
700af3b8: b140         	cbz	r0, 0x700af3cc <vPortFree+0x1c> @ imm = #0x10
700af3ba: e7ff         	b	0x700af3bc <vPortFree+0xc> @ imm = #-0x2
;         vTaskSuspendAll();
700af3bc: f000 fc08    	bl	0x700afbd0 <vTaskSuspendAll> @ imm = #0x810
;             free( pv );
700af3c0: 9801         	ldr	r0, [sp, #0x4]
700af3c2: f7f0 eec0    	blx	0x700a0144 <free>       @ imm = #-0xf280
;         ( void ) xTaskResumeAll();
700af3c6: f7f2 ff6b    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0xd12a
;     }
700af3ca: e7ff         	b	0x700af3cc <vPortFree+0x1c> @ imm = #-0x2
; }
700af3cc: b002         	add	sp, #0x8
700af3ce: bd80         	pop	{r7, pc}

700af3d0 <wcslen>:
700af3d0: e3a01000     	mov	r1, #0
700af3d4: e7902001     	ldr	r2, [r0, r1]
700af3d8: e2811004     	add	r1, r1, #4
700af3dc: e3520000     	cmp	r2, #0
700af3e0: 1afffffb     	bne	0x700af3d4 <wcslen+0x4> @ imm = #-0x14
700af3e4: e2410004     	sub	r0, r1, #4
700af3e8: e1a00140     	asr	r0, r0, #2
700af3ec: e12fff1e     	bx	lr

700af3f0 <CSL_udmapCppi5SetEpiDataPresent>:
; {
700af3f0: b082         	sub	sp, #0x8
700af3f2: 9001         	str	r0, [sp, #0x4]
700af3f4: f88d 1003    	strb.w	r1, [sp, #0x3]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_EINFO, (bEpiDataPresent==(bool)true) ? (uint32_t)1U : (uint32_t)0U );
700af3f8: 9901         	ldr	r1, [sp, #0x4]
700af3fa: 6808         	ldr	r0, [r1]
700af3fc: f020 5000    	bic	r0, r0, #0x20000000
700af400: f89d 2003    	ldrb.w	r2, [sp, #0x3]
700af404: f362 705d    	bfi	r0, r2, #29, #1
700af408: 6008         	str	r0, [r1]
; }
700af40a: b002         	add	sp, #0x8
700af40c: 4770         	bx	lr
700af40e: 0000         	movs	r0, r0

700af410 <DebugP_memLogWriterInit>:
; {
700af410: b580         	push	{r7, lr}
700af412: b082         	sub	sp, #0x8
700af414: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     gDebugP_memTraceLogWriterSelfCoreName = SOC_getCoreName(selfCoreId);
700af418: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700af41c: f7fe ff78    	bl	0x700ae310 <SOC_getCoreName> @ imm = #-0x1110
700af420: f642 11f0    	movw	r1, #0x29f0
700af424: f2c7 010b    	movt	r1, #0x700b
700af428: 6008         	str	r0, [r1]
; }
700af42a: b002         	add	sp, #0x8
700af42c: bd80         	pop	{r7, pc}
700af42e: 0000         	movs	r0, r0

700af430 <Sciclient_rmPsGetIrqNode>:
; {
700af430: b081         	sub	sp, #0x4
700af432: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return gPstack.ps[index].p_n;
700af436: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700af43a: eb00 0140    	add.w	r1, r0, r0, lsl #1
700af43e: f241 0058    	movw	r0, #0x1058
700af442: f2c7 0008    	movt	r0, #0x7008
700af446: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700af44a: b001         	add	sp, #0x4
700af44c: 4770         	bx	lr
700af44e: 0000         	movs	r0, r0

700af450 <Sciclient_rmPsInit>:
; {
700af450: b580         	push	{r7, lr}
700af452: b082         	sub	sp, #0x8
;     memset(&gPstack.ps[0], 0, sizeof(gPstack.ps));
700af454: f241 0058    	movw	r0, #0x1058
700af458: f2c7 0008    	movt	r0, #0x7008
700af45c: 9001         	str	r0, [sp, #0x4]
700af45e: 2124         	movs	r1, #0x24
700af460: f7eb ee58    	blx	0x7009b114 <__aeabi_memclr8> @ imm = #-0x14350
700af464: 9901         	ldr	r1, [sp, #0x4]
700af466: 2000         	movs	r0, #0x0
;     gPstack.psp = 0;
700af468: 8488         	strh	r0, [r1, #0x24]
; }
700af46a: b002         	add	sp, #0x8
700af46c: bd80         	pop	{r7, pc}
700af46e: 0000         	movs	r0, r0

700af470 <UART_breakCtl>:
; {
700af470: b580         	push	{r7, lr}
700af472: b082         	sub	sp, #0x8
700af474: 9001         	str	r0, [sp, #0x4]
700af476: 9100         	str	r1, [sp]
;     HW_WR_FIELD32(baseAddr + UART_LCR, UART_LCR_BREAK_EN,
700af478: 9801         	ldr	r0, [sp, #0x4]
700af47a: 300c         	adds	r0, #0xc
700af47c: 9900         	ldr	r1, [sp]
700af47e: ea4f 1391    	lsr.w	r3, r1, #0x6
700af482: 2140         	movs	r1, #0x40
700af484: 2206         	movs	r2, #0x6
700af486: f7ff f91b    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #-0xdca
; }
700af48a: b002         	add	sp, #0x8
700af48c: bd80         	pop	{r7, pc}
700af48e: 0000         	movs	r0, r0

700af490 <UART_lld_Transaction_deInit>:
; {
700af490: b081         	sub	sp, #0x4
700af492: 9000         	str	r0, [sp]
;     trans->buf              = NULL;
700af494: 9900         	ldr	r1, [sp]
700af496: 2000         	movs	r0, #0x0
700af498: 6008         	str	r0, [r1]
;     trans->count            = 0U;
700af49a: 9900         	ldr	r1, [sp]
700af49c: 6048         	str	r0, [r1, #0x4]
;     trans->timeout          = 0U;
700af49e: 9900         	ldr	r1, [sp]
700af4a0: 6088         	str	r0, [r1, #0x8]
;     trans->status           = UART_STATUS_SUCCESS;
700af4a2: 9900         	ldr	r1, [sp]
700af4a4: 60c8         	str	r0, [r1, #0xc]
;     trans->args             = NULL;
700af4a6: 9900         	ldr	r1, [sp]
700af4a8: 6108         	str	r0, [r1, #0x10]
; }
700af4aa: b001         	add	sp, #0x4
700af4ac: 4770         	bx	lr
700af4ae: 0000         	movs	r0, r0

700af4b0 <UART_writeInterrupt>:
; {
700af4b0: b580         	push	{r7, lr}
700af4b2: b084         	sub	sp, #0x10
700af4b4: 9003         	str	r0, [sp, #0xc]
700af4b6: 2000         	movs	r0, #0x0
;     int32_t     status = UART_STATUS_SUCCESS;
700af4b8: 9002         	str	r0, [sp, #0x8]
;     baseAddr = hUart->baseAddr;
700af4ba: 9803         	ldr	r0, [sp, #0xc]
700af4bc: 6800         	ldr	r0, [r0]
700af4be: 9001         	str	r0, [sp, #0x4]
;     UART_intrEnable(baseAddr, UART_INTR_THR);
700af4c0: 9801         	ldr	r0, [sp, #0x4]
700af4c2: 2102         	movs	r1, #0x2
700af4c4: f7f6 fe6c    	bl	0x700a61a0 <UART_intrEnable> @ imm = #-0x9328
;     return status;
700af4c8: 9802         	ldr	r0, [sp, #0x8]
700af4ca: b004         	add	sp, #0x10
700af4cc: bd80         	pop	{r7, pc}
700af4ce: 0000         	movs	r0, r0

700af4d0 <UdmaChPdmaPrms_init>:
; {
700af4d0: b081         	sub	sp, #0x4
700af4d2: 9000         	str	r0, [sp]
;     if(NULL_PTR != pdmaPrms)
700af4d4: 9800         	ldr	r0, [sp]
700af4d6: b140         	cbz	r0, 0x700af4ea <UdmaChPdmaPrms_init+0x1a> @ imm = #0x10
700af4d8: e7ff         	b	0x700af4da <UdmaChPdmaPrms_init+0xa> @ imm = #-0x2
;         pdmaPrms->elemSize  = UDMA_PDMA_ES_8BITS;
700af4da: 9900         	ldr	r1, [sp]
700af4dc: 2000         	movs	r0, #0x0
700af4de: 6008         	str	r0, [r1]
;         pdmaPrms->elemCnt   = 0U;
700af4e0: 9900         	ldr	r1, [sp]
700af4e2: 6048         	str	r0, [r1, #0x4]
;         pdmaPrms->fifoCnt   = 0U;
700af4e4: 9900         	ldr	r1, [sp]
700af4e6: 6088         	str	r0, [r1, #0x8]
;     }
700af4e8: e7ff         	b	0x700af4ea <UdmaChPdmaPrms_init+0x1a> @ imm = #-0x2
;     return;
700af4ea: b001         	add	sp, #0x4
700af4ec: 4770         	bx	lr
700af4ee: 0000         	movs	r0, r0

700af4f0 <prvTimerTask>:
;     {
700af4f0: b580         	push	{r7, lr}
700af4f2: b084         	sub	sp, #0x10
700af4f4: 9003         	str	r0, [sp, #0xc]
;         for( ; ; )
700af4f6: e7ff         	b	0x700af4f8 <prvTimerTask+0x8> @ imm = #-0x2
700af4f8: a801         	add	r0, sp, #0x4
;             xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
700af4fa: f7fe fc29    	bl	0x700add50 <prvGetNextExpireTime> @ imm = #-0x17ae
700af4fe: 9002         	str	r0, [sp, #0x8]
;             prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
700af500: 9802         	ldr	r0, [sp, #0x8]
700af502: 9901         	ldr	r1, [sp, #0x4]
700af504: f7fb f894    	bl	0x700aa630 <prvProcessTimerOrBlockTask> @ imm = #-0x4ed8
;             prvProcessReceivedCommands();
700af508: f7f3 fb4a    	bl	0x700a2ba0 <prvProcessReceivedCommands> @ imm = #-0xc96c
;         for( ; ; )
700af50c: e7f4         	b	0x700af4f8 <prvTimerTask+0x8> @ imm = #-0x18
700af50e: 0000         	movs	r0, r0

700af510 <tm_queue_receive>:
; {
700af510: b580         	push	{r7, lr}
;    status = xQueueReceive(tm_queue_array[queue_id], (void* const) message_ptr, portMAX_DELAY);
700af512: f245 22b4    	movw	r2, #0x52b4
700af516: f2c7 0208    	movt	r2, #0x7008
700af51a: f852 0020    	ldr.w	r0, [r2, r0, lsl #2]
700af51e: f04f 32ff    	mov.w	r2, #0xffffffff
700af522: f7f4 f8b5    	bl	0x700a3690 <xQueueReceive> @ imm = #-0xbe96
;    if (status != pdTRUE)
700af526: 3801         	subs	r0, #0x1
700af528: bf18         	it	ne
700af52a: 2001         	movne	r0, #0x1
; }
700af52c: bd80         	pop	{r7, pc}
700af52e: 0000         	movs	r0, r0

700af530 <xPortStartScheduler>:
; BaseType_t xPortStartScheduler(void) {
700af530: b580         	push	{r7, lr}
700af532: b082         	sub	sp, #0x8
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700af534: b672         	cpsid i
;   ulPortSchedularRunning = pdTRUE;
700af536: f642 2120    	movw	r1, #0x2a20
700af53a: f2c7 010b    	movt	r1, #0x700b
700af53e: 2001         	movs	r0, #0x1
700af540: 9001         	str	r0, [sp, #0x4]
700af542: 6008         	str	r0, [r1]
;   vPortRestoreTaskContext();
700af544: f001 e916    	blx	0x700b0774 <vPortRestoreTaskContext> @ imm = #0x122c
700af548: 9801         	ldr	r0, [sp, #0x4]
;   return pdTRUE;
700af54a: b002         	add	sp, #0x8
700af54c: bd80         	pop	{r7, pc}
700af54e: 0000         	movs	r0, r0

700af550 <xTaskGetTickCount>:
; TickType_t xTaskGetTickCount(void) {
700af550: b580         	push	{r7, lr}
700af552: b082         	sub	sp, #0x8
;   portTICK_TYPE_ENTER_CRITICAL();
700af554: f7ff f914    	bl	0x700ae780 <vTaskEnterCritical> @ imm = #-0xdd8
;     xTicks = xTickCount;
700af558: f642 2054    	movw	r0, #0x2a54
700af55c: f2c7 000b    	movt	r0, #0x700b
700af560: 6800         	ldr	r0, [r0]
700af562: 9001         	str	r0, [sp, #0x4]
;   portTICK_TYPE_EXIT_CRITICAL();
700af564: f7fe f9cc    	bl	0x700ad900 <vTaskExitCritical> @ imm = #-0x1c68
;   return xTicks;
700af568: 9801         	ldr	r0, [sp, #0x4]
700af56a: b002         	add	sp, #0x8
700af56c: bd80         	pop	{r7, pc}
700af56e: 0000         	movs	r0, r0

700af570 <CSL_secProxyGetDataAddr>:
; {
700af570: b084         	sub	sp, #0x10
700af572: 9003         	str	r0, [sp, #0xc]
700af574: 9102         	str	r1, [sp, #0x8]
700af576: 9201         	str	r2, [sp, #0x4]
;     dataAddr = (uintptr_t)pSecProxyCfg->proxyTargetAddr + ((uintptr_t)threadNum * CSL_SEC_PROXY_TARGET_CHAN_SIZE) + (uintptr_t)CSL_SEC_PROXY_RSVD_MSG_BYTES;
700af578: 9803         	ldr	r0, [sp, #0xc]
700af57a: 6900         	ldr	r0, [r0, #0x10]
700af57c: 9902         	ldr	r1, [sp, #0x8]
700af57e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700af582: 3004         	adds	r0, #0x4
700af584: 9000         	str	r0, [sp]
;     return dataAddr;
700af586: 9800         	ldr	r0, [sp]
700af588: b004         	add	sp, #0x10
700af58a: 4770         	bx	lr
700af58c: 0000         	movs	r0, r0
700af58e: 0000         	movs	r0, r0

700af590 <UART_IsParameter>:
; {
700af590: b082         	sub	sp, #0x8
700af592: 9001         	str	r0, [sp, #0x4]
700af594: 2000         	movs	r0, #0x0
;     int32_t status = UART_STATUS_SUCCESS;
700af596: 9000         	str	r0, [sp]
;     if(InuptParameter == 0U)
700af598: 9801         	ldr	r0, [sp, #0x4]
700af59a: b920         	cbnz	r0, 0x700af5a6 <UART_IsParameter+0x16> @ imm = #0x8
700af59c: e7ff         	b	0x700af59e <UART_IsParameter+0xe> @ imm = #-0x2
700af59e: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700af5a2: 9000         	str	r0, [sp]
;     }
700af5a4: e7ff         	b	0x700af5a6 <UART_IsParameter+0x16> @ imm = #-0x2
;     return status;
700af5a6: 9800         	ldr	r0, [sp]
700af5a8: b002         	add	sp, #0x8
700af5aa: 4770         	bx	lr
700af5ac: 0000         	movs	r0, r0
700af5ae: 0000         	movs	r0, r0

700af5b0 <pvPortMalloc>:
; {
700af5b0: b580         	push	{r7, lr}
700af5b2: b082         	sub	sp, #0x8
700af5b4: 9001         	str	r0, [sp, #0x4]
;     vTaskSuspendAll();
700af5b6: f000 fb0b    	bl	0x700afbd0 <vTaskSuspendAll> @ imm = #0x616
;         pvReturn = malloc( xWantedSize );
700af5ba: 9801         	ldr	r0, [sp, #0x4]
700af5bc: f7ed ee9a    	blx	0x7009d2f4 <malloc>     @ imm = #-0x122cc
700af5c0: 9000         	str	r0, [sp]
;     ( void ) xTaskResumeAll();
700af5c2: f7f2 fe6d    	bl	0x700a22a0 <xTaskResumeAll> @ imm = #-0xd326
;     return pvReturn;
700af5c6: 9800         	ldr	r0, [sp]
700af5c8: b002         	add	sp, #0x8
700af5ca: bd80         	pop	{r7, pc}

700af5cc <strlen>:
700af5cc: e3a01000     	mov	r1, #0
700af5d0: e7d02001     	ldrb	r2, [r0, r1]
700af5d4: e2811001     	add	r1, r1, #1
700af5d8: e3520000     	cmp	r2, #0
700af5dc: 1afffffb     	bne	0x700af5d0 <strlen+0x4> @ imm = #-0x14
700af5e0: e2410001     	sub	r0, r1, #1
700af5e4: e12fff1e     	bx	lr
		...

700af5f0 <vPortYeildFromISR>:
; void vPortYeildFromISR(uint32_t xSwitchRequired) {
700af5f0: b081         	sub	sp, #0x4
700af5f2: 9000         	str	r0, [sp]
;   if (xSwitchRequired != pdFALSE) {
700af5f4: 9800         	ldr	r0, [sp]
700af5f6: b138         	cbz	r0, 0x700af608 <vPortYeildFromISR+0x18> @ imm = #0xe
700af5f8: e7ff         	b	0x700af5fa <vPortYeildFromISR+0xa> @ imm = #-0x2
;     ulPortYieldRequired = pdTRUE;
700af5fa: f642 2128    	movw	r1, #0x2a28
700af5fe: f2c7 010b    	movt	r1, #0x700b
700af602: 2001         	movs	r0, #0x1
700af604: 6008         	str	r0, [r1]
;   }
700af606: e7ff         	b	0x700af608 <vPortYeildFromISR+0x18> @ imm = #-0x2
; }
700af608: b001         	add	sp, #0x4
700af60a: 4770         	bx	lr

700af60c <TI_memcpy_small>:
700af60c: e3a0c000     	mov	r12, #0

700af610 <_loop>:
700af610: e152000c     	cmp	r2, r12
700af614: 012fff1e     	bxeq	lr
700af618: e7d1300c     	ldrb	r3, [r1, r12]
700af61c: e7c0300c     	strb	r3, [r0, r12]
700af620: e28cc001     	add	r12, r12, #1
700af624: eafffff9     	b	0x700af610 <_loop>      @ imm = #-0x1c
		...

700af630 <CSL_udmapCppi5SetDescType>:
; {
700af630: b082         	sub	sp, #0x8
700af632: 9001         	str	r0, [sp, #0x4]
700af634: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_DTYPE, descType );
700af636: 9901         	ldr	r1, [sp, #0x4]
700af638: 6808         	ldr	r0, [r1]
700af63a: f020 4040    	bic	r0, r0, #0xc0000000
700af63e: 9a00         	ldr	r2, [sp]
700af640: ea40 7082    	orr.w	r0, r0, r2, lsl #30
700af644: 6008         	str	r0, [r1]
; }
700af646: b002         	add	sp, #0x8
700af648: 4770         	bx	lr
700af64a: 0000         	movs	r0, r0
700af64c: 0000         	movs	r0, r0
700af64e: 0000         	movs	r0, r0

700af650 <UART_fifoCharGet>:
; {
700af650: b580         	push	{r7, lr}
700af652: b082         	sub	sp, #0x8
700af654: 9001         	str	r0, [sp, #0x4]
700af656: 2000         	movs	r0, #0x0
;     uint32_t tempRetVal = 0U;
700af658: 9000         	str	r0, [sp]
;     tempRetVal = HW_RD_REG32(baseAddr + UART_RHR);
700af65a: 9801         	ldr	r0, [sp, #0x4]
700af65c: f000 fa90    	bl	0x700afb80 <HW_RD_REG32_RAW> @ imm = #0x520
700af660: 9000         	str	r0, [sp]
;     return ((uint8_t) tempRetVal);
700af662: f89d 0000    	ldrb.w	r0, [sp]
700af666: b002         	add	sp, #0x8
700af668: bd80         	pop	{r7, pc}
700af66a: 0000         	movs	r0, r0
700af66c: 0000         	movs	r0, r0
700af66e: 0000         	movs	r0, r0

700af670 <UART_timeGuardConfig>:
; {
700af670: b580         	push	{r7, lr}
700af672: b082         	sub	sp, #0x8
700af674: 9001         	str	r0, [sp, #0x4]
700af676: 9100         	str	r1, [sp]
;     HW_WR_FIELD32(baseAddr + UART_TIMEGUARD, UART_TIMEGUARD_TIMEGUARD,
700af678: 9801         	ldr	r0, [sp, #0x4]
700af67a: 3094         	adds	r0, #0x94
700af67c: 9b00         	ldr	r3, [sp]
700af67e: 21ff         	movs	r1, #0xff
700af680: 2200         	movs	r2, #0x0
700af682: f7ff f81d    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #-0xfc6
; }
700af686: b002         	add	sp, #0x8
700af688: bd80         	pop	{r7, pc}
700af68a: 0000         	movs	r0, r0
700af68c: 0000         	movs	r0, r0
700af68e: 0000         	movs	r0, r0

700af690 <CSL_udmapCppi5SetPsDataLen>:
; {
700af690: b082         	sub	sp, #0x8
700af692: 9001         	str	r0, [sp, #0x4]
700af694: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PSWCNT, (psDataLen/4U) );
700af696: 9901         	ldr	r1, [sp, #0x4]
700af698: 6808         	ldr	r0, [r1]
700af69a: 9a00         	ldr	r2, [sp]
700af69c: 0892         	lsrs	r2, r2, #0x2
700af69e: f362 509b    	bfi	r0, r2, #22, #6
700af6a2: 6008         	str	r0, [r1]
; }
700af6a4: b002         	add	sp, #0x8
700af6a6: 4770         	bx	lr
		...

700af6b0 <Sciclient_rmIrqSet>:
; {
700af6b0: b580         	push	{r7, lr}
700af6b2: b084         	sub	sp, #0x10
700af6b4: 9003         	str	r0, [sp, #0xc]
700af6b6: 9102         	str	r1, [sp, #0x8]
700af6b8: 9201         	str	r2, [sp, #0x4]
;     return Sciclient_rmProgramInterruptRoute(req, resp, timeout);
700af6ba: 9803         	ldr	r0, [sp, #0xc]
700af6bc: 9902         	ldr	r1, [sp, #0x8]
700af6be: 9a01         	ldr	r2, [sp, #0x4]
700af6c0: f7f1 fafe    	bl	0x700a0cc0 <Sciclient_rmProgramInterruptRoute> @ imm = #-0xea04
700af6c4: b004         	add	sp, #0x10
700af6c6: bd80         	pop	{r7, pc}
		...

700af6d0 <Sciclient_secProxyThreadStatusReg>:
; {
700af6d0: b081         	sub	sp, #0x4
700af6d2: 9000         	str	r0, [sp]
;     return ((uint32_t)(uintptr_t)(gSciclientSecProxyCfg.pSecProxyRtRegs) +
700af6d4: f642 00d0    	movw	r0, #0x28d0
700af6d8: f2c7 000b    	movt	r0, #0x700b
700af6dc: 6880         	ldr	r0, [r0, #0x8]
;         CSL_SEC_PROXY_RT_THREAD_STATUS(thread));
700af6de: 9900         	ldr	r1, [sp]
;     return ((uint32_t)(uintptr_t)(gSciclientSecProxyCfg.pSecProxyRtRegs) +
700af6e0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700af6e4: b001         	add	sp, #0x4
700af6e6: 4770         	bx	lr
		...

700af6f0 <TimerP_start>:
; {
700af6f0: b082         	sub	sp, #0x8
700af6f2: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (uint32_t *)(baseAddr + TIMER_TCLR);
700af6f4: 9801         	ldr	r0, [sp, #0x4]
700af6f6: 3038         	adds	r0, #0x38
700af6f8: 9000         	str	r0, [sp]
;     *addr |= (0x1U << 0);
700af6fa: 9900         	ldr	r1, [sp]
700af6fc: 6808         	ldr	r0, [r1]
700af6fe: f040 0001    	orr	r0, r0, #0x1
700af702: 6008         	str	r0, [r1]
; }
700af704: b002         	add	sp, #0x8
700af706: 4770         	bx	lr
		...

700af710 <TimerP_stop>:
; {
700af710: b082         	sub	sp, #0x8
700af712: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TCLR);
700af714: 9801         	ldr	r0, [sp, #0x4]
700af716: 3038         	adds	r0, #0x38
700af718: 9000         	str	r0, [sp]
;     *addr &= ~(0x1U << 0);
700af71a: 9900         	ldr	r1, [sp]
700af71c: 6808         	ldr	r0, [r1]
700af71e: f020 0001    	bic	r0, r0, #0x1
700af722: 6008         	str	r0, [r1]
; }
700af724: b002         	add	sp, #0x8
700af726: 4770         	bx	lr
		...

700af730 <UART_divisorLatchDisable>:
; {
700af730: b580         	push	{r7, lr}
700af732: b082         	sub	sp, #0x8
700af734: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_LCR, UART_LCR_DIV_EN,
700af736: 9801         	ldr	r0, [sp, #0x4]
700af738: 300c         	adds	r0, #0xc
700af73a: 2180         	movs	r1, #0x80
700af73c: 2207         	movs	r2, #0x7
700af73e: 2300         	movs	r3, #0x0
700af740: f7fe ffbe    	bl	0x700ae6c0 <HW_WR_FIELD32_RAW> @ imm = #-0x1084
; }
700af744: b002         	add	sp, #0x8
700af746: bd80         	pop	{r7, pc}
		...

700af750 <UART_modemControlReset>:
; {
700af750: b580         	push	{r7, lr}
700af752: b082         	sub	sp, #0x8
700af754: 9001         	str	r0, [sp, #0x4]
700af756: 2000         	movs	r0, #0x0
;     uint32_t mcrResetVal = 0U;
700af758: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_MCR, mcrResetVal);
700af75a: 9801         	ldr	r0, [sp, #0x4]
700af75c: 3010         	adds	r0, #0x10
700af75e: 9900         	ldr	r1, [sp]
700af760: f000 fa16    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x42c
; }
700af764: b002         	add	sp, #0x8
700af766: bd80         	pop	{r7, pc}
		...

700af770 <UART_putChar>:
; {
700af770: b580         	push	{r7, lr}
700af772: b082         	sub	sp, #0x8
700af774: 9001         	str	r0, [sp, #0x4]
700af776: f88d 1003    	strb.w	r1, [sp, #0x3]
;     HW_WR_REG32(baseAddr + UART_THR, (uint32_t) byteTx);
700af77a: 9801         	ldr	r0, [sp, #0x4]
700af77c: f89d 1003    	ldrb.w	r1, [sp, #0x3]
700af780: f000 fa06    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x40c
; }
700af784: b002         	add	sp, #0x8
700af786: bd80         	pop	{r7, pc}

700af788 <TI_memset_small>:
700af788: e3a03000     	mov	r3, #0

700af78c <_loop>:
700af78c: e1520003     	cmp	r2, r3
700af790: 012fff1e     	bxeq	lr
700af794: e7c01003     	strb	r1, [r0, r3]
700af798: e2833001     	add	r3, r3, #1
700af79c: eafffffa     	b	0x700af78c <_loop>      @ imm = #-0x18

700af7a0 <CSL_REG64_WR_RAW>:
; {
700af7a0: b084         	sub	sp, #0x10
700af7a2: 9003         	str	r0, [sp, #0xc]
700af7a4: 9301         	str	r3, [sp, #0x4]
700af7a6: 9200         	str	r2, [sp]
;     *p = v;
700af7a8: 9800         	ldr	r0, [sp]
700af7aa: 9901         	ldr	r1, [sp, #0x4]
700af7ac: 9a03         	ldr	r2, [sp, #0xc]
700af7ae: e9c2 0100    	strd	r0, r1, [r2]
;     return;
700af7b2: b004         	add	sp, #0x10
700af7b4: 4770         	bx	lr
		...
700af7be: 0000         	movs	r0, r0

700af7c0 <CSL_udmapCppi5LinkDesc>:
; {
700af7c0: b084         	sub	sp, #0x10
700af7c2: 9003         	str	r0, [sp, #0xc]
700af7c4: 9301         	str	r3, [sp, #0x4]
700af7c6: 9200         	str	r2, [sp]
;     pDesc->nextDescPtr = physBufferDescAddr;
700af7c8: 9800         	ldr	r0, [sp]
700af7ca: 9a01         	ldr	r2, [sp, #0x4]
700af7cc: 9903         	ldr	r1, [sp, #0xc]
700af7ce: 614a         	str	r2, [r1, #0x14]
700af7d0: 6108         	str	r0, [r1, #0x10]
; }
700af7d2: b004         	add	sp, #0x10
700af7d4: 4770         	bx	lr
		...
700af7de: 0000         	movs	r0, r0

700af7e0 <CSL_udmapCppi5SetBufferAddr>:
; {
700af7e0: b084         	sub	sp, #0x10
700af7e2: 9003         	str	r0, [sp, #0xc]
700af7e4: 9301         	str	r3, [sp, #0x4]
700af7e6: 9200         	str	r2, [sp]
;     pDesc->bufPtr    = physBufferAddr;
700af7e8: 9800         	ldr	r0, [sp]
700af7ea: 9a01         	ldr	r2, [sp, #0x4]
700af7ec: 9903         	ldr	r1, [sp, #0xc]
700af7ee: 61ca         	str	r2, [r1, #0x1c]
700af7f0: 6188         	str	r0, [r1, #0x18]
; }
700af7f2: b004         	add	sp, #0x10
700af7f4: 4770         	bx	lr
		...
700af7fe: 0000         	movs	r0, r0

700af800 <CSL_udmapCppi5SetBufferLen>:
; {
700af800: b082         	sub	sp, #0x8
700af802: 9001         	str	r0, [sp, #0x4]
700af804: 9100         	str	r1, [sp]
;     CSL_FINS( pDesc->bufInfo1, UDMAP_CPPI5_PD_BUFINFO1_LEN, bufferLenBytes );
700af806: 9901         	ldr	r1, [sp, #0x4]
700af808: 6a08         	ldr	r0, [r1, #0x20]
700af80a: 9a00         	ldr	r2, [sp]
700af80c: f362 0015    	bfi	r0, r2, #0, #22
700af810: 6208         	str	r0, [r1, #0x20]
; }
700af812: b002         	add	sp, #0x8
700af814: 4770         	bx	lr
		...
700af81e: 0000         	movs	r0, r0

700af820 <CSL_udmapCppi5SetOrgBufferAddr>:
; {
700af820: b084         	sub	sp, #0x10
700af822: 9003         	str	r0, [sp, #0xc]
700af824: 9301         	str	r3, [sp, #0x4]
700af826: 9200         	str	r2, [sp]
;     pDesc->orgBufPtr = physBufferAddr;
700af828: 9800         	ldr	r0, [sp]
700af82a: 9a01         	ldr	r2, [sp, #0x4]
700af82c: 9903         	ldr	r1, [sp, #0xc]
700af82e: 62ca         	str	r2, [r1, #0x2c]
700af830: 6288         	str	r0, [r1, #0x28]
; }
700af832: b004         	add	sp, #0x10
700af834: 4770         	bx	lr
		...
700af83e: 0000         	movs	r0, r0

700af840 <CSL_udmapCppi5SetPsDataLoc>:
; {
700af840: b082         	sub	sp, #0x8
700af842: 9001         	str	r0, [sp, #0x4]
700af844: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PSINFO, psLoc );
700af846: 9901         	ldr	r1, [sp, #0x4]
700af848: 6808         	ldr	r0, [r1]
700af84a: 9a00         	ldr	r2, [sp]
700af84c: f362 701c    	bfi	r0, r2, #28, #1
700af850: 6008         	str	r0, [r1]
; }
700af852: b002         	add	sp, #0x8
700af854: 4770         	bx	lr
		...
700af85e: 0000         	movs	r0, r0

700af860 <CSL_udmapCppi5SetPsFlags>:
; {
700af860: b082         	sub	sp, #0x8
700af862: 9001         	str	r0, [sp, #0x4]
700af864: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1, UDMAP_CPPI5_PD_PKTINFO1_PSFLGS, psFlags );
700af866: 9901         	ldr	r1, [sp, #0x4]
700af868: 6848         	ldr	r0, [r1, #0x4]
700af86a: 9a00         	ldr	r2, [sp]
700af86c: f362 601b    	bfi	r0, r2, #24, #4
700af870: 6048         	str	r0, [r1, #0x4]
; }
700af872: b002         	add	sp, #0x8
700af874: 4770         	bx	lr
		...
700af87e: 0000         	movs	r0, r0

700af880 <Sciclient_rmIrqRelease>:
; {
700af880: b580         	push	{r7, lr}
700af882: b084         	sub	sp, #0x10
700af884: 9003         	str	r0, [sp, #0xc]
700af886: 9102         	str	r1, [sp, #0x8]
;     return Sciclient_rmClearInterruptRoute(req, &resp, timeout);
700af888: 9803         	ldr	r0, [sp, #0xc]
700af88a: 9a02         	ldr	r2, [sp, #0x8]
700af88c: 4669         	mov	r1, sp
700af88e: f7f0 fee7    	bl	0x700a0660 <Sciclient_rmClearInterruptRoute> @ imm = #-0xf232
700af892: b004         	add	sp, #0x10
700af894: bd80         	pop	{r7, pc}
		...
700af89e: 0000         	movs	r0, r0

700af8a0 <Sciclient_secProxyReadThreadCount>:
; {
700af8a0: b580         	push	{r7, lr}
700af8a2: b082         	sub	sp, #0x8
700af8a4: 9001         	str	r0, [sp, #0x4]
;     return (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700af8a6: 9801         	ldr	r0, [sp, #0x4]
700af8a8: f7ff ff12    	bl	0x700af6d0 <Sciclient_secProxyThreadStatusReg> @ imm = #-0x1dc
700af8ac: f000 f9c8    	bl	0x700afc40 <CSL_REG32_RD_RAW> @ imm = #0x390
700af8b0: b2c0         	uxtb	r0, r0
700af8b2: b002         	add	sp, #0x8
700af8b4: bd80         	pop	{r7, pc}
		...
700af8be: 0000         	movs	r0, r0

700af8c0 <SemaphoreP_destruct>:
; {
700af8c0: b580         	push	{r7, lr}
700af8c2: b082         	sub	sp, #0x8
700af8c4: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700af8c6: 9801         	ldr	r0, [sp, #0x4]
700af8c8: 9000         	str	r0, [sp]
;     vSemaphoreDelete(pSemaphore->semHndl);
700af8ca: 9800         	ldr	r0, [sp]
700af8cc: 6d00         	ldr	r0, [r0, #0x50]
700af8ce: f7ff fb27    	bl	0x700aef20 <vQueueDelete> @ imm = #-0x9b2
; }
700af8d2: b002         	add	sp, #0x8
700af8d4: bd80         	pop	{r7, pc}
		...
700af8de: 0000         	movs	r0, r0

700af8e0 <UART_divideRoundCloset>:
; {
700af8e0: b082         	sub	sp, #0x8
700af8e2: 9001         	str	r0, [sp, #0x4]
700af8e4: 9100         	str	r1, [sp]
;     return ((divident + (divisor/2U))/divisor);
700af8e6: 9801         	ldr	r0, [sp, #0x4]
700af8e8: 9900         	ldr	r1, [sp]
700af8ea: eb00 0051    	add.w	r0, r0, r1, lsr #1
700af8ee: fbb0 f0f1    	udiv	r0, r0, r1
700af8f2: b002         	add	sp, #0x8
700af8f4: 4770         	bx	lr
		...
700af8fe: 0000         	movs	r0, r0

700af900 <UART_regConfModeRestore>:
; {
700af900: b580         	push	{r7, lr}
700af902: b082         	sub	sp, #0x8
700af904: 9001         	str	r0, [sp, #0x4]
700af906: 9100         	str	r1, [sp]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700af908: 9801         	ldr	r0, [sp, #0x4]
700af90a: 300c         	adds	r0, #0xc
700af90c: 9900         	ldr	r1, [sp]
700af90e: f000 f93f    	bl	0x700afb90 <HW_WR_REG32_RAW> @ imm = #0x27e
; }
700af912: b002         	add	sp, #0x8
700af914: bd80         	pop	{r7, pc}
		...
700af91e: 0000         	movs	r0, r0

700af920 <tm_thread_resume>:
; {
700af920: b580         	push	{r7, lr}
;    vTaskResume(tm_thread_array[thread_id]);
700af922: f245 11c8    	movw	r1, #0x51c8
700af926: f2c7 0108    	movt	r1, #0x7008
700af92a: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700af92e: f7f9 f82f    	bl	0x700a8990 <vTaskResume> @ imm = #-0x6fa2
;    return TM_SUCCESS;
700af932: 2000         	movs	r0, #0x0
700af934: bd80         	pop	{r7, pc}
		...
700af93e: 0000         	movs	r0, r0

700af940 <tm_thread_suspend>:
; {
700af940: b580         	push	{r7, lr}
;    vTaskSuspend(tm_thread_array[thread_id]);
700af942: f245 11c8    	movw	r1, #0x51c8
700af946: f2c7 0108    	movt	r1, #0x7008
700af94a: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700af94e: f7f5 fb47    	bl	0x700a4fe0 <vTaskSuspend> @ imm = #-0xa972
;    return TM_SUCCESS;
700af952: 2000         	movs	r0, #0x0
700af954: bd80         	pop	{r7, pc}
		...
700af95e: 0000         	movs	r0, r0

700af960 <DebugP_uartSetDrvIndex>:
; {
700af960: b081         	sub	sp, #0x4
700af962: 9000         	str	r0, [sp]
;     gDebugP_uartDrvIndex = uartDrvIndex;
700af964: 9800         	ldr	r0, [sp]
700af966: f642 11f4    	movw	r1, #0x29f4
700af96a: f2c7 010b    	movt	r1, #0x700b
700af96e: 6008         	str	r0, [r1]
; }
700af970: b001         	add	sp, #0x4
700af972: 4770         	bx	lr
		...

700af980 <Sciclient_rmIrIntControlReg>:
; {
700af980: b081         	sub	sp, #0x4
700af982: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return (outp * SCICLIENT_IR_INT_CONTROL_REG_STEP) +
700af986: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700af98a: 2004         	movs	r0, #0x4
700af98c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700af990: b001         	add	sp, #0x4
700af992: 4770         	bx	lr
		...

700af9a0 <Udma_rmAllocFreeRing>:
; {
700af9a0: b082         	sub	sp, #0x8
700af9a2: 9001         	str	r0, [sp, #0x4]
700af9a4: f64f 70ff    	movw	r0, #0xffff
;     uint16_t            ringNum = UDMA_RING_INVALID;
700af9a8: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return (ringNum);
700af9ac: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700af9b0: b002         	add	sp, #0x8
700af9b2: 4770         	bx	lr
		...

700af9c0 <xTaskGetCurrentTaskHandle>:
; TaskHandle_t xTaskGetCurrentTaskHandle(void) {
700af9c0: b081         	sub	sp, #0x4
;   xReturn = pxCurrentTCB;
700af9c2: f642 200c    	movw	r0, #0x2a0c
700af9c6: f2c7 000b    	movt	r0, #0x700b
700af9ca: 6800         	ldr	r0, [r0]
700af9cc: 9000         	str	r0, [sp]
;   return xReturn;
700af9ce: 9800         	ldr	r0, [sp]
700af9d0: b001         	add	sp, #0x4
700af9d2: 4770         	bx	lr
		...

700af9e0 <CSL_udmapCppi5SetSrcTag>:
; {
700af9e0: b082         	sub	sp, #0x8
700af9e2: 9001         	str	r0, [sp, #0x4]
700af9e4: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->srcDstTag, UDMAP_CPPI5_PD_SRCDSTTAG_SRCTAG, srcTag );
700af9e6: 9901         	ldr	r1, [sp, #0x4]
700af9e8: f8bd 0000    	ldrh.w	r0, [sp]
700af9ec: 81c8         	strh	r0, [r1, #0xe]
; }
700af9ee: b002         	add	sp, #0x8
700af9f0: 4770         	bx	lr
		...
700af9fe: 0000         	movs	r0, r0

700afa00 <TimerP_getCount>:
; {
700afa00: b082         	sub	sp, #0x8
700afa02: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TCRR);
700afa04: 9801         	ldr	r0, [sp, #0x4]
700afa06: 303c         	adds	r0, #0x3c
700afa08: 9000         	str	r0, [sp]
;     return *addr;
700afa0a: 9800         	ldr	r0, [sp]
700afa0c: 6800         	ldr	r0, [r0]
700afa0e: b002         	add	sp, #0x8
700afa10: 4770         	bx	lr
		...
700afa1e: 0000         	movs	r0, r0

700afa20 <TimerP_getReloadCount>:
; {
700afa20: b082         	sub	sp, #0x8
700afa22: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TLDR);
700afa24: 9801         	ldr	r0, [sp, #0x4]
700afa26: 3040         	adds	r0, #0x40
700afa28: 9000         	str	r0, [sp]
;     return *addr;
700afa2a: 9800         	ldr	r0, [sp]
700afa2c: 6800         	ldr	r0, [r0]
700afa2e: b002         	add	sp, #0x8
700afa30: 4770         	bx	lr
		...
700afa3e: 0000         	movs	r0, r0

700afa40 <main_message_isr_test>:
; {
700afa40: b580         	push	{r7, lr}
;    tm_initialize(tm_message_isr_to_task_initialize);
700afa42: f24e 3011    	movw	r0, #0xe311
700afa46: f2c7 0009    	movt	r0, #0x7009
700afa4a: f000 f9c9    	bl	0x700afde0 <tm_initialize> @ imm = #0x392
;    return 0;
700afa4e: 2000         	movs	r0, #0x0
700afa50: bd80         	pop	{r7, pc}
		...
700afa5e: 0000         	movs	r0, r0

700afa60 <putchar_>:
; {
700afa60: b510         	push	{r4, lr}
700afa62: 4604         	mov	r4, r0
;     DebugP_memLogWriterPutChar(character);
700afa64: f7f2 fd6c    	bl	0x700a2540 <DebugP_memLogWriterPutChar> @ imm = #-0xd528
;     DebugP_uartLogWriterPutChar(character);
700afa68: 4620         	mov	r0, r4
700afa6a: e8bd 4010    	pop.w	{r4, lr}
700afa6e: f7fd becf    	b.w	0x700ad810 <DebugP_uartLogWriterPutChar> @ imm = #-0x2262
		...
700afa7e: 0000         	movs	r0, r0

700afa80 <tm_interrupt_handler>:
;    if (test_interrupt_handler != NULL)
700afa80: f642 2010    	movw	r0, #0x2a10
700afa84: f2c7 000b    	movt	r0, #0x700b
700afa88: 6800         	ldr	r0, [r0]
700afa8a: 2800         	cmp	r0, #0x0
; }
700afa8c: bf08         	it	eq
700afa8e: 4770         	bxeq	lr
;       ((void (*)(void)) test_interrupt_handler)();
700afa90: 4700         	bx	r0
		...
700afa9e: 0000         	movs	r0, r0

700afaa0 <tm_setup_pmu>:
; {
700afaa0: b580         	push	{r7, lr}
;    PMU_init(&gPmuConfig);
700afaa2: f642 1090    	movw	r0, #0x2990
700afaa6: f2c7 000b    	movt	r0, #0x700b
700afaaa: f7f1 f9d1    	bl	0x700a0e50 <PMU_init>   @ imm = #-0xec5e
;    return 1;
700afaae: 2001         	movs	r0, #0x1
700afab0: bd80         	pop	{r7, pc}
		...
700afabe: 0000         	movs	r0, r0

700afac0 <uiPortGetRunTimeCounterValue>:
; uint32_t uiPortGetRunTimeCounterValue() {
700afac0: b580         	push	{r7, lr}
700afac2: b082         	sub	sp, #0x8
;   uint64_t timeInUsecs = ClockP_getTimeUsec();
700afac4: f7fb f864    	bl	0x700aab90 <ClockP_getTimeUsec> @ imm = #-0x4f38
700afac8: 9101         	str	r1, [sp, #0x4]
700afaca: 9000         	str	r0, [sp]
;   return (uint32_t)(timeInUsecs);
700afacc: 9800         	ldr	r0, [sp]
700aface: b002         	add	sp, #0x8
700afad0: bd80         	pop	{r7, pc}
		...
700afade: 0000         	movs	r0, r0

700afae0 <CSL_REG32_WR_RAW>:
; {
700afae0: b082         	sub	sp, #0x8
700afae2: 9001         	str	r0, [sp, #0x4]
700afae4: 9100         	str	r1, [sp]
;     *p = v;
700afae6: 9800         	ldr	r0, [sp]
700afae8: 9901         	ldr	r1, [sp, #0x4]
700afaea: 6008         	str	r0, [r1]
;     return;
700afaec: b002         	add	sp, #0x8
700afaee: 4770         	bx	lr

700afaf0 <CSL_REG32_WR_RAW>:
; {
700afaf0: b082         	sub	sp, #0x8
700afaf2: 9001         	str	r0, [sp, #0x4]
700afaf4: 9100         	str	r1, [sp]
;     *p = v;
700afaf6: 9800         	ldr	r0, [sp]
700afaf8: 9901         	ldr	r1, [sp, #0x4]
700afafa: 6008         	str	r0, [r1]
;     return;
700afafc: b002         	add	sp, #0x8
700afafe: 4770         	bx	lr

700afb00 <CSL_REG32_WR_RAW>:
; {
700afb00: b082         	sub	sp, #0x8
700afb02: 9001         	str	r0, [sp, #0x4]
700afb04: 9100         	str	r1, [sp]
;     *p = v;
700afb06: 9800         	ldr	r0, [sp]
700afb08: 9901         	ldr	r1, [sp, #0x4]
700afb0a: 6008         	str	r0, [r1]
;     return;
700afb0c: b002         	add	sp, #0x8
700afb0e: 4770         	bx	lr

700afb10 <CSL_REG32_WR_RAW>:
; {
700afb10: b082         	sub	sp, #0x8
700afb12: 9001         	str	r0, [sp, #0x4]
700afb14: 9100         	str	r1, [sp]
;     *p = v;
700afb16: 9800         	ldr	r0, [sp]
700afb18: 9901         	ldr	r1, [sp, #0x4]
700afb1a: 6008         	str	r0, [r1]
;     return;
700afb1c: b002         	add	sp, #0x8
700afb1e: 4770         	bx	lr

700afb20 <CSL_REG32_WR_RAW>:
; {
700afb20: b082         	sub	sp, #0x8
700afb22: 9001         	str	r0, [sp, #0x4]
700afb24: 9100         	str	r1, [sp]
;     *p = v;
700afb26: 9800         	ldr	r0, [sp]
700afb28: 9901         	ldr	r1, [sp, #0x4]
700afb2a: 6008         	str	r0, [r1]
;     return;
700afb2c: b002         	add	sp, #0x8
700afb2e: 4770         	bx	lr

700afb30 <CSL_udmapCppi5SetDstTag>:
; {
700afb30: b082         	sub	sp, #0x8
700afb32: 9001         	str	r0, [sp, #0x4]
700afb34: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->srcDstTag, UDMAP_CPPI5_PD_SRCDSTTAG_DSTTAG, dstTag );
700afb36: 9901         	ldr	r1, [sp, #0x4]
700afb38: 9800         	ldr	r0, [sp]
700afb3a: 8188         	strh	r0, [r1, #0xc]
; }
700afb3c: b002         	add	sp, #0x8
700afb3e: 4770         	bx	lr

700afb40 <CSL_udmapCppi5SetOrgBufferLen>:
; {
700afb40: b082         	sub	sp, #0x8
700afb42: 9001         	str	r0, [sp, #0x4]
700afb44: 9100         	str	r1, [sp]
;     pDesc->orgBufLen = bufferLenBytes;
700afb46: 9800         	ldr	r0, [sp]
700afb48: 9901         	ldr	r1, [sp, #0x4]
700afb4a: 6248         	str	r0, [r1, #0x24]
; }
700afb4c: b002         	add	sp, #0x8
700afb4e: 4770         	bx	lr

700afb50 <ClockP_getTimerCount>:
; {
700afb50: b580         	push	{r7, lr}
700afb52: b082         	sub	sp, #0x8
700afb54: 9001         	str	r0, [sp, #0x4]
;     return TimerP_getCount(timerBaseAddr);
700afb56: 9801         	ldr	r0, [sp, #0x4]
700afb58: f7ff ff52    	bl	0x700afa00 <TimerP_getCount> @ imm = #-0x15c
700afb5c: b002         	add	sp, #0x8
700afb5e: bd80         	pop	{r7, pc}

700afb60 <ClockP_sleepTicks>:
; {
700afb60: b580         	push	{r7, lr}
700afb62: b082         	sub	sp, #0x8
700afb64: 9001         	str	r0, [sp, #0x4]
;     vTaskDelay(ticks);
700afb66: 9801         	ldr	r0, [sp, #0x4]
700afb68: f7fe fc72    	bl	0x700ae450 <vTaskDelay> @ imm = #-0x171c
; }
700afb6c: b002         	add	sp, #0x8
700afb6e: bd80         	pop	{r7, pc}

700afb70 <ClockP_timerClearOverflowInt>:
; {
700afb70: b580         	push	{r7, lr}
700afb72: b082         	sub	sp, #0x8
700afb74: 9001         	str	r0, [sp, #0x4]
;     TimerP_clearOverflowInt(timerBaseAddr);
700afb76: 9801         	ldr	r0, [sp, #0x4]
700afb78: f7ff f852    	bl	0x700aec20 <TimerP_clearOverflowInt> @ imm = #-0xf5c
; }
700afb7c: b002         	add	sp, #0x8
700afb7e: bd80         	pop	{r7, pc}

700afb80 <HW_RD_REG32_RAW>:
; {
700afb80: b082         	sub	sp, #0x8
700afb82: 9001         	str	r0, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700afb84: 9801         	ldr	r0, [sp, #0x4]
700afb86: 6800         	ldr	r0, [r0]
700afb88: 9000         	str	r0, [sp]
;     return (regVal);
700afb8a: 9800         	ldr	r0, [sp]
700afb8c: b002         	add	sp, #0x8
700afb8e: 4770         	bx	lr

700afb90 <HW_WR_REG32_RAW>:
; {
700afb90: b082         	sub	sp, #0x8
700afb92: 9001         	str	r0, [sp, #0x4]
700afb94: 9100         	str	r1, [sp]
;     *(volatile uint32_t *) ((uintptr_t) addr) = value;
700afb96: 9800         	ldr	r0, [sp]
700afb98: 9901         	ldr	r1, [sp, #0x4]
700afb9a: 6008         	str	r0, [r1]
;     return;
700afb9c: b002         	add	sp, #0x8
700afb9e: 4770         	bx	lr

700afba0 <Udma_defaultVirtToPhyFxn>:
; {
700afba0: b083         	sub	sp, #0xc
700afba2: 9002         	str	r0, [sp, #0x8]
700afba4: 9101         	str	r1, [sp, #0x4]
700afba6: 9200         	str	r2, [sp]
;     return ((uint64_t) virtAddr);
700afba8: 9802         	ldr	r0, [sp, #0x8]
700afbaa: 2100         	movs	r1, #0x0
700afbac: b003         	add	sp, #0xc
700afbae: 4770         	bx	lr

700afbb0 <__aeabi_memset8>:
700afbb0: e1a03001     	mov	r3, r1
700afbb4: e1a01002     	mov	r1, r2
700afbb8: e1a02003     	mov	r2, r3
700afbbc: eafffef1     	b	0x700af788 <TI_memset_small> @ imm = #-0x43c

700afbc0 <_out_null>:
; {
700afbc0: b084         	sub	sp, #0x10
700afbc2: f88d 000f    	strb.w	r0, [sp, #0xf]
700afbc6: 9102         	str	r1, [sp, #0x8]
700afbc8: 9201         	str	r2, [sp, #0x4]
700afbca: 9300         	str	r3, [sp]
; }
700afbcc: b004         	add	sp, #0x10
700afbce: 4770         	bx	lr

700afbd0 <vTaskSuspendAll>:
;   ++uxSchedulerSuspended;
700afbd0: f642 2134    	movw	r1, #0x2a34
700afbd4: f2c7 010b    	movt	r1, #0x700b
700afbd8: 6808         	ldr	r0, [r1]
700afbda: 3001         	adds	r0, #0x1
700afbdc: 6008         	str	r0, [r1]
; }
700afbde: 4770         	bx	lr

700afbe0 <CSL_REG64_RD_RAW>:
; {
700afbe0: b081         	sub	sp, #0x4
700afbe2: 9000         	str	r0, [sp]
;     return (*p);
700afbe4: 9800         	ldr	r0, [sp]
700afbe6: e9d0 0100    	ldrd	r0, r1, [r0]
700afbea: b001         	add	sp, #0x4
700afbec: 4770         	bx	lr
700afbee: 0000         	movs	r0, r0

700afbf0 <vListInitialiseItem>:
; {
700afbf0: b081         	sub	sp, #0x4
700afbf2: 9000         	str	r0, [sp]
;     pxItem->pxContainer = NULL;
700afbf4: 9900         	ldr	r1, [sp]
700afbf6: 2000         	movs	r0, #0x0
700afbf8: 6108         	str	r0, [r1, #0x10]
; }
700afbfa: b001         	add	sp, #0x4
700afbfc: 4770         	bx	lr
700afbfe: 0000         	movs	r0, r0

700afc00 <vTaskMissedYield>:
; void vTaskMissedYield(void) { xYieldPending = pdTRUE; }
700afc00: f642 2160    	movw	r1, #0x2a60
700afc04: f2c7 010b    	movt	r1, #0x700b
700afc08: 2001         	movs	r0, #0x1
700afc0a: 6008         	str	r0, [r1]
700afc0c: 4770         	bx	lr
700afc0e: 0000         	movs	r0, r0

700afc10 <CSL_REG32_RD_RAW>:
; {
700afc10: b081         	sub	sp, #0x4
700afc12: 9000         	str	r0, [sp]
;     return (*p);
700afc14: 9800         	ldr	r0, [sp]
700afc16: 6800         	ldr	r0, [r0]
700afc18: b001         	add	sp, #0x4
700afc1a: 4770         	bx	lr
700afc1c: 0000         	movs	r0, r0
700afc1e: 0000         	movs	r0, r0

700afc20 <CSL_REG32_RD_RAW>:
; {
700afc20: b081         	sub	sp, #0x4
700afc22: 9000         	str	r0, [sp]
;     return (*p);
700afc24: 9800         	ldr	r0, [sp]
700afc26: 6800         	ldr	r0, [r0]
700afc28: b001         	add	sp, #0x4
700afc2a: 4770         	bx	lr
700afc2c: 0000         	movs	r0, r0
700afc2e: 0000         	movs	r0, r0

700afc30 <CSL_REG32_RD_RAW>:
; {
700afc30: b081         	sub	sp, #0x4
700afc32: 9000         	str	r0, [sp]
;     return (*p);
700afc34: 9800         	ldr	r0, [sp]
700afc36: 6800         	ldr	r0, [r0]
700afc38: b001         	add	sp, #0x4
700afc3a: 4770         	bx	lr
700afc3c: 0000         	movs	r0, r0
700afc3e: 0000         	movs	r0, r0

700afc40 <CSL_REG32_RD_RAW>:
; {
700afc40: b081         	sub	sp, #0x4
700afc42: 9000         	str	r0, [sp]
;     return (*p);
700afc44: 9800         	ldr	r0, [sp]
700afc46: 6800         	ldr	r0, [r0]
700afc48: b001         	add	sp, #0x4
700afc4a: 4770         	bx	lr
700afc4c: 0000         	movs	r0, r0
700afc4e: 0000         	movs	r0, r0

700afc50 <CSL_REG32_RD_RAW>:
; {
700afc50: b081         	sub	sp, #0x4
700afc52: 9000         	str	r0, [sp]
;     return (*p);
700afc54: 9800         	ldr	r0, [sp]
700afc56: 6800         	ldr	r0, [r0]
700afc58: b001         	add	sp, #0x4
700afc5a: 4770         	bx	lr
700afc5c: 0000         	movs	r0, r0
700afc5e: 0000         	movs	r0, r0

700afc60 <CSL_REG32_RD_RAW>:
; {
700afc60: b081         	sub	sp, #0x4
700afc62: 9000         	str	r0, [sp]
;     return (*p);
700afc64: 9800         	ldr	r0, [sp]
700afc66: 6800         	ldr	r0, [r0]
700afc68: b001         	add	sp, #0x4
700afc6a: 4770         	bx	lr
700afc6c: 0000         	movs	r0, r0
700afc6e: 0000         	movs	r0, r0

700afc70 <PMU_resetCounters>:
; static void PMU_resetCounters(void) {
700afc70: b580         	push	{r7, lr}
;   CSL_armR5PmuResetCycleCnt();
700afc72: f7f2 eb00    	blx	0x700a2274 <CSL_armR5PmuResetCycleCnt> @ imm = #-0xda00
;   CSL_armR5PmuResetCntrs();
700afc76: f7f2 eb06    	blx	0x700a2284 <CSL_armR5PmuResetCntrs> @ imm = #-0xd9f4
; }
700afc7a: bd80         	pop	{r7, pc}
700afc7c: 0000         	movs	r0, r0
700afc7e: 0000         	movs	r0, r0

700afc80 <Sciclient_getSelfDevIdCore>:
;     return gSciclientHandle.devIdCore;
700afc80: f642 1058    	movw	r0, #0x2958
700afc84: f2c7 000b    	movt	r0, #0x700b
700afc88: 6880         	ldr	r0, [r0, #0x8]
700afc8a: 4770         	bx	lr
700afc8c: 0000         	movs	r0, r0
700afc8e: 0000         	movs	r0, r0

700afc90 <Sciclient_rmPsGetPsp>:
;     return gPstack.psp;
700afc90: f241 0058    	movw	r0, #0x1058
700afc94: f2c7 0008    	movt	r0, #0x7008
700afc98: 8c80         	ldrh	r0, [r0, #0x24]
700afc9a: 4770         	bx	lr
700afc9c: 0000         	movs	r0, r0
700afc9e: 0000         	movs	r0, r0

700afca0 <Udma_rmFreeFreeRing>:
; {
700afca0: b082         	sub	sp, #0x8
700afca2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700afca6: 9100         	str	r1, [sp]
;     return;
700afca8: b002         	add	sp, #0x8
700afcaa: 4770         	bx	lr
700afcac: 0000         	movs	r0, r0
700afcae: 0000         	movs	r0, r0

700afcb0 <xTaskGetIdleTaskHandle>:
;   return xIdleTaskHandle;
700afcb0: f642 2040    	movw	r0, #0x2a40
700afcb4: f2c7 000b    	movt	r0, #0x700b
700afcb8: 6800         	ldr	r0, [r0]
700afcba: 4770         	bx	lr
700afcbc: 0000         	movs	r0, r0
700afcbe: 0000         	movs	r0, r0

700afcc0 <.Lfastpath_exit>:
700afcc0: e0420003     	sub	r0, r2, r3
700afcc4: e12fff1e     	bx	lr
700afcc8: e320f000     	nop
700afccc: 00000000     	andeq	r0, r0, r0

700afcd0 <Hwip_dataAndInstructionBarrier>:
;     __asm__ __volatile__ (" isb"   "\n\t": : : "memory");
700afcd0: f3bf 8f6f    	isb	sy
;     __asm__ __volatile__ (" dsb"   "\n\t": : : "memory");
700afcd4: f3bf 8f4f    	dsb	sy
; }
700afcd8: 4770         	bx	lr
700afcda: 0000         	movs	r0, r0
700afcdc: 0000         	movs	r0, r0
700afcde: 0000         	movs	r0, r0

700afce0 <prvTaskExitError>:
; static void prvTaskExitError(void) {
700afce0: b580         	push	{r7, lr}
700afce2: 2000         	movs	r0, #0x0
;   DebugP_assertNoLog(0);
700afce4: f001 fafc    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x15f8
; }
700afce8: bd80         	pop	{r7, pc}
700afcea: 0000         	movs	r0, r0
700afcec: 0000         	movs	r0, r0
700afcee: 0000         	movs	r0, r0

700afcf0 <ClockP_getTicks>:
; {
700afcf0: b580         	push	{r7, lr}
;     return ((uint32_t)xTaskGetTickCount());
700afcf2: f7ff fc2d    	bl	0x700af550 <xTaskGetTickCount> @ imm = #-0x7a6
700afcf6: bd80         	pop	{r7, pc}
		...

700afd00 <UART_lld_errorCallback>:
; {
700afd00: b081         	sub	sp, #0x4
700afd02: 9000         	str	r0, [sp]
; }
700afd04: b001         	add	sp, #0x4
700afd06: 4770         	bx	lr
		...

700afd10 <Udma_ringAssertFnPointers>:
; {
700afd10: b081         	sub	sp, #0x4
700afd12: 9000         	str	r0, [sp]
;     return;
700afd14: b001         	add	sp, #0x4
700afd16: 4770         	bx	lr
		...

700afd20 <vApplicationIdleHook>:
; void vApplicationIdleHook(void) {
700afd20: b580         	push	{r7, lr}
;   vApplicationLoadHook();
700afd22: f7fc f87d    	bl	0x700abe20 <vApplicationLoadHook> @ imm = #-0x3f06
; }
700afd26: bd80         	pop	{r7, pc}
		...

700afd30 <tm_interrupt_raise>:
;    HwiP_post(SOFTWARE_INTERRUPT_ID);
700afd30: 200a         	movs	r0, #0xa
700afd32: f000 b8ed    	b.w	0x700aff10 <HwiP_post>  @ imm = #0x1da
		...
700afd3e: 0000         	movs	r0, r0

700afd40 <Board_driversOpen>:
;     return status;
700afd40: 2000         	movs	r0, #0x0
700afd42: 4770         	bx	lr
		...

700afd50 <Sciclient_rmPsGetMaxPsp>:
; {
700afd50: 2003         	movs	r0, #0x3
;     return SCICLIENT_PS_MAX_DEPTH;
700afd52: 4770         	bx	lr
		...

700afd60 <TaskP_yield>:
;     taskYIELD();
700afd60: df00         	svc	#0x0
; }
700afd62: 4770         	bx	lr
		...

700afd70 <__aeabi_idiv0>:
700afd70: e12fff1e     	bx	lr
		...

700afd80 <__aeabi_ldiv0>:
700afd80: e12fff1e     	bx	lr
		...

700afd90 <main>:
;    return rtos_main_freertos();
700afd90: f7f9 b846    	b.w	0x700a8e20 <rtos_main_freertos> @ imm = #-0x6f74
		...

700afda0 <tm_pmu_profile_end>:
;    PMU_profileEnd(name);
700afda0: f7f5 bdd6    	b.w	0x700a5950 <PMU_profileEnd> @ imm = #-0xa454
		...

700afdb0 <tm_pmu_profile_print>:
;    PMU_profilePrintEntry(name);
700afdb0: f7f7 bd2e    	b.w	0x700a7810 <PMU_profilePrintEntry> @ imm = #-0x85a4
		...

700afdc0 <tm_pmu_profile_start>:
;    PMU_profileStart(name);
700afdc0: f7f9 bbee    	b.w	0x700a95a0 <PMU_profileStart> @ imm = #-0x6824
		...

700afdd0 <Board_init>:
; }
700afdd0: 4770         	bx	lr
		...
700afdde: 0000         	movs	r0, r0

700afde0 <tm_initialize>:
;    test_initialization_function();
700afde0: 4700         	bx	r0
		...
700afdee: 0000         	movs	r0, r0

700afdf0 <vPortConfigTimerForRunTimeStats>:
; }
700afdf0: 4770         	bx	lr
		...
700afdfe: 0000         	movs	r0, r0
