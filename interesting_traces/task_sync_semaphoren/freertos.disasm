
.\files\freertos.out:	file format elf32-littlearm

Disassembly of section .vectors:

00000000 <_vectors>:
;         LDR pc, reset_addr          // Reset
       0: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x20 <reset_addr>
;         LDR pc, undefined_addr      // Undefined Instruction
       4: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x24 <undefined_addr>
;         LDR pc, svc_addr            // Software interrupt
       8: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x28 <svc_addr>
;         LDR pc, prefetch_abort_addr // Abort (prefetch)
       c: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x2c <prefetch_abort_addr>
;         LDR pc, data_abort_addr     // Abort (data)
      10: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x30 <data_abort_addr>
;         LDR pc, reserved_addr       // rsvd
      14: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x34 <reserved_addr>
;         LDR pc, irq_addr            // IRQ
      18: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x38 <irq_addr>
;         LDR pc, fiq_addr            // FIQ
      1c: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x3c <fiq_addr>

00000020 <reset_addr>:
      20: 14 f6 0a 70  	.word	0x700af614

00000024 <undefined_addr>:
      24: 21 eb 0a 70  	.word	0x700aeb21

00000028 <svc_addr>:
      28: 0c ec 0a 70  	.word	0x700aec0c

0000002c <prefetch_abort_addr>:
      2c: 61 eb 0a 70  	.word	0x700aeb61

00000030 <data_abort_addr>:
      30: 30 ee 0a 70  	.word	0x700aee30

00000034 <reserved_addr>:
      34: e1 ea 0a 70  	.word	0x700aeae1

00000038 <irq_addr>:
      38: 7c ec 0a 70  	.word	0x700aec7c

0000003c <fiq_addr>:
      3c: 71 e9 0a 70  	.word	0x700ae971

Disassembly of section .text.hwi:

700ae260 <HwiP_enableInt>:
; {
700ae260: b580         	push	{r7, lr}
700ae262: b084         	sub	sp, #0x10
700ae264: 9003         	str	r0, [sp, #0xc]
;     Hwip_dataAndInstructionBarrier();
700ae266: f7ff ff63    	bl	0x700ae130 <Hwip_dataAndInstructionBarrier> @ imm = #-0x13a
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_EN(intNum));
700ae26a: f640 509c    	movw	r0, #0xd9c
700ae26e: f2c7 000b    	movt	r0, #0x700b
700ae272: 6801         	ldr	r1, [r0]
700ae274: 9803         	ldr	r0, [sp, #0xc]
700ae276: f400 70f0    	and	r0, r0, #0x1e0
700ae27a: 4408         	add	r0, r1
700ae27c: f500 6081    	add.w	r0, r0, #0x408
700ae280: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700ae282: 9803         	ldr	r0, [sp, #0xc]
700ae284: f000 001f    	and	r0, r0, #0x1f
700ae288: 9001         	str	r0, [sp, #0x4]
;     *addr = ((uint32_t)0x1 << bitPos);
700ae28a: 9901         	ldr	r1, [sp, #0x4]
700ae28c: 2001         	movs	r0, #0x1
700ae28e: 4088         	lsls	r0, r1
700ae290: 9902         	ldr	r1, [sp, #0x8]
700ae292: 6008         	str	r0, [r1]
; }
700ae294: b004         	add	sp, #0x10
700ae296: bd80         	pop	{r7, pc}
700ae298: bf00         	nop
700ae29a: bf00         	nop
700ae29c: bf00         	nop
700ae29e: bf00         	nop

700ae2a0 <HwiP_disableInt>:
; {
700ae2a0: b580         	push	{r7, lr}
700ae2a2: b084         	sub	sp, #0x10
700ae2a4: 9003         	str	r0, [sp, #0xc]
700ae2a6: 2000         	movs	r0, #0x0
;     uint32_t isEnable = 0;
700ae2a8: 9000         	str	r0, [sp]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_DIS(intNum));
700ae2aa: f640 509c    	movw	r0, #0xd9c
700ae2ae: f2c7 000b    	movt	r0, #0x700b
700ae2b2: 6801         	ldr	r1, [r0]
700ae2b4: 9803         	ldr	r0, [sp, #0xc]
700ae2b6: f400 70f0    	and	r0, r0, #0x1e0
700ae2ba: 4408         	add	r0, r1
700ae2bc: f200 400c    	addw	r0, r0, #0x40c
700ae2c0: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700ae2c2: 9803         	ldr	r0, [sp, #0xc]
700ae2c4: f000 001f    	and	r0, r0, #0x1f
700ae2c8: 9001         	str	r0, [sp, #0x4]
;     if( (*addr & ((uint32_t)0x1 << bitPos))!=0U)
700ae2ca: 9802         	ldr	r0, [sp, #0x8]
700ae2cc: 6800         	ldr	r0, [r0]
700ae2ce: 9901         	ldr	r1, [sp, #0x4]
700ae2d0: 40c8         	lsrs	r0, r1
700ae2d2: 07c0         	lsls	r0, r0, #0x1f
700ae2d4: b118         	cbz	r0, 0x700ae2de <HwiP_disableInt+0x3e> @ imm = #0x6
700ae2d6: e7ff         	b	0x700ae2d8 <HwiP_disableInt+0x38> @ imm = #-0x2
700ae2d8: 2001         	movs	r0, #0x1
;         isEnable = 1;
700ae2da: 9000         	str	r0, [sp]
;     }
700ae2dc: e7ff         	b	0x700ae2de <HwiP_disableInt+0x3e> @ imm = #-0x2
;     *addr = ((uint32_t)0x1 << bitPos);
700ae2de: 9901         	ldr	r1, [sp, #0x4]
700ae2e0: 2001         	movs	r0, #0x1
700ae2e2: 4088         	lsls	r0, r1
700ae2e4: 9902         	ldr	r1, [sp, #0x8]
700ae2e6: 6008         	str	r0, [r1]
;     Hwip_dataAndInstructionBarrier();
700ae2e8: f7ff ff22    	bl	0x700ae130 <Hwip_dataAndInstructionBarrier> @ imm = #-0x1bc
;     return isEnable;
700ae2ec: 9800         	ldr	r0, [sp]
700ae2ee: b004         	add	sp, #0x10
700ae2f0: bd80         	pop	{r7, pc}
700ae2f2: bf00         	nop
700ae2f4: bf00         	nop
700ae2f6: bf00         	nop
700ae2f8: bf00         	nop
700ae2fa: bf00         	nop
700ae2fc: bf00         	nop
700ae2fe: bf00         	nop

700ae300 <HwiP_restoreInt>:
; {
700ae300: b580         	push	{r7, lr}
700ae302: b082         	sub	sp, #0x8
700ae304: 9001         	str	r0, [sp, #0x4]
700ae306: 9100         	str	r1, [sp]
;     if(oldIntState!=0U)
700ae308: 9800         	ldr	r0, [sp]
700ae30a: b120         	cbz	r0, 0x700ae316 <HwiP_restoreInt+0x16> @ imm = #0x8
700ae30c: e7ff         	b	0x700ae30e <HwiP_restoreInt+0xe> @ imm = #-0x2
;         HwiP_enableInt(intNum);
700ae30e: 9801         	ldr	r0, [sp, #0x4]
700ae310: f7ff ffa6    	bl	0x700ae260 <HwiP_enableInt> @ imm = #-0xb4
;     }
700ae314: e003         	b	0x700ae31e <HwiP_restoreInt+0x1e> @ imm = #0x6
;        (void) HwiP_disableInt(intNum);
700ae316: 9801         	ldr	r0, [sp, #0x4]
700ae318: f7ff ffc2    	bl	0x700ae2a0 <HwiP_disableInt> @ imm = #-0x7c
700ae31c: e7ff         	b	0x700ae31e <HwiP_restoreInt+0x1e> @ imm = #-0x2
; }
700ae31e: b002         	add	sp, #0x8
700ae320: bd80         	pop	{r7, pc}
700ae322: bf00         	nop
700ae324: bf00         	nop
700ae326: bf00         	nop
700ae328: bf00         	nop
700ae32a: bf00         	nop
700ae32c: bf00         	nop
700ae32e: bf00         	nop

700ae330 <HwiP_clearInt>:
; {
700ae330: b083         	sub	sp, #0xc
700ae332: 9002         	str	r0, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_STS(intNum));
700ae334: f640 509c    	movw	r0, #0xd9c
700ae338: f2c7 000b    	movt	r0, #0x700b
700ae33c: 6801         	ldr	r1, [r0]
700ae33e: 9802         	ldr	r0, [sp, #0x8]
700ae340: f400 70f0    	and	r0, r0, #0x1e0
700ae344: 4408         	add	r0, r1
700ae346: f200 4004    	addw	r0, r0, #0x404
700ae34a: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700ae34c: 9802         	ldr	r0, [sp, #0x8]
700ae34e: f000 001f    	and	r0, r0, #0x1f
700ae352: 9000         	str	r0, [sp]
;     *addr = ((uint32_t)0x1 << bitPos);
700ae354: 9900         	ldr	r1, [sp]
700ae356: 2001         	movs	r0, #0x1
700ae358: 4088         	lsls	r0, r1
700ae35a: 9901         	ldr	r1, [sp, #0x4]
700ae35c: 6008         	str	r0, [r1]
; }
700ae35e: b003         	add	sp, #0xc
700ae360: 4770         	bx	lr
700ae362: bf00         	nop
700ae364: bf00         	nop
700ae366: bf00         	nop
700ae368: bf00         	nop
700ae36a: bf00         	nop
700ae36c: bf00         	nop
700ae36e: bf00         	nop

700ae370 <HwiP_post>:
; {
700ae370: b580         	push	{r7, lr}
700ae372: b084         	sub	sp, #0x10
700ae374: 9003         	str	r0, [sp, #0xc]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_RAW(intNum));
700ae376: f640 509c    	movw	r0, #0xd9c
700ae37a: f2c7 000b    	movt	r0, #0x700b
700ae37e: 6801         	ldr	r1, [r0]
700ae380: 9803         	ldr	r0, [sp, #0xc]
700ae382: f400 70f0    	and	r0, r0, #0x1e0
700ae386: 4408         	add	r0, r1
700ae388: f500 6080    	add.w	r0, r0, #0x400
700ae38c: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700ae38e: 9803         	ldr	r0, [sp, #0xc]
700ae390: f000 001f    	and	r0, r0, #0x1f
700ae394: 9001         	str	r0, [sp, #0x4]
;     *addr = ((uint32_t)0x1 << bitPos);
700ae396: 9901         	ldr	r1, [sp, #0x4]
700ae398: 2001         	movs	r0, #0x1
700ae39a: 4088         	lsls	r0, r1
700ae39c: 9902         	ldr	r1, [sp, #0x8]
700ae39e: 6008         	str	r0, [r1]
;     Hwip_dataAndInstructionBarrier();
700ae3a0: f7ff fec6    	bl	0x700ae130 <Hwip_dataAndInstructionBarrier> @ imm = #-0x274
; }
700ae3a4: b004         	add	sp, #0x10
700ae3a6: bd80         	pop	{r7, pc}
700ae3a8: bf00         	nop
700ae3aa: bf00         	nop
700ae3ac: bf00         	nop
700ae3ae: bf00         	nop

700ae3b0 <HwiP_Params_init>:
; {
700ae3b0: b081         	sub	sp, #0x4
700ae3b2: 9000         	str	r0, [sp]
;     params->intNum = 0;
700ae3b4: 9900         	ldr	r1, [sp]
700ae3b6: 2000         	movs	r0, #0x0
700ae3b8: 6008         	str	r0, [r1]
;     params->callback = NULL;
700ae3ba: 9900         	ldr	r1, [sp]
700ae3bc: 6048         	str	r0, [r1, #0x4]
;     params->args = NULL;
700ae3be: 9900         	ldr	r1, [sp]
700ae3c0: 6088         	str	r0, [r1, #0x8]
;     params->eventId = 0; /* NOT USED */
700ae3c2: 9900         	ldr	r1, [sp]
700ae3c4: 8188         	strh	r0, [r1, #0xc]
;     params->priority = (HwiP_MAX_PRIORITY-1U);
700ae3c6: 9a00         	ldr	r2, [sp]
700ae3c8: 210f         	movs	r1, #0xf
700ae3ca: 7391         	strb	r1, [r2, #0xe]
;     params->isFIQ = 0;
700ae3cc: 9900         	ldr	r1, [sp]
700ae3ce: 73c8         	strb	r0, [r1, #0xf]
;     params->isPulse = 0;
700ae3d0: 9900         	ldr	r1, [sp]
700ae3d2: 7408         	strb	r0, [r1, #0x10]
; }
700ae3d4: b001         	add	sp, #0x4
700ae3d6: 4770         	bx	lr
700ae3d8: bf00         	nop
700ae3da: bf00         	nop
700ae3dc: bf00         	nop
700ae3de: bf00         	nop

700ae3e0 <HwiP_construct>:
; {
700ae3e0: b580         	push	{r7, lr}
700ae3e2: b084         	sub	sp, #0x10
700ae3e4: 9003         	str	r0, [sp, #0xc]
700ae3e6: 9102         	str	r1, [sp, #0x8]
;     HwiP_Struct *obj = (HwiP_Struct *)handle;
700ae3e8: 9803         	ldr	r0, [sp, #0xc]
700ae3ea: 9001         	str	r0, [sp, #0x4]
700ae3ec: 2001         	movs	r0, #0x1
;     DebugP_assertNoLog( sizeof(HwiP_Struct) <= sizeof(HwiP_Object) );
700ae3ee: f001 f9a7    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x134e
;     DebugP_assertNoLog( params->callback != NULL );
700ae3f2: 9802         	ldr	r0, [sp, #0x8]
700ae3f4: 6840         	ldr	r0, [r0, #0x4]
700ae3f6: 2800         	cmp	r0, #0x0
700ae3f8: bf18         	it	ne
700ae3fa: 2001         	movne	r0, #0x1
700ae3fc: f001 f9a0    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x1340
;     DebugP_assertNoLog( params->intNum < HwiP_MAX_INTERRUPTS );
700ae400: 9802         	ldr	r0, [sp, #0x8]
700ae402: 6801         	ldr	r1, [r0]
700ae404: 2000         	movs	r0, #0x0
700ae406: 9000         	str	r0, [sp]
700ae408: f5b1 7f00    	cmp.w	r1, #0x200
700ae40c: bf38         	it	lo
700ae40e: 2001         	movlo	r0, #0x1
700ae410: f001 f996    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x132c
700ae414: 9800         	ldr	r0, [sp]
;     DebugP_assertNoLog( params->priority < HwiP_MAX_PRIORITY );
700ae416: 9902         	ldr	r1, [sp, #0x8]
700ae418: 7b89         	ldrb	r1, [r1, #0xe]
700ae41a: 2910         	cmp	r1, #0x10
700ae41c: bf38         	it	lo
700ae41e: 2001         	movlo	r0, #0x1
700ae420: f001 f98e    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x131c
;     (void) HwiP_disableInt(params->intNum);
700ae424: 9802         	ldr	r0, [sp, #0x8]
700ae426: 6800         	ldr	r0, [r0]
700ae428: f7ff ff3a    	bl	0x700ae2a0 <HwiP_disableInt> @ imm = #-0x18c
;     HwiP_clearInt(params->intNum);
700ae42c: 9802         	ldr	r0, [sp, #0x8]
700ae42e: 6800         	ldr	r0, [r0]
700ae430: f7ff ff7e    	bl	0x700ae330 <HwiP_clearInt> @ imm = #-0x104
;     HwiP_setAsFIQ(params->intNum, params->isFIQ);
700ae434: 9902         	ldr	r1, [sp, #0x8]
700ae436: 6808         	ldr	r0, [r1]
700ae438: 7bc9         	ldrb	r1, [r1, #0xf]
700ae43a: f000 f841    	bl	0x700ae4c0 <HwiP_setAsFIQ> @ imm = #0x82
;     HwiP_setPri(params->intNum, params->priority);
700ae43e: 9902         	ldr	r1, [sp, #0x8]
700ae440: 6808         	ldr	r0, [r1]
700ae442: 7b89         	ldrb	r1, [r1, #0xe]
700ae444: f000 f86c    	bl	0x700ae520 <HwiP_setPri> @ imm = #0xd8
;     HwiP_setAsPulse(params->intNum, params->isPulse);
700ae448: 9902         	ldr	r1, [sp, #0x8]
700ae44a: 6808         	ldr	r0, [r1]
700ae44c: 7c09         	ldrb	r1, [r1, #0x10]
700ae44e: f000 f87f    	bl	0x700ae550 <HwiP_setAsPulse> @ imm = #0xfe
;     if(params->isFIQ != 0U)
700ae452: 9802         	ldr	r0, [sp, #0x8]
700ae454: 7bc0         	ldrb	r0, [r0, #0xf]
700ae456: b148         	cbz	r0, 0x700ae46c <HwiP_construct+0x8c> @ imm = #0x12
700ae458: e7ff         	b	0x700ae45a <HwiP_construct+0x7a> @ imm = #-0x2
;         HwiP_setVecAddr(params->intNum, (uintptr_t)HwiP_fiq_handler);
700ae45a: 9802         	ldr	r0, [sp, #0x8]
700ae45c: 6800         	ldr	r0, [r0]
700ae45e: f64e 1171    	movw	r1, #0xe971
700ae462: f2c7 010a    	movt	r1, #0x700a
700ae466: f000 f8a3    	bl	0x700ae5b0 <HwiP_setVecAddr> @ imm = #0x146
;     }
700ae46a: e008         	b	0x700ae47e <HwiP_construct+0x9e> @ imm = #0x10
;         HwiP_setVecAddr(params->intNum, (uintptr_t)HwiP_irq_handler);
700ae46c: 9802         	ldr	r0, [sp, #0x8]
700ae46e: 6800         	ldr	r0, [r0]
700ae470: f64e 417c    	movw	r1, #0xec7c
700ae474: f2c7 010a    	movt	r1, #0x700a
700ae478: f000 f89a    	bl	0x700ae5b0 <HwiP_setVecAddr> @ imm = #0x134
700ae47c: e7ff         	b	0x700ae47e <HwiP_construct+0x9e> @ imm = #-0x2
;     gHwiCtrl.isr[params->intNum] = params->callback;
700ae47e: 9802         	ldr	r0, [sp, #0x8]
700ae480: 6802         	ldr	r2, [r0]
700ae482: 6840         	ldr	r0, [r0, #0x4]
700ae484: f240 0100    	movw	r1, #0x0
700ae488: f2c7 0108    	movt	r1, #0x7008
700ae48c: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     gHwiCtrl.isrArgs[params->intNum] = params->args;
700ae490: 9802         	ldr	r0, [sp, #0x8]
700ae492: 6802         	ldr	r2, [r0]
700ae494: 6880         	ldr	r0, [r0, #0x8]
700ae496: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ae49a: f8c1 0800    	str.w	r0, [r1, #0x800]
;     obj->intNum = params->intNum;
700ae49e: 9802         	ldr	r0, [sp, #0x8]
700ae4a0: 6800         	ldr	r0, [r0]
700ae4a2: 9901         	ldr	r1, [sp, #0x4]
700ae4a4: 6008         	str	r0, [r1]
;     HwiP_enableInt(params->intNum);
700ae4a6: 9802         	ldr	r0, [sp, #0x8]
700ae4a8: 6800         	ldr	r0, [r0]
700ae4aa: f7ff fed9    	bl	0x700ae260 <HwiP_enableInt> @ imm = #-0x24e
700ae4ae: 2000         	movs	r0, #0x0
;     return SystemP_SUCCESS;
700ae4b0: b004         	add	sp, #0x10
700ae4b2: bd80         	pop	{r7, pc}
700ae4b4: bf00         	nop
700ae4b6: bf00         	nop
700ae4b8: bf00         	nop
700ae4ba: bf00         	nop
700ae4bc: bf00         	nop
700ae4be: bf00         	nop

700ae4c0 <HwiP_setAsFIQ>:
; {
700ae4c0: b084         	sub	sp, #0x10
700ae4c2: 9003         	str	r0, [sp, #0xc]
700ae4c4: 9102         	str	r1, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_MAP(intNum));
700ae4c6: f640 509c    	movw	r0, #0xd9c
700ae4ca: f2c7 000b    	movt	r0, #0x700b
700ae4ce: 6801         	ldr	r1, [r0]
700ae4d0: 9803         	ldr	r0, [sp, #0xc]
700ae4d2: f400 70f0    	and	r0, r0, #0x1e0
700ae4d6: 4408         	add	r0, r1
700ae4d8: f500 6083    	add.w	r0, r0, #0x418
700ae4dc: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700ae4de: 9803         	ldr	r0, [sp, #0xc]
700ae4e0: f000 001f    	and	r0, r0, #0x1f
700ae4e4: 9000         	str	r0, [sp]
;     if(isFIQ != 0U)
700ae4e6: 9802         	ldr	r0, [sp, #0x8]
700ae4e8: b148         	cbz	r0, 0x700ae4fe <HwiP_setAsFIQ+0x3e> @ imm = #0x12
700ae4ea: e7ff         	b	0x700ae4ec <HwiP_setAsFIQ+0x2c> @ imm = #-0x2
;         *addr |= ((uint32_t)0x1u << bitPos);
700ae4ec: 9900         	ldr	r1, [sp]
700ae4ee: 2001         	movs	r0, #0x1
700ae4f0: fa00 f201    	lsl.w	r2, r0, r1
700ae4f4: 9901         	ldr	r1, [sp, #0x4]
700ae4f6: 6808         	ldr	r0, [r1]
700ae4f8: 4310         	orrs	r0, r2
700ae4fa: 6008         	str	r0, [r1]
;     }
700ae4fc: e008         	b	0x700ae510 <HwiP_setAsFIQ+0x50> @ imm = #0x10
;         *addr &= ~(0x1u << bitPos);
700ae4fe: 9900         	ldr	r1, [sp]
700ae500: 2001         	movs	r0, #0x1
700ae502: fa00 f201    	lsl.w	r2, r0, r1
700ae506: 9901         	ldr	r1, [sp, #0x4]
700ae508: 6808         	ldr	r0, [r1]
700ae50a: 4390         	bics	r0, r2
700ae50c: 6008         	str	r0, [r1]
700ae50e: e7ff         	b	0x700ae510 <HwiP_setAsFIQ+0x50> @ imm = #-0x2
; }
700ae510: b004         	add	sp, #0x10
700ae512: 4770         	bx	lr
700ae514: bf00         	nop
700ae516: bf00         	nop
700ae518: bf00         	nop
700ae51a: bf00         	nop
700ae51c: bf00         	nop
700ae51e: bf00         	nop

700ae520 <HwiP_setPri>:
; {
700ae520: b083         	sub	sp, #0xc
700ae522: 9002         	str	r0, [sp, #0x8]
700ae524: 9101         	str	r1, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_PRI(intNum));
700ae526: f640 509c    	movw	r0, #0xd9c
700ae52a: f2c7 000b    	movt	r0, #0x700b
700ae52e: 6800         	ldr	r0, [r0]
700ae530: 9902         	ldr	r1, [sp, #0x8]
700ae532: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ae536: f500 5080    	add.w	r0, r0, #0x1000
700ae53a: 9000         	str	r0, [sp]
;     *addr = (priority & 0xFu);
700ae53c: 9801         	ldr	r0, [sp, #0x4]
700ae53e: f000 000f    	and	r0, r0, #0xf
700ae542: 9900         	ldr	r1, [sp]
700ae544: 6008         	str	r0, [r1]
; }
700ae546: b003         	add	sp, #0xc
700ae548: 4770         	bx	lr
700ae54a: bf00         	nop
700ae54c: bf00         	nop
700ae54e: bf00         	nop

700ae550 <HwiP_setAsPulse>:
; {
700ae550: b084         	sub	sp, #0x10
700ae552: 9003         	str	r0, [sp, #0xc]
700ae554: 9102         	str	r1, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(intNum));
700ae556: f640 509c    	movw	r0, #0xd9c
700ae55a: f2c7 000b    	movt	r0, #0x700b
700ae55e: 6801         	ldr	r1, [r0]
700ae560: 9803         	ldr	r0, [sp, #0xc]
700ae562: f400 70f0    	and	r0, r0, #0x1e0
700ae566: 4408         	add	r0, r1
700ae568: f200 401c    	addw	r0, r0, #0x41c
700ae56c: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700ae56e: 9803         	ldr	r0, [sp, #0xc]
700ae570: f000 001f    	and	r0, r0, #0x1f
700ae574: 9000         	str	r0, [sp]
;     if(isPulse != 0U)
700ae576: 9802         	ldr	r0, [sp, #0x8]
700ae578: b148         	cbz	r0, 0x700ae58e <HwiP_setAsPulse+0x3e> @ imm = #0x12
700ae57a: e7ff         	b	0x700ae57c <HwiP_setAsPulse+0x2c> @ imm = #-0x2
;         *addr |= ((uint32_t)0x1u << bitPos);
700ae57c: 9900         	ldr	r1, [sp]
700ae57e: 2001         	movs	r0, #0x1
700ae580: fa00 f201    	lsl.w	r2, r0, r1
700ae584: 9901         	ldr	r1, [sp, #0x4]
700ae586: 6808         	ldr	r0, [r1]
700ae588: 4310         	orrs	r0, r2
700ae58a: 6008         	str	r0, [r1]
;     }
700ae58c: e008         	b	0x700ae5a0 <HwiP_setAsPulse+0x50> @ imm = #0x10
;         *addr &= ~(0x1u << bitPos);
700ae58e: 9900         	ldr	r1, [sp]
700ae590: 2001         	movs	r0, #0x1
700ae592: fa00 f201    	lsl.w	r2, r0, r1
700ae596: 9901         	ldr	r1, [sp, #0x4]
700ae598: 6808         	ldr	r0, [r1]
700ae59a: 4390         	bics	r0, r2
700ae59c: 6008         	str	r0, [r1]
700ae59e: e7ff         	b	0x700ae5a0 <HwiP_setAsPulse+0x50> @ imm = #-0x2
; }
700ae5a0: b004         	add	sp, #0x10
700ae5a2: 4770         	bx	lr
700ae5a4: bf00         	nop
700ae5a6: bf00         	nop
700ae5a8: bf00         	nop
700ae5aa: bf00         	nop
700ae5ac: bf00         	nop
700ae5ae: bf00         	nop

700ae5b0 <HwiP_setVecAddr>:
; {
700ae5b0: b083         	sub	sp, #0xc
700ae5b2: 9002         	str	r0, [sp, #0x8]
700ae5b4: 9101         	str	r1, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_VEC(intNum));
700ae5b6: f640 509c    	movw	r0, #0xd9c
700ae5ba: f2c7 000b    	movt	r0, #0x700b
700ae5be: 6800         	ldr	r0, [r0]
700ae5c0: 9902         	ldr	r1, [sp, #0x8]
700ae5c2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ae5c6: f500 5000    	add.w	r0, r0, #0x2000
700ae5ca: 9000         	str	r0, [sp]
;     *addr = ((uint32_t)vecAddr & 0xFFFFFFFCU);
700ae5cc: 9801         	ldr	r0, [sp, #0x4]
700ae5ce: f020 0003    	bic	r0, r0, #0x3
700ae5d2: 9900         	ldr	r1, [sp]
700ae5d4: 6008         	str	r0, [r1]
; }
700ae5d6: b003         	add	sp, #0xc
700ae5d8: 4770         	bx	lr
700ae5da: bf00         	nop
700ae5dc: bf00         	nop
700ae5de: bf00         	nop

700ae5e0 <HwiP_destruct>:
; {
700ae5e0: b580         	push	{r7, lr}
700ae5e2: b084         	sub	sp, #0x10
700ae5e4: 9003         	str	r0, [sp, #0xc]
;     HwiP_Struct *obj = (HwiP_Struct *)handle;
700ae5e6: 9803         	ldr	r0, [sp, #0xc]
700ae5e8: 9002         	str	r0, [sp, #0x8]
;    (void) HwiP_disableInt(obj->intNum);
700ae5ea: 9802         	ldr	r0, [sp, #0x8]
700ae5ec: 6800         	ldr	r0, [r0]
700ae5ee: f7ff fe57    	bl	0x700ae2a0 <HwiP_disableInt> @ imm = #-0x352
;     HwiP_clearInt(obj->intNum);
700ae5f2: 9802         	ldr	r0, [sp, #0x8]
700ae5f4: 6800         	ldr	r0, [r0]
700ae5f6: f7ff fe9b    	bl	0x700ae330 <HwiP_clearInt> @ imm = #-0x2ca
;     HwiP_setAsFIQ(obj->intNum, 0);
700ae5fa: 9802         	ldr	r0, [sp, #0x8]
700ae5fc: 6800         	ldr	r0, [r0]
700ae5fe: 2100         	movs	r1, #0x0
700ae600: 9101         	str	r1, [sp, #0x4]
700ae602: f7ff ff5d    	bl	0x700ae4c0 <HwiP_setAsFIQ> @ imm = #-0x146
;     HwiP_setPri(obj->intNum, HwiP_MAX_PRIORITY-1U);
700ae606: 9802         	ldr	r0, [sp, #0x8]
700ae608: 6800         	ldr	r0, [r0]
700ae60a: 210f         	movs	r1, #0xf
700ae60c: f7ff ff88    	bl	0x700ae520 <HwiP_setPri> @ imm = #-0xf0
700ae610: 9901         	ldr	r1, [sp, #0x4]
;     HwiP_setAsPulse(obj->intNum, 0);
700ae612: 9802         	ldr	r0, [sp, #0x8]
700ae614: 6800         	ldr	r0, [r0]
700ae616: f7ff ff9b    	bl	0x700ae550 <HwiP_setAsPulse> @ imm = #-0xca
;     HwiP_setVecAddr(obj->intNum, (uintptr_t)HwiP_irq_handler);
700ae61a: 9802         	ldr	r0, [sp, #0x8]
700ae61c: 6800         	ldr	r0, [r0]
700ae61e: f64e 417c    	movw	r1, #0xec7c
700ae622: f2c7 010a    	movt	r1, #0x700a
700ae626: f7ff ffc3    	bl	0x700ae5b0 <HwiP_setVecAddr> @ imm = #-0x7a
700ae62a: 9801         	ldr	r0, [sp, #0x4]
;     gHwiCtrl.isr[obj->intNum] = NULL;
700ae62c: 9902         	ldr	r1, [sp, #0x8]
700ae62e: 680a         	ldr	r2, [r1]
700ae630: f240 0100    	movw	r1, #0x0
700ae634: f2c7 0108    	movt	r1, #0x7008
700ae638: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     gHwiCtrl.isrArgs[obj->intNum] = NULL;
700ae63c: 9a02         	ldr	r2, [sp, #0x8]
700ae63e: 6812         	ldr	r2, [r2]
700ae640: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ae644: f8c1 0800    	str.w	r0, [r1, #0x800]
; }
700ae648: b004         	add	sp, #0x10
700ae64a: bd80         	pop	{r7, pc}
700ae64c: bf00         	nop
700ae64e: bf00         	nop

700ae650 <HwiP_init>:
; {
700ae650: b580         	push	{r7, lr}
700ae652: b084         	sub	sp, #0x10
;     (void) HwiP_disable();
700ae654: f000 ebb4    	blx	0x700aedc0 <HwiP_disable> @ imm = #0x768
;     (void) HwiP_disableFIQ();
700ae658: f000 ebba    	blx	0x700aedd0 <HwiP_disableFIQ> @ imm = #0x774
;     DebugP_assertNoLog(gHwiConfig.intcBaseAddr != 0U);
700ae65c: f640 509c    	movw	r0, #0xd9c
700ae660: f2c7 000b    	movt	r0, #0x700b
700ae664: 6800         	ldr	r0, [r0]
700ae666: 2800         	cmp	r0, #0x0
700ae668: bf18         	it	ne
700ae66a: 2001         	movne	r0, #0x1
700ae66c: f001 f868    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x10d0
;     gHwiCtrl.spuriousIRQCount = 0;
700ae670: f240 0100    	movw	r1, #0x0
700ae674: f2c7 0108    	movt	r1, #0x7008
700ae678: f44f 5280    	mov.w	r2, #0x1000
700ae67c: 2000         	movs	r0, #0x0
700ae67e: 5088         	str	r0, [r1, r2]
700ae680: f241 0204    	movw	r2, #0x1004
;     gHwiCtrl.spuriousFIQCount = 0;
700ae684: 5088         	str	r0, [r1, r2]
;     for(i=0; i<HwiP_MAX_INTERRUPTS; i++)
700ae686: 9003         	str	r0, [sp, #0xc]
700ae688: e7ff         	b	0x700ae68a <HwiP_init+0x3a> @ imm = #-0x2
700ae68a: 9903         	ldr	r1, [sp, #0xc]
700ae68c: 2000         	movs	r0, #0x0
700ae68e: ebb0 2f51    	cmp.w	r0, r1, lsr #9
700ae692: d11d         	bne	0x700ae6d0 <HwiP_init+0x80> @ imm = #0x3a
700ae694: e7ff         	b	0x700ae696 <HwiP_init+0x46> @ imm = #-0x2
;         gHwiCtrl.isr[i] = NULL;
700ae696: 9a03         	ldr	r2, [sp, #0xc]
700ae698: f240 0100    	movw	r1, #0x0
700ae69c: f2c7 0108    	movt	r1, #0x7008
700ae6a0: 2000         	movs	r0, #0x0
700ae6a2: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gHwiCtrl.isrArgs[i] = NULL;
700ae6a6: 9a03         	ldr	r2, [sp, #0xc]
700ae6a8: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ae6ac: f8c1 0800    	str.w	r0, [r1, #0x800]
;         HwiP_setPri(i, 0xF);
700ae6b0: 9803         	ldr	r0, [sp, #0xc]
700ae6b2: 210f         	movs	r1, #0xf
700ae6b4: f7ff ff34    	bl	0x700ae520 <HwiP_setPri> @ imm = #-0x198
;         HwiP_setVecAddr(i, (uintptr_t)HwiP_irq_handler);
700ae6b8: 9803         	ldr	r0, [sp, #0xc]
700ae6ba: f64e 417c    	movw	r1, #0xec7c
700ae6be: f2c7 010a    	movt	r1, #0x700a
700ae6c2: f7ff ff75    	bl	0x700ae5b0 <HwiP_setVecAddr> @ imm = #-0x116
;     }
700ae6c6: e7ff         	b	0x700ae6c8 <HwiP_init+0x78> @ imm = #-0x2
;     for(i=0; i<HwiP_MAX_INTERRUPTS; i++)
700ae6c8: 9803         	ldr	r0, [sp, #0xc]
700ae6ca: 3001         	adds	r0, #0x1
700ae6cc: 9003         	str	r0, [sp, #0xc]
700ae6ce: e7dc         	b	0x700ae68a <HwiP_init+0x3a> @ imm = #-0x48
700ae6d0: 2000         	movs	r0, #0x0
;     for(i=0; i<(HwiP_MAX_INTERRUPTS/INTERRUPT_VALUE); i++)
700ae6d2: 9003         	str	r0, [sp, #0xc]
700ae6d4: e7ff         	b	0x700ae6d6 <HwiP_init+0x86> @ imm = #-0x2
700ae6d6: 9803         	ldr	r0, [sp, #0xc]
700ae6d8: 280f         	cmp	r0, #0xf
700ae6da: d838         	bhi	0x700ae74e <HwiP_init+0xfe> @ imm = #0x70
700ae6dc: e7ff         	b	0x700ae6de <HwiP_init+0x8e> @ imm = #-0x2
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_DIS(i*INTERRUPT_VALUE));
700ae6de: f640 519c    	movw	r1, #0xd9c
700ae6e2: f2c7 010b    	movt	r1, #0x700b
700ae6e6: 6808         	ldr	r0, [r1]
700ae6e8: 9a03         	ldr	r2, [sp, #0xc]
700ae6ea: f002 020f    	and	r2, r2, #0xf
700ae6ee: eb00 1042    	add.w	r0, r0, r2, lsl #5
700ae6f2: f200 400c    	addw	r0, r0, #0x40c
700ae6f6: 9002         	str	r0, [sp, #0x8]
;         *addr = 0xFFFFFFFFu;
700ae6f8: 9a02         	ldr	r2, [sp, #0x8]
700ae6fa: f04f 30ff    	mov.w	r0, #0xffffffff
700ae6fe: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_STS(i*INTERRUPT_VALUE));
700ae700: 680a         	ldr	r2, [r1]
700ae702: 9b03         	ldr	r3, [sp, #0xc]
700ae704: f003 030f    	and	r3, r3, #0xf
700ae708: eb02 1243    	add.w	r2, r2, r3, lsl #5
700ae70c: f202 4204    	addw	r2, r2, #0x404
700ae710: 9202         	str	r2, [sp, #0x8]
;         *addr = 0xFFFFFFFFu;
700ae712: 9a02         	ldr	r2, [sp, #0x8]
700ae714: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(i*INTERRUPT_VALUE));
700ae716: 6808         	ldr	r0, [r1]
700ae718: 9a03         	ldr	r2, [sp, #0xc]
700ae71a: f002 020f    	and	r2, r2, #0xf
700ae71e: eb00 1042    	add.w	r0, r0, r2, lsl #5
700ae722: f200 401c    	addw	r0, r0, #0x41c
700ae726: 9002         	str	r0, [sp, #0x8]
;         *addr = 0x0u;
700ae728: 9a02         	ldr	r2, [sp, #0x8]
700ae72a: 2000         	movs	r0, #0x0
700ae72c: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_MAP(i*INTERRUPT_VALUE));
700ae72e: 6809         	ldr	r1, [r1]
700ae730: 9a03         	ldr	r2, [sp, #0xc]
700ae732: f002 020f    	and	r2, r2, #0xf
700ae736: eb01 1142    	add.w	r1, r1, r2, lsl #5
700ae73a: f501 6183    	add.w	r1, r1, #0x418
700ae73e: 9102         	str	r1, [sp, #0x8]
;         *addr = 0x0u;
700ae740: 9902         	ldr	r1, [sp, #0x8]
700ae742: 6008         	str	r0, [r1]
;     }
700ae744: e7ff         	b	0x700ae746 <HwiP_init+0xf6> @ imm = #-0x2
;     for(i=0; i<(HwiP_MAX_INTERRUPTS/INTERRUPT_VALUE); i++)
700ae746: 9803         	ldr	r0, [sp, #0xc]
700ae748: 3001         	adds	r0, #0x1
700ae74a: 9003         	str	r0, [sp, #0xc]
700ae74c: e7c3         	b	0x700ae6d6 <HwiP_init+0x86> @ imm = #-0x7a
;         gdummy = HwiP_getIRQVecAddr();
700ae74e: f000 f817    	bl	0x700ae780 <HwiP_getIRQVecAddr> @ imm = #0x2e
700ae752: f644 418c    	movw	r1, #0x4c8c
700ae756: f2c7 0108    	movt	r1, #0x7008
700ae75a: 9100         	str	r1, [sp]
700ae75c: 6008         	str	r0, [r1]
;         gdummy = HwiP_getFIQVecAddr();
700ae75e: f000 f81f    	bl	0x700ae7a0 <HwiP_getFIQVecAddr> @ imm = #0x3e
700ae762: 9900         	ldr	r1, [sp]
700ae764: 6008         	str	r0, [r1]
700ae766: 2000         	movs	r0, #0x0
;         HwiP_ackIRQ(0);
700ae768: 9001         	str	r0, [sp, #0x4]
700ae76a: f000 f829    	bl	0x700ae7c0 <HwiP_ackIRQ> @ imm = #0x52
700ae76e: 9801         	ldr	r0, [sp, #0x4]
;         HwiP_ackFIQ(0);
700ae770: f000 f836    	bl	0x700ae7e0 <HwiP_ackFIQ> @ imm = #0x6c
;     HwiP_enableVIC();
700ae774: f000 eb48    	blx	0x700aee08 <HwiP_enableVIC> @ imm = #0x690
;     HwiP_enableFIQ();
700ae778: f000 eb3a    	blx	0x700aedf0 <HwiP_enableFIQ> @ imm = #0x674
; }
700ae77c: b004         	add	sp, #0x10
700ae77e: bd80         	pop	{r7, pc}

700ae780 <HwiP_getIRQVecAddr>:
; {
700ae780: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700ae782: f640 509c    	movw	r0, #0xd9c
700ae786: f2c7 000b    	movt	r0, #0x700b
700ae78a: 6800         	ldr	r0, [r0]
700ae78c: 3018         	adds	r0, #0x18
700ae78e: 9000         	str	r0, [sp]
;     return *addr;
700ae790: 9800         	ldr	r0, [sp]
700ae792: 6800         	ldr	r0, [r0]
700ae794: b001         	add	sp, #0x4
700ae796: 4770         	bx	lr
700ae798: bf00         	nop
700ae79a: bf00         	nop
700ae79c: bf00         	nop
700ae79e: bf00         	nop

700ae7a0 <HwiP_getFIQVecAddr>:
; {
700ae7a0: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700ae7a2: f640 509c    	movw	r0, #0xd9c
700ae7a6: f2c7 000b    	movt	r0, #0x700b
700ae7aa: 6800         	ldr	r0, [r0]
700ae7ac: 301c         	adds	r0, #0x1c
700ae7ae: 9000         	str	r0, [sp]
;     return *addr;
700ae7b0: 9800         	ldr	r0, [sp]
700ae7b2: 6800         	ldr	r0, [r0]
700ae7b4: b001         	add	sp, #0x4
700ae7b6: 4770         	bx	lr
700ae7b8: bf00         	nop
700ae7ba: bf00         	nop
700ae7bc: bf00         	nop
700ae7be: bf00         	nop

700ae7c0 <HwiP_ackIRQ>:
; {
700ae7c0: b082         	sub	sp, #0x8
700ae7c2: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700ae7c4: f640 509c    	movw	r0, #0xd9c
700ae7c8: f2c7 000b    	movt	r0, #0x700b
700ae7cc: 6800         	ldr	r0, [r0]
700ae7ce: 3018         	adds	r0, #0x18
700ae7d0: 9000         	str	r0, [sp]
;     *addr= intNum;
700ae7d2: 9801         	ldr	r0, [sp, #0x4]
700ae7d4: 9900         	ldr	r1, [sp]
700ae7d6: 6008         	str	r0, [r1]
; }
700ae7d8: b002         	add	sp, #0x8
700ae7da: 4770         	bx	lr
700ae7dc: bf00         	nop
700ae7de: bf00         	nop

700ae7e0 <HwiP_ackFIQ>:
; {
700ae7e0: b082         	sub	sp, #0x8
700ae7e2: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700ae7e4: f640 509c    	movw	r0, #0xd9c
700ae7e8: f2c7 000b    	movt	r0, #0x700b
700ae7ec: 6800         	ldr	r0, [r0]
700ae7ee: 301c         	adds	r0, #0x1c
700ae7f0: 9000         	str	r0, [sp]
;     *addr= intNum;
700ae7f2: 9801         	ldr	r0, [sp, #0x4]
700ae7f4: 9900         	ldr	r1, [sp]
700ae7f6: 6008         	str	r0, [r1]
; }
700ae7f8: b002         	add	sp, #0x8
700ae7fa: 4770         	bx	lr
700ae7fc: bf00         	nop
700ae7fe: bf00         	nop

700ae800 <HwiP_inISR>:
; {
700ae800: b580         	push	{r7, lr}
700ae802: b082         	sub	sp, #0x8
;     uint32_t mode = (HwiP_getCPSR() & 0x1FU);
700ae804: f000 eb10    	blx	0x700aee28 <HwiP_getCPSR> @ imm = #0x620
700ae808: f000 001f    	and	r0, r0, #0x1f
700ae80c: 9001         	str	r0, [sp, #0x4]
700ae80e: 2000         	movs	r0, #0x0
;     uint32_t result =0;
700ae810: 9000         	str	r0, [sp]
;     if(mode != ARMV7R_SYSTEM_MODE)
700ae812: 9801         	ldr	r0, [sp, #0x4]
700ae814: 281f         	cmp	r0, #0x1f
700ae816: d003         	beq	0x700ae820 <HwiP_inISR+0x20> @ imm = #0x6
700ae818: e7ff         	b	0x700ae81a <HwiP_inISR+0x1a> @ imm = #-0x2
700ae81a: 2001         	movs	r0, #0x1
;          result= 1;
700ae81c: 9000         	str	r0, [sp]
;     }
700ae81e: e7ff         	b	0x700ae820 <HwiP_inISR+0x20> @ imm = #-0x2
;     return result;
700ae820: 9800         	ldr	r0, [sp]
700ae822: b002         	add	sp, #0x8
700ae824: bd80         	pop	{r7, pc}
		...
700ae82e: 0000         	movs	r0, r0

700ae830 <HwiP_irq_handler_c>:
; {
700ae830: b580         	push	{r7, lr}
700ae832: b086         	sub	sp, #0x18
700ae834: a804         	add	r0, sp, #0x10
;     status = HwiP_getIRQ(&intNum);
700ae836: f000 f843    	bl	0x700ae8c0 <HwiP_getIRQ> @ imm = #0x86
700ae83a: 9005         	str	r0, [sp, #0x14]
;     if(status==SystemP_SUCCESS)
700ae83c: 9805         	ldr	r0, [sp, #0x14]
700ae83e: bb78         	cbnz	r0, 0x700ae8a0 <HwiP_irq_handler_c+0x70> @ imm = #0x5e
700ae840: e7ff         	b	0x700ae842 <HwiP_irq_handler_c+0x12> @ imm = #-0x2
;         uint32_t isPulse = HwiP_isPulse(intNum);
700ae842: 9804         	ldr	r0, [sp, #0x10]
700ae844: f000 f864    	bl	0x700ae910 <HwiP_isPulse> @ imm = #0xc8
700ae848: 9003         	str	r0, [sp, #0xc]
;         if(isPulse != 0U)
700ae84a: 9803         	ldr	r0, [sp, #0xc]
700ae84c: b120         	cbz	r0, 0x700ae858 <HwiP_irq_handler_c+0x28> @ imm = #0x8
700ae84e: e7ff         	b	0x700ae850 <HwiP_irq_handler_c+0x20> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700ae850: 9804         	ldr	r0, [sp, #0x10]
700ae852: f7ff fd6d    	bl	0x700ae330 <HwiP_clearInt> @ imm = #-0x526
;         }
700ae856: e7ff         	b	0x700ae858 <HwiP_irq_handler_c+0x28> @ imm = #-0x2
;         isr = gHwiCtrl.isr[intNum];
700ae858: 9904         	ldr	r1, [sp, #0x10]
700ae85a: f240 0000    	movw	r0, #0x0
700ae85e: f2c7 0008    	movt	r0, #0x7008
700ae862: f850 1021    	ldr.w	r1, [r0, r1, lsl #2]
700ae866: 9102         	str	r1, [sp, #0x8]
;         args = gHwiCtrl.isrArgs[intNum];
700ae868: 9904         	ldr	r1, [sp, #0x10]
700ae86a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ae86e: f8d0 0800    	ldr.w	r0, [r0, #0x800]
700ae872: 9001         	str	r0, [sp, #0x4]
;         HwiP_enable();
700ae874: f000 eab4    	blx	0x700aede0 <HwiP_enable> @ imm = #0x568
;         if(isr!=NULL)
700ae878: 9802         	ldr	r0, [sp, #0x8]
700ae87a: b120         	cbz	r0, 0x700ae886 <HwiP_irq_handler_c+0x56> @ imm = #0x8
700ae87c: e7ff         	b	0x700ae87e <HwiP_irq_handler_c+0x4e> @ imm = #-0x2
;             isr(args);
700ae87e: 9902         	ldr	r1, [sp, #0x8]
700ae880: 9801         	ldr	r0, [sp, #0x4]
700ae882: 4788         	blx	r1
;         }
700ae884: e7ff         	b	0x700ae886 <HwiP_irq_handler_c+0x56> @ imm = #-0x2
;         (void)HwiP_disable();
700ae886: f000 ea9c    	blx	0x700aedc0 <HwiP_disable> @ imm = #0x538
;         if(isPulse == 0U)
700ae88a: 9803         	ldr	r0, [sp, #0xc]
700ae88c: b920         	cbnz	r0, 0x700ae898 <HwiP_irq_handler_c+0x68> @ imm = #0x8
700ae88e: e7ff         	b	0x700ae890 <HwiP_irq_handler_c+0x60> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700ae890: 9804         	ldr	r0, [sp, #0x10]
700ae892: f7ff fd4d    	bl	0x700ae330 <HwiP_clearInt> @ imm = #-0x566
;         }
700ae896: e7ff         	b	0x700ae898 <HwiP_irq_handler_c+0x68> @ imm = #-0x2
;         HwiP_ackIRQ(intNum);
700ae898: 9804         	ldr	r0, [sp, #0x10]
700ae89a: f000 f859    	bl	0x700ae950 <HwiP_ackIRQ> @ imm = #0xb2
;     }
700ae89e: e00c         	b	0x700ae8ba <HwiP_irq_handler_c+0x8a> @ imm = #0x18
;         gHwiCtrl.spuriousIRQCount++;
700ae8a0: f240 0100    	movw	r1, #0x0
700ae8a4: f2c7 0108    	movt	r1, #0x7008
700ae8a8: f44f 5280    	mov.w	r2, #0x1000
700ae8ac: 5888         	ldr	r0, [r1, r2]
700ae8ae: 3001         	adds	r0, #0x1
700ae8b0: 5088         	str	r0, [r1, r2]
700ae8b2: 2000         	movs	r0, #0x0
;         HwiP_ackIRQ(0);
700ae8b4: f000 f84c    	bl	0x700ae950 <HwiP_ackIRQ> @ imm = #0x98
700ae8b8: e7ff         	b	0x700ae8ba <HwiP_irq_handler_c+0x8a> @ imm = #-0x2
; }
700ae8ba: b006         	add	sp, #0x18
700ae8bc: bd80         	pop	{r7, pc}
700ae8be: bf00         	nop

700ae8c0 <HwiP_getIRQ>:
; {
700ae8c0: b084         	sub	sp, #0x10
700ae8c2: 9003         	str	r0, [sp, #0xc]
700ae8c4: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700ae8c8: 9001         	str	r0, [sp, #0x4]
;     *intNum = 0;
700ae8ca: 9903         	ldr	r1, [sp, #0xc]
700ae8cc: 2000         	movs	r0, #0x0
700ae8ce: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_ACTIRQ);
700ae8d0: f640 509c    	movw	r0, #0xd9c
700ae8d4: f2c7 000b    	movt	r0, #0x700b
700ae8d8: 6800         	ldr	r0, [r0]
700ae8da: 3020         	adds	r0, #0x20
700ae8dc: 9002         	str	r0, [sp, #0x8]
;     value = *addr;
700ae8de: 9802         	ldr	r0, [sp, #0x8]
700ae8e0: 6800         	ldr	r0, [r0]
700ae8e2: 9000         	str	r0, [sp]
;     if((value & 0x80000000U) != 0U)
700ae8e4: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ae8e8: 0600         	lsls	r0, r0, #0x18
700ae8ea: 2800         	cmp	r0, #0x0
700ae8ec: d508         	bpl	0x700ae900 <HwiP_getIRQ+0x40> @ imm = #0x10
700ae8ee: e7ff         	b	0x700ae8f0 <HwiP_getIRQ+0x30> @ imm = #-0x2
;         *intNum = (value & (HwiP_MAX_INTERRUPTS-1U));
700ae8f0: 9800         	ldr	r0, [sp]
700ae8f2: f36f 205f    	bfc	r0, #9, #23
700ae8f6: 9903         	ldr	r1, [sp, #0xc]
700ae8f8: 6008         	str	r0, [r1]
700ae8fa: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700ae8fc: 9001         	str	r0, [sp, #0x4]
;     }
700ae8fe: e7ff         	b	0x700ae900 <HwiP_getIRQ+0x40> @ imm = #-0x2
;     return status;
700ae900: 9801         	ldr	r0, [sp, #0x4]
700ae902: b004         	add	sp, #0x10
700ae904: 4770         	bx	lr
700ae906: bf00         	nop
700ae908: bf00         	nop
700ae90a: bf00         	nop
700ae90c: bf00         	nop
700ae90e: bf00         	nop

700ae910 <HwiP_isPulse>:
; {
700ae910: b083         	sub	sp, #0xc
700ae912: 9002         	str	r0, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(intNum));
700ae914: f640 509c    	movw	r0, #0xd9c
700ae918: f2c7 000b    	movt	r0, #0x700b
700ae91c: 6801         	ldr	r1, [r0]
700ae91e: 9802         	ldr	r0, [sp, #0x8]
700ae920: f400 70f0    	and	r0, r0, #0x1e0
700ae924: 4408         	add	r0, r1
700ae926: f200 401c    	addw	r0, r0, #0x41c
700ae92a: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700ae92c: 9802         	ldr	r0, [sp, #0x8]
700ae92e: f000 001f    	and	r0, r0, #0x1f
700ae932: 9000         	str	r0, [sp]
;     return ((*addr >> bitPos) & 0x1u );
700ae934: 9801         	ldr	r0, [sp, #0x4]
700ae936: 6800         	ldr	r0, [r0]
700ae938: 9900         	ldr	r1, [sp]
700ae93a: 40c8         	lsrs	r0, r1
700ae93c: f000 0001    	and	r0, r0, #0x1
700ae940: b003         	add	sp, #0xc
700ae942: 4770         	bx	lr
700ae944: bf00         	nop
700ae946: bf00         	nop
700ae948: bf00         	nop
700ae94a: bf00         	nop
700ae94c: bf00         	nop
700ae94e: bf00         	nop

700ae950 <HwiP_ackIRQ>:
; {
700ae950: b082         	sub	sp, #0x8
700ae952: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700ae954: f640 509c    	movw	r0, #0xd9c
700ae958: f2c7 000b    	movt	r0, #0x700b
700ae95c: 6800         	ldr	r0, [r0]
700ae95e: 3018         	adds	r0, #0x18
700ae960: 9000         	str	r0, [sp]
;     *addr= intNum;
700ae962: 9801         	ldr	r0, [sp, #0x4]
700ae964: 9900         	ldr	r1, [sp]
700ae966: 6008         	str	r0, [r1]
; }
700ae968: b002         	add	sp, #0x8
700ae96a: 4770         	bx	lr
700ae96c: bf00         	nop
700ae96e: bf00         	nop

700ae970 <HwiP_fiq_handler>:
; {
700ae970: b5df         	push	{r0, r1, r2, r3, r4, r6, r7, lr}
700ae972: af06         	add	r7, sp, #0x18
700ae974: b086         	sub	sp, #0x18
700ae976: 466c         	mov	r4, sp
700ae978: f36f 0402    	bfc	r4, #0, #3
700ae97c: 46a5         	mov	sp, r4
;     gdummy = HwiP_getFIQVecAddr();
700ae97e: f000 f867    	bl	0x700aea50 <HwiP_getFIQVecAddr> @ imm = #0xce
700ae982: f244 188c    	movw	r8, #0x418c
700ae986: f2c7 0808    	movt	r8, #0x7008
700ae98a: f8c8 0000    	str.w	r0, [r8]
700ae98e: a804         	add	r0, sp, #0x10
;     status = HwiP_getFIQ(&intNum);
700ae990: f000 f86e    	bl	0x700aea70 <HwiP_getFIQ> @ imm = #0xdc
700ae994: 9005         	str	r0, [sp, #0x14]
;     if(status==SystemP_SUCCESS)
700ae996: f8dd 8014    	ldr.w	r8, [sp, #0x14]
700ae99a: f1b8 0f00    	cmp.w	r8, #0x0
700ae99e: d13b         	bne	0x700aea18 <HwiP_fiq_handler+0xa8> @ imm = #0x76
700ae9a0: e7ff         	b	0x700ae9a2 <HwiP_fiq_handler+0x32> @ imm = #-0x2
;         uint32_t isPulse = HwiP_isPulse(intNum);
700ae9a2: 9804         	ldr	r0, [sp, #0x10]
700ae9a4: f7ff ffb4    	bl	0x700ae910 <HwiP_isPulse> @ imm = #-0x98
700ae9a8: 9003         	str	r0, [sp, #0xc]
;         if(isPulse != 0U)
700ae9aa: f8dd 800c    	ldr.w	r8, [sp, #0xc]
700ae9ae: f1b8 0f00    	cmp.w	r8, #0x0
700ae9b2: d004         	beq	0x700ae9be <HwiP_fiq_handler+0x4e> @ imm = #0x8
700ae9b4: e7ff         	b	0x700ae9b6 <HwiP_fiq_handler+0x46> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700ae9b6: 9804         	ldr	r0, [sp, #0x10]
700ae9b8: f7ff fcba    	bl	0x700ae330 <HwiP_clearInt> @ imm = #-0x68c
;         }
700ae9bc: e7ff         	b	0x700ae9be <HwiP_fiq_handler+0x4e> @ imm = #-0x2
;         isr = gHwiCtrl.isr[intNum];
700ae9be: f8dd 9010    	ldr.w	r9, [sp, #0x10]
700ae9c2: f240 0800    	movw	r8, #0x0
700ae9c6: f2c7 0808    	movt	r8, #0x7008
700ae9ca: f858 9029    	ldr.w	r9, [r8, r9, lsl #2]
700ae9ce: f8cd 9008    	str.w	r9, [sp, #0x8]
;         args = gHwiCtrl.isrArgs[intNum];
700ae9d2: f8dd 9010    	ldr.w	r9, [sp, #0x10]
700ae9d6: eb08 0889    	add.w	r8, r8, r9, lsl #2
700ae9da: f8d8 8800    	ldr.w	r8, [r8, #0x800]
700ae9de: f8cd 8004    	str.w	r8, [sp, #0x4]
;         if(isr!=NULL)
700ae9e2: f8dd 8008    	ldr.w	r8, [sp, #0x8]
700ae9e6: f1b8 0f00    	cmp.w	r8, #0x0
700ae9ea: d005         	beq	0x700ae9f8 <HwiP_fiq_handler+0x88> @ imm = #0xa
700ae9ec: e7ff         	b	0x700ae9ee <HwiP_fiq_handler+0x7e> @ imm = #-0x2
;             isr(args);
700ae9ee: f8dd 8008    	ldr.w	r8, [sp, #0x8]
700ae9f2: 9801         	ldr	r0, [sp, #0x4]
700ae9f4: 47c0         	blx	r8
;         }
700ae9f6: e7ff         	b	0x700ae9f8 <HwiP_fiq_handler+0x88> @ imm = #-0x2
;         (void)HwiP_disableFIQ();
700ae9f8: f000 e9ea    	blx	0x700aedd0 <HwiP_disableFIQ> @ imm = #0x3d4
;         if(isPulse == 0U)
700ae9fc: f8dd 800c    	ldr.w	r8, [sp, #0xc]
700aea00: f1b8 0f00    	cmp.w	r8, #0x0
700aea04: d104         	bne	0x700aea10 <HwiP_fiq_handler+0xa0> @ imm = #0x8
700aea06: e7ff         	b	0x700aea08 <HwiP_fiq_handler+0x98> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700aea08: 9804         	ldr	r0, [sp, #0x10]
700aea0a: f7ff fc91    	bl	0x700ae330 <HwiP_clearInt> @ imm = #-0x6de
;         }
700aea0e: e7ff         	b	0x700aea10 <HwiP_fiq_handler+0xa0> @ imm = #-0x2
;         HwiP_ackFIQ(intNum);
700aea10: 9804         	ldr	r0, [sp, #0x10]
700aea12: f000 f855    	bl	0x700aeac0 <HwiP_ackFIQ> @ imm = #0xaa
;     }
700aea16: e00f         	b	0x700aea38 <HwiP_fiq_handler+0xc8> @ imm = #0x1e
;         gHwiCtrl.spuriousFIQCount++;
700aea18: f240 0900    	movw	r9, #0x0
700aea1c: f2c7 0908    	movt	r9, #0x7008
700aea20: f241 0a04    	movw	r10, #0x1004
700aea24: f859 800a    	ldr.w	r8, [r9, r10]
700aea28: f108 0801    	add.w	r8, r8, #0x1
700aea2c: f849 800a    	str.w	r8, [r9, r10]
700aea30: 2000         	movs	r0, #0x0
;         HwiP_ackFIQ(0);
700aea32: f000 f845    	bl	0x700aeac0 <HwiP_ackFIQ> @ imm = #0x8a
700aea36: e7ff         	b	0x700aea38 <HwiP_fiq_handler+0xc8> @ imm = #-0x2
; }
700aea38: f1a7 0418    	sub.w	r4, r7, #0x18
700aea3c: 46a5         	mov	sp, r4
700aea3e: e8bd 40df    	pop.w	{r0, r1, r2, r3, r4, r6, r7, lr}
700aea42: f3de 8f04    	subs	pc, lr, #0x4
700aea46: bf00         	nop
700aea48: bf00         	nop
700aea4a: bf00         	nop
700aea4c: bf00         	nop
700aea4e: bf00         	nop

700aea50 <HwiP_getFIQVecAddr>:
; {
700aea50: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700aea52: f640 509c    	movw	r0, #0xd9c
700aea56: f2c7 000b    	movt	r0, #0x700b
700aea5a: 6800         	ldr	r0, [r0]
700aea5c: 301c         	adds	r0, #0x1c
700aea5e: 9000         	str	r0, [sp]
;     return *addr;
700aea60: 9800         	ldr	r0, [sp]
700aea62: 6800         	ldr	r0, [r0]
700aea64: b001         	add	sp, #0x4
700aea66: 4770         	bx	lr
700aea68: bf00         	nop
700aea6a: bf00         	nop
700aea6c: bf00         	nop
700aea6e: bf00         	nop

700aea70 <HwiP_getFIQ>:
; {
700aea70: b084         	sub	sp, #0x10
700aea72: 9003         	str	r0, [sp, #0xc]
700aea74: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700aea78: 9001         	str	r0, [sp, #0x4]
;     *intNum = 0;
700aea7a: 9903         	ldr	r1, [sp, #0xc]
700aea7c: 2000         	movs	r0, #0x0
700aea7e: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_ACTFIQ);
700aea80: f640 509c    	movw	r0, #0xd9c
700aea84: f2c7 000b    	movt	r0, #0x700b
700aea88: 6800         	ldr	r0, [r0]
700aea8a: 3024         	adds	r0, #0x24
700aea8c: 9002         	str	r0, [sp, #0x8]
;     value = *addr;
700aea8e: 9802         	ldr	r0, [sp, #0x8]
700aea90: 6800         	ldr	r0, [r0]
700aea92: 9000         	str	r0, [sp]
;     if((value & 0x80000000U) != 0U)
700aea94: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aea98: 0600         	lsls	r0, r0, #0x18
700aea9a: 2800         	cmp	r0, #0x0
700aea9c: d508         	bpl	0x700aeab0 <HwiP_getFIQ+0x40> @ imm = #0x10
700aea9e: e7ff         	b	0x700aeaa0 <HwiP_getFIQ+0x30> @ imm = #-0x2
;         *intNum = (value & 0x3FFU);
700aeaa0: 9800         	ldr	r0, [sp]
700aeaa2: f36f 209f    	bfc	r0, #10, #22
700aeaa6: 9903         	ldr	r1, [sp, #0xc]
700aeaa8: 6008         	str	r0, [r1]
700aeaaa: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700aeaac: 9001         	str	r0, [sp, #0x4]
;     }
700aeaae: e7ff         	b	0x700aeab0 <HwiP_getFIQ+0x40> @ imm = #-0x2
;     return status;
700aeab0: 9801         	ldr	r0, [sp, #0x4]
700aeab2: b004         	add	sp, #0x10
700aeab4: 4770         	bx	lr
700aeab6: bf00         	nop
700aeab8: bf00         	nop
700aeaba: bf00         	nop
700aeabc: bf00         	nop
700aeabe: bf00         	nop

700aeac0 <HwiP_ackFIQ>:
; {
700aeac0: b082         	sub	sp, #0x8
700aeac2: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700aeac4: f640 509c    	movw	r0, #0xd9c
700aeac8: f2c7 000b    	movt	r0, #0x700b
700aeacc: 6800         	ldr	r0, [r0]
700aeace: 301c         	adds	r0, #0x1c
700aead0: 9000         	str	r0, [sp]
;     *addr= intNum;
700aead2: 9801         	ldr	r0, [sp, #0x4]
700aead4: 9900         	ldr	r1, [sp]
700aead6: 6008         	str	r0, [r1]
; }
700aead8: b002         	add	sp, #0x8
700aeada: 4770         	bx	lr
700aeadc: bf00         	nop
700aeade: bf00         	nop

700aeae0 <HwiP_reserved_handler>:
; {
700aeae0: b5d0         	push	{r4, r6, r7, lr}
700aeae2: af02         	add	r7, sp, #0x8
700aeae4: b082         	sub	sp, #0x8
700aeae6: 466c         	mov	r4, sp
700aeae8: f36f 0402    	bfc	r4, #0, #3
700aeaec: 46a5         	mov	sp, r4
700aeaee: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700aeaf2: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U) { ; }
700aeaf6: e7ff         	b	0x700aeaf8 <HwiP_reserved_handler+0x18> @ imm = #-0x2
700aeaf8: f8dd e004    	ldr.w	lr, [sp, #0x4]
700aeafc: f1be 0f00    	cmp.w	lr, #0x0
700aeb00: d001         	beq	0x700aeb06 <HwiP_reserved_handler+0x26> @ imm = #0x2
700aeb02: e7ff         	b	0x700aeb04 <HwiP_reserved_handler+0x24> @ imm = #-0x2
700aeb04: e7f8         	b	0x700aeaf8 <HwiP_reserved_handler+0x18> @ imm = #-0x10
; }
700aeb06: f1a7 0408    	sub.w	r4, r7, #0x8
700aeb0a: 46a5         	mov	sp, r4
700aeb0c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700aeb10: f3de 8f00    	subs	pc, lr, #0x0
700aeb14: bf00         	nop
700aeb16: bf00         	nop
700aeb18: bf00         	nop
700aeb1a: bf00         	nop
700aeb1c: bf00         	nop
700aeb1e: bf00         	nop

700aeb20 <HwiP_undefined_handler>:
; {
700aeb20: b5d0         	push	{r4, r6, r7, lr}
700aeb22: af02         	add	r7, sp, #0x8
700aeb24: b082         	sub	sp, #0x8
700aeb26: 466c         	mov	r4, sp
700aeb28: f36f 0402    	bfc	r4, #0, #3
700aeb2c: 46a5         	mov	sp, r4
700aeb2e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700aeb32: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U){  ; }
700aeb36: e7ff         	b	0x700aeb38 <HwiP_undefined_handler+0x18> @ imm = #-0x2
700aeb38: f8dd e004    	ldr.w	lr, [sp, #0x4]
700aeb3c: f1be 0f00    	cmp.w	lr, #0x0
700aeb40: d001         	beq	0x700aeb46 <HwiP_undefined_handler+0x26> @ imm = #0x2
700aeb42: e7ff         	b	0x700aeb44 <HwiP_undefined_handler+0x24> @ imm = #-0x2
700aeb44: e7f8         	b	0x700aeb38 <HwiP_undefined_handler+0x18> @ imm = #-0x10
; }
700aeb46: f1a7 0408    	sub.w	r4, r7, #0x8
700aeb4a: 46a5         	mov	sp, r4
700aeb4c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700aeb50: f3de 8f00    	subs	pc, lr, #0x0
700aeb54: bf00         	nop
700aeb56: bf00         	nop
700aeb58: bf00         	nop
700aeb5a: bf00         	nop
700aeb5c: bf00         	nop
700aeb5e: bf00         	nop

700aeb60 <HwiP_prefetch_abort_handler>:
; {
700aeb60: b5d0         	push	{r4, r6, r7, lr}
700aeb62: af02         	add	r7, sp, #0x8
700aeb64: b082         	sub	sp, #0x8
700aeb66: 466c         	mov	r4, sp
700aeb68: f36f 0402    	bfc	r4, #0, #3
700aeb6c: 46a5         	mov	sp, r4
700aeb6e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700aeb72: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U)  { ;}
700aeb76: e7ff         	b	0x700aeb78 <HwiP_prefetch_abort_handler+0x18> @ imm = #-0x2
700aeb78: f8dd e004    	ldr.w	lr, [sp, #0x4]
700aeb7c: f1be 0f00    	cmp.w	lr, #0x0
700aeb80: d001         	beq	0x700aeb86 <HwiP_prefetch_abort_handler+0x26> @ imm = #0x2
700aeb82: e7ff         	b	0x700aeb84 <HwiP_prefetch_abort_handler+0x24> @ imm = #-0x2
700aeb84: e7f8         	b	0x700aeb78 <HwiP_prefetch_abort_handler+0x18> @ imm = #-0x10
; }
700aeb86: f1a7 0408    	sub.w	r4, r7, #0x8
700aeb8a: 46a5         	mov	sp, r4
700aeb8c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700aeb90: f3de 8f04    	subs	pc, lr, #0x4
700aeb94: bf00         	nop
700aeb96: bf00         	nop
700aeb98: bf00         	nop
700aeb9a: bf00         	nop
700aeb9c: bf00         	nop
700aeb9e: bf00         	nop

700aeba0 <HwiP_data_abort_handler_c>:
; {
700aeba0: b5d0         	push	{r4, r6, r7, lr}
700aeba2: af02         	add	r7, sp, #0x8
700aeba4: b082         	sub	sp, #0x8
700aeba6: 466c         	mov	r4, sp
700aeba8: f36f 0402    	bfc	r4, #0, #3
700aebac: 46a5         	mov	sp, r4
700aebae: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700aebb2: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U){ ; }
700aebb6: e7ff         	b	0x700aebb8 <HwiP_data_abort_handler_c+0x18> @ imm = #-0x2
700aebb8: f8dd e004    	ldr.w	lr, [sp, #0x4]
700aebbc: f1be 0f00    	cmp.w	lr, #0x0
700aebc0: d001         	beq	0x700aebc6 <HwiP_data_abort_handler_c+0x26> @ imm = #0x2
700aebc2: e7ff         	b	0x700aebc4 <HwiP_data_abort_handler_c+0x24> @ imm = #-0x2
700aebc4: e7f8         	b	0x700aebb8 <HwiP_data_abort_handler_c+0x18> @ imm = #-0x10
; }
700aebc6: f1a7 0408    	sub.w	r4, r7, #0x8
700aebca: 46a5         	mov	sp, r4
700aebcc: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700aebd0: f3de 8f04    	subs	pc, lr, #0x4

700aebd4 <vPortRestoreTaskContext>:
;         CPS     #SYS_MODE
700aebd4: f102001f     	cps	#0x1f
;         portRESTORE_CONTEXT
700aebd8: e59f01c8     	ldr	r0, [pc, #0x1c8]        @ 0x700aeda8 <pxCurrentTCBConst>
700aebdc: e5901000     	ldr	r1, [r0]
700aebe0: e591d000     	ldr	sp, [r1]
700aebe4: e59f01c0     	ldr	r0, [pc, #0x1c0]        @ 0x700aedac <ulPortTaskHasFPUContextConst>
700aebe8: e49d1004     	ldr	r1, [sp], #4
700aebec: e5801000     	str	r1, [r0]
700aebf0: e3510000     	cmp	r1, #0
700aebf4: 149d0004     	ldrne	r0, [sp], #4
700aebf8: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700aebfc: 1ee10a10     	vmsrne	fpscr, r0
700aec00: f57ff01f     	clrex
700aec04: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700aec08: f8bd0a00     	rfeia	sp!

700aec0c <HwiP_svc_handler>:
;         portSAVE_CONTEXT
700aec0c: f96d051f     	srsdb	sp!, #0x1f
700aec10: f102001f     	cps	#0x1f
700aec14: e92d5fff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700aec18: e59f218c     	ldr	r2, [pc, #0x18c]        @ 0x700aedac <ulPortTaskHasFPUContextConst>
700aec1c: e5923000     	ldr	r3, [r2]
700aec20: e3530000     	cmp	r3, #0
700aec24: 1ef11a10     	vmrsne	r1, fpscr
700aec28: 1d2d0b20     	vpushne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700aec2c: 152d1004     	strne	r1, [sp, #-0x4]!
700aec30: e52d3004     	str	r3, [sp, #-0x4]!
700aec34: e59f016c     	ldr	r0, [pc, #0x16c]        @ 0x700aeda8 <pxCurrentTCBConst>
700aec38: e5901000     	ldr	r1, [r0]
700aec3c: e581d000     	str	sp, [r1]
;         LDR     R0, vTaskSwitchContextConst
700aec40: e59f0168     	ldr	r0, [pc, #0x168]        @ 0x700aedb0 <vTaskSwitchContextConst>
;         BLX     R0
700aec44: e12fff30     	blx	r0
;         portRESTORE_CONTEXT
700aec48: e59f0158     	ldr	r0, [pc, #0x158]        @ 0x700aeda8 <pxCurrentTCBConst>
700aec4c: e5901000     	ldr	r1, [r0]
700aec50: e591d000     	ldr	sp, [r1]
700aec54: e59f0150     	ldr	r0, [pc, #0x150]        @ 0x700aedac <ulPortTaskHasFPUContextConst>
700aec58: e49d1004     	ldr	r1, [sp], #4
700aec5c: e5801000     	str	r1, [r0]
700aec60: e3510000     	cmp	r1, #0
700aec64: 149d0004     	ldrne	r0, [sp], #4
700aec68: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700aec6c: 1ee10a10     	vmsrne	fpscr, r0
700aec70: f57ff01f     	clrex
700aec74: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700aec78: f8bd0a00     	rfeia	sp!

700aec7c <HwiP_irq_handler>:
;         SUB             lr, lr, #4
700aec7c: e24ee004     	sub	lr, lr, #4
;         PUSH    {lr}
700aec80: e52de004     	str	lr, [sp, #-0x4]!
;         MRS     lr, SPSR
700aec84: e14fe000     	mrs	lr, spsr
;         PUSH    {lr}
700aec88: e52de004     	str	lr, [sp, #-0x4]!
;         CPS  #SVC_MODE
700aec8c: f1020013     	cps	#0x13
;         PUSH    {r0-r4, r12}
700aec90: e92d101f     	push	{r0, r1, r2, r3, r4, r12}
;         LDR     r3, ulPortInterruptNestingConst
700aec94: e59f3118     	ldr	r3, [pc, #0x118]        @ 0x700aedb4 <ulPortInterruptNestingConst>
;         LDR     r1, [r3]
700aec98: e5931000     	ldr	r1, [r3]
;         ADD     r4, r1, #1
700aec9c: e2814001     	add	r4, r1, #1
;         STR     r4, [r3]
700aeca0: e5834000     	str	r4, [r3]
;         FMRX  R0, FPSCR
700aeca4: eef10a10     	vmrs	r0, fpscr
;         VPUSH {D0-D15}
700aeca8: ed2d0b20     	vpush	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
;         PUSH  {R0}
700aecac: e52d0004     	str	r0, [sp, #-0x4]!
;         MOV     r2, sp
700aecb0: e1a0200d     	mov	r2, sp
;         AND     r2, r2, #4
700aecb4: e2022004     	and	r2, r2, #4
;         SUB     sp, sp, r2
700aecb8: e04dd002     	sub	sp, sp, r2
;         PUSH    {r0-r4, lr}
700aecbc: e92d401f     	push	{r0, r1, r2, r3, r4, lr}
;         LDR     r1, vApplicationIRQHandlerConst
700aecc0: e59f10f0     	ldr	r1, [pc, #0xf0]         @ 0x700aedb8 <vApplicationIRQHandlerConst>
;         BLX     r1
700aecc4: e12fff31     	blx	r1
;         POP     {r0-r4, lr}
700aecc8: e8bd401f     	pop	{r0, r1, r2, r3, r4, lr}
;         ADD     sp, sp, r2
700aeccc: e08dd002     	add	sp, sp, r2
;         CPSID   i
700aecd0: f10c0080     	cpsid	i
;         DSB
700aecd4: f57ff04f     	dsb	sy
;         ISB
700aecd8: f57ff06f     	isb	sy
;         POP   {R0}
700aecdc: e49d0004     	ldr	r0, [sp], #4
;         VPOP  {D0-D15}
700aece0: ecbd0b20     	vpop	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
;         VMSR  FPSCR, R0
700aece4: eee10a10     	vmsr	fpscr, r0
;         STR     r1, [r3]
700aece8: e5831000     	str	r1, [r3]
;         CMP     r1, #0
700aecec: e3510000     	cmp	r1, #0
;         BNE     exit_without_switch
700aecf0: 1a000003     	bne	0x700aed04 <exit_without_switch> @ imm = #0xc
;         LDR     r1, =ulPortYieldRequired
700aecf4: e59f10c0     	ldr	r1, [pc, #0xc0]         @ 0x700aedbc <vApplicationIRQHandlerConst+0x4>
;         LDR     r0, [r1]
700aecf8: e5910000     	ldr	r0, [r1]
;         CMP     r0, #0
700aecfc: e3500000     	cmp	r0, #0
;         BNE     switch_before_exit
700aed00: 1a000005     	bne	0x700aed1c <switch_before_exit> @ imm = #0x14

700aed04 <exit_without_switch>:
;         POP     {r0-r4, r12}
700aed04: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         CPS  #IRQ_MODE
700aed08: f1020012     	cps	#0x12
;         POP     {LR}
700aed0c: e49de004     	ldr	lr, [sp], #4
;         MSR     SPSR_cxsf, LR
700aed10: e16ff00e     	msr	SPSR_fsxc, lr
;         POP     {LR}
700aed14: e49de004     	ldr	lr, [sp], #4
;         MOVS    PC, LR
700aed18: e1b0f00e     	movs	pc, lr

700aed1c <switch_before_exit>:
;         MOV     r0, #0
700aed1c: e3a00000     	mov	r0, #0
;         STR     r0, [r1]
700aed20: e5810000     	str	r0, [r1]
;         POP     {r0-r4, r12}
700aed24: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         CPS  #IRQ_MODE
700aed28: f1020012     	cps	#0x12
;         POP     {LR}
700aed2c: e49de004     	ldr	lr, [sp], #4
;         MSR     SPSR_cxsf, LR
700aed30: e16ff00e     	msr	SPSR_fsxc, lr
;         POP     {LR}
700aed34: e49de004     	ldr	lr, [sp], #4
;         portSAVE_CONTEXT
700aed38: f96d051f     	srsdb	sp!, #0x1f
700aed3c: f102001f     	cps	#0x1f
700aed40: e92d5fff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700aed44: e59f2060     	ldr	r2, [pc, #0x60]         @ 0x700aedac <ulPortTaskHasFPUContextConst>
700aed48: e5923000     	ldr	r3, [r2]
700aed4c: e3530000     	cmp	r3, #0
700aed50: 1ef11a10     	vmrsne	r1, fpscr
700aed54: 1d2d0b20     	vpushne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700aed58: 152d1004     	strne	r1, [sp, #-0x4]!
700aed5c: e52d3004     	str	r3, [sp, #-0x4]!
700aed60: e59f0040     	ldr	r0, [pc, #0x40]         @ 0x700aeda8 <pxCurrentTCBConst>
700aed64: e5901000     	ldr	r1, [r0]
700aed68: e581d000     	str	sp, [r1]
;         LDR     R0, vTaskSwitchContextConst
700aed6c: e59f003c     	ldr	r0, [pc, #0x3c]         @ 0x700aedb0 <vTaskSwitchContextConst>
;         BLX     R0
700aed70: e12fff30     	blx	r0
;         portRESTORE_CONTEXT
700aed74: e59f002c     	ldr	r0, [pc, #0x2c]         @ 0x700aeda8 <pxCurrentTCBConst>
700aed78: e5901000     	ldr	r1, [r0]
700aed7c: e591d000     	ldr	sp, [r1]
700aed80: e59f0024     	ldr	r0, [pc, #0x24]         @ 0x700aedac <ulPortTaskHasFPUContextConst>
700aed84: e49d1004     	ldr	r1, [sp], #4
700aed88: e5801000     	str	r1, [r0]
700aed8c: e3510000     	cmp	r1, #0
700aed90: 149d0004     	ldrne	r0, [sp], #4
700aed94: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700aed98: 1ee10a10     	vmsrne	fpscr, r0
700aed9c: f57ff01f     	clrex
700aeda0: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700aeda4: f8bd0a00     	rfeia	sp!

700aeda8 <pxCurrentTCBConst>:
700aeda8: ac 0d 0b 70  	.word	0x700b0dac

700aedac <ulPortTaskHasFPUContextConst>:
700aedac: c4 0d 0b 70  	.word	0x700b0dc4

700aedb0 <vTaskSwitchContextConst>:
700aedb0: 41 4e 0a 70  	.word	0x700a4e41

700aedb4 <ulPortInterruptNestingConst>:
700aedb4: bc 0d 0b 70  	.word	0x700b0dbc

700aedb8 <vApplicationIRQHandlerConst>:
700aedb8: 31 e8 0a 70  	.word	0x700ae831
700aedbc: c8 0d 0b 70  	.word	0x700b0dc8

700aedc0 <HwiP_disable>:
;         mrs     r0, cpsr
700aedc0: e10f0000     	mrs	r0, apsr
;         orr     r12, r0, #0x80
700aedc4: e380c080     	orr	r12, r0, #128
;         msr     cpsr_cf, r12
700aedc8: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700aedcc: e12fff1e     	bx	lr

700aedd0 <HwiP_disableFIQ>:
;         mrs     r0, cpsr
700aedd0: e10f0000     	mrs	r0, apsr
;         orr     r12, r0, #0x40
700aedd4: e380c040     	orr	r12, r0, #64
;         msr     cpsr_cf, r12
700aedd8: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700aeddc: e12fff1e     	bx	lr

700aede0 <HwiP_enable>:
;         mrs     r0, cpsr
700aede0: e10f0000     	mrs	r0, apsr
;         bic     r12, r0, #0x80
700aede4: e3c0c080     	bic	r12, r0, #128
;         msr     cpsr_cf, r12
700aede8: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700aedec: e12fff1e     	bx	lr

700aedf0 <HwiP_enableFIQ>:
;         mrs     r0, cpsr
700aedf0: e10f0000     	mrs	r0, apsr
;         bic     r12, r0, #0x40
700aedf4: e3c0c040     	bic	r12, r0, #64
;         msr     cpsr_cf, r12
700aedf8: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700aedfc: e12fff1e     	bx	lr

700aee00 <HwiP_restore>:
;         msr     cpsr_cf, r0
700aee00: e129f000     	msr	CPSR_fc, r0
;         bx      LR
700aee04: e12fff1e     	bx	lr

700aee08 <HwiP_enableVIC>:
;         MRC     p15, #0, r0, c1, c0, #0  /* Read SCTLR */
700aee08: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         ORR     r0, r0, #(1<<24)         /* Set VE mask (VIC controller provides handler address for IRQ) */
700aee0c: e3800401     	orr	r0, r0, #16777216
;         MCR     p15, #0, r0, c1, c0, #0  /* Write modified SCTLR */
700aee10: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700aee14: e12fff1e     	bx	lr

700aee18 <HwiP_disableVIC>:
;         MRC     p15, #0, r0, c1, c0, #0  /* Read SCTLR */
700aee18: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         BIC     r0, r0, #(1<<24)         /* Clear VE mask (VIC controller provides handler address for IRQ) */
700aee1c: e3c00401     	bic	r0, r0, #16777216
;         MCR     p15, #0, r0, c1, c0, #0  /* Write modified SCTLR */
700aee20: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700aee24: e12fff1e     	bx	lr

700aee28 <HwiP_getCPSR>:
;         mrs     r0, cpsr
700aee28: e10f0000     	mrs	r0, apsr
;         bx      LR
700aee2c: e12fff1e     	bx	lr

700aee30 <HwiP_data_abort_handler>:
;         PUSH	{r0-r4, r12}
700aee30: e92d101f     	push	{r0, r1, r2, r3, r4, r12}
;         MRS r0, SPSR
700aee34: e14f0000     	mrs	r0, spsr
;         AND r1, r0, #0x20
700aee38: e2001020     	and	r1, r0, #32
;         CMP R1, #0
700aee3c: e3510000     	cmp	r1, #0
;         BEQ ARM_STATE
700aee40: 0a000000     	beq	0x700aee48 <ARM_STATE>  @ imm = #0x0
;         SUB lr, lr, #2
700aee44: e24ee002     	sub	lr, lr, #2

700aee48 <ARM_STATE>:
;         SUB lr, lr, #4
700aee48: e24ee004     	sub	lr, lr, #4

700aee4c <END>:
;         PUSH	{lr}
700aee4c: e52de004     	str	lr, [sp, #-0x4]!
;         MRS	lr, SPSR
700aee50: e14fe000     	mrs	lr, spsr
;         PUSH	{lr}
700aee54: e52de004     	str	lr, [sp, #-0x4]!
;         LDR	r1, HwiP_data_abort_handler_const
700aee58: e59f1014     	ldr	r1, [pc, #0x14]         @ 0x700aee74 <HwiP_data_abort_handler_const>
;         BLX	r1
700aee5c: e12fff31     	blx	r1
;         POP	{LR}
700aee60: e49de004     	ldr	lr, [sp], #4
;         MSR	SPSR_cxsf, LR
700aee64: e16ff00e     	msr	SPSR_fsxc, lr
;         POP	{LR}
700aee68: e49de004     	ldr	lr, [sp], #4
;         POP	{r0-r4, r12}
700aee6c: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         MOVS	PC, LR
700aee70: e1b0f00e     	movs	pc, lr

700aee74 <HwiP_data_abort_handler_const>:
700aee74: a1 eb 0a 70  	.word	0x700aeba1
700aee78: 00 00 00 00  	.word	0x00000000
700aee7c: 00 00 00 00  	.word	0x00000000

Disassembly of section .text.cache:

700aee80 <CacheP_disableL1d>:
;         push    {r0-r7, r9-r11, lr}
700aee80: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700aee84: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x0004         // clear C bit
700aee88: e3c00004     	bic	r0, r0, #4
;         dsb
700aee8c: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0 // L1D cache disabled
700aee90: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         movw    r0, :lower16:CacheP_wbInvAllAsm
700aee94: e30f00ac     	movw	r0, #0xf0ac
;         movt    r0, :upper16:CacheP_wbInvAllAsm
700aee98: e347000a     	movt	r0, #0x700a
;         blx     r0
700aee9c: e12fff30     	blx	r0
;         pop     {r0-r7, r9-r11, lr}
700aeea0: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700aeea4: e12fff1e     	bx	lr

700aeea8 <CacheP_disableL1p>:
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700aeea8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x1000         // clear I bit
700aeeac: e3c00a01     	bic	r0, r0, #4096
;         mcr     p15, #0, r0, c1, c0, #0 // L1P cache disabled
700aeeb0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         mcr     p15, #0, r1, c7, c5, #0 // Invalidate entire instruction cache
700aeeb4: ee071f15     	mcr	p15, #0x0, r1, c7, c5, #0x0
;         isb
700aeeb8: f57ff06f     	isb	sy
;         bx      lr
700aeebc: e12fff1e     	bx	lr

700aeec0 <CacheP_enableL1d>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCR register
700aeec0: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x0004          // set C bit (bit 2) to 1
700aeec4: e3800004     	orr	r0, r0, #4
;         dsb
700aeec8: f57ff04f     	dsb	sy
;         mcr     p15, #0, r1, c15, c5, #0 // Invalidate entire data cache
700aeecc: ee0f1f15     	mcr	p15, #0x0, r1, c15, c5, #0x0
;         mcr     p15, #0, r0, c1, c0, #0  // L1D cache enabled
700aeed0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      lr
700aeed4: e12fff1e     	bx	lr

700aeed8 <CacheP_enableL1p>:
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700aeed8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x1000         // set I bit (bit 12) to 1
700aeedc: e3800a01     	orr	r0, r0, #4096
;         mcr     p15, #0, r1, c7, c5, #0 // Invalidate entire instruction cache
700aeee0: ee071f15     	mcr	p15, #0x0, r1, c7, c5, #0x0
;         mcr     p15, #0, r0, c1, c0, #0 // ICache enabled
700aeee4: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb
700aeee8: f57ff06f     	isb	sy
;         bx      lr
700aeeec: e12fff1e     	bx	lr

700aeef0 <CacheP_invL1d>:
;         push    {r4}
700aeef0: e52d4004     	str	r4, [sp, #-0x4]!
;         add     r1, r0, r1              // calculate last address
700aeef4: e0801001     	add	r1, r0, r1
;         ldr     r3, l1dCacheLineSizeInvL1dAddr
700aeef8: e59f3024     	ldr	r3, [pc, #0x24]         @ 0x700aef24 <l1dCacheLineSizeInvL1dAddr>
;         ldr     r3, [r3]
700aeefc: e5933000     	ldr	r3, [r3]
;         sub     r4, r3, #1
700aef00: e2434001     	sub	r4, r3, #1
;         bic     r0, r0, r4              // align blockPtr to cache line
700aef04: e1c00004     	bic	r0, r0, r4

700aef08 <invL1dCache_loop>:
;         mcr     p15, #0, r0, c7, c6, #1 // invalidate single entry in L1D cache
700aef08: ee070f36     	mcr	p15, #0x0, r0, c7, c6, #0x1
;         add     r0, r0, r3              // increment address by cache line size
700aef0c: e0800003     	add	r0, r0, r3
;         cmp     r0, r1                  // compare to last address
700aef10: e1500001     	cmp	r0, r1
;         blo     invL1dCache_loop        // loop if > 0
700aef14: 3afffffb     	blo	0x700aef08 <invL1dCache_loop> @ imm = #-0x14
;         dsb                             // drain write buffer
700aef18: f57ff04f     	dsb	sy
;         pop     {r4}
700aef1c: e49d4004     	ldr	r4, [sp], #4
;         bx      lr                      // return
700aef20: e12fff1e     	bx	lr

700aef24 <l1dCacheLineSizeInvL1dAddr>:
700aef24: 74 fc 0a 70  	.word	0x700afc74

700aef28 <CacheP_invL1p>:
;         push    {r4}
700aef28: e52d4004     	str	r4, [sp, #-0x4]!
;         add     r1, r0, r1              // calculate last address
700aef2c: e0801001     	add	r1, r0, r1
;         ldr     r3, l1pCacheLineSizeAddr
700aef30: e59f3028     	ldr	r3, [pc, #0x28]         @ 0x700aef60 <l1pCacheLineSizeAddr>
;         ldr     r3, [r3]
700aef34: e5933000     	ldr	r3, [r3]
;         sub     r4, r3, #1
700aef38: e2434001     	sub	r4, r3, #1
;         bic     r0, r0, r4              // align blockPtr to cache line
700aef3c: e1c00004     	bic	r0, r0, r4

700aef40 <invL1pCache_loop>:
;         mcr     p15, #0, r0, c7, c5, #1 // invalidate single entry in ICache
700aef40: ee070f35     	mcr	p15, #0x0, r0, c7, c5, #0x1
;         add     r0, r0, r3              // increment address by cache line size
700aef44: e0800003     	add	r0, r0, r3
;         cmp     r0, r1                  // compare to last address
700aef48: e1500001     	cmp	r0, r1
;         blo     invL1pCache_loop        // loop if > 0
700aef4c: 3afffffb     	blo	0x700aef40 <invL1pCache_loop> @ imm = #-0x14
;         dsb                             // drain write buffer
700aef50: f57ff04f     	dsb	sy
;         isb                             // flush instruction pipeline
700aef54: f57ff06f     	isb	sy
;         pop     {r4}
700aef58: e49d4004     	ldr	r4, [sp], #4
;         bx      lr
700aef5c: e12fff1e     	bx	lr

700aef60 <l1pCacheLineSizeAddr>:
700aef60: f0 09 0b 70  	.word	0x700b09f0

700aef64 <CacheP_invL1dAll>:
;         mcr     p15, #0, r0, c15, c5, #0 // Invalidate entire data cache
700aef64: ee0f0f15     	mcr	p15, #0x0, r0, c15, c5, #0x0
;         bx      lr                       // return
700aef68: e12fff1e     	bx	lr

700aef6c <CacheP_invL1pAll>:
;         mcr     p15, #0, r0, c7, c5, #0 // invalidate all entries in ICache
700aef6c: ee070f15     	mcr	p15, #0x0, r0, c7, c5, #0x0
;         bx      lr                      // return
700aef70: e12fff1e     	bx	lr

700aef74 <CacheP_wb>:
;         push    {r4, r5}
700aef74: e92d0030     	push	{r4, r5}
;         dmb                              // Ensure all previous memory accesses
700aef78: f57ff05f     	dmb	sy
;         add     r1, r0, r1               // calculate last address
700aef7c: e0801001     	add	r1, r0, r1
;         ldr     r4, l1dCacheLineSizeWbAddr
700aef80: e59f4024     	ldr	r4, [pc, #0x24]         @ 0x700aefac <l1dCacheLineSizeWbAddr>
;         ldr     r4, [r4]
700aef84: e5944000     	ldr	r4, [r4]
;         sub     r5, r4, #1
700aef88: e2445001     	sub	r5, r4, #1
;         bic     r0, r0, r5               // align address to cache line
700aef8c: e1c00005     	bic	r0, r0, r5

700aef90 <writeback>:
;         mcr     p15, #0, r0, c7, c10, #1 // write back a cache line
700aef90: ee070f3a     	mcr	p15, #0x0, r0, c7, c10, #0x1
;         add     r0, r0, r4               // increment address by cache line size
700aef94: e0800004     	add	r0, r0, r4
;         cmp     r0, r1                   // compare to last address
700aef98: e1500001     	cmp	r0, r1
;         blo     writeback                // loop if count > 0
700aef9c: 3afffffb     	blo	0x700aef90 <writeback>  @ imm = #-0x14
;         dsb                              // drain write buffer
700aefa0: f57ff04f     	dsb	sy
;         pop     {r4, r5}
700aefa4: e8bd0030     	pop	{r4, r5}
;         bx      lr
700aefa8: e12fff1e     	bx	lr

700aefac <l1dCacheLineSizeWbAddr>:
700aefac: 74 fc 0a 70  	.word	0x700afc74

700aefb0 <CacheP_wbInv>:
;         push    {r4, r5}
700aefb0: e92d0030     	push	{r4, r5}
;         dmb                              // Ensure all previous memory accesses
700aefb4: f57ff05f     	dmb	sy
;         add     r1, r0, r1               // calculate last address
700aefb8: e0801001     	add	r1, r0, r1
;         ldr     r4, l1dCacheLineSizeWbInvAddr
700aefbc: e59f4024     	ldr	r4, [pc, #0x24]         @ 0x700aefe8 <l1dCacheLineSizeWbInvAddr>
;         ldr     r4, [r4]
700aefc0: e5944000     	ldr	r4, [r4]
;         sub     r5, r4, #1
700aefc4: e2445001     	sub	r5, r4, #1
;         bic     r0, r0, r5               // align blockPtr to cache line
700aefc8: e1c00005     	bic	r0, r0, r5

700aefcc <writebackInv>:
;         mcr     p15, #0, r0, c7, c14, #1 // writeback inv a cache line
700aefcc: ee070f3e     	mcr	p15, #0x0, r0, c7, c14, #0x1
;         add     r0, r0, r4               // increment address by cache line size
700aefd0: e0800004     	add	r0, r0, r4
;         cmp     r0, r1                   // compare to last address
700aefd4: e1500001     	cmp	r0, r1
;         blo     writebackInv             // loop if count > 0
700aefd8: 3afffffb     	blo	0x700aefcc <writebackInv> @ imm = #-0x14
;         dsb                              // drain write buffer
700aefdc: f57ff04f     	dsb	sy
;         pop     {r4, r5}
700aefe0: e8bd0030     	pop	{r4, r5}
;         bx      lr
700aefe4: e12fff1e     	bx	lr

700aefe8 <l1dCacheLineSizeWbInvAddr>:
700aefe8: 74 fc 0a 70  	.word	0x700afc74

700aefec <CacheP_wbAll>:
;         stmfd   sp!, {r0-r7, r9-r11, lr}
700aefec: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         dmb                             // Ensure all previous memory accesses
700aeff0: f57ff05f     	dmb	sy
;         mrc     p15, #1, r0, c0, c0, #1 // read clidr
700aeff4: ee300f30     	mrc	p15, #0x1, r0, c0, c0, #0x1
;         ands    r3, r0, #0x7000000      // extract loc from clidr
700aeff8: e2103407     	ands	r3, r0, #117440512
;         mov     r3, r3, lsr #23         // left align loc bit field
700aeffc: e1a03ba3     	lsr	r3, r3, #23
;         beq     wbafinished             // if loc is 0, then no need to clean
700af000: 0a00001d     	beq	0x700af07c <wbafinished> @ imm = #0x74
;         mov     r10, #0                 // start clean at cache level 0
700af004: e3a0a000     	mov	r10, #0

700af008 <wbaloop1>:
;         add     r2, r10, r10, lsr #1    // work out 3x current cache level
700af008: e08a20aa     	add	r2, r10, r10, lsr #1
;         mov     r1, r0, lsr r2          // extract cache type bits from clidr
700af00c: e1a01230     	lsr	r1, r0, r2
;         and     r1, r1, #7              // mask of bits for current cache only
700af010: e2011007     	and	r1, r1, #7
;         cmp     r1, #2                  // see what cache we have at this level
700af014: e3510002     	cmp	r1, #2
;         blt     wbaskip                 // skip if no cache, or just i-cache
700af018: ba000014     	blt	0x700af070 <wbaskip>    @ imm = #0x50
;         mrs     r6, cpsr
700af01c: e10f6000     	mrs	r6, apsr
;         cpsid   i                       // disable interrupts
700af020: f10c0080     	cpsid	i
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700af024: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         isb                             // flush prefetch buffer
700af028: f57ff06f     	isb	sy
;         mrc     p15, #1, r1, c0, c0, #0 // read the new csidr
700af02c: ee301f10     	mrc	p15, #0x1, r1, c0, c0, #0x0
;         msr     cpsr_c, r6              // restore interrupts
700af030: e121f006     	msr	CPSR_c, r6
;         and     r2, r1, #7              // extract the length of the cache lines
700af034: e2012007     	and	r2, r1, #7
;         add     r2, r2, #4              // add 4 (line length offset)
700af038: e2822004     	add	r2, r2, #4
;         mov     r4, #0x3ff
700af03c: e30043ff     	movw	r4, #0x3ff
;         ands    r4, r4, r1, lsr #3      // find maximum number on the way size
700af040: e01441a1     	ands	r4, r4, r1, lsr #3
;         clz     r5, r4                  // find bit position of way size inc.
700af044: e16f5f14     	clz	r5, r4
;         mov     r7, #0x7fff
700af048: e3077fff     	movw	r7, #0x7fff
;         ands    r7, r7, r1, lsr #13     // extract max number of the index size
700af04c: e01776a1     	ands	r7, r7, r1, lsr #13

700af050 <wbaloop2>:
;         mov     r9, r4                  // create working copy of max way size
700af050: e1a09004     	mov	r9, r4

700af054 <wbaloop3>:
;         orr     r11, r10, r9, lsl r5    // factor way and cache number into r11
700af054: e18ab519     	orr	r11, r10, r9, lsl r5
;         orr     r11, r11, r7, lsl r2    // factor index number into r11
700af058: e18bb217     	orr	r11, r11, r7, lsl r2
;         mcr     p15, #0, r11, c7, c10, #2 // clean line by set/way
700af05c: ee07bf5a     	mcr	p15, #0x0, r11, c7, c10, #0x2
;         subs    r9, r9, #1              // decrement the way
700af060: e2599001     	subs	r9, r9, #1
;         bge     wbaloop3
700af064: aafffffa     	bge	0x700af054 <wbaloop3>   @ imm = #-0x18
;         subs    r7, r7, #1              // decrement the index
700af068: e2577001     	subs	r7, r7, #1
;         bge     wbaloop2
700af06c: aafffff7     	bge	0x700af050 <wbaloop2>   @ imm = #-0x24

700af070 <wbaskip>:
;         add     r10, r10, #2            // increment cache number
700af070: e28aa002     	add	r10, r10, #2
;         cmp     r3, r10
700af074: e153000a     	cmp	r3, r10
;         bgt     wbaloop1
700af078: caffffe2     	bgt	0x700af008 <wbaloop1>   @ imm = #-0x78

700af07c <wbafinished>:
;         mov     r10, #0                 // switch back to cache level 0
700af07c: e3a0a000     	mov	r10, #0
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700af080: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         dsb
700af084: f57ff04f     	dsb	sy
;         isb                             // flush prefetch buffer
700af088: f57ff06f     	isb	sy
;         ldmfd   sp!, {r0-r7, r9-r11, lr}
700af08c: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700af090: e12fff1e     	bx	lr

700af094 <CacheP_wbInvAll>:
;         push    {r0-r7, r9-r11, lr}
700af094: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         movw    r0, :lower16:CacheP_wbInvAllAsm
700af098: e30f00ac     	movw	r0, #0xf0ac
;         movt    r0, :upper16:CacheP_wbInvAllAsm
700af09c: e347000a     	movt	r0, #0x700a
;         blx     r0
700af0a0: e12fff30     	blx	r0
;         pop     {r0-r7, r9-r11, lr}
700af0a4: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700af0a8: e12fff1e     	bx	lr

700af0ac <CacheP_wbInvAllAsm>:
;         dmb                             // Ensure all previous memory accesses
700af0ac: f57ff05f     	dmb	sy
;         mrc     p15, #1, r0, c0, c0, #1 // read clidr
700af0b0: ee300f30     	mrc	p15, #0x1, r0, c0, c0, #0x1
;         ands    r3, r0, #0x7000000      // extract loc from clidr
700af0b4: e2103407     	ands	r3, r0, #117440512
;         mov     r3, r3, lsr #23         // left align loc bit field
700af0b8: e1a03ba3     	lsr	r3, r3, #23
;         beq     finished                // if loc is 0, then no need to clean
700af0bc: 0a00001d     	beq	0x700af138 <finished>   @ imm = #0x74
;         mov     r10, #0                 // start clean at cache level 0
700af0c0: e3a0a000     	mov	r10, #0

700af0c4 <loop1>:
;         add     r2, r10, r10, lsr #1    // work out 3x current cache level
700af0c4: e08a20aa     	add	r2, r10, r10, lsr #1
;         mov     r1, r0, lsr r2          // extract cache type bits from clidr
700af0c8: e1a01230     	lsr	r1, r0, r2
;         and     r1, r1, #7              // mask of bits for current cache only
700af0cc: e2011007     	and	r1, r1, #7
;         cmp     r1, #2                  // see what cache we have at this level
700af0d0: e3510002     	cmp	r1, #2
;         blt     skip                    // skip if no cache, or just i-cache
700af0d4: ba000014     	blt	0x700af12c <skip>       @ imm = #0x50
;         mrs     r6, cpsr
700af0d8: e10f6000     	mrs	r6, apsr
;         cpsid   i                       // disable interrupts
700af0dc: f10c0080     	cpsid	i
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700af0e0: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         isb                             // flush prefetch buffer
700af0e4: f57ff06f     	isb	sy
;         mrc     p15, #1, r1, c0, c0, #0 // read the new csidr
700af0e8: ee301f10     	mrc	p15, #0x1, r1, c0, c0, #0x0
;         msr     cpsr_c, r6              // restore interrupts
700af0ec: e121f006     	msr	CPSR_c, r6
;         and     r2, r1, #7              // extract the length of the cache lines
700af0f0: e2012007     	and	r2, r1, #7
;         add     r2, r2, #4              // add 4 (line length offset)
700af0f4: e2822004     	add	r2, r2, #4
;         mov     r4, #0x3ff
700af0f8: e30043ff     	movw	r4, #0x3ff
;         ands    r4, r4, r1, lsr #3      // find maximum number on the way size
700af0fc: e01441a1     	ands	r4, r4, r1, lsr #3
;         clz     r5, r4                  // find bit position of way size inc.
700af100: e16f5f14     	clz	r5, r4
;         mov     r7, #0x7fff
700af104: e3077fff     	movw	r7, #0x7fff
;         ands    r7, r7, r1, lsr #13     // extract max number of the index size
700af108: e01776a1     	ands	r7, r7, r1, lsr #13

700af10c <loop2>:
;         mov     r9, r4                  // create working copy of max way size
700af10c: e1a09004     	mov	r9, r4

700af110 <loop3>:
;         orr     r11, r10, r9, lsl r5    // factor way and cache number into r11
700af110: e18ab519     	orr	r11, r10, r9, lsl r5
;         orr     r11, r11, r7, lsl r2    // factor index number into r11
700af114: e18bb217     	orr	r11, r11, r7, lsl r2
;         mcr     p15, #0, r11, c7, c14, #2 // clean & invalidate by set/way
700af118: ee07bf5e     	mcr	p15, #0x0, r11, c7, c14, #0x2
;         subs    r9, r9, #1              // decrement the way
700af11c: e2599001     	subs	r9, r9, #1
;         bge     loop3
700af120: aafffffa     	bge	0x700af110 <loop3>      @ imm = #-0x18
;         subs    r7, r7, #1              // decrement the index
700af124: e2577001     	subs	r7, r7, #1
;         bge     loop2
700af128: aafffff7     	bge	0x700af10c <loop2>      @ imm = #-0x24

700af12c <skip>:
;         add     r10, r10, #2            // increment cache number
700af12c: e28aa002     	add	r10, r10, #2
;         cmp     r3, r10
700af130: e153000a     	cmp	r3, r10
;         bgt     loop1
700af134: caffffe2     	bgt	0x700af0c4 <loop1>      @ imm = #-0x78

700af138 <finished>:
;         mov     r10, #0                 // swith back to cache level 0
700af138: e3a0a000     	mov	r10, #0
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700af13c: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         dsb
700af140: f57ff04f     	dsb	sy
;         isb                             // flush prefetch buffer
700af144: f57ff06f     	isb	sy
;         bx      lr
700af148: e12fff1e     	bx	lr

700af14c <CacheP_getEnabled>:
;         mov     r0, #0
700af14c: e3a00000     	mov	r0, #0
;         mrc     p15, #0, r1, c1, c0, #0 // fetch Control Register into r1
700af150: ee111f10     	mrc	p15, #0x0, r1, c1, c0, #0x0
;         tst     r1, #0x1000             // test I bit (bit 12) for L1P
700af154: e3110a01     	tst	r1, #4096
;         addne   r0, r0, #1              // if I is true, L1P is enabled
700af158: 12800001     	addne	r0, r0, #1
;         tst     r1, #0x0004             // test C bit (bit 2) for L1D
700af15c: e3110004     	tst	r1, #4
;         addne   r0, r0, #2              // if C bit is true, L1D is enabled
700af160: 12800002     	addne	r0, r0, #2
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700af164: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         tst     r1, #0x0002             // test L2EN bit (bit 1) for L2EN
700af168: e3110002     	tst	r1, #2
;         beq     getEnabledDone
700af16c: 0a000003     	beq	0x700af180 <getEnabledDone> @ imm = #0xc
;         tst     r0, #0x0001
700af170: e3100001     	tst	r0, #1
;         addne   r0, r0, #4              // If L2EN and L1P then L2P
700af174: 12800004     	addne	r0, r0, #4
;         tst     r0, #0x0002
700af178: e3100002     	tst	r0, #2
;         addne   r0, r0, #8              // If L2EN and L1D then L2D
700af17c: 12800008     	addne	r0, r0, #8

700af180 <getEnabledDone>:
;         bx      lr
700af180: e12fff1e     	bx	lr

700af184 <CacheP_getCacheLevelInfo>:
;         mcr     p15, #2, r0, c0, c0, #0 // write to Cache Size Selection Reg
700af184: ee400f10     	mcr	p15, #0x2, r0, c0, c0, #0x0
;         mrc     p15, #1, r0, c0, c0, #0 // read Cache Size Id Reg
700af188: ee300f10     	mrc	p15, #0x1, r0, c0, c0, #0x0
;         bx      lr
700af18c: e12fff1e     	bx	lr

700af190 <CacheP_configForceWrThru>:
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700af190: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         cmp     r0, #0
700af194: e3500000     	cmp	r0, #0
;         beq     FWT_disable
700af198: 0a000001     	beq	0x700af1a4 <FWT_disable> @ imm = #0x4
;         orr     r1, r1, #(1 << 9)       // set (enable) force write-thru bit
700af19c: e3811c02     	orr	r1, r1, #512
;         b       FWT_exit
700af1a0: ea000000     	b	0x700af1a8 <FWT_exit>   @ imm = #0x0

700af1a4 <FWT_disable>:
;         bic     r1, r1, #(1 << 9)       // clear (disable) force write-thru bit
700af1a4: e3c11c02     	bic	r1, r1, #512

700af1a8 <FWT_exit>:
;         mcr     p15, #0, r1, c1, c0, #1 // write Auxiliary Ctrl Register
700af1a8: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         bx      lr
700af1ac: e12fff1e     	bx	lr

700af1b0 <CacheP_setDLFO>:
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700af1b0: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         orr     r1, r1, #(1 << 13)      // set DLFO to disable LF optimization
700af1b4: e3811a02     	orr	r1, r1, #8192
;         mcr     p15, #0, r1, c1, c0, #1 // write Auxiliary Ctrl Register
700af1b8: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         bx      lr
700af1bc: e12fff1e     	bx	lr

700af1c0 <CacheP_init>:
; {
700af1c0: b580         	push	{r7, lr}
700af1c2: b084         	sub	sp, #0x10
700af1c4: 2000         	movs	r0, #0x0
;     info = CacheP_getCacheLevelInfo(0);
700af1c6: f7ff efde    	blx	0x700af184 <CacheP_getCacheLevelInfo> @ imm = #-0x44
700af1ca: 9003         	str	r0, [sp, #0xc]
;     DebugP_assertNoLog (gCacheL1dCacheLineSize == (4U << ((info & 0x7U) + 2U)));
700af1cc: 9803         	ldr	r0, [sp, #0xc]
700af1ce: f000 0007    	and	r0, r0, #0x7
700af1d2: 1c81         	adds	r1, r0, #0x2
700af1d4: 2004         	movs	r0, #0x4
700af1d6: 9001         	str	r0, [sp, #0x4]
700af1d8: 4088         	lsls	r0, r1
700af1da: 3820         	subs	r0, #0x20
700af1dc: fab0 f080    	clz	r0, r0
700af1e0: 0940         	lsrs	r0, r0, #0x5
700af1e2: f000 faad    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x55a
700af1e6: 2001         	movs	r0, #0x1
;     info = CacheP_getCacheLevelInfo(1);
700af1e8: f7ff efcc    	blx	0x700af184 <CacheP_getCacheLevelInfo> @ imm = #-0x68
700af1ec: 4601         	mov	r1, r0
700af1ee: 9801         	ldr	r0, [sp, #0x4]
700af1f0: 9103         	str	r1, [sp, #0xc]
;     DebugP_assertNoLog (gCacheL1pCacheLineSize == (4U << ((info & 0x7U) + 2U)));
700af1f2: 9903         	ldr	r1, [sp, #0xc]
700af1f4: f001 0107    	and	r1, r1, #0x7
700af1f8: 3102         	adds	r1, #0x2
700af1fa: 4088         	lsls	r0, r1
700af1fc: 3820         	subs	r0, #0x20
700af1fe: fab0 f080    	clz	r0, r0
700af202: 0940         	lsrs	r0, r0, #0x5
700af204: f000 fa9c    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x538
;     enabled = CacheP_getEnabled();
700af208: f7ff efa0    	blx	0x700af14c <CacheP_getEnabled> @ imm = #-0xc0
700af20c: 9002         	str	r0, [sp, #0x8]
;     if (enabled!=0U) {
700af20e: 9802         	ldr	r0, [sp, #0x8]
700af210: b120         	cbz	r0, 0x700af21c <CacheP_init+0x5c> @ imm = #0x8
700af212: e7ff         	b	0x700af214 <CacheP_init+0x54> @ imm = #-0x2
700af214: 200f         	movs	r0, #0xf
;         CacheP_disable((uint32_t)CacheP_TYPE_ALL);
700af216: f000 f81b    	bl	0x700af250 <CacheP_disable> @ imm = #0x36
;     }
700af21a: e7ff         	b	0x700af21c <CacheP_init+0x5c> @ imm = #-0x2
;     if (gCacheConfig.enable!=0U) {
700af21c: f64f 305c    	movw	r0, #0xfb5c
700af220: f2c7 000a    	movt	r0, #0x700a
700af224: 6800         	ldr	r0, [r0]
700af226: b158         	cbz	r0, 0x700af240 <CacheP_init+0x80> @ imm = #0x16
700af228: e7ff         	b	0x700af22a <CacheP_init+0x6a> @ imm = #-0x2
;          CacheP_configForceWrThru(gCacheConfig.enableForceWrThru);
700af22a: f64f 305c    	movw	r0, #0xfb5c
700af22e: f2c7 000a    	movt	r0, #0x700a
700af232: 6840         	ldr	r0, [r0, #0x4]
700af234: f7ff efac    	blx	0x700af190 <CacheP_configForceWrThru> @ imm = #-0xa8
700af238: 200f         	movs	r0, #0xf
;         CacheP_enable((uint32_t)CacheP_TYPE_ALL);
700af23a: f000 f831    	bl	0x700af2a0 <CacheP_enable> @ imm = #0x62
;     }
700af23e: e7ff         	b	0x700af240 <CacheP_init+0x80> @ imm = #-0x2
; }
700af240: b004         	add	sp, #0x10
700af242: bd80         	pop	{r7, pc}
700af244: bf00         	nop
700af246: bf00         	nop
700af248: bf00         	nop
700af24a: bf00         	nop
700af24c: bf00         	nop
700af24e: bf00         	nop

700af250 <CacheP_disable>:
; {
700af250: b580         	push	{r7, lr}
700af252: b084         	sub	sp, #0x10
700af254: 9003         	str	r0, [sp, #0xc]
;     enabled = CacheP_getEnabled();
700af256: f7ff ef7a    	blx	0x700af14c <CacheP_getEnabled> @ imm = #-0x10c
700af25a: 9002         	str	r0, [sp, #0x8]
;     if ((enabled & ((type) & ((uint32_t)CacheP_TYPE_L1D)))!=0U) {
700af25c: 9902         	ldr	r1, [sp, #0x8]
700af25e: 9803         	ldr	r0, [sp, #0xc]
700af260: 4008         	ands	r0, r1
700af262: 0780         	lsls	r0, r0, #0x1e
700af264: 2800         	cmp	r0, #0x0
700af266: d509         	bpl	0x700af27c <CacheP_disable+0x2c> @ imm = #0x12
700af268: e7ff         	b	0x700af26a <CacheP_disable+0x1a> @ imm = #-0x2
;         key = HwiP_disable();
700af26a: f7ff edaa    	blx	0x700aedc0 <HwiP_disable> @ imm = #-0x4ac
700af26e: 9001         	str	r0, [sp, #0x4]
;         CacheP_disableL1d();             /* Disable L1D Cache */
700af270: f7ff ee06    	blx	0x700aee80 <CacheP_disableL1d> @ imm = #-0x3f4
;         HwiP_restore(key);
700af274: 9801         	ldr	r0, [sp, #0x4]
700af276: f7ff edc4    	blx	0x700aee00 <HwiP_restore> @ imm = #-0x478
;     }
700af27a: e7ff         	b	0x700af27c <CacheP_disable+0x2c> @ imm = #-0x2
;     if ((enabled & ((type) & ((uint32_t)CacheP_TYPE_L1P)))!=0U) {
700af27c: 9902         	ldr	r1, [sp, #0x8]
700af27e: 9803         	ldr	r0, [sp, #0xc]
700af280: 4008         	ands	r0, r1
700af282: 07c0         	lsls	r0, r0, #0x1f
700af284: b148         	cbz	r0, 0x700af29a <CacheP_disable+0x4a> @ imm = #0x12
700af286: e7ff         	b	0x700af288 <CacheP_disable+0x38> @ imm = #-0x2
;         key = HwiP_disable();
700af288: f7ff ed9a    	blx	0x700aedc0 <HwiP_disable> @ imm = #-0x4cc
700af28c: 9001         	str	r0, [sp, #0x4]
;         CacheP_disableL1p();             /* Disable L1P Cache */
700af28e: f7ff ee0c    	blx	0x700aeea8 <CacheP_disableL1p> @ imm = #-0x3e8
;         HwiP_restore(key);
700af292: 9801         	ldr	r0, [sp, #0x4]
700af294: f7ff edb4    	blx	0x700aee00 <HwiP_restore> @ imm = #-0x498
;     }
700af298: e7ff         	b	0x700af29a <CacheP_disable+0x4a> @ imm = #-0x2
; }
700af29a: b004         	add	sp, #0x10
700af29c: bd80         	pop	{r7, pc}
700af29e: bf00         	nop

700af2a0 <CacheP_enable>:
; {
700af2a0: b580         	push	{r7, lr}
700af2a2: b082         	sub	sp, #0x8
700af2a4: 9001         	str	r0, [sp, #0x4]
;     disabled = ~(CacheP_getEnabled());
700af2a6: f7ff ef52    	blx	0x700af14c <CacheP_getEnabled> @ imm = #-0x15c
700af2aa: 43c0         	mvns	r0, r0
700af2ac: 9000         	str	r0, [sp]
;     if ((disabled & ((type) & ((uint32_t)CacheP_TYPE_L1D)))!=0U) {
700af2ae: 9900         	ldr	r1, [sp]
700af2b0: 9801         	ldr	r0, [sp, #0x4]
700af2b2: 4008         	ands	r0, r1
700af2b4: 0780         	lsls	r0, r0, #0x1e
700af2b6: 2800         	cmp	r0, #0x0
700af2b8: d503         	bpl	0x700af2c2 <CacheP_enable+0x22> @ imm = #0x6
700af2ba: e7ff         	b	0x700af2bc <CacheP_enable+0x1c> @ imm = #-0x2
;         CacheP_enableL1d();              /* Enable L1D Cache */
700af2bc: f7ff ee00    	blx	0x700aeec0 <CacheP_enableL1d> @ imm = #-0x400
;     }
700af2c0: e7ff         	b	0x700af2c2 <CacheP_enable+0x22> @ imm = #-0x2
;     if ((disabled & ((type) & ((uint32_t)CacheP_TYPE_L1P)))!=0U) {
700af2c2: 9900         	ldr	r1, [sp]
700af2c4: 9801         	ldr	r0, [sp, #0x4]
700af2c6: 4008         	ands	r0, r1
700af2c8: 07c0         	lsls	r0, r0, #0x1f
700af2ca: b118         	cbz	r0, 0x700af2d4 <CacheP_enable+0x34> @ imm = #0x6
700af2cc: e7ff         	b	0x700af2ce <CacheP_enable+0x2e> @ imm = #-0x2
;         CacheP_enableL1p();              /* Enable L1P Cache */
700af2ce: f7ff ee04    	blx	0x700aeed8 <CacheP_enableL1p> @ imm = #-0x3f8
;     }
700af2d2: e7ff         	b	0x700af2d4 <CacheP_enable+0x34> @ imm = #-0x2
; }
700af2d4: b002         	add	sp, #0x8
700af2d6: bd80         	pop	{r7, pc}
700af2d8: bf00         	nop
700af2da: bf00         	nop
700af2dc: bf00         	nop
700af2de: bf00         	nop

700af2e0 <CacheP_inv>:
; {
700af2e0: b580         	push	{r7, lr}
700af2e2: b084         	sub	sp, #0x10
700af2e4: 9003         	str	r0, [sp, #0xc]
700af2e6: 9102         	str	r1, [sp, #0x8]
700af2e8: 9201         	str	r2, [sp, #0x4]
;     if (((type) & ((uint32_t)CacheP_TYPE_L1P))!=0U) {
700af2ea: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700af2ee: 07c0         	lsls	r0, r0, #0x1f
700af2f0: b128         	cbz	r0, 0x700af2fe <CacheP_inv+0x1e> @ imm = #0xa
700af2f2: e7ff         	b	0x700af2f4 <CacheP_inv+0x14> @ imm = #-0x2
;         CacheP_invL1p((uint32_t)blockPtr, byteCnt);
700af2f4: 9803         	ldr	r0, [sp, #0xc]
700af2f6: 9902         	ldr	r1, [sp, #0x8]
700af2f8: f7ff ee16    	blx	0x700aef28 <CacheP_invL1p> @ imm = #-0x3d4
;     }
700af2fc: e7ff         	b	0x700af2fe <CacheP_inv+0x1e> @ imm = #-0x2
;     if (((type) & ((uint32_t)CacheP_TYPE_L1D))!=0U) {
700af2fe: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700af302: 0780         	lsls	r0, r0, #0x1e
700af304: 2800         	cmp	r0, #0x0
700af306: d505         	bpl	0x700af314 <CacheP_inv+0x34> @ imm = #0xa
700af308: e7ff         	b	0x700af30a <CacheP_inv+0x2a> @ imm = #-0x2
;         CacheP_invL1d((uint32_t)blockPtr, byteCnt);
700af30a: 9803         	ldr	r0, [sp, #0xc]
700af30c: 9902         	ldr	r1, [sp, #0x8]
700af30e: f7ff edf0    	blx	0x700aeef0 <CacheP_invL1d> @ imm = #-0x420
;     }
700af312: e7ff         	b	0x700af314 <CacheP_inv+0x34> @ imm = #-0x2
; }
700af314: b004         	add	sp, #0x10
700af316: bd80         	pop	{r7, pc}
		...

Disassembly of section .text.mpu:

700af320 <MpuP_RegionAttrs_init>:
; {
700af320: b081         	sub	sp, #0x4
700af322: 9000         	str	r0, [sp]
;     region->isExecuteNever = 0;
700af324: 9900         	ldr	r1, [sp]
700af326: 2000         	movs	r0, #0x0
700af328: 7108         	strb	r0, [r1, #0x4]
;     region->accessPerm     = (uint8_t)MpuP_AP_S_RW_U_R;
700af32a: 9a00         	ldr	r2, [sp]
700af32c: 2102         	movs	r1, #0x2
700af32e: 7191         	strb	r1, [r2, #0x6]
;     region->tex            = 0;
700af330: 9900         	ldr	r1, [sp]
700af332: 7148         	strb	r0, [r1, #0x5]
;     region->isSharable     = 1;
700af334: 9a00         	ldr	r2, [sp]
700af336: 2101         	movs	r1, #0x1
700af338: 70d1         	strb	r1, [r2, #0x3]
;     region->isCacheable    = 0;
700af33a: 9900         	ldr	r1, [sp]
700af33c: 7048         	strb	r0, [r1, #0x1]
;     region->isBufferable   = 0;
700af33e: 9900         	ldr	r1, [sp]
700af340: 7088         	strb	r0, [r1, #0x2]
;     region->isEnable       = 0;
700af342: 9900         	ldr	r1, [sp]
700af344: 7008         	strb	r0, [r1]
;     region->subregionDisableMask = 0;
700af346: 9900         	ldr	r1, [sp]
700af348: 71c8         	strb	r0, [r1, #0x7]
; }
700af34a: b001         	add	sp, #0x4
700af34c: 4770         	bx	lr
700af34e: bf00         	nop

700af350 <MpuP_setRegion>:
; {
700af350: b580         	push	{r7, lr}
700af352: b08a         	sub	sp, #0x28
700af354: 9009         	str	r0, [sp, #0x24]
700af356: 9108         	str	r1, [sp, #0x20]
700af358: 9207         	str	r2, [sp, #0x1c]
700af35a: 9306         	str	r3, [sp, #0x18]
;     uint32_t value = size;
700af35c: 9807         	ldr	r0, [sp, #0x1c]
700af35e: 9000         	str	r0, [sp]
;     DebugP_assertNoLog( regionNum < MpuP_MAX_REGIONS);
700af360: 9909         	ldr	r1, [sp, #0x24]
700af362: 2000         	movs	r0, #0x0
700af364: 2910         	cmp	r1, #0x10
700af366: bf38         	it	lo
700af368: 2001         	movlo	r0, #0x1
700af36a: f000 f9e9    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x3d2
;     value = (value & (uint32_t)0x1F);
700af36e: 9800         	ldr	r0, [sp]
700af370: f000 001f    	and	r0, r0, #0x1f
700af374: 9000         	str	r0, [sp]
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700af376: 9806         	ldr	r0, [sp, #0x18]
;                   | ((uint32_t)(attrs->isEnable &  (uint32_t)0x1) << (uint32_t)0);
700af378: 7801         	ldrb	r1, [r0]
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700af37a: 79c0         	ldrb	r0, [r0, #0x7]
700af37c: 0200         	lsls	r0, r0, #0x8
;                   | ((uint32_t)(value            & (uint32_t)0x1F) << (uint32_t)1)
700af37e: 9a00         	ldr	r2, [sp]
700af380: f002 021f    	and	r2, r2, #0x1f
700af384: ea40 0042    	orr.w	r0, r0, r2, lsl #1
;                   | ((uint32_t)(attrs->isEnable &  (uint32_t)0x1) << (uint32_t)0);
700af388: f001 0101    	and	r1, r1, #0x1
700af38c: 4408         	add	r0, r1
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700af38e: 9004         	str	r0, [sp, #0x10]
;     baseAddress = ((uint32_t)addr & ~( (1U <<((uint64_t)value+1U))-1U ));
700af390: 9808         	ldr	r0, [sp, #0x20]
700af392: 9900         	ldr	r1, [sp]
700af394: 1c4a         	adds	r2, r1, #0x1
700af396: 2101         	movs	r1, #0x1
700af398: 4091         	lsls	r1, r2
700af39a: 4249         	rsbs	r1, r1, #0
700af39c: 4008         	ands	r0, r1
700af39e: 9005         	str	r0, [sp, #0x14]
;     regionAttrs = MpuP_getAttrs(attrs);
700af3a0: 9806         	ldr	r0, [sp, #0x18]
700af3a2: f000 f81d    	bl	0x700af3e0 <MpuP_getAttrs> @ imm = #0x3a
700af3a6: 9003         	str	r0, [sp, #0xc]
;     enabled = MpuP_isEnable();
700af3a8: f000 f84a    	bl	0x700af440 <MpuP_isEnable> @ imm = #0x94
700af3ac: 9002         	str	r0, [sp, #0x8]
;     MpuP_disable();
700af3ae: f000 f84f    	bl	0x700af450 <MpuP_disable> @ imm = #0x9e
;     key = HwiP_disable();
700af3b2: f7ff ed06    	blx	0x700aedc0 <HwiP_disable> @ imm = #-0x5f4
700af3b6: 9001         	str	r0, [sp, #0x4]
;     MpuP_setRegionAsm(regionNum, baseAddress, sizeAndEnable, regionAttrs);
700af3b8: 9809         	ldr	r0, [sp, #0x24]
700af3ba: 9905         	ldr	r1, [sp, #0x14]
700af3bc: 9a04         	ldr	r2, [sp, #0x10]
700af3be: 9b03         	ldr	r3, [sp, #0xc]
700af3c0: f000 e90c    	blx	0x700af5dc <MpuP_setRegionAsm> @ imm = #0x218
;     HwiP_restore(key);
700af3c4: 9801         	ldr	r0, [sp, #0x4]
700af3c6: f7ff ed1c    	blx	0x700aee00 <HwiP_restore> @ imm = #-0x5c8
;     if (enabled != 0U) {
700af3ca: 9802         	ldr	r0, [sp, #0x8]
700af3cc: b118         	cbz	r0, 0x700af3d6 <MpuP_setRegion+0x86> @ imm = #0x6
700af3ce: e7ff         	b	0x700af3d0 <MpuP_setRegion+0x80> @ imm = #-0x2
;         MpuP_enable();
700af3d0: f000 f85e    	bl	0x700af490 <MpuP_enable> @ imm = #0xbc
;     }
700af3d4: e7ff         	b	0x700af3d6 <MpuP_setRegion+0x86> @ imm = #-0x2
; }
700af3d6: b00a         	add	sp, #0x28
700af3d8: bd80         	pop	{r7, pc}
700af3da: bf00         	nop
700af3dc: bf00         	nop
700af3de: bf00         	nop

700af3e0 <MpuP_getAttrs>:
; {
700af3e0: b580         	push	{r7, lr}
700af3e2: b082         	sub	sp, #0x8
700af3e4: 9001         	str	r0, [sp, #0x4]
;           ((uint32_t)(region->isExecuteNever & (uint32_t)0x1) << (uint32_t)12)
700af3e6: f8dd c004    	ldr.w	r12, [sp, #0x4]
;         | ((uint32_t)(region->isCacheable    & (uint32_t)0x1) << (uint32_t)1)
700af3ea: f89c 2001    	ldrb.w	r2, [r12, #0x1]
;         | ((uint32_t)(region->isBufferable   & (uint32_t)0x1) << (uint32_t)0);
700af3ee: f89c 1002    	ldrb.w	r1, [r12, #0x2]
;         | ((uint32_t)(region->isSharable     & (uint32_t)0x1) << (uint32_t)2)
700af3f2: f89c 3003    	ldrb.w	r3, [r12, #0x3]
;           ((uint32_t)(region->isExecuteNever & (uint32_t)0x1) << (uint32_t)12)
700af3f6: f89c 0004    	ldrb.w	r0, [r12, #0x4]
700af3fa: f000 0001    	and	r0, r0, #0x1
700af3fe: 0300         	lsls	r0, r0, #0xc
;         | ((uint32_t)(region->accessPerm     & (uint32_t)0x7) << (uint32_t)8)
700af400: f89c e006    	ldrb.w	lr, [r12, #0x6]
700af404: f00e 0e07    	and	lr, lr, #0x7
700af408: ea40 200e    	orr.w	r0, r0, lr, lsl #8
;         | ((uint32_t)(region->tex            & (uint32_t)0x7) << (uint32_t)3)
700af40c: f89c c005    	ldrb.w	r12, [r12, #0x5]
700af410: f00c 0c07    	and	r12, r12, #0x7
700af414: ea40 00cc    	orr.w	r0, r0, r12, lsl #3
;         | ((uint32_t)(region->isSharable     & (uint32_t)0x1) << (uint32_t)2)
700af418: f003 0301    	and	r3, r3, #0x1
700af41c: ea40 0083    	orr.w	r0, r0, r3, lsl #2
;         | ((uint32_t)(region->isCacheable    & (uint32_t)0x1) << (uint32_t)1)
700af420: f002 0201    	and	r2, r2, #0x1
700af424: ea40 0042    	orr.w	r0, r0, r2, lsl #1
;         | ((uint32_t)(region->isBufferable   & (uint32_t)0x1) << (uint32_t)0);
700af428: f001 0101    	and	r1, r1, #0x1
700af42c: 4408         	add	r0, r1
;     uint32_t regionAttrs =
700af42e: 9000         	str	r0, [sp]
;     return regionAttrs;
700af430: 9800         	ldr	r0, [sp]
700af432: b002         	add	sp, #0x8
700af434: bd80         	pop	{r7, pc}
700af436: bf00         	nop
700af438: bf00         	nop
700af43a: bf00         	nop
700af43c: bf00         	nop
700af43e: bf00         	nop

700af440 <MpuP_isEnable>:
; {
700af440: b580         	push	{r7, lr}
;     return MpuP_isEnableAsm();
700af442: f000 e8c2    	blx	0x700af5c8 <MpuP_isEnableAsm> @ imm = #0x184
700af446: bd80         	pop	{r7, pc}
700af448: bf00         	nop
700af44a: bf00         	nop
700af44c: bf00         	nop
700af44e: bf00         	nop

700af450 <MpuP_disable>:
; {
700af450: b580         	push	{r7, lr}
700af452: b082         	sub	sp, #0x8
;     if(MpuP_isEnable()!=0U)
700af454: f7ff fff4    	bl	0x700af440 <MpuP_isEnable> @ imm = #-0x18
700af458: b1a0         	cbz	r0, 0x700af484 <MpuP_disable+0x34> @ imm = #0x28
700af45a: e7ff         	b	0x700af45c <MpuP_disable+0xc> @ imm = #-0x2
;         key = HwiP_disable();
700af45c: f7ff ecb0    	blx	0x700aedc0 <HwiP_disable> @ imm = #-0x6a0
700af460: 9000         	str	r0, [sp]
;         type = CacheP_getEnabled();
700af462: f7ff ee74    	blx	0x700af14c <CacheP_getEnabled> @ imm = #-0x318
700af466: 9001         	str	r0, [sp, #0x4]
;         CacheP_disable(type);
700af468: 9801         	ldr	r0, [sp, #0x4]
700af46a: f7ff fef1    	bl	0x700af250 <CacheP_disable> @ imm = #-0x21e
;         __asm__ __volatile__ (" dsb" "\n\t": : : "memory");
700af46e: f3bf 8f4f    	dsb	sy
;         MpuP_disableAsm();
700af472: f000 e882    	blx	0x700af578 <MpuP_disableAsm> @ imm = #0x104
;         CacheP_enable(type);
700af476: 9801         	ldr	r0, [sp, #0x4]
700af478: f7ff ff12    	bl	0x700af2a0 <CacheP_enable> @ imm = #-0x1dc
;         HwiP_restore(key);
700af47c: 9800         	ldr	r0, [sp]
700af47e: f7ff ecc0    	blx	0x700aee00 <HwiP_restore> @ imm = #-0x680
;     }
700af482: e7ff         	b	0x700af484 <MpuP_disable+0x34> @ imm = #-0x2
; }
700af484: b002         	add	sp, #0x8
700af486: bd80         	pop	{r7, pc}
700af488: bf00         	nop
700af48a: bf00         	nop
700af48c: bf00         	nop
700af48e: bf00         	nop

700af490 <MpuP_enable>:
; {
700af490: b580         	push	{r7, lr}
700af492: b082         	sub	sp, #0x8
;     if(MpuP_isEnable()==(uint32_t) 0U)
700af494: f7ff ffd4    	bl	0x700af440 <MpuP_isEnable> @ imm = #-0x58
700af498: b9e0         	cbnz	r0, 0x700af4d4 <MpuP_enable+0x44> @ imm = #0x38
700af49a: e7ff         	b	0x700af49c <MpuP_enable+0xc> @ imm = #-0x2
;         key = HwiP_disable();
700af49c: f7ff ec90    	blx	0x700aedc0 <HwiP_disable> @ imm = #-0x6e0
700af4a0: 9000         	str	r0, [sp]
;         type = (uint32_t)CacheP_getEnabled();
700af4a2: f7ff ee54    	blx	0x700af14c <CacheP_getEnabled> @ imm = #-0x358
700af4a6: 9001         	str	r0, [sp, #0x4]
;         if (type & CacheP_TYPE_L1) {
700af4a8: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700af4ac: 0780         	lsls	r0, r0, #0x1e
700af4ae: b120         	cbz	r0, 0x700af4ba <MpuP_enable+0x2a> @ imm = #0x8
700af4b0: e7ff         	b	0x700af4b2 <MpuP_enable+0x22> @ imm = #-0x2
700af4b2: 2003         	movs	r0, #0x3
;             CacheP_disable(CacheP_TYPE_L1);
700af4b4: f7ff fecc    	bl	0x700af250 <CacheP_disable> @ imm = #-0x268
;         }
700af4b8: e7ff         	b	0x700af4ba <MpuP_enable+0x2a> @ imm = #-0x2
;         MpuP_enableAsm();
700af4ba: f000 e872    	blx	0x700af5a0 <MpuP_enableAsm> @ imm = #0xe4
;         CacheP_enable(type);
700af4be: 9801         	ldr	r0, [sp, #0x4]
700af4c0: f7ff feee    	bl	0x700af2a0 <CacheP_enable> @ imm = #-0x224
;         __asm__  __volatile__ (" dsb" "\n\t": : : "memory");
700af4c4: f3bf 8f4f    	dsb	sy
;         __asm__  __volatile__ (" isb" "\n\t": : : "memory");
700af4c8: f3bf 8f6f    	isb	sy
;         HwiP_restore(key);
700af4cc: 9800         	ldr	r0, [sp]
700af4ce: f7ff ec98    	blx	0x700aee00 <HwiP_restore> @ imm = #-0x6d0
;     }
700af4d2: e7ff         	b	0x700af4d4 <MpuP_enable+0x44> @ imm = #-0x2
; }
700af4d4: b002         	add	sp, #0x8
700af4d6: bd80         	pop	{r7, pc}
700af4d8: bf00         	nop
700af4da: bf00         	nop
700af4dc: bf00         	nop
700af4de: bf00         	nop

700af4e0 <MpuP_init>:
; {
700af4e0: b580         	push	{r7, lr}
700af4e2: b082         	sub	sp, #0x8
;     if (MpuP_isEnable()!=0U) {
700af4e4: f7ff ffac    	bl	0x700af440 <MpuP_isEnable> @ imm = #-0xa8
700af4e8: b118         	cbz	r0, 0x700af4f2 <MpuP_init+0x12> @ imm = #0x6
700af4ea: e7ff         	b	0x700af4ec <MpuP_init+0xc> @ imm = #-0x2
;         MpuP_disable();
700af4ec: f7ff ffb0    	bl	0x700af450 <MpuP_disable> @ imm = #-0xa0
;     }
700af4f0: e7ff         	b	0x700af4f2 <MpuP_init+0x12> @ imm = #-0x2
;     MpuP_disableBRAsm();
700af4f2: f000 e84e    	blx	0x700af590 <MpuP_disableBRAsm> @ imm = #0x9c
;     DebugP_assertNoLog( gMpuConfig.numRegions < MpuP_MAX_REGIONS);
700af4f6: f64f 3064    	movw	r0, #0xfb64
700af4fa: f2c7 000a    	movt	r0, #0x700a
700af4fe: 6801         	ldr	r1, [r0]
700af500: 2000         	movs	r0, #0x0
700af502: 9000         	str	r0, [sp]
700af504: 2910         	cmp	r1, #0x10
700af506: bf38         	it	lo
700af508: 2001         	movlo	r0, #0x1
700af50a: f000 f919    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x232
700af50e: 9800         	ldr	r0, [sp]
;     for (i = 0; i < gMpuConfig.numRegions; i++)
700af510: 9001         	str	r0, [sp, #0x4]
700af512: e7ff         	b	0x700af514 <MpuP_init+0x34> @ imm = #-0x2
700af514: 9801         	ldr	r0, [sp, #0x4]
700af516: f64f 3164    	movw	r1, #0xfb64
700af51a: f2c7 010a    	movt	r1, #0x700a
700af51e: 6809         	ldr	r1, [r1]
700af520: 4288         	cmp	r0, r1
700af522: d212         	bhs	0x700af54a <MpuP_init+0x6a> @ imm = #0x24
700af524: e7ff         	b	0x700af526 <MpuP_init+0x46> @ imm = #-0x2
;         MpuP_setRegion(i,
700af526: 9801         	ldr	r0, [sp, #0x4]
;                 (void*)gMpuRegionConfig[i].baseAddr,
700af528: f64f 3170    	movw	r1, #0xfb70
700af52c: f2c7 010a    	movt	r1, #0x700a
700af530: eb01 1300    	add.w	r3, r1, r0, lsl #4
700af534: 0102         	lsls	r2, r0, #0x4
700af536: 5889         	ldr	r1, [r1, r2]
;                 gMpuRegionConfig[i].size,
700af538: 685a         	ldr	r2, [r3, #0x4]
;                 &gMpuRegionConfig[i].attrs
700af53a: 3308         	adds	r3, #0x8
;         MpuP_setRegion(i,
700af53c: f7ff ff08    	bl	0x700af350 <MpuP_setRegion> @ imm = #-0x1f0
;     }
700af540: e7ff         	b	0x700af542 <MpuP_init+0x62> @ imm = #-0x2
;     for (i = 0; i < gMpuConfig.numRegions; i++)
700af542: 9801         	ldr	r0, [sp, #0x4]
700af544: 3001         	adds	r0, #0x1
700af546: 9001         	str	r0, [sp, #0x4]
700af548: e7e4         	b	0x700af514 <MpuP_init+0x34> @ imm = #-0x38
;     if (gMpuConfig.enableBackgroundRegion!=0U) {
700af54a: f64f 3064    	movw	r0, #0xfb64
700af54e: f2c7 000a    	movt	r0, #0x700a
700af552: 6840         	ldr	r0, [r0, #0x4]
700af554: b118         	cbz	r0, 0x700af55e <MpuP_init+0x7e> @ imm = #0x6
700af556: e7ff         	b	0x700af558 <MpuP_init+0x78> @ imm = #-0x2
;         MpuP_enableBRAsm();
700af558: f000 e82e    	blx	0x700af5b8 <MpuP_enableBRAsm> @ imm = #0x5c
;     }
700af55c: e7ff         	b	0x700af55e <MpuP_init+0x7e> @ imm = #-0x2
;     if (gMpuConfig.enableMpu!=0U) {
700af55e: f64f 3064    	movw	r0, #0xfb64
700af562: f2c7 000a    	movt	r0, #0x700a
700af566: 6880         	ldr	r0, [r0, #0x8]
700af568: b118         	cbz	r0, 0x700af572 <MpuP_init+0x92> @ imm = #0x6
700af56a: e7ff         	b	0x700af56c <MpuP_init+0x8c> @ imm = #-0x2
;         MpuP_enable();
700af56c: f7ff ff90    	bl	0x700af490 <MpuP_enable> @ imm = #-0xe0
;     }
700af570: e7ff         	b	0x700af572 <MpuP_init+0x92> @ imm = #-0x2
; }
700af572: b002         	add	sp, #0x8
700af574: bd80         	pop	{r7, pc}
700af576: 0000         	movs	r0, r0

700af578 <MpuP_disableAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700af578: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x1             // clear bit 0 in r0
700af57c: e3c00001     	bic	r0, r0, #1
;         dsb
700af580: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0  // MPU disabled (bit 0 = 0)
700af584: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb                              // flush instruction pipeline
700af588: f57ff06f     	isb	sy
;         bx      LR
700af58c: e12fff1e     	bx	lr

700af590 <MpuP_disableBRAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700af590: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x20000         // clear bit 17 in r0
700af594: e3c00802     	bic	r0, r0, #131072
;         mcr     p15, #0, r0, c1, c0, #0  // disable background region
700af598: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700af59c: e12fff1e     	bx	lr

700af5a0 <MpuP_enableAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700af5a0: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x1             // set bit 0 in r0
700af5a4: e3800001     	orr	r0, r0, #1
;         dsb
700af5a8: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0  // MPU enabled (bit 0 = 1)
700af5ac: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb                              // flush instruction pipeline
700af5b0: f57ff06f     	isb	sy
;         bx      LR
700af5b4: e12fff1e     	bx	lr

700af5b8 <MpuP_enableBRAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700af5b8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x20000         // set bit 17 in r0
700af5bc: e3800802     	orr	r0, r0, #131072
;         mcr     p15, #0, r0, c1, c0, #0  // background region enabled
700af5c0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700af5c4: e12fff1e     	bx	lr

700af5c8 <MpuP_isEnableAsm>:
;         mov     r0, #0
700af5c8: e3a00000     	mov	r0, #0
;         mrc     p15, #0, r1, c1, c0, #0  // read SCTLR register to r1
700af5cc: ee111f10     	mrc	p15, #0x0, r1, c1, c0, #0x0
;         tst     r1, #0x1                 // test bit 0
700af5d0: e3110001     	tst	r1, #1
;         movne   r0, #1                   // if not 0, MPU is enabled
700af5d4: 13a00001     	movne	r0, #1
;         bx      LR
700af5d8: e12fff1e     	bx	lr

700af5dc <MpuP_setRegionAsm>:
;         mcr     p15, #0, r0, c6, c2, #0  // select MPU region
700af5dc: ee060f12     	mcr	p15, #0x0, r0, c6, c2, #0x0
;         mcr     p15, #0, r1, c6, c1, #0  // set region base address
700af5e0: ee061f11     	mcr	p15, #0x0, r1, c6, c1, #0x0
;         mcr     p15, #0, r2, c6, c1, #2  // set region size and enable it
700af5e4: ee062f51     	mcr	p15, #0x0, r2, c6, c1, #0x2
;         mcr     p15, #0, r3, c6, c1, #4  // set protection attributes
700af5e8: ee063f91     	mcr	p15, #0x0, r3, c6, c1, #0x4
;         bx      LR
700af5ec: e12fff1e     	bx	lr

Disassembly of section .text.boot:

700af5f0 <_c_int00_sbl>:
;         MRC     p15, #0, r1, c0, c0, #5
700af5f0: ee101fb0     	mrc	p15, #0x0, r1, c0, c0, #0x5
;         BFC     r1, #8, #24
700af5f4: e7df141f     	bfc	r1, #8, #24
;         CMP     r1, #0
700af5f8: e3510000     	cmp	r1, #0
;         BNE     _sblLoopForever
700af5fc: 1a000001     	bne	0x700af608 <_sblLoopForever> @ imm = #0x4
;         LDR     r1, _c_int00_addr
700af600: e59f1008     	ldr	r1, [pc, #0x8]          @ 0x700af610 <_c_int00_addr>
;         BLX     r1
700af604: e12fff31     	blx	r1

700af608 <_sblLoopForever>:
;         WFI
700af608: e320f003     	wfi
;         B       _sblLoopForever
700af60c: eafffffd     	b	0x700af608 <_sblLoopForever> @ imm = #-0xc

700af610 <_c_int00_addr>:
700af610: 14 f6 0a 70  	.word	0x700af614

700af614 <_c_int00>:
;         mrs     r0, cpsr
700af614: e10f0000     	mrs	r0, apsr
;         orr     r0, r0, #0xC0
700af618: e38000c0     	orr	r0, r0, #192
;         msr     cpsr_cf, r0
700af61c: e129f000     	msr	CPSR_fc, r0
;         MRC      p15,#0x0,r0,c1,c0,#2
700af620: ee110f50     	mrc	p15, #0x0, r0, c1, c0, #0x2
;         MOV      r3,#0xf00000
700af624: e3a0360f     	mov	r3, #15728640
;         ORR      r0,r0,r3
700af628: e1800003     	orr	r0, r0, r3
;         MCR      p15,#0x0,r0,c1,c0,#2
700af62c: ee010f50     	mcr	p15, #0x0, r0, c1, c0, #0x2
;         MOV      r0,#0x40000000
700af630: e3a00101     	mov	r0, #1073741824
;         FMXR     FPEXC,r0
700af634: eee80a10     	vmsr	fpexc, r0
;         MRS     r0, cpsr
700af638: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700af63c: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x11  // SET FIQ MODE
700af640: e3800011     	orr	r0, r0, #17
;         MSR     cpsr_cf, r0
700af644: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_FIQ_STACK_END
700af648: e59fd0d4     	ldr	sp, [pc, #0xd4]         @ 0x700af724 <c_FIQ_STACK_END>
;         MRS     r0, cpsr
700af64c: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700af650: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x12  // SET IRQ MODE
700af654: e3800012     	orr	r0, r0, #18
;         MSR     cpsr_cf, r0
700af658: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_IRQ_STACK_END
700af65c: e59fd0bc     	ldr	sp, [pc, #0xbc]         @ 0x700af720 <c_IRQ_STACK_END>
;         MRS     r0, cpsr
700af660: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700af664: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x13  // SET SVC MODE
700af668: e3800013     	orr	r0, r0, #19
;         MSR     cpsr_cf, r0
700af66c: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_SVC_STACK_END
700af670: e59fd0b0     	ldr	sp, [pc, #0xb0]         @ 0x700af728 <c_SVC_STACK_END>
;         MRS     r0, cpsr
700af674: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700af678: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x17  // SET ABORT MODE
700af67c: e3800017     	orr	r0, r0, #23
;         MSR     cpsr_cf, r0
700af680: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_ABORT_STACK_END
700af684: e59fd0a0     	ldr	sp, [pc, #0xa0]         @ 0x700af72c <c_ABORT_STACK_END>
;         MRS     r0, cpsr
700af688: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700af68c: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x1B  // SET ABORT MODE
700af690: e380001b     	orr	r0, r0, #27
;         MSR     cpsr_cf, r0
700af694: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_UNDEFINED_STACK_END
700af698: e59fd090     	ldr	sp, [pc, #0x90]         @ 0x700af730 <c_UNDEFINED_STACK_END>
;         MRS     r0, cpsr
700af69c: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700af6a0: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x1F  // SET SYSTEM MODE
700af6a4: e380001f     	orr	r0, r0, #31
;         MSR     cpsr_cf, r0
700af6a8: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_STACK_END
700af6ac: e59fd068     	ldr	sp, [pc, #0x68]         @ 0x700af71c <c_STACK_END>
;         MRC p15, 0, r0, c1, c0, 0  // Read System Control Register
700af6b0: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         BIC r0, r0, #0x1 << 2      // Disable data cache bit
700af6b4: e3c00004     	bic	r0, r0, #4
;         BIC r0, r0, #0x1 << 12     // Disable instruction cache bit
700af6b8: e3c00a01     	bic	r0, r0, #4096
;         DSB
700af6bc: f57ff04f     	dsb	sy
;         MCR p15, 0, r0, c1, c0, 0  // Write System Control Register
700af6c0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         ISB                        // Ensures following instructions are not executed from cache
700af6c4: f57ff06f     	isb	sy
;         MRC p15, 0, r1, c1, c0, 1  // Read Auxiliary Control Register
700af6c8: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         ORR r1, r1, #(0x1 << 3)    //Enable ECC for Cache
700af6cc: e3811008     	orr	r1, r1, #8
;         ORR r1,r1,#(0x1 << 5)
700af6d0: e3811020     	orr	r1, r1, #32
;         MCR p15, 0, r1, c1, c0, 1  // Write Auxiliary Control Register
700af6d4: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         MCR p15, 0, r0, c15, c5, 0 // Invalidate entire data cache
700af6d8: ee0f0f15     	mcr	p15, #0x0, r0, c15, c5, #0x0
;         MCR p15, 0, r0, c7, c5, 0  // Invalidate entire instruction cache
700af6dc: ee070f15     	mcr	p15, #0x0, r0, c7, c5, #0x0
;         MRC p15, 0, r0, c1, c0, 0  // Read System Control Register
700af6e0: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         ORR r0, r0, #0x1 << 2      // Enable data cache bit
700af6e4: e3800004     	orr	r0, r0, #4
;         ORR r0, r0, #0x1 << 12     // Enable instruction cache bit
700af6e8: e3800a01     	orr	r0, r0, #4096
;         DSB
700af6ec: f57ff04f     	dsb	sy
;         MCR p15, 0, r0, c1, c0, 0  // Write System Control Register
700af6f0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         ISB
700af6f4: f57ff06f     	isb	sy
;         BL      __mpu_init
700af6f8: fa000028     	blx	0x700af7a0 <__mpu_init> @ imm = #0xa0
;         BL      _system_pre_init
700af6fc: fa00001b     	blx	0x700af770 <_system_pre_init> @ imm = #0x6c
;         CMP     R0, #0
700af700: e3500000     	cmp	r0, #0
;         BEQ     bypass_auto_init
700af704: 0a000000     	beq	0x700af70c <bypass_auto_init> @ imm = #0x0
;         BL      __TI_auto_init
700af708: ebffee12     	bl	0x700aaf58 <__TI_auto_init_nobinit_nopinit> @ imm = #-0x47b8

700af70c <bypass_auto_init>:
;         BL      main
700af70c: fafffab3     	blx	0x700ae1e0 <main>       @ imm = #-0x1534
;         MOV     R0, #1
700af710: e3a00001     	mov	r0, #1
;         BL      exit
700af714: eb000025     	bl	0x700af7b0 <abort>      @ imm = #0x94

700af718 <L1>:
; L1:     B       L1
700af718: eafffffe     	b	0x700af718 <L1>         @ imm = #-0x8

700af71c <c_STACK_END>:
700af71c: 00 8e 09 70  	.word	0x70098e00

700af720 <c_IRQ_STACK_END>:
700af720: 10 0f 0b 70  	.word	0x700b0f10

700af724 <c_FIQ_STACK_END>:
700af724: 10 10 0b 70  	.word	0x700b1010

700af728 <c_SVC_STACK_END>:
700af728: 10 20 0b 70  	.word	0x700b2010

700af72c <c_ABORT_STACK_END>:
700af72c: 10 21 0b 70  	.word	0x700b2110

700af730 <c_UNDEFINED_STACK_END>:
700af730: 10 22 0b 70  	.word	0x700b2210
700af734: 00 00 00 00  	.word	0x00000000
700af738: 00 00 00 00  	.word	0x00000000
700af73c: 00 00 00 00  	.word	0x00000000

700af740 <_DebugP_assertNoLog>:
; {
700af740: b580         	push	{r7, lr}
700af742: b082         	sub	sp, #0x8
700af744: 9001         	str	r0, [sp, #0x4]
;     if(expression==0)
700af746: 9801         	ldr	r0, [sp, #0x4]
700af748: b950         	cbnz	r0, 0x700af760 <_DebugP_assertNoLog+0x20> @ imm = #0x14
700af74a: e7ff         	b	0x700af74c <_DebugP_assertNoLog+0xc> @ imm = #-0x2
700af74c: 2001         	movs	r0, #0x1
;         volatile uint32_t assert_loop = 1;
700af74e: 9000         	str	r0, [sp]
;         (void) HwiP_disable();
700af750: f7ff eb36    	blx	0x700aedc0 <HwiP_disable> @ imm = #-0x994
;         while(assert_loop!= 0U)
700af754: e7ff         	b	0x700af756 <_DebugP_assertNoLog+0x16> @ imm = #-0x2
700af756: 9800         	ldr	r0, [sp]
700af758: b108         	cbz	r0, 0x700af75e <_DebugP_assertNoLog+0x1e> @ imm = #0x2
700af75a: e7ff         	b	0x700af75c <_DebugP_assertNoLog+0x1c> @ imm = #-0x2
700af75c: e7fb         	b	0x700af756 <_DebugP_assertNoLog+0x16> @ imm = #-0xa
;     }
700af75e: e7ff         	b	0x700af760 <_DebugP_assertNoLog+0x20> @ imm = #-0x2
; }
700af760: b002         	add	sp, #0x8
700af762: bd80         	pop	{r7, pc}
		...

700af770 <_system_pre_init>:
; {
700af770: b580         	push	{r7, lr}
700af772: b082         	sub	sp, #0x8
;     uint32_t bss_size = ((uintptr_t)&__BSS_END - (uintptr_t)&__BSS_START);
700af774: f240 0000    	movw	r0, #0x0
700af778: f2c7 0008    	movt	r0, #0x7008
700af77c: f644 6100    	movw	r1, #0x4e00
700af780: f2c7 0108    	movt	r1, #0x7008
700af784: 1a09         	subs	r1, r1, r0
700af786: 9101         	str	r1, [sp, #0x4]
;     (void) memset((void*)&__BSS_START, 0x00, bss_size);
700af788: 9901         	ldr	r1, [sp, #0x4]
700af78a: f7ea e854    	blx	0x70099834 <__aeabi_memclr8> @ imm = #-0x15f58
700af78e: 2001         	movs	r0, #0x1
;     return 1;
700af790: b002         	add	sp, #0x8
700af792: bd80         	pop	{r7, pc}
		...

700af7a0 <__mpu_init>:
; {
700af7a0: b580         	push	{r7, lr}
;     MpuP_init();
700af7a2: f7ff fe9d    	bl	0x700af4e0 <MpuP_init>  @ imm = #-0x2c6
;     CacheP_init();
700af7a6: e8bd 4080    	pop.w	{r7, lr}
700af7aa: f7ff bd09    	b.w	0x700af1c0 <CacheP_init> @ imm = #-0x5ee
700af7ae: 0000         	movs	r0, r0

Disassembly of section .text:abort:

700af7b0 <abort>:
700af7b0: e320f000     	nop
700af7b4: eafffffe     	b	0x700af7b4 <abort+0x4>  @ imm = #-0x8

Disassembly of section .text:

70098e00 <_vsnprintf>:
; {
70098e00: e92d 43f0    	push.w	{r4, r5, r6, r7, r8, r9, lr}
70098e04: b0c1         	sub	sp, #0x104
70098e06: f8dd c120    	ldr.w	r12, [sp, #0x120]
70098e0a: f8cd c100    	str.w	r12, [sp, #0x100]
70098e0e: 903f         	str	r0, [sp, #0xfc]
70098e10: 913e         	str	r1, [sp, #0xf8]
70098e12: 923d         	str	r2, [sp, #0xf4]
70098e14: 933c         	str	r3, [sp, #0xf0]
70098e16: 2000         	movs	r0, #0x0
;   size_t idx = 0U;
70098e18: 9037         	str	r0, [sp, #0xdc]
;   if (!buffer) {
70098e1a: 983e         	ldr	r0, [sp, #0xf8]
70098e1c: b930         	cbnz	r0, 0x70098e2c <_vsnprintf+0x2c> @ imm = #0xc
70098e1e: e7ff         	b	0x70098e20 <_vsnprintf+0x20> @ imm = #-0x2
;     out = _out_null;
70098e20: f24e 0021    	movw	r0, #0xe021
70098e24: f2c7 000a    	movt	r0, #0x700a
70098e28: 903f         	str	r0, [sp, #0xfc]
;   }
70098e2a: e7ff         	b	0x70098e2c <_vsnprintf+0x2c> @ imm = #-0x2
;   while (*format)
70098e2c: e7ff         	b	0x70098e2e <_vsnprintf+0x2e> @ imm = #-0x2
70098e2e: 983c         	ldr	r0, [sp, #0xf0]
70098e30: 7800         	ldrb	r0, [r0]
70098e32: 2800         	cmp	r0, #0x0
70098e34: f000 84e3    	beq.w	0x700997fe <_vsnprintf+0x9fe> @ imm = #0x9c6
70098e38: e7ff         	b	0x70098e3a <_vsnprintf+0x3a> @ imm = #-0x2
;     if (*format != '%') {
70098e3a: 983c         	ldr	r0, [sp, #0xf0]
70098e3c: 7800         	ldrb	r0, [r0]
70098e3e: 2825         	cmp	r0, #0x25
70098e40: d00e         	beq	0x70098e60 <_vsnprintf+0x60> @ imm = #0x1c
70098e42: e7ff         	b	0x70098e44 <_vsnprintf+0x44> @ imm = #-0x2
;       out(*format, buffer, idx++, maxlen);
70098e44: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
70098e48: 983c         	ldr	r0, [sp, #0xf0]
70098e4a: 7800         	ldrb	r0, [r0]
70098e4c: 993e         	ldr	r1, [sp, #0xf8]
70098e4e: 9a37         	ldr	r2, [sp, #0xdc]
70098e50: 1c53         	adds	r3, r2, #0x1
70098e52: 9337         	str	r3, [sp, #0xdc]
70098e54: 9b3d         	ldr	r3, [sp, #0xf4]
70098e56: 47e0         	blx	r12
;       format++;
70098e58: 983c         	ldr	r0, [sp, #0xf0]
70098e5a: 3001         	adds	r0, #0x1
70098e5c: 903c         	str	r0, [sp, #0xf0]
;       continue;
70098e5e: e7e6         	b	0x70098e2e <_vsnprintf+0x2e> @ imm = #-0x34
;       format++;
70098e60: 983c         	ldr	r0, [sp, #0xf0]
70098e62: 3001         	adds	r0, #0x1
70098e64: 903c         	str	r0, [sp, #0xf0]
70098e66: e7ff         	b	0x70098e68 <_vsnprintf+0x68> @ imm = #-0x2
70098e68: 2000         	movs	r0, #0x0
;     flags = 0U;
70098e6a: 903b         	str	r0, [sp, #0xec]
;     do {
70098e6c: e7ff         	b	0x70098e6e <_vsnprintf+0x6e> @ imm = #-0x2
;       switch (*format) {
70098e6e: 983c         	ldr	r0, [sp, #0xf0]
70098e70: 7800         	ldrb	r0, [r0]
70098e72: 3820         	subs	r0, #0x20
70098e74: 4601         	mov	r1, r0
70098e76: 912a         	str	r1, [sp, #0xa8]
70098e78: 2810         	cmp	r0, #0x10
70098e7a: d83d         	bhi	0x70098ef8 <_vsnprintf+0xf8> @ imm = #0x7a
70098e7c: 992a         	ldr	r1, [sp, #0xa8]
70098e7e: e8df f001    	tbb	[pc, r1]
70098e82: 27 3b 3b 31  	.word	0x313b3b27
70098e86: 3b 3b 3b 3b  	.word	0x3b3b3b3b
70098e8a: 3b 3b 3b 1d  	.word	0x1d3b3b3b
70098e8e: 3b 13 3b 3b  	.word	0x3b3b133b
70098e92: 09 00        	.short	0x0009
;         case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
70098e94: 983b         	ldr	r0, [sp, #0xec]
70098e96: f040 0001    	orr	r0, r0, #0x1
70098e9a: 903b         	str	r0, [sp, #0xec]
70098e9c: 983c         	ldr	r0, [sp, #0xf0]
70098e9e: 3001         	adds	r0, #0x1
70098ea0: 903c         	str	r0, [sp, #0xf0]
70098ea2: 2001         	movs	r0, #0x1
70098ea4: 9038         	str	r0, [sp, #0xe0]
70098ea6: e02a         	b	0x70098efe <_vsnprintf+0xfe> @ imm = #0x54
;         case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
70098ea8: 983b         	ldr	r0, [sp, #0xec]
70098eaa: f040 0002    	orr	r0, r0, #0x2
70098eae: 903b         	str	r0, [sp, #0xec]
70098eb0: 983c         	ldr	r0, [sp, #0xf0]
70098eb2: 3001         	adds	r0, #0x1
70098eb4: 903c         	str	r0, [sp, #0xf0]
70098eb6: 2001         	movs	r0, #0x1
70098eb8: 9038         	str	r0, [sp, #0xe0]
70098eba: e020         	b	0x70098efe <_vsnprintf+0xfe> @ imm = #0x40
;         case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
70098ebc: 983b         	ldr	r0, [sp, #0xec]
70098ebe: f040 0004    	orr	r0, r0, #0x4
70098ec2: 903b         	str	r0, [sp, #0xec]
70098ec4: 983c         	ldr	r0, [sp, #0xf0]
70098ec6: 3001         	adds	r0, #0x1
70098ec8: 903c         	str	r0, [sp, #0xf0]
70098eca: 2001         	movs	r0, #0x1
70098ecc: 9038         	str	r0, [sp, #0xe0]
70098ece: e016         	b	0x70098efe <_vsnprintf+0xfe> @ imm = #0x2c
;         case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
70098ed0: 983b         	ldr	r0, [sp, #0xec]
70098ed2: f040 0008    	orr	r0, r0, #0x8
70098ed6: 903b         	str	r0, [sp, #0xec]
70098ed8: 983c         	ldr	r0, [sp, #0xf0]
70098eda: 3001         	adds	r0, #0x1
70098edc: 903c         	str	r0, [sp, #0xf0]
70098ede: 2001         	movs	r0, #0x1
70098ee0: 9038         	str	r0, [sp, #0xe0]
70098ee2: e00c         	b	0x70098efe <_vsnprintf+0xfe> @ imm = #0x18
;         case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
70098ee4: 983b         	ldr	r0, [sp, #0xec]
70098ee6: f040 0010    	orr	r0, r0, #0x10
70098eea: 903b         	str	r0, [sp, #0xec]
70098eec: 983c         	ldr	r0, [sp, #0xf0]
70098eee: 3001         	adds	r0, #0x1
70098ef0: 903c         	str	r0, [sp, #0xf0]
70098ef2: 2001         	movs	r0, #0x1
70098ef4: 9038         	str	r0, [sp, #0xe0]
70098ef6: e002         	b	0x70098efe <_vsnprintf+0xfe> @ imm = #0x4
70098ef8: 2000         	movs	r0, #0x0
;         default :                                   n = 0U; break;
70098efa: 9038         	str	r0, [sp, #0xe0]
70098efc: e7ff         	b	0x70098efe <_vsnprintf+0xfe> @ imm = #-0x2
;     } while (n);
70098efe: e7ff         	b	0x70098f00 <_vsnprintf+0x100> @ imm = #-0x2
70098f00: 9838         	ldr	r0, [sp, #0xe0]
70098f02: 2800         	cmp	r0, #0x0
70098f04: d1b3         	bne	0x70098e6e <_vsnprintf+0x6e> @ imm = #-0x9a
70098f06: e7ff         	b	0x70098f08 <_vsnprintf+0x108> @ imm = #-0x2
70098f08: 2000         	movs	r0, #0x0
;     width = 0U;
70098f0a: 903a         	str	r0, [sp, #0xe8]
;     if (_is_digit(*format)) {
70098f0c: 983c         	ldr	r0, [sp, #0xf0]
70098f0e: 7800         	ldrb	r0, [r0]
70098f10: f013 ff76    	bl	0x700ace00 <_is_digit>  @ imm = #0x13eec
70098f14: b128         	cbz	r0, 0x70098f22 <_vsnprintf+0x122> @ imm = #0xa
70098f16: e7ff         	b	0x70098f18 <_vsnprintf+0x118> @ imm = #-0x2
70098f18: a83c         	add	r0, sp, #0xf0
;       width = _atoi(&format);
70098f1a: f013 fb81    	bl	0x700ac620 <_atoi>      @ imm = #0x13702
70098f1e: 903a         	str	r0, [sp, #0xe8]
;     }
70098f20: e01e         	b	0x70098f60 <_vsnprintf+0x160> @ imm = #0x3c
;     else if (*format == '*') {
70098f22: 983c         	ldr	r0, [sp, #0xf0]
70098f24: 7800         	ldrb	r0, [r0]
70098f26: 282a         	cmp	r0, #0x2a
70098f28: d119         	bne	0x70098f5e <_vsnprintf+0x15e> @ imm = #0x32
70098f2a: e7ff         	b	0x70098f2c <_vsnprintf+0x12c> @ imm = #-0x2
;       const int w = va_arg(va, int);
70098f2c: 9840         	ldr	r0, [sp, #0x100]
70098f2e: 1d01         	adds	r1, r0, #0x4
70098f30: 9140         	str	r1, [sp, #0x100]
70098f32: 6800         	ldr	r0, [r0]
70098f34: 9036         	str	r0, [sp, #0xd8]
;       if (w < 0) {
70098f36: 9836         	ldr	r0, [sp, #0xd8]
70098f38: f1b0 3fff    	cmp.w	r0, #0xffffffff
70098f3c: dc08         	bgt	0x70098f50 <_vsnprintf+0x150> @ imm = #0x10
70098f3e: e7ff         	b	0x70098f40 <_vsnprintf+0x140> @ imm = #-0x2
;         flags |= FLAGS_LEFT;    // reverse padding
70098f40: 983b         	ldr	r0, [sp, #0xec]
70098f42: f040 0002    	orr	r0, r0, #0x2
70098f46: 903b         	str	r0, [sp, #0xec]
;         width = (unsigned int)-w;
70098f48: 9836         	ldr	r0, [sp, #0xd8]
70098f4a: 4240         	rsbs	r0, r0, #0
70098f4c: 903a         	str	r0, [sp, #0xe8]
;       }
70098f4e: e002         	b	0x70098f56 <_vsnprintf+0x156> @ imm = #0x4
;         width = (unsigned int)w;
70098f50: 9836         	ldr	r0, [sp, #0xd8]
70098f52: 903a         	str	r0, [sp, #0xe8]
70098f54: e7ff         	b	0x70098f56 <_vsnprintf+0x156> @ imm = #-0x2
;       format++;
70098f56: 983c         	ldr	r0, [sp, #0xf0]
70098f58: 3001         	adds	r0, #0x1
70098f5a: 903c         	str	r0, [sp, #0xf0]
;     }
70098f5c: e7ff         	b	0x70098f5e <_vsnprintf+0x15e> @ imm = #-0x2
70098f5e: e7ff         	b	0x70098f60 <_vsnprintf+0x160> @ imm = #-0x2
70098f60: 2000         	movs	r0, #0x0
;     precision = 0U;
70098f62: 9039         	str	r0, [sp, #0xe4]
;     if (*format == '.') {
70098f64: 983c         	ldr	r0, [sp, #0xf0]
70098f66: 7800         	ldrb	r0, [r0]
70098f68: 282e         	cmp	r0, #0x2e
70098f6a: d12e         	bne	0x70098fca <_vsnprintf+0x1ca> @ imm = #0x5c
70098f6c: e7ff         	b	0x70098f6e <_vsnprintf+0x16e> @ imm = #-0x2
;       flags |= FLAGS_PRECISION;
70098f6e: 983b         	ldr	r0, [sp, #0xec]
70098f70: f440 6080    	orr	r0, r0, #0x400
70098f74: 903b         	str	r0, [sp, #0xec]
;       format++;
70098f76: 983c         	ldr	r0, [sp, #0xf0]
70098f78: 3001         	adds	r0, #0x1
70098f7a: 903c         	str	r0, [sp, #0xf0]
;       if (_is_digit(*format)) {
70098f7c: 983c         	ldr	r0, [sp, #0xf0]
70098f7e: 7800         	ldrb	r0, [r0]
70098f80: f013 ff3e    	bl	0x700ace00 <_is_digit>  @ imm = #0x13e7c
70098f84: b128         	cbz	r0, 0x70098f92 <_vsnprintf+0x192> @ imm = #0xa
70098f86: e7ff         	b	0x70098f88 <_vsnprintf+0x188> @ imm = #-0x2
70098f88: a83c         	add	r0, sp, #0xf0
;         precision = _atoi(&format);
70098f8a: f013 fb49    	bl	0x700ac620 <_atoi>      @ imm = #0x13692
70098f8e: 9039         	str	r0, [sp, #0xe4]
;       }
70098f90: e01a         	b	0x70098fc8 <_vsnprintf+0x1c8> @ imm = #0x34
;       else if (*format == '*') {
70098f92: 983c         	ldr	r0, [sp, #0xf0]
70098f94: 7800         	ldrb	r0, [r0]
70098f96: 282a         	cmp	r0, #0x2a
70098f98: d115         	bne	0x70098fc6 <_vsnprintf+0x1c6> @ imm = #0x2a
70098f9a: e7ff         	b	0x70098f9c <_vsnprintf+0x19c> @ imm = #-0x2
;         const int prec = (int)va_arg(va, int);
70098f9c: 9840         	ldr	r0, [sp, #0x100]
70098f9e: 1d01         	adds	r1, r0, #0x4
70098fa0: 9140         	str	r1, [sp, #0x100]
70098fa2: 6800         	ldr	r0, [r0]
70098fa4: 9035         	str	r0, [sp, #0xd4]
;         precision = prec > 0 ? (unsigned int)prec : 0U;
70098fa6: 9835         	ldr	r0, [sp, #0xd4]
70098fa8: 2801         	cmp	r0, #0x1
70098faa: db03         	blt	0x70098fb4 <_vsnprintf+0x1b4> @ imm = #0x6
70098fac: e7ff         	b	0x70098fae <_vsnprintf+0x1ae> @ imm = #-0x2
70098fae: 9835         	ldr	r0, [sp, #0xd4]
70098fb0: 9029         	str	r0, [sp, #0xa4]
70098fb2: e002         	b	0x70098fba <_vsnprintf+0x1ba> @ imm = #0x4
70098fb4: 2000         	movs	r0, #0x0
;         precision = prec > 0 ? (unsigned int)prec : 0U;
70098fb6: 9029         	str	r0, [sp, #0xa4]
70098fb8: e7ff         	b	0x70098fba <_vsnprintf+0x1ba> @ imm = #-0x2
70098fba: 9829         	ldr	r0, [sp, #0xa4]
70098fbc: 9039         	str	r0, [sp, #0xe4]
;         format++;
70098fbe: 983c         	ldr	r0, [sp, #0xf0]
70098fc0: 3001         	adds	r0, #0x1
70098fc2: 903c         	str	r0, [sp, #0xf0]
;       }
70098fc4: e7ff         	b	0x70098fc6 <_vsnprintf+0x1c6> @ imm = #-0x2
70098fc6: e7ff         	b	0x70098fc8 <_vsnprintf+0x1c8> @ imm = #-0x2
;     }
70098fc8: e7ff         	b	0x70098fca <_vsnprintf+0x1ca> @ imm = #-0x2
;     switch (*format) {
70098fca: 983c         	ldr	r0, [sp, #0xf0]
70098fcc: 7800         	ldrb	r0, [r0]
70098fce: 3868         	subs	r0, #0x68
70098fd0: 4601         	mov	r1, r0
70098fd2: 9128         	str	r1, [sp, #0xa0]
70098fd4: 2812         	cmp	r0, #0x12
70098fd6: d84e         	bhi	0x70099076 <_vsnprintf+0x276> @ imm = #0x9c
70098fd8: 9928         	ldr	r1, [sp, #0xa0]
70098fda: e8df f001    	tbb	[pc, r1]
70098fde: 1f 4c 3c 4c  	.word	0x4c3c4c1f
70098fe2: 0a 4c 4c 4c  	.word	0x4c4c4c0a
70098fe6: 4c 4c 4c 4c  	.word	0x4c4c4c4c
70098fea: 34 4c 4c 4c  	.word	0x4c4c4c34
70098fee: 4c 4c 44 00  	.word	0x00444c4c
;         flags |= FLAGS_LONG;
70098ff2: 983b         	ldr	r0, [sp, #0xec]
70098ff4: f440 7080    	orr	r0, r0, #0x100
70098ff8: 903b         	str	r0, [sp, #0xec]
;         format++;
70098ffa: 983c         	ldr	r0, [sp, #0xf0]
70098ffc: 3001         	adds	r0, #0x1
70098ffe: 903c         	str	r0, [sp, #0xf0]
;         if (*format == 'l') {
70099000: 983c         	ldr	r0, [sp, #0xf0]
70099002: 7800         	ldrb	r0, [r0]
70099004: 286c         	cmp	r0, #0x6c
70099006: d108         	bne	0x7009901a <_vsnprintf+0x21a> @ imm = #0x10
70099008: e7ff         	b	0x7009900a <_vsnprintf+0x20a> @ imm = #-0x2
;           flags |= FLAGS_LONG_LONG;
7009900a: 983b         	ldr	r0, [sp, #0xec]
7009900c: f440 7000    	orr	r0, r0, #0x200
70099010: 903b         	str	r0, [sp, #0xec]
;           format++;
70099012: 983c         	ldr	r0, [sp, #0xf0]
70099014: 3001         	adds	r0, #0x1
70099016: 903c         	str	r0, [sp, #0xf0]
;         }
70099018: e7ff         	b	0x7009901a <_vsnprintf+0x21a> @ imm = #-0x2
;         break;
7009901a: e02d         	b	0x70099078 <_vsnprintf+0x278> @ imm = #0x5a
;         flags |= FLAGS_SHORT;
7009901c: 983b         	ldr	r0, [sp, #0xec]
7009901e: f040 0080    	orr	r0, r0, #0x80
70099022: 903b         	str	r0, [sp, #0xec]
;         format++;
70099024: 983c         	ldr	r0, [sp, #0xf0]
70099026: 3001         	adds	r0, #0x1
70099028: 903c         	str	r0, [sp, #0xf0]
;         if (*format == 'h') {
7009902a: 983c         	ldr	r0, [sp, #0xf0]
7009902c: 7800         	ldrb	r0, [r0]
7009902e: 2868         	cmp	r0, #0x68
70099030: d108         	bne	0x70099044 <_vsnprintf+0x244> @ imm = #0x10
70099032: e7ff         	b	0x70099034 <_vsnprintf+0x234> @ imm = #-0x2
;           flags |= FLAGS_CHAR;
70099034: 983b         	ldr	r0, [sp, #0xec]
70099036: f040 0040    	orr	r0, r0, #0x40
7009903a: 903b         	str	r0, [sp, #0xec]
;           format++;
7009903c: 983c         	ldr	r0, [sp, #0xf0]
7009903e: 3001         	adds	r0, #0x1
70099040: 903c         	str	r0, [sp, #0xf0]
;         }
70099042: e7ff         	b	0x70099044 <_vsnprintf+0x244> @ imm = #-0x2
;         break;
70099044: e018         	b	0x70099078 <_vsnprintf+0x278> @ imm = #0x30
;         flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
70099046: 983b         	ldr	r0, [sp, #0xec]
70099048: f440 7080    	orr	r0, r0, #0x100
7009904c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009904e: 983c         	ldr	r0, [sp, #0xf0]
70099050: 3001         	adds	r0, #0x1
70099052: 903c         	str	r0, [sp, #0xf0]
;         break;
70099054: e010         	b	0x70099078 <_vsnprintf+0x278> @ imm = #0x20
;         flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
70099056: 983b         	ldr	r0, [sp, #0xec]
70099058: f440 7000    	orr	r0, r0, #0x200
7009905c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009905e: 983c         	ldr	r0, [sp, #0xf0]
70099060: 3001         	adds	r0, #0x1
70099062: 903c         	str	r0, [sp, #0xf0]
;         break;
70099064: e008         	b	0x70099078 <_vsnprintf+0x278> @ imm = #0x10
;         flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
70099066: 983b         	ldr	r0, [sp, #0xec]
70099068: f440 7080    	orr	r0, r0, #0x100
7009906c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009906e: 983c         	ldr	r0, [sp, #0xf0]
70099070: 3001         	adds	r0, #0x1
70099072: 903c         	str	r0, [sp, #0xf0]
;         break;
70099074: e000         	b	0x70099078 <_vsnprintf+0x278> @ imm = #0x0
;         break;
70099076: e7ff         	b	0x70099078 <_vsnprintf+0x278> @ imm = #-0x2
;     switch (*format) {
70099078: 983c         	ldr	r0, [sp, #0xf0]
7009907a: 7800         	ldrb	r0, [r0]
7009907c: 3825         	subs	r0, #0x25
7009907e: 4601         	mov	r1, r0
70099080: 9127         	str	r1, [sp, #0x9c]
70099082: 2853         	cmp	r0, #0x53
70099084: f200 83ab    	bhi.w	0x700997de <_vsnprintf+0x9de> @ imm = #0x756
70099088: 9927         	ldr	r1, [sp, #0x9c]
7009908a: e8df f011    	tbh	[pc, r1, lsl #1]
7009908e: 9b 03 a8 03  	.word	0x03a8039b
70099092: a8 03 a8 03  	.word	0x03a803a8
70099096: a8 03 a8 03  	.word	0x03a803a8
7009909a: a8 03 a8 03  	.word	0x03a803a8
7009909e: a8 03 a8 03  	.word	0x03a803a8
700990a2: a8 03 a8 03  	.word	0x03a803a8
700990a6: a8 03 a8 03  	.word	0x03a803a8
700990aa: a8 03 a8 03  	.word	0x03a803a8
700990ae: a8 03 a8 03  	.word	0x03a803a8
700990b2: a8 03 a8 03  	.word	0x03a803a8
700990b6: a8 03 a8 03  	.word	0x03a803a8
700990ba: a8 03 a8 03  	.word	0x03a803a8
700990be: a8 03 a8 03  	.word	0x03a803a8
700990c2: a8 03 a8 03  	.word	0x03a803a8
700990c6: a8 03 a8 03  	.word	0x03a803a8
700990ca: a8 03 a8 03  	.word	0x03a803a8
700990ce: 5e 02 32 02  	.word	0x0232025e
700990d2: 5e 02 a8 03  	.word	0x03a8025e
700990d6: a8 03 a8 03  	.word	0x03a803a8
700990da: a8 03 a8 03  	.word	0x03a803a8
700990de: a8 03 a8 03  	.word	0x03a803a8
700990e2: a8 03 a8 03  	.word	0x03a803a8
700990e6: a8 03 a8 03  	.word	0x03a803a8
700990ea: a8 03 a8 03  	.word	0x03a803a8
700990ee: a8 03 a8 03  	.word	0x03a803a8
700990f2: a8 03 54 00  	.word	0x005403a8
700990f6: a8 03 a8 03  	.word	0x03a803a8
700990fa: a8 03 a8 03  	.word	0x03a803a8
700990fe: a8 03 a8 03  	.word	0x03a803a8
70099102: a8 03 a8 03  	.word	0x03a803a8
70099106: a8 03 54 00  	.word	0x005403a8
7009910a: 9e 02 54 00  	.word	0x0054029e
7009910e: 5e 02 32 02  	.word	0x0232025e
70099112: 5e 02 a8 03  	.word	0x03a8025e
70099116: 54 00 a8 03  	.word	0x03a80054
7009911a: a8 03 a8 03  	.word	0x03a803a8
7009911e: a8 03 a8 03  	.word	0x03a803a8
70099122: 54 00 6e 03  	.word	0x036e0054
70099126: a8 03 a8 03  	.word	0x03a803a8
7009912a: e2 02 a8 03  	.word	0x03a802e2
7009912e: 54 00 a8 03  	.word	0x03a80054
70099132: a8 03 54 00  	.word	0x005403a8
;         if (*format == 'x' || *format == 'X') {
70099136: 983c         	ldr	r0, [sp, #0xf0]
70099138: 7800         	ldrb	r0, [r0]
7009913a: 2878         	cmp	r0, #0x78
7009913c: d005         	beq	0x7009914a <_vsnprintf+0x34a> @ imm = #0xa
7009913e: e7ff         	b	0x70099140 <_vsnprintf+0x340> @ imm = #-0x2
70099140: 983c         	ldr	r0, [sp, #0xf0]
70099142: 7800         	ldrb	r0, [r0]
70099144: 2858         	cmp	r0, #0x58
70099146: d103         	bne	0x70099150 <_vsnprintf+0x350> @ imm = #0x6
70099148: e7ff         	b	0x7009914a <_vsnprintf+0x34a> @ imm = #-0x2
7009914a: 2010         	movs	r0, #0x10
;           base = 16U;
7009914c: 9034         	str	r0, [sp, #0xd0]
;         }
7009914e: e018         	b	0x70099182 <_vsnprintf+0x382> @ imm = #0x30
;         else if (*format == 'o') {
70099150: 983c         	ldr	r0, [sp, #0xf0]
70099152: 7800         	ldrb	r0, [r0]
70099154: 286f         	cmp	r0, #0x6f
70099156: d103         	bne	0x70099160 <_vsnprintf+0x360> @ imm = #0x6
70099158: e7ff         	b	0x7009915a <_vsnprintf+0x35a> @ imm = #-0x2
7009915a: 2008         	movs	r0, #0x8
;           base =  8U;
7009915c: 9034         	str	r0, [sp, #0xd0]
;         }
7009915e: e00f         	b	0x70099180 <_vsnprintf+0x380> @ imm = #0x1e
;         else if (*format == 'b') {
70099160: 983c         	ldr	r0, [sp, #0xf0]
70099162: 7800         	ldrb	r0, [r0]
70099164: 2862         	cmp	r0, #0x62
70099166: d103         	bne	0x70099170 <_vsnprintf+0x370> @ imm = #0x6
70099168: e7ff         	b	0x7009916a <_vsnprintf+0x36a> @ imm = #-0x2
7009916a: 2002         	movs	r0, #0x2
;           base =  2U;
7009916c: 9034         	str	r0, [sp, #0xd0]
;         }
7009916e: e006         	b	0x7009917e <_vsnprintf+0x37e> @ imm = #0xc
70099170: 200a         	movs	r0, #0xa
;           base = 10U;
70099172: 9034         	str	r0, [sp, #0xd0]
;           flags &= ~FLAGS_HASH;   // no hash for dec format
70099174: 983b         	ldr	r0, [sp, #0xec]
70099176: f020 0010    	bic	r0, r0, #0x10
7009917a: 903b         	str	r0, [sp, #0xec]
7009917c: e7ff         	b	0x7009917e <_vsnprintf+0x37e> @ imm = #-0x2
7009917e: e7ff         	b	0x70099180 <_vsnprintf+0x380> @ imm = #-0x2
70099180: e7ff         	b	0x70099182 <_vsnprintf+0x382> @ imm = #-0x2
;         if (*format == 'X') {
70099182: 983c         	ldr	r0, [sp, #0xf0]
70099184: 7800         	ldrb	r0, [r0]
70099186: 2858         	cmp	r0, #0x58
70099188: d105         	bne	0x70099196 <_vsnprintf+0x396> @ imm = #0xa
7009918a: e7ff         	b	0x7009918c <_vsnprintf+0x38c> @ imm = #-0x2
;           flags |= FLAGS_UPPERCASE;
7009918c: 983b         	ldr	r0, [sp, #0xec]
7009918e: f040 0020    	orr	r0, r0, #0x20
70099192: 903b         	str	r0, [sp, #0xec]
;         }
70099194: e7ff         	b	0x70099196 <_vsnprintf+0x396> @ imm = #-0x2
;         if ((*format != 'i') && (*format != 'd')) {
70099196: 983c         	ldr	r0, [sp, #0xf0]
70099198: 7800         	ldrb	r0, [r0]
7009919a: 2869         	cmp	r0, #0x69
7009919c: d00a         	beq	0x700991b4 <_vsnprintf+0x3b4> @ imm = #0x14
7009919e: e7ff         	b	0x700991a0 <_vsnprintf+0x3a0> @ imm = #-0x2
700991a0: 983c         	ldr	r0, [sp, #0xf0]
700991a2: 7800         	ldrb	r0, [r0]
700991a4: 2864         	cmp	r0, #0x64
700991a6: d005         	beq	0x700991b4 <_vsnprintf+0x3b4> @ imm = #0xa
700991a8: e7ff         	b	0x700991aa <_vsnprintf+0x3aa> @ imm = #-0x2
;           flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
700991aa: 983b         	ldr	r0, [sp, #0xec]
700991ac: f020 000c    	bic	r0, r0, #0xc
700991b0: 903b         	str	r0, [sp, #0xec]
;         }
700991b2: e7ff         	b	0x700991b4 <_vsnprintf+0x3b4> @ imm = #-0x2
;         if (flags & FLAGS_PRECISION) {
700991b4: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
700991b8: 0740         	lsls	r0, r0, #0x1d
700991ba: 2800         	cmp	r0, #0x0
700991bc: d505         	bpl	0x700991ca <_vsnprintf+0x3ca> @ imm = #0xa
700991be: e7ff         	b	0x700991c0 <_vsnprintf+0x3c0> @ imm = #-0x2
;           flags &= ~FLAGS_ZEROPAD;
700991c0: 983b         	ldr	r0, [sp, #0xec]
700991c2: f020 0001    	bic	r0, r0, #0x1
700991c6: 903b         	str	r0, [sp, #0xec]
;         }
700991c8: e7ff         	b	0x700991ca <_vsnprintf+0x3ca> @ imm = #-0x2
;         if ((*format == 'i') || (*format == 'd')) {
700991ca: 983c         	ldr	r0, [sp, #0xf0]
700991cc: 7800         	ldrb	r0, [r0]
700991ce: 2869         	cmp	r0, #0x69
700991d0: d006         	beq	0x700991e0 <_vsnprintf+0x3e0> @ imm = #0xc
700991d2: e7ff         	b	0x700991d4 <_vsnprintf+0x3d4> @ imm = #-0x2
700991d4: 983c         	ldr	r0, [sp, #0xf0]
700991d6: 7800         	ldrb	r0, [r0]
700991d8: 2864         	cmp	r0, #0x64
700991da: f040 80e9    	bne.w	0x700993b0 <_vsnprintf+0x5b0> @ imm = #0x1d2
700991de: e7ff         	b	0x700991e0 <_vsnprintf+0x3e0> @ imm = #-0x2
;           if (flags & FLAGS_LONG_LONG) {
700991e0: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
700991e4: 0780         	lsls	r0, r0, #0x1e
700991e6: 2800         	cmp	r0, #0x0
700991e8: d550         	bpl	0x7009928c <_vsnprintf+0x48c> @ imm = #0xa0
700991ea: e7ff         	b	0x700991ec <_vsnprintf+0x3ec> @ imm = #-0x2
;             const long long value = va_arg(va, long long);
700991ec: 9840         	ldr	r0, [sp, #0x100]
700991ee: 3007         	adds	r0, #0x7
700991f0: f020 0107    	bic	r1, r0, #0x7
700991f4: f101 0008    	add.w	r0, r1, #0x8
700991f8: 9040         	str	r0, [sp, #0x100]
700991fa: 6808         	ldr	r0, [r1]
700991fc: 6849         	ldr	r1, [r1, #0x4]
700991fe: 9133         	str	r1, [sp, #0xcc]
70099200: 9032         	str	r0, [sp, #0xc8]
;             idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
70099202: 983f         	ldr	r0, [sp, #0xfc]
70099204: 9023         	str	r0, [sp, #0x8c]
70099206: 983e         	ldr	r0, [sp, #0xf8]
70099208: 9024         	str	r0, [sp, #0x90]
7009920a: 9837         	ldr	r0, [sp, #0xdc]
7009920c: 9025         	str	r0, [sp, #0x94]
7009920e: 983d         	ldr	r0, [sp, #0xf4]
70099210: 9026         	str	r0, [sp, #0x98]
70099212: 9932         	ldr	r1, [sp, #0xc8]
70099214: 9833         	ldr	r0, [sp, #0xcc]
70099216: 3901         	subs	r1, #0x1
70099218: f170 0000    	sbcs	r0, r0, #0x0
7009921c: db05         	blt	0x7009922a <_vsnprintf+0x42a> @ imm = #0xa
7009921e: e7ff         	b	0x70099220 <_vsnprintf+0x420> @ imm = #-0x2
70099220: 9932         	ldr	r1, [sp, #0xc8]
70099222: 9833         	ldr	r0, [sp, #0xcc]
70099224: 9121         	str	r1, [sp, #0x84]
70099226: 9022         	str	r0, [sp, #0x88]
70099228: e008         	b	0x7009923c <_vsnprintf+0x43c> @ imm = #0x10
7009922a: 9832         	ldr	r0, [sp, #0xc8]
7009922c: 9a33         	ldr	r2, [sp, #0xcc]
7009922e: 4241         	rsbs	r1, r0, #0
70099230: f04f 0000    	mov.w	r0, #0x0
70099234: 4190         	sbcs	r0, r2
70099236: 9121         	str	r1, [sp, #0x84]
70099238: 9022         	str	r0, [sp, #0x88]
7009923a: e7ff         	b	0x7009923c <_vsnprintf+0x43c> @ imm = #-0x2
7009923c: 9b26         	ldr	r3, [sp, #0x98]
7009923e: 9a25         	ldr	r2, [sp, #0x94]
70099240: 9924         	ldr	r1, [sp, #0x90]
70099242: 9823         	ldr	r0, [sp, #0x8c]
70099244: f8dd c084    	ldr.w	r12, [sp, #0x84]
70099248: 9c22         	ldr	r4, [sp, #0x88]
7009924a: 9d33         	ldr	r5, [sp, #0xcc]
7009924c: 9e34         	ldr	r6, [sp, #0xd0]
7009924e: 9f39         	ldr	r7, [sp, #0xe4]
70099250: f8dd 80e8    	ldr.w	r8, [sp, #0xe8]
70099254: f8dd 90ec    	ldr.w	r9, [sp, #0xec]
70099258: 46ee         	mov	lr, sp
7009925a: f8cd e080    	str.w	lr, [sp, #0x80]
7009925e: f8ce 9020    	str.w	r9, [lr, #0x20]
70099262: f8ce 801c    	str.w	r8, [lr, #0x1c]
70099266: f8ce 7018    	str.w	r7, [lr, #0x18]
7009926a: 2700         	movs	r7, #0x0
7009926c: f8ce 7014    	str.w	r7, [lr, #0x14]
70099270: f8ce 6010    	str.w	r6, [lr, #0x10]
70099274: ea4f 75d5    	lsr.w	r5, r5, #0x1f
70099278: f8ce 5008    	str.w	r5, [lr, #0x8]
7009927c: f8ce 4004    	str.w	r4, [lr, #0x4]
70099280: f8ce c000    	str.w	r12, [lr]
70099284: f008 f82c    	bl	0x700a12e0 <_ntoa_long_long> @ imm = #0x8058
70099288: 9037         	str	r0, [sp, #0xdc]
;           }
7009928a: e090         	b	0x700993ae <_vsnprintf+0x5ae> @ imm = #0x120
;           else if (flags & FLAGS_LONG) {
7009928c: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
70099290: 07c0         	lsls	r0, r0, #0x1f
70099292: b3b0         	cbz	r0, 0x70099302 <_vsnprintf+0x502> @ imm = #0x6c
70099294: e7ff         	b	0x70099296 <_vsnprintf+0x496> @ imm = #-0x2
;             const long value = va_arg(va, long);
70099296: 9840         	ldr	r0, [sp, #0x100]
70099298: 1d01         	adds	r1, r0, #0x4
7009929a: 9140         	str	r1, [sp, #0x100]
7009929c: 6800         	ldr	r0, [r0]
7009929e: 9031         	str	r0, [sp, #0xc4]
;             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
700992a0: 983f         	ldr	r0, [sp, #0xfc]
700992a2: 901c         	str	r0, [sp, #0x70]
700992a4: 983e         	ldr	r0, [sp, #0xf8]
700992a6: 901d         	str	r0, [sp, #0x74]
700992a8: 9837         	ldr	r0, [sp, #0xdc]
700992aa: 901e         	str	r0, [sp, #0x78]
700992ac: 983d         	ldr	r0, [sp, #0xf4]
700992ae: 901f         	str	r0, [sp, #0x7c]
700992b0: 9831         	ldr	r0, [sp, #0xc4]
700992b2: 2801         	cmp	r0, #0x1
700992b4: db03         	blt	0x700992be <_vsnprintf+0x4be> @ imm = #0x6
700992b6: e7ff         	b	0x700992b8 <_vsnprintf+0x4b8> @ imm = #-0x2
700992b8: 9831         	ldr	r0, [sp, #0xc4]
700992ba: 901b         	str	r0, [sp, #0x6c]
700992bc: e003         	b	0x700992c6 <_vsnprintf+0x4c6> @ imm = #0x6
700992be: 9831         	ldr	r0, [sp, #0xc4]
700992c0: 4240         	rsbs	r0, r0, #0
700992c2: 901b         	str	r0, [sp, #0x6c]
700992c4: e7ff         	b	0x700992c6 <_vsnprintf+0x4c6> @ imm = #-0x2
700992c6: 9b1f         	ldr	r3, [sp, #0x7c]
700992c8: 9a1e         	ldr	r2, [sp, #0x78]
700992ca: 991d         	ldr	r1, [sp, #0x74]
700992cc: 981c         	ldr	r0, [sp, #0x70]
700992ce: f8dd c06c    	ldr.w	r12, [sp, #0x6c]
700992d2: 9c31         	ldr	r4, [sp, #0xc4]
700992d4: 9d34         	ldr	r5, [sp, #0xd0]
700992d6: 9e39         	ldr	r6, [sp, #0xe4]
700992d8: 9f3a         	ldr	r7, [sp, #0xe8]
700992da: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
700992de: 46ee         	mov	lr, sp
700992e0: f8ce 8014    	str.w	r8, [lr, #0x14]
700992e4: f8ce 7010    	str.w	r7, [lr, #0x10]
700992e8: f8ce 600c    	str.w	r6, [lr, #0xc]
700992ec: f8ce 5008    	str.w	r5, [lr, #0x8]
700992f0: 0fe4         	lsrs	r4, r4, #0x1f
700992f2: f8ce 4004    	str.w	r4, [lr, #0x4]
700992f6: f8ce c000    	str.w	r12, [lr]
700992fa: f009 ffc9    	bl	0x700a3290 <_ntoa_long> @ imm = #0x9f92
700992fe: 9037         	str	r0, [sp, #0xdc]
;           }
70099300: e054         	b	0x700993ac <_vsnprintf+0x5ac> @ imm = #0xa8
;             const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
70099302: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
70099306: 0640         	lsls	r0, r0, #0x19
70099308: 2800         	cmp	r0, #0x0
7009930a: d506         	bpl	0x7009931a <_vsnprintf+0x51a> @ imm = #0xc
7009930c: e7ff         	b	0x7009930e <_vsnprintf+0x50e> @ imm = #-0x2
7009930e: 9840         	ldr	r0, [sp, #0x100]
70099310: 1d01         	adds	r1, r0, #0x4
70099312: 9140         	str	r1, [sp, #0x100]
70099314: 7800         	ldrb	r0, [r0]
70099316: 901a         	str	r0, [sp, #0x68]
70099318: e015         	b	0x70099346 <_vsnprintf+0x546> @ imm = #0x2a
7009931a: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009931e: 0600         	lsls	r0, r0, #0x18
70099320: 2800         	cmp	r0, #0x0
70099322: d507         	bpl	0x70099334 <_vsnprintf+0x534> @ imm = #0xe
70099324: e7ff         	b	0x70099326 <_vsnprintf+0x526> @ imm = #-0x2
70099326: 9840         	ldr	r0, [sp, #0x100]
70099328: 1d01         	adds	r1, r0, #0x4
7009932a: 9140         	str	r1, [sp, #0x100]
7009932c: f9b0 0000    	ldrsh.w	r0, [r0]
70099330: 9019         	str	r0, [sp, #0x64]
70099332: e005         	b	0x70099340 <_vsnprintf+0x540> @ imm = #0xa
70099334: 9840         	ldr	r0, [sp, #0x100]
70099336: 1d01         	adds	r1, r0, #0x4
70099338: 9140         	str	r1, [sp, #0x100]
7009933a: 6800         	ldr	r0, [r0]
7009933c: 9019         	str	r0, [sp, #0x64]
7009933e: e7ff         	b	0x70099340 <_vsnprintf+0x540> @ imm = #-0x2
70099340: 9819         	ldr	r0, [sp, #0x64]
70099342: 901a         	str	r0, [sp, #0x68]
70099344: e7ff         	b	0x70099346 <_vsnprintf+0x546> @ imm = #-0x2
70099346: 981a         	ldr	r0, [sp, #0x68]
70099348: 9030         	str	r0, [sp, #0xc0]
;             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009934a: 983f         	ldr	r0, [sp, #0xfc]
7009934c: 9015         	str	r0, [sp, #0x54]
7009934e: 983e         	ldr	r0, [sp, #0xf8]
70099350: 9016         	str	r0, [sp, #0x58]
70099352: 9837         	ldr	r0, [sp, #0xdc]
70099354: 9017         	str	r0, [sp, #0x5c]
70099356: 983d         	ldr	r0, [sp, #0xf4]
70099358: 9018         	str	r0, [sp, #0x60]
7009935a: 9830         	ldr	r0, [sp, #0xc0]
7009935c: 2801         	cmp	r0, #0x1
7009935e: db03         	blt	0x70099368 <_vsnprintf+0x568> @ imm = #0x6
70099360: e7ff         	b	0x70099362 <_vsnprintf+0x562> @ imm = #-0x2
70099362: 9830         	ldr	r0, [sp, #0xc0]
70099364: 9014         	str	r0, [sp, #0x50]
70099366: e003         	b	0x70099370 <_vsnprintf+0x570> @ imm = #0x6
70099368: 9830         	ldr	r0, [sp, #0xc0]
7009936a: 4240         	rsbs	r0, r0, #0
7009936c: 9014         	str	r0, [sp, #0x50]
7009936e: e7ff         	b	0x70099370 <_vsnprintf+0x570> @ imm = #-0x2
70099370: 9b18         	ldr	r3, [sp, #0x60]
70099372: 9a17         	ldr	r2, [sp, #0x5c]
70099374: 9916         	ldr	r1, [sp, #0x58]
70099376: 9815         	ldr	r0, [sp, #0x54]
70099378: f8dd c050    	ldr.w	r12, [sp, #0x50]
7009937c: 9c30         	ldr	r4, [sp, #0xc0]
7009937e: 9d34         	ldr	r5, [sp, #0xd0]
70099380: 9e39         	ldr	r6, [sp, #0xe4]
70099382: 9f3a         	ldr	r7, [sp, #0xe8]
70099384: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
70099388: 46ee         	mov	lr, sp
7009938a: f8ce 8014    	str.w	r8, [lr, #0x14]
7009938e: f8ce 7010    	str.w	r7, [lr, #0x10]
70099392: f8ce 600c    	str.w	r6, [lr, #0xc]
70099396: f8ce 5008    	str.w	r5, [lr, #0x8]
7009939a: 0fe4         	lsrs	r4, r4, #0x1f
7009939c: f8ce 4004    	str.w	r4, [lr, #0x4]
700993a0: f8ce c000    	str.w	r12, [lr]
700993a4: f009 ff74    	bl	0x700a3290 <_ntoa_long> @ imm = #0x9ee8
700993a8: 9037         	str	r0, [sp, #0xdc]
700993aa: e7ff         	b	0x700993ac <_vsnprintf+0x5ac> @ imm = #-0x2
700993ac: e7ff         	b	0x700993ae <_vsnprintf+0x5ae> @ imm = #-0x2
;         }
700993ae: e09c         	b	0x700994ea <_vsnprintf+0x6ea> @ imm = #0x138
;           if (flags & FLAGS_LONG_LONG) {
700993b0: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
700993b4: 0780         	lsls	r0, r0, #0x1e
700993b6: 2800         	cmp	r0, #0x0
700993b8: d52f         	bpl	0x7009941a <_vsnprintf+0x61a> @ imm = #0x5e
700993ba: e7ff         	b	0x700993bc <_vsnprintf+0x5bc> @ imm = #-0x2
;             idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
700993bc: 983f         	ldr	r0, [sp, #0xfc]
700993be: 993e         	ldr	r1, [sp, #0xf8]
700993c0: 9a37         	ldr	r2, [sp, #0xdc]
700993c2: 9b3d         	ldr	r3, [sp, #0xf4]
700993c4: f8dd c100    	ldr.w	r12, [sp, #0x100]
700993c8: f10c 0c07    	add.w	r12, r12, #0x7
700993cc: f02c 0e07    	bic	lr, r12, #0x7
700993d0: f10e 0c08    	add.w	r12, lr, #0x8
700993d4: f8cd c100    	str.w	r12, [sp, #0x100]
700993d8: f8de c000    	ldr.w	r12, [lr]
700993dc: f8de 4004    	ldr.w	r4, [lr, #0x4]
700993e0: 9e34         	ldr	r6, [sp, #0xd0]
700993e2: 9d39         	ldr	r5, [sp, #0xe4]
700993e4: 9f3a         	ldr	r7, [sp, #0xe8]
700993e6: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
700993ea: 46ee         	mov	lr, sp
700993ec: f8cd e04c    	str.w	lr, [sp, #0x4c]
700993f0: f8ce 8020    	str.w	r8, [lr, #0x20]
700993f4: f8ce 701c    	str.w	r7, [lr, #0x1c]
700993f8: f8ce 5018    	str.w	r5, [lr, #0x18]
700993fc: 2500         	movs	r5, #0x0
700993fe: f8ce 5014    	str.w	r5, [lr, #0x14]
70099402: f8ce 6010    	str.w	r6, [lr, #0x10]
70099406: f8ce 5008    	str.w	r5, [lr, #0x8]
7009940a: f8ce 4004    	str.w	r4, [lr, #0x4]
7009940e: f8ce c000    	str.w	r12, [lr]
70099412: f007 ff65    	bl	0x700a12e0 <_ntoa_long_long> @ imm = #0x7eca
70099416: 9037         	str	r0, [sp, #0xdc]
;           }
70099418: e066         	b	0x700994e8 <_vsnprintf+0x6e8> @ imm = #0xcc
;           else if (flags & FLAGS_LONG) {
7009941a: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009941e: 07c0         	lsls	r0, r0, #0x1f
70099420: b310         	cbz	r0, 0x70099468 <_vsnprintf+0x668> @ imm = #0x44
70099422: e7ff         	b	0x70099424 <_vsnprintf+0x624> @ imm = #-0x2
;             idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
70099424: 983f         	ldr	r0, [sp, #0xfc]
70099426: 993e         	ldr	r1, [sp, #0xf8]
70099428: 9a37         	ldr	r2, [sp, #0xdc]
7009942a: 9b3d         	ldr	r3, [sp, #0xf4]
7009942c: f8dd c100    	ldr.w	r12, [sp, #0x100]
70099430: f10c 0e04    	add.w	lr, r12, #0x4
70099434: f8cd e100    	str.w	lr, [sp, #0x100]
70099438: f8dc c000    	ldr.w	r12, [r12]
7009943c: 9c34         	ldr	r4, [sp, #0xd0]
7009943e: 9d39         	ldr	r5, [sp, #0xe4]
70099440: 9e3a         	ldr	r6, [sp, #0xe8]
70099442: 9f3b         	ldr	r7, [sp, #0xec]
70099444: 46ee         	mov	lr, sp
70099446: f8ce 7014    	str.w	r7, [lr, #0x14]
7009944a: f8ce 6010    	str.w	r6, [lr, #0x10]
7009944e: f8ce 500c    	str.w	r5, [lr, #0xc]
70099452: f8ce 4008    	str.w	r4, [lr, #0x8]
70099456: 2400         	movs	r4, #0x0
70099458: f8ce 4004    	str.w	r4, [lr, #0x4]
7009945c: f8ce c000    	str.w	r12, [lr]
70099460: f009 ff16    	bl	0x700a3290 <_ntoa_long> @ imm = #0x9e2c
70099464: 9037         	str	r0, [sp, #0xdc]
;           }
70099466: e03e         	b	0x700994e6 <_vsnprintf+0x6e6> @ imm = #0x7c
;             const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
70099468: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009946c: 0640         	lsls	r0, r0, #0x19
7009946e: 2800         	cmp	r0, #0x0
70099470: d506         	bpl	0x70099480 <_vsnprintf+0x680> @ imm = #0xc
70099472: e7ff         	b	0x70099474 <_vsnprintf+0x674> @ imm = #-0x2
70099474: 9840         	ldr	r0, [sp, #0x100]
70099476: 1d01         	adds	r1, r0, #0x4
70099478: 9140         	str	r1, [sp, #0x100]
7009947a: 7800         	ldrb	r0, [r0]
7009947c: 9012         	str	r0, [sp, #0x48]
7009947e: e014         	b	0x700994aa <_vsnprintf+0x6aa> @ imm = #0x28
70099480: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
70099484: 0600         	lsls	r0, r0, #0x18
70099486: 2800         	cmp	r0, #0x0
70099488: d506         	bpl	0x70099498 <_vsnprintf+0x698> @ imm = #0xc
7009948a: e7ff         	b	0x7009948c <_vsnprintf+0x68c> @ imm = #-0x2
7009948c: 9840         	ldr	r0, [sp, #0x100]
7009948e: 1d01         	adds	r1, r0, #0x4
70099490: 9140         	str	r1, [sp, #0x100]
70099492: 8800         	ldrh	r0, [r0]
70099494: 9011         	str	r0, [sp, #0x44]
70099496: e005         	b	0x700994a4 <_vsnprintf+0x6a4> @ imm = #0xa
70099498: 9840         	ldr	r0, [sp, #0x100]
7009949a: 1d01         	adds	r1, r0, #0x4
7009949c: 9140         	str	r1, [sp, #0x100]
7009949e: 6800         	ldr	r0, [r0]
700994a0: 9011         	str	r0, [sp, #0x44]
700994a2: e7ff         	b	0x700994a4 <_vsnprintf+0x6a4> @ imm = #-0x2
700994a4: 9811         	ldr	r0, [sp, #0x44]
700994a6: 9012         	str	r0, [sp, #0x48]
700994a8: e7ff         	b	0x700994aa <_vsnprintf+0x6aa> @ imm = #-0x2
700994aa: 9812         	ldr	r0, [sp, #0x48]
700994ac: 902f         	str	r0, [sp, #0xbc]
;             idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
700994ae: 983f         	ldr	r0, [sp, #0xfc]
700994b0: 993e         	ldr	r1, [sp, #0xf8]
700994b2: 9a37         	ldr	r2, [sp, #0xdc]
700994b4: 9b3d         	ldr	r3, [sp, #0xf4]
700994b6: f8dd c0bc    	ldr.w	r12, [sp, #0xbc]
700994ba: 9c34         	ldr	r4, [sp, #0xd0]
700994bc: 9d39         	ldr	r5, [sp, #0xe4]
700994be: 9e3a         	ldr	r6, [sp, #0xe8]
700994c0: 9f3b         	ldr	r7, [sp, #0xec]
700994c2: 46ee         	mov	lr, sp
700994c4: f8ce 7014    	str.w	r7, [lr, #0x14]
700994c8: f8ce 6010    	str.w	r6, [lr, #0x10]
700994cc: f8ce 500c    	str.w	r5, [lr, #0xc]
700994d0: f8ce 4008    	str.w	r4, [lr, #0x8]
700994d4: 2400         	movs	r4, #0x0
700994d6: f8ce 4004    	str.w	r4, [lr, #0x4]
700994da: f8ce c000    	str.w	r12, [lr]
700994de: f009 fed7    	bl	0x700a3290 <_ntoa_long> @ imm = #0x9dae
700994e2: 9037         	str	r0, [sp, #0xdc]
700994e4: e7ff         	b	0x700994e6 <_vsnprintf+0x6e6> @ imm = #-0x2
700994e6: e7ff         	b	0x700994e8 <_vsnprintf+0x6e8> @ imm = #-0x2
700994e8: e7ff         	b	0x700994ea <_vsnprintf+0x6ea> @ imm = #-0x2
;         format++;
700994ea: 983c         	ldr	r0, [sp, #0xf0]
700994ec: 3001         	adds	r0, #0x1
700994ee: 903c         	str	r0, [sp, #0xf0]
;         break;
700994f0: e183         	b	0x700997fa <_vsnprintf+0x9fa> @ imm = #0x306
;         if (*format == 'F') flags |= FLAGS_UPPERCASE;
700994f2: 983c         	ldr	r0, [sp, #0xf0]
700994f4: 7800         	ldrb	r0, [r0]
700994f6: 2846         	cmp	r0, #0x46
700994f8: d105         	bne	0x70099506 <_vsnprintf+0x706> @ imm = #0xa
700994fa: e7ff         	b	0x700994fc <_vsnprintf+0x6fc> @ imm = #-0x2
700994fc: 983b         	ldr	r0, [sp, #0xec]
700994fe: f040 0020    	orr	r0, r0, #0x20
70099502: 903b         	str	r0, [sp, #0xec]
70099504: e7ff         	b	0x70099506 <_vsnprintf+0x706> @ imm = #-0x2
;         idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
70099506: 983f         	ldr	r0, [sp, #0xfc]
70099508: 993e         	ldr	r1, [sp, #0xf8]
7009950a: 9a37         	ldr	r2, [sp, #0xdc]
7009950c: 9b3d         	ldr	r3, [sp, #0xf4]
7009950e: f8dd c100    	ldr.w	r12, [sp, #0x100]
70099512: f10c 0c07    	add.w	r12, r12, #0x7
70099516: f02c 0c07    	bic	r12, r12, #0x7
7009951a: f10c 0e08    	add.w	lr, r12, #0x8
7009951e: f8cd e100    	str.w	lr, [sp, #0x100]
70099522: ed9c 0b00    	vldr	d0, [r12]
70099526: f8dd c0e4    	ldr.w	r12, [sp, #0xe4]
7009952a: 9c3a         	ldr	r4, [sp, #0xe8]
7009952c: 9d3b         	ldr	r5, [sp, #0xec]
7009952e: 46ee         	mov	lr, sp
70099530: f8ce 5008    	str.w	r5, [lr, #0x8]
70099534: f8ce 4004    	str.w	r4, [lr, #0x4]
70099538: f8ce c000    	str.w	r12, [lr]
7009953c: f000 fc80    	bl	0x70099e40 <_ftoa>      @ imm = #0x900
70099540: 9037         	str	r0, [sp, #0xdc]
;         format++;
70099542: 983c         	ldr	r0, [sp, #0xf0]
70099544: 3001         	adds	r0, #0x1
70099546: 903c         	str	r0, [sp, #0xf0]
;         break;
70099548: e157         	b	0x700997fa <_vsnprintf+0x9fa> @ imm = #0x2ae
;         if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
7009954a: 983c         	ldr	r0, [sp, #0xf0]
7009954c: 7800         	ldrb	r0, [r0]
7009954e: 2867         	cmp	r0, #0x67
70099550: d005         	beq	0x7009955e <_vsnprintf+0x75e> @ imm = #0xa
70099552: e7ff         	b	0x70099554 <_vsnprintf+0x754> @ imm = #-0x2
70099554: 983c         	ldr	r0, [sp, #0xf0]
70099556: 7800         	ldrb	r0, [r0]
70099558: 2847         	cmp	r0, #0x47
7009955a: d105         	bne	0x70099568 <_vsnprintf+0x768> @ imm = #0xa
7009955c: e7ff         	b	0x7009955e <_vsnprintf+0x75e> @ imm = #-0x2
7009955e: 983b         	ldr	r0, [sp, #0xec]
70099560: f440 6000    	orr	r0, r0, #0x800
70099564: 903b         	str	r0, [sp, #0xec]
70099566: e7ff         	b	0x70099568 <_vsnprintf+0x768> @ imm = #-0x2
;         if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
70099568: 983c         	ldr	r0, [sp, #0xf0]
7009956a: 7800         	ldrb	r0, [r0]
7009956c: 2845         	cmp	r0, #0x45
7009956e: d005         	beq	0x7009957c <_vsnprintf+0x77c> @ imm = #0xa
70099570: e7ff         	b	0x70099572 <_vsnprintf+0x772> @ imm = #-0x2
70099572: 983c         	ldr	r0, [sp, #0xf0]
70099574: 7800         	ldrb	r0, [r0]
70099576: 2847         	cmp	r0, #0x47
70099578: d105         	bne	0x70099586 <_vsnprintf+0x786> @ imm = #0xa
7009957a: e7ff         	b	0x7009957c <_vsnprintf+0x77c> @ imm = #-0x2
7009957c: 983b         	ldr	r0, [sp, #0xec]
7009957e: f040 0020    	orr	r0, r0, #0x20
70099582: 903b         	str	r0, [sp, #0xec]
70099584: e7ff         	b	0x70099586 <_vsnprintf+0x786> @ imm = #-0x2
;         idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
70099586: 983f         	ldr	r0, [sp, #0xfc]
70099588: 993e         	ldr	r1, [sp, #0xf8]
7009958a: 9a37         	ldr	r2, [sp, #0xdc]
7009958c: 9b3d         	ldr	r3, [sp, #0xf4]
7009958e: f8dd c100    	ldr.w	r12, [sp, #0x100]
70099592: f10c 0c07    	add.w	r12, r12, #0x7
70099596: f02c 0c07    	bic	r12, r12, #0x7
7009959a: f10c 0e08    	add.w	lr, r12, #0x8
7009959e: f8cd e100    	str.w	lr, [sp, #0x100]
700995a2: ed9c 0b00    	vldr	d0, [r12]
700995a6: f8dd c0e4    	ldr.w	r12, [sp, #0xe4]
700995aa: 9c3a         	ldr	r4, [sp, #0xe8]
700995ac: 9d3b         	ldr	r5, [sp, #0xec]
700995ae: 46ee         	mov	lr, sp
700995b0: f8ce 5008    	str.w	r5, [lr, #0x8]
700995b4: f8ce 4004    	str.w	r4, [lr, #0x4]
700995b8: f8ce c000    	str.w	r12, [lr]
700995bc: f000 fed0    	bl	0x7009a360 <_etoa>      @ imm = #0xda0
700995c0: 9037         	str	r0, [sp, #0xdc]
;         format++;
700995c2: 983c         	ldr	r0, [sp, #0xf0]
700995c4: 3001         	adds	r0, #0x1
700995c6: 903c         	str	r0, [sp, #0xf0]
;         break;
700995c8: e117         	b	0x700997fa <_vsnprintf+0x9fa> @ imm = #0x22e
700995ca: 2001         	movs	r0, #0x1
;         unsigned int l = 1U;
700995cc: 902e         	str	r0, [sp, #0xb8]
;         if (!(flags & FLAGS_LEFT)) {
700995ce: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
700995d2: 0780         	lsls	r0, r0, #0x1e
700995d4: 2800         	cmp	r0, #0x0
700995d6: d413         	bmi	0x70099600 <_vsnprintf+0x800> @ imm = #0x26
700995d8: e7ff         	b	0x700995da <_vsnprintf+0x7da> @ imm = #-0x2
;           while (l++ < width) {
700995da: e7ff         	b	0x700995dc <_vsnprintf+0x7dc> @ imm = #-0x2
700995dc: 982e         	ldr	r0, [sp, #0xb8]
700995de: 1c41         	adds	r1, r0, #0x1
700995e0: 912e         	str	r1, [sp, #0xb8]
700995e2: 993a         	ldr	r1, [sp, #0xe8]
700995e4: 4288         	cmp	r0, r1
700995e6: d20a         	bhs	0x700995fe <_vsnprintf+0x7fe> @ imm = #0x14
700995e8: e7ff         	b	0x700995ea <_vsnprintf+0x7ea> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
700995ea: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
700995ee: 993e         	ldr	r1, [sp, #0xf8]
700995f0: 9a37         	ldr	r2, [sp, #0xdc]
700995f2: 1c50         	adds	r0, r2, #0x1
700995f4: 9037         	str	r0, [sp, #0xdc]
700995f6: 9b3d         	ldr	r3, [sp, #0xf4]
700995f8: 2020         	movs	r0, #0x20
700995fa: 47e0         	blx	r12
;           while (l++ < width) {
700995fc: e7ee         	b	0x700995dc <_vsnprintf+0x7dc> @ imm = #-0x24
;         }
700995fe: e7ff         	b	0x70099600 <_vsnprintf+0x800> @ imm = #-0x2
;         out((char)va_arg(va, int), buffer, idx++, maxlen);
70099600: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
70099604: 9840         	ldr	r0, [sp, #0x100]
70099606: 1d01         	adds	r1, r0, #0x4
70099608: 9140         	str	r1, [sp, #0x100]
7009960a: 7800         	ldrb	r0, [r0]
7009960c: 993e         	ldr	r1, [sp, #0xf8]
7009960e: 9a37         	ldr	r2, [sp, #0xdc]
70099610: 1c53         	adds	r3, r2, #0x1
70099612: 9337         	str	r3, [sp, #0xdc]
70099614: 9b3d         	ldr	r3, [sp, #0xf4]
70099616: 47e0         	blx	r12
;         if (flags & FLAGS_LEFT) {
70099618: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009961c: 0780         	lsls	r0, r0, #0x1e
7009961e: 2800         	cmp	r0, #0x0
70099620: d513         	bpl	0x7009964a <_vsnprintf+0x84a> @ imm = #0x26
70099622: e7ff         	b	0x70099624 <_vsnprintf+0x824> @ imm = #-0x2
;           while (l++ < width) {
70099624: e7ff         	b	0x70099626 <_vsnprintf+0x826> @ imm = #-0x2
70099626: 982e         	ldr	r0, [sp, #0xb8]
70099628: 1c41         	adds	r1, r0, #0x1
7009962a: 912e         	str	r1, [sp, #0xb8]
7009962c: 993a         	ldr	r1, [sp, #0xe8]
7009962e: 4288         	cmp	r0, r1
70099630: d20a         	bhs	0x70099648 <_vsnprintf+0x848> @ imm = #0x14
70099632: e7ff         	b	0x70099634 <_vsnprintf+0x834> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
70099634: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
70099638: 993e         	ldr	r1, [sp, #0xf8]
7009963a: 9a37         	ldr	r2, [sp, #0xdc]
7009963c: 1c50         	adds	r0, r2, #0x1
7009963e: 9037         	str	r0, [sp, #0xdc]
70099640: 9b3d         	ldr	r3, [sp, #0xf4]
70099642: 2020         	movs	r0, #0x20
70099644: 47e0         	blx	r12
;           while (l++ < width) {
70099646: e7ee         	b	0x70099626 <_vsnprintf+0x826> @ imm = #-0x24
;         }
70099648: e7ff         	b	0x7009964a <_vsnprintf+0x84a> @ imm = #-0x2
;         format++;
7009964a: 983c         	ldr	r0, [sp, #0xf0]
7009964c: 3001         	adds	r0, #0x1
7009964e: 903c         	str	r0, [sp, #0xf0]
;         break;
70099650: e0d3         	b	0x700997fa <_vsnprintf+0x9fa> @ imm = #0x1a6
;         const char* p = va_arg(va, char*);
70099652: 9840         	ldr	r0, [sp, #0x100]
70099654: 1d01         	adds	r1, r0, #0x4
70099656: 9140         	str	r1, [sp, #0x100]
70099658: 6800         	ldr	r0, [r0]
7009965a: 902d         	str	r0, [sp, #0xb4]
;         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
7009965c: 982d         	ldr	r0, [sp, #0xb4]
7009965e: 9010         	str	r0, [sp, #0x40]
70099660: 9839         	ldr	r0, [sp, #0xe4]
70099662: b118         	cbz	r0, 0x7009966c <_vsnprintf+0x86c> @ imm = #0x6
70099664: e7ff         	b	0x70099666 <_vsnprintf+0x866> @ imm = #-0x2
70099666: 9839         	ldr	r0, [sp, #0xe4]
70099668: 900f         	str	r0, [sp, #0x3c]
7009966a: e003         	b	0x70099674 <_vsnprintf+0x874> @ imm = #0x6
7009966c: f04f 30ff    	mov.w	r0, #0xffffffff
;         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
70099670: 900f         	str	r0, [sp, #0x3c]
70099672: e7ff         	b	0x70099674 <_vsnprintf+0x874> @ imm = #-0x2
70099674: 9810         	ldr	r0, [sp, #0x40]
70099676: 990f         	ldr	r1, [sp, #0x3c]
70099678: f012 fb7a    	bl	0x700abd70 <_strnlen_s> @ imm = #0x126f4
7009967c: 902c         	str	r0, [sp, #0xb0]
;         if (flags & FLAGS_PRECISION) {
7009967e: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
70099682: 0740         	lsls	r0, r0, #0x1d
70099684: 2800         	cmp	r0, #0x0
70099686: d50e         	bpl	0x700996a6 <_vsnprintf+0x8a6> @ imm = #0x1c
70099688: e7ff         	b	0x7009968a <_vsnprintf+0x88a> @ imm = #-0x2
;           l = (l < precision ? l : precision);
7009968a: 982c         	ldr	r0, [sp, #0xb0]
7009968c: 9939         	ldr	r1, [sp, #0xe4]
7009968e: 4288         	cmp	r0, r1
70099690: d203         	bhs	0x7009969a <_vsnprintf+0x89a> @ imm = #0x6
70099692: e7ff         	b	0x70099694 <_vsnprintf+0x894> @ imm = #-0x2
70099694: 982c         	ldr	r0, [sp, #0xb0]
70099696: 900e         	str	r0, [sp, #0x38]
70099698: e002         	b	0x700996a0 <_vsnprintf+0x8a0> @ imm = #0x4
7009969a: 9839         	ldr	r0, [sp, #0xe4]
7009969c: 900e         	str	r0, [sp, #0x38]
7009969e: e7ff         	b	0x700996a0 <_vsnprintf+0x8a0> @ imm = #-0x2
700996a0: 980e         	ldr	r0, [sp, #0x38]
700996a2: 902c         	str	r0, [sp, #0xb0]
;         }
700996a4: e7ff         	b	0x700996a6 <_vsnprintf+0x8a6> @ imm = #-0x2
;         if (!(flags & FLAGS_LEFT)) {
700996a6: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
700996aa: 0780         	lsls	r0, r0, #0x1e
700996ac: 2800         	cmp	r0, #0x0
700996ae: d413         	bmi	0x700996d8 <_vsnprintf+0x8d8> @ imm = #0x26
700996b0: e7ff         	b	0x700996b2 <_vsnprintf+0x8b2> @ imm = #-0x2
;           while (l++ < width) {
700996b2: e7ff         	b	0x700996b4 <_vsnprintf+0x8b4> @ imm = #-0x2
700996b4: 982c         	ldr	r0, [sp, #0xb0]
700996b6: 1c41         	adds	r1, r0, #0x1
700996b8: 912c         	str	r1, [sp, #0xb0]
700996ba: 993a         	ldr	r1, [sp, #0xe8]
700996bc: 4288         	cmp	r0, r1
700996be: d20a         	bhs	0x700996d6 <_vsnprintf+0x8d6> @ imm = #0x14
700996c0: e7ff         	b	0x700996c2 <_vsnprintf+0x8c2> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
700996c2: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
700996c6: 993e         	ldr	r1, [sp, #0xf8]
700996c8: 9a37         	ldr	r2, [sp, #0xdc]
700996ca: 1c50         	adds	r0, r2, #0x1
700996cc: 9037         	str	r0, [sp, #0xdc]
700996ce: 9b3d         	ldr	r3, [sp, #0xf4]
700996d0: 2020         	movs	r0, #0x20
700996d2: 47e0         	blx	r12
;           while (l++ < width) {
700996d4: e7ee         	b	0x700996b4 <_vsnprintf+0x8b4> @ imm = #-0x24
;         }
700996d6: e7ff         	b	0x700996d8 <_vsnprintf+0x8d8> @ imm = #-0x2
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
700996d8: e7ff         	b	0x700996da <_vsnprintf+0x8da> @ imm = #-0x2
700996da: 982d         	ldr	r0, [sp, #0xb4]
700996dc: 7801         	ldrb	r1, [r0]
700996de: 2000         	movs	r0, #0x0
700996e0: 900d         	str	r0, [sp, #0x34]
700996e2: b1a1         	cbz	r1, 0x7009970e <_vsnprintf+0x90e> @ imm = #0x28
700996e4: e7ff         	b	0x700996e6 <_vsnprintf+0x8e6> @ imm = #-0x2
700996e6: 2001         	movs	r0, #0x1
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
700996e8: f89d 10ed    	ldrb.w	r1, [sp, #0xed]
700996ec: ea4f 7141    	lsl.w	r1, r1, #0x1d
700996f0: 2900         	cmp	r1, #0x0
700996f2: 900c         	str	r0, [sp, #0x30]
700996f4: d508         	bpl	0x70099708 <_vsnprintf+0x908> @ imm = #0x10
700996f6: e7ff         	b	0x700996f8 <_vsnprintf+0x8f8> @ imm = #-0x2
700996f8: 9839         	ldr	r0, [sp, #0xe4]
700996fa: 1e41         	subs	r1, r0, #0x1
700996fc: 9139         	str	r1, [sp, #0xe4]
700996fe: 2800         	cmp	r0, #0x0
70099700: bf18         	it	ne
70099702: 2001         	movne	r0, #0x1
70099704: 900c         	str	r0, [sp, #0x30]
70099706: e7ff         	b	0x70099708 <_vsnprintf+0x908> @ imm = #-0x2
70099708: 980c         	ldr	r0, [sp, #0x30]
7009970a: 900d         	str	r0, [sp, #0x34]
7009970c: e7ff         	b	0x7009970e <_vsnprintf+0x90e> @ imm = #-0x2
7009970e: 980d         	ldr	r0, [sp, #0x34]
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
70099710: 07c0         	lsls	r0, r0, #0x1f
70099712: b168         	cbz	r0, 0x70099730 <_vsnprintf+0x930> @ imm = #0x1a
70099714: e7ff         	b	0x70099716 <_vsnprintf+0x916> @ imm = #-0x2
;           out(*(p++), buffer, idx++, maxlen);
70099716: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009971a: 982d         	ldr	r0, [sp, #0xb4]
7009971c: 1c41         	adds	r1, r0, #0x1
7009971e: 912d         	str	r1, [sp, #0xb4]
70099720: 7800         	ldrb	r0, [r0]
70099722: 993e         	ldr	r1, [sp, #0xf8]
70099724: 9a37         	ldr	r2, [sp, #0xdc]
70099726: 1c53         	adds	r3, r2, #0x1
70099728: 9337         	str	r3, [sp, #0xdc]
7009972a: 9b3d         	ldr	r3, [sp, #0xf4]
7009972c: 47e0         	blx	r12
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009972e: e7d4         	b	0x700996da <_vsnprintf+0x8da> @ imm = #-0x58
;         if (flags & FLAGS_LEFT) {
70099730: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
70099734: 0780         	lsls	r0, r0, #0x1e
70099736: 2800         	cmp	r0, #0x0
70099738: d513         	bpl	0x70099762 <_vsnprintf+0x962> @ imm = #0x26
7009973a: e7ff         	b	0x7009973c <_vsnprintf+0x93c> @ imm = #-0x2
;           while (l++ < width) {
7009973c: e7ff         	b	0x7009973e <_vsnprintf+0x93e> @ imm = #-0x2
7009973e: 982c         	ldr	r0, [sp, #0xb0]
70099740: 1c41         	adds	r1, r0, #0x1
70099742: 912c         	str	r1, [sp, #0xb0]
70099744: 993a         	ldr	r1, [sp, #0xe8]
70099746: 4288         	cmp	r0, r1
70099748: d20a         	bhs	0x70099760 <_vsnprintf+0x960> @ imm = #0x14
7009974a: e7ff         	b	0x7009974c <_vsnprintf+0x94c> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009974c: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
70099750: 993e         	ldr	r1, [sp, #0xf8]
70099752: 9a37         	ldr	r2, [sp, #0xdc]
70099754: 1c50         	adds	r0, r2, #0x1
70099756: 9037         	str	r0, [sp, #0xdc]
70099758: 9b3d         	ldr	r3, [sp, #0xf4]
7009975a: 2020         	movs	r0, #0x20
7009975c: 47e0         	blx	r12
;           while (l++ < width) {
7009975e: e7ee         	b	0x7009973e <_vsnprintf+0x93e> @ imm = #-0x24
;         }
70099760: e7ff         	b	0x70099762 <_vsnprintf+0x962> @ imm = #-0x2
;         format++;
70099762: 983c         	ldr	r0, [sp, #0xf0]
70099764: 3001         	adds	r0, #0x1
70099766: 903c         	str	r0, [sp, #0xf0]
;         break;
70099768: e047         	b	0x700997fa <_vsnprintf+0x9fa> @ imm = #0x8e
7009976a: 2008         	movs	r0, #0x8
;         width = sizeof(void*) * 2U;
7009976c: 903a         	str	r0, [sp, #0xe8]
;         flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
7009976e: 983b         	ldr	r0, [sp, #0xec]
70099770: f040 0021    	orr	r0, r0, #0x21
70099774: 903b         	str	r0, [sp, #0xec]
70099776: 2400         	movs	r4, #0x0
;         const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
70099778: f88d 40af    	strb.w	r4, [sp, #0xaf]
;           idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
7009977c: 983f         	ldr	r0, [sp, #0xfc]
7009977e: 993e         	ldr	r1, [sp, #0xf8]
70099780: 9a37         	ldr	r2, [sp, #0xdc]
70099782: 9b3d         	ldr	r3, [sp, #0xf4]
70099784: f8dd c100    	ldr.w	r12, [sp, #0x100]
70099788: f10c 0e04    	add.w	lr, r12, #0x4
7009978c: f8cd e100    	str.w	lr, [sp, #0x100]
70099790: f8dc c000    	ldr.w	r12, [r12]
70099794: 9d39         	ldr	r5, [sp, #0xe4]
70099796: 9e3a         	ldr	r6, [sp, #0xe8]
70099798: 9f3b         	ldr	r7, [sp, #0xec]
7009979a: 46ee         	mov	lr, sp
7009979c: f8ce 7014    	str.w	r7, [lr, #0x14]
700997a0: f8ce 6010    	str.w	r6, [lr, #0x10]
700997a4: f8ce 500c    	str.w	r5, [lr, #0xc]
700997a8: 2510         	movs	r5, #0x10
700997aa: f8ce 5008    	str.w	r5, [lr, #0x8]
700997ae: f8ce 4004    	str.w	r4, [lr, #0x4]
700997b2: f8ce c000    	str.w	r12, [lr]
700997b6: f009 fd6b    	bl	0x700a3290 <_ntoa_long> @ imm = #0x9ad6
700997ba: 9037         	str	r0, [sp, #0xdc]
;         format++;
700997bc: 983c         	ldr	r0, [sp, #0xf0]
700997be: 3001         	adds	r0, #0x1
700997c0: 903c         	str	r0, [sp, #0xf0]
;         break;
700997c2: e01a         	b	0x700997fa <_vsnprintf+0x9fa> @ imm = #0x34
;         out('%', buffer, idx++, maxlen);
700997c4: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
700997c8: 993e         	ldr	r1, [sp, #0xf8]
700997ca: 9a37         	ldr	r2, [sp, #0xdc]
700997cc: 1c50         	adds	r0, r2, #0x1
700997ce: 9037         	str	r0, [sp, #0xdc]
700997d0: 9b3d         	ldr	r3, [sp, #0xf4]
700997d2: 2025         	movs	r0, #0x25
700997d4: 47e0         	blx	r12
;         format++;
700997d6: 983c         	ldr	r0, [sp, #0xf0]
700997d8: 3001         	adds	r0, #0x1
700997da: 903c         	str	r0, [sp, #0xf0]
;         break;
700997dc: e00d         	b	0x700997fa <_vsnprintf+0x9fa> @ imm = #0x1a
;         out(*format, buffer, idx++, maxlen);
700997de: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
700997e2: 983c         	ldr	r0, [sp, #0xf0]
700997e4: 7800         	ldrb	r0, [r0]
700997e6: 993e         	ldr	r1, [sp, #0xf8]
700997e8: 9a37         	ldr	r2, [sp, #0xdc]
700997ea: 1c53         	adds	r3, r2, #0x1
700997ec: 9337         	str	r3, [sp, #0xdc]
700997ee: 9b3d         	ldr	r3, [sp, #0xf4]
700997f0: 47e0         	blx	r12
;         format++;
700997f2: 983c         	ldr	r0, [sp, #0xf0]
700997f4: 3001         	adds	r0, #0x1
700997f6: 903c         	str	r0, [sp, #0xf0]
;         break;
700997f8: e7ff         	b	0x700997fa <_vsnprintf+0x9fa> @ imm = #-0x2
;   while (*format)
700997fa: f7ff bb18    	b.w	0x70098e2e <_vsnprintf+0x2e> @ imm = #-0x9d0
;   out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
700997fe: 983f         	ldr	r0, [sp, #0xfc]
70099800: 900a         	str	r0, [sp, #0x28]
70099802: 983e         	ldr	r0, [sp, #0xf8]
70099804: 900b         	str	r0, [sp, #0x2c]
70099806: 9837         	ldr	r0, [sp, #0xdc]
70099808: 993d         	ldr	r1, [sp, #0xf4]
7009980a: 4288         	cmp	r0, r1
7009980c: d203         	bhs	0x70099816 <_vsnprintf+0xa16> @ imm = #0x6
7009980e: e7ff         	b	0x70099810 <_vsnprintf+0xa10> @ imm = #-0x2
70099810: 9837         	ldr	r0, [sp, #0xdc]
70099812: 9009         	str	r0, [sp, #0x24]
70099814: e003         	b	0x7009981e <_vsnprintf+0xa1e> @ imm = #0x6
70099816: 983d         	ldr	r0, [sp, #0xf4]
70099818: 3801         	subs	r0, #0x1
7009981a: 9009         	str	r0, [sp, #0x24]
7009981c: e7ff         	b	0x7009981e <_vsnprintf+0xa1e> @ imm = #-0x2
7009981e: f8dd c028    	ldr.w	r12, [sp, #0x28]
70099822: 990b         	ldr	r1, [sp, #0x2c]
70099824: 9a09         	ldr	r2, [sp, #0x24]
70099826: 9b3d         	ldr	r3, [sp, #0xf4]
70099828: 2000         	movs	r0, #0x0
7009982a: 47e0         	blx	r12
;   return (int)idx;
7009982c: 9837         	ldr	r0, [sp, #0xdc]
7009982e: b041         	add	sp, #0x104
70099830: e8bd 83f0    	pop.w	{r4, r5, r6, r7, r8, r9, pc}

70099834 <__aeabi_memclr8>:
70099834: e1a02001     	mov	r2, r1
70099838: e3b01000     	movs	r1, #0
7009983c: ea0050f1     	b	0x700adc08 <TI_memset_small> @ imm = #0x143c4

70099840 <Sciclient_rmIrqRouteValidate>:
; {
70099840: b580         	push	{r7, lr}
70099842: b09e         	sub	sp, #0x78
70099844: 901d         	str	r0, [sp, #0x74]
70099846: 2001         	movs	r0, #0x1
;     bool valid = true;
70099848: f88d 0073    	strb.w	r0, [sp, #0x73]
7009984c: 2000         	movs	r0, #0x0
;     const struct Sciclient_rmIrqNode *cur_n, *next_n = NULL;
7009984e: 9009         	str	r0, [sp, #0x24]
70099850: 9019         	str	r0, [sp, #0x64]
;     bool cur_outp_valid = false, next_inp_valid = false;
70099852: f88d 005f    	strb.w	r0, [sp, #0x5f]
70099856: f88d 005e    	strb.w	r0, [sp, #0x5e]
;     uint16_t cur_outp = 0, next_inp = 0;
7009985a: f8ad 0056    	strh.w	r0, [sp, #0x56]
7009985e: f8ad 0054    	strh.w	r0, [sp, #0x54]
;     struct tisci_msg_rm_get_resource_range_req req = {{0}};
70099862: 9014         	str	r0, [sp, #0x50]
70099864: 9013         	str	r0, [sp, #0x4c]
70099866: 9012         	str	r0, [sp, #0x48]
;     struct tisci_msg_rm_get_resource_range_resp host_resp = {{0}};
70099868: 9011         	str	r0, [sp, #0x44]
7009986a: 9010         	str	r0, [sp, #0x40]
7009986c: 900f         	str	r0, [sp, #0x3c]
7009986e: 900e         	str	r0, [sp, #0x38]
;     struct tisci_msg_rm_get_resource_range_resp all_resp = {{0}};
70099870: 900d         	str	r0, [sp, #0x34]
70099872: 900c         	str	r0, [sp, #0x30]
70099874: 900b         	str	r0, [sp, #0x2c]
70099876: 900a         	str	r0, [sp, #0x28]
;     if (cfg->s_ia == SCICLIENT_RM_DEV_NONE) {
70099878: 981d         	ldr	r0, [sp, #0x74]
7009987a: 8a00         	ldrh	r0, [r0, #0x10]
7009987c: 28ff         	cmp	r0, #0xff
7009987e: d12c         	bne	0x700998da <Sciclient_rmIrqRouteValidate+0x9a> @ imm = #0x58
70099880: e7ff         	b	0x70099882 <Sciclient_rmIrqRouteValidate+0x42> @ imm = #-0x2
70099882: 2000         	movs	r0, #0x0
;         cur_n = Sciclient_rmPsGetIrqNode(0u);
70099884: f014 f814    	bl	0x700ad8b0 <Sciclient_rmPsGetIrqNode> @ imm = #0x14028
70099888: 901a         	str	r0, [sp, #0x68]
;         if (cur_n == NULL) {
7009988a: 981a         	ldr	r0, [sp, #0x68]
7009988c: b920         	cbnz	r0, 0x70099898 <Sciclient_rmIrqRouteValidate+0x58> @ imm = #0x8
7009988e: e7ff         	b	0x70099890 <Sciclient_rmIrqRouteValidate+0x50> @ imm = #-0x2
70099890: 2000         	movs	r0, #0x0
;             valid = false;
70099892: f88d 0073    	strb.w	r0, [sp, #0x73]
;         } else {
70099896: e01f         	b	0x700998d8 <Sciclient_rmIrqRouteValidate+0x98> @ imm = #0x3e
;             cur_if = cur_n->p_if[Sciclient_rmPsGetIfIdx(0u)];
70099898: 981a         	ldr	r0, [sp, #0x68]
7009989a: 6840         	ldr	r0, [r0, #0x4]
7009989c: 9008         	str	r0, [sp, #0x20]
7009989e: 2000         	movs	r0, #0x0
700998a0: f012 fbbe    	bl	0x700ac020 <Sciclient_rmPsGetIfIdx> @ imm = #0x1277c
700998a4: 4601         	mov	r1, r0
700998a6: 9808         	ldr	r0, [sp, #0x20]
700998a8: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700998ac: 9018         	str	r0, [sp, #0x60]
;             if ((cfg->s_idx < cur_if->lbase) ||
700998ae: 981d         	ldr	r0, [sp, #0x74]
700998b0: 8900         	ldrh	r0, [r0, #0x8]
700998b2: 9918         	ldr	r1, [sp, #0x60]
700998b4: 8809         	ldrh	r1, [r1]
700998b6: 4288         	cmp	r0, r1
700998b8: db09         	blt	0x700998ce <Sciclient_rmIrqRouteValidate+0x8e> @ imm = #0x12
700998ba: e7ff         	b	0x700998bc <Sciclient_rmIrqRouteValidate+0x7c> @ imm = #-0x2
;                 (cfg->s_idx >= (cur_if->lbase + cur_if->len))) {
700998bc: 981d         	ldr	r0, [sp, #0x74]
700998be: 8900         	ldrh	r0, [r0, #0x8]
700998c0: 9a18         	ldr	r2, [sp, #0x60]
700998c2: 8811         	ldrh	r1, [r2]
700998c4: 8892         	ldrh	r2, [r2, #0x4]
700998c6: 4411         	add	r1, r2
;             if ((cfg->s_idx < cur_if->lbase) ||
700998c8: 4288         	cmp	r0, r1
700998ca: db04         	blt	0x700998d6 <Sciclient_rmIrqRouteValidate+0x96> @ imm = #0x8
700998cc: e7ff         	b	0x700998ce <Sciclient_rmIrqRouteValidate+0x8e> @ imm = #-0x2
700998ce: 2000         	movs	r0, #0x0
;                 valid = false;
700998d0: f88d 0073    	strb.w	r0, [sp, #0x73]
;             }
700998d4: e7ff         	b	0x700998d6 <Sciclient_rmIrqRouteValidate+0x96> @ imm = #-0x2
700998d6: e7ff         	b	0x700998d8 <Sciclient_rmIrqRouteValidate+0x98> @ imm = #-0x2
;     }
700998d8: e7ff         	b	0x700998da <Sciclient_rmIrqRouteValidate+0x9a> @ imm = #-0x2
;     if ((valid == true) &&
700998da: f89d 0073    	ldrb.w	r0, [sp, #0x73]
700998de: 07c0         	lsls	r0, r0, #0x1f
700998e0: b148         	cbz	r0, 0x700998f6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #0x12
700998e2: e7ff         	b	0x700998e4 <Sciclient_rmIrqRouteValidate+0xa4> @ imm = #-0x2
;         (Sciclient_rmPsGetPsp() <= 1U)) {
700998e4: f014 fc04    	bl	0x700ae0f0 <Sciclient_rmPsGetPsp> @ imm = #0x14808
;     if ((valid == true) &&
700998e8: 2801         	cmp	r0, #0x1
700998ea: d804         	bhi	0x700998f6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #0x8
700998ec: e7ff         	b	0x700998ee <Sciclient_rmIrqRouteValidate+0xae> @ imm = #-0x2
700998ee: 2000         	movs	r0, #0x0
;         valid = false;
700998f0: f88d 0073    	strb.w	r0, [sp, #0x73]
;     }
700998f4: e7ff         	b	0x700998f6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #-0x2
;     if (valid == true) {
700998f6: f89d 0073    	ldrb.w	r0, [sp, #0x73]
700998fa: 07c0         	lsls	r0, r0, #0x1f
700998fc: b150         	cbz	r0, 0x70099914 <Sciclient_rmIrqRouteValidate+0xd4> @ imm = #0x14
700998fe: e7ff         	b	0x70099900 <Sciclient_rmIrqRouteValidate+0xc0> @ imm = #-0x2
;         if (Sciclient_rmIrqCheckLoop(cfg) == true) {
70099900: 981d         	ldr	r0, [sp, #0x74]
70099902: f00d f98d    	bl	0x700a6c20 <Sciclient_rmIrqCheckLoop> @ imm = #0xd31a
70099906: b120         	cbz	r0, 0x70099912 <Sciclient_rmIrqRouteValidate+0xd2> @ imm = #0x8
70099908: e7ff         	b	0x7009990a <Sciclient_rmIrqRouteValidate+0xca> @ imm = #-0x2
7009990a: 2000         	movs	r0, #0x0
;             valid = false;
7009990c: f88d 0073    	strb.w	r0, [sp, #0x73]
;         }
70099910: e7ff         	b	0x70099912 <Sciclient_rmIrqRouteValidate+0xd2> @ imm = #-0x2
;     }
70099912: e7ff         	b	0x70099914 <Sciclient_rmIrqRouteValidate+0xd4> @ imm = #-0x2
70099914: 2000         	movs	r0, #0x0
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
70099916: f8ad 0070    	strh.w	r0, [sp, #0x70]
7009991a: e7ff         	b	0x7009991c <Sciclient_rmIrqRouteValidate+0xdc> @ imm = #-0x2
7009991c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099920: 9006         	str	r0, [sp, #0x18]
70099922: f014 fbe5    	bl	0x700ae0f0 <Sciclient_rmPsGetPsp> @ imm = #0x147ca
70099926: 9906         	ldr	r1, [sp, #0x18]
70099928: 4602         	mov	r2, r0
7009992a: 2000         	movs	r0, #0x0
7009992c: 4291         	cmp	r1, r2
7009992e: 9007         	str	r0, [sp, #0x1c]
70099930: da06         	bge	0x70099940 <Sciclient_rmIrqRouteValidate+0x100> @ imm = #0xc
70099932: e7ff         	b	0x70099934 <Sciclient_rmIrqRouteValidate+0xf4> @ imm = #-0x2
70099934: f89d 0073    	ldrb.w	r0, [sp, #0x73]
70099938: f000 0001    	and	r0, r0, #0x1
7009993c: 9007         	str	r0, [sp, #0x1c]
7009993e: e7ff         	b	0x70099940 <Sciclient_rmIrqRouteValidate+0x100> @ imm = #-0x2
70099940: 9807         	ldr	r0, [sp, #0x1c]
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
70099942: 07c0         	lsls	r0, r0, #0x1f
70099944: 2800         	cmp	r0, #0x0
70099946: f000 826f    	beq.w	0x70099e28 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x4de
7009994a: e7ff         	b	0x7009994c <Sciclient_rmIrqRouteValidate+0x10c> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
7009994c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099950: f013 ffae    	bl	0x700ad8b0 <Sciclient_rmPsGetIrqNode> @ imm = #0x13f5c
70099954: 901a         	str	r0, [sp, #0x68]
;         cur_if = cur_n->p_if[Sciclient_rmPsGetIfIdx(i)];
70099956: 981a         	ldr	r0, [sp, #0x68]
70099958: 6840         	ldr	r0, [r0, #0x4]
7009995a: 9004         	str	r0, [sp, #0x10]
7009995c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099960: f012 fb5e    	bl	0x700ac020 <Sciclient_rmPsGetIfIdx> @ imm = #0x126bc
70099964: 4601         	mov	r1, r0
70099966: 9804         	ldr	r0, [sp, #0x10]
70099968: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009996c: 9018         	str	r0, [sp, #0x60]
;         if (i < (Sciclient_rmPsGetPsp() - 1u)) {
7009996e: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099972: 9005         	str	r0, [sp, #0x14]
70099974: f014 fbbc    	bl	0x700ae0f0 <Sciclient_rmPsGetPsp> @ imm = #0x14778
70099978: 4601         	mov	r1, r0
7009997a: 9805         	ldr	r0, [sp, #0x14]
7009997c: 3901         	subs	r1, #0x1
7009997e: 4288         	cmp	r0, r1
70099980: d20f         	bhs	0x700999a2 <Sciclient_rmIrqRouteValidate+0x162> @ imm = #0x1e
70099982: e7ff         	b	0x70099984 <Sciclient_rmIrqRouteValidate+0x144> @ imm = #-0x2
;             next_n = Sciclient_rmPsGetIrqNode(i + 1u);
70099984: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099988: 3001         	adds	r0, #0x1
7009998a: b280         	uxth	r0, r0
7009998c: f013 ff90    	bl	0x700ad8b0 <Sciclient_rmPsGetIrqNode> @ imm = #0x13f20
70099990: 9019         	str	r0, [sp, #0x64]
;             if (next_n == NULL) {
70099992: 9819         	ldr	r0, [sp, #0x64]
70099994: b920         	cbnz	r0, 0x700999a0 <Sciclient_rmIrqRouteValidate+0x160> @ imm = #0x8
70099996: e7ff         	b	0x70099998 <Sciclient_rmIrqRouteValidate+0x158> @ imm = #-0x2
70099998: 2000         	movs	r0, #0x0
;                 valid = false;
7009999a: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009999e: e243         	b	0x70099e28 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x486
;         }
700999a0: e7ff         	b	0x700999a2 <Sciclient_rmIrqRouteValidate+0x162> @ imm = #-0x2
;         if (i > 0u) {
700999a2: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
700999a6: b158         	cbz	r0, 0x700999c0 <Sciclient_rmIrqRouteValidate+0x180> @ imm = #0x16
700999a8: e7ff         	b	0x700999aa <Sciclient_rmIrqRouteValidate+0x16a> @ imm = #-0x2
;             if (Sciclient_rmIrIsIr(cur_n->id) != true) {
700999aa: 981a         	ldr	r0, [sp, #0x68]
700999ac: 8800         	ldrh	r0, [r0]
700999ae: f013 f9df    	bl	0x700acd70 <Sciclient_rmIrIsIr> @ imm = #0x133be
700999b2: b920         	cbnz	r0, 0x700999be <Sciclient_rmIrqRouteValidate+0x17e> @ imm = #0x8
700999b4: e7ff         	b	0x700999b6 <Sciclient_rmIrqRouteValidate+0x176> @ imm = #-0x2
700999b6: 2000         	movs	r0, #0x0
;                 valid = false;
700999b8: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
700999bc: e234         	b	0x70099e28 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x468
;         }
700999be: e7ff         	b	0x700999c0 <Sciclient_rmIrqRouteValidate+0x180> @ imm = #-0x2
;         if ((i == 0u) && (i < (Sciclient_rmPsGetPsp() - 1u))) {
700999c0: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
700999c4: 2800         	cmp	r0, #0x0
700999c6: f040 8080    	bne.w	0x70099aca <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #0x100
700999ca: e7ff         	b	0x700999cc <Sciclient_rmIrqRouteValidate+0x18c> @ imm = #-0x2
700999cc: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
700999d0: 9003         	str	r0, [sp, #0xc]
700999d2: f014 fb8d    	bl	0x700ae0f0 <Sciclient_rmPsGetPsp> @ imm = #0x1471a
700999d6: 4601         	mov	r1, r0
700999d8: 9803         	ldr	r0, [sp, #0xc]
700999da: 3901         	subs	r1, #0x1
700999dc: 4288         	cmp	r0, r1
700999de: d274         	bhs	0x70099aca <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #0xe8
700999e0: e7ff         	b	0x700999e2 <Sciclient_rmIrqRouteValidate+0x1a2> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cur_n->id) == true) {
700999e2: 981a         	ldr	r0, [sp, #0x68]
700999e4: 8800         	ldrh	r0, [r0]
700999e6: f013 f9ab    	bl	0x700acd40 <Sciclient_rmIaIsIa> @ imm = #0x13356
700999ea: 2800         	cmp	r0, #0x0
700999ec: d049         	beq	0x70099a82 <Sciclient_rmIrqRouteValidate+0x242> @ imm = #0x92
700999ee: e7ff         	b	0x700999f0 <Sciclient_rmIrqRouteValidate+0x1b0> @ imm = #-0x2
700999f0: 2000         	movs	r0, #0x0
;                 cur_outp_valid = false;
700999f2: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 next_inp_valid = false;
700999f6: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cfg->vint,
700999fa: 9a18         	ldr	r2, [sp, #0x60]
700999fc: 8850         	ldrh	r0, [r2, #0x2]
700999fe: 991d         	ldr	r1, [sp, #0x74]
70099a00: 8a49         	ldrh	r1, [r1, #0x12]
70099a02: 8812         	ldrh	r2, [r2]
70099a04: 1a89         	subs	r1, r1, r2
70099a06: 4408         	add	r0, r1
70099a08: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 cur_outp = cfg->vint;
70099a0c: 981d         	ldr	r0, [sp, #0x74]
70099a0e: 8a40         	ldrh	r0, [r0, #0x12]
70099a10: f8ad 0056    	strh.w	r0, [sp, #0x56]
70099a14: 2001         	movs	r0, #0x1
;                 cur_outp_valid = true;
70099a16: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 if ((next_n != NULL) && (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
70099a1a: 9819         	ldr	r0, [sp, #0x64]
70099a1c: b160         	cbz	r0, 0x70099a38 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #0x18
70099a1e: e7ff         	b	0x70099a20 <Sciclient_rmIrqRouteValidate+0x1e0> @ imm = #-0x2
70099a20: 9819         	ldr	r0, [sp, #0x64]
70099a22: 8800         	ldrh	r0, [r0]
70099a24: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
70099a28: f00a fe1a    	bl	0x700a4660 <Sciclient_rmIrInpIsFree> @ imm = #0xac34
70099a2c: b920         	cbnz	r0, 0x70099a38 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #0x8
70099a2e: e7ff         	b	0x70099a30 <Sciclient_rmIrqRouteValidate+0x1f0> @ imm = #-0x2
70099a30: 2001         	movs	r0, #0x1
;                     next_inp_valid = true;
70099a32: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 }
70099a36: e7ff         	b	0x70099a38 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #-0x2
;                 if (Sciclient_rmParamIsValid(cfg->valid_params,
70099a38: 981d         	ldr	r0, [sp, #0x74]
70099a3a: 6800         	ldr	r0, [r0]
70099a3c: 2110         	movs	r1, #0x10
70099a3e: f013 fba7    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x1374e
70099a42: b1e8         	cbz	r0, 0x70099a80 <Sciclient_rmIrqRouteValidate+0x240> @ imm = #0x3a
70099a44: e7ff         	b	0x70099a46 <Sciclient_rmIrqRouteValidate+0x206> @ imm = #-0x2
;                     cur_inp = cfg->global_evt;
70099a46: 981d         	ldr	r0, [sp, #0x74]
70099a48: 89c0         	ldrh	r0, [r0, #0xe]
70099a4a: 9016         	str	r0, [sp, #0x58]
;                     if (Sciclient_rmIaValidateGlobalEvt(cur_n->id,
70099a4c: 981a         	ldr	r0, [sp, #0x68]
70099a4e: 8800         	ldrh	r0, [r0]
;                                       cur_inp) ==
70099a50: f8bd 1058    	ldrh.w	r1, [sp, #0x58]
;                     if (Sciclient_rmIaValidateGlobalEvt(cur_n->id,
70099a54: f011 f844    	bl	0x700aaae0 <Sciclient_rmIaValidateGlobalEvt> @ imm = #0x11088
70099a58: b968         	cbnz	r0, 0x70099a76 <Sciclient_rmIrqRouteValidate+0x236> @ imm = #0x1a
70099a5a: e7ff         	b	0x70099a5c <Sciclient_rmIrqRouteValidate+0x21c> @ imm = #-0x2
;                         if (Sciclient_rmPsSetInp(i, cur_inp) != SystemP_SUCCESS) {
70099a5c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099a60: f8bd 1058    	ldrh.w	r1, [sp, #0x58]
70099a64: f011 fe64    	bl	0x700ab730 <Sciclient_rmPsSetInp> @ imm = #0x11cc8
70099a68: b120         	cbz	r0, 0x70099a74 <Sciclient_rmIrqRouteValidate+0x234> @ imm = #0x8
70099a6a: e7ff         	b	0x70099a6c <Sciclient_rmIrqRouteValidate+0x22c> @ imm = #-0x2
70099a6c: 2000         	movs	r0, #0x0
;                             valid = false;
70099a6e: f88d 0073    	strb.w	r0, [sp, #0x73]
;                             break;
70099a72: e1d9         	b	0x70099e28 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x3b2
;                     } else {
70099a74: e003         	b	0x70099a7e <Sciclient_rmIrqRouteValidate+0x23e> @ imm = #0x6
70099a76: 2000         	movs	r0, #0x0
;                         valid = false;
70099a78: f88d 0073    	strb.w	r0, [sp, #0x73]
;                         break;
70099a7c: e1d4         	b	0x70099e28 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x3a8
;                 }
70099a7e: e7ff         	b	0x70099a80 <Sciclient_rmIrqRouteValidate+0x240> @ imm = #-0x2
;             } else {
70099a80: e022         	b	0x70099ac8 <Sciclient_rmIrqRouteValidate+0x288> @ imm = #0x44
70099a82: 2001         	movs	r0, #0x1
;                 cur_outp_valid = true;
70099a84: f88d 005f    	strb.w	r0, [sp, #0x5f]
70099a88: 2000         	movs	r0, #0x0
;                 next_inp_valid = false;
70099a8a: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 cur_outp = cfg->s_idx;
70099a8e: 981d         	ldr	r0, [sp, #0x74]
70099a90: 8900         	ldrh	r0, [r0, #0x8]
70099a92: f8ad 0056    	strh.w	r0, [sp, #0x56]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cur_outp, cur_if->lbase,
70099a96: 9a18         	ldr	r2, [sp, #0x60]
70099a98: 8850         	ldrh	r0, [r2, #0x2]
70099a9a: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
70099a9e: 8812         	ldrh	r2, [r2]
70099aa0: 1a89         	subs	r1, r1, r2
70099aa2: 4408         	add	r0, r1
70099aa4: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 if ((next_n != NULL) && (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
70099aa8: 9819         	ldr	r0, [sp, #0x64]
70099aaa: b160         	cbz	r0, 0x70099ac6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #0x18
70099aac: e7ff         	b	0x70099aae <Sciclient_rmIrqRouteValidate+0x26e> @ imm = #-0x2
70099aae: 9819         	ldr	r0, [sp, #0x64]
70099ab0: 8800         	ldrh	r0, [r0]
70099ab2: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
70099ab6: f00a fdd3    	bl	0x700a4660 <Sciclient_rmIrInpIsFree> @ imm = #0xaba6
70099aba: b920         	cbnz	r0, 0x70099ac6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #0x8
70099abc: e7ff         	b	0x70099abe <Sciclient_rmIrqRouteValidate+0x27e> @ imm = #-0x2
70099abe: 2001         	movs	r0, #0x1
;                     next_inp_valid = true;
70099ac0: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 }
70099ac4: e7ff         	b	0x70099ac6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #-0x2
70099ac6: e7ff         	b	0x70099ac8 <Sciclient_rmIrqRouteValidate+0x288> @ imm = #-0x2
;         }
70099ac8: e7ff         	b	0x70099aca <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #-0x2
;         if ((i > 0u) && (i < (Sciclient_rmPsGetPsp() - 1u))) {
70099aca: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099ace: 2800         	cmp	r0, #0x0
70099ad0: f000 80c4    	beq.w	0x70099c5c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #0x188
70099ad4: e7ff         	b	0x70099ad6 <Sciclient_rmIrqRouteValidate+0x296> @ imm = #-0x2
70099ad6: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099ada: 9002         	str	r0, [sp, #0x8]
70099adc: f014 fb08    	bl	0x700ae0f0 <Sciclient_rmPsGetPsp> @ imm = #0x14610
70099ae0: 4601         	mov	r1, r0
70099ae2: 9802         	ldr	r0, [sp, #0x8]
70099ae4: 3901         	subs	r1, #0x1
70099ae6: 4288         	cmp	r0, r1
70099ae8: f080 80b8    	bhs.w	0x70099c5c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #0x170
70099aec: e7ff         	b	0x70099aee <Sciclient_rmIrqRouteValidate+0x2ae> @ imm = #-0x2
;             req.secondary_host = cfg->host;
70099aee: 981d         	ldr	r0, [sp, #0x74]
70099af0: 7900         	ldrb	r0, [r0, #0x4]
70099af2: f88d 0053    	strb.w	r0, [sp, #0x53]
;             req.type = cur_n->id;
70099af6: 981a         	ldr	r0, [sp, #0x68]
70099af8: 8800         	ldrh	r0, [r0]
70099afa: f8ad 0050    	strh.w	r0, [sp, #0x50]
70099afe: 2000         	movs	r0, #0x0
;             req.subtype = TISCI_RESASG_SUBTYPE_IR_OUTPUT;
70099b00: f88d 0052    	strb.w	r0, [sp, #0x52]
70099b04: a812         	add	r0, sp, #0x48
70099b06: a90e         	add	r1, sp, #0x38
70099b08: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &host_resp,
70099b0c: f00f fec0    	bl	0x700a9890 <Sciclient_rmGetResourceRange> @ imm = #0xfd80
70099b10: b120         	cbz	r0, 0x70099b1c <Sciclient_rmIrqRouteValidate+0x2dc> @ imm = #0x8
70099b12: e7ff         	b	0x70099b14 <Sciclient_rmIrqRouteValidate+0x2d4> @ imm = #-0x2
70099b14: 2000         	movs	r0, #0x0
;                 valid = false;
70099b16: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099b1a: e185         	b	0x70099e28 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x30a
70099b1c: 2080         	movs	r0, #0x80
;             req.secondary_host = TISCI_HOST_ID_ALL;
70099b1e: f88d 0053    	strb.w	r0, [sp, #0x53]
70099b22: a812         	add	r0, sp, #0x48
70099b24: a90a         	add	r1, sp, #0x28
70099b26: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &all_resp,
70099b2a: f00f feb1    	bl	0x700a9890 <Sciclient_rmGetResourceRange> @ imm = #0xfd62
70099b2e: b120         	cbz	r0, 0x70099b3a <Sciclient_rmIrqRouteValidate+0x2fa> @ imm = #0x8
70099b30: e7ff         	b	0x70099b32 <Sciclient_rmIrqRouteValidate+0x2f2> @ imm = #-0x2
70099b32: 2000         	movs	r0, #0x0
;                 valid = false;
70099b34: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099b38: e176         	b	0x70099e28 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x2ec
;             for (j = cur_if->lbase; j < cur_if->lbase + cur_if->len;
70099b3a: 9818         	ldr	r0, [sp, #0x60]
70099b3c: 8800         	ldrh	r0, [r0]
70099b3e: f8ad 006e    	strh.w	r0, [sp, #0x6e]
70099b42: e7ff         	b	0x70099b44 <Sciclient_rmIrqRouteValidate+0x304> @ imm = #-0x2
70099b44: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
70099b48: 9a18         	ldr	r2, [sp, #0x60]
70099b4a: 8811         	ldrh	r1, [r2]
70099b4c: 8892         	ldrh	r2, [r2, #0x4]
70099b4e: 4411         	add	r1, r2
70099b50: 4288         	cmp	r0, r1
70099b52: f280 8082    	bge.w	0x70099c5a <Sciclient_rmIrqRouteValidate+0x41a> @ imm = #0x104
70099b56: e7ff         	b	0x70099b58 <Sciclient_rmIrqRouteValidate+0x318> @ imm = #-0x2
70099b58: 2000         	movs	r0, #0x0
;                 cur_outp_valid = false;
70099b5a: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 next_inp_valid = false;
70099b5e: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 cur_outp = j;
70099b62: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
70099b66: f8ad 0056    	strh.w	r0, [sp, #0x56]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cur_outp, cur_if->lbase,
70099b6a: 9a18         	ldr	r2, [sp, #0x60]
70099b6c: 8850         	ldrh	r0, [r2, #0x2]
70099b6e: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
70099b72: 8812         	ldrh	r2, [r2]
70099b74: 1a89         	subs	r1, r1, r2
70099b76: 4408         	add	r0, r1
70099b78: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 if ((((cur_outp >= host_resp.range_start) &&
70099b7c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099b80: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
70099b84: 4288         	cmp	r0, r1
70099b86: db0a         	blt	0x70099b9e <Sciclient_rmIrqRouteValidate+0x35e> @ imm = #0x14
70099b88: e7ff         	b	0x70099b8a <Sciclient_rmIrqRouteValidate+0x34a> @ imm = #-0x2
;                       (cur_outp < host_resp.range_start + host_resp.range_num)) ||
70099b8a: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099b8e: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
70099b92: f8bd 2042    	ldrh.w	r2, [sp, #0x42]
70099b96: 4411         	add	r1, r2
70099b98: 4288         	cmp	r0, r1
70099b9a: db33         	blt	0x70099c04 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x66
70099b9c: e7ff         	b	0x70099b9e <Sciclient_rmIrqRouteValidate+0x35e> @ imm = #-0x2
;                      ((cur_outp >= host_resp.range_start_sec) &&
70099b9e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099ba2: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
70099ba6: 4288         	cmp	r0, r1
70099ba8: db0a         	blt	0x70099bc0 <Sciclient_rmIrqRouteValidate+0x380> @ imm = #0x14
70099baa: e7ff         	b	0x70099bac <Sciclient_rmIrqRouteValidate+0x36c> @ imm = #-0x2
;                       (cur_outp < host_resp.range_start_sec +
70099bac: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099bb0: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
;                                   host_resp.range_num_sec))) ||
70099bb4: f8bd 2046    	ldrh.w	r2, [sp, #0x46]
;                       (cur_outp < host_resp.range_start_sec +
70099bb8: 4411         	add	r1, r2
;                                   host_resp.range_num_sec))) ||
70099bba: 4288         	cmp	r0, r1
70099bbc: db22         	blt	0x70099c04 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x44
70099bbe: e7ff         	b	0x70099bc0 <Sciclient_rmIrqRouteValidate+0x380> @ imm = #-0x2
;                     (((cur_outp >= all_resp.range_start) &&
70099bc0: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099bc4: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
70099bc8: 4288         	cmp	r0, r1
70099bca: db0a         	blt	0x70099be2 <Sciclient_rmIrqRouteValidate+0x3a2> @ imm = #0x14
70099bcc: e7ff         	b	0x70099bce <Sciclient_rmIrqRouteValidate+0x38e> @ imm = #-0x2
;                       (cur_outp < all_resp.range_start + all_resp.range_num)) ||
70099bce: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099bd2: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
70099bd6: f8bd 2032    	ldrh.w	r2, [sp, #0x32]
70099bda: 4411         	add	r1, r2
70099bdc: 4288         	cmp	r0, r1
70099bde: db11         	blt	0x70099c04 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x22
70099be0: e7ff         	b	0x70099be2 <Sciclient_rmIrqRouteValidate+0x3a2> @ imm = #-0x2
;                      ((cur_outp >= all_resp.range_start_sec) &&
70099be2: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099be6: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
70099bea: 4288         	cmp	r0, r1
70099bec: db2e         	blt	0x70099c4c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #0x5c
70099bee: e7ff         	b	0x70099bf0 <Sciclient_rmIrqRouteValidate+0x3b0> @ imm = #-0x2
;                       (cur_outp < all_resp.range_start_sec +
70099bf0: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099bf4: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
;                                   all_resp.range_num_sec)))) {
70099bf8: f8bd 2036    	ldrh.w	r2, [sp, #0x36]
;                       (cur_outp < all_resp.range_start_sec +
70099bfc: 4411         	add	r1, r2
;                 if ((((cur_outp >= host_resp.range_start) &&
70099bfe: 4288         	cmp	r0, r1
70099c00: da24         	bge	0x70099c4c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #0x48
70099c02: e7ff         	b	0x70099c04 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #-0x2
;                     if (Sciclient_rmIrOutpIsFree(cur_n->id, cur_outp) ==
70099c04: 981a         	ldr	r0, [sp, #0x68]
70099c06: 8800         	ldrh	r0, [r0]
70099c08: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
70099c0c: f00d fce0    	bl	0x700a75d0 <Sciclient_rmIrOutpIsFree> @ imm = #0xd9c0
70099c10: b920         	cbnz	r0, 0x70099c1c <Sciclient_rmIrqRouteValidate+0x3dc> @ imm = #0x8
70099c12: e7ff         	b	0x70099c14 <Sciclient_rmIrqRouteValidate+0x3d4> @ imm = #-0x2
70099c14: 2001         	movs	r0, #0x1
;                         cur_outp_valid = true;
70099c16: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                     }
70099c1a: e7ff         	b	0x70099c1c <Sciclient_rmIrqRouteValidate+0x3dc> @ imm = #-0x2
;                     if (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
70099c1c: 9819         	ldr	r0, [sp, #0x64]
70099c1e: 8800         	ldrh	r0, [r0]
70099c20: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
70099c24: f00a fd1c    	bl	0x700a4660 <Sciclient_rmIrInpIsFree> @ imm = #0xaa38
70099c28: b920         	cbnz	r0, 0x70099c34 <Sciclient_rmIrqRouteValidate+0x3f4> @ imm = #0x8
70099c2a: e7ff         	b	0x70099c2c <Sciclient_rmIrqRouteValidate+0x3ec> @ imm = #-0x2
70099c2c: 2001         	movs	r0, #0x1
;                         next_inp_valid = true;
70099c2e: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                     }
70099c32: e7ff         	b	0x70099c34 <Sciclient_rmIrqRouteValidate+0x3f4> @ imm = #-0x2
;                     if ((cur_outp_valid == true) &&
70099c34: f89d 005f    	ldrb.w	r0, [sp, #0x5f]
70099c38: 07c0         	lsls	r0, r0, #0x1f
70099c3a: b130         	cbz	r0, 0x70099c4a <Sciclient_rmIrqRouteValidate+0x40a> @ imm = #0xc
70099c3c: e7ff         	b	0x70099c3e <Sciclient_rmIrqRouteValidate+0x3fe> @ imm = #-0x2
;                         (next_inp_valid == true)) {
70099c3e: f89d 005e    	ldrb.w	r0, [sp, #0x5e]
;                     if ((cur_outp_valid == true) &&
70099c42: 07c0         	lsls	r0, r0, #0x1f
70099c44: b108         	cbz	r0, 0x70099c4a <Sciclient_rmIrqRouteValidate+0x40a> @ imm = #0x2
70099c46: e7ff         	b	0x70099c48 <Sciclient_rmIrqRouteValidate+0x408> @ imm = #-0x2
;                         break;
70099c48: e007         	b	0x70099c5a <Sciclient_rmIrqRouteValidate+0x41a> @ imm = #0xe
;                 }
70099c4a: e7ff         	b	0x70099c4c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #-0x2
;             }
70099c4c: e7ff         	b	0x70099c4e <Sciclient_rmIrqRouteValidate+0x40e> @ imm = #-0x2
;                  j++) {
70099c4e: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
70099c52: 3001         	adds	r0, #0x1
70099c54: f8ad 006e    	strh.w	r0, [sp, #0x6e]
;             for (j = cur_if->lbase; j < cur_if->lbase + cur_if->len;
70099c58: e774         	b	0x70099b44 <Sciclient_rmIrqRouteValidate+0x304> @ imm = #-0x118
;         }
70099c5a: e7ff         	b	0x70099c5c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #-0x2
;         if (i == (Sciclient_rmPsGetPsp() - 1u)) {
70099c5c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099c60: 9001         	str	r0, [sp, #0x4]
70099c62: f014 fa45    	bl	0x700ae0f0 <Sciclient_rmPsGetPsp> @ imm = #0x1448a
70099c66: 4601         	mov	r1, r0
70099c68: 9801         	ldr	r0, [sp, #0x4]
70099c6a: 3901         	subs	r1, #0x1
70099c6c: 4288         	cmp	r0, r1
70099c6e: f040 809f    	bne.w	0x70099db0 <Sciclient_rmIrqRouteValidate+0x570> @ imm = #0x13e
70099c72: e7ff         	b	0x70099c74 <Sciclient_rmIrqRouteValidate+0x434> @ imm = #-0x2
70099c74: 2000         	movs	r0, #0x0
;             cur_outp_valid = false;
70099c76: f88d 005f    	strb.w	r0, [sp, #0x5f]
70099c7a: 2101         	movs	r1, #0x1
;             next_inp_valid = true;
70099c7c: f88d 105e    	strb.w	r1, [sp, #0x5e]
;             req.secondary_host = cfg->host;
70099c80: 991d         	ldr	r1, [sp, #0x74]
70099c82: 7909         	ldrb	r1, [r1, #0x4]
70099c84: f88d 1053    	strb.w	r1, [sp, #0x53]
;             req.type = cur_n->id;
70099c88: 991a         	ldr	r1, [sp, #0x68]
70099c8a: 8809         	ldrh	r1, [r1]
70099c8c: f8ad 1050    	strh.w	r1, [sp, #0x50]
;             req.subtype = TISCI_RESASG_SUBTYPE_IR_OUTPUT;
70099c90: f88d 0052    	strb.w	r0, [sp, #0x52]
70099c94: a812         	add	r0, sp, #0x48
70099c96: a90e         	add	r1, sp, #0x38
70099c98: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &host_resp,
70099c9c: f00f fdf8    	bl	0x700a9890 <Sciclient_rmGetResourceRange> @ imm = #0xfbf0
70099ca0: b120         	cbz	r0, 0x70099cac <Sciclient_rmIrqRouteValidate+0x46c> @ imm = #0x8
70099ca2: e7ff         	b	0x70099ca4 <Sciclient_rmIrqRouteValidate+0x464> @ imm = #-0x2
70099ca4: 2000         	movs	r0, #0x0
;                 valid = false;
70099ca6: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099caa: e0bd         	b	0x70099e28 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x17a
70099cac: 2080         	movs	r0, #0x80
;             req.secondary_host = TISCI_HOST_ID_ALL;
70099cae: f88d 0053    	strb.w	r0, [sp, #0x53]
70099cb2: a812         	add	r0, sp, #0x48
70099cb4: a90a         	add	r1, sp, #0x28
70099cb6: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &all_resp,
70099cba: f00f fde9    	bl	0x700a9890 <Sciclient_rmGetResourceRange> @ imm = #0xfbd2
70099cbe: b120         	cbz	r0, 0x70099cca <Sciclient_rmIrqRouteValidate+0x48a> @ imm = #0x8
70099cc0: e7ff         	b	0x70099cc2 <Sciclient_rmIrqRouteValidate+0x482> @ imm = #-0x2
70099cc2: 2000         	movs	r0, #0x0
;                 valid = false;
70099cc4: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099cc8: e0ae         	b	0x70099e28 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x15c
;             cur_outp = SCICLIENT_INP_TO_OUTP(cfg->d_irq,
70099cca: 9a18         	ldr	r2, [sp, #0x60]
70099ccc: 8810         	ldrh	r0, [r2]
70099cce: 991d         	ldr	r1, [sp, #0x74]
70099cd0: 8989         	ldrh	r1, [r1, #0xc]
70099cd2: 8852         	ldrh	r2, [r2, #0x2]
70099cd4: 1a89         	subs	r1, r1, r2
70099cd6: 4408         	add	r0, r1
70099cd8: f8ad 0056    	strh.w	r0, [sp, #0x56]
;             if ((((cur_outp >= host_resp.range_start) &&
70099cdc: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099ce0: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
70099ce4: 4288         	cmp	r0, r1
70099ce6: db0a         	blt	0x70099cfe <Sciclient_rmIrqRouteValidate+0x4be> @ imm = #0x14
70099ce8: e7ff         	b	0x70099cea <Sciclient_rmIrqRouteValidate+0x4aa> @ imm = #-0x2
;                   (cur_outp < host_resp.range_start + host_resp.range_num)) ||
70099cea: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099cee: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
70099cf2: f8bd 2042    	ldrh.w	r2, [sp, #0x42]
70099cf6: 4411         	add	r1, r2
70099cf8: 4288         	cmp	r0, r1
70099cfa: db33         	blt	0x70099d64 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x66
70099cfc: e7ff         	b	0x70099cfe <Sciclient_rmIrqRouteValidate+0x4be> @ imm = #-0x2
;                  ((cur_outp >= host_resp.range_start_sec) &&
70099cfe: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099d02: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
70099d06: 4288         	cmp	r0, r1
70099d08: db0a         	blt	0x70099d20 <Sciclient_rmIrqRouteValidate+0x4e0> @ imm = #0x14
70099d0a: e7ff         	b	0x70099d0c <Sciclient_rmIrqRouteValidate+0x4cc> @ imm = #-0x2
;                   (cur_outp < host_resp.range_start_sec +
70099d0c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099d10: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
;                               host_resp.range_num_sec))) ||
70099d14: f8bd 2046    	ldrh.w	r2, [sp, #0x46]
;                   (cur_outp < host_resp.range_start_sec +
70099d18: 4411         	add	r1, r2
;                               host_resp.range_num_sec))) ||
70099d1a: 4288         	cmp	r0, r1
70099d1c: db22         	blt	0x70099d64 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x44
70099d1e: e7ff         	b	0x70099d20 <Sciclient_rmIrqRouteValidate+0x4e0> @ imm = #-0x2
;                 (((cur_outp >= all_resp.range_start) &&
70099d20: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099d24: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
70099d28: 4288         	cmp	r0, r1
70099d2a: db0a         	blt	0x70099d42 <Sciclient_rmIrqRouteValidate+0x502> @ imm = #0x14
70099d2c: e7ff         	b	0x70099d2e <Sciclient_rmIrqRouteValidate+0x4ee> @ imm = #-0x2
;                   (cur_outp < all_resp.range_start + all_resp.range_num)) ||
70099d2e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099d32: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
70099d36: f8bd 2032    	ldrh.w	r2, [sp, #0x32]
70099d3a: 4411         	add	r1, r2
70099d3c: 4288         	cmp	r0, r1
70099d3e: db11         	blt	0x70099d64 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x22
70099d40: e7ff         	b	0x70099d42 <Sciclient_rmIrqRouteValidate+0x502> @ imm = #-0x2
;                  ((cur_outp >= all_resp.range_start_sec) &&
70099d42: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099d46: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
70099d4a: 4288         	cmp	r0, r1
70099d4c: db2f         	blt	0x70099dae <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #0x5e
70099d4e: e7ff         	b	0x70099d50 <Sciclient_rmIrqRouteValidate+0x510> @ imm = #-0x2
;                   (cur_outp < all_resp.range_start_sec +
70099d50: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099d54: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
;                               all_resp.range_num_sec)))) {
70099d58: f8bd 2036    	ldrh.w	r2, [sp, #0x36]
;                   (cur_outp < all_resp.range_start_sec +
70099d5c: 4411         	add	r1, r2
;             if ((((cur_outp >= host_resp.range_start) &&
70099d5e: 4288         	cmp	r0, r1
70099d60: da25         	bge	0x70099dae <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #0x4a
70099d62: e7ff         	b	0x70099d64 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #-0x2
;                 if ((cur_if->rid == cfg->d_id) &&
70099d64: 9818         	ldr	r0, [sp, #0x60]
70099d66: 88c0         	ldrh	r0, [r0, #0x6]
70099d68: 991d         	ldr	r1, [sp, #0x74]
70099d6a: 8949         	ldrh	r1, [r1, #0xa]
70099d6c: 4288         	cmp	r0, r1
70099d6e: d11d         	bne	0x70099dac <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x3a
70099d70: e7ff         	b	0x70099d72 <Sciclient_rmIrqRouteValidate+0x532> @ imm = #-0x2
;                     (cfg->d_irq >= (cur_if->rbase)) &&
70099d72: 981d         	ldr	r0, [sp, #0x74]
70099d74: 8980         	ldrh	r0, [r0, #0xc]
70099d76: 9918         	ldr	r1, [sp, #0x60]
70099d78: 8849         	ldrh	r1, [r1, #0x2]
70099d7a: 4288         	cmp	r0, r1
70099d7c: db16         	blt	0x70099dac <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x2c
70099d7e: e7ff         	b	0x70099d80 <Sciclient_rmIrqRouteValidate+0x540> @ imm = #-0x2
;                     (cfg->d_irq < (cur_if->rbase + cur_if->len))) {
70099d80: 981d         	ldr	r0, [sp, #0x74]
70099d82: 8980         	ldrh	r0, [r0, #0xc]
70099d84: 9a18         	ldr	r2, [sp, #0x60]
70099d86: 8851         	ldrh	r1, [r2, #0x2]
70099d88: 8892         	ldrh	r2, [r2, #0x4]
70099d8a: 4411         	add	r1, r2
;                 if ((cur_if->rid == cfg->d_id) &&
70099d8c: 4288         	cmp	r0, r1
70099d8e: da0d         	bge	0x70099dac <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x1a
70099d90: e7ff         	b	0x70099d92 <Sciclient_rmIrqRouteValidate+0x552> @ imm = #-0x2
;                     if (Sciclient_rmIrOutpIsFree(cur_n->id, cur_outp) ==
70099d92: 981a         	ldr	r0, [sp, #0x68]
70099d94: 8800         	ldrh	r0, [r0]
70099d96: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
70099d9a: f00d fc19    	bl	0x700a75d0 <Sciclient_rmIrOutpIsFree> @ imm = #0xd832
70099d9e: b920         	cbnz	r0, 0x70099daa <Sciclient_rmIrqRouteValidate+0x56a> @ imm = #0x8
70099da0: e7ff         	b	0x70099da2 <Sciclient_rmIrqRouteValidate+0x562> @ imm = #-0x2
70099da2: 2001         	movs	r0, #0x1
;                         cur_outp_valid = true;
70099da4: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                     }
70099da8: e7ff         	b	0x70099daa <Sciclient_rmIrqRouteValidate+0x56a> @ imm = #-0x2
;                 }
70099daa: e7ff         	b	0x70099dac <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #-0x2
; 	    }
70099dac: e7ff         	b	0x70099dae <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #-0x2
;         }
70099dae: e7ff         	b	0x70099db0 <Sciclient_rmIrqRouteValidate+0x570> @ imm = #-0x2
;         if ((cur_outp_valid == true) && (next_inp_valid == true)) {
70099db0: f89d 005f    	ldrb.w	r0, [sp, #0x5f]
70099db4: 07c0         	lsls	r0, r0, #0x1f
70099db6: b360         	cbz	r0, 0x70099e12 <Sciclient_rmIrqRouteValidate+0x5d2> @ imm = #0x58
70099db8: e7ff         	b	0x70099dba <Sciclient_rmIrqRouteValidate+0x57a> @ imm = #-0x2
70099dba: f89d 005e    	ldrb.w	r0, [sp, #0x5e]
70099dbe: 07c0         	lsls	r0, r0, #0x1f
70099dc0: b338         	cbz	r0, 0x70099e12 <Sciclient_rmIrqRouteValidate+0x5d2> @ imm = #0x4e
70099dc2: e7ff         	b	0x70099dc4 <Sciclient_rmIrqRouteValidate+0x584> @ imm = #-0x2
;             if (i < (Sciclient_rmPsGetPsp() - (1u))) {
70099dc4: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099dc8: 9000         	str	r0, [sp]
70099dca: f014 f991    	bl	0x700ae0f0 <Sciclient_rmPsGetPsp> @ imm = #0x14322
70099dce: 4601         	mov	r1, r0
70099dd0: 9800         	ldr	r0, [sp]
70099dd2: 3901         	subs	r1, #0x1
70099dd4: 4288         	cmp	r0, r1
70099dd6: d20f         	bhs	0x70099df8 <Sciclient_rmIrqRouteValidate+0x5b8> @ imm = #0x1e
70099dd8: e7ff         	b	0x70099dda <Sciclient_rmIrqRouteValidate+0x59a> @ imm = #-0x2
;                 if (Sciclient_rmPsSetInp(i + (1u), next_inp) != SystemP_SUCCESS) {
70099dda: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099dde: 3001         	adds	r0, #0x1
70099de0: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
70099de4: b280         	uxth	r0, r0
70099de6: f011 fca3    	bl	0x700ab730 <Sciclient_rmPsSetInp> @ imm = #0x11946
70099dea: b120         	cbz	r0, 0x70099df6 <Sciclient_rmIrqRouteValidate+0x5b6> @ imm = #0x8
70099dec: e7ff         	b	0x70099dee <Sciclient_rmIrqRouteValidate+0x5ae> @ imm = #-0x2
70099dee: 2000         	movs	r0, #0x0
;                     valid = false;
70099df0: f88d 0073    	strb.w	r0, [sp, #0x73]
;                     break;
70099df4: e018         	b	0x70099e28 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x30
;             }
70099df6: e7ff         	b	0x70099df8 <Sciclient_rmIrqRouteValidate+0x5b8> @ imm = #-0x2
;             if (Sciclient_rmPsSetOutp(i, cur_outp) != SystemP_SUCCESS) {
70099df8: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099dfc: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
70099e00: f011 fcbe    	bl	0x700ab780 <Sciclient_rmPsSetOutp> @ imm = #0x1197c
70099e04: b120         	cbz	r0, 0x70099e10 <Sciclient_rmIrqRouteValidate+0x5d0> @ imm = #0x8
70099e06: e7ff         	b	0x70099e08 <Sciclient_rmIrqRouteValidate+0x5c8> @ imm = #-0x2
70099e08: 2000         	movs	r0, #0x0
;                 valid = false;
70099e0a: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099e0e: e00b         	b	0x70099e28 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x16
;         } else {
70099e10: e003         	b	0x70099e1a <Sciclient_rmIrqRouteValidate+0x5da> @ imm = #0x6
70099e12: 2000         	movs	r0, #0x0
;             valid = false;
70099e14: f88d 0073    	strb.w	r0, [sp, #0x73]
;             break;
70099e18: e006         	b	0x70099e28 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0xc
;     }
70099e1a: e7ff         	b	0x70099e1c <Sciclient_rmIrqRouteValidate+0x5dc> @ imm = #-0x2
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
70099e1c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099e20: 3001         	adds	r0, #0x1
70099e22: f8ad 0070    	strh.w	r0, [sp, #0x70]
70099e26: e579         	b	0x7009991c <Sciclient_rmIrqRouteValidate+0xdc> @ imm = #-0x50e
;     return valid;
70099e28: f89d 0073    	ldrb.w	r0, [sp, #0x73]
70099e2c: f000 0001    	and	r0, r0, #0x1
70099e30: b01e         	add	sp, #0x78
70099e32: bd80         	pop	{r7, pc}

70099e34 <malloc>:
70099e34: e1a01000     	mov	r1, r0
70099e38: e3a00008     	mov	r0, #8
70099e3c: ea001164     	b	0x7009e3d4 <memalign>   @ imm = #0x4590

70099e40 <_ftoa>:
; {
70099e40: b570         	push	{r4, r5, r6, lr}
70099e42: b0a2         	sub	sp, #0x88
70099e44: f8dd c0a0    	ldr.w	r12, [sp, #0xa0]
70099e48: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
70099e4c: f8dd c098    	ldr.w	r12, [sp, #0x98]
70099e50: 9020         	str	r0, [sp, #0x80]
70099e52: 911f         	str	r1, [sp, #0x7c]
70099e54: 921e         	str	r2, [sp, #0x78]
70099e56: 931d         	str	r3, [sp, #0x74]
70099e58: ed8d 0b1a    	vstr	d0, [sp, #104]
70099e5c: 2000         	movs	r0, #0x0
;   size_t len  = 0U;
70099e5e: 9011         	str	r0, [sp, #0x44]
;   double diff = 0.0;
70099e60: 900f         	str	r0, [sp, #0x3c]
70099e62: 900e         	str	r0, [sp, #0x38]
;   if (value != value)
70099e64: ed9d 0b1a    	vldr	d0, [sp, #104]
70099e68: eeb4 0b40    	vcmp.f64	d0, d0
70099e6c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
70099e70: d71a         	bvc	0x70099ea8 <_ftoa+0x68> @ imm = #0x34
70099e72: e7ff         	b	0x70099e74 <_ftoa+0x34> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
70099e74: 9820         	ldr	r0, [sp, #0x80]
70099e76: 991f         	ldr	r1, [sp, #0x7c]
70099e78: 9a1e         	ldr	r2, [sp, #0x78]
70099e7a: 9b1d         	ldr	r3, [sp, #0x74]
70099e7c: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
70099e80: 9c28         	ldr	r4, [sp, #0xa0]
70099e82: 46ee         	mov	lr, sp
70099e84: f8ce 400c    	str.w	r4, [lr, #0xc]
70099e88: f8ce c008    	str.w	r12, [lr, #0x8]
70099e8c: f04f 0c03    	mov.w	r12, #0x3
70099e90: f8ce c004    	str.w	r12, [lr, #0x4]
70099e94: f640 1cfc    	movw	r12, #0x9fc
70099e98: f2c7 0c0b    	movt	r12, #0x700b
70099e9c: f8ce c000    	str.w	r12, [lr]
70099ea0: f00b fde6    	bl	0x700a5a70 <_out_rev>   @ imm = #0xbbcc
70099ea4: 9021         	str	r0, [sp, #0x84]
70099ea6: e257         	b	0x7009a358 <_ftoa+0x518> @ imm = #0x4ae
;   if (value < -DBL_MAX)
70099ea8: ed9d 0b1a    	vldr	d0, [sp, #104]
70099eac: ed9f 1bd2    	vldr	d1, [pc, #840]          @ 0x7009a1f8 <_ftoa+0x3b8>
70099eb0: eeb4 0b41    	vcmp.f64	d0, d1
70099eb4: eef1 fa10    	vmrs	APSR_nzcv, fpscr
70099eb8: d51a         	bpl	0x70099ef0 <_ftoa+0xb0> @ imm = #0x34
70099eba: e7ff         	b	0x70099ebc <_ftoa+0x7c> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
70099ebc: 9820         	ldr	r0, [sp, #0x80]
70099ebe: 991f         	ldr	r1, [sp, #0x7c]
70099ec0: 9a1e         	ldr	r2, [sp, #0x78]
70099ec2: 9b1d         	ldr	r3, [sp, #0x74]
70099ec4: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
70099ec8: 9c28         	ldr	r4, [sp, #0xa0]
70099eca: 46ee         	mov	lr, sp
70099ecc: f8ce 400c    	str.w	r4, [lr, #0xc]
70099ed0: f8ce c008    	str.w	r12, [lr, #0x8]
70099ed4: f04f 0c04    	mov.w	r12, #0x4
70099ed8: f8ce c004    	str.w	r12, [lr, #0x4]
70099edc: f640 1cd9    	movw	r12, #0x9d9
70099ee0: f2c7 0c0b    	movt	r12, #0x700b
70099ee4: f8ce c000    	str.w	r12, [lr]
70099ee8: f00b fdc2    	bl	0x700a5a70 <_out_rev>   @ imm = #0xbb84
70099eec: 9021         	str	r0, [sp, #0x84]
70099eee: e233         	b	0x7009a358 <_ftoa+0x518> @ imm = #0x466
;   if (value > DBL_MAX)
70099ef0: ed9d 0b1a    	vldr	d0, [sp, #104]
70099ef4: ed9f 1bc2    	vldr	d1, [pc, #776]          @ 0x7009a200 <_ftoa+0x3c0>
70099ef8: eeb4 0b41    	vcmp.f64	d0, d1
70099efc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
70099f00: dd26         	ble	0x70099f50 <_ftoa+0x110> @ imm = #0x4c
70099f02: e7ff         	b	0x70099f04 <_ftoa+0xc4> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
70099f04: 9820         	ldr	r0, [sp, #0x80]
70099f06: 991f         	ldr	r1, [sp, #0x7c]
70099f08: 9a1e         	ldr	r2, [sp, #0x78]
70099f0a: 9b1d         	ldr	r3, [sp, #0x74]
70099f0c: 9e28         	ldr	r6, [sp, #0xa0]
70099f0e: f006 0e04    	and	lr, r6, #0x4
70099f12: f640 14e3    	movw	r4, #0x9e3
70099f16: f2c7 040b    	movt	r4, #0x700b
70099f1a: f640 1cf8    	movw	r12, #0x9f8
70099f1e: f2c7 0c0b    	movt	r12, #0x700b
70099f22: f1be 0f00    	cmp.w	lr, #0x0
70099f26: bf18         	it	ne
70099f28: 46a4         	movne	r12, r4
70099f2a: 2403         	movs	r4, #0x3
70099f2c: f1be 0f00    	cmp.w	lr, #0x0
70099f30: bf18         	it	ne
70099f32: 2404         	movne	r4, #0x4
70099f34: 9d27         	ldr	r5, [sp, #0x9c]
70099f36: 46ee         	mov	lr, sp
70099f38: f8ce 600c    	str.w	r6, [lr, #0xc]
70099f3c: f8ce 5008    	str.w	r5, [lr, #0x8]
70099f40: f8ce 4004    	str.w	r4, [lr, #0x4]
70099f44: f8ce c000    	str.w	r12, [lr]
70099f48: f00b fd92    	bl	0x700a5a70 <_out_rev>   @ imm = #0xbb24
70099f4c: 9021         	str	r0, [sp, #0x84]
70099f4e: e203         	b	0x7009a358 <_ftoa+0x518> @ imm = #0x406
;   if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
70099f50: ed9d 0b1a    	vldr	d0, [sp, #104]
70099f54: ed9f 1bac    	vldr	d1, [pc, #688]          @ 0x7009a208 <_ftoa+0x3c8>
70099f58: eeb4 0b41    	vcmp.f64	d0, d1
70099f5c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
70099f60: dc0a         	bgt	0x70099f78 <_ftoa+0x138> @ imm = #0x14
70099f62: e7ff         	b	0x70099f64 <_ftoa+0x124> @ imm = #-0x2
70099f64: ed9d 0b1a    	vldr	d0, [sp, #104]
70099f68: ed9f 1ba9    	vldr	d1, [pc, #676]          @ 0x7009a210 <_ftoa+0x3d0>
70099f6c: eeb4 0b41    	vcmp.f64	d0, d1
70099f70: eef1 fa10    	vmrs	APSR_nzcv, fpscr
70099f74: d515         	bpl	0x70099fa2 <_ftoa+0x162> @ imm = #0x2a
70099f76: e7ff         	b	0x70099f78 <_ftoa+0x138> @ imm = #-0x2
;     return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
70099f78: 9820         	ldr	r0, [sp, #0x80]
70099f7a: 991f         	ldr	r1, [sp, #0x7c]
70099f7c: 9a1e         	ldr	r2, [sp, #0x78]
70099f7e: 9b1d         	ldr	r3, [sp, #0x74]
70099f80: ed9d 0b1a    	vldr	d0, [sp, #104]
70099f84: f8dd c098    	ldr.w	r12, [sp, #0x98]
70099f88: 9c27         	ldr	r4, [sp, #0x9c]
70099f8a: 9d28         	ldr	r5, [sp, #0xa0]
70099f8c: 46ee         	mov	lr, sp
70099f8e: f8ce 5008    	str.w	r5, [lr, #0x8]
70099f92: f8ce 4004    	str.w	r4, [lr, #0x4]
70099f96: f8ce c000    	str.w	r12, [lr]
70099f9a: f000 f9e1    	bl	0x7009a360 <_etoa>      @ imm = #0x3c2
70099f9e: 9021         	str	r0, [sp, #0x84]
70099fa0: e1da         	b	0x7009a358 <_ftoa+0x518> @ imm = #0x3b4
70099fa2: f04f 0000    	mov.w	r0, #0x0
;   bool negative = false;
70099fa6: f88d 0037    	strb.w	r0, [sp, #0x37]
;   if (value < 0) {
70099faa: ed9d 0b1a    	vldr	d0, [sp, #104]
70099fae: eeb5 0b40    	vcmp.f64	d0, #0
70099fb2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
70099fb6: d50d         	bpl	0x70099fd4 <_ftoa+0x194> @ imm = #0x1a
70099fb8: e7ff         	b	0x70099fba <_ftoa+0x17a> @ imm = #-0x2
70099fba: f04f 0001    	mov.w	r0, #0x1
;     negative = true;
70099fbe: f88d 0037    	strb.w	r0, [sp, #0x37]
;     value = 0 - value;
70099fc2: ed9d 1b1a    	vldr	d1, [sp, #104]
70099fc6: ed9f 0b94    	vldr	d0, [pc, #592]          @ 0x7009a218 <_ftoa+0x3d8>
70099fca: ee30 0b41    	vsub.f64	d0, d0, d1
70099fce: ed8d 0b1a    	vstr	d0, [sp, #104]
;   }
70099fd2: e7ff         	b	0x70099fd4 <_ftoa+0x194> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION)) {
70099fd4: f89d 00a1    	ldrb.w	r0, [sp, #0xa1]
70099fd8: ea4f 7040    	lsl.w	r0, r0, #0x1d
70099fdc: 2800         	cmp	r0, #0x0
70099fde: d403         	bmi	0x70099fe8 <_ftoa+0x1a8> @ imm = #0x6
70099fe0: e7ff         	b	0x70099fe2 <_ftoa+0x1a2> @ imm = #-0x2
70099fe2: 2006         	movs	r0, #0x6
;     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
70099fe4: 9026         	str	r0, [sp, #0x98]
;   }
70099fe6: e7ff         	b	0x70099fe8 <_ftoa+0x1a8> @ imm = #-0x2
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
70099fe8: e7ff         	b	0x70099fea <_ftoa+0x1aa> @ imm = #-0x2
70099fea: 9911         	ldr	r1, [sp, #0x44]
70099fec: 2000         	movs	r0, #0x0
70099fee: 291f         	cmp	r1, #0x1f
70099ff0: 9007         	str	r0, [sp, #0x1c]
70099ff2: d807         	bhi	0x7009a004 <_ftoa+0x1c4> @ imm = #0xe
70099ff4: e7ff         	b	0x70099ff6 <_ftoa+0x1b6> @ imm = #-0x2
70099ff6: 9926         	ldr	r1, [sp, #0x98]
70099ff8: 2000         	movs	r0, #0x0
70099ffa: 2909         	cmp	r1, #0x9
70099ffc: bf88         	it	hi
70099ffe: 2001         	movhi	r0, #0x1
7009a000: 9007         	str	r0, [sp, #0x1c]
7009a002: e7ff         	b	0x7009a004 <_ftoa+0x1c4> @ imm = #-0x2
7009a004: 9807         	ldr	r0, [sp, #0x1c]
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009a006: 07c0         	lsls	r0, r0, #0x1f
7009a008: b150         	cbz	r0, 0x7009a020 <_ftoa+0x1e0> @ imm = #0x14
7009a00a: e7ff         	b	0x7009a00c <_ftoa+0x1cc> @ imm = #-0x2
;     buf[len++] = '0';
7009a00c: 9a11         	ldr	r2, [sp, #0x44]
7009a00e: 1c50         	adds	r0, r2, #0x1
7009a010: 9011         	str	r0, [sp, #0x44]
7009a012: a912         	add	r1, sp, #0x48
7009a014: 2030         	movs	r0, #0x30
7009a016: 5488         	strb	r0, [r1, r2]
;     prec--;
7009a018: 9826         	ldr	r0, [sp, #0x98]
7009a01a: 3801         	subs	r0, #0x1
7009a01c: 9026         	str	r0, [sp, #0x98]
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009a01e: e7e4         	b	0x70099fea <_ftoa+0x1aa> @ imm = #-0x38
;   int whole = (int)value;
7009a020: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a024: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009a028: ed8d 0a0c    	vstr	s0, [sp, #48]
;   double tmp = (value - whole) * pow10[prec];
7009a02c: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a030: ed9d 1a0c    	vldr	s2, [sp, #48]
7009a034: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009a038: ee30 0b41    	vsub.f64	d0, d0, d1
7009a03c: 9926         	ldr	r1, [sp, #0x98]
7009a03e: f64f 4078    	movw	r0, #0xfc78
7009a042: f2c7 000a    	movt	r0, #0x700a
7009a046: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009a04a: ed90 1b00    	vldr	d1, [r0]
7009a04e: ee20 0b01    	vmul.f64	d0, d0, d1
7009a052: ed8d 0b0a    	vstr	d0, [sp, #40]
;   unsigned long frac = (unsigned long)tmp;
7009a056: ed9d 0b0a    	vldr	d0, [sp, #40]
7009a05a: eebc 0bc0    	vcvt.u32.f64	s0, d0
7009a05e: ed8d 0a09    	vstr	s0, [sp, #36]
;   diff = tmp - frac;
7009a062: ed9d 0b0a    	vldr	d0, [sp, #40]
7009a066: ed9d 1a09    	vldr	s2, [sp, #36]
7009a06a: eeb8 1b41    	vcvt.f64.u32	d1, s2
7009a06e: ee30 0b41    	vsub.f64	d0, d0, d1
7009a072: ed8d 0b0e    	vstr	d0, [sp, #56]
;   if (diff > 0.5) {
7009a076: ed9d 0b0e    	vldr	d0, [sp, #56]
7009a07a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a07e: eeb4 0b41    	vcmp.f64	d0, d1
7009a082: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a086: dd1e         	ble	0x7009a0c6 <_ftoa+0x286> @ imm = #0x3c
7009a088: e7ff         	b	0x7009a08a <_ftoa+0x24a> @ imm = #-0x2
;     ++frac;
7009a08a: 9809         	ldr	r0, [sp, #0x24]
7009a08c: 3001         	adds	r0, #0x1
7009a08e: 9009         	str	r0, [sp, #0x24]
;     if (frac >= pow10[prec]) {
7009a090: ed9d 0a09    	vldr	s0, [sp, #36]
7009a094: eeb8 0b40    	vcvt.f64.u32	d0, s0
7009a098: 9926         	ldr	r1, [sp, #0x98]
7009a09a: f64f 4078    	movw	r0, #0xfc78
7009a09e: f2c7 000a    	movt	r0, #0x700a
7009a0a2: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009a0a6: ed90 1b00    	vldr	d1, [r0]
7009a0aa: eeb4 0b41    	vcmp.f64	d0, d1
7009a0ae: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a0b2: db07         	blt	0x7009a0c4 <_ftoa+0x284> @ imm = #0xe
7009a0b4: e7ff         	b	0x7009a0b6 <_ftoa+0x276> @ imm = #-0x2
7009a0b6: f04f 0000    	mov.w	r0, #0x0
;       frac = 0;
7009a0ba: 9009         	str	r0, [sp, #0x24]
;       ++whole;
7009a0bc: 980c         	ldr	r0, [sp, #0x30]
7009a0be: 3001         	adds	r0, #0x1
7009a0c0: 900c         	str	r0, [sp, #0x30]
;     }
7009a0c2: e7ff         	b	0x7009a0c4 <_ftoa+0x284> @ imm = #-0x2
;   }
7009a0c4: e018         	b	0x7009a0f8 <_ftoa+0x2b8> @ imm = #0x30
;   else if (diff < 0.5) {
7009a0c6: ed9d 0b0e    	vldr	d0, [sp, #56]
7009a0ca: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a0ce: eeb4 0b41    	vcmp.f64	d0, d1
7009a0d2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a0d6: d501         	bpl	0x7009a0dc <_ftoa+0x29c> @ imm = #0x2
7009a0d8: e7ff         	b	0x7009a0da <_ftoa+0x29a> @ imm = #-0x2
;   }
7009a0da: e00c         	b	0x7009a0f6 <_ftoa+0x2b6> @ imm = #0x18
;   else if ((frac == 0U) || (frac & 1U)) {
7009a0dc: 9809         	ldr	r0, [sp, #0x24]
7009a0de: b128         	cbz	r0, 0x7009a0ec <_ftoa+0x2ac> @ imm = #0xa
7009a0e0: e7ff         	b	0x7009a0e2 <_ftoa+0x2a2> @ imm = #-0x2
7009a0e2: f89d 0024    	ldrb.w	r0, [sp, #0x24]
7009a0e6: 07c0         	lsls	r0, r0, #0x1f
7009a0e8: b120         	cbz	r0, 0x7009a0f4 <_ftoa+0x2b4> @ imm = #0x8
7009a0ea: e7ff         	b	0x7009a0ec <_ftoa+0x2ac> @ imm = #-0x2
;     ++frac;
7009a0ec: 9809         	ldr	r0, [sp, #0x24]
7009a0ee: 3001         	adds	r0, #0x1
7009a0f0: 9009         	str	r0, [sp, #0x24]
;   }
7009a0f2: e7ff         	b	0x7009a0f4 <_ftoa+0x2b4> @ imm = #-0x2
7009a0f4: e7ff         	b	0x7009a0f6 <_ftoa+0x2b6> @ imm = #-0x2
7009a0f6: e7ff         	b	0x7009a0f8 <_ftoa+0x2b8> @ imm = #-0x2
;   if (prec == 0U) {
7009a0f8: 9826         	ldr	r0, [sp, #0x98]
7009a0fa: bb48         	cbnz	r0, 0x7009a150 <_ftoa+0x310> @ imm = #0x52
7009a0fc: e7ff         	b	0x7009a0fe <_ftoa+0x2be> @ imm = #-0x2
;     diff = value - (double)whole;
7009a0fe: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a102: ed9d 1a0c    	vldr	s2, [sp, #48]
7009a106: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009a10a: ee30 0b41    	vsub.f64	d0, d0, d1
7009a10e: ed8d 0b0e    	vstr	d0, [sp, #56]
;     if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
7009a112: ed9d 0b0e    	vldr	d0, [sp, #56]
7009a116: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a11a: eeb4 0b41    	vcmp.f64	d0, d1
7009a11e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a122: d50a         	bpl	0x7009a13a <_ftoa+0x2fa> @ imm = #0x14
7009a124: e7ff         	b	0x7009a126 <_ftoa+0x2e6> @ imm = #-0x2
7009a126: ed9d 0b0e    	vldr	d0, [sp, #56]
7009a12a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a12e: eeb4 0b41    	vcmp.f64	d0, d1
7009a132: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a136: dd0a         	ble	0x7009a14e <_ftoa+0x30e> @ imm = #0x14
7009a138: e7ff         	b	0x7009a13a <_ftoa+0x2fa> @ imm = #-0x2
7009a13a: f89d 0030    	ldrb.w	r0, [sp, #0x30]
7009a13e: ea4f 70c0    	lsl.w	r0, r0, #0x1f
7009a142: b120         	cbz	r0, 0x7009a14e <_ftoa+0x30e> @ imm = #0x8
7009a144: e7ff         	b	0x7009a146 <_ftoa+0x306> @ imm = #-0x2
;       ++whole;
7009a146: 980c         	ldr	r0, [sp, #0x30]
7009a148: 3001         	adds	r0, #0x1
7009a14a: 900c         	str	r0, [sp, #0x30]
;     }
7009a14c: e7ff         	b	0x7009a14e <_ftoa+0x30e> @ imm = #-0x2
;   }
7009a14e: e04d         	b	0x7009a1ec <_ftoa+0x3ac> @ imm = #0x9a
;     unsigned int count = prec;
7009a150: 9826         	ldr	r0, [sp, #0x98]
7009a152: 9008         	str	r0, [sp, #0x20]
;     while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a154: e7ff         	b	0x7009a156 <_ftoa+0x316> @ imm = #-0x2
7009a156: 9811         	ldr	r0, [sp, #0x44]
7009a158: 281f         	cmp	r0, #0x1f
7009a15a: d821         	bhi	0x7009a1a0 <_ftoa+0x360> @ imm = #0x42
7009a15c: e7ff         	b	0x7009a15e <_ftoa+0x31e> @ imm = #-0x2
;       --count;
7009a15e: 9808         	ldr	r0, [sp, #0x20]
7009a160: 3801         	subs	r0, #0x1
7009a162: 9008         	str	r0, [sp, #0x20]
;       buf[len++] = (char)(48U + (frac % 10U));
7009a164: 9809         	ldr	r0, [sp, #0x24]
7009a166: f64c 41cd    	movw	r1, #0xcccd
7009a16a: f6cc 41cc    	movt	r1, #0xcccc
7009a16e: fba0 3201    	umull	r3, r2, r0, r1
7009a172: ea4f 02d2    	lsr.w	r2, r2, #0x3
7009a176: eb02 0282    	add.w	r2, r2, r2, lsl #2
7009a17a: eba0 0042    	sub.w	r0, r0, r2, lsl #1
7009a17e: f040 0030    	orr	r0, r0, #0x30
7009a182: 9b11         	ldr	r3, [sp, #0x44]
7009a184: 1c5a         	adds	r2, r3, #0x1
7009a186: 9211         	str	r2, [sp, #0x44]
7009a188: aa12         	add	r2, sp, #0x48
7009a18a: 54d0         	strb	r0, [r2, r3]
;       if (!(frac /= 10U)) {
7009a18c: 9809         	ldr	r0, [sp, #0x24]
7009a18e: fba0 1001    	umull	r1, r0, r0, r1
7009a192: ea4f 00d0    	lsr.w	r0, r0, #0x3
7009a196: 9009         	str	r0, [sp, #0x24]
7009a198: b908         	cbnz	r0, 0x7009a19e <_ftoa+0x35e> @ imm = #0x2
7009a19a: e7ff         	b	0x7009a19c <_ftoa+0x35c> @ imm = #-0x2
;         break;
7009a19c: e000         	b	0x7009a1a0 <_ftoa+0x360> @ imm = #0x0
;     while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a19e: e7da         	b	0x7009a156 <_ftoa+0x316> @ imm = #-0x4c
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009a1a0: e7ff         	b	0x7009a1a2 <_ftoa+0x362> @ imm = #-0x2
7009a1a2: 9911         	ldr	r1, [sp, #0x44]
7009a1a4: 2000         	movs	r0, #0x0
7009a1a6: 291f         	cmp	r1, #0x1f
7009a1a8: 9006         	str	r0, [sp, #0x18]
7009a1aa: d808         	bhi	0x7009a1be <_ftoa+0x37e> @ imm = #0x10
7009a1ac: e7ff         	b	0x7009a1ae <_ftoa+0x36e> @ imm = #-0x2
7009a1ae: 9808         	ldr	r0, [sp, #0x20]
7009a1b0: 1e41         	subs	r1, r0, #0x1
7009a1b2: 9108         	str	r1, [sp, #0x20]
7009a1b4: 2800         	cmp	r0, #0x0
7009a1b6: bf18         	it	ne
7009a1b8: 2001         	movne	r0, #0x1
7009a1ba: 9006         	str	r0, [sp, #0x18]
7009a1bc: e7ff         	b	0x7009a1be <_ftoa+0x37e> @ imm = #-0x2
7009a1be: 9806         	ldr	r0, [sp, #0x18]
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009a1c0: 07c0         	lsls	r0, r0, #0x1f
7009a1c2: b138         	cbz	r0, 0x7009a1d4 <_ftoa+0x394> @ imm = #0xe
7009a1c4: e7ff         	b	0x7009a1c6 <_ftoa+0x386> @ imm = #-0x2
;       buf[len++] = '0';
7009a1c6: 9a11         	ldr	r2, [sp, #0x44]
7009a1c8: 1c50         	adds	r0, r2, #0x1
7009a1ca: 9011         	str	r0, [sp, #0x44]
7009a1cc: a912         	add	r1, sp, #0x48
7009a1ce: 2030         	movs	r0, #0x30
7009a1d0: 5488         	strb	r0, [r1, r2]
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009a1d2: e7e6         	b	0x7009a1a2 <_ftoa+0x362> @ imm = #-0x34
;     if (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a1d4: 9811         	ldr	r0, [sp, #0x44]
7009a1d6: 281f         	cmp	r0, #0x1f
7009a1d8: d807         	bhi	0x7009a1ea <_ftoa+0x3aa> @ imm = #0xe
7009a1da: e7ff         	b	0x7009a1dc <_ftoa+0x39c> @ imm = #-0x2
;       buf[len++] = '.';
7009a1dc: 9a11         	ldr	r2, [sp, #0x44]
7009a1de: 1c50         	adds	r0, r2, #0x1
7009a1e0: 9011         	str	r0, [sp, #0x44]
7009a1e2: a912         	add	r1, sp, #0x48
7009a1e4: 202e         	movs	r0, #0x2e
7009a1e6: 5488         	strb	r0, [r1, r2]
;     }
7009a1e8: e7ff         	b	0x7009a1ea <_ftoa+0x3aa> @ imm = #-0x2
7009a1ea: e7ff         	b	0x7009a1ec <_ftoa+0x3ac> @ imm = #-0x2
;   while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a1ec: e7ff         	b	0x7009a1ee <_ftoa+0x3ae> @ imm = #-0x2
7009a1ee: 9811         	ldr	r0, [sp, #0x44]
7009a1f0: 281f         	cmp	r0, #0x1f
7009a1f2: d835         	bhi	0x7009a260 <_ftoa+0x420> @ imm = #0x6a
7009a1f4: e014         	b	0x7009a220 <_ftoa+0x3e0> @ imm = #0x28
7009a1f6: bf00         	nop
7009a1f8: ff ff ff ff  	.word	0xffffffff
7009a1fc: ff ff ef ff  	.word	0xffefffff
7009a200: ff ff ff ff  	.word	0xffffffff
7009a204: ff ff ef 7f  	.word	0x7fefffff
7009a208: 00 00 00 00  	.word	0x00000000
7009a20c: 65 cd cd 41  	.word	0x41cdcd65
7009a210: 00 00 00 00  	.word	0x00000000
7009a214: 65 cd cd c1  	.word	0xc1cdcd65
7009a218: 00 00 00 00  	.word	0x00000000
7009a21c: 00 00 00 00  	.word	0x00000000
;     buf[len++] = (char)(48 + (whole % 10));
7009a220: 980c         	ldr	r0, [sp, #0x30]
7009a222: f246 6167    	movw	r1, #0x6667
7009a226: f2c6 6166    	movt	r1, #0x6666
7009a22a: fb50 f301    	smmul	r3, r0, r1
7009a22e: 089a         	lsrs	r2, r3, #0x2
7009a230: eb02 72d3    	add.w	r2, r2, r3, lsr #31
7009a234: eb02 0282    	add.w	r2, r2, r2, lsl #2
7009a238: eba0 0042    	sub.w	r0, r0, r2, lsl #1
7009a23c: 3030         	adds	r0, #0x30
7009a23e: 9b11         	ldr	r3, [sp, #0x44]
7009a240: 1c5a         	adds	r2, r3, #0x1
7009a242: 9211         	str	r2, [sp, #0x44]
7009a244: aa12         	add	r2, sp, #0x48
7009a246: 54d0         	strb	r0, [r2, r3]
;     if (!(whole /= 10)) {
7009a248: 980c         	ldr	r0, [sp, #0x30]
7009a24a: fb50 f101    	smmul	r1, r0, r1
7009a24e: ea4f 00a1    	asr.w	r0, r1, #0x2
7009a252: eb00 70d1    	add.w	r0, r0, r1, lsr #31
7009a256: 900c         	str	r0, [sp, #0x30]
7009a258: b908         	cbnz	r0, 0x7009a25e <_ftoa+0x41e> @ imm = #0x2
7009a25a: e7ff         	b	0x7009a25c <_ftoa+0x41c> @ imm = #-0x2
;       break;
7009a25c: e000         	b	0x7009a260 <_ftoa+0x420> @ imm = #0x0
;   while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a25e: e7c6         	b	0x7009a1ee <_ftoa+0x3ae> @ imm = #-0x74
;   if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
7009a260: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a264: 0780         	lsls	r0, r0, #0x1e
7009a266: 2800         	cmp	r0, #0x0
7009a268: d432         	bmi	0x7009a2d0 <_ftoa+0x490> @ imm = #0x64
7009a26a: e7ff         	b	0x7009a26c <_ftoa+0x42c> @ imm = #-0x2
7009a26c: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a270: 07c0         	lsls	r0, r0, #0x1f
7009a272: b368         	cbz	r0, 0x7009a2d0 <_ftoa+0x490> @ imm = #0x5a
7009a274: e7ff         	b	0x7009a276 <_ftoa+0x436> @ imm = #-0x2
;     if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
7009a276: 9827         	ldr	r0, [sp, #0x9c]
7009a278: b178         	cbz	r0, 0x7009a29a <_ftoa+0x45a> @ imm = #0x1e
7009a27a: e7ff         	b	0x7009a27c <_ftoa+0x43c> @ imm = #-0x2
7009a27c: f89d 0037    	ldrb.w	r0, [sp, #0x37]
7009a280: 07c0         	lsls	r0, r0, #0x1f
7009a282: b930         	cbnz	r0, 0x7009a292 <_ftoa+0x452> @ imm = #0xc
7009a284: e7ff         	b	0x7009a286 <_ftoa+0x446> @ imm = #-0x2
7009a286: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a28a: f010 0f0c    	tst.w	r0, #0xc
7009a28e: d004         	beq	0x7009a29a <_ftoa+0x45a> @ imm = #0x8
7009a290: e7ff         	b	0x7009a292 <_ftoa+0x452> @ imm = #-0x2
;       width--;
7009a292: 9827         	ldr	r0, [sp, #0x9c]
7009a294: 3801         	subs	r0, #0x1
7009a296: 9027         	str	r0, [sp, #0x9c]
;     }
7009a298: e7ff         	b	0x7009a29a <_ftoa+0x45a> @ imm = #-0x2
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009a29a: e7ff         	b	0x7009a29c <_ftoa+0x45c> @ imm = #-0x2
7009a29c: 9911         	ldr	r1, [sp, #0x44]
7009a29e: 9a27         	ldr	r2, [sp, #0x9c]
7009a2a0: 2000         	movs	r0, #0x0
7009a2a2: 4291         	cmp	r1, r2
7009a2a4: 9005         	str	r0, [sp, #0x14]
7009a2a6: d207         	bhs	0x7009a2b8 <_ftoa+0x478> @ imm = #0xe
7009a2a8: e7ff         	b	0x7009a2aa <_ftoa+0x46a> @ imm = #-0x2
7009a2aa: 9911         	ldr	r1, [sp, #0x44]
7009a2ac: 2000         	movs	r0, #0x0
7009a2ae: 2920         	cmp	r1, #0x20
7009a2b0: bf38         	it	lo
7009a2b2: 2001         	movlo	r0, #0x1
7009a2b4: 9005         	str	r0, [sp, #0x14]
7009a2b6: e7ff         	b	0x7009a2b8 <_ftoa+0x478> @ imm = #-0x2
7009a2b8: 9805         	ldr	r0, [sp, #0x14]
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009a2ba: 07c0         	lsls	r0, r0, #0x1f
7009a2bc: b138         	cbz	r0, 0x7009a2ce <_ftoa+0x48e> @ imm = #0xe
7009a2be: e7ff         	b	0x7009a2c0 <_ftoa+0x480> @ imm = #-0x2
;       buf[len++] = '0';
7009a2c0: 9a11         	ldr	r2, [sp, #0x44]
7009a2c2: 1c50         	adds	r0, r2, #0x1
7009a2c4: 9011         	str	r0, [sp, #0x44]
7009a2c6: a912         	add	r1, sp, #0x48
7009a2c8: 2030         	movs	r0, #0x30
7009a2ca: 5488         	strb	r0, [r1, r2]
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009a2cc: e7e6         	b	0x7009a29c <_ftoa+0x45c> @ imm = #-0x34
;   }
7009a2ce: e7ff         	b	0x7009a2d0 <_ftoa+0x490> @ imm = #-0x2
;   if (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a2d0: 9811         	ldr	r0, [sp, #0x44]
7009a2d2: 281f         	cmp	r0, #0x1f
7009a2d4: d829         	bhi	0x7009a32a <_ftoa+0x4ea> @ imm = #0x52
7009a2d6: e7ff         	b	0x7009a2d8 <_ftoa+0x498> @ imm = #-0x2
;     if (negative) {
7009a2d8: f89d 0037    	ldrb.w	r0, [sp, #0x37]
7009a2dc: 07c0         	lsls	r0, r0, #0x1f
7009a2de: b138         	cbz	r0, 0x7009a2f0 <_ftoa+0x4b0> @ imm = #0xe
7009a2e0: e7ff         	b	0x7009a2e2 <_ftoa+0x4a2> @ imm = #-0x2
;       buf[len++] = '-';
7009a2e2: 9a11         	ldr	r2, [sp, #0x44]
7009a2e4: 1c50         	adds	r0, r2, #0x1
7009a2e6: 9011         	str	r0, [sp, #0x44]
7009a2e8: a912         	add	r1, sp, #0x48
7009a2ea: 202d         	movs	r0, #0x2d
7009a2ec: 5488         	strb	r0, [r1, r2]
;     }
7009a2ee: e01b         	b	0x7009a328 <_ftoa+0x4e8> @ imm = #0x36
;     else if (flags & FLAGS_PLUS) {
7009a2f0: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a2f4: 0740         	lsls	r0, r0, #0x1d
7009a2f6: 2800         	cmp	r0, #0x0
7009a2f8: d507         	bpl	0x7009a30a <_ftoa+0x4ca> @ imm = #0xe
7009a2fa: e7ff         	b	0x7009a2fc <_ftoa+0x4bc> @ imm = #-0x2
;       buf[len++] = '+';  // ignore the space if the '+' exists
7009a2fc: 9a11         	ldr	r2, [sp, #0x44]
7009a2fe: 1c50         	adds	r0, r2, #0x1
7009a300: 9011         	str	r0, [sp, #0x44]
7009a302: a912         	add	r1, sp, #0x48
7009a304: 202b         	movs	r0, #0x2b
7009a306: 5488         	strb	r0, [r1, r2]
;     }
7009a308: e00d         	b	0x7009a326 <_ftoa+0x4e6> @ imm = #0x1a
;     else if (flags & FLAGS_SPACE) {
7009a30a: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a30e: 0700         	lsls	r0, r0, #0x1c
7009a310: 2800         	cmp	r0, #0x0
7009a312: d507         	bpl	0x7009a324 <_ftoa+0x4e4> @ imm = #0xe
7009a314: e7ff         	b	0x7009a316 <_ftoa+0x4d6> @ imm = #-0x2
;       buf[len++] = ' ';
7009a316: 9a11         	ldr	r2, [sp, #0x44]
7009a318: 1c50         	adds	r0, r2, #0x1
7009a31a: 9011         	str	r0, [sp, #0x44]
7009a31c: a912         	add	r1, sp, #0x48
7009a31e: 2020         	movs	r0, #0x20
7009a320: 5488         	strb	r0, [r1, r2]
;     }
7009a322: e7ff         	b	0x7009a324 <_ftoa+0x4e4> @ imm = #-0x2
7009a324: e7ff         	b	0x7009a326 <_ftoa+0x4e6> @ imm = #-0x2
7009a326: e7ff         	b	0x7009a328 <_ftoa+0x4e8> @ imm = #-0x2
;   }
7009a328: e7ff         	b	0x7009a32a <_ftoa+0x4ea> @ imm = #-0x2
;   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
7009a32a: 9820         	ldr	r0, [sp, #0x80]
7009a32c: 991f         	ldr	r1, [sp, #0x7c]
7009a32e: 9a1e         	ldr	r2, [sp, #0x78]
7009a330: 9b1d         	ldr	r3, [sp, #0x74]
7009a332: f8dd c044    	ldr.w	r12, [sp, #0x44]
7009a336: 9c27         	ldr	r4, [sp, #0x9c]
7009a338: 9d28         	ldr	r5, [sp, #0xa0]
7009a33a: 46ee         	mov	lr, sp
7009a33c: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a340: f8ce 4008    	str.w	r4, [lr, #0x8]
7009a344: f8ce c004    	str.w	r12, [lr, #0x4]
7009a348: f10d 0c48    	add.w	r12, sp, #0x48
7009a34c: f8ce c000    	str.w	r12, [lr]
7009a350: f00b fb8e    	bl	0x700a5a70 <_out_rev>   @ imm = #0xb71c
7009a354: 9021         	str	r0, [sp, #0x84]
7009a356: e7ff         	b	0x7009a358 <_ftoa+0x518> @ imm = #-0x2
; }
7009a358: 9821         	ldr	r0, [sp, #0x84]
7009a35a: b022         	add	sp, #0x88
7009a35c: bd70         	pop	{r4, r5, r6, pc}
7009a35e: 0000         	movs	r0, r0

7009a360 <_etoa>:
; {
7009a360: b570         	push	{r4, r5, r6, lr}
7009a362: b0a8         	sub	sp, #0xa0
7009a364: f8dd c0b8    	ldr.w	r12, [sp, #0xb8]
7009a368: f8dd c0b4    	ldr.w	r12, [sp, #0xb4]
7009a36c: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009a370: 9026         	str	r0, [sp, #0x98]
7009a372: 9125         	str	r1, [sp, #0x94]
7009a374: 9224         	str	r2, [sp, #0x90]
7009a376: 9323         	str	r3, [sp, #0x8c]
7009a378: ed8d 0b20    	vstr	d0, [sp, #128]
;   if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
7009a37c: ed9d 0b20    	vldr	d0, [sp, #128]
7009a380: eeb4 0b40    	vcmp.f64	d0, d0
7009a384: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a388: d614         	bvs	0x7009a3b4 <_etoa+0x54> @ imm = #0x28
7009a38a: e7ff         	b	0x7009a38c <_etoa+0x2c> @ imm = #-0x2
7009a38c: ed9d 0b20    	vldr	d0, [sp, #128]
7009a390: ed9f 1bdb    	vldr	d1, [pc, #876]          @ 0x7009a700 <_etoa+0x3a0>
7009a394: eeb4 0b41    	vcmp.f64	d0, d1
7009a398: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a39c: dc0a         	bgt	0x7009a3b4 <_etoa+0x54> @ imm = #0x14
7009a39e: e7ff         	b	0x7009a3a0 <_etoa+0x40> @ imm = #-0x2
7009a3a0: ed9d 0b20    	vldr	d0, [sp, #128]
7009a3a4: ed9f 1bd8    	vldr	d1, [pc, #864]          @ 0x7009a708 <_etoa+0x3a8>
7009a3a8: eeb4 0b41    	vcmp.f64	d0, d1
7009a3ac: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a3b0: d515         	bpl	0x7009a3de <_etoa+0x7e> @ imm = #0x2a
7009a3b2: e7ff         	b	0x7009a3b4 <_etoa+0x54> @ imm = #-0x2
;     return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
7009a3b4: 9826         	ldr	r0, [sp, #0x98]
7009a3b6: 9925         	ldr	r1, [sp, #0x94]
7009a3b8: 9a24         	ldr	r2, [sp, #0x90]
7009a3ba: 9b23         	ldr	r3, [sp, #0x8c]
7009a3bc: ed9d 0b20    	vldr	d0, [sp, #128]
7009a3c0: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009a3c4: 9c2d         	ldr	r4, [sp, #0xb4]
7009a3c6: 9d2e         	ldr	r5, [sp, #0xb8]
7009a3c8: 46ee         	mov	lr, sp
7009a3ca: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a3ce: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a3d2: f8ce c000    	str.w	r12, [lr]
7009a3d6: f7ff fd33    	bl	0x70099e40 <_ftoa>      @ imm = #-0x59a
7009a3da: 9027         	str	r0, [sp, #0x9c]
7009a3dc: e1d8         	b	0x7009a790 <_etoa+0x430> @ imm = #0x3b0
;   const bool negative = value < 0;
7009a3de: ed9d 0b20    	vldr	d0, [sp, #128]
7009a3e2: f04f 0000    	mov.w	r0, #0x0
7009a3e6: eeb5 0b40    	vcmp.f64	d0, #0
7009a3ea: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a3ee: bf48         	it	mi
7009a3f0: 2001         	movmi	r0, #0x1
7009a3f2: f88d 007f    	strb.w	r0, [sp, #0x7f]
;   if (negative) {
7009a3f6: f89d 007f    	ldrb.w	r0, [sp, #0x7f]
7009a3fa: ea4f 70c0    	lsl.w	r0, r0, #0x1f
7009a3fe: b138         	cbz	r0, 0x7009a410 <_etoa+0xb0> @ imm = #0xe
7009a400: e7ff         	b	0x7009a402 <_etoa+0xa2> @ imm = #-0x2
;     value = -value;
7009a402: ed9d 0b20    	vldr	d0, [sp, #128]
7009a406: eeb1 0b40    	vneg.f64	d0, d0
7009a40a: ed8d 0b20    	vstr	d0, [sp, #128]
;   }
7009a40e: e7ff         	b	0x7009a410 <_etoa+0xb0> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION)) {
7009a410: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009a414: 0740         	lsls	r0, r0, #0x1d
7009a416: 2800         	cmp	r0, #0x0
7009a418: d403         	bmi	0x7009a422 <_etoa+0xc2> @ imm = #0x6
7009a41a: e7ff         	b	0x7009a41c <_etoa+0xbc> @ imm = #-0x2
7009a41c: 2006         	movs	r0, #0x6
;     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
7009a41e: 902c         	str	r0, [sp, #0xb0]
;   }
7009a420: e7ff         	b	0x7009a422 <_etoa+0xc2> @ imm = #-0x2
;   conv.F = value;
7009a422: ed9d 0b20    	vldr	d0, [sp, #128]
7009a426: ed8d 0b1c    	vstr	d0, [sp, #112]
;   int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
7009a42a: 981d         	ldr	r0, [sp, #0x74]
7009a42c: f3c0 500a    	ubfx	r0, r0, #0x14, #0xb
7009a430: f2a0 30ff    	subw	r0, r0, #0x3ff
7009a434: 901b         	str	r0, [sp, #0x6c]
;   conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
7009a436: 981d         	ldr	r0, [sp, #0x74]
7009a438: f240 31ff    	movw	r1, #0x3ff
7009a43c: f361 501f    	bfi	r0, r1, #20, #12
7009a440: 901d         	str	r0, [sp, #0x74]
;   int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
7009a442: ed9d 0a1b    	vldr	s0, [sp, #108]
7009a446: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009a44a: ed9f 1bd3    	vldr	d1, [pc, #844]          @ 0x7009a798 <_etoa+0x438>
7009a44e: ee20 0b01    	vmul.f64	d0, d0, d1
7009a452: ed9f 1bd3    	vldr	d1, [pc, #844]          @ 0x7009a7a0 <_etoa+0x440>
7009a456: ee30 1b01    	vadd.f64	d1, d0, d1
7009a45a: ed9d 0b1c    	vldr	d0, [sp, #112]
7009a45e: eebf 2b08    	vmov.f64	d2, #-1.500000e+00
7009a462: ee30 0b02    	vadd.f64	d0, d0, d2
7009a466: ed9f 2bd0    	vldr	d2, [pc, #832]          @ 0x7009a7a8 <_etoa+0x448>
7009a46a: ee20 0b02    	vmul.f64	d0, d0, d2
7009a46e: ee30 0b01    	vadd.f64	d0, d0, d1
7009a472: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009a476: ed8d 0a1a    	vstr	s0, [sp, #104]
;   exp2 = (int)(expval * 3.321928094887362 + 0.5);
7009a47a: ed9d 0a1a    	vldr	s0, [sp, #104]
7009a47e: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009a482: ed9f 1bcb    	vldr	d1, [pc, #812]          @ 0x7009a7b0 <_etoa+0x450>
7009a486: ee20 0b01    	vmul.f64	d0, d0, d1
7009a48a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a48e: ee30 0b01    	vadd.f64	d0, d0, d1
7009a492: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009a496: ed8d 0a1b    	vstr	s0, [sp, #108]
;   const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
7009a49a: ed9d 0a1a    	vldr	s0, [sp, #104]
7009a49e: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009a4a2: ed9d 1a1b    	vldr	s2, [sp, #108]
7009a4a6: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009a4aa: ed9f 2bc3    	vldr	d2, [pc, #780]          @ 0x7009a7b8 <_etoa+0x458>
7009a4ae: ee21 1b02    	vmul.f64	d1, d1, d2
7009a4b2: ed9f 2bc3    	vldr	d2, [pc, #780]          @ 0x7009a7c0 <_etoa+0x460>
7009a4b6: ee20 0b02    	vmul.f64	d0, d0, d2
7009a4ba: ee30 0b01    	vadd.f64	d0, d0, d1
7009a4be: ed8d 0b18    	vstr	d0, [sp, #96]
;   const double z2 = z * z;
7009a4c2: ed9d 0b18    	vldr	d0, [sp, #96]
7009a4c6: ee20 0b00    	vmul.f64	d0, d0, d0
7009a4ca: ed8d 0b16    	vstr	d0, [sp, #88]
;   conv.U = (uint64_t)(exp2 + 1023) << 52U;
7009a4ce: 981b         	ldr	r0, [sp, #0x6c]
7009a4d0: f200 30ff    	addw	r0, r0, #0x3ff
7009a4d4: 0500         	lsls	r0, r0, #0x14
7009a4d6: 2100         	movs	r1, #0x0
7009a4d8: 911c         	str	r1, [sp, #0x70]
7009a4da: 901d         	str	r0, [sp, #0x74]
;   conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
7009a4dc: ed9d 2b18    	vldr	d2, [sp, #96]
7009a4e0: ee32 0b02    	vadd.f64	d0, d2, d2
7009a4e4: eeb0 1b00    	vmov.f64	d1, #2.000000e+00
7009a4e8: ee31 1b42    	vsub.f64	d1, d1, d2
7009a4ec: ed9d 2b16    	vldr	d2, [sp, #88]
7009a4f0: eeb2 3b0c    	vmov.f64	d3, #1.400000e+01
7009a4f4: ee82 3b03    	vdiv.f64	d3, d2, d3
7009a4f8: eeb2 4b04    	vmov.f64	d4, #1.000000e+01
7009a4fc: ee33 3b04    	vadd.f64	d3, d3, d4
7009a500: ee82 3b03    	vdiv.f64	d3, d2, d3
7009a504: eeb1 4b08    	vmov.f64	d4, #6.000000e+00
7009a508: ee33 3b04    	vadd.f64	d3, d3, d4
7009a50c: ee82 2b03    	vdiv.f64	d2, d2, d3
7009a510: ee31 1b02    	vadd.f64	d1, d1, d2
7009a514: ee80 0b01    	vdiv.f64	d0, d0, d1
7009a518: eeb7 1b00    	vmov.f64	d1, #1.000000e+00
7009a51c: ee30 1b01    	vadd.f64	d1, d0, d1
7009a520: ed9d 0b1c    	vldr	d0, [sp, #112]
7009a524: ee20 0b01    	vmul.f64	d0, d0, d1
7009a528: ed8d 0b1c    	vstr	d0, [sp, #112]
;   if (value < conv.F) {
7009a52c: ed9d 0b20    	vldr	d0, [sp, #128]
7009a530: ed9d 1b1c    	vldr	d1, [sp, #112]
7009a534: eeb4 0b41    	vcmp.f64	d0, d1
7009a538: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a53c: d50c         	bpl	0x7009a558 <_etoa+0x1f8> @ imm = #0x18
7009a53e: e7ff         	b	0x7009a540 <_etoa+0x1e0> @ imm = #-0x2
;     expval--;
7009a540: 981a         	ldr	r0, [sp, #0x68]
7009a542: 3801         	subs	r0, #0x1
7009a544: 901a         	str	r0, [sp, #0x68]
;     conv.F /= 10;
7009a546: ed9d 0b1c    	vldr	d0, [sp, #112]
7009a54a: eeb2 1b04    	vmov.f64	d1, #1.000000e+01
7009a54e: ee80 0b01    	vdiv.f64	d0, d0, d1
7009a552: ed8d 0b1c    	vstr	d0, [sp, #112]
;   }
7009a556: e7ff         	b	0x7009a558 <_etoa+0x1f8> @ imm = #-0x2
;   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
7009a558: 991a         	ldr	r1, [sp, #0x68]
7009a55a: f04f 0000    	mov.w	r0, #0x0
7009a55e: 2963         	cmp	r1, #0x63
7009a560: 9012         	str	r0, [sp, #0x48]
7009a562: dc08         	bgt	0x7009a576 <_etoa+0x216> @ imm = #0x10
7009a564: e7ff         	b	0x7009a566 <_etoa+0x206> @ imm = #-0x2
7009a566: 991a         	ldr	r1, [sp, #0x68]
7009a568: 2000         	movs	r0, #0x0
7009a56a: f111 0f64    	cmn.w	r1, #0x64
7009a56e: bfc8         	it	gt
7009a570: 2001         	movgt	r0, #0x1
7009a572: 9012         	str	r0, [sp, #0x48]
7009a574: e7ff         	b	0x7009a576 <_etoa+0x216> @ imm = #-0x2
7009a576: 9812         	ldr	r0, [sp, #0x48]
;   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
7009a578: 07c1         	lsls	r1, r0, #0x1f
7009a57a: 2005         	movs	r0, #0x5
7009a57c: 2900         	cmp	r1, #0x0
7009a57e: bf18         	it	ne
7009a580: 2004         	movne	r0, #0x4
7009a582: 9015         	str	r0, [sp, #0x54]
;   if (flags & FLAGS_ADAPT_EXP) {
7009a584: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009a588: ea4f 7000    	lsl.w	r0, r0, #0x1c
7009a58c: 2800         	cmp	r0, #0x0
7009a58e: d539         	bpl	0x7009a604 <_etoa+0x2a4> @ imm = #0x72
7009a590: e7ff         	b	0x7009a592 <_etoa+0x232> @ imm = #-0x2
;     if ((value >= 1e-4) && (value < 1e6)) {
7009a592: ed9d 0b20    	vldr	d0, [sp, #128]
7009a596: ed9f 1b8c    	vldr	d1, [pc, #560]          @ 0x7009a7c8 <_etoa+0x468>
7009a59a: eeb4 0b41    	vcmp.f64	d0, d1
7009a59e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a5a2: db20         	blt	0x7009a5e6 <_etoa+0x286> @ imm = #0x40
7009a5a4: e7ff         	b	0x7009a5a6 <_etoa+0x246> @ imm = #-0x2
7009a5a6: ed9d 0b20    	vldr	d0, [sp, #128]
7009a5aa: ed9f 1b89    	vldr	d1, [pc, #548]          @ 0x7009a7d0 <_etoa+0x470>
7009a5ae: eeb4 0b41    	vcmp.f64	d0, d1
7009a5b2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a5b6: d516         	bpl	0x7009a5e6 <_etoa+0x286> @ imm = #0x2c
7009a5b8: e7ff         	b	0x7009a5ba <_etoa+0x25a> @ imm = #-0x2
;       if ((int)prec > expval) {
7009a5ba: 982c         	ldr	r0, [sp, #0xb0]
7009a5bc: 991a         	ldr	r1, [sp, #0x68]
7009a5be: 4288         	cmp	r0, r1
7009a5c0: dd06         	ble	0x7009a5d0 <_etoa+0x270> @ imm = #0xc
7009a5c2: e7ff         	b	0x7009a5c4 <_etoa+0x264> @ imm = #-0x2
;         prec = (unsigned)((int)prec - expval - 1);
7009a5c4: 992c         	ldr	r1, [sp, #0xb0]
7009a5c6: 981a         	ldr	r0, [sp, #0x68]
7009a5c8: 43c0         	mvns	r0, r0
7009a5ca: 4408         	add	r0, r1
7009a5cc: 902c         	str	r0, [sp, #0xb0]
;       }
7009a5ce: e002         	b	0x7009a5d6 <_etoa+0x276> @ imm = #0x4
7009a5d0: 2000         	movs	r0, #0x0
;         prec = 0;
7009a5d2: 902c         	str	r0, [sp, #0xb0]
7009a5d4: e7ff         	b	0x7009a5d6 <_etoa+0x276> @ imm = #-0x2
;       flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
7009a5d6: 982e         	ldr	r0, [sp, #0xb8]
7009a5d8: f440 6080    	orr	r0, r0, #0x400
7009a5dc: 902e         	str	r0, [sp, #0xb8]
7009a5de: 2000         	movs	r0, #0x0
;       minwidth = 0U;
7009a5e0: 9015         	str	r0, [sp, #0x54]
;       expval   = 0;
7009a5e2: 901a         	str	r0, [sp, #0x68]
;     }
7009a5e4: e00d         	b	0x7009a602 <_etoa+0x2a2> @ imm = #0x1a
;       if ((prec > 0) && (flags & FLAGS_PRECISION)) {
7009a5e6: 982c         	ldr	r0, [sp, #0xb0]
7009a5e8: b150         	cbz	r0, 0x7009a600 <_etoa+0x2a0> @ imm = #0x14
7009a5ea: e7ff         	b	0x7009a5ec <_etoa+0x28c> @ imm = #-0x2
7009a5ec: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009a5f0: 0740         	lsls	r0, r0, #0x1d
7009a5f2: 2800         	cmp	r0, #0x0
7009a5f4: d504         	bpl	0x7009a600 <_etoa+0x2a0> @ imm = #0x8
7009a5f6: e7ff         	b	0x7009a5f8 <_etoa+0x298> @ imm = #-0x2
;         --prec;
7009a5f8: 982c         	ldr	r0, [sp, #0xb0]
7009a5fa: 3801         	subs	r0, #0x1
7009a5fc: 902c         	str	r0, [sp, #0xb0]
;       }
7009a5fe: e7ff         	b	0x7009a600 <_etoa+0x2a0> @ imm = #-0x2
7009a600: e7ff         	b	0x7009a602 <_etoa+0x2a2> @ imm = #-0x2
;   }
7009a602: e7ff         	b	0x7009a604 <_etoa+0x2a4> @ imm = #-0x2
;   unsigned int fwidth = width;
7009a604: 982d         	ldr	r0, [sp, #0xb4]
7009a606: 9014         	str	r0, [sp, #0x50]
;   if (width > minwidth) {
7009a608: 982d         	ldr	r0, [sp, #0xb4]
7009a60a: 9915         	ldr	r1, [sp, #0x54]
7009a60c: 4288         	cmp	r0, r1
7009a60e: d905         	bls	0x7009a61c <_etoa+0x2bc> @ imm = #0xa
7009a610: e7ff         	b	0x7009a612 <_etoa+0x2b2> @ imm = #-0x2
;     fwidth -= minwidth;
7009a612: 9915         	ldr	r1, [sp, #0x54]
7009a614: 9814         	ldr	r0, [sp, #0x50]
7009a616: 1a40         	subs	r0, r0, r1
7009a618: 9014         	str	r0, [sp, #0x50]
;   } else {
7009a61a: e002         	b	0x7009a622 <_etoa+0x2c2> @ imm = #0x4
7009a61c: 2000         	movs	r0, #0x0
;     fwidth = 0U;
7009a61e: 9014         	str	r0, [sp, #0x50]
7009a620: e7ff         	b	0x7009a622 <_etoa+0x2c2> @ imm = #-0x2
;   if ((flags & FLAGS_LEFT) && minwidth) {
7009a622: f89d 00b8    	ldrb.w	r0, [sp, #0xb8]
7009a626: 0780         	lsls	r0, r0, #0x1e
7009a628: 2800         	cmp	r0, #0x0
7009a62a: d506         	bpl	0x7009a63a <_etoa+0x2da> @ imm = #0xc
7009a62c: e7ff         	b	0x7009a62e <_etoa+0x2ce> @ imm = #-0x2
7009a62e: 9815         	ldr	r0, [sp, #0x54]
7009a630: b118         	cbz	r0, 0x7009a63a <_etoa+0x2da> @ imm = #0x6
7009a632: e7ff         	b	0x7009a634 <_etoa+0x2d4> @ imm = #-0x2
7009a634: 2000         	movs	r0, #0x0
;     fwidth = 0U;
7009a636: 9014         	str	r0, [sp, #0x50]
;   }
7009a638: e7ff         	b	0x7009a63a <_etoa+0x2da> @ imm = #-0x2
;   if (expval) {
7009a63a: 981a         	ldr	r0, [sp, #0x68]
7009a63c: b148         	cbz	r0, 0x7009a652 <_etoa+0x2f2> @ imm = #0x12
7009a63e: e7ff         	b	0x7009a640 <_etoa+0x2e0> @ imm = #-0x2
;     value /= conv.F;
7009a640: ed9d 1b1c    	vldr	d1, [sp, #112]
7009a644: ed9d 0b20    	vldr	d0, [sp, #128]
7009a648: ee80 0b01    	vdiv.f64	d0, d0, d1
7009a64c: ed8d 0b20    	vstr	d0, [sp, #128]
;   }
7009a650: e7ff         	b	0x7009a652 <_etoa+0x2f2> @ imm = #-0x2
;   const size_t start_idx = idx;
7009a652: 9824         	ldr	r0, [sp, #0x90]
7009a654: 9013         	str	r0, [sp, #0x4c]
;   idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
7009a656: 9826         	ldr	r0, [sp, #0x98]
7009a658: 900e         	str	r0, [sp, #0x38]
7009a65a: 9825         	ldr	r0, [sp, #0x94]
7009a65c: 900f         	str	r0, [sp, #0x3c]
7009a65e: 9824         	ldr	r0, [sp, #0x90]
7009a660: 9010         	str	r0, [sp, #0x40]
7009a662: 9823         	ldr	r0, [sp, #0x8c]
7009a664: 9011         	str	r0, [sp, #0x44]
7009a666: f89d 007f    	ldrb.w	r0, [sp, #0x7f]
7009a66a: 07c0         	lsls	r0, r0, #0x1f
7009a66c: b138         	cbz	r0, 0x7009a67e <_etoa+0x31e> @ imm = #0xe
7009a66e: e7ff         	b	0x7009a670 <_etoa+0x310> @ imm = #-0x2
7009a670: ed9d 0b20    	vldr	d0, [sp, #128]
7009a674: eeb1 0b40    	vneg.f64	d0, d0
7009a678: ed8d 0b0c    	vstr	d0, [sp, #48]
7009a67c: e004         	b	0x7009a688 <_etoa+0x328> @ imm = #0x8
7009a67e: ed9d 0b20    	vldr	d0, [sp, #128]
7009a682: ed8d 0b0c    	vstr	d0, [sp, #48]
7009a686: e7ff         	b	0x7009a688 <_etoa+0x328> @ imm = #-0x2
7009a688: 9b11         	ldr	r3, [sp, #0x44]
7009a68a: 9a10         	ldr	r2, [sp, #0x40]
7009a68c: 990f         	ldr	r1, [sp, #0x3c]
7009a68e: 980e         	ldr	r0, [sp, #0x38]
7009a690: ed9d 0b0c    	vldr	d0, [sp, #48]
7009a694: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009a698: 9c14         	ldr	r4, [sp, #0x50]
7009a69a: f8dd e0b8    	ldr.w	lr, [sp, #0xb8]
7009a69e: f42e 6500    	bic	r5, lr, #0x800
7009a6a2: 46ee         	mov	lr, sp
7009a6a4: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a6a8: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a6ac: f8ce c000    	str.w	r12, [lr]
7009a6b0: f7ff fbc6    	bl	0x70099e40 <_ftoa>      @ imm = #-0x874
7009a6b4: 9024         	str	r0, [sp, #0x90]
;   if (minwidth) {
7009a6b6: 9815         	ldr	r0, [sp, #0x54]
7009a6b8: 2800         	cmp	r0, #0x0
7009a6ba: d066         	beq	0x7009a78a <_etoa+0x42a> @ imm = #0xcc
7009a6bc: e7ff         	b	0x7009a6be <_etoa+0x35e> @ imm = #-0x2
;     out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
7009a6be: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009a6c2: 982e         	ldr	r0, [sp, #0xb8]
7009a6c4: 0681         	lsls	r1, r0, #0x1a
7009a6c6: 2065         	movs	r0, #0x65
7009a6c8: 2900         	cmp	r1, #0x0
7009a6ca: bf48         	it	mi
7009a6cc: 2045         	movmi	r0, #0x45
7009a6ce: 9925         	ldr	r1, [sp, #0x94]
7009a6d0: 9a24         	ldr	r2, [sp, #0x90]
7009a6d2: 1c53         	adds	r3, r2, #0x1
7009a6d4: 9324         	str	r3, [sp, #0x90]
7009a6d6: 9b23         	ldr	r3, [sp, #0x8c]
7009a6d8: 47e0         	blx	r12
;     idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
7009a6da: 9826         	ldr	r0, [sp, #0x98]
7009a6dc: 9008         	str	r0, [sp, #0x20]
7009a6de: 9825         	ldr	r0, [sp, #0x94]
7009a6e0: 9009         	str	r0, [sp, #0x24]
7009a6e2: 9824         	ldr	r0, [sp, #0x90]
7009a6e4: 900a         	str	r0, [sp, #0x28]
7009a6e6: 9823         	ldr	r0, [sp, #0x8c]
7009a6e8: 900b         	str	r0, [sp, #0x2c]
7009a6ea: 981a         	ldr	r0, [sp, #0x68]
7009a6ec: f1b0 3fff    	cmp.w	r0, #0xffffffff
7009a6f0: dc0e         	bgt	0x7009a710 <_etoa+0x3b0> @ imm = #0x1c
7009a6f2: e7ff         	b	0x7009a6f4 <_etoa+0x394> @ imm = #-0x2
7009a6f4: 981a         	ldr	r0, [sp, #0x68]
7009a6f6: 4240         	rsbs	r0, r0, #0
7009a6f8: 9007         	str	r0, [sp, #0x1c]
7009a6fa: e00c         	b	0x7009a716 <_etoa+0x3b6> @ imm = #0x18
7009a6fc: bf00         	nop
7009a6fe: bf00         	nop
7009a700: ff ff ff ff  	.word	0xffffffff
7009a704: ff ff ef 7f  	.word	0x7fefffff
7009a708: ff ff ff ff  	.word	0xffffffff
7009a70c: ff ff ef ff  	.word	0xffefffff
7009a710: 981a         	ldr	r0, [sp, #0x68]
7009a712: 9007         	str	r0, [sp, #0x1c]
7009a714: e7ff         	b	0x7009a716 <_etoa+0x3b6> @ imm = #-0x2
7009a716: 9b0b         	ldr	r3, [sp, #0x2c]
7009a718: 9a0a         	ldr	r2, [sp, #0x28]
7009a71a: 9909         	ldr	r1, [sp, #0x24]
7009a71c: 9808         	ldr	r0, [sp, #0x20]
7009a71e: f8dd c01c    	ldr.w	r12, [sp, #0x1c]
7009a722: 9c1a         	ldr	r4, [sp, #0x68]
7009a724: f8dd e054    	ldr.w	lr, [sp, #0x54]
7009a728: f1ae 0501    	sub.w	r5, lr, #0x1
7009a72c: 46ee         	mov	lr, sp
7009a72e: 2605         	movs	r6, #0x5
7009a730: f8ce 6014    	str.w	r6, [lr, #0x14]
7009a734: f8ce 5010    	str.w	r5, [lr, #0x10]
7009a738: 2500         	movs	r5, #0x0
7009a73a: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a73e: 250a         	movs	r5, #0xa
7009a740: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a744: ea4f 74d4    	lsr.w	r4, r4, #0x1f
7009a748: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a74c: f8ce c000    	str.w	r12, [lr]
7009a750: f008 fd9e    	bl	0x700a3290 <_ntoa_long> @ imm = #0x8b3c
7009a754: 9024         	str	r0, [sp, #0x90]
;     if (flags & FLAGS_LEFT) {
7009a756: f89d 00b8    	ldrb.w	r0, [sp, #0xb8]
7009a75a: 0780         	lsls	r0, r0, #0x1e
7009a75c: 2800         	cmp	r0, #0x0
7009a75e: d513         	bpl	0x7009a788 <_etoa+0x428> @ imm = #0x26
7009a760: e7ff         	b	0x7009a762 <_etoa+0x402> @ imm = #-0x2
;       while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
7009a762: e7ff         	b	0x7009a764 <_etoa+0x404> @ imm = #-0x2
7009a764: 9824         	ldr	r0, [sp, #0x90]
7009a766: 9913         	ldr	r1, [sp, #0x4c]
7009a768: 1a40         	subs	r0, r0, r1
7009a76a: 992d         	ldr	r1, [sp, #0xb4]
7009a76c: 4288         	cmp	r0, r1
7009a76e: d20a         	bhs	0x7009a786 <_etoa+0x426> @ imm = #0x14
7009a770: e7ff         	b	0x7009a772 <_etoa+0x412> @ imm = #-0x2
7009a772: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009a776: 9925         	ldr	r1, [sp, #0x94]
7009a778: 9a24         	ldr	r2, [sp, #0x90]
7009a77a: 1c50         	adds	r0, r2, #0x1
7009a77c: 9024         	str	r0, [sp, #0x90]
7009a77e: 9b23         	ldr	r3, [sp, #0x8c]
7009a780: 2020         	movs	r0, #0x20
7009a782: 47e0         	blx	r12
7009a784: e7ee         	b	0x7009a764 <_etoa+0x404> @ imm = #-0x24
;     }
7009a786: e7ff         	b	0x7009a788 <_etoa+0x428> @ imm = #-0x2
;   }
7009a788: e7ff         	b	0x7009a78a <_etoa+0x42a> @ imm = #-0x2
;   return idx;
7009a78a: 9824         	ldr	r0, [sp, #0x90]
7009a78c: 9027         	str	r0, [sp, #0x9c]
7009a78e: e7ff         	b	0x7009a790 <_etoa+0x430> @ imm = #-0x2
; }
7009a790: 9827         	ldr	r0, [sp, #0x9c]
7009a792: b028         	add	sp, #0xa0
7009a794: bd70         	pop	{r4, r5, r6, pc}
7009a796: bf00         	nop
7009a798: fb 79 9f 50  	.word	0x509f79fb
7009a79c: 13 44 d3 3f  	.word	0x3fd34413
7009a7a0: b3 c8 60 8b  	.word	0x8b60c8b3
7009a7a4: 28 8a c6 3f  	.word	0x3fc68a28
7009a7a8: 61 43 6f 63  	.word	0x636f4361
7009a7ac: a7 87 d2 3f  	.word	0x3fd287a7
7009a7b0: 71 a3 79 09  	.word	0x0979a371
7009a7b4: 4f 93 0a 40  	.word	0x400a934f
7009a7b8: ef 39 fa fe  	.word	0xfefa39ef
7009a7bc: 42 2e e6 bf  	.word	0xbfe62e42
7009a7c0: 16 55 b5 bb  	.word	0xbbb55516
7009a7c4: b1 6b 02 40  	.word	0x40026bb1
7009a7c8: 2d 43 1c eb  	.word	0xeb1c432d
7009a7cc: e2 36 1a 3f  	.word	0x3f1a36e2
7009a7d0: 00 00 00 00  	.word	0x00000000
7009a7d4: 80 84 2e 41  	.word	0x412e8480

7009a7d8 <__aeabi_memcpy8>:
7009a7d8: ea004cab     	b	0x700ada8c <TI_memcpy_small> @ imm = #0x132ac

7009a7dc <_nop>:
7009a7dc: e12fff1e     	bx	lr

7009a7e0 <UART_open>:
; {
7009a7e0: b580         	push	{r7, lr}
7009a7e2: b092         	sub	sp, #0x48
7009a7e4: 9011         	str	r0, [sp, #0x44]
7009a7e6: 9110         	str	r1, [sp, #0x40]
7009a7e8: 2000         	movs	r0, #0x0
;     int32_t             status = SystemP_SUCCESS;
7009a7ea: 900f         	str	r0, [sp, #0x3c]
;     UART_Handle         handle = NULL;
7009a7ec: 900e         	str	r0, [sp, #0x38]
;     UART_Config        *config = NULL;
7009a7ee: 900d         	str	r0, [sp, #0x34]
;     UART_Object        *object    = NULL;
7009a7f0: 900c         	str	r0, [sp, #0x30]
;     if(index >= gUartConfigNum)
7009a7f2: 9811         	ldr	r0, [sp, #0x44]
7009a7f4: f640 51a0    	movw	r1, #0xda0
7009a7f8: f2c7 010b    	movt	r1, #0x700b
7009a7fc: 6809         	ldr	r1, [r1]
7009a7fe: 4288         	cmp	r0, r1
7009a800: d304         	blo	0x7009a80c <UART_open+0x2c> @ imm = #0x8
7009a802: e7ff         	b	0x7009a804 <UART_open+0x24> @ imm = #-0x2
7009a804: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009a808: 900f         	str	r0, [sp, #0x3c]
;     }
7009a80a: e008         	b	0x7009a81e <UART_open+0x3e> @ imm = #0x10
;         config = &gUartConfig[index];
7009a80c: 9911         	ldr	r1, [sp, #0x44]
7009a80e: f640 505c    	movw	r0, #0xd5c
7009a812: f2c7 000b    	movt	r0, #0x700b
7009a816: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009a81a: 900d         	str	r0, [sp, #0x34]
7009a81c: e7ff         	b	0x7009a81e <UART_open+0x3e> @ imm = #-0x2
;     DebugP_assert(NULL_PTR != gUartDrvObj.lock);
7009a81e: f640 21e0    	movw	r1, #0xae0
7009a822: f2c7 010b    	movt	r1, #0x700b
7009a826: f851 0b04    	ldr	r0, [r1], #4
7009a82a: 9103         	str	r1, [sp, #0xc]
7009a82c: 2800         	cmp	r0, #0x0
7009a82e: bf18         	it	ne
7009a830: 2001         	movne	r0, #0x1
7009a832: f240 1174    	movw	r1, #0x174
7009a836: f2c7 010b    	movt	r1, #0x700b
7009a83a: 466a         	mov	r2, sp
7009a83c: 6011         	str	r1, [r2]
7009a83e: f240 31dd    	movw	r1, #0x3dd
7009a842: f2c7 010b    	movt	r1, #0x700b
7009a846: f240 521f    	movw	r2, #0x51f
7009a84a: f2c7 020b    	movt	r2, #0x700b
7009a84e: f240 1301    	movw	r3, #0x101
7009a852: f00e fc65    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xe8ca
7009a856: 9803         	ldr	r0, [sp, #0xc]
7009a858: f04f 31ff    	mov.w	r1, #0xffffffff
;     (void)SemaphoreP_pend(&gUartDrvObj.lockObj, SystemP_WAIT_FOREVER);
7009a85c: f00e fa08    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0xe410
;     if(SystemP_SUCCESS  == status)
7009a860: 980f         	ldr	r0, [sp, #0x3c]
7009a862: bb38         	cbnz	r0, 0x7009a8b4 <UART_open+0xd4> @ imm = #0x4e
7009a864: e7ff         	b	0x7009a866 <UART_open+0x86> @ imm = #-0x2
;         object = config->object;
7009a866: 980d         	ldr	r0, [sp, #0x34]
7009a868: 6840         	ldr	r0, [r0, #0x4]
7009a86a: 900c         	str	r0, [sp, #0x30]
;         attrs  = config->attrs;
7009a86c: 980d         	ldr	r0, [sp, #0x34]
7009a86e: 6800         	ldr	r0, [r0]
7009a870: 900b         	str	r0, [sp, #0x2c]
;         DebugP_assert(NULL_PTR != object);
7009a872: 980c         	ldr	r0, [sp, #0x30]
7009a874: 2800         	cmp	r0, #0x0
7009a876: bf18         	it	ne
7009a878: 2001         	movne	r0, #0x1
7009a87a: f240 31ca    	movw	r1, #0x3ca
7009a87e: f2c7 010b    	movt	r1, #0x700b
7009a882: 466a         	mov	r2, sp
7009a884: 6011         	str	r1, [r2]
7009a886: f240 31dd    	movw	r1, #0x3dd
7009a88a: f2c7 010b    	movt	r1, #0x700b
7009a88e: f240 521f    	movw	r2, #0x51f
7009a892: f2c7 020b    	movt	r2, #0x700b
7009a896: f44f 7384    	mov.w	r3, #0x108
7009a89a: f00e fc41    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xe882
;         if(TRUE == object->isOpen)
7009a89e: 980c         	ldr	r0, [sp, #0x30]
7009a8a0: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009a8a4: 2801         	cmp	r0, #0x1
7009a8a6: d104         	bne	0x7009a8b2 <UART_open+0xd2> @ imm = #0x8
7009a8a8: e7ff         	b	0x7009a8aa <UART_open+0xca> @ imm = #-0x2
7009a8aa: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009a8ae: 900f         	str	r0, [sp, #0x3c]
;         }
7009a8b0: e7ff         	b	0x7009a8b2 <UART_open+0xd2> @ imm = #-0x2
;     }
7009a8b2: e7ff         	b	0x7009a8b4 <UART_open+0xd4> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009a8b4: 980f         	ldr	r0, [sp, #0x3c]
7009a8b6: 2800         	cmp	r0, #0x0
7009a8b8: f040 80cd    	bne.w	0x7009aa56 <UART_open+0x276> @ imm = #0x19a
7009a8bc: e7ff         	b	0x7009a8be <UART_open+0xde> @ imm = #-0x2
;         object->handle = (UART_Handle) config;
7009a8be: 980d         	ldr	r0, [sp, #0x34]
7009a8c0: 990c         	ldr	r1, [sp, #0x30]
7009a8c2: 6008         	str	r0, [r1]
;         if(NULL != prms)
7009a8c4: 9810         	ldr	r0, [sp, #0x40]
7009a8c6: b138         	cbz	r0, 0x7009a8d8 <UART_open+0xf8> @ imm = #0xe
7009a8c8: e7ff         	b	0x7009a8ca <UART_open+0xea> @ imm = #-0x2
;             ( void )memcpy(&object->prms, prms, sizeof(UART_Params));
7009a8ca: 980c         	ldr	r0, [sp, #0x30]
7009a8cc: 3004         	adds	r0, #0x4
7009a8ce: 9910         	ldr	r1, [sp, #0x40]
7009a8d0: 2258         	movs	r2, #0x58
7009a8d2: f7ff ef82    	blx	0x7009a7d8 <__aeabi_memcpy8> @ imm = #-0xfc
;         }
7009a8d6: e004         	b	0x7009a8e2 <UART_open+0x102> @ imm = #0x8
;             UART_Params_init(&object->prms);
7009a8d8: 980c         	ldr	r0, [sp, #0x30]
7009a8da: 3004         	adds	r0, #0x4
7009a8dc: f00e fc60    	bl	0x700a91a0 <UART_Params_init> @ imm = #0xe8c0
7009a8e0: e7ff         	b	0x7009a8e2 <UART_open+0x102> @ imm = #-0x2
;         object->uartLld_handle             = &object->uartLld_object;
7009a8e2: 990c         	ldr	r1, [sp, #0x30]
7009a8e4: f501 7022    	add.w	r0, r1, #0x288
7009a8e8: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;         uartLld_handle                     = object->uartLld_handle;
7009a8ec: 980c         	ldr	r0, [sp, #0x30]
7009a8ee: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009a8f2: 9005         	str	r0, [sp, #0x14]
;         object->uartLld_initHandle         = &object->uartLld_initObject;
7009a8f4: 990c         	ldr	r1, [sp, #0x30]
7009a8f6: f501 7040    	add.w	r0, r1, #0x300
7009a8fa: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;         uartLldInit_handle                 = object->uartLld_initHandle;
7009a8fe: 980c         	ldr	r0, [sp, #0x30]
7009a900: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
7009a904: 9004         	str	r0, [sp, #0x10]
;         uartLld_handle->hUartInit          = uartLldInit_handle;
7009a906: 9804         	ldr	r0, [sp, #0x10]
7009a908: 9905         	ldr	r1, [sp, #0x14]
7009a90a: 6048         	str	r0, [r1, #0x4]
;         uartLld_handle->baseAddr           = attrs->baseAddr;
7009a90c: 980b         	ldr	r0, [sp, #0x2c]
7009a90e: 6800         	ldr	r0, [r0]
7009a910: 9905         	ldr	r1, [sp, #0x14]
7009a912: 6008         	str	r0, [r1]
;         uartLld_handle->args               = (void *)object->handle;
7009a914: 980c         	ldr	r0, [sp, #0x30]
7009a916: 6800         	ldr	r0, [r0]
7009a918: 9905         	ldr	r1, [sp, #0x14]
7009a91a: 6608         	str	r0, [r1, #0x60]
;         uartLld_handle->writeBuf           = object->writeBuf;
7009a91c: 980c         	ldr	r0, [sp, #0x30]
7009a91e: 6dc0         	ldr	r0, [r0, #0x5c]
7009a920: 9905         	ldr	r1, [sp, #0x14]
7009a922: 6088         	str	r0, [r1, #0x8]
;         uartLld_handle->writeCount         = object->writeCount;
7009a924: 980c         	ldr	r0, [sp, #0x30]
7009a926: 6e00         	ldr	r0, [r0, #0x60]
7009a928: 9905         	ldr	r1, [sp, #0x14]
7009a92a: 60c8         	str	r0, [r1, #0xc]
;         uartLld_handle->writeSizeRemaining = object->writeSizeRemaining;
7009a92c: 980c         	ldr	r0, [sp, #0x30]
7009a92e: 6e40         	ldr	r0, [r0, #0x64]
7009a930: 9905         	ldr	r1, [sp, #0x14]
7009a932: 6108         	str	r0, [r1, #0x10]
;         uartLld_handle->readBuf            = object->readBuf;
7009a934: 980c         	ldr	r0, [sp, #0x30]
7009a936: 6e80         	ldr	r0, [r0, #0x68]
7009a938: 9905         	ldr	r1, [sp, #0x14]
7009a93a: 6148         	str	r0, [r1, #0x14]
;         uartLld_handle->readCount          = object->readCount;
7009a93c: 980c         	ldr	r0, [sp, #0x30]
7009a93e: 6ec0         	ldr	r0, [r0, #0x6c]
7009a940: 9905         	ldr	r1, [sp, #0x14]
7009a942: 6188         	str	r0, [r1, #0x18]
;         uartLld_handle->readSizeRemaining  = object->readSizeRemaining;
7009a944: 980c         	ldr	r0, [sp, #0x30]
7009a946: 6f00         	ldr	r0, [r0, #0x70]
7009a948: 9905         	ldr	r1, [sp, #0x14]
7009a94a: 61c8         	str	r0, [r1, #0x1c]
;         uartLld_handle->rxTimeoutCnt       = object->rxTimeoutCnt;
7009a94c: 980c         	ldr	r0, [sp, #0x30]
7009a94e: 6f40         	ldr	r0, [r0, #0x74]
7009a950: 9905         	ldr	r1, [sp, #0x14]
7009a952: 6208         	str	r0, [r1, #0x20]
;         uartLld_handle->readErrorCnt       = object->readErrorCnt;
7009a954: 980c         	ldr	r0, [sp, #0x30]
7009a956: 6f80         	ldr	r0, [r0, #0x78]
7009a958: 9905         	ldr	r1, [sp, #0x14]
7009a95a: 6248         	str	r0, [r1, #0x24]
;         uartLld_handle->state              = UART_STATE_RESET;
7009a95c: 9905         	ldr	r1, [sp, #0x14]
7009a95e: 2000         	movs	r0, #0x0
7009a960: 6548         	str	r0, [r1, #0x54]
;         uartLldInit_handle->inputClkFreq      = attrs->inputClkFreq;
7009a962: 990b         	ldr	r1, [sp, #0x2c]
7009a964: 6849         	ldr	r1, [r1, #0x4]
7009a966: 9a04         	ldr	r2, [sp, #0x10]
7009a968: 6011         	str	r1, [r2]
;         uartLldInit_handle->baudRate          = object->prms.baudRate;
7009a96a: 990c         	ldr	r1, [sp, #0x30]
7009a96c: 6849         	ldr	r1, [r1, #0x4]
7009a96e: 9a04         	ldr	r2, [sp, #0x10]
7009a970: 6051         	str	r1, [r2, #0x4]
;         uartLldInit_handle->baudRate          = object->prms.baudRate;
7009a972: 990c         	ldr	r1, [sp, #0x30]
7009a974: 6849         	ldr	r1, [r1, #0x4]
7009a976: 9a04         	ldr	r2, [sp, #0x10]
7009a978: 6051         	str	r1, [r2, #0x4]
;         uartLldInit_handle->dataLength        = object->prms.dataLength;
7009a97a: 990c         	ldr	r1, [sp, #0x30]
7009a97c: 6889         	ldr	r1, [r1, #0x8]
7009a97e: 9a04         	ldr	r2, [sp, #0x10]
7009a980: 6091         	str	r1, [r2, #0x8]
;         uartLldInit_handle->stopBits          = object->prms.stopBits;
7009a982: 990c         	ldr	r1, [sp, #0x30]
7009a984: 68c9         	ldr	r1, [r1, #0xc]
7009a986: 9a04         	ldr	r2, [sp, #0x10]
7009a988: 60d1         	str	r1, [r2, #0xc]
;         uartLldInit_handle->parityType        = object->prms.parityType;
7009a98a: 990c         	ldr	r1, [sp, #0x30]
7009a98c: 6909         	ldr	r1, [r1, #0x10]
7009a98e: 9a04         	ldr	r2, [sp, #0x10]
7009a990: 6111         	str	r1, [r2, #0x10]
;         uartLldInit_handle->readReturnMode    = object->prms.readReturnMode;
7009a992: 990c         	ldr	r1, [sp, #0x30]
7009a994: 6989         	ldr	r1, [r1, #0x18]
7009a996: 9a04         	ldr	r2, [sp, #0x10]
7009a998: 6151         	str	r1, [r2, #0x14]
;         uartLldInit_handle->hwFlowControl     = object->prms.hwFlowControl;
7009a99a: 990c         	ldr	r1, [sp, #0x30]
7009a99c: 6a89         	ldr	r1, [r1, #0x28]
7009a99e: 9a04         	ldr	r2, [sp, #0x10]
7009a9a0: 6191         	str	r1, [r2, #0x18]
;         uartLldInit_handle->hwFlowControlThr  = object->prms.hwFlowControlThr;
7009a9a2: 990c         	ldr	r1, [sp, #0x30]
7009a9a4: 6ac9         	ldr	r1, [r1, #0x2c]
7009a9a6: 9a04         	ldr	r2, [sp, #0x10]
7009a9a8: 61d1         	str	r1, [r2, #0x1c]
;         uartLldInit_handle->intrNum           = object->prms.intrNum;
7009a9aa: 990c         	ldr	r1, [sp, #0x30]
7009a9ac: 6b49         	ldr	r1, [r1, #0x34]
7009a9ae: 9a04         	ldr	r2, [sp, #0x10]
7009a9b0: 6251         	str	r1, [r2, #0x24]
;         uartLldInit_handle->transferMode      = object->prms.transferMode;
7009a9b2: 990c         	ldr	r1, [sp, #0x30]
7009a9b4: 6b09         	ldr	r1, [r1, #0x30]
7009a9b6: 9a04         	ldr	r2, [sp, #0x10]
7009a9b8: 6211         	str	r1, [r2, #0x20]
;         uartLldInit_handle->intrPriority      = object->prms.intrPriority;
7009a9ba: 990c         	ldr	r1, [sp, #0x30]
7009a9bc: f891 1038    	ldrb.w	r1, [r1, #0x38]
7009a9c0: 9a04         	ldr	r2, [sp, #0x10]
7009a9c2: f882 1028    	strb.w	r1, [r2, #0x28]
;         uartLldInit_handle->operMode          = object->prms.operMode;
7009a9c6: 990c         	ldr	r1, [sp, #0x30]
7009a9c8: 6c49         	ldr	r1, [r1, #0x44]
7009a9ca: 9a04         	ldr	r2, [sp, #0x10]
7009a9cc: 62d1         	str	r1, [r2, #0x2c]
;         uartLldInit_handle->rxTrigLvl         = object->prms.rxTrigLvl;
7009a9ce: 990c         	ldr	r1, [sp, #0x30]
7009a9d0: 6c89         	ldr	r1, [r1, #0x48]
7009a9d2: 9a04         	ldr	r2, [sp, #0x10]
7009a9d4: 6391         	str	r1, [r2, #0x38]
;         uartLldInit_handle->txTrigLvl         = object->prms.txTrigLvl;
7009a9d6: 990c         	ldr	r1, [sp, #0x30]
7009a9d8: 6cc9         	ldr	r1, [r1, #0x4c]
7009a9da: 9a04         	ldr	r2, [sp, #0x10]
7009a9dc: 63d1         	str	r1, [r2, #0x3c]
;         uartLldInit_handle->uartDmaHandle     = NULL;
7009a9de: 9904         	ldr	r1, [sp, #0x10]
7009a9e0: 6488         	str	r0, [r1, #0x48]
;         uartLldInit_handle->dmaChCfg          = NULL;
7009a9e2: 9904         	ldr	r1, [sp, #0x10]
7009a9e4: 64c8         	str	r0, [r1, #0x4c]
;         uartLldInit_handle->rxEvtNum          = object->prms.rxEvtNum;
7009a9e6: 980c         	ldr	r0, [sp, #0x30]
7009a9e8: 6d00         	ldr	r0, [r0, #0x50]
7009a9ea: 9904         	ldr	r1, [sp, #0x10]
7009a9ec: 6408         	str	r0, [r1, #0x40]
;         uartLldInit_handle->txEvtNum          = object->prms.txEvtNum;
7009a9ee: 980c         	ldr	r0, [sp, #0x30]
7009a9f0: 6d40         	ldr	r0, [r0, #0x54]
7009a9f2: 9904         	ldr	r1, [sp, #0x10]
7009a9f4: 6448         	str	r0, [r1, #0x44]
;         uartLldInit_handle->writeMode         = object->prms.writeMode;
7009a9f6: 980c         	ldr	r0, [sp, #0x30]
7009a9f8: 69c0         	ldr	r0, [r0, #0x1c]
7009a9fa: 9904         	ldr	r1, [sp, #0x10]
7009a9fc: 6348         	str	r0, [r1, #0x34]
;         uartLldInit_handle->readMode          = object->prms.readMode;
7009a9fe: 980c         	ldr	r0, [sp, #0x30]
7009aa00: 6940         	ldr	r0, [r0, #0x14]
7009aa02: 9904         	ldr	r1, [sp, #0x10]
7009aa04: 6308         	str	r0, [r1, #0x30]
;         uartLldInit_handle->timeGuardVal      = object->prms.timeGuardVal;
7009aa06: 980c         	ldr	r0, [sp, #0x30]
7009aa08: 6d80         	ldr	r0, [r0, #0x58]
7009aa0a: 9904         	ldr	r1, [sp, #0x10]
7009aa0c: 6508         	str	r0, [r1, #0x50]
;         uartLldInit_handle->clockP_get        = ClockP_getTicks;
7009aa0e: 9904         	ldr	r1, [sp, #0x10]
7009aa10: f24e 1061    	movw	r0, #0xe161
7009aa14: f2c7 000a    	movt	r0, #0x700a
7009aa18: 6548         	str	r0, [r1, #0x54]
;         uartLldInit_handle->clockP_usecToTick = ClockP_usecToTicks;
7009aa1a: 9904         	ldr	r1, [sp, #0x10]
7009aa1c: f24d 70b1    	movw	r0, #0xd7b1
7009aa20: f2c7 000a    	movt	r0, #0x700a
7009aa24: 6588         	str	r0, [r1, #0x58]
;         uartLldInit_handle->readCompleteCallbackFxn =  UART_lld_readCompleteCallback;
7009aa26: 9904         	ldr	r1, [sp, #0x10]
7009aa28: f64a 3041    	movw	r0, #0xab41
7009aa2c: f2c7 000a    	movt	r0, #0x700a
7009aa30: 65c8         	str	r0, [r1, #0x5c]
;         uartLldInit_handle->writeCompleteCallbackFxn = UART_lld_writeCompleteCallback;
7009aa32: 9904         	ldr	r1, [sp, #0x10]
7009aa34: f64a 2081    	movw	r0, #0xaa81
7009aa38: f2c7 000a    	movt	r0, #0x700a
7009aa3c: 6608         	str	r0, [r1, #0x60]
;         uartLldInit_handle->errorCallbackFxn =         UART_lld_errorCallback;
7009aa3e: 9904         	ldr	r1, [sp, #0x10]
7009aa40: f24e 1071    	movw	r0, #0xe171
7009aa44: f2c7 000a    	movt	r0, #0x700a
7009aa48: 6648         	str	r0, [r1, #0x64]
;         status = UART_checkOpenParams(&object->prms);
7009aa4a: 980c         	ldr	r0, [sp, #0x30]
7009aa4c: 3004         	adds	r0, #0x4
7009aa4e: f011 fa2f    	bl	0x700abeb0 <UART_checkOpenParams> @ imm = #0x1145e
7009aa52: 900f         	str	r0, [sp, #0x3c]
;     }
7009aa54: e7ff         	b	0x7009aa56 <UART_open+0x276> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009aa56: 980f         	ldr	r0, [sp, #0x3c]
7009aa58: 2800         	cmp	r0, #0x0
7009aa5a: f040 80b8    	bne.w	0x7009abce <UART_open+0x3ee> @ imm = #0x170
7009aa5e: e7ff         	b	0x7009aa60 <UART_open+0x280> @ imm = #-0x2
;         uartLld_handle->state = UART_STATE_RESET;
7009aa60: 9905         	ldr	r1, [sp, #0x14]
7009aa62: 2000         	movs	r0, #0x0
7009aa64: 6548         	str	r0, [r1, #0x54]
;         if(UART_CONFIG_MODE_DMA == object->prms.transferMode)
7009aa66: 980c         	ldr	r0, [sp, #0x30]
7009aa68: 6b00         	ldr	r0, [r0, #0x30]
7009aa6a: 2803         	cmp	r0, #0x3
7009aa6c: d117         	bne	0x7009aa9e <UART_open+0x2be> @ imm = #0x2e
7009aa6e: e7ff         	b	0x7009aa70 <UART_open+0x290> @ imm = #-0x2
;             uartLldInit_handle->uartDmaHandle = (UART_DmaHandle) gUartDmaHandle[index];
7009aa70: 9911         	ldr	r1, [sp, #0x44]
7009aa72: f640 2028    	movw	r0, #0xa28
7009aa76: f2c7 000b    	movt	r0, #0x700b
7009aa7a: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009aa7e: 9904         	ldr	r1, [sp, #0x10]
7009aa80: 6488         	str	r0, [r1, #0x48]
;             uartLldInit_handle->dmaChCfg      = gUartDmaChConfig[index];
7009aa82: 9911         	ldr	r1, [sp, #0x44]
7009aa84: f640 50a4    	movw	r0, #0xda4
7009aa88: f2c7 000b    	movt	r0, #0x700b
7009aa8c: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009aa90: 9904         	ldr	r1, [sp, #0x10]
7009aa92: 64c8         	str	r0, [r1, #0x4c]
;             status = UART_lld_initDma(uartLld_handle);
7009aa94: 9805         	ldr	r0, [sp, #0x14]
7009aa96: f005 fdab    	bl	0x700a05f0 <UART_lld_initDma> @ imm = #0x5b56
7009aa9a: 900f         	str	r0, [sp, #0x3c]
;         }
7009aa9c: e008         	b	0x7009aab0 <UART_open+0x2d0> @ imm = #0x10
;             status = UART_lld_init(uartLld_handle);
7009aa9e: 9805         	ldr	r0, [sp, #0x14]
7009aaa0: f006 ffc6    	bl	0x700a1a30 <UART_lld_init> @ imm = #0x6f8c
7009aaa4: 900f         	str	r0, [sp, #0x3c]
;             object->uartDmaHandle = NULL;
7009aaa6: 990c         	ldr	r1, [sp, #0x30]
7009aaa8: 2000         	movs	r0, #0x0
7009aaaa: f8c1 0280    	str.w	r0, [r1, #0x280]
7009aaae: e7ff         	b	0x7009aab0 <UART_open+0x2d0> @ imm = #-0x2
;         if(SystemP_SUCCESS == status)
7009aab0: 980f         	ldr	r0, [sp, #0x3c]
7009aab2: 2800         	cmp	r0, #0x0
7009aab4: f040 808a    	bne.w	0x7009abcc <UART_open+0x3ec> @ imm = #0x114
7009aab8: e7ff         	b	0x7009aaba <UART_open+0x2da> @ imm = #-0x2
;             status = SemaphoreP_constructMutex(&object->lockObj);
7009aaba: 980c         	ldr	r0, [sp, #0x30]
7009aabc: 308c         	adds	r0, #0x8c
7009aabe: f00e ffc7    	bl	0x700a9a50 <SemaphoreP_constructMutex> @ imm = #0xef8e
7009aac2: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009aac4: 980f         	ldr	r0, [sp, #0x3c]
7009aac6: b930         	cbnz	r0, 0x7009aad6 <UART_open+0x2f6> @ imm = #0xc
7009aac8: e7ff         	b	0x7009aaca <UART_open+0x2ea> @ imm = #-0x2
;                 object->lock = &object->lockObj;
7009aaca: 990c         	ldr	r1, [sp, #0x30]
7009aacc: f101 008c    	add.w	r0, r1, #0x8c
7009aad0: f8c1 0088    	str.w	r0, [r1, #0x88]
;             }
7009aad4: e7ff         	b	0x7009aad6 <UART_open+0x2f6> @ imm = #-0x2
;             status += SemaphoreP_constructBinary(&object->readTransferSemObj, 0U);
7009aad6: 980c         	ldr	r0, [sp, #0x30]
7009aad8: f500 7094    	add.w	r0, r0, #0x128
7009aadc: 2100         	movs	r1, #0x0
7009aade: f00b fc27    	bl	0x700a6330 <SemaphoreP_constructBinary> @ imm = #0xb84e
7009aae2: 4601         	mov	r1, r0
7009aae4: 980f         	ldr	r0, [sp, #0x3c]
7009aae6: 4408         	add	r0, r1
7009aae8: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009aaea: 980f         	ldr	r0, [sp, #0x3c]
7009aaec: b958         	cbnz	r0, 0x7009ab06 <UART_open+0x326> @ imm = #0x16
7009aaee: e7ff         	b	0x7009aaf0 <UART_open+0x310> @ imm = #-0x2
;                 object->readTransferSem = &object->readTransferSemObj;
7009aaf0: 990c         	ldr	r1, [sp, #0x30]
7009aaf2: f501 7094    	add.w	r0, r1, #0x128
7009aaf6: f8c1 0124    	str.w	r0, [r1, #0x124]
;                 uartLld_handle->readTransferMutex = object->readTransferSem;
7009aafa: 980c         	ldr	r0, [sp, #0x30]
7009aafc: f8d0 0124    	ldr.w	r0, [r0, #0x124]
7009ab00: 9905         	ldr	r1, [sp, #0x14]
7009ab02: 6588         	str	r0, [r1, #0x58]
;             }
7009ab04: e7ff         	b	0x7009ab06 <UART_open+0x326> @ imm = #-0x2
;             status += SemaphoreP_constructBinary(&object->writeTransferSemObj, 0U);
7009ab06: 980c         	ldr	r0, [sp, #0x30]
7009ab08: f500 70e2    	add.w	r0, r0, #0x1c4
7009ab0c: 2100         	movs	r1, #0x0
7009ab0e: f00b fc0f    	bl	0x700a6330 <SemaphoreP_constructBinary> @ imm = #0xb81e
7009ab12: 4601         	mov	r1, r0
7009ab14: 980f         	ldr	r0, [sp, #0x3c]
7009ab16: 4408         	add	r0, r1
7009ab18: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009ab1a: 980f         	ldr	r0, [sp, #0x3c]
7009ab1c: b958         	cbnz	r0, 0x7009ab36 <UART_open+0x356> @ imm = #0x16
7009ab1e: e7ff         	b	0x7009ab20 <UART_open+0x340> @ imm = #-0x2
;                 object->writeTransferSem = &object->writeTransferSemObj;
7009ab20: 990c         	ldr	r1, [sp, #0x30]
7009ab22: f501 70e2    	add.w	r0, r1, #0x1c4
7009ab26: f8c1 01c0    	str.w	r0, [r1, #0x1c0]
;                 uartLld_handle->writeTransferMutex = object->writeTransferSem;
7009ab2a: 980c         	ldr	r0, [sp, #0x30]
7009ab2c: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
7009ab30: 9905         	ldr	r1, [sp, #0x14]
7009ab32: 65c8         	str	r0, [r1, #0x5c]
;             }
7009ab34: e7ff         	b	0x7009ab36 <UART_open+0x356> @ imm = #-0x2
;             if((UART_CONFIG_MODE_INTERRUPT == object->prms.transferMode) && (TRUE != object->prms.skipIntrReg))
7009ab36: 980c         	ldr	r0, [sp, #0x30]
7009ab38: 6b00         	ldr	r0, [r0, #0x30]
7009ab3a: 2801         	cmp	r0, #0x1
7009ab3c: d145         	bne	0x7009abca <UART_open+0x3ea> @ imm = #0x8a
7009ab3e: e7ff         	b	0x7009ab40 <UART_open+0x360> @ imm = #-0x2
7009ab40: 980c         	ldr	r0, [sp, #0x30]
7009ab42: 6bc0         	ldr	r0, [r0, #0x3c]
7009ab44: 2801         	cmp	r0, #0x1
7009ab46: d040         	beq	0x7009abca <UART_open+0x3ea> @ imm = #0x80
7009ab48: e7ff         	b	0x7009ab4a <UART_open+0x36a> @ imm = #-0x2
;                 DebugP_assert(object->prms.intrNum != 0xFFFFU);
7009ab4a: 980c         	ldr	r0, [sp, #0x30]
7009ab4c: 6b40         	ldr	r0, [r0, #0x34]
7009ab4e: f64f 71ff    	movw	r1, #0xffff
7009ab52: 1a40         	subs	r0, r0, r1
7009ab54: bf18         	it	ne
7009ab56: 2001         	movne	r0, #0x1
7009ab58: f240 019c    	movw	r1, #0x9c
7009ab5c: f2c7 010b    	movt	r1, #0x700b
7009ab60: 466a         	mov	r2, sp
7009ab62: 6011         	str	r1, [r2]
7009ab64: f240 31dd    	movw	r1, #0x3dd
7009ab68: f2c7 010b    	movt	r1, #0x700b
7009ab6c: f240 521f    	movw	r2, #0x51f
7009ab70: f2c7 020b    	movt	r2, #0x700b
7009ab74: f44f 73bf    	mov.w	r3, #0x17e
7009ab78: f00e fad2    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xe5a4
7009ab7c: a806         	add	r0, sp, #0x18
;                 HwiP_Params_init(&hwiPrms);
7009ab7e: 9002         	str	r0, [sp, #0x8]
7009ab80: f013 fc16    	bl	0x700ae3b0 <HwiP_Params_init> @ imm = #0x1382c
7009ab84: 9902         	ldr	r1, [sp, #0x8]
;                 hwiPrms.intNum      = object->prms.intrNum;
7009ab86: 980c         	ldr	r0, [sp, #0x30]
7009ab88: 6b40         	ldr	r0, [r0, #0x34]
7009ab8a: 9006         	str	r0, [sp, #0x18]
;                 hwiPrms.callback    = &UART_lld_controllerIsr;
7009ab8c: f64e 1001    	movw	r0, #0xe901
7009ab90: f2c7 0009    	movt	r0, #0x7009
7009ab94: 9007         	str	r0, [sp, #0x1c]
;                 hwiPrms.priority    = object->prms.intrPriority;
7009ab96: 980c         	ldr	r0, [sp, #0x30]
7009ab98: f890 0038    	ldrb.w	r0, [r0, #0x38]
7009ab9c: f88d 0026    	strb.w	r0, [sp, #0x26]
;                 hwiPrms.args        = (void *) uartLld_handle;
7009aba0: 9805         	ldr	r0, [sp, #0x14]
7009aba2: 9008         	str	r0, [sp, #0x20]
;                 status += HwiP_construct(&object->hwiObj, &hwiPrms);
7009aba4: 980c         	ldr	r0, [sp, #0x30]
7009aba6: f500 7018    	add.w	r0, r0, #0x260
7009abaa: f013 fc19    	bl	0x700ae3e0 <HwiP_construct> @ imm = #0x13832
7009abae: 4601         	mov	r1, r0
7009abb0: 980f         	ldr	r0, [sp, #0x3c]
7009abb2: 4408         	add	r0, r1
7009abb4: 900f         	str	r0, [sp, #0x3c]
;                 if(SystemP_SUCCESS == status)
7009abb6: 980f         	ldr	r0, [sp, #0x3c]
7009abb8: b930         	cbnz	r0, 0x7009abc8 <UART_open+0x3e8> @ imm = #0xc
7009abba: e7ff         	b	0x7009abbc <UART_open+0x3dc> @ imm = #-0x2
;                     object->hwiHandle = &object->hwiObj;
7009abbc: 990c         	ldr	r1, [sp, #0x30]
7009abbe: f501 7018    	add.w	r0, r1, #0x260
7009abc2: f8c1 025c    	str.w	r0, [r1, #0x25c]
;                 }
7009abc6: e7ff         	b	0x7009abc8 <UART_open+0x3e8> @ imm = #-0x2
;             }
7009abc8: e7ff         	b	0x7009abca <UART_open+0x3ea> @ imm = #-0x2
;         }
7009abca: e7ff         	b	0x7009abcc <UART_open+0x3ec> @ imm = #-0x2
;     }
7009abcc: e7ff         	b	0x7009abce <UART_open+0x3ee> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009abce: 980f         	ldr	r0, [sp, #0x3c]
7009abd0: b938         	cbnz	r0, 0x7009abe2 <UART_open+0x402> @ imm = #0xe
7009abd2: e7ff         	b	0x7009abd4 <UART_open+0x3f4> @ imm = #-0x2
;         object->isOpen = TRUE;
7009abd4: 990c         	ldr	r1, [sp, #0x30]
7009abd6: 2001         	movs	r0, #0x1
7009abd8: f8c1 0084    	str.w	r0, [r1, #0x84]
;         handle = (UART_Handle) config;
7009abdc: 980d         	ldr	r0, [sp, #0x34]
7009abde: 900e         	str	r0, [sp, #0x38]
;     }
7009abe0: e7ff         	b	0x7009abe2 <UART_open+0x402> @ imm = #-0x2
;     SemaphoreP_post(&gUartDrvObj.lockObj);
7009abe2: f640 20e0    	movw	r0, #0xae0
7009abe6: f2c7 000b    	movt	r0, #0x700b
7009abea: 3004         	adds	r0, #0x4
7009abec: f00f fb90    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0xf720
;     if(SystemP_SUCCESS != status)
7009abf0: 980f         	ldr	r0, [sp, #0x3c]
7009abf2: b140         	cbz	r0, 0x7009ac06 <UART_open+0x426> @ imm = #0x10
7009abf4: e7ff         	b	0x7009abf6 <UART_open+0x416> @ imm = #-0x2
;         if(NULL != config)
7009abf6: 980d         	ldr	r0, [sp, #0x34]
7009abf8: b120         	cbz	r0, 0x7009ac04 <UART_open+0x424> @ imm = #0x8
7009abfa: e7ff         	b	0x7009abfc <UART_open+0x41c> @ imm = #-0x2
;             UART_close((UART_Handle) config);
7009abfc: 980d         	ldr	r0, [sp, #0x34]
7009abfe: f003 fcc7    	bl	0x7009e590 <UART_close> @ imm = #0x398e
;         }
7009ac02: e7ff         	b	0x7009ac04 <UART_open+0x424> @ imm = #-0x2
;     }
7009ac04: e7ff         	b	0x7009ac06 <UART_open+0x426> @ imm = #-0x2
;     return (handle);
7009ac06: 980e         	ldr	r0, [sp, #0x38]
7009ac08: b012         	add	sp, #0x48
7009ac0a: bd80         	pop	{r7, pc}
7009ac0c: 0000         	movs	r0, r0
7009ac0e: 0000         	movs	r0, r0

7009ac10 <Udma_chAllocResource>:
; {
7009ac10: b580         	push	{r7, lr}
7009ac12: b088         	sub	sp, #0x20
7009ac14: 9007         	str	r0, [sp, #0x1c]
7009ac16: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK, tempRetVal;
7009ac18: 9006         	str	r0, [sp, #0x18]
7009ac1a: f64f 70ff    	movw	r0, #0xffff
;     uint16_t                ringNum = UDMA_RING_INVALID;
7009ac1e: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     drvHandle = chHandle->drvHandle;
7009ac22: 9807         	ldr	r0, [sp, #0x1c]
7009ac24: 6e80         	ldr	r0, [r0, #0x68]
7009ac26: 9004         	str	r0, [sp, #0x10]
;     if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009ac28: 9807         	ldr	r0, [sp, #0x1c]
7009ac2a: 7800         	ldrb	r0, [r0]
7009ac2c: 0740         	lsls	r0, r0, #0x1d
7009ac2e: 2800         	cmp	r0, #0x0
7009ac30: d54d         	bpl	0x7009acce <Udma_chAllocResource+0xbe> @ imm = #0x9a
7009ac32: e7ff         	b	0x7009ac34 <Udma_chAllocResource+0x24> @ imm = #-0x2
;         if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009ac34: 9807         	ldr	r0, [sp, #0x1c]
7009ac36: 7800         	ldrb	r0, [r0]
7009ac38: 0640         	lsls	r0, r0, #0x19
7009ac3a: 2800         	cmp	r0, #0x0
7009ac3c: d508         	bpl	0x7009ac50 <Udma_chAllocResource+0x40> @ imm = #0x10
7009ac3e: e7ff         	b	0x7009ac40 <Udma_chAllocResource+0x30> @ imm = #-0x2
;                 Udma_rmAllocBlkCopyHcCh(chHandle->chPrms.chNum, drvHandle);
7009ac40: 9807         	ldr	r0, [sp, #0x1c]
7009ac42: 6840         	ldr	r0, [r0, #0x4]
7009ac44: 9904         	ldr	r1, [sp, #0x10]
7009ac46: f007 f9eb    	bl	0x700a2020 <Udma_rmAllocBlkCopyHcCh> @ imm = #0x73d6
;             chHandle->txChNum =
7009ac4a: 9907         	ldr	r1, [sp, #0x1c]
7009ac4c: 66c8         	str	r0, [r1, #0x6c]
;         }
7009ac4e: e016         	b	0x7009ac7e <Udma_chAllocResource+0x6e> @ imm = #0x2c
;         else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009ac50: 9807         	ldr	r0, [sp, #0x1c]
7009ac52: 7800         	ldrb	r0, [r0]
7009ac54: 0600         	lsls	r0, r0, #0x18
7009ac56: 2800         	cmp	r0, #0x0
7009ac58: d508         	bpl	0x7009ac6c <Udma_chAllocResource+0x5c> @ imm = #0x10
7009ac5a: e7ff         	b	0x7009ac5c <Udma_chAllocResource+0x4c> @ imm = #-0x2
;                 Udma_rmAllocBlkCopyUhcCh(chHandle->chPrms.chNum, drvHandle);
7009ac5c: 9807         	ldr	r0, [sp, #0x1c]
7009ac5e: 6840         	ldr	r0, [r0, #0x4]
7009ac60: 9904         	ldr	r1, [sp, #0x10]
7009ac62: f007 fa75    	bl	0x700a2150 <Udma_rmAllocBlkCopyUhcCh> @ imm = #0x74ea
;             chHandle->txChNum =
7009ac66: 9907         	ldr	r1, [sp, #0x1c]
7009ac68: 66c8         	str	r0, [r1, #0x6c]
;         }
7009ac6a: e007         	b	0x7009ac7c <Udma_chAllocResource+0x6c> @ imm = #0xe
;                 Udma_rmAllocBlkCopyCh(chHandle->chPrms.chNum, drvHandle);
7009ac6c: 9807         	ldr	r0, [sp, #0x1c]
7009ac6e: 6840         	ldr	r0, [r0, #0x4]
7009ac70: 9904         	ldr	r1, [sp, #0x10]
7009ac72: f007 f93d    	bl	0x700a1ef0 <Udma_rmAllocBlkCopyCh> @ imm = #0x727a
;             chHandle->txChNum =
7009ac76: 9907         	ldr	r1, [sp, #0x1c]
7009ac78: 66c8         	str	r0, [r1, #0x6c]
7009ac7a: e7ff         	b	0x7009ac7c <Udma_chAllocResource+0x6c> @ imm = #-0x2
7009ac7c: e7ff         	b	0x7009ac7e <Udma_chAllocResource+0x6e> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID == chHandle->txChNum)
7009ac7e: 9807         	ldr	r0, [sp, #0x1c]
7009ac80: 6ec0         	ldr	r0, [r0, #0x6c]
7009ac82: f510 3f80    	cmn.w	r0, #0x10000
7009ac86: d104         	bne	0x7009ac92 <Udma_chAllocResource+0x82> @ imm = #0x8
7009ac88: e7ff         	b	0x7009ac8a <Udma_chAllocResource+0x7a> @ imm = #-0x2
7009ac8a: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
7009ac8e: 9006         	str	r0, [sp, #0x18]
;         }
7009ac90: e01c         	b	0x7009accc <Udma_chAllocResource+0xbc> @ imm = #0x38
;             if (UDMA_INST_TYPE_LCDMA_BCDMA == chHandle->drvHandle->instType)
7009ac92: 9807         	ldr	r0, [sp, #0x1c]
7009ac94: 6e80         	ldr	r0, [r0, #0x68]
7009ac96: 6800         	ldr	r0, [r0]
7009ac98: 2801         	cmp	r0, #0x1
7009ac9a: d10b         	bne	0x7009acb4 <Udma_chAllocResource+0xa4> @ imm = #0x16
7009ac9c: e7ff         	b	0x7009ac9e <Udma_chAllocResource+0x8e> @ imm = #-0x2
;                 chHandle->rxChNum     = UDMA_DMA_CH_INVALID;
7009ac9e: 9907         	ldr	r1, [sp, #0x1c]
7009aca0: 2000         	movs	r0, #0x0
7009aca2: f6cf 70ff    	movt	r0, #0xffff
7009aca6: 6708         	str	r0, [r1, #0x70]
;                 chHandle->peerThreadId = UDMA_THREAD_ID_INVALID;
7009aca8: 9907         	ldr	r1, [sp, #0x1c]
7009acaa: 2004         	movs	r0, #0x4
7009acac: f6cf 70ff    	movt	r0, #0xffff
7009acb0: 67c8         	str	r0, [r1, #0x7c]
;             }
7009acb2: e00a         	b	0x7009acca <Udma_chAllocResource+0xba> @ imm = #0x14
;                 chHandle->rxChNum = chHandle->txChNum;
7009acb4: 9907         	ldr	r1, [sp, #0x1c]
7009acb6: 6ec8         	ldr	r0, [r1, #0x6c]
7009acb8: 6708         	str	r0, [r1, #0x70]
;                     chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
7009acba: 9907         	ldr	r1, [sp, #0x1c]
7009acbc: 6f08         	ldr	r0, [r1, #0x70]
7009acbe: 9a04         	ldr	r2, [sp, #0x10]
7009acc0: f8d2 20d8    	ldr.w	r2, [r2, #0xd8]
7009acc4: 4410         	add	r0, r2
;                 chHandle->peerThreadId =
7009acc6: 67c8         	str	r0, [r1, #0x7c]
7009acc8: e7ff         	b	0x7009acca <Udma_chAllocResource+0xba> @ imm = #-0x2
7009acca: e7ff         	b	0x7009accc <Udma_chAllocResource+0xbc> @ imm = #-0x2
;     }
7009accc: e0bd         	b	0x7009ae4a <Udma_chAllocResource+0x23a> @ imm = #0x17a
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009acce: 9807         	ldr	r0, [sp, #0x1c]
7009acd0: 7800         	ldrb	r0, [r0]
7009acd2: 07c0         	lsls	r0, r0, #0x1f
7009acd4: 2800         	cmp	r0, #0x0
7009acd6: d03f         	beq	0x7009ad58 <Udma_chAllocResource+0x148> @ imm = #0x7e
7009acd8: e7ff         	b	0x7009acda <Udma_chAllocResource+0xca> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009acda: 9807         	ldr	r0, [sp, #0x1c]
7009acdc: 7800         	ldrb	r0, [r0]
7009acde: 0640         	lsls	r0, r0, #0x19
7009ace0: 2800         	cmp	r0, #0x0
7009ace2: d508         	bpl	0x7009acf6 <Udma_chAllocResource+0xe6> @ imm = #0x10
7009ace4: e7ff         	b	0x7009ace6 <Udma_chAllocResource+0xd6> @ imm = #-0x2
;                     Udma_rmAllocTxHcCh(chHandle->chPrms.chNum, drvHandle);
7009ace6: 9807         	ldr	r0, [sp, #0x1c]
7009ace8: 6840         	ldr	r0, [r0, #0x4]
7009acea: 9904         	ldr	r1, [sp, #0x10]
7009acec: f007 fd28    	bl	0x700a2740 <Udma_rmAllocTxHcCh> @ imm = #0x7a50
;                 chHandle->txChNum =
7009acf0: 9907         	ldr	r1, [sp, #0x1c]
7009acf2: 66c8         	str	r0, [r1, #0x6c]
;             }
7009acf4: e025         	b	0x7009ad42 <Udma_chAllocResource+0x132> @ imm = #0x4a
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009acf6: 9807         	ldr	r0, [sp, #0x1c]
7009acf8: 7840         	ldrb	r0, [r0, #0x1]
7009acfa: 07c0         	lsls	r0, r0, #0x1f
7009acfc: b148         	cbz	r0, 0x7009ad12 <Udma_chAllocResource+0x102> @ imm = #0x12
7009acfe: e7ff         	b	0x7009ad00 <Udma_chAllocResource+0xf0> @ imm = #-0x2
;                     Udma_rmAllocMappedTxCh(chHandle->chPrms.chNum, drvHandle, chHandle->chPrms.mappedChGrp);
7009ad00: 9a07         	ldr	r2, [sp, #0x1c]
7009ad02: 9904         	ldr	r1, [sp, #0x10]
7009ad04: 6850         	ldr	r0, [r2, #0x4]
7009ad06: 68d2         	ldr	r2, [r2, #0xc]
7009ad08: f005 fb12    	bl	0x700a0330 <Udma_rmAllocMappedTxCh> @ imm = #0x5624
;                 chHandle->txChNum =
7009ad0c: 9907         	ldr	r1, [sp, #0x1c]
7009ad0e: 66c8         	str	r0, [r1, #0x6c]
;             }
7009ad10: e016         	b	0x7009ad40 <Udma_chAllocResource+0x130> @ imm = #0x2c
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009ad12: 9807         	ldr	r0, [sp, #0x1c]
7009ad14: 7800         	ldrb	r0, [r0]
7009ad16: 0600         	lsls	r0, r0, #0x18
7009ad18: 2800         	cmp	r0, #0x0
7009ad1a: d508         	bpl	0x7009ad2e <Udma_chAllocResource+0x11e> @ imm = #0x10
7009ad1c: e7ff         	b	0x7009ad1e <Udma_chAllocResource+0x10e> @ imm = #-0x2
;                     Udma_rmAllocTxUhcCh(chHandle->chPrms.chNum, drvHandle);
7009ad1e: 9807         	ldr	r0, [sp, #0x1c]
7009ad20: 6840         	ldr	r0, [r0, #0x4]
7009ad22: 9904         	ldr	r1, [sp, #0x10]
7009ad24: f007 fda4    	bl	0x700a2870 <Udma_rmAllocTxUhcCh> @ imm = #0x7b48
;                 chHandle->txChNum =
7009ad28: 9907         	ldr	r1, [sp, #0x1c]
7009ad2a: 66c8         	str	r0, [r1, #0x6c]
;             }
7009ad2c: e007         	b	0x7009ad3e <Udma_chAllocResource+0x12e> @ imm = #0xe
;                     Udma_rmAllocTxCh(chHandle->chPrms.chNum, drvHandle);
7009ad2e: 9807         	ldr	r0, [sp, #0x1c]
7009ad30: 6840         	ldr	r0, [r0, #0x4]
7009ad32: 9904         	ldr	r1, [sp, #0x10]
7009ad34: f007 fc6c    	bl	0x700a2610 <Udma_rmAllocTxCh> @ imm = #0x78d8
;                 chHandle->txChNum =
7009ad38: 9907         	ldr	r1, [sp, #0x1c]
7009ad3a: 66c8         	str	r0, [r1, #0x6c]
7009ad3c: e7ff         	b	0x7009ad3e <Udma_chAllocResource+0x12e> @ imm = #-0x2
7009ad3e: e7ff         	b	0x7009ad40 <Udma_chAllocResource+0x130> @ imm = #-0x2
7009ad40: e7ff         	b	0x7009ad42 <Udma_chAllocResource+0x132> @ imm = #-0x2
;             if(UDMA_DMA_CH_INVALID == chHandle->txChNum)
7009ad42: 9807         	ldr	r0, [sp, #0x1c]
7009ad44: 6ec0         	ldr	r0, [r0, #0x6c]
7009ad46: f510 3f80    	cmn.w	r0, #0x10000
7009ad4a: d104         	bne	0x7009ad56 <Udma_chAllocResource+0x146> @ imm = #0x8
7009ad4c: e7ff         	b	0x7009ad4e <Udma_chAllocResource+0x13e> @ imm = #-0x2
7009ad4e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009ad52: 9006         	str	r0, [sp, #0x18]
;             }
7009ad54: e7ff         	b	0x7009ad56 <Udma_chAllocResource+0x146> @ imm = #-0x2
;         }
7009ad56: e05c         	b	0x7009ae12 <Udma_chAllocResource+0x202> @ imm = #0xb8
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009ad58: 9807         	ldr	r0, [sp, #0x1c]
7009ad5a: 7800         	ldrb	r0, [r0]
7009ad5c: 0640         	lsls	r0, r0, #0x19
7009ad5e: 2800         	cmp	r0, #0x0
7009ad60: d508         	bpl	0x7009ad74 <Udma_chAllocResource+0x164> @ imm = #0x10
7009ad62: e7ff         	b	0x7009ad64 <Udma_chAllocResource+0x154> @ imm = #-0x2
;                     Udma_rmAllocRxHcCh(chHandle->chPrms.chNum, drvHandle);
7009ad64: 9807         	ldr	r0, [sp, #0x1c]
7009ad66: 6840         	ldr	r0, [r0, #0x4]
7009ad68: 9904         	ldr	r1, [sp, #0x10]
7009ad6a: f007 fb21    	bl	0x700a23b0 <Udma_rmAllocRxHcCh> @ imm = #0x7642
;                 chHandle->rxChNum =
7009ad6e: 9907         	ldr	r1, [sp, #0x1c]
7009ad70: 6708         	str	r0, [r1, #0x70]
;             }
7009ad72: e026         	b	0x7009adc2 <Udma_chAllocResource+0x1b2> @ imm = #0x4c
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009ad74: 9807         	ldr	r0, [sp, #0x1c]
7009ad76: 7840         	ldrb	r0, [r0, #0x1]
7009ad78: 07c0         	lsls	r0, r0, #0x1f
7009ad7a: b150         	cbz	r0, 0x7009ad92 <Udma_chAllocResource+0x182> @ imm = #0x14
7009ad7c: e7ff         	b	0x7009ad7e <Udma_chAllocResource+0x16e> @ imm = #-0x2
;                     Udma_rmAllocMappedRxCh(chHandle->chPrms.chNum, drvHandle, chHandle->chPrms.mappedChGrp - UDMA_NUM_MAPPED_TX_GROUP);
7009ad7e: 9a07         	ldr	r2, [sp, #0x1c]
7009ad80: 9904         	ldr	r1, [sp, #0x10]
7009ad82: 6850         	ldr	r0, [r2, #0x4]
7009ad84: 68d2         	ldr	r2, [r2, #0xc]
7009ad86: 3a04         	subs	r2, #0x4
7009ad88: f005 fa22    	bl	0x700a01d0 <Udma_rmAllocMappedRxCh> @ imm = #0x5444
;                 chHandle->rxChNum =
7009ad8c: 9907         	ldr	r1, [sp, #0x1c]
7009ad8e: 6708         	str	r0, [r1, #0x70]
;             }
7009ad90: e016         	b	0x7009adc0 <Udma_chAllocResource+0x1b0> @ imm = #0x2c
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009ad92: 9807         	ldr	r0, [sp, #0x1c]
7009ad94: 7800         	ldrb	r0, [r0]
7009ad96: 0600         	lsls	r0, r0, #0x18
7009ad98: 2800         	cmp	r0, #0x0
7009ad9a: d508         	bpl	0x7009adae <Udma_chAllocResource+0x19e> @ imm = #0x10
7009ad9c: e7ff         	b	0x7009ad9e <Udma_chAllocResource+0x18e> @ imm = #-0x2
;                     Udma_rmAllocRxUhcCh(chHandle->chPrms.chNum, drvHandle);
7009ad9e: 9807         	ldr	r0, [sp, #0x1c]
7009ada0: 6840         	ldr	r0, [r0, #0x4]
7009ada2: 9904         	ldr	r1, [sp, #0x10]
7009ada4: f007 fb9c    	bl	0x700a24e0 <Udma_rmAllocRxUhcCh> @ imm = #0x7738
;                 chHandle->rxChNum =
7009ada8: 9907         	ldr	r1, [sp, #0x1c]
7009adaa: 6708         	str	r0, [r1, #0x70]
;             }
7009adac: e007         	b	0x7009adbe <Udma_chAllocResource+0x1ae> @ imm = #0xe
;                     Udma_rmAllocRxCh(chHandle->chPrms.chNum, drvHandle);
7009adae: 9807         	ldr	r0, [sp, #0x1c]
7009adb0: 6840         	ldr	r0, [r0, #0x4]
7009adb2: 9904         	ldr	r1, [sp, #0x10]
7009adb4: f007 fa64    	bl	0x700a2280 <Udma_rmAllocRxCh> @ imm = #0x74c8
;                 chHandle->rxChNum =
7009adb8: 9907         	ldr	r1, [sp, #0x1c]
7009adba: 6708         	str	r0, [r1, #0x70]
7009adbc: e7ff         	b	0x7009adbe <Udma_chAllocResource+0x1ae> @ imm = #-0x2
7009adbe: e7ff         	b	0x7009adc0 <Udma_chAllocResource+0x1b0> @ imm = #-0x2
7009adc0: e7ff         	b	0x7009adc2 <Udma_chAllocResource+0x1b2> @ imm = #-0x2
;             if(UDMA_DMA_CH_INVALID == chHandle->rxChNum)
7009adc2: 9807         	ldr	r0, [sp, #0x1c]
7009adc4: 6f00         	ldr	r0, [r0, #0x70]
7009adc6: f510 3f80    	cmn.w	r0, #0x10000
7009adca: d104         	bne	0x7009add6 <Udma_chAllocResource+0x1c6> @ imm = #0x8
7009adcc: e7ff         	b	0x7009adce <Udma_chAllocResource+0x1be> @ imm = #-0x2
7009adce: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009add2: 9006         	str	r0, [sp, #0x18]
;             }
7009add4: e01c         	b	0x7009ae10 <Udma_chAllocResource+0x200> @ imm = #0x38
;                 chHandle->defaultFlow               = &chHandle->defaultFlowObj;
7009add6: 9907         	ldr	r1, [sp, #0x1c]
7009add8: f501 70e6    	add.w	r0, r1, #0x1cc
7009addc: f8c1 01c8    	str.w	r0, [r1, #0x1c8]
;                 chHandle->defaultFlow->drvHandle    = drvHandle;
7009ade0: 9804         	ldr	r0, [sp, #0x10]
7009ade2: 9907         	ldr	r1, [sp, #0x1c]
7009ade4: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009ade8: 6008         	str	r0, [r1]
;                 chHandle->defaultFlow->flowStart    = chHandle->rxChNum;
7009adea: 9907         	ldr	r1, [sp, #0x1c]
7009adec: 6f08         	ldr	r0, [r1, #0x70]
7009adee: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009adf2: 6048         	str	r0, [r1, #0x4]
;                 chHandle->defaultFlow->flowCnt      = 1U;
7009adf4: 9807         	ldr	r0, [sp, #0x1c]
7009adf6: f8d0 11c8    	ldr.w	r1, [r0, #0x1c8]
7009adfa: 2001         	movs	r0, #0x1
7009adfc: 6088         	str	r0, [r1, #0x8]
;                 chHandle->defaultFlow->flowInitDone = UDMA_INIT_DONE;
7009adfe: 9807         	ldr	r0, [sp, #0x1c]
7009ae00: f8d0 11c8    	ldr.w	r1, [r0, #0x1c8]
7009ae04: f64a 30cd    	movw	r0, #0xabcd
7009ae08: f6ca 30dc    	movt	r0, #0xabdc
7009ae0c: 60c8         	str	r0, [r1, #0xc]
7009ae0e: e7ff         	b	0x7009ae10 <Udma_chAllocResource+0x200> @ imm = #-0x2
7009ae10: e7ff         	b	0x7009ae12 <Udma_chAllocResource+0x202> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
7009ae12: 9806         	ldr	r0, [sp, #0x18]
7009ae14: b9c0         	cbnz	r0, 0x7009ae48 <Udma_chAllocResource+0x238> @ imm = #0x30
7009ae16: e7ff         	b	0x7009ae18 <Udma_chAllocResource+0x208> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA)
7009ae18: 9807         	ldr	r0, [sp, #0x1c]
7009ae1a: 7800         	ldrb	r0, [r0]
7009ae1c: 0700         	lsls	r0, r0, #0x1c
7009ae1e: 2800         	cmp	r0, #0x0
7009ae20: d507         	bpl	0x7009ae32 <Udma_chAllocResource+0x222> @ imm = #0xe
7009ae22: e7ff         	b	0x7009ae24 <Udma_chAllocResource+0x214> @ imm = #-0x2
;                 chHandle->pdmaChNum = chHandle->chPrms.peerChNum;
7009ae24: 9907         	ldr	r1, [sp, #0x1c]
7009ae26: 6888         	ldr	r0, [r1, #0x8]
7009ae28: 6788         	str	r0, [r1, #0x78]
;                 chHandle->peerThreadId = chHandle->pdmaChNum;
7009ae2a: 9907         	ldr	r1, [sp, #0x1c]
7009ae2c: 6f88         	ldr	r0, [r1, #0x78]
7009ae2e: 67c8         	str	r0, [r1, #0x7c]
;             }
7009ae30: e7ff         	b	0x7009ae32 <Udma_chAllocResource+0x222> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_PSIL) == UDMA_CH_FLAG_PSIL)
7009ae32: 9807         	ldr	r0, [sp, #0x1c]
7009ae34: 7800         	ldrb	r0, [r0]
7009ae36: 06c0         	lsls	r0, r0, #0x1b
7009ae38: 2800         	cmp	r0, #0x0
7009ae3a: d504         	bpl	0x7009ae46 <Udma_chAllocResource+0x236> @ imm = #0x8
7009ae3c: e7ff         	b	0x7009ae3e <Udma_chAllocResource+0x22e> @ imm = #-0x2
;                 chHandle->peerThreadId = chHandle->chPrms.peerChNum;
7009ae3e: 9907         	ldr	r1, [sp, #0x1c]
7009ae40: 6888         	ldr	r0, [r1, #0x8]
7009ae42: 67c8         	str	r0, [r1, #0x7c]
;             }
7009ae44: e7ff         	b	0x7009ae46 <Udma_chAllocResource+0x236> @ imm = #-0x2
;         }
7009ae46: e7ff         	b	0x7009ae48 <Udma_chAllocResource+0x238> @ imm = #-0x2
7009ae48: e7ff         	b	0x7009ae4a <Udma_chAllocResource+0x23a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ae4a: 9806         	ldr	r0, [sp, #0x18]
7009ae4c: 2800         	cmp	r0, #0x0
7009ae4e: f040 8088    	bne.w	0x7009af62 <Udma_chAllocResource+0x352> @ imm = #0x110
7009ae52: e7ff         	b	0x7009ae54 <Udma_chAllocResource+0x244> @ imm = #-0x2
;         if(NULL_PTR != chHandle->chPrms.fqRingPrms.ringMem)
7009ae54: 9807         	ldr	r0, [sp, #0x1c]
7009ae56: 6940         	ldr	r0, [r0, #0x14]
7009ae58: 2800         	cmp	r0, #0x0
7009ae5a: f000 8081    	beq.w	0x7009af60 <Udma_chAllocResource+0x350> @ imm = #0x102
7009ae5e: e7ff         	b	0x7009ae60 <Udma_chAllocResource+0x250> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) ==
7009ae60: 9807         	ldr	r0, [sp, #0x1c]
7009ae62: 7800         	ldrb	r0, [r0]
7009ae64: 0740         	lsls	r0, r0, #0x1d
7009ae66: 2800         	cmp	r0, #0x0
7009ae68: d505         	bpl	0x7009ae76 <Udma_chAllocResource+0x266> @ imm = #0xa
7009ae6a: e7ff         	b	0x7009ae6c <Udma_chAllocResource+0x25c> @ imm = #-0x2
;                 ringNum = (uint16_t)chHandle->txChNum;
7009ae6c: 9807         	ldr	r0, [sp, #0x1c]
7009ae6e: 6ec0         	ldr	r0, [r0, #0x6c]
7009ae70: f8ad 000e    	strh.w	r0, [sp, #0xe]
;             }
7009ae74: e044         	b	0x7009af00 <Udma_chAllocResource+0x2f0> @ imm = #0x88
;                 if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009ae76: 9807         	ldr	r0, [sp, #0x1c]
7009ae78: 7840         	ldrb	r0, [r0, #0x1]
7009ae7a: 07c0         	lsls	r0, r0, #0x1f
7009ae7c: b338         	cbz	r0, 0x7009aece <Udma_chAllocResource+0x2be> @ imm = #0x4e
7009ae7e: e7ff         	b	0x7009ae80 <Udma_chAllocResource+0x270> @ imm = #-0x2
;                     chHandle->chPrms.fqRingPrms.mappedRingGrp  = chHandle->chPrms.mappedChGrp;
7009ae80: 9907         	ldr	r1, [sp, #0x1c]
7009ae82: 68c8         	ldr	r0, [r1, #0xc]
7009ae84: 6288         	str	r0, [r1, #0x28]
;                     if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009ae86: 9807         	ldr	r0, [sp, #0x1c]
7009ae88: 7800         	ldrb	r0, [r0]
7009ae8a: 07c0         	lsls	r0, r0, #0x1f
7009ae8c: b178         	cbz	r0, 0x7009aeae <Udma_chAllocResource+0x29e> @ imm = #0x1e
7009ae8e: e7ff         	b	0x7009ae90 <Udma_chAllocResource+0x280> @ imm = #-0x2
;                         chHandle->chPrms.fqRingPrms.mappedChNum    = chHandle->txChNum;
7009ae90: 9907         	ldr	r1, [sp, #0x1c]
7009ae92: 6ec8         	ldr	r0, [r1, #0x6c]
7009ae94: 62c8         	str	r0, [r1, #0x2c]
;                         retVal = Udma_getMappedChRingAttributes(drvHandle, chHandle->chPrms.mappedChGrp, chHandle->txChNum, &chAttr);
7009ae96: 9804         	ldr	r0, [sp, #0x10]
7009ae98: 9a07         	ldr	r2, [sp, #0x1c]
7009ae9a: 68d1         	ldr	r1, [r2, #0xc]
7009ae9c: 6ed2         	ldr	r2, [r2, #0x6c]
7009ae9e: 466b         	mov	r3, sp
7009aea0: f00b f996    	bl	0x700a61d0 <Udma_getMappedChRingAttributes> @ imm = #0xb32c
7009aea4: 9006         	str	r0, [sp, #0x18]
;                         ringNum = chAttr.defaultRing;
7009aea6: 9800         	ldr	r0, [sp]
7009aea8: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                     }
7009aeac: e00e         	b	0x7009aecc <Udma_chAllocResource+0x2bc> @ imm = #0x1c
;                         chHandle->chPrms.fqRingPrms.mappedChNum    = chHandle->rxChNum;
7009aeae: 9907         	ldr	r1, [sp, #0x1c]
7009aeb0: 6f08         	ldr	r0, [r1, #0x70]
7009aeb2: 62c8         	str	r0, [r1, #0x2c]
;                         retVal = Udma_getMappedChRingAttributes(drvHandle, chHandle->chPrms.mappedChGrp, chHandle->rxChNum, &chAttr);
7009aeb4: 9804         	ldr	r0, [sp, #0x10]
7009aeb6: 9a07         	ldr	r2, [sp, #0x1c]
7009aeb8: 68d1         	ldr	r1, [r2, #0xc]
7009aeba: 6f12         	ldr	r2, [r2, #0x70]
7009aebc: 466b         	mov	r3, sp
7009aebe: f00b f987    	bl	0x700a61d0 <Udma_getMappedChRingAttributes> @ imm = #0xb30e
7009aec2: 9006         	str	r0, [sp, #0x18]
;                         ringNum = chAttr.defaultRing;
7009aec4: 9800         	ldr	r0, [sp]
7009aec6: f8ad 000e    	strh.w	r0, [sp, #0xe]
7009aeca: e7ff         	b	0x7009aecc <Udma_chAllocResource+0x2bc> @ imm = #-0x2
;                 }
7009aecc: e017         	b	0x7009aefe <Udma_chAllocResource+0x2ee> @ imm = #0x2e
;                 else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009aece: 9807         	ldr	r0, [sp, #0x1c]
7009aed0: 7800         	ldrb	r0, [r0]
7009aed2: 07c0         	lsls	r0, r0, #0x1f
7009aed4: b148         	cbz	r0, 0x7009aeea <Udma_chAllocResource+0x2da> @ imm = #0x12
7009aed6: e7ff         	b	0x7009aed8 <Udma_chAllocResource+0x2c8> @ imm = #-0x2
;                     ringNum = (uint16_t)(chHandle->txChNum + drvHandle->txChOffset);
7009aed8: 9807         	ldr	r0, [sp, #0x1c]
7009aeda: 6ec0         	ldr	r0, [r0, #0x6c]
7009aedc: 9904         	ldr	r1, [sp, #0x10]
7009aede: f8d1 110c    	ldr.w	r1, [r1, #0x10c]
7009aee2: 4408         	add	r0, r1
7009aee4: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                 }
7009aee8: e008         	b	0x7009aefc <Udma_chAllocResource+0x2ec> @ imm = #0x10
;                     ringNum = (uint16_t)(chHandle->rxChNum + drvHandle->rxChOffset);
7009aeea: 9807         	ldr	r0, [sp, #0x1c]
7009aeec: 6f00         	ldr	r0, [r0, #0x70]
7009aeee: 9904         	ldr	r1, [sp, #0x10]
7009aef0: f8d1 1114    	ldr.w	r1, [r1, #0x114]
7009aef4: 4408         	add	r0, r1
7009aef6: f8ad 000e    	strh.w	r0, [sp, #0xe]
7009aefa: e7ff         	b	0x7009aefc <Udma_chAllocResource+0x2ec> @ imm = #-0x2
7009aefc: e7ff         	b	0x7009aefe <Udma_chAllocResource+0x2ee> @ imm = #-0x2
7009aefe: e7ff         	b	0x7009af00 <Udma_chAllocResource+0x2f0> @ imm = #-0x2
;             chHandle->fqRing = &chHandle->fqRingObj;
7009af00: 9907         	ldr	r1, [sp, #0x1c]
7009af02: f101 0090    	add.w	r0, r1, #0x90
7009af06: f8c1 0080    	str.w	r0, [r1, #0x80]
;                          drvHandle,
7009af0a: 9804         	ldr	r0, [sp, #0x10]
;                          chHandle->fqRing,
7009af0c: 9b07         	ldr	r3, [sp, #0x1c]
7009af0e: f8d3 1080    	ldr.w	r1, [r3, #0x80]
;                          ringNum,
7009af12: f8bd 200e    	ldrh.w	r2, [sp, #0xe]
;                          &chHandle->chPrms.fqRingPrms);
7009af16: 3314         	adds	r3, #0x14
;             retVal = Udma_ringAlloc(
7009af18: f002 fdb2    	bl	0x7009da80 <Udma_ringAlloc> @ imm = #0x2b64
7009af1c: 9006         	str	r0, [sp, #0x18]
;             if(UDMA_SOK != retVal)
7009af1e: 9806         	ldr	r0, [sp, #0x18]
7009af20: b128         	cbz	r0, 0x7009af2e <Udma_chAllocResource+0x31e> @ imm = #0xa
7009af22: e7ff         	b	0x7009af24 <Udma_chAllocResource+0x314> @ imm = #-0x2
;                 chHandle->fqRing = (Udma_RingHandleInt) NULL_PTR;
7009af24: 9907         	ldr	r1, [sp, #0x1c]
7009af26: 2000         	movs	r0, #0x0
7009af28: f8c1 0080    	str.w	r0, [r1, #0x80]
;             }
7009af2c: e017         	b	0x7009af5e <Udma_chAllocResource+0x34e> @ imm = #0x2e
;             else if(((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED) &&
7009af2e: 9807         	ldr	r0, [sp, #0x1c]
7009af30: 7840         	ldrb	r0, [r0, #0x1]
7009af32: 07c0         	lsls	r0, r0, #0x1f
7009af34: b190         	cbz	r0, 0x7009af5c <Udma_chAllocResource+0x34c> @ imm = #0x24
7009af36: e7ff         	b	0x7009af38 <Udma_chAllocResource+0x328> @ imm = #-0x2
;                     ((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX))
7009af38: 9807         	ldr	r0, [sp, #0x1c]
;             else if(((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED) &&
7009af3a: 7800         	ldrb	r0, [r0]
7009af3c: 0780         	lsls	r0, r0, #0x1e
7009af3e: 2800         	cmp	r0, #0x0
7009af40: d50c         	bpl	0x7009af5c <Udma_chAllocResource+0x34c> @ imm = #0x18
7009af42: e7ff         	b	0x7009af44 <Udma_chAllocResource+0x334> @ imm = #-0x2
;                 chHandle->defaultFlow->flowStart    = chHandle->fqRing->ringNum - drvHandle->rxChOffset;
7009af44: 9907         	ldr	r1, [sp, #0x1c]
7009af46: f8d1 0080    	ldr.w	r0, [r1, #0x80]
7009af4a: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009af4e: 8880         	ldrh	r0, [r0, #0x4]
7009af50: 9a04         	ldr	r2, [sp, #0x10]
7009af52: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009af56: 1a80         	subs	r0, r0, r2
7009af58: 6048         	str	r0, [r1, #0x4]
;             }
7009af5a: e7ff         	b	0x7009af5c <Udma_chAllocResource+0x34c> @ imm = #-0x2
7009af5c: e7ff         	b	0x7009af5e <Udma_chAllocResource+0x34e> @ imm = #-0x2
;         }
7009af5e: e7ff         	b	0x7009af60 <Udma_chAllocResource+0x350> @ imm = #-0x2
;     }
7009af60: e7ff         	b	0x7009af62 <Udma_chAllocResource+0x352> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009af62: 9806         	ldr	r0, [sp, #0x18]
7009af64: b930         	cbnz	r0, 0x7009af74 <Udma_chAllocResource+0x364> @ imm = #0xc
7009af66: e7ff         	b	0x7009af68 <Udma_chAllocResource+0x358> @ imm = #-0x2
;         chHandle->cqRing = &chHandle->fqRingObj;
7009af68: 9907         	ldr	r1, [sp, #0x1c]
7009af6a: f101 0090    	add.w	r0, r1, #0x90
7009af6e: f8c1 0084    	str.w	r0, [r1, #0x84]
;     }
7009af72: e7ff         	b	0x7009af74 <Udma_chAllocResource+0x364> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009af74: 9806         	ldr	r0, [sp, #0x18]
7009af76: b928         	cbnz	r0, 0x7009af84 <Udma_chAllocResource+0x374> @ imm = #0xa
7009af78: e7ff         	b	0x7009af7a <Udma_chAllocResource+0x36a> @ imm = #-0x2
;         chHandle->tdCqRing = (Udma_RingHandleInt) NULL_PTR;
7009af7a: 9907         	ldr	r1, [sp, #0x1c]
7009af7c: 2000         	movs	r0, #0x0
7009af7e: f8c1 0088    	str.w	r0, [r1, #0x88]
;     }
7009af82: e7ff         	b	0x7009af84 <Udma_chAllocResource+0x374> @ imm = #-0x2
;     if(UDMA_SOK != retVal)
7009af84: 9806         	ldr	r0, [sp, #0x18]
7009af86: b148         	cbz	r0, 0x7009af9c <Udma_chAllocResource+0x38c> @ imm = #0x12
7009af88: e7ff         	b	0x7009af8a <Udma_chAllocResource+0x37a> @ imm = #-0x2
;         tempRetVal = Udma_chFreeResource(chHandle);
7009af8a: 9807         	ldr	r0, [sp, #0x1c]
7009af8c: f002 fc70    	bl	0x7009d870 <Udma_chFreeResource> @ imm = #0x28e0
7009af90: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK != tempRetVal)
7009af92: 9805         	ldr	r0, [sp, #0x14]
7009af94: b108         	cbz	r0, 0x7009af9a <Udma_chAllocResource+0x38a> @ imm = #0x2
7009af96: e7ff         	b	0x7009af98 <Udma_chAllocResource+0x388> @ imm = #-0x2
;         }
7009af98: e7ff         	b	0x7009af9a <Udma_chAllocResource+0x38a> @ imm = #-0x2
;     }
7009af9a: e004         	b	0x7009afa6 <Udma_chAllocResource+0x396> @ imm = #0x8
;         Udma_chAssignRegOverlay(drvHandle, chHandle);
7009af9c: 9804         	ldr	r0, [sp, #0x10]
7009af9e: 9907         	ldr	r1, [sp, #0x1c]
7009afa0: f005 fd26    	bl	0x700a09f0 <Udma_chAssignRegOverlay> @ imm = #0x5a4c
7009afa4: e7ff         	b	0x7009afa6 <Udma_chAllocResource+0x396> @ imm = #-0x2
;     return (retVal);
7009afa6: 9806         	ldr	r0, [sp, #0x18]
7009afa8: b008         	add	sp, #0x20
7009afaa: bd80         	pop	{r7, pc}
7009afac: 0000         	movs	r0, r0
7009afae: 0000         	movs	r0, r0

7009afb0 <CSL_REG32_WR_RAW>:
; {
7009afb0: b082         	sub	sp, #0x8
7009afb2: 9001         	str	r0, [sp, #0x4]
7009afb4: 9100         	str	r1, [sp]
;     *p = v;
7009afb6: 9800         	ldr	r0, [sp]
7009afb8: 9901         	ldr	r1, [sp, #0x4]
7009afba: 6008         	str	r0, [r1]
;     return;
7009afbc: b002         	add	sp, #0x8
7009afbe: 4770         	bx	lr

7009afc0 <strcmp>:
7009afc0: e5d02000     	ldrb	r2, [r0]
7009afc4: e5d13000     	ldrb	r3, [r1]
7009afc8: e3520001     	cmp	r2, #1
7009afcc: 21520003     	cmphs	r2, r3
7009afd0: 1a004c52     	bne	0x700ae120 <.Lfastpath_exit> @ imm = #0x13148
7009afd4: e16d41f0     	strd	r4, r5, [sp, #-16]!
7009afd8: e1804001     	orr	r4, r0, r1
7009afdc: e1cd60f8     	strd	r6, r7, [sp, #8]
7009afe0: e3e0c000     	mvn	r12, #0
7009afe4: e1a02e84     	lsl	r2, r4, #29
7009afe8: e3520000     	cmp	r2, #0
7009afec: 0a000013     	beq	0x7009b040 <strcmp+0x80> @ imm = #0x4c
7009aff0: e0204001     	eor	r4, r0, r1
7009aff4: e3140007     	tst	r4, #7
7009aff8: 1a00003e     	bne	0x7009b0f8 <strcmp+0x138> @ imm = #0xf8
7009affc: e2004007     	and	r4, r0, #7
7009b000: e3c00007     	bic	r0, r0, #7
7009b004: e2045003     	and	r5, r4, #3
7009b008: e3c11007     	bic	r1, r1, #7
7009b00c: e1a05185     	lsl	r5, r5, #3
7009b010: e0c021d0     	ldrd	r2, r3, [r0], #16
7009b014: e3140004     	tst	r4, #4
7009b018: e0c161d0     	ldrd	r6, r7, [r1], #16
7009b01c: e1e0451c     	mvn	r4, r12, lsl r5
7009b020: e1822004     	orr	r2, r2, r4
7009b024: e1866004     	orr	r6, r6, r4
7009b028: 0a000006     	beq	0x7009b048 <strcmp+0x88> @ imm = #0x18
7009b02c: e1833004     	orr	r3, r3, r4
7009b030: e1a0200c     	mov	r2, r12
7009b034: e1877004     	orr	r7, r7, r4
7009b038: e1a0600c     	mov	r6, r12
7009b03c: ea000001     	b	0x7009b048 <strcmp+0x88> @ imm = #0x4
7009b040: e0c021d0     	ldrd	r2, r3, [r0], #16
7009b044: e0c161d0     	ldrd	r6, r7, [r1], #16
7009b048: e6525f9c     	uadd8	r5, r2, r12
7009b04c: e0224006     	eor	r4, r2, r6
7009b050: e6844fbc     	sel	r4, r4, r12
7009b054: e3540000     	cmp	r4, #0
7009b058: 1a00001b     	bne	0x7009b0cc <strcmp+0x10c> @ imm = #0x6c
7009b05c: e6535f9c     	uadd8	r5, r3, r12
7009b060: e0235007     	eor	r5, r3, r7
7009b064: e6855fbc     	sel	r5, r5, r12
7009b068: e3550000     	cmp	r5, #0
7009b06c: 1a00000b     	bne	0x7009b0a0 <strcmp+0xe0> @ imm = #0x2c
7009b070: e14020d8     	ldrd	r2, r3, [r0, #-8]
7009b074: e14160d8     	ldrd	r6, r7, [r1, #-8]
7009b078: e6525f9c     	uadd8	r5, r2, r12
7009b07c: e0224006     	eor	r4, r2, r6
7009b080: e6844fbc     	sel	r4, r4, r12
7009b084: e6535f9c     	uadd8	r5, r3, r12
7009b088: e0235007     	eor	r5, r3, r7
7009b08c: e6855fbc     	sel	r5, r5, r12
7009b090: e1955004     	orrs	r5, r5, r4
7009b094: 0affffe9     	beq	0x7009b040 <strcmp+0x80> @ imm = #-0x5c
7009b098: e3540000     	cmp	r4, #0
7009b09c: 1a00000a     	bne	0x7009b0cc <strcmp+0x10c> @ imm = #0x28
7009b0a0: e6bf5f35     	rev	r5, r5
7009b0a4: e16f4f15     	clz	r4, r5
7009b0a8: e3c44007     	bic	r4, r4, #7
7009b0ac: e1a01437     	lsr	r1, r7, r4
7009b0b0: e1cd60d8     	ldrd	r6, r7, [sp, #8]
7009b0b4: e1a03433     	lsr	r3, r3, r4
7009b0b8: e20300ff     	and	r0, r3, #255
7009b0bc: e20110ff     	and	r1, r1, #255
7009b0c0: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009b0c4: e0400001     	sub	r0, r0, r1
7009b0c8: e12fff1e     	bx	lr
7009b0cc: e6bf4f34     	rev	r4, r4
7009b0d0: e16f4f14     	clz	r4, r4
7009b0d4: e3c44007     	bic	r4, r4, #7
7009b0d8: e1a01436     	lsr	r1, r6, r4
7009b0dc: e1cd60d8     	ldrd	r6, r7, [sp, #8]
7009b0e0: e1a02432     	lsr	r2, r2, r4
7009b0e4: e20200ff     	and	r0, r2, #255
7009b0e8: e20110ff     	and	r1, r1, #255
7009b0ec: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009b0f0: e0400001     	sub	r0, r0, r1
7009b0f4: e12fff1e     	bx	lr
7009b0f8: e3140003     	tst	r4, #3
7009b0fc: 1a000022     	bne	0x7009b18c <strcmp+0x1cc> @ imm = #0x88
7009b100: e2104003     	ands	r4, r0, #3
7009b104: 1a000017     	bne	0x7009b168 <strcmp+0x1a8> @ imm = #0x5c
7009b108: e4902008     	ldr	r2, [r0], #8
7009b10c: e4913008     	ldr	r3, [r1], #8
7009b110: e6525f9c     	uadd8	r5, r2, r12
7009b114: e0225003     	eor	r5, r2, r3
7009b118: e6855fbc     	sel	r5, r5, r12
7009b11c: e3550000     	cmp	r5, #0
7009b120: 1a000006     	bne	0x7009b140 <strcmp+0x180> @ imm = #0x18
7009b124: e5102004     	ldr	r2, [r0, #-0x4]
7009b128: e5113004     	ldr	r3, [r1, #-0x4]
7009b12c: e6525f9c     	uadd8	r5, r2, r12
7009b130: e0225003     	eor	r5, r2, r3
7009b134: e6855fbc     	sel	r5, r5, r12
7009b138: e3550000     	cmp	r5, #0
7009b13c: 0afffff1     	beq	0x7009b108 <strcmp+0x148> @ imm = #-0x3c
7009b140: e6bf5f35     	rev	r5, r5
7009b144: e16f4f15     	clz	r4, r5
7009b148: e3c44007     	bic	r4, r4, #7
7009b14c: e1a01433     	lsr	r1, r3, r4
7009b150: e1a02432     	lsr	r2, r2, r4
7009b154: e20200ff     	and	r0, r2, #255
7009b158: e20110ff     	and	r1, r1, #255
7009b15c: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009b160: e0400001     	sub	r0, r0, r1
7009b164: e12fff1e     	bx	lr
7009b168: e1a04184     	lsl	r4, r4, #3
7009b16c: e3c00003     	bic	r0, r0, #3
7009b170: e4902008     	ldr	r2, [r0], #8
7009b174: e3c11003     	bic	r1, r1, #3
7009b178: e4913008     	ldr	r3, [r1], #8
7009b17c: e1e0441c     	mvn	r4, r12, lsl r4
7009b180: e1822004     	orr	r2, r2, r4
7009b184: e1833004     	orr	r3, r3, r4
7009b188: eaffffe0     	b	0x7009b110 <strcmp+0x150> @ imm = #-0x80
7009b18c: e2104003     	ands	r4, r0, #3
7009b190: 0a000015     	beq	0x7009b1ec <strcmp+0x22c> @ imm = #0x54
7009b194: e0411004     	sub	r1, r1, r4
7009b198: e3c00003     	bic	r0, r0, #3
7009b19c: e1b04f84     	lsls	r4, r4, #31
7009b1a0: e4902004     	ldr	r2, [r0], #4
7009b1a4: 0a000006     	beq	0x7009b1c4 <strcmp+0x204> @ imm = #0x18
7009b1a8: 2a00000e     	bhs	0x7009b1e8 <strcmp+0x228> @ imm = #0x38
7009b1ac: e5d13002     	ldrb	r3, [r1, #0x2]
7009b1b0: e6ef4872     	uxtb	r4, r2, ror #16
7009b1b4: e0544003     	subs	r4, r4, r3
7009b1b8: 1a000007     	bne	0x7009b1dc <strcmp+0x21c> @ imm = #0x1c
7009b1bc: e3530000     	cmp	r3, #0
7009b1c0: 0a000005     	beq	0x7009b1dc <strcmp+0x21c> @ imm = #0x14
7009b1c4: e5d13003     	ldrb	r3, [r1, #0x3]
7009b1c8: e6ef4c72     	uxtb	r4, r2, ror #24
7009b1cc: e0544003     	subs	r4, r4, r3
7009b1d0: 1a000001     	bne	0x7009b1dc <strcmp+0x21c> @ imm = #0x4
7009b1d4: e3530000     	cmp	r3, #0
7009b1d8: 1a000002     	bne	0x7009b1e8 <strcmp+0x228> @ imm = #0x8
7009b1dc: e1a00004     	mov	r0, r4
7009b1e0: e49d4010     	ldr	r4, [sp], #16
7009b1e4: e12fff1e     	bx	lr
7009b1e8: e2811004     	add	r1, r1, #4
7009b1ec: e4902004     	ldr	r2, [r0], #4
7009b1f0: e1b04f81     	lsls	r4, r1, #31
7009b1f4: e3c11003     	bic	r1, r1, #3
7009b1f8: e4913004     	ldr	r3, [r1], #4
7009b1fc: 8a00002f     	bhi	0x7009b2c0 <strcmp+0x300> @ imm = #0xbc
7009b200: 2a000017     	bhs	0x7009b264 <strcmp+0x2a4> @ imm = #0x5c
7009b204: e3c244ff     	bic	r4, r2, #-16777216
7009b208: e6525f9c     	uadd8	r5, r2, r12
7009b20c: e0345423     	eors	r5, r4, r3, lsr #8
7009b210: e6855fbc     	sel	r5, r5, r12
7009b214: 1a000007     	bne	0x7009b238 <strcmp+0x278> @ imm = #0x1c
7009b218: e3550000     	cmp	r5, #0
7009b21c: 1a000007     	bne	0x7009b240 <strcmp+0x280> @ imm = #0x1c
7009b220: e4913004     	ldr	r3, [r1], #4
7009b224: e0244002     	eor	r4, r4, r2
7009b228: e1540c03     	cmp	r4, r3, lsl #24
7009b22c: 1a000009     	bne	0x7009b258 <strcmp+0x298> @ imm = #0x24
7009b230: e4902004     	ldr	r2, [r0], #4
7009b234: eafffff2     	b	0x7009b204 <strcmp+0x244> @ imm = #-0x38
7009b238: e1a03423     	lsr	r3, r3, #8
7009b23c: ea000037     	b	0x7009b320 <strcmp+0x360> @ imm = #0xdc
7009b240: e3d554ff     	bics	r5, r5, #-16777216
7009b244: 1a000032     	bne	0x7009b314 <strcmp+0x354> @ imm = #0xc8
7009b248: e5d10000     	ldrb	r0, [r1]
7009b24c: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009b250: e2600000     	rsb	r0, r0, #0
7009b254: e12fff1e     	bx	lr
7009b258: e1a02c22     	lsr	r2, r2, #24
7009b25c: e20330ff     	and	r3, r3, #255
7009b260: ea00002e     	b	0x7009b320 <strcmp+0x360> @ imm = #0xb8
7009b264: e002482c     	and	r4, r2, r12, lsr #16
7009b268: e6525f9c     	uadd8	r5, r2, r12
7009b26c: e0345823     	eors	r5, r4, r3, lsr #16
7009b270: e6855fbc     	sel	r5, r5, r12
7009b274: 1a000007     	bne	0x7009b298 <strcmp+0x2d8> @ imm = #0x1c
7009b278: e3550000     	cmp	r5, #0
7009b27c: 1a000007     	bne	0x7009b2a0 <strcmp+0x2e0> @ imm = #0x1c
7009b280: e4913004     	ldr	r3, [r1], #4
7009b284: e0244002     	eor	r4, r4, r2
7009b288: e1540803     	cmp	r4, r3, lsl #16
7009b28c: 1a000008     	bne	0x7009b2b4 <strcmp+0x2f4> @ imm = #0x20
7009b290: e4902004     	ldr	r2, [r0], #4
7009b294: eafffff2     	b	0x7009b264 <strcmp+0x2a4> @ imm = #-0x38
7009b298: e1a03823     	lsr	r3, r3, #16
7009b29c: ea00001f     	b	0x7009b320 <strcmp+0x360> @ imm = #0x7c
7009b2a0: e015582c     	ands	r5, r5, r12, lsr #16
7009b2a4: 1a00001a     	bne	0x7009b314 <strcmp+0x354> @ imm = #0x68
7009b2a8: e1d130b0     	ldrh	r3, [r1]
7009b2ac: e1a02822     	lsr	r2, r2, #16
7009b2b0: ea00001a     	b	0x7009b320 <strcmp+0x360> @ imm = #0x68
7009b2b4: e1a02822     	lsr	r2, r2, #16
7009b2b8: e003382c     	and	r3, r3, r12, lsr #16
7009b2bc: ea000017     	b	0x7009b320 <strcmp+0x360> @ imm = #0x5c
7009b2c0: e20240ff     	and	r4, r2, #255
7009b2c4: e6525f9c     	uadd8	r5, r2, r12
7009b2c8: e0345c23     	eors	r5, r4, r3, lsr #24
7009b2cc: e6855fbc     	sel	r5, r5, r12
7009b2d0: 1a000007     	bne	0x7009b2f4 <strcmp+0x334> @ imm = #0x1c
7009b2d4: e3550000     	cmp	r5, #0
7009b2d8: 1a000007     	bne	0x7009b2fc <strcmp+0x33c> @ imm = #0x1c
7009b2dc: e4913004     	ldr	r3, [r1], #4
7009b2e0: e0244002     	eor	r4, r4, r2
7009b2e4: e1540403     	cmp	r4, r3, lsl #8
7009b2e8: 1a000006     	bne	0x7009b308 <strcmp+0x348> @ imm = #0x18
7009b2ec: e4902004     	ldr	r2, [r0], #4
7009b2f0: eafffff2     	b	0x7009b2c0 <strcmp+0x300> @ imm = #-0x38
7009b2f4: e1a03c23     	lsr	r3, r3, #24
7009b2f8: ea000008     	b	0x7009b320 <strcmp+0x360> @ imm = #0x20
7009b2fc: e31500ff     	tst	r5, #255
7009b300: 1a000003     	bne	0x7009b314 <strcmp+0x354> @ imm = #0xc
7009b304: e5913000     	ldr	r3, [r1]
7009b308: e1a02422     	lsr	r2, r2, #8
7009b30c: e3c334ff     	bic	r3, r3, #-16777216
7009b310: ea000002     	b	0x7009b320 <strcmp+0x360> @ imm = #0x8
7009b314: e3a00000     	mov	r0, #0
7009b318: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009b31c: e12fff1e     	bx	lr
7009b320: e6bf2f32     	rev	r2, r2
7009b324: e6bf3f33     	rev	r3, r3
7009b328: e6524f9c     	uadd8	r4, r2, r12
7009b32c: e0224003     	eor	r4, r2, r3
7009b330: e6845fbc     	sel	r5, r4, r12
7009b334: e16f4f15     	clz	r4, r5
7009b338: e1a02412     	lsl	r2, r2, r4
7009b33c: e1a03413     	lsl	r3, r3, r4
7009b340: e1a00c22     	lsr	r0, r2, #24
7009b344: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009b348: e0400c23     	sub	r0, r0, r3, lsr #24
7009b34c: e12fff1e     	bx	lr

7009b350 <Udma_chDisableTxChan>:
; {
7009b350: b580         	push	{r7, lr}
7009b352: b09a         	sub	sp, #0x68
7009b354: 9019         	str	r0, [sp, #0x64]
7009b356: 9118         	str	r1, [sp, #0x60]
7009b358: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009b35a: 9017         	str	r0, [sp, #0x5c]
;     uint32_t            peerRtEnable = 0U, currTimeout = 0U;
7009b35c: 9016         	str	r0, [sp, #0x58]
7009b35e: 9015         	str	r0, [sp, #0x54]
;     drvHandle = chHandle->drvHandle;
7009b360: 9819         	ldr	r0, [sp, #0x64]
7009b362: 6e80         	ldr	r0, [r0, #0x68]
7009b364: 9014         	str	r0, [sp, #0x50]
7009b366: 2008         	movs	r0, #0x8
;     rtEnableRegOffset = CSL_PSILCFG_REG_RT_ENABLE - CSL_PSILCFG_REG_STATIC_TR;
7009b368: 9008         	str	r0, [sp, #0x20]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b36a: 9814         	ldr	r0, [sp, #0x50]
7009b36c: 6800         	ldr	r0, [r0]
7009b36e: 2801         	cmp	r0, #0x1
7009b370: d10e         	bne	0x7009b390 <Udma_chDisableTxChan+0x40> @ imm = #0x1c
7009b372: e7ff         	b	0x7009b374 <Udma_chDisableTxChan+0x24> @ imm = #-0x2
;                  &drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, (bool)false, (bool)false);
7009b374: 9a14         	ldr	r2, [sp, #0x50]
7009b376: f102 0008    	add.w	r0, r2, #0x8
7009b37a: 9919         	ldr	r1, [sp, #0x64]
7009b37c: 6ec9         	ldr	r1, [r1, #0x6c]
7009b37e: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b382: 4411         	add	r1, r2
7009b384: 2300         	movs	r3, #0x0
;         retVal = CSL_bcdmaTeardownTxChan(
7009b386: 461a         	mov	r2, r3
7009b388: f010 fc02    	bl	0x700abb90 <CSL_bcdmaTeardownTxChan> @ imm = #0x10804
7009b38c: 9017         	str	r0, [sp, #0x5c]
;     }
7009b38e: e00f         	b	0x7009b3b0 <Udma_chDisableTxChan+0x60> @ imm = #0x1e
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b390: 9814         	ldr	r0, [sp, #0x50]
7009b392: 6800         	ldr	r0, [r0]
7009b394: 2802         	cmp	r0, #0x2
7009b396: d10a         	bne	0x7009b3ae <Udma_chDisableTxChan+0x5e> @ imm = #0x14
7009b398: e7ff         	b	0x7009b39a <Udma_chDisableTxChan+0x4a> @ imm = #-0x2
;                  &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009b39a: 9814         	ldr	r0, [sp, #0x50]
7009b39c: 3054         	adds	r0, #0x54
7009b39e: 9919         	ldr	r1, [sp, #0x64]
7009b3a0: 6ec9         	ldr	r1, [r1, #0x6c]
7009b3a2: 2300         	movs	r3, #0x0
;         retVal = CSL_pktdmaTeardownTxChan(
7009b3a4: 461a         	mov	r2, r3
7009b3a6: f011 fabb    	bl	0x700ac920 <CSL_pktdmaTeardownTxChan> @ imm = #0x11576
7009b3aa: 9017         	str	r0, [sp, #0x5c]
;     }
7009b3ac: e7ff         	b	0x7009b3ae <Udma_chDisableTxChan+0x5e> @ imm = #-0x2
7009b3ae: e7ff         	b	0x7009b3b0 <Udma_chDisableTxChan+0x60> @ imm = #-0x2
;     if(CSL_PASS != retVal)
7009b3b0: 9817         	ldr	r0, [sp, #0x5c]
7009b3b2: b108         	cbz	r0, 0x7009b3b8 <Udma_chDisableTxChan+0x68> @ imm = #0x2
7009b3b4: e7ff         	b	0x7009b3b6 <Udma_chDisableTxChan+0x66> @ imm = #-0x2
;     }
7009b3b6: e7ff         	b	0x7009b3b8 <Udma_chDisableTxChan+0x68> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009b3b8: e7ff         	b	0x7009b3ba <Udma_chDisableTxChan+0x6a> @ imm = #-0x2
7009b3ba: 9817         	ldr	r0, [sp, #0x5c]
7009b3bc: bbc8         	cbnz	r0, 0x7009b432 <Udma_chDisableTxChan+0xe2> @ imm = #0x72
7009b3be: e7ff         	b	0x7009b3c0 <Udma_chDisableTxChan+0x70> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b3c0: 9814         	ldr	r0, [sp, #0x50]
7009b3c2: 6800         	ldr	r0, [r0]
7009b3c4: 2801         	cmp	r0, #0x1
7009b3c6: d110         	bne	0x7009b3ea <Udma_chDisableTxChan+0x9a> @ imm = #0x20
7009b3c8: e7ff         	b	0x7009b3ca <Udma_chDisableTxChan+0x7a> @ imm = #-0x2
;             (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009b3ca: 9a14         	ldr	r2, [sp, #0x50]
7009b3cc: f102 0008    	add.w	r0, r2, #0x8
7009b3d0: 9919         	ldr	r1, [sp, #0x64]
7009b3d2: 6ec9         	ldr	r1, [r1, #0x6c]
7009b3d4: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b3d8: 4411         	add	r1, r2
7009b3da: aa0e         	add	r2, sp, #0x38
7009b3dc: f011 fda0    	bl	0x700acf20 <CSL_bcdmaGetTxRT> @ imm = #0x11b40
;             if(FALSE == bcdmaRtStatus.enable)
7009b3e0: 980e         	ldr	r0, [sp, #0x38]
7009b3e2: b908         	cbnz	r0, 0x7009b3e8 <Udma_chDisableTxChan+0x98> @ imm = #0x2
7009b3e4: e7ff         	b	0x7009b3e6 <Udma_chDisableTxChan+0x96> @ imm = #-0x2
;                 break;
7009b3e6: e024         	b	0x7009b432 <Udma_chDisableTxChan+0xe2> @ imm = #0x48
;         }
7009b3e8: e011         	b	0x7009b40e <Udma_chDisableTxChan+0xbe> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b3ea: 9814         	ldr	r0, [sp, #0x50]
7009b3ec: 6800         	ldr	r0, [r0]
7009b3ee: 2802         	cmp	r0, #0x2
7009b3f0: d10c         	bne	0x7009b40c <Udma_chDisableTxChan+0xbc> @ imm = #0x18
7009b3f2: e7ff         	b	0x7009b3f4 <Udma_chDisableTxChan+0xa4> @ imm = #-0x2
;             (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009b3f4: 9814         	ldr	r0, [sp, #0x50]
7009b3f6: 3054         	adds	r0, #0x54
7009b3f8: 9919         	ldr	r1, [sp, #0x64]
7009b3fa: 6ec9         	ldr	r1, [r1, #0x6c]
7009b3fc: aa09         	add	r2, sp, #0x24
7009b3fe: f010 fa37    	bl	0x700ab870 <CSL_pktdmaGetTxRT> @ imm = #0x1046e
;             if(FALSE == pktdmaRtStatus.enable)
7009b402: 9809         	ldr	r0, [sp, #0x24]
7009b404: b908         	cbnz	r0, 0x7009b40a <Udma_chDisableTxChan+0xba> @ imm = #0x2
7009b406: e7ff         	b	0x7009b408 <Udma_chDisableTxChan+0xb8> @ imm = #-0x2
;                 break;
7009b408: e013         	b	0x7009b432 <Udma_chDisableTxChan+0xe2> @ imm = #0x26
;         }
7009b40a: e7ff         	b	0x7009b40c <Udma_chDisableTxChan+0xbc> @ imm = #-0x2
7009b40c: e7ff         	b	0x7009b40e <Udma_chDisableTxChan+0xbe> @ imm = #-0x2
;         if(currTimeout > timeout)
7009b40e: 9815         	ldr	r0, [sp, #0x54]
7009b410: 9918         	ldr	r1, [sp, #0x60]
7009b412: 4288         	cmp	r0, r1
7009b414: d904         	bls	0x7009b420 <Udma_chDisableTxChan+0xd0> @ imm = #0x8
7009b416: e7ff         	b	0x7009b418 <Udma_chDisableTxChan+0xc8> @ imm = #-0x2
7009b418: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009b41c: 9017         	str	r0, [sp, #0x5c]
;         }
7009b41e: e007         	b	0x7009b430 <Udma_chDisableTxChan+0xe0> @ imm = #0xe
7009b420: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009b424: f00e f8bc    	bl	0x700a95a0 <ClockP_usleep> @ imm = #0xe178
;             currTimeout++;
7009b428: 9815         	ldr	r0, [sp, #0x54]
7009b42a: 3001         	adds	r0, #0x1
7009b42c: 9015         	str	r0, [sp, #0x54]
7009b42e: e7ff         	b	0x7009b430 <Udma_chDisableTxChan+0xe0> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009b430: e7c3         	b	0x7009b3ba <Udma_chDisableTxChan+0x6a> @ imm = #-0x7a
;     if(UDMA_SOK != retVal)
7009b432: 9817         	ldr	r0, [sp, #0x5c]
7009b434: 2800         	cmp	r0, #0x0
7009b436: f000 80e4    	beq.w	0x7009b602 <Udma_chDisableTxChan+0x2b2> @ imm = #0x1c8
7009b43a: e7ff         	b	0x7009b43c <Udma_chDisableTxChan+0xec> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b43c: 9814         	ldr	r0, [sp, #0x50]
7009b43e: 6800         	ldr	r0, [r0]
7009b440: 2801         	cmp	r0, #0x1
7009b442: d10e         	bne	0x7009b462 <Udma_chDisableTxChan+0x112> @ imm = #0x1c
7009b444: e7ff         	b	0x7009b446 <Udma_chDisableTxChan+0xf6> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, (bool)true, (bool)false);
7009b446: 9a14         	ldr	r2, [sp, #0x50]
7009b448: f102 0008    	add.w	r0, r2, #0x8
7009b44c: 9919         	ldr	r1, [sp, #0x64]
7009b44e: 6ec9         	ldr	r1, [r1, #0x6c]
7009b450: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b454: 4411         	add	r1, r2
7009b456: 2201         	movs	r2, #0x1
7009b458: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownTxChan(
7009b45a: f010 fb99    	bl	0x700abb90 <CSL_bcdmaTeardownTxChan> @ imm = #0x10732
7009b45e: 9017         	str	r0, [sp, #0x5c]
;         }
7009b460: e00f         	b	0x7009b482 <Udma_chDisableTxChan+0x132> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b462: 9814         	ldr	r0, [sp, #0x50]
7009b464: 6800         	ldr	r0, [r0]
7009b466: 2802         	cmp	r0, #0x2
7009b468: d10a         	bne	0x7009b480 <Udma_chDisableTxChan+0x130> @ imm = #0x14
7009b46a: e7ff         	b	0x7009b46c <Udma_chDisableTxChan+0x11c> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009b46c: 9814         	ldr	r0, [sp, #0x50]
7009b46e: 3054         	adds	r0, #0x54
7009b470: 9919         	ldr	r1, [sp, #0x64]
7009b472: 6ec9         	ldr	r1, [r1, #0x6c]
7009b474: 2201         	movs	r2, #0x1
7009b476: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownTxChan(
7009b478: f011 fa52    	bl	0x700ac920 <CSL_pktdmaTeardownTxChan> @ imm = #0x114a4
7009b47c: 9017         	str	r0, [sp, #0x5c]
;         }
7009b47e: e7ff         	b	0x7009b480 <Udma_chDisableTxChan+0x130> @ imm = #-0x2
7009b480: e7ff         	b	0x7009b482 <Udma_chDisableTxChan+0x132> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009b482: 9817         	ldr	r0, [sp, #0x5c]
7009b484: b108         	cbz	r0, 0x7009b48a <Udma_chDisableTxChan+0x13a> @ imm = #0x2
7009b486: e7ff         	b	0x7009b488 <Udma_chDisableTxChan+0x138> @ imm = #-0x2
;         }
7009b488: e7ff         	b	0x7009b48a <Udma_chDisableTxChan+0x13a> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b48a: 9814         	ldr	r0, [sp, #0x50]
7009b48c: 6800         	ldr	r0, [r0]
7009b48e: 2801         	cmp	r0, #0x1
7009b490: d128         	bne	0x7009b4e4 <Udma_chDisableTxChan+0x194> @ imm = #0x50
7009b492: e7ff         	b	0x7009b494 <Udma_chDisableTxChan+0x144> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs,
7009b494: 9a14         	ldr	r2, [sp, #0x50]
7009b496: f102 0008    	add.w	r0, r2, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009b49a: 9919         	ldr	r1, [sp, #0x64]
7009b49c: 6ec9         	ldr	r1, [r1, #0x6c]
7009b49e: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b4a2: 4411         	add	r1, r2
;                 rtEnableRegOffset,
7009b4a4: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaGetChanPeerReg(
7009b4a6: 46ec         	mov	r12, sp
7009b4a8: aa16         	add	r2, sp, #0x58
7009b4aa: 9206         	str	r2, [sp, #0x18]
7009b4ac: f8cc 2000    	str.w	r2, [r12]
7009b4b0: 2200         	movs	r2, #0x0
7009b4b2: 9207         	str	r2, [sp, #0x1c]
7009b4b4: f010 fc34    	bl	0x700abd20 <CSL_bcdmaGetChanPeerReg> @ imm = #0x10868
7009b4b8: f8dd c018    	ldr.w	r12, [sp, #0x18]
7009b4bc: 9a07         	ldr	r2, [sp, #0x1c]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_FLUSH, (uint32_t) 1U);
7009b4be: 9816         	ldr	r0, [sp, #0x58]
7009b4c0: f040 5080    	orr	r0, r0, #0x10000000
7009b4c4: 9016         	str	r0, [sp, #0x58]
;                 &drvHandle->bcdmaRegs,
7009b4c6: 9b14         	ldr	r3, [sp, #0x50]
7009b4c8: f103 0008    	add.w	r0, r3, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009b4cc: 9919         	ldr	r1, [sp, #0x64]
7009b4ce: 6ec9         	ldr	r1, [r1, #0x6c]
7009b4d0: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
7009b4d4: 4419         	add	r1, r3
;                 rtEnableRegOffset,
7009b4d6: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaSetChanPeerReg(
7009b4d8: 46ee         	mov	lr, sp
7009b4da: f8ce c000    	str.w	r12, [lr]
7009b4de: f010 ff1f    	bl	0x700ac320 <CSL_bcdmaSetChanPeerReg> @ imm = #0x10e3e
;         }
7009b4e2: e025         	b	0x7009b530 <Udma_chDisableTxChan+0x1e0> @ imm = #0x4a
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b4e4: 9814         	ldr	r0, [sp, #0x50]
7009b4e6: 6800         	ldr	r0, [r0]
7009b4e8: 2802         	cmp	r0, #0x2
7009b4ea: d120         	bne	0x7009b52e <Udma_chDisableTxChan+0x1de> @ imm = #0x40
7009b4ec: e7ff         	b	0x7009b4ee <Udma_chDisableTxChan+0x19e> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs,
7009b4ee: 9814         	ldr	r0, [sp, #0x50]
7009b4f0: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009b4f2: 9919         	ldr	r1, [sp, #0x64]
7009b4f4: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009b4f6: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaGetChanPeerReg(
7009b4f8: 46ec         	mov	r12, sp
7009b4fa: aa16         	add	r2, sp, #0x58
7009b4fc: 9204         	str	r2, [sp, #0x10]
7009b4fe: f8cc 2000    	str.w	r2, [r12]
7009b502: 2200         	movs	r2, #0x0
7009b504: 9205         	str	r2, [sp, #0x14]
7009b506: f011 fba3    	bl	0x700acc50 <CSL_pktdmaGetChanPeerReg> @ imm = #0x11746
7009b50a: f8dd c010    	ldr.w	r12, [sp, #0x10]
7009b50e: 9a05         	ldr	r2, [sp, #0x14]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_FLUSH, (uint32_t) 1U);
7009b510: 9816         	ldr	r0, [sp, #0x58]
7009b512: f040 5080    	orr	r0, r0, #0x10000000
7009b516: 9016         	str	r0, [sp, #0x58]
;                 &drvHandle->pktdmaRegs,
7009b518: 9814         	ldr	r0, [sp, #0x50]
7009b51a: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009b51c: 9919         	ldr	r1, [sp, #0x64]
7009b51e: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009b520: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaSetChanPeerReg(
7009b522: 46ee         	mov	lr, sp
7009b524: f8ce c000    	str.w	r12, [lr]
7009b528: f011 fbaa    	bl	0x700acc80 <CSL_pktdmaSetChanPeerReg> @ imm = #0x11754
;         }
7009b52c: e7ff         	b	0x7009b52e <Udma_chDisableTxChan+0x1de> @ imm = #-0x2
7009b52e: e7ff         	b	0x7009b530 <Udma_chDisableTxChan+0x1e0> @ imm = #-0x2
7009b530: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009b532: 9015         	str	r0, [sp, #0x54]
;         while(UDMA_SOK == retVal)
7009b534: e7ff         	b	0x7009b536 <Udma_chDisableTxChan+0x1e6> @ imm = #-0x2
7009b536: 9817         	ldr	r0, [sp, #0x5c]
7009b538: 2800         	cmp	r0, #0x0
7009b53a: d161         	bne	0x7009b600 <Udma_chDisableTxChan+0x2b0> @ imm = #0xc2
7009b53c: e7ff         	b	0x7009b53e <Udma_chDisableTxChan+0x1ee> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b53e: 9814         	ldr	r0, [sp, #0x50]
7009b540: 6800         	ldr	r0, [r0]
7009b542: 2801         	cmp	r0, #0x1
7009b544: d126         	bne	0x7009b594 <Udma_chDisableTxChan+0x244> @ imm = #0x4c
7009b546: e7ff         	b	0x7009b548 <Udma_chDisableTxChan+0x1f8> @ imm = #-0x2
;                 (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009b548: 9a14         	ldr	r2, [sp, #0x50]
7009b54a: f102 0008    	add.w	r0, r2, #0x8
7009b54e: 9919         	ldr	r1, [sp, #0x64]
7009b550: 6ec9         	ldr	r1, [r1, #0x6c]
7009b552: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b556: 4411         	add	r1, r2
7009b558: aa0e         	add	r2, sp, #0x38
7009b55a: f011 fce1    	bl	0x700acf20 <CSL_bcdmaGetTxRT> @ imm = #0x119c2
;                     &drvHandle->bcdmaRegs,
7009b55e: 9a14         	ldr	r2, [sp, #0x50]
7009b560: f102 0008    	add.w	r0, r2, #0x8
;                     chHandle->txChNum + drvHandle->txChOffset,
7009b564: 9919         	ldr	r1, [sp, #0x64]
7009b566: 6ec9         	ldr	r1, [r1, #0x6c]
7009b568: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b56c: 4411         	add	r1, r2
;                     rtEnableRegOffset, &peerRtEnable);
7009b56e: 9b08         	ldr	r3, [sp, #0x20]
;                 (void) CSL_bcdmaGetChanPeerReg(
7009b570: 46ec         	mov	r12, sp
7009b572: aa16         	add	r2, sp, #0x58
7009b574: f8cc 2000    	str.w	r2, [r12]
7009b578: 2200         	movs	r2, #0x0
7009b57a: f010 fbd1    	bl	0x700abd20 <CSL_bcdmaGetChanPeerReg> @ imm = #0x107a2
;                 if((FALSE == bcdmaRtStatus.enable) &&
7009b57e: 980e         	ldr	r0, [sp, #0x38]
7009b580: b938         	cbnz	r0, 0x7009b592 <Udma_chDisableTxChan+0x242> @ imm = #0xe
7009b582: e7ff         	b	0x7009b584 <Udma_chDisableTxChan+0x234> @ imm = #-0x2
;                 (CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE) == FALSE))
7009b584: 9916         	ldr	r1, [sp, #0x58]
7009b586: 2000         	movs	r0, #0x0
;                 if((FALSE == bcdmaRtStatus.enable) &&
7009b588: ebb0 7fd1    	cmp.w	r0, r1, lsr #31
7009b58c: d101         	bne	0x7009b592 <Udma_chDisableTxChan+0x242> @ imm = #0x2
7009b58e: e7ff         	b	0x7009b590 <Udma_chDisableTxChan+0x240> @ imm = #-0x2
;                     break;
7009b590: e036         	b	0x7009b600 <Udma_chDisableTxChan+0x2b0> @ imm = #0x6c
;             }
7009b592: e023         	b	0x7009b5dc <Udma_chDisableTxChan+0x28c> @ imm = #0x46
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b594: 9814         	ldr	r0, [sp, #0x50]
7009b596: 6800         	ldr	r0, [r0]
7009b598: 2802         	cmp	r0, #0x2
7009b59a: d11e         	bne	0x7009b5da <Udma_chDisableTxChan+0x28a> @ imm = #0x3c
7009b59c: e7ff         	b	0x7009b59e <Udma_chDisableTxChan+0x24e> @ imm = #-0x2
;                 (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009b59e: 9814         	ldr	r0, [sp, #0x50]
7009b5a0: 3054         	adds	r0, #0x54
7009b5a2: 9919         	ldr	r1, [sp, #0x64]
7009b5a4: 6ec9         	ldr	r1, [r1, #0x6c]
7009b5a6: aa09         	add	r2, sp, #0x24
7009b5a8: f010 f962    	bl	0x700ab870 <CSL_pktdmaGetTxRT> @ imm = #0x102c4
;                     &drvHandle->pktdmaRegs,
7009b5ac: 9814         	ldr	r0, [sp, #0x50]
7009b5ae: 3054         	adds	r0, #0x54
;                     chHandle->txChNum,
7009b5b0: 9919         	ldr	r1, [sp, #0x64]
7009b5b2: 6ec9         	ldr	r1, [r1, #0x6c]
;                     rtEnableRegOffset, &peerRtEnable);
7009b5b4: 9b08         	ldr	r3, [sp, #0x20]
;                 (void) CSL_pktdmaGetChanPeerReg(
7009b5b6: 46ec         	mov	r12, sp
7009b5b8: aa16         	add	r2, sp, #0x58
7009b5ba: f8cc 2000    	str.w	r2, [r12]
7009b5be: 2200         	movs	r2, #0x0
7009b5c0: f011 fb46    	bl	0x700acc50 <CSL_pktdmaGetChanPeerReg> @ imm = #0x1168c
;                 if((FALSE == pktdmaRtStatus.enable) &&
7009b5c4: 9809         	ldr	r0, [sp, #0x24]
7009b5c6: b938         	cbnz	r0, 0x7009b5d8 <Udma_chDisableTxChan+0x288> @ imm = #0xe
7009b5c8: e7ff         	b	0x7009b5ca <Udma_chDisableTxChan+0x27a> @ imm = #-0x2
;                 (CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE) == FALSE))
7009b5ca: 9916         	ldr	r1, [sp, #0x58]
7009b5cc: 2000         	movs	r0, #0x0
;                 if((FALSE == pktdmaRtStatus.enable) &&
7009b5ce: ebb0 7fd1    	cmp.w	r0, r1, lsr #31
7009b5d2: d101         	bne	0x7009b5d8 <Udma_chDisableTxChan+0x288> @ imm = #0x2
7009b5d4: e7ff         	b	0x7009b5d6 <Udma_chDisableTxChan+0x286> @ imm = #-0x2
;                     break;
7009b5d6: e013         	b	0x7009b600 <Udma_chDisableTxChan+0x2b0> @ imm = #0x26
;             }
7009b5d8: e7ff         	b	0x7009b5da <Udma_chDisableTxChan+0x28a> @ imm = #-0x2
7009b5da: e7ff         	b	0x7009b5dc <Udma_chDisableTxChan+0x28c> @ imm = #-0x2
;             if(currTimeout > timeout)
7009b5dc: 9815         	ldr	r0, [sp, #0x54]
7009b5de: 9918         	ldr	r1, [sp, #0x60]
7009b5e0: 4288         	cmp	r0, r1
7009b5e2: d904         	bls	0x7009b5ee <Udma_chDisableTxChan+0x29e> @ imm = #0x8
7009b5e4: e7ff         	b	0x7009b5e6 <Udma_chDisableTxChan+0x296> @ imm = #-0x2
7009b5e6: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009b5ea: 9017         	str	r0, [sp, #0x5c]
;             }
7009b5ec: e007         	b	0x7009b5fe <Udma_chDisableTxChan+0x2ae> @ imm = #0xe
7009b5ee: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009b5f2: f00d ffd5    	bl	0x700a95a0 <ClockP_usleep> @ imm = #0xdfaa
;                 currTimeout++;
7009b5f6: 9815         	ldr	r0, [sp, #0x54]
7009b5f8: 3001         	adds	r0, #0x1
7009b5fa: 9015         	str	r0, [sp, #0x54]
7009b5fc: e7ff         	b	0x7009b5fe <Udma_chDisableTxChan+0x2ae> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009b5fe: e79a         	b	0x7009b536 <Udma_chDisableTxChan+0x1e6> @ imm = #-0xcc
;     }
7009b600: e7ff         	b	0x7009b602 <Udma_chDisableTxChan+0x2b2> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b602: 9817         	ldr	r0, [sp, #0x5c]
7009b604: 2800         	cmp	r0, #0x0
7009b606: d150         	bne	0x7009b6aa <Udma_chDisableTxChan+0x35a> @ imm = #0xa0
7009b608: e7ff         	b	0x7009b60a <Udma_chDisableTxChan+0x2ba> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b60a: 9814         	ldr	r0, [sp, #0x50]
7009b60c: 6800         	ldr	r0, [r0]
7009b60e: 2801         	cmp	r0, #0x1
7009b610: d126         	bne	0x7009b660 <Udma_chDisableTxChan+0x310> @ imm = #0x4c
7009b612: e7ff         	b	0x7009b614 <Udma_chDisableTxChan+0x2c4> @ imm = #-0x2
7009b614: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.enable   = FALSE;
7009b616: 9003         	str	r0, [sp, #0xc]
7009b618: 900e         	str	r0, [sp, #0x38]
;             bcdmaRtStatus.teardown = FALSE;
7009b61a: 900f         	str	r0, [sp, #0x3c]
;             bcdmaRtStatus.forcedTeardown = FALSE;
7009b61c: 9012         	str	r0, [sp, #0x48]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 0U);
7009b61e: 9816         	ldr	r0, [sp, #0x58]
7009b620: f020 4080    	bic	r0, r0, #0x40000000
7009b624: 9016         	str	r0, [sp, #0x58]
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009b626: 9a14         	ldr	r2, [sp, #0x50]
7009b628: f102 0008    	add.w	r0, r2, #0x8
7009b62c: 9919         	ldr	r1, [sp, #0x64]
7009b62e: 6ec9         	ldr	r1, [r1, #0x6c]
7009b630: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b634: 4411         	add	r1, r2
7009b636: aa0e         	add	r2, sp, #0x38
7009b638: f011 fca2    	bl	0x700acf80 <CSL_bcdmaSetTxRT> @ imm = #0x11944
7009b63c: 9a03         	ldr	r2, [sp, #0xc]
;                 &drvHandle->bcdmaRegs,
7009b63e: 9b14         	ldr	r3, [sp, #0x50]
7009b640: f103 0008    	add.w	r0, r3, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009b644: 9919         	ldr	r1, [sp, #0x64]
7009b646: 6ec9         	ldr	r1, [r1, #0x6c]
7009b648: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
7009b64c: 4419         	add	r1, r3
;                 rtEnableRegOffset,
7009b64e: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaSetChanPeerReg(
7009b650: 46ee         	mov	lr, sp
7009b652: f10d 0c58    	add.w	r12, sp, #0x58
7009b656: f8ce c000    	str.w	r12, [lr]
7009b65a: f010 fe61    	bl	0x700ac320 <CSL_bcdmaSetChanPeerReg> @ imm = #0x10cc2
;         }
7009b65e: e023         	b	0x7009b6a8 <Udma_chDisableTxChan+0x358> @ imm = #0x46
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b660: 9814         	ldr	r0, [sp, #0x50]
7009b662: 6800         	ldr	r0, [r0]
7009b664: 2802         	cmp	r0, #0x2
7009b666: d11e         	bne	0x7009b6a6 <Udma_chDisableTxChan+0x356> @ imm = #0x3c
7009b668: e7ff         	b	0x7009b66a <Udma_chDisableTxChan+0x31a> @ imm = #-0x2
7009b66a: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.enable   = FALSE;
7009b66c: 9002         	str	r0, [sp, #0x8]
7009b66e: 9009         	str	r0, [sp, #0x24]
;             pktdmaRtStatus.teardown = FALSE;
7009b670: 900a         	str	r0, [sp, #0x28]
;             pktdmaRtStatus.forcedTeardown = FALSE;
7009b672: 900d         	str	r0, [sp, #0x34]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 0U);
7009b674: 9816         	ldr	r0, [sp, #0x58]
7009b676: f020 4080    	bic	r0, r0, #0x40000000
7009b67a: 9016         	str	r0, [sp, #0x58]
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009b67c: 9814         	ldr	r0, [sp, #0x50]
7009b67e: 3054         	adds	r0, #0x54
7009b680: 9919         	ldr	r1, [sp, #0x64]
7009b682: 6ec9         	ldr	r1, [r1, #0x6c]
7009b684: aa09         	add	r2, sp, #0x24
7009b686: f010 feab    	bl	0x700ac3e0 <CSL_pktdmaSetTxRT> @ imm = #0x10d56
7009b68a: 9a02         	ldr	r2, [sp, #0x8]
;                 &drvHandle->pktdmaRegs,
7009b68c: 9814         	ldr	r0, [sp, #0x50]
7009b68e: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009b690: 9919         	ldr	r1, [sp, #0x64]
7009b692: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009b694: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaSetChanPeerReg(
7009b696: 46ee         	mov	lr, sp
7009b698: f10d 0c58    	add.w	r12, sp, #0x58
7009b69c: f8ce c000    	str.w	r12, [lr]
7009b6a0: f011 faee    	bl	0x700acc80 <CSL_pktdmaSetChanPeerReg> @ imm = #0x115dc
;         }
7009b6a4: e7ff         	b	0x7009b6a6 <Udma_chDisableTxChan+0x356> @ imm = #-0x2
7009b6a6: e7ff         	b	0x7009b6a8 <Udma_chDisableTxChan+0x358> @ imm = #-0x2
;     }
7009b6a8: e7ff         	b	0x7009b6aa <Udma_chDisableTxChan+0x35a> @ imm = #-0x2
;     return (retVal);
7009b6aa: 9817         	ldr	r0, [sp, #0x5c]
7009b6ac: b01a         	add	sp, #0x68
7009b6ae: bd80         	pop	{r7, pc}

7009b6b0 <Udma_eventConfig>:
; {
7009b6b0: b580         	push	{r7, lr}
7009b6b2: b098         	sub	sp, #0x60
7009b6b4: 9017         	str	r0, [sp, #0x5c]
7009b6b6: 9116         	str	r1, [sp, #0x58]
7009b6b8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009b6ba: 9001         	str	r0, [sp, #0x4]
7009b6bc: 9015         	str	r0, [sp, #0x54]
;     eventPrms = &eventHandle->eventPrms;
7009b6be: 9916         	ldr	r1, [sp, #0x58]
7009b6c0: 3108         	adds	r1, #0x8
7009b6c2: 9110         	str	r1, [sp, #0x40]
;     rmIrqReq.valid_params           = 0U;
7009b6c4: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.global_event           = 0U;
7009b6c6: f8ad 0028    	strh.w	r0, [sp, #0x28]
;     rmIrqReq.src_id                 = 0U;
7009b6ca: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.src_index              = 0U;
7009b6ce: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     rmIrqReq.dst_id                 = 0U;
7009b6d2: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     rmIrqReq.dst_host_irq           = 0U;
7009b6d6: f8ad 0022    	strh.w	r0, [sp, #0x22]
;     rmIrqReq.ia_id                  = 0U;
7009b6da: f8ad 0024    	strh.w	r0, [sp, #0x24]
;     rmIrqReq.vint                   = 0U;
7009b6de: f8ad 0026    	strh.w	r0, [sp, #0x26]
;     rmIrqReq.vint_status_bit_index  = 0U;
7009b6e2: f88d 002a    	strb.w	r0, [sp, #0x2a]
7009b6e6: 20ff         	movs	r0, #0xff
;     rmIrqReq.secondary_host         = TISCI_MSG_VALUE_RM_UNUSED_SECONDARY_HOST;
7009b6e8: f88d 002b    	strb.w	r0, [sp, #0x2b]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009b6ec: 9810         	ldr	r0, [sp, #0x40]
7009b6ee: 6800         	ldr	r0, [r0]
7009b6f0: 2805         	cmp	r0, #0x5
7009b6f2: d00a         	beq	0x7009b70a <Udma_eventConfig+0x5a> @ imm = #0x14
7009b6f4: e7ff         	b	0x7009b6f6 <Udma_eventConfig+0x46> @ imm = #-0x2
;         rmIrqReq.valid_params  |= TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID;
7009b6f6: 9806         	ldr	r0, [sp, #0x18]
7009b6f8: f040 0010    	orr	r0, r0, #0x10
7009b6fc: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.global_event   = (uint16_t)Udma_eventGetId(eventHandle);
7009b6fe: 9816         	ldr	r0, [sp, #0x58]
7009b700: f010 f866    	bl	0x700ab7d0 <Udma_eventGetId> @ imm = #0x100cc
7009b704: f8ad 0028    	strh.w	r0, [sp, #0x28]
;     }
7009b708: e7ff         	b	0x7009b70a <Udma_eventConfig+0x5a> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009b70a: 9816         	ldr	r0, [sp, #0x58]
7009b70c: 6d80         	ldr	r0, [r0, #0x58]
7009b70e: f510 3f80    	cmn.w	r0, #0x10000
7009b712: d012         	beq	0x7009b73a <Udma_eventConfig+0x8a> @ imm = #0x24
7009b714: e7ff         	b	0x7009b716 <Udma_eventConfig+0x66> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_ID_VALID;
7009b716: 9806         	ldr	r0, [sp, #0x18]
7009b718: f040 0001    	orr	r0, r0, #0x1
7009b71c: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID;
7009b71e: 9806         	ldr	r0, [sp, #0x18]
7009b720: f040 0002    	orr	r0, r0, #0x2
7009b724: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.dst_id        = drvHandle->devIdCore;
7009b726: 9817         	ldr	r0, [sp, #0x5c]
7009b728: f8b0 00ea    	ldrh.w	r0, [r0, #0xea]
7009b72c: f8ad 0020    	strh.w	r0, [sp, #0x20]
;         rmIrqReq.dst_host_irq  = (uint16_t)eventHandle->coreIntrNum;
7009b730: 9816         	ldr	r0, [sp, #0x58]
7009b732: 6d80         	ldr	r0, [r0, #0x58]
7009b734: f8ad 0022    	strh.w	r0, [sp, #0x22]
;     }
7009b738: e7ff         	b	0x7009b73a <Udma_eventConfig+0x8a> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->eventPrms.controllerEventHandle)
7009b73a: 9816         	ldr	r0, [sp, #0x58]
7009b73c: 6980         	ldr	r0, [r0, #0x18]
7009b73e: b128         	cbz	r0, 0x7009b74c <Udma_eventConfig+0x9c> @ imm = #0xa
7009b740: e7ff         	b	0x7009b742 <Udma_eventConfig+0x92> @ imm = #-0x2
;         vintrNum = ((Udma_EventHandleInt) (eventHandle->eventPrms.controllerEventHandle))->vintrNum;
7009b742: 9816         	ldr	r0, [sp, #0x58]
7009b744: 6980         	ldr	r0, [r0, #0x18]
7009b746: 6cc0         	ldr	r0, [r0, #0x4c]
7009b748: 9014         	str	r0, [sp, #0x50]
;     }
7009b74a: e003         	b	0x7009b754 <Udma_eventConfig+0xa4> @ imm = #0x6
;         vintrNum = eventHandle->vintrNum;
7009b74c: 9816         	ldr	r0, [sp, #0x58]
7009b74e: 6cc0         	ldr	r0, [r0, #0x4c]
7009b750: 9014         	str	r0, [sp, #0x50]
7009b752: e7ff         	b	0x7009b754 <Udma_eventConfig+0xa4> @ imm = #-0x2
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_IA_ID_VALID;
7009b754: 9806         	ldr	r0, [sp, #0x18]
7009b756: f040 0004    	orr	r0, r0, #0x4
7009b75a: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_VALID;
7009b75c: 9806         	ldr	r0, [sp, #0x18]
7009b75e: f040 0008    	orr	r0, r0, #0x8
7009b762: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.ia_id         = drvHandle->devIdIa;
7009b764: 9817         	ldr	r0, [sp, #0x5c]
7009b766: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009b76a: f8ad 0024    	strh.w	r0, [sp, #0x24]
;     rmIrqReq.vint          = (uint16_t)vintrNum;
7009b76e: 9814         	ldr	r0, [sp, #0x50]
7009b770: f8ad 0026    	strh.w	r0, [sp, #0x26]
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
7009b774: 9816         	ldr	r0, [sp, #0x58]
7009b776: 6d00         	ldr	r0, [r0, #0x50]
7009b778: f64f 71ff    	movw	r1, #0xffff
7009b77c: 4288         	cmp	r0, r1
7009b77e: d009         	beq	0x7009b794 <Udma_eventConfig+0xe4> @ imm = #0x12
7009b780: e7ff         	b	0x7009b782 <Udma_eventConfig+0xd2> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_STATUS_BIT_INDEX_VALID;
7009b782: 9806         	ldr	r0, [sp, #0x18]
7009b784: f040 0020    	orr	r0, r0, #0x20
7009b788: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.vint_status_bit_index  = (uint8_t)eventHandle->vintrBitNum;
7009b78a: 9816         	ldr	r0, [sp, #0x58]
7009b78c: 6d00         	ldr	r0, [r0, #0x50]
7009b78e: f88d 002a    	strb.w	r0, [sp, #0x2a]
;     }
7009b792: e7ff         	b	0x7009b794 <Udma_eventConfig+0xe4> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009b794: 9810         	ldr	r0, [sp, #0x40]
7009b796: 6800         	ldr	r0, [r0]
7009b798: 2801         	cmp	r0, #0x1
7009b79a: d00a         	beq	0x7009b7b2 <Udma_eventConfig+0x102> @ imm = #0x14
7009b79c: e7ff         	b	0x7009b79e <Udma_eventConfig+0xee> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType) ||
7009b79e: 9810         	ldr	r0, [sp, #0x40]
7009b7a0: 6800         	ldr	r0, [r0]
7009b7a2: 2802         	cmp	r0, #0x2
7009b7a4: d005         	beq	0x7009b7b2 <Udma_eventConfig+0x102> @ imm = #0xa
7009b7a6: e7ff         	b	0x7009b7a8 <Udma_eventConfig+0xf8> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009b7a8: 9810         	ldr	r0, [sp, #0x40]
7009b7aa: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009b7ac: 2806         	cmp	r0, #0x6
7009b7ae: d14d         	bne	0x7009b84c <Udma_eventConfig+0x19c> @ imm = #0x9a
7009b7b0: e7ff         	b	0x7009b7b2 <Udma_eventConfig+0x102> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009b7b2: 9810         	ldr	r0, [sp, #0x40]
7009b7b4: 6880         	ldr	r0, [r0, #0x8]
7009b7b6: 9012         	str	r0, [sp, #0x48]
;         rmIrqReq.src_id = drvHandle->srcIdRingIrq;
7009b7b8: 9817         	ldr	r0, [sp, #0x5c]
7009b7ba: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009b7be: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009b7c2: 9810         	ldr	r0, [sp, #0x40]
7009b7c4: 6800         	ldr	r0, [r0]
7009b7c6: 2801         	cmp	r0, #0x1
7009b7c8: d005         	beq	0x7009b7d6 <Udma_eventConfig+0x126> @ imm = #0xa
7009b7ca: e7ff         	b	0x7009b7cc <Udma_eventConfig+0x11c> @ imm = #-0x2
7009b7cc: 9810         	ldr	r0, [sp, #0x40]
7009b7ce: 6800         	ldr	r0, [r0]
7009b7d0: 2806         	cmp	r0, #0x6
7009b7d2: d12e         	bne	0x7009b832 <Udma_eventConfig+0x182> @ imm = #0x5c
7009b7d4: e7ff         	b	0x7009b7d6 <Udma_eventConfig+0x126> @ imm = #-0x2
;             rmIrqReq.src_index = chHandle->cqRing->ringNum;
7009b7d6: 9812         	ldr	r0, [sp, #0x48]
7009b7d8: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009b7dc: 8880         	ldrh	r0, [r0, #0x4]
7009b7de: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009b7e2: 9812         	ldr	r0, [sp, #0x48]
7009b7e4: 7800         	ldrb	r0, [r0]
7009b7e6: 0740         	lsls	r0, r0, #0x1d
7009b7e8: 2800         	cmp	r0, #0x0
7009b7ea: d509         	bpl	0x7009b800 <Udma_eventConfig+0x150> @ imm = #0x12
7009b7ec: e7ff         	b	0x7009b7ee <Udma_eventConfig+0x13e> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->blkCopyRingIrqOffset;
7009b7ee: 9817         	ldr	r0, [sp, #0x5c]
7009b7f0: f8d0 10f0    	ldr.w	r1, [r0, #0xf0]
7009b7f4: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b7f8: 4408         	add	r0, r1
7009b7fa: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b7fe: e017         	b	0x7009b830 <Udma_eventConfig+0x180> @ imm = #0x2e
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009b800: 9812         	ldr	r0, [sp, #0x48]
7009b802: 7800         	ldrb	r0, [r0]
7009b804: 07c0         	lsls	r0, r0, #0x1f
7009b806: b148         	cbz	r0, 0x7009b81c <Udma_eventConfig+0x16c> @ imm = #0x12
7009b808: e7ff         	b	0x7009b80a <Udma_eventConfig+0x15a> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009b80a: 9817         	ldr	r0, [sp, #0x5c]
7009b80c: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009b810: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b814: 4408         	add	r0, r1
7009b816: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b81a: e008         	b	0x7009b82e <Udma_eventConfig+0x17e> @ imm = #0x10
;                 rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009b81c: 9817         	ldr	r0, [sp, #0x5c]
7009b81e: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009b822: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b826: 4408         	add	r0, r1
7009b828: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009b82c: e7ff         	b	0x7009b82e <Udma_eventConfig+0x17e> @ imm = #-0x2
7009b82e: e7ff         	b	0x7009b830 <Udma_eventConfig+0x180> @ imm = #-0x2
;         }
7009b830: e00b         	b	0x7009b84a <Udma_eventConfig+0x19a> @ imm = #0x16
;             rmIrqReq.src_index = chHandle->tdCqRing->ringNum;
7009b832: 9812         	ldr	r0, [sp, #0x48]
7009b834: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009b838: 8880         	ldrh	r0, [r0, #0x4]
7009b83a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             rmIrqReq.src_index += TISCI_RINGACC0_OES_IRQ_SRC_IDX_START;
7009b83e: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b842: 3014         	adds	r0, #0x14
7009b844: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009b848: e7ff         	b	0x7009b84a <Udma_eventConfig+0x19a> @ imm = #-0x2
;     }
7009b84a: e7ff         	b	0x7009b84c <Udma_eventConfig+0x19c> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009b84c: 9810         	ldr	r0, [sp, #0x40]
7009b84e: 6800         	ldr	r0, [r0]
7009b850: 2803         	cmp	r0, #0x3
7009b852: d156         	bne	0x7009b902 <Udma_eventConfig+0x252> @ imm = #0xac
7009b854: e7ff         	b	0x7009b856 <Udma_eventConfig+0x1a6> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b856: 9817         	ldr	r0, [sp, #0x5c]
7009b858: 6800         	ldr	r0, [r0]
7009b85a: 2802         	cmp	r0, #0x2
7009b85c: d104         	bne	0x7009b868 <Udma_eventConfig+0x1b8> @ imm = #0x8
7009b85e: e7ff         	b	0x7009b860 <Udma_eventConfig+0x1b0> @ imm = #-0x2
7009b860: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009b864: 9015         	str	r0, [sp, #0x54]
;         }
7009b866: e04b         	b	0x7009b900 <Udma_eventConfig+0x250> @ imm = #0x96
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009b868: 9810         	ldr	r0, [sp, #0x40]
7009b86a: 6880         	ldr	r0, [r0, #0x8]
7009b86c: 9012         	str	r0, [sp, #0x48]
;             rmIrqReq.src_id = drvHandle->srcIdTrIrq;
7009b86e: 9817         	ldr	r0, [sp, #0x5c]
7009b870: f8b0 00fc    	ldrh.w	r0, [r0, #0xfc]
7009b874: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009b878: 9812         	ldr	r0, [sp, #0x48]
7009b87a: 7800         	ldrb	r0, [r0]
7009b87c: 0740         	lsls	r0, r0, #0x1d
7009b87e: 2800         	cmp	r0, #0x0
7009b880: d50d         	bpl	0x7009b89e <Udma_eventConfig+0x1ee> @ imm = #0x1a
7009b882: e7ff         	b	0x7009b884 <Udma_eventConfig+0x1d4> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009b884: 9812         	ldr	r0, [sp, #0x48]
7009b886: 6ec0         	ldr	r0, [r0, #0x6c]
7009b888: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->blkCopyTrIrqOffset;
7009b88c: 9817         	ldr	r0, [sp, #0x5c]
7009b88e: f8d0 1100    	ldr.w	r1, [r0, #0x100]
7009b892: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b896: 4408         	add	r0, r1
7009b898: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b89c: e02f         	b	0x7009b8fe <Udma_eventConfig+0x24e> @ imm = #0x5e
;             else if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009b89e: 9812         	ldr	r0, [sp, #0x48]
7009b8a0: 7800         	ldrb	r0, [r0]
7009b8a2: 0780         	lsls	r0, r0, #0x1e
7009b8a4: 2800         	cmp	r0, #0x0
7009b8a6: d50d         	bpl	0x7009b8c4 <Udma_eventConfig+0x214> @ imm = #0x1a
7009b8a8: e7ff         	b	0x7009b8aa <Udma_eventConfig+0x1fa> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->rxChNum;
7009b8aa: 9812         	ldr	r0, [sp, #0x48]
7009b8ac: 6f00         	ldr	r0, [r0, #0x70]
7009b8ae: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->rxTrIrqOffset;
7009b8b2: 9817         	ldr	r0, [sp, #0x5c]
7009b8b4: f8d0 1108    	ldr.w	r1, [r0, #0x108]
7009b8b8: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b8bc: 4408         	add	r0, r1
7009b8be: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b8c2: e01b         	b	0x7009b8fc <Udma_eventConfig+0x24c> @ imm = #0x36
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009b8c4: 9812         	ldr	r0, [sp, #0x48]
7009b8c6: 7800         	ldrb	r0, [r0]
7009b8c8: 07c0         	lsls	r0, r0, #0x1f
7009b8ca: b168         	cbz	r0, 0x7009b8e8 <Udma_eventConfig+0x238> @ imm = #0x1a
7009b8cc: e7ff         	b	0x7009b8ce <Udma_eventConfig+0x21e> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009b8ce: 9812         	ldr	r0, [sp, #0x48]
7009b8d0: 6ec0         	ldr	r0, [r0, #0x6c]
7009b8d2: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->txTrIrqOffset;
7009b8d6: 9817         	ldr	r0, [sp, #0x5c]
7009b8d8: f8d0 1104    	ldr.w	r1, [r0, #0x104]
7009b8dc: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b8e0: 4408         	add	r0, r1
7009b8e2: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b8e6: e008         	b	0x7009b8fa <Udma_eventConfig+0x24a> @ imm = #0x10
;                 rmIrqReq.src_id = drvHandle->devIdIa;
7009b8e8: 9817         	ldr	r0, [sp, #0x5c]
7009b8ea: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009b8ee: f8ad 001c    	strh.w	r0, [sp, #0x1c]
7009b8f2: 2000         	movs	r0, #0x0
;                 rmIrqReq.src_index = 0U;                /* Not used by DMSC RM */
7009b8f4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009b8f8: e7ff         	b	0x7009b8fa <Udma_eventConfig+0x24a> @ imm = #-0x2
7009b8fa: e7ff         	b	0x7009b8fc <Udma_eventConfig+0x24c> @ imm = #-0x2
7009b8fc: e7ff         	b	0x7009b8fe <Udma_eventConfig+0x24e> @ imm = #-0x2
7009b8fe: e7ff         	b	0x7009b900 <Udma_eventConfig+0x250> @ imm = #-0x2
;     }
7009b900: e7ff         	b	0x7009b902 <Udma_eventConfig+0x252> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
7009b902: 9810         	ldr	r0, [sp, #0x40]
7009b904: 6800         	ldr	r0, [r0]
7009b906: 2804         	cmp	r0, #0x4
7009b908: d130         	bne	0x7009b96c <Udma_eventConfig+0x2bc> @ imm = #0x60
7009b90a: e7ff         	b	0x7009b90c <Udma_eventConfig+0x25c> @ imm = #-0x2
;         ringHandle = (Udma_RingHandleInt) eventPrms->ringHandle;
7009b90c: 9810         	ldr	r0, [sp, #0x40]
7009b90e: 68c0         	ldr	r0, [r0, #0xc]
7009b910: 9011         	str	r0, [sp, #0x44]
;         rmIrqReq.src_id     = drvHandle->srcIdRingIrq;
7009b912: 9817         	ldr	r0, [sp, #0x5c]
7009b914: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009b918: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         rmIrqReq.src_index  = ringHandle->ringNum;
7009b91c: 9811         	ldr	r0, [sp, #0x44]
7009b91e: 8880         	ldrh	r0, [r0, #0x4]
7009b920: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009b924: 9817         	ldr	r0, [sp, #0x5c]
7009b926: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009b92a: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b92e: 4408         	add	r0, r1
7009b930: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009b934: 9811         	ldr	r0, [sp, #0x44]
7009b936: 6dc0         	ldr	r0, [r0, #0x5c]
7009b938: 2804         	cmp	r0, #0x4
7009b93a: d316         	blo	0x7009b96a <Udma_eventConfig+0x2ba> @ imm = #0x2c
7009b93c: e7ff         	b	0x7009b93e <Udma_eventConfig+0x28e> @ imm = #-0x2
;            (ringHandle->mappedRingGrp < (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
7009b93e: 9811         	ldr	r0, [sp, #0x44]
7009b940: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009b942: 2807         	cmp	r0, #0x7
7009b944: d811         	bhi	0x7009b96a <Udma_eventConfig+0x2ba> @ imm = #0x22
7009b946: e7ff         	b	0x7009b948 <Udma_eventConfig+0x298> @ imm = #-0x2
;             rmIrqReq.src_index -= drvHandle->txRingIrqOffset;
7009b948: 9817         	ldr	r0, [sp, #0x5c]
7009b94a: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009b94e: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b952: 1a40         	subs	r0, r0, r1
7009b954: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009b958: 9817         	ldr	r0, [sp, #0x5c]
7009b95a: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009b95e: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b962: 4408         	add	r0, r1
7009b964: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         }
7009b968: e7ff         	b	0x7009b96a <Udma_eventConfig+0x2ba> @ imm = #-0x2
;     }
7009b96a: e7ff         	b	0x7009b96c <Udma_eventConfig+0x2bc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b96c: 9815         	ldr	r0, [sp, #0x54]
7009b96e: b9d8         	cbnz	r0, 0x7009b9a8 <Udma_eventConfig+0x2f8> @ imm = #0x36
7009b970: e7ff         	b	0x7009b972 <Udma_eventConfig+0x2c2> @ imm = #-0x2
;         Udma_eventProgramSteering(drvHandle, eventHandle);
7009b972: 9817         	ldr	r0, [sp, #0x5c]
7009b974: 9916         	ldr	r1, [sp, #0x58]
7009b976: f011 fcb3    	bl	0x700ad2e0 <Udma_eventProgramSteering> @ imm = #0x11966
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009b97a: 9817         	ldr	r0, [sp, #0x5c]
7009b97c: 6800         	ldr	r0, [r0]
7009b97e: b130         	cbz	r0, 0x7009b98e <Udma_eventConfig+0x2de> @ imm = #0xc
7009b980: e7ff         	b	0x7009b982 <Udma_eventConfig+0x2d2> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009b982: 9810         	ldr	r0, [sp, #0x40]
7009b984: 6800         	ldr	r0, [r0]
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009b986: 2805         	cmp	r0, #0x5
7009b988: d101         	bne	0x7009b98e <Udma_eventConfig+0x2de> @ imm = #0x2
7009b98a: e7ff         	b	0x7009b98c <Udma_eventConfig+0x2dc> @ imm = #-0x2
;         }
7009b98c: e00b         	b	0x7009b9a6 <Udma_eventConfig+0x2f6> @ imm = #0x16
7009b98e: a804         	add	r0, sp, #0x10
7009b990: a902         	add	r1, sp, #0x8
7009b992: f04f 32ff    	mov.w	r2, #0xffffffff
;             retVal = Sciclient_rmIrqSet(
7009b996: f012 f8cb    	bl	0x700adb30 <Sciclient_rmIrqSet> @ imm = #0x12196
7009b99a: 9015         	str	r0, [sp, #0x54]
;             if(CSL_PASS != retVal)
7009b99c: 9815         	ldr	r0, [sp, #0x54]
7009b99e: b108         	cbz	r0, 0x7009b9a4 <Udma_eventConfig+0x2f4> @ imm = #0x2
7009b9a0: e7ff         	b	0x7009b9a2 <Udma_eventConfig+0x2f2> @ imm = #-0x2
;             }
7009b9a2: e7ff         	b	0x7009b9a4 <Udma_eventConfig+0x2f4> @ imm = #-0x2
7009b9a4: e7ff         	b	0x7009b9a6 <Udma_eventConfig+0x2f6> @ imm = #-0x2
;     }
7009b9a6: e7ff         	b	0x7009b9a8 <Udma_eventConfig+0x2f8> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b9a8: 9815         	ldr	r0, [sp, #0x54]
7009b9aa: bb58         	cbnz	r0, 0x7009ba04 <Udma_eventConfig+0x354> @ imm = #0x56
7009b9ac: e7ff         	b	0x7009b9ae <Udma_eventConfig+0x2fe> @ imm = #-0x2
;         if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009b9ae: 9816         	ldr	r0, [sp, #0x58]
7009b9b0: 6d80         	ldr	r0, [r0, #0x58]
7009b9b2: f510 3f80    	cmn.w	r0, #0x10000
7009b9b6: d024         	beq	0x7009ba02 <Udma_eventConfig+0x352> @ imm = #0x48
7009b9b8: e7ff         	b	0x7009b9ba <Udma_eventConfig+0x30a> @ imm = #-0x2
;             coreIntrNum = eventHandle->coreIntrNum;
7009b9ba: 9816         	ldr	r0, [sp, #0x58]
7009b9bc: 6d80         	ldr	r0, [r0, #0x58]
7009b9be: 9013         	str	r0, [sp, #0x4c]
7009b9c0: a80b         	add	r0, sp, #0x2c
;             HwiP_Params_init(&hwiPrms);
7009b9c2: 9000         	str	r0, [sp]
7009b9c4: f012 fcf4    	bl	0x700ae3b0 <HwiP_Params_init> @ imm = #0x129e8
7009b9c8: 9900         	ldr	r1, [sp]
;             hwiPrms.intNum = coreIntrNum;
7009b9ca: 9813         	ldr	r0, [sp, #0x4c]
7009b9cc: 900b         	str	r0, [sp, #0x2c]
;             hwiPrms.callback = &Udma_eventIsrFxn;
7009b9ce: f643 6021    	movw	r0, #0x3e21
7009b9d2: f2c7 000a    	movt	r0, #0x700a
7009b9d6: 900c         	str	r0, [sp, #0x30]
;             hwiPrms.args = eventHandle;
7009b9d8: 9816         	ldr	r0, [sp, #0x58]
7009b9da: 900d         	str	r0, [sp, #0x34]
;             hwiPrms.priority = eventHandle->eventPrms.intrPriority;
7009b9dc: 9816         	ldr	r0, [sp, #0x58]
7009b9de: 6a00         	ldr	r0, [r0, #0x20]
7009b9e0: f88d 003a    	strb.w	r0, [sp, #0x3a]
;             retVal = HwiP_construct(&eventHandle->hwiObject, &hwiPrms);
7009b9e4: 9816         	ldr	r0, [sp, #0x58]
7009b9e6: 3068         	adds	r0, #0x68
7009b9e8: f012 fcfa    	bl	0x700ae3e0 <HwiP_construct> @ imm = #0x129f4
7009b9ec: 9015         	str	r0, [sp, #0x54]
;             if(SystemP_SUCCESS != retVal)
7009b9ee: 9815         	ldr	r0, [sp, #0x54]
7009b9f0: b108         	cbz	r0, 0x7009b9f6 <Udma_eventConfig+0x346> @ imm = #0x2
7009b9f2: e7ff         	b	0x7009b9f4 <Udma_eventConfig+0x344> @ imm = #-0x2
;             }
7009b9f4: e004         	b	0x7009ba00 <Udma_eventConfig+0x350> @ imm = #0x8
;                 eventHandle->hwiHandle = &eventHandle->hwiObject;
7009b9f6: 9916         	ldr	r1, [sp, #0x58]
7009b9f8: f101 0068    	add.w	r0, r1, #0x68
7009b9fc: 6648         	str	r0, [r1, #0x64]
7009b9fe: e7ff         	b	0x7009ba00 <Udma_eventConfig+0x350> @ imm = #-0x2
;         }
7009ba00: e7ff         	b	0x7009ba02 <Udma_eventConfig+0x352> @ imm = #-0x2
;     }
7009ba02: e7ff         	b	0x7009ba04 <Udma_eventConfig+0x354> @ imm = #-0x2
;     return (retVal);
7009ba04: 9815         	ldr	r0, [sp, #0x54]
7009ba06: b018         	add	sp, #0x60
7009ba08: bd80         	pop	{r7, pc}
7009ba0a: 0000         	movs	r0, r0
7009ba0c: 0000         	movs	r0, r0
7009ba0e: 0000         	movs	r0, r0

7009ba10 <Sciclient_rmIrqGetRoute>:
; {
7009ba10: b580         	push	{r7, lr}
7009ba12: b08e         	sub	sp, #0x38
7009ba14: 900d         	str	r0, [sp, #0x34]
7009ba16: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009ba18: 900c         	str	r0, [sp, #0x30]
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009ba1a: 980d         	ldr	r0, [sp, #0x34]
7009ba1c: 88c0         	ldrh	r0, [r0, #0x6]
7009ba1e: f011 f9a7    	bl	0x700acd70 <Sciclient_rmIrIsIr> @ imm = #0x1134e
7009ba22: b930         	cbnz	r0, 0x7009ba32 <Sciclient_rmIrqGetRoute+0x22> @ imm = #0xc
7009ba24: e7ff         	b	0x7009ba26 <Sciclient_rmIrqGetRoute+0x16> @ imm = #-0x2
;         (Sciclient_rmIrIsIr(cfg->d_id) == true)) {
7009ba26: 980d         	ldr	r0, [sp, #0x34]
7009ba28: 8940         	ldrh	r0, [r0, #0xa]
7009ba2a: f011 f9a1    	bl	0x700acd70 <Sciclient_rmIrIsIr> @ imm = #0x11342
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009ba2e: b120         	cbz	r0, 0x7009ba3a <Sciclient_rmIrqGetRoute+0x2a> @ imm = #0x8
7009ba30: e7ff         	b	0x7009ba32 <Sciclient_rmIrqGetRoute+0x22> @ imm = #-0x2
7009ba32: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009ba36: 900c         	str	r0, [sp, #0x30]
;     }
7009ba38: e7ff         	b	0x7009ba3a <Sciclient_rmIrqGetRoute+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009ba3a: 980c         	ldr	r0, [sp, #0x30]
7009ba3c: 2800         	cmp	r0, #0x0
7009ba3e: d156         	bne	0x7009baee <Sciclient_rmIrqGetRoute+0xde> @ imm = #0xac
7009ba40: e7ff         	b	0x7009ba42 <Sciclient_rmIrqGetRoute+0x32> @ imm = #-0x2
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009ba42: 980d         	ldr	r0, [sp, #0x34]
7009ba44: 8a00         	ldrh	r0, [r0, #0x10]
7009ba46: 28ff         	cmp	r0, #0xff
7009ba48: d042         	beq	0x7009bad0 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x84
7009ba4a: e7ff         	b	0x7009ba4c <Sciclient_rmIrqGetRoute+0x3c> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009ba4c: 980d         	ldr	r0, [sp, #0x34]
7009ba4e: 6800         	ldr	r0, [r0]
7009ba50: 2104         	movs	r1, #0x4
7009ba52: f011 fb9d    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x1173a
;              true) &&
7009ba56: b3d8         	cbz	r0, 0x7009bad0 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x76
7009ba58: e7ff         	b	0x7009ba5a <Sciclient_rmIrqGetRoute+0x4a> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009ba5a: 980d         	ldr	r0, [sp, #0x34]
7009ba5c: 6800         	ldr	r0, [r0]
7009ba5e: 2108         	movs	r1, #0x8
7009ba60: f011 fb96    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x1172c
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009ba64: b3a0         	cbz	r0, 0x7009bad0 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x68
7009ba66: e7ff         	b	0x7009ba68 <Sciclient_rmIrqGetRoute+0x58> @ imm = #-0x2
;             if ((Sciclient_rmParamIsValid(cfg->valid_params,
7009ba68: 980d         	ldr	r0, [sp, #0x34]
7009ba6a: 6800         	ldr	r0, [r0]
7009ba6c: 2110         	movs	r1, #0x10
7009ba6e: f011 fb8f    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x1171e
;                  true) &&
7009ba72: b1d0         	cbz	r0, 0x7009baaa <Sciclient_rmIrqGetRoute+0x9a> @ imm = #0x34
7009ba74: e7ff         	b	0x7009ba76 <Sciclient_rmIrqGetRoute+0x66> @ imm = #-0x2
;                 (Sciclient_rmParamIsValid(cfg->valid_params,
7009ba76: 980d         	ldr	r0, [sp, #0x34]
7009ba78: 6800         	ldr	r0, [r0]
7009ba7a: 2120         	movs	r1, #0x20
7009ba7c: f011 fb88    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x11710
;             if ((Sciclient_rmParamIsValid(cfg->valid_params,
7009ba80: b198         	cbz	r0, 0x7009baaa <Sciclient_rmIrqGetRoute+0x9a> @ imm = #0x26
7009ba82: e7ff         	b	0x7009ba84 <Sciclient_rmIrqGetRoute+0x74> @ imm = #-0x2
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009ba84: f8dd c034    	ldr.w	r12, [sp, #0x34]
7009ba88: f8bc 1010    	ldrh.w	r1, [r12, #0x10]
;                                cfg->vint, cfg->global_evt,
7009ba8c: f8bc 2012    	ldrh.w	r2, [r12, #0x12]
7009ba90: f8bc 300e    	ldrh.w	r3, [r12, #0xe]
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009ba94: f89c 0004    	ldrb.w	r0, [r12, #0x4]
;                                cfg->vint_sb);
7009ba98: f89c c014    	ldrb.w	r12, [r12, #0x14]
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009ba9c: 46ee         	mov	lr, sp
7009ba9e: f8ce c000    	str.w	r12, [lr]
7009baa2: f005 f99d    	bl	0x700a0de0 <Sciclient_rmIaValidateMapping> @ imm = #0x533a
7009baa6: 900c         	str	r0, [sp, #0x30]
;             }
7009baa8: e7ff         	b	0x7009baaa <Sciclient_rmIrqGetRoute+0x9a> @ imm = #-0x2
;             if (r == SystemP_SUCCESS) {
7009baaa: 980c         	ldr	r0, [sp, #0x30]
7009baac: b978         	cbnz	r0, 0x7009bace <Sciclient_rmIrqGetRoute+0xbe> @ imm = #0x1e
7009baae: e7ff         	b	0x7009bab0 <Sciclient_rmIrqGetRoute+0xa0> @ imm = #-0x2
;                 inp = cfg->global_evt;
7009bab0: 980d         	ldr	r0, [sp, #0x34]
7009bab2: 89c0         	ldrh	r0, [r0, #0xe]
7009bab4: f8ad 0028    	strh.w	r0, [sp, #0x28]
;                 outp = cfg->vint;
7009bab8: 980d         	ldr	r0, [sp, #0x34]
7009baba: 8a40         	ldrh	r0, [r0, #0x12]
7009babc: f8ad 0024    	strh.w	r0, [sp, #0x24]
;                 r = Sciclient_rmIrqGetNode(cfg->s_ia, &cur_n);
7009bac0: 980d         	ldr	r0, [sp, #0x34]
7009bac2: 8a00         	ldrh	r0, [r0, #0x10]
7009bac4: a906         	add	r1, sp, #0x18
7009bac6: f008 fc03    	bl	0x700a42d0 <Sciclient_rmIrqGetNode> @ imm = #0x8806
7009baca: 900c         	str	r0, [sp, #0x30]
;             }
7009bacc: e7ff         	b	0x7009bace <Sciclient_rmIrqGetRoute+0xbe> @ imm = #-0x2
;         } else {
7009bace: e00d         	b	0x7009baec <Sciclient_rmIrqGetRoute+0xdc> @ imm = #0x1a
7009bad0: 2000         	movs	r0, #0x0
;             inp = 0u;
7009bad2: f8ad 0028    	strh.w	r0, [sp, #0x28]
;             outp = cfg->s_idx;
7009bad6: 980d         	ldr	r0, [sp, #0x34]
7009bad8: 8900         	ldrh	r0, [r0, #0x8]
7009bada: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             r = Sciclient_rmIrqGetNode(cfg->s_id, &cur_n);
7009bade: 980d         	ldr	r0, [sp, #0x34]
7009bae0: 88c0         	ldrh	r0, [r0, #0x6]
7009bae2: a906         	add	r1, sp, #0x18
7009bae4: f008 fbf4    	bl	0x700a42d0 <Sciclient_rmIrqGetNode> @ imm = #0x87e8
7009bae8: 900c         	str	r0, [sp, #0x30]
7009baea: e7ff         	b	0x7009baec <Sciclient_rmIrqGetRoute+0xdc> @ imm = #-0x2
;     }
7009baec: e7ff         	b	0x7009baee <Sciclient_rmIrqGetRoute+0xde> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009baee: 980c         	ldr	r0, [sp, #0x30]
7009baf0: b948         	cbnz	r0, 0x7009bb06 <Sciclient_rmIrqGetRoute+0xf6> @ imm = #0x12
7009baf2: e7ff         	b	0x7009baf4 <Sciclient_rmIrqGetRoute+0xe4> @ imm = #-0x2
7009baf4: 2001         	movs	r0, #0x1
;         search = true;
7009baf6: f88d 0021    	strb.w	r0, [sp, #0x21]
7009bafa: 2000         	movs	r0, #0x0
;         rt_complete = false;
7009bafc: f88d 0020    	strb.w	r0, [sp, #0x20]
;         Sciclient_rmPsInit();
7009bb00: f011 fee6    	bl	0x700ad8d0 <Sciclient_rmPsInit> @ imm = #0x11dcc
;     } else {
7009bb04: e003         	b	0x7009bb0e <Sciclient_rmIrqGetRoute+0xfe> @ imm = #0x6
7009bb06: 2000         	movs	r0, #0x0
;         search = false;
7009bb08: f88d 0021    	strb.w	r0, [sp, #0x21]
7009bb0c: e7ff         	b	0x7009bb0e <Sciclient_rmIrqGetRoute+0xfe> @ imm = #-0x2
7009bb0e: 2000         	movs	r0, #0x0
;     for (search_depth = 0u;
7009bb10: f8ad 002e    	strh.w	r0, [sp, #0x2e]
7009bb14: e7ff         	b	0x7009bb16 <Sciclient_rmIrqGetRoute+0x106> @ imm = #-0x2
;          (search_depth < Sciclient_rmPsGetMaxPsp()) && (search == true);
7009bb16: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009bb1a: 9002         	str	r0, [sp, #0x8]
7009bb1c: f012 fb48    	bl	0x700ae1b0 <Sciclient_rmPsGetMaxPsp> @ imm = #0x12690
7009bb20: 9902         	ldr	r1, [sp, #0x8]
7009bb22: 4602         	mov	r2, r0
7009bb24: 2000         	movs	r0, #0x0
7009bb26: 4291         	cmp	r1, r2
7009bb28: 9003         	str	r0, [sp, #0xc]
7009bb2a: da06         	bge	0x7009bb3a <Sciclient_rmIrqGetRoute+0x12a> @ imm = #0xc
7009bb2c: e7ff         	b	0x7009bb2e <Sciclient_rmIrqGetRoute+0x11e> @ imm = #-0x2
7009bb2e: f89d 0021    	ldrb.w	r0, [sp, #0x21]
7009bb32: f000 0001    	and	r0, r0, #0x1
7009bb36: 9003         	str	r0, [sp, #0xc]
7009bb38: e7ff         	b	0x7009bb3a <Sciclient_rmIrqGetRoute+0x12a> @ imm = #-0x2
7009bb3a: 9803         	ldr	r0, [sp, #0xc]
;     for (search_depth = 0u;
7009bb3c: 07c0         	lsls	r0, r0, #0x1f
7009bb3e: 2800         	cmp	r0, #0x0
7009bb40: f000 80d8    	beq.w	0x7009bcf4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x1b0
7009bb44: e7ff         	b	0x7009bb46 <Sciclient_rmIrqGetRoute+0x136> @ imm = #-0x2
7009bb46: 2000         	movs	r0, #0x0
;         push_node = false;
7009bb48: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         for (if_idx = 0u; if_idx < cur_n->n_if; if_idx++) {
7009bb4c: f8ad 002c    	strh.w	r0, [sp, #0x2c]
7009bb50: e7ff         	b	0x7009bb52 <Sciclient_rmIrqGetRoute+0x142> @ imm = #-0x2
7009bb52: f8bd 002c    	ldrh.w	r0, [sp, #0x2c]
7009bb56: 9906         	ldr	r1, [sp, #0x18]
7009bb58: 8849         	ldrh	r1, [r1, #0x2]
7009bb5a: 4288         	cmp	r0, r1
7009bb5c: da6b         	bge	0x7009bc36 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0xd6
7009bb5e: e7ff         	b	0x7009bb60 <Sciclient_rmIrqGetRoute+0x150> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(cur_n, if_idx, &cur_if);
7009bb60: 9806         	ldr	r0, [sp, #0x18]
7009bb62: f8bd 102c    	ldrh.w	r1, [sp, #0x2c]
7009bb66: aa04         	add	r2, sp, #0x10
7009bb68: f010 f97a    	bl	0x700abe60 <Sciclient_rmIrqGetNodeItf> @ imm = #0x102f4
7009bb6c: 900c         	str	r0, [sp, #0x30]
;             if (r != SystemP_SUCCESS) {
7009bb6e: 980c         	ldr	r0, [sp, #0x30]
7009bb70: b108         	cbz	r0, 0x7009bb76 <Sciclient_rmIrqGetRoute+0x166> @ imm = #0x2
7009bb72: e7ff         	b	0x7009bb74 <Sciclient_rmIrqGetRoute+0x164> @ imm = #-0x2
;                 break;
7009bb74: e05f         	b	0x7009bc36 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0xbe
;             if ((outp >= cur_if->lbase) &&
7009bb76: f8bd 0024    	ldrh.w	r0, [sp, #0x24]
7009bb7a: 9904         	ldr	r1, [sp, #0x10]
7009bb7c: 8809         	ldrh	r1, [r1]
7009bb7e: 4288         	cmp	r0, r1
7009bb80: db52         	blt	0x7009bc28 <Sciclient_rmIrqGetRoute+0x218> @ imm = #0xa4
7009bb82: e7ff         	b	0x7009bb84 <Sciclient_rmIrqGetRoute+0x174> @ imm = #-0x2
;                 (outp < (cur_if->lbase + cur_if->len))) {
7009bb84: f8bd 0024    	ldrh.w	r0, [sp, #0x24]
7009bb88: 9a04         	ldr	r2, [sp, #0x10]
7009bb8a: 8811         	ldrh	r1, [r2]
7009bb8c: 8892         	ldrh	r2, [r2, #0x4]
7009bb8e: 4411         	add	r1, r2
;             if ((outp >= cur_if->lbase) &&
7009bb90: 4288         	cmp	r0, r1
7009bb92: da49         	bge	0x7009bc28 <Sciclient_rmIrqGetRoute+0x218> @ imm = #0x92
7009bb94: e7ff         	b	0x7009bb96 <Sciclient_rmIrqGetRoute+0x186> @ imm = #-0x2
;                 if ((cur_if->rid == cfg->d_id) &&
7009bb96: 9804         	ldr	r0, [sp, #0x10]
7009bb98: 88c0         	ldrh	r0, [r0, #0x6]
7009bb9a: 990d         	ldr	r1, [sp, #0x34]
7009bb9c: 8949         	ldrh	r1, [r1, #0xa]
7009bb9e: 4288         	cmp	r0, r1
7009bba0: d110         	bne	0x7009bbc4 <Sciclient_rmIrqGetRoute+0x1b4> @ imm = #0x20
7009bba2: e7ff         	b	0x7009bba4 <Sciclient_rmIrqGetRoute+0x194> @ imm = #-0x2
;                     (SCICLIENT_OUTP_TO_INP(outp, cur_if->lbase,
7009bba4: 9a04         	ldr	r2, [sp, #0x10]
7009bba6: 8850         	ldrh	r0, [r2, #0x2]
7009bba8: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
7009bbac: 8812         	ldrh	r2, [r2]
7009bbae: 1a89         	subs	r1, r1, r2
7009bbb0: 4408         	add	r0, r1
;                      cfg->d_irq)) {
7009bbb2: 990d         	ldr	r1, [sp, #0x34]
7009bbb4: 8989         	ldrh	r1, [r1, #0xc]
;                 if ((cur_if->rid == cfg->d_id) &&
7009bbb6: 4288         	cmp	r0, r1
7009bbb8: d104         	bne	0x7009bbc4 <Sciclient_rmIrqGetRoute+0x1b4> @ imm = #0x8
7009bbba: e7ff         	b	0x7009bbbc <Sciclient_rmIrqGetRoute+0x1ac> @ imm = #-0x2
7009bbbc: 2001         	movs	r0, #0x1
;                     rt_complete = true;
7009bbbe: f88d 0020    	strb.w	r0, [sp, #0x20]
;                     break;
7009bbc2: e038         	b	0x7009bc36 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x70
;                 if (Sciclient_rmIrIsIr(cur_if->rid) == true) {
7009bbc4: 9804         	ldr	r0, [sp, #0x10]
7009bbc6: 88c0         	ldrh	r0, [r0, #0x6]
7009bbc8: f011 f8d2    	bl	0x700acd70 <Sciclient_rmIrIsIr> @ imm = #0x111a4
7009bbcc: b358         	cbz	r0, 0x7009bc26 <Sciclient_rmIrqGetRoute+0x216> @ imm = #0x56
7009bbce: e7ff         	b	0x7009bbd0 <Sciclient_rmIrqGetRoute+0x1c0> @ imm = #-0x2
;                     r = Sciclient_rmIrqGetNode(cur_if->rid, &next_n);
7009bbd0: 9804         	ldr	r0, [sp, #0x10]
7009bbd2: 88c0         	ldrh	r0, [r0, #0x6]
7009bbd4: a905         	add	r1, sp, #0x14
7009bbd6: f008 fb7b    	bl	0x700a42d0 <Sciclient_rmIrqGetNode> @ imm = #0x86f6
7009bbda: 900c         	str	r0, [sp, #0x30]
;                     if (r != SystemP_SUCCESS) {
7009bbdc: 980c         	ldr	r0, [sp, #0x30]
7009bbde: b108         	cbz	r0, 0x7009bbe4 <Sciclient_rmIrqGetRoute+0x1d4> @ imm = #0x2
7009bbe0: e7ff         	b	0x7009bbe2 <Sciclient_rmIrqGetRoute+0x1d2> @ imm = #-0x2
;                         break;
7009bbe2: e028         	b	0x7009bc36 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x50
;                     next_inp = SCICLIENT_OUTP_TO_INP(outp,
7009bbe4: 9a04         	ldr	r2, [sp, #0x10]
7009bbe6: 8850         	ldrh	r0, [r2, #0x2]
7009bbe8: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
7009bbec: 8812         	ldrh	r2, [r2]
7009bbee: 1a89         	subs	r1, r1, r2
7009bbf0: 4408         	add	r0, r1
7009bbf2: f8ad 0026    	strh.w	r0, [sp, #0x26]
;                     r = Sciclient_rmIrGetOutp(next_n->id, next_inp,
7009bbf6: 9805         	ldr	r0, [sp, #0x14]
7009bbf8: 8800         	ldrh	r0, [r0]
7009bbfa: f8bd 1026    	ldrh.w	r1, [sp, #0x26]
7009bbfe: f10d 0222    	add.w	r2, sp, #0x22
7009bc02: f007 ff95    	bl	0x700a3b30 <Sciclient_rmIrGetOutp> @ imm = #0x7f2a
7009bc06: 900c         	str	r0, [sp, #0x30]
;                     if (r == SystemP_SUCCESS) {
7009bc08: 980c         	ldr	r0, [sp, #0x30]
7009bc0a: b930         	cbnz	r0, 0x7009bc1a <Sciclient_rmIrqGetRoute+0x20a> @ imm = #0xc
7009bc0c: e7ff         	b	0x7009bc0e <Sciclient_rmIrqGetRoute+0x1fe> @ imm = #-0x2
7009bc0e: 2001         	movs	r0, #0x1
;                         push_node = true;
7009bc10: f88d 001f    	strb.w	r0, [sp, #0x1f]
7009bc14: 2000         	movs	r0, #0x0
;                         r = SystemP_SUCCESS;
7009bc16: 900c         	str	r0, [sp, #0x30]
;                         break;
7009bc18: e00d         	b	0x7009bc36 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x1a
;                     if (r != SystemP_FAILURE) {
7009bc1a: 980c         	ldr	r0, [sp, #0x30]
7009bc1c: 3001         	adds	r0, #0x1
7009bc1e: b108         	cbz	r0, 0x7009bc24 <Sciclient_rmIrqGetRoute+0x214> @ imm = #0x2
7009bc20: e7ff         	b	0x7009bc22 <Sciclient_rmIrqGetRoute+0x212> @ imm = #-0x2
;                         break;
7009bc22: e008         	b	0x7009bc36 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x10
;                 }
7009bc24: e7ff         	b	0x7009bc26 <Sciclient_rmIrqGetRoute+0x216> @ imm = #-0x2
;             }
7009bc26: e7ff         	b	0x7009bc28 <Sciclient_rmIrqGetRoute+0x218> @ imm = #-0x2
;         }
7009bc28: e7ff         	b	0x7009bc2a <Sciclient_rmIrqGetRoute+0x21a> @ imm = #-0x2
;         for (if_idx = 0u; if_idx < cur_n->n_if; if_idx++) {
7009bc2a: f8bd 002c    	ldrh.w	r0, [sp, #0x2c]
7009bc2e: 3001         	adds	r0, #0x1
7009bc30: f8ad 002c    	strh.w	r0, [sp, #0x2c]
7009bc34: e78d         	b	0x7009bb52 <Sciclient_rmIrqGetRoute+0x142> @ imm = #-0xe6
;         if (r != SystemP_SUCCESS) {
7009bc36: 980c         	ldr	r0, [sp, #0x30]
7009bc38: b108         	cbz	r0, 0x7009bc3e <Sciclient_rmIrqGetRoute+0x22e> @ imm = #0x2
7009bc3a: e7ff         	b	0x7009bc3c <Sciclient_rmIrqGetRoute+0x22c> @ imm = #-0x2
;             break;
7009bc3c: e05a         	b	0x7009bcf4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0xb4
;         if ((rt_complete == true) || (push_node == true)) {
7009bc3e: f89d 0020    	ldrb.w	r0, [sp, #0x20]
7009bc42: 07c0         	lsls	r0, r0, #0x1f
7009bc44: b930         	cbnz	r0, 0x7009bc54 <Sciclient_rmIrqGetRoute+0x244> @ imm = #0xc
7009bc46: e7ff         	b	0x7009bc48 <Sciclient_rmIrqGetRoute+0x238> @ imm = #-0x2
7009bc48: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009bc4c: 07c0         	lsls	r0, r0, #0x1f
7009bc4e: 2800         	cmp	r0, #0x0
7009bc50: d049         	beq	0x7009bce6 <Sciclient_rmIrqGetRoute+0x2d6> @ imm = #0x92
7009bc52: e7ff         	b	0x7009bc54 <Sciclient_rmIrqGetRoute+0x244> @ imm = #-0x2
;             r = Sciclient_rmPsPush(cur_n, if_idx);
7009bc54: 9806         	ldr	r0, [sp, #0x18]
7009bc56: f8bd 102c    	ldrh.w	r1, [sp, #0x2c]
7009bc5a: f00e feb1    	bl	0x700aa9c0 <Sciclient_rmPsPush> @ imm = #0xed62
7009bc5e: 900c         	str	r0, [sp, #0x30]
;             if (r != SystemP_SUCCESS) {
7009bc60: 980c         	ldr	r0, [sp, #0x30]
7009bc62: b108         	cbz	r0, 0x7009bc68 <Sciclient_rmIrqGetRoute+0x258> @ imm = #0x2
7009bc64: e7ff         	b	0x7009bc66 <Sciclient_rmIrqGetRoute+0x256> @ imm = #-0x2
;                 break;
7009bc66: e045         	b	0x7009bcf4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x8a
;             if ((search_depth > 0u) ||
7009bc68: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009bc6c: b950         	cbnz	r0, 0x7009bc84 <Sciclient_rmIrqGetRoute+0x274> @ imm = #0x14
7009bc6e: e7ff         	b	0x7009bc70 <Sciclient_rmIrqGetRoute+0x260> @ imm = #-0x2
;                 ((search_depth == 0u) &&
7009bc70: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009bc74: bb28         	cbnz	r0, 0x7009bcc2 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #0x4a
7009bc76: e7ff         	b	0x7009bc78 <Sciclient_rmIrqGetRoute+0x268> @ imm = #-0x2
;                  (Sciclient_rmIaIsIa(cur_n->id) == true))) {
7009bc78: 9806         	ldr	r0, [sp, #0x18]
7009bc7a: 8800         	ldrh	r0, [r0]
7009bc7c: f011 f860    	bl	0x700acd40 <Sciclient_rmIaIsIa> @ imm = #0x110c0
;             if ((search_depth > 0u) ||
7009bc80: b1f8         	cbz	r0, 0x7009bcc2 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #0x3e
7009bc82: e7ff         	b	0x7009bc84 <Sciclient_rmIrqGetRoute+0x274> @ imm = #-0x2
;                 cur_psp = Sciclient_rmPsGetPsp();
7009bc84: f012 fa34    	bl	0x700ae0f0 <Sciclient_rmPsGetPsp> @ imm = #0x12468
7009bc88: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;                 r = Sciclient_rmPsSetInp(cur_psp - (1u), inp);
7009bc8c: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009bc90: 3801         	subs	r0, #0x1
7009bc92: f8bd 1028    	ldrh.w	r1, [sp, #0x28]
7009bc96: b280         	uxth	r0, r0
7009bc98: f00f fd4a    	bl	0x700ab730 <Sciclient_rmPsSetInp> @ imm = #0xfa94
7009bc9c: 900c         	str	r0, [sp, #0x30]
;                 if (r != SystemP_SUCCESS) {
7009bc9e: 980c         	ldr	r0, [sp, #0x30]
7009bca0: b108         	cbz	r0, 0x7009bca6 <Sciclient_rmIrqGetRoute+0x296> @ imm = #0x2
7009bca2: e7ff         	b	0x7009bca4 <Sciclient_rmIrqGetRoute+0x294> @ imm = #-0x2
;                     break;
7009bca4: e026         	b	0x7009bcf4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x4c
;                 r = Sciclient_rmPsSetOutp(cur_psp - (1u),
7009bca6: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009bcaa: 3801         	subs	r0, #0x1
;                         outp);
7009bcac: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
;                 r = Sciclient_rmPsSetOutp(cur_psp - (1u),
7009bcb0: b280         	uxth	r0, r0
7009bcb2: f00f fd65    	bl	0x700ab780 <Sciclient_rmPsSetOutp> @ imm = #0xfaca
7009bcb6: 900c         	str	r0, [sp, #0x30]
;                 if (r != SystemP_SUCCESS) {
7009bcb8: 980c         	ldr	r0, [sp, #0x30]
7009bcba: b108         	cbz	r0, 0x7009bcc0 <Sciclient_rmIrqGetRoute+0x2b0> @ imm = #0x2
7009bcbc: e7ff         	b	0x7009bcbe <Sciclient_rmIrqGetRoute+0x2ae> @ imm = #-0x2
;                     break;
7009bcbe: e019         	b	0x7009bcf4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x32
;             }
7009bcc0: e7ff         	b	0x7009bcc2 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #-0x2
;             if (rt_complete == true) {
7009bcc2: f89d 0020    	ldrb.w	r0, [sp, #0x20]
7009bcc6: 07c0         	lsls	r0, r0, #0x1f
7009bcc8: b108         	cbz	r0, 0x7009bcce <Sciclient_rmIrqGetRoute+0x2be> @ imm = #0x2
7009bcca: e7ff         	b	0x7009bccc <Sciclient_rmIrqGetRoute+0x2bc> @ imm = #-0x2
;                 break;
7009bccc: e012         	b	0x7009bcf4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x24
;                 cur_n = next_n;
7009bcce: 9805         	ldr	r0, [sp, #0x14]
7009bcd0: 9006         	str	r0, [sp, #0x18]
;                 inp = next_inp;
7009bcd2: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
7009bcd6: f8ad 0028    	strh.w	r0, [sp, #0x28]
;                 outp = next_outp;
7009bcda: f8bd 0022    	ldrh.w	r0, [sp, #0x22]
7009bcde: f8ad 0024    	strh.w	r0, [sp, #0x24]
7009bce2: e7ff         	b	0x7009bce4 <Sciclient_rmIrqGetRoute+0x2d4> @ imm = #-0x2
;         }
7009bce4: e7ff         	b	0x7009bce6 <Sciclient_rmIrqGetRoute+0x2d6> @ imm = #-0x2
;     }
7009bce6: e7ff         	b	0x7009bce8 <Sciclient_rmIrqGetRoute+0x2d8> @ imm = #-0x2
;          search_depth++) {
7009bce8: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009bcec: 3001         	adds	r0, #0x1
7009bcee: f8ad 002e    	strh.w	r0, [sp, #0x2e]
;     for (search_depth = 0u;
7009bcf2: e710         	b	0x7009bb16 <Sciclient_rmIrqGetRoute+0x106> @ imm = #-0x1e0
;     if (search_depth >= Sciclient_rmPsGetMaxPsp()) {
7009bcf4: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009bcf8: 9001         	str	r0, [sp, #0x4]
7009bcfa: f012 fa59    	bl	0x700ae1b0 <Sciclient_rmPsGetMaxPsp> @ imm = #0x124b2
7009bcfe: 4601         	mov	r1, r0
7009bd00: 9801         	ldr	r0, [sp, #0x4]
7009bd02: 4288         	cmp	r0, r1
7009bd04: db04         	blt	0x7009bd10 <Sciclient_rmIrqGetRoute+0x300> @ imm = #0x8
7009bd06: e7ff         	b	0x7009bd08 <Sciclient_rmIrqGetRoute+0x2f8> @ imm = #-0x2
7009bd08: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
7009bd0c: 900c         	str	r0, [sp, #0x30]
;     }
7009bd0e: e7ff         	b	0x7009bd10 <Sciclient_rmIrqGetRoute+0x300> @ imm = #-0x2
;     return r;
7009bd10: 980c         	ldr	r0, [sp, #0x30]
7009bd12: b00e         	add	sp, #0x38
7009bd14: bd80         	pop	{r7, pc}
7009bd16: 0000         	movs	r0, r0

7009bd18 <$Ven$TA$L$PI$$HwiP_enable>:
7009bd18: f8df f000    	ldr.w	pc, [pc, #0x0]          @ 0x7009bd1c <$Ven$TA$L$PI$$HwiP_enable+0x4>
7009bd1c: e0 ed 0a 70  	.word	0x700aede0

7009bd20 <Udma_eventReset>:
; {
7009bd20: b580         	push	{r7, lr}
7009bd22: b090         	sub	sp, #0x40
7009bd24: 900f         	str	r0, [sp, #0x3c]
7009bd26: 910e         	str	r1, [sp, #0x38]
7009bd28: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009bd2a: 9001         	str	r0, [sp, #0x4]
7009bd2c: 900d         	str	r0, [sp, #0x34]
;     eventPrms = &eventHandle->eventPrms;
7009bd2e: 990e         	ldr	r1, [sp, #0x38]
7009bd30: 3108         	adds	r1, #0x8
7009bd32: 9109         	str	r1, [sp, #0x24]
;     rmIrqReq.valid_params           = 0U;
7009bd34: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.global_event           = 0U;
7009bd36: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     rmIrqReq.src_id                 = 0U;
7009bd3a: f8ad 0014    	strh.w	r0, [sp, #0x14]
;     rmIrqReq.src_index              = 0U;
7009bd3e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;     rmIrqReq.dst_id                 = 0U;
7009bd42: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     rmIrqReq.dst_host_irq           = 0U;
7009bd46: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     rmIrqReq.ia_id                  = 0U;
7009bd4a: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.vint                   = 0U;
7009bd4e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     rmIrqReq.vint_status_bit_index  = 0U;
7009bd52: f88d 0022    	strb.w	r0, [sp, #0x22]
7009bd56: 20ff         	movs	r0, #0xff
;     rmIrqReq.secondary_host         = TISCI_MSG_VALUE_RM_UNUSED_SECONDARY_HOST;
7009bd58: f88d 0023    	strb.w	r0, [sp, #0x23]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009bd5c: 9809         	ldr	r0, [sp, #0x24]
7009bd5e: 6800         	ldr	r0, [r0]
7009bd60: 2805         	cmp	r0, #0x5
7009bd62: d00a         	beq	0x7009bd7a <Udma_eventReset+0x5a> @ imm = #0x14
7009bd64: e7ff         	b	0x7009bd66 <Udma_eventReset+0x46> @ imm = #-0x2
;         rmIrqReq.valid_params  |= TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID;
7009bd66: 9804         	ldr	r0, [sp, #0x10]
7009bd68: f040 0010    	orr	r0, r0, #0x10
7009bd6c: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.global_event   = (uint16_t)Udma_eventGetId(eventHandle);
7009bd6e: 980e         	ldr	r0, [sp, #0x38]
7009bd70: f00f fd2e    	bl	0x700ab7d0 <Udma_eventGetId> @ imm = #0xfa5c
7009bd74: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     }
7009bd78: e7ff         	b	0x7009bd7a <Udma_eventReset+0x5a> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009bd7a: 980e         	ldr	r0, [sp, #0x38]
7009bd7c: 6d80         	ldr	r0, [r0, #0x58]
7009bd7e: f510 3f80    	cmn.w	r0, #0x10000
7009bd82: d012         	beq	0x7009bdaa <Udma_eventReset+0x8a> @ imm = #0x24
7009bd84: e7ff         	b	0x7009bd86 <Udma_eventReset+0x66> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_ID_VALID;
7009bd86: 9804         	ldr	r0, [sp, #0x10]
7009bd88: f040 0001    	orr	r0, r0, #0x1
7009bd8c: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID;
7009bd8e: 9804         	ldr	r0, [sp, #0x10]
7009bd90: f040 0002    	orr	r0, r0, #0x2
7009bd94: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.dst_id       = drvHandle->devIdCore;
7009bd96: 980f         	ldr	r0, [sp, #0x3c]
7009bd98: f8b0 00ea    	ldrh.w	r0, [r0, #0xea]
7009bd9c: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         rmIrqReq.dst_host_irq = (uint16_t)eventHandle->coreIntrNum;
7009bda0: 980e         	ldr	r0, [sp, #0x38]
7009bda2: 6d80         	ldr	r0, [r0, #0x58]
7009bda4: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     }
7009bda8: e7ff         	b	0x7009bdaa <Udma_eventReset+0x8a> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->eventPrms.controllerEventHandle)
7009bdaa: 980e         	ldr	r0, [sp, #0x38]
7009bdac: 6980         	ldr	r0, [r0, #0x18]
7009bdae: b128         	cbz	r0, 0x7009bdbc <Udma_eventReset+0x9c> @ imm = #0xa
7009bdb0: e7ff         	b	0x7009bdb2 <Udma_eventReset+0x92> @ imm = #-0x2
;         vintrNum = ((Udma_EventHandleInt) (eventHandle->eventPrms.controllerEventHandle))->vintrNum;
7009bdb2: 980e         	ldr	r0, [sp, #0x38]
7009bdb4: 6980         	ldr	r0, [r0, #0x18]
7009bdb6: 6cc0         	ldr	r0, [r0, #0x4c]
7009bdb8: 900c         	str	r0, [sp, #0x30]
;     }
7009bdba: e003         	b	0x7009bdc4 <Udma_eventReset+0xa4> @ imm = #0x6
;         vintrNum = eventHandle->vintrNum;
7009bdbc: 980e         	ldr	r0, [sp, #0x38]
7009bdbe: 6cc0         	ldr	r0, [r0, #0x4c]
7009bdc0: 900c         	str	r0, [sp, #0x30]
7009bdc2: e7ff         	b	0x7009bdc4 <Udma_eventReset+0xa4> @ imm = #-0x2
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_IA_ID_VALID;
7009bdc4: 9804         	ldr	r0, [sp, #0x10]
7009bdc6: f040 0004    	orr	r0, r0, #0x4
7009bdca: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_VALID;
7009bdcc: 9804         	ldr	r0, [sp, #0x10]
7009bdce: f040 0008    	orr	r0, r0, #0x8
7009bdd2: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.ia_id         = drvHandle->devIdIa;
7009bdd4: 980f         	ldr	r0, [sp, #0x3c]
7009bdd6: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009bdda: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.vint          = (uint16_t)vintrNum;
7009bdde: 980c         	ldr	r0, [sp, #0x30]
7009bde0: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
7009bde4: 980e         	ldr	r0, [sp, #0x38]
7009bde6: 6d00         	ldr	r0, [r0, #0x50]
7009bde8: f64f 71ff    	movw	r1, #0xffff
7009bdec: 4288         	cmp	r0, r1
7009bdee: d009         	beq	0x7009be04 <Udma_eventReset+0xe4> @ imm = #0x12
7009bdf0: e7ff         	b	0x7009bdf2 <Udma_eventReset+0xd2> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_STATUS_BIT_INDEX_VALID;
7009bdf2: 9804         	ldr	r0, [sp, #0x10]
7009bdf4: f040 0020    	orr	r0, r0, #0x20
7009bdf8: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.vint_status_bit_index  = (uint8_t)eventHandle->vintrBitNum;
7009bdfa: 980e         	ldr	r0, [sp, #0x38]
7009bdfc: 6d00         	ldr	r0, [r0, #0x50]
7009bdfe: f88d 0022    	strb.w	r0, [sp, #0x22]
;     }
7009be02: e7ff         	b	0x7009be04 <Udma_eventReset+0xe4> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009be04: 9809         	ldr	r0, [sp, #0x24]
7009be06: 6800         	ldr	r0, [r0]
7009be08: 2801         	cmp	r0, #0x1
7009be0a: d00a         	beq	0x7009be22 <Udma_eventReset+0x102> @ imm = #0x14
7009be0c: e7ff         	b	0x7009be0e <Udma_eventReset+0xee> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType)||
7009be0e: 9809         	ldr	r0, [sp, #0x24]
7009be10: 6800         	ldr	r0, [r0]
7009be12: 2806         	cmp	r0, #0x6
7009be14: d005         	beq	0x7009be22 <Udma_eventReset+0x102> @ imm = #0xa
7009be16: e7ff         	b	0x7009be18 <Udma_eventReset+0xf8> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType))
7009be18: 9809         	ldr	r0, [sp, #0x24]
7009be1a: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009be1c: 2802         	cmp	r0, #0x2
7009be1e: d14d         	bne	0x7009bebc <Udma_eventReset+0x19c> @ imm = #0x9a
7009be20: e7ff         	b	0x7009be22 <Udma_eventReset+0x102> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009be22: 9809         	ldr	r0, [sp, #0x24]
7009be24: 6880         	ldr	r0, [r0, #0x8]
7009be26: 900b         	str	r0, [sp, #0x2c]
;         rmIrqReq.src_id = drvHandle->srcIdRingIrq;
7009be28: 980f         	ldr	r0, [sp, #0x3c]
7009be2a: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009be2e: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009be32: 9809         	ldr	r0, [sp, #0x24]
7009be34: 6800         	ldr	r0, [r0]
7009be36: 2801         	cmp	r0, #0x1
7009be38: d005         	beq	0x7009be46 <Udma_eventReset+0x126> @ imm = #0xa
7009be3a: e7ff         	b	0x7009be3c <Udma_eventReset+0x11c> @ imm = #-0x2
7009be3c: 9809         	ldr	r0, [sp, #0x24]
7009be3e: 6800         	ldr	r0, [r0]
7009be40: 2806         	cmp	r0, #0x6
7009be42: d12e         	bne	0x7009bea2 <Udma_eventReset+0x182> @ imm = #0x5c
7009be44: e7ff         	b	0x7009be46 <Udma_eventReset+0x126> @ imm = #-0x2
;             rmIrqReq.src_index = chHandle->cqRing->ringNum;
7009be46: 980b         	ldr	r0, [sp, #0x2c]
7009be48: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009be4c: 8880         	ldrh	r0, [r0, #0x4]
7009be4e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009be52: 980b         	ldr	r0, [sp, #0x2c]
7009be54: 7800         	ldrb	r0, [r0]
7009be56: 0740         	lsls	r0, r0, #0x1d
7009be58: 2800         	cmp	r0, #0x0
7009be5a: d509         	bpl	0x7009be70 <Udma_eventReset+0x150> @ imm = #0x12
7009be5c: e7ff         	b	0x7009be5e <Udma_eventReset+0x13e> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->blkCopyRingIrqOffset;
7009be5e: 980f         	ldr	r0, [sp, #0x3c]
7009be60: f8d0 10f0    	ldr.w	r1, [r0, #0xf0]
7009be64: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009be68: 4408         	add	r0, r1
7009be6a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009be6e: e017         	b	0x7009bea0 <Udma_eventReset+0x180> @ imm = #0x2e
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009be70: 980b         	ldr	r0, [sp, #0x2c]
7009be72: 7800         	ldrb	r0, [r0]
7009be74: 07c0         	lsls	r0, r0, #0x1f
7009be76: b148         	cbz	r0, 0x7009be8c <Udma_eventReset+0x16c> @ imm = #0x12
7009be78: e7ff         	b	0x7009be7a <Udma_eventReset+0x15a> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009be7a: 980f         	ldr	r0, [sp, #0x3c]
7009be7c: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009be80: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009be84: 4408         	add	r0, r1
7009be86: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009be8a: e008         	b	0x7009be9e <Udma_eventReset+0x17e> @ imm = #0x10
;                 rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009be8c: 980f         	ldr	r0, [sp, #0x3c]
7009be8e: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009be92: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009be96: 4408         	add	r0, r1
7009be98: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009be9c: e7ff         	b	0x7009be9e <Udma_eventReset+0x17e> @ imm = #-0x2
7009be9e: e7ff         	b	0x7009bea0 <Udma_eventReset+0x180> @ imm = #-0x2
;         }
7009bea0: e00b         	b	0x7009beba <Udma_eventReset+0x19a> @ imm = #0x16
;             rmIrqReq.src_index = chHandle->tdCqRing->ringNum;
7009bea2: 980b         	ldr	r0, [sp, #0x2c]
7009bea4: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009bea8: 8880         	ldrh	r0, [r0, #0x4]
7009beaa: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             rmIrqReq.src_index += TISCI_RINGACC0_OES_IRQ_SRC_IDX_START;
7009beae: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009beb2: 3014         	adds	r0, #0x14
7009beb4: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009beb8: e7ff         	b	0x7009beba <Udma_eventReset+0x19a> @ imm = #-0x2
;     }
7009beba: e7ff         	b	0x7009bebc <Udma_eventReset+0x19c> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009bebc: 9809         	ldr	r0, [sp, #0x24]
7009bebe: 6800         	ldr	r0, [r0]
7009bec0: 2803         	cmp	r0, #0x3
7009bec2: d156         	bne	0x7009bf72 <Udma_eventReset+0x252> @ imm = #0xac
7009bec4: e7ff         	b	0x7009bec6 <Udma_eventReset+0x1a6> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009bec6: 980f         	ldr	r0, [sp, #0x3c]
7009bec8: 6800         	ldr	r0, [r0]
7009beca: 2802         	cmp	r0, #0x2
7009becc: d104         	bne	0x7009bed8 <Udma_eventReset+0x1b8> @ imm = #0x8
7009bece: e7ff         	b	0x7009bed0 <Udma_eventReset+0x1b0> @ imm = #-0x2
7009bed0: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009bed4: 900d         	str	r0, [sp, #0x34]
;         }
7009bed6: e04b         	b	0x7009bf70 <Udma_eventReset+0x250> @ imm = #0x96
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009bed8: 9809         	ldr	r0, [sp, #0x24]
7009beda: 6880         	ldr	r0, [r0, #0x8]
7009bedc: 900b         	str	r0, [sp, #0x2c]
;             rmIrqReq.src_id = drvHandle->srcIdTrIrq;
7009bede: 980f         	ldr	r0, [sp, #0x3c]
7009bee0: f8b0 00fc    	ldrh.w	r0, [r0, #0xfc]
7009bee4: f8ad 0014    	strh.w	r0, [sp, #0x14]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009bee8: 980b         	ldr	r0, [sp, #0x2c]
7009beea: 7800         	ldrb	r0, [r0]
7009beec: 0740         	lsls	r0, r0, #0x1d
7009beee: 2800         	cmp	r0, #0x0
7009bef0: d50d         	bpl	0x7009bf0e <Udma_eventReset+0x1ee> @ imm = #0x1a
7009bef2: e7ff         	b	0x7009bef4 <Udma_eventReset+0x1d4> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009bef4: 980b         	ldr	r0, [sp, #0x2c]
7009bef6: 6ec0         	ldr	r0, [r0, #0x6c]
7009bef8: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->blkCopyTrIrqOffset;
7009befc: 980f         	ldr	r0, [sp, #0x3c]
7009befe: f8d0 1100    	ldr.w	r1, [r0, #0x100]
7009bf02: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bf06: 4408         	add	r0, r1
7009bf08: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009bf0c: e02f         	b	0x7009bf6e <Udma_eventReset+0x24e> @ imm = #0x5e
;             else if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009bf0e: 980b         	ldr	r0, [sp, #0x2c]
7009bf10: 7800         	ldrb	r0, [r0]
7009bf12: 0780         	lsls	r0, r0, #0x1e
7009bf14: 2800         	cmp	r0, #0x0
7009bf16: d50d         	bpl	0x7009bf34 <Udma_eventReset+0x214> @ imm = #0x1a
7009bf18: e7ff         	b	0x7009bf1a <Udma_eventReset+0x1fa> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->rxChNum;
7009bf1a: 980b         	ldr	r0, [sp, #0x2c]
7009bf1c: 6f00         	ldr	r0, [r0, #0x70]
7009bf1e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->rxTrIrqOffset;
7009bf22: 980f         	ldr	r0, [sp, #0x3c]
7009bf24: f8d0 1108    	ldr.w	r1, [r0, #0x108]
7009bf28: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bf2c: 4408         	add	r0, r1
7009bf2e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009bf32: e01b         	b	0x7009bf6c <Udma_eventReset+0x24c> @ imm = #0x36
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009bf34: 980b         	ldr	r0, [sp, #0x2c]
7009bf36: 7800         	ldrb	r0, [r0]
7009bf38: 07c0         	lsls	r0, r0, #0x1f
7009bf3a: b168         	cbz	r0, 0x7009bf58 <Udma_eventReset+0x238> @ imm = #0x1a
7009bf3c: e7ff         	b	0x7009bf3e <Udma_eventReset+0x21e> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009bf3e: 980b         	ldr	r0, [sp, #0x2c]
7009bf40: 6ec0         	ldr	r0, [r0, #0x6c]
7009bf42: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->txTrIrqOffset;
7009bf46: 980f         	ldr	r0, [sp, #0x3c]
7009bf48: f8d0 1104    	ldr.w	r1, [r0, #0x104]
7009bf4c: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bf50: 4408         	add	r0, r1
7009bf52: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009bf56: e008         	b	0x7009bf6a <Udma_eventReset+0x24a> @ imm = #0x10
;                 rmIrqReq.src_id = drvHandle->devIdIa;
7009bf58: 980f         	ldr	r0, [sp, #0x3c]
7009bf5a: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009bf5e: f8ad 0014    	strh.w	r0, [sp, #0x14]
7009bf62: 2000         	movs	r0, #0x0
;                 rmIrqReq.src_index = 0U;                /* Not used by DMSC RM */
7009bf64: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009bf68: e7ff         	b	0x7009bf6a <Udma_eventReset+0x24a> @ imm = #-0x2
7009bf6a: e7ff         	b	0x7009bf6c <Udma_eventReset+0x24c> @ imm = #-0x2
7009bf6c: e7ff         	b	0x7009bf6e <Udma_eventReset+0x24e> @ imm = #-0x2
7009bf6e: e7ff         	b	0x7009bf70 <Udma_eventReset+0x250> @ imm = #-0x2
;     }
7009bf70: e7ff         	b	0x7009bf72 <Udma_eventReset+0x252> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
7009bf72: 9809         	ldr	r0, [sp, #0x24]
7009bf74: 6800         	ldr	r0, [r0]
7009bf76: 2804         	cmp	r0, #0x4
7009bf78: d130         	bne	0x7009bfdc <Udma_eventReset+0x2bc> @ imm = #0x60
7009bf7a: e7ff         	b	0x7009bf7c <Udma_eventReset+0x25c> @ imm = #-0x2
;         ringHandle = (Udma_RingHandleInt) eventPrms->ringHandle;
7009bf7c: 9809         	ldr	r0, [sp, #0x24]
7009bf7e: 68c0         	ldr	r0, [r0, #0xc]
7009bf80: 900a         	str	r0, [sp, #0x28]
;         rmIrqReq.src_id     = drvHandle->srcIdRingIrq;
7009bf82: 980f         	ldr	r0, [sp, #0x3c]
7009bf84: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009bf88: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmIrqReq.src_index  = ringHandle->ringNum;
7009bf8c: 980a         	ldr	r0, [sp, #0x28]
7009bf8e: 8880         	ldrh	r0, [r0, #0x4]
7009bf90: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009bf94: 980f         	ldr	r0, [sp, #0x3c]
7009bf96: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009bf9a: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bf9e: 4408         	add	r0, r1
7009bfa0: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009bfa4: 980a         	ldr	r0, [sp, #0x28]
7009bfa6: 6dc0         	ldr	r0, [r0, #0x5c]
7009bfa8: 2804         	cmp	r0, #0x4
7009bfaa: d316         	blo	0x7009bfda <Udma_eventReset+0x2ba> @ imm = #0x2c
7009bfac: e7ff         	b	0x7009bfae <Udma_eventReset+0x28e> @ imm = #-0x2
;            (ringHandle->mappedRingGrp < (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
7009bfae: 980a         	ldr	r0, [sp, #0x28]
7009bfb0: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009bfb2: 2807         	cmp	r0, #0x7
7009bfb4: d811         	bhi	0x7009bfda <Udma_eventReset+0x2ba> @ imm = #0x22
7009bfb6: e7ff         	b	0x7009bfb8 <Udma_eventReset+0x298> @ imm = #-0x2
;             rmIrqReq.src_index -= drvHandle->txRingIrqOffset;
7009bfb8: 980f         	ldr	r0, [sp, #0x3c]
7009bfba: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009bfbe: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bfc2: 1a40         	subs	r0, r0, r1
7009bfc4: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009bfc8: 980f         	ldr	r0, [sp, #0x3c]
7009bfca: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009bfce: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bfd2: 4408         	add	r0, r1
7009bfd4: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         }
7009bfd8: e7ff         	b	0x7009bfda <Udma_eventReset+0x2ba> @ imm = #-0x2
;     }
7009bfda: e7ff         	b	0x7009bfdc <Udma_eventReset+0x2bc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009bfdc: 980d         	ldr	r0, [sp, #0x34]
7009bfde: b9b0         	cbnz	r0, 0x7009c00e <Udma_eventReset+0x2ee> @ imm = #0x2c
7009bfe0: e7ff         	b	0x7009bfe2 <Udma_eventReset+0x2c2> @ imm = #-0x2
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009bfe2: 980f         	ldr	r0, [sp, #0x3c]
7009bfe4: 6800         	ldr	r0, [r0]
7009bfe6: b130         	cbz	r0, 0x7009bff6 <Udma_eventReset+0x2d6> @ imm = #0xc
7009bfe8: e7ff         	b	0x7009bfea <Udma_eventReset+0x2ca> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009bfea: 9809         	ldr	r0, [sp, #0x24]
7009bfec: 6800         	ldr	r0, [r0]
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009bfee: 2805         	cmp	r0, #0x5
7009bff0: d101         	bne	0x7009bff6 <Udma_eventReset+0x2d6> @ imm = #0x2
7009bff2: e7ff         	b	0x7009bff4 <Udma_eventReset+0x2d4> @ imm = #-0x2
;         }
7009bff4: e00a         	b	0x7009c00c <Udma_eventReset+0x2ec> @ imm = #0x14
7009bff6: a802         	add	r0, sp, #0x8
7009bff8: f04f 31ff    	mov.w	r1, #0xffffffff
;             retVal = Sciclient_rmIrqRelease(&rmIrqReq, UDMA_SCICLIENT_TIMEOUT);
7009bffc: f011 fe80    	bl	0x700add00 <Sciclient_rmIrqRelease> @ imm = #0x11d00
7009c000: 900d         	str	r0, [sp, #0x34]
;             if(CSL_PASS != retVal)
7009c002: 980d         	ldr	r0, [sp, #0x34]
7009c004: b108         	cbz	r0, 0x7009c00a <Udma_eventReset+0x2ea> @ imm = #0x2
7009c006: e7ff         	b	0x7009c008 <Udma_eventReset+0x2e8> @ imm = #-0x2
;             }
7009c008: e7ff         	b	0x7009c00a <Udma_eventReset+0x2ea> @ imm = #-0x2
7009c00a: e7ff         	b	0x7009c00c <Udma_eventReset+0x2ec> @ imm = #-0x2
;     }
7009c00c: e7ff         	b	0x7009c00e <Udma_eventReset+0x2ee> @ imm = #-0x2
;     return (retVal);
7009c00e: 980d         	ldr	r0, [sp, #0x34]
7009c010: b010         	add	sp, #0x40
7009c012: bd80         	pop	{r7, pc}
		...

7009c020 <Sciclient_service>:
; {
7009c020: b580         	push	{r7, lr}
7009c022: b094         	sub	sp, #0x50
7009c024: 9013         	str	r0, [sp, #0x4c]
7009c026: 9112         	str	r1, [sp, #0x48]
7009c028: 2000         	movs	r0, #0x0
;     int32_t   status        = SystemP_SUCCESS;
7009c02a: 9011         	str	r0, [sp, #0x44]
7009c02c: 210f         	movs	r1, #0xf
;     uint32_t  contextId     = SCICLIENT_CONTEXT_MAX_NUM;
7009c02e: 9110         	str	r1, [sp, #0x40]
;     uint32_t  initialCount  = 0U;
7009c030: 900f         	str	r0, [sp, #0x3c]
;     uint8_t   localSeqId    = gSciclientHandle.currSeqId;
7009c032: f640 5100    	movw	r1, #0xd00
7009c036: f2c7 010b    	movt	r1, #0x700b
7009c03a: 6809         	ldr	r1, [r1]
7009c03c: f88d 103b    	strb.w	r1, [sp, #0x3b]
;     uint32_t  txPayloadSize = 0U;
7009c040: 900d         	str	r0, [sp, #0x34]
;     uint32_t  rxPayloadSize = 0U;
7009c042: 900c         	str	r0, [sp, #0x30]
;     uint8_t  *pLocalRespPayload = NULL;
7009c044: 900b         	str	r0, [sp, #0x2c]
;     uint8_t  *pSecHeader = NULL;
7009c046: 9007         	str	r0, [sp, #0x1c]
;     if((pReqPrm == NULL) || (pRespPrm == NULL) || (pReqPrm->pReqPayload == NULL))
7009c048: 9813         	ldr	r0, [sp, #0x4c]
7009c04a: b138         	cbz	r0, 0x7009c05c <Sciclient_service+0x3c> @ imm = #0xe
7009c04c: e7ff         	b	0x7009c04e <Sciclient_service+0x2e> @ imm = #-0x2
7009c04e: 9812         	ldr	r0, [sp, #0x48]
7009c050: b120         	cbz	r0, 0x7009c05c <Sciclient_service+0x3c> @ imm = #0x8
7009c052: e7ff         	b	0x7009c054 <Sciclient_service+0x34> @ imm = #-0x2
7009c054: 9813         	ldr	r0, [sp, #0x4c]
7009c056: 6880         	ldr	r0, [r0, #0x8]
7009c058: b920         	cbnz	r0, 0x7009c064 <Sciclient_service+0x44> @ imm = #0x8
7009c05a: e7ff         	b	0x7009c05c <Sciclient_service+0x3c> @ imm = #-0x2
7009c05c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009c060: 9011         	str	r0, [sp, #0x44]
;     }
7009c062: e09e         	b	0x7009c1a2 <Sciclient_service+0x182> @ imm = #0x13c
;         contextId = Sciclient_getCurrentContext(pReqPrm->messageType);
7009c064: 9813         	ldr	r0, [sp, #0x4c]
7009c066: 8800         	ldrh	r0, [r0]
7009c068: f009 ffa2    	bl	0x700a5fb0 <Sciclient_getCurrentContext> @ imm = #0x9f44
7009c06c: 9010         	str	r0, [sp, #0x40]
;         if(contextId < SCICLIENT_CONTEXT_MAX_NUM)
7009c06e: 9810         	ldr	r0, [sp, #0x40]
7009c070: 280e         	cmp	r0, #0xe
7009c072: f200 8091    	bhi.w	0x7009c198 <Sciclient_service+0x178> @ imm = #0x122
7009c076: e7ff         	b	0x7009c078 <Sciclient_service+0x58> @ imm = #-0x2
;             txThread = Sciclient_getTxThreadId(contextId);
7009c078: 9810         	ldr	r0, [sp, #0x40]
7009c07a: f011 fbc9    	bl	0x700ad810 <Sciclient_getTxThreadId> @ imm = #0x11792
7009c07e: 900a         	str	r0, [sp, #0x28]
;             rxThread = Sciclient_getRxThreadId(contextId);
7009c080: 9810         	ldr	r0, [sp, #0x40]
7009c082: f011 fbb5    	bl	0x700ad7f0 <Sciclient_getRxThreadId> @ imm = #0x1176a
7009c086: 9009         	str	r0, [sp, #0x24]
;             if(gSciclientMap[contextId].context == SCICLIENT_SECURE_CONTEXT)
7009c088: 9810         	ldr	r0, [sp, #0x40]
7009c08a: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009c08e: f24f 70b8    	movw	r0, #0xf7b8
7009c092: f2c7 000a    	movt	r0, #0x700a
7009c096: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
7009c09a: b938         	cbnz	r0, 0x7009c0ac <Sciclient_service+0x8c> @ imm = #0xe
7009c09c: e7ff         	b	0x7009c09e <Sciclient_service+0x7e> @ imm = #-0x2
;                 gSecHeaderSizeWords = sizeof(struct tisci_sec_header)/sizeof(uint32_t);
7009c09e: f640 6104    	movw	r1, #0xe04
7009c0a2: f2c7 010b    	movt	r1, #0x700b
7009c0a6: 2001         	movs	r0, #0x1
7009c0a8: 7008         	strb	r0, [r1]
;             }
7009c0aa: e006         	b	0x7009c0ba <Sciclient_service+0x9a> @ imm = #0xc
;                 gSecHeaderSizeWords = 0;
7009c0ac: f640 6104    	movw	r1, #0xe04
7009c0b0: f2c7 010b    	movt	r1, #0x700b
7009c0b4: 2000         	movs	r0, #0x0
7009c0b6: 7008         	strb	r0, [r1]
7009c0b8: e7ff         	b	0x7009c0ba <Sciclient_service+0x9a> @ imm = #-0x2
;             gSciclientHandle.maxMsgSizeBytes = CSL_secProxyGetMaxMsgSize(&gSciclientSecProxyCfg) -
7009c0ba: f640 4078    	movw	r0, #0xc78
7009c0be: f2c7 000b    	movt	r0, #0x700b
7009c0c2: f010 fe25    	bl	0x700acd10 <CSL_secProxyGetMaxMsgSize> @ imm = #0x10c4a
7009c0c6: 3804         	subs	r0, #0x4
7009c0c8: f640 5100    	movw	r1, #0xd00
7009c0cc: f2c7 010b    	movt	r1, #0x700b
7009c0d0: 6148         	str	r0, [r1, #0x14]
;             if(gSciclientMap[contextId].context == SCICLIENT_SECURE_CONTEXT)
7009c0d2: 9810         	ldr	r0, [sp, #0x40]
7009c0d4: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009c0d8: f24f 70b8    	movw	r0, #0xf7b8
7009c0dc: f2c7 000a    	movt	r0, #0x700a
7009c0e0: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
7009c0e4: b940         	cbnz	r0, 0x7009c0f8 <Sciclient_service+0xd8> @ imm = #0x10
7009c0e6: e7ff         	b	0x7009c0e8 <Sciclient_service+0xc8> @ imm = #-0x2
7009c0e8: 2000         	movs	r0, #0x0
;                 secHeader.integ_check = (uint16_t)0;
7009c0ea: f8ad 0014    	strh.w	r0, [sp, #0x14]
;                 secHeader.rsvd = (uint16_t)0;
7009c0ee: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009c0f2: a805         	add	r0, sp, #0x14
;                 pSecHeader = (uint8_t * )(&secHeader);
7009c0f4: 9007         	str	r0, [sp, #0x1c]
;             }
7009c0f6: e7ff         	b	0x7009c0f8 <Sciclient_service+0xd8> @ imm = #-0x2
;             if (pReqPrm->reqPayloadSize > 0U)
7009c0f8: 9813         	ldr	r0, [sp, #0x4c]
7009c0fa: 68c0         	ldr	r0, [r0, #0xc]
7009c0fc: b128         	cbz	r0, 0x7009c10a <Sciclient_service+0xea> @ imm = #0xa
7009c0fe: e7ff         	b	0x7009c100 <Sciclient_service+0xe0> @ imm = #-0x2
;                 txPayloadSize = pReqPrm->reqPayloadSize - sizeof(struct tisci_header);
7009c100: 9813         	ldr	r0, [sp, #0x4c]
7009c102: 68c0         	ldr	r0, [r0, #0xc]
7009c104: 3808         	subs	r0, #0x8
7009c106: 900d         	str	r0, [sp, #0x34]
;             }
7009c108: e002         	b	0x7009c110 <Sciclient_service+0xf0> @ imm = #0x4
7009c10a: 2000         	movs	r0, #0x0
;                 txPayloadSize = 0U;
7009c10c: 900d         	str	r0, [sp, #0x34]
7009c10e: e7ff         	b	0x7009c110 <Sciclient_service+0xf0> @ imm = #-0x2
;             if (txPayloadSize > (gSciclientHandle.maxMsgSizeBytes - sizeof(struct tisci_header)))
7009c110: 980d         	ldr	r0, [sp, #0x34]
7009c112: f640 5100    	movw	r1, #0xd00
7009c116: f2c7 010b    	movt	r1, #0x700b
7009c11a: 6949         	ldr	r1, [r1, #0x14]
7009c11c: 3908         	subs	r1, #0x8
7009c11e: 4288         	cmp	r0, r1
7009c120: d904         	bls	0x7009c12c <Sciclient_service+0x10c> @ imm = #0x8
7009c122: e7ff         	b	0x7009c124 <Sciclient_service+0x104> @ imm = #-0x2
7009c124: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009c128: 9011         	str	r0, [sp, #0x44]
;             }
7009c12a: e7ff         	b	0x7009c12c <Sciclient_service+0x10c> @ imm = #-0x2
;             if ((txPayloadSize > 0U) && (pReqPrm->pReqPayload == NULL))
7009c12c: 980d         	ldr	r0, [sp, #0x34]
7009c12e: b140         	cbz	r0, 0x7009c142 <Sciclient_service+0x122> @ imm = #0x10
7009c130: e7ff         	b	0x7009c132 <Sciclient_service+0x112> @ imm = #-0x2
7009c132: 9813         	ldr	r0, [sp, #0x4c]
7009c134: 6880         	ldr	r0, [r0, #0x8]
7009c136: b920         	cbnz	r0, 0x7009c142 <Sciclient_service+0x122> @ imm = #0x8
7009c138: e7ff         	b	0x7009c13a <Sciclient_service+0x11a> @ imm = #-0x2
7009c13a: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009c13e: 9011         	str	r0, [sp, #0x44]
;             }
7009c140: e7ff         	b	0x7009c142 <Sciclient_service+0x122> @ imm = #-0x2
;             if (pRespPrm->respPayloadSize > 0U)
7009c142: 9812         	ldr	r0, [sp, #0x48]
7009c144: 6880         	ldr	r0, [r0, #0x8]
7009c146: b128         	cbz	r0, 0x7009c154 <Sciclient_service+0x134> @ imm = #0xa
7009c148: e7ff         	b	0x7009c14a <Sciclient_service+0x12a> @ imm = #-0x2
;                 rxPayloadSize = pRespPrm->respPayloadSize - sizeof(struct tisci_header);
7009c14a: 9812         	ldr	r0, [sp, #0x48]
7009c14c: 6880         	ldr	r0, [r0, #0x8]
7009c14e: 3808         	subs	r0, #0x8
7009c150: 900c         	str	r0, [sp, #0x30]
;             }
7009c152: e002         	b	0x7009c15a <Sciclient_service+0x13a> @ imm = #0x4
7009c154: 2000         	movs	r0, #0x0
;                 rxPayloadSize = 0U;
7009c156: 900c         	str	r0, [sp, #0x30]
7009c158: e7ff         	b	0x7009c15a <Sciclient_service+0x13a> @ imm = #-0x2
;             if (rxPayloadSize > (gSciclientHandle.maxMsgSizeBytes - sizeof(struct tisci_header)))
7009c15a: 980c         	ldr	r0, [sp, #0x30]
7009c15c: f640 5100    	movw	r1, #0xd00
7009c160: f2c7 010b    	movt	r1, #0x700b
7009c164: 6949         	ldr	r1, [r1, #0x14]
7009c166: 3908         	subs	r1, #0x8
7009c168: 4288         	cmp	r0, r1
7009c16a: d904         	bls	0x7009c176 <Sciclient_service+0x156> @ imm = #0x8
7009c16c: e7ff         	b	0x7009c16e <Sciclient_service+0x14e> @ imm = #-0x2
7009c16e: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009c172: 9011         	str	r0, [sp, #0x44]
;             }
7009c174: e7ff         	b	0x7009c176 <Sciclient_service+0x156> @ imm = #-0x2
;             if ((rxPayloadSize > 0U) && (pRespPrm->pRespPayload == NULL))
7009c176: 980c         	ldr	r0, [sp, #0x30]
7009c178: b140         	cbz	r0, 0x7009c18c <Sciclient_service+0x16c> @ imm = #0x10
7009c17a: e7ff         	b	0x7009c17c <Sciclient_service+0x15c> @ imm = #-0x2
7009c17c: 9812         	ldr	r0, [sp, #0x48]
7009c17e: 6840         	ldr	r0, [r0, #0x4]
7009c180: b920         	cbnz	r0, 0x7009c18c <Sciclient_service+0x16c> @ imm = #0x8
7009c182: e7ff         	b	0x7009c184 <Sciclient_service+0x164> @ imm = #-0x2
7009c184: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009c188: 9011         	str	r0, [sp, #0x44]
;             }
7009c18a: e004         	b	0x7009c196 <Sciclient_service+0x176> @ imm = #0x8
;                 pLocalRespPayload = (uint8_t *)(pRespPrm->pRespPayload + sizeof(struct tisci_header));
7009c18c: 9812         	ldr	r0, [sp, #0x48]
7009c18e: 6840         	ldr	r0, [r0, #0x4]
7009c190: 3008         	adds	r0, #0x8
7009c192: 900b         	str	r0, [sp, #0x2c]
7009c194: e7ff         	b	0x7009c196 <Sciclient_service+0x176> @ imm = #-0x2
;         }
7009c196: e003         	b	0x7009c1a0 <Sciclient_service+0x180> @ imm = #0x6
7009c198: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009c19c: 9011         	str	r0, [sp, #0x44]
7009c19e: e7ff         	b	0x7009c1a0 <Sciclient_service+0x180> @ imm = #-0x2
7009c1a0: e7ff         	b	0x7009c1a2 <Sciclient_service+0x182> @ imm = #-0x2
;     key = HwiP_disable();
7009c1a2: f012 ee0e    	blx	0x700aedc0 <HwiP_disable> @ imm = #0x12c1c
7009c1a6: 9008         	str	r0, [sp, #0x20]
;     if (SystemP_SUCCESS == status)
7009c1a8: 9811         	ldr	r0, [sp, #0x44]
7009c1aa: 2800         	cmp	r0, #0x0
7009c1ac: d159         	bne	0x7009c262 <Sciclient_service+0x242> @ imm = #0xb2
7009c1ae: e7ff         	b	0x7009c1b0 <Sciclient_service+0x190> @ imm = #-0x2
;         Sciclient_secProxyFlush(rxThread);
7009c1b0: 9809         	ldr	r0, [sp, #0x24]
7009c1b2: f010 fad5    	bl	0x700ac760 <Sciclient_secProxyFlush> @ imm = #0x105aa
;         header = (struct tisci_header*)pReqPrm->pReqPayload;
7009c1b6: 9813         	ldr	r0, [sp, #0x4c]
7009c1b8: 6880         	ldr	r0, [r0, #0x8]
7009c1ba: 9006         	str	r0, [sp, #0x18]
;         header->type = pReqPrm->messageType;
7009c1bc: 9813         	ldr	r0, [sp, #0x4c]
7009c1be: 8800         	ldrh	r0, [r0]
7009c1c0: 9906         	ldr	r1, [sp, #0x18]
7009c1c2: 8008         	strh	r0, [r1]
;         header->host = (uint8_t) gSciclientMap[contextId].hostId;
7009c1c4: 9810         	ldr	r0, [sp, #0x40]
7009c1c6: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009c1ca: f24f 70b8    	movw	r0, #0xf7b8
7009c1ce: f2c7 000a    	movt	r0, #0x700a
7009c1d2: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009c1d6: 6840         	ldr	r0, [r0, #0x4]
7009c1d8: 9906         	ldr	r1, [sp, #0x18]
7009c1da: 7088         	strb	r0, [r1, #0x2]
;         header->seq = localSeqId;
7009c1dc: f89d 003b    	ldrb.w	r0, [sp, #0x3b]
7009c1e0: 9906         	ldr	r1, [sp, #0x18]
7009c1e2: 70c8         	strb	r0, [r1, #0x3]
;         pFlags = (uint8_t*)&pReqPrm->flags;
7009c1e4: 9813         	ldr	r0, [sp, #0x4c]
7009c1e6: 3004         	adds	r0, #0x4
7009c1e8: 9004         	str	r0, [sp, #0x10]
7009c1ea: 2000         	movs	r0, #0x0
;         for (numBytes = 0; numBytes < sizeof(pReqPrm->flags); numBytes++)
7009c1ec: 9003         	str	r0, [sp, #0xc]
7009c1ee: e7ff         	b	0x7009c1f0 <Sciclient_service+0x1d0> @ imm = #-0x2
7009c1f0: 9803         	ldr	r0, [sp, #0xc]
7009c1f2: 2803         	cmp	r0, #0x3
7009c1f4: d811         	bhi	0x7009c21a <Sciclient_service+0x1fa> @ imm = #0x22
7009c1f6: e7ff         	b	0x7009c1f8 <Sciclient_service+0x1d8> @ imm = #-0x2
;             uint8_t *pDestFlags = ((uint8_t*)&header->flags) + numBytes;
7009c1f8: 9806         	ldr	r0, [sp, #0x18]
7009c1fa: 9903         	ldr	r1, [sp, #0xc]
7009c1fc: 4408         	add	r0, r1
7009c1fe: 3004         	adds	r0, #0x4
7009c200: 9002         	str	r0, [sp, #0x8]
;             *pDestFlags = *pFlags;
7009c202: 9804         	ldr	r0, [sp, #0x10]
7009c204: 7800         	ldrb	r0, [r0]
7009c206: 9902         	ldr	r1, [sp, #0x8]
7009c208: 7008         	strb	r0, [r1]
;             pFlags++;
7009c20a: 9804         	ldr	r0, [sp, #0x10]
7009c20c: 3001         	adds	r0, #0x1
7009c20e: 9004         	str	r0, [sp, #0x10]
;         }
7009c210: e7ff         	b	0x7009c212 <Sciclient_service+0x1f2> @ imm = #-0x2
;         for (numBytes = 0; numBytes < sizeof(pReqPrm->flags); numBytes++)
7009c212: 9803         	ldr	r0, [sp, #0xc]
7009c214: 3001         	adds	r0, #0x1
7009c216: 9003         	str	r0, [sp, #0xc]
7009c218: e7ea         	b	0x7009c1f0 <Sciclient_service+0x1d0> @ imm = #-0x2c
;         gSciclientHandle.currSeqId = (gSciclientHandle.currSeqId + 1U) %
7009c21a: f640 5100    	movw	r1, #0xd00
7009c21e: f2c7 010b    	movt	r1, #0x700b
7009c222: 6808         	ldr	r0, [r1]
7009c224: 3001         	adds	r0, #0x1
7009c226: f644 1225    	movw	r2, #0x4925
7009c22a: f2c2 4292    	movt	r2, #0x2492
7009c22e: fba0 3202    	umull	r3, r2, r0, r2
7009c232: 1a83         	subs	r3, r0, r2
7009c234: eb02 0353    	add.w	r3, r2, r3, lsr #1
7009c238: 089a         	lsrs	r2, r3, #0x2
7009c23a: 00d2         	lsls	r2, r2, #0x3
7009c23c: eba2 0293    	sub.w	r2, r2, r3, lsr #2
7009c240: 1a80         	subs	r0, r0, r2
7009c242: 6008         	str	r0, [r1]
;         status = Sciclient_secProxyVerifyThread(txThread);
7009c244: 980a         	ldr	r0, [sp, #0x28]
7009c246: f011 f87b    	bl	0x700ad340 <Sciclient_secProxyVerifyThread> @ imm = #0x110f6
7009c24a: 9011         	str	r0, [sp, #0x44]
;         if (SystemP_SUCCESS == status)
7009c24c: 9811         	ldr	r0, [sp, #0x44]
7009c24e: b938         	cbnz	r0, 0x7009c260 <Sciclient_service+0x240> @ imm = #0xe
7009c250: e7ff         	b	0x7009c252 <Sciclient_service+0x232> @ imm = #-0x2
;             status = Sciclient_secProxyWaitThread(txThread, pReqPrm->timeout);
7009c252: 980a         	ldr	r0, [sp, #0x28]
7009c254: 9913         	ldr	r1, [sp, #0x4c]
7009c256: 6909         	ldr	r1, [r1, #0x10]
7009c258: f00f ffa2    	bl	0x700ac1a0 <Sciclient_secProxyWaitThread> @ imm = #0xff44
7009c25c: 9011         	str	r0, [sp, #0x44]
;         }
7009c25e: e7ff         	b	0x7009c260 <Sciclient_service+0x240> @ imm = #-0x2
;     }
7009c260: e7ff         	b	0x7009c262 <Sciclient_service+0x242> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
7009c262: 9811         	ldr	r0, [sp, #0x44]
7009c264: b9b0         	cbnz	r0, 0x7009c294 <Sciclient_service+0x274> @ imm = #0x2c
7009c266: e7ff         	b	0x7009c268 <Sciclient_service+0x248> @ imm = #-0x2
;         initialCount = Sciclient_secProxyReadThreadCount(rxThread);
7009c268: 9809         	ldr	r0, [sp, #0x24]
7009c26a: f011 fd59    	bl	0x700add20 <Sciclient_secProxyReadThreadCount> @ imm = #0x11ab2
7009c26e: 900f         	str	r0, [sp, #0x3c]
;         Sciclient_sendMessage(txThread, pSecHeader ,(uint8_t *) header,
7009c270: 980a         	ldr	r0, [sp, #0x28]
7009c272: 9907         	ldr	r1, [sp, #0x1c]
7009c274: 9a06         	ldr	r2, [sp, #0x18]
;                               (pReqPrm->pReqPayload + sizeof(struct tisci_header)),
7009c276: 9b13         	ldr	r3, [sp, #0x4c]
7009c278: 689b         	ldr	r3, [r3, #0x8]
7009c27a: 3308         	adds	r3, #0x8
;                               txPayloadSize);
7009c27c: f8dd c034    	ldr.w	r12, [sp, #0x34]
;         Sciclient_sendMessage(txThread, pSecHeader ,(uint8_t *) header,
7009c280: 46ee         	mov	lr, sp
7009c282: f8ce c000    	str.w	r12, [lr]
7009c286: f004 fd03    	bl	0x700a0c90 <Sciclient_sendMessage> @ imm = #0x4a06
;         status = Sciclient_secProxyVerifyThread(rxThread);
7009c28a: 9809         	ldr	r0, [sp, #0x24]
7009c28c: f011 f858    	bl	0x700ad340 <Sciclient_secProxyVerifyThread> @ imm = #0x110b0
7009c290: 9011         	str	r0, [sp, #0x44]
;     }
7009c292: e7ff         	b	0x7009c294 <Sciclient_service+0x274> @ imm = #-0x2
;     if ((status == SystemP_SUCCESS) &&
7009c294: 9811         	ldr	r0, [sp, #0x44]
7009c296: b978         	cbnz	r0, 0x7009c2b8 <Sciclient_service+0x298> @ imm = #0x1e
7009c298: e7ff         	b	0x7009c29a <Sciclient_service+0x27a> @ imm = #-0x2
;         ((pReqPrm->flags & TISCI_MSG_FLAG_MASK) != 0U))
7009c29a: 9813         	ldr	r0, [sp, #0x4c]
;     if ((status == SystemP_SUCCESS) &&
7009c29c: 7900         	ldrb	r0, [r0, #0x4]
7009c29e: 0780         	lsls	r0, r0, #0x1e
7009c2a0: b150         	cbz	r0, 0x7009c2b8 <Sciclient_service+0x298> @ imm = #0x14
7009c2a2: e7ff         	b	0x7009c2a4 <Sciclient_service+0x284> @ imm = #-0x2
;         status = Sciclient_waitForMessage(rxThread, pReqPrm->timeout, initialCount, localSeqId);
7009c2a4: 9809         	ldr	r0, [sp, #0x24]
7009c2a6: 9913         	ldr	r1, [sp, #0x4c]
7009c2a8: 6909         	ldr	r1, [r1, #0x10]
7009c2aa: 9a0f         	ldr	r2, [sp, #0x3c]
7009c2ac: f89d 303b    	ldrb.w	r3, [sp, #0x3b]
7009c2b0: f008 f8f6    	bl	0x700a44a0 <Sciclient_waitForMessage> @ imm = #0x81ec
7009c2b4: 9011         	str	r0, [sp, #0x44]
;     }
7009c2b6: e7ff         	b	0x7009c2b8 <Sciclient_service+0x298> @ imm = #-0x2
;     if(status == SystemP_SUCCESS)
7009c2b8: 9811         	ldr	r0, [sp, #0x44]
7009c2ba: b990         	cbnz	r0, 0x7009c2e2 <Sciclient_service+0x2c2> @ imm = #0x24
7009c2bc: e7ff         	b	0x7009c2be <Sciclient_service+0x29e> @ imm = #-0x2
;         pRespPrm->flags = Sciclient_secProxyReadThread32(rxThread, 1U+gSecHeaderSizeWords);
7009c2be: 9809         	ldr	r0, [sp, #0x24]
7009c2c0: f640 6104    	movw	r1, #0xe04
7009c2c4: f2c7 010b    	movt	r1, #0x700b
7009c2c8: 7809         	ldrb	r1, [r1]
7009c2ca: 3101         	adds	r1, #0x1
7009c2cc: b2c9         	uxtb	r1, r1
7009c2ce: f010 fd67    	bl	0x700acda0 <Sciclient_secProxyReadThread32> @ imm = #0x10ace
7009c2d2: 9912         	ldr	r1, [sp, #0x48]
7009c2d4: 6008         	str	r0, [r1]
;         Sciclient_recvMessage(rxThread, pLocalRespPayload, rxPayloadSize);
7009c2d6: 9809         	ldr	r0, [sp, #0x24]
7009c2d8: 990b         	ldr	r1, [sp, #0x2c]
7009c2da: 9a0c         	ldr	r2, [sp, #0x30]
7009c2dc: f005 f9e0    	bl	0x700a16a0 <Sciclient_recvMessage> @ imm = #0x53c0
;     }
7009c2e0: e7ff         	b	0x7009c2e2 <Sciclient_service+0x2c2> @ imm = #-0x2
;     HwiP_restore(key);
7009c2e2: 9808         	ldr	r0, [sp, #0x20]
7009c2e4: f012 ed8c    	blx	0x700aee00 <HwiP_restore> @ imm = #0x12b18
;     return status;
7009c2e8: 9811         	ldr	r0, [sp, #0x44]
7009c2ea: b014         	add	sp, #0x50
7009c2ec: bd80         	pop	{r7, pc}
7009c2ee: 0000         	movs	r0, r0

7009c2f0 <Udma_chDisableRxChan>:
; {
7009c2f0: b580         	push	{r7, lr}
7009c2f2: b096         	sub	sp, #0x58
7009c2f4: 9015         	str	r0, [sp, #0x54]
7009c2f6: 9114         	str	r1, [sp, #0x50]
7009c2f8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009c2fa: 9013         	str	r0, [sp, #0x4c]
;     uint32_t            currTimeout = 0U, regVal;
7009c2fc: 9012         	str	r0, [sp, #0x48]
;     uint32_t            peerRtEnable = 0U, peerRtEnableBit = 0U;
7009c2fe: 9004         	str	r0, [sp, #0x10]
7009c300: 9003         	str	r0, [sp, #0xc]
;     drvHandle = chHandle->drvHandle;
7009c302: 9815         	ldr	r0, [sp, #0x54]
7009c304: 6e80         	ldr	r0, [r0, #0x68]
7009c306: 9010         	str	r0, [sp, #0x40]
7009c308: 2008         	movs	r0, #0x8
;     rtEnableRegOffset = CSL_PSILCFG_REG_RT_ENABLE - CSL_PSILCFG_REG_STATIC_TR;
7009c30a: 9002         	str	r0, [sp, #0x8]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c30c: 9810         	ldr	r0, [sp, #0x40]
7009c30e: 6800         	ldr	r0, [r0]
7009c310: 2801         	cmp	r0, #0x1
7009c312: d115         	bne	0x7009c340 <Udma_chDisableRxChan+0x50> @ imm = #0x2a
7009c314: e7ff         	b	0x7009c316 <Udma_chDisableRxChan+0x26> @ imm = #-0x2
;         regVal = CSL_REG32_RD(&chHandle->pBcdmaRxRtRegs->PEER8);
7009c316: 9815         	ldr	r0, [sp, #0x54]
7009c318: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009c31c: f500 7008    	add.w	r0, r0, #0x220
7009c320: f011 fece    	bl	0x700ae0c0 <CSL_REG32_RD_RAW> @ imm = #0x11d9c
7009c324: 9011         	str	r0, [sp, #0x44]
;         CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 1U);
7009c326: 9811         	ldr	r0, [sp, #0x44]
7009c328: f040 4080    	orr	r0, r0, #0x40000000
7009c32c: 9011         	str	r0, [sp, #0x44]
;         CSL_REG32_WR(&chHandle->pBcdmaRxRtRegs->PEER8, regVal);
7009c32e: 9815         	ldr	r0, [sp, #0x54]
7009c330: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009c334: f500 7008    	add.w	r0, r0, #0x220
7009c338: 9911         	ldr	r1, [sp, #0x44]
7009c33a: f011 fe21    	bl	0x700adf80 <CSL_REG32_WR_RAW> @ imm = #0x11c42
;     }
7009c33e: e01a         	b	0x7009c376 <Udma_chDisableRxChan+0x86> @ imm = #0x34
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c340: 9810         	ldr	r0, [sp, #0x40]
7009c342: 6800         	ldr	r0, [r0]
7009c344: 2802         	cmp	r0, #0x2
7009c346: d115         	bne	0x7009c374 <Udma_chDisableRxChan+0x84> @ imm = #0x2a
7009c348: e7ff         	b	0x7009c34a <Udma_chDisableRxChan+0x5a> @ imm = #-0x2
;         regVal = CSL_REG32_RD(&chHandle->pPktdmaRxRtRegs->PEER8);
7009c34a: 9815         	ldr	r0, [sp, #0x54]
7009c34c: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009c350: f500 7008    	add.w	r0, r0, #0x220
7009c354: f011 feb4    	bl	0x700ae0c0 <CSL_REG32_RD_RAW> @ imm = #0x11d68
7009c358: 9011         	str	r0, [sp, #0x44]
;         CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 1U);
7009c35a: 9811         	ldr	r0, [sp, #0x44]
7009c35c: f040 4080    	orr	r0, r0, #0x40000000
7009c360: 9011         	str	r0, [sp, #0x44]
;         CSL_REG32_WR(&chHandle->pPktdmaRxRtRegs->PEER8, regVal);
7009c362: 9815         	ldr	r0, [sp, #0x54]
7009c364: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009c368: f500 7008    	add.w	r0, r0, #0x220
7009c36c: 9911         	ldr	r1, [sp, #0x44]
7009c36e: f011 fe07    	bl	0x700adf80 <CSL_REG32_WR_RAW> @ imm = #0x11c0e
;     }
7009c372: e7ff         	b	0x7009c374 <Udma_chDisableRxChan+0x84> @ imm = #-0x2
7009c374: e7ff         	b	0x7009c376 <Udma_chDisableRxChan+0x86> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009c376: e7ff         	b	0x7009c378 <Udma_chDisableRxChan+0x88> @ imm = #-0x2
7009c378: 9813         	ldr	r0, [sp, #0x4c]
7009c37a: bbc8         	cbnz	r0, 0x7009c3f0 <Udma_chDisableRxChan+0x100> @ imm = #0x72
7009c37c: e7ff         	b	0x7009c37e <Udma_chDisableRxChan+0x8e> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c37e: 9810         	ldr	r0, [sp, #0x40]
7009c380: 6800         	ldr	r0, [r0]
7009c382: 2801         	cmp	r0, #0x1
7009c384: d110         	bne	0x7009c3a8 <Udma_chDisableRxChan+0xb8> @ imm = #0x20
7009c386: e7ff         	b	0x7009c388 <Udma_chDisableRxChan+0x98> @ imm = #-0x2
;             (void) CSL_bcdmaGetRxRT(&drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009c388: 9a10         	ldr	r2, [sp, #0x40]
7009c38a: f102 0008    	add.w	r0, r2, #0x8
7009c38e: 9915         	ldr	r1, [sp, #0x54]
7009c390: 6f09         	ldr	r1, [r1, #0x70]
7009c392: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c396: 4411         	add	r1, r2
7009c398: aa0a         	add	r2, sp, #0x28
7009c39a: f010 fda9    	bl	0x700acef0 <CSL_bcdmaGetRxRT> @ imm = #0x10b52
;             if(FALSE == bcdmaRtStatus.enable)
7009c39e: 980a         	ldr	r0, [sp, #0x28]
7009c3a0: b908         	cbnz	r0, 0x7009c3a6 <Udma_chDisableRxChan+0xb6> @ imm = #0x2
7009c3a2: e7ff         	b	0x7009c3a4 <Udma_chDisableRxChan+0xb4> @ imm = #-0x2
;                 break;
7009c3a4: e024         	b	0x7009c3f0 <Udma_chDisableRxChan+0x100> @ imm = #0x48
;         }
7009c3a6: e011         	b	0x7009c3cc <Udma_chDisableRxChan+0xdc> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c3a8: 9810         	ldr	r0, [sp, #0x40]
7009c3aa: 6800         	ldr	r0, [r0]
7009c3ac: 2802         	cmp	r0, #0x2
7009c3ae: d10c         	bne	0x7009c3ca <Udma_chDisableRxChan+0xda> @ imm = #0x18
7009c3b0: e7ff         	b	0x7009c3b2 <Udma_chDisableRxChan+0xc2> @ imm = #-0x2
;             (void) CSL_pktdmaGetRxRT(&drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009c3b2: 9810         	ldr	r0, [sp, #0x40]
7009c3b4: 3054         	adds	r0, #0x54
7009c3b6: 9915         	ldr	r1, [sp, #0x54]
7009c3b8: 6f09         	ldr	r1, [r1, #0x70]
7009c3ba: aa05         	add	r2, sp, #0x14
7009c3bc: f00f fa30    	bl	0x700ab820 <CSL_pktdmaGetRxRT> @ imm = #0xf460
;             if(FALSE == pktdmaRtStatus.enable)
7009c3c0: 9805         	ldr	r0, [sp, #0x14]
7009c3c2: b908         	cbnz	r0, 0x7009c3c8 <Udma_chDisableRxChan+0xd8> @ imm = #0x2
7009c3c4: e7ff         	b	0x7009c3c6 <Udma_chDisableRxChan+0xd6> @ imm = #-0x2
;                 break;
7009c3c6: e013         	b	0x7009c3f0 <Udma_chDisableRxChan+0x100> @ imm = #0x26
;         }
7009c3c8: e7ff         	b	0x7009c3ca <Udma_chDisableRxChan+0xda> @ imm = #-0x2
7009c3ca: e7ff         	b	0x7009c3cc <Udma_chDisableRxChan+0xdc> @ imm = #-0x2
;         if(currTimeout > timeout)
7009c3cc: 9812         	ldr	r0, [sp, #0x48]
7009c3ce: 9914         	ldr	r1, [sp, #0x50]
7009c3d0: 4288         	cmp	r0, r1
7009c3d2: d904         	bls	0x7009c3de <Udma_chDisableRxChan+0xee> @ imm = #0x8
7009c3d4: e7ff         	b	0x7009c3d6 <Udma_chDisableRxChan+0xe6> @ imm = #-0x2
7009c3d6: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009c3da: 9013         	str	r0, [sp, #0x4c]
;         }
7009c3dc: e007         	b	0x7009c3ee <Udma_chDisableRxChan+0xfe> @ imm = #0xe
7009c3de: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009c3e2: f00d f8dd    	bl	0x700a95a0 <ClockP_usleep> @ imm = #0xd1ba
;             currTimeout++;
7009c3e6: 9812         	ldr	r0, [sp, #0x48]
7009c3e8: 3001         	adds	r0, #0x1
7009c3ea: 9012         	str	r0, [sp, #0x48]
7009c3ec: e7ff         	b	0x7009c3ee <Udma_chDisableRxChan+0xfe> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009c3ee: e7c3         	b	0x7009c378 <Udma_chDisableRxChan+0x88> @ imm = #-0x7a
;     if(UDMA_SOK != retVal)
7009c3f0: 9813         	ldr	r0, [sp, #0x4c]
7009c3f2: 2800         	cmp	r0, #0x0
7009c3f4: f000 8091    	beq.w	0x7009c51a <Udma_chDisableRxChan+0x22a> @ imm = #0x122
7009c3f8: e7ff         	b	0x7009c3fa <Udma_chDisableRxChan+0x10a> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c3fa: 9810         	ldr	r0, [sp, #0x40]
7009c3fc: 6800         	ldr	r0, [r0]
7009c3fe: 2801         	cmp	r0, #0x1
7009c400: d10e         	bne	0x7009c420 <Udma_chDisableRxChan+0x130> @ imm = #0x1c
7009c402: e7ff         	b	0x7009c404 <Udma_chDisableRxChan+0x114> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, (bool)true, (bool)false);
7009c404: 9a10         	ldr	r2, [sp, #0x40]
7009c406: f102 0008    	add.w	r0, r2, #0x8
7009c40a: 9915         	ldr	r1, [sp, #0x54]
7009c40c: 6f09         	ldr	r1, [r1, #0x70]
7009c40e: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c412: 4411         	add	r1, r2
7009c414: 2201         	movs	r2, #0x1
7009c416: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownRxChan(
7009c418: f00f fb92    	bl	0x700abb40 <CSL_bcdmaTeardownRxChan> @ imm = #0xf724
7009c41c: 9013         	str	r0, [sp, #0x4c]
;         }
7009c41e: e00f         	b	0x7009c440 <Udma_chDisableRxChan+0x150> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c420: 9810         	ldr	r0, [sp, #0x40]
7009c422: 6800         	ldr	r0, [r0]
7009c424: 2802         	cmp	r0, #0x2
7009c426: d10a         	bne	0x7009c43e <Udma_chDisableRxChan+0x14e> @ imm = #0x14
7009c428: e7ff         	b	0x7009c42a <Udma_chDisableRxChan+0x13a> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->rxChNum, (bool)true, (bool)false);
7009c42a: 9810         	ldr	r0, [sp, #0x40]
7009c42c: 3054         	adds	r0, #0x54
7009c42e: 9915         	ldr	r1, [sp, #0x54]
7009c430: 6f09         	ldr	r1, [r1, #0x70]
7009c432: 2201         	movs	r2, #0x1
7009c434: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownRxChan(
7009c436: f010 fa53    	bl	0x700ac8e0 <CSL_pktdmaTeardownRxChan> @ imm = #0x104a6
7009c43a: 9013         	str	r0, [sp, #0x4c]
;         }
7009c43c: e7ff         	b	0x7009c43e <Udma_chDisableRxChan+0x14e> @ imm = #-0x2
7009c43e: e7ff         	b	0x7009c440 <Udma_chDisableRxChan+0x150> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009c440: 9813         	ldr	r0, [sp, #0x4c]
7009c442: b108         	cbz	r0, 0x7009c448 <Udma_chDisableRxChan+0x158> @ imm = #0x2
7009c444: e7ff         	b	0x7009c446 <Udma_chDisableRxChan+0x156> @ imm = #-0x2
;         }
7009c446: e7ff         	b	0x7009c448 <Udma_chDisableRxChan+0x158> @ imm = #-0x2
7009c448: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009c44a: 9012         	str	r0, [sp, #0x48]
;         while(UDMA_SOK == retVal)
7009c44c: e7ff         	b	0x7009c44e <Udma_chDisableRxChan+0x15e> @ imm = #-0x2
7009c44e: 9813         	ldr	r0, [sp, #0x4c]
7009c450: 2800         	cmp	r0, #0x0
7009c452: d161         	bne	0x7009c518 <Udma_chDisableRxChan+0x228> @ imm = #0xc2
7009c454: e7ff         	b	0x7009c456 <Udma_chDisableRxChan+0x166> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c456: 9810         	ldr	r0, [sp, #0x40]
7009c458: 6800         	ldr	r0, [r0]
7009c45a: 2801         	cmp	r0, #0x1
7009c45c: d126         	bne	0x7009c4ac <Udma_chDisableRxChan+0x1bc> @ imm = #0x4c
7009c45e: e7ff         	b	0x7009c460 <Udma_chDisableRxChan+0x170> @ imm = #-0x2
;                 (void) CSL_bcdmaGetRxRT(&drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009c460: 9a10         	ldr	r2, [sp, #0x40]
7009c462: f102 0008    	add.w	r0, r2, #0x8
7009c466: 9915         	ldr	r1, [sp, #0x54]
7009c468: 6f09         	ldr	r1, [r1, #0x70]
7009c46a: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c46e: 4411         	add	r1, r2
7009c470: aa0a         	add	r2, sp, #0x28
7009c472: f010 fd3d    	bl	0x700acef0 <CSL_bcdmaGetRxRT> @ imm = #0x10a7a
;                     &drvHandle->bcdmaRegs,
7009c476: 9a10         	ldr	r2, [sp, #0x40]
7009c478: f102 0008    	add.w	r0, r2, #0x8
;                     chHandle->rxChNum + drvHandle->rxChOffset,
7009c47c: 9915         	ldr	r1, [sp, #0x54]
7009c47e: 6f09         	ldr	r1, [r1, #0x70]
7009c480: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c484: 4411         	add	r1, r2
;                     rtEnableRegOffset, &peerRtEnable);
7009c486: 9b02         	ldr	r3, [sp, #0x8]
;                 (void) CSL_bcdmaGetChanPeerReg(
7009c488: 46ec         	mov	r12, sp
7009c48a: aa04         	add	r2, sp, #0x10
7009c48c: f8cc 2000    	str.w	r2, [r12]
7009c490: 2201         	movs	r2, #0x1
7009c492: f00f fc45    	bl	0x700abd20 <CSL_bcdmaGetChanPeerReg> @ imm = #0xf88a
;                 peerRtEnableBit = CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE);
7009c496: 9804         	ldr	r0, [sp, #0x10]
7009c498: 0fc0         	lsrs	r0, r0, #0x1f
7009c49a: 9003         	str	r0, [sp, #0xc]
;                 if((FALSE == bcdmaRtStatus.enable) && (FALSE == peerRtEnableBit))
7009c49c: 980a         	ldr	r0, [sp, #0x28]
7009c49e: b920         	cbnz	r0, 0x7009c4aa <Udma_chDisableRxChan+0x1ba> @ imm = #0x8
7009c4a0: e7ff         	b	0x7009c4a2 <Udma_chDisableRxChan+0x1b2> @ imm = #-0x2
7009c4a2: 9803         	ldr	r0, [sp, #0xc]
7009c4a4: b908         	cbnz	r0, 0x7009c4aa <Udma_chDisableRxChan+0x1ba> @ imm = #0x2
7009c4a6: e7ff         	b	0x7009c4a8 <Udma_chDisableRxChan+0x1b8> @ imm = #-0x2
;                     break;
7009c4a8: e036         	b	0x7009c518 <Udma_chDisableRxChan+0x228> @ imm = #0x6c
;             }
7009c4aa: e023         	b	0x7009c4f4 <Udma_chDisableRxChan+0x204> @ imm = #0x46
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c4ac: 9810         	ldr	r0, [sp, #0x40]
7009c4ae: 6800         	ldr	r0, [r0]
7009c4b0: 2802         	cmp	r0, #0x2
7009c4b2: d11e         	bne	0x7009c4f2 <Udma_chDisableRxChan+0x202> @ imm = #0x3c
7009c4b4: e7ff         	b	0x7009c4b6 <Udma_chDisableRxChan+0x1c6> @ imm = #-0x2
;                 (void) CSL_pktdmaGetRxRT(&drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009c4b6: 9810         	ldr	r0, [sp, #0x40]
7009c4b8: 3054         	adds	r0, #0x54
7009c4ba: 9915         	ldr	r1, [sp, #0x54]
7009c4bc: 6f09         	ldr	r1, [r1, #0x70]
7009c4be: aa05         	add	r2, sp, #0x14
7009c4c0: f00f f9ae    	bl	0x700ab820 <CSL_pktdmaGetRxRT> @ imm = #0xf35c
;                     &drvHandle->pktdmaRegs,
7009c4c4: 9810         	ldr	r0, [sp, #0x40]
7009c4c6: 3054         	adds	r0, #0x54
;                     chHandle->rxChNum,
7009c4c8: 9915         	ldr	r1, [sp, #0x54]
7009c4ca: 6f09         	ldr	r1, [r1, #0x70]
;                     rtEnableRegOffset, &peerRtEnable);
7009c4cc: 9b02         	ldr	r3, [sp, #0x8]
;                 (void) CSL_pktdmaGetChanPeerReg(
7009c4ce: 46ec         	mov	r12, sp
7009c4d0: aa04         	add	r2, sp, #0x10
7009c4d2: f8cc 2000    	str.w	r2, [r12]
7009c4d6: 2201         	movs	r2, #0x1
7009c4d8: f010 fbba    	bl	0x700acc50 <CSL_pktdmaGetChanPeerReg> @ imm = #0x10774
;                 peerRtEnableBit = CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE);
7009c4dc: 9804         	ldr	r0, [sp, #0x10]
7009c4de: 0fc0         	lsrs	r0, r0, #0x1f
7009c4e0: 9003         	str	r0, [sp, #0xc]
;                 if((FALSE == pktdmaRtStatus.enable) && (FALSE == peerRtEnableBit))
7009c4e2: 9805         	ldr	r0, [sp, #0x14]
7009c4e4: b920         	cbnz	r0, 0x7009c4f0 <Udma_chDisableRxChan+0x200> @ imm = #0x8
7009c4e6: e7ff         	b	0x7009c4e8 <Udma_chDisableRxChan+0x1f8> @ imm = #-0x2
7009c4e8: 9803         	ldr	r0, [sp, #0xc]
7009c4ea: b908         	cbnz	r0, 0x7009c4f0 <Udma_chDisableRxChan+0x200> @ imm = #0x2
7009c4ec: e7ff         	b	0x7009c4ee <Udma_chDisableRxChan+0x1fe> @ imm = #-0x2
;                     break;
7009c4ee: e013         	b	0x7009c518 <Udma_chDisableRxChan+0x228> @ imm = #0x26
;             }
7009c4f0: e7ff         	b	0x7009c4f2 <Udma_chDisableRxChan+0x202> @ imm = #-0x2
7009c4f2: e7ff         	b	0x7009c4f4 <Udma_chDisableRxChan+0x204> @ imm = #-0x2
;             if(currTimeout > timeout)
7009c4f4: 9812         	ldr	r0, [sp, #0x48]
7009c4f6: 9914         	ldr	r1, [sp, #0x50]
7009c4f8: 4288         	cmp	r0, r1
7009c4fa: d904         	bls	0x7009c506 <Udma_chDisableRxChan+0x216> @ imm = #0x8
7009c4fc: e7ff         	b	0x7009c4fe <Udma_chDisableRxChan+0x20e> @ imm = #-0x2
7009c4fe: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009c502: 9013         	str	r0, [sp, #0x4c]
;             }
7009c504: e007         	b	0x7009c516 <Udma_chDisableRxChan+0x226> @ imm = #0xe
7009c506: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009c50a: f00d f849    	bl	0x700a95a0 <ClockP_usleep> @ imm = #0xd092
;                 currTimeout++;
7009c50e: 9812         	ldr	r0, [sp, #0x48]
7009c510: 3001         	adds	r0, #0x1
7009c512: 9012         	str	r0, [sp, #0x48]
7009c514: e7ff         	b	0x7009c516 <Udma_chDisableRxChan+0x226> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009c516: e79a         	b	0x7009c44e <Udma_chDisableRxChan+0x15e> @ imm = #-0xcc
;     }
7009c518: e7ff         	b	0x7009c51a <Udma_chDisableRxChan+0x22a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c51a: 9813         	ldr	r0, [sp, #0x4c]
7009c51c: 2800         	cmp	r0, #0x0
7009c51e: d148         	bne	0x7009c5b2 <Udma_chDisableRxChan+0x2c2> @ imm = #0x90
7009c520: e7ff         	b	0x7009c522 <Udma_chDisableRxChan+0x232> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c522: 9810         	ldr	r0, [sp, #0x40]
7009c524: 6800         	ldr	r0, [r0]
7009c526: 2801         	cmp	r0, #0x1
7009c528: d122         	bne	0x7009c570 <Udma_chDisableRxChan+0x280> @ imm = #0x44
7009c52a: e7ff         	b	0x7009c52c <Udma_chDisableRxChan+0x23c> @ imm = #-0x2
7009c52c: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.teardown = FALSE;   /* Note that other bits are cleared from previous call */
7009c52e: 900b         	str	r0, [sp, #0x2c]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) FALSE);
7009c530: 9804         	ldr	r0, [sp, #0x10]
7009c532: f020 4080    	bic	r0, r0, #0x40000000
7009c536: 9004         	str	r0, [sp, #0x10]
;                 &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009c538: 9a10         	ldr	r2, [sp, #0x40]
7009c53a: f102 0008    	add.w	r0, r2, #0x8
7009c53e: 9915         	ldr	r1, [sp, #0x54]
7009c540: 6f09         	ldr	r1, [r1, #0x70]
7009c542: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c546: 4411         	add	r1, r2
7009c548: aa0a         	add	r2, sp, #0x28
;             (void) CSL_bcdmaSetRxRT(
7009c54a: f010 fd01    	bl	0x700acf50 <CSL_bcdmaSetRxRT> @ imm = #0x10a02
;                 &drvHandle->bcdmaRegs,
7009c54e: 9a10         	ldr	r2, [sp, #0x40]
7009c550: f102 0008    	add.w	r0, r2, #0x8
;                 chHandle->rxChNum + drvHandle->rxChOffset,
7009c554: 9915         	ldr	r1, [sp, #0x54]
7009c556: 6f09         	ldr	r1, [r1, #0x70]
7009c558: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c55c: 4411         	add	r1, r2
;                 rtEnableRegOffset,
7009c55e: 9b02         	ldr	r3, [sp, #0x8]
;             (void) CSL_bcdmaSetChanPeerReg(
7009c560: 46ec         	mov	r12, sp
7009c562: aa04         	add	r2, sp, #0x10
7009c564: f8cc 2000    	str.w	r2, [r12]
7009c568: 2201         	movs	r2, #0x1
7009c56a: f00f fed9    	bl	0x700ac320 <CSL_bcdmaSetChanPeerReg> @ imm = #0xfdb2
;         }
7009c56e: e01f         	b	0x7009c5b0 <Udma_chDisableRxChan+0x2c0> @ imm = #0x3e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c570: 9810         	ldr	r0, [sp, #0x40]
7009c572: 6800         	ldr	r0, [r0]
7009c574: 2802         	cmp	r0, #0x2
7009c576: d11a         	bne	0x7009c5ae <Udma_chDisableRxChan+0x2be> @ imm = #0x34
7009c578: e7ff         	b	0x7009c57a <Udma_chDisableRxChan+0x28a> @ imm = #-0x2
7009c57a: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.teardown = FALSE;   /* Note that other bits are cleared from previous call */
7009c57c: 9006         	str	r0, [sp, #0x18]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) FALSE);
7009c57e: 9804         	ldr	r0, [sp, #0x10]
7009c580: f020 4080    	bic	r0, r0, #0x40000000
7009c584: 9004         	str	r0, [sp, #0x10]
;                 &drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009c586: 9810         	ldr	r0, [sp, #0x40]
7009c588: 3054         	adds	r0, #0x54
7009c58a: 9915         	ldr	r1, [sp, #0x54]
7009c58c: 6f09         	ldr	r1, [r1, #0x70]
7009c58e: aa05         	add	r2, sp, #0x14
;             (void) CSL_pktdmaSetRxRT(
7009c590: f00f ff06    	bl	0x700ac3a0 <CSL_pktdmaSetRxRT> @ imm = #0xfe0c
;                 &drvHandle->pktdmaRegs,
7009c594: 9810         	ldr	r0, [sp, #0x40]
7009c596: 3054         	adds	r0, #0x54
;                 chHandle->rxChNum,
7009c598: 9915         	ldr	r1, [sp, #0x54]
7009c59a: 6f09         	ldr	r1, [r1, #0x70]
;                 rtEnableRegOffset,
7009c59c: 9b02         	ldr	r3, [sp, #0x8]
;             (void) CSL_pktdmaSetChanPeerReg(
7009c59e: 46ec         	mov	r12, sp
7009c5a0: aa04         	add	r2, sp, #0x10
7009c5a2: f8cc 2000    	str.w	r2, [r12]
7009c5a6: 2201         	movs	r2, #0x1
7009c5a8: f010 fb6a    	bl	0x700acc80 <CSL_pktdmaSetChanPeerReg> @ imm = #0x106d4
;         }
7009c5ac: e7ff         	b	0x7009c5ae <Udma_chDisableRxChan+0x2be> @ imm = #-0x2
7009c5ae: e7ff         	b	0x7009c5b0 <Udma_chDisableRxChan+0x2c0> @ imm = #-0x2
;     }
7009c5b0: e7ff         	b	0x7009c5b2 <Udma_chDisableRxChan+0x2c2> @ imm = #-0x2
;     return (retVal);
7009c5b2: 9813         	ldr	r0, [sp, #0x4c]
7009c5b4: b016         	add	sp, #0x58
7009c5b6: bd80         	pop	{r7, pc}
		...

7009c5c0 <CSL_bcdmaChanOpCfgChan>:
; {
7009c5c0: b580         	push	{r7, lr}
7009c5c2: b08a         	sub	sp, #0x28
7009c5c4: 9009         	str	r0, [sp, #0x24]
7009c5c6: 9108         	str	r1, [sp, #0x20]
7009c5c8: 9207         	str	r2, [sp, #0x1c]
7009c5ca: 9306         	str	r3, [sp, #0x18]
7009c5cc: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
7009c5ce: 9005         	str	r0, [sp, #0x14]
;     if( pOpData == NULL )
7009c5d0: 9806         	ldr	r0, [sp, #0x18]
7009c5d2: b920         	cbnz	r0, 0x7009c5de <CSL_bcdmaChanOpCfgChan+0x1e> @ imm = #0x8
7009c5d4: e7ff         	b	0x7009c5d6 <CSL_bcdmaChanOpCfgChan+0x16> @ imm = #-0x2
7009c5d6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
7009c5da: 9005         	str	r0, [sp, #0x14]
;     }
7009c5dc: e137         	b	0x7009c84e <CSL_bcdmaChanOpCfgChan+0x28e> @ imm = #0x26e
;         switch( chanType )
7009c5de: 9808         	ldr	r0, [sp, #0x20]
7009c5e0: 9000         	str	r0, [sp]
7009c5e2: b148         	cbz	r0, 0x7009c5f8 <CSL_bcdmaChanOpCfgChan+0x38> @ imm = #0x12
7009c5e4: e7ff         	b	0x7009c5e6 <CSL_bcdmaChanOpCfgChan+0x26> @ imm = #-0x2
7009c5e6: 9800         	ldr	r0, [sp]
7009c5e8: 2801         	cmp	r0, #0x1
7009c5ea: d057         	beq	0x7009c69c <CSL_bcdmaChanOpCfgChan+0xdc> @ imm = #0xae
7009c5ec: e7ff         	b	0x7009c5ee <CSL_bcdmaChanOpCfgChan+0x2e> @ imm = #-0x2
7009c5ee: 9800         	ldr	r0, [sp]
7009c5f0: 2802         	cmp	r0, #0x2
7009c5f2: f000 80c1    	beq.w	0x7009c778 <CSL_bcdmaChanOpCfgChan+0x1b8> @ imm = #0x182
7009c5f6: e125         	b	0x7009c844 <CSL_bcdmaChanOpCfgChan+0x284> @ imm = #0x24a
;                     CSL_BcdmaTxChanCfg *pChanCfg = (CSL_BcdmaTxChanCfg *)pOpData;
7009c5f8: 9806         	ldr	r0, [sp, #0x18]
7009c5fa: 9003         	str	r0, [sp, #0xc]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES)   ||    /* Block-copy supports 32, 64, and 128-byte bursts */
7009c5fc: 9803         	ldr	r0, [sp, #0xc]
7009c5fe: 6c40         	ldr	r0, [r0, #0x44]
7009c600: 2802         	cmp	r0, #0x2
7009c602: d80a         	bhi	0x7009c61a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #0x14
7009c604: e7ff         	b	0x7009c606 <CSL_bcdmaChanOpCfgChan+0x46> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009c606: 9803         	ldr	r0, [sp, #0xc]
7009c608: 6a00         	ldr	r0, [r0, #0x20]
7009c60a: 2807         	cmp	r0, #0x7
7009c60c: d805         	bhi	0x7009c61a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #0xa
7009c60e: e7ff         	b	0x7009c610 <CSL_bcdmaChanOpCfgChan+0x50> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009c610: 9803         	ldr	r0, [sp, #0xc]
7009c612: 6ac0         	ldr	r0, [r0, #0x2c]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES)   ||    /* Block-copy supports 32, 64, and 128-byte bursts */
7009c614: 2804         	cmp	r0, #0x4
7009c616: d304         	blo	0x7009c622 <CSL_bcdmaChanOpCfgChan+0x62> @ imm = #0x8
7009c618: e7ff         	b	0x7009c61a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #-0x2
7009c61a: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009c61e: 9005         	str	r0, [sp, #0x14]
;                     }
7009c620: e03b         	b	0x7009c69a <CSL_bcdmaChanOpCfgChan+0xda> @ imm = #0x76
;                         regVal = CSL_REG32_RD( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG );
7009c622: 9809         	ldr	r0, [sp, #0x24]
7009c624: 6840         	ldr	r0, [r0, #0x4]
7009c626: 9907         	ldr	r1, [sp, #0x1c]
7009c628: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c62c: f011 fd20    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0x11a40
7009c630: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_BCCFG_CHAN_CFG_PAUSE_ON_ERR, pChanCfg->pauseOnError );
7009c632: 9804         	ldr	r0, [sp, #0x10]
7009c634: f020 4000    	bic	r0, r0, #0x80000000
7009c638: 9903         	ldr	r1, [sp, #0xc]
7009c63a: 6809         	ldr	r1, [r1]
7009c63c: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009c640: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_BCCFG_CHAN_CFG_BURST_SIZE, pChanCfg->burstSize );
7009c642: 9804         	ldr	r0, [sp, #0x10]
7009c644: 9903         	ldr	r1, [sp, #0xc]
7009c646: 6c49         	ldr	r1, [r1, #0x44]
7009c648: f361 208b    	bfi	r0, r1, #10, #2
7009c64c: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG, regVal );
7009c64e: 9809         	ldr	r0, [sp, #0x24]
7009c650: 6840         	ldr	r0, [r0, #0x4]
7009c652: 9907         	ldr	r1, [sp, #0x1c]
7009c654: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c658: 9904         	ldr	r1, [sp, #0x10]
7009c65a: f7fe fca9    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x16ae
;                         regVal = CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c65e: 9803         	ldr	r0, [sp, #0xc]
7009c660: 6a01         	ldr	r1, [r0, #0x20]
;                                  CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009c662: 6a80         	ldr	r0, [r0, #0x28]
7009c664: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c668: f361 701e    	bfi	r0, r1, #28, #3
7009c66c: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].PRI_CTRL, regVal );
7009c66e: 9809         	ldr	r0, [sp, #0x24]
7009c670: 6840         	ldr	r0, [r0, #0x4]
7009c672: 9907         	ldr	r1, [sp, #0x1c]
7009c674: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c678: 3064         	adds	r0, #0x64
7009c67a: 9904         	ldr	r1, [sp, #0x10]
7009c67c: f7fe fc98    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x16d0
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].TST_SCHED, CSL_FMK(BCDMA_BCCFG_CHAN_TST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009c680: 9809         	ldr	r0, [sp, #0x24]
7009c682: 6840         	ldr	r0, [r0, #0x4]
7009c684: 9907         	ldr	r1, [sp, #0x1c]
7009c686: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c68a: 3080         	adds	r0, #0x80
7009c68c: 9903         	ldr	r1, [sp, #0xc]
7009c68e: 6ac9         	ldr	r1, [r1, #0x2c]
7009c690: f001 0103    	and	r1, r1, #0x3
7009c694: f7fe fc8c    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x16e8
7009c698: e7ff         	b	0x7009c69a <CSL_bcdmaChanOpCfgChan+0xda> @ imm = #-0x2
;                 break;
7009c69a: e0d7         	b	0x7009c84c <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0x1ae
;                     CSL_BcdmaTxChanCfg *pChanCfg = (CSL_BcdmaTxChanCfg *)pOpData;
7009c69c: 9806         	ldr	r0, [sp, #0x18]
7009c69e: 9002         	str	r0, [sp, #0x8]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||    /* Split-tx supports 32, and 64-byte bursts */
7009c6a0: 9802         	ldr	r0, [sp, #0x8]
7009c6a2: 6c40         	ldr	r0, [r0, #0x44]
7009c6a4: 2801         	cmp	r0, #0x1
7009c6a6: d80a         	bhi	0x7009c6be <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #0x14
7009c6a8: e7ff         	b	0x7009c6aa <CSL_bcdmaChanOpCfgChan+0xea> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009c6aa: 9802         	ldr	r0, [sp, #0x8]
7009c6ac: 6a00         	ldr	r0, [r0, #0x20]
7009c6ae: 2807         	cmp	r0, #0x7
7009c6b0: d805         	bhi	0x7009c6be <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #0xa
7009c6b2: e7ff         	b	0x7009c6b4 <CSL_bcdmaChanOpCfgChan+0xf4> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009c6b4: 9802         	ldr	r0, [sp, #0x8]
7009c6b6: 6ac0         	ldr	r0, [r0, #0x2c]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||    /* Split-tx supports 32, and 64-byte bursts */
7009c6b8: 2804         	cmp	r0, #0x4
7009c6ba: d304         	blo	0x7009c6c6 <CSL_bcdmaChanOpCfgChan+0x106> @ imm = #0x8
7009c6bc: e7ff         	b	0x7009c6be <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #-0x2
7009c6be: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009c6c2: 9005         	str	r0, [sp, #0x14]
;                     }
7009c6c4: e057         	b	0x7009c776 <CSL_bcdmaChanOpCfgChan+0x1b6> @ imm = #0xae
;                         regVal = CSL_REG32_RD( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG );
7009c6c6: 9809         	ldr	r0, [sp, #0x24]
7009c6c8: 68c0         	ldr	r0, [r0, #0xc]
7009c6ca: 9907         	ldr	r1, [sp, #0x1c]
7009c6cc: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c6d0: f011 fcce    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0x1199c
7009c6d4: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_PAUSE_ON_ERR, pChanCfg->pauseOnError);
7009c6d6: 9804         	ldr	r0, [sp, #0x10]
7009c6d8: f020 4000    	bic	r0, r0, #0x80000000
7009c6dc: 9902         	ldr	r1, [sp, #0x8]
7009c6de: 6809         	ldr	r1, [r1]
7009c6e0: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009c6e4: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_BURST_SIZE, pChanCfg->burstSize );
7009c6e6: 9804         	ldr	r0, [sp, #0x10]
7009c6e8: 9902         	ldr	r1, [sp, #0x8]
7009c6ea: 6c49         	ldr	r1, [r1, #0x44]
7009c6ec: f361 208b    	bfi	r0, r1, #10, #2
7009c6f0: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_TDTYPE, pChanCfg->tdType );
7009c6f2: 9804         	ldr	r0, [sp, #0x10]
7009c6f4: 9902         	ldr	r1, [sp, #0x8]
7009c6f6: 6c09         	ldr	r1, [r1, #0x40]
7009c6f8: f361 2049    	bfi	r0, r1, #9, #1
7009c6fc: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_NOTDPKT, pChanCfg->bNoTeardownCompletePkt );
7009c6fe: 9804         	ldr	r0, [sp, #0x10]
7009c700: f420 7080    	bic	r0, r0, #0x100
7009c704: 9902         	ldr	r1, [sp, #0x8]
7009c706: f891 103c    	ldrb.w	r1, [r1, #0x3c]
7009c70a: f001 0101    	and	r1, r1, #0x1
7009c70e: ea40 2001    	orr.w	r0, r0, r1, lsl #8
7009c712: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG, regVal );
7009c714: 9809         	ldr	r0, [sp, #0x24]
7009c716: 68c0         	ldr	r0, [r0, #0xc]
7009c718: 9907         	ldr	r1, [sp, #0x1c]
7009c71a: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c71e: 9904         	ldr	r1, [sp, #0x10]
7009c720: f7fe fc46    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x1774
;                         regVal = CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c724: 9802         	ldr	r0, [sp, #0x8]
7009c726: 6a01         	ldr	r1, [r0, #0x20]
;                                  CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009c728: 6a80         	ldr	r0, [r0, #0x28]
7009c72a: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c72e: f361 701e    	bfi	r0, r1, #28, #3
7009c732: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TPRI_CTRL, regVal );
7009c734: 9809         	ldr	r0, [sp, #0x24]
7009c736: 68c0         	ldr	r0, [r0, #0xc]
7009c738: 9907         	ldr	r1, [sp, #0x1c]
7009c73a: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c73e: 3064         	adds	r0, #0x64
7009c740: 9904         	ldr	r1, [sp, #0x10]
7009c742: f7fe fc35    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x1796
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].THREAD, CSL_FMK(BCDMA_TXCCFG_CHAN_THREAD_ID, pChanCfg->threadId) );
7009c746: 9809         	ldr	r0, [sp, #0x24]
7009c748: 68c0         	ldr	r0, [r0, #0xc]
7009c74a: 9907         	ldr	r1, [sp, #0x1c]
7009c74c: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c750: 3068         	adds	r0, #0x68
7009c752: 9902         	ldr	r1, [sp, #0x8]
7009c754: f8b1 1048    	ldrh.w	r1, [r1, #0x48]
7009c758: f7fe fc2a    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x17ac
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TST_SCHED, CSL_FMK(BCDMA_TXCCFG_CHAN_TST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009c75c: 9809         	ldr	r0, [sp, #0x24]
7009c75e: 68c0         	ldr	r0, [r0, #0xc]
7009c760: 9907         	ldr	r1, [sp, #0x1c]
7009c762: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c766: 3080         	adds	r0, #0x80
7009c768: 9902         	ldr	r1, [sp, #0x8]
7009c76a: 6ac9         	ldr	r1, [r1, #0x2c]
7009c76c: f001 0103    	and	r1, r1, #0x3
7009c770: f7fe fc1e    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x17c4
7009c774: e7ff         	b	0x7009c776 <CSL_bcdmaChanOpCfgChan+0x1b6> @ imm = #-0x2
;                 break;
7009c776: e069         	b	0x7009c84c <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0xd2
;                     CSL_BcdmaRxChanCfg *pChanCfg = (CSL_BcdmaRxChanCfg *)pOpData;
7009c778: 9806         	ldr	r0, [sp, #0x18]
7009c77a: 9001         	str	r0, [sp, #0x4]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||     /* Split-rx supports 32, and 64-byte bursts */
7009c77c: 9801         	ldr	r0, [sp, #0x4]
7009c77e: 6bc0         	ldr	r0, [r0, #0x3c]
7009c780: 2801         	cmp	r0, #0x1
7009c782: d80a         	bhi	0x7009c79a <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #0x14
7009c784: e7ff         	b	0x7009c786 <CSL_bcdmaChanOpCfgChan+0x1c6> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009c786: 9801         	ldr	r0, [sp, #0x4]
7009c788: 6980         	ldr	r0, [r0, #0x18]
7009c78a: 2807         	cmp	r0, #0x7
7009c78c: d805         	bhi	0x7009c79a <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #0xa
7009c78e: e7ff         	b	0x7009c790 <CSL_bcdmaChanOpCfgChan+0x1d0> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009c790: 9801         	ldr	r0, [sp, #0x4]
7009c792: 6b80         	ldr	r0, [r0, #0x38]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||     /* Split-rx supports 32, and 64-byte bursts */
7009c794: 2804         	cmp	r0, #0x4
7009c796: d304         	blo	0x7009c7a2 <CSL_bcdmaChanOpCfgChan+0x1e2> @ imm = #0x8
7009c798: e7ff         	b	0x7009c79a <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #-0x2
7009c79a: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009c79e: 9005         	str	r0, [sp, #0x14]
;                     }
7009c7a0: e04f         	b	0x7009c842 <CSL_bcdmaChanOpCfgChan+0x282> @ imm = #0x9e
;                         regVal = CSL_REG32_RD( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG );
7009c7a2: 9809         	ldr	r0, [sp, #0x24]
7009c7a4: 6940         	ldr	r0, [r0, #0x14]
7009c7a6: 9907         	ldr	r1, [sp, #0x1c]
7009c7a8: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c7ac: f011 fc60    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0x118c0
7009c7b0: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_PAUSE_ON_ERR, pChanCfg->pauseOnError);
7009c7b2: 9804         	ldr	r0, [sp, #0x10]
7009c7b4: f020 4000    	bic	r0, r0, #0x80000000
7009c7b8: 9901         	ldr	r1, [sp, #0x4]
7009c7ba: 6809         	ldr	r1, [r1]
7009c7bc: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009c7c0: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_BURST_SIZE, pChanCfg->burstSize );
7009c7c2: 9804         	ldr	r0, [sp, #0x10]
7009c7c4: 9901         	ldr	r1, [sp, #0x4]
7009c7c6: 6bc9         	ldr	r1, [r1, #0x3c]
7009c7c8: f361 208b    	bfi	r0, r1, #10, #2
7009c7cc: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_IGNORE_LONG, pChanCfg->bIgnoreLongPkts ? (uint32_t)1U : (uint32_t)0U );
7009c7ce: 9804         	ldr	r0, [sp, #0x10]
7009c7d0: f420 4080    	bic	r0, r0, #0x4000
7009c7d4: 9901         	ldr	r1, [sp, #0x4]
7009c7d6: f891 1035    	ldrb.w	r1, [r1, #0x35]
7009c7da: f361 308e    	bfi	r0, r1, #14, #1
7009c7de: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG, regVal );
7009c7e0: 9809         	ldr	r0, [sp, #0x24]
7009c7e2: 6940         	ldr	r0, [r0, #0x14]
7009c7e4: 9907         	ldr	r1, [sp, #0x1c]
7009c7e6: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c7ea: 9904         	ldr	r1, [sp, #0x10]
7009c7ec: f7fe fbe0    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x1840
;                         regVal = CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c7f0: 9801         	ldr	r0, [sp, #0x4]
7009c7f2: 6981         	ldr	r1, [r0, #0x18]
;                                  CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009c7f4: 6a00         	ldr	r0, [r0, #0x20]
7009c7f6: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c7fa: f361 701e    	bfi	r0, r1, #28, #3
7009c7fe: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RPRI_CTRL, regVal );
7009c800: 9809         	ldr	r0, [sp, #0x24]
7009c802: 6940         	ldr	r0, [r0, #0x14]
7009c804: 9907         	ldr	r1, [sp, #0x1c]
7009c806: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c80a: 3064         	adds	r0, #0x64
7009c80c: 9904         	ldr	r1, [sp, #0x10]
7009c80e: f7fe fbcf    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x1862
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].THREAD, CSL_FMK(BCDMA_RXCCFG_CHAN_THREAD_ID, pChanCfg->threadId) );
7009c812: 9809         	ldr	r0, [sp, #0x24]
7009c814: 6940         	ldr	r0, [r0, #0x14]
7009c816: 9907         	ldr	r1, [sp, #0x1c]
7009c818: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c81c: 3068         	adds	r0, #0x68
7009c81e: 9901         	ldr	r1, [sp, #0x4]
7009c820: f8b1 1040    	ldrh.w	r1, [r1, #0x40]
7009c824: f7fe fbc4    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x1878
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RST_SCHED, CSL_FMK(BCDMA_RXCCFG_CHAN_RST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009c828: 9809         	ldr	r0, [sp, #0x24]
7009c82a: 6940         	ldr	r0, [r0, #0x14]
7009c82c: 9907         	ldr	r1, [sp, #0x1c]
7009c82e: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c832: 3080         	adds	r0, #0x80
7009c834: 9901         	ldr	r1, [sp, #0x4]
7009c836: 6b89         	ldr	r1, [r1, #0x38]
7009c838: f001 0103    	and	r1, r1, #0x3
7009c83c: f7fe fbb8    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x1890
7009c840: e7ff         	b	0x7009c842 <CSL_bcdmaChanOpCfgChan+0x282> @ imm = #-0x2
;                 break;
7009c842: e003         	b	0x7009c84c <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0x6
7009c844: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
7009c848: 9005         	str	r0, [sp, #0x14]
;                 break;
7009c84a: e7ff         	b	0x7009c84c <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #-0x2
7009c84c: e7ff         	b	0x7009c84e <CSL_bcdmaChanOpCfgChan+0x28e> @ imm = #-0x2
;     return retVal;
7009c84e: 9805         	ldr	r0, [sp, #0x14]
7009c850: b00a         	add	sp, #0x28
7009c852: bd80         	pop	{r7, pc}
		...

7009c860 <TimerP_setup>:
; {
7009c860: b510         	push	{r4, lr}
7009c862: b096         	sub	sp, #0x58
7009c864: 9015         	str	r0, [sp, #0x54]
7009c866: 9114         	str	r1, [sp, #0x50]
;     DebugP_assert( baseAddr!=0U);
7009c868: 9815         	ldr	r0, [sp, #0x54]
7009c86a: 2800         	cmp	r0, #0x0
7009c86c: bf18         	it	ne
7009c86e: 2001         	movne	r0, #0x1
7009c870: f240 41aa    	movw	r1, #0x4aa
7009c874: f2c7 010b    	movt	r1, #0x700b
7009c878: 466a         	mov	r2, sp
7009c87a: 6011         	str	r1, [r2]
7009c87c: f240 1139    	movw	r1, #0x139
7009c880: f2c7 010b    	movt	r1, #0x700b
7009c884: 9106         	str	r1, [sp, #0x18]
7009c886: f240 42b7    	movw	r2, #0x4b7
7009c88a: f2c7 020b    	movt	r2, #0x700b
7009c88e: 9207         	str	r2, [sp, #0x1c]
7009c890: 2342         	movs	r3, #0x42
7009c892: f00c fc45    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xc88a
7009c896: 9906         	ldr	r1, [sp, #0x18]
7009c898: 9a07         	ldr	r2, [sp, #0x1c]
;     DebugP_assert( params->inputPreScaler != 0U);
7009c89a: 9814         	ldr	r0, [sp, #0x50]
7009c89c: 6800         	ldr	r0, [r0]
7009c89e: 2800         	cmp	r0, #0x0
7009c8a0: bf18         	it	ne
7009c8a2: 2001         	movne	r0, #0x1
7009c8a4: f240 1357    	movw	r3, #0x157
7009c8a8: f2c7 030b    	movt	r3, #0x700b
7009c8ac: 46ec         	mov	r12, sp
7009c8ae: f8cc 3000    	str.w	r3, [r12]
7009c8b2: 2343         	movs	r3, #0x43
7009c8b4: f00c fc34    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xc868
7009c8b8: 9906         	ldr	r1, [sp, #0x18]
7009c8ba: 9a07         	ldr	r2, [sp, #0x1c]
;     DebugP_assert( params->inputClkHz != 0U);
7009c8bc: 9814         	ldr	r0, [sp, #0x50]
7009c8be: 6840         	ldr	r0, [r0, #0x4]
7009c8c0: 2800         	cmp	r0, #0x0
7009c8c2: bf18         	it	ne
7009c8c4: 2001         	movne	r0, #0x1
7009c8c6: f240 2388    	movw	r3, #0x288
7009c8ca: f2c7 030b    	movt	r3, #0x700b
7009c8ce: 46ec         	mov	r12, sp
7009c8d0: f8cc 3000    	str.w	r3, [r12]
7009c8d4: 2344         	movs	r3, #0x44
7009c8d6: f00c fc23    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xc846
;     DebugP_assert(( params->periodInUsec != 0U) || (params->periodInNsec != 0U) );
7009c8da: 9814         	ldr	r0, [sp, #0x50]
7009c8dc: 6881         	ldr	r1, [r0, #0x8]
7009c8de: 2001         	movs	r0, #0x1
7009c8e0: 9008         	str	r0, [sp, #0x20]
7009c8e2: b939         	cbnz	r1, 0x7009c8f4 <TimerP_setup+0x94> @ imm = #0xe
7009c8e4: e7ff         	b	0x7009c8e6 <TimerP_setup+0x86> @ imm = #-0x2
7009c8e6: 9814         	ldr	r0, [sp, #0x50]
7009c8e8: 68c0         	ldr	r0, [r0, #0xc]
7009c8ea: 2800         	cmp	r0, #0x0
7009c8ec: bf18         	it	ne
7009c8ee: 2001         	movne	r0, #0x1
7009c8f0: 9008         	str	r0, [sp, #0x20]
7009c8f2: e7ff         	b	0x7009c8f4 <TimerP_setup+0x94> @ imm = #-0x2
7009c8f4: 9808         	ldr	r0, [sp, #0x20]
;     DebugP_assert(( params->periodInUsec != 0U) || (params->periodInNsec != 0U) );
7009c8f6: f000 0001    	and	r0, r0, #0x1
7009c8fa: f64f 41c8    	movw	r1, #0xfcc8
7009c8fe: f2c7 010a    	movt	r1, #0x700a
7009c902: 466a         	mov	r2, sp
7009c904: 6011         	str	r1, [r2]
7009c906: f240 1139    	movw	r1, #0x139
7009c90a: f2c7 010b    	movt	r1, #0x700b
7009c90e: 9103         	str	r1, [sp, #0xc]
7009c910: f240 42b7    	movw	r2, #0x4b7
7009c914: f2c7 020b    	movt	r2, #0x700b
7009c918: 9204         	str	r2, [sp, #0x10]
7009c91a: 2345         	movs	r3, #0x45
7009c91c: f00c fc00    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xc800
7009c920: 9903         	ldr	r1, [sp, #0xc]
7009c922: 9a04         	ldr	r2, [sp, #0x10]
;     DebugP_assert( params->inputPreScaler <= 256U);
7009c924: 9814         	ldr	r0, [sp, #0x50]
7009c926: 6803         	ldr	r3, [r0]
7009c928: 2000         	movs	r0, #0x0
7009c92a: 9005         	str	r0, [sp, #0x14]
7009c92c: f5b3 7f80    	cmp.w	r3, #0x100
7009c930: bf98         	it	ls
7009c932: 2001         	movls	r0, #0x1
7009c934: f240 03fb    	movw	r3, #0xfb
7009c938: f2c7 030b    	movt	r3, #0x700b
7009c93c: 46ec         	mov	r12, sp
7009c93e: f8cc 3000    	str.w	r3, [r12]
7009c942: 2347         	movs	r3, #0x47
7009c944: f00c fbec    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xc7d8
7009c948: 9903         	ldr	r1, [sp, #0xc]
7009c94a: 9a04         	ldr	r2, [sp, #0x10]
;     DebugP_assert( (params->inputClkHz % params->inputPreScaler) == 0U);
7009c94c: 9814         	ldr	r0, [sp, #0x50]
7009c94e: 6803         	ldr	r3, [r0]
7009c950: f8d0 c004    	ldr.w	r12, [r0, #0x4]
7009c954: fbbc f0f3    	udiv	r0, r12, r3
7009c958: fb00 c013    	mls	r0, r0, r3, r12
7009c95c: fab0 f080    	clz	r0, r0
7009c960: 0940         	lsrs	r0, r0, #0x5
7009c962: f64f 53ac    	movw	r3, #0xfdac
7009c966: f2c7 030a    	movt	r3, #0x700a
7009c96a: 46ec         	mov	r12, sp
7009c96c: f8cc 3000    	str.w	r3, [r12]
7009c970: 2349         	movs	r3, #0x49
7009c972: f00c fbd5    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xc7aa
;     TimerP_stop(baseAddr);
7009c976: 9815         	ldr	r0, [sp, #0x54]
7009c978: f011 f90a    	bl	0x700adb90 <TimerP_stop> @ imm = #0x11214
;     TimerP_clearOverflowInt(baseAddr);
7009c97c: 9815         	ldr	r0, [sp, #0x54]
7009c97e: f010 fb5f    	bl	0x700ad040 <TimerP_clearOverflowInt> @ imm = #0x106be
7009c982: 9905         	ldr	r1, [sp, #0x14]
;     timeInNsec = (uint64_t)params->periodInNsec;
7009c984: 9814         	ldr	r0, [sp, #0x50]
7009c986: 68c0         	ldr	r0, [r0, #0xc]
7009c988: 910f         	str	r1, [sp, #0x3c]
7009c98a: 900e         	str	r0, [sp, #0x38]
;     if(timeInNsec == 0U)
7009c98c: 980e         	ldr	r0, [sp, #0x38]
7009c98e: 990f         	ldr	r1, [sp, #0x3c]
7009c990: 4308         	orrs	r0, r1
7009c992: b948         	cbnz	r0, 0x7009c9a8 <TimerP_setup+0x148> @ imm = #0x12
7009c994: e7ff         	b	0x7009c996 <TimerP_setup+0x136> @ imm = #-0x2
;         timeInNsec = (uint64_t)params->periodInUsec*1000U;
7009c996: 9814         	ldr	r0, [sp, #0x50]
7009c998: 6880         	ldr	r0, [r0, #0x8]
7009c99a: f44f 717a    	mov.w	r1, #0x3e8
7009c99e: fba0 0101    	umull	r0, r1, r0, r1
7009c9a2: 910f         	str	r1, [sp, #0x3c]
7009c9a4: 900e         	str	r0, [sp, #0x38]
;     }
7009c9a6: e7ff         	b	0x7009c9a8 <TimerP_setup+0x148> @ imm = #-0x2
;     inputClkHz = (uint64_t)params->inputClkHz / (uint64_t)params->inputPreScaler;
7009c9a8: 9814         	ldr	r0, [sp, #0x50]
7009c9aa: 6802         	ldr	r2, [r0]
7009c9ac: 6840         	ldr	r0, [r0, #0x4]
7009c9ae: 2300         	movs	r3, #0x0
7009c9b0: 9302         	str	r3, [sp, #0x8]
7009c9b2: 4619         	mov	r1, r3
7009c9b4: f010 ee6e    	blx	0x700ad694 <__aeabi_uldivmod> @ imm = #0x10cdc
7009c9b8: 9b02         	ldr	r3, [sp, #0x8]
7009c9ba: 910d         	str	r1, [sp, #0x34]
7009c9bc: 900c         	str	r0, [sp, #0x30]
;     timerCycles =  ( inputClkHz * timeInNsec ) / 1000000000U;
7009c9be: f8dd c030    	ldr.w	r12, [sp, #0x30]
7009c9c2: 990d         	ldr	r1, [sp, #0x34]
7009c9c4: 9a0e         	ldr	r2, [sp, #0x38]
7009c9c6: f8dd e03c    	ldr.w	lr, [sp, #0x3c]
7009c9ca: fbac 0402    	umull	r0, r4, r12, r2
7009c9ce: fb0c 4c0e    	mla	r12, r12, lr, r4
7009c9d2: fb01 c102    	mla	r1, r1, r2, r12
7009c9d6: f64c 2200    	movw	r2, #0xca00
7009c9da: f6c3 329a    	movt	r2, #0x3b9a
7009c9de: f010 ee5a    	blx	0x700ad694 <__aeabi_uldivmod> @ imm = #0x10cb4
7009c9e2: 4602         	mov	r2, r0
7009c9e4: 9802         	ldr	r0, [sp, #0x8]
7009c9e6: 9201         	str	r2, [sp, #0x4]
7009c9e8: 460a         	mov	r2, r1
7009c9ea: 9901         	ldr	r1, [sp, #0x4]
7009c9ec: 920b         	str	r2, [sp, #0x2c]
7009c9ee: 910a         	str	r1, [sp, #0x28]
;     DebugP_assert( timerCycles < 0xFFFFFFFFU );
7009c9f0: 9a0a         	ldr	r2, [sp, #0x28]
7009c9f2: 990b         	ldr	r1, [sp, #0x2c]
7009c9f4: f1b2 32ff    	subs.w	r2, r2, #0xffffffff
7009c9f8: f171 0100    	sbcs	r1, r1, #0x0
7009c9fc: bf38         	it	lo
7009c9fe: 2001         	movlo	r0, #0x1
7009ca00: f240 216e    	movw	r1, #0x26e
7009ca04: f2c7 010b    	movt	r1, #0x700b
7009ca08: 466a         	mov	r2, sp
7009ca0a: 6011         	str	r1, [r2]
7009ca0c: f240 1139    	movw	r1, #0x139
7009ca10: f2c7 010b    	movt	r1, #0x700b
7009ca14: f240 42b7    	movw	r2, #0x4b7
7009ca18: f2c7 020b    	movt	r2, #0x700b
7009ca1c: 2359         	movs	r3, #0x59
7009ca1e: f00c fb7f    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xc6fe
7009ca22: 9802         	ldr	r0, [sp, #0x8]
;     countVal = 0xFFFFFFFFu - (timerCycles - 1U);
7009ca24: 990a         	ldr	r1, [sp, #0x28]
7009ca26: 4249         	rsbs	r1, r1, #0
7009ca28: 9111         	str	r1, [sp, #0x44]
;     reloadVal = 0;
7009ca2a: 9010         	str	r0, [sp, #0x40]
;     ctrlVal = 0;
7009ca2c: 9012         	str	r0, [sp, #0x48]
;     if(params->inputPreScaler>1U)
7009ca2e: 9814         	ldr	r0, [sp, #0x50]
7009ca30: 6800         	ldr	r0, [r0]
7009ca32: 2802         	cmp	r0, #0x2
7009ca34: d320         	blo	0x7009ca78 <TimerP_setup+0x218> @ imm = #0x40
7009ca36: e7ff         	b	0x7009ca38 <TimerP_setup+0x1d8> @ imm = #-0x2
7009ca38: 2008         	movs	r0, #0x8
;         for(preScaleVal=8U; preScaleVal>=1U; preScaleVal--)
7009ca3a: 9009         	str	r0, [sp, #0x24]
7009ca3c: e7ff         	b	0x7009ca3e <TimerP_setup+0x1de> @ imm = #-0x2
7009ca3e: 9809         	ldr	r0, [sp, #0x24]
7009ca40: b168         	cbz	r0, 0x7009ca5e <TimerP_setup+0x1fe> @ imm = #0x1a
7009ca42: e7ff         	b	0x7009ca44 <TimerP_setup+0x1e4> @ imm = #-0x2
;             if( (params->inputPreScaler & (0x1U << preScaleVal)) != 0U )
7009ca44: 9814         	ldr	r0, [sp, #0x50]
7009ca46: 6800         	ldr	r0, [r0]
7009ca48: 9909         	ldr	r1, [sp, #0x24]
7009ca4a: 40c8         	lsrs	r0, r1
7009ca4c: 07c0         	lsls	r0, r0, #0x1f
7009ca4e: b108         	cbz	r0, 0x7009ca54 <TimerP_setup+0x1f4> @ imm = #0x2
7009ca50: e7ff         	b	0x7009ca52 <TimerP_setup+0x1f2> @ imm = #-0x2
;                 break;
7009ca52: e004         	b	0x7009ca5e <TimerP_setup+0x1fe> @ imm = #0x8
;         }
7009ca54: e7ff         	b	0x7009ca56 <TimerP_setup+0x1f6> @ imm = #-0x2
;         for(preScaleVal=8U; preScaleVal>=1U; preScaleVal--)
7009ca56: 9809         	ldr	r0, [sp, #0x24]
7009ca58: 3801         	subs	r0, #0x1
7009ca5a: 9009         	str	r0, [sp, #0x24]
7009ca5c: e7ef         	b	0x7009ca3e <TimerP_setup+0x1de> @ imm = #-0x22
;         ctrlVal |= (0x1U << 5);
7009ca5e: 9812         	ldr	r0, [sp, #0x48]
7009ca60: f040 0020    	orr	r0, r0, #0x20
7009ca64: 9012         	str	r0, [sp, #0x48]
;         ctrlVal |= ( ((preScaleVal - 1U) & 0x7U) << 2);
7009ca66: 9809         	ldr	r0, [sp, #0x24]
7009ca68: 3801         	subs	r0, #0x1
7009ca6a: f000 0107    	and	r1, r0, #0x7
7009ca6e: 9812         	ldr	r0, [sp, #0x48]
7009ca70: ea40 0081    	orr.w	r0, r0, r1, lsl #2
7009ca74: 9012         	str	r0, [sp, #0x48]
;     }
7009ca76: e7ff         	b	0x7009ca78 <TimerP_setup+0x218> @ imm = #-0x2
;     if(params->oneshotMode==0U)
7009ca78: 9814         	ldr	r0, [sp, #0x50]
7009ca7a: 6900         	ldr	r0, [r0, #0x10]
7009ca7c: b938         	cbnz	r0, 0x7009ca8e <TimerP_setup+0x22e> @ imm = #0xe
7009ca7e: e7ff         	b	0x7009ca80 <TimerP_setup+0x220> @ imm = #-0x2
;         ctrlVal |= (0x1U << 1);
7009ca80: 9812         	ldr	r0, [sp, #0x48]
7009ca82: f040 0002    	orr	r0, r0, #0x2
7009ca86: 9012         	str	r0, [sp, #0x48]
;         reloadVal = countVal;
7009ca88: 9811         	ldr	r0, [sp, #0x44]
7009ca8a: 9010         	str	r0, [sp, #0x40]
;     }
7009ca8c: e7ff         	b	0x7009ca8e <TimerP_setup+0x22e> @ imm = #-0x2
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TCLR);
7009ca8e: 9815         	ldr	r0, [sp, #0x54]
7009ca90: 3038         	adds	r0, #0x38
7009ca92: 9013         	str	r0, [sp, #0x4c]
;     *addr = ctrlVal;
7009ca94: 9812         	ldr	r0, [sp, #0x48]
7009ca96: 9913         	ldr	r1, [sp, #0x4c]
7009ca98: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TCRR);
7009ca9a: 9815         	ldr	r0, [sp, #0x54]
7009ca9c: 303c         	adds	r0, #0x3c
7009ca9e: 9013         	str	r0, [sp, #0x4c]
;     *addr = countVal;
7009caa0: 9811         	ldr	r0, [sp, #0x44]
7009caa2: 9913         	ldr	r1, [sp, #0x4c]
7009caa4: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TLDR);
7009caa6: 9815         	ldr	r0, [sp, #0x54]
7009caa8: 3040         	adds	r0, #0x40
7009caaa: 9013         	str	r0, [sp, #0x4c]
;     *addr = reloadVal;
7009caac: 9810         	ldr	r0, [sp, #0x40]
7009caae: 9913         	ldr	r1, [sp, #0x4c]
7009cab0: 6008         	str	r0, [r1]
;     if((params->enableOverflowInt) != 0U)
7009cab2: 9814         	ldr	r0, [sp, #0x50]
7009cab4: 6940         	ldr	r0, [r0, #0x14]
7009cab6: b138         	cbz	r0, 0x7009cac8 <TimerP_setup+0x268> @ imm = #0xe
7009cab8: e7ff         	b	0x7009caba <TimerP_setup+0x25a> @ imm = #-0x2
;         addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_INT_ENABLE);
7009caba: 9815         	ldr	r0, [sp, #0x54]
7009cabc: 302c         	adds	r0, #0x2c
7009cabe: 9013         	str	r0, [sp, #0x4c]
;         *addr = (0x1U << TIMER_OVF_INT_SHIFT);
7009cac0: 9913         	ldr	r1, [sp, #0x4c]
7009cac2: 2002         	movs	r0, #0x2
7009cac4: 6008         	str	r0, [r1]
;     }
7009cac6: e006         	b	0x7009cad6 <TimerP_setup+0x276> @ imm = #0xc
;         addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_INT_DISABLE);
7009cac8: 9815         	ldr	r0, [sp, #0x54]
7009caca: 3030         	adds	r0, #0x30
7009cacc: 9013         	str	r0, [sp, #0x4c]
;         *addr = (0x1U << TIMER_OVF_INT_SHIFT);
7009cace: 9913         	ldr	r1, [sp, #0x4c]
7009cad0: 2002         	movs	r0, #0x2
7009cad2: 6008         	str	r0, [r1]
7009cad4: e7ff         	b	0x7009cad6 <TimerP_setup+0x276> @ imm = #-0x2
; }
7009cad6: b016         	add	sp, #0x58
7009cad8: bd10         	pop	{r4, pc}
7009cada: 0000         	movs	r0, r0
7009cadc: 0000         	movs	r0, r0
7009cade: 0000         	movs	r0, r0

7009cae0 <Udma_chConfigRx>:
; {
7009cae0: b580         	push	{r7, lr}
7009cae2: b09c         	sub	sp, #0x70
7009cae4: 901b         	str	r0, [sp, #0x6c]
7009cae6: 911a         	str	r1, [sp, #0x68]
7009cae8: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009caea: 9019         	str	r0, [sp, #0x64]
;     Udma_ChHandleInt        chHandleInt = (Udma_ChHandleInt) chHandle;
7009caec: 981b         	ldr	r0, [sp, #0x6c]
7009caee: 9017         	str	r0, [sp, #0x5c]
;     if((NULL_PTR == chHandleInt) ||
7009caf0: 9817         	ldr	r0, [sp, #0x5c]
7009caf2: b188         	cbz	r0, 0x7009cb18 <Udma_chConfigRx+0x38> @ imm = #0x22
7009caf4: e7ff         	b	0x7009caf6 <Udma_chConfigRx+0x16> @ imm = #-0x2
;         (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
7009caf6: 9817         	ldr	r0, [sp, #0x5c]
7009caf8: f8d0 0244    	ldr.w	r0, [r0, #0x244]
7009cafc: f64a 31cd    	movw	r1, #0xabcd
7009cb00: f6ca 31dc    	movt	r1, #0xabdc
7009cb04: 4288         	cmp	r0, r1
7009cb06: d107         	bne	0x7009cb18 <Udma_chConfigRx+0x38> @ imm = #0xe
7009cb08: e7ff         	b	0x7009cb0a <Udma_chConfigRx+0x2a> @ imm = #-0x2
;         ((chHandleInt->chType & UDMA_CH_FLAG_RX) != UDMA_CH_FLAG_RX))
7009cb0a: 9817         	ldr	r0, [sp, #0x5c]
7009cb0c: 6800         	ldr	r0, [r0]
7009cb0e: f000 0002    	and	r0, r0, #0x2
;     if((NULL_PTR == chHandleInt) ||
7009cb12: 2802         	cmp	r0, #0x2
7009cb14: d004         	beq	0x7009cb20 <Udma_chConfigRx+0x40> @ imm = #0x8
7009cb16: e7ff         	b	0x7009cb18 <Udma_chConfigRx+0x38> @ imm = #-0x2
7009cb18: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009cb1c: 9019         	str	r0, [sp, #0x64]
;     }
7009cb1e: e7ff         	b	0x7009cb20 <Udma_chConfigRx+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009cb20: 9819         	ldr	r0, [sp, #0x64]
7009cb22: b9a8         	cbnz	r0, 0x7009cb50 <Udma_chConfigRx+0x70> @ imm = #0x2a
7009cb24: e7ff         	b	0x7009cb26 <Udma_chConfigRx+0x46> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
7009cb26: 9817         	ldr	r0, [sp, #0x5c]
7009cb28: 6e80         	ldr	r0, [r0, #0x68]
7009cb2a: 9018         	str	r0, [sp, #0x60]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009cb2c: 9818         	ldr	r0, [sp, #0x60]
7009cb2e: b150         	cbz	r0, 0x7009cb46 <Udma_chConfigRx+0x66> @ imm = #0x14
7009cb30: e7ff         	b	0x7009cb32 <Udma_chConfigRx+0x52> @ imm = #-0x2
7009cb32: 9818         	ldr	r0, [sp, #0x60]
7009cb34: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009cb38: f64a 31cd    	movw	r1, #0xabcd
7009cb3c: f6ca 31dc    	movt	r1, #0xabdc
7009cb40: 4288         	cmp	r0, r1
7009cb42: d004         	beq	0x7009cb4e <Udma_chConfigRx+0x6e> @ imm = #0x8
7009cb44: e7ff         	b	0x7009cb46 <Udma_chConfigRx+0x66> @ imm = #-0x2
7009cb46: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009cb4a: 9019         	str	r0, [sp, #0x64]
;         }
7009cb4c: e7ff         	b	0x7009cb4e <Udma_chConfigRx+0x6e> @ imm = #-0x2
;     }
7009cb4e: e7ff         	b	0x7009cb50 <Udma_chConfigRx+0x70> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009cb50: 9819         	ldr	r0, [sp, #0x64]
7009cb52: 2800         	cmp	r0, #0x0
7009cb54: f040 80f1    	bne.w	0x7009cd3a <Udma_chConfigRx+0x25a> @ imm = #0x1e2
7009cb58: e7ff         	b	0x7009cb5a <Udma_chConfigRx+0x7a> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
7009cb5a: 9818         	ldr	r0, [sp, #0x60]
7009cb5c: 6800         	ldr	r0, [r0]
7009cb5e: 2801         	cmp	r0, #0x1
7009cb60: d107         	bne	0x7009cb72 <Udma_chConfigRx+0x92> @ imm = #0xe
7009cb62: e7ff         	b	0x7009cb64 <Udma_chConfigRx+0x84> @ imm = #-0x2
;             ((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
7009cb64: 9817         	ldr	r0, [sp, #0x5c]
;         if ((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
7009cb66: 7800         	ldrb	r0, [r0]
7009cb68: 0740         	lsls	r0, r0, #0x1d
7009cb6a: 2800         	cmp	r0, #0x0
7009cb6c: d501         	bpl	0x7009cb72 <Udma_chConfigRx+0x92> @ imm = #0x2
7009cb6e: e7ff         	b	0x7009cb70 <Udma_chConfigRx+0x90> @ imm = #-0x2
;         }
7009cb70: e0e2         	b	0x7009cd38 <Udma_chConfigRx+0x258> @ imm = #0x1c4
7009cb72: f645 70ff    	movw	r0, #0x5fff
;             rmUdmaRxReq.valid_params        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERR_VALID |
7009cb76: 9010         	str	r0, [sp, #0x40]
;             rmUdmaRxReq.nav_id              = drvHandle->devIdUdma;
7009cb78: 9818         	ldr	r0, [sp, #0x60]
7009cb7a: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009cb7e: f8ad 0044    	strh.w	r0, [sp, #0x44]
;             rmUdmaRxReq.index               = (uint16_t)chHandleInt->rxChNum;
7009cb82: 9817         	ldr	r0, [sp, #0x5c]
7009cb84: 6f00         	ldr	r0, [r0, #0x70]
7009cb86: f8ad 0046    	strh.w	r0, [sp, #0x46]
;             rmUdmaRxReq.rx_pause_on_err     = rxPrms->pauseOnError;
7009cb8a: 981a         	ldr	r0, [sp, #0x68]
7009cb8c: 7800         	ldrb	r0, [r0]
7009cb8e: f88d 0054    	strb.w	r0, [sp, #0x54]
;             rmUdmaRxReq.rx_atype            = rxPrms->addrType;
7009cb92: 981a         	ldr	r0, [sp, #0x68]
7009cb94: 7840         	ldrb	r0, [r0, #0x1]
7009cb96: f88d 0055    	strb.w	r0, [sp, #0x55]
;             rmUdmaRxReq.rx_chan_type        = rxPrms->chanType;
7009cb9a: 981a         	ldr	r0, [sp, #0x68]
7009cb9c: 7880         	ldrb	r0, [r0, #0x2]
7009cb9e: f88d 0056    	strb.w	r0, [sp, #0x56]
;             rmUdmaRxReq.rx_fetch_size       = rxPrms->fetchWordSize;
7009cba2: 981a         	ldr	r0, [sp, #0x68]
7009cba4: 8880         	ldrh	r0, [r0, #0x4]
7009cba6: f8ad 0048    	strh.w	r0, [sp, #0x48]
;             rmUdmaRxReq.rx_priority         = rxPrms->busPriority;
7009cbaa: 981a         	ldr	r0, [sp, #0x68]
7009cbac: 7980         	ldrb	r0, [r0, #0x6]
7009cbae: f88d 004c    	strb.w	r0, [sp, #0x4c]
;             rmUdmaRxReq.rx_qos              = rxPrms->busQos;
7009cbb2: 981a         	ldr	r0, [sp, #0x68]
7009cbb4: 79c0         	ldrb	r0, [r0, #0x7]
7009cbb6: f88d 004d    	strb.w	r0, [sp, #0x4d]
;             rmUdmaRxReq.rx_orderid          = rxPrms->busOrderId;
7009cbba: 981a         	ldr	r0, [sp, #0x68]
7009cbbc: 7a00         	ldrb	r0, [r0, #0x8]
7009cbbe: f88d 004e    	strb.w	r0, [sp, #0x4e]
;             rmUdmaRxReq.rx_sched_priority   = rxPrms->dmaPriority;
7009cbc2: 981a         	ldr	r0, [sp, #0x68]
7009cbc4: 7a40         	ldrb	r0, [r0, #0x9]
7009cbc6: f88d 004f    	strb.w	r0, [sp, #0x4f]
;             rmUdmaRxReq.flowid_start        = rxPrms->flowIdFwRangeStart;
7009cbca: 981a         	ldr	r0, [sp, #0x68]
7009cbcc: 8940         	ldrh	r0, [r0, #0xa]
7009cbce: f8ad 0050    	strh.w	r0, [sp, #0x50]
;             rmUdmaRxReq.flowid_cnt          = rxPrms->flowIdFwRangeCnt;
7009cbd2: 981a         	ldr	r0, [sp, #0x68]
7009cbd4: 8980         	ldrh	r0, [r0, #0xc]
7009cbd6: f8ad 0052    	strh.w	r0, [sp, #0x52]
;             rmUdmaRxReq.rx_ignore_short     = rxPrms->ignoreShortPkts;
7009cbda: 981a         	ldr	r0, [sp, #0x68]
7009cbdc: 7c80         	ldrb	r0, [r0, #0x12]
7009cbde: f88d 0057    	strb.w	r0, [sp, #0x57]
;             rmUdmaRxReq.rx_ignore_long      = rxPrms->ignoreLongPkts;
7009cbe2: 981a         	ldr	r0, [sp, #0x68]
7009cbe4: 7cc0         	ldrb	r0, [r0, #0x13]
7009cbe6: f88d 0058    	strb.w	r0, [sp, #0x58]
;             rmUdmaRxReq.rx_burst_size       = rxPrms->burstSize;
7009cbea: 981a         	ldr	r0, [sp, #0x68]
7009cbec: 7e00         	ldrb	r0, [r0, #0x18]
7009cbee: f88d 0059    	strb.w	r0, [sp, #0x59]
;             if(NULL_PTR != chHandleInt->tdCqRing)
7009cbf2: 9817         	ldr	r0, [sp, #0x5c]
7009cbf4: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009cbf8: b138         	cbz	r0, 0x7009cc0a <Udma_chConfigRx+0x12a> @ imm = #0xe
7009cbfa: e7ff         	b	0x7009cbfc <Udma_chConfigRx+0x11c> @ imm = #-0x2
;                 rmUdmaRxReq.rxcq_qnum          = chHandleInt->tdCqRing->ringNum;
7009cbfc: 9817         	ldr	r0, [sp, #0x5c]
7009cbfe: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009cc02: 8880         	ldrh	r0, [r0, #0x4]
7009cc04: f8ad 004a    	strh.w	r0, [sp, #0x4a]
;             }
7009cc08: e004         	b	0x7009cc14 <Udma_chConfigRx+0x134> @ imm = #0x8
7009cc0a: f64f 70ff    	movw	r0, #0xffff
;                 rmUdmaRxReq.rxcq_qnum          = UDMA_RING_INVALID;
7009cc0e: f8ad 004a    	strh.w	r0, [sp, #0x4a]
7009cc12: e7ff         	b	0x7009cc14 <Udma_chConfigRx+0x134> @ imm = #-0x2
7009cc14: a80e         	add	r0, sp, #0x38
7009cc16: a90c         	add	r1, sp, #0x30
7009cc18: f04f 32ff    	mov.w	r2, #0xffffffff
;             retVal = Sciclient_rmUdmapRxChCfg(
7009cc1c: f00e f910    	bl	0x700aae40 <Sciclient_rmUdmapRxChCfg> @ imm = #0xe220
7009cc20: 9019         	str	r0, [sp, #0x64]
;             if(CSL_PASS != retVal)
7009cc22: 9819         	ldr	r0, [sp, #0x64]
7009cc24: b108         	cbz	r0, 0x7009cc2a <Udma_chConfigRx+0x14a> @ imm = #0x2
7009cc26: e7ff         	b	0x7009cc28 <Udma_chConfigRx+0x148> @ imm = #-0x2
;             }
7009cc28: e7ff         	b	0x7009cc2a <Udma_chConfigRx+0x14a> @ imm = #-0x2
;             if((((chHandleInt->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA) ||
7009cc2a: 9817         	ldr	r0, [sp, #0x5c]
7009cc2c: 6800         	ldr	r0, [r0]
7009cc2e: f000 0008    	and	r0, r0, #0x8
7009cc32: 2808         	cmp	r0, #0x8
7009cc34: d006         	beq	0x7009cc44 <Udma_chConfigRx+0x164> @ imm = #0xc
7009cc36: e7ff         	b	0x7009cc38 <Udma_chConfigRx+0x158> @ imm = #-0x2
;                     ((chHandleInt->chType & UDMA_CH_FLAG_PSIL) == UDMA_CH_FLAG_PSIL)) &&
7009cc38: 9817         	ldr	r0, [sp, #0x5c]
7009cc3a: 7800         	ldrb	r0, [r0]
7009cc3c: 06c0         	lsls	r0, r0, #0x1b
7009cc3e: 2800         	cmp	r0, #0x0
7009cc40: d569         	bpl	0x7009cd16 <Udma_chConfigRx+0x236> @ imm = #0xd2
7009cc42: e7ff         	b	0x7009cc44 <Udma_chConfigRx+0x164> @ imm = #-0x2
;                (TRUE == rxPrms->configDefaultFlow))
7009cc44: 981a         	ldr	r0, [sp, #0x68]
7009cc46: 6940         	ldr	r0, [r0, #0x14]
;             if((((chHandleInt->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA) ||
7009cc48: 2801         	cmp	r0, #0x1
7009cc4a: d164         	bne	0x7009cd16 <Udma_chConfigRx+0x236> @ imm = #0xc8
7009cc4c: e7ff         	b	0x7009cc4e <Udma_chConfigRx+0x16e> @ imm = #-0x2
;                 UdmaFlowPrms_init(&flowPrms, chHandleInt->chType);
7009cc4e: 9817         	ldr	r0, [sp, #0x5c]
7009cc50: 6801         	ldr	r1, [r0]
7009cc52: a801         	add	r0, sp, #0x4
7009cc54: f00b f87c    	bl	0x700a7d50 <UdmaFlowPrms_init> @ imm = #0xb0f8
;                 flowPrms.psInfoPresent = rxPrms->flowPsInfoPresent;
7009cc58: 981a         	ldr	r0, [sp, #0x68]
7009cc5a: 7bc0         	ldrb	r0, [r0, #0xf]
7009cc5c: f88d 0009    	strb.w	r0, [sp, #0x9]
;                 flowPrms.einfoPresent  = rxPrms->flowEInfoPresent;
7009cc60: 981a         	ldr	r0, [sp, #0x68]
7009cc62: 7b80         	ldrb	r0, [r0, #0xe]
7009cc64: f88d 0008    	strb.w	r0, [sp, #0x8]
;                 flowPrms.errorHandling = rxPrms->flowErrorHandling;
7009cc68: 981a         	ldr	r0, [sp, #0x68]
7009cc6a: 7c00         	ldrb	r0, [r0, #0x10]
7009cc6c: f88d 000a    	strb.w	r0, [sp, #0xa]
;                 flowPrms.sopOffset     = rxPrms->flowSopOffset;
7009cc70: 981a         	ldr	r0, [sp, #0x68]
7009cc72: 7c40         	ldrb	r0, [r0, #0x11]
7009cc74: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                 if(NULL_PTR == chHandleInt->cqRing)
7009cc78: 9817         	ldr	r0, [sp, #0x5c]
7009cc7a: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009cc7e: b928         	cbnz	r0, 0x7009cc8c <Udma_chConfigRx+0x1ac> @ imm = #0xa
7009cc80: e7ff         	b	0x7009cc82 <Udma_chConfigRx+0x1a2> @ imm = #-0x2
7009cc82: f64f 70ff    	movw	r0, #0xffff
;                     cqRing = UDMA_RING_INVALID;
7009cc86: f8ad 0002    	strh.w	r0, [sp, #0x2]
;                 }
7009cc8a: e006         	b	0x7009cc9a <Udma_chConfigRx+0x1ba> @ imm = #0xc
;                     cqRing = chHandleInt->cqRing->ringNum;
7009cc8c: 9817         	ldr	r0, [sp, #0x5c]
7009cc8e: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009cc92: 8880         	ldrh	r0, [r0, #0x4]
7009cc94: f8ad 0002    	strh.w	r0, [sp, #0x2]
7009cc98: e7ff         	b	0x7009cc9a <Udma_chConfigRx+0x1ba> @ imm = #-0x2
;                 if(NULL_PTR == chHandleInt->fqRing)
7009cc9a: 9817         	ldr	r0, [sp, #0x5c]
7009cc9c: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009cca0: b928         	cbnz	r0, 0x7009ccae <Udma_chConfigRx+0x1ce> @ imm = #0xa
7009cca2: e7ff         	b	0x7009cca4 <Udma_chConfigRx+0x1c4> @ imm = #-0x2
7009cca4: f64f 70ff    	movw	r0, #0xffff
;                     fqRing = UDMA_RING_INVALID;
7009cca8: f8ad 0000    	strh.w	r0, [sp]
;                 }
7009ccac: e006         	b	0x7009ccbc <Udma_chConfigRx+0x1dc> @ imm = #0xc
;                     fqRing = chHandleInt->fqRing->ringNum;
7009ccae: 9817         	ldr	r0, [sp, #0x5c]
7009ccb0: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009ccb4: 8880         	ldrh	r0, [r0, #0x4]
7009ccb6: f8ad 0000    	strh.w	r0, [sp]
7009ccba: e7ff         	b	0x7009ccbc <Udma_chConfigRx+0x1dc> @ imm = #-0x2
;                 flowPrms.defaultRxCQ    = cqRing;
7009ccbc: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
7009ccc0: f8ad 0010    	strh.w	r0, [sp, #0x10]
;                 flowPrms.fdq0Sz0Qnum    = fqRing;
7009ccc4: f8bd 0000    	ldrh.w	r0, [sp]
7009ccc8: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;                 flowPrms.fdq0Sz1Qnum    = fqRing;
7009cccc: f8bd 0000    	ldrh.w	r0, [sp]
7009ccd0: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;                 flowPrms.fdq0Sz2Qnum    = fqRing;
7009ccd4: f8bd 0000    	ldrh.w	r0, [sp]
7009ccd8: f8ad 002c    	strh.w	r0, [sp, #0x2c]
;                 flowPrms.fdq0Sz3Qnum    = fqRing;
7009ccdc: f8bd 0000    	ldrh.w	r0, [sp]
7009cce0: f8ad 002e    	strh.w	r0, [sp, #0x2e]
;                 flowPrms.fdq1Qnum       = fqRing;
7009cce4: f8bd 0000    	ldrh.w	r0, [sp]
7009cce8: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 flowPrms.fdq2Qnum       = fqRing;
7009ccec: f8bd 0000    	ldrh.w	r0, [sp]
7009ccf0: f8ad 0020    	strh.w	r0, [sp, #0x20]
;                 flowPrms.fdq3Qnum       = fqRing;
7009ccf4: f8bd 0000    	ldrh.w	r0, [sp]
7009ccf8: f8ad 0022    	strh.w	r0, [sp, #0x22]
;                 retVal = Udma_flowConfig(chHandleInt->defaultFlow, 0U, &flowPrms);
7009ccfc: 9817         	ldr	r0, [sp, #0x5c]
7009ccfe: f8d0 01c8    	ldr.w	r0, [r0, #0x1c8]
7009cd02: 2100         	movs	r1, #0x0
7009cd04: aa01         	add	r2, sp, #0x4
7009cd06: f001 f8bb    	bl	0x7009de80 <Udma_flowConfig> @ imm = #0x1176
7009cd0a: 9019         	str	r0, [sp, #0x64]
;                 if(UDMA_SOK != retVal)
7009cd0c: 9819         	ldr	r0, [sp, #0x64]
7009cd0e: b108         	cbz	r0, 0x7009cd14 <Udma_chConfigRx+0x234> @ imm = #0x2
7009cd10: e7ff         	b	0x7009cd12 <Udma_chConfigRx+0x232> @ imm = #-0x2
;                 }
7009cd12: e7ff         	b	0x7009cd14 <Udma_chConfigRx+0x234> @ imm = #-0x2
;             }
7009cd14: e7ff         	b	0x7009cd16 <Udma_chConfigRx+0x236> @ imm = #-0x2
;             if(UDMA_SOK == retVal)
7009cd16: 9819         	ldr	r0, [sp, #0x64]
7009cd18: b968         	cbnz	r0, 0x7009cd36 <Udma_chConfigRx+0x256> @ imm = #0x1a
7009cd1a: e7ff         	b	0x7009cd1c <Udma_chConfigRx+0x23c> @ imm = #-0x2
;                 (void) memcpy(&chHandleInt->rxPrms, rxPrms, sizeof(chHandleInt->rxPrms));
7009cd1c: 9817         	ldr	r0, [sp, #0x5c]
7009cd1e: f500 70fc    	add.w	r0, r0, #0x1f8
7009cd22: 991a         	ldr	r1, [sp, #0x68]
7009cd24: e8b1 100c    	ldm.w	r1!, {r2, r3, r12}
7009cd28: e8a0 100c    	stm.w	r0!, {r2, r3, r12}
7009cd2c: e891 500c    	ldm.w	r1, {r2, r3, r12, lr}
7009cd30: e880 500c    	stm.w	r0, {r2, r3, r12, lr}
;             }
7009cd34: e7ff         	b	0x7009cd36 <Udma_chConfigRx+0x256> @ imm = #-0x2
7009cd36: e7ff         	b	0x7009cd38 <Udma_chConfigRx+0x258> @ imm = #-0x2
;     }
7009cd38: e7ff         	b	0x7009cd3a <Udma_chConfigRx+0x25a> @ imm = #-0x2
;     return (retVal);
7009cd3a: 9819         	ldr	r0, [sp, #0x64]
7009cd3c: b01c         	add	sp, #0x70
7009cd3e: bd80         	pop	{r7, pc}

7009cd40 <Sciclient_rmIrqFindRoute>:
; {
7009cd40: b580         	push	{r7, lr}
7009cd42: b08a         	sub	sp, #0x28
7009cd44: 9009         	str	r0, [sp, #0x24]
7009cd46: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009cd48: 9008         	str	r0, [sp, #0x20]
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009cd4a: 9809         	ldr	r0, [sp, #0x24]
7009cd4c: 88c0         	ldrh	r0, [r0, #0x6]
7009cd4e: f010 f80f    	bl	0x700acd70 <Sciclient_rmIrIsIr> @ imm = #0x1001e
7009cd52: b930         	cbnz	r0, 0x7009cd62 <Sciclient_rmIrqFindRoute+0x22> @ imm = #0xc
7009cd54: e7ff         	b	0x7009cd56 <Sciclient_rmIrqFindRoute+0x16> @ imm = #-0x2
;         (Sciclient_rmIrIsIr(cfg->d_id) == true)) {
7009cd56: 9809         	ldr	r0, [sp, #0x24]
7009cd58: 8940         	ldrh	r0, [r0, #0xa]
7009cd5a: f010 f809    	bl	0x700acd70 <Sciclient_rmIrIsIr> @ imm = #0x10012
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009cd5e: b120         	cbz	r0, 0x7009cd6a <Sciclient_rmIrqFindRoute+0x2a> @ imm = #0x8
7009cd60: e7ff         	b	0x7009cd62 <Sciclient_rmIrqFindRoute+0x22> @ imm = #-0x2
7009cd62: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009cd66: 9008         	str	r0, [sp, #0x20]
;     }
7009cd68: e7ff         	b	0x7009cd6a <Sciclient_rmIrqFindRoute+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009cd6a: 9808         	ldr	r0, [sp, #0x20]
7009cd6c: bb20         	cbnz	r0, 0x7009cdb8 <Sciclient_rmIrqFindRoute+0x78> @ imm = #0x48
7009cd6e: e7ff         	b	0x7009cd70 <Sciclient_rmIrqFindRoute+0x30> @ imm = #-0x2
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009cd70: 9809         	ldr	r0, [sp, #0x24]
7009cd72: 8a00         	ldrh	r0, [r0, #0x10]
7009cd74: 28ff         	cmp	r0, #0xff
7009cd76: d015         	beq	0x7009cda4 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0x2a
7009cd78: e7ff         	b	0x7009cd7a <Sciclient_rmIrqFindRoute+0x3a> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009cd7a: 9809         	ldr	r0, [sp, #0x24]
7009cd7c: 6800         	ldr	r0, [r0]
7009cd7e: 2104         	movs	r1, #0x4
7009cd80: f010 fa06    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x1040c
;              true) &&
7009cd84: b170         	cbz	r0, 0x7009cda4 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0x1c
7009cd86: e7ff         	b	0x7009cd88 <Sciclient_rmIrqFindRoute+0x48> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009cd88: 9809         	ldr	r0, [sp, #0x24]
7009cd8a: 6800         	ldr	r0, [r0]
7009cd8c: 2108         	movs	r1, #0x8
7009cd8e: f010 f9ff    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x103fe
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009cd92: b138         	cbz	r0, 0x7009cda4 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0xe
7009cd94: e7ff         	b	0x7009cd96 <Sciclient_rmIrqFindRoute+0x56> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNode(cfg->s_ia, &cur_n);
7009cd96: 9809         	ldr	r0, [sp, #0x24]
7009cd98: 8a00         	ldrh	r0, [r0, #0x10]
7009cd9a: a905         	add	r1, sp, #0x14
7009cd9c: f007 fa98    	bl	0x700a42d0 <Sciclient_rmIrqGetNode> @ imm = #0x7530
7009cda0: 9008         	str	r0, [sp, #0x20]
;         } else {
7009cda2: e006         	b	0x7009cdb2 <Sciclient_rmIrqFindRoute+0x72> @ imm = #0xc
;             r = Sciclient_rmIrqGetNode(cfg->s_id, &cur_n);
7009cda4: 9809         	ldr	r0, [sp, #0x24]
7009cda6: 88c0         	ldrh	r0, [r0, #0x6]
7009cda8: a905         	add	r1, sp, #0x14
7009cdaa: f007 fa91    	bl	0x700a42d0 <Sciclient_rmIrqGetNode> @ imm = #0x7522
7009cdae: 9008         	str	r0, [sp, #0x20]
7009cdb0: e7ff         	b	0x7009cdb2 <Sciclient_rmIrqFindRoute+0x72> @ imm = #-0x2
;         root_n = cur_n;
7009cdb2: 9805         	ldr	r0, [sp, #0x14]
7009cdb4: 9004         	str	r0, [sp, #0x10]
;     }
7009cdb6: e7ff         	b	0x7009cdb8 <Sciclient_rmIrqFindRoute+0x78> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009cdb8: 9808         	ldr	r0, [sp, #0x20]
7009cdba: b968         	cbnz	r0, 0x7009cdd8 <Sciclient_rmIrqFindRoute+0x98> @ imm = #0x1a
7009cdbc: e7ff         	b	0x7009cdbe <Sciclient_rmIrqFindRoute+0x7e> @ imm = #-0x2
7009cdbe: 2001         	movs	r0, #0x1
;         search = true;
7009cdc0: 9002         	str	r0, [sp, #0x8]
7009cdc2: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         Sciclient_rmPsInit();
7009cdc6: f010 fd83    	bl	0x700ad8d0 <Sciclient_rmPsInit> @ imm = #0x10b06
7009cdca: 9802         	ldr	r0, [sp, #0x8]
;         search_depth = 1u;
7009cdcc: f8ad 001c    	strh.w	r0, [sp, #0x1c]
7009cdd0: 2000         	movs	r0, #0x0
;         if_idx = 0u;
7009cdd2: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     } else {
7009cdd6: e003         	b	0x7009cde0 <Sciclient_rmIrqFindRoute+0xa0> @ imm = #0x6
7009cdd8: 2000         	movs	r0, #0x0
;         search = false;
7009cdda: f88d 001f    	strb.w	r0, [sp, #0x1f]
7009cdde: e7ff         	b	0x7009cde0 <Sciclient_rmIrqFindRoute+0xa0> @ imm = #-0x2
;     while (search == true) {
7009cde0: e7ff         	b	0x7009cde2 <Sciclient_rmIrqFindRoute+0xa2> @ imm = #-0x2
7009cde2: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009cde6: 07c0         	lsls	r0, r0, #0x1f
7009cde8: 2800         	cmp	r0, #0x0
7009cdea: f000 80ca    	beq.w	0x7009cf82 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x194
7009cdee: e7ff         	b	0x7009cdf0 <Sciclient_rmIrqFindRoute+0xb0> @ imm = #-0x2
7009cdf0: 2000         	movs	r0, #0x0
;         node_clear = false;
7009cdf2: f88d 0019    	strb.w	r0, [sp, #0x19]
;         if (if_idx < cur_n->n_if) {
7009cdf6: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009cdfa: 9905         	ldr	r1, [sp, #0x14]
7009cdfc: 8849         	ldrh	r1, [r1, #0x2]
7009cdfe: 4288         	cmp	r0, r1
7009ce00: f280 8087    	bge.w	0x7009cf12 <Sciclient_rmIrqFindRoute+0x1d2> @ imm = #0x10e
7009ce04: e7ff         	b	0x7009ce06 <Sciclient_rmIrqFindRoute+0xc6> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(cur_n, if_idx, &cur_if);
7009ce06: 9805         	ldr	r0, [sp, #0x14]
7009ce08: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009ce0c: aa03         	add	r2, sp, #0xc
7009ce0e: f00f f827    	bl	0x700abe60 <Sciclient_rmIrqGetNodeItf> @ imm = #0xf04e
7009ce12: 9008         	str	r0, [sp, #0x20]
;             if (r != SystemP_SUCCESS) {
7009ce14: 9808         	ldr	r0, [sp, #0x20]
7009ce16: b108         	cbz	r0, 0x7009ce1c <Sciclient_rmIrqFindRoute+0xdc> @ imm = #0x2
7009ce18: e7ff         	b	0x7009ce1a <Sciclient_rmIrqFindRoute+0xda> @ imm = #-0x2
;                 break;
7009ce1a: e0b2         	b	0x7009cf82 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x164
;             if ((Sciclient_rmIaIsIa(cur_n->id) == false) &&
7009ce1c: 9805         	ldr	r0, [sp, #0x14]
7009ce1e: 8800         	ldrh	r0, [r0]
7009ce20: f00f ff8e    	bl	0x700acd40 <Sciclient_rmIaIsIa> @ imm = #0xff1c
7009ce24: b9d0         	cbnz	r0, 0x7009ce5c <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0x34
7009ce26: e7ff         	b	0x7009ce28 <Sciclient_rmIrqFindRoute+0xe8> @ imm = #-0x2
;                 (Sciclient_rmPsIsEmpty() == true) &&
7009ce28: f010 f9ca    	bl	0x700ad1c0 <Sciclient_rmPsIsEmpty> @ imm = #0x10394
7009ce2c: b1b0         	cbz	r0, 0x7009ce5c <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0x2c
7009ce2e: e7ff         	b	0x7009ce30 <Sciclient_rmIrqFindRoute+0xf0> @ imm = #-0x2
;                 ((cfg->s_idx < cur_if->lbase) ||
7009ce30: 9809         	ldr	r0, [sp, #0x24]
7009ce32: 8900         	ldrh	r0, [r0, #0x8]
7009ce34: 9903         	ldr	r1, [sp, #0xc]
7009ce36: 8809         	ldrh	r1, [r1]
7009ce38: 4288         	cmp	r0, r1
7009ce3a: db09         	blt	0x7009ce50 <Sciclient_rmIrqFindRoute+0x110> @ imm = #0x12
7009ce3c: e7ff         	b	0x7009ce3e <Sciclient_rmIrqFindRoute+0xfe> @ imm = #-0x2
;                  (cfg->s_idx >= (cur_if->lbase + cur_if->len)))) {
7009ce3e: 9809         	ldr	r0, [sp, #0x24]
7009ce40: 8900         	ldrh	r0, [r0, #0x8]
7009ce42: 9a03         	ldr	r2, [sp, #0xc]
7009ce44: 8811         	ldrh	r1, [r2]
7009ce46: 8892         	ldrh	r2, [r2, #0x4]
7009ce48: 4411         	add	r1, r2
;             if ((Sciclient_rmIaIsIa(cur_n->id) == false) &&
7009ce4a: 4288         	cmp	r0, r1
7009ce4c: db06         	blt	0x7009ce5c <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0xc
7009ce4e: e7ff         	b	0x7009ce50 <Sciclient_rmIrqFindRoute+0x110> @ imm = #-0x2
;                 if_idx++;
7009ce50: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009ce54: 3001         	adds	r0, #0x1
7009ce56: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             } else if (Sciclient_rmPsGetPsp() < search_depth) {
7009ce5a: e059         	b	0x7009cf10 <Sciclient_rmIrqFindRoute+0x1d0> @ imm = #0xb2
7009ce5c: f011 f948    	bl	0x700ae0f0 <Sciclient_rmPsGetPsp> @ imm = #0x11290
7009ce60: f8bd 101c    	ldrh.w	r1, [sp, #0x1c]
7009ce64: 4288         	cmp	r0, r1
7009ce66: da1e         	bge	0x7009cea6 <Sciclient_rmIrqFindRoute+0x166> @ imm = #0x3c
7009ce68: e7ff         	b	0x7009ce6a <Sciclient_rmIrqFindRoute+0x12a> @ imm = #-0x2
;                 r = Sciclient_rmPsPush(cur_n, if_idx);
7009ce6a: 9805         	ldr	r0, [sp, #0x14]
7009ce6c: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009ce70: f00d fda6    	bl	0x700aa9c0 <Sciclient_rmPsPush> @ imm = #0xdb4c
7009ce74: 9008         	str	r0, [sp, #0x20]
;                 if (r != SystemP_SUCCESS) {
7009ce76: 9808         	ldr	r0, [sp, #0x20]
7009ce78: b108         	cbz	r0, 0x7009ce7e <Sciclient_rmIrqFindRoute+0x13e> @ imm = #0x2
7009ce7a: e7ff         	b	0x7009ce7c <Sciclient_rmIrqFindRoute+0x13c> @ imm = #-0x2
;                     break;
7009ce7c: e081         	b	0x7009cf82 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x102
;                 r = Sciclient_rmIrqGetNode(cur_if->rid, &cur_n);
7009ce7e: 9803         	ldr	r0, [sp, #0xc]
7009ce80: 88c0         	ldrh	r0, [r0, #0x6]
7009ce82: a905         	add	r1, sp, #0x14
7009ce84: f007 fa24    	bl	0x700a42d0 <Sciclient_rmIrqGetNode> @ imm = #0x7448
7009ce88: 9008         	str	r0, [sp, #0x20]
;                 if (cur_n == NULL) {
7009ce8a: 9805         	ldr	r0, [sp, #0x14]
7009ce8c: b930         	cbnz	r0, 0x7009ce9c <Sciclient_rmIrqFindRoute+0x15c> @ imm = #0xc
7009ce8e: e7ff         	b	0x7009ce90 <Sciclient_rmIrqFindRoute+0x150> @ imm = #-0x2
7009ce90: 2001         	movs	r0, #0x1
;                     node_clear = true;
7009ce92: f88d 0019    	strb.w	r0, [sp, #0x19]
7009ce96: 2000         	movs	r0, #0x0
;                     r = SystemP_SUCCESS;
7009ce98: 9008         	str	r0, [sp, #0x20]
;                 } else {
7009ce9a: e003         	b	0x7009cea4 <Sciclient_rmIrqFindRoute+0x164> @ imm = #0x6
7009ce9c: 2000         	movs	r0, #0x0
;                     if_idx = 0u;
7009ce9e: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009cea2: e7ff         	b	0x7009cea4 <Sciclient_rmIrqFindRoute+0x164> @ imm = #-0x2
;             } else {
7009cea4: e033         	b	0x7009cf0e <Sciclient_rmIrqFindRoute+0x1ce> @ imm = #0x66
;                 if ((cur_if->rid == cfg->d_id) &&
7009cea6: 9803         	ldr	r0, [sp, #0xc]
7009cea8: 88c0         	ldrh	r0, [r0, #0x6]
7009ceaa: 9909         	ldr	r1, [sp, #0x24]
7009ceac: 8949         	ldrh	r1, [r1, #0xa]
7009ceae: 4288         	cmp	r0, r1
7009ceb0: d127         	bne	0x7009cf02 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x4e
7009ceb2: e7ff         	b	0x7009ceb4 <Sciclient_rmIrqFindRoute+0x174> @ imm = #-0x2
;                     (cfg->d_irq >= (cur_if->rbase)) &&
7009ceb4: 9809         	ldr	r0, [sp, #0x24]
7009ceb6: 8980         	ldrh	r0, [r0, #0xc]
7009ceb8: 9903         	ldr	r1, [sp, #0xc]
7009ceba: 8849         	ldrh	r1, [r1, #0x2]
7009cebc: 4288         	cmp	r0, r1
7009cebe: db20         	blt	0x7009cf02 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x40
7009cec0: e7ff         	b	0x7009cec2 <Sciclient_rmIrqFindRoute+0x182> @ imm = #-0x2
;                     (cfg->d_irq <
7009cec2: 9809         	ldr	r0, [sp, #0x24]
7009cec4: 8980         	ldrh	r0, [r0, #0xc]
;                      (cur_if->rbase + cur_if->len))) {
7009cec6: 9a03         	ldr	r2, [sp, #0xc]
7009cec8: 8851         	ldrh	r1, [r2, #0x2]
7009ceca: 8892         	ldrh	r2, [r2, #0x4]
7009cecc: 4411         	add	r1, r2
;                 if ((cur_if->rid == cfg->d_id) &&
7009cece: 4288         	cmp	r0, r1
7009ced0: da17         	bge	0x7009cf02 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x2e
7009ced2: e7ff         	b	0x7009ced4 <Sciclient_rmIrqFindRoute+0x194> @ imm = #-0x2
;                     r = Sciclient_rmPsPush(cur_n, if_idx);
7009ced4: 9805         	ldr	r0, [sp, #0x14]
7009ced6: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009ceda: f00d fd71    	bl	0x700aa9c0 <Sciclient_rmPsPush> @ imm = #0xdae2
7009cede: 9008         	str	r0, [sp, #0x20]
;                     if (r != SystemP_SUCCESS) {
7009cee0: 9808         	ldr	r0, [sp, #0x20]
7009cee2: b108         	cbz	r0, 0x7009cee8 <Sciclient_rmIrqFindRoute+0x1a8> @ imm = #0x2
7009cee4: e7ff         	b	0x7009cee6 <Sciclient_rmIrqFindRoute+0x1a6> @ imm = #-0x2
;                         break;
7009cee6: e04c         	b	0x7009cf82 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x98
;                     if (Sciclient_rmIrqRouteValidate(cfg) == true) {
7009cee8: 9809         	ldr	r0, [sp, #0x24]
7009ceea: f7fc fca9    	bl	0x70099840 <Sciclient_rmIrqRouteValidate> @ imm = #-0x36ae
7009ceee: b108         	cbz	r0, 0x7009cef4 <Sciclient_rmIrqFindRoute+0x1b4> @ imm = #0x2
7009cef0: e7ff         	b	0x7009cef2 <Sciclient_rmIrqFindRoute+0x1b2> @ imm = #-0x2
;                         break;
7009cef2: e046         	b	0x7009cf82 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x8c
7009cef4: a805         	add	r0, sp, #0x14
7009cef6: f10d 011a    	add.w	r1, sp, #0x1a
;                         Sciclient_rmPsPop(&cur_n, &if_idx);
7009cefa: f00b f909    	bl	0x700a8110 <Sciclient_rmPsPop> @ imm = #0xb212
7009cefe: e7ff         	b	0x7009cf00 <Sciclient_rmIrqFindRoute+0x1c0> @ imm = #-0x2
;                 }
7009cf00: e7ff         	b	0x7009cf02 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #-0x2
;                 if_idx++;
7009cf02: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009cf06: 3001         	adds	r0, #0x1
7009cf08: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009cf0c: e7ff         	b	0x7009cf0e <Sciclient_rmIrqFindRoute+0x1ce> @ imm = #-0x2
7009cf0e: e7ff         	b	0x7009cf10 <Sciclient_rmIrqFindRoute+0x1d0> @ imm = #-0x2
;         } else {
7009cf10: e003         	b	0x7009cf1a <Sciclient_rmIrqFindRoute+0x1da> @ imm = #0x6
7009cf12: 2001         	movs	r0, #0x1
;             node_clear = true;
7009cf14: f88d 0019    	strb.w	r0, [sp, #0x19]
7009cf18: e7ff         	b	0x7009cf1a <Sciclient_rmIrqFindRoute+0x1da> @ imm = #-0x2
;         if (node_clear == true) {
7009cf1a: f89d 0019    	ldrb.w	r0, [sp, #0x19]
7009cf1e: 07c0         	lsls	r0, r0, #0x1f
7009cf20: b370         	cbz	r0, 0x7009cf80 <Sciclient_rmIrqFindRoute+0x240> @ imm = #0x5c
7009cf22: e7ff         	b	0x7009cf24 <Sciclient_rmIrqFindRoute+0x1e4> @ imm = #-0x2
;             if (Sciclient_rmPsIsEmpty() == true) {
7009cf24: f010 f94c    	bl	0x700ad1c0 <Sciclient_rmPsIsEmpty> @ imm = #0x10298
7009cf28: b1c8         	cbz	r0, 0x7009cf5e <Sciclient_rmIrqFindRoute+0x21e> @ imm = #0x32
7009cf2a: e7ff         	b	0x7009cf2c <Sciclient_rmIrqFindRoute+0x1ec> @ imm = #-0x2
;                 search_depth++;
7009cf2c: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
7009cf30: 3001         	adds	r0, #0x1
7009cf32: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;                 cur_n = root_n;
7009cf36: 9804         	ldr	r0, [sp, #0x10]
7009cf38: 9005         	str	r0, [sp, #0x14]
7009cf3a: 2000         	movs	r0, #0x0
;                 if_idx = 0u;
7009cf3c: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;                 if (search_depth >= Sciclient_rmPsGetMaxPsp()) {
7009cf40: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
7009cf44: 9001         	str	r0, [sp, #0x4]
7009cf46: f011 f933    	bl	0x700ae1b0 <Sciclient_rmPsGetMaxPsp> @ imm = #0x11266
7009cf4a: 4601         	mov	r1, r0
7009cf4c: 9801         	ldr	r0, [sp, #0x4]
7009cf4e: 4288         	cmp	r0, r1
7009cf50: db04         	blt	0x7009cf5c <Sciclient_rmIrqFindRoute+0x21c> @ imm = #0x8
7009cf52: e7ff         	b	0x7009cf54 <Sciclient_rmIrqFindRoute+0x214> @ imm = #-0x2
7009cf54: f04f 30ff    	mov.w	r0, #0xffffffff
;                     r = SystemP_FAILURE;
7009cf58: 9008         	str	r0, [sp, #0x20]
;                     break;
7009cf5a: e012         	b	0x7009cf82 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x24
;             } else {
7009cf5c: e00f         	b	0x7009cf7e <Sciclient_rmIrqFindRoute+0x23e> @ imm = #0x1e
7009cf5e: a805         	add	r0, sp, #0x14
7009cf60: f10d 011a    	add.w	r1, sp, #0x1a
;                 r = Sciclient_rmPsPop(&cur_n, &if_idx);
7009cf64: f00b f8d4    	bl	0x700a8110 <Sciclient_rmPsPop> @ imm = #0xb1a8
7009cf68: 9008         	str	r0, [sp, #0x20]
;                 if (r != SystemP_SUCCESS) {
7009cf6a: 9808         	ldr	r0, [sp, #0x20]
7009cf6c: b108         	cbz	r0, 0x7009cf72 <Sciclient_rmIrqFindRoute+0x232> @ imm = #0x2
7009cf6e: e7ff         	b	0x7009cf70 <Sciclient_rmIrqFindRoute+0x230> @ imm = #-0x2
;                     break;
7009cf70: e007         	b	0x7009cf82 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0xe
;                 if_idx++;
7009cf72: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009cf76: 3001         	adds	r0, #0x1
7009cf78: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009cf7c: e7ff         	b	0x7009cf7e <Sciclient_rmIrqFindRoute+0x23e> @ imm = #-0x2
;         }
7009cf7e: e7ff         	b	0x7009cf80 <Sciclient_rmIrqFindRoute+0x240> @ imm = #-0x2
;     while (search == true) {
7009cf80: e72f         	b	0x7009cde2 <Sciclient_rmIrqFindRoute+0xa2> @ imm = #-0x1a2
;     return r;
7009cf82: 9808         	ldr	r0, [sp, #0x20]
7009cf84: b00a         	add	sp, #0x28
7009cf86: bd80         	pop	{r7, pc}
		...

7009cf90 <UART_fifoConfig>:
; {
7009cf90: b580         	push	{r7, lr}
7009cf92: b092         	sub	sp, #0x48
7009cf94: 9011         	str	r0, [sp, #0x44]
7009cf96: 9110         	str	r1, [sp, #0x40]
7009cf98: 2000         	movs	r0, #0x0
;     uint32_t fcrValue = 0U;
7009cf9a: 900c         	str	r0, [sp, #0x30]
;     uint32_t txGra = (fifoConfig & UART_FIFO_CONFIG_TXGRA) >> 26;
7009cf9c: 9810         	ldr	r0, [sp, #0x40]
7009cf9e: f3c0 6083    	ubfx	r0, r0, #0x1a, #0x4
7009cfa2: 900b         	str	r0, [sp, #0x2c]
;     uint32_t rxGra = (fifoConfig & UART_FIFO_CONFIG_RXGRA) >> 22;
7009cfa4: 9810         	ldr	r0, [sp, #0x40]
7009cfa6: f3c0 5083    	ubfx	r0, r0, #0x16, #0x4
7009cfaa: 900a         	str	r0, [sp, #0x28]
;     uint32_t txTrig = (fifoConfig & UART_FIFO_CONFIG_TXTRIG) >> 14;
7009cfac: 9810         	ldr	r0, [sp, #0x40]
7009cfae: f3c0 3087    	ubfx	r0, r0, #0xe, #0x8
7009cfb2: 9009         	str	r0, [sp, #0x24]
;     uint32_t rxTrig = (fifoConfig & UART_FIFO_CONFIG_RXTRIG) >> 6;
7009cfb4: 9810         	ldr	r0, [sp, #0x40]
7009cfb6: f3c0 1087    	ubfx	r0, r0, #0x6, #0x8
7009cfba: 9008         	str	r0, [sp, #0x20]
;     uint32_t txClr = (fifoConfig & UART_FIFO_CONFIG_TXCLR) >> 5;
7009cfbc: 9810         	ldr	r0, [sp, #0x40]
7009cfbe: f3c0 1040    	ubfx	r0, r0, #0x5, #0x1
7009cfc2: 9007         	str	r0, [sp, #0x1c]
;     uint32_t rxClr = (fifoConfig & UART_FIFO_CONFIG_RXCLR) >> 4;
7009cfc4: 9810         	ldr	r0, [sp, #0x40]
7009cfc6: f3c0 1000    	ubfx	r0, r0, #0x4, #0x1
7009cfca: 9006         	str	r0, [sp, #0x18]
;     uint32_t dmaEnPath = (fifoConfig & UART_FIFO_CONFIG_DMAENPATH) >> 3;
7009cfcc: 9810         	ldr	r0, [sp, #0x40]
7009cfce: f3c0 00c0    	ubfx	r0, r0, #0x3, #0x1
7009cfd2: 9005         	str	r0, [sp, #0x14]
;     uint32_t dmaMode   = (fifoConfig & UART_FIFO_CONFIG_DMAMODE);
7009cfd4: 9810         	ldr	r0, [sp, #0x40]
7009cfd6: f000 0007    	and	r0, r0, #0x7
7009cfda: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = UART_enhanFuncEnable(baseAddr);
7009cfdc: 9811         	ldr	r0, [sp, #0x44]
7009cfde: f00f fa7f    	bl	0x700ac4e0 <UART_enhanFuncEnable> @ imm = #0xf4fe
7009cfe2: 900f         	str	r0, [sp, #0x3c]
;     tcrTlrBitVal = UART_subConfigTCRTLRModeEn(baseAddr);
7009cfe4: 9811         	ldr	r0, [sp, #0x44]
7009cfe6: f00a fdc3    	bl	0x700a7b70 <UART_subConfigTCRTLRModeEn> @ imm = #0xab86
7009cfea: 900e         	str	r0, [sp, #0x38]
;     fcrValue |= UART_FCR_FIFO_EN_MASK;
7009cfec: 980c         	ldr	r0, [sp, #0x30]
7009cfee: f040 0001    	orr	r0, r0, #0x1
7009cff2: 900c         	str	r0, [sp, #0x30]
;     if(UART_TRIG_LVL_GRANULARITY_1 != rxGra)
7009cff4: 980a         	ldr	r0, [sp, #0x28]
7009cff6: 2801         	cmp	r0, #0x1
7009cff8: d033         	beq	0x7009d062 <UART_fifoConfig+0xd2> @ imm = #0x66
7009cffa: e7ff         	b	0x7009cffc <UART_fifoConfig+0x6c> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_RX_TRIG_GRANU1,
7009cffc: 9811         	ldr	r0, [sp, #0x44]
7009cffe: 3040         	adds	r0, #0x40
7009d000: 2180         	movs	r1, #0x80
7009d002: 2207         	movs	r2, #0x7
7009d004: 2300         	movs	r3, #0x0
7009d006: 9303         	str	r3, [sp, #0xc]
7009d008: f00f fd62    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0xfac4
7009d00c: 9b03         	ldr	r3, [sp, #0xc]
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA,
7009d00e: 9811         	ldr	r0, [sp, #0x44]
7009d010: 301c         	adds	r0, #0x1c
7009d012: 21f0         	movs	r1, #0xf0
7009d014: 2204         	movs	r2, #0x4
7009d016: f00f fd5b    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0xfab6
;         fcrValue &= ~((uint32_t) UART_FCR_RX_FIFO_TRIG_MASK);
7009d01a: 980c         	ldr	r0, [sp, #0x30]
7009d01c: f020 00c0    	bic	r0, r0, #0xc0
7009d020: 900c         	str	r0, [sp, #0x30]
;         if((UART_RXTRIGLVL_8 == rxTrig) ||
7009d022: 9808         	ldr	r0, [sp, #0x20]
7009d024: 2808         	cmp	r0, #0x8
7009d026: d00c         	beq	0x7009d042 <UART_fifoConfig+0xb2> @ imm = #0x18
7009d028: e7ff         	b	0x7009d02a <UART_fifoConfig+0x9a> @ imm = #-0x2
;            (UART_RXTRIGLVL_16 == rxTrig) ||
7009d02a: 9808         	ldr	r0, [sp, #0x20]
7009d02c: 2810         	cmp	r0, #0x10
7009d02e: d008         	beq	0x7009d042 <UART_fifoConfig+0xb2> @ imm = #0x10
7009d030: e7ff         	b	0x7009d032 <UART_fifoConfig+0xa2> @ imm = #-0x2
;            (UART_RXTRIGLVL_56 == rxTrig) ||
7009d032: 9808         	ldr	r0, [sp, #0x20]
7009d034: 2838         	cmp	r0, #0x38
7009d036: d004         	beq	0x7009d042 <UART_fifoConfig+0xb2> @ imm = #0x8
7009d038: e7ff         	b	0x7009d03a <UART_fifoConfig+0xaa> @ imm = #-0x2
;            (UART_RXTRIGLVL_60 == rxTrig))
7009d03a: 9808         	ldr	r0, [sp, #0x20]
;         if((UART_RXTRIGLVL_8 == rxTrig) ||
7009d03c: 283c         	cmp	r0, #0x3c
7009d03e: d107         	bne	0x7009d050 <UART_fifoConfig+0xc0> @ imm = #0xe
7009d040: e7ff         	b	0x7009d042 <UART_fifoConfig+0xb2> @ imm = #-0x2
;             fcrValue |= rxTrig & UART_FCR_RX_FIFO_TRIG_MASK;
7009d042: 9808         	ldr	r0, [sp, #0x20]
7009d044: f000 01c0    	and	r1, r0, #0xc0
7009d048: 980c         	ldr	r0, [sp, #0x30]
7009d04a: 4308         	orrs	r0, r1
7009d04c: 900c         	str	r0, [sp, #0x30]
;         }
7009d04e: e007         	b	0x7009d060 <UART_fifoConfig+0xd0> @ imm = #0xe
;             HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA,
7009d050: 9811         	ldr	r0, [sp, #0x44]
7009d052: 301c         	adds	r0, #0x1c
7009d054: 9b08         	ldr	r3, [sp, #0x20]
7009d056: 21f0         	movs	r1, #0xf0
7009d058: 2204         	movs	r2, #0x4
7009d05a: f00f fd39    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0xfa72
7009d05e: e7ff         	b	0x7009d060 <UART_fifoConfig+0xd0> @ imm = #-0x2
;     }
7009d060: e01d         	b	0x7009d09e <UART_fifoConfig+0x10e> @ imm = #0x3a
;         rxTrig &= 0x003FU;
7009d062: 9808         	ldr	r0, [sp, #0x20]
7009d064: f000 003f    	and	r0, r0, #0x3f
7009d068: 9008         	str	r0, [sp, #0x20]
;         tlrValue = (rxTrig & 0x003CU) >> 2;
7009d06a: 9808         	ldr	r0, [sp, #0x20]
7009d06c: f3c0 0083    	ubfx	r0, r0, #0x2, #0x4
7009d070: 900d         	str	r0, [sp, #0x34]
;         fcrValue |= (rxTrig & 0x0003U) << UART_FCR_RX_FIFO_TRIG_SHIFT;
7009d072: 9808         	ldr	r0, [sp, #0x20]
7009d074: f000 0103    	and	r1, r0, #0x3
7009d078: 980c         	ldr	r0, [sp, #0x30]
7009d07a: ea40 1081    	orr.w	r0, r0, r1, lsl #6
7009d07e: 900c         	str	r0, [sp, #0x30]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_RX_TRIG_GRANU1,
7009d080: 9811         	ldr	r0, [sp, #0x44]
7009d082: 3040         	adds	r0, #0x40
7009d084: 2180         	movs	r1, #0x80
7009d086: 2207         	movs	r2, #0x7
7009d088: 2301         	movs	r3, #0x1
7009d08a: f00f fd21    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0xfa42
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA, tlrValue);
7009d08e: 9811         	ldr	r0, [sp, #0x44]
7009d090: 301c         	adds	r0, #0x1c
7009d092: 9b0d         	ldr	r3, [sp, #0x34]
7009d094: 21f0         	movs	r1, #0xf0
7009d096: 2204         	movs	r2, #0x4
7009d098: f00f fd1a    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0xfa34
7009d09c: e7ff         	b	0x7009d09e <UART_fifoConfig+0x10e> @ imm = #-0x2
;     if(UART_TRIG_LVL_GRANULARITY_1 != txGra)
7009d09e: 980b         	ldr	r0, [sp, #0x2c]
7009d0a0: 2801         	cmp	r0, #0x1
7009d0a2: d033         	beq	0x7009d10c <UART_fifoConfig+0x17c> @ imm = #0x66
7009d0a4: e7ff         	b	0x7009d0a6 <UART_fifoConfig+0x116> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_TX_TRIG_GRANU1,
7009d0a6: 9811         	ldr	r0, [sp, #0x44]
7009d0a8: 3040         	adds	r0, #0x40
7009d0aa: 2140         	movs	r1, #0x40
7009d0ac: 2206         	movs	r2, #0x6
7009d0ae: 2300         	movs	r3, #0x0
7009d0b0: 9302         	str	r3, [sp, #0x8]
7009d0b2: f00f fd0d    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0xfa1a
7009d0b6: 9b02         	ldr	r3, [sp, #0x8]
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA,
7009d0b8: 9811         	ldr	r0, [sp, #0x44]
7009d0ba: 301c         	adds	r0, #0x1c
7009d0bc: 210f         	movs	r1, #0xf
7009d0be: 461a         	mov	r2, r3
7009d0c0: f00f fd06    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0xfa0c
;         fcrValue &= ~((uint32_t) UART_FCR_TX_FIFO_TRIG_MASK);
7009d0c4: 980c         	ldr	r0, [sp, #0x30]
7009d0c6: f020 0030    	bic	r0, r0, #0x30
7009d0ca: 900c         	str	r0, [sp, #0x30]
;         if((UART_TXTRIGLVL_8 == (txTrig)) ||
7009d0cc: 9809         	ldr	r0, [sp, #0x24]
7009d0ce: 2808         	cmp	r0, #0x8
7009d0d0: d00c         	beq	0x7009d0ec <UART_fifoConfig+0x15c> @ imm = #0x18
7009d0d2: e7ff         	b	0x7009d0d4 <UART_fifoConfig+0x144> @ imm = #-0x2
;            (UART_TXTRIGLVL_16 == (txTrig)) ||
7009d0d4: 9809         	ldr	r0, [sp, #0x24]
7009d0d6: 2810         	cmp	r0, #0x10
7009d0d8: d008         	beq	0x7009d0ec <UART_fifoConfig+0x15c> @ imm = #0x10
7009d0da: e7ff         	b	0x7009d0dc <UART_fifoConfig+0x14c> @ imm = #-0x2
;            (UART_TXTRIGLVL_32 == (txTrig)) ||
7009d0dc: 9809         	ldr	r0, [sp, #0x24]
7009d0de: 2820         	cmp	r0, #0x20
7009d0e0: d004         	beq	0x7009d0ec <UART_fifoConfig+0x15c> @ imm = #0x8
7009d0e2: e7ff         	b	0x7009d0e4 <UART_fifoConfig+0x154> @ imm = #-0x2
;            (UART_TXTRIGLVL_56 == (txTrig)))
7009d0e4: 9809         	ldr	r0, [sp, #0x24]
;         if((UART_TXTRIGLVL_8 == (txTrig)) ||
7009d0e6: 2838         	cmp	r0, #0x38
7009d0e8: d107         	bne	0x7009d0fa <UART_fifoConfig+0x16a> @ imm = #0xe
7009d0ea: e7ff         	b	0x7009d0ec <UART_fifoConfig+0x15c> @ imm = #-0x2
;             fcrValue |= txTrig & UART_FCR_TX_FIFO_TRIG_MASK;
7009d0ec: 9809         	ldr	r0, [sp, #0x24]
7009d0ee: f000 0130    	and	r1, r0, #0x30
7009d0f2: 980c         	ldr	r0, [sp, #0x30]
7009d0f4: 4308         	orrs	r0, r1
7009d0f6: 900c         	str	r0, [sp, #0x30]
;         }
7009d0f8: e007         	b	0x7009d10a <UART_fifoConfig+0x17a> @ imm = #0xe
;             HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA,
7009d0fa: 9811         	ldr	r0, [sp, #0x44]
7009d0fc: 301c         	adds	r0, #0x1c
7009d0fe: 9b09         	ldr	r3, [sp, #0x24]
7009d100: 210f         	movs	r1, #0xf
7009d102: 2200         	movs	r2, #0x0
7009d104: f00f fce4    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0xf9c8
7009d108: e7ff         	b	0x7009d10a <UART_fifoConfig+0x17a> @ imm = #-0x2
;     }
7009d10a: e01d         	b	0x7009d148 <UART_fifoConfig+0x1b8> @ imm = #0x3a
;         txTrig &= 0x003FU;
7009d10c: 9809         	ldr	r0, [sp, #0x24]
7009d10e: f000 003f    	and	r0, r0, #0x3f
7009d112: 9009         	str	r0, [sp, #0x24]
;         tlrValue = (txTrig & 0x003CU) >> 2;
7009d114: 9809         	ldr	r0, [sp, #0x24]
7009d116: f3c0 0083    	ubfx	r0, r0, #0x2, #0x4
7009d11a: 900d         	str	r0, [sp, #0x34]
;         fcrValue |= (txTrig & 0x0003U) << UART_FCR_TX_FIFO_TRIG_SHIFT;
7009d11c: 9809         	ldr	r0, [sp, #0x24]
7009d11e: f000 0103    	and	r1, r0, #0x3
7009d122: 980c         	ldr	r0, [sp, #0x30]
7009d124: ea40 1001    	orr.w	r0, r0, r1, lsl #4
7009d128: 900c         	str	r0, [sp, #0x30]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_TX_TRIG_GRANU1,
7009d12a: 9811         	ldr	r0, [sp, #0x44]
7009d12c: 3040         	adds	r0, #0x40
7009d12e: 2140         	movs	r1, #0x40
7009d130: 2206         	movs	r2, #0x6
7009d132: 2301         	movs	r3, #0x1
7009d134: f00f fccc    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0xf998
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA, tlrValue);
7009d138: 9811         	ldr	r0, [sp, #0x44]
7009d13a: 301c         	adds	r0, #0x1c
7009d13c: 9b0d         	ldr	r3, [sp, #0x34]
7009d13e: 210f         	movs	r1, #0xf
7009d140: 2200         	movs	r2, #0x0
7009d142: f00f fcc5    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0xf98a
7009d146: e7ff         	b	0x7009d148 <UART_fifoConfig+0x1b8> @ imm = #-0x2
;     if(UART_DMA_EN_PATH_FCR == dmaEnPath)
7009d148: 9805         	ldr	r0, [sp, #0x14]
7009d14a: b9a8         	cbnz	r0, 0x7009d178 <UART_fifoConfig+0x1e8> @ imm = #0x2a
7009d14c: e7ff         	b	0x7009d14e <UART_fifoConfig+0x1be> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_CTL,
7009d14e: 9811         	ldr	r0, [sp, #0x44]
7009d150: 3040         	adds	r0, #0x40
7009d152: 2101         	movs	r1, #0x1
7009d154: 2300         	movs	r3, #0x0
7009d156: 461a         	mov	r2, r3
7009d158: f00f fcba    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0xf974
;         dmaMode &= 0x1U;
7009d15c: 9804         	ldr	r0, [sp, #0x10]
7009d15e: f000 0001    	and	r0, r0, #0x1
7009d162: 9004         	str	r0, [sp, #0x10]
;         fcrValue &= ~((uint32_t) UART_FCR_DMA_MODE_MASK);
7009d164: 980c         	ldr	r0, [sp, #0x30]
7009d166: f020 0008    	bic	r0, r0, #0x8
7009d16a: 900c         	str	r0, [sp, #0x30]
;         fcrValue |= dmaMode << UART_FCR_DMA_MODE_SHIFT;
7009d16c: 9904         	ldr	r1, [sp, #0x10]
7009d16e: 980c         	ldr	r0, [sp, #0x30]
7009d170: ea40 00c1    	orr.w	r0, r0, r1, lsl #3
7009d174: 900c         	str	r0, [sp, #0x30]
;     }
7009d176: e013         	b	0x7009d1a0 <UART_fifoConfig+0x210> @ imm = #0x26
;         dmaMode &= 0x3U;
7009d178: 9804         	ldr	r0, [sp, #0x10]
7009d17a: f000 0003    	and	r0, r0, #0x3
7009d17e: 9004         	str	r0, [sp, #0x10]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_CTL,
7009d180: 9811         	ldr	r0, [sp, #0x44]
7009d182: 3040         	adds	r0, #0x40
7009d184: 2200         	movs	r2, #0x0
7009d186: 2301         	movs	r3, #0x1
7009d188: 9301         	str	r3, [sp, #0x4]
7009d18a: 4619         	mov	r1, r3
7009d18c: f00f fca0    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0xf940
7009d190: 9a01         	ldr	r2, [sp, #0x4]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_2, dmaMode);
7009d192: 9811         	ldr	r0, [sp, #0x44]
7009d194: 3040         	adds	r0, #0x40
7009d196: 9b04         	ldr	r3, [sp, #0x10]
7009d198: 2106         	movs	r1, #0x6
7009d19a: f00f fc99    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0xf932
7009d19e: e7ff         	b	0x7009d1a0 <UART_fifoConfig+0x210> @ imm = #-0x2
;     fcrValue |= rxClr << UART_FCR_RX_FIFO_CLEAR_SHIFT;
7009d1a0: 9906         	ldr	r1, [sp, #0x18]
7009d1a2: 980c         	ldr	r0, [sp, #0x30]
7009d1a4: ea40 0041    	orr.w	r0, r0, r1, lsl #1
7009d1a8: 900c         	str	r0, [sp, #0x30]
;     fcrValue |= txClr << UART_FCR_TX_FIFO_CLEAR_SHIFT;
7009d1aa: 9907         	ldr	r1, [sp, #0x1c]
7009d1ac: 980c         	ldr	r0, [sp, #0x30]
7009d1ae: ea40 0081    	orr.w	r0, r0, r1, lsl #2
7009d1b2: 900c         	str	r0, [sp, #0x30]
;     UART_fifoRegisterWrite(baseAddr, fcrValue);
7009d1b4: 9811         	ldr	r0, [sp, #0x44]
7009d1b6: 990c         	ldr	r1, [sp, #0x30]
7009d1b8: f00c feea    	bl	0x700a9f90 <UART_fifoRegisterWrite> @ imm = #0xcdd4
;     UART_tcrTlrBitValRestore(baseAddr, tcrTlrBitVal);
7009d1bc: 9811         	ldr	r0, [sp, #0x44]
7009d1be: 990e         	ldr	r1, [sp, #0x38]
7009d1c0: f00b fbee    	bl	0x700a89a0 <UART_tcrTlrBitValRestore> @ imm = #0xb7dc
;     UART_enhanFuncBitValRestore(baseAddr, enhanFnBitVal);
7009d1c4: 9811         	ldr	r0, [sp, #0x44]
7009d1c6: 990f         	ldr	r1, [sp, #0x3c]
7009d1c8: f00f fca2    	bl	0x700acb10 <UART_enhanFuncBitValRestore> @ imm = #0xf944
;     return fcrValue;
7009d1cc: 980c         	ldr	r0, [sp, #0x30]
7009d1ce: b012         	add	sp, #0x48
7009d1d0: bd80         	pop	{r7, pc}
		...
7009d1de: 0000         	movs	r0, r0

7009d1e0 <_ntoa_format>:
; {
7009d1e0: b570         	push	{r4, r5, r6, lr}
7009d1e2: b08c         	sub	sp, #0x30
7009d1e4: 4684         	mov	r12, r0
7009d1e6: 9816         	ldr	r0, [sp, #0x58]
7009d1e8: 9815         	ldr	r0, [sp, #0x54]
7009d1ea: 9814         	ldr	r0, [sp, #0x50]
7009d1ec: 9813         	ldr	r0, [sp, #0x4c]
7009d1ee: 9812         	ldr	r0, [sp, #0x48]
7009d1f0: f8dd e044    	ldr.w	lr, [sp, #0x44]
7009d1f4: f8dd e040    	ldr.w	lr, [sp, #0x40]
7009d1f8: f8cd c02c    	str.w	r12, [sp, #0x2c]
7009d1fc: 910a         	str	r1, [sp, #0x28]
7009d1fe: 9209         	str	r2, [sp, #0x24]
7009d200: 9308         	str	r3, [sp, #0x20]
7009d202: f88d 001f    	strb.w	r0, [sp, #0x1f]
;   if (!(flags & FLAGS_LEFT)) {
7009d206: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d20a: 0780         	lsls	r0, r0, #0x1e
7009d20c: 2800         	cmp	r0, #0x0
7009d20e: d454         	bmi	0x7009d2ba <_ntoa_format+0xda> @ imm = #0xa8
7009d210: e7ff         	b	0x7009d212 <_ntoa_format+0x32> @ imm = #-0x2
;     if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
7009d212: 9815         	ldr	r0, [sp, #0x54]
7009d214: b1a0         	cbz	r0, 0x7009d240 <_ntoa_format+0x60> @ imm = #0x28
7009d216: e7ff         	b	0x7009d218 <_ntoa_format+0x38> @ imm = #-0x2
7009d218: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d21c: 07c0         	lsls	r0, r0, #0x1f
7009d21e: b178         	cbz	r0, 0x7009d240 <_ntoa_format+0x60> @ imm = #0x1e
7009d220: e7ff         	b	0x7009d222 <_ntoa_format+0x42> @ imm = #-0x2
7009d222: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009d226: 07c0         	lsls	r0, r0, #0x1f
7009d228: b930         	cbnz	r0, 0x7009d238 <_ntoa_format+0x58> @ imm = #0xc
7009d22a: e7ff         	b	0x7009d22c <_ntoa_format+0x4c> @ imm = #-0x2
7009d22c: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d230: f010 0f0c    	tst.w	r0, #0xc
7009d234: d004         	beq	0x7009d240 <_ntoa_format+0x60> @ imm = #0x8
7009d236: e7ff         	b	0x7009d238 <_ntoa_format+0x58> @ imm = #-0x2
;       width--;
7009d238: 9815         	ldr	r0, [sp, #0x54]
7009d23a: 3801         	subs	r0, #0x1
7009d23c: 9015         	str	r0, [sp, #0x54]
;     }
7009d23e: e7ff         	b	0x7009d240 <_ntoa_format+0x60> @ imm = #-0x2
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d240: e7ff         	b	0x7009d242 <_ntoa_format+0x62> @ imm = #-0x2
7009d242: 9911         	ldr	r1, [sp, #0x44]
7009d244: 9a14         	ldr	r2, [sp, #0x50]
7009d246: 2000         	movs	r0, #0x0
7009d248: 4291         	cmp	r1, r2
7009d24a: 9006         	str	r0, [sp, #0x18]
7009d24c: d207         	bhs	0x7009d25e <_ntoa_format+0x7e> @ imm = #0xe
7009d24e: e7ff         	b	0x7009d250 <_ntoa_format+0x70> @ imm = #-0x2
7009d250: 9911         	ldr	r1, [sp, #0x44]
7009d252: 2000         	movs	r0, #0x0
7009d254: 2920         	cmp	r1, #0x20
7009d256: bf38         	it	lo
7009d258: 2001         	movlo	r0, #0x1
7009d25a: 9006         	str	r0, [sp, #0x18]
7009d25c: e7ff         	b	0x7009d25e <_ntoa_format+0x7e> @ imm = #-0x2
7009d25e: 9806         	ldr	r0, [sp, #0x18]
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d260: 07c0         	lsls	r0, r0, #0x1f
7009d262: b138         	cbz	r0, 0x7009d274 <_ntoa_format+0x94> @ imm = #0xe
7009d264: e7ff         	b	0x7009d266 <_ntoa_format+0x86> @ imm = #-0x2
;       buf[len++] = '0';
7009d266: 9910         	ldr	r1, [sp, #0x40]
7009d268: 9a11         	ldr	r2, [sp, #0x44]
7009d26a: 1c50         	adds	r0, r2, #0x1
7009d26c: 9011         	str	r0, [sp, #0x44]
7009d26e: 2030         	movs	r0, #0x30
7009d270: 5488         	strb	r0, [r1, r2]
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d272: e7e6         	b	0x7009d242 <_ntoa_format+0x62> @ imm = #-0x34
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d274: e7ff         	b	0x7009d276 <_ntoa_format+0x96> @ imm = #-0x2
7009d276: 2000         	movs	r0, #0x0
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d278: f89d 1058    	ldrb.w	r1, [sp, #0x58]
7009d27c: ea4f 71c1    	lsl.w	r1, r1, #0x1f
7009d280: 9005         	str	r0, [sp, #0x14]
7009d282: b171         	cbz	r1, 0x7009d2a2 <_ntoa_format+0xc2> @ imm = #0x1c
7009d284: e7ff         	b	0x7009d286 <_ntoa_format+0xa6> @ imm = #-0x2
7009d286: 9911         	ldr	r1, [sp, #0x44]
7009d288: 9a15         	ldr	r2, [sp, #0x54]
7009d28a: 2000         	movs	r0, #0x0
7009d28c: 4291         	cmp	r1, r2
7009d28e: 9005         	str	r0, [sp, #0x14]
7009d290: d207         	bhs	0x7009d2a2 <_ntoa_format+0xc2> @ imm = #0xe
7009d292: e7ff         	b	0x7009d294 <_ntoa_format+0xb4> @ imm = #-0x2
7009d294: 9911         	ldr	r1, [sp, #0x44]
7009d296: 2000         	movs	r0, #0x0
7009d298: 2920         	cmp	r1, #0x20
7009d29a: bf38         	it	lo
7009d29c: 2001         	movlo	r0, #0x1
7009d29e: 9005         	str	r0, [sp, #0x14]
7009d2a0: e7ff         	b	0x7009d2a2 <_ntoa_format+0xc2> @ imm = #-0x2
7009d2a2: 9805         	ldr	r0, [sp, #0x14]
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d2a4: 07c0         	lsls	r0, r0, #0x1f
7009d2a6: b138         	cbz	r0, 0x7009d2b8 <_ntoa_format+0xd8> @ imm = #0xe
7009d2a8: e7ff         	b	0x7009d2aa <_ntoa_format+0xca> @ imm = #-0x2
;       buf[len++] = '0';
7009d2aa: 9910         	ldr	r1, [sp, #0x40]
7009d2ac: 9a11         	ldr	r2, [sp, #0x44]
7009d2ae: 1c50         	adds	r0, r2, #0x1
7009d2b0: 9011         	str	r0, [sp, #0x44]
7009d2b2: 2030         	movs	r0, #0x30
7009d2b4: 5488         	strb	r0, [r1, r2]
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d2b6: e7de         	b	0x7009d276 <_ntoa_format+0x96> @ imm = #-0x44
;   }
7009d2b8: e7ff         	b	0x7009d2ba <_ntoa_format+0xda> @ imm = #-0x2
;   if (flags & FLAGS_HASH) {
7009d2ba: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d2be: 06c0         	lsls	r0, r0, #0x1b
7009d2c0: 2800         	cmp	r0, #0x0
7009d2c2: d569         	bpl	0x7009d398 <_ntoa_format+0x1b8> @ imm = #0xd2
7009d2c4: e7ff         	b	0x7009d2c6 <_ntoa_format+0xe6> @ imm = #-0x2
;     if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
7009d2c6: f89d 0059    	ldrb.w	r0, [sp, #0x59]
7009d2ca: 0740         	lsls	r0, r0, #0x1d
7009d2cc: 2800         	cmp	r0, #0x0
7009d2ce: d41c         	bmi	0x7009d30a <_ntoa_format+0x12a> @ imm = #0x38
7009d2d0: e7ff         	b	0x7009d2d2 <_ntoa_format+0xf2> @ imm = #-0x2
7009d2d2: 9811         	ldr	r0, [sp, #0x44]
7009d2d4: b1c8         	cbz	r0, 0x7009d30a <_ntoa_format+0x12a> @ imm = #0x32
7009d2d6: e7ff         	b	0x7009d2d8 <_ntoa_format+0xf8> @ imm = #-0x2
7009d2d8: 9811         	ldr	r0, [sp, #0x44]
7009d2da: 9914         	ldr	r1, [sp, #0x50]
7009d2dc: 4288         	cmp	r0, r1
7009d2de: d005         	beq	0x7009d2ec <_ntoa_format+0x10c> @ imm = #0xa
7009d2e0: e7ff         	b	0x7009d2e2 <_ntoa_format+0x102> @ imm = #-0x2
7009d2e2: 9811         	ldr	r0, [sp, #0x44]
7009d2e4: 9915         	ldr	r1, [sp, #0x54]
7009d2e6: 4288         	cmp	r0, r1
7009d2e8: d10f         	bne	0x7009d30a <_ntoa_format+0x12a> @ imm = #0x1e
7009d2ea: e7ff         	b	0x7009d2ec <_ntoa_format+0x10c> @ imm = #-0x2
;       len--;
7009d2ec: 9811         	ldr	r0, [sp, #0x44]
7009d2ee: 3801         	subs	r0, #0x1
7009d2f0: 9011         	str	r0, [sp, #0x44]
;       if (len && (base == 16U)) {
7009d2f2: 9811         	ldr	r0, [sp, #0x44]
7009d2f4: b140         	cbz	r0, 0x7009d308 <_ntoa_format+0x128> @ imm = #0x10
7009d2f6: e7ff         	b	0x7009d2f8 <_ntoa_format+0x118> @ imm = #-0x2
7009d2f8: 9813         	ldr	r0, [sp, #0x4c]
7009d2fa: 2810         	cmp	r0, #0x10
7009d2fc: d104         	bne	0x7009d308 <_ntoa_format+0x128> @ imm = #0x8
7009d2fe: e7ff         	b	0x7009d300 <_ntoa_format+0x120> @ imm = #-0x2
;         len--;
7009d300: 9811         	ldr	r0, [sp, #0x44]
7009d302: 3801         	subs	r0, #0x1
7009d304: 9011         	str	r0, [sp, #0x44]
;       }
7009d306: e7ff         	b	0x7009d308 <_ntoa_format+0x128> @ imm = #-0x2
;     }
7009d308: e7ff         	b	0x7009d30a <_ntoa_format+0x12a> @ imm = #-0x2
;     if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d30a: 9813         	ldr	r0, [sp, #0x4c]
7009d30c: 2810         	cmp	r0, #0x10
7009d30e: d111         	bne	0x7009d334 <_ntoa_format+0x154> @ imm = #0x22
7009d310: e7ff         	b	0x7009d312 <_ntoa_format+0x132> @ imm = #-0x2
7009d312: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d316: 0680         	lsls	r0, r0, #0x1a
7009d318: 2800         	cmp	r0, #0x0
7009d31a: d40b         	bmi	0x7009d334 <_ntoa_format+0x154> @ imm = #0x16
7009d31c: e7ff         	b	0x7009d31e <_ntoa_format+0x13e> @ imm = #-0x2
7009d31e: 9811         	ldr	r0, [sp, #0x44]
7009d320: 281f         	cmp	r0, #0x1f
7009d322: d807         	bhi	0x7009d334 <_ntoa_format+0x154> @ imm = #0xe
7009d324: e7ff         	b	0x7009d326 <_ntoa_format+0x146> @ imm = #-0x2
;       buf[len++] = 'x';
7009d326: 9910         	ldr	r1, [sp, #0x40]
7009d328: 9a11         	ldr	r2, [sp, #0x44]
7009d32a: 1c50         	adds	r0, r2, #0x1
7009d32c: 9011         	str	r0, [sp, #0x44]
7009d32e: 2078         	movs	r0, #0x78
7009d330: 5488         	strb	r0, [r1, r2]
;     }
7009d332: e025         	b	0x7009d380 <_ntoa_format+0x1a0> @ imm = #0x4a
;     else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d334: 9813         	ldr	r0, [sp, #0x4c]
7009d336: 2810         	cmp	r0, #0x10
7009d338: d111         	bne	0x7009d35e <_ntoa_format+0x17e> @ imm = #0x22
7009d33a: e7ff         	b	0x7009d33c <_ntoa_format+0x15c> @ imm = #-0x2
7009d33c: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d340: 0680         	lsls	r0, r0, #0x1a
7009d342: 2800         	cmp	r0, #0x0
7009d344: d50b         	bpl	0x7009d35e <_ntoa_format+0x17e> @ imm = #0x16
7009d346: e7ff         	b	0x7009d348 <_ntoa_format+0x168> @ imm = #-0x2
7009d348: 9811         	ldr	r0, [sp, #0x44]
7009d34a: 281f         	cmp	r0, #0x1f
7009d34c: d807         	bhi	0x7009d35e <_ntoa_format+0x17e> @ imm = #0xe
7009d34e: e7ff         	b	0x7009d350 <_ntoa_format+0x170> @ imm = #-0x2
;       buf[len++] = 'X';
7009d350: 9910         	ldr	r1, [sp, #0x40]
7009d352: 9a11         	ldr	r2, [sp, #0x44]
7009d354: 1c50         	adds	r0, r2, #0x1
7009d356: 9011         	str	r0, [sp, #0x44]
7009d358: 2058         	movs	r0, #0x58
7009d35a: 5488         	strb	r0, [r1, r2]
;     }
7009d35c: e00f         	b	0x7009d37e <_ntoa_format+0x19e> @ imm = #0x1e
;     else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d35e: 9813         	ldr	r0, [sp, #0x4c]
7009d360: 2802         	cmp	r0, #0x2
7009d362: d10b         	bne	0x7009d37c <_ntoa_format+0x19c> @ imm = #0x16
7009d364: e7ff         	b	0x7009d366 <_ntoa_format+0x186> @ imm = #-0x2
7009d366: 9811         	ldr	r0, [sp, #0x44]
7009d368: 281f         	cmp	r0, #0x1f
7009d36a: d807         	bhi	0x7009d37c <_ntoa_format+0x19c> @ imm = #0xe
7009d36c: e7ff         	b	0x7009d36e <_ntoa_format+0x18e> @ imm = #-0x2
;       buf[len++] = 'b';
7009d36e: 9910         	ldr	r1, [sp, #0x40]
7009d370: 9a11         	ldr	r2, [sp, #0x44]
7009d372: 1c50         	adds	r0, r2, #0x1
7009d374: 9011         	str	r0, [sp, #0x44]
7009d376: 2062         	movs	r0, #0x62
7009d378: 5488         	strb	r0, [r1, r2]
;     }
7009d37a: e7ff         	b	0x7009d37c <_ntoa_format+0x19c> @ imm = #-0x2
7009d37c: e7ff         	b	0x7009d37e <_ntoa_format+0x19e> @ imm = #-0x2
7009d37e: e7ff         	b	0x7009d380 <_ntoa_format+0x1a0> @ imm = #-0x2
;     if (len < PRINTF_NTOA_BUFFER_SIZE) {
7009d380: 9811         	ldr	r0, [sp, #0x44]
7009d382: 281f         	cmp	r0, #0x1f
7009d384: d807         	bhi	0x7009d396 <_ntoa_format+0x1b6> @ imm = #0xe
7009d386: e7ff         	b	0x7009d388 <_ntoa_format+0x1a8> @ imm = #-0x2
;       buf[len++] = '0';
7009d388: 9910         	ldr	r1, [sp, #0x40]
7009d38a: 9a11         	ldr	r2, [sp, #0x44]
7009d38c: 1c50         	adds	r0, r2, #0x1
7009d38e: 9011         	str	r0, [sp, #0x44]
7009d390: 2030         	movs	r0, #0x30
7009d392: 5488         	strb	r0, [r1, r2]
;     }
7009d394: e7ff         	b	0x7009d396 <_ntoa_format+0x1b6> @ imm = #-0x2
;   }
7009d396: e7ff         	b	0x7009d398 <_ntoa_format+0x1b8> @ imm = #-0x2
;   if (len < PRINTF_NTOA_BUFFER_SIZE) {
7009d398: 9811         	ldr	r0, [sp, #0x44]
7009d39a: 281f         	cmp	r0, #0x1f
7009d39c: d829         	bhi	0x7009d3f2 <_ntoa_format+0x212> @ imm = #0x52
7009d39e: e7ff         	b	0x7009d3a0 <_ntoa_format+0x1c0> @ imm = #-0x2
;     if (negative) {
7009d3a0: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009d3a4: 07c0         	lsls	r0, r0, #0x1f
7009d3a6: b138         	cbz	r0, 0x7009d3b8 <_ntoa_format+0x1d8> @ imm = #0xe
7009d3a8: e7ff         	b	0x7009d3aa <_ntoa_format+0x1ca> @ imm = #-0x2
;       buf[len++] = '-';
7009d3aa: 9910         	ldr	r1, [sp, #0x40]
7009d3ac: 9a11         	ldr	r2, [sp, #0x44]
7009d3ae: 1c50         	adds	r0, r2, #0x1
7009d3b0: 9011         	str	r0, [sp, #0x44]
7009d3b2: 202d         	movs	r0, #0x2d
7009d3b4: 5488         	strb	r0, [r1, r2]
;     }
7009d3b6: e01b         	b	0x7009d3f0 <_ntoa_format+0x210> @ imm = #0x36
;     else if (flags & FLAGS_PLUS) {
7009d3b8: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d3bc: 0740         	lsls	r0, r0, #0x1d
7009d3be: 2800         	cmp	r0, #0x0
7009d3c0: d507         	bpl	0x7009d3d2 <_ntoa_format+0x1f2> @ imm = #0xe
7009d3c2: e7ff         	b	0x7009d3c4 <_ntoa_format+0x1e4> @ imm = #-0x2
;       buf[len++] = '+';  // ignore the space if the '+' exists
7009d3c4: 9910         	ldr	r1, [sp, #0x40]
7009d3c6: 9a11         	ldr	r2, [sp, #0x44]
7009d3c8: 1c50         	adds	r0, r2, #0x1
7009d3ca: 9011         	str	r0, [sp, #0x44]
7009d3cc: 202b         	movs	r0, #0x2b
7009d3ce: 5488         	strb	r0, [r1, r2]
;     }
7009d3d0: e00d         	b	0x7009d3ee <_ntoa_format+0x20e> @ imm = #0x1a
;     else if (flags & FLAGS_SPACE) {
7009d3d2: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d3d6: 0700         	lsls	r0, r0, #0x1c
7009d3d8: 2800         	cmp	r0, #0x0
7009d3da: d507         	bpl	0x7009d3ec <_ntoa_format+0x20c> @ imm = #0xe
7009d3dc: e7ff         	b	0x7009d3de <_ntoa_format+0x1fe> @ imm = #-0x2
;       buf[len++] = ' ';
7009d3de: 9910         	ldr	r1, [sp, #0x40]
7009d3e0: 9a11         	ldr	r2, [sp, #0x44]
7009d3e2: 1c50         	adds	r0, r2, #0x1
7009d3e4: 9011         	str	r0, [sp, #0x44]
7009d3e6: 2020         	movs	r0, #0x20
7009d3e8: 5488         	strb	r0, [r1, r2]
;     }
7009d3ea: e7ff         	b	0x7009d3ec <_ntoa_format+0x20c> @ imm = #-0x2
7009d3ec: e7ff         	b	0x7009d3ee <_ntoa_format+0x20e> @ imm = #-0x2
7009d3ee: e7ff         	b	0x7009d3f0 <_ntoa_format+0x210> @ imm = #-0x2
;   }
7009d3f0: e7ff         	b	0x7009d3f2 <_ntoa_format+0x212> @ imm = #-0x2
;   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
7009d3f2: 980b         	ldr	r0, [sp, #0x2c]
7009d3f4: 990a         	ldr	r1, [sp, #0x28]
7009d3f6: 9a09         	ldr	r2, [sp, #0x24]
7009d3f8: 9b08         	ldr	r3, [sp, #0x20]
7009d3fa: f8dd c040    	ldr.w	r12, [sp, #0x40]
7009d3fe: 9c11         	ldr	r4, [sp, #0x44]
7009d400: 9d15         	ldr	r5, [sp, #0x54]
7009d402: 9e16         	ldr	r6, [sp, #0x58]
7009d404: 46ee         	mov	lr, sp
7009d406: f8ce 600c    	str.w	r6, [lr, #0xc]
7009d40a: f8ce 5008    	str.w	r5, [lr, #0x8]
7009d40e: f8ce 4004    	str.w	r4, [lr, #0x4]
7009d412: f8ce c000    	str.w	r12, [lr]
7009d416: f008 fb2b    	bl	0x700a5a70 <_out_rev>   @ imm = #0x8656
7009d41a: b00c         	add	sp, #0x30
7009d41c: bd70         	pop	{r4, r5, r6, pc}
7009d41e: 0000         	movs	r0, r0

7009d420 <Udma_eventRegister>:
; {
7009d420: b5b0         	push	{r4, r5, r7, lr}
7009d422: b088         	sub	sp, #0x20
7009d424: 9007         	str	r0, [sp, #0x1c]
7009d426: 9106         	str	r1, [sp, #0x18]
7009d428: 9205         	str	r2, [sp, #0x14]
7009d42a: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009d42c: 9004         	str	r0, [sp, #0x10]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009d42e: 9003         	str	r0, [sp, #0xc]
;     if((NULL_PTR == drvHandle) || (NULL_PTR == eventHandle) || (NULL_PTR == eventPrms))
7009d430: 9807         	ldr	r0, [sp, #0x1c]
7009d432: b130         	cbz	r0, 0x7009d442 <Udma_eventRegister+0x22> @ imm = #0xc
7009d434: e7ff         	b	0x7009d436 <Udma_eventRegister+0x16> @ imm = #-0x2
7009d436: 9806         	ldr	r0, [sp, #0x18]
7009d438: b118         	cbz	r0, 0x7009d442 <Udma_eventRegister+0x22> @ imm = #0x6
7009d43a: e7ff         	b	0x7009d43c <Udma_eventRegister+0x1c> @ imm = #-0x2
7009d43c: 9805         	ldr	r0, [sp, #0x14]
7009d43e: b920         	cbnz	r0, 0x7009d44a <Udma_eventRegister+0x2a> @ imm = #0x8
7009d440: e7ff         	b	0x7009d442 <Udma_eventRegister+0x22> @ imm = #-0x2
7009d442: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009d446: 9004         	str	r0, [sp, #0x10]
;     }
7009d448: e7ff         	b	0x7009d44a <Udma_eventRegister+0x2a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d44a: 9804         	ldr	r0, [sp, #0x10]
7009d44c: b988         	cbnz	r0, 0x7009d472 <Udma_eventRegister+0x52> @ imm = #0x22
7009d44e: e7ff         	b	0x7009d450 <Udma_eventRegister+0x30> @ imm = #-0x2
;         drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009d450: 9807         	ldr	r0, [sp, #0x1c]
7009d452: 9002         	str	r0, [sp, #0x8]
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009d454: 9802         	ldr	r0, [sp, #0x8]
7009d456: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009d45a: f64a 31cd    	movw	r1, #0xabcd
7009d45e: f6ca 31dc    	movt	r1, #0xabdc
7009d462: 4288         	cmp	r0, r1
7009d464: d004         	beq	0x7009d470 <Udma_eventRegister+0x50> @ imm = #0x8
7009d466: e7ff         	b	0x7009d468 <Udma_eventRegister+0x48> @ imm = #-0x2
7009d468: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009d46c: 9004         	str	r0, [sp, #0x10]
;         }
7009d46e: e7ff         	b	0x7009d470 <Udma_eventRegister+0x50> @ imm = #-0x2
;     }
7009d470: e7ff         	b	0x7009d472 <Udma_eventRegister+0x52> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d472: 9804         	ldr	r0, [sp, #0x10]
7009d474: b930         	cbnz	r0, 0x7009d484 <Udma_eventRegister+0x64> @ imm = #0xc
7009d476: e7ff         	b	0x7009d478 <Udma_eventRegister+0x58> @ imm = #-0x2
;         retVal = Udma_eventCheckParams(drvHandleInt, eventPrms);
7009d478: 9802         	ldr	r0, [sp, #0x8]
7009d47a: 9905         	ldr	r1, [sp, #0x14]
7009d47c: f006 f9c0    	bl	0x700a3800 <Udma_eventCheckParams> @ imm = #0x6380
7009d480: 9004         	str	r0, [sp, #0x10]
;     }
7009d482: e7ff         	b	0x7009d484 <Udma_eventRegister+0x64> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d484: 9804         	ldr	r0, [sp, #0x10]
7009d486: bbb0         	cbnz	r0, 0x7009d4f6 <Udma_eventRegister+0xd6> @ imm = #0x6c
7009d488: e7ff         	b	0x7009d48a <Udma_eventRegister+0x6a> @ imm = #-0x2
;         eventHandleInt = (Udma_EventHandleInt) eventHandle;
7009d48a: 9806         	ldr	r0, [sp, #0x18]
7009d48c: 9001         	str	r0, [sp, #0x4]
;             &eventHandleInt->eventPrms, eventPrms, sizeof(eventHandleInt->eventPrms));
7009d48e: 9801         	ldr	r0, [sp, #0x4]
7009d490: 3008         	adds	r0, #0x8
7009d492: 9905         	ldr	r1, [sp, #0x14]
;         (void) memcpy(
7009d494: e8b1 501c    	ldm.w	r1!, {r2, r3, r4, r12, lr}
7009d498: e8a0 501c    	stm.w	r0!, {r2, r3, r4, r12, lr}
7009d49c: e8b1 501c    	ldm.w	r1!, {r2, r3, r4, r12, lr}
7009d4a0: e8a0 501c    	stm.w	r0!, {r2, r3, r4, r12, lr}
7009d4a4: e891 503c    	ldm.w	r1, {r2, r3, r4, r5, r12, lr}
7009d4a8: e880 503c    	stm.w	r0, {r2, r3, r4, r5, r12, lr}
;         eventHandleInt->drvHandle       = drvHandleInt;
7009d4ac: 9802         	ldr	r0, [sp, #0x8]
7009d4ae: 9901         	ldr	r1, [sp, #0x4]
7009d4b0: 6008         	str	r0, [r1]
;         eventHandleInt->globalEvent     = UDMA_EVENT_INVALID;
7009d4b2: 9901         	ldr	r1, [sp, #0x4]
7009d4b4: f64f 70ff    	movw	r0, #0xffff
7009d4b8: 6488         	str	r0, [r1, #0x48]
;         eventHandleInt->vintrNum        = UDMA_EVENT_INVALID;
7009d4ba: 9901         	ldr	r1, [sp, #0x4]
7009d4bc: 64c8         	str	r0, [r1, #0x4c]
;         eventHandleInt->vintrBitNum     = UDMA_EVENT_INVALID;
7009d4be: 9901         	ldr	r1, [sp, #0x4]
7009d4c0: 6508         	str	r0, [r1, #0x50]
;         eventHandleInt->irIntrNum       = UDMA_INTR_INVALID;
7009d4c2: 9901         	ldr	r1, [sp, #0x4]
7009d4c4: 2000         	movs	r0, #0x0
7009d4c6: f6cf 70ff    	movt	r0, #0xffff
7009d4ca: 6548         	str	r0, [r1, #0x54]
;         eventHandleInt->coreIntrNum     = UDMA_INTR_INVALID;
7009d4cc: 9901         	ldr	r1, [sp, #0x4]
7009d4ce: 6588         	str	r0, [r1, #0x58]
;         eventHandleInt->nextEvent       = (Udma_EventHandleInt) NULL_PTR;
7009d4d0: 9901         	ldr	r1, [sp, #0x4]
7009d4d2: 2000         	movs	r0, #0x0
7009d4d4: 65c8         	str	r0, [r1, #0x5c]
;         eventHandleInt->prevEvent       = (Udma_EventHandleInt) NULL_PTR;
7009d4d6: 9901         	ldr	r1, [sp, #0x4]
7009d4d8: 6608         	str	r0, [r1, #0x60]
;         eventHandleInt->hwiHandle       = NULL_PTR;
7009d4da: 9901         	ldr	r1, [sp, #0x4]
7009d4dc: 6648         	str	r0, [r1, #0x64]
;         eventHandleInt->vintrBitAllocFlag = 0U;
7009d4de: 9901         	ldr	r1, [sp, #0x4]
7009d4e0: f8c1 008c    	str.w	r0, [r1, #0x8c]
7009d4e4: f8c1 0088    	str.w	r0, [r1, #0x88]
;         eventHandleInt->pIaGeviRegs     = (volatile CSL_intaggr_imapRegs_gevi *) NULL_PTR;
7009d4e8: 9901         	ldr	r1, [sp, #0x4]
7009d4ea: f8c1 0090    	str.w	r0, [r1, #0x90]
;         eventHandleInt->pIaVintrRegs    = (volatile CSL_intaggr_intrRegs_vint *) NULL_PTR;
7009d4ee: 9901         	ldr	r1, [sp, #0x4]
7009d4f0: f8c1 0094    	str.w	r0, [r1, #0x94]
;     }
7009d4f4: e7ff         	b	0x7009d4f6 <Udma_eventRegister+0xd6> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d4f6: 9804         	ldr	r0, [sp, #0x10]
7009d4f8: 2800         	cmp	r0, #0x0
7009d4fa: f040 809f    	bne.w	0x7009d63c <Udma_eventRegister+0x21c> @ imm = #0x13e
7009d4fe: e7ff         	b	0x7009d500 <Udma_eventRegister+0xe0> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandleInt->instType) &&
7009d500: 9802         	ldr	r0, [sp, #0x8]
7009d502: 6800         	ldr	r0, [r0]
7009d504: b130         	cbz	r0, 0x7009d514 <Udma_eventRegister+0xf4> @ imm = #0xc
7009d506: e7ff         	b	0x7009d508 <Udma_eventRegister+0xe8> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType))
7009d508: 9805         	ldr	r0, [sp, #0x14]
7009d50a: 6800         	ldr	r0, [r0]
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandleInt->instType) &&
7009d50c: 2802         	cmp	r0, #0x2
7009d50e: d101         	bne	0x7009d514 <Udma_eventRegister+0xf4> @ imm = #0x2
7009d510: e7ff         	b	0x7009d512 <Udma_eventRegister+0xf2> @ imm = #-0x2
;         }
7009d512: e092         	b	0x7009d63a <Udma_eventRegister+0x21a> @ imm = #0x124
;             retVal = Udma_eventAllocResource(drvHandleInt, eventHandleInt);
7009d514: 9802         	ldr	r0, [sp, #0x8]
7009d516: 9901         	ldr	r1, [sp, #0x4]
7009d518: f000 f89a    	bl	0x7009d650 <Udma_eventAllocResource> @ imm = #0x134
7009d51c: 9004         	str	r0, [sp, #0x10]
;             if(UDMA_SOK == retVal)
7009d51e: 9804         	ldr	r0, [sp, #0x10]
7009d520: b918         	cbnz	r0, 0x7009d52a <Udma_eventRegister+0x10a> @ imm = #0x6
7009d522: e7ff         	b	0x7009d524 <Udma_eventRegister+0x104> @ imm = #-0x2
7009d524: 2001         	movs	r0, #0x1
;                 allocDone = (uint32_t) TRUE;
7009d526: 9003         	str	r0, [sp, #0xc]
;             }
7009d528: e000         	b	0x7009d52c <Udma_eventRegister+0x10c> @ imm = #0x0
7009d52a: e7ff         	b	0x7009d52c <Udma_eventRegister+0x10c> @ imm = #-0x2
;             if(UDMA_SOK == retVal)
7009d52c: 9804         	ldr	r0, [sp, #0x10]
7009d52e: b9a0         	cbnz	r0, 0x7009d55a <Udma_eventRegister+0x13a> @ imm = #0x28
7009d530: e7ff         	b	0x7009d532 <Udma_eventRegister+0x112> @ imm = #-0x2
;                 eventHandleInt->eventInitDone = UDMA_INIT_DONE;
7009d532: 9901         	ldr	r1, [sp, #0x4]
7009d534: f64a 30cd    	movw	r0, #0xabcd
7009d538: f6ca 30dc    	movt	r0, #0xabdc
7009d53c: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 retVal = Udma_eventConfig(drvHandleInt, eventHandleInt);
7009d540: 9802         	ldr	r0, [sp, #0x8]
7009d542: 9901         	ldr	r1, [sp, #0x4]
7009d544: f7fe f8b4    	bl	0x7009b6b0 <Udma_eventConfig> @ imm = #-0x1e98
7009d548: 9004         	str	r0, [sp, #0x10]
;                 if(UDMA_SOK == retVal)
7009d54a: 9804         	ldr	r0, [sp, #0x10]
7009d54c: b918         	cbnz	r0, 0x7009d556 <Udma_eventRegister+0x136> @ imm = #0x6
7009d54e: e7ff         	b	0x7009d550 <Udma_eventRegister+0x130> @ imm = #-0x2
7009d550: 2001         	movs	r0, #0x1
;                     allocDone = (uint32_t) TRUE;
7009d552: 9003         	str	r0, [sp, #0xc]
;                 }
7009d554: e000         	b	0x7009d558 <Udma_eventRegister+0x138> @ imm = #0x0
7009d556: e7ff         	b	0x7009d558 <Udma_eventRegister+0x138> @ imm = #-0x2
;             }
7009d558: e7ff         	b	0x7009d55a <Udma_eventRegister+0x13a> @ imm = #-0x2
;             if(UDMA_SOK != retVal)
7009d55a: 9804         	ldr	r0, [sp, #0x10]
7009d55c: b170         	cbz	r0, 0x7009d57c <Udma_eventRegister+0x15c> @ imm = #0x1c
7009d55e: e7ff         	b	0x7009d560 <Udma_eventRegister+0x140> @ imm = #-0x2
;                 if(((uint32_t) TRUE) == allocDone)
7009d560: 9803         	ldr	r0, [sp, #0xc]
7009d562: 2801         	cmp	r0, #0x1
7009d564: d109         	bne	0x7009d57a <Udma_eventRegister+0x15a> @ imm = #0x12
7009d566: e7ff         	b	0x7009d568 <Udma_eventRegister+0x148> @ imm = #-0x2
;                     Udma_eventFreeResource(drvHandleInt, eventHandleInt);
7009d568: 9802         	ldr	r0, [sp, #0x8]
7009d56a: 9901         	ldr	r1, [sp, #0x4]
7009d56c: f006 fdc0    	bl	0x700a40f0 <Udma_eventFreeResource> @ imm = #0x6b80
;                     eventHandleInt->eventInitDone = UDMA_DEINIT_DONE;
7009d570: 9901         	ldr	r1, [sp, #0x4]
7009d572: 2000         	movs	r0, #0x0
7009d574: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 }
7009d578: e7ff         	b	0x7009d57a <Udma_eventRegister+0x15a> @ imm = #-0x2
;             }
7009d57a: e05d         	b	0x7009d638 <Udma_eventRegister+0x218> @ imm = #0xba
;                 eventPrms->intrStatusReg    = &eventHandleInt->pIaVintrRegs->STATUSM;
7009d57c: 9801         	ldr	r0, [sp, #0x4]
7009d57e: f8d0 0094    	ldr.w	r0, [r0, #0x94]
7009d582: 3020         	adds	r0, #0x20
7009d584: 9905         	ldr	r1, [sp, #0x14]
7009d586: 6248         	str	r0, [r1, #0x24]
;                 eventPrms->intrClearReg     = &eventHandleInt->pIaVintrRegs->STATUS_CLEAR;
7009d588: 9801         	ldr	r0, [sp, #0x4]
7009d58a: f8d0 0094    	ldr.w	r0, [r0, #0x94]
7009d58e: 3018         	adds	r0, #0x18
7009d590: 9905         	ldr	r1, [sp, #0x14]
7009d592: 6288         	str	r0, [r1, #0x28]
;                 if(eventHandleInt->vintrBitNum != UDMA_EVENT_INVALID)
7009d594: 9801         	ldr	r0, [sp, #0x4]
7009d596: 6d00         	ldr	r0, [r0, #0x50]
7009d598: f64f 71ff    	movw	r1, #0xffff
7009d59c: 4288         	cmp	r0, r1
7009d59e: d017         	beq	0x7009d5d0 <Udma_eventRegister+0x1b0> @ imm = #0x2e
7009d5a0: e7ff         	b	0x7009d5a2 <Udma_eventRegister+0x182> @ imm = #-0x2
;                     eventPrms->intrMask     = ((uint64_t)1U << eventHandleInt->vintrBitNum);
7009d5a2: 9801         	ldr	r0, [sp, #0x4]
7009d5a4: 6d03         	ldr	r3, [r0, #0x50]
7009d5a6: f1a3 0120    	sub.w	r1, r3, #0x20
7009d5aa: 2201         	movs	r2, #0x1
7009d5ac: fa02 fc01    	lsl.w	r12, r2, r1
7009d5b0: f1c3 0020    	rsb.w	r0, r3, #0x20
7009d5b4: fa22 f000    	lsr.w	r0, r2, r0
7009d5b8: 2900         	cmp	r1, #0x0
7009d5ba: bf58         	it	pl
7009d5bc: 4660         	movpl	r0, r12
7009d5be: fa02 f203    	lsl.w	r2, r2, r3
7009d5c2: 2900         	cmp	r1, #0x0
7009d5c4: bf58         	it	pl
7009d5c6: 2200         	movpl	r2, #0x0
7009d5c8: 9905         	ldr	r1, [sp, #0x14]
7009d5ca: 630a         	str	r2, [r1, #0x30]
7009d5cc: 6348         	str	r0, [r1, #0x34]
;                 }
7009d5ce: e004         	b	0x7009d5da <Udma_eventRegister+0x1ba> @ imm = #0x8
;                     eventPrms->intrMask     = 0U;
7009d5d0: 9905         	ldr	r1, [sp, #0x14]
7009d5d2: 2000         	movs	r0, #0x0
7009d5d4: 6348         	str	r0, [r1, #0x34]
7009d5d6: 6308         	str	r0, [r1, #0x30]
7009d5d8: e7ff         	b	0x7009d5da <Udma_eventRegister+0x1ba> @ imm = #-0x2
;                 if(NULL_PTR == eventHandleInt->eventPrms.controllerEventHandle)
7009d5da: 9801         	ldr	r0, [sp, #0x4]
7009d5dc: 6980         	ldr	r0, [r0, #0x18]
7009d5de: b948         	cbnz	r0, 0x7009d5f4 <Udma_eventRegister+0x1d4> @ imm = #0x12
7009d5e0: e7ff         	b	0x7009d5e2 <Udma_eventRegister+0x1c2> @ imm = #-0x2
;                     eventPrms->vintrNum     = eventHandleInt->vintrNum;
7009d5e2: 9801         	ldr	r0, [sp, #0x4]
7009d5e4: 6cc0         	ldr	r0, [r0, #0x4c]
7009d5e6: 9905         	ldr	r1, [sp, #0x14]
7009d5e8: 6388         	str	r0, [r1, #0x38]
;                     eventPrms->coreIntrNum  = eventHandleInt->coreIntrNum;
7009d5ea: 9801         	ldr	r0, [sp, #0x4]
7009d5ec: 6d80         	ldr	r0, [r0, #0x58]
7009d5ee: 9905         	ldr	r1, [sp, #0x14]
7009d5f0: 63c8         	str	r0, [r1, #0x3c]
;                 }
7009d5f2: e00a         	b	0x7009d60a <Udma_eventRegister+0x1ea> @ imm = #0x14
;                        ((Udma_EventHandleInt) (eventHandleInt->eventPrms.controllerEventHandle))->vintrNum;
7009d5f4: 9801         	ldr	r0, [sp, #0x4]
7009d5f6: 6980         	ldr	r0, [r0, #0x18]
7009d5f8: 6cc0         	ldr	r0, [r0, #0x4c]
;                     eventPrms->vintrNum       =
7009d5fa: 9905         	ldr	r1, [sp, #0x14]
7009d5fc: 6388         	str	r0, [r1, #0x38]
;                         ((Udma_EventHandleInt) (eventHandleInt->eventPrms.controllerEventHandle))->coreIntrNum;
7009d5fe: 9801         	ldr	r0, [sp, #0x4]
7009d600: 6980         	ldr	r0, [r0, #0x18]
7009d602: 6d80         	ldr	r0, [r0, #0x58]
;                     eventPrms->coreIntrNum    =
7009d604: 9905         	ldr	r1, [sp, #0x14]
7009d606: 63c8         	str	r0, [r1, #0x3c]
7009d608: e7ff         	b	0x7009d60a <Udma_eventRegister+0x1ea> @ imm = #-0x2
;                 eventHandleInt->eventPrms.intrStatusReg   = eventPrms->intrStatusReg;
7009d60a: 9805         	ldr	r0, [sp, #0x14]
7009d60c: 6a40         	ldr	r0, [r0, #0x24]
7009d60e: 9901         	ldr	r1, [sp, #0x4]
7009d610: 62c8         	str	r0, [r1, #0x2c]
;                 eventHandleInt->eventPrms.intrClearReg    = eventPrms->intrClearReg;
7009d612: 9805         	ldr	r0, [sp, #0x14]
7009d614: 6a80         	ldr	r0, [r0, #0x28]
7009d616: 9901         	ldr	r1, [sp, #0x4]
7009d618: 6308         	str	r0, [r1, #0x30]
;                 eventHandleInt->eventPrms.intrMask        = eventPrms->intrMask;
7009d61a: 9905         	ldr	r1, [sp, #0x14]
7009d61c: 6b08         	ldr	r0, [r1, #0x30]
7009d61e: 6b4a         	ldr	r2, [r1, #0x34]
7009d620: 9901         	ldr	r1, [sp, #0x4]
7009d622: 63ca         	str	r2, [r1, #0x3c]
7009d624: 6388         	str	r0, [r1, #0x38]
;                 eventHandleInt->eventPrms.vintrNum        = eventPrms->vintrNum;
7009d626: 9805         	ldr	r0, [sp, #0x14]
7009d628: 6b80         	ldr	r0, [r0, #0x38]
7009d62a: 9901         	ldr	r1, [sp, #0x4]
7009d62c: 6408         	str	r0, [r1, #0x40]
;                 eventHandleInt->eventPrms.coreIntrNum     = eventPrms->coreIntrNum;
7009d62e: 9805         	ldr	r0, [sp, #0x14]
7009d630: 6bc0         	ldr	r0, [r0, #0x3c]
7009d632: 9901         	ldr	r1, [sp, #0x4]
7009d634: 6448         	str	r0, [r1, #0x44]
7009d636: e7ff         	b	0x7009d638 <Udma_eventRegister+0x218> @ imm = #-0x2
7009d638: e7ff         	b	0x7009d63a <Udma_eventRegister+0x21a> @ imm = #-0x2
;     }
7009d63a: e7ff         	b	0x7009d63c <Udma_eventRegister+0x21c> @ imm = #-0x2
;     return (retVal);
7009d63c: 9804         	ldr	r0, [sp, #0x10]
7009d63e: b008         	add	sp, #0x20
7009d640: bdb0         	pop	{r4, r5, r7, pc}
		...
7009d64e: 0000         	movs	r0, r0

7009d650 <Udma_eventAllocResource>:
; {
7009d650: b580         	push	{r7, lr}
7009d652: b08a         	sub	sp, #0x28
7009d654: 9009         	str	r0, [sp, #0x24]
7009d656: 9108         	str	r1, [sp, #0x20]
7009d658: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009d65a: 9007         	str	r0, [sp, #0x1c]
;     eventPrms = &eventHandle->eventPrms;
7009d65c: 9808         	ldr	r0, [sp, #0x20]
7009d65e: 3008         	adds	r0, #0x8
7009d660: 9004         	str	r0, [sp, #0x10]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009d662: 9804         	ldr	r0, [sp, #0x10]
7009d664: 6800         	ldr	r0, [r0]
7009d666: 2805         	cmp	r0, #0x5
7009d668: d01b         	beq	0x7009d6a2 <Udma_eventAllocResource+0x52> @ imm = #0x36
7009d66a: e7ff         	b	0x7009d66c <Udma_eventAllocResource+0x1c> @ imm = #-0x2
;         eventHandle->globalEvent = Udma_rmAllocEvent(drvHandle);
7009d66c: 9809         	ldr	r0, [sp, #0x24]
7009d66e: f009 fcdf    	bl	0x700a7030 <Udma_rmAllocEvent> @ imm = #0x99be
7009d672: 9908         	ldr	r1, [sp, #0x20]
7009d674: 6488         	str	r0, [r1, #0x48]
;         if(UDMA_EVENT_INVALID == eventHandle->globalEvent)
7009d676: 9808         	ldr	r0, [sp, #0x20]
7009d678: 6c80         	ldr	r0, [r0, #0x48]
7009d67a: f64f 71ff    	movw	r1, #0xffff
7009d67e: 4288         	cmp	r0, r1
7009d680: d104         	bne	0x7009d68c <Udma_eventAllocResource+0x3c> @ imm = #0x8
7009d682: e7ff         	b	0x7009d684 <Udma_eventAllocResource+0x34> @ imm = #-0x2
7009d684: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
7009d688: 9007         	str	r0, [sp, #0x1c]
;         }
7009d68a: e009         	b	0x7009d6a0 <Udma_eventAllocResource+0x50> @ imm = #0x12
;                 &drvHandle->iaRegs.pImapRegs->GEVI[eventHandle->globalEvent];
7009d68c: 9809         	ldr	r0, [sp, #0x24]
7009d68e: f8d0 00a0    	ldr.w	r0, [r0, #0xa0]
7009d692: 9908         	ldr	r1, [sp, #0x20]
7009d694: 6c8a         	ldr	r2, [r1, #0x48]
7009d696: eb00 00c2    	add.w	r0, r0, r2, lsl #3
;             eventHandle->pIaGeviRegs =
7009d69a: f8c1 0090    	str.w	r0, [r1, #0x90]
7009d69e: e7ff         	b	0x7009d6a0 <Udma_eventAllocResource+0x50> @ imm = #-0x2
;     }
7009d6a0: e7ff         	b	0x7009d6a2 <Udma_eventAllocResource+0x52> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d6a2: 9807         	ldr	r0, [sp, #0x1c]
7009d6a4: bb00         	cbnz	r0, 0x7009d6e8 <Udma_eventAllocResource+0x98> @ imm = #0x40
7009d6a6: e7ff         	b	0x7009d6a8 <Udma_eventAllocResource+0x58> @ imm = #-0x2
;         if((UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode) ||
7009d6a8: 9804         	ldr	r0, [sp, #0x10]
7009d6aa: 6840         	ldr	r0, [r0, #0x4]
7009d6ac: 2801         	cmp	r0, #0x1
7009d6ae: d009         	beq	0x7009d6c4 <Udma_eventAllocResource+0x74> @ imm = #0x12
7009d6b0: e7ff         	b	0x7009d6b2 <Udma_eventAllocResource+0x62> @ imm = #-0x2
;             ((UDMA_EVENT_MODE_SHARED == eventPrms->eventMode) &&
7009d6b2: 9804         	ldr	r0, [sp, #0x10]
7009d6b4: 6840         	ldr	r0, [r0, #0x4]
7009d6b6: 2802         	cmp	r0, #0x2
7009d6b8: d115         	bne	0x7009d6e6 <Udma_eventAllocResource+0x96> @ imm = #0x2a
7009d6ba: e7ff         	b	0x7009d6bc <Udma_eventAllocResource+0x6c> @ imm = #-0x2
;                 (NULL_PTR == eventPrms->controllerEventHandle)))
7009d6bc: 9804         	ldr	r0, [sp, #0x10]
7009d6be: 6900         	ldr	r0, [r0, #0x10]
;         if((UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode) ||
7009d6c0: b988         	cbnz	r0, 0x7009d6e6 <Udma_eventAllocResource+0x96> @ imm = #0x22
7009d6c2: e7ff         	b	0x7009d6c4 <Udma_eventAllocResource+0x74> @ imm = #-0x2
;             eventHandle->vintrNum = Udma_rmAllocVintr(drvHandle);
7009d6c4: 9809         	ldr	r0, [sp, #0x24]
7009d6c6: f009 fd03    	bl	0x700a70d0 <Udma_rmAllocVintr> @ imm = #0x9a06
7009d6ca: 9908         	ldr	r1, [sp, #0x20]
7009d6cc: 64c8         	str	r0, [r1, #0x4c]
;             if(UDMA_EVENT_INVALID == eventHandle->vintrNum)
7009d6ce: 9808         	ldr	r0, [sp, #0x20]
7009d6d0: 6cc0         	ldr	r0, [r0, #0x4c]
7009d6d2: f64f 71ff    	movw	r1, #0xffff
7009d6d6: 4288         	cmp	r0, r1
7009d6d8: d104         	bne	0x7009d6e4 <Udma_eventAllocResource+0x94> @ imm = #0x8
7009d6da: e7ff         	b	0x7009d6dc <Udma_eventAllocResource+0x8c> @ imm = #-0x2
7009d6dc: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009d6e0: 9007         	str	r0, [sp, #0x1c]
;             }
7009d6e2: e7ff         	b	0x7009d6e4 <Udma_eventAllocResource+0x94> @ imm = #-0x2
;         }
7009d6e4: e7ff         	b	0x7009d6e6 <Udma_eventAllocResource+0x96> @ imm = #-0x2
;     }
7009d6e6: e7ff         	b	0x7009d6e8 <Udma_eventAllocResource+0x98> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d6e8: 9807         	ldr	r0, [sp, #0x1c]
7009d6ea: b9b8         	cbnz	r0, 0x7009d71c <Udma_eventAllocResource+0xcc> @ imm = #0x2e
7009d6ec: e7ff         	b	0x7009d6ee <Udma_eventAllocResource+0x9e> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009d6ee: 9804         	ldr	r0, [sp, #0x10]
7009d6f0: 6800         	ldr	r0, [r0]
7009d6f2: 2805         	cmp	r0, #0x5
7009d6f4: d011         	beq	0x7009d71a <Udma_eventAllocResource+0xca> @ imm = #0x22
7009d6f6: e7ff         	b	0x7009d6f8 <Udma_eventAllocResource+0xa8> @ imm = #-0x2
;             eventHandle->vintrBitNum = Udma_rmAllocVintrBit(eventHandle);
7009d6f8: 9808         	ldr	r0, [sp, #0x20]
7009d6fa: f007 fc11    	bl	0x700a4f20 <Udma_rmAllocVintrBit> @ imm = #0x7822
7009d6fe: 9908         	ldr	r1, [sp, #0x20]
7009d700: 6508         	str	r0, [r1, #0x50]
;             if(UDMA_EVENT_INVALID == eventHandle->vintrBitNum)
7009d702: 9808         	ldr	r0, [sp, #0x20]
7009d704: 6d00         	ldr	r0, [r0, #0x50]
7009d706: f64f 71ff    	movw	r1, #0xffff
7009d70a: 4288         	cmp	r0, r1
7009d70c: d104         	bne	0x7009d718 <Udma_eventAllocResource+0xc8> @ imm = #0x8
7009d70e: e7ff         	b	0x7009d710 <Udma_eventAllocResource+0xc0> @ imm = #-0x2
7009d710: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009d714: 9007         	str	r0, [sp, #0x1c]
;             }
7009d716: e7ff         	b	0x7009d718 <Udma_eventAllocResource+0xc8> @ imm = #-0x2
;         }
7009d718: e7ff         	b	0x7009d71a <Udma_eventAllocResource+0xca> @ imm = #-0x2
;     }
7009d71a: e7ff         	b	0x7009d71c <Udma_eventAllocResource+0xcc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d71c: 9807         	ldr	r0, [sp, #0x1c]
7009d71e: 2800         	cmp	r0, #0x0
7009d720: d146         	bne	0x7009d7b0 <Udma_eventAllocResource+0x160> @ imm = #0x8c
7009d722: e7ff         	b	0x7009d724 <Udma_eventAllocResource+0xd4> @ imm = #-0x2
;         if((((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
7009d724: 9804         	ldr	r0, [sp, #0x10]
7009d726: 6940         	ldr	r0, [r0, #0x14]
7009d728: b120         	cbz	r0, 0x7009d734 <Udma_eventAllocResource+0xe4> @ imm = #0x8
7009d72a: e7ff         	b	0x7009d72c <Udma_eventAllocResource+0xdc> @ imm = #-0x2
;                 (NULL_PTR == eventPrms->controllerEventHandle)) ||
7009d72c: 9804         	ldr	r0, [sp, #0x10]
7009d72e: 6900         	ldr	r0, [r0, #0x10]
7009d730: b128         	cbz	r0, 0x7009d73e <Udma_eventAllocResource+0xee> @ imm = #0xa
7009d732: e7ff         	b	0x7009d734 <Udma_eventAllocResource+0xe4> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009d734: 9804         	ldr	r0, [sp, #0x10]
7009d736: 6800         	ldr	r0, [r0]
;         if((((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
7009d738: 2805         	cmp	r0, #0x5
7009d73a: d138         	bne	0x7009d7ae <Udma_eventAllocResource+0x15e> @ imm = #0x70
7009d73c: e7ff         	b	0x7009d73e <Udma_eventAllocResource+0xee> @ imm = #-0x2
;             if(UDMA_CORE_INTR_ANY != eventPrms->preferredCoreIntrNum)
7009d73e: 9804         	ldr	r0, [sp, #0x10]
7009d740: 6a00         	ldr	r0, [r0, #0x20]
7009d742: 2101         	movs	r1, #0x1
7009d744: f6cf 71ff    	movt	r1, #0xffff
7009d748: 4288         	cmp	r0, r1
7009d74a: d007         	beq	0x7009d75c <Udma_eventAllocResource+0x10c> @ imm = #0xe
7009d74c: e7ff         	b	0x7009d74e <Udma_eventAllocResource+0xfe> @ imm = #-0x2
;                 preferredIrIntrNum = Udma_rmTranslateCoreIntrInput(drvHandle, eventPrms->preferredCoreIntrNum);
7009d74e: 9809         	ldr	r0, [sp, #0x24]
7009d750: 9904         	ldr	r1, [sp, #0x10]
7009d752: 6a09         	ldr	r1, [r1, #0x20]
7009d754: f00f fffc    	bl	0x700ad750 <Udma_rmTranslateCoreIntrInput> @ imm = #0xfff8
7009d758: 9005         	str	r0, [sp, #0x14]
;             }
7009d75a: e003         	b	0x7009d764 <Udma_eventAllocResource+0x114> @ imm = #0x6
;                 preferredIrIntrNum = eventPrms->preferredCoreIntrNum;
7009d75c: 9804         	ldr	r0, [sp, #0x10]
7009d75e: 6a00         	ldr	r0, [r0, #0x20]
7009d760: 9005         	str	r0, [sp, #0x14]
7009d762: e7ff         	b	0x7009d764 <Udma_eventAllocResource+0x114> @ imm = #-0x2
;             if(UDMA_INTR_INVALID != preferredIrIntrNum)
7009d764: 9805         	ldr	r0, [sp, #0x14]
7009d766: f510 3f80    	cmn.w	r0, #0x10000
7009d76a: d015         	beq	0x7009d798 <Udma_eventAllocResource+0x148> @ imm = #0x2a
7009d76c: e7ff         	b	0x7009d76e <Udma_eventAllocResource+0x11e> @ imm = #-0x2
;                     Udma_rmAllocIrIntr(preferredIrIntrNum, drvHandle);
7009d76e: 9805         	ldr	r0, [sp, #0x14]
7009d770: 9909         	ldr	r1, [sp, #0x24]
7009d772: f004 f82d    	bl	0x700a17d0 <Udma_rmAllocIrIntr> @ imm = #0x405a
;                 eventHandle->irIntrNum =
7009d776: 9908         	ldr	r1, [sp, #0x20]
7009d778: 6548         	str	r0, [r1, #0x54]
;                 if(UDMA_INTR_INVALID != eventHandle->irIntrNum)
7009d77a: 9808         	ldr	r0, [sp, #0x20]
7009d77c: 6d40         	ldr	r0, [r0, #0x54]
7009d77e: f510 3f80    	cmn.w	r0, #0x10000
7009d782: d008         	beq	0x7009d796 <Udma_eventAllocResource+0x146> @ imm = #0x10
7009d784: e7ff         	b	0x7009d786 <Udma_eventAllocResource+0x136> @ imm = #-0x2
;                     eventHandle->coreIntrNum = Udma_rmTranslateIrOutput(drvHandle, eventHandle->irIntrNum);
7009d786: 9809         	ldr	r0, [sp, #0x24]
7009d788: 9908         	ldr	r1, [sp, #0x20]
7009d78a: 6d49         	ldr	r1, [r1, #0x54]
7009d78c: f00f fff8    	bl	0x700ad780 <Udma_rmTranslateIrOutput> @ imm = #0xfff0
7009d790: 9908         	ldr	r1, [sp, #0x20]
7009d792: 6588         	str	r0, [r1, #0x58]
;                 }
7009d794: e7ff         	b	0x7009d796 <Udma_eventAllocResource+0x146> @ imm = #-0x2
;             }
7009d796: e7ff         	b	0x7009d798 <Udma_eventAllocResource+0x148> @ imm = #-0x2
;             if(UDMA_INTR_INVALID == eventHandle->coreIntrNum)
7009d798: 9808         	ldr	r0, [sp, #0x20]
7009d79a: 6d80         	ldr	r0, [r0, #0x58]
7009d79c: f510 3f80    	cmn.w	r0, #0x10000
7009d7a0: d104         	bne	0x7009d7ac <Udma_eventAllocResource+0x15c> @ imm = #0x8
7009d7a2: e7ff         	b	0x7009d7a4 <Udma_eventAllocResource+0x154> @ imm = #-0x2
7009d7a4: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009d7a8: 9007         	str	r0, [sp, #0x1c]
;             }
7009d7aa: e7ff         	b	0x7009d7ac <Udma_eventAllocResource+0x15c> @ imm = #-0x2
;         }
7009d7ac: e7ff         	b	0x7009d7ae <Udma_eventAllocResource+0x15e> @ imm = #-0x2
;     }
7009d7ae: e7ff         	b	0x7009d7b0 <Udma_eventAllocResource+0x160> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d7b0: 9807         	ldr	r0, [sp, #0x1c]
7009d7b2: bb18         	cbnz	r0, 0x7009d7fc <Udma_eventAllocResource+0x1ac> @ imm = #0x46
7009d7b4: e7ff         	b	0x7009d7b6 <Udma_eventAllocResource+0x166> @ imm = #-0x2
;         cookie = HwiP_disable();
7009d7b6: f011 eb04    	blx	0x700aedc0 <HwiP_disable> @ imm = #0x11608
7009d7ba: 9002         	str	r0, [sp, #0x8]
;         eventHandle->prevEvent = (Udma_EventHandleInt) NULL_PTR;
7009d7bc: 9908         	ldr	r1, [sp, #0x20]
7009d7be: 2000         	movs	r0, #0x0
7009d7c0: 6608         	str	r0, [r1, #0x60]
;         eventHandle->nextEvent = (Udma_EventHandleInt) NULL_PTR;
7009d7c2: 9908         	ldr	r1, [sp, #0x20]
7009d7c4: 65c8         	str	r0, [r1, #0x5c]
;         if(NULL_PTR != eventPrms->controllerEventHandle)
7009d7c6: 9804         	ldr	r0, [sp, #0x10]
7009d7c8: 6900         	ldr	r0, [r0, #0x10]
7009d7ca: b198         	cbz	r0, 0x7009d7f4 <Udma_eventAllocResource+0x1a4> @ imm = #0x26
7009d7cc: e7ff         	b	0x7009d7ce <Udma_eventAllocResource+0x17e> @ imm = #-0x2
;             lastEvent = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
7009d7ce: 9804         	ldr	r0, [sp, #0x10]
7009d7d0: 6900         	ldr	r0, [r0, #0x10]
7009d7d2: 9003         	str	r0, [sp, #0xc]
;             while(NULL_PTR != lastEvent->nextEvent)
7009d7d4: e7ff         	b	0x7009d7d6 <Udma_eventAllocResource+0x186> @ imm = #-0x2
7009d7d6: 9803         	ldr	r0, [sp, #0xc]
7009d7d8: 6dc0         	ldr	r0, [r0, #0x5c]
7009d7da: b120         	cbz	r0, 0x7009d7e6 <Udma_eventAllocResource+0x196> @ imm = #0x8
7009d7dc: e7ff         	b	0x7009d7de <Udma_eventAllocResource+0x18e> @ imm = #-0x2
;                 lastEvent = lastEvent->nextEvent;
7009d7de: 9803         	ldr	r0, [sp, #0xc]
7009d7e0: 6dc0         	ldr	r0, [r0, #0x5c]
7009d7e2: 9003         	str	r0, [sp, #0xc]
;             while(NULL_PTR != lastEvent->nextEvent)
7009d7e4: e7f7         	b	0x7009d7d6 <Udma_eventAllocResource+0x186> @ imm = #-0x12
;             eventHandle->prevEvent = lastEvent;
7009d7e6: 9803         	ldr	r0, [sp, #0xc]
7009d7e8: 9908         	ldr	r1, [sp, #0x20]
7009d7ea: 6608         	str	r0, [r1, #0x60]
;             lastEvent->nextEvent   = eventHandle;
7009d7ec: 9808         	ldr	r0, [sp, #0x20]
7009d7ee: 9903         	ldr	r1, [sp, #0xc]
7009d7f0: 65c8         	str	r0, [r1, #0x5c]
;         }
7009d7f2: e7ff         	b	0x7009d7f4 <Udma_eventAllocResource+0x1a4> @ imm = #-0x2
;         HwiP_restore(cookie);
7009d7f4: 9802         	ldr	r0, [sp, #0x8]
7009d7f6: f011 eb04    	blx	0x700aee00 <HwiP_restore> @ imm = #0x11608
;     }
7009d7fa: e7ff         	b	0x7009d7fc <Udma_eventAllocResource+0x1ac> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d7fc: 9807         	ldr	r0, [sp, #0x1c]
7009d7fe: b9a0         	cbnz	r0, 0x7009d82a <Udma_eventAllocResource+0x1da> @ imm = #0x28
7009d800: e7ff         	b	0x7009d802 <Udma_eventAllocResource+0x1b2> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009d802: 9804         	ldr	r0, [sp, #0x10]
7009d804: 6800         	ldr	r0, [r0]
7009d806: 2803         	cmp	r0, #0x3
7009d808: d10e         	bne	0x7009d828 <Udma_eventAllocResource+0x1d8> @ imm = #0x1c
7009d80a: e7ff         	b	0x7009d80c <Udma_eventAllocResource+0x1bc> @ imm = #-0x2
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009d80c: 9804         	ldr	r0, [sp, #0x10]
7009d80e: 6880         	ldr	r0, [r0, #0x8]
7009d810: 9001         	str	r0, [sp, #0x4]
;             if(TRUE == chHandle->chOesAllocDone)
7009d812: 9801         	ldr	r0, [sp, #0x4]
7009d814: f8d0 0248    	ldr.w	r0, [r0, #0x248]
7009d818: 2801         	cmp	r0, #0x1
7009d81a: d104         	bne	0x7009d826 <Udma_eventAllocResource+0x1d6> @ imm = #0x8
7009d81c: e7ff         	b	0x7009d81e <Udma_eventAllocResource+0x1ce> @ imm = #-0x2
7009d81e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009d822: 9007         	str	r0, [sp, #0x1c]
;             }
7009d824: e7ff         	b	0x7009d826 <Udma_eventAllocResource+0x1d6> @ imm = #-0x2
;         }
7009d826: e7ff         	b	0x7009d828 <Udma_eventAllocResource+0x1d8> @ imm = #-0x2
;     }
7009d828: e7ff         	b	0x7009d82a <Udma_eventAllocResource+0x1da> @ imm = #-0x2
;     if(UDMA_SOK != retVal)
7009d82a: 9807         	ldr	r0, [sp, #0x1c]
7009d82c: b128         	cbz	r0, 0x7009d83a <Udma_eventAllocResource+0x1ea> @ imm = #0xa
7009d82e: e7ff         	b	0x7009d830 <Udma_eventAllocResource+0x1e0> @ imm = #-0x2
;         Udma_eventFreeResource(drvHandle, eventHandle);
7009d830: 9809         	ldr	r0, [sp, #0x24]
7009d832: 9908         	ldr	r1, [sp, #0x20]
7009d834: f006 fc5c    	bl	0x700a40f0 <Udma_eventFreeResource> @ imm = #0x68b8
;     }
7009d838: e016         	b	0x7009d868 <Udma_eventAllocResource+0x218> @ imm = #0x2c
;         if(NULL_PTR == eventPrms->controllerEventHandle)
7009d83a: 9804         	ldr	r0, [sp, #0x10]
7009d83c: 6900         	ldr	r0, [r0, #0x10]
7009d83e: b920         	cbnz	r0, 0x7009d84a <Udma_eventAllocResource+0x1fa> @ imm = #0x8
7009d840: e7ff         	b	0x7009d842 <Udma_eventAllocResource+0x1f2> @ imm = #-0x2
;             vintrNum = eventHandle->vintrNum;
7009d842: 9808         	ldr	r0, [sp, #0x20]
7009d844: 6cc0         	ldr	r0, [r0, #0x4c]
7009d846: 9006         	str	r0, [sp, #0x18]
;         }
7009d848: e004         	b	0x7009d854 <Udma_eventAllocResource+0x204> @ imm = #0x8
;             vintrNum = ((Udma_EventHandleInt) (eventPrms->controllerEventHandle))->vintrNum;
7009d84a: 9804         	ldr	r0, [sp, #0x10]
7009d84c: 6900         	ldr	r0, [r0, #0x10]
7009d84e: 6cc0         	ldr	r0, [r0, #0x4c]
7009d850: 9006         	str	r0, [sp, #0x18]
7009d852: e7ff         	b	0x7009d854 <Udma_eventAllocResource+0x204> @ imm = #-0x2
;         eventHandle->pIaVintrRegs = &drvHandle->iaRegs.pIntrRegs->VINT[vintrNum];
7009d854: 9809         	ldr	r0, [sp, #0x24]
7009d856: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
7009d85a: 9906         	ldr	r1, [sp, #0x18]
7009d85c: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009d860: 9908         	ldr	r1, [sp, #0x20]
7009d862: f8c1 0094    	str.w	r0, [r1, #0x94]
7009d866: e7ff         	b	0x7009d868 <Udma_eventAllocResource+0x218> @ imm = #-0x2
;     return (retVal);
7009d868: 9807         	ldr	r0, [sp, #0x1c]
7009d86a: b00a         	add	sp, #0x28
7009d86c: bd80         	pop	{r7, pc}
7009d86e: 0000         	movs	r0, r0

7009d870 <Udma_chFreeResource>:
; {
7009d870: b580         	push	{r7, lr}
7009d872: b084         	sub	sp, #0x10
7009d874: 9003         	str	r0, [sp, #0xc]
7009d876: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009d878: 9002         	str	r0, [sp, #0x8]
;     drvHandle = chHandle->drvHandle;
7009d87a: 9803         	ldr	r0, [sp, #0xc]
7009d87c: 6e80         	ldr	r0, [r0, #0x68]
7009d87e: 9001         	str	r0, [sp, #0x4]
;     if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009d880: 9803         	ldr	r0, [sp, #0xc]
7009d882: 7800         	ldrb	r0, [r0]
7009d884: 0740         	lsls	r0, r0, #0x1d
7009d886: 2800         	cmp	r0, #0x0
7009d888: d52e         	bpl	0x7009d8e8 <Udma_chFreeResource+0x78> @ imm = #0x5c
7009d88a: e7ff         	b	0x7009d88c <Udma_chFreeResource+0x1c> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID != chHandle->txChNum)
7009d88c: 9803         	ldr	r0, [sp, #0xc]
7009d88e: 6ec0         	ldr	r0, [r0, #0x6c]
7009d890: f510 3f80    	cmn.w	r0, #0x10000
7009d894: d027         	beq	0x7009d8e6 <Udma_chFreeResource+0x76> @ imm = #0x4e
7009d896: e7ff         	b	0x7009d898 <Udma_chFreeResource+0x28> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009d898: 9803         	ldr	r0, [sp, #0xc]
7009d89a: 7800         	ldrb	r0, [r0]
7009d89c: 0640         	lsls	r0, r0, #0x19
7009d89e: 2800         	cmp	r0, #0x0
7009d8a0: d506         	bpl	0x7009d8b0 <Udma_chFreeResource+0x40> @ imm = #0xc
7009d8a2: e7ff         	b	0x7009d8a4 <Udma_chFreeResource+0x34> @ imm = #-0x2
;                 Udma_rmFreeBlkCopyHcCh(chHandle->txChNum, drvHandle);
7009d8a4: 9803         	ldr	r0, [sp, #0xc]
7009d8a6: 6ec0         	ldr	r0, [r0, #0x6c]
7009d8a8: 9901         	ldr	r1, [sp, #0x4]
7009d8aa: f00c fdd9    	bl	0x700aa460 <Udma_rmFreeBlkCopyHcCh> @ imm = #0xcbb2
;             }
7009d8ae: e012         	b	0x7009d8d6 <Udma_chFreeResource+0x66> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009d8b0: 9803         	ldr	r0, [sp, #0xc]
7009d8b2: 7800         	ldrb	r0, [r0]
7009d8b4: 0600         	lsls	r0, r0, #0x18
7009d8b6: 2800         	cmp	r0, #0x0
7009d8b8: d506         	bpl	0x7009d8c8 <Udma_chFreeResource+0x58> @ imm = #0xc
7009d8ba: e7ff         	b	0x7009d8bc <Udma_chFreeResource+0x4c> @ imm = #-0x2
;                 Udma_rmFreeBlkCopyUhcCh(chHandle->txChNum, drvHandle);
7009d8bc: 9803         	ldr	r0, [sp, #0xc]
7009d8be: 6ec0         	ldr	r0, [r0, #0x6c]
7009d8c0: 9901         	ldr	r1, [sp, #0x4]
7009d8c2: f00c fe05    	bl	0x700aa4d0 <Udma_rmFreeBlkCopyUhcCh> @ imm = #0xcc0a
;             }
7009d8c6: e005         	b	0x7009d8d4 <Udma_chFreeResource+0x64> @ imm = #0xa
;                 Udma_rmFreeBlkCopyCh(chHandle->txChNum, drvHandle);
7009d8c8: 9803         	ldr	r0, [sp, #0xc]
7009d8ca: 6ec0         	ldr	r0, [r0, #0x6c]
7009d8cc: 9901         	ldr	r1, [sp, #0x4]
7009d8ce: f00c fd8f    	bl	0x700aa3f0 <Udma_rmFreeBlkCopyCh> @ imm = #0xcb1e
7009d8d2: e7ff         	b	0x7009d8d4 <Udma_chFreeResource+0x64> @ imm = #-0x2
7009d8d4: e7ff         	b	0x7009d8d6 <Udma_chFreeResource+0x66> @ imm = #-0x2
;             chHandle->txChNum = UDMA_DMA_CH_INVALID;
7009d8d6: 9903         	ldr	r1, [sp, #0xc]
7009d8d8: 2000         	movs	r0, #0x0
7009d8da: f6cf 70ff    	movt	r0, #0xffff
7009d8de: 66c8         	str	r0, [r1, #0x6c]
;             chHandle->rxChNum = UDMA_DMA_CH_INVALID;
7009d8e0: 9903         	ldr	r1, [sp, #0xc]
7009d8e2: 6708         	str	r0, [r1, #0x70]
;         }
7009d8e4: e7ff         	b	0x7009d8e6 <Udma_chFreeResource+0x76> @ imm = #-0x2
;     }
7009d8e6: e084         	b	0x7009d9f2 <Udma_chFreeResource+0x182> @ imm = #0x108
;         if(UDMA_DMA_CH_INVALID != chHandle->txChNum)
7009d8e8: 9803         	ldr	r0, [sp, #0xc]
7009d8ea: 6ec0         	ldr	r0, [r0, #0x6c]
7009d8ec: f510 3f80    	cmn.w	r0, #0x10000
7009d8f0: d032         	beq	0x7009d958 <Udma_chFreeResource+0xe8> @ imm = #0x64
7009d8f2: e7ff         	b	0x7009d8f4 <Udma_chFreeResource+0x84> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009d8f4: 9803         	ldr	r0, [sp, #0xc]
7009d8f6: 7800         	ldrb	r0, [r0]
7009d8f8: 0640         	lsls	r0, r0, #0x19
7009d8fa: 2800         	cmp	r0, #0x0
7009d8fc: d506         	bpl	0x7009d90c <Udma_chFreeResource+0x9c> @ imm = #0xc
7009d8fe: e7ff         	b	0x7009d900 <Udma_chFreeResource+0x90> @ imm = #-0x2
;                 Udma_rmFreeTxHcCh(chHandle->txChNum, drvHandle);
7009d900: 9803         	ldr	r0, [sp, #0xc]
7009d902: 6ec0         	ldr	r0, [r0, #0x6c]
7009d904: 9901         	ldr	r1, [sp, #0x4]
7009d906: f00c fefb    	bl	0x700aa700 <Udma_rmFreeTxHcCh> @ imm = #0xcdf6
;             }
7009d90a: e01f         	b	0x7009d94c <Udma_chFreeResource+0xdc> @ imm = #0x3e
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009d90c: 9803         	ldr	r0, [sp, #0xc]
7009d90e: 7840         	ldrb	r0, [r0, #0x1]
7009d910: 07c0         	lsls	r0, r0, #0x1f
7009d912: b138         	cbz	r0, 0x7009d924 <Udma_chFreeResource+0xb4> @ imm = #0xe
7009d914: e7ff         	b	0x7009d916 <Udma_chFreeResource+0xa6> @ imm = #-0x2
;                 Udma_rmFreeMappedTxCh(chHandle->txChNum, drvHandle, chHandle->chPrms.mappedChGrp);
7009d916: 9803         	ldr	r0, [sp, #0xc]
7009d918: 68c2         	ldr	r2, [r0, #0xc]
7009d91a: 6ec0         	ldr	r0, [r0, #0x6c]
7009d91c: 9901         	ldr	r1, [sp, #0x4]
7009d91e: f00c f827    	bl	0x700a9970 <Udma_rmFreeMappedTxCh> @ imm = #0xc04e
;             }
7009d922: e012         	b	0x7009d94a <Udma_chFreeResource+0xda> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009d924: 9803         	ldr	r0, [sp, #0xc]
7009d926: 7800         	ldrb	r0, [r0]
7009d928: 0600         	lsls	r0, r0, #0x18
7009d92a: 2800         	cmp	r0, #0x0
7009d92c: d506         	bpl	0x7009d93c <Udma_chFreeResource+0xcc> @ imm = #0xc
7009d92e: e7ff         	b	0x7009d930 <Udma_chFreeResource+0xc0> @ imm = #-0x2
;                 Udma_rmFreeTxUhcCh(chHandle->txChNum, drvHandle);
7009d930: 9803         	ldr	r0, [sp, #0xc]
7009d932: 6ec0         	ldr	r0, [r0, #0x6c]
7009d934: 9901         	ldr	r1, [sp, #0x4]
7009d936: f00c ff1b    	bl	0x700aa770 <Udma_rmFreeTxUhcCh> @ imm = #0xce36
;             }
7009d93a: e005         	b	0x7009d948 <Udma_chFreeResource+0xd8> @ imm = #0xa
;                 Udma_rmFreeTxCh(chHandle->txChNum, drvHandle);
7009d93c: 9803         	ldr	r0, [sp, #0xc]
7009d93e: 6ec0         	ldr	r0, [r0, #0x6c]
7009d940: 9901         	ldr	r1, [sp, #0x4]
7009d942: f00c fea5    	bl	0x700aa690 <Udma_rmFreeTxCh> @ imm = #0xcd4a
7009d946: e7ff         	b	0x7009d948 <Udma_chFreeResource+0xd8> @ imm = #-0x2
7009d948: e7ff         	b	0x7009d94a <Udma_chFreeResource+0xda> @ imm = #-0x2
7009d94a: e7ff         	b	0x7009d94c <Udma_chFreeResource+0xdc> @ imm = #-0x2
;             chHandle->txChNum = UDMA_DMA_CH_INVALID;
7009d94c: 9903         	ldr	r1, [sp, #0xc]
7009d94e: 2000         	movs	r0, #0x0
7009d950: f6cf 70ff    	movt	r0, #0xffff
7009d954: 66c8         	str	r0, [r1, #0x6c]
;         }
7009d956: e7ff         	b	0x7009d958 <Udma_chFreeResource+0xe8> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID != chHandle->rxChNum)
7009d958: 9803         	ldr	r0, [sp, #0xc]
7009d95a: 6f00         	ldr	r0, [r0, #0x70]
7009d95c: f510 3f80    	cmn.w	r0, #0x10000
7009d960: d033         	beq	0x7009d9ca <Udma_chFreeResource+0x15a> @ imm = #0x66
7009d962: e7ff         	b	0x7009d964 <Udma_chFreeResource+0xf4> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009d964: 9803         	ldr	r0, [sp, #0xc]
7009d966: 7800         	ldrb	r0, [r0]
7009d968: 0640         	lsls	r0, r0, #0x19
7009d96a: 2800         	cmp	r0, #0x0
7009d96c: d506         	bpl	0x7009d97c <Udma_chFreeResource+0x10c> @ imm = #0xc
7009d96e: e7ff         	b	0x7009d970 <Udma_chFreeResource+0x100> @ imm = #-0x2
;                 Udma_rmFreeRxHcCh(chHandle->rxChNum, drvHandle);
7009d970: 9803         	ldr	r0, [sp, #0xc]
7009d972: 6f00         	ldr	r0, [r0, #0x70]
7009d974: 9901         	ldr	r1, [sp, #0x4]
7009d976: f00c fe1b    	bl	0x700aa5b0 <Udma_rmFreeRxHcCh> @ imm = #0xcc36
;             }
7009d97a: e020         	b	0x7009d9be <Udma_chFreeResource+0x14e> @ imm = #0x40
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009d97c: 9803         	ldr	r0, [sp, #0xc]
7009d97e: 7840         	ldrb	r0, [r0, #0x1]
7009d980: 07c0         	lsls	r0, r0, #0x1f
7009d982: b140         	cbz	r0, 0x7009d996 <Udma_chFreeResource+0x126> @ imm = #0x10
7009d984: e7ff         	b	0x7009d986 <Udma_chFreeResource+0x116> @ imm = #-0x2
;                 Udma_rmFreeMappedRxCh(chHandle->rxChNum, drvHandle, chHandle->chPrms.mappedChGrp - UDMA_NUM_MAPPED_TX_GROUP);
7009d986: 9803         	ldr	r0, [sp, #0xc]
7009d988: 68c2         	ldr	r2, [r0, #0xc]
7009d98a: 6f00         	ldr	r0, [r0, #0x70]
7009d98c: 9901         	ldr	r1, [sp, #0x4]
7009d98e: 3a04         	subs	r2, #0x4
7009d990: f00b ffb6    	bl	0x700a9900 <Udma_rmFreeMappedRxCh> @ imm = #0xbf6c
;             }
7009d994: e012         	b	0x7009d9bc <Udma_chFreeResource+0x14c> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009d996: 9803         	ldr	r0, [sp, #0xc]
7009d998: 7800         	ldrb	r0, [r0]
7009d99a: 0600         	lsls	r0, r0, #0x18
7009d99c: 2800         	cmp	r0, #0x0
7009d99e: d506         	bpl	0x7009d9ae <Udma_chFreeResource+0x13e> @ imm = #0xc
7009d9a0: e7ff         	b	0x7009d9a2 <Udma_chFreeResource+0x132> @ imm = #-0x2
;                 Udma_rmFreeRxUhcCh(chHandle->rxChNum, drvHandle);
7009d9a2: 9803         	ldr	r0, [sp, #0xc]
7009d9a4: 6f00         	ldr	r0, [r0, #0x70]
7009d9a6: 9901         	ldr	r1, [sp, #0x4]
7009d9a8: f00c fe3a    	bl	0x700aa620 <Udma_rmFreeRxUhcCh> @ imm = #0xcc74
;             }
7009d9ac: e005         	b	0x7009d9ba <Udma_chFreeResource+0x14a> @ imm = #0xa
;                 Udma_rmFreeRxCh(chHandle->rxChNum, drvHandle);
7009d9ae: 9803         	ldr	r0, [sp, #0xc]
7009d9b0: 6f00         	ldr	r0, [r0, #0x70]
7009d9b2: 9901         	ldr	r1, [sp, #0x4]
7009d9b4: f00c fdc4    	bl	0x700aa540 <Udma_rmFreeRxCh> @ imm = #0xcb88
7009d9b8: e7ff         	b	0x7009d9ba <Udma_chFreeResource+0x14a> @ imm = #-0x2
7009d9ba: e7ff         	b	0x7009d9bc <Udma_chFreeResource+0x14c> @ imm = #-0x2
7009d9bc: e7ff         	b	0x7009d9be <Udma_chFreeResource+0x14e> @ imm = #-0x2
;             chHandle->rxChNum = UDMA_DMA_CH_INVALID;
7009d9be: 9903         	ldr	r1, [sp, #0xc]
7009d9c0: 2000         	movs	r0, #0x0
7009d9c2: f6cf 70ff    	movt	r0, #0xffff
7009d9c6: 6708         	str	r0, [r1, #0x70]
;         }
7009d9c8: e7ff         	b	0x7009d9ca <Udma_chFreeResource+0x15a> @ imm = #-0x2
;         chHandle->defaultFlowObj.drvHandle    = (Udma_DrvHandleInt) NULL_PTR;
7009d9ca: 9903         	ldr	r1, [sp, #0xc]
7009d9cc: 2000         	movs	r0, #0x0
7009d9ce: f8c1 01cc    	str.w	r0, [r1, #0x1cc]
;         chHandle->defaultFlowObj.flowStart    = UDMA_FLOW_INVALID;
7009d9d2: 9a03         	ldr	r2, [sp, #0xc]
7009d9d4: 2100         	movs	r1, #0x0
7009d9d6: f6cf 71ff    	movt	r1, #0xffff
7009d9da: f8c2 11d0    	str.w	r1, [r2, #0x1d0]
;         chHandle->defaultFlowObj.flowCnt      = 0U;
7009d9de: 9903         	ldr	r1, [sp, #0xc]
7009d9e0: f8c1 01d4    	str.w	r0, [r1, #0x1d4]
;         chHandle->defaultFlowObj.flowInitDone = UDMA_DEINIT_DONE;
7009d9e4: 9903         	ldr	r1, [sp, #0xc]
7009d9e6: f8c1 01d8    	str.w	r0, [r1, #0x1d8]
;         chHandle->defaultFlow                 = (Udma_FlowHandleInt) NULL_PTR;
7009d9ea: 9903         	ldr	r1, [sp, #0xc]
7009d9ec: f8c1 01c8    	str.w	r0, [r1, #0x1c8]
7009d9f0: e7ff         	b	0x7009d9f2 <Udma_chFreeResource+0x182> @ imm = #-0x2
;     chHandle->pdmaChNum = UDMA_DMA_CH_INVALID;
7009d9f2: 9903         	ldr	r1, [sp, #0xc]
7009d9f4: 2000         	movs	r0, #0x0
7009d9f6: f6cf 70ff    	movt	r0, #0xffff
7009d9fa: 6788         	str	r0, [r1, #0x78]
;     chHandle->peerThreadId = UDMA_THREAD_ID_INVALID;
7009d9fc: 9903         	ldr	r1, [sp, #0xc]
7009d9fe: 2004         	movs	r0, #0x4
7009da00: f6cf 70ff    	movt	r0, #0xffff
7009da04: 67c8         	str	r0, [r1, #0x7c]
;     if(NULL_PTR != chHandle->fqRing)
7009da06: 9803         	ldr	r0, [sp, #0xc]
7009da08: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009da0c: b190         	cbz	r0, 0x7009da34 <Udma_chFreeResource+0x1c4> @ imm = #0x24
7009da0e: e7ff         	b	0x7009da10 <Udma_chFreeResource+0x1a0> @ imm = #-0x2
;         retVal += Udma_ringFree(chHandle->fqRing);
7009da10: 9803         	ldr	r0, [sp, #0xc]
7009da12: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009da16: f007 fd5b    	bl	0x700a54d0 <Udma_ringFree> @ imm = #0x7ab6
7009da1a: 4601         	mov	r1, r0
7009da1c: 9802         	ldr	r0, [sp, #0x8]
7009da1e: 4408         	add	r0, r1
7009da20: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
7009da22: 9802         	ldr	r0, [sp, #0x8]
7009da24: b108         	cbz	r0, 0x7009da2a <Udma_chFreeResource+0x1ba> @ imm = #0x2
7009da26: e7ff         	b	0x7009da28 <Udma_chFreeResource+0x1b8> @ imm = #-0x2
;         }
7009da28: e7ff         	b	0x7009da2a <Udma_chFreeResource+0x1ba> @ imm = #-0x2
;         chHandle->fqRing = (Udma_RingHandleInt) NULL_PTR;
7009da2a: 9903         	ldr	r1, [sp, #0xc]
7009da2c: 2000         	movs	r0, #0x0
7009da2e: f8c1 0080    	str.w	r0, [r1, #0x80]
;     }
7009da32: e7ff         	b	0x7009da34 <Udma_chFreeResource+0x1c4> @ imm = #-0x2
;     if(NULL_PTR != chHandle->cqRing)
7009da34: 9803         	ldr	r0, [sp, #0xc]
7009da36: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009da3a: b128         	cbz	r0, 0x7009da48 <Udma_chFreeResource+0x1d8> @ imm = #0xa
7009da3c: e7ff         	b	0x7009da3e <Udma_chFreeResource+0x1ce> @ imm = #-0x2
;         chHandle->cqRing = (Udma_RingHandleInt) NULL_PTR;
7009da3e: 9903         	ldr	r1, [sp, #0xc]
7009da40: 2000         	movs	r0, #0x0
7009da42: f8c1 0084    	str.w	r0, [r1, #0x84]
;     }
7009da46: e7ff         	b	0x7009da48 <Udma_chFreeResource+0x1d8> @ imm = #-0x2
;     if(NULL_PTR != chHandle->tdCqRing)
7009da48: 9803         	ldr	r0, [sp, #0xc]
7009da4a: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009da4e: b190         	cbz	r0, 0x7009da76 <Udma_chFreeResource+0x206> @ imm = #0x24
7009da50: e7ff         	b	0x7009da52 <Udma_chFreeResource+0x1e2> @ imm = #-0x2
;         retVal += Udma_ringFree(chHandle->tdCqRing);
7009da52: 9803         	ldr	r0, [sp, #0xc]
7009da54: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009da58: f007 fd3a    	bl	0x700a54d0 <Udma_ringFree> @ imm = #0x7a74
7009da5c: 4601         	mov	r1, r0
7009da5e: 9802         	ldr	r0, [sp, #0x8]
7009da60: 4408         	add	r0, r1
7009da62: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
7009da64: 9802         	ldr	r0, [sp, #0x8]
7009da66: b108         	cbz	r0, 0x7009da6c <Udma_chFreeResource+0x1fc> @ imm = #0x2
7009da68: e7ff         	b	0x7009da6a <Udma_chFreeResource+0x1fa> @ imm = #-0x2
;         }
7009da6a: e7ff         	b	0x7009da6c <Udma_chFreeResource+0x1fc> @ imm = #-0x2
;         chHandle->tdCqRing = (Udma_RingHandleInt) NULL_PTR;
7009da6c: 9903         	ldr	r1, [sp, #0xc]
7009da6e: 2000         	movs	r0, #0x0
7009da70: f8c1 0088    	str.w	r0, [r1, #0x88]
;     }
7009da74: e7ff         	b	0x7009da76 <Udma_chFreeResource+0x206> @ imm = #-0x2
;     return (retVal);
7009da76: 9802         	ldr	r0, [sp, #0x8]
7009da78: b004         	add	sp, #0x10
7009da7a: bd80         	pop	{r7, pc}
7009da7c: 0000         	movs	r0, r0
7009da7e: 0000         	movs	r0, r0

7009da80 <Udma_ringAlloc>:
; {
7009da80: b580         	push	{r7, lr}
7009da82: b096         	sub	sp, #0x58
7009da84: 9015         	str	r0, [sp, #0x54]
7009da86: 9114         	str	r1, [sp, #0x50]
7009da88: f8ad 204e    	strh.w	r2, [sp, #0x4e]
7009da8c: 9312         	str	r3, [sp, #0x48]
7009da8e: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009da90: 9011         	str	r0, [sp, #0x44]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009da92: 900d         	str	r0, [sp, #0x34]
;     Udma_DrvHandleInt   drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009da94: 9815         	ldr	r0, [sp, #0x54]
7009da96: 900c         	str	r0, [sp, #0x30]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
7009da98: 9814         	ldr	r0, [sp, #0x50]
7009da9a: 900b         	str	r0, [sp, #0x2c]
;     if((NULL_PTR == drvHandleInt) ||
7009da9c: 980c         	ldr	r0, [sp, #0x30]
7009da9e: b130         	cbz	r0, 0x7009daae <Udma_ringAlloc+0x2e> @ imm = #0xc
7009daa0: e7ff         	b	0x7009daa2 <Udma_ringAlloc+0x22> @ imm = #-0x2
;        (NULL_PTR == ringHandleInt) ||
7009daa2: 980b         	ldr	r0, [sp, #0x2c]
7009daa4: b118         	cbz	r0, 0x7009daae <Udma_ringAlloc+0x2e> @ imm = #0x6
7009daa6: e7ff         	b	0x7009daa8 <Udma_ringAlloc+0x28> @ imm = #-0x2
;        (NULL_PTR == ringPrms))
7009daa8: 9812         	ldr	r0, [sp, #0x48]
;     if((NULL_PTR == drvHandleInt) ||
7009daaa: b920         	cbnz	r0, 0x7009dab6 <Udma_ringAlloc+0x36> @ imm = #0x8
7009daac: e7ff         	b	0x7009daae <Udma_ringAlloc+0x2e> @ imm = #-0x2
7009daae: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009dab2: 9011         	str	r0, [sp, #0x44]
;     }
7009dab4: e7ff         	b	0x7009dab6 <Udma_ringAlloc+0x36> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dab6: 9811         	ldr	r0, [sp, #0x44]
7009dab8: b978         	cbnz	r0, 0x7009dada <Udma_ringAlloc+0x5a> @ imm = #0x1e
7009daba: e7ff         	b	0x7009dabc <Udma_ringAlloc+0x3c> @ imm = #-0x2
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009dabc: 980c         	ldr	r0, [sp, #0x30]
7009dabe: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009dac2: f64a 31cd    	movw	r1, #0xabcd
7009dac6: f6ca 31dc    	movt	r1, #0xabdc
7009daca: 4288         	cmp	r0, r1
7009dacc: d004         	beq	0x7009dad8 <Udma_ringAlloc+0x58> @ imm = #0x8
7009dace: e7ff         	b	0x7009dad0 <Udma_ringAlloc+0x50> @ imm = #-0x2
7009dad0: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009dad4: 9011         	str	r0, [sp, #0x44]
;         }
7009dad6: e7ff         	b	0x7009dad8 <Udma_ringAlloc+0x58> @ imm = #-0x2
;     }
7009dad8: e7ff         	b	0x7009dada <Udma_ringAlloc+0x5a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dada: 9811         	ldr	r0, [sp, #0x44]
7009dadc: b930         	cbnz	r0, 0x7009daec <Udma_ringAlloc+0x6c> @ imm = #0xc
7009dade: e7ff         	b	0x7009dae0 <Udma_ringAlloc+0x60> @ imm = #-0x2
;         retVal = Udma_ringCheckParams(drvHandleInt, ringPrms);
7009dae0: 980c         	ldr	r0, [sp, #0x30]
7009dae2: 9912         	ldr	r1, [sp, #0x48]
7009dae4: f007 fb54    	bl	0x700a5190 <Udma_ringCheckParams> @ imm = #0x76a8
7009dae8: 9011         	str	r0, [sp, #0x44]
;     }
7009daea: e7ff         	b	0x7009daec <Udma_ringAlloc+0x6c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009daec: 9811         	ldr	r0, [sp, #0x44]
7009daee: 2800         	cmp	r0, #0x0
7009daf0: d140         	bne	0x7009db74 <Udma_ringAlloc+0xf4> @ imm = #0x80
7009daf2: e7ff         	b	0x7009daf4 <Udma_ringAlloc+0x74> @ imm = #-0x2
;         if(UDMA_RING_ANY == ringNum)
7009daf4: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009daf8: f64f 71fe    	movw	r1, #0xfffe
7009dafc: 4288         	cmp	r0, r1
7009dafe: d126         	bne	0x7009db4e <Udma_ringAlloc+0xce> @ imm = #0x4c
7009db00: e7ff         	b	0x7009db02 <Udma_ringAlloc+0x82> @ imm = #-0x2
;             if(UDMA_MAPPED_GROUP_INVALID == ringPrms->mappedRingGrp)
7009db02: 9812         	ldr	r0, [sp, #0x48]
7009db04: 6940         	ldr	r0, [r0, #0x14]
7009db06: 2104         	movs	r1, #0x4
7009db08: f6cf 71ff    	movt	r1, #0xffff
7009db0c: 4288         	cmp	r0, r1
7009db0e: d106         	bne	0x7009db1e <Udma_ringAlloc+0x9e> @ imm = #0xc
7009db10: e7ff         	b	0x7009db12 <Udma_ringAlloc+0x92> @ imm = #-0x2
;                 ringHandleInt->ringNum = Udma_rmAllocFreeRing(drvHandleInt);
7009db12: 980c         	ldr	r0, [sp, #0x30]
7009db14: f010 f974    	bl	0x700ade00 <Udma_rmAllocFreeRing> @ imm = #0x102e8
7009db18: 990b         	ldr	r1, [sp, #0x2c]
7009db1a: 8088         	strh	r0, [r1, #0x4]
;             }
7009db1c: e008         	b	0x7009db30 <Udma_ringAlloc+0xb0> @ imm = #0x10
;                 ringHandleInt->ringNum = Udma_rmAllocMappedRing(drvHandleInt, ringPrms->mappedRingGrp, ringPrms->mappedChNum);
7009db1e: 980c         	ldr	r0, [sp, #0x30]
7009db20: 9a12         	ldr	r2, [sp, #0x48]
7009db22: 6951         	ldr	r1, [r2, #0x14]
7009db24: 6992         	ldr	r2, [r2, #0x18]
7009db26: f003 f9fb    	bl	0x700a0f20 <Udma_rmAllocMappedRing> @ imm = #0x33f6
7009db2a: 990b         	ldr	r1, [sp, #0x2c]
7009db2c: 8088         	strh	r0, [r1, #0x4]
7009db2e: e7ff         	b	0x7009db30 <Udma_ringAlloc+0xb0> @ imm = #-0x2
;             if(UDMA_RING_INVALID == ringHandleInt->ringNum)
7009db30: 980b         	ldr	r0, [sp, #0x2c]
7009db32: 8880         	ldrh	r0, [r0, #0x4]
7009db34: f64f 71ff    	movw	r1, #0xffff
7009db38: 4288         	cmp	r0, r1
7009db3a: d104         	bne	0x7009db46 <Udma_ringAlloc+0xc6> @ imm = #0x8
7009db3c: e7ff         	b	0x7009db3e <Udma_ringAlloc+0xbe> @ imm = #-0x2
7009db3e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009db42: 9011         	str	r0, [sp, #0x44]
;             }
7009db44: e002         	b	0x7009db4c <Udma_ringAlloc+0xcc> @ imm = #0x4
7009db46: 2001         	movs	r0, #0x1
;                 allocDone = (uint32_t) TRUE;
7009db48: 900d         	str	r0, [sp, #0x34]
7009db4a: e7ff         	b	0x7009db4c <Udma_ringAlloc+0xcc> @ imm = #-0x2
;         }
7009db4c: e011         	b	0x7009db72 <Udma_ringAlloc+0xf2> @ imm = #0x22
;             if(ringNum >= drvHandleInt->maxRings)
7009db4e: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009db52: 990c         	ldr	r1, [sp, #0x30]
7009db54: f8d1 10dc    	ldr.w	r1, [r1, #0xdc]
7009db58: 4288         	cmp	r0, r1
7009db5a: d304         	blo	0x7009db66 <Udma_ringAlloc+0xe6> @ imm = #0x8
7009db5c: e7ff         	b	0x7009db5e <Udma_ringAlloc+0xde> @ imm = #-0x2
7009db5e: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
7009db62: 9011         	str	r0, [sp, #0x44]
;             }
7009db64: e004         	b	0x7009db70 <Udma_ringAlloc+0xf0> @ imm = #0x8
;                 ringHandleInt->ringNum = ringNum;
7009db66: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009db6a: 990b         	ldr	r1, [sp, #0x2c]
7009db6c: 8088         	strh	r0, [r1, #0x4]
7009db6e: e7ff         	b	0x7009db70 <Udma_ringAlloc+0xf0> @ imm = #-0x2
7009db70: e7ff         	b	0x7009db72 <Udma_ringAlloc+0xf2> @ imm = #-0x2
;     }
7009db72: e7ff         	b	0x7009db74 <Udma_ringAlloc+0xf4> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009db74: 9811         	ldr	r0, [sp, #0x44]
7009db76: b9a8         	cbnz	r0, 0x7009dba4 <Udma_ringAlloc+0x124> @ imm = #0x2a
7009db78: e7ff         	b	0x7009db7a <Udma_ringAlloc+0xfa> @ imm = #-0x2
;         Udma_ringAssertFnPointers(drvHandleInt);
7009db7a: 980c         	ldr	r0, [sp, #0x30]
7009db7c: f010 fb00    	bl	0x700ae180 <Udma_ringAssertFnPointers> @ imm = #0x10600
;         ringHandleInt->drvHandle = drvHandleInt;
7009db80: 980c         	ldr	r0, [sp, #0x30]
7009db82: 990b         	ldr	r1, [sp, #0x2c]
7009db84: 6008         	str	r0, [r1]
;         ringHandleInt->mappedRingGrp   = ringPrms->mappedRingGrp;
7009db86: 9812         	ldr	r0, [sp, #0x48]
7009db88: 6940         	ldr	r0, [r0, #0x14]
7009db8a: 990b         	ldr	r1, [sp, #0x2c]
7009db8c: 65c8         	str	r0, [r1, #0x5c]
;         ringHandleInt->mappedChNum     = ringPrms->mappedChNum;
7009db8e: 9812         	ldr	r0, [sp, #0x48]
7009db90: 6980         	ldr	r0, [r0, #0x18]
7009db92: 990b         	ldr	r1, [sp, #0x2c]
7009db94: 6608         	str	r0, [r1, #0x60]
;         drvHandleInt->ringSetCfg(drvHandleInt, ringHandleInt, ringPrms);
7009db96: 980c         	ldr	r0, [sp, #0x30]
7009db98: f8d0 35c4    	ldr.w	r3, [r0, #0x5c4]
7009db9c: 990b         	ldr	r1, [sp, #0x2c]
7009db9e: 9a12         	ldr	r2, [sp, #0x48]
7009dba0: 4798         	blx	r3
;     }
7009dba2: e7ff         	b	0x7009dba4 <Udma_ringAlloc+0x124> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dba4: 9811         	ldr	r0, [sp, #0x44]
7009dba6: 2800         	cmp	r0, #0x0
7009dba8: d146         	bne	0x7009dc38 <Udma_ringAlloc+0x1b8> @ imm = #0x8c
7009dbaa: e7ff         	b	0x7009dbac <Udma_ringAlloc+0x12c> @ imm = #-0x2
7009dbac: 20bf         	movs	r0, #0xbf
;         rmRingReq.valid_params  = TISCI_MSG_VALUE_RM_RING_ADDR_LO_VALID |
7009dbae: 9004         	str	r0, [sp, #0x10]
;         rmRingReq.nav_id        = drvHandleInt->devIdRing;
7009dbb0: 980c         	ldr	r0, [sp, #0x30]
7009dbb2: f8b0 00e0    	ldrh.w	r0, [r0, #0xe0]
7009dbb6: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmRingReq.index         = ringHandleInt->ringNum;
7009dbba: 980b         	ldr	r0, [sp, #0x2c]
7009dbbc: 8880         	ldrh	r0, [r0, #0x4]
7009dbbe: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         physBase = Udma_virtToPhyFxn(ringPrms->ringMem, drvHandleInt, (Udma_ChHandleInt) NULL_PTR);
7009dbc2: 9812         	ldr	r0, [sp, #0x48]
7009dbc4: 6800         	ldr	r0, [r0]
7009dbc6: 990c         	ldr	r1, [sp, #0x30]
7009dbc8: 2200         	movs	r2, #0x0
7009dbca: f00c fe69    	bl	0x700aa8a0 <Udma_virtToPhyFxn> @ imm = #0xccd2
7009dbce: 910f         	str	r1, [sp, #0x3c]
7009dbd0: 900e         	str	r0, [sp, #0x38]
;         rmRingReq.addr_lo       = (uint32_t)physBase;
7009dbd2: 980e         	ldr	r0, [sp, #0x38]
7009dbd4: 9006         	str	r0, [sp, #0x18]
;         rmRingReq.addr_hi       = (uint32_t)(physBase >> 32UL);
7009dbd6: 980f         	ldr	r0, [sp, #0x3c]
7009dbd8: 9007         	str	r0, [sp, #0x1c]
;         rmRingReq.count         = ringPrms->elemCnt;
7009dbda: 9812         	ldr	r0, [sp, #0x48]
7009dbdc: 68c0         	ldr	r0, [r0, #0xc]
7009dbde: 9008         	str	r0, [sp, #0x20]
;         rmRingReq.mode          = ringPrms->mode;
7009dbe0: 9812         	ldr	r0, [sp, #0x48]
7009dbe2: 7a00         	ldrb	r0, [r0, #0x8]
7009dbe4: f88d 0024    	strb.w	r0, [sp, #0x24]
;         rmRingReq.size          = ringPrms->elemSize;
7009dbe8: 9812         	ldr	r0, [sp, #0x48]
7009dbea: 7c00         	ldrb	r0, [r0, #0x10]
7009dbec: f88d 0025    	strb.w	r0, [sp, #0x25]
;         rmRingReq.order_id      = ringPrms->orderId;
7009dbf0: 9812         	ldr	r0, [sp, #0x48]
7009dbf2: 7c40         	ldrb	r0, [r0, #0x11]
7009dbf4: f88d 0026    	strb.w	r0, [sp, #0x26]
;         rmRingReq.asel          = ringPrms->asel;
7009dbf8: 9812         	ldr	r0, [sp, #0x48]
7009dbfa: 7c80         	ldrb	r0, [r0, #0x12]
7009dbfc: f88d 0029    	strb.w	r0, [sp, #0x29]
;         if(UDMA_RING_VIRTID_INVALID != ringPrms->virtId)
7009dc00: 9812         	ldr	r0, [sp, #0x48]
7009dc02: 8940         	ldrh	r0, [r0, #0xa]
7009dc04: f64f 71ff    	movw	r1, #0xffff
7009dc08: 4288         	cmp	r0, r1
7009dc0a: d009         	beq	0x7009dc20 <Udma_ringAlloc+0x1a0> @ imm = #0x12
7009dc0c: e7ff         	b	0x7009dc0e <Udma_ringAlloc+0x18e> @ imm = #-0x2
;             rmRingReq.valid_params |= TISCI_MSG_VALUE_RM_RING_VIRTID_VALID;
7009dc0e: 9804         	ldr	r0, [sp, #0x10]
7009dc10: f040 0040    	orr	r0, r0, #0x40
7009dc14: 9004         	str	r0, [sp, #0x10]
;             rmRingReq.virtid        = ringPrms->virtId;
7009dc16: 9812         	ldr	r0, [sp, #0x48]
7009dc18: 8940         	ldrh	r0, [r0, #0xa]
7009dc1a: f8ad 0027    	strh.w	r0, [sp, #0x27]
;         }
7009dc1e: e7ff         	b	0x7009dc20 <Udma_ringAlloc+0x1a0> @ imm = #-0x2
7009dc20: a802         	add	r0, sp, #0x8
7009dc22: 4669         	mov	r1, sp
7009dc24: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmRingCfg(
7009dc28: f00d f87a    	bl	0x700aad20 <Sciclient_rmRingCfg> @ imm = #0xd0f4
7009dc2c: 9011         	str	r0, [sp, #0x44]
;         if(CSL_PASS != retVal)
7009dc2e: 9811         	ldr	r0, [sp, #0x44]
7009dc30: b108         	cbz	r0, 0x7009dc36 <Udma_ringAlloc+0x1b6> @ imm = #0x2
7009dc32: e7ff         	b	0x7009dc34 <Udma_ringAlloc+0x1b4> @ imm = #-0x2
;         }
7009dc34: e7ff         	b	0x7009dc36 <Udma_ringAlloc+0x1b6> @ imm = #-0x2
;     }
7009dc36: e7ff         	b	0x7009dc38 <Udma_ringAlloc+0x1b8> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dc38: 9811         	ldr	r0, [sp, #0x44]
7009dc3a: b938         	cbnz	r0, 0x7009dc4c <Udma_ringAlloc+0x1cc> @ imm = #0xe
7009dc3c: e7ff         	b	0x7009dc3e <Udma_ringAlloc+0x1be> @ imm = #-0x2
;         ringHandleInt->ringInitDone = UDMA_INIT_DONE;
7009dc3e: 990b         	ldr	r1, [sp, #0x2c]
7009dc40: f64a 30cd    	movw	r0, #0xabcd
7009dc44: f6ca 30dc    	movt	r0, #0xabdc
7009dc48: 6588         	str	r0, [r1, #0x58]
;     }
7009dc4a: e01b         	b	0x7009dc84 <Udma_ringAlloc+0x204> @ imm = #0x36
;         if(((uint32_t) TRUE) == allocDone)
7009dc4c: 980d         	ldr	r0, [sp, #0x34]
7009dc4e: 2801         	cmp	r0, #0x1
7009dc50: d117         	bne	0x7009dc82 <Udma_ringAlloc+0x202> @ imm = #0x2e
7009dc52: e7ff         	b	0x7009dc54 <Udma_ringAlloc+0x1d4> @ imm = #-0x2
;             if(UDMA_MAPPED_GROUP_INVALID == ringPrms->mappedRingGrp)
7009dc54: 9812         	ldr	r0, [sp, #0x48]
7009dc56: 6940         	ldr	r0, [r0, #0x14]
7009dc58: 2104         	movs	r1, #0x4
7009dc5a: f6cf 71ff    	movt	r1, #0xffff
7009dc5e: 4288         	cmp	r0, r1
7009dc60: d106         	bne	0x7009dc70 <Udma_ringAlloc+0x1f0> @ imm = #0xc
7009dc62: e7ff         	b	0x7009dc64 <Udma_ringAlloc+0x1e4> @ imm = #-0x2
;                 Udma_rmFreeFreeRing(ringHandleInt->ringNum, drvHandleInt);
7009dc64: 980b         	ldr	r0, [sp, #0x2c]
7009dc66: 8880         	ldrh	r0, [r0, #0x4]
7009dc68: 990c         	ldr	r1, [sp, #0x30]
7009dc6a: f010 fa49    	bl	0x700ae100 <Udma_rmFreeFreeRing> @ imm = #0x10492
;             }
7009dc6e: e007         	b	0x7009dc80 <Udma_ringAlloc+0x200> @ imm = #0xe
;                 Udma_rmFreeMappedRing(ringHandleInt->ringNum, drvHandleInt, ringHandleInt->mappedRingGrp, ringHandleInt->mappedChNum);
7009dc70: 9b0b         	ldr	r3, [sp, #0x2c]
7009dc72: 8898         	ldrh	r0, [r3, #0x4]
7009dc74: 990c         	ldr	r1, [sp, #0x30]
7009dc76: 6dda         	ldr	r2, [r3, #0x5c]
7009dc78: 6e1b         	ldr	r3, [r3, #0x60]
7009dc7a: f00a fae9    	bl	0x700a8250 <Udma_rmFreeMappedRing> @ imm = #0xa5d2
7009dc7e: e7ff         	b	0x7009dc80 <Udma_ringAlloc+0x200> @ imm = #-0x2
;         }
7009dc80: e7ff         	b	0x7009dc82 <Udma_ringAlloc+0x202> @ imm = #-0x2
7009dc82: e7ff         	b	0x7009dc84 <Udma_ringAlloc+0x204> @ imm = #-0x2
;     return (retVal);
7009dc84: 9811         	ldr	r0, [sp, #0x44]
7009dc86: b016         	add	sp, #0x58
7009dc88: bd80         	pop	{r7, pc}
7009dc8a: 0000         	movs	r0, r0
7009dc8c: 0000         	movs	r0, r0
7009dc8e: 0000         	movs	r0, r0

7009dc90 <Udma_chDisableBlkCpyChan>:
; {
7009dc90: b580         	push	{r7, lr}
7009dc92: b090         	sub	sp, #0x40
7009dc94: 900f         	str	r0, [sp, #0x3c]
7009dc96: 910e         	str	r1, [sp, #0x38]
7009dc98: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009dc9a: 900d         	str	r0, [sp, #0x34]
;     uint32_t            currTimeout = 0U;
7009dc9c: 900c         	str	r0, [sp, #0x30]
;     drvHandle = chHandle->drvHandle;
7009dc9e: 980f         	ldr	r0, [sp, #0x3c]
7009dca0: 6e80         	ldr	r0, [r0, #0x68]
7009dca2: 900b         	str	r0, [sp, #0x2c]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009dca4: 980b         	ldr	r0, [sp, #0x2c]
7009dca6: 6800         	ldr	r0, [r0]
7009dca8: 2801         	cmp	r0, #0x1
7009dcaa: d10a         	bne	0x7009dcc2 <Udma_chDisableBlkCpyChan+0x32> @ imm = #0x14
7009dcac: e7ff         	b	0x7009dcae <Udma_chDisableBlkCpyChan+0x1e> @ imm = #-0x2
;                  &drvHandle->bcdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009dcae: 980b         	ldr	r0, [sp, #0x2c]
7009dcb0: 3008         	adds	r0, #0x8
7009dcb2: 990f         	ldr	r1, [sp, #0x3c]
7009dcb4: 6ec9         	ldr	r1, [r1, #0x6c]
7009dcb6: 2300         	movs	r3, #0x0
;         retVal = CSL_bcdmaTeardownTxChan(
7009dcb8: 461a         	mov	r2, r3
7009dcba: f00d ff69    	bl	0x700abb90 <CSL_bcdmaTeardownTxChan> @ imm = #0xded2
7009dcbe: 900d         	str	r0, [sp, #0x34]
;     }
7009dcc0: e00f         	b	0x7009dce2 <Udma_chDisableBlkCpyChan+0x52> @ imm = #0x1e
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009dcc2: 980b         	ldr	r0, [sp, #0x2c]
7009dcc4: 6800         	ldr	r0, [r0]
7009dcc6: 2802         	cmp	r0, #0x2
7009dcc8: d10a         	bne	0x7009dce0 <Udma_chDisableBlkCpyChan+0x50> @ imm = #0x14
7009dcca: e7ff         	b	0x7009dccc <Udma_chDisableBlkCpyChan+0x3c> @ imm = #-0x2
;                  &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009dccc: 980b         	ldr	r0, [sp, #0x2c]
7009dcce: 3054         	adds	r0, #0x54
7009dcd0: 990f         	ldr	r1, [sp, #0x3c]
7009dcd2: 6ec9         	ldr	r1, [r1, #0x6c]
7009dcd4: 2300         	movs	r3, #0x0
;         retVal = CSL_pktdmaTeardownTxChan(
7009dcd6: 461a         	mov	r2, r3
7009dcd8: f00e fe22    	bl	0x700ac920 <CSL_pktdmaTeardownTxChan> @ imm = #0xec44
7009dcdc: 900d         	str	r0, [sp, #0x34]
;     }
7009dcde: e7ff         	b	0x7009dce0 <Udma_chDisableBlkCpyChan+0x50> @ imm = #-0x2
7009dce0: e7ff         	b	0x7009dce2 <Udma_chDisableBlkCpyChan+0x52> @ imm = #-0x2
;     if(CSL_PASS != retVal)
7009dce2: 980d         	ldr	r0, [sp, #0x34]
7009dce4: b108         	cbz	r0, 0x7009dcea <Udma_chDisableBlkCpyChan+0x5a> @ imm = #0x2
7009dce6: e7ff         	b	0x7009dce8 <Udma_chDisableBlkCpyChan+0x58> @ imm = #-0x2
;     }
7009dce8: e7ff         	b	0x7009dcea <Udma_chDisableBlkCpyChan+0x5a> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009dcea: e7ff         	b	0x7009dcec <Udma_chDisableBlkCpyChan+0x5c> @ imm = #-0x2
7009dcec: 980d         	ldr	r0, [sp, #0x34]
7009dcee: bba8         	cbnz	r0, 0x7009dd5c <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x6a
7009dcf0: e7ff         	b	0x7009dcf2 <Udma_chDisableBlkCpyChan+0x62> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009dcf2: 980b         	ldr	r0, [sp, #0x2c]
7009dcf4: 6800         	ldr	r0, [r0]
7009dcf6: 2801         	cmp	r0, #0x1
7009dcf8: d10c         	bne	0x7009dd14 <Udma_chDisableBlkCpyChan+0x84> @ imm = #0x18
7009dcfa: e7ff         	b	0x7009dcfc <Udma_chDisableBlkCpyChan+0x6c> @ imm = #-0x2
;             (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009dcfc: 980b         	ldr	r0, [sp, #0x2c]
7009dcfe: 3008         	adds	r0, #0x8
7009dd00: 990f         	ldr	r1, [sp, #0x3c]
7009dd02: 6ec9         	ldr	r1, [r1, #0x6c]
7009dd04: aa05         	add	r2, sp, #0x14
7009dd06: f00f f90b    	bl	0x700acf20 <CSL_bcdmaGetTxRT> @ imm = #0xf216
;             if(FALSE == bcdmaRtStatus.enable)
7009dd0a: 9805         	ldr	r0, [sp, #0x14]
7009dd0c: b908         	cbnz	r0, 0x7009dd12 <Udma_chDisableBlkCpyChan+0x82> @ imm = #0x2
7009dd0e: e7ff         	b	0x7009dd10 <Udma_chDisableBlkCpyChan+0x80> @ imm = #-0x2
;                 break;
7009dd10: e024         	b	0x7009dd5c <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x48
;         }
7009dd12: e011         	b	0x7009dd38 <Udma_chDisableBlkCpyChan+0xa8> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009dd14: 980b         	ldr	r0, [sp, #0x2c]
7009dd16: 6800         	ldr	r0, [r0]
7009dd18: 2802         	cmp	r0, #0x2
7009dd1a: d10c         	bne	0x7009dd36 <Udma_chDisableBlkCpyChan+0xa6> @ imm = #0x18
7009dd1c: e7ff         	b	0x7009dd1e <Udma_chDisableBlkCpyChan+0x8e> @ imm = #-0x2
;             (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009dd1e: 980b         	ldr	r0, [sp, #0x2c]
7009dd20: 3054         	adds	r0, #0x54
7009dd22: 990f         	ldr	r1, [sp, #0x3c]
7009dd24: 6ec9         	ldr	r1, [r1, #0x6c]
7009dd26: 466a         	mov	r2, sp
7009dd28: f00d fda2    	bl	0x700ab870 <CSL_pktdmaGetTxRT> @ imm = #0xdb44
;             if(FALSE == pktdmaRtStatus.enable)
7009dd2c: 9800         	ldr	r0, [sp]
7009dd2e: b908         	cbnz	r0, 0x7009dd34 <Udma_chDisableBlkCpyChan+0xa4> @ imm = #0x2
7009dd30: e7ff         	b	0x7009dd32 <Udma_chDisableBlkCpyChan+0xa2> @ imm = #-0x2
;                 break;
7009dd32: e013         	b	0x7009dd5c <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x26
;         }
7009dd34: e7ff         	b	0x7009dd36 <Udma_chDisableBlkCpyChan+0xa6> @ imm = #-0x2
7009dd36: e7ff         	b	0x7009dd38 <Udma_chDisableBlkCpyChan+0xa8> @ imm = #-0x2
;         if(currTimeout > timeout)
7009dd38: 980c         	ldr	r0, [sp, #0x30]
7009dd3a: 990e         	ldr	r1, [sp, #0x38]
7009dd3c: 4288         	cmp	r0, r1
7009dd3e: d904         	bls	0x7009dd4a <Udma_chDisableBlkCpyChan+0xba> @ imm = #0x8
7009dd40: e7ff         	b	0x7009dd42 <Udma_chDisableBlkCpyChan+0xb2> @ imm = #-0x2
7009dd42: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009dd46: 900d         	str	r0, [sp, #0x34]
;         }
7009dd48: e007         	b	0x7009dd5a <Udma_chDisableBlkCpyChan+0xca> @ imm = #0xe
7009dd4a: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009dd4e: f00b fc27    	bl	0x700a95a0 <ClockP_usleep> @ imm = #0xb84e
;             currTimeout++;
7009dd52: 980c         	ldr	r0, [sp, #0x30]
7009dd54: 3001         	adds	r0, #0x1
7009dd56: 900c         	str	r0, [sp, #0x30]
7009dd58: e7ff         	b	0x7009dd5a <Udma_chDisableBlkCpyChan+0xca> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009dd5a: e7c7         	b	0x7009dcec <Udma_chDisableBlkCpyChan+0x5c> @ imm = #-0x72
;     if(UDMA_SOK != retVal)
7009dd5c: 980d         	ldr	r0, [sp, #0x34]
7009dd5e: 2800         	cmp	r0, #0x0
7009dd60: d05f         	beq	0x7009de22 <Udma_chDisableBlkCpyChan+0x192> @ imm = #0xbe
7009dd62: e7ff         	b	0x7009dd64 <Udma_chDisableBlkCpyChan+0xd4> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009dd64: 980b         	ldr	r0, [sp, #0x2c]
7009dd66: 6800         	ldr	r0, [r0]
7009dd68: 2801         	cmp	r0, #0x1
7009dd6a: d10a         	bne	0x7009dd82 <Udma_chDisableBlkCpyChan+0xf2> @ imm = #0x14
7009dd6c: e7ff         	b	0x7009dd6e <Udma_chDisableBlkCpyChan+0xde> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009dd6e: 980b         	ldr	r0, [sp, #0x2c]
7009dd70: 3008         	adds	r0, #0x8
7009dd72: 990f         	ldr	r1, [sp, #0x3c]
7009dd74: 6ec9         	ldr	r1, [r1, #0x6c]
7009dd76: 2201         	movs	r2, #0x1
7009dd78: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownTxChan(
7009dd7a: f00d ff09    	bl	0x700abb90 <CSL_bcdmaTeardownTxChan> @ imm = #0xde12
7009dd7e: 900d         	str	r0, [sp, #0x34]
;         }
7009dd80: e00f         	b	0x7009dda2 <Udma_chDisableBlkCpyChan+0x112> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009dd82: 980b         	ldr	r0, [sp, #0x2c]
7009dd84: 6800         	ldr	r0, [r0]
7009dd86: 2802         	cmp	r0, #0x2
7009dd88: d10a         	bne	0x7009dda0 <Udma_chDisableBlkCpyChan+0x110> @ imm = #0x14
7009dd8a: e7ff         	b	0x7009dd8c <Udma_chDisableBlkCpyChan+0xfc> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009dd8c: 980b         	ldr	r0, [sp, #0x2c]
7009dd8e: 3054         	adds	r0, #0x54
7009dd90: 990f         	ldr	r1, [sp, #0x3c]
7009dd92: 6ec9         	ldr	r1, [r1, #0x6c]
7009dd94: 2201         	movs	r2, #0x1
7009dd96: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownTxChan(
7009dd98: f00e fdc2    	bl	0x700ac920 <CSL_pktdmaTeardownTxChan> @ imm = #0xeb84
7009dd9c: 900d         	str	r0, [sp, #0x34]
;         }
7009dd9e: e7ff         	b	0x7009dda0 <Udma_chDisableBlkCpyChan+0x110> @ imm = #-0x2
7009dda0: e7ff         	b	0x7009dda2 <Udma_chDisableBlkCpyChan+0x112> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009dda2: 980d         	ldr	r0, [sp, #0x34]
7009dda4: b108         	cbz	r0, 0x7009ddaa <Udma_chDisableBlkCpyChan+0x11a> @ imm = #0x2
7009dda6: e7ff         	b	0x7009dda8 <Udma_chDisableBlkCpyChan+0x118> @ imm = #-0x2
;         }
7009dda8: e7ff         	b	0x7009ddaa <Udma_chDisableBlkCpyChan+0x11a> @ imm = #-0x2
7009ddaa: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009ddac: 900c         	str	r0, [sp, #0x30]
;         while(UDMA_SOK == retVal)
7009ddae: e7ff         	b	0x7009ddb0 <Udma_chDisableBlkCpyChan+0x120> @ imm = #-0x2
7009ddb0: 980d         	ldr	r0, [sp, #0x34]
7009ddb2: bba8         	cbnz	r0, 0x7009de20 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x6a
7009ddb4: e7ff         	b	0x7009ddb6 <Udma_chDisableBlkCpyChan+0x126> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009ddb6: 980b         	ldr	r0, [sp, #0x2c]
7009ddb8: 6800         	ldr	r0, [r0]
7009ddba: 2801         	cmp	r0, #0x1
7009ddbc: d10c         	bne	0x7009ddd8 <Udma_chDisableBlkCpyChan+0x148> @ imm = #0x18
7009ddbe: e7ff         	b	0x7009ddc0 <Udma_chDisableBlkCpyChan+0x130> @ imm = #-0x2
;                 (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009ddc0: 980b         	ldr	r0, [sp, #0x2c]
7009ddc2: 3008         	adds	r0, #0x8
7009ddc4: 990f         	ldr	r1, [sp, #0x3c]
7009ddc6: 6ec9         	ldr	r1, [r1, #0x6c]
7009ddc8: aa05         	add	r2, sp, #0x14
7009ddca: f00f f8a9    	bl	0x700acf20 <CSL_bcdmaGetTxRT> @ imm = #0xf152
;                 if(FALSE == bcdmaRtStatus.enable)
7009ddce: 9805         	ldr	r0, [sp, #0x14]
7009ddd0: b908         	cbnz	r0, 0x7009ddd6 <Udma_chDisableBlkCpyChan+0x146> @ imm = #0x2
7009ddd2: e7ff         	b	0x7009ddd4 <Udma_chDisableBlkCpyChan+0x144> @ imm = #-0x2
;                     break;
7009ddd4: e024         	b	0x7009de20 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x48
;             }
7009ddd6: e011         	b	0x7009ddfc <Udma_chDisableBlkCpyChan+0x16c> @ imm = #0x22
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009ddd8: 980b         	ldr	r0, [sp, #0x2c]
7009ddda: 6800         	ldr	r0, [r0]
7009dddc: 2802         	cmp	r0, #0x2
7009ddde: d10c         	bne	0x7009ddfa <Udma_chDisableBlkCpyChan+0x16a> @ imm = #0x18
7009dde0: e7ff         	b	0x7009dde2 <Udma_chDisableBlkCpyChan+0x152> @ imm = #-0x2
;                 (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009dde2: 980b         	ldr	r0, [sp, #0x2c]
7009dde4: 3054         	adds	r0, #0x54
7009dde6: 990f         	ldr	r1, [sp, #0x3c]
7009dde8: 6ec9         	ldr	r1, [r1, #0x6c]
7009ddea: 466a         	mov	r2, sp
7009ddec: f00d fd40    	bl	0x700ab870 <CSL_pktdmaGetTxRT> @ imm = #0xda80
;                 if(FALSE == pktdmaRtStatus.enable)
7009ddf0: 9800         	ldr	r0, [sp]
7009ddf2: b908         	cbnz	r0, 0x7009ddf8 <Udma_chDisableBlkCpyChan+0x168> @ imm = #0x2
7009ddf4: e7ff         	b	0x7009ddf6 <Udma_chDisableBlkCpyChan+0x166> @ imm = #-0x2
;                     break;
7009ddf6: e013         	b	0x7009de20 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x26
;             }
7009ddf8: e7ff         	b	0x7009ddfa <Udma_chDisableBlkCpyChan+0x16a> @ imm = #-0x2
7009ddfa: e7ff         	b	0x7009ddfc <Udma_chDisableBlkCpyChan+0x16c> @ imm = #-0x2
;             if(currTimeout > timeout)
7009ddfc: 980c         	ldr	r0, [sp, #0x30]
7009ddfe: 990e         	ldr	r1, [sp, #0x38]
7009de00: 4288         	cmp	r0, r1
7009de02: d904         	bls	0x7009de0e <Udma_chDisableBlkCpyChan+0x17e> @ imm = #0x8
7009de04: e7ff         	b	0x7009de06 <Udma_chDisableBlkCpyChan+0x176> @ imm = #-0x2
7009de06: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009de0a: 900d         	str	r0, [sp, #0x34]
;             }
7009de0c: e007         	b	0x7009de1e <Udma_chDisableBlkCpyChan+0x18e> @ imm = #0xe
7009de0e: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009de12: f00b fbc5    	bl	0x700a95a0 <ClockP_usleep> @ imm = #0xb78a
;                 currTimeout++;
7009de16: 980c         	ldr	r0, [sp, #0x30]
7009de18: 3001         	adds	r0, #0x1
7009de1a: 900c         	str	r0, [sp, #0x30]
7009de1c: e7ff         	b	0x7009de1e <Udma_chDisableBlkCpyChan+0x18e> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009de1e: e7c7         	b	0x7009ddb0 <Udma_chDisableBlkCpyChan+0x120> @ imm = #-0x72
;     }
7009de20: e7ff         	b	0x7009de22 <Udma_chDisableBlkCpyChan+0x192> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009de22: 980d         	ldr	r0, [sp, #0x34]
7009de24: bb20         	cbnz	r0, 0x7009de70 <Udma_chDisableBlkCpyChan+0x1e0> @ imm = #0x48
7009de26: e7ff         	b	0x7009de28 <Udma_chDisableBlkCpyChan+0x198> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009de28: 980b         	ldr	r0, [sp, #0x2c]
7009de2a: 6800         	ldr	r0, [r0]
7009de2c: 2801         	cmp	r0, #0x1
7009de2e: d10c         	bne	0x7009de4a <Udma_chDisableBlkCpyChan+0x1ba> @ imm = #0x18
7009de30: e7ff         	b	0x7009de32 <Udma_chDisableBlkCpyChan+0x1a2> @ imm = #-0x2
7009de32: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.enable   = FALSE;
7009de34: 9005         	str	r0, [sp, #0x14]
;             bcdmaRtStatus.teardown = FALSE;
7009de36: 9006         	str	r0, [sp, #0x18]
;             bcdmaRtStatus.forcedTeardown = FALSE;
7009de38: 9009         	str	r0, [sp, #0x24]
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009de3a: 980b         	ldr	r0, [sp, #0x2c]
7009de3c: 3008         	adds	r0, #0x8
7009de3e: 990f         	ldr	r1, [sp, #0x3c]
7009de40: 6ec9         	ldr	r1, [r1, #0x6c]
7009de42: aa05         	add	r2, sp, #0x14
7009de44: f00f f89c    	bl	0x700acf80 <CSL_bcdmaSetTxRT> @ imm = #0xf138
;         }
7009de48: e011         	b	0x7009de6e <Udma_chDisableBlkCpyChan+0x1de> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009de4a: 980b         	ldr	r0, [sp, #0x2c]
7009de4c: 6800         	ldr	r0, [r0]
7009de4e: 2802         	cmp	r0, #0x2
7009de50: d10c         	bne	0x7009de6c <Udma_chDisableBlkCpyChan+0x1dc> @ imm = #0x18
7009de52: e7ff         	b	0x7009de54 <Udma_chDisableBlkCpyChan+0x1c4> @ imm = #-0x2
7009de54: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.enable   = FALSE;
7009de56: 9000         	str	r0, [sp]
;             pktdmaRtStatus.teardown = FALSE;
7009de58: 9001         	str	r0, [sp, #0x4]
;             pktdmaRtStatus.forcedTeardown = FALSE;
7009de5a: 9004         	str	r0, [sp, #0x10]
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009de5c: 980b         	ldr	r0, [sp, #0x2c]
7009de5e: 3054         	adds	r0, #0x54
7009de60: 990f         	ldr	r1, [sp, #0x3c]
7009de62: 6ec9         	ldr	r1, [r1, #0x6c]
7009de64: 466a         	mov	r2, sp
7009de66: f00e fabb    	bl	0x700ac3e0 <CSL_pktdmaSetTxRT> @ imm = #0xe576
;         }
7009de6a: e7ff         	b	0x7009de6c <Udma_chDisableBlkCpyChan+0x1dc> @ imm = #-0x2
7009de6c: e7ff         	b	0x7009de6e <Udma_chDisableBlkCpyChan+0x1de> @ imm = #-0x2
;     }
7009de6e: e7ff         	b	0x7009de70 <Udma_chDisableBlkCpyChan+0x1e0> @ imm = #-0x2
;     return (retVal);
7009de70: 980d         	ldr	r0, [sp, #0x34]
7009de72: b010         	add	sp, #0x40
7009de74: bd80         	pop	{r7, pc}
		...
7009de7e: 0000         	movs	r0, r0

7009de80 <Udma_flowConfig>:
; {
7009de80: b580         	push	{r7, lr}
7009de82: b09e         	sub	sp, #0x78
7009de84: 901d         	str	r0, [sp, #0x74]
7009de86: 911c         	str	r1, [sp, #0x70]
7009de88: 921b         	str	r2, [sp, #0x6c]
7009de8a: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009de8c: 901a         	str	r0, [sp, #0x68]
;     Udma_FlowHandleInt  flowHandleInt = (Udma_FlowHandleInt) flowHandle;
7009de8e: 981d         	ldr	r0, [sp, #0x74]
7009de90: 9018         	str	r0, [sp, #0x60]
;     if((NULL_PTR == flowHandleInt) ||
7009de92: 9818         	ldr	r0, [sp, #0x60]
7009de94: b160         	cbz	r0, 0x7009deb0 <Udma_flowConfig+0x30> @ imm = #0x18
7009de96: e7ff         	b	0x7009de98 <Udma_flowConfig+0x18> @ imm = #-0x2
;        (flowHandleInt->flowInitDone != UDMA_INIT_DONE) ||
7009de98: 9818         	ldr	r0, [sp, #0x60]
7009de9a: 68c0         	ldr	r0, [r0, #0xc]
7009de9c: f64a 31cd    	movw	r1, #0xabcd
7009dea0: f6ca 31dc    	movt	r1, #0xabdc
7009dea4: 4288         	cmp	r0, r1
7009dea6: d103         	bne	0x7009deb0 <Udma_flowConfig+0x30> @ imm = #0x6
7009dea8: e7ff         	b	0x7009deaa <Udma_flowConfig+0x2a> @ imm = #-0x2
;        (NULL_PTR == flowPrms))
7009deaa: 981b         	ldr	r0, [sp, #0x6c]
;     if((NULL_PTR == flowHandleInt) ||
7009deac: b920         	cbnz	r0, 0x7009deb8 <Udma_flowConfig+0x38> @ imm = #0x8
7009deae: e7ff         	b	0x7009deb0 <Udma_flowConfig+0x30> @ imm = #-0x2
7009deb0: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009deb4: 901a         	str	r0, [sp, #0x68]
;     }
7009deb6: e7ff         	b	0x7009deb8 <Udma_flowConfig+0x38> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009deb8: 981a         	ldr	r0, [sp, #0x68]
7009deba: b9a8         	cbnz	r0, 0x7009dee8 <Udma_flowConfig+0x68> @ imm = #0x2a
7009debc: e7ff         	b	0x7009debe <Udma_flowConfig+0x3e> @ imm = #-0x2
;         drvHandle = flowHandleInt->drvHandle;
7009debe: 9818         	ldr	r0, [sp, #0x60]
7009dec0: 6800         	ldr	r0, [r0]
7009dec2: 9019         	str	r0, [sp, #0x64]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009dec4: 9819         	ldr	r0, [sp, #0x64]
7009dec6: b150         	cbz	r0, 0x7009dede <Udma_flowConfig+0x5e> @ imm = #0x14
7009dec8: e7ff         	b	0x7009deca <Udma_flowConfig+0x4a> @ imm = #-0x2
7009deca: 9819         	ldr	r0, [sp, #0x64]
7009decc: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009ded0: f64a 31cd    	movw	r1, #0xabcd
7009ded4: f6ca 31dc    	movt	r1, #0xabdc
7009ded8: 4288         	cmp	r0, r1
7009deda: d004         	beq	0x7009dee6 <Udma_flowConfig+0x66> @ imm = #0x8
7009dedc: e7ff         	b	0x7009dede <Udma_flowConfig+0x5e> @ imm = #-0x2
7009dede: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009dee2: 901a         	str	r0, [sp, #0x68]
;         }
7009dee4: e7ff         	b	0x7009dee6 <Udma_flowConfig+0x66> @ imm = #-0x2
;     }
7009dee6: e7ff         	b	0x7009dee8 <Udma_flowConfig+0x68> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dee8: 981a         	ldr	r0, [sp, #0x68]
7009deea: b958         	cbnz	r0, 0x7009df04 <Udma_flowConfig+0x84> @ imm = #0x16
7009deec: e7ff         	b	0x7009deee <Udma_flowConfig+0x6e> @ imm = #-0x2
;         if(flowIdx >= flowHandleInt->flowCnt)
7009deee: 981c         	ldr	r0, [sp, #0x70]
7009def0: 9918         	ldr	r1, [sp, #0x60]
7009def2: 6889         	ldr	r1, [r1, #0x8]
7009def4: 4288         	cmp	r0, r1
7009def6: d304         	blo	0x7009df02 <Udma_flowConfig+0x82> @ imm = #0x8
7009def8: e7ff         	b	0x7009defa <Udma_flowConfig+0x7a> @ imm = #-0x2
7009defa: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
7009defe: 901a         	str	r0, [sp, #0x68]
;         }
7009df00: e7ff         	b	0x7009df02 <Udma_flowConfig+0x82> @ imm = #-0x2
;     }
7009df02: e7ff         	b	0x7009df04 <Udma_flowConfig+0x84> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009df04: 981a         	ldr	r0, [sp, #0x68]
7009df06: 2800         	cmp	r0, #0x0
7009df08: f040 80a3    	bne.w	0x7009e052 <Udma_flowConfig+0x1d2> @ imm = #0x146
7009df0c: e7ff         	b	0x7009df0e <Udma_flowConfig+0x8e> @ imm = #-0x2
7009df0e: f64f 70ff    	movw	r0, #0xffff
7009df12: f2c0 0007    	movt	r0, #0x7
;         rmFlowReq.valid_params          = TISCI_MSG_VALUE_RM_UDMAP_FLOW_EINFO_PRESENT_VALID |
7009df16: 900f         	str	r0, [sp, #0x3c]
;         rmFlowReq.nav_id                = drvHandle->devIdUdma;
7009df18: 9819         	ldr	r0, [sp, #0x64]
7009df1a: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009df1e: f8ad 0040    	strh.w	r0, [sp, #0x40]
;         rmFlowReq.flow_index            = (uint16_t)(flowHandleInt->flowStart + flowIdx);
7009df22: 9818         	ldr	r0, [sp, #0x60]
7009df24: 6840         	ldr	r0, [r0, #0x4]
7009df26: 991c         	ldr	r1, [sp, #0x70]
7009df28: 4408         	add	r0, r1
7009df2a: f8ad 0042    	strh.w	r0, [sp, #0x42]
;         rmFlowReq.rx_einfo_present      = flowPrms->einfoPresent;
7009df2e: 981b         	ldr	r0, [sp, #0x6c]
7009df30: 7900         	ldrb	r0, [r0, #0x4]
7009df32: f88d 0044    	strb.w	r0, [sp, #0x44]
;         rmFlowReq.rx_psinfo_present     = flowPrms->psInfoPresent;
7009df36: 981b         	ldr	r0, [sp, #0x6c]
7009df38: 7940         	ldrb	r0, [r0, #0x5]
7009df3a: f88d 0045    	strb.w	r0, [sp, #0x45]
;         rmFlowReq.rx_error_handling     = flowPrms->errorHandling;
7009df3e: 981b         	ldr	r0, [sp, #0x6c]
7009df40: 7980         	ldrb	r0, [r0, #0x6]
7009df42: f88d 0046    	strb.w	r0, [sp, #0x46]
;         rmFlowReq.rx_desc_type          = flowPrms->descType;
7009df46: 981b         	ldr	r0, [sp, #0x6c]
7009df48: 79c0         	ldrb	r0, [r0, #0x7]
7009df4a: f88d 0047    	strb.w	r0, [sp, #0x47]
;         rmFlowReq.rx_ps_location        = flowPrms->psLocation;
7009df4e: 981b         	ldr	r0, [sp, #0x6c]
7009df50: 7a00         	ldrb	r0, [r0, #0x8]
7009df52: f88d 005c    	strb.w	r0, [sp, #0x5c]
;         rmFlowReq.rx_sop_offset         = flowPrms->sopOffset;
7009df56: 981b         	ldr	r0, [sp, #0x6c]
7009df58: 8940         	ldrh	r0, [r0, #0xa]
7009df5a: f8ad 0048    	strh.w	r0, [sp, #0x48]
;         rmFlowReq.rx_dest_qnum          = flowPrms->defaultRxCQ;
7009df5e: 981b         	ldr	r0, [sp, #0x6c]
7009df60: 8980         	ldrh	r0, [r0, #0xc]
7009df62: f8ad 004a    	strh.w	r0, [sp, #0x4a]
;         rmFlowReq.rx_src_tag_hi         = flowPrms->srcTagHi;
7009df66: 981b         	ldr	r0, [sp, #0x6c]
7009df68: 7b80         	ldrb	r0, [r0, #0xe]
7009df6a: f88d 004c    	strb.w	r0, [sp, #0x4c]
;         rmFlowReq.rx_src_tag_lo         = flowPrms->srcTagLo;
7009df6e: 981b         	ldr	r0, [sp, #0x6c]
7009df70: 7bc0         	ldrb	r0, [r0, #0xf]
7009df72: f88d 004d    	strb.w	r0, [sp, #0x4d]
;         rmFlowReq.rx_src_tag_hi_sel     = flowPrms->srcTagHiSel;
7009df76: 981b         	ldr	r0, [sp, #0x6c]
7009df78: 7c00         	ldrb	r0, [r0, #0x10]
7009df7a: f88d 0050    	strb.w	r0, [sp, #0x50]
;         rmFlowReq.rx_src_tag_lo_sel     = flowPrms->srcTagLoSel;
7009df7e: 981b         	ldr	r0, [sp, #0x6c]
7009df80: 7c40         	ldrb	r0, [r0, #0x11]
7009df82: f88d 0051    	strb.w	r0, [sp, #0x51]
;         rmFlowReq.rx_dest_tag_hi        = flowPrms->destTagHi;
7009df86: 981b         	ldr	r0, [sp, #0x6c]
7009df88: 7c80         	ldrb	r0, [r0, #0x12]
7009df8a: f88d 004e    	strb.w	r0, [sp, #0x4e]
;         rmFlowReq.rx_dest_tag_lo        = flowPrms->destTagLo;
7009df8e: 981b         	ldr	r0, [sp, #0x6c]
7009df90: 7cc0         	ldrb	r0, [r0, #0x13]
7009df92: f88d 004f    	strb.w	r0, [sp, #0x4f]
;         rmFlowReq.rx_dest_tag_hi_sel    = flowPrms->destTagHiSel;
7009df96: 981b         	ldr	r0, [sp, #0x6c]
7009df98: 7d00         	ldrb	r0, [r0, #0x14]
7009df9a: f88d 0052    	strb.w	r0, [sp, #0x52]
;         rmFlowReq.rx_dest_tag_lo_sel    = flowPrms->destTagLoSel;
7009df9e: 981b         	ldr	r0, [sp, #0x6c]
7009dfa0: 7d40         	ldrb	r0, [r0, #0x15]
7009dfa2: f88d 0053    	strb.w	r0, [sp, #0x53]
;         rmFlowReq.rx_fdq0_sz0_qnum      = flowPrms->fdq0Sz0Qnum;
7009dfa6: 981b         	ldr	r0, [sp, #0x6c]
7009dfa8: 8b00         	ldrh	r0, [r0, #0x18]
7009dfaa: f8ad 0054    	strh.w	r0, [sp, #0x54]
;         rmFlowReq.rx_fdq1_qnum          = flowPrms->fdq1Qnum;
7009dfae: 981b         	ldr	r0, [sp, #0x6c]
7009dfb0: 8b40         	ldrh	r0, [r0, #0x1a]
7009dfb2: f8ad 0056    	strh.w	r0, [sp, #0x56]
;         rmFlowReq.rx_fdq2_qnum          = flowPrms->fdq2Qnum;
7009dfb6: 981b         	ldr	r0, [sp, #0x6c]
7009dfb8: 8b80         	ldrh	r0, [r0, #0x1c]
7009dfba: f8ad 0058    	strh.w	r0, [sp, #0x58]
;         rmFlowReq.rx_fdq3_qnum          = flowPrms->fdq3Qnum;
7009dfbe: 981b         	ldr	r0, [sp, #0x6c]
7009dfc0: 8bc0         	ldrh	r0, [r0, #0x1e]
7009dfc2: f8ad 005a    	strh.w	r0, [sp, #0x5a]
7009dfc6: a80d         	add	r0, sp, #0x34
7009dfc8: a90b         	add	r1, sp, #0x2c
7009dfca: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmUdmapFlowCfg(
7009dfce: f00c fed7    	bl	0x700aad80 <Sciclient_rmUdmapFlowCfg> @ imm = #0xcdae
7009dfd2: 901a         	str	r0, [sp, #0x68]
;         if(CSL_PASS != retVal)
7009dfd4: 981a         	ldr	r0, [sp, #0x68]
7009dfd6: b108         	cbz	r0, 0x7009dfdc <Udma_flowConfig+0x15c> @ imm = #0x2
7009dfd8: e7ff         	b	0x7009dfda <Udma_flowConfig+0x15a> @ imm = #-0x2
;         }
7009dfda: e7ff         	b	0x7009dfdc <Udma_flowConfig+0x15c> @ imm = #-0x2
7009dfdc: 207f         	movs	r0, #0x7f
;         rmOptFlowReq.valid_params       = TISCI_MSG_VALUE_RM_UDMAP_FLOW_SIZE_THRESH0_VALID |
7009dfde: 9005         	str	r0, [sp, #0x14]
;         rmOptFlowReq.nav_id             = drvHandle->devIdUdma;
7009dfe0: 9819         	ldr	r0, [sp, #0x64]
7009dfe2: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009dfe6: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         rmOptFlowReq.flow_index         = (uint16_t)(flowHandleInt->flowStart + flowIdx);
7009dfea: 9818         	ldr	r0, [sp, #0x60]
7009dfec: 6840         	ldr	r0, [r0, #0x4]
7009dfee: 991c         	ldr	r1, [sp, #0x70]
7009dff0: 4408         	add	r0, r1
7009dff2: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         rmOptFlowReq.rx_size_thresh0    = (flowPrms->sizeThresh0 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009dff6: 981b         	ldr	r0, [sp, #0x6c]
7009dff8: 8c00         	ldrh	r0, [r0, #0x20]
7009dffa: 0940         	lsrs	r0, r0, #0x5
7009dffc: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         rmOptFlowReq.rx_size_thresh1    = (flowPrms->sizeThresh1 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009e000: 981b         	ldr	r0, [sp, #0x6c]
7009e002: 8c40         	ldrh	r0, [r0, #0x22]
7009e004: 0940         	lsrs	r0, r0, #0x5
7009e006: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmOptFlowReq.rx_size_thresh2    = (flowPrms->sizeThresh2 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009e00a: 981b         	ldr	r0, [sp, #0x6c]
7009e00c: 8c80         	ldrh	r0, [r0, #0x24]
7009e00e: 0940         	lsrs	r0, r0, #0x5
7009e010: f8ad 0020    	strh.w	r0, [sp, #0x20]
;         rmOptFlowReq.rx_fdq0_sz1_qnum   = flowPrms->fdq0Sz1Qnum;
7009e014: 981b         	ldr	r0, [sp, #0x6c]
7009e016: 8cc0         	ldrh	r0, [r0, #0x26]
7009e018: f8ad 0022    	strh.w	r0, [sp, #0x22]
;         rmOptFlowReq.rx_fdq0_sz2_qnum   = flowPrms->fdq0Sz2Qnum;
7009e01c: 981b         	ldr	r0, [sp, #0x6c]
7009e01e: 8d00         	ldrh	r0, [r0, #0x28]
7009e020: f8ad 0024    	strh.w	r0, [sp, #0x24]
;         rmOptFlowReq.rx_fdq0_sz3_qnum   = flowPrms->fdq0Sz3Qnum;
7009e024: 981b         	ldr	r0, [sp, #0x6c]
7009e026: 8d40         	ldrh	r0, [r0, #0x2a]
7009e028: f8ad 0026    	strh.w	r0, [sp, #0x26]
;         rmOptFlowReq.rx_size_thresh_en  = flowPrms->sizeThreshEn;
7009e02c: 981b         	ldr	r0, [sp, #0x6c]
7009e02e: 7d80         	ldrb	r0, [r0, #0x16]
7009e030: f88d 0028    	strb.w	r0, [sp, #0x28]
7009e034: a803         	add	r0, sp, #0xc
7009e036: a901         	add	r1, sp, #0x4
7009e038: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal += Sciclient_rmUdmapFlowSizeThreshCfg(
7009e03c: f00c fed0    	bl	0x700aade0 <Sciclient_rmUdmapFlowSizeThreshCfg> @ imm = #0xcda0
7009e040: 4601         	mov	r1, r0
7009e042: 981a         	ldr	r0, [sp, #0x68]
7009e044: 4408         	add	r0, r1
7009e046: 901a         	str	r0, [sp, #0x68]
;         if(CSL_PASS != retVal)
7009e048: 981a         	ldr	r0, [sp, #0x68]
7009e04a: b108         	cbz	r0, 0x7009e050 <Udma_flowConfig+0x1d0> @ imm = #0x2
7009e04c: e7ff         	b	0x7009e04e <Udma_flowConfig+0x1ce> @ imm = #-0x2
;         }
7009e04e: e7ff         	b	0x7009e050 <Udma_flowConfig+0x1d0> @ imm = #-0x2
;     }
7009e050: e7ff         	b	0x7009e052 <Udma_flowConfig+0x1d2> @ imm = #-0x2
;     return (retVal);
7009e052: 981a         	ldr	r0, [sp, #0x68]
7009e054: b01e         	add	sp, #0x78
7009e056: bd80         	pop	{r7, pc}
		...

7009e060 <SOC_moduleSetClockFrequency>:
; {
7009e060: b580         	push	{r7, lr}
7009e062: b090         	sub	sp, #0x40
7009e064: 900f         	str	r0, [sp, #0x3c]
7009e066: 910e         	str	r1, [sp, #0x38]
7009e068: 930d         	str	r3, [sp, #0x34]
7009e06a: 920c         	str	r2, [sp, #0x30]
7009e06c: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
7009e06e: 9002         	str	r0, [sp, #0x8]
7009e070: 900b         	str	r0, [sp, #0x2c]
;     uint32_t i = 0U;
7009e072: 900a         	str	r0, [sp, #0x28]
;     uint64_t respClkRate = 0;
7009e074: 9009         	str	r0, [sp, #0x24]
7009e076: 9008         	str	r0, [sp, #0x20]
;     uint32_t numParents = 0U;
7009e078: 9007         	str	r0, [sp, #0x1c]
;     uint32_t moduleClockParentChanged = 0U;
7009e07a: 9006         	str	r0, [sp, #0x18]
;     uint32_t clockStatus = 0U;
7009e07c: 9005         	str	r0, [sp, #0x14]
;     uint32_t origParent = 0U;
7009e07e: 9004         	str	r0, [sp, #0x10]
;     uint32_t foundParent = 0U;
7009e080: 9003         	str	r0, [sp, #0xc]
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009e082: 980f         	ldr	r0, [sp, #0x3c]
;                                             clkId,
7009e084: 990e         	ldr	r1, [sp, #0x38]
7009e086: aa05         	add	r2, sp, #0x14
7009e088: f04f 33ff    	mov.w	r3, #0xffffffff
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009e08c: f009 fbe0    	bl	0x700a7850 <Sciclient_pmModuleGetClkStatus> @ imm = #0x97c0
7009e090: 900b         	str	r0, [sp, #0x2c]
;     if (status == SystemP_SUCCESS)
7009e092: 980b         	ldr	r0, [sp, #0x2c]
7009e094: b948         	cbnz	r0, 0x7009e0aa <SOC_moduleSetClockFrequency+0x4a> @ imm = #0x12
7009e096: e7ff         	b	0x7009e098 <SOC_moduleSetClockFrequency+0x38> @ imm = #-0x2
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009e098: 980f         	ldr	r0, [sp, #0x3c]
;                                                    clkId,
7009e09a: 990e         	ldr	r1, [sp, #0x38]
7009e09c: aa07         	add	r2, sp, #0x1c
7009e09e: f04f 33ff    	mov.w	r3, #0xffffffff
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009e0a2: f008 fcb5    	bl	0x700a6a10 <Sciclient_pmGetModuleClkNumParent> @ imm = #0x896a
7009e0a6: 900b         	str	r0, [sp, #0x2c]
;     }
7009e0a8: e7ff         	b	0x7009e0aa <SOC_moduleSetClockFrequency+0x4a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e0aa: 980b         	ldr	r0, [sp, #0x2c]
7009e0ac: b970         	cbnz	r0, 0x7009e0cc <SOC_moduleSetClockFrequency+0x6c> @ imm = #0x1c
7009e0ae: e7ff         	b	0x7009e0b0 <SOC_moduleSetClockFrequency+0x50> @ imm = #-0x2
;         if(numParents > 1U)
7009e0b0: 9807         	ldr	r0, [sp, #0x1c]
7009e0b2: 2802         	cmp	r0, #0x2
7009e0b4: d309         	blo	0x7009e0ca <SOC_moduleSetClockFrequency+0x6a> @ imm = #0x12
7009e0b6: e7ff         	b	0x7009e0b8 <SOC_moduleSetClockFrequency+0x58> @ imm = #-0x2
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009e0b8: 980f         	ldr	r0, [sp, #0x3c]
;                                                     clkId,
7009e0ba: 990e         	ldr	r1, [sp, #0x38]
7009e0bc: aa04         	add	r2, sp, #0x10
7009e0be: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009e0c2: f009 f9e5    	bl	0x700a7490 <Sciclient_pmGetModuleClkParent> @ imm = #0x93ca
7009e0c6: 900b         	str	r0, [sp, #0x2c]
;         }
7009e0c8: e7ff         	b	0x7009e0ca <SOC_moduleSetClockFrequency+0x6a> @ imm = #-0x2
;     }
7009e0ca: e7ff         	b	0x7009e0cc <SOC_moduleSetClockFrequency+0x6c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e0cc: 980b         	ldr	r0, [sp, #0x2c]
7009e0ce: b960         	cbnz	r0, 0x7009e0ea <SOC_moduleSetClockFrequency+0x8a> @ imm = #0x18
7009e0d0: e7ff         	b	0x7009e0d2 <SOC_moduleSetClockFrequency+0x72> @ imm = #-0x2
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009e0d2: 980f         	ldr	r0, [sp, #0x3c]
;                                               clkId,
7009e0d4: 990e         	ldr	r1, [sp, #0x38]
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009e0d6: 466b         	mov	r3, sp
7009e0d8: f04f 32ff    	mov.w	r2, #0xffffffff
7009e0dc: 601a         	str	r2, [r3]
7009e0de: 2300         	movs	r3, #0x0
7009e0e0: 461a         	mov	r2, r3
7009e0e2: f00a f98d    	bl	0x700a8400 <Sciclient_pmModuleClkRequest> @ imm = #0xa31a
7009e0e6: 900b         	str	r0, [sp, #0x2c]
;     }
7009e0e8: e7ff         	b	0x7009e0ea <SOC_moduleSetClockFrequency+0x8a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e0ea: 980b         	ldr	r0, [sp, #0x2c]
7009e0ec: 2800         	cmp	r0, #0x0
7009e0ee: d14d         	bne	0x7009e18c <SOC_moduleSetClockFrequency+0x12c> @ imm = #0x9a
7009e0f0: e7ff         	b	0x7009e0f2 <SOC_moduleSetClockFrequency+0x92> @ imm = #-0x2
7009e0f2: 2000         	movs	r0, #0x0
;         foundParent = 0U;
7009e0f4: 9003         	str	r0, [sp, #0xc]
;         for(i=0U;i<numParents;i++)
7009e0f6: 900a         	str	r0, [sp, #0x28]
7009e0f8: e7ff         	b	0x7009e0fa <SOC_moduleSetClockFrequency+0x9a> @ imm = #-0x2
7009e0fa: 980a         	ldr	r0, [sp, #0x28]
7009e0fc: 9907         	ldr	r1, [sp, #0x1c]
7009e0fe: 4288         	cmp	r0, r1
7009e100: d243         	bhs	0x7009e18a <SOC_moduleSetClockFrequency+0x12a> @ imm = #0x86
7009e102: e7ff         	b	0x7009e104 <SOC_moduleSetClockFrequency+0xa4> @ imm = #-0x2
;             if (numParents > 1U)
7009e104: 9807         	ldr	r0, [sp, #0x1c]
7009e106: 2802         	cmp	r0, #0x2
7009e108: d311         	blo	0x7009e12e <SOC_moduleSetClockFrequency+0xce> @ imm = #0x22
7009e10a: e7ff         	b	0x7009e10c <SOC_moduleSetClockFrequency+0xac> @ imm = #-0x2
;                 status = Sciclient_pmSetModuleClkParent(moduleId,
7009e10c: 980f         	ldr	r0, [sp, #0x3c]
;                                                         clkId,
7009e10e: 990e         	ldr	r1, [sp, #0x38]
;                                                         clkId+i+1,
7009e110: 9a0a         	ldr	r2, [sp, #0x28]
7009e112: 440a         	add	r2, r1
7009e114: 3201         	adds	r2, #0x1
7009e116: f04f 33ff    	mov.w	r3, #0xffffffff
;                 status = Sciclient_pmSetModuleClkParent(moduleId,
7009e11a: f009 fa09    	bl	0x700a7530 <Sciclient_pmSetModuleClkParent> @ imm = #0x9412
7009e11e: 900b         	str	r0, [sp, #0x2c]
;                 if (status == SystemP_SUCCESS)
7009e120: 980b         	ldr	r0, [sp, #0x2c]
7009e122: b918         	cbnz	r0, 0x7009e12c <SOC_moduleSetClockFrequency+0xcc> @ imm = #0x6
7009e124: e7ff         	b	0x7009e126 <SOC_moduleSetClockFrequency+0xc6> @ imm = #-0x2
7009e126: 2001         	movs	r0, #0x1
;                     moduleClockParentChanged = 1U;
7009e128: 9006         	str	r0, [sp, #0x18]
;                 }
7009e12a: e7ff         	b	0x7009e12c <SOC_moduleSetClockFrequency+0xcc> @ imm = #-0x2
;             }
7009e12c: e7ff         	b	0x7009e12e <SOC_moduleSetClockFrequency+0xce> @ imm = #-0x2
;             if (status == SystemP_SUCCESS)
7009e12e: 980b         	ldr	r0, [sp, #0x2c]
7009e130: b988         	cbnz	r0, 0x7009e156 <SOC_moduleSetClockFrequency+0xf6> @ imm = #0x22
7009e132: e7ff         	b	0x7009e134 <SOC_moduleSetClockFrequency+0xd4> @ imm = #-0x2
;                 status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009e134: 980f         	ldr	r0, [sp, #0x3c]
;                                                         clkId,
7009e136: 990e         	ldr	r1, [sp, #0x38]
;                                                         clkRate,
7009e138: 9a0c         	ldr	r2, [sp, #0x30]
7009e13a: 9b0d         	ldr	r3, [sp, #0x34]
;                 status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009e13c: 46ee         	mov	lr, sp
7009e13e: f04f 3cff    	mov.w	r12, #0xffffffff
7009e142: f8ce c004    	str.w	r12, [lr, #0x4]
7009e146: f10d 0c20    	add.w	r12, sp, #0x20
7009e14a: f8ce c000    	str.w	r12, [lr]
7009e14e: f003 fd07    	bl	0x700a1b60 <Sciclient_pmQueryModuleClkFreq> @ imm = #0x3a0e
7009e152: 900b         	str	r0, [sp, #0x2c]
;             }
7009e154: e7ff         	b	0x7009e156 <SOC_moduleSetClockFrequency+0xf6> @ imm = #-0x2
;             if (status == SystemP_SUCCESS)
7009e156: 980b         	ldr	r0, [sp, #0x2c]
7009e158: b970         	cbnz	r0, 0x7009e178 <SOC_moduleSetClockFrequency+0x118> @ imm = #0x1c
7009e15a: e7ff         	b	0x7009e15c <SOC_moduleSetClockFrequency+0xfc> @ imm = #-0x2
;                 if(respClkRate == clkRate)
7009e15c: 9808         	ldr	r0, [sp, #0x20]
7009e15e: 9909         	ldr	r1, [sp, #0x24]
7009e160: 9a0c         	ldr	r2, [sp, #0x30]
7009e162: 9b0d         	ldr	r3, [sp, #0x34]
7009e164: 4059         	eors	r1, r3
7009e166: ea80 0002    	eor.w	r0, r0, r2
7009e16a: 4308         	orrs	r0, r1
7009e16c: b918         	cbnz	r0, 0x7009e176 <SOC_moduleSetClockFrequency+0x116> @ imm = #0x6
7009e16e: e7ff         	b	0x7009e170 <SOC_moduleSetClockFrequency+0x110> @ imm = #-0x2
7009e170: 2001         	movs	r0, #0x1
;                     foundParent = 1U;
7009e172: 9003         	str	r0, [sp, #0xc]
;                 }
7009e174: e7ff         	b	0x7009e176 <SOC_moduleSetClockFrequency+0x116> @ imm = #-0x2
;             }
7009e176: e7ff         	b	0x7009e178 <SOC_moduleSetClockFrequency+0x118> @ imm = #-0x2
;             if(foundParent)
7009e178: 9803         	ldr	r0, [sp, #0xc]
7009e17a: b108         	cbz	r0, 0x7009e180 <SOC_moduleSetClockFrequency+0x120> @ imm = #0x2
7009e17c: e7ff         	b	0x7009e17e <SOC_moduleSetClockFrequency+0x11e> @ imm = #-0x2
;                 break; /* found a parent to set clock frequency, rebak form the loop */
7009e17e: e004         	b	0x7009e18a <SOC_moduleSetClockFrequency+0x12a> @ imm = #0x8
;         }
7009e180: e7ff         	b	0x7009e182 <SOC_moduleSetClockFrequency+0x122> @ imm = #-0x2
;         for(i=0U;i<numParents;i++)
7009e182: 980a         	ldr	r0, [sp, #0x28]
7009e184: 3001         	adds	r0, #0x1
7009e186: 900a         	str	r0, [sp, #0x28]
7009e188: e7b7         	b	0x7009e0fa <SOC_moduleSetClockFrequency+0x9a> @ imm = #-0x92
;     }
7009e18a: e7ff         	b	0x7009e18c <SOC_moduleSetClockFrequency+0x12c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e18c: 980b         	ldr	r0, [sp, #0x2c]
7009e18e: b9d0         	cbnz	r0, 0x7009e1c6 <SOC_moduleSetClockFrequency+0x166> @ imm = #0x34
7009e190: e7ff         	b	0x7009e192 <SOC_moduleSetClockFrequency+0x132> @ imm = #-0x2
;         if(foundParent == 1U)
7009e192: 9803         	ldr	r0, [sp, #0xc]
7009e194: 2801         	cmp	r0, #0x1
7009e196: d111         	bne	0x7009e1bc <SOC_moduleSetClockFrequency+0x15c> @ imm = #0x22
7009e198: e7ff         	b	0x7009e19a <SOC_moduleSetClockFrequency+0x13a> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009e19a: 980f         	ldr	r0, [sp, #0x3c]
;                                                   clkId,
7009e19c: 990e         	ldr	r1, [sp, #0x38]
;                                                   clkRate,
7009e19e: 9a0c         	ldr	r2, [sp, #0x30]
7009e1a0: 9b0d         	ldr	r3, [sp, #0x34]
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009e1a2: 46ee         	mov	lr, sp
7009e1a4: f04f 3cff    	mov.w	r12, #0xffffffff
7009e1a8: f8ce c004    	str.w	r12, [lr, #0x4]
7009e1ac: f44f 7c00    	mov.w	r12, #0x200
7009e1b0: f8ce c000    	str.w	r12, [lr]
7009e1b4: f005 f98c    	bl	0x700a34d0 <Sciclient_pmSetModuleClkFreq> @ imm = #0x5318
7009e1b8: 900b         	str	r0, [sp, #0x2c]
;         }
7009e1ba: e003         	b	0x7009e1c4 <SOC_moduleSetClockFrequency+0x164> @ imm = #0x6
7009e1bc: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009e1c0: 900b         	str	r0, [sp, #0x2c]
7009e1c2: e7ff         	b	0x7009e1c4 <SOC_moduleSetClockFrequency+0x164> @ imm = #-0x2
;     }
7009e1c4: e7ff         	b	0x7009e1c6 <SOC_moduleSetClockFrequency+0x166> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e1c6: 980b         	ldr	r0, [sp, #0x2c]
7009e1c8: b988         	cbnz	r0, 0x7009e1ee <SOC_moduleSetClockFrequency+0x18e> @ imm = #0x22
7009e1ca: e7ff         	b	0x7009e1cc <SOC_moduleSetClockFrequency+0x16c> @ imm = #-0x2
;         if (clockStatus == TISCI_MSG_VALUE_CLOCK_HW_STATE_NOT_READY)
7009e1cc: 9805         	ldr	r0, [sp, #0x14]
7009e1ce: b968         	cbnz	r0, 0x7009e1ec <SOC_moduleSetClockFrequency+0x18c> @ imm = #0x1a
7009e1d0: e7ff         	b	0x7009e1d2 <SOC_moduleSetClockFrequency+0x172> @ imm = #-0x2
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009e1d2: 980f         	ldr	r0, [sp, #0x3c]
;                                                   clkId,
7009e1d4: 990e         	ldr	r1, [sp, #0x38]
;                                                   clockStatus,
7009e1d6: 9a05         	ldr	r2, [sp, #0x14]
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009e1d8: 46ec         	mov	r12, sp
7009e1da: f04f 33ff    	mov.w	r3, #0xffffffff
7009e1de: f8cc 3000    	str.w	r3, [r12]
7009e1e2: 2300         	movs	r3, #0x0
7009e1e4: f00a f90c    	bl	0x700a8400 <Sciclient_pmModuleClkRequest> @ imm = #0xa218
7009e1e8: 900b         	str	r0, [sp, #0x2c]
;         }
7009e1ea: e7ff         	b	0x7009e1ec <SOC_moduleSetClockFrequency+0x18c> @ imm = #-0x2
;     }
7009e1ec: e7ff         	b	0x7009e1ee <SOC_moduleSetClockFrequency+0x18e> @ imm = #-0x2
;     if (status != SystemP_SUCCESS)
7009e1ee: 980b         	ldr	r0, [sp, #0x2c]
7009e1f0: b168         	cbz	r0, 0x7009e20e <SOC_moduleSetClockFrequency+0x1ae> @ imm = #0x1a
7009e1f2: e7ff         	b	0x7009e1f4 <SOC_moduleSetClockFrequency+0x194> @ imm = #-0x2
;         if (moduleClockParentChanged == 1U)
7009e1f4: 9806         	ldr	r0, [sp, #0x18]
7009e1f6: 2801         	cmp	r0, #0x1
7009e1f8: d108         	bne	0x7009e20c <SOC_moduleSetClockFrequency+0x1ac> @ imm = #0x10
7009e1fa: e7ff         	b	0x7009e1fc <SOC_moduleSetClockFrequency+0x19c> @ imm = #-0x2
;             Sciclient_pmSetModuleClkParent(moduleId,
7009e1fc: 980f         	ldr	r0, [sp, #0x3c]
;                                            clkId,
7009e1fe: 990e         	ldr	r1, [sp, #0x38]
;                                            origParent,
7009e200: 9a04         	ldr	r2, [sp, #0x10]
7009e202: f04f 33ff    	mov.w	r3, #0xffffffff
;             Sciclient_pmSetModuleClkParent(moduleId,
7009e206: f009 f993    	bl	0x700a7530 <Sciclient_pmSetModuleClkParent> @ imm = #0x9326
;         }
7009e20a: e7ff         	b	0x7009e20c <SOC_moduleSetClockFrequency+0x1ac> @ imm = #-0x2
;     }
7009e20c: e7ff         	b	0x7009e20e <SOC_moduleSetClockFrequency+0x1ae> @ imm = #-0x2
;     return status;
7009e20e: 980b         	ldr	r0, [sp, #0x2c]
7009e210: b010         	add	sp, #0x40
7009e212: bd80         	pop	{r7, pc}
		...

7009e220 <SOC_moduleSetClockFrequencyWithParent>:
; {
7009e220: b580         	push	{r7, lr}
7009e222: b092         	sub	sp, #0x48
7009e224: 460b         	mov	r3, r1
7009e226: 4684         	mov	r12, r0
7009e228: 9915         	ldr	r1, [sp, #0x54]
7009e22a: 9814         	ldr	r0, [sp, #0x50]
7009e22c: f8cd c044    	str.w	r12, [sp, #0x44]
7009e230: 9310         	str	r3, [sp, #0x40]
7009e232: 920f         	str	r2, [sp, #0x3c]
7009e234: 910d         	str	r1, [sp, #0x34]
7009e236: 900c         	str	r0, [sp, #0x30]
7009e238: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
7009e23a: 9002         	str	r0, [sp, #0x8]
7009e23c: 900b         	str	r0, [sp, #0x2c]
;     uint64_t respClkRate = 0;
7009e23e: 9009         	str	r0, [sp, #0x24]
7009e240: 9008         	str	r0, [sp, #0x20]
;     uint32_t numParents = 0U;
7009e242: 9007         	str	r0, [sp, #0x1c]
;     uint32_t moduleClockParentChanged = 0U;
7009e244: 9006         	str	r0, [sp, #0x18]
;     uint32_t clockStatus = 0U;
7009e246: 9005         	str	r0, [sp, #0x14]
;     uint32_t origParent = 0U;
7009e248: 9004         	str	r0, [sp, #0x10]
;     uint32_t foundParent = 0U;
7009e24a: 9003         	str	r0, [sp, #0xc]
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009e24c: 9811         	ldr	r0, [sp, #0x44]
;                                             clkId,
7009e24e: 9910         	ldr	r1, [sp, #0x40]
7009e250: aa05         	add	r2, sp, #0x14
7009e252: f04f 33ff    	mov.w	r3, #0xffffffff
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009e256: f009 fafb    	bl	0x700a7850 <Sciclient_pmModuleGetClkStatus> @ imm = #0x95f6
7009e25a: 900b         	str	r0, [sp, #0x2c]
;     if (status == SystemP_SUCCESS)
7009e25c: 980b         	ldr	r0, [sp, #0x2c]
7009e25e: b948         	cbnz	r0, 0x7009e274 <SOC_moduleSetClockFrequencyWithParent+0x54> @ imm = #0x12
7009e260: e7ff         	b	0x7009e262 <SOC_moduleSetClockFrequencyWithParent+0x42> @ imm = #-0x2
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009e262: 9811         	ldr	r0, [sp, #0x44]
;                                                    clkId,
7009e264: 9910         	ldr	r1, [sp, #0x40]
7009e266: aa07         	add	r2, sp, #0x1c
7009e268: f04f 33ff    	mov.w	r3, #0xffffffff
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009e26c: f008 fbd0    	bl	0x700a6a10 <Sciclient_pmGetModuleClkNumParent> @ imm = #0x87a0
7009e270: 900b         	str	r0, [sp, #0x2c]
;     }
7009e272: e7ff         	b	0x7009e274 <SOC_moduleSetClockFrequencyWithParent+0x54> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e274: 980b         	ldr	r0, [sp, #0x2c]
7009e276: b970         	cbnz	r0, 0x7009e296 <SOC_moduleSetClockFrequencyWithParent+0x76> @ imm = #0x1c
7009e278: e7ff         	b	0x7009e27a <SOC_moduleSetClockFrequencyWithParent+0x5a> @ imm = #-0x2
;         if(numParents > 1U)
7009e27a: 9807         	ldr	r0, [sp, #0x1c]
7009e27c: 2802         	cmp	r0, #0x2
7009e27e: d309         	blo	0x7009e294 <SOC_moduleSetClockFrequencyWithParent+0x74> @ imm = #0x12
7009e280: e7ff         	b	0x7009e282 <SOC_moduleSetClockFrequencyWithParent+0x62> @ imm = #-0x2
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009e282: 9811         	ldr	r0, [sp, #0x44]
;                                                     clkId,
7009e284: 9910         	ldr	r1, [sp, #0x40]
7009e286: aa04         	add	r2, sp, #0x10
7009e288: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009e28c: f009 f900    	bl	0x700a7490 <Sciclient_pmGetModuleClkParent> @ imm = #0x9200
7009e290: 900b         	str	r0, [sp, #0x2c]
;         }
7009e292: e7ff         	b	0x7009e294 <SOC_moduleSetClockFrequencyWithParent+0x74> @ imm = #-0x2
;     }
7009e294: e7ff         	b	0x7009e296 <SOC_moduleSetClockFrequencyWithParent+0x76> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e296: 980b         	ldr	r0, [sp, #0x2c]
7009e298: b960         	cbnz	r0, 0x7009e2b4 <SOC_moduleSetClockFrequencyWithParent+0x94> @ imm = #0x18
7009e29a: e7ff         	b	0x7009e29c <SOC_moduleSetClockFrequencyWithParent+0x7c> @ imm = #-0x2
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009e29c: 9811         	ldr	r0, [sp, #0x44]
;                                               clkId,
7009e29e: 9910         	ldr	r1, [sp, #0x40]
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009e2a0: 466b         	mov	r3, sp
7009e2a2: f04f 32ff    	mov.w	r2, #0xffffffff
7009e2a6: 601a         	str	r2, [r3]
7009e2a8: 2300         	movs	r3, #0x0
7009e2aa: 461a         	mov	r2, r3
7009e2ac: f00a f8a8    	bl	0x700a8400 <Sciclient_pmModuleClkRequest> @ imm = #0xa150
7009e2b0: 900b         	str	r0, [sp, #0x2c]
;     }
7009e2b2: e7ff         	b	0x7009e2b4 <SOC_moduleSetClockFrequencyWithParent+0x94> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e2b4: 980b         	ldr	r0, [sp, #0x2c]
7009e2b6: b960         	cbnz	r0, 0x7009e2d2 <SOC_moduleSetClockFrequencyWithParent+0xb2> @ imm = #0x18
7009e2b8: e7ff         	b	0x7009e2ba <SOC_moduleSetClockFrequencyWithParent+0x9a> @ imm = #-0x2
;         if (clkParent > (clkId + numParents))
7009e2ba: 980f         	ldr	r0, [sp, #0x3c]
7009e2bc: 9910         	ldr	r1, [sp, #0x40]
7009e2be: 9a07         	ldr	r2, [sp, #0x1c]
7009e2c0: 4411         	add	r1, r2
7009e2c2: 4288         	cmp	r0, r1
7009e2c4: d904         	bls	0x7009e2d0 <SOC_moduleSetClockFrequencyWithParent+0xb0> @ imm = #0x8
7009e2c6: e7ff         	b	0x7009e2c8 <SOC_moduleSetClockFrequencyWithParent+0xa8> @ imm = #-0x2
7009e2c8: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009e2cc: 900b         	str	r0, [sp, #0x2c]
;         }
7009e2ce: e7ff         	b	0x7009e2d0 <SOC_moduleSetClockFrequencyWithParent+0xb0> @ imm = #-0x2
;     }
7009e2d0: e7ff         	b	0x7009e2d2 <SOC_moduleSetClockFrequencyWithParent+0xb2> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e2d2: 980b         	ldr	r0, [sp, #0x2c]
7009e2d4: b9a8         	cbnz	r0, 0x7009e302 <SOC_moduleSetClockFrequencyWithParent+0xe2> @ imm = #0x2a
7009e2d6: e7ff         	b	0x7009e2d8 <SOC_moduleSetClockFrequencyWithParent+0xb8> @ imm = #-0x2
;         if (clkParent != origParent)
7009e2d8: 980f         	ldr	r0, [sp, #0x3c]
7009e2da: 9904         	ldr	r1, [sp, #0x10]
7009e2dc: 4288         	cmp	r0, r1
7009e2de: d00f         	beq	0x7009e300 <SOC_moduleSetClockFrequencyWithParent+0xe0> @ imm = #0x1e
7009e2e0: e7ff         	b	0x7009e2e2 <SOC_moduleSetClockFrequencyWithParent+0xc2> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkParent(moduleId,
7009e2e2: 9811         	ldr	r0, [sp, #0x44]
;                                                         clkId,
7009e2e4: 9910         	ldr	r1, [sp, #0x40]
;                                                         clkParent,
7009e2e6: 9a0f         	ldr	r2, [sp, #0x3c]
7009e2e8: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmSetModuleClkParent(moduleId,
7009e2ec: f009 f920    	bl	0x700a7530 <Sciclient_pmSetModuleClkParent> @ imm = #0x9240
7009e2f0: 900b         	str	r0, [sp, #0x2c]
;             if (status == SystemP_SUCCESS)
7009e2f2: 980b         	ldr	r0, [sp, #0x2c]
7009e2f4: b918         	cbnz	r0, 0x7009e2fe <SOC_moduleSetClockFrequencyWithParent+0xde> @ imm = #0x6
7009e2f6: e7ff         	b	0x7009e2f8 <SOC_moduleSetClockFrequencyWithParent+0xd8> @ imm = #-0x2
7009e2f8: 2001         	movs	r0, #0x1
;                 moduleClockParentChanged = 1U;
7009e2fa: 9006         	str	r0, [sp, #0x18]
;             }
7009e2fc: e7ff         	b	0x7009e2fe <SOC_moduleSetClockFrequencyWithParent+0xde> @ imm = #-0x2
;         }
7009e2fe: e7ff         	b	0x7009e300 <SOC_moduleSetClockFrequencyWithParent+0xe0> @ imm = #-0x2
;     }
7009e300: e7ff         	b	0x7009e302 <SOC_moduleSetClockFrequencyWithParent+0xe2> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e302: 980b         	ldr	r0, [sp, #0x2c]
7009e304: b988         	cbnz	r0, 0x7009e32a <SOC_moduleSetClockFrequencyWithParent+0x10a> @ imm = #0x22
7009e306: e7ff         	b	0x7009e308 <SOC_moduleSetClockFrequencyWithParent+0xe8> @ imm = #-0x2
;         status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009e308: 9811         	ldr	r0, [sp, #0x44]
;                                                 clkId,
7009e30a: 9910         	ldr	r1, [sp, #0x40]
;                                                 clkRate,
7009e30c: 9a0c         	ldr	r2, [sp, #0x30]
7009e30e: 9b0d         	ldr	r3, [sp, #0x34]
;         status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009e310: 46ee         	mov	lr, sp
7009e312: f04f 3cff    	mov.w	r12, #0xffffffff
7009e316: f8ce c004    	str.w	r12, [lr, #0x4]
7009e31a: f10d 0c20    	add.w	r12, sp, #0x20
7009e31e: f8ce c000    	str.w	r12, [lr]
7009e322: f003 fc1d    	bl	0x700a1b60 <Sciclient_pmQueryModuleClkFreq> @ imm = #0x383a
7009e326: 900b         	str	r0, [sp, #0x2c]
;     }
7009e328: e7ff         	b	0x7009e32a <SOC_moduleSetClockFrequencyWithParent+0x10a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e32a: 980b         	ldr	r0, [sp, #0x2c]
7009e32c: b970         	cbnz	r0, 0x7009e34c <SOC_moduleSetClockFrequencyWithParent+0x12c> @ imm = #0x1c
7009e32e: e7ff         	b	0x7009e330 <SOC_moduleSetClockFrequencyWithParent+0x110> @ imm = #-0x2
;         if(respClkRate == clkRate)
7009e330: 9808         	ldr	r0, [sp, #0x20]
7009e332: 9909         	ldr	r1, [sp, #0x24]
7009e334: 9a0c         	ldr	r2, [sp, #0x30]
7009e336: 9b0d         	ldr	r3, [sp, #0x34]
7009e338: 4059         	eors	r1, r3
7009e33a: ea80 0002    	eor.w	r0, r0, r2
7009e33e: 4308         	orrs	r0, r1
7009e340: b918         	cbnz	r0, 0x7009e34a <SOC_moduleSetClockFrequencyWithParent+0x12a> @ imm = #0x6
7009e342: e7ff         	b	0x7009e344 <SOC_moduleSetClockFrequencyWithParent+0x124> @ imm = #-0x2
7009e344: 2001         	movs	r0, #0x1
;             foundParent = 1U;
7009e346: 9003         	str	r0, [sp, #0xc]
;         }
7009e348: e7ff         	b	0x7009e34a <SOC_moduleSetClockFrequencyWithParent+0x12a> @ imm = #-0x2
;     }
7009e34a: e7ff         	b	0x7009e34c <SOC_moduleSetClockFrequencyWithParent+0x12c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e34c: 980b         	ldr	r0, [sp, #0x2c]
7009e34e: b9d0         	cbnz	r0, 0x7009e386 <SOC_moduleSetClockFrequencyWithParent+0x166> @ imm = #0x34
7009e350: e7ff         	b	0x7009e352 <SOC_moduleSetClockFrequencyWithParent+0x132> @ imm = #-0x2
;         if(foundParent == 1U)
7009e352: 9803         	ldr	r0, [sp, #0xc]
7009e354: 2801         	cmp	r0, #0x1
7009e356: d111         	bne	0x7009e37c <SOC_moduleSetClockFrequencyWithParent+0x15c> @ imm = #0x22
7009e358: e7ff         	b	0x7009e35a <SOC_moduleSetClockFrequencyWithParent+0x13a> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009e35a: 9811         	ldr	r0, [sp, #0x44]
;                                                   clkId,
7009e35c: 9910         	ldr	r1, [sp, #0x40]
;                                                   clkRate,
7009e35e: 9a0c         	ldr	r2, [sp, #0x30]
7009e360: 9b0d         	ldr	r3, [sp, #0x34]
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009e362: 46ee         	mov	lr, sp
7009e364: f04f 3cff    	mov.w	r12, #0xffffffff
7009e368: f8ce c004    	str.w	r12, [lr, #0x4]
7009e36c: f44f 7c00    	mov.w	r12, #0x200
7009e370: f8ce c000    	str.w	r12, [lr]
7009e374: f005 f8ac    	bl	0x700a34d0 <Sciclient_pmSetModuleClkFreq> @ imm = #0x5158
7009e378: 900b         	str	r0, [sp, #0x2c]
;         }
7009e37a: e003         	b	0x7009e384 <SOC_moduleSetClockFrequencyWithParent+0x164> @ imm = #0x6
7009e37c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009e380: 900b         	str	r0, [sp, #0x2c]
7009e382: e7ff         	b	0x7009e384 <SOC_moduleSetClockFrequencyWithParent+0x164> @ imm = #-0x2
;     }
7009e384: e7ff         	b	0x7009e386 <SOC_moduleSetClockFrequencyWithParent+0x166> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e386: 980b         	ldr	r0, [sp, #0x2c]
7009e388: b988         	cbnz	r0, 0x7009e3ae <SOC_moduleSetClockFrequencyWithParent+0x18e> @ imm = #0x22
7009e38a: e7ff         	b	0x7009e38c <SOC_moduleSetClockFrequencyWithParent+0x16c> @ imm = #-0x2
;         if (clockStatus == TISCI_MSG_VALUE_CLOCK_HW_STATE_NOT_READY)
7009e38c: 9805         	ldr	r0, [sp, #0x14]
7009e38e: b968         	cbnz	r0, 0x7009e3ac <SOC_moduleSetClockFrequencyWithParent+0x18c> @ imm = #0x1a
7009e390: e7ff         	b	0x7009e392 <SOC_moduleSetClockFrequencyWithParent+0x172> @ imm = #-0x2
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009e392: 9811         	ldr	r0, [sp, #0x44]
;                                                   clkId,
7009e394: 9910         	ldr	r1, [sp, #0x40]
;                                                   clockStatus,
7009e396: 9a05         	ldr	r2, [sp, #0x14]
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009e398: 46ec         	mov	r12, sp
7009e39a: f04f 33ff    	mov.w	r3, #0xffffffff
7009e39e: f8cc 3000    	str.w	r3, [r12]
7009e3a2: 2300         	movs	r3, #0x0
7009e3a4: f00a f82c    	bl	0x700a8400 <Sciclient_pmModuleClkRequest> @ imm = #0xa058
7009e3a8: 900b         	str	r0, [sp, #0x2c]
;         }
7009e3aa: e7ff         	b	0x7009e3ac <SOC_moduleSetClockFrequencyWithParent+0x18c> @ imm = #-0x2
;     }
7009e3ac: e7ff         	b	0x7009e3ae <SOC_moduleSetClockFrequencyWithParent+0x18e> @ imm = #-0x2
;     if (status != SystemP_SUCCESS)
7009e3ae: 980b         	ldr	r0, [sp, #0x2c]
7009e3b0: b168         	cbz	r0, 0x7009e3ce <SOC_moduleSetClockFrequencyWithParent+0x1ae> @ imm = #0x1a
7009e3b2: e7ff         	b	0x7009e3b4 <SOC_moduleSetClockFrequencyWithParent+0x194> @ imm = #-0x2
;         if (moduleClockParentChanged == 1U)
7009e3b4: 9806         	ldr	r0, [sp, #0x18]
7009e3b6: 2801         	cmp	r0, #0x1
7009e3b8: d108         	bne	0x7009e3cc <SOC_moduleSetClockFrequencyWithParent+0x1ac> @ imm = #0x10
7009e3ba: e7ff         	b	0x7009e3bc <SOC_moduleSetClockFrequencyWithParent+0x19c> @ imm = #-0x2
;             Sciclient_pmSetModuleClkParent(moduleId,
7009e3bc: 9811         	ldr	r0, [sp, #0x44]
;                                            clkId,
7009e3be: 9910         	ldr	r1, [sp, #0x40]
;                                            origParent,
7009e3c0: 9a04         	ldr	r2, [sp, #0x10]
7009e3c2: f04f 33ff    	mov.w	r3, #0xffffffff
;             Sciclient_pmSetModuleClkParent(moduleId,
7009e3c6: f009 f8b3    	bl	0x700a7530 <Sciclient_pmSetModuleClkParent> @ imm = #0x9166
;         }
7009e3ca: e7ff         	b	0x7009e3cc <SOC_moduleSetClockFrequencyWithParent+0x1ac> @ imm = #-0x2
;     }
7009e3cc: e7ff         	b	0x7009e3ce <SOC_moduleSetClockFrequencyWithParent+0x1ae> @ imm = #-0x2
;     return status;
7009e3ce: 980b         	ldr	r0, [sp, #0x2c]
7009e3d0: b012         	add	sp, #0x48
7009e3d2: bd80         	pop	{r7, pc}

7009e3d4 <memalign>:
7009e3d4: e92d4bf0     	push	{r4, r5, r6, r7, r8, r9, r11, lr}
7009e3d8: e59f5190     	ldr	r5, [pc, #0x190]        @ 0x7009e570 <memalign+0x19c>
7009e3dc: e3a02000     	mov	r2, #0
7009e3e0: e3a08000     	mov	r8, #0
7009e3e4: e2413001     	sub	r3, r1, #1
7009e3e8: e2454008     	sub	r4, r5, #8
7009e3ec: e3550007     	cmp	r5, #7
7009e3f0: 81a02004     	movhi	r2, r4
7009e3f4: e1530002     	cmp	r3, r2
7009e3f8: 2a00005a     	bhs	0x7009e568 <memalign+0x194> @ imm = #0x168
7009e3fc: e2402001     	sub	r2, r0, #1
7009e400: e59f316c     	ldr	r3, [pc, #0x16c]        @ 0x7009e574 <memalign+0x1a0>
7009e404: e3a07008     	mov	r7, #8
7009e408: e2816007     	add	r6, r1, #7
7009e40c: e1100002     	tst	r0, r2
7009e410: 01a07000     	moveq	r7, r0
7009e414: e3500007     	cmp	r0, #7
7009e418: e5930000     	ldr	r0, [r3]
7009e41c: e3a02008     	mov	r2, #8
7009e420: 91a07002     	movls	r7, r2
7009e424: e12fff30     	blx	r0
7009e428: e59f0148     	ldr	r0, [pc, #0x148]        @ 0x7009e578 <memalign+0x1a4>
7009e42c: e5d01000     	ldrb	r1, [r0]
7009e430: e3510000     	cmp	r1, #0
7009e434: 1a000011     	bne	0x7009e480 <memalign+0xac> @ imm = #0x44
7009e438: e3a02000     	mov	r2, #0
7009e43c: e3a01000     	mov	r1, #0
7009e440: e3550007     	cmp	r5, #7
7009e444: 81a02004     	movhi	r2, r4
7009e448: e3520000     	cmp	r2, #0
7009e44c: 1a000002     	bne	0x7009e45c <memalign+0x88> @ imm = #0x8
7009e450: e59f2124     	ldr	r2, [pc, #0x124]        @ 0x7009e57c <memalign+0x1a8>
7009e454: e5821000     	str	r1, [r2]
7009e458: ea000006     	b	0x7009e478 <memalign+0xa4> @ imm = #0x18
7009e45c: e59f211c     	ldr	r2, [pc, #0x11c]        @ 0x7009e580 <memalign+0x1ac>
7009e460: e3550007     	cmp	r5, #7
7009e464: 91a04001     	movls	r4, r1
7009e468: e59f310c     	ldr	r3, [pc, #0x10c]        @ 0x7009e57c <memalign+0x1a8>
7009e46c: e5821008     	str	r1, [r2, #0x8]
7009e470: e5832000     	str	r2, [r3]
7009e474: e5824000     	str	r4, [r2]
7009e478: e3a01001     	mov	r1, #1
7009e47c: e5c01000     	strb	r1, [r0]
7009e480: e59f50f4     	ldr	r5, [pc, #0xf4]         @ 0x7009e57c <memalign+0x1a8>
7009e484: e3c69007     	bic	r9, r6, #7
7009e488: e2470001     	sub	r0, r7, #1
7009e48c: e2671000     	rsb	r1, r7, #0
7009e490: e5956000     	ldr	r6, [r5]
7009e494: e3560000     	cmp	r6, #0
7009e498: 0a00002f     	beq	0x7009e55c <memalign+0x188> @ imm = #0xbc
7009e49c: e2865008     	add	r5, r6, #8
7009e4a0: e0802005     	add	r2, r0, r5
7009e4a4: e0024001     	and	r4, r2, r1
7009e4a8: e1550004     	cmp	r5, r4
7009e4ac: 0a00000c     	beq	0x7009e4e4 <memalign+0x110> @ imm = #0x30
7009e4b0: e2862010     	add	r2, r6, #16
7009e4b4: e2443008     	sub	r3, r4, #8
7009e4b8: e1520003     	cmp	r2, r3
7009e4bc: 9a000001     	bls	0x7009e4c8 <memalign+0xf4> @ imm = #0x4
7009e4c0: e0844007     	add	r4, r4, r7
7009e4c4: eafffffa     	b	0x7009e4b4 <memalign+0xe0> @ imm = #-0x18
7009e4c8: e5962000     	ldr	r2, [r6]
7009e4cc: e0843009     	add	r3, r4, r9
7009e4d0: e3c22001     	bic	r2, r2, #1
7009e4d4: e0852002     	add	r2, r5, r2
7009e4d8: e1520003     	cmp	r2, r3
7009e4dc: 3affffeb     	blo	0x7009e490 <memalign+0xbc> @ imm = #-0x54
7009e4e0: ea000004     	b	0x7009e4f8 <memalign+0x124> @ imm = #0x10
7009e4e4: e5962000     	ldr	r2, [r6]
7009e4e8: e3c22001     	bic	r2, r2, #1
7009e4ec: e1520009     	cmp	r2, r9
7009e4f0: baffffe6     	blt	0x7009e490 <memalign+0xbc> @ imm = #-0x68
7009e4f4: e1a04005     	mov	r4, r5
7009e4f8: e1a00006     	mov	r0, r6
7009e4fc: eb003944     	bl	0x700aca14 <free_list_remove> @ imm = #0xe510
7009e500: e1540005     	cmp	r4, r5
7009e504: 0a00000c     	beq	0x7009e53c <memalign+0x168> @ imm = #0x30
7009e508: e5960000     	ldr	r0, [r6]
7009e50c: e0441005     	sub	r1, r4, r5
7009e510: e2412008     	sub	r2, r1, #8
7009e514: e1a04006     	mov	r4, r6
7009e518: e3c00001     	bic	r0, r0, #1
7009e51c: e0400001     	sub	r0, r0, r1
7009e520: e3c21001     	bic	r1, r2, #1
7009e524: e3800001     	orr	r0, r0, #1
7009e528: e6842001     	str	r2, [r4], r1
7009e52c: e5a40008     	str	r0, [r4, #0x8]!
7009e530: e1a00006     	mov	r0, r6
7009e534: eb0036f9     	bl	0x700ac120 <free_list_insert> @ imm = #0xdbe4
7009e538: e1a06004     	mov	r6, r4
7009e53c: e1a00006     	mov	r0, r6
7009e540: e1a01009     	mov	r1, r9
7009e544: eb00220a     	bl	0x700a6d74 <split>      @ imm = #0x8828
7009e548: e59f0034     	ldr	r0, [pc, #0x34]         @ 0x7009e584 <memalign+0x1b0>
7009e54c: e5900000     	ldr	r0, [r0]
7009e550: e12fff30     	blx	r0
7009e554: e2868008     	add	r8, r6, #8
7009e558: ea000002     	b	0x7009e568 <memalign+0x194> @ imm = #0x8
7009e55c: e59f0020     	ldr	r0, [pc, #0x20]         @ 0x7009e584 <memalign+0x1b0>
7009e560: e5900000     	ldr	r0, [r0]
7009e564: e12fff30     	blx	r0
7009e568: e1a00008     	mov	r0, r8
7009e56c: e8bd8bf0     	pop	{r4, r5, r6, r7, r8, r9, r11, pc}
7009e570: 00 00 01 00  	.word	0x00010000
7009e574: 78 0d 0b 70  	.word	0x700b0d78
7009e578: 08 0e 0b 70  	.word	0x700b0e08
7009e57c: bc 4d 08 70  	.word	0x70084dbc
7009e580: 00 4e 08 70  	.word	0x70084e00
7009e584: 7c 0d 0b 70  	.word	0x700b0d7c
7009e588: 00 00 00 00  	.word	0x00000000
7009e58c: 00 00 00 00  	.word	0x00000000

7009e590 <UART_close>:
; {
7009e590: b580         	push	{r7, lr}
7009e592: b08a         	sub	sp, #0x28
7009e594: 9009         	str	r0, [sp, #0x24]
;     config = (UART_Config *) handle;
7009e596: 9809         	ldr	r0, [sp, #0x24]
7009e598: 9008         	str	r0, [sp, #0x20]
;     if ((NULL != config) && (config->object != NULL) && (config->object->isOpen != FALSE))
7009e59a: 9808         	ldr	r0, [sp, #0x20]
7009e59c: 2800         	cmp	r0, #0x0
7009e59e: f000 80ce    	beq.w	0x7009e73e <UART_close+0x1ae> @ imm = #0x19c
7009e5a2: e7ff         	b	0x7009e5a4 <UART_close+0x14> @ imm = #-0x2
7009e5a4: 9808         	ldr	r0, [sp, #0x20]
7009e5a6: 6840         	ldr	r0, [r0, #0x4]
7009e5a8: 2800         	cmp	r0, #0x0
7009e5aa: f000 80c8    	beq.w	0x7009e73e <UART_close+0x1ae> @ imm = #0x190
7009e5ae: e7ff         	b	0x7009e5b0 <UART_close+0x20> @ imm = #-0x2
7009e5b0: 9808         	ldr	r0, [sp, #0x20]
7009e5b2: 6840         	ldr	r0, [r0, #0x4]
7009e5b4: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009e5b8: 2800         	cmp	r0, #0x0
7009e5ba: f000 80c0    	beq.w	0x7009e73e <UART_close+0x1ae> @ imm = #0x180
7009e5be: e7ff         	b	0x7009e5c0 <UART_close+0x30> @ imm = #-0x2
;         object = config->object;
7009e5c0: 9808         	ldr	r0, [sp, #0x20]
7009e5c2: 6840         	ldr	r0, [r0, #0x4]
7009e5c4: 9007         	str	r0, [sp, #0x1c]
;         attrs = config->attrs;
7009e5c6: 9808         	ldr	r0, [sp, #0x20]
7009e5c8: 6800         	ldr	r0, [r0]
7009e5ca: 9006         	str	r0, [sp, #0x18]
;         object->uartLld_handle = &object->uartLld_object;
7009e5cc: 9907         	ldr	r1, [sp, #0x1c]
7009e5ce: f501 7022    	add.w	r0, r1, #0x288
7009e5d2: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;         uartLld_handle = object->uartLld_handle;
7009e5d6: 9807         	ldr	r0, [sp, #0x1c]
7009e5d8: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009e5dc: 9005         	str	r0, [sp, #0x14]
;         DebugP_assert(NULL_PTR != object);
7009e5de: 9807         	ldr	r0, [sp, #0x1c]
7009e5e0: 2800         	cmp	r0, #0x0
7009e5e2: bf18         	it	ne
7009e5e4: 2001         	movne	r0, #0x1
7009e5e6: f240 31ca    	movw	r1, #0x3ca
7009e5ea: f2c7 010b    	movt	r1, #0x700b
7009e5ee: 466a         	mov	r2, sp
7009e5f0: 6011         	str	r1, [r2]
7009e5f2: f240 31dd    	movw	r1, #0x3dd
7009e5f6: f2c7 010b    	movt	r1, #0x700b
7009e5fa: 9101         	str	r1, [sp, #0x4]
7009e5fc: f240 520a    	movw	r2, #0x50a
7009e600: f2c7 020b    	movt	r2, #0x700b
7009e604: 9202         	str	r2, [sp, #0x8]
7009e606: f240 13c5    	movw	r3, #0x1c5
7009e60a: f00a fd89    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xab12
7009e60e: 9901         	ldr	r1, [sp, #0x4]
7009e610: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != attrs);
7009e612: 9806         	ldr	r0, [sp, #0x18]
7009e614: 2800         	cmp	r0, #0x0
7009e616: bf18         	it	ne
7009e618: 2001         	movne	r0, #0x1
7009e61a: f240 4313    	movw	r3, #0x413
7009e61e: f2c7 030b    	movt	r3, #0x700b
7009e622: 46ec         	mov	r12, sp
7009e624: f8cc 3000    	str.w	r3, [r12]
7009e628: f44f 73e3    	mov.w	r3, #0x1c6
7009e62c: f00a fd78    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xaaf0
7009e630: 9901         	ldr	r1, [sp, #0x4]
7009e632: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != gUartDrvObj.lock);
7009e634: f640 23e0    	movw	r3, #0xae0
7009e638: f2c7 030b    	movt	r3, #0x700b
7009e63c: f853 0b04    	ldr	r0, [r3], #4
7009e640: 9303         	str	r3, [sp, #0xc]
7009e642: 2800         	cmp	r0, #0x0
7009e644: bf18         	it	ne
7009e646: 2001         	movne	r0, #0x1
7009e648: f240 1374    	movw	r3, #0x174
7009e64c: f2c7 030b    	movt	r3, #0x700b
7009e650: 46ec         	mov	r12, sp
7009e652: f8cc 3000    	str.w	r3, [r12]
7009e656: f44f 73e4    	mov.w	r3, #0x1c8
7009e65a: f00a fd61    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xaac2
7009e65e: 9803         	ldr	r0, [sp, #0xc]
7009e660: f04f 31ff    	mov.w	r1, #0xffffffff
;         (void)SemaphoreP_pend(&gUartDrvObj.lockObj, SystemP_WAIT_FOREVER);
7009e664: f00a fb04    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0xa608
;         UART_flushTxFifo(handle);
7009e668: 9809         	ldr	r0, [sp, #0x24]
7009e66a: f007 f8d1    	bl	0x700a5810 <UART_flushTxFifo> @ imm = #0x71a2
;         UART_intrDisable(attrs->baseAddr,
7009e66e: 9806         	ldr	r0, [sp, #0x18]
7009e670: 6800         	ldr	r0, [r0]
7009e672: 2107         	movs	r1, #0x7
7009e674: 9104         	str	r1, [sp, #0x10]
7009e676: f006 f863    	bl	0x700a4740 <UART_intrDisable> @ imm = #0x60c6
;         UART_intr2Disable(attrs->baseAddr, UART_INT2_TX_EMPTY);
7009e67a: 9806         	ldr	r0, [sp, #0x18]
7009e67c: 6800         	ldr	r0, [r0]
7009e67e: 2102         	movs	r1, #0x2
7009e680: f00e fdce    	bl	0x700ad220 <UART_intr2Disable> @ imm = #0xeb9c
7009e684: 9904         	ldr	r1, [sp, #0x10]
;         (void)UART_operatingModeSelect(attrs->baseAddr, UART_OPER_MODE_DISABLED);
7009e686: 9806         	ldr	r0, [sp, #0x18]
7009e688: 6800         	ldr	r0, [r0]
7009e68a: f00e fe11    	bl	0x700ad2b0 <UART_operatingModeSelect> @ imm = #0xec22
;         if(UART_CONFIG_MODE_DMA == object->prms.transferMode)
7009e68e: 9807         	ldr	r0, [sp, #0x1c]
7009e690: 6b00         	ldr	r0, [r0, #0x30]
7009e692: 2803         	cmp	r0, #0x3
7009e694: d104         	bne	0x7009e6a0 <UART_close+0x110> @ imm = #0x8
7009e696: e7ff         	b	0x7009e698 <UART_close+0x108> @ imm = #-0x2
;             (void)UART_lld_deInitDma(uartLld_handle);
7009e698: 9805         	ldr	r0, [sp, #0x14]
7009e69a: f00b fcb1    	bl	0x700aa000 <UART_lld_deInitDma> @ imm = #0xb962
;         }
7009e69e: e003         	b	0x7009e6a8 <UART_close+0x118> @ imm = #0x6
;             (void)UART_lld_deInit(uartLld_handle);
7009e6a0: 9805         	ldr	r0, [sp, #0x14]
7009e6a2: f00c f9bd    	bl	0x700aaa20 <UART_lld_deInit> @ imm = #0xc37a
7009e6a6: e7ff         	b	0x7009e6a8 <UART_close+0x118> @ imm = #-0x2
;         if(NULL != object->lock)
7009e6a8: 9807         	ldr	r0, [sp, #0x1c]
7009e6aa: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009e6ae: b148         	cbz	r0, 0x7009e6c4 <UART_close+0x134> @ imm = #0x12
7009e6b0: e7ff         	b	0x7009e6b2 <UART_close+0x122> @ imm = #-0x2
;             SemaphoreP_destruct(&object->lockObj);
7009e6b2: 9807         	ldr	r0, [sp, #0x1c]
7009e6b4: 308c         	adds	r0, #0x8c
7009e6b6: f00f fb43    	bl	0x700add40 <SemaphoreP_destruct> @ imm = #0xf686
;             object->lock = NULL;
7009e6ba: 9907         	ldr	r1, [sp, #0x1c]
7009e6bc: 2000         	movs	r0, #0x0
7009e6be: f8c1 0088    	str.w	r0, [r1, #0x88]
;         }
7009e6c2: e7ff         	b	0x7009e6c4 <UART_close+0x134> @ imm = #-0x2
;         if(NULL != object->readTransferSem)
7009e6c4: 9807         	ldr	r0, [sp, #0x1c]
7009e6c6: f8d0 0124    	ldr.w	r0, [r0, #0x124]
7009e6ca: b160         	cbz	r0, 0x7009e6e6 <UART_close+0x156> @ imm = #0x18
7009e6cc: e7ff         	b	0x7009e6ce <UART_close+0x13e> @ imm = #-0x2
;             SemaphoreP_destruct(&object->readTransferSemObj);
7009e6ce: 9807         	ldr	r0, [sp, #0x1c]
7009e6d0: f500 7094    	add.w	r0, r0, #0x128
7009e6d4: f00f fb34    	bl	0x700add40 <SemaphoreP_destruct> @ imm = #0xf668
;             object->readTransferSem = NULL;
7009e6d8: 9907         	ldr	r1, [sp, #0x1c]
7009e6da: 2000         	movs	r0, #0x0
7009e6dc: f8c1 0124    	str.w	r0, [r1, #0x124]
;             uartLld_handle->readTransferMutex = NULL;
7009e6e0: 9905         	ldr	r1, [sp, #0x14]
7009e6e2: 6588         	str	r0, [r1, #0x58]
;         }
7009e6e4: e7ff         	b	0x7009e6e6 <UART_close+0x156> @ imm = #-0x2
;         if(NULL != object->writeTransferSem)
7009e6e6: 9807         	ldr	r0, [sp, #0x1c]
7009e6e8: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
7009e6ec: b160         	cbz	r0, 0x7009e708 <UART_close+0x178> @ imm = #0x18
7009e6ee: e7ff         	b	0x7009e6f0 <UART_close+0x160> @ imm = #-0x2
;             SemaphoreP_destruct(&object->writeTransferSemObj);
7009e6f0: 9807         	ldr	r0, [sp, #0x1c]
7009e6f2: f500 70e2    	add.w	r0, r0, #0x1c4
7009e6f6: f00f fb23    	bl	0x700add40 <SemaphoreP_destruct> @ imm = #0xf646
;             object->writeTransferSem = NULL;
7009e6fa: 9907         	ldr	r1, [sp, #0x1c]
7009e6fc: 2000         	movs	r0, #0x0
7009e6fe: f8c1 01c0    	str.w	r0, [r1, #0x1c0]
;             uartLld_handle->writeTransferMutex = NULL;
7009e702: 9905         	ldr	r1, [sp, #0x14]
7009e704: 65c8         	str	r0, [r1, #0x5c]
;         }
7009e706: e7ff         	b	0x7009e708 <UART_close+0x178> @ imm = #-0x2
;         if(NULL != object->hwiHandle)
7009e708: 9807         	ldr	r0, [sp, #0x1c]
7009e70a: f8d0 025c    	ldr.w	r0, [r0, #0x25c]
7009e70e: b150         	cbz	r0, 0x7009e726 <UART_close+0x196> @ imm = #0x14
7009e710: e7ff         	b	0x7009e712 <UART_close+0x182> @ imm = #-0x2
;             HwiP_destruct(&object->hwiObj);
7009e712: 9807         	ldr	r0, [sp, #0x1c]
7009e714: f500 7018    	add.w	r0, r0, #0x260
7009e718: f00f ff62    	bl	0x700ae5e0 <HwiP_destruct> @ imm = #0xfec4
;             object->hwiHandle = NULL;
7009e71c: 9907         	ldr	r1, [sp, #0x1c]
7009e71e: 2000         	movs	r0, #0x0
7009e720: f8c1 025c    	str.w	r0, [r1, #0x25c]
;         }
7009e724: e7ff         	b	0x7009e726 <UART_close+0x196> @ imm = #-0x2
;         object->isOpen = FALSE;
7009e726: 9907         	ldr	r1, [sp, #0x1c]
7009e728: 2000         	movs	r0, #0x0
7009e72a: f8c1 0084    	str.w	r0, [r1, #0x84]
;         SemaphoreP_post(&gUartDrvObj.lockObj);
7009e72e: f640 20e0    	movw	r0, #0xae0
7009e732: f2c7 000b    	movt	r0, #0x700b
7009e736: 3004         	adds	r0, #0x4
7009e738: f00b fdea    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0xbbd4
;     }
7009e73c: e7ff         	b	0x7009e73e <UART_close+0x1ae> @ imm = #-0x2
;     return;
7009e73e: b00a         	add	sp, #0x28
7009e740: bd80         	pop	{r7, pc}
7009e742: 0000         	movs	r0, r0

7009e744 <free>:
7009e744: e3500000     	cmp	r0, #0
7009e748: 012fff1e     	bxeq	lr
7009e74c: e92d41f0     	push	{r4, r5, r6, r7, r8, lr}
7009e750: e1a04000     	mov	r4, r0
7009e754: e59f0188     	ldr	r0, [pc, #0x188]        @ 0x7009e8e4 <free+0x1a0>
7009e758: e5900000     	ldr	r0, [r0]
7009e75c: e12fff30     	blx	r0
7009e760: e59f0180     	ldr	r0, [pc, #0x180]        @ 0x7009e8e8 <free+0x1a4>
7009e764: e2444008     	sub	r4, r4, #8
7009e768: e3a05000     	mov	r5, #0
7009e76c: e5901000     	ldr	r1, [r0]
7009e770: e1500004     	cmp	r0, r4
7009e774: e3c12001     	bic	r2, r1, #1
7009e778: 2a000004     	bhs	0x7009e790 <free+0x4c>  @ imm = #0x10
7009e77c: e0801002     	add	r1, r0, r2
7009e780: e1a05000     	mov	r5, r0
7009e784: e2811008     	add	r1, r1, #8
7009e788: e1a00001     	mov	r0, r1
7009e78c: eafffff6     	b	0x7009e76c <free+0x28>  @ imm = #-0x28
7009e790: e59f3150     	ldr	r3, [pc, #0x150]        @ 0x7009e8e8 <free+0x1a4>
7009e794: e0802002     	add	r2, r0, r2
7009e798: e59f714c     	ldr	r7, [pc, #0x14c]        @ 0x7009e8ec <free+0x1a8>
7009e79c: e2826008     	add	r6, r2, #8
7009e7a0: e0872003     	add	r2, r7, r3
7009e7a4: e3570007     	cmp	r7, #7
7009e7a8: 82423008     	subhi	r3, r2, #8
7009e7ac: e1560003     	cmp	r6, r3
7009e7b0: 83006000     	movwhi	r6, #0x0
7009e7b4: e1500004     	cmp	r0, r4
7009e7b8: 1a000045     	bne	0x7009e8d4 <free+0x190> @ imm = #0x114
7009e7bc: e2110001     	ands	r0, r1, #1
7009e7c0: 0a000043     	beq	0x7009e8d4 <free+0x190> @ imm = #0x10c
7009e7c4: e3550000     	cmp	r5, #0
7009e7c8: 0a000009     	beq	0x7009e7f4 <free+0xb0>  @ imm = #0x24
7009e7cc: e5951000     	ldr	r1, [r5]
7009e7d0: e3a00000     	mov	r0, #0
7009e7d4: e3a07000     	mov	r7, #0
7009e7d8: e2111001     	ands	r1, r1, #1
7009e7dc: 01a00005     	moveq	r0, r5
7009e7e0: e3560000     	cmp	r6, #0
7009e7e4: 1a000005     	bne	0x7009e800 <free+0xbc>  @ imm = #0x14
7009e7e8: e3510000     	cmp	r1, #0
7009e7ec: 0a00000b     	beq	0x7009e820 <free+0xdc>  @ imm = #0x2c
7009e7f0: ea000022     	b	0x7009e880 <free+0x13c> @ imm = #0x88
7009e7f4: e3a00000     	mov	r0, #0
7009e7f8: e3560000     	cmp	r6, #0
7009e7fc: 0a00001f     	beq	0x7009e880 <free+0x13c> @ imm = #0x7c
7009e800: e5d61000     	ldrb	r1, [r6]
7009e804: e3a07000     	mov	r7, #0
7009e808: e3a08000     	mov	r8, #0
7009e80c: e3110001     	tst	r1, #1
7009e810: 01a07006     	moveq	r7, r6
7009e814: e3500000     	cmp	r0, #0
7009e818: 0a000007     	beq	0x7009e83c <free+0xf8>  @ imm = #0x1c
7009e81c: e1a05000     	mov	r5, r0
7009e820: e1a00005     	mov	r0, r5
7009e824: eb00387a     	bl	0x700aca14 <free_list_remove> @ imm = #0xe1e8
7009e828: e3a08001     	mov	r8, #1
7009e82c: e3570000     	cmp	r7, #0
7009e830: 0a00001d     	beq	0x7009e8ac <free+0x168> @ imm = #0x74
7009e834: e1a06007     	mov	r6, r7
7009e838: ea000002     	b	0x7009e848 <free+0x104> @ imm = #0x8
7009e83c: e3a05000     	mov	r5, #0
7009e840: e3570000     	cmp	r7, #0
7009e844: 0a00000d     	beq	0x7009e880 <free+0x13c> @ imm = #0x34
7009e848: e1a00006     	mov	r0, r6
7009e84c: eb003870     	bl	0x700aca14 <free_list_remove> @ imm = #0xe1c0
7009e850: e3580000     	cmp	r8, #0
7009e854: 0a00000c     	beq	0x7009e88c <free+0x148> @ imm = #0x30
7009e858: e5950000     	ldr	r0, [r5]
7009e85c: e5941000     	ldr	r1, [r4]
7009e860: e5962000     	ldr	r2, [r6]
7009e864: e2800010     	add	r0, r0, #16
7009e868: e3c11001     	bic	r1, r1, #1
7009e86c: e3c00001     	bic	r0, r0, #1
7009e870: e3c22001     	bic	r2, r2, #1
7009e874: e0800001     	add	r0, r0, r1
7009e878: e0800002     	add	r0, r0, r2
7009e87c: ea000010     	b	0x7009e8c4 <free+0x180> @ imm = #0x40
7009e880: e5940000     	ldr	r0, [r4]
7009e884: e3c00001     	bic	r0, r0, #1
7009e888: ea000005     	b	0x7009e8a4 <free+0x160> @ imm = #0x14
7009e88c: e5940000     	ldr	r0, [r4]
7009e890: e5961000     	ldr	r1, [r6]
7009e894: e2800008     	add	r0, r0, #8
7009e898: e3c11001     	bic	r1, r1, #1
7009e89c: e3c00001     	bic	r0, r0, #1
7009e8a0: e0800001     	add	r0, r0, r1
7009e8a4: e5840000     	str	r0, [r4]
7009e8a8: ea000007     	b	0x7009e8cc <free+0x188> @ imm = #0x1c
7009e8ac: e5950000     	ldr	r0, [r5]
7009e8b0: e5941000     	ldr	r1, [r4]
7009e8b4: e2800008     	add	r0, r0, #8
7009e8b8: e3c11001     	bic	r1, r1, #1
7009e8bc: e3c00001     	bic	r0, r0, #1
7009e8c0: e0800001     	add	r0, r0, r1
7009e8c4: e1a04005     	mov	r4, r5
7009e8c8: e5850000     	str	r0, [r5]
7009e8cc: e1a00004     	mov	r0, r4
7009e8d0: eb003612     	bl	0x700ac120 <free_list_insert> @ imm = #0xd848
7009e8d4: e59f0014     	ldr	r0, [pc, #0x14]         @ 0x7009e8f0 <free+0x1ac>
7009e8d8: e5900000     	ldr	r0, [r0]
7009e8dc: e8bd41f0     	pop	{r4, r5, r6, r7, r8, lr}
7009e8e0: e12fff10     	bx	r0
7009e8e4: 78 0d 0b 70  	.word	0x700b0d78
7009e8e8: 00 4e 08 70  	.word	0x70084e00
7009e8ec: 00 00 01 00  	.word	0x00010000
7009e8f0: 7c 0d 0b 70  	.word	0x700b0d7c
7009e8f4: 00 00 00 00  	.word	0x00000000
7009e8f8: 00 00 00 00  	.word	0x00000000
7009e8fc: 00 00 00 00  	.word	0x00000000

7009e900 <UART_lld_controllerIsr>:
; {
7009e900: b580         	push	{r7, lr}
7009e902: b086         	sub	sp, #0x18
7009e904: 9005         	str	r0, [sp, #0x14]
7009e906: 2001         	movs	r0, #0x1
;     uint32_t            retVal = TRUE;
7009e908: 9001         	str	r0, [sp, #0x4]
;     if(NULL != args)
7009e90a: 9805         	ldr	r0, [sp, #0x14]
7009e90c: 2800         	cmp	r0, #0x0
7009e90e: f000 80c8    	beq.w	0x7009eaa2 <UART_lld_controllerIsr+0x1a2> @ imm = #0x190
7009e912: e7ff         	b	0x7009e914 <UART_lld_controllerIsr+0x14> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
7009e914: 9805         	ldr	r0, [sp, #0x14]
7009e916: 9002         	str	r0, [sp, #0x8]
;         while (retVal == TRUE)
7009e918: e7ff         	b	0x7009e91a <UART_lld_controllerIsr+0x1a> @ imm = #-0x2
7009e91a: 9801         	ldr	r0, [sp, #0x4]
7009e91c: 2801         	cmp	r0, #0x1
7009e91e: f040 80bf    	bne.w	0x7009eaa0 <UART_lld_controllerIsr+0x1a0> @ imm = #0x17e
7009e922: e7ff         	b	0x7009e924 <UART_lld_controllerIsr+0x24> @ imm = #-0x2
;             intType = UART_getIntrIdentityStatus(hUart->baseAddr);
7009e924: 9802         	ldr	r0, [sp, #0x8]
7009e926: 6800         	ldr	r0, [r0]
7009e928: f00c fff2    	bl	0x700ab910 <UART_getIntrIdentityStatus> @ imm = #0xcfe4
7009e92c: 9004         	str	r0, [sp, #0x10]
;             if ((intType & UART_INTID_RX_THRES_REACH) == UART_INTID_RX_THRES_REACH)
7009e92e: f89d 0010    	ldrb.w	r0, [sp, #0x10]
7009e932: 0740         	lsls	r0, r0, #0x1d
7009e934: 2800         	cmp	r0, #0x0
7009e936: d561         	bpl	0x7009e9fc <UART_lld_controllerIsr+0xfc> @ imm = #0xc2
7009e938: e7ff         	b	0x7009e93a <UART_lld_controllerIsr+0x3a> @ imm = #-0x2
;                 if ((intType & UART_INTID_RX_LINE_STAT_ERROR) ==
7009e93a: 9804         	ldr	r0, [sp, #0x10]
7009e93c: f000 0006    	and	r0, r0, #0x6
7009e940: 2806         	cmp	r0, #0x6
7009e942: d104         	bne	0x7009e94e <UART_lld_controllerIsr+0x4e> @ imm = #0x8
7009e944: e7ff         	b	0x7009e946 <UART_lld_controllerIsr+0x46> @ imm = #-0x2
;                     (void)UART_procLineStatusErr(hUart);
7009e946: 9802         	ldr	r0, [sp, #0x8]
7009e948: f002 fb8a    	bl	0x700a1060 <UART_procLineStatusErr> @ imm = #0x2714
;                 }
7009e94c: e055         	b	0x7009e9fa <UART_lld_controllerIsr+0xfa> @ imm = #0xaa
;                     if ((intType & UART_INTID_CHAR_TIMEOUT) == UART_INTID_CHAR_TIMEOUT)
7009e94e: 9804         	ldr	r0, [sp, #0x10]
7009e950: f000 000c    	and	r0, r0, #0xc
7009e954: 280c         	cmp	r0, #0xc
7009e956: d10a         	bne	0x7009e96e <UART_lld_controllerIsr+0x6e> @ imm = #0x14
7009e958: e7ff         	b	0x7009e95a <UART_lld_controllerIsr+0x5a> @ imm = #-0x2
;                         UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009e95a: 9802         	ldr	r0, [sp, #0x8]
7009e95c: 6800         	ldr	r0, [r0]
7009e95e: 2105         	movs	r1, #0x5
7009e960: f005 feee    	bl	0x700a4740 <UART_intrDisable> @ imm = #0x5ddc
;                         hUart->rxTimeoutCnt++;
7009e964: 9902         	ldr	r1, [sp, #0x8]
7009e966: 6a08         	ldr	r0, [r1, #0x20]
7009e968: 3001         	adds	r0, #0x1
7009e96a: 6208         	str	r0, [r1, #0x20]
;                     }
7009e96c: e7ff         	b	0x7009e96e <UART_lld_controllerIsr+0x6e> @ imm = #-0x2
;                     if (hUart->readSizeRemaining > 0U)
7009e96e: 9802         	ldr	r0, [sp, #0x8]
7009e970: 69c0         	ldr	r0, [r0, #0x1c]
7009e972: b3a8         	cbz	r0, 0x7009e9e0 <UART_lld_controllerIsr+0xe0> @ imm = #0x6a
7009e974: e7ff         	b	0x7009e976 <UART_lld_controllerIsr+0x76> @ imm = #-0x2
;                         hUart->readSizeRemaining = UART_readData(hUart, hUart->readSizeRemaining);
7009e976: 9802         	ldr	r0, [sp, #0x8]
7009e978: 69c1         	ldr	r1, [r0, #0x1c]
7009e97a: f00a fb91    	bl	0x700a90a0 <UART_readData> @ imm = #0xa722
7009e97e: 9902         	ldr	r1, [sp, #0x8]
7009e980: 61c8         	str	r0, [r1, #0x1c]
;                         if ((hUart->readSizeRemaining == 0U) ||
7009e982: 9802         	ldr	r0, [sp, #0x8]
7009e984: 69c0         	ldr	r0, [r0, #0x1c]
7009e986: b130         	cbz	r0, 0x7009e996 <UART_lld_controllerIsr+0x96> @ imm = #0xc
7009e988: e7ff         	b	0x7009e98a <UART_lld_controllerIsr+0x8a> @ imm = #-0x2
;                             (hUart->hUartInit->readReturnMode == UART_READ_RETURN_MODE_PARTIAL))
7009e98a: 9802         	ldr	r0, [sp, #0x8]
7009e98c: 6840         	ldr	r0, [r0, #0x4]
7009e98e: 6940         	ldr	r0, [r0, #0x14]
;                         if ((hUart->readSizeRemaining == 0U) ||
7009e990: 2801         	cmp	r0, #0x1
7009e992: d11e         	bne	0x7009e9d2 <UART_lld_controllerIsr+0xd2> @ imm = #0x3c
7009e994: e7ff         	b	0x7009e996 <UART_lld_controllerIsr+0x96> @ imm = #-0x2
;                             UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009e996: 9802         	ldr	r0, [sp, #0x8]
7009e998: 6800         	ldr	r0, [r0]
7009e99a: 2105         	movs	r1, #0x5
7009e99c: f005 fed0    	bl	0x700a4740 <UART_intrDisable> @ imm = #0x5da0
;                             hUart->readBuf = (uint8_t *)hUart->readBuf - hUart->readCount;
7009e9a0: 9902         	ldr	r1, [sp, #0x8]
7009e9a2: 6948         	ldr	r0, [r1, #0x14]
7009e9a4: 698a         	ldr	r2, [r1, #0x18]
7009e9a6: 1a80         	subs	r0, r0, r2
7009e9a8: 6148         	str	r0, [r1, #0x14]
;                             if (hUart->readTrans.buf != NULL)
7009e9aa: 9802         	ldr	r0, [sp, #0x8]
7009e9ac: 6a80         	ldr	r0, [r0, #0x28]
7009e9ae: b138         	cbz	r0, 0x7009e9c0 <UART_lld_controllerIsr+0xc0> @ imm = #0xe
7009e9b0: e7ff         	b	0x7009e9b2 <UART_lld_controllerIsr+0xb2> @ imm = #-0x2
;                                 hUart->readTrans.count = (uint32_t)(hUart->readCount);
7009e9b2: 9902         	ldr	r1, [sp, #0x8]
7009e9b4: 6988         	ldr	r0, [r1, #0x18]
7009e9b6: 62c8         	str	r0, [r1, #0x2c]
;                                 hUart->readTrans.status = UART_TRANSFER_STATUS_SUCCESS;
7009e9b8: 9902         	ldr	r1, [sp, #0x8]
7009e9ba: 2000         	movs	r0, #0x0
7009e9bc: 6348         	str	r0, [r1, #0x34]
;                             }
7009e9be: e7ff         	b	0x7009e9c0 <UART_lld_controllerIsr+0xc0> @ imm = #-0x2
;                             hUart->hUartInit->readCompleteCallbackFxn(hUart);
7009e9c0: 9802         	ldr	r0, [sp, #0x8]
7009e9c2: 6841         	ldr	r1, [r0, #0x4]
7009e9c4: 6dc9         	ldr	r1, [r1, #0x5c]
7009e9c6: 4788         	blx	r1
;                             UART_lld_Transaction_deInit(&hUart->readTrans);
7009e9c8: 9802         	ldr	r0, [sp, #0x8]
7009e9ca: 3028         	adds	r0, #0x28
7009e9cc: f00e ffa0    	bl	0x700ad910 <UART_lld_Transaction_deInit> @ imm = #0xef40
;                         }
7009e9d0: e005         	b	0x7009e9de <UART_lld_controllerIsr+0xde> @ imm = #0xa
;                             UART_intrEnable(hUart->baseAddr, (uint32_t) UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009e9d2: 9802         	ldr	r0, [sp, #0x8]
7009e9d4: 6800         	ldr	r0, [r0]
7009e9d6: 2105         	movs	r1, #0x5
7009e9d8: f005 fdd2    	bl	0x700a4580 <UART_intrEnable> @ imm = #0x5ba4
7009e9dc: e7ff         	b	0x7009e9de <UART_lld_controllerIsr+0xde> @ imm = #-0x2
;                     }
7009e9de: e00b         	b	0x7009e9f8 <UART_lld_controllerIsr+0xf8> @ imm = #0x16
;                         (void)UART_getChar(hUart->baseAddr, &rdData);
7009e9e0: 9802         	ldr	r0, [sp, #0x8]
7009e9e2: 6800         	ldr	r0, [r0]
7009e9e4: f10d 010f    	add.w	r1, sp, #0xf
7009e9e8: f00b fefa    	bl	0x700aa7e0 <UART_getChar> @ imm = #0xbdf4
;                         UART_intrDisable(hUart->baseAddr, (uint32_t) UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009e9ec: 9802         	ldr	r0, [sp, #0x8]
7009e9ee: 6800         	ldr	r0, [r0]
7009e9f0: 2105         	movs	r1, #0x5
7009e9f2: f005 fea5    	bl	0x700a4740 <UART_intrDisable> @ imm = #0x5d4a
7009e9f6: e7ff         	b	0x7009e9f8 <UART_lld_controllerIsr+0xf8> @ imm = #-0x2
7009e9f8: e7ff         	b	0x7009e9fa <UART_lld_controllerIsr+0xfa> @ imm = #-0x2
;             }
7009e9fa: e050         	b	0x7009ea9e <UART_lld_controllerIsr+0x19e> @ imm = #0xa0
;             else if ((intType & UART_INTID_TX_THRES_REACH) == UART_INTID_TX_THRES_REACH)
7009e9fc: f89d 0010    	ldrb.w	r0, [sp, #0x10]
7009ea00: 0780         	lsls	r0, r0, #0x1e
7009ea02: 2800         	cmp	r0, #0x0
7009ea04: d534         	bpl	0x7009ea70 <UART_lld_controllerIsr+0x170> @ imm = #0x68
7009ea06: e7ff         	b	0x7009ea08 <UART_lld_controllerIsr+0x108> @ imm = #-0x2
;                 if (hUart->writeSizeRemaining > 0U)
7009ea08: 9802         	ldr	r0, [sp, #0x8]
7009ea0a: 6900         	ldr	r0, [r0, #0x10]
7009ea0c: b348         	cbz	r0, 0x7009ea62 <UART_lld_controllerIsr+0x162> @ imm = #0x52
7009ea0e: e7ff         	b	0x7009ea10 <UART_lld_controllerIsr+0x110> @ imm = #-0x2
;                     hUart->writeSizeRemaining = (uint32_t)UART_writeData(hUart, (hUart->writeSizeRemaining));
7009ea10: 9802         	ldr	r0, [sp, #0x8]
7009ea12: 6901         	ldr	r1, [r0, #0x10]
7009ea14: f00b ff14    	bl	0x700aa840 <UART_writeData> @ imm = #0xbe28
7009ea18: 9902         	ldr	r1, [sp, #0x8]
7009ea1a: 6108         	str	r0, [r1, #0x10]
;                     if ((hUart->writeSizeRemaining) == 0U)
7009ea1c: 9802         	ldr	r0, [sp, #0x8]
7009ea1e: 6900         	ldr	r0, [r0, #0x10]
7009ea20: b9f0         	cbnz	r0, 0x7009ea60 <UART_lld_controllerIsr+0x160> @ imm = #0x3c
7009ea22: e7ff         	b	0x7009ea24 <UART_lld_controllerIsr+0x124> @ imm = #-0x2
;                         UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
7009ea24: 9802         	ldr	r0, [sp, #0x8]
7009ea26: 6800         	ldr	r0, [r0]
7009ea28: 2102         	movs	r1, #0x2
7009ea2a: f005 fe89    	bl	0x700a4740 <UART_intrDisable> @ imm = #0x5d12
;                         hUart->writeBuf = (const void *)((uint8_t *)hUart->writeBuf - hUart->writeCount);
7009ea2e: 9902         	ldr	r1, [sp, #0x8]
7009ea30: 6888         	ldr	r0, [r1, #0x8]
7009ea32: 68ca         	ldr	r2, [r1, #0xc]
7009ea34: 1a80         	subs	r0, r0, r2
7009ea36: 6088         	str	r0, [r1, #0x8]
;                         if (hUart->writeTrans.buf != NULL)
7009ea38: 9802         	ldr	r0, [sp, #0x8]
7009ea3a: 6bc0         	ldr	r0, [r0, #0x3c]
7009ea3c: b138         	cbz	r0, 0x7009ea4e <UART_lld_controllerIsr+0x14e> @ imm = #0xe
7009ea3e: e7ff         	b	0x7009ea40 <UART_lld_controllerIsr+0x140> @ imm = #-0x2
;                             hUart->writeTrans.count = (uint32_t)(hUart->writeCount);
7009ea40: 9902         	ldr	r1, [sp, #0x8]
7009ea42: 68c8         	ldr	r0, [r1, #0xc]
7009ea44: 6408         	str	r0, [r1, #0x40]
;                             hUart->writeTrans.status = UART_TRANSFER_STATUS_SUCCESS;
7009ea46: 9902         	ldr	r1, [sp, #0x8]
7009ea48: 2000         	movs	r0, #0x0
7009ea4a: 6488         	str	r0, [r1, #0x48]
;                         }
7009ea4c: e7ff         	b	0x7009ea4e <UART_lld_controllerIsr+0x14e> @ imm = #-0x2
;                         hUart->hUartInit->writeCompleteCallbackFxn(hUart);
7009ea4e: 9802         	ldr	r0, [sp, #0x8]
7009ea50: 6841         	ldr	r1, [r0, #0x4]
7009ea52: 6e09         	ldr	r1, [r1, #0x60]
7009ea54: 4788         	blx	r1
;                         UART_lld_Transaction_deInit(&hUart->writeTrans);
7009ea56: 9802         	ldr	r0, [sp, #0x8]
7009ea58: 303c         	adds	r0, #0x3c
7009ea5a: f00e ff59    	bl	0x700ad910 <UART_lld_Transaction_deInit> @ imm = #0xeeb2
;                     }
7009ea5e: e7ff         	b	0x7009ea60 <UART_lld_controllerIsr+0x160> @ imm = #-0x2
;                 }
7009ea60: e005         	b	0x7009ea6e <UART_lld_controllerIsr+0x16e> @ imm = #0xa
;                     UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
7009ea62: 9802         	ldr	r0, [sp, #0x8]
7009ea64: 6800         	ldr	r0, [r0]
7009ea66: 2102         	movs	r1, #0x2
7009ea68: f005 fe6a    	bl	0x700a4740 <UART_intrDisable> @ imm = #0x5cd4
7009ea6c: e7ff         	b	0x7009ea6e <UART_lld_controllerIsr+0x16e> @ imm = #-0x2
;             }
7009ea6e: e015         	b	0x7009ea9c <UART_lld_controllerIsr+0x19c> @ imm = #0x2a
;             else if ((intType & UART_INTID_CHAR_TIMEOUT) == UART_INTID_CHAR_TIMEOUT)
7009ea70: 9804         	ldr	r0, [sp, #0x10]
7009ea72: f000 000c    	and	r0, r0, #0xc
7009ea76: 280c         	cmp	r0, #0xc
7009ea78: d10c         	bne	0x7009ea94 <UART_lld_controllerIsr+0x194> @ imm = #0x18
7009ea7a: e7ff         	b	0x7009ea7c <UART_lld_controllerIsr+0x17c> @ imm = #-0x2
;                 if (FALSE == UART_checkCharsAvailInFifo(hUart->baseAddr))
7009ea7c: 9802         	ldr	r0, [sp, #0x8]
7009ea7e: 6800         	ldr	r0, [r0]
7009ea80: f00c fd66    	bl	0x700ab550 <UART_checkCharsAvailInFifo> @ imm = #0xcacc
7009ea84: b928         	cbnz	r0, 0x7009ea92 <UART_lld_controllerIsr+0x192> @ imm = #0xa
7009ea86: e7ff         	b	0x7009ea88 <UART_lld_controllerIsr+0x188> @ imm = #-0x2
;                     UART_i2310WA(hUart->baseAddr);
7009ea88: 9802         	ldr	r0, [sp, #0x8]
7009ea8a: 6800         	ldr	r0, [r0]
7009ea8c: f00d fc08    	bl	0x700ac2a0 <UART_i2310WA> @ imm = #0xd810
;                 }
7009ea90: e7ff         	b	0x7009ea92 <UART_lld_controllerIsr+0x192> @ imm = #-0x2
;             }
7009ea92: e002         	b	0x7009ea9a <UART_lld_controllerIsr+0x19a> @ imm = #0x4
7009ea94: 2000         	movs	r0, #0x0
;                 retVal = FALSE;
7009ea96: 9001         	str	r0, [sp, #0x4]
7009ea98: e7ff         	b	0x7009ea9a <UART_lld_controllerIsr+0x19a> @ imm = #-0x2
7009ea9a: e7ff         	b	0x7009ea9c <UART_lld_controllerIsr+0x19c> @ imm = #-0x2
7009ea9c: e7ff         	b	0x7009ea9e <UART_lld_controllerIsr+0x19e> @ imm = #-0x2
;         while (retVal == TRUE)
7009ea9e: e73c         	b	0x7009e91a <UART_lld_controllerIsr+0x1a> @ imm = #-0x188
;     }
7009eaa0: e000         	b	0x7009eaa4 <UART_lld_controllerIsr+0x1a4> @ imm = #0x0
7009eaa2: e7ff         	b	0x7009eaa4 <UART_lld_controllerIsr+0x1a4> @ imm = #-0x2
; }
7009eaa4: b006         	add	sp, #0x18
7009eaa6: bd80         	pop	{r7, pc}
		...

7009eab0 <UART_write>:
; {
7009eab0: b580         	push	{r7, lr}
7009eab2: b08e         	sub	sp, #0x38
7009eab4: 900d         	str	r0, [sp, #0x34]
7009eab6: 910c         	str	r1, [sp, #0x30]
7009eab8: 2000         	movs	r0, #0x0
;     int32_t             status = SystemP_SUCCESS, semStatus = SystemP_SUCCESS;
7009eaba: 900b         	str	r0, [sp, #0x2c]
7009eabc: 900a         	str	r0, [sp, #0x28]
;     if ((NULL_PTR == handle) || (NULL_PTR == trans))
7009eabe: 980d         	ldr	r0, [sp, #0x34]
7009eac0: b118         	cbz	r0, 0x7009eaca <UART_write+0x1a> @ imm = #0x6
7009eac2: e7ff         	b	0x7009eac4 <UART_write+0x14> @ imm = #-0x2
7009eac4: 980c         	ldr	r0, [sp, #0x30]
7009eac6: b920         	cbnz	r0, 0x7009ead2 <UART_write+0x22> @ imm = #0x8
7009eac8: e7ff         	b	0x7009eaca <UART_write+0x1a> @ imm = #-0x2
7009eaca: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009eace: 900b         	str	r0, [sp, #0x2c]
;     }
7009ead0: e7ff         	b	0x7009ead2 <UART_write+0x22> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009ead2: 980b         	ldr	r0, [sp, #0x2c]
7009ead4: 2800         	cmp	r0, #0x0
7009ead6: d141         	bne	0x7009eb5c <UART_write+0xac> @ imm = #0x82
7009ead8: e7ff         	b	0x7009eada <UART_write+0x2a> @ imm = #-0x2
;         config  = (UART_Config *) handle;
7009eada: 980d         	ldr	r0, [sp, #0x34]
7009eadc: 9009         	str	r0, [sp, #0x24]
;         object  = config->object;
7009eade: 9809         	ldr	r0, [sp, #0x24]
7009eae0: 6840         	ldr	r0, [r0, #0x4]
7009eae2: 9008         	str	r0, [sp, #0x20]
;         attrs   = config->attrs;
7009eae4: 9809         	ldr	r0, [sp, #0x24]
7009eae6: 6800         	ldr	r0, [r0]
7009eae8: 9007         	str	r0, [sp, #0x1c]
;         prms    = &config->object->prms;
7009eaea: 9809         	ldr	r0, [sp, #0x24]
7009eaec: 6840         	ldr	r0, [r0, #0x4]
7009eaee: 3004         	adds	r0, #0x4
7009eaf0: 9006         	str	r0, [sp, #0x18]
;         uartLld_handle = object->uartLld_handle;
7009eaf2: 9808         	ldr	r0, [sp, #0x20]
7009eaf4: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009eaf8: 9004         	str	r0, [sp, #0x10]
;         object->writeTrans = trans;
7009eafa: 980c         	ldr	r0, [sp, #0x30]
7009eafc: 9908         	ldr	r1, [sp, #0x20]
7009eafe: f8c1 0080    	str.w	r0, [r1, #0x80]
;         DebugP_assert(NULL_PTR != object);
7009eb02: 9808         	ldr	r0, [sp, #0x20]
7009eb04: 2800         	cmp	r0, #0x0
7009eb06: bf18         	it	ne
7009eb08: 2001         	movne	r0, #0x1
7009eb0a: f240 31ca    	movw	r1, #0x3ca
7009eb0e: f2c7 010b    	movt	r1, #0x700b
7009eb12: 466a         	mov	r2, sp
7009eb14: 6011         	str	r1, [r2]
7009eb16: f240 31dd    	movw	r1, #0x3dd
7009eb1a: f2c7 010b    	movt	r1, #0x700b
7009eb1e: 9101         	str	r1, [sp, #0x4]
7009eb20: f240 42f4    	movw	r2, #0x4f4
7009eb24: f2c7 020b    	movt	r2, #0x700b
7009eb28: 9202         	str	r2, [sp, #0x8]
7009eb2a: f44f 7305    	mov.w	r3, #0x214
7009eb2e: f00a faf7    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xa5ee
7009eb32: 9901         	ldr	r1, [sp, #0x4]
7009eb34: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != attrs);
7009eb36: 9807         	ldr	r0, [sp, #0x1c]
7009eb38: 2800         	cmp	r0, #0x0
7009eb3a: bf18         	it	ne
7009eb3c: 2001         	movne	r0, #0x1
7009eb3e: f240 4313    	movw	r3, #0x413
7009eb42: f2c7 030b    	movt	r3, #0x700b
7009eb46: 46ec         	mov	r12, sp
7009eb48: f8cc 3000    	str.w	r3, [r12]
7009eb4c: f240 2315    	movw	r3, #0x215
7009eb50: f00a fae6    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xa5cc
;         extendedParams.args = trans->args;
7009eb54: 980c         	ldr	r0, [sp, #0x30]
7009eb56: 6900         	ldr	r0, [r0, #0x10]
7009eb58: 9003         	str	r0, [sp, #0xc]
;     }
7009eb5a: e7ff         	b	0x7009eb5c <UART_write+0xac> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009eb5c: 980b         	ldr	r0, [sp, #0x2c]
7009eb5e: b950         	cbnz	r0, 0x7009eb76 <UART_write+0xc6> @ imm = #0x14
7009eb60: e7ff         	b	0x7009eb62 <UART_write+0xb2> @ imm = #-0x2
;         if (TRUE == prms->skipIntrReg)
7009eb62: 9806         	ldr	r0, [sp, #0x18]
7009eb64: 6b80         	ldr	r0, [r0, #0x38]
7009eb66: 2801         	cmp	r0, #0x1
7009eb68: d104         	bne	0x7009eb74 <UART_write+0xc4> @ imm = #0x8
7009eb6a: e7ff         	b	0x7009eb6c <UART_write+0xbc> @ imm = #-0x2
7009eb6c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009eb70: 900b         	str	r0, [sp, #0x2c]
;         }
7009eb72: e7ff         	b	0x7009eb74 <UART_write+0xc4> @ imm = #-0x2
;     }
7009eb74: e7ff         	b	0x7009eb76 <UART_write+0xc6> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009eb76: 980b         	ldr	r0, [sp, #0x2c]
7009eb78: 2800         	cmp	r0, #0x0
7009eb7a: d168         	bne	0x7009ec4e <UART_write+0x19e> @ imm = #0xd0
7009eb7c: e7ff         	b	0x7009eb7e <UART_write+0xce> @ imm = #-0x2
;         key = HwiP_disable();
7009eb7e: f010 e920    	blx	0x700aedc0 <HwiP_disable> @ imm = #0x10240
7009eb82: 9005         	str	r0, [sp, #0x14]
;         HwiP_restore(key);
7009eb84: 9805         	ldr	r0, [sp, #0x14]
7009eb86: f010 e93c    	blx	0x700aee00 <HwiP_restore> @ imm = #0x10278
;         uartLld_handle->state = UART_STATE_READY;
7009eb8a: 9904         	ldr	r1, [sp, #0x10]
7009eb8c: 2001         	movs	r0, #0x1
7009eb8e: 6548         	str	r0, [r1, #0x54]
;         if ((UART_CONFIG_MODE_INTERRUPT == prms->transferMode) ||
7009eb90: 9806         	ldr	r0, [sp, #0x18]
7009eb92: 6ac0         	ldr	r0, [r0, #0x2c]
7009eb94: 2801         	cmp	r0, #0x1
7009eb96: d005         	beq	0x7009eba4 <UART_write+0xf4> @ imm = #0xa
7009eb98: e7ff         	b	0x7009eb9a <UART_write+0xea> @ imm = #-0x2
;             (UART_CONFIG_MODE_DMA == prms->transferMode))
7009eb9a: 9806         	ldr	r0, [sp, #0x18]
7009eb9c: 6ac0         	ldr	r0, [r0, #0x2c]
;         if ((UART_CONFIG_MODE_INTERRUPT == prms->transferMode) ||
7009eb9e: 2803         	cmp	r0, #0x3
7009eba0: d146         	bne	0x7009ec30 <UART_write+0x180> @ imm = #0x8c
7009eba2: e7ff         	b	0x7009eba4 <UART_write+0xf4> @ imm = #-0x2
;             if (UART_CONFIG_MODE_INTERRUPT == prms->transferMode)
7009eba4: 9806         	ldr	r0, [sp, #0x18]
7009eba6: 6ac0         	ldr	r0, [r0, #0x2c]
7009eba8: 2801         	cmp	r0, #0x1
7009ebaa: d109         	bne	0x7009ebc0 <UART_write+0x110> @ imm = #0x12
7009ebac: e7ff         	b	0x7009ebae <UART_write+0xfe> @ imm = #-0x2
;                 status = UART_lld_writeIntr(uartLld_handle, trans->buf, trans->count, &extendedParams);
7009ebae: 9804         	ldr	r0, [sp, #0x10]
7009ebb0: 9a0c         	ldr	r2, [sp, #0x30]
7009ebb2: 6811         	ldr	r1, [r2]
7009ebb4: 6852         	ldr	r2, [r2, #0x4]
7009ebb6: ab03         	add	r3, sp, #0xc
7009ebb8: f006 fcf2    	bl	0x700a55a0 <UART_lld_writeIntr> @ imm = #0x69e4
7009ebbc: 900b         	str	r0, [sp, #0x2c]
;             }
7009ebbe: e008         	b	0x7009ebd2 <UART_write+0x122> @ imm = #0x10
;                 status = UART_lld_writeDma(uartLld_handle, trans->buf, trans->count, &extendedParams);
7009ebc0: 9804         	ldr	r0, [sp, #0x10]
7009ebc2: 9a0c         	ldr	r2, [sp, #0x30]
7009ebc4: 6811         	ldr	r1, [r2]
7009ebc6: 6852         	ldr	r2, [r2, #0x4]
7009ebc8: ab03         	add	r3, sp, #0xc
7009ebca: f006 fb49    	bl	0x700a5260 <UART_lld_writeDma> @ imm = #0x6692
7009ebce: 900b         	str	r0, [sp, #0x2c]
7009ebd0: e7ff         	b	0x7009ebd2 <UART_write+0x122> @ imm = #-0x2
;             if (SystemP_SUCCESS == status)
7009ebd2: 980b         	ldr	r0, [sp, #0x2c]
7009ebd4: bb58         	cbnz	r0, 0x7009ec2e <UART_write+0x17e> @ imm = #0x56
7009ebd6: e7ff         	b	0x7009ebd8 <UART_write+0x128> @ imm = #-0x2
;                 if(object->prms.writeMode == UART_TRANSFER_MODE_BLOCKING)
7009ebd8: 9808         	ldr	r0, [sp, #0x20]
7009ebda: 69c0         	ldr	r0, [r0, #0x1c]
7009ebdc: bb18         	cbnz	r0, 0x7009ec26 <UART_write+0x176> @ imm = #0x46
7009ebde: e7ff         	b	0x7009ebe0 <UART_write+0x130> @ imm = #-0x2
;                     semStatus = SemaphoreP_pend(&object->writeTransferSemObj, trans->timeout);
7009ebe0: 9808         	ldr	r0, [sp, #0x20]
7009ebe2: f500 70e2    	add.w	r0, r0, #0x1c4
7009ebe6: 990c         	ldr	r1, [sp, #0x30]
7009ebe8: 6889         	ldr	r1, [r1, #0x8]
7009ebea: f00a f841    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0xa082
7009ebee: 900a         	str	r0, [sp, #0x28]
;                     if (semStatus == SystemP_SUCCESS)
7009ebf0: 980a         	ldr	r0, [sp, #0x28]
7009ebf2: b960         	cbnz	r0, 0x7009ec0e <UART_write+0x15e> @ imm = #0x18
7009ebf4: e7ff         	b	0x7009ebf6 <UART_write+0x146> @ imm = #-0x2
;                         if (trans->status == (uint32_t)UART_STATUS_SUCCESS)
7009ebf6: 980c         	ldr	r0, [sp, #0x30]
7009ebf8: 68c0         	ldr	r0, [r0, #0xc]
7009ebfa: b918         	cbnz	r0, 0x7009ec04 <UART_write+0x154> @ imm = #0x6
7009ebfc: e7ff         	b	0x7009ebfe <UART_write+0x14e> @ imm = #-0x2
7009ebfe: 2000         	movs	r0, #0x0
;                             status = SystemP_SUCCESS;
7009ec00: 900b         	str	r0, [sp, #0x2c]
;                         }
7009ec02: e003         	b	0x7009ec0c <UART_write+0x15c> @ imm = #0x6
7009ec04: f04f 30ff    	mov.w	r0, #0xffffffff
;                             status = SystemP_FAILURE;
7009ec08: 900b         	str	r0, [sp, #0x2c]
7009ec0a: e7ff         	b	0x7009ec0c <UART_write+0x15c> @ imm = #-0x2
;                     }
7009ec0c: e00a         	b	0x7009ec24 <UART_write+0x174> @ imm = #0x14
;                         trans->status = UART_TRANSFER_TIMEOUT;
7009ec0e: 990c         	ldr	r1, [sp, #0x30]
7009ec10: f06f 0001    	mvn	r0, #0x1
7009ec14: 60c8         	str	r0, [r1, #0xc]
;                         (void)UART_writeCancelNoCB(uartLld_handle);
7009ec16: 9804         	ldr	r0, [sp, #0x10]
7009ec18: f009 fcca    	bl	0x700a85b0 <UART_writeCancelNoCB> @ imm = #0x9994
7009ec1c: f04f 30ff    	mov.w	r0, #0xffffffff
;                         status = SystemP_FAILURE;
7009ec20: 900b         	str	r0, [sp, #0x2c]
7009ec22: e7ff         	b	0x7009ec24 <UART_write+0x174> @ imm = #-0x2
;                 }
7009ec24: e002         	b	0x7009ec2c <UART_write+0x17c> @ imm = #0x4
7009ec26: 2000         	movs	r0, #0x0
;                     status = SystemP_SUCCESS;
7009ec28: 900b         	str	r0, [sp, #0x2c]
7009ec2a: e7ff         	b	0x7009ec2c <UART_write+0x17c> @ imm = #-0x2
;             }
7009ec2c: e7ff         	b	0x7009ec2e <UART_write+0x17e> @ imm = #-0x2
;         }
7009ec2e: e00d         	b	0x7009ec4c <UART_write+0x19c> @ imm = #0x1a
;             status = UART_lld_write(uartLld_handle, trans->buf, trans->count, trans->timeout, &extendedParams);
7009ec30: 9804         	ldr	r0, [sp, #0x10]
7009ec32: 9b0c         	ldr	r3, [sp, #0x30]
7009ec34: 6819         	ldr	r1, [r3]
7009ec36: 685a         	ldr	r2, [r3, #0x4]
7009ec38: 689b         	ldr	r3, [r3, #0x8]
7009ec3a: 46ee         	mov	lr, sp
7009ec3c: f10d 0c0c    	add.w	r12, sp, #0xc
7009ec40: f8ce c000    	str.w	r12, [lr]
7009ec44: f006 f81c    	bl	0x700a4c80 <UART_lld_write> @ imm = #0x6038
7009ec48: 900b         	str	r0, [sp, #0x2c]
7009ec4a: e7ff         	b	0x7009ec4c <UART_write+0x19c> @ imm = #-0x2
;     }
7009ec4c: e7ff         	b	0x7009ec4e <UART_write+0x19e> @ imm = #-0x2
;     return (status);
7009ec4e: 980b         	ldr	r0, [sp, #0x2c]
7009ec50: b00e         	add	sp, #0x38
7009ec52: bd80         	pop	{r7, pc}
		...

7009ec60 <Sciclient_rmClearInterruptRoute>:
; {
7009ec60: b580         	push	{r7, lr}
7009ec62: b08e         	sub	sp, #0x38
7009ec64: 900d         	str	r0, [sp, #0x34]
7009ec66: 910c         	str	r1, [sp, #0x30]
7009ec68: 920b         	str	r2, [sp, #0x2c]
7009ec6a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009ec6c: 9001         	str	r0, [sp, #0x4]
7009ec6e: 900a         	str	r0, [sp, #0x28]
7009ec70: f241 0101    	movw	r1, #0x1001
;     uint16_t messageType = TISCI_MSG_RM_IRQ_RELEASE;
7009ec74: f8ad 1026    	strh.w	r1, [sp, #0x26]
;     memset(&cfg, 0, sizeof(cfg));
7009ec78: 9008         	str	r0, [sp, #0x20]
7009ec7a: 9007         	str	r0, [sp, #0x1c]
7009ec7c: 9006         	str	r0, [sp, #0x18]
7009ec7e: 9005         	str	r0, [sp, #0x14]
7009ec80: 9004         	str	r0, [sp, #0x10]
7009ec82: 9003         	str	r0, [sp, #0xc]
7009ec84: 9002         	str	r0, [sp, #0x8]
;     if((req == NULL) || (resp == NULL)) {
7009ec86: 980d         	ldr	r0, [sp, #0x34]
7009ec88: b118         	cbz	r0, 0x7009ec92 <Sciclient_rmClearInterruptRoute+0x32> @ imm = #0x6
7009ec8a: e7ff         	b	0x7009ec8c <Sciclient_rmClearInterruptRoute+0x2c> @ imm = #-0x2
7009ec8c: 980c         	ldr	r0, [sp, #0x30]
7009ec8e: b920         	cbnz	r0, 0x7009ec9a <Sciclient_rmClearInterruptRoute+0x3a> @ imm = #0x8
7009ec90: e7ff         	b	0x7009ec92 <Sciclient_rmClearInterruptRoute+0x32> @ imm = #-0x2
7009ec92: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009ec96: 900a         	str	r0, [sp, #0x28]
;     }
7009ec98: e7ff         	b	0x7009ec9a <Sciclient_rmClearInterruptRoute+0x3a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
7009ec9a: 980a         	ldr	r0, [sp, #0x28]
7009ec9c: b968         	cbnz	r0, 0x7009ecba <Sciclient_rmClearInterruptRoute+0x5a> @ imm = #0x1a
7009ec9e: e7ff         	b	0x7009eca0 <Sciclient_rmClearInterruptRoute+0x40> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
7009eca0: 980d         	ldr	r0, [sp, #0x34]
7009eca2: 6880         	ldr	r0, [r0, #0x8]
7009eca4: f04f 4100    	mov.w	r1, #0x80000000
7009eca8: f00e fa72    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0xe4e4
;     if (r == SystemP_SUCCESS &&
7009ecac: b128         	cbz	r0, 0x7009ecba <Sciclient_rmClearInterruptRoute+0x5a> @ imm = #0xa
7009ecae: e7ff         	b	0x7009ecb0 <Sciclient_rmClearInterruptRoute+0x50> @ imm = #-0x2
;         dst_host = req->secondary_host;
7009ecb0: 980d         	ldr	r0, [sp, #0x34]
7009ecb2: 7ec0         	ldrb	r0, [r0, #0x1b]
7009ecb4: f88d 0025    	strb.w	r0, [sp, #0x25]
;     } else {
7009ecb8: e00f         	b	0x7009ecda <Sciclient_rmClearInterruptRoute+0x7a> @ imm = #0x1e
;         dst_host = (uint8_t) gSciclientMap[Sciclient_getCurrentContext(messageType)].hostId;
7009ecba: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
7009ecbe: f007 f977    	bl	0x700a5fb0 <Sciclient_getCurrentContext> @ imm = #0x72ee
7009ecc2: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009ecc6: f24f 70b8    	movw	r0, #0xf7b8
7009ecca: f2c7 000a    	movt	r0, #0x700a
7009ecce: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009ecd2: 6840         	ldr	r0, [r0, #0x4]
7009ecd4: f88d 0025    	strb.w	r0, [sp, #0x25]
7009ecd8: e7ff         	b	0x7009ecda <Sciclient_rmClearInterruptRoute+0x7a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
7009ecda: 980a         	ldr	r0, [sp, #0x28]
7009ecdc: b960         	cbnz	r0, 0x7009ecf8 <Sciclient_rmClearInterruptRoute+0x98> @ imm = #0x18
7009ecde: e7ff         	b	0x7009ece0 <Sciclient_rmClearInterruptRoute+0x80> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
7009ece0: 980d         	ldr	r0, [sp, #0x34]
7009ece2: 6880         	ldr	r0, [r0, #0x8]
7009ece4: 2104         	movs	r1, #0x4
7009ece6: f00e fa53    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0xe4a6
;     if (r == SystemP_SUCCESS &&
7009ecea: b128         	cbz	r0, 0x7009ecf8 <Sciclient_rmClearInterruptRoute+0x98> @ imm = #0xa
7009ecec: e7ff         	b	0x7009ecee <Sciclient_rmClearInterruptRoute+0x8e> @ imm = #-0x2
;         cfg.s_ia = req->ia_id;
7009ecee: 980d         	ldr	r0, [sp, #0x34]
7009ecf0: 8a80         	ldrh	r0, [r0, #0x14]
7009ecf2: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     } else {
7009ecf6: e003         	b	0x7009ed00 <Sciclient_rmClearInterruptRoute+0xa0> @ imm = #0x6
7009ecf8: 20ff         	movs	r0, #0xff
;         cfg.s_ia = SCICLIENT_RM_DEV_NONE;
7009ecfa: f8ad 0018    	strh.w	r0, [sp, #0x18]
7009ecfe: e7ff         	b	0x7009ed00 <Sciclient_rmClearInterruptRoute+0xa0> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009ed00: 980a         	ldr	r0, [sp, #0x28]
7009ed02: 2800         	cmp	r0, #0x0
7009ed04: d175         	bne	0x7009edf2 <Sciclient_rmClearInterruptRoute+0x192> @ imm = #0xea
7009ed06: e7ff         	b	0x7009ed08 <Sciclient_rmClearInterruptRoute+0xa8> @ imm = #-0x2
;         cfg.valid_params = req->valid_params;
7009ed08: 980d         	ldr	r0, [sp, #0x34]
7009ed0a: 6880         	ldr	r0, [r0, #0x8]
7009ed0c: 9002         	str	r0, [sp, #0x8]
;         cfg.host = dst_host;
7009ed0e: f89d 0025    	ldrb.w	r0, [sp, #0x25]
7009ed12: f88d 000c    	strb.w	r0, [sp, #0xc]
;         cfg.s_id = req->src_id;
7009ed16: 980d         	ldr	r0, [sp, #0x34]
7009ed18: 8980         	ldrh	r0, [r0, #0xc]
7009ed1a: f8ad 000e    	strh.w	r0, [sp, #0xe]
;         cfg.s_idx = req->src_index;
7009ed1e: 980d         	ldr	r0, [sp, #0x34]
7009ed20: 89c0         	ldrh	r0, [r0, #0xe]
7009ed22: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         cfg.d_id = req->dst_id;
7009ed26: 980d         	ldr	r0, [sp, #0x34]
7009ed28: 8a00         	ldrh	r0, [r0, #0x10]
7009ed2a: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         cfg.d_irq = req->dst_host_irq;
7009ed2e: 980d         	ldr	r0, [sp, #0x34]
7009ed30: 8a40         	ldrh	r0, [r0, #0x12]
7009ed32: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         cfg.global_evt = req->global_event;
7009ed36: 980d         	ldr	r0, [sp, #0x34]
7009ed38: 8b00         	ldrh	r0, [r0, #0x18]
7009ed3a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         cfg.vint = req->vint;
7009ed3e: 980d         	ldr	r0, [sp, #0x34]
7009ed40: 8ac0         	ldrh	r0, [r0, #0x16]
7009ed42: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         cfg.vint_sb = req->vint_status_bit_index;
7009ed46: 980d         	ldr	r0, [sp, #0x34]
7009ed48: 7e80         	ldrb	r0, [r0, #0x1a]
7009ed4a: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         if (Sciclient_rmIrqCfgIsDirectNonEvent(cfg.valid_params) == true) {
7009ed4e: 9802         	ldr	r0, [sp, #0x8]
7009ed50: f00a ff96    	bl	0x700a9c80 <Sciclient_rmIrqCfgIsDirectNonEvent> @ imm = #0xaf2c
7009ed54: b310         	cbz	r0, 0x7009ed9c <Sciclient_rmClearInterruptRoute+0x13c> @ imm = #0x44
7009ed56: e7ff         	b	0x7009ed58 <Sciclient_rmClearInterruptRoute+0xf8> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cfg.s_id) == true) {
7009ed58: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
7009ed5c: f00d fff0    	bl	0x700acd40 <Sciclient_rmIaIsIa> @ imm = #0xdfe0
7009ed60: b168         	cbz	r0, 0x7009ed7e <Sciclient_rmClearInterruptRoute+0x11e> @ imm = #0x1a
7009ed62: e7ff         	b	0x7009ed64 <Sciclient_rmClearInterruptRoute+0x104> @ imm = #-0x2
;                 cfg.s_ia = cfg.s_id;
7009ed64: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
7009ed68: f8ad 0018    	strh.w	r0, [sp, #0x18]
;                 cfg.vint = cfg.s_idx;
7009ed6c: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
7009ed70: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009ed74: a802         	add	r0, sp, #0x8
;                 r = Sciclient_rmIrqUnmappedVintRouteDelete(&cfg);
7009ed76: f00b ffa3    	bl	0x700aacc0 <Sciclient_rmIrqUnmappedVintRouteDelete> @ imm = #0xbf46
7009ed7a: 900a         	str	r0, [sp, #0x28]
;             } else {
7009ed7c: e00d         	b	0x7009ed9a <Sciclient_rmClearInterruptRoute+0x13a> @ imm = #0x1a
7009ed7e: a802         	add	r0, sp, #0x8
;                 r = Sciclient_rmIrqGetRoute(&cfg);
7009ed80: f7fc fe46    	bl	0x7009ba10 <Sciclient_rmIrqGetRoute> @ imm = #-0x3374
7009ed84: 900a         	str	r0, [sp, #0x28]
;                 if (r == SystemP_SUCCESS) {
7009ed86: 980a         	ldr	r0, [sp, #0x28]
7009ed88: b930         	cbnz	r0, 0x7009ed98 <Sciclient_rmClearInterruptRoute+0x138> @ imm = #0xc
7009ed8a: e7ff         	b	0x7009ed8c <Sciclient_rmClearInterruptRoute+0x12c> @ imm = #-0x2
7009ed8c: a802         	add	r0, sp, #0x8
7009ed8e: 2100         	movs	r1, #0x0
;                     r = Sciclient_rmIrqDeleteRoute(&cfg, false);
7009ed90: f000 f9ce    	bl	0x7009f130 <Sciclient_rmIrqDeleteRoute> @ imm = #0x39c
7009ed94: 900a         	str	r0, [sp, #0x28]
;                 }
7009ed96: e7ff         	b	0x7009ed98 <Sciclient_rmClearInterruptRoute+0x138> @ imm = #-0x2
7009ed98: e7ff         	b	0x7009ed9a <Sciclient_rmClearInterruptRoute+0x13a> @ imm = #-0x2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
7009ed9a: e029         	b	0x7009edf0 <Sciclient_rmClearInterruptRoute+0x190> @ imm = #0x52
7009ed9c: 9802         	ldr	r0, [sp, #0x8]
7009ed9e: f00a ff37    	bl	0x700a9c10 <Sciclient_rmIrqCfgIsDirectEvent> @ imm = #0xae6e
;                 true) ||
7009eda2: b928         	cbnz	r0, 0x7009edb0 <Sciclient_rmClearInterruptRoute+0x150> @ imm = #0xa
7009eda4: e7ff         	b	0x7009eda6 <Sciclient_rmClearInterruptRoute+0x146> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg.valid_params) ==
7009eda6: 9802         	ldr	r0, [sp, #0x8]
7009eda8: f00a ffa2    	bl	0x700a9cf0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0xaf44
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
7009edac: b128         	cbz	r0, 0x7009edba <Sciclient_rmClearInterruptRoute+0x15a> @ imm = #0xa
7009edae: e7ff         	b	0x7009edb0 <Sciclient_rmClearInterruptRoute+0x150> @ imm = #-0x2
7009edb0: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqVintDelete(&cfg);
7009edb2: f002 fb35    	bl	0x700a1420 <Sciclient_rmIrqVintDelete> @ imm = #0x266a
7009edb6: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsUnmappedVintDirectEvent(cfg.valid_params) ==
7009edb8: e019         	b	0x7009edee <Sciclient_rmClearInterruptRoute+0x18e> @ imm = #0x32
7009edba: 9802         	ldr	r0, [sp, #0x8]
7009edbc: f00b f808    	bl	0x700a9dd0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent> @ imm = #0xb010
7009edc0: b128         	cbz	r0, 0x7009edce <Sciclient_rmClearInterruptRoute+0x16e> @ imm = #0xa
7009edc2: e7ff         	b	0x7009edc4 <Sciclient_rmClearInterruptRoute+0x164> @ imm = #-0x2
7009edc4: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqUnmappedVintRouteDelete(&cfg);
7009edc6: f00b ff7b    	bl	0x700aacc0 <Sciclient_rmIrqUnmappedVintRouteDelete> @ imm = #0xbef6
7009edca: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsOesOnly(cfg.valid_params) == true) {
7009edcc: e00e         	b	0x7009edec <Sciclient_rmClearInterruptRoute+0x18c> @ imm = #0x1c
7009edce: 9802         	ldr	r0, [sp, #0x8]
7009edd0: f00a ffc6    	bl	0x700a9d60 <Sciclient_rmIrqCfgIsOesOnly> @ imm = #0xaf8c
7009edd4: b128         	cbz	r0, 0x7009ede2 <Sciclient_rmClearInterruptRoute+0x182> @ imm = #0xa
7009edd6: e7ff         	b	0x7009edd8 <Sciclient_rmClearInterruptRoute+0x178> @ imm = #-0x2
7009edd8: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqClearOesRegister(&cfg);
7009edda: f00d fb21    	bl	0x700ac420 <Sciclient_rmIrqClearOesRegister> @ imm = #0xd642
7009edde: 900a         	str	r0, [sp, #0x28]
;         } else {
7009ede0: e003         	b	0x7009edea <Sciclient_rmClearInterruptRoute+0x18a> @ imm = #0x6
7009ede2: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
7009ede6: 900a         	str	r0, [sp, #0x28]
7009ede8: e7ff         	b	0x7009edea <Sciclient_rmClearInterruptRoute+0x18a> @ imm = #-0x2
7009edea: e7ff         	b	0x7009edec <Sciclient_rmClearInterruptRoute+0x18c> @ imm = #-0x2
7009edec: e7ff         	b	0x7009edee <Sciclient_rmClearInterruptRoute+0x18e> @ imm = #-0x2
7009edee: e7ff         	b	0x7009edf0 <Sciclient_rmClearInterruptRoute+0x190> @ imm = #-0x2
;     }
7009edf0: e7ff         	b	0x7009edf2 <Sciclient_rmClearInterruptRoute+0x192> @ imm = #-0x2
;     return r;
7009edf2: 980a         	ldr	r0, [sp, #0x28]
7009edf4: b00e         	add	sp, #0x38
7009edf6: bd80         	pop	{r7, pc}
		...

7009ee00 <Udma_chConfigTx>:
; {
7009ee00: b580         	push	{r7, lr}
7009ee02: b090         	sub	sp, #0x40
7009ee04: 900f         	str	r0, [sp, #0x3c]
7009ee06: 910e         	str	r1, [sp, #0x38]
7009ee08: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009ee0a: 900d         	str	r0, [sp, #0x34]
;     Udma_ChHandleInt        chHandleInt = (Udma_ChHandleInt) chHandle;
7009ee0c: 980f         	ldr	r0, [sp, #0x3c]
7009ee0e: 900b         	str	r0, [sp, #0x2c]
;     if((NULL_PTR == chHandleInt) ||
7009ee10: 980b         	ldr	r0, [sp, #0x2c]
7009ee12: b178         	cbz	r0, 0x7009ee34 <Udma_chConfigTx+0x34> @ imm = #0x1e
7009ee14: e7ff         	b	0x7009ee16 <Udma_chConfigTx+0x16> @ imm = #-0x2
;        (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
7009ee16: 980b         	ldr	r0, [sp, #0x2c]
7009ee18: f8d0 0244    	ldr.w	r0, [r0, #0x244]
7009ee1c: f64a 31cd    	movw	r1, #0xabcd
7009ee20: f6ca 31dc    	movt	r1, #0xabdc
7009ee24: 4288         	cmp	r0, r1
7009ee26: d105         	bne	0x7009ee34 <Udma_chConfigTx+0x34> @ imm = #0xa
7009ee28: e7ff         	b	0x7009ee2a <Udma_chConfigTx+0x2a> @ imm = #-0x2
;        ((chHandleInt->chType & UDMA_CH_FLAG_TX) != UDMA_CH_FLAG_TX))
7009ee2a: 980b         	ldr	r0, [sp, #0x2c]
;     if((NULL_PTR == chHandleInt) ||
7009ee2c: 7800         	ldrb	r0, [r0]
7009ee2e: 07c0         	lsls	r0, r0, #0x1f
7009ee30: b920         	cbnz	r0, 0x7009ee3c <Udma_chConfigTx+0x3c> @ imm = #0x8
7009ee32: e7ff         	b	0x7009ee34 <Udma_chConfigTx+0x34> @ imm = #-0x2
7009ee34: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009ee38: 900d         	str	r0, [sp, #0x34]
;     }
7009ee3a: e7ff         	b	0x7009ee3c <Udma_chConfigTx+0x3c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ee3c: 980d         	ldr	r0, [sp, #0x34]
7009ee3e: b9a8         	cbnz	r0, 0x7009ee6c <Udma_chConfigTx+0x6c> @ imm = #0x2a
7009ee40: e7ff         	b	0x7009ee42 <Udma_chConfigTx+0x42> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
7009ee42: 980b         	ldr	r0, [sp, #0x2c]
7009ee44: 6e80         	ldr	r0, [r0, #0x68]
7009ee46: 900c         	str	r0, [sp, #0x30]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009ee48: 980c         	ldr	r0, [sp, #0x30]
7009ee4a: b150         	cbz	r0, 0x7009ee62 <Udma_chConfigTx+0x62> @ imm = #0x14
7009ee4c: e7ff         	b	0x7009ee4e <Udma_chConfigTx+0x4e> @ imm = #-0x2
7009ee4e: 980c         	ldr	r0, [sp, #0x30]
7009ee50: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009ee54: f64a 31cd    	movw	r1, #0xabcd
7009ee58: f6ca 31dc    	movt	r1, #0xabdc
7009ee5c: 4288         	cmp	r0, r1
7009ee5e: d004         	beq	0x7009ee6a <Udma_chConfigTx+0x6a> @ imm = #0x8
7009ee60: e7ff         	b	0x7009ee62 <Udma_chConfigTx+0x62> @ imm = #-0x2
7009ee62: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009ee66: 900d         	str	r0, [sp, #0x34]
;         }
7009ee68: e7ff         	b	0x7009ee6a <Udma_chConfigTx+0x6a> @ imm = #-0x2
;     }
7009ee6a: e7ff         	b	0x7009ee6c <Udma_chConfigTx+0x6c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ee6c: 980d         	ldr	r0, [sp, #0x34]
7009ee6e: 2800         	cmp	r0, #0x0
7009ee70: f040 808e    	bne.w	0x7009ef90 <Udma_chConfigTx+0x190> @ imm = #0x11c
7009ee74: e7ff         	b	0x7009ee76 <Udma_chConfigTx+0x76> @ imm = #-0x2
7009ee76: f647 70ff    	movw	r0, #0x7fff
;         rmUdmaTxReq.valid_params        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERR_VALID |
7009ee7a: 9004         	str	r0, [sp, #0x10]
;         rmUdmaTxReq.nav_id              = drvHandle->devIdUdma;
7009ee7c: 980c         	ldr	r0, [sp, #0x30]
7009ee7e: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009ee82: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmUdmaTxReq.index               = (uint16_t)chHandleInt->txChNum;
7009ee86: 980b         	ldr	r0, [sp, #0x2c]
7009ee88: 6ec0         	ldr	r0, [r0, #0x6c]
7009ee8a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         rmUdmaTxReq.tx_pause_on_err     = txPrms->pauseOnError;
7009ee8e: 980e         	ldr	r0, [sp, #0x38]
7009ee90: 7800         	ldrb	r0, [r0]
7009ee92: f88d 0018    	strb.w	r0, [sp, #0x18]
;         rmUdmaTxReq.tx_filt_einfo       = txPrms->filterEinfo;
7009ee96: 980e         	ldr	r0, [sp, #0x38]
7009ee98: 7840         	ldrb	r0, [r0, #0x1]
7009ee9a: f88d 0019    	strb.w	r0, [sp, #0x19]
;         rmUdmaTxReq.tx_filt_pswords     = txPrms->filterPsWords;
7009ee9e: 980e         	ldr	r0, [sp, #0x38]
7009eea0: 7880         	ldrb	r0, [r0, #0x2]
7009eea2: f88d 001a    	strb.w	r0, [sp, #0x1a]
;         rmUdmaTxReq.tx_atype            = txPrms->addrType;
7009eea6: 980e         	ldr	r0, [sp, #0x38]
7009eea8: 78c0         	ldrb	r0, [r0, #0x3]
7009eeaa: f88d 001b    	strb.w	r0, [sp, #0x1b]
;         rmUdmaTxReq.tx_chan_type        = txPrms->chanType;
7009eeae: 980e         	ldr	r0, [sp, #0x38]
7009eeb0: 7900         	ldrb	r0, [r0, #0x4]
7009eeb2: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         rmUdmaTxReq.tx_fetch_size       = txPrms->fetchWordSize;
7009eeb6: 980e         	ldr	r0, [sp, #0x38]
7009eeb8: 88c0         	ldrh	r0, [r0, #0x6]
7009eeba: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmUdmaTxReq.tx_priority         = txPrms->busPriority;
7009eebe: 980e         	ldr	r0, [sp, #0x38]
7009eec0: 7a00         	ldrb	r0, [r0, #0x8]
7009eec2: f88d 0023    	strb.w	r0, [sp, #0x23]
;         rmUdmaTxReq.tx_qos              = txPrms->busQos;
7009eec6: 980e         	ldr	r0, [sp, #0x38]
7009eec8: 7a40         	ldrb	r0, [r0, #0x9]
7009eeca: f88d 0024    	strb.w	r0, [sp, #0x24]
;         rmUdmaTxReq.tx_orderid          = txPrms->busOrderId;
7009eece: 980e         	ldr	r0, [sp, #0x38]
7009eed0: 7a80         	ldrb	r0, [r0, #0xa]
7009eed2: f88d 0025    	strb.w	r0, [sp, #0x25]
;         rmUdmaTxReq.fdepth              = txPrms->fifoDepth;
7009eed6: 980e         	ldr	r0, [sp, #0x38]
7009eed8: 89c0         	ldrh	r0, [r0, #0xe]
7009eeda: f8ad 0026    	strh.w	r0, [sp, #0x26]
;         rmUdmaTxReq.tx_burst_size       = txPrms->burstSize;
7009eede: 980e         	ldr	r0, [sp, #0x38]
7009eee0: 7c00         	ldrb	r0, [r0, #0x10]
7009eee2: f88d 0029    	strb.w	r0, [sp, #0x29]
;         rmUdmaTxReq.tx_sched_priority   = txPrms->dmaPriority;
7009eee6: 980e         	ldr	r0, [sp, #0x38]
7009eee8: 7ac0         	ldrb	r0, [r0, #0xb]
7009eeea: f88d 0028    	strb.w	r0, [sp, #0x28]
;         rmUdmaTxReq.tx_credit_count     = txPrms->txCredit;
7009eeee: 980e         	ldr	r0, [sp, #0x38]
7009eef0: 7b00         	ldrb	r0, [r0, #0xc]
7009eef2: f88d 0020    	strb.w	r0, [sp, #0x20]
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009eef6: 980c         	ldr	r0, [sp, #0x30]
7009eef8: 6800         	ldr	r0, [r0]
7009eefa: 2801         	cmp	r0, #0x1
7009eefc: d11d         	bne	0x7009ef3a <Udma_chConfigTx+0x13a> @ imm = #0x3a
7009eefe: e7ff         	b	0x7009ef00 <Udma_chConfigTx+0x100> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009ef00: 980b         	ldr	r0, [sp, #0x2c]
7009ef02: 7800         	ldrb	r0, [r0]
7009ef04: 0740         	lsls	r0, r0, #0x1d
7009ef06: 2800         	cmp	r0, #0x0
7009ef08: d508         	bpl	0x7009ef1c <Udma_chConfigTx+0x11c> @ imm = #0x10
7009ef0a: e7ff         	b	0x7009ef0c <Udma_chConfigTx+0x10c> @ imm = #-0x2
;                 rmUdmaTxReq.valid_params    |= TISCI_MSG_VALUE_RM_UDMAP_EXTENDED_CH_TYPE_VALID;
7009ef0c: 9804         	ldr	r0, [sp, #0x10]
7009ef0e: f440 3080    	orr	r0, r0, #0x10000
7009ef12: 9004         	str	r0, [sp, #0x10]
7009ef14: 2001         	movs	r0, #0x1
;                 rmUdmaTxReq.extended_ch_type = UDMA_DMSC_EXTENDED_CH_TYPE_BCDMA_BLK_CPY;
7009ef16: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             }
7009ef1a: e00d         	b	0x7009ef38 <Udma_chConfigTx+0x138> @ imm = #0x1a
;             else if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009ef1c: 980b         	ldr	r0, [sp, #0x2c]
7009ef1e: 7800         	ldrb	r0, [r0]
7009ef20: 07c0         	lsls	r0, r0, #0x1f
7009ef22: b140         	cbz	r0, 0x7009ef36 <Udma_chConfigTx+0x136> @ imm = #0x10
7009ef24: e7ff         	b	0x7009ef26 <Udma_chConfigTx+0x126> @ imm = #-0x2
;                 rmUdmaTxReq.valid_params    |= TISCI_MSG_VALUE_RM_UDMAP_EXTENDED_CH_TYPE_VALID;
7009ef26: 9804         	ldr	r0, [sp, #0x10]
7009ef28: f440 3080    	orr	r0, r0, #0x10000
7009ef2c: 9004         	str	r0, [sp, #0x10]
7009ef2e: 2000         	movs	r0, #0x0
;                 rmUdmaTxReq.extended_ch_type = UDMA_DMSC_EXTENDED_CH_TYPE_BCDMA_SPLIT_TR_TX;
7009ef30: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             }
7009ef34: e7ff         	b	0x7009ef36 <Udma_chConfigTx+0x136> @ imm = #-0x2
7009ef36: e7ff         	b	0x7009ef38 <Udma_chConfigTx+0x138> @ imm = #-0x2
;         }
7009ef38: e7ff         	b	0x7009ef3a <Udma_chConfigTx+0x13a> @ imm = #-0x2
;         if(NULL_PTR != chHandleInt->tdCqRing)
7009ef3a: 980b         	ldr	r0, [sp, #0x2c]
7009ef3c: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009ef40: b158         	cbz	r0, 0x7009ef5a <Udma_chConfigTx+0x15a> @ imm = #0x16
7009ef42: e7ff         	b	0x7009ef44 <Udma_chConfigTx+0x144> @ imm = #-0x2
;             rmUdmaTxReq.txcq_qnum       = chHandleInt->tdCqRing->ringNum;
7009ef44: 980b         	ldr	r0, [sp, #0x2c]
7009ef46: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009ef4a: 8880         	ldrh	r0, [r0, #0x4]
7009ef4c: f8ad 0021    	strh.w	r0, [sp, #0x21]
;             rmUdmaTxReq.tx_supr_tdpkt   = txPrms->supressTdCqPkt;
7009ef50: 980e         	ldr	r0, [sp, #0x38]
7009ef52: 7c40         	ldrb	r0, [r0, #0x11]
7009ef54: f88d 001d    	strb.w	r0, [sp, #0x1d]
;         }
7009ef58: e007         	b	0x7009ef6a <Udma_chConfigTx+0x16a> @ imm = #0xe
7009ef5a: f64f 70ff    	movw	r0, #0xffff
;             rmUdmaTxReq.txcq_qnum       = UDMA_RING_INVALID;
7009ef5e: f8ad 0021    	strh.w	r0, [sp, #0x21]
7009ef62: 2001         	movs	r0, #0x1
;             rmUdmaTxReq.tx_supr_tdpkt   = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_SUPPRESS_TD_ENABLED;
7009ef64: f88d 001d    	strb.w	r0, [sp, #0x1d]
7009ef68: e7ff         	b	0x7009ef6a <Udma_chConfigTx+0x16a> @ imm = #-0x2
7009ef6a: a802         	add	r0, sp, #0x8
7009ef6c: 4669         	mov	r1, sp
7009ef6e: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmUdmapTxChCfg(
7009ef72: f00b ff95    	bl	0x700aaea0 <Sciclient_rmUdmapTxChCfg> @ imm = #0xbf2a
7009ef76: 900d         	str	r0, [sp, #0x34]
;         if(CSL_PASS != retVal)
7009ef78: 980d         	ldr	r0, [sp, #0x34]
7009ef7a: b108         	cbz	r0, 0x7009ef80 <Udma_chConfigTx+0x180> @ imm = #0x2
7009ef7c: e7ff         	b	0x7009ef7e <Udma_chConfigTx+0x17e> @ imm = #-0x2
;         }
7009ef7e: e7ff         	b	0x7009ef80 <Udma_chConfigTx+0x180> @ imm = #-0x2
;         (void) memcpy(&chHandleInt->txPrms, txPrms, sizeof(chHandleInt->txPrms));
7009ef80: 980b         	ldr	r0, [sp, #0x2c]
7009ef82: f500 70f2    	add.w	r0, r0, #0x1e4
7009ef86: 990e         	ldr	r1, [sp, #0x38]
7009ef88: 2212         	movs	r2, #0x12
7009ef8a: f7fb ec26    	blx	0x7009a7d8 <__aeabi_memcpy8> @ imm = #-0x47b4
;     }
7009ef8e: e7ff         	b	0x7009ef90 <Udma_chConfigTx+0x190> @ imm = #-0x2
;     return (retVal);
7009ef90: 980d         	ldr	r0, [sp, #0x34]
7009ef92: b010         	add	sp, #0x40
7009ef94: bd80         	pop	{r7, pc}
		...
7009ef9e: 0000         	movs	r0, r0

7009efa0 <ClockP_init>:
; {
7009efa0: b580         	push	{r7, lr}
7009efa2: b096         	sub	sp, #0x58
;     DebugP_assert( gClockConfig.timerInputPreScaler != 0U);
7009efa4: f640 40b8    	movw	r0, #0xcb8
7009efa8: f2c7 000b    	movt	r0, #0x700b
7009efac: 9009         	str	r0, [sp, #0x24]
7009efae: 68c0         	ldr	r0, [r0, #0xc]
7009efb0: 2800         	cmp	r0, #0x0
7009efb2: bf18         	it	ne
7009efb4: 2001         	movne	r0, #0x1
7009efb6: f64f 711b    	movw	r1, #0xff1b
7009efba: f2c7 010a    	movt	r1, #0x700a
7009efbe: 466a         	mov	r2, sp
7009efc0: 6011         	str	r1, [r2]
7009efc2: f240 11ad    	movw	r1, #0x1ad
7009efc6: f2c7 010b    	movt	r1, #0x700b
7009efca: 9107         	str	r1, [sp, #0x1c]
7009efcc: f240 42c4    	movw	r2, #0x4c4
7009efd0: f2c7 020b    	movt	r2, #0x700b
7009efd4: 9208         	str	r2, [sp, #0x20]
7009efd6: 2334         	movs	r3, #0x34
7009efd8: f00a f8a2    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xa144
7009efdc: 9907         	ldr	r1, [sp, #0x1c]
7009efde: 9a08         	ldr	r2, [sp, #0x20]
7009efe0: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.timerInputClkHz != 0U);
7009efe2: 6880         	ldr	r0, [r0, #0x8]
7009efe4: 2800         	cmp	r0, #0x0
7009efe6: bf18         	it	ne
7009efe8: 2001         	movne	r0, #0x1
7009efea: f64f 738c    	movw	r3, #0xff8c
7009efee: f2c7 030a    	movt	r3, #0x700a
7009eff2: 46ec         	mov	r12, sp
7009eff4: f8cc 3000    	str.w	r3, [r12]
7009eff8: 2335         	movs	r3, #0x35
7009effa: f00a f891    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xa122
7009effe: 9907         	ldr	r1, [sp, #0x1c]
7009f000: 9a08         	ldr	r2, [sp, #0x20]
7009f002: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.usecPerTick != 0U);
7009f004: 6900         	ldr	r0, [r0, #0x10]
7009f006: 2800         	cmp	r0, #0x0
7009f008: bf18         	it	ne
7009f00a: 2001         	movne	r0, #0x1
7009f00c: f240 03dc    	movw	r3, #0xdc
7009f010: f2c7 030b    	movt	r3, #0x700b
7009f014: 46ec         	mov	r12, sp
7009f016: f8cc 3000    	str.w	r3, [r12]
7009f01a: 2336         	movs	r3, #0x36
7009f01c: f00a f880    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xa100
7009f020: 9907         	ldr	r1, [sp, #0x1c]
7009f022: 9a08         	ldr	r2, [sp, #0x20]
7009f024: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.timerBaseAddr != 0U);
7009f026: 6800         	ldr	r0, [r0]
7009f028: 2800         	cmp	r0, #0x0
7009f02a: bf18         	it	ne
7009f02c: 2001         	movne	r0, #0x1
7009f02e: f240 035a    	movw	r3, #0x5a
7009f032: f2c7 030b    	movt	r3, #0x700b
7009f036: 46ec         	mov	r12, sp
7009f038: f8cc 3000    	str.w	r3, [r12]
7009f03c: 2337         	movs	r3, #0x37
7009f03e: f00a f86f    	bl	0x700a9120 <_DebugP_assert> @ imm = #0xa0de
7009f042: 9809         	ldr	r0, [sp, #0x24]
;     gClockCtrl.ticks = 0;
7009f044: f644 4290    	movw	r2, #0x4c90
7009f048: f2c7 0208    	movt	r2, #0x7008
7009f04c: 2100         	movs	r1, #0x0
7009f04e: 6051         	str	r1, [r2, #0x4]
7009f050: 6011         	str	r1, [r2]
;     gClockCtrl.usecPerTick = gClockConfig.usecPerTick;
7009f052: 6903         	ldr	r3, [r0, #0x10]
7009f054: 6093         	str	r3, [r2, #0x8]
;     gClockCtrl.timerBaseAddr = gClockConfig.timerBaseAddr;
7009f056: 6800         	ldr	r0, [r0]
7009f058: 62d0         	str	r0, [r2, #0x2c]
7009f05a: f244 2040    	movw	r0, #0x4240
7009f05e: f2c0 000f    	movt	r0, #0xf
;     if( pdMS_TO_TICKS( TIME_IN_MILLI_SECONDS ) != ClockP_usecToTicks( TIME_IN_MICRO_SECONDS ) )
7009f062: f00e fba5    	bl	0x700ad7b0 <ClockP_usecToTicks> @ imm = #0xe74a
7009f066: f5b0 7f7a    	cmp.w	r0, #0x3e8
7009f06a: d01d         	beq	0x7009f0a8 <ClockP_init+0x108> @ imm = #0x3a
7009f06c: e7ff         	b	0x7009f06e <ClockP_init+0xce> @ imm = #-0x2
;         DebugP_logWarn("FreeRTOS configTICK_RATE_HZ (%d), does not match ClockP tick rate Hz (%d)\r\n",
7009f06e: f640 40b8    	movw	r0, #0xcb8
7009f072: f2c7 000b    	movt	r0, #0x700b
7009f076: 6901         	ldr	r1, [r0, #0x10]
7009f078: f244 2040    	movw	r0, #0x4240
7009f07c: f2c0 000f    	movt	r0, #0xf
7009f080: fbb0 f0f1    	udiv	r0, r0, r1
7009f084: 4669         	mov	r1, sp
7009f086: 6048         	str	r0, [r1, #0x4]
7009f088: f44f 707a    	mov.w	r0, #0x3e8
7009f08c: 6008         	str	r0, [r1]
7009f08e: f64f 31c0    	movw	r1, #0xfbc0
7009f092: f2c7 010a    	movt	r1, #0x700a
7009f096: f240 42c4    	movw	r2, #0x4c4
7009f09a: f2c7 020b    	movt	r2, #0x700b
7009f09e: 2004         	movs	r0, #0x4
7009f0a0: 2346         	movs	r3, #0x46
7009f0a2: f009 f885    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #0x910a
;     }
7009f0a6: e7ff         	b	0x7009f0a8 <ClockP_init+0x108> @ imm = #-0x2
7009f0a8: a80f         	add	r0, sp, #0x3c
;     TimerP_Params_init(&timerParams);
7009f0aa: 9002         	str	r0, [sp, #0x8]
7009f0ac: f00d fc58    	bl	0x700ac960 <TimerP_Params_init> @ imm = #0xd8b0
7009f0b0: 9902         	ldr	r1, [sp, #0x8]
;     timerParams.inputPreScaler    = gClockConfig.timerInputPreScaler;
7009f0b2: f640 40b8    	movw	r0, #0xcb8
7009f0b6: f2c7 000b    	movt	r0, #0x700b
7009f0ba: 9004         	str	r0, [sp, #0x10]
7009f0bc: 68c2         	ldr	r2, [r0, #0xc]
7009f0be: 920f         	str	r2, [sp, #0x3c]
;     timerParams.inputClkHz        = gClockConfig.timerInputClkHz;
7009f0c0: 6882         	ldr	r2, [r0, #0x8]
7009f0c2: 9210         	str	r2, [sp, #0x40]
;     timerParams.periodInUsec      = gClockConfig.usecPerTick;
7009f0c4: 6900         	ldr	r0, [r0, #0x10]
7009f0c6: 9011         	str	r0, [sp, #0x44]
7009f0c8: 2000         	movs	r0, #0x0
;     timerParams.oneshotMode       = 0;
7009f0ca: 9003         	str	r0, [sp, #0xc]
7009f0cc: 9013         	str	r0, [sp, #0x4c]
7009f0ce: 2001         	movs	r0, #0x1
;     timerParams.enableOverflowInt = 1;
7009f0d0: 9014         	str	r0, [sp, #0x50]
;     TimerP_setup(gClockCtrl.timerBaseAddr, &timerParams);
7009f0d2: f644 4090    	movw	r0, #0x4c90
7009f0d6: f2c7 0008    	movt	r0, #0x7008
7009f0da: 9006         	str	r0, [sp, #0x18]
7009f0dc: 6ac0         	ldr	r0, [r0, #0x2c]
7009f0de: f7fd fbbf    	bl	0x7009c860 <TimerP_setup> @ imm = #-0x2882
7009f0e2: 9806         	ldr	r0, [sp, #0x18]
;     gClockCtrl.timerReloadCount = TimerP_getReloadCount(gClockCtrl.timerBaseAddr);
7009f0e4: 6ac0         	ldr	r0, [r0, #0x2c]
7009f0e6: f00e fedb    	bl	0x700adea0 <TimerP_getReloadCount> @ imm = #0xedb6
7009f0ea: 9906         	ldr	r1, [sp, #0x18]
7009f0ec: 6308         	str	r0, [r1, #0x30]
7009f0ee: a80a         	add	r0, sp, #0x28
;     HwiP_Params_init(&timerHwiParams);
7009f0f0: 9005         	str	r0, [sp, #0x14]
7009f0f2: f00f f95d    	bl	0x700ae3b0 <HwiP_Params_init> @ imm = #0xf2ba
7009f0f6: 9b03         	ldr	r3, [sp, #0xc]
7009f0f8: 9a04         	ldr	r2, [sp, #0x10]
7009f0fa: 9905         	ldr	r1, [sp, #0x14]
7009f0fc: 9806         	ldr	r0, [sp, #0x18]
;     timerHwiParams.intNum = gClockConfig.timerHwiIntNum;
7009f0fe: f8d2 c004    	ldr.w	r12, [r2, #0x4]
7009f102: f8cd c028    	str.w	r12, [sp, #0x28]
;     timerHwiParams.callback = ClockP_timerTickIsr;
7009f106: f64c 2c91    	movw	r12, #0xca91
7009f10a: f2c7 0c0a    	movt	r12, #0x700a
7009f10e: f8cd c02c    	str.w	r12, [sp, #0x2c]
;     timerHwiParams.isPulse = 0;
7009f112: f88d 3038    	strb.w	r3, [sp, #0x38]
;     timerHwiParams.priority = gClockConfig.intrPriority;
7009f116: 7d12         	ldrb	r2, [r2, #0x14]
7009f118: f88d 2036    	strb.w	r2, [sp, #0x36]
;     (void)HwiP_construct(&gClockCtrl.timerHwiObj, &timerHwiParams);
7009f11c: 300c         	adds	r0, #0xc
7009f11e: f00f f95f    	bl	0x700ae3e0 <HwiP_construct> @ imm = #0xf2be
;     TimerP_start(gClockCtrl.timerBaseAddr);
7009f122: 9806         	ldr	r0, [sp, #0x18]
7009f124: 6ac0         	ldr	r0, [r0, #0x2c]
7009f126: f00e fd23    	bl	0x700adb70 <TimerP_start> @ imm = #0xea46
; }
7009f12a: b016         	add	sp, #0x58
7009f12c: bd80         	pop	{r7, pc}
7009f12e: 0000         	movs	r0, r0

7009f130 <Sciclient_rmIrqDeleteRoute>:
; {
7009f130: b580         	push	{r7, lr}
7009f132: b090         	sub	sp, #0x40
7009f134: 900f         	str	r0, [sp, #0x3c]
7009f136: f88d 103b    	strb.w	r1, [sp, #0x3b]
7009f13a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009f13c: 900d         	str	r0, [sp, #0x34]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
7009f13e: 9002         	str	r0, [sp, #0x8]
;     struct Sciclient_rmIrInst *ir_inst = NULL;
7009f140: 9001         	str	r0, [sp, #0x4]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
7009f142: f8ad 0032    	strh.w	r0, [sp, #0x32]
7009f146: e7ff         	b	0x7009f148 <Sciclient_rmIrqDeleteRoute+0x18> @ imm = #-0x2
7009f148: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009f14c: 9000         	str	r0, [sp]
7009f14e: f00e ffcf    	bl	0x700ae0f0 <Sciclient_rmPsGetPsp> @ imm = #0xef9e
7009f152: 4601         	mov	r1, r0
7009f154: 9800         	ldr	r0, [sp]
7009f156: 4288         	cmp	r0, r1
7009f158: f280 80ac    	bge.w	0x7009f2b4 <Sciclient_rmIrqDeleteRoute+0x184> @ imm = #0x158
7009f15c: e7ff         	b	0x7009f15e <Sciclient_rmIrqDeleteRoute+0x2e> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
7009f15e: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009f162: f00e fba5    	bl	0x700ad8b0 <Sciclient_rmPsGetIrqNode> @ imm = #0xe74a
7009f166: 900b         	str	r0, [sp, #0x2c]
;         cur_inp = Sciclient_rmPsGetInp(i);
7009f168: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009f16c: f00c ff78    	bl	0x700ac060 <Sciclient_rmPsGetInp> @ imm = #0xcef0
7009f170: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;         cur_outp = Sciclient_rmPsGetOutp(i);
7009f174: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009f178: f00c ff92    	bl	0x700ac0a0 <Sciclient_rmPsGetOutp> @ imm = #0xcf24
7009f17c: f8ad 0028    	strh.w	r0, [sp, #0x28]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
7009f180: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009f184: 2800         	cmp	r0, #0x0
7009f186: d156         	bne	0x7009f236 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0xac
7009f188: e7ff         	b	0x7009f18a <Sciclient_rmIrqDeleteRoute+0x5a> @ imm = #-0x2
7009f18a: 980b         	ldr	r0, [sp, #0x2c]
7009f18c: 8800         	ldrh	r0, [r0]
7009f18e: f00d fdd7    	bl	0x700acd40 <Sciclient_rmIaIsIa> @ imm = #0xdbae
7009f192: 2800         	cmp	r0, #0x0
7009f194: d04f         	beq	0x7009f236 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0x9e
7009f196: e7ff         	b	0x7009f198 <Sciclient_rmIrqDeleteRoute+0x68> @ imm = #-0x2
;             (unmap_vint == true)) {
7009f198: f89d 003b    	ldrb.w	r0, [sp, #0x3b]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
7009f19c: 07c0         	lsls	r0, r0, #0x1f
7009f19e: 2800         	cmp	r0, #0x0
7009f1a0: d049         	beq	0x7009f236 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0x92
7009f1a2: e7ff         	b	0x7009f1a4 <Sciclient_rmIrqDeleteRoute+0x74> @ imm = #-0x2
7009f1a4: 203c         	movs	r0, #0x3c
7009f1a6: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
7009f1aa: 9005         	str	r0, [sp, #0x14]
;             req.secondary_host = cfg->host;
7009f1ac: 980f         	ldr	r0, [sp, #0x3c]
7009f1ae: 7900         	ldrb	r0, [r0, #0x4]
7009f1b0: f88d 0027    	strb.w	r0, [sp, #0x27]
;             req.src_id = cfg->s_id;
7009f1b4: 980f         	ldr	r0, [sp, #0x3c]
7009f1b6: 88c0         	ldrh	r0, [r0, #0x6]
7009f1b8: f8ad 0018    	strh.w	r0, [sp, #0x18]
;             req.src_index = cfg->s_idx;
7009f1bc: 980f         	ldr	r0, [sp, #0x3c]
7009f1be: 8900         	ldrh	r0, [r0, #0x8]
7009f1c0: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             req.ia_id = cfg->s_ia;
7009f1c4: 980f         	ldr	r0, [sp, #0x3c]
7009f1c6: 8a00         	ldrh	r0, [r0, #0x10]
7009f1c8: f8ad 0020    	strh.w	r0, [sp, #0x20]
;             req.vint = cur_outp;
7009f1cc: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
7009f1d0: f8ad 0022    	strh.w	r0, [sp, #0x22]
;             req.global_event = cur_inp;
7009f1d4: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009f1d8: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             req.vint_status_bit_index = cfg->vint_sb;
7009f1dc: 980f         	ldr	r0, [sp, #0x3c]
7009f1de: 7d00         	ldrb	r0, [r0, #0x14]
7009f1e0: f88d 0026    	strb.w	r0, [sp, #0x26]
7009f1e4: a803         	add	r0, sp, #0xc
7009f1e6: f04f 31ff    	mov.w	r1, #0xffffffff
;             r = Sciclient_rmIrqReleaseRaw(&req,
7009f1ea: f00b fee1    	bl	0x700aafb0 <Sciclient_rmIrqReleaseRaw> @ imm = #0xbdc2
7009f1ee: 900d         	str	r0, [sp, #0x34]
;             if (r == SystemP_SUCCESS) {
7009f1f0: 980d         	ldr	r0, [sp, #0x34]
7009f1f2: b9f8         	cbnz	r0, 0x7009f234 <Sciclient_rmIrqDeleteRoute+0x104> @ imm = #0x3e
7009f1f4: e7ff         	b	0x7009f1f6 <Sciclient_rmIrqDeleteRoute+0xc6> @ imm = #-0x2
;                 ia_inst = Sciclient_rmIaGetInst(cur_n->id);
7009f1f6: 980b         	ldr	r0, [sp, #0x2c]
7009f1f8: 8800         	ldrh	r0, [r0]
7009f1fa: f00b fbb1    	bl	0x700aa960 <Sciclient_rmIaGetInst> @ imm = #0xb762
7009f1fe: 9002         	str	r0, [sp, #0x8]
;                 if (ia_inst != NULL) {
7009f200: 9802         	ldr	r0, [sp, #0x8]
7009f202: b1b0         	cbz	r0, 0x7009f232 <Sciclient_rmIrqDeleteRoute+0x102> @ imm = #0x2c
7009f204: e7ff         	b	0x7009f206 <Sciclient_rmIrqDeleteRoute+0xd6> @ imm = #-0x2
;                     ia_inst->vint_usage_count[cur_outp]--;
7009f206: 9802         	ldr	r0, [sp, #0x8]
7009f208: 6901         	ldr	r1, [r0, #0x10]
7009f20a: f8bd 2028    	ldrh.w	r2, [sp, #0x28]
7009f20e: 5c88         	ldrb	r0, [r1, r2]
7009f210: 3801         	subs	r0, #0x1
7009f212: 5488         	strb	r0, [r1, r2]
;                     if (ia_inst->v0_b0_evt == cur_inp - ia_inst->sevt_offset) {
7009f214: 9a02         	ldr	r2, [sp, #0x8]
7009f216: 8a90         	ldrh	r0, [r2, #0x14]
7009f218: f8bd 102a    	ldrh.w	r1, [sp, #0x2a]
7009f21c: 8912         	ldrh	r2, [r2, #0x8]
7009f21e: 1a89         	subs	r1, r1, r2
7009f220: 4288         	cmp	r0, r1
7009f222: d105         	bne	0x7009f230 <Sciclient_rmIrqDeleteRoute+0x100> @ imm = #0xa
7009f224: e7ff         	b	0x7009f226 <Sciclient_rmIrqDeleteRoute+0xf6> @ imm = #-0x2
;                         ia_inst->v0_b0_evt = SCICLIENT_RM_IA_GENERIC_EVT_RESETVAL;
7009f226: 9902         	ldr	r1, [sp, #0x8]
7009f228: f64f 70ff    	movw	r0, #0xffff
7009f22c: 8288         	strh	r0, [r1, #0x14]
;                     }
7009f22e: e7ff         	b	0x7009f230 <Sciclient_rmIrqDeleteRoute+0x100> @ imm = #-0x2
;                 }
7009f230: e7ff         	b	0x7009f232 <Sciclient_rmIrqDeleteRoute+0x102> @ imm = #-0x2
;             }
7009f232: e7ff         	b	0x7009f234 <Sciclient_rmIrqDeleteRoute+0x104> @ imm = #-0x2
;         }
7009f234: e7ff         	b	0x7009f236 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #-0x2
;         if (i > 0u) {
7009f236: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009f23a: b3a0         	cbz	r0, 0x7009f2a6 <Sciclient_rmIrqDeleteRoute+0x176> @ imm = #0x68
7009f23c: e7ff         	b	0x7009f23e <Sciclient_rmIrqDeleteRoute+0x10e> @ imm = #-0x2
7009f23e: 2003         	movs	r0, #0x3
7009f240: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_DST_ID_VALID |
7009f244: 9005         	str	r0, [sp, #0x14]
;             req.secondary_host = cfg->host;
7009f246: 980f         	ldr	r0, [sp, #0x3c]
7009f248: 7900         	ldrb	r0, [r0, #0x4]
7009f24a: f88d 0027    	strb.w	r0, [sp, #0x27]
;             req.src_id = cur_n->id;
7009f24e: 980b         	ldr	r0, [sp, #0x2c]
7009f250: 8800         	ldrh	r0, [r0]
7009f252: f8ad 0018    	strh.w	r0, [sp, #0x18]
;             req.src_index = cur_inp;
7009f256: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009f25a: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             req.dst_id = cur_n->id;
7009f25e: 980b         	ldr	r0, [sp, #0x2c]
7009f260: 8800         	ldrh	r0, [r0]
7009f262: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.dst_host_irq = cur_outp;
7009f266: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
7009f26a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009f26e: a803         	add	r0, sp, #0xc
7009f270: f04f 31ff    	mov.w	r1, #0xffffffff
;             r = Sciclient_rmIrqReleaseRaw(&req,
7009f274: f00b fe9c    	bl	0x700aafb0 <Sciclient_rmIrqReleaseRaw> @ imm = #0xbd38
7009f278: 900d         	str	r0, [sp, #0x34]
;             if ((r == SystemP_SUCCESS) && (cur_outp == 0)) {
7009f27a: 980d         	ldr	r0, [sp, #0x34]
7009f27c: b990         	cbnz	r0, 0x7009f2a4 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #0x24
7009f27e: e7ff         	b	0x7009f280 <Sciclient_rmIrqDeleteRoute+0x150> @ imm = #-0x2
7009f280: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
7009f284: b970         	cbnz	r0, 0x7009f2a4 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #0x1c
7009f286: e7ff         	b	0x7009f288 <Sciclient_rmIrqDeleteRoute+0x158> @ imm = #-0x2
;                 ir_inst = Sciclient_rmIrGetInst(cur_n->id);
7009f288: 980b         	ldr	r0, [sp, #0x2c]
7009f28a: 8800         	ldrh	r0, [r0]
7009f28c: f00a fe48    	bl	0x700a9f20 <Sciclient_rmIrGetInst> @ imm = #0xac90
7009f290: 9001         	str	r0, [sp, #0x4]
;                 if (ir_inst != NULL) {
7009f292: 9801         	ldr	r0, [sp, #0x4]
7009f294: b128         	cbz	r0, 0x7009f2a2 <Sciclient_rmIrqDeleteRoute+0x172> @ imm = #0xa
7009f296: e7ff         	b	0x7009f298 <Sciclient_rmIrqDeleteRoute+0x168> @ imm = #-0x2
;                     ir_inst->inp0_mapping = SCICLIENT_RM_IR_MAPPING_FREE;
7009f298: 9901         	ldr	r1, [sp, #0x4]
7009f29a: f64f 70ff    	movw	r0, #0xffff
7009f29e: 8188         	strh	r0, [r1, #0xc]
;                 }
7009f2a0: e7ff         	b	0x7009f2a2 <Sciclient_rmIrqDeleteRoute+0x172> @ imm = #-0x2
;             }
7009f2a2: e7ff         	b	0x7009f2a4 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #-0x2
;         }
7009f2a4: e7ff         	b	0x7009f2a6 <Sciclient_rmIrqDeleteRoute+0x176> @ imm = #-0x2
;     }
7009f2a6: e7ff         	b	0x7009f2a8 <Sciclient_rmIrqDeleteRoute+0x178> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
7009f2a8: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009f2ac: 3001         	adds	r0, #0x1
7009f2ae: f8ad 0032    	strh.w	r0, [sp, #0x32]
7009f2b2: e749         	b	0x7009f148 <Sciclient_rmIrqDeleteRoute+0x18> @ imm = #-0x16e
;     return r;
7009f2b4: 980d         	ldr	r0, [sp, #0x34]
7009f2b6: b010         	add	sp, #0x40
7009f2b8: bd80         	pop	{r7, pc}
7009f2ba: 0000         	movs	r0, r0
7009f2bc: 0000         	movs	r0, r0
7009f2be: 0000         	movs	r0, r0

7009f2c0 <Sciclient_rmProgramInterruptRoute>:
; {
7009f2c0: b580         	push	{r7, lr}
7009f2c2: b08e         	sub	sp, #0x38
7009f2c4: 900d         	str	r0, [sp, #0x34]
7009f2c6: 910c         	str	r1, [sp, #0x30]
7009f2c8: 920b         	str	r2, [sp, #0x2c]
7009f2ca: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009f2cc: 9001         	str	r0, [sp, #0x4]
7009f2ce: 900a         	str	r0, [sp, #0x28]
7009f2d0: f44f 5180    	mov.w	r1, #0x1000
;     uint16_t messageType = TISCI_MSG_RM_IRQ_SET;
7009f2d4: f8ad 1026    	strh.w	r1, [sp, #0x26]
;     memset(&cfg, 0, sizeof(cfg));
7009f2d8: 9008         	str	r0, [sp, #0x20]
7009f2da: 9007         	str	r0, [sp, #0x1c]
7009f2dc: 9006         	str	r0, [sp, #0x18]
7009f2de: 9005         	str	r0, [sp, #0x14]
7009f2e0: 9004         	str	r0, [sp, #0x10]
7009f2e2: 9003         	str	r0, [sp, #0xc]
7009f2e4: 9002         	str	r0, [sp, #0x8]
;     if((req == NULL) || (resp == NULL)) {
7009f2e6: 980d         	ldr	r0, [sp, #0x34]
7009f2e8: b118         	cbz	r0, 0x7009f2f2 <Sciclient_rmProgramInterruptRoute+0x32> @ imm = #0x6
7009f2ea: e7ff         	b	0x7009f2ec <Sciclient_rmProgramInterruptRoute+0x2c> @ imm = #-0x2
7009f2ec: 980c         	ldr	r0, [sp, #0x30]
7009f2ee: b920         	cbnz	r0, 0x7009f2fa <Sciclient_rmProgramInterruptRoute+0x3a> @ imm = #0x8
7009f2f0: e7ff         	b	0x7009f2f2 <Sciclient_rmProgramInterruptRoute+0x32> @ imm = #-0x2
7009f2f2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009f2f6: 900a         	str	r0, [sp, #0x28]
;     }
7009f2f8: e7ff         	b	0x7009f2fa <Sciclient_rmProgramInterruptRoute+0x3a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
7009f2fa: 980a         	ldr	r0, [sp, #0x28]
7009f2fc: b968         	cbnz	r0, 0x7009f31a <Sciclient_rmProgramInterruptRoute+0x5a> @ imm = #0x1a
7009f2fe: e7ff         	b	0x7009f300 <Sciclient_rmProgramInterruptRoute+0x40> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
7009f300: 980d         	ldr	r0, [sp, #0x34]
7009f302: 6880         	ldr	r0, [r0, #0x8]
7009f304: f04f 4100    	mov.w	r1, #0x80000000
7009f308: f00d ff42    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0xde84
;     if (r == SystemP_SUCCESS &&
7009f30c: b128         	cbz	r0, 0x7009f31a <Sciclient_rmProgramInterruptRoute+0x5a> @ imm = #0xa
7009f30e: e7ff         	b	0x7009f310 <Sciclient_rmProgramInterruptRoute+0x50> @ imm = #-0x2
;         dst_host = req->secondary_host;
7009f310: 980d         	ldr	r0, [sp, #0x34]
7009f312: 7ec0         	ldrb	r0, [r0, #0x1b]
7009f314: f88d 0025    	strb.w	r0, [sp, #0x25]
;     } else {
7009f318: e00f         	b	0x7009f33a <Sciclient_rmProgramInterruptRoute+0x7a> @ imm = #0x1e
;         dst_host = (uint8_t) gSciclientMap[Sciclient_getCurrentContext(messageType)].hostId;
7009f31a: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
7009f31e: f006 fe47    	bl	0x700a5fb0 <Sciclient_getCurrentContext> @ imm = #0x6c8e
7009f322: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009f326: f24f 70b8    	movw	r0, #0xf7b8
7009f32a: f2c7 000a    	movt	r0, #0x700a
7009f32e: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009f332: 6840         	ldr	r0, [r0, #0x4]
7009f334: f88d 0025    	strb.w	r0, [sp, #0x25]
7009f338: e7ff         	b	0x7009f33a <Sciclient_rmProgramInterruptRoute+0x7a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
7009f33a: 980a         	ldr	r0, [sp, #0x28]
7009f33c: b960         	cbnz	r0, 0x7009f358 <Sciclient_rmProgramInterruptRoute+0x98> @ imm = #0x18
7009f33e: e7ff         	b	0x7009f340 <Sciclient_rmProgramInterruptRoute+0x80> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
7009f340: 980d         	ldr	r0, [sp, #0x34]
7009f342: 6880         	ldr	r0, [r0, #0x8]
7009f344: 2104         	movs	r1, #0x4
7009f346: f00d ff23    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0xde46
;     if (r == SystemP_SUCCESS &&
7009f34a: b128         	cbz	r0, 0x7009f358 <Sciclient_rmProgramInterruptRoute+0x98> @ imm = #0xa
7009f34c: e7ff         	b	0x7009f34e <Sciclient_rmProgramInterruptRoute+0x8e> @ imm = #-0x2
;         cfg.s_ia = req->ia_id;
7009f34e: 980d         	ldr	r0, [sp, #0x34]
7009f350: 8a80         	ldrh	r0, [r0, #0x14]
7009f352: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     } else {
7009f356: e003         	b	0x7009f360 <Sciclient_rmProgramInterruptRoute+0xa0> @ imm = #0x6
7009f358: 20ff         	movs	r0, #0xff
;         cfg.s_ia = SCICLIENT_RM_DEV_NONE;
7009f35a: f8ad 0018    	strh.w	r0, [sp, #0x18]
7009f35e: e7ff         	b	0x7009f360 <Sciclient_rmProgramInterruptRoute+0xa0> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009f360: 980a         	ldr	r0, [sp, #0x28]
7009f362: 2800         	cmp	r0, #0x0
7009f364: d16e         	bne	0x7009f444 <Sciclient_rmProgramInterruptRoute+0x184> @ imm = #0xdc
7009f366: e7ff         	b	0x7009f368 <Sciclient_rmProgramInterruptRoute+0xa8> @ imm = #-0x2
;         cfg.valid_params = req->valid_params;
7009f368: 980d         	ldr	r0, [sp, #0x34]
7009f36a: 6880         	ldr	r0, [r0, #0x8]
7009f36c: 9002         	str	r0, [sp, #0x8]
;         cfg.host = dst_host;
7009f36e: f89d 0025    	ldrb.w	r0, [sp, #0x25]
7009f372: f88d 000c    	strb.w	r0, [sp, #0xc]
;         cfg.s_id = req->src_id;
7009f376: 980d         	ldr	r0, [sp, #0x34]
7009f378: 8980         	ldrh	r0, [r0, #0xc]
7009f37a: f8ad 000e    	strh.w	r0, [sp, #0xe]
;         cfg.s_idx = req->src_index;
7009f37e: 980d         	ldr	r0, [sp, #0x34]
7009f380: 89c0         	ldrh	r0, [r0, #0xe]
7009f382: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         cfg.d_id = req->dst_id;
7009f386: 980d         	ldr	r0, [sp, #0x34]
7009f388: 8a00         	ldrh	r0, [r0, #0x10]
7009f38a: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         cfg.d_irq = req->dst_host_irq;
7009f38e: 980d         	ldr	r0, [sp, #0x34]
7009f390: 8a40         	ldrh	r0, [r0, #0x12]
7009f392: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         cfg.global_evt = req->global_event;
7009f396: 980d         	ldr	r0, [sp, #0x34]
7009f398: 8b00         	ldrh	r0, [r0, #0x18]
7009f39a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         cfg.vint = req->vint;
7009f39e: 980d         	ldr	r0, [sp, #0x34]
7009f3a0: 8ac0         	ldrh	r0, [r0, #0x16]
7009f3a2: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         cfg.vint_sb = req->vint_status_bit_index;
7009f3a6: 980d         	ldr	r0, [sp, #0x34]
7009f3a8: 7e80         	ldrb	r0, [r0, #0x1a]
7009f3aa: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         cfg.set_resp = resp;
7009f3ae: 980c         	ldr	r0, [sp, #0x30]
7009f3b0: 9008         	str	r0, [sp, #0x20]
;         if (Sciclient_rmIrqCfgIsDirectNonEvent(cfg.valid_params) == true) {
7009f3b2: 9802         	ldr	r0, [sp, #0x8]
7009f3b4: f00a fc64    	bl	0x700a9c80 <Sciclient_rmIrqCfgIsDirectNonEvent> @ imm = #0xa8c8
7009f3b8: b1c8         	cbz	r0, 0x7009f3ee <Sciclient_rmProgramInterruptRoute+0x12e> @ imm = #0x32
7009f3ba: e7ff         	b	0x7009f3bc <Sciclient_rmProgramInterruptRoute+0xfc> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cfg.s_id) == true) {
7009f3bc: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
7009f3c0: f00d fcbe    	bl	0x700acd40 <Sciclient_rmIaIsIa> @ imm = #0xd97c
7009f3c4: b128         	cbz	r0, 0x7009f3d2 <Sciclient_rmProgramInterruptRoute+0x112> @ imm = #0xa
7009f3c6: e7ff         	b	0x7009f3c8 <Sciclient_rmProgramInterruptRoute+0x108> @ imm = #-0x2
;                 cfg.vint = cfg.s_idx;
7009f3c8: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
7009f3cc: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             }
7009f3d0: e7ff         	b	0x7009f3d2 <Sciclient_rmProgramInterruptRoute+0x112> @ imm = #-0x2
7009f3d2: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqFindRoute(&cfg);
7009f3d4: f7fd fcb4    	bl	0x7009cd40 <Sciclient_rmIrqFindRoute> @ imm = #-0x2698
7009f3d8: 900a         	str	r0, [sp, #0x28]
;             if (r == SystemP_SUCCESS) {
7009f3da: 980a         	ldr	r0, [sp, #0x28]
7009f3dc: b930         	cbnz	r0, 0x7009f3ec <Sciclient_rmProgramInterruptRoute+0x12c> @ imm = #0xc
7009f3de: e7ff         	b	0x7009f3e0 <Sciclient_rmProgramInterruptRoute+0x120> @ imm = #-0x2
7009f3e0: a802         	add	r0, sp, #0x8
7009f3e2: 2100         	movs	r1, #0x0
;                 r = Sciclient_rmIrqProgramRoute(&cfg, false);
7009f3e4: f000 f8fc    	bl	0x7009f5e0 <Sciclient_rmIrqProgramRoute> @ imm = #0x1f8
7009f3e8: 900a         	str	r0, [sp, #0x28]
;             }
7009f3ea: e7ff         	b	0x7009f3ec <Sciclient_rmProgramInterruptRoute+0x12c> @ imm = #-0x2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
7009f3ec: e029         	b	0x7009f442 <Sciclient_rmProgramInterruptRoute+0x182> @ imm = #0x52
7009f3ee: 9802         	ldr	r0, [sp, #0x8]
7009f3f0: f00a fc0e    	bl	0x700a9c10 <Sciclient_rmIrqCfgIsDirectEvent> @ imm = #0xa81c
;                 true) ||
7009f3f4: b928         	cbnz	r0, 0x7009f402 <Sciclient_rmProgramInterruptRoute+0x142> @ imm = #0xa
7009f3f6: e7ff         	b	0x7009f3f8 <Sciclient_rmProgramInterruptRoute+0x138> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg.valid_params) ==
7009f3f8: 9802         	ldr	r0, [sp, #0x8]
7009f3fa: f00a fc79    	bl	0x700a9cf0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0xa8f2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
7009f3fe: b128         	cbz	r0, 0x7009f40c <Sciclient_rmProgramInterruptRoute+0x14c> @ imm = #0xa
7009f400: e7ff         	b	0x7009f402 <Sciclient_rmProgramInterruptRoute+0x142> @ imm = #-0x2
7009f402: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqVintAdd(&cfg);
7009f404: f003 fc7c    	bl	0x700a2d00 <Sciclient_rmIrqVintAdd> @ imm = #0x38f8
7009f408: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsUnmappedVintDirectEvent(cfg.valid_params) ==
7009f40a: e019         	b	0x7009f440 <Sciclient_rmProgramInterruptRoute+0x180> @ imm = #0x32
7009f40c: 9802         	ldr	r0, [sp, #0x8]
7009f40e: f00a fcdf    	bl	0x700a9dd0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent> @ imm = #0xa9be
7009f412: b128         	cbz	r0, 0x7009f420 <Sciclient_rmProgramInterruptRoute+0x160> @ imm = #0xa
7009f414: e7ff         	b	0x7009f416 <Sciclient_rmProgramInterruptRoute+0x156> @ imm = #-0x2
7009f416: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmUnmappedVintRouteCreate(&cfg);
7009f418: f00b feea    	bl	0x700ab1f0 <Sciclient_rmUnmappedVintRouteCreate> @ imm = #0xbdd4
7009f41c: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsOesOnly(cfg.valid_params) == true) {
7009f41e: e00e         	b	0x7009f43e <Sciclient_rmProgramInterruptRoute+0x17e> @ imm = #0x1c
7009f420: 9802         	ldr	r0, [sp, #0x8]
7009f422: f00a fc9d    	bl	0x700a9d60 <Sciclient_rmIrqCfgIsOesOnly> @ imm = #0xa93a
7009f426: b128         	cbz	r0, 0x7009f434 <Sciclient_rmProgramInterruptRoute+0x174> @ imm = #0xa
7009f428: e7ff         	b	0x7009f42a <Sciclient_rmProgramInterruptRoute+0x16a> @ imm = #-0x2
7009f42a: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqProgramOesRegister(&cfg);
7009f42c: f00c fdd8    	bl	0x700abfe0 <Sciclient_rmIrqProgramOesRegister> @ imm = #0xcbb0
7009f430: 900a         	str	r0, [sp, #0x28]
;         } else {
7009f432: e003         	b	0x7009f43c <Sciclient_rmProgramInterruptRoute+0x17c> @ imm = #0x6
7009f434: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
7009f438: 900a         	str	r0, [sp, #0x28]
7009f43a: e7ff         	b	0x7009f43c <Sciclient_rmProgramInterruptRoute+0x17c> @ imm = #-0x2
7009f43c: e7ff         	b	0x7009f43e <Sciclient_rmProgramInterruptRoute+0x17e> @ imm = #-0x2
7009f43e: e7ff         	b	0x7009f440 <Sciclient_rmProgramInterruptRoute+0x180> @ imm = #-0x2
7009f440: e7ff         	b	0x7009f442 <Sciclient_rmProgramInterruptRoute+0x182> @ imm = #-0x2
;     }
7009f442: e7ff         	b	0x7009f444 <Sciclient_rmProgramInterruptRoute+0x184> @ imm = #-0x2
;     return r;
7009f444: 980a         	ldr	r0, [sp, #0x28]
7009f446: b00e         	add	sp, #0x38
7009f448: bd80         	pop	{r7, pc}
7009f44a: 0000         	movs	r0, r0
7009f44c: 0000         	movs	r0, r0
7009f44e: 0000         	movs	r0, r0

7009f450 <PMU_init>:
; int32_t PMU_init(PMU_Config *cfg) {
7009f450: b580         	push	{r7, lr}
7009f452: b08a         	sub	sp, #0x28
7009f454: 9009         	str	r0, [sp, #0x24]
;   memset((void *)&gProfileObject, 0U, sizeof(gProfileObject));
7009f456: f243 0080    	movw	r0, #0x3080
7009f45a: f2c7 0008    	movt	r0, #0x7008
7009f45e: 9003         	str	r0, [sp, #0xc]
7009f460: f640 510c    	movw	r1, #0xd0c
7009f464: f7fa e9e6    	blx	0x70099834 <__aeabi_memclr8> @ imm = #-0x5c34
7009f468: 9a03         	ldr	r2, [sp, #0xc]
7009f46a: 2000         	movs	r0, #0x0
;   gProfileObject.logIndex = 0U;
7009f46c: 9004         	str	r0, [sp, #0x10]
7009f46e: 6010         	str	r0, [r2]
;   gProfileObject.bCycleCounter = cfg->bCycleCounter;
7009f470: 9909         	ldr	r1, [sp, #0x24]
7009f472: 6809         	ldr	r1, [r1]
7009f474: 6051         	str	r1, [r2, #0x4]
;   DebugP_assert(cfg->numEventCounters <= 3U);
7009f476: 9909         	ldr	r1, [sp, #0x24]
7009f478: 6849         	ldr	r1, [r1, #0x4]
7009f47a: 2904         	cmp	r1, #0x4
7009f47c: bf38         	it	lo
7009f47e: 2001         	movlo	r0, #0x1
7009f480: f240 1191    	movw	r1, #0x191
7009f484: f2c7 010b    	movt	r1, #0x700b
7009f488: 466a         	mov	r2, sp
7009f48a: 6011         	str	r1, [r2]
7009f48c: f240 5129    	movw	r1, #0x529
7009f490: f2c7 010b    	movt	r1, #0x700b
7009f494: f240 5233    	movw	r2, #0x533
7009f498: f2c7 020b    	movt	r2, #0x700b
7009f49c: 236e         	movs	r3, #0x6e
7009f49e: f009 fe3f    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x9c7e
7009f4a2: 9a03         	ldr	r2, [sp, #0xc]
7009f4a4: 9804         	ldr	r0, [sp, #0x10]
;   gProfileObject.numEvents = cfg->numEventCounters;
7009f4a6: 9909         	ldr	r1, [sp, #0x24]
7009f4a8: 6849         	ldr	r1, [r1, #0x4]
7009f4aa: 6091         	str	r1, [r2, #0x8]
;   for (i = 0; i < PMU_MAX_LOG_ENTRIES; i++) {
7009f4ac: 9008         	str	r0, [sp, #0x20]
7009f4ae: e7ff         	b	0x7009f4b0 <PMU_init+0x60> @ imm = #-0x2
7009f4b0: 9808         	ldr	r0, [sp, #0x20]
7009f4b2: 283f         	cmp	r0, #0x3f
7009f4b4: d833         	bhi	0x7009f51e <PMU_init+0xce> @ imm = #0x66
7009f4b6: e7ff         	b	0x7009f4b8 <PMU_init+0x68> @ imm = #-0x2
;     PMU_ProfilePoint *p = &gProfileObject.point[i];
7009f4b8: 9808         	ldr	r0, [sp, #0x20]
7009f4ba: f243 0280    	movw	r2, #0x3080
7009f4be: f2c7 0208    	movt	r2, #0x7008
7009f4c2: 2134         	movs	r1, #0x34
7009f4c4: fb00 2001    	mla	r0, r0, r1, r2
7009f4c8: 300c         	adds	r0, #0xc
7009f4ca: 9006         	str	r0, [sp, #0x18]
7009f4cc: 2000         	movs	r0, #0x0
;     for (j = 0; j < cfg->numEventCounters; j++) {
7009f4ce: 9007         	str	r0, [sp, #0x1c]
7009f4d0: e7ff         	b	0x7009f4d2 <PMU_init+0x82> @ imm = #-0x2
7009f4d2: 9807         	ldr	r0, [sp, #0x1c]
7009f4d4: 9909         	ldr	r1, [sp, #0x24]
7009f4d6: 6849         	ldr	r1, [r1, #0x4]
7009f4d8: 4288         	cmp	r0, r1
7009f4da: d21b         	bhs	0x7009f514 <PMU_init+0xc4> @ imm = #0x36
7009f4dc: e7ff         	b	0x7009f4de <PMU_init+0x8e> @ imm = #-0x2
;       p->events[j].name = cfg->eventCounters[j].name;
7009f4de: 9809         	ldr	r0, [sp, #0x24]
7009f4e0: 6880         	ldr	r0, [r0, #0x8]
7009f4e2: 9a07         	ldr	r2, [sp, #0x1c]
7009f4e4: eb00 00c2    	add.w	r0, r0, r2, lsl #3
7009f4e8: 6840         	ldr	r0, [r0, #0x4]
7009f4ea: 9906         	ldr	r1, [sp, #0x18]
7009f4ec: eb02 0242    	add.w	r2, r2, r2, lsl #1
7009f4f0: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;       p->events[j].type = cfg->eventCounters[j].type;
7009f4f4: 9809         	ldr	r0, [sp, #0x24]
7009f4f6: 6880         	ldr	r0, [r0, #0x8]
7009f4f8: 9a07         	ldr	r2, [sp, #0x1c]
7009f4fa: f850 0032    	ldr.w	r0, [r0, r2, lsl #3]
7009f4fe: 9906         	ldr	r1, [sp, #0x18]
7009f500: eb02 0242    	add.w	r2, r2, r2, lsl #1
7009f504: eb01 0182    	add.w	r1, r1, r2, lsl #2
7009f508: 6048         	str	r0, [r1, #0x4]
;     }
7009f50a: e7ff         	b	0x7009f50c <PMU_init+0xbc> @ imm = #-0x2
;     for (j = 0; j < cfg->numEventCounters; j++) {
7009f50c: 9807         	ldr	r0, [sp, #0x1c]
7009f50e: 3001         	adds	r0, #0x1
7009f510: 9007         	str	r0, [sp, #0x1c]
7009f512: e7de         	b	0x7009f4d2 <PMU_init+0x82> @ imm = #-0x44
;   }
7009f514: e7ff         	b	0x7009f516 <PMU_init+0xc6> @ imm = #-0x2
;   for (i = 0; i < PMU_MAX_LOG_ENTRIES; i++) {
7009f516: 9808         	ldr	r0, [sp, #0x20]
7009f518: 3001         	adds	r0, #0x1
7009f51a: 9008         	str	r0, [sp, #0x20]
7009f51c: e7c8         	b	0x7009f4b0 <PMU_init+0x60> @ imm = #-0x70
;   int32_t numCount = CSL_armR5PmuGetNumCntrs();
7009f51e: f001 e946    	blx	0x700a07ac <CSL_armR5PmuGetNumCntrs> @ imm = #0x128c
7009f522: 9005         	str	r0, [sp, #0x14]
;   DebugP_assert(numCount == cfg->numEventCounters);
7009f524: 9805         	ldr	r0, [sp, #0x14]
7009f526: 9909         	ldr	r1, [sp, #0x24]
7009f528: 6849         	ldr	r1, [r1, #0x4]
7009f52a: 1a40         	subs	r0, r0, r1
7009f52c: fab0 f080    	clz	r0, r0
7009f530: 0940         	lsrs	r0, r0, #0x5
7009f532: f64f 71d2    	movw	r1, #0xffd2
7009f536: f2c7 010a    	movt	r1, #0x700a
7009f53a: 466a         	mov	r2, sp
7009f53c: 6011         	str	r1, [r2]
7009f53e: f240 5129    	movw	r1, #0x529
7009f542: f2c7 010b    	movt	r1, #0x700b
7009f546: f240 5233    	movw	r2, #0x533
7009f54a: f2c7 020b    	movt	r2, #0x700b
7009f54e: 237d         	movs	r3, #0x7d
7009f550: f009 fde6    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x9bcc
7009f554: 2100         	movs	r1, #0x0
7009f556: 9102         	str	r1, [sp, #0x8]
7009f558: 2201         	movs	r2, #0x1
;   CSL_armR5PmuCfg(0, 0, 1);
7009f55a: 4608         	mov	r0, r1
7009f55c: f001 e8f8    	blx	0x700a0750 <CSL_armR5PmuCfg> @ imm = #0x11f0
7009f560: 9802         	ldr	r0, [sp, #0x8]
;   for (i = 0; i < cfg->numEventCounters; i++) {
7009f562: 9008         	str	r0, [sp, #0x20]
7009f564: e7ff         	b	0x7009f566 <PMU_init+0x116> @ imm = #-0x2
7009f566: 9808         	ldr	r0, [sp, #0x20]
7009f568: 9909         	ldr	r1, [sp, #0x24]
7009f56a: 6849         	ldr	r1, [r1, #0x4]
7009f56c: 4288         	cmp	r0, r1
7009f56e: d20c         	bhs	0x7009f58a <PMU_init+0x13a> @ imm = #0x18
7009f570: e7ff         	b	0x7009f572 <PMU_init+0x122> @ imm = #-0x2
;     CSL_armR5PmuCfgCntr(i, (cfg->eventCounters[i].type & 0xFF));
7009f572: 9808         	ldr	r0, [sp, #0x20]
7009f574: 9909         	ldr	r1, [sp, #0x24]
7009f576: 6889         	ldr	r1, [r1, #0x8]
7009f578: f811 1030    	ldrb.w	r1, [r1, r0, lsl #3]
7009f57c: f001 e91e    	blx	0x700a07bc <CSL_armR5PmuCfgCntr> @ imm = #0x123c
;   }
7009f580: e7ff         	b	0x7009f582 <PMU_init+0x132> @ imm = #-0x2
;   for (i = 0; i < cfg->numEventCounters; i++) {
7009f582: 9808         	ldr	r0, [sp, #0x20]
7009f584: 3001         	adds	r0, #0x1
7009f586: 9008         	str	r0, [sp, #0x20]
7009f588: e7ed         	b	0x7009f566 <PMU_init+0x116> @ imm = #-0x26
7009f58a: 2000         	movs	r0, #0x0
;   for (i = 0; i < cfg->numEventCounters; i++) {
7009f58c: 9008         	str	r0, [sp, #0x20]
7009f58e: e7ff         	b	0x7009f590 <PMU_init+0x140> @ imm = #-0x2
7009f590: 9808         	ldr	r0, [sp, #0x20]
7009f592: 9909         	ldr	r1, [sp, #0x24]
7009f594: 6849         	ldr	r1, [r1, #0x4]
7009f596: 4288         	cmp	r0, r1
7009f598: d209         	bhs	0x7009f5ae <PMU_init+0x15e> @ imm = #0x12
7009f59a: e7ff         	b	0x7009f59c <PMU_init+0x14c> @ imm = #-0x2
;     CSL_armR5PmuEnableCntrOverflowIntr(i, 0);
7009f59c: 9808         	ldr	r0, [sp, #0x20]
7009f59e: 2100         	movs	r1, #0x0
7009f5a0: f001 e918    	blx	0x700a07d4 <CSL_armR5PmuEnableCntrOverflowIntr> @ imm = #0x1230
;   }
7009f5a4: e7ff         	b	0x7009f5a6 <PMU_init+0x156> @ imm = #-0x2
;   for (i = 0; i < cfg->numEventCounters; i++) {
7009f5a6: 9808         	ldr	r0, [sp, #0x20]
7009f5a8: 3001         	adds	r0, #0x1
7009f5aa: 9008         	str	r0, [sp, #0x20]
7009f5ac: e7f0         	b	0x7009f590 <PMU_init+0x140> @ imm = #-0x20
;   if (cfg->bCycleCounter == TRUE) {
7009f5ae: 9809         	ldr	r0, [sp, #0x24]
7009f5b0: 6800         	ldr	r0, [r0]
7009f5b2: 2801         	cmp	r0, #0x1
7009f5b4: d105         	bne	0x7009f5c2 <PMU_init+0x172> @ imm = #0xa
7009f5b6: e7ff         	b	0x7009f5b8 <PMU_init+0x168> @ imm = #-0x2
7009f5b8: 201f         	movs	r0, #0x1f
7009f5ba: 2100         	movs	r1, #0x0
;     CSL_armR5PmuEnableCntrOverflowIntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM, 0);
7009f5bc: f001 e90a    	blx	0x700a07d4 <CSL_armR5PmuEnableCntrOverflowIntr> @ imm = #0x1214
;   }
7009f5c0: e7ff         	b	0x7009f5c2 <PMU_init+0x172> @ imm = #-0x2
;   CSL_armR5PmuResetCntrs();
7009f5c2: f001 e960    	blx	0x700a0884 <CSL_armR5PmuResetCntrs> @ imm = #0x12c0
;   CSL_armR5PmuResetCycleCnt();
7009f5c6: f001 e956    	blx	0x700a0874 <CSL_armR5PmuResetCycleCnt> @ imm = #0x12ac
;   PMU_enableAllCounters(cfg->numEventCounters);
7009f5ca: 9809         	ldr	r0, [sp, #0x24]
7009f5cc: 6840         	ldr	r0, [r0, #0x4]
7009f5ce: f00d f807    	bl	0x700ac5e0 <PMU_enableAllCounters> @ imm = #0xd00e
7009f5d2: 2000         	movs	r0, #0x0
;   return SystemP_SUCCESS;
7009f5d4: b00a         	add	sp, #0x28
7009f5d6: bd80         	pop	{r7, pc}
		...

7009f5e0 <Sciclient_rmIrqProgramRoute>:
; {
7009f5e0: b580         	push	{r7, lr}
7009f5e2: b092         	sub	sp, #0x48
7009f5e4: 9011         	str	r0, [sp, #0x44]
7009f5e6: f88d 1043    	strb.w	r1, [sp, #0x43]
7009f5ea: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009f5ec: 900f         	str	r0, [sp, #0x3c]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
7009f5ee: 9003         	str	r0, [sp, #0xc]
;     struct Sciclient_rmIrInst *ir_inst = NULL;
7009f5f0: 9002         	str	r0, [sp, #0x8]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
7009f5f2: f8ad 003a    	strh.w	r0, [sp, #0x3a]
7009f5f6: e7ff         	b	0x7009f5f8 <Sciclient_rmIrqProgramRoute+0x18> @ imm = #-0x2
7009f5f8: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f5fc: 9001         	str	r0, [sp, #0x4]
7009f5fe: f00e fd77    	bl	0x700ae0f0 <Sciclient_rmPsGetPsp> @ imm = #0xeaee
7009f602: 4601         	mov	r1, r0
7009f604: 9801         	ldr	r0, [sp, #0x4]
7009f606: 4288         	cmp	r0, r1
7009f608: f280 80aa    	bge.w	0x7009f760 <Sciclient_rmIrqProgramRoute+0x180> @ imm = #0x154
7009f60c: e7ff         	b	0x7009f60e <Sciclient_rmIrqProgramRoute+0x2e> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
7009f60e: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f612: f00e f94d    	bl	0x700ad8b0 <Sciclient_rmPsGetIrqNode> @ imm = #0xe29a
7009f616: 900d         	str	r0, [sp, #0x34]
;         cur_inp = Sciclient_rmPsGetInp(i);
7009f618: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f61c: f00c fd20    	bl	0x700ac060 <Sciclient_rmPsGetInp> @ imm = #0xca40
7009f620: 900c         	str	r0, [sp, #0x30]
;         cur_outp = Sciclient_rmPsGetOutp(i);
7009f622: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f626: f00c fd3b    	bl	0x700ac0a0 <Sciclient_rmPsGetOutp> @ imm = #0xca76
7009f62a: 900b         	str	r0, [sp, #0x2c]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
7009f62c: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f630: 2800         	cmp	r0, #0x0
7009f632: d154         	bne	0x7009f6de <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0xa8
7009f634: e7ff         	b	0x7009f636 <Sciclient_rmIrqProgramRoute+0x56> @ imm = #-0x2
7009f636: 980d         	ldr	r0, [sp, #0x34]
7009f638: 8800         	ldrh	r0, [r0]
7009f63a: f00d fb81    	bl	0x700acd40 <Sciclient_rmIaIsIa> @ imm = #0xd702
7009f63e: 2800         	cmp	r0, #0x0
7009f640: d04d         	beq	0x7009f6de <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0x9a
7009f642: e7ff         	b	0x7009f644 <Sciclient_rmIrqProgramRoute+0x64> @ imm = #-0x2
;             (map_vint == true)) {
7009f644: f89d 0043    	ldrb.w	r0, [sp, #0x43]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
7009f648: 07c0         	lsls	r0, r0, #0x1f
7009f64a: 2800         	cmp	r0, #0x0
7009f64c: d047         	beq	0x7009f6de <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0x8e
7009f64e: e7ff         	b	0x7009f650 <Sciclient_rmIrqProgramRoute+0x70> @ imm = #-0x2
7009f650: 203c         	movs	r0, #0x3c
7009f652: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
7009f656: 9006         	str	r0, [sp, #0x18]
;             req.secondary_host = cfg->host;
7009f658: 9811         	ldr	r0, [sp, #0x44]
7009f65a: 7900         	ldrb	r0, [r0, #0x4]
7009f65c: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             req.src_id = cfg->s_id;
7009f660: 9811         	ldr	r0, [sp, #0x44]
7009f662: 88c0         	ldrh	r0, [r0, #0x6]
7009f664: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.src_index = cfg->s_idx;
7009f668: 9811         	ldr	r0, [sp, #0x44]
7009f66a: 8900         	ldrh	r0, [r0, #0x8]
7009f66c: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             req.ia_id = cfg->s_ia;
7009f670: 9811         	ldr	r0, [sp, #0x44]
7009f672: 8a00         	ldrh	r0, [r0, #0x10]
7009f674: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             req.vint = cur_outp;
7009f678: 980b         	ldr	r0, [sp, #0x2c]
7009f67a: f8ad 0026    	strh.w	r0, [sp, #0x26]
;             req.global_event = cur_inp;
7009f67e: 980c         	ldr	r0, [sp, #0x30]
7009f680: f8ad 0028    	strh.w	r0, [sp, #0x28]
;             req.vint_status_bit_index = cfg->vint_sb;
7009f684: 9811         	ldr	r0, [sp, #0x44]
7009f686: 7d00         	ldrb	r0, [r0, #0x14]
7009f688: f88d 002a    	strb.w	r0, [sp, #0x2a]
;                                       cfg->set_resp,
7009f68c: 9811         	ldr	r0, [sp, #0x44]
7009f68e: 6981         	ldr	r1, [r0, #0x18]
7009f690: a804         	add	r0, sp, #0x10
7009f692: f04f 32ff    	mov.w	r2, #0xffffffff
;             r = Sciclient_rmIrqSetRaw(&req,
7009f696: f00b fae3    	bl	0x700aac60 <Sciclient_rmIrqSetRaw> @ imm = #0xb5c6
7009f69a: 900f         	str	r0, [sp, #0x3c]
;             if (r == SystemP_SUCCESS) {
7009f69c: 980f         	ldr	r0, [sp, #0x3c]
7009f69e: b9e8         	cbnz	r0, 0x7009f6dc <Sciclient_rmIrqProgramRoute+0xfc> @ imm = #0x3a
7009f6a0: e7ff         	b	0x7009f6a2 <Sciclient_rmIrqProgramRoute+0xc2> @ imm = #-0x2
;                 ia_inst = Sciclient_rmIaGetInst(cur_n->id);
7009f6a2: 980d         	ldr	r0, [sp, #0x34]
7009f6a4: 8800         	ldrh	r0, [r0]
7009f6a6: f00b f95b    	bl	0x700aa960 <Sciclient_rmIaGetInst> @ imm = #0xb2b6
7009f6aa: 9003         	str	r0, [sp, #0xc]
;                 if (ia_inst != NULL) {
7009f6ac: 9803         	ldr	r0, [sp, #0xc]
7009f6ae: b1a0         	cbz	r0, 0x7009f6da <Sciclient_rmIrqProgramRoute+0xfa> @ imm = #0x28
7009f6b0: e7ff         	b	0x7009f6b2 <Sciclient_rmIrqProgramRoute+0xd2> @ imm = #-0x2
;                     ia_inst->vint_usage_count[cur_outp]++;
7009f6b2: 9803         	ldr	r0, [sp, #0xc]
7009f6b4: 6901         	ldr	r1, [r0, #0x10]
7009f6b6: 9a0b         	ldr	r2, [sp, #0x2c]
7009f6b8: 5c88         	ldrb	r0, [r1, r2]
7009f6ba: 3001         	adds	r0, #0x1
7009f6bc: 5488         	strb	r0, [r1, r2]
;                     if ((cur_outp == 0) && (cfg->vint_sb == 0)) {
7009f6be: 980b         	ldr	r0, [sp, #0x2c]
7009f6c0: b950         	cbnz	r0, 0x7009f6d8 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #0x14
7009f6c2: e7ff         	b	0x7009f6c4 <Sciclient_rmIrqProgramRoute+0xe4> @ imm = #-0x2
7009f6c4: 9811         	ldr	r0, [sp, #0x44]
7009f6c6: 7d00         	ldrb	r0, [r0, #0x14]
7009f6c8: b930         	cbnz	r0, 0x7009f6d8 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #0xc
7009f6ca: e7ff         	b	0x7009f6cc <Sciclient_rmIrqProgramRoute+0xec> @ imm = #-0x2
;                         ia_inst->v0_b0_evt = cur_inp - ia_inst->sevt_offset;
7009f6cc: 980c         	ldr	r0, [sp, #0x30]
7009f6ce: 9903         	ldr	r1, [sp, #0xc]
7009f6d0: 890a         	ldrh	r2, [r1, #0x8]
7009f6d2: 1a80         	subs	r0, r0, r2
7009f6d4: 8288         	strh	r0, [r1, #0x14]
;                     }
7009f6d6: e7ff         	b	0x7009f6d8 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #-0x2
;                 }
7009f6d8: e7ff         	b	0x7009f6da <Sciclient_rmIrqProgramRoute+0xfa> @ imm = #-0x2
;             }
7009f6da: e7ff         	b	0x7009f6dc <Sciclient_rmIrqProgramRoute+0xfc> @ imm = #-0x2
;         }
7009f6dc: e7ff         	b	0x7009f6de <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #-0x2
;         if (i > 0u) {
7009f6de: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f6e2: b390         	cbz	r0, 0x7009f74a <Sciclient_rmIrqProgramRoute+0x16a> @ imm = #0x64
7009f6e4: e7ff         	b	0x7009f6e6 <Sciclient_rmIrqProgramRoute+0x106> @ imm = #-0x2
7009f6e6: 2003         	movs	r0, #0x3
7009f6e8: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_DST_ID_VALID |
7009f6ec: 9006         	str	r0, [sp, #0x18]
;             req.secondary_host = cfg->host;
7009f6ee: 9811         	ldr	r0, [sp, #0x44]
7009f6f0: 7900         	ldrb	r0, [r0, #0x4]
7009f6f2: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             req.src_id = cur_n->id;
7009f6f6: 980d         	ldr	r0, [sp, #0x34]
7009f6f8: 8800         	ldrh	r0, [r0]
7009f6fa: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.src_index = cur_inp;
7009f6fe: 980c         	ldr	r0, [sp, #0x30]
7009f700: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             req.dst_id = cur_n->id;
7009f704: 980d         	ldr	r0, [sp, #0x34]
7009f706: 8800         	ldrh	r0, [r0]
7009f708: f8ad 0020    	strh.w	r0, [sp, #0x20]
;             req.dst_host_irq = cur_outp;
7009f70c: 980b         	ldr	r0, [sp, #0x2c]
7009f70e: f8ad 0022    	strh.w	r0, [sp, #0x22]
;                                       cfg->set_resp,
7009f712: 9811         	ldr	r0, [sp, #0x44]
7009f714: 6981         	ldr	r1, [r0, #0x18]
7009f716: a804         	add	r0, sp, #0x10
7009f718: f04f 32ff    	mov.w	r2, #0xffffffff
;             r = Sciclient_rmIrqSetRaw(&req,
7009f71c: f00b faa0    	bl	0x700aac60 <Sciclient_rmIrqSetRaw> @ imm = #0xb540
7009f720: 900f         	str	r0, [sp, #0x3c]
;             if ((r == SystemP_SUCCESS) && (cur_outp == 0)) {
7009f722: 980f         	ldr	r0, [sp, #0x3c]
7009f724: b980         	cbnz	r0, 0x7009f748 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #0x20
7009f726: e7ff         	b	0x7009f728 <Sciclient_rmIrqProgramRoute+0x148> @ imm = #-0x2
7009f728: 980b         	ldr	r0, [sp, #0x2c]
7009f72a: b968         	cbnz	r0, 0x7009f748 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #0x1a
7009f72c: e7ff         	b	0x7009f72e <Sciclient_rmIrqProgramRoute+0x14e> @ imm = #-0x2
;                 ir_inst = Sciclient_rmIrGetInst(cur_n->id);
7009f72e: 980d         	ldr	r0, [sp, #0x34]
7009f730: 8800         	ldrh	r0, [r0]
7009f732: f00a fbf5    	bl	0x700a9f20 <Sciclient_rmIrGetInst> @ imm = #0xa7ea
7009f736: 9002         	str	r0, [sp, #0x8]
;                 if (ir_inst != NULL) {
7009f738: 9802         	ldr	r0, [sp, #0x8]
7009f73a: b120         	cbz	r0, 0x7009f746 <Sciclient_rmIrqProgramRoute+0x166> @ imm = #0x8
7009f73c: e7ff         	b	0x7009f73e <Sciclient_rmIrqProgramRoute+0x15e> @ imm = #-0x2
;                     ir_inst->inp0_mapping = cur_outp;
7009f73e: 980b         	ldr	r0, [sp, #0x2c]
7009f740: 9902         	ldr	r1, [sp, #0x8]
7009f742: 8188         	strh	r0, [r1, #0xc]
;                 }
7009f744: e7ff         	b	0x7009f746 <Sciclient_rmIrqProgramRoute+0x166> @ imm = #-0x2
;             }
7009f746: e7ff         	b	0x7009f748 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #-0x2
;         }
7009f748: e7ff         	b	0x7009f74a <Sciclient_rmIrqProgramRoute+0x16a> @ imm = #-0x2
;         if (r != SystemP_SUCCESS) {
7009f74a: 980f         	ldr	r0, [sp, #0x3c]
7009f74c: b108         	cbz	r0, 0x7009f752 <Sciclient_rmIrqProgramRoute+0x172> @ imm = #0x2
7009f74e: e7ff         	b	0x7009f750 <Sciclient_rmIrqProgramRoute+0x170> @ imm = #-0x2
;             break;
7009f750: e006         	b	0x7009f760 <Sciclient_rmIrqProgramRoute+0x180> @ imm = #0xc
;     }
7009f752: e7ff         	b	0x7009f754 <Sciclient_rmIrqProgramRoute+0x174> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
7009f754: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f758: 3001         	adds	r0, #0x1
7009f75a: f8ad 003a    	strh.w	r0, [sp, #0x3a]
7009f75e: e74b         	b	0x7009f5f8 <Sciclient_rmIrqProgramRoute+0x18> @ imm = #-0x16a
;     return r;
7009f760: 980f         	ldr	r0, [sp, #0x3c]
7009f762: b012         	add	sp, #0x48
7009f764: bd80         	pop	{r7, pc}
		...
7009f76e: 0000         	movs	r0, r0

7009f770 <Udma_chEnableLocal>:
; {
7009f770: b580         	push	{r7, lr}
7009f772: b08e         	sub	sp, #0x38
7009f774: 900d         	str	r0, [sp, #0x34]
;     drvHandle = chHandle->drvHandle;
7009f776: 980d         	ldr	r0, [sp, #0x34]
7009f778: 6e80         	ldr	r0, [r0, #0x68]
7009f77a: 900b         	str	r0, [sp, #0x2c]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f77c: 980b         	ldr	r0, [sp, #0x2c]
7009f77e: 6800         	ldr	r0, [r0]
7009f780: 2801         	cmp	r0, #0x1
7009f782: d163         	bne	0x7009f84c <Udma_chEnableLocal+0xdc> @ imm = #0xc6
7009f784: e7ff         	b	0x7009f786 <Udma_chEnableLocal+0x16> @ imm = #-0x2
7009f786: 2001         	movs	r0, #0x1
;         bcdmaRtEnable.enable         = TRUE;
7009f788: 9005         	str	r0, [sp, #0x14]
7009f78a: 2000         	movs	r0, #0x0
;         bcdmaRtEnable.teardown       = FALSE;
7009f78c: 9006         	str	r0, [sp, #0x18]
;         bcdmaRtEnable.forcedTeardown = FALSE;
7009f78e: 9009         	str	r0, [sp, #0x24]
;         bcdmaRtEnable.pause          = FALSE;
7009f790: 9007         	str	r0, [sp, #0x1c]
;         bcdmaRtEnable.error          = FALSE;
7009f792: 9008         	str	r0, [sp, #0x20]
;         if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009f794: 980d         	ldr	r0, [sp, #0x34]
7009f796: 7800         	ldrb	r0, [r0]
7009f798: 0740         	lsls	r0, r0, #0x1d
7009f79a: 2800         	cmp	r0, #0x0
7009f79c: d508         	bpl	0x7009f7b0 <Udma_chEnableLocal+0x40> @ imm = #0x10
7009f79e: e7ff         	b	0x7009f7a0 <Udma_chEnableLocal+0x30> @ imm = #-0x2
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum , &bcdmaRtEnable);
7009f7a0: 980b         	ldr	r0, [sp, #0x2c]
7009f7a2: 3008         	adds	r0, #0x8
7009f7a4: 990d         	ldr	r1, [sp, #0x34]
7009f7a6: 6ec9         	ldr	r1, [r1, #0x6c]
7009f7a8: aa05         	add	r2, sp, #0x14
7009f7aa: f00d fbe9    	bl	0x700acf80 <CSL_bcdmaSetTxRT> @ imm = #0xd7d2
;         }
7009f7ae: e04c         	b	0x7009f84a <Udma_chEnableLocal+0xda> @ imm = #0x98
;         else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009f7b0: 980d         	ldr	r0, [sp, #0x34]
7009f7b2: 7800         	ldrb	r0, [r0]
7009f7b4: 07c0         	lsls	r0, r0, #0x1f
7009f7b6: b300         	cbz	r0, 0x7009f7fa <Udma_chEnableLocal+0x8a> @ imm = #0x40
7009f7b8: e7ff         	b	0x7009f7ba <Udma_chEnableLocal+0x4a> @ imm = #-0x2
;             regVal = CSL_REG32_RD(&chHandle->pBcdmaTxRtRegs->PEER8);
7009f7ba: 980d         	ldr	r0, [sp, #0x34]
7009f7bc: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f7c0: f500 7008    	add.w	r0, r0, #0x220
7009f7c4: f00e fc7c    	bl	0x700ae0c0 <CSL_REG32_RD_RAW> @ imm = #0xe8f8
7009f7c8: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
7009f7ca: 980c         	ldr	r0, [sp, #0x30]
7009f7cc: f040 4000    	orr	r0, r0, #0x80000000
7009f7d0: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pBcdmaTxRtRegs->PEER8, regVal);
7009f7d2: 980d         	ldr	r0, [sp, #0x34]
7009f7d4: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f7d8: f500 7008    	add.w	r0, r0, #0x220
7009f7dc: 990c         	ldr	r1, [sp, #0x30]
7009f7de: f00e fbcf    	bl	0x700adf80 <CSL_REG32_WR_RAW> @ imm = #0xe79e
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtEnable);
7009f7e2: 9a0b         	ldr	r2, [sp, #0x2c]
7009f7e4: f102 0008    	add.w	r0, r2, #0x8
7009f7e8: 990d         	ldr	r1, [sp, #0x34]
7009f7ea: 6ec9         	ldr	r1, [r1, #0x6c]
7009f7ec: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009f7f0: 4411         	add	r1, r2
7009f7f2: aa05         	add	r2, sp, #0x14
7009f7f4: f00d fbc4    	bl	0x700acf80 <CSL_bcdmaSetTxRT> @ imm = #0xd788
;         }
7009f7f8: e026         	b	0x7009f848 <Udma_chEnableLocal+0xd8> @ imm = #0x4c
;         else if ((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009f7fa: 980d         	ldr	r0, [sp, #0x34]
7009f7fc: 7800         	ldrb	r0, [r0]
7009f7fe: 0780         	lsls	r0, r0, #0x1e
7009f800: 2800         	cmp	r0, #0x0
7009f802: d520         	bpl	0x7009f846 <Udma_chEnableLocal+0xd6> @ imm = #0x40
7009f804: e7ff         	b	0x7009f806 <Udma_chEnableLocal+0x96> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtEnable);
7009f806: 9a0b         	ldr	r2, [sp, #0x2c]
7009f808: f102 0008    	add.w	r0, r2, #0x8
7009f80c: 990d         	ldr	r1, [sp, #0x34]
7009f80e: 6f09         	ldr	r1, [r1, #0x70]
7009f810: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009f814: 4411         	add	r1, r2
7009f816: aa05         	add	r2, sp, #0x14
;             (void) CSL_bcdmaSetRxRT(
7009f818: f00d fb9a    	bl	0x700acf50 <CSL_bcdmaSetRxRT> @ imm = #0xd734
;             regVal = CSL_REG32_RD(&chHandle->pBcdmaRxRtRegs->PEER8);
7009f81c: 980d         	ldr	r0, [sp, #0x34]
7009f81e: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f822: f500 7008    	add.w	r0, r0, #0x220
7009f826: f00e fc4b    	bl	0x700ae0c0 <CSL_REG32_RD_RAW> @ imm = #0xe896
7009f82a: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
7009f82c: 980c         	ldr	r0, [sp, #0x30]
7009f82e: f040 4000    	orr	r0, r0, #0x80000000
7009f832: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pBcdmaRxRtRegs->PEER8, regVal);
7009f834: 980d         	ldr	r0, [sp, #0x34]
7009f836: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f83a: f500 7008    	add.w	r0, r0, #0x220
7009f83e: 990c         	ldr	r1, [sp, #0x30]
7009f840: f00e fb9e    	bl	0x700adf80 <CSL_REG32_WR_RAW> @ imm = #0xe73c
;         }
7009f844: e7ff         	b	0x7009f846 <Udma_chEnableLocal+0xd6> @ imm = #-0x2
7009f846: e7ff         	b	0x7009f848 <Udma_chEnableLocal+0xd8> @ imm = #-0x2
7009f848: e7ff         	b	0x7009f84a <Udma_chEnableLocal+0xda> @ imm = #-0x2
;     }
7009f84a: e050         	b	0x7009f8ee <Udma_chEnableLocal+0x17e> @ imm = #0xa0
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f84c: 980b         	ldr	r0, [sp, #0x2c]
7009f84e: 6800         	ldr	r0, [r0]
7009f850: 2802         	cmp	r0, #0x2
7009f852: d14b         	bne	0x7009f8ec <Udma_chEnableLocal+0x17c> @ imm = #0x96
7009f854: e7ff         	b	0x7009f856 <Udma_chEnableLocal+0xe6> @ imm = #-0x2
7009f856: 2001         	movs	r0, #0x1
;         pktdmaRtEnable.enable         = TRUE;
7009f858: 9000         	str	r0, [sp]
7009f85a: 2000         	movs	r0, #0x0
;         pktdmaRtEnable.teardown       = FALSE;
7009f85c: 9001         	str	r0, [sp, #0x4]
;         pktdmaRtEnable.forcedTeardown = FALSE;
7009f85e: 9004         	str	r0, [sp, #0x10]
;         pktdmaRtEnable.pause          = FALSE;
7009f860: 9002         	str	r0, [sp, #0x8]
;         pktdmaRtEnable.error          = FALSE;
7009f862: 9003         	str	r0, [sp, #0xc]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009f864: 980d         	ldr	r0, [sp, #0x34]
7009f866: 7800         	ldrb	r0, [r0]
7009f868: 07c0         	lsls	r0, r0, #0x1f
7009f86a: b1e0         	cbz	r0, 0x7009f8a6 <Udma_chEnableLocal+0x136> @ imm = #0x38
7009f86c: e7ff         	b	0x7009f86e <Udma_chEnableLocal+0xfe> @ imm = #-0x2
;             regVal = CSL_REG32_RD(&chHandle->pPktdmaTxRtRegs->PEER8);
7009f86e: 980d         	ldr	r0, [sp, #0x34]
7009f870: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009f874: f500 7008    	add.w	r0, r0, #0x220
7009f878: f00e fc22    	bl	0x700ae0c0 <CSL_REG32_RD_RAW> @ imm = #0xe844
7009f87c: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
7009f87e: 980c         	ldr	r0, [sp, #0x30]
7009f880: f040 4000    	orr	r0, r0, #0x80000000
7009f884: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pPktdmaTxRtRegs->PEER8, regVal);
7009f886: 980d         	ldr	r0, [sp, #0x34]
7009f888: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009f88c: f500 7008    	add.w	r0, r0, #0x220
7009f890: 990c         	ldr	r1, [sp, #0x30]
7009f892: f00e fb75    	bl	0x700adf80 <CSL_REG32_WR_RAW> @ imm = #0xe6ea
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtEnable);
7009f896: 980b         	ldr	r0, [sp, #0x2c]
7009f898: 3054         	adds	r0, #0x54
7009f89a: 990d         	ldr	r1, [sp, #0x34]
7009f89c: 6ec9         	ldr	r1, [r1, #0x6c]
7009f89e: 466a         	mov	r2, sp
7009f8a0: f00c fd9e    	bl	0x700ac3e0 <CSL_pktdmaSetTxRT> @ imm = #0xcb3c
;         }
7009f8a4: e7ff         	b	0x7009f8a6 <Udma_chEnableLocal+0x136> @ imm = #-0x2
;         if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009f8a6: 980d         	ldr	r0, [sp, #0x34]
7009f8a8: 7800         	ldrb	r0, [r0]
7009f8aa: 0780         	lsls	r0, r0, #0x1e
7009f8ac: 2800         	cmp	r0, #0x0
7009f8ae: d51c         	bpl	0x7009f8ea <Udma_chEnableLocal+0x17a> @ imm = #0x38
7009f8b0: e7ff         	b	0x7009f8b2 <Udma_chEnableLocal+0x142> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtEnable);
7009f8b2: 980b         	ldr	r0, [sp, #0x2c]
7009f8b4: 3054         	adds	r0, #0x54
7009f8b6: 990d         	ldr	r1, [sp, #0x34]
7009f8b8: 6f09         	ldr	r1, [r1, #0x70]
7009f8ba: 466a         	mov	r2, sp
;             (void) CSL_pktdmaSetRxRT(
7009f8bc: f00c fd70    	bl	0x700ac3a0 <CSL_pktdmaSetRxRT> @ imm = #0xcae0
;             regVal = CSL_REG32_RD(&chHandle->pPktdmaRxRtRegs->PEER8);
7009f8c0: 980d         	ldr	r0, [sp, #0x34]
7009f8c2: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009f8c6: f500 7008    	add.w	r0, r0, #0x220
7009f8ca: f00e fbf9    	bl	0x700ae0c0 <CSL_REG32_RD_RAW> @ imm = #0xe7f2
7009f8ce: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
7009f8d0: 980c         	ldr	r0, [sp, #0x30]
7009f8d2: f040 4000    	orr	r0, r0, #0x80000000
7009f8d6: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pPktdmaRxRtRegs->PEER8, regVal);
7009f8d8: 980d         	ldr	r0, [sp, #0x34]
7009f8da: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009f8de: f500 7008    	add.w	r0, r0, #0x220
7009f8e2: 990c         	ldr	r1, [sp, #0x30]
7009f8e4: f00e fb4c    	bl	0x700adf80 <CSL_REG32_WR_RAW> @ imm = #0xe698
;         }
7009f8e8: e7ff         	b	0x7009f8ea <Udma_chEnableLocal+0x17a> @ imm = #-0x2
;     }
7009f8ea: e7ff         	b	0x7009f8ec <Udma_chEnableLocal+0x17c> @ imm = #-0x2
7009f8ec: e7ff         	b	0x7009f8ee <Udma_chEnableLocal+0x17e> @ imm = #-0x2
;     return;
7009f8ee: b00e         	add	sp, #0x38
7009f8f0: bd80         	pop	{r7, pc}
		...
7009f8fe: 0000         	movs	r0, r0

7009f900 <Udma_chConfigPdma>:
; {
7009f900: b580         	push	{r7, lr}
7009f902: b08a         	sub	sp, #0x28
7009f904: 9009         	str	r0, [sp, #0x24]
7009f906: 9108         	str	r1, [sp, #0x20]
7009f908: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f90a: 9007         	str	r0, [sp, #0x1c]
;     volatile uint32_t  *PEER8=NULL, *PEER0=NULL, *PEER1=NULL;
7009f90c: 9006         	str	r0, [sp, #0x18]
7009f90e: 9005         	str	r0, [sp, #0x14]
7009f910: 9004         	str	r0, [sp, #0x10]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
7009f912: 9809         	ldr	r0, [sp, #0x24]
7009f914: 9002         	str	r0, [sp, #0x8]
;     if((NULL_PTR == chHandleInt) ||
7009f916: 9802         	ldr	r0, [sp, #0x8]
7009f918: b1a0         	cbz	r0, 0x7009f944 <Udma_chConfigPdma+0x44> @ imm = #0x28
7009f91a: e7ff         	b	0x7009f91c <Udma_chConfigPdma+0x1c> @ imm = #-0x2
;        (NULL_PTR == pdmaPrms) ||
7009f91c: 9808         	ldr	r0, [sp, #0x20]
7009f91e: b188         	cbz	r0, 0x7009f944 <Udma_chConfigPdma+0x44> @ imm = #0x22
7009f920: e7ff         	b	0x7009f922 <Udma_chConfigPdma+0x22> @ imm = #-0x2
;        (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
7009f922: 9802         	ldr	r0, [sp, #0x8]
7009f924: f8d0 0244    	ldr.w	r0, [r0, #0x244]
7009f928: f64a 31cd    	movw	r1, #0xabcd
7009f92c: f6ca 31dc    	movt	r1, #0xabdc
7009f930: 4288         	cmp	r0, r1
7009f932: d107         	bne	0x7009f944 <Udma_chConfigPdma+0x44> @ imm = #0xe
7009f934: e7ff         	b	0x7009f936 <Udma_chConfigPdma+0x36> @ imm = #-0x2
;        ((chHandleInt->chType & UDMA_CH_FLAG_PDMA) != UDMA_CH_FLAG_PDMA))
7009f936: 9802         	ldr	r0, [sp, #0x8]
7009f938: 6800         	ldr	r0, [r0]
7009f93a: f000 0008    	and	r0, r0, #0x8
;     if((NULL_PTR == chHandleInt) ||
7009f93e: 2808         	cmp	r0, #0x8
7009f940: d004         	beq	0x7009f94c <Udma_chConfigPdma+0x4c> @ imm = #0x8
7009f942: e7ff         	b	0x7009f944 <Udma_chConfigPdma+0x44> @ imm = #-0x2
7009f944: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009f948: 9007         	str	r0, [sp, #0x1c]
;     }
7009f94a: e7ff         	b	0x7009f94c <Udma_chConfigPdma+0x4c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f94c: 9807         	ldr	r0, [sp, #0x1c]
7009f94e: b9a8         	cbnz	r0, 0x7009f97c <Udma_chConfigPdma+0x7c> @ imm = #0x2a
7009f950: e7ff         	b	0x7009f952 <Udma_chConfigPdma+0x52> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
7009f952: 9802         	ldr	r0, [sp, #0x8]
7009f954: 6e80         	ldr	r0, [r0, #0x68]
7009f956: 9003         	str	r0, [sp, #0xc]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009f958: 9803         	ldr	r0, [sp, #0xc]
7009f95a: b150         	cbz	r0, 0x7009f972 <Udma_chConfigPdma+0x72> @ imm = #0x14
7009f95c: e7ff         	b	0x7009f95e <Udma_chConfigPdma+0x5e> @ imm = #-0x2
7009f95e: 9803         	ldr	r0, [sp, #0xc]
7009f960: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009f964: f64a 31cd    	movw	r1, #0xabcd
7009f968: f6ca 31dc    	movt	r1, #0xabdc
7009f96c: 4288         	cmp	r0, r1
7009f96e: d004         	beq	0x7009f97a <Udma_chConfigPdma+0x7a> @ imm = #0x8
7009f970: e7ff         	b	0x7009f972 <Udma_chConfigPdma+0x72> @ imm = #-0x2
7009f972: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009f976: 9007         	str	r0, [sp, #0x1c]
;         }
7009f978: e7ff         	b	0x7009f97a <Udma_chConfigPdma+0x7a> @ imm = #-0x2
;     }
7009f97a: e7ff         	b	0x7009f97c <Udma_chConfigPdma+0x7c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f97c: 9807         	ldr	r0, [sp, #0x1c]
7009f97e: 2800         	cmp	r0, #0x0
7009f980: d17a         	bne	0x7009fa78 <Udma_chConfigPdma+0x178> @ imm = #0xf4
7009f982: e7ff         	b	0x7009f984 <Udma_chConfigPdma+0x84> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f984: 9803         	ldr	r0, [sp, #0xc]
7009f986: 6800         	ldr	r0, [r0]
7009f988: 2801         	cmp	r0, #0x1
7009f98a: d137         	bne	0x7009f9fc <Udma_chConfigPdma+0xfc> @ imm = #0x6e
7009f98c: e7ff         	b	0x7009f98e <Udma_chConfigPdma+0x8e> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009f98e: 9802         	ldr	r0, [sp, #0x8]
7009f990: 7800         	ldrb	r0, [r0]
7009f992: 07c0         	lsls	r0, r0, #0x1f
7009f994: b198         	cbz	r0, 0x7009f9be <Udma_chConfigPdma+0xbe> @ imm = #0x26
7009f996: e7ff         	b	0x7009f998 <Udma_chConfigPdma+0x98> @ imm = #-0x2
;                 PEER8 = &chHandleInt->pBcdmaTxRtRegs->PEER8;
7009f998: 9802         	ldr	r0, [sp, #0x8]
7009f99a: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f99e: f500 7008    	add.w	r0, r0, #0x220
7009f9a2: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pBcdmaTxRtRegs->PEER1;
7009f9a4: 9802         	ldr	r0, [sp, #0x8]
7009f9a6: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f9aa: f500 7001    	add.w	r0, r0, #0x204
7009f9ae: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pBcdmaTxRtRegs->PEER0;
7009f9b0: 9802         	ldr	r0, [sp, #0x8]
7009f9b2: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f9b6: f500 7000    	add.w	r0, r0, #0x200
7009f9ba: 9005         	str	r0, [sp, #0x14]
;             }
7009f9bc: e012         	b	0x7009f9e4 <Udma_chConfigPdma+0xe4> @ imm = #0x24
;                 PEER8 = &chHandleInt->pBcdmaRxRtRegs->PEER8;
7009f9be: 9802         	ldr	r0, [sp, #0x8]
7009f9c0: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f9c4: f500 7008    	add.w	r0, r0, #0x220
7009f9c8: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pBcdmaRxRtRegs->PEER1;
7009f9ca: 9802         	ldr	r0, [sp, #0x8]
7009f9cc: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f9d0: f500 7001    	add.w	r0, r0, #0x204
7009f9d4: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pBcdmaRxRtRegs->PEER0;
7009f9d6: 9802         	ldr	r0, [sp, #0x8]
7009f9d8: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f9dc: f500 7000    	add.w	r0, r0, #0x200
7009f9e0: 9005         	str	r0, [sp, #0x14]
7009f9e2: e7ff         	b	0x7009f9e4 <Udma_chConfigPdma+0xe4> @ imm = #-0x2
;             Udma_chSetPeerReg(drvHandle, pdmaPrms, PEER8, PEER1, PEER0);
7009f9e4: 9803         	ldr	r0, [sp, #0xc]
7009f9e6: 9908         	ldr	r1, [sp, #0x20]
7009f9e8: 9a06         	ldr	r2, [sp, #0x18]
7009f9ea: 9b04         	ldr	r3, [sp, #0x10]
7009f9ec: f8dd c014    	ldr.w	r12, [sp, #0x14]
7009f9f0: 46ee         	mov	lr, sp
7009f9f2: f8ce c000    	str.w	r12, [lr]
7009f9f6: f00b fb6b    	bl	0x700ab0d0 <Udma_chSetPeerReg> @ imm = #0xb6d6
;         }
7009f9fa: e03c         	b	0x7009fa76 <Udma_chConfigPdma+0x176> @ imm = #0x78
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f9fc: 9803         	ldr	r0, [sp, #0xc]
7009f9fe: 6800         	ldr	r0, [r0]
7009fa00: 2802         	cmp	r0, #0x2
7009fa02: d137         	bne	0x7009fa74 <Udma_chConfigPdma+0x174> @ imm = #0x6e
7009fa04: e7ff         	b	0x7009fa06 <Udma_chConfigPdma+0x106> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009fa06: 9802         	ldr	r0, [sp, #0x8]
7009fa08: 7800         	ldrb	r0, [r0]
7009fa0a: 07c0         	lsls	r0, r0, #0x1f
7009fa0c: b198         	cbz	r0, 0x7009fa36 <Udma_chConfigPdma+0x136> @ imm = #0x26
7009fa0e: e7ff         	b	0x7009fa10 <Udma_chConfigPdma+0x110> @ imm = #-0x2
;                 PEER8 = &chHandleInt->pPktdmaTxRtRegs->PEER8;
7009fa10: 9802         	ldr	r0, [sp, #0x8]
7009fa12: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009fa16: f500 7008    	add.w	r0, r0, #0x220
7009fa1a: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pPktdmaTxRtRegs->PEER1;
7009fa1c: 9802         	ldr	r0, [sp, #0x8]
7009fa1e: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009fa22: f500 7001    	add.w	r0, r0, #0x204
7009fa26: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pPktdmaTxRtRegs->PEER0;
7009fa28: 9802         	ldr	r0, [sp, #0x8]
7009fa2a: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009fa2e: f500 7000    	add.w	r0, r0, #0x200
7009fa32: 9005         	str	r0, [sp, #0x14]
;             }
7009fa34: e012         	b	0x7009fa5c <Udma_chConfigPdma+0x15c> @ imm = #0x24
;                 PEER8 = &chHandleInt->pPktdmaRxRtRegs->PEER8;
7009fa36: 9802         	ldr	r0, [sp, #0x8]
7009fa38: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009fa3c: f500 7008    	add.w	r0, r0, #0x220
7009fa40: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pPktdmaRxRtRegs->PEER1;
7009fa42: 9802         	ldr	r0, [sp, #0x8]
7009fa44: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009fa48: f500 7001    	add.w	r0, r0, #0x204
7009fa4c: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pPktdmaRxRtRegs->PEER0;
7009fa4e: 9802         	ldr	r0, [sp, #0x8]
7009fa50: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009fa54: f500 7000    	add.w	r0, r0, #0x200
7009fa58: 9005         	str	r0, [sp, #0x14]
7009fa5a: e7ff         	b	0x7009fa5c <Udma_chConfigPdma+0x15c> @ imm = #-0x2
;             Udma_chSetPeerReg(drvHandle, pdmaPrms, PEER8, PEER1, PEER0);
7009fa5c: 9803         	ldr	r0, [sp, #0xc]
7009fa5e: 9908         	ldr	r1, [sp, #0x20]
7009fa60: 9a06         	ldr	r2, [sp, #0x18]
7009fa62: 9b04         	ldr	r3, [sp, #0x10]
7009fa64: f8dd c014    	ldr.w	r12, [sp, #0x14]
7009fa68: 46ee         	mov	lr, sp
7009fa6a: f8ce c000    	str.w	r12, [lr]
7009fa6e: f00b fb2f    	bl	0x700ab0d0 <Udma_chSetPeerReg> @ imm = #0xb65e
;         }
7009fa72: e7ff         	b	0x7009fa74 <Udma_chConfigPdma+0x174> @ imm = #-0x2
7009fa74: e7ff         	b	0x7009fa76 <Udma_chConfigPdma+0x176> @ imm = #-0x2
;     }
7009fa76: e7ff         	b	0x7009fa78 <Udma_chConfigPdma+0x178> @ imm = #-0x2
;     return (retVal);
7009fa78: 9807         	ldr	r0, [sp, #0x1c]
7009fa7a: b00a         	add	sp, #0x28
7009fa7c: bd80         	pop	{r7, pc}
7009fa7e: 0000         	movs	r0, r0

7009fa80 <xQueueSemaphoreTake>:
; {
7009fa80: b580         	push	{r7, lr}
7009fa82: b08a         	sub	sp, #0x28
7009fa84: 9008         	str	r0, [sp, #0x20]
7009fa86: 9107         	str	r1, [sp, #0x1c]
7009fa88: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
7009fa8a: 9006         	str	r0, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
7009fa8c: 9908         	ldr	r1, [sp, #0x20]
7009fa8e: 9103         	str	r1, [sp, #0xc]
;         BaseType_t xInheritanceOccurred = pdFALSE;
7009fa90: 9002         	str	r0, [sp, #0x8]
;     for( ; ; )
7009fa92: e7ff         	b	0x7009fa94 <xQueueSemaphoreTake+0x14> @ imm = #-0x2
;         taskENTER_CRITICAL();
7009fa94: f00d f89c    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0xd138
;             const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
7009fa98: 9803         	ldr	r0, [sp, #0xc]
7009fa9a: 6b80         	ldr	r0, [r0, #0x38]
7009fa9c: 9001         	str	r0, [sp, #0x4]
;             if( uxSemaphoreCount > ( UBaseType_t ) 0 )
7009fa9e: 9801         	ldr	r0, [sp, #0x4]
7009faa0: b310         	cbz	r0, 0x7009fae8 <xQueueSemaphoreTake+0x68> @ imm = #0x44
7009faa2: e7ff         	b	0x7009faa4 <xQueueSemaphoreTake+0x24> @ imm = #-0x2
;                 pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
7009faa4: 9801         	ldr	r0, [sp, #0x4]
7009faa6: 3801         	subs	r0, #0x1
7009faa8: 9903         	ldr	r1, [sp, #0xc]
7009faaa: 6388         	str	r0, [r1, #0x38]
;                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
7009faac: 9803         	ldr	r0, [sp, #0xc]
7009faae: 6800         	ldr	r0, [r0]
7009fab0: b928         	cbnz	r0, 0x7009fabe <xQueueSemaphoreTake+0x3e> @ imm = #0xa
7009fab2: e7ff         	b	0x7009fab4 <xQueueSemaphoreTake+0x34> @ imm = #-0x2
;                             pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
7009fab4: f00d faf4    	bl	0x700ad0a0 <pvTaskIncrementMutexHeldCount> @ imm = #0xd5e8
7009fab8: 9903         	ldr	r1, [sp, #0xc]
7009faba: 6088         	str	r0, [r1, #0x8]
;                         }
7009fabc: e000         	b	0x7009fac0 <xQueueSemaphoreTake+0x40> @ imm = #0x0
7009fabe: e7ff         	b	0x7009fac0 <xQueueSemaphoreTake+0x40> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
7009fac0: 9803         	ldr	r0, [sp, #0xc]
7009fac2: 6900         	ldr	r0, [r0, #0x10]
7009fac4: b150         	cbz	r0, 0x7009fadc <xQueueSemaphoreTake+0x5c> @ imm = #0x14
7009fac6: e7ff         	b	0x7009fac8 <xQueueSemaphoreTake+0x48> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
7009fac8: 9803         	ldr	r0, [sp, #0xc]
7009faca: 3010         	adds	r0, #0x10
7009facc: f006 fa10    	bl	0x700a5ef0 <xTaskRemoveFromEventList> @ imm = #0x6420
7009fad0: b110         	cbz	r0, 0x7009fad8 <xQueueSemaphoreTake+0x58> @ imm = #0x4
7009fad2: e7ff         	b	0x7009fad4 <xQueueSemaphoreTake+0x54> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
7009fad4: df00         	svc	#0x0
;                     }
7009fad6: e000         	b	0x7009fada <xQueueSemaphoreTake+0x5a> @ imm = #0x0
7009fad8: e7ff         	b	0x7009fada <xQueueSemaphoreTake+0x5a> @ imm = #-0x2
;                 }
7009fada: e000         	b	0x7009fade <xQueueSemaphoreTake+0x5e> @ imm = #0x0
7009fadc: e7ff         	b	0x7009fade <xQueueSemaphoreTake+0x5e> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
7009fade: f00c f8f7    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0xc1ee
7009fae2: 2001         	movs	r0, #0x1
;                 return pdPASS;
7009fae4: 9009         	str	r0, [sp, #0x24]
7009fae6: e083         	b	0x7009fbf0 <xQueueSemaphoreTake+0x170> @ imm = #0x106
;                 if( xTicksToWait == ( TickType_t ) 0 )
7009fae8: 9807         	ldr	r0, [sp, #0x1c]
7009faea: b928         	cbnz	r0, 0x7009faf8 <xQueueSemaphoreTake+0x78> @ imm = #0xa
7009faec: e7ff         	b	0x7009faee <xQueueSemaphoreTake+0x6e> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
7009faee: f00c f8ef    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0xc1de
7009faf2: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
7009faf4: 9009         	str	r0, [sp, #0x24]
7009faf6: e07b         	b	0x7009fbf0 <xQueueSemaphoreTake+0x170> @ imm = #0xf6
;                 else if( xEntryTimeSet == pdFALSE )
7009faf8: 9806         	ldr	r0, [sp, #0x18]
7009fafa: b930         	cbnz	r0, 0x7009fb0a <xQueueSemaphoreTake+0x8a> @ imm = #0xc
7009fafc: e7ff         	b	0x7009fafe <xQueueSemaphoreTake+0x7e> @ imm = #-0x2
7009fafe: a804         	add	r0, sp, #0x10
;                     vTaskInternalSetTimeOutState( &xTimeOut );
7009fb00: f00d fdf6    	bl	0x700ad6f0 <vTaskInternalSetTimeOutState> @ imm = #0xdbec
7009fb04: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
7009fb06: 9006         	str	r0, [sp, #0x18]
;                 }
7009fb08: e000         	b	0x7009fb0c <xQueueSemaphoreTake+0x8c> @ imm = #0x0
7009fb0a: e7ff         	b	0x7009fb0c <xQueueSemaphoreTake+0x8c> @ imm = #-0x2
7009fb0c: e7ff         	b	0x7009fb0e <xQueueSemaphoreTake+0x8e> @ imm = #-0x2
7009fb0e: e7ff         	b	0x7009fb10 <xQueueSemaphoreTake+0x90> @ imm = #-0x2
;         taskEXIT_CRITICAL();
7009fb10: f00c f8de    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0xc1bc
;         vTaskSuspendAll();
7009fb14: f00e fa8c    	bl	0x700ae030 <vTaskSuspendAll> @ imm = #0xe518
;         prvLockQueue( pxQueue );
7009fb18: f00d f85a    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0xd0b4
7009fb1c: 9803         	ldr	r0, [sp, #0xc]
7009fb1e: f990 0044    	ldrsb.w	r0, [r0, #0x44]
7009fb22: 3001         	adds	r0, #0x1
7009fb24: b928         	cbnz	r0, 0x7009fb32 <xQueueSemaphoreTake+0xb2> @ imm = #0xa
7009fb26: e7ff         	b	0x7009fb28 <xQueueSemaphoreTake+0xa8> @ imm = #-0x2
7009fb28: 9903         	ldr	r1, [sp, #0xc]
7009fb2a: 2000         	movs	r0, #0x0
7009fb2c: f881 0044    	strb.w	r0, [r1, #0x44]
7009fb30: e7ff         	b	0x7009fb32 <xQueueSemaphoreTake+0xb2> @ imm = #-0x2
7009fb32: 9803         	ldr	r0, [sp, #0xc]
7009fb34: f990 0045    	ldrsb.w	r0, [r0, #0x45]
7009fb38: 3001         	adds	r0, #0x1
7009fb3a: b928         	cbnz	r0, 0x7009fb48 <xQueueSemaphoreTake+0xc8> @ imm = #0xa
7009fb3c: e7ff         	b	0x7009fb3e <xQueueSemaphoreTake+0xbe> @ imm = #-0x2
7009fb3e: 9903         	ldr	r1, [sp, #0xc]
7009fb40: 2000         	movs	r0, #0x0
7009fb42: f881 0045    	strb.w	r0, [r1, #0x45]
7009fb46: e7ff         	b	0x7009fb48 <xQueueSemaphoreTake+0xc8> @ imm = #-0x2
7009fb48: f00c f8c2    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0xc184
7009fb4c: a804         	add	r0, sp, #0x10
7009fb4e: a907         	add	r1, sp, #0x1c
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
7009fb50: f007 fdde    	bl	0x700a7710 <xTaskCheckForTimeOut> @ imm = #0x7bbc
7009fb54: bb58         	cbnz	r0, 0x7009fbae <xQueueSemaphoreTake+0x12e> @ imm = #0x56
7009fb56: e7ff         	b	0x7009fb58 <xQueueSemaphoreTake+0xd8> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
7009fb58: 9803         	ldr	r0, [sp, #0xc]
7009fb5a: f00d fc09    	bl	0x700ad370 <prvIsQueueEmpty> @ imm = #0xd812
7009fb5e: b1f8         	cbz	r0, 0x7009fba0 <xQueueSemaphoreTake+0x120> @ imm = #0x3e
7009fb60: e7ff         	b	0x7009fb62 <xQueueSemaphoreTake+0xe2> @ imm = #-0x2
;                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
7009fb62: 9803         	ldr	r0, [sp, #0xc]
7009fb64: 6800         	ldr	r0, [r0]
7009fb66: b950         	cbnz	r0, 0x7009fb7e <xQueueSemaphoreTake+0xfe> @ imm = #0x14
7009fb68: e7ff         	b	0x7009fb6a <xQueueSemaphoreTake+0xea> @ imm = #-0x2
;                             taskENTER_CRITICAL();
7009fb6a: f00d f831    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0xd062
;                                 xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
7009fb6e: 9803         	ldr	r0, [sp, #0xc]
7009fb70: 6880         	ldr	r0, [r0, #0x8]
7009fb72: f003 fdbd    	bl	0x700a36f0 <xTaskPriorityInherit> @ imm = #0x3b7a
7009fb76: 9002         	str	r0, [sp, #0x8]
;                             taskEXIT_CRITICAL();
7009fb78: f00c f8aa    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0xc154
;                         }
7009fb7c: e000         	b	0x7009fb80 <xQueueSemaphoreTake+0x100> @ imm = #0x0
7009fb7e: e7ff         	b	0x7009fb80 <xQueueSemaphoreTake+0x100> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
7009fb80: 9803         	ldr	r0, [sp, #0xc]
7009fb82: 3024         	adds	r0, #0x24
7009fb84: 9907         	ldr	r1, [sp, #0x1c]
7009fb86: f00d fcb3    	bl	0x700ad4f0 <vTaskPlaceOnEventList> @ imm = #0xd966
;                 prvUnlockQueue( pxQueue );
7009fb8a: 9803         	ldr	r0, [sp, #0xc]
7009fb8c: f006 fb78    	bl	0x700a6280 <prvUnlockQueue> @ imm = #0x66f0
;                 if( xTaskResumeAll() == pdFALSE )
7009fb90: f000 fe86    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #0xd0c
7009fb94: b910         	cbnz	r0, 0x7009fb9c <xQueueSemaphoreTake+0x11c> @ imm = #0x4
7009fb96: e7ff         	b	0x7009fb98 <xQueueSemaphoreTake+0x118> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
7009fb98: df00         	svc	#0x0
;                 }
7009fb9a: e000         	b	0x7009fb9e <xQueueSemaphoreTake+0x11e> @ imm = #0x0
7009fb9c: e7ff         	b	0x7009fb9e <xQueueSemaphoreTake+0x11e> @ imm = #-0x2
;             }
7009fb9e: e005         	b	0x7009fbac <xQueueSemaphoreTake+0x12c> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
7009fba0: 9803         	ldr	r0, [sp, #0xc]
7009fba2: f006 fb6d    	bl	0x700a6280 <prvUnlockQueue> @ imm = #0x66da
;                 ( void ) xTaskResumeAll();
7009fba6: f000 fe7b    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #0xcf6
7009fbaa: e7ff         	b	0x7009fbac <xQueueSemaphoreTake+0x12c> @ imm = #-0x2
;         }
7009fbac: e01f         	b	0x7009fbee <xQueueSemaphoreTake+0x16e> @ imm = #0x3e
;             prvUnlockQueue( pxQueue );
7009fbae: 9803         	ldr	r0, [sp, #0xc]
7009fbb0: f006 fb66    	bl	0x700a6280 <prvUnlockQueue> @ imm = #0x66cc
;             ( void ) xTaskResumeAll();
7009fbb4: f000 fe74    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #0xce8
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
7009fbb8: 9803         	ldr	r0, [sp, #0xc]
7009fbba: f00d fbd9    	bl	0x700ad370 <prvIsQueueEmpty> @ imm = #0xd7b2
7009fbbe: b1a0         	cbz	r0, 0x7009fbea <xQueueSemaphoreTake+0x16a> @ imm = #0x28
7009fbc0: e7ff         	b	0x7009fbc2 <xQueueSemaphoreTake+0x142> @ imm = #-0x2
;                         if( xInheritanceOccurred != pdFALSE )
7009fbc2: 9802         	ldr	r0, [sp, #0x8]
7009fbc4: b170         	cbz	r0, 0x7009fbe4 <xQueueSemaphoreTake+0x164> @ imm = #0x1c
7009fbc6: e7ff         	b	0x7009fbc8 <xQueueSemaphoreTake+0x148> @ imm = #-0x2
;                             taskENTER_CRITICAL();
7009fbc8: f00d f802    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0xd004
;                                 uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
7009fbcc: 9803         	ldr	r0, [sp, #0xc]
7009fbce: f00d fc77    	bl	0x700ad4c0 <prvGetDisinheritPriorityAfterTimeout> @ imm = #0xd8ee
7009fbd2: 9000         	str	r0, [sp]
;                                 vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
7009fbd4: 9803         	ldr	r0, [sp, #0xc]
7009fbd6: 6880         	ldr	r0, [r0, #0x8]
7009fbd8: 9900         	ldr	r1, [sp]
7009fbda: f004 f999    	bl	0x700a3f10 <vTaskPriorityDisinheritAfterTimeout> @ imm = #0x4332
;                             taskEXIT_CRITICAL();
7009fbde: f00c f877    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0xc0ee
;                         }
7009fbe2: e7ff         	b	0x7009fbe4 <xQueueSemaphoreTake+0x164> @ imm = #-0x2
7009fbe4: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
7009fbe6: 9009         	str	r0, [sp, #0x24]
7009fbe8: e002         	b	0x7009fbf0 <xQueueSemaphoreTake+0x170> @ imm = #0x4
7009fbea: e7ff         	b	0x7009fbec <xQueueSemaphoreTake+0x16c> @ imm = #-0x2
7009fbec: e7ff         	b	0x7009fbee <xQueueSemaphoreTake+0x16e> @ imm = #-0x2
;     for( ; ; )
7009fbee: e751         	b	0x7009fa94 <xQueueSemaphoreTake+0x14> @ imm = #-0x15e
; }
7009fbf0: 9809         	ldr	r0, [sp, #0x24]
7009fbf2: b00a         	add	sp, #0x28
7009fbf4: bd80         	pop	{r7, pc}
		...
7009fbfe: 0000         	movs	r0, r0

7009fc00 <xTaskIncrementTick>:
; BaseType_t xTaskIncrementTick(void) {
7009fc00: b580         	push	{r7, lr}
7009fc02: b086         	sub	sp, #0x18
7009fc04: 2000         	movs	r0, #0x0
;   BaseType_t xSwitchRequired = pdFALSE;
7009fc06: 9003         	str	r0, [sp, #0xc]
;   if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
7009fc08: f640 50d4    	movw	r0, #0xdd4
7009fc0c: f2c7 000b    	movt	r0, #0x700b
7009fc10: 6800         	ldr	r0, [r0]
7009fc12: 2800         	cmp	r0, #0x0
7009fc14: f040 80a3    	bne.w	0x7009fd5e <xTaskIncrementTick+0x15e> @ imm = #0x146
7009fc18: e7ff         	b	0x7009fc1a <xTaskIncrementTick+0x1a> @ imm = #-0x2
;     const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
7009fc1a: f640 51f4    	movw	r1, #0xdf4
7009fc1e: f2c7 010b    	movt	r1, #0x700b
7009fc22: 6808         	ldr	r0, [r1]
7009fc24: 3001         	adds	r0, #0x1
7009fc26: 9002         	str	r0, [sp, #0x8]
;     xTickCount = xConstTickCount;
7009fc28: 9802         	ldr	r0, [sp, #0x8]
7009fc2a: 6008         	str	r0, [r1]
;     if (xConstTickCount ==
7009fc2c: 9802         	ldr	r0, [sp, #0x8]
7009fc2e: b9c0         	cbnz	r0, 0x7009fc62 <xTaskIncrementTick+0x62> @ imm = #0x30
7009fc30: e7ff         	b	0x7009fc32 <xTaskIncrementTick+0x32> @ imm = #-0x2
;       taskSWITCH_DELAYED_LISTS();
7009fc32: f644 52b0    	movw	r2, #0x4db0
7009fc36: f2c7 0208    	movt	r2, #0x7008
7009fc3a: 6810         	ldr	r0, [r2]
7009fc3c: 9001         	str	r0, [sp, #0x4]
7009fc3e: f644 51b4    	movw	r1, #0x4db4
7009fc42: f2c7 0108    	movt	r1, #0x7008
7009fc46: 6808         	ldr	r0, [r1]
7009fc48: 6010         	str	r0, [r2]
7009fc4a: 9801         	ldr	r0, [sp, #0x4]
7009fc4c: 6008         	str	r0, [r1]
7009fc4e: f640 51e8    	movw	r1, #0xde8
7009fc52: f2c7 010b    	movt	r1, #0x700b
7009fc56: 6808         	ldr	r0, [r1]
7009fc58: 3001         	adds	r0, #0x1
7009fc5a: 6008         	str	r0, [r1]
7009fc5c: f00c fca0    	bl	0x700ac5a0 <prvResetNextTaskUnblockTime> @ imm = #0xc940
;     } else {
7009fc60: e000         	b	0x7009fc64 <xTaskIncrementTick+0x64> @ imm = #0x0
7009fc62: e7ff         	b	0x7009fc64 <xTaskIncrementTick+0x64> @ imm = #-0x2
;     if (xConstTickCount >= xNextTaskUnblockTime) {
7009fc64: 9802         	ldr	r0, [sp, #0x8]
7009fc66: f640 51e4    	movw	r1, #0xde4
7009fc6a: f2c7 010b    	movt	r1, #0x700b
7009fc6e: 6809         	ldr	r1, [r1]
7009fc70: 4288         	cmp	r0, r1
7009fc72: d368         	blo	0x7009fd46 <xTaskIncrementTick+0x146> @ imm = #0xd0
7009fc74: e7ff         	b	0x7009fc76 <xTaskIncrementTick+0x76> @ imm = #-0x2
;       for (;;) {
7009fc76: e7ff         	b	0x7009fc78 <xTaskIncrementTick+0x78> @ imm = #-0x2
;         if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
7009fc78: f644 50b0    	movw	r0, #0x4db0
7009fc7c: f2c7 0008    	movt	r0, #0x7008
7009fc80: 6800         	ldr	r0, [r0]
7009fc82: 6800         	ldr	r0, [r0]
7009fc84: b940         	cbnz	r0, 0x7009fc98 <xTaskIncrementTick+0x98> @ imm = #0x10
7009fc86: e7ff         	b	0x7009fc88 <xTaskIncrementTick+0x88> @ imm = #-0x2
;           xNextTaskUnblockTime =
7009fc88: f640 51e4    	movw	r1, #0xde4
7009fc8c: f2c7 010b    	movt	r1, #0x700b
7009fc90: f04f 30ff    	mov.w	r0, #0xffffffff
7009fc94: 6008         	str	r0, [r1]
;           break;
7009fc96: e055         	b	0x7009fd44 <xTaskIncrementTick+0x144> @ imm = #0xaa
;           pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
7009fc98: f644 50b0    	movw	r0, #0x4db0
7009fc9c: f2c7 0008    	movt	r0, #0x7008
7009fca0: 6800         	ldr	r0, [r0]
7009fca2: 68c0         	ldr	r0, [r0, #0xc]
7009fca4: 68c0         	ldr	r0, [r0, #0xc]
7009fca6: 9005         	str	r0, [sp, #0x14]
;           xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
7009fca8: 9805         	ldr	r0, [sp, #0x14]
7009fcaa: 6840         	ldr	r0, [r0, #0x4]
7009fcac: 9004         	str	r0, [sp, #0x10]
;           if (xConstTickCount < xItemValue) {
7009fcae: 9802         	ldr	r0, [sp, #0x8]
7009fcb0: 9904         	ldr	r1, [sp, #0x10]
7009fcb2: 4288         	cmp	r0, r1
7009fcb4: d207         	bhs	0x7009fcc6 <xTaskIncrementTick+0xc6> @ imm = #0xe
7009fcb6: e7ff         	b	0x7009fcb8 <xTaskIncrementTick+0xb8> @ imm = #-0x2
;             xNextTaskUnblockTime = xItemValue;
7009fcb8: 9804         	ldr	r0, [sp, #0x10]
7009fcba: f640 51e4    	movw	r1, #0xde4
7009fcbe: f2c7 010b    	movt	r1, #0x700b
7009fcc2: 6008         	str	r0, [r1]
;             break; /*lint !e9011 Code structure here is deedmed easier to
7009fcc4: e03e         	b	0x7009fd44 <xTaskIncrementTick+0x144> @ imm = #0x7c
7009fcc6: e7ff         	b	0x7009fcc8 <xTaskIncrementTick+0xc8> @ imm = #-0x2
;           (void)uxListRemove(&(pxTCB->xStateListItem));
7009fcc8: 9805         	ldr	r0, [sp, #0x14]
7009fcca: 3004         	adds	r0, #0x4
7009fccc: f00b ff10    	bl	0x700abaf0 <uxListRemove> @ imm = #0xbe20
;           if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
7009fcd0: 9805         	ldr	r0, [sp, #0x14]
7009fcd2: 6a80         	ldr	r0, [r0, #0x28]
7009fcd4: b128         	cbz	r0, 0x7009fce2 <xTaskIncrementTick+0xe2> @ imm = #0xa
7009fcd6: e7ff         	b	0x7009fcd8 <xTaskIncrementTick+0xd8> @ imm = #-0x2
;             (void)uxListRemove(&(pxTCB->xEventListItem));
7009fcd8: 9805         	ldr	r0, [sp, #0x14]
7009fcda: 3018         	adds	r0, #0x18
7009fcdc: f00b ff08    	bl	0x700abaf0 <uxListRemove> @ imm = #0xbe10
;           } else {
7009fce0: e000         	b	0x7009fce4 <xTaskIncrementTick+0xe4> @ imm = #0x0
7009fce2: e7ff         	b	0x7009fce4 <xTaskIncrementTick+0xe4> @ imm = #-0x2
;           prvAddTaskToReadyList(pxTCB);
7009fce4: 9805         	ldr	r0, [sp, #0x14]
7009fce6: 6ac0         	ldr	r0, [r0, #0x2c]
7009fce8: f640 51dc    	movw	r1, #0xddc
7009fcec: f2c7 010b    	movt	r1, #0x700b
7009fcf0: 6809         	ldr	r1, [r1]
7009fcf2: 4288         	cmp	r0, r1
7009fcf4: d908         	bls	0x7009fd08 <xTaskIncrementTick+0x108> @ imm = #0x10
7009fcf6: e7ff         	b	0x7009fcf8 <xTaskIncrementTick+0xf8> @ imm = #-0x2
7009fcf8: 9805         	ldr	r0, [sp, #0x14]
7009fcfa: 6ac0         	ldr	r0, [r0, #0x2c]
7009fcfc: f640 51dc    	movw	r1, #0xddc
7009fd00: f2c7 010b    	movt	r1, #0x700b
7009fd04: 6008         	str	r0, [r1]
7009fd06: e7ff         	b	0x7009fd08 <xTaskIncrementTick+0x108> @ imm = #-0x2
7009fd08: 9905         	ldr	r1, [sp, #0x14]
7009fd0a: 6ac8         	ldr	r0, [r1, #0x2c]
7009fd0c: eb00 0280    	add.w	r2, r0, r0, lsl #2
7009fd10: f244 40f8    	movw	r0, #0x44f8
7009fd14: f2c7 0008    	movt	r0, #0x7008
7009fd18: eb00 0082    	add.w	r0, r0, r2, lsl #2
7009fd1c: 3104         	adds	r1, #0x4
7009fd1e: f00c fcbf    	bl	0x700ac6a0 <vListInsertEnd> @ imm = #0xc97e
;             if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
7009fd22: 9805         	ldr	r0, [sp, #0x14]
7009fd24: 6ac0         	ldr	r0, [r0, #0x2c]
7009fd26: f640 51ac    	movw	r1, #0xdac
7009fd2a: f2c7 010b    	movt	r1, #0x700b
7009fd2e: 6809         	ldr	r1, [r1]
7009fd30: 6ac9         	ldr	r1, [r1, #0x2c]
7009fd32: 4288         	cmp	r0, r1
7009fd34: d303         	blo	0x7009fd3e <xTaskIncrementTick+0x13e> @ imm = #0x6
7009fd36: e7ff         	b	0x7009fd38 <xTaskIncrementTick+0x138> @ imm = #-0x2
7009fd38: 2001         	movs	r0, #0x1
;               xSwitchRequired = pdTRUE;
7009fd3a: 9003         	str	r0, [sp, #0xc]
;             } else {
7009fd3c: e000         	b	0x7009fd40 <xTaskIncrementTick+0x140> @ imm = #0x0
7009fd3e: e7ff         	b	0x7009fd40 <xTaskIncrementTick+0x140> @ imm = #-0x2
7009fd40: e7ff         	b	0x7009fd42 <xTaskIncrementTick+0x142> @ imm = #-0x2
;       for (;;) {
7009fd42: e799         	b	0x7009fc78 <xTaskIncrementTick+0x78> @ imm = #-0xce
;     }
7009fd44: e7ff         	b	0x7009fd46 <xTaskIncrementTick+0x146> @ imm = #-0x2
;       if (xYieldPending != pdFALSE) {
7009fd46: f640 6000    	movw	r0, #0xe00
7009fd4a: f2c7 000b    	movt	r0, #0x700b
7009fd4e: 6800         	ldr	r0, [r0]
7009fd50: b118         	cbz	r0, 0x7009fd5a <xTaskIncrementTick+0x15a> @ imm = #0x6
7009fd52: e7ff         	b	0x7009fd54 <xTaskIncrementTick+0x154> @ imm = #-0x2
7009fd54: 2001         	movs	r0, #0x1
;         xSwitchRequired = pdTRUE;
7009fd56: 9003         	str	r0, [sp, #0xc]
;       } else {
7009fd58: e000         	b	0x7009fd5c <xTaskIncrementTick+0x15c> @ imm = #0x0
7009fd5a: e7ff         	b	0x7009fd5c <xTaskIncrementTick+0x15c> @ imm = #-0x2
;   } else {
7009fd5c: e007         	b	0x7009fd6e <xTaskIncrementTick+0x16e> @ imm = #0xe
;     ++xPendedTicks;
7009fd5e: f640 51ec    	movw	r1, #0xdec
7009fd62: f2c7 010b    	movt	r1, #0x700b
7009fd66: 6808         	ldr	r0, [r1]
7009fd68: 3001         	adds	r0, #0x1
7009fd6a: 6008         	str	r0, [r1]
7009fd6c: e7ff         	b	0x7009fd6e <xTaskIncrementTick+0x16e> @ imm = #-0x2
;   return xSwitchRequired;
7009fd6e: 9803         	ldr	r0, [sp, #0xc]
7009fd70: b006         	add	sp, #0x18
7009fd72: bd80         	pop	{r7, pc}
		...

7009fd80 <CSL_bcdmaChanOpTeardownChan>:
; {
7009fd80: b580         	push	{r7, lr}
7009fd82: b08c         	sub	sp, #0x30
7009fd84: 900b         	str	r0, [sp, #0x2c]
7009fd86: 910a         	str	r1, [sp, #0x28]
7009fd88: 9209         	str	r2, [sp, #0x24]
7009fd8a: 9308         	str	r3, [sp, #0x20]
7009fd8c: 2000         	movs	r0, #0x0
;     int32_t  retVal = CSL_PASS;
7009fd8e: 9007         	str	r0, [sp, #0x1c]
;     if( CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)false )
7009fd90: 980b         	ldr	r0, [sp, #0x2c]
7009fd92: 990a         	ldr	r1, [sp, #0x28]
7009fd94: 9a09         	ldr	r2, [sp, #0x24]
7009fd96: f009 f883    	bl	0x700a8ea0 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x9106
7009fd9a: b920         	cbnz	r0, 0x7009fda6 <CSL_bcdmaChanOpTeardownChan+0x26> @ imm = #0x8
7009fd9c: e7ff         	b	0x7009fd9e <CSL_bcdmaChanOpTeardownChan+0x1e> @ imm = #-0x2
7009fd9e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
7009fda2: 9007         	str	r0, [sp, #0x1c]
;     }
7009fda4: e09f         	b	0x7009fee6 <CSL_bcdmaChanOpTeardownChan+0x166> @ imm = #0x13e
7009fda6: 2000         	movs	r0, #0x0
;         uint32_t force = (uint32_t)0U, wait = (uint32_t)0U;
7009fda8: 9005         	str	r0, [sp, #0x14]
7009fdaa: 9004         	str	r0, [sp, #0x10]
;         if( pOpData != NULL )
7009fdac: 9808         	ldr	r0, [sp, #0x20]
7009fdae: b148         	cbz	r0, 0x7009fdc4 <CSL_bcdmaChanOpTeardownChan+0x44> @ imm = #0x12
7009fdb0: e7ff         	b	0x7009fdb2 <CSL_bcdmaChanOpTeardownChan+0x32> @ imm = #-0x2
;             CSL_BcdmaTeardownOpts *pTdOpts = (CSL_BcdmaTeardownOpts *)pOpData;
7009fdb2: 9808         	ldr	r0, [sp, #0x20]
7009fdb4: 9003         	str	r0, [sp, #0xc]
;             force = pTdOpts->force;
7009fdb6: 9803         	ldr	r0, [sp, #0xc]
7009fdb8: 6800         	ldr	r0, [r0]
7009fdba: 9005         	str	r0, [sp, #0x14]
;             wait  = pTdOpts->wait;
7009fdbc: 9803         	ldr	r0, [sp, #0xc]
7009fdbe: 6840         	ldr	r0, [r0, #0x4]
7009fdc0: 9004         	str	r0, [sp, #0x10]
;         }
7009fdc2: e7ff         	b	0x7009fdc4 <CSL_bcdmaChanOpTeardownChan+0x44> @ imm = #-0x2
;         switch( chanType )
7009fdc4: 980a         	ldr	r0, [sp, #0x28]
7009fdc6: 9001         	str	r0, [sp, #0x4]
7009fdc8: b148         	cbz	r0, 0x7009fdde <CSL_bcdmaChanOpTeardownChan+0x5e> @ imm = #0x12
7009fdca: e7ff         	b	0x7009fdcc <CSL_bcdmaChanOpTeardownChan+0x4c> @ imm = #-0x2
7009fdcc: 9801         	ldr	r0, [sp, #0x4]
7009fdce: 2801         	cmp	r0, #0x1
7009fdd0: d024         	beq	0x7009fe1c <CSL_bcdmaChanOpTeardownChan+0x9c> @ imm = #0x48
7009fdd2: e7ff         	b	0x7009fdd4 <CSL_bcdmaChanOpTeardownChan+0x54> @ imm = #-0x2
7009fdd4: 9801         	ldr	r0, [sp, #0x4]
7009fdd6: 2802         	cmp	r0, #0x2
7009fdd8: d03f         	beq	0x7009fe5a <CSL_bcdmaChanOpTeardownChan+0xda> @ imm = #0x7e
7009fdda: e7ff         	b	0x7009fddc <CSL_bcdmaChanOpTeardownChan+0x5c> @ imm = #-0x2
;         {
7009fddc: e7ff         	b	0x7009fdde <CSL_bcdmaChanOpTeardownChan+0x5e> @ imm = #-0x2
;                 regVal = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL );
7009fdde: 980b         	ldr	r0, [sp, #0x2c]
7009fde0: 6880         	ldr	r0, [r0, #0x8]
7009fde2: 9909         	ldr	r1, [sp, #0x24]
7009fde4: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009fde8: f00e f942    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0xe284
7009fdec: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_BCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
7009fdee: 9806         	ldr	r0, [sp, #0x18]
7009fdf0: f040 4080    	orr	r0, r0, #0x40000000
7009fdf4: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_BCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
7009fdf6: 9806         	ldr	r0, [sp, #0x18]
7009fdf8: f020 5180    	bic	r1, r0, #0x10000000
7009fdfc: 9a05         	ldr	r2, [sp, #0x14]
7009fdfe: f101 5080    	add.w	r0, r1, #0x10000000
7009fe02: 2a00         	cmp	r2, #0x0
7009fe04: bf08         	it	eq
7009fe06: 4608         	moveq	r0, r1
7009fe08: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, regVal );
7009fe0a: 980b         	ldr	r0, [sp, #0x2c]
7009fe0c: 6880         	ldr	r0, [r0, #0x8]
7009fe0e: 9909         	ldr	r1, [sp, #0x24]
7009fe10: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009fe14: 9906         	ldr	r1, [sp, #0x18]
7009fe16: f7fb f8cb    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x4e6a
;                 break;
7009fe1a: e03d         	b	0x7009fe98 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #0x7a
;                 regVal = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
7009fe1c: 980b         	ldr	r0, [sp, #0x2c]
7009fe1e: 6900         	ldr	r0, [r0, #0x10]
7009fe20: 9909         	ldr	r1, [sp, #0x24]
7009fe22: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009fe26: f00e f923    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0xe246
7009fe2a: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_TXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
7009fe2c: 9806         	ldr	r0, [sp, #0x18]
7009fe2e: f040 4080    	orr	r0, r0, #0x40000000
7009fe32: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_TXCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
7009fe34: 9806         	ldr	r0, [sp, #0x18]
7009fe36: f020 5180    	bic	r1, r0, #0x10000000
7009fe3a: 9a05         	ldr	r2, [sp, #0x14]
7009fe3c: f101 5080    	add.w	r0, r1, #0x10000000
7009fe40: 2a00         	cmp	r2, #0x0
7009fe42: bf08         	it	eq
7009fe44: 4608         	moveq	r0, r1
7009fe46: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, regVal );
7009fe48: 980b         	ldr	r0, [sp, #0x2c]
7009fe4a: 6900         	ldr	r0, [r0, #0x10]
7009fe4c: 9909         	ldr	r1, [sp, #0x24]
7009fe4e: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009fe52: 9906         	ldr	r1, [sp, #0x18]
7009fe54: f7fb f8ac    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x4ea8
;                 break;
7009fe58: e01e         	b	0x7009fe98 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #0x3c
;                 regVal = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
7009fe5a: 980b         	ldr	r0, [sp, #0x2c]
7009fe5c: 6980         	ldr	r0, [r0, #0x18]
7009fe5e: 9909         	ldr	r1, [sp, #0x24]
7009fe60: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009fe64: f00e f904    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0xe208
7009fe68: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_RXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
7009fe6a: 9806         	ldr	r0, [sp, #0x18]
7009fe6c: f040 4080    	orr	r0, r0, #0x40000000
7009fe70: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_RXCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
7009fe72: 9806         	ldr	r0, [sp, #0x18]
7009fe74: f020 5180    	bic	r1, r0, #0x10000000
7009fe78: 9a05         	ldr	r2, [sp, #0x14]
7009fe7a: f101 5080    	add.w	r0, r1, #0x10000000
7009fe7e: 2a00         	cmp	r2, #0x0
7009fe80: bf08         	it	eq
7009fe82: 4608         	moveq	r0, r1
7009fe84: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, regVal );
7009fe86: 980b         	ldr	r0, [sp, #0x2c]
7009fe88: 6980         	ldr	r0, [r0, #0x18]
7009fe8a: 9909         	ldr	r1, [sp, #0x24]
7009fe8c: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009fe90: 9906         	ldr	r1, [sp, #0x18]
7009fe92: f7fb f88d    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x4ee6
;                 break;
7009fe96: e7ff         	b	0x7009fe98 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #-0x2
;         if(wait != 0U)
7009fe98: 9804         	ldr	r0, [sp, #0x10]
7009fe9a: b318         	cbz	r0, 0x7009fee4 <CSL_bcdmaChanOpTeardownChan+0x164> @ imm = #0x46
7009fe9c: e7ff         	b	0x7009fe9e <CSL_bcdmaChanOpTeardownChan+0x11e> @ imm = #-0x2
7009fe9e: 2080         	movs	r0, #0x80
;             uint32_t retryCnt = CSL_BCDMA_TEARDOWN_COMPLETE_WAIT_MAX_CNT;
7009fea0: 9002         	str	r0, [sp, #0x8]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
7009fea2: e7ff         	b	0x7009fea4 <CSL_bcdmaChanOpTeardownChan+0x124> @ imm = #-0x2
7009fea4: 980b         	ldr	r0, [sp, #0x2c]
7009fea6: 990a         	ldr	r1, [sp, #0x28]
7009fea8: 9a09         	ldr	r2, [sp, #0x24]
7009feaa: f008 fff9    	bl	0x700a8ea0 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x8ff2
7009feae: 4601         	mov	r1, r0
7009feb0: 2000         	movs	r0, #0x0
7009feb2: 9000         	str	r0, [sp]
7009feb4: b131         	cbz	r1, 0x7009fec4 <CSL_bcdmaChanOpTeardownChan+0x144> @ imm = #0xc
7009feb6: e7ff         	b	0x7009feb8 <CSL_bcdmaChanOpTeardownChan+0x138> @ imm = #-0x2
7009feb8: 9802         	ldr	r0, [sp, #0x8]
7009feba: 2800         	cmp	r0, #0x0
7009febc: bf18         	it	ne
7009febe: 2001         	movne	r0, #0x1
7009fec0: 9000         	str	r0, [sp]
7009fec2: e7ff         	b	0x7009fec4 <CSL_bcdmaChanOpTeardownChan+0x144> @ imm = #-0x2
7009fec4: 9800         	ldr	r0, [sp]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
7009fec6: 07c0         	lsls	r0, r0, #0x1f
7009fec8: b120         	cbz	r0, 0x7009fed4 <CSL_bcdmaChanOpTeardownChan+0x154> @ imm = #0x8
7009feca: e7ff         	b	0x7009fecc <CSL_bcdmaChanOpTeardownChan+0x14c> @ imm = #-0x2
;                 retryCnt--;
7009fecc: 9802         	ldr	r0, [sp, #0x8]
7009fece: 3801         	subs	r0, #0x1
7009fed0: 9002         	str	r0, [sp, #0x8]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
7009fed2: e7e7         	b	0x7009fea4 <CSL_bcdmaChanOpTeardownChan+0x124> @ imm = #-0x32
;             if( retryCnt == (uint32_t)0U ) {
7009fed4: 9802         	ldr	r0, [sp, #0x8]
7009fed6: b920         	cbnz	r0, 0x7009fee2 <CSL_bcdmaChanOpTeardownChan+0x162> @ imm = #0x8
7009fed8: e7ff         	b	0x7009feda <CSL_bcdmaChanOpTeardownChan+0x15a> @ imm = #-0x2
7009feda: f04f 30ff    	mov.w	r0, #0xffffffff
;                 retVal = CSL_EFAIL;
7009fede: 9007         	str	r0, [sp, #0x1c]
;             }
7009fee0: e7ff         	b	0x7009fee2 <CSL_bcdmaChanOpTeardownChan+0x162> @ imm = #-0x2
;         }
7009fee2: e7ff         	b	0x7009fee4 <CSL_bcdmaChanOpTeardownChan+0x164> @ imm = #-0x2
7009fee4: e7ff         	b	0x7009fee6 <CSL_bcdmaChanOpTeardownChan+0x166> @ imm = #-0x2
;     return retVal;
7009fee6: 9807         	ldr	r0, [sp, #0x1c]
7009fee8: b00c         	add	sp, #0x30
7009feea: bd80         	pop	{r7, pc}
7009feec: 0000         	movs	r0, r0
7009feee: 0000         	movs	r0, r0

7009fef0 <CSL_bcdmaChanOp>:
; {
7009fef0: b580         	push	{r7, lr}
7009fef2: b088         	sub	sp, #0x20
7009fef4: f8dd c028    	ldr.w	r12, [sp, #0x28]
7009fef8: 9007         	str	r0, [sp, #0x1c]
7009fefa: 9106         	str	r1, [sp, #0x18]
7009fefc: 9205         	str	r2, [sp, #0x14]
7009fefe: 9304         	str	r3, [sp, #0x10]
7009ff00: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
7009ff02: 9003         	str	r0, [sp, #0xc]
;     if( ( pCfg == NULL )                                    ||
7009ff04: 9807         	ldr	r0, [sp, #0x1c]
7009ff06: b158         	cbz	r0, 0x7009ff20 <CSL_bcdmaChanOp+0x30> @ imm = #0x16
7009ff08: e7ff         	b	0x7009ff0a <CSL_bcdmaChanOp+0x1a> @ imm = #-0x2
;         ( chanType > CSL_BCDMA_CHAN_TYPE_SPLIT_RX )         ||
7009ff0a: 9805         	ldr	r0, [sp, #0x14]
7009ff0c: 2802         	cmp	r0, #0x2
7009ff0e: d807         	bhi	0x7009ff20 <CSL_bcdmaChanOp+0x30> @ imm = #0xe
7009ff10: e7ff         	b	0x7009ff12 <CSL_bcdmaChanOp+0x22> @ imm = #-0x2
;         ( !CSL_bcdmaChanOpIsValidChanIdx( pCfg, chanType, chanIdx ) )
7009ff12: 9807         	ldr	r0, [sp, #0x1c]
7009ff14: 9905         	ldr	r1, [sp, #0x14]
7009ff16: 9a04         	ldr	r2, [sp, #0x10]
7009ff18: f009 f802    	bl	0x700a8f20 <CSL_bcdmaChanOpIsValidChanIdx> @ imm = #0x9004
;     if( ( pCfg == NULL )                                    ||
7009ff1c: b920         	cbnz	r0, 0x7009ff28 <CSL_bcdmaChanOp+0x38> @ imm = #0x8
7009ff1e: e7ff         	b	0x7009ff20 <CSL_bcdmaChanOp+0x30> @ imm = #-0x2
7009ff20: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
7009ff24: 9003         	str	r0, [sp, #0xc]
;     }
7009ff26: e094         	b	0x700a0052 <CSL_bcdmaChanOp+0x162> @ imm = #0x128
;         switch(chanOp )
7009ff28: 9806         	ldr	r0, [sp, #0x18]
7009ff2a: 9002         	str	r0, [sp, #0x8]
7009ff2c: 280e         	cmp	r0, #0xe
7009ff2e: f200 808b    	bhi.w	0x700a0048 <CSL_bcdmaChanOp+0x158> @ imm = #0x116
7009ff32: 9902         	ldr	r1, [sp, #0x8]
7009ff34: e8df f001    	tbb	[pc, r1]
7009ff38: 08 10 18 20  	.word	0x20181008
7009ff3c: 28 30 38 3f  	.word	0x3f383028
7009ff40: 47 4f 57 5f  	.word	0x5f574f47
7009ff44: 6c 79 81 00  	.word	0x0081796c
;                 retVal = CSL_bcdmaChanOpCfgChan( pCfg, chanType, chanIdx, pOpData );
7009ff48: 9807         	ldr	r0, [sp, #0x1c]
7009ff4a: 9905         	ldr	r1, [sp, #0x14]
7009ff4c: 9a04         	ldr	r2, [sp, #0x10]
7009ff4e: 9b0a         	ldr	r3, [sp, #0x28]
7009ff50: f7fc fb36    	bl	0x7009c5c0 <CSL_bcdmaChanOpCfgChan> @ imm = #-0x3994
7009ff54: 9003         	str	r0, [sp, #0xc]
;                 break;
7009ff56: e07b         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0xf6
;                 retVal = CSL_bcdmaChanOpSetChanEnable( pCfg, chanType, chanIdx, (bool)true );
7009ff58: 9807         	ldr	r0, [sp, #0x1c]
7009ff5a: 9905         	ldr	r1, [sp, #0x14]
7009ff5c: 9a04         	ldr	r2, [sp, #0x10]
7009ff5e: 2301         	movs	r3, #0x1
7009ff60: f007 fc26    	bl	0x700a77b0 <CSL_bcdmaChanOpSetChanEnable> @ imm = #0x784c
7009ff64: 9003         	str	r0, [sp, #0xc]
;                 break;
7009ff66: e073         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0xe6
;                 retVal = CSL_bcdmaChanOpSetChanEnable( pCfg, chanType, chanIdx, (bool)false );
7009ff68: 9807         	ldr	r0, [sp, #0x1c]
7009ff6a: 9905         	ldr	r1, [sp, #0x14]
7009ff6c: 9a04         	ldr	r2, [sp, #0x10]
7009ff6e: 2300         	movs	r3, #0x0
7009ff70: f007 fc1e    	bl	0x700a77b0 <CSL_bcdmaChanOpSetChanEnable> @ imm = #0x783c
7009ff74: 9003         	str	r0, [sp, #0xc]
;                 break;
7009ff76: e06b         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0xd6
;                 retVal = CSL_bcdmaChanOpSetChanPause( pCfg, chanType, chanIdx, (bool)true );
7009ff78: 9807         	ldr	r0, [sp, #0x1c]
7009ff7a: 9905         	ldr	r1, [sp, #0x14]
7009ff7c: 9a04         	ldr	r2, [sp, #0x10]
7009ff7e: 2301         	movs	r3, #0x1
7009ff80: f006 fb36    	bl	0x700a65f0 <CSL_bcdmaChanOpSetChanPause> @ imm = #0x666c
7009ff84: 9003         	str	r0, [sp, #0xc]
;                 break;
7009ff86: e063         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0xc6
;                 retVal = CSL_bcdmaChanOpSetChanPause( pCfg, chanType, chanIdx, (bool)false );
7009ff88: 9807         	ldr	r0, [sp, #0x1c]
7009ff8a: 9905         	ldr	r1, [sp, #0x14]
7009ff8c: 9a04         	ldr	r2, [sp, #0x10]
7009ff8e: 2300         	movs	r3, #0x0
7009ff90: f006 fb2e    	bl	0x700a65f0 <CSL_bcdmaChanOpSetChanPause> @ imm = #0x665c
7009ff94: 9003         	str	r0, [sp, #0xc]
;                 break;
7009ff96: e05b         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0xb6
;                 retVal = CSL_bcdmaChanOpTeardownChan( pCfg, chanType, chanIdx, pOpData );
7009ff98: 9807         	ldr	r0, [sp, #0x1c]
7009ff9a: 9905         	ldr	r1, [sp, #0x14]
7009ff9c: 9a04         	ldr	r2, [sp, #0x10]
7009ff9e: 9b0a         	ldr	r3, [sp, #0x28]
7009ffa0: f7ff feee    	bl	0x7009fd80 <CSL_bcdmaChanOpTeardownChan> @ imm = #-0x224
7009ffa4: 9003         	str	r0, [sp, #0xc]
;                 break;
7009ffa6: e053         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0xa6
;                 retVal = CSL_bcdmaChanOpTriggerChan( pCfg, chanType, chanIdx );
7009ffa8: 9807         	ldr	r0, [sp, #0x1c]
7009ffaa: 9905         	ldr	r1, [sp, #0x14]
7009ffac: 9a04         	ldr	r2, [sp, #0x10]
7009ffae: f009 fb77    	bl	0x700a96a0 <CSL_bcdmaChanOpTriggerChan> @ imm = #0x96ee
7009ffb2: 9003         	str	r0, [sp, #0xc]
;                 break;
7009ffb4: e04c         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0x98
;                 retVal = CSL_bcdmaChanOpGetChanRT( pCfg, chanType, chanIdx, pOpData );
7009ffb6: 9807         	ldr	r0, [sp, #0x1c]
7009ffb8: 9905         	ldr	r1, [sp, #0x14]
7009ffba: 9a04         	ldr	r2, [sp, #0x10]
7009ffbc: 9b0a         	ldr	r3, [sp, #0x28]
7009ffbe: f004 fd0f    	bl	0x700a49e0 <CSL_bcdmaChanOpGetChanRT> @ imm = #0x4a1e
7009ffc2: 9003         	str	r0, [sp, #0xc]
;                 break;
7009ffc4: e044         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0x88
;                 retVal = CSL_bcdmaChanOpSetChanRT( pCfg, chanType, chanIdx, pOpData );
7009ffc6: 9807         	ldr	r0, [sp, #0x1c]
7009ffc8: 9905         	ldr	r1, [sp, #0x14]
7009ffca: 9a04         	ldr	r2, [sp, #0x10]
7009ffcc: 9b0a         	ldr	r3, [sp, #0x28]
7009ffce: f006 fb67    	bl	0x700a66a0 <CSL_bcdmaChanOpSetChanRT> @ imm = #0x66ce
7009ffd2: 9003         	str	r0, [sp, #0xc]
;                 break;
7009ffd4: e03c         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0x78
;                 retVal = CSL_bcdmaChanOpGetChanStats( pCfg, chanType, chanIdx, pOpData );
7009ffd6: 9807         	ldr	r0, [sp, #0x1c]
7009ffd8: 9905         	ldr	r1, [sp, #0x14]
7009ffda: 9a04         	ldr	r2, [sp, #0x10]
7009ffdc: 9b0a         	ldr	r3, [sp, #0x28]
7009ffde: f000 fa57    	bl	0x700a0490 <CSL_bcdmaChanOpGetChanStats> @ imm = #0x4ae
7009ffe2: 9003         	str	r0, [sp, #0xc]
;                 break;
7009ffe4: e034         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0x68
;                 retVal = CSL_bcdmaChanOpDecChanStats( pCfg, chanType, chanIdx, pOpData );
7009ffe6: 9807         	ldr	r0, [sp, #0x1c]
7009ffe8: 9905         	ldr	r1, [sp, #0x14]
7009ffea: 9a04         	ldr	r2, [sp, #0x10]
7009ffec: 9b0a         	ldr	r3, [sp, #0x28]
7009ffee: f003 f82f    	bl	0x700a3050 <CSL_bcdmaChanOpDecChanStats> @ imm = #0x305e
7009fff2: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fff4: e02c         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0x58
;                 retVal = CSL_bcdmaChanOpAccessRemotePeerReg( pCfg, chanType, chanIdx, pOpData, (bool)true );
7009fff6: 9807         	ldr	r0, [sp, #0x1c]
7009fff8: 9905         	ldr	r1, [sp, #0x14]
7009fffa: 9a04         	ldr	r2, [sp, #0x10]
7009fffc: 9b0a         	ldr	r3, [sp, #0x28]
7009fffe: 46ee         	mov	lr, sp
700a0000: f04f 0c01    	mov.w	r12, #0x1
700a0004: f8ce c000    	str.w	r12, [lr]
700a0008: f005 fcd2    	bl	0x700a59b0 <CSL_bcdmaChanOpAccessRemotePeerReg> @ imm = #0x59a4
700a000c: 9003         	str	r0, [sp, #0xc]
;                 break;
700a000e: e01f         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0x3e
;                 retVal = CSL_bcdmaChanOpAccessRemotePeerReg( pCfg, chanType, chanIdx, pOpData, (bool)false );
700a0010: 9807         	ldr	r0, [sp, #0x1c]
700a0012: 9905         	ldr	r1, [sp, #0x14]
700a0014: 9a04         	ldr	r2, [sp, #0x10]
700a0016: 9b0a         	ldr	r3, [sp, #0x28]
700a0018: 46ee         	mov	lr, sp
700a001a: f04f 0c00    	mov.w	r12, #0x0
700a001e: f8ce c000    	str.w	r12, [lr]
700a0022: f005 fcc5    	bl	0x700a59b0 <CSL_bcdmaChanOpAccessRemotePeerReg> @ imm = #0x598a
700a0026: 9003         	str	r0, [sp, #0xc]
;                 break;
700a0028: e012         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0x24
;                 retVal = CSL_bcdmaChanOpSetBurstSize( pCfg, chanType, chanIdx, pOpData );
700a002a: 9807         	ldr	r0, [sp, #0x1c]
700a002c: 9905         	ldr	r1, [sp, #0x14]
700a002e: 9a04         	ldr	r2, [sp, #0x10]
700a0030: 9b0a         	ldr	r3, [sp, #0x28]
700a0032: f005 f845    	bl	0x700a50c0 <CSL_bcdmaChanOpSetBurstSize> @ imm = #0x508a
700a0036: 9003         	str	r0, [sp, #0xc]
;                 break;
700a0038: e00a         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0x14
;                 retVal = CSL_bcdmaChanOpClearError( pCfg, chanType, chanIdx );
700a003a: 9807         	ldr	r0, [sp, #0x1c]
700a003c: 9905         	ldr	r1, [sp, #0x14]
700a003e: 9a04         	ldr	r2, [sp, #0x10]
700a0040: f009 f96e    	bl	0x700a9320 <CSL_bcdmaChanOpClearError> @ imm = #0x92dc
700a0044: 9003         	str	r0, [sp, #0xc]
;                 break;
700a0046: e003         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #0x6
700a0048: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a004c: 9003         	str	r0, [sp, #0xc]
;                 break;
700a004e: e7ff         	b	0x700a0050 <CSL_bcdmaChanOp+0x160> @ imm = #-0x2
700a0050: e7ff         	b	0x700a0052 <CSL_bcdmaChanOp+0x162> @ imm = #-0x2
;     return retVal;
700a0052: 9803         	ldr	r0, [sp, #0xc]
700a0054: b008         	add	sp, #0x20
700a0056: bd80         	pop	{r7, pc}
		...

700a0060 <Udma_chOpen>:
; {
700a0060: b580         	push	{r7, lr}
700a0062: b08a         	sub	sp, #0x28
700a0064: 9009         	str	r0, [sp, #0x24]
700a0066: 9108         	str	r1, [sp, #0x20]
700a0068: 9207         	str	r2, [sp, #0x1c]
700a006a: 9306         	str	r3, [sp, #0x18]
700a006c: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK, tempRetVal;
700a006e: 9005         	str	r0, [sp, #0x14]
;     uint32_t            allocDone = (uint32_t) FALSE;
700a0070: 9003         	str	r0, [sp, #0xc]
;     Udma_DrvHandleInt   drvHandleInt = (Udma_DrvHandleInt) drvHandle;
700a0072: 9809         	ldr	r0, [sp, #0x24]
700a0074: 9001         	str	r0, [sp, #0x4]
;     if((drvHandleInt == NULL_PTR) || (NULL_PTR == chHandle) || (NULL_PTR == chPrms))
700a0076: 9801         	ldr	r0, [sp, #0x4]
700a0078: b130         	cbz	r0, 0x700a0088 <Udma_chOpen+0x28> @ imm = #0xc
700a007a: e7ff         	b	0x700a007c <Udma_chOpen+0x1c> @ imm = #-0x2
700a007c: 9808         	ldr	r0, [sp, #0x20]
700a007e: b118         	cbz	r0, 0x700a0088 <Udma_chOpen+0x28> @ imm = #0x6
700a0080: e7ff         	b	0x700a0082 <Udma_chOpen+0x22> @ imm = #-0x2
700a0082: 9806         	ldr	r0, [sp, #0x18]
700a0084: b920         	cbnz	r0, 0x700a0090 <Udma_chOpen+0x30> @ imm = #0x8
700a0086: e7ff         	b	0x700a0088 <Udma_chOpen+0x28> @ imm = #-0x2
700a0088: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a008c: 9005         	str	r0, [sp, #0x14]
;     }
700a008e: e7ff         	b	0x700a0090 <Udma_chOpen+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a0090: 9805         	ldr	r0, [sp, #0x14]
700a0092: b978         	cbnz	r0, 0x700a00b4 <Udma_chOpen+0x54> @ imm = #0x1e
700a0094: e7ff         	b	0x700a0096 <Udma_chOpen+0x36> @ imm = #-0x2
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
700a0096: 9801         	ldr	r0, [sp, #0x4]
700a0098: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a009c: f64a 31cd    	movw	r1, #0xabcd
700a00a0: f6ca 31dc    	movt	r1, #0xabdc
700a00a4: 4288         	cmp	r0, r1
700a00a6: d004         	beq	0x700a00b2 <Udma_chOpen+0x52> @ imm = #0x8
700a00a8: e7ff         	b	0x700a00aa <Udma_chOpen+0x4a> @ imm = #-0x2
700a00aa: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a00ae: 9005         	str	r0, [sp, #0x14]
;         }
700a00b0: e7ff         	b	0x700a00b2 <Udma_chOpen+0x52> @ imm = #-0x2
;     }
700a00b2: e7ff         	b	0x700a00b4 <Udma_chOpen+0x54> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a00b4: 9805         	ldr	r0, [sp, #0x14]
700a00b6: b938         	cbnz	r0, 0x700a00c8 <Udma_chOpen+0x68> @ imm = #0xe
700a00b8: e7ff         	b	0x700a00ba <Udma_chOpen+0x5a> @ imm = #-0x2
;         retVal = Udma_chCheckParams(drvHandleInt, chType, chPrms);
700a00ba: 9801         	ldr	r0, [sp, #0x4]
700a00bc: 9907         	ldr	r1, [sp, #0x1c]
700a00be: 9a06         	ldr	r2, [sp, #0x18]
700a00c0: f006 f82e    	bl	0x700a6120 <Udma_chCheckParams> @ imm = #0x605c
700a00c4: 9005         	str	r0, [sp, #0x14]
;     }
700a00c6: e7ff         	b	0x700a00c8 <Udma_chOpen+0x68> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a00c8: 9805         	ldr	r0, [sp, #0x14]
700a00ca: 2800         	cmp	r0, #0x0
700a00cc: d145         	bne	0x700a015a <Udma_chOpen+0xfa> @ imm = #0x8a
700a00ce: e7ff         	b	0x700a00d0 <Udma_chOpen+0x70> @ imm = #-0x2
;         chHandleInt = (Udma_ChHandleInt) chHandle;
700a00d0: 9808         	ldr	r0, [sp, #0x20]
700a00d2: 9002         	str	r0, [sp, #0x8]
;         (void) memset(chHandleInt, 0, sizeof(Udma_ChObject));
700a00d4: 9802         	ldr	r0, [sp, #0x8]
700a00d6: f44f 7116    	mov.w	r1, #0x258
700a00da: f7f9 ebac    	blx	0x70099834 <__aeabi_memclr8> @ imm = #-0x68a8
;         (void) memcpy(&chHandleInt->chPrms, chPrms, sizeof(Udma_ChPrms));
700a00de: 9802         	ldr	r0, [sp, #0x8]
700a00e0: 3004         	adds	r0, #0x4
700a00e2: 9906         	ldr	r1, [sp, #0x18]
700a00e4: 2264         	movs	r2, #0x64
700a00e6: f7fa eb78    	blx	0x7009a7d8 <__aeabi_memcpy8> @ imm = #-0x5910
;         chHandleInt->chType            = chType;
700a00ea: 9807         	ldr	r0, [sp, #0x1c]
700a00ec: 9902         	ldr	r1, [sp, #0x8]
700a00ee: 6008         	str	r0, [r1]
;         chHandleInt->drvHandle         = drvHandleInt;
700a00f0: 9801         	ldr	r0, [sp, #0x4]
700a00f2: 9902         	ldr	r1, [sp, #0x8]
700a00f4: 6688         	str	r0, [r1, #0x68]
;         chHandleInt->txChNum           = UDMA_DMA_CH_INVALID;
700a00f6: 9902         	ldr	r1, [sp, #0x8]
700a00f8: 2000         	movs	r0, #0x0
700a00fa: f6cf 70ff    	movt	r0, #0xffff
700a00fe: 66c8         	str	r0, [r1, #0x6c]
;         chHandleInt->rxChNum           = UDMA_DMA_CH_INVALID;
700a0100: 9902         	ldr	r1, [sp, #0x8]
700a0102: 6708         	str	r0, [r1, #0x70]
;         chHandleInt->extChNum          = UDMA_DMA_CH_INVALID;
700a0104: 9902         	ldr	r1, [sp, #0x8]
700a0106: 6748         	str	r0, [r1, #0x74]
;         chHandleInt->pdmaChNum         = UDMA_DMA_CH_INVALID;
700a0108: 9902         	ldr	r1, [sp, #0x8]
700a010a: 6788         	str	r0, [r1, #0x78]
;         chHandleInt->peerThreadId      = UDMA_THREAD_ID_INVALID;
700a010c: 9902         	ldr	r1, [sp, #0x8]
700a010e: 2004         	movs	r0, #0x4
700a0110: f6cf 70ff    	movt	r0, #0xffff
700a0114: 67c8         	str	r0, [r1, #0x7c]
;         chHandleInt->fqRing            = (Udma_RingHandleInt) NULL_PTR;
700a0116: 9902         	ldr	r1, [sp, #0x8]
700a0118: 2000         	movs	r0, #0x0
700a011a: 9000         	str	r0, [sp]
700a011c: f8c1 0080    	str.w	r0, [r1, #0x80]
;         chHandleInt->cqRing            = (Udma_RingHandleInt) NULL_PTR;
700a0120: 9902         	ldr	r1, [sp, #0x8]
700a0122: f8c1 0084    	str.w	r0, [r1, #0x84]
;         chHandleInt->tdCqRing          = (Udma_RingHandleInt) NULL_PTR;
700a0126: 9902         	ldr	r1, [sp, #0x8]
700a0128: f8c1 0088    	str.w	r0, [r1, #0x88]
;         UdmaChTxPrms_init(&chHandleInt->txPrms, chType);
700a012c: 9802         	ldr	r0, [sp, #0x8]
700a012e: f500 70f2    	add.w	r0, r0, #0x1e4
700a0132: 9907         	ldr	r1, [sp, #0x1c]
700a0134: f006 f9ac    	bl	0x700a6490 <UdmaChTxPrms_init> @ imm = #0x6358
;         UdmaChRxPrms_init(&chHandleInt->rxPrms, chType);
700a0138: 9802         	ldr	r0, [sp, #0x8]
700a013a: f500 70fc    	add.w	r0, r0, #0x1f8
700a013e: 9907         	ldr	r1, [sp, #0x1c]
700a0140: f006 f94e    	bl	0x700a63e0 <UdmaChRxPrms_init> @ imm = #0x629c
;         Udma_chInitRegs(chHandleInt);
700a0144: 9802         	ldr	r0, [sp, #0x8]
700a0146: f00b f973    	bl	0x700ab430 <Udma_chInitRegs> @ imm = #0xb2e6
700a014a: 9800         	ldr	r0, [sp]
;         chHandleInt->chOesAllocDone    = FALSE;
700a014c: 9902         	ldr	r1, [sp, #0x8]
700a014e: f8c1 0248    	str.w	r0, [r1, #0x248]
;         chHandleInt->trigger           = CSL_UDMAP_TR_FLAGS_TRIGGER_NONE;
700a0152: 9902         	ldr	r1, [sp, #0x8]
700a0154: f8c1 024c    	str.w	r0, [r1, #0x24c]
;     }
700a0158: e7ff         	b	0x700a015a <Udma_chOpen+0xfa> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a015a: 9805         	ldr	r0, [sp, #0x14]
700a015c: b960         	cbnz	r0, 0x700a0178 <Udma_chOpen+0x118> @ imm = #0x18
700a015e: e7ff         	b	0x700a0160 <Udma_chOpen+0x100> @ imm = #-0x2
;         retVal = Udma_chAllocResource(chHandleInt);
700a0160: 9802         	ldr	r0, [sp, #0x8]
700a0162: f7fa fd55    	bl	0x7009ac10 <Udma_chAllocResource> @ imm = #-0x5556
700a0166: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK == retVal)
700a0168: 9805         	ldr	r0, [sp, #0x14]
700a016a: b918         	cbnz	r0, 0x700a0174 <Udma_chOpen+0x114> @ imm = #0x6
700a016c: e7ff         	b	0x700a016e <Udma_chOpen+0x10e> @ imm = #-0x2
700a016e: 2001         	movs	r0, #0x1
;             allocDone = (uint32_t) TRUE;
700a0170: 9003         	str	r0, [sp, #0xc]
;         }
700a0172: e000         	b	0x700a0176 <Udma_chOpen+0x116> @ imm = #0x0
700a0174: e7ff         	b	0x700a0176 <Udma_chOpen+0x116> @ imm = #-0x2
;     }
700a0176: e7ff         	b	0x700a0178 <Udma_chOpen+0x118> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a0178: 9805         	ldr	r0, [sp, #0x14]
700a017a: b948         	cbnz	r0, 0x700a0190 <Udma_chOpen+0x130> @ imm = #0x12
700a017c: e7ff         	b	0x700a017e <Udma_chOpen+0x11e> @ imm = #-0x2
;         retVal = Udma_chPair(chHandleInt);
700a017e: 9802         	ldr	r0, [sp, #0x8]
700a0180: f008 fdbe    	bl	0x700a8d00 <Udma_chPair> @ imm = #0x8b7c
700a0184: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK != retVal)
700a0186: 9805         	ldr	r0, [sp, #0x14]
700a0188: b108         	cbz	r0, 0x700a018e <Udma_chOpen+0x12e> @ imm = #0x2
700a018a: e7ff         	b	0x700a018c <Udma_chOpen+0x12c> @ imm = #-0x2
;         }
700a018c: e7ff         	b	0x700a018e <Udma_chOpen+0x12e> @ imm = #-0x2
;     }
700a018e: e7ff         	b	0x700a0190 <Udma_chOpen+0x130> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a0190: 9805         	ldr	r0, [sp, #0x14]
700a0192: b940         	cbnz	r0, 0x700a01a6 <Udma_chOpen+0x146> @ imm = #0x10
700a0194: e7ff         	b	0x700a0196 <Udma_chOpen+0x136> @ imm = #-0x2
;         chHandleInt->chInitDone = UDMA_INIT_DONE;
700a0196: 9902         	ldr	r1, [sp, #0x8]
700a0198: f64a 30cd    	movw	r0, #0xabcd
700a019c: f6ca 30dc    	movt	r0, #0xabdc
700a01a0: f8c1 0244    	str.w	r0, [r1, #0x244]
;     }
700a01a4: e00d         	b	0x700a01c2 <Udma_chOpen+0x162> @ imm = #0x1a
;         if(((uint32_t) TRUE) == allocDone)
700a01a6: 9803         	ldr	r0, [sp, #0xc]
700a01a8: 2801         	cmp	r0, #0x1
700a01aa: d109         	bne	0x700a01c0 <Udma_chOpen+0x160> @ imm = #0x12
700a01ac: e7ff         	b	0x700a01ae <Udma_chOpen+0x14e> @ imm = #-0x2
;             tempRetVal = Udma_chFreeResource(chHandleInt);
700a01ae: 9802         	ldr	r0, [sp, #0x8]
700a01b0: f7fd fb5e    	bl	0x7009d870 <Udma_chFreeResource> @ imm = #-0x2944
700a01b4: 9004         	str	r0, [sp, #0x10]
;             if(UDMA_SOK != tempRetVal)
700a01b6: 9804         	ldr	r0, [sp, #0x10]
700a01b8: b108         	cbz	r0, 0x700a01be <Udma_chOpen+0x15e> @ imm = #0x2
700a01ba: e7ff         	b	0x700a01bc <Udma_chOpen+0x15c> @ imm = #-0x2
;             }
700a01bc: e7ff         	b	0x700a01be <Udma_chOpen+0x15e> @ imm = #-0x2
;         }
700a01be: e7ff         	b	0x700a01c0 <Udma_chOpen+0x160> @ imm = #-0x2
700a01c0: e7ff         	b	0x700a01c2 <Udma_chOpen+0x162> @ imm = #-0x2
;     return (retVal);
700a01c2: 9805         	ldr	r0, [sp, #0x14]
700a01c4: b00a         	add	sp, #0x28
700a01c6: bd80         	pop	{r7, pc}
		...

700a01d0 <Udma_rmAllocMappedRxCh>:
; {
700a01d0: b580         	push	{r7, lr}
700a01d2: b08a         	sub	sp, #0x28
700a01d4: 9009         	str	r0, [sp, #0x24]
700a01d6: 9108         	str	r1, [sp, #0x20]
700a01d8: 9207         	str	r2, [sp, #0x1c]
700a01da: 2000         	movs	r0, #0x0
700a01dc: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a01e0: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a01e2: 9808         	ldr	r0, [sp, #0x20]
700a01e4: f500 70ea    	add.w	r0, r0, #0x1d4
700a01e8: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a01ea: 9808         	ldr	r0, [sp, #0x20]
700a01ec: f500 609f    	add.w	r0, r0, #0x4f8
700a01f0: f04f 31ff    	mov.w	r1, #0xffffffff
700a01f4: f008 fd3c    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x8a78
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a01f8: 9809         	ldr	r0, [sp, #0x24]
700a01fa: 2101         	movs	r1, #0x1
700a01fc: f6cf 71ff    	movt	r1, #0xffff
700a0200: 4288         	cmp	r0, r1
700a0202: d142         	bne	0x700a028a <Udma_rmAllocMappedRxCh+0xba> @ imm = #0x84
700a0204: e7ff         	b	0x700a0206 <Udma_rmAllocMappedRxCh+0x36> @ imm = #-0x2
700a0206: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numMappedRxCh[mappedChGrp]; i++)
700a0208: 9005         	str	r0, [sp, #0x14]
700a020a: e7ff         	b	0x700a020c <Udma_rmAllocMappedRxCh+0x3c> @ imm = #-0x2
700a020c: 9805         	ldr	r0, [sp, #0x14]
700a020e: 9901         	ldr	r1, [sp, #0x4]
700a0210: 9a07         	ldr	r2, [sp, #0x1c]
700a0212: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0216: 6f89         	ldr	r1, [r1, #0x78]
700a0218: 4288         	cmp	r0, r1
700a021a: d235         	bhs	0x700a0288 <Udma_rmAllocMappedRxCh+0xb8> @ imm = #0x6a
700a021c: e7ff         	b	0x700a021e <Udma_rmAllocMappedRxCh+0x4e> @ imm = #-0x2
;             offset = i >> 5U;
700a021e: 9805         	ldr	r0, [sp, #0x14]
700a0220: 0940         	lsrs	r0, r0, #0x5
700a0222: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a0224: 9805         	ldr	r0, [sp, #0x14]
700a0226: 9904         	ldr	r1, [sp, #0x10]
700a0228: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a022c: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a022e: 9903         	ldr	r1, [sp, #0xc]
700a0230: 2001         	movs	r0, #0x1
700a0232: 4088         	lsls	r0, r1
700a0234: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedRxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a0236: 9808         	ldr	r0, [sp, #0x20]
700a0238: 9907         	ldr	r1, [sp, #0x1c]
700a023a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a023e: 9904         	ldr	r1, [sp, #0x10]
700a0240: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0244: f8d0 0334    	ldr.w	r0, [r0, #0x334]
700a0248: 9902         	ldr	r1, [sp, #0x8]
700a024a: 4008         	ands	r0, r1
700a024c: 4288         	cmp	r0, r1
700a024e: d116         	bne	0x700a027e <Udma_rmAllocMappedRxCh+0xae> @ imm = #0x2c
700a0250: e7ff         	b	0x700a0252 <Udma_rmAllocMappedRxCh+0x82> @ imm = #-0x2
;                 drvHandle->mappedRxChFlag[mappedChGrp][offset] &= ~bitMask;
700a0252: 9a02         	ldr	r2, [sp, #0x8]
700a0254: 9808         	ldr	r0, [sp, #0x20]
700a0256: 9907         	ldr	r1, [sp, #0x1c]
700a0258: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a025c: 9904         	ldr	r1, [sp, #0x10]
700a025e: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a0262: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700a0266: 4390         	bics	r0, r2
700a0268: f8c1 0334    	str.w	r0, [r1, #0x334]
;                 chNum = i + rmInitPrms->startMappedRxCh[mappedChGrp];  /* Add start offset */
700a026c: 9805         	ldr	r0, [sp, #0x14]
700a026e: 9901         	ldr	r1, [sp, #0x4]
700a0270: 9a07         	ldr	r2, [sp, #0x1c]
700a0272: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0276: 6e89         	ldr	r1, [r1, #0x68]
700a0278: 4408         	add	r0, r1
700a027a: 9006         	str	r0, [sp, #0x18]
;                 break;
700a027c: e004         	b	0x700a0288 <Udma_rmAllocMappedRxCh+0xb8> @ imm = #0x8
;         }
700a027e: e7ff         	b	0x700a0280 <Udma_rmAllocMappedRxCh+0xb0> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numMappedRxCh[mappedChGrp]; i++)
700a0280: 9805         	ldr	r0, [sp, #0x14]
700a0282: 3001         	adds	r0, #0x1
700a0284: 9005         	str	r0, [sp, #0x14]
700a0286: e7c1         	b	0x700a020c <Udma_rmAllocMappedRxCh+0x3c> @ imm = #-0x7e
;     }
700a0288: e047         	b	0x700a031a <Udma_rmAllocMappedRxCh+0x14a> @ imm = #0x8e
;         if((preferredChNum >= rmInitPrms->startMappedRxCh[mappedChGrp]) &&
700a028a: 9809         	ldr	r0, [sp, #0x24]
700a028c: 9901         	ldr	r1, [sp, #0x4]
700a028e: 9a07         	ldr	r2, [sp, #0x1c]
700a0290: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0294: 6e89         	ldr	r1, [r1, #0x68]
700a0296: 4288         	cmp	r0, r1
700a0298: d33e         	blo	0x700a0318 <Udma_rmAllocMappedRxCh+0x148> @ imm = #0x7c
700a029a: e7ff         	b	0x700a029c <Udma_rmAllocMappedRxCh+0xcc> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startMappedRxCh[mappedChGrp] + rmInitPrms->numMappedRxCh[mappedChGrp])))
700a029c: 9809         	ldr	r0, [sp, #0x24]
700a029e: 9901         	ldr	r1, [sp, #0x4]
700a02a0: 9a07         	ldr	r2, [sp, #0x1c]
700a02a2: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a02a6: 6e91         	ldr	r1, [r2, #0x68]
700a02a8: 6f92         	ldr	r2, [r2, #0x78]
700a02aa: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startMappedRxCh[mappedChGrp]) &&
700a02ac: 4288         	cmp	r0, r1
700a02ae: d233         	bhs	0x700a0318 <Udma_rmAllocMappedRxCh+0x148> @ imm = #0x66
700a02b0: e7ff         	b	0x700a02b2 <Udma_rmAllocMappedRxCh+0xe2> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startMappedRxCh[mappedChGrp];
700a02b2: 9809         	ldr	r0, [sp, #0x24]
700a02b4: 9901         	ldr	r1, [sp, #0x4]
700a02b6: 9a07         	ldr	r2, [sp, #0x1c]
700a02b8: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a02bc: 6e89         	ldr	r1, [r1, #0x68]
700a02be: 1a40         	subs	r0, r0, r1
700a02c0: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a02c2: 9805         	ldr	r0, [sp, #0x14]
700a02c4: 0940         	lsrs	r0, r0, #0x5
700a02c6: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a02c8: 9805         	ldr	r0, [sp, #0x14]
700a02ca: 9904         	ldr	r1, [sp, #0x10]
700a02cc: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a02d0: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a02d2: 9903         	ldr	r1, [sp, #0xc]
700a02d4: 2001         	movs	r0, #0x1
700a02d6: 4088         	lsls	r0, r1
700a02d8: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedRxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a02da: 9808         	ldr	r0, [sp, #0x20]
700a02dc: 9907         	ldr	r1, [sp, #0x1c]
700a02de: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a02e2: 9904         	ldr	r1, [sp, #0x10]
700a02e4: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a02e8: f8d0 0334    	ldr.w	r0, [r0, #0x334]
700a02ec: 9902         	ldr	r1, [sp, #0x8]
700a02ee: 4008         	ands	r0, r1
700a02f0: 4288         	cmp	r0, r1
700a02f2: d110         	bne	0x700a0316 <Udma_rmAllocMappedRxCh+0x146> @ imm = #0x20
700a02f4: e7ff         	b	0x700a02f6 <Udma_rmAllocMappedRxCh+0x126> @ imm = #-0x2
;                 drvHandle->mappedRxChFlag[mappedChGrp][offset] &= ~bitMask;
700a02f6: 9a02         	ldr	r2, [sp, #0x8]
700a02f8: 9808         	ldr	r0, [sp, #0x20]
700a02fa: 9907         	ldr	r1, [sp, #0x1c]
700a02fc: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0300: 9904         	ldr	r1, [sp, #0x10]
700a0302: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a0306: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700a030a: 4390         	bics	r0, r2
700a030c: f8c1 0334    	str.w	r0, [r1, #0x334]
;                 chNum = preferredChNum;
700a0310: 9809         	ldr	r0, [sp, #0x24]
700a0312: 9006         	str	r0, [sp, #0x18]
;             }
700a0314: e7ff         	b	0x700a0316 <Udma_rmAllocMappedRxCh+0x146> @ imm = #-0x2
;         }
700a0316: e7ff         	b	0x700a0318 <Udma_rmAllocMappedRxCh+0x148> @ imm = #-0x2
700a0318: e7ff         	b	0x700a031a <Udma_rmAllocMappedRxCh+0x14a> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a031a: 9808         	ldr	r0, [sp, #0x20]
700a031c: f500 609f    	add.w	r0, r0, #0x4f8
700a0320: f009 fff6    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x9fec
;     return (chNum);
700a0324: 9806         	ldr	r0, [sp, #0x18]
700a0326: b00a         	add	sp, #0x28
700a0328: bd80         	pop	{r7, pc}
700a032a: 0000         	movs	r0, r0
700a032c: 0000         	movs	r0, r0
700a032e: 0000         	movs	r0, r0

700a0330 <Udma_rmAllocMappedTxCh>:
; {
700a0330: b580         	push	{r7, lr}
700a0332: b08a         	sub	sp, #0x28
700a0334: 9009         	str	r0, [sp, #0x24]
700a0336: 9108         	str	r1, [sp, #0x20]
700a0338: 9207         	str	r2, [sp, #0x1c]
700a033a: 2000         	movs	r0, #0x0
700a033c: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a0340: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a0342: 9808         	ldr	r0, [sp, #0x20]
700a0344: f500 70ea    	add.w	r0, r0, #0x1d4
700a0348: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a034a: 9808         	ldr	r0, [sp, #0x20]
700a034c: f500 609f    	add.w	r0, r0, #0x4f8
700a0350: f04f 31ff    	mov.w	r1, #0xffffffff
700a0354: f008 fc8c    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x8918
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a0358: 9809         	ldr	r0, [sp, #0x24]
700a035a: 2101         	movs	r1, #0x1
700a035c: f6cf 71ff    	movt	r1, #0xffff
700a0360: 4288         	cmp	r0, r1
700a0362: d142         	bne	0x700a03ea <Udma_rmAllocMappedTxCh+0xba> @ imm = #0x84
700a0364: e7ff         	b	0x700a0366 <Udma_rmAllocMappedTxCh+0x36> @ imm = #-0x2
700a0366: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numMappedTxCh[mappedChGrp]; i++)
700a0368: 9005         	str	r0, [sp, #0x14]
700a036a: e7ff         	b	0x700a036c <Udma_rmAllocMappedTxCh+0x3c> @ imm = #-0x2
700a036c: 9805         	ldr	r0, [sp, #0x14]
700a036e: 9901         	ldr	r1, [sp, #0x4]
700a0370: 9a07         	ldr	r2, [sp, #0x1c]
700a0372: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0376: 6d89         	ldr	r1, [r1, #0x58]
700a0378: 4288         	cmp	r0, r1
700a037a: d235         	bhs	0x700a03e8 <Udma_rmAllocMappedTxCh+0xb8> @ imm = #0x6a
700a037c: e7ff         	b	0x700a037e <Udma_rmAllocMappedTxCh+0x4e> @ imm = #-0x2
;             offset = i >> 5U;
700a037e: 9805         	ldr	r0, [sp, #0x14]
700a0380: 0940         	lsrs	r0, r0, #0x5
700a0382: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a0384: 9805         	ldr	r0, [sp, #0x14]
700a0386: 9904         	ldr	r1, [sp, #0x10]
700a0388: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a038c: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a038e: 9903         	ldr	r1, [sp, #0xc]
700a0390: 2001         	movs	r0, #0x1
700a0392: 4088         	lsls	r0, r1
700a0394: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedTxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a0396: 9808         	ldr	r0, [sp, #0x20]
700a0398: 9907         	ldr	r1, [sp, #0x1c]
700a039a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a039e: 9904         	ldr	r1, [sp, #0x10]
700a03a0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a03a4: f8d0 0324    	ldr.w	r0, [r0, #0x324]
700a03a8: 9902         	ldr	r1, [sp, #0x8]
700a03aa: 4008         	ands	r0, r1
700a03ac: 4288         	cmp	r0, r1
700a03ae: d116         	bne	0x700a03de <Udma_rmAllocMappedTxCh+0xae> @ imm = #0x2c
700a03b0: e7ff         	b	0x700a03b2 <Udma_rmAllocMappedTxCh+0x82> @ imm = #-0x2
;                 drvHandle->mappedTxChFlag[mappedChGrp][offset] &= ~bitMask;
700a03b2: 9a02         	ldr	r2, [sp, #0x8]
700a03b4: 9808         	ldr	r0, [sp, #0x20]
700a03b6: 9907         	ldr	r1, [sp, #0x1c]
700a03b8: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a03bc: 9904         	ldr	r1, [sp, #0x10]
700a03be: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a03c2: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a03c6: 4390         	bics	r0, r2
700a03c8: f8c1 0324    	str.w	r0, [r1, #0x324]
;                 chNum = i + rmInitPrms->startMappedTxCh[mappedChGrp];  /* Add start offset */
700a03cc: 9805         	ldr	r0, [sp, #0x14]
700a03ce: 9901         	ldr	r1, [sp, #0x4]
700a03d0: 9a07         	ldr	r2, [sp, #0x1c]
700a03d2: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a03d6: 6c89         	ldr	r1, [r1, #0x48]
700a03d8: 4408         	add	r0, r1
700a03da: 9006         	str	r0, [sp, #0x18]
;                 break;
700a03dc: e004         	b	0x700a03e8 <Udma_rmAllocMappedTxCh+0xb8> @ imm = #0x8
;         }
700a03de: e7ff         	b	0x700a03e0 <Udma_rmAllocMappedTxCh+0xb0> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numMappedTxCh[mappedChGrp]; i++)
700a03e0: 9805         	ldr	r0, [sp, #0x14]
700a03e2: 3001         	adds	r0, #0x1
700a03e4: 9005         	str	r0, [sp, #0x14]
700a03e6: e7c1         	b	0x700a036c <Udma_rmAllocMappedTxCh+0x3c> @ imm = #-0x7e
;     }
700a03e8: e047         	b	0x700a047a <Udma_rmAllocMappedTxCh+0x14a> @ imm = #0x8e
;         if((preferredChNum >= rmInitPrms->startMappedTxCh[mappedChGrp]) &&
700a03ea: 9809         	ldr	r0, [sp, #0x24]
700a03ec: 9901         	ldr	r1, [sp, #0x4]
700a03ee: 9a07         	ldr	r2, [sp, #0x1c]
700a03f0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a03f4: 6c89         	ldr	r1, [r1, #0x48]
700a03f6: 4288         	cmp	r0, r1
700a03f8: d33e         	blo	0x700a0478 <Udma_rmAllocMappedTxCh+0x148> @ imm = #0x7c
700a03fa: e7ff         	b	0x700a03fc <Udma_rmAllocMappedTxCh+0xcc> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startMappedTxCh[mappedChGrp] + rmInitPrms->numMappedTxCh[mappedChGrp])))
700a03fc: 9809         	ldr	r0, [sp, #0x24]
700a03fe: 9901         	ldr	r1, [sp, #0x4]
700a0400: 9a07         	ldr	r2, [sp, #0x1c]
700a0402: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a0406: 6c91         	ldr	r1, [r2, #0x48]
700a0408: 6d92         	ldr	r2, [r2, #0x58]
700a040a: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startMappedTxCh[mappedChGrp]) &&
700a040c: 4288         	cmp	r0, r1
700a040e: d233         	bhs	0x700a0478 <Udma_rmAllocMappedTxCh+0x148> @ imm = #0x66
700a0410: e7ff         	b	0x700a0412 <Udma_rmAllocMappedTxCh+0xe2> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startMappedTxCh[mappedChGrp];
700a0412: 9809         	ldr	r0, [sp, #0x24]
700a0414: 9901         	ldr	r1, [sp, #0x4]
700a0416: 9a07         	ldr	r2, [sp, #0x1c]
700a0418: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a041c: 6c89         	ldr	r1, [r1, #0x48]
700a041e: 1a40         	subs	r0, r0, r1
700a0420: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a0422: 9805         	ldr	r0, [sp, #0x14]
700a0424: 0940         	lsrs	r0, r0, #0x5
700a0426: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a0428: 9805         	ldr	r0, [sp, #0x14]
700a042a: 9904         	ldr	r1, [sp, #0x10]
700a042c: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a0430: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a0432: 9903         	ldr	r1, [sp, #0xc]
700a0434: 2001         	movs	r0, #0x1
700a0436: 4088         	lsls	r0, r1
700a0438: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedTxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a043a: 9808         	ldr	r0, [sp, #0x20]
700a043c: 9907         	ldr	r1, [sp, #0x1c]
700a043e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0442: 9904         	ldr	r1, [sp, #0x10]
700a0444: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0448: f8d0 0324    	ldr.w	r0, [r0, #0x324]
700a044c: 9902         	ldr	r1, [sp, #0x8]
700a044e: 4008         	ands	r0, r1
700a0450: 4288         	cmp	r0, r1
700a0452: d110         	bne	0x700a0476 <Udma_rmAllocMappedTxCh+0x146> @ imm = #0x20
700a0454: e7ff         	b	0x700a0456 <Udma_rmAllocMappedTxCh+0x126> @ imm = #-0x2
;                 drvHandle->mappedTxChFlag[mappedChGrp][offset] &= ~bitMask;
700a0456: 9a02         	ldr	r2, [sp, #0x8]
700a0458: 9808         	ldr	r0, [sp, #0x20]
700a045a: 9907         	ldr	r1, [sp, #0x1c]
700a045c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0460: 9904         	ldr	r1, [sp, #0x10]
700a0462: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a0466: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a046a: 4390         	bics	r0, r2
700a046c: f8c1 0324    	str.w	r0, [r1, #0x324]
;                 chNum = preferredChNum;
700a0470: 9809         	ldr	r0, [sp, #0x24]
700a0472: 9006         	str	r0, [sp, #0x18]
;             }
700a0474: e7ff         	b	0x700a0476 <Udma_rmAllocMappedTxCh+0x146> @ imm = #-0x2
;         }
700a0476: e7ff         	b	0x700a0478 <Udma_rmAllocMappedTxCh+0x148> @ imm = #-0x2
700a0478: e7ff         	b	0x700a047a <Udma_rmAllocMappedTxCh+0x14a> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a047a: 9808         	ldr	r0, [sp, #0x20]
700a047c: f500 609f    	add.w	r0, r0, #0x4f8
700a0480: f009 ff46    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x9e8c
;     return (chNum);
700a0484: 9806         	ldr	r0, [sp, #0x18]
700a0486: b00a         	add	sp, #0x28
700a0488: bd80         	pop	{r7, pc}
700a048a: 0000         	movs	r0, r0
700a048c: 0000         	movs	r0, r0
700a048e: 0000         	movs	r0, r0

700a0490 <CSL_bcdmaChanOpGetChanStats>:
; {
700a0490: b580         	push	{r7, lr}
700a0492: b088         	sub	sp, #0x20
700a0494: 9007         	str	r0, [sp, #0x1c]
700a0496: 9106         	str	r1, [sp, #0x18]
700a0498: 9205         	str	r2, [sp, #0x14]
700a049a: 9304         	str	r3, [sp, #0x10]
700a049c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a049e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a04a0: 9804         	ldr	r0, [sp, #0x10]
700a04a2: b920         	cbnz	r0, 0x700a04ae <CSL_bcdmaChanOpGetChanStats+0x1e> @ imm = #0x8
700a04a4: e7ff         	b	0x700a04a6 <CSL_bcdmaChanOpGetChanStats+0x16> @ imm = #-0x2
700a04a6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a04aa: 9003         	str	r0, [sp, #0xc]
;     }
700a04ac: e099         	b	0x700a05e2 <CSL_bcdmaChanOpGetChanStats+0x152> @ imm = #0x132
;         CSL_BcdmaChanStats *pChanStats = (CSL_BcdmaChanStats *)pOpData;
700a04ae: 9804         	ldr	r0, [sp, #0x10]
700a04b0: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a04b2: 9806         	ldr	r0, [sp, #0x18]
700a04b4: 9001         	str	r0, [sp, #0x4]
700a04b6: b140         	cbz	r0, 0x700a04ca <CSL_bcdmaChanOpGetChanStats+0x3a> @ imm = #0x10
700a04b8: e7ff         	b	0x700a04ba <CSL_bcdmaChanOpGetChanStats+0x2a> @ imm = #-0x2
700a04ba: 9801         	ldr	r0, [sp, #0x4]
700a04bc: 2801         	cmp	r0, #0x1
700a04be: d031         	beq	0x700a0524 <CSL_bcdmaChanOpGetChanStats+0x94> @ imm = #0x62
700a04c0: e7ff         	b	0x700a04c2 <CSL_bcdmaChanOpGetChanStats+0x32> @ imm = #-0x2
700a04c2: 9801         	ldr	r0, [sp, #0x4]
700a04c4: 2802         	cmp	r0, #0x2
700a04c6: d05a         	beq	0x700a057e <CSL_bcdmaChanOpGetChanStats+0xee> @ imm = #0xb4
700a04c8: e086         	b	0x700a05d8 <CSL_bcdmaChanOpGetChanStats+0x148> @ imm = #0x10c
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].PCNT );
700a04ca: 9807         	ldr	r0, [sp, #0x1c]
700a04cc: 6880         	ldr	r0, [r0, #0x8]
700a04ce: 9905         	ldr	r1, [sp, #0x14]
700a04d0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a04d4: f500 6080    	add.w	r0, r0, #0x400
700a04d8: f00d fdca    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0xdb94
700a04dc: 9902         	ldr	r1, [sp, #0x8]
700a04de: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].BCNT );
700a04e0: 9807         	ldr	r0, [sp, #0x1c]
700a04e2: 6880         	ldr	r0, [r0, #0x8]
700a04e4: 9905         	ldr	r1, [sp, #0x14]
700a04e6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a04ea: f500 6081    	add.w	r0, r0, #0x408
700a04ee: f00d fdbf    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0xdb7e
700a04f2: 9902         	ldr	r1, [sp, #0x8]
700a04f4: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].SBCNT );
700a04f6: 9807         	ldr	r0, [sp, #0x1c]
700a04f8: 6880         	ldr	r0, [r0, #0x8]
700a04fa: 9905         	ldr	r1, [sp, #0x14]
700a04fc: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a0500: f500 6082    	add.w	r0, r0, #0x410
700a0504: f00d fdb4    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0xdb68
700a0508: 9902         	ldr	r1, [sp, #0x8]
700a050a: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = (uint32_t)0U;
700a050c: 9902         	ldr	r1, [sp, #0x8]
700a050e: 2000         	movs	r0, #0x0
700a0510: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = (uint32_t)0U;
700a0512: 9902         	ldr	r1, [sp, #0x8]
700a0514: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->txPayloadByteCnt;
700a0516: 9902         	ldr	r1, [sp, #0x8]
700a0518: 6848         	ldr	r0, [r1, #0x4]
700a051a: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->txStartedByteCnt;
700a051c: 9902         	ldr	r1, [sp, #0x8]
700a051e: 6888         	ldr	r0, [r1, #0x8]
700a0520: 6188         	str	r0, [r1, #0x18]
;                 break;
700a0522: e05d         	b	0x700a05e0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0xba
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].PCNT );
700a0524: 9807         	ldr	r0, [sp, #0x1c]
700a0526: 6900         	ldr	r0, [r0, #0x10]
700a0528: 9905         	ldr	r1, [sp, #0x14]
700a052a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a052e: f500 6080    	add.w	r0, r0, #0x400
700a0532: f00d fd9d    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0xdb3a
700a0536: 9902         	ldr	r1, [sp, #0x8]
700a0538: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].BCNT );
700a053a: 9807         	ldr	r0, [sp, #0x1c]
700a053c: 6900         	ldr	r0, [r0, #0x10]
700a053e: 9905         	ldr	r1, [sp, #0x14]
700a0540: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a0544: f500 6081    	add.w	r0, r0, #0x408
700a0548: f00d fd92    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0xdb24
700a054c: 9902         	ldr	r1, [sp, #0x8]
700a054e: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].SBCNT );
700a0550: 9807         	ldr	r0, [sp, #0x1c]
700a0552: 6900         	ldr	r0, [r0, #0x10]
700a0554: 9905         	ldr	r1, [sp, #0x14]
700a0556: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a055a: f500 6082    	add.w	r0, r0, #0x410
700a055e: f00d fd87    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0xdb0e
700a0562: 9902         	ldr	r1, [sp, #0x8]
700a0564: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = (uint32_t)0U;
700a0566: 9902         	ldr	r1, [sp, #0x8]
700a0568: 2000         	movs	r0, #0x0
700a056a: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = (uint32_t)0U;
700a056c: 9902         	ldr	r1, [sp, #0x8]
700a056e: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->txPayloadByteCnt;
700a0570: 9902         	ldr	r1, [sp, #0x8]
700a0572: 6848         	ldr	r0, [r1, #0x4]
700a0574: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->txStartedByteCnt;
700a0576: 9902         	ldr	r1, [sp, #0x8]
700a0578: 6888         	ldr	r0, [r1, #0x8]
700a057a: 6188         	str	r0, [r1, #0x18]
;                 break;
700a057c: e030         	b	0x700a05e0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0x60
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].PCNT );
700a057e: 9807         	ldr	r0, [sp, #0x1c]
700a0580: 6980         	ldr	r0, [r0, #0x18]
700a0582: 9905         	ldr	r1, [sp, #0x14]
700a0584: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a0588: f500 6080    	add.w	r0, r0, #0x400
700a058c: f00d fd70    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0xdae0
700a0590: 9902         	ldr	r1, [sp, #0x8]
700a0592: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = (uint32_t)0U;
700a0594: 9902         	ldr	r1, [sp, #0x8]
700a0596: 2000         	movs	r0, #0x0
700a0598: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = (uint32_t)0U;
700a059a: 9902         	ldr	r1, [sp, #0x8]
700a059c: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].BCNT );
700a059e: 9807         	ldr	r0, [sp, #0x1c]
700a05a0: 6980         	ldr	r0, [r0, #0x18]
700a05a2: 9905         	ldr	r1, [sp, #0x14]
700a05a4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a05a8: f500 6081    	add.w	r0, r0, #0x408
700a05ac: f00d fd60    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0xdac0
700a05b0: 9902         	ldr	r1, [sp, #0x8]
700a05b2: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].SBCNT );
700a05b4: 9807         	ldr	r0, [sp, #0x1c]
700a05b6: 6980         	ldr	r0, [r0, #0x18]
700a05b8: 9905         	ldr	r1, [sp, #0x14]
700a05ba: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a05be: f500 6082    	add.w	r0, r0, #0x410
700a05c2: f00d fd55    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0xdaaa
700a05c6: 9902         	ldr	r1, [sp, #0x8]
700a05c8: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->rxPayloadByteCnt;
700a05ca: 9902         	ldr	r1, [sp, #0x8]
700a05cc: 68c8         	ldr	r0, [r1, #0xc]
700a05ce: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->rxStartedByteCnt;
700a05d0: 9902         	ldr	r1, [sp, #0x8]
700a05d2: 6908         	ldr	r0, [r1, #0x10]
700a05d4: 6188         	str	r0, [r1, #0x18]
;                 break;
700a05d6: e003         	b	0x700a05e0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0x6
700a05d8: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a05dc: 9003         	str	r0, [sp, #0xc]
;                 break;
700a05de: e7ff         	b	0x700a05e0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #-0x2
700a05e0: e7ff         	b	0x700a05e2 <CSL_bcdmaChanOpGetChanStats+0x152> @ imm = #-0x2
;     return retVal;
700a05e2: 9803         	ldr	r0, [sp, #0xc]
700a05e4: b008         	add	sp, #0x20
700a05e6: bd80         	pop	{r7, pc}
		...

700a05f0 <UART_lld_initDma>:
; {
700a05f0: b580         	push	{r7, lr}
700a05f2: b084         	sub	sp, #0x10
700a05f4: 9003         	str	r0, [sp, #0xc]
700a05f6: 2000         	movs	r0, #0x0
;     int32_t                status = UART_STATUS_SUCCESS;
700a05f8: 9002         	str	r0, [sp, #0x8]
;     if((hUart != NULL_PTR) && (hUart->hUartInit != NULL_PTR))
700a05fa: 9803         	ldr	r0, [sp, #0xc]
700a05fc: b168         	cbz	r0, 0x700a061a <UART_lld_initDma+0x2a> @ imm = #0x1a
700a05fe: e7ff         	b	0x700a0600 <UART_lld_initDma+0x10> @ imm = #-0x2
700a0600: 9803         	ldr	r0, [sp, #0xc]
700a0602: 6840         	ldr	r0, [r0, #0x4]
700a0604: b148         	cbz	r0, 0x700a061a <UART_lld_initDma+0x2a> @ imm = #0x12
700a0606: e7ff         	b	0x700a0608 <UART_lld_initDma+0x18> @ imm = #-0x2
;         if(hUart->state != UART_STATE_RESET)
700a0608: 9803         	ldr	r0, [sp, #0xc]
700a060a: 6d40         	ldr	r0, [r0, #0x54]
700a060c: b120         	cbz	r0, 0x700a0618 <UART_lld_initDma+0x28> @ imm = #0x8
700a060e: e7ff         	b	0x700a0610 <UART_lld_initDma+0x20> @ imm = #-0x2
700a0610: f06f 0004    	mvn	r0, #0x4
;             status = UART_TRANSFER_INVALID_STATE;
700a0614: 9002         	str	r0, [sp, #0x8]
;         }
700a0616: e7ff         	b	0x700a0618 <UART_lld_initDma+0x28> @ imm = #-0x2
;     }
700a0618: e003         	b	0x700a0622 <UART_lld_initDma+0x32> @ imm = #0x6
700a061a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a061e: 9002         	str	r0, [sp, #0x8]
700a0620: e7ff         	b	0x700a0622 <UART_lld_initDma+0x32> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a0622: 9802         	ldr	r0, [sp, #0x8]
700a0624: 2800         	cmp	r0, #0x0
700a0626: d170         	bne	0x700a070a <UART_lld_initDma+0x11a> @ imm = #0xe0
700a0628: e7ff         	b	0x700a062a <UART_lld_initDma+0x3a> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a062a: 9903         	ldr	r1, [sp, #0xc]
700a062c: 2002         	movs	r0, #0x2
700a062e: 6548         	str	r0, [r1, #0x54]
;         hUartInit = hUart->hUartInit;
700a0630: 9803         	ldr	r0, [sp, #0xc]
700a0632: 6840         	ldr	r0, [r0, #0x4]
700a0634: 9001         	str	r0, [sp, #0x4]
;         hUart->lineStatusTimeout = hUartInit->clockP_usecToTick(UART_READ_LINE_STATUS_TIMEOUT_IN_US);
700a0636: 9801         	ldr	r0, [sp, #0x4]
700a0638: 6d82         	ldr	r2, [r0, #0x58]
700a063a: f244 2040    	movw	r0, #0x4240
700a063e: f2c0 000f    	movt	r0, #0xf
700a0642: 2100         	movs	r1, #0x0
700a0644: 9100         	str	r1, [sp]
700a0646: 4790         	blx	r2
700a0648: 9a00         	ldr	r2, [sp]
700a064a: 9903         	ldr	r1, [sp, #0xc]
700a064c: 66ca         	str	r2, [r1, #0x6c]
700a064e: 6688         	str	r0, [r1, #0x68]
;         status += UART_IsBaseAddrValid(hUart->baseAddr);
700a0650: 9803         	ldr	r0, [sp, #0xc]
700a0652: 6800         	ldr	r0, [r0]
700a0654: f006 fb3c    	bl	0x700a6cd0 <UART_IsBaseAddrValid> @ imm = #0x6678
700a0658: 4601         	mov	r1, r0
700a065a: 9802         	ldr	r0, [sp, #0x8]
700a065c: 4408         	add	r0, r1
700a065e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->inputClkFreq);
700a0660: 9801         	ldr	r0, [sp, #0x4]
700a0662: 6800         	ldr	r0, [r0]
700a0664: f00d f9d4    	bl	0x700ada10 <UART_IsParameter> @ imm = #0xd3a8
700a0668: 4601         	mov	r1, r0
700a066a: 9802         	ldr	r0, [sp, #0x8]
700a066c: 4408         	add	r0, r1
700a066e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->baudRate);
700a0670: 9801         	ldr	r0, [sp, #0x4]
700a0672: 6840         	ldr	r0, [r0, #0x4]
700a0674: f00d f9cc    	bl	0x700ada10 <UART_IsParameter> @ imm = #0xd398
700a0678: 4601         	mov	r1, r0
700a067a: 9802         	ldr	r0, [sp, #0x8]
700a067c: 4408         	add	r0, r1
700a067e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsDataLengthValid(hUartInit->dataLength);
700a0680: 9801         	ldr	r0, [sp, #0x4]
700a0682: 6880         	ldr	r0, [r0, #0x8]
700a0684: f00c f98c    	bl	0x700ac9a0 <UART_IsDataLengthValid> @ imm = #0xc318
700a0688: 4601         	mov	r1, r0
700a068a: 9802         	ldr	r0, [sp, #0x8]
700a068c: 4408         	add	r0, r1
700a068e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsStopBitsValid(hUartInit->stopBits);
700a0690: 9801         	ldr	r0, [sp, #0x4]
700a0692: 68c0         	ldr	r0, [r0, #0xc]
700a0694: f00c ffec    	bl	0x700ad670 <UART_IsStopBitsValid> @ imm = #0xcfd8
700a0698: 4601         	mov	r1, r0
700a069a: 9802         	ldr	r0, [sp, #0x8]
700a069c: 4408         	add	r0, r1
700a069e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParityTypeValid(hUartInit->parityType);
700a06a0: 9801         	ldr	r0, [sp, #0x4]
700a06a2: 6900         	ldr	r0, [r0, #0x10]
700a06a4: f00b fedc    	bl	0x700ac460 <UART_IsParityTypeValid> @ imm = #0xbdb8
700a06a8: 4601         	mov	r1, r0
700a06aa: 9802         	ldr	r0, [sp, #0x8]
700a06ac: 4408         	add	r0, r1
700a06ae: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsHWFlowCtrlValid(hUartInit->hwFlowControlThr);
700a06b0: 9801         	ldr	r0, [sp, #0x4]
700a06b2: 69c0         	ldr	r0, [r0, #0x1c]
700a06b4: f00b fd94    	bl	0x700ac1e0 <UART_IsHWFlowCtrlValid> @ imm = #0xbb28
700a06b8: 4601         	mov	r1, r0
700a06ba: 9802         	ldr	r0, [sp, #0x8]
700a06bc: 4408         	add	r0, r1
700a06be: 9002         	str	r0, [sp, #0x8]
;         status += UART_OperModeValid(hUartInit->operMode);
700a06c0: 9801         	ldr	r0, [sp, #0x4]
700a06c2: 6ac0         	ldr	r0, [r0, #0x2c]
700a06c4: f00a fdc4    	bl	0x700ab250 <UART_OperModeValid> @ imm = #0xab88
700a06c8: 4601         	mov	r1, r0
700a06ca: 9802         	ldr	r0, [sp, #0x8]
700a06cc: 4408         	add	r0, r1
700a06ce: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsRxTrigLvlValid(hUartInit->rxTrigLvl);
700a06d0: 9801         	ldr	r0, [sp, #0x4]
700a06d2: 6b80         	ldr	r0, [r0, #0x38]
700a06d4: f00b fda4    	bl	0x700ac220 <UART_IsRxTrigLvlValid> @ imm = #0xbb48
700a06d8: 4601         	mov	r1, r0
700a06da: 9802         	ldr	r0, [sp, #0x8]
700a06dc: 4408         	add	r0, r1
700a06de: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsTxTrigLvlValid(hUartInit->txTrigLvl);
700a06e0: 9801         	ldr	r0, [sp, #0x4]
700a06e2: 6bc0         	ldr	r0, [r0, #0x3c]
700a06e4: f00b fdbc    	bl	0x700ac260 <UART_IsTxTrigLvlValid> @ imm = #0xbb78
700a06e8: 4601         	mov	r1, r0
700a06ea: 9802         	ldr	r0, [sp, #0x8]
700a06ec: 4408         	add	r0, r1
700a06ee: 9002         	str	r0, [sp, #0x8]
;         if((hUartInit->uartDmaHandle == NULL_PTR)
700a06f0: 9801         	ldr	r0, [sp, #0x4]
700a06f2: 6c80         	ldr	r0, [r0, #0x48]
;             || (hUartInit->dmaChCfg == NULL_PTR))
700a06f4: b120         	cbz	r0, 0x700a0700 <UART_lld_initDma+0x110> @ imm = #0x8
700a06f6: e7ff         	b	0x700a06f8 <UART_lld_initDma+0x108> @ imm = #-0x2
700a06f8: 9801         	ldr	r0, [sp, #0x4]
700a06fa: 6cc0         	ldr	r0, [r0, #0x4c]
;         if((hUartInit->uartDmaHandle == NULL_PTR)
700a06fc: b920         	cbnz	r0, 0x700a0708 <UART_lld_initDma+0x118> @ imm = #0x8
700a06fe: e7ff         	b	0x700a0700 <UART_lld_initDma+0x110> @ imm = #-0x2
;             status += UART_INVALID_PARAM;
700a0700: 9802         	ldr	r0, [sp, #0x8]
700a0702: 3803         	subs	r0, #0x3
700a0704: 9002         	str	r0, [sp, #0x8]
;         }
700a0706: e7ff         	b	0x700a0708 <UART_lld_initDma+0x118> @ imm = #-0x2
;     }
700a0708: e7ff         	b	0x700a070a <UART_lld_initDma+0x11a> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a070a: 9802         	ldr	r0, [sp, #0x8]
700a070c: b950         	cbnz	r0, 0x700a0724 <UART_lld_initDma+0x134> @ imm = #0x14
700a070e: e7ff         	b	0x700a0710 <UART_lld_initDma+0x120> @ imm = #-0x2
;         UART_configInstance(hUart);
700a0710: 9803         	ldr	r0, [sp, #0xc]
700a0712: f003 f985    	bl	0x700a3a20 <UART_configInstance> @ imm = #0x330a
;         status = UART_lld_dmaInit(hUart, hUart->hUartInit->dmaChCfg);
700a0716: 9803         	ldr	r0, [sp, #0xc]
700a0718: 6841         	ldr	r1, [r0, #0x4]
700a071a: 6cc9         	ldr	r1, [r1, #0x4c]
700a071c: f00b f948    	bl	0x700ab9b0 <UART_lld_dmaInit> @ imm = #0xb290
700a0720: 9002         	str	r0, [sp, #0x8]
;     }
700a0722: e7ff         	b	0x700a0724 <UART_lld_initDma+0x134> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a0724: 9802         	ldr	r0, [sp, #0x8]
700a0726: b920         	cbnz	r0, 0x700a0732 <UART_lld_initDma+0x142> @ imm = #0x8
700a0728: e7ff         	b	0x700a072a <UART_lld_initDma+0x13a> @ imm = #-0x2
;         hUart->state = UART_STATE_READY;
700a072a: 9903         	ldr	r1, [sp, #0xc]
700a072c: 2001         	movs	r0, #0x1
700a072e: 6548         	str	r0, [r1, #0x54]
;     }
700a0730: e004         	b	0x700a073c <UART_lld_initDma+0x14c> @ imm = #0x8
;        status = UART_lld_deInitDma(hUart);
700a0732: 9803         	ldr	r0, [sp, #0xc]
700a0734: f009 fc64    	bl	0x700aa000 <UART_lld_deInitDma> @ imm = #0x98c8
700a0738: 9002         	str	r0, [sp, #0x8]
700a073a: e7ff         	b	0x700a073c <UART_lld_initDma+0x14c> @ imm = #-0x2
;     return status;
700a073c: 9802         	ldr	r0, [sp, #0x8]
700a073e: b004         	add	sp, #0x10
700a0740: bd80         	pop	{r7, pc}
700a0742: 0000         	movs	r0, r0

700a0744 <CSL_armR5PmuSelectCntr>:
;     AND     r0, r0, #0x1F
700a0744: e200001f     	and	r0, r0, #31
;     MCR     p15, #0, r0, c9, c12, #5        /* Write PMSELR Register */
700a0748: ee090fbc     	mcr	p15, #0x0, r0, c9, c12, #0x5
;     BX      lr
700a074c: e12fff1e     	bx	lr

700a0750 <CSL_armR5PmuCfg>:
;     MRC     p15, #0, r3, c9, c12, #0        /* Read PMCR Register */
700a0750: ee193f1c     	mrc	p15, #0x0, r3, c9, c12, #0x0
;     BIC     r3, r3, #((1<<3) | (1<<4))      /* Clear D and X bits */
700a0754: e3c33018     	bic	r3, r3, #24
;     CMP     r0, #0
700a0758: e3500000     	cmp	r0, #0
;     BEQ     armR5PmuCfg_00
700a075c: 0a000000     	beq	0x700a0764 <armR5PmuCfg_00> @ imm = #0x0
;     ORR     r3, r3, #(1<<3)                 /* Set D bit */
700a0760: e3833008     	orr	r3, r3, #8

700a0764 <armR5PmuCfg_00>:
;     CMP     r1, #0
700a0764: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuCfg_01
700a0768: 0a000000     	beq	0x700a0770 <armR5PmuCfg_01> @ imm = #0x0
;     ORR     r3, r3, #(1<<4)                 /* Set X bit */
700a076c: e3833010     	orr	r3, r3, #16

700a0770 <armR5PmuCfg_01>:
;     MCR     p15, #0, r3, c9, c12, #0        /* Write PMCR Register */
700a0770: ee093f1c     	mcr	p15, #0x0, r3, c9, c12, #0x0
;     EOR     r3, r3, r3                      /* Clear r3 */
700a0774: e0233003     	eor	r3, r3, r3
;     CMP     r2, #0
700a0778: e3520000     	cmp	r2, #0
;     BEQ     armR5PmuCfg_02
700a077c: 0a000000     	beq	0x700a0784 <armR5PmuCfg_02> @ imm = #0x0
;     ORR     r3, r3, #1
700a0780: e3833001     	orr	r3, r3, #1

700a0784 <armR5PmuCfg_02>:
;     MCR     p15, #0, r3, c9, c14, #0        /* Write PMUSERENR Register */
700a0784: ee093f1e     	mcr	p15, #0x0, r3, c9, c14, #0x0
;     BX      lr
700a0788: e12fff1e     	bx	lr

700a078c <CSL_armR5PmuEnableAllCntrs>:
;     MRC     p15, #0, r1, c9, c12, #0        /* Read PMCR */
700a078c: ee191f1c     	mrc	p15, #0x0, r1, c9, c12, #0x0
;     CMP     r0, #0
700a0790: e3500000     	cmp	r0, #0
;     BEQ     armR5PmuEnableAllCntrs_disable
700a0794: 0a000001     	beq	0x700a07a0 <armR5PmuEnableAllCntrs_disable> @ imm = #0x4
;     ORR     r1, r1, #0x1                    /* Set E bit to enable all counters */
700a0798: e3811001     	orr	r1, r1, #1
;     B       armR5PmuEnableAllCntrs_00
700a079c: ea000000     	b	0x700a07a4 <armR5PmuEnableAllCntrs_00> @ imm = #0x0

700a07a0 <armR5PmuEnableAllCntrs_disable>:
;     BIC     r1, r1, #0x1                    /* Clr E bit to disable all counters */
700a07a0: e3c11001     	bic	r1, r1, #1

700a07a4 <armR5PmuEnableAllCntrs_00>:
;     MCR     p15, #0, r1, c9, c12, #0        /* Write modified PMCR */
700a07a4: ee091f1c     	mcr	p15, #0x0, r1, c9, c12, #0x0
;     BX      lr
700a07a8: e12fff1e     	bx	lr

700a07ac <CSL_armR5PmuGetNumCntrs>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR (Performance Monitor Control Register) */
700a07ac: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     LSR     r0, r0, #11                     /* Shift and */
700a07b0: e1a005a0     	lsr	r0, r0, #11
;     AND     r0, r0, #0x1F                   /*   mask to get N */
700a07b4: e200001f     	and	r0, r0, #31
;     BX      lr
700a07b8: e12fff1e     	bx	lr

700a07bc <CSL_armR5PmuCfgCntr>:
;     PUSH    {lr}
700a07bc: e52de004     	str	lr, [sp, #-0x4]!
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a07c0: ebffffdf     	bl	0x700a0744 <CSL_armR5PmuSelectCntr> @ imm = #-0x84
;     AND     r1, r1, #0xFF
700a07c4: e20110ff     	and	r1, r1, #255
;     MCR     p15, #0, r1, c9, c13, #1        /* Write PMXEVTYPERx Register */
700a07c8: ee091f3d     	mcr	p15, #0x0, r1, c9, c13, #0x1
;     POP     {lr}
700a07cc: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a07d0: e12fff1e     	bx	lr

700a07d4 <CSL_armR5PmuEnableCntrOverflowIntr>:
;     AND     r0, r0, #0x1F                   /* cntrNum must be <= 31 */
700a07d4: e200001f     	and	r0, r0, #31
;     MOV     r2, #1
700a07d8: e3a02001     	mov	r2, #1
;     LSL     r0, r2, r0                      /* r0 is bit-mask corresponding to cntrNum */
700a07dc: e1a00012     	lsl	r0, r2, r0
;     CMP     r1, #0
700a07e0: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuEnableCntrOverflowIntr_clear
700a07e4: 0a000001     	beq	0x700a07f0 <armR5PmuEnableCntrOverflowIntr_clear> @ imm = #0x4
;     MCR     p15, #0, r0, c9, c14, #1        /* Write PMINTENSET Register (writes of 0 have no effect) */
700a07e8: ee090f3e     	mcr	p15, #0x0, r0, c9, c14, #0x1
;     B       armR5PmuEnableCntrOverflowIntr_00
700a07ec: ea000000     	b	0x700a07f4 <armR5PmuEnableCntrOverflowIntr_00> @ imm = #0x0

700a07f0 <armR5PmuEnableCntrOverflowIntr_clear>:
;     MCR     p15, #0, r0, c9, c14, #2        /* Write PMINTENCLR Register (writes of 0 have no effect) */
700a07f0: ee090f5e     	mcr	p15, #0x0, r0, c9, c14, #0x2

700a07f4 <armR5PmuEnableCntrOverflowIntr_00>:
;     BX      lr
700a07f4: e12fff1e     	bx	lr

700a07f8 <CSL_armR5PmuEnableCntr>:
;     AND     r0, r0, #0x1F                   /* cntrNum must be <= 31 */
700a07f8: e200001f     	and	r0, r0, #31
;     MOV     r2, #1
700a07fc: e3a02001     	mov	r2, #1
;     LSL     r0, r2, r0                      /* r0 is bit-mask corresponding to cntrNum */
700a0800: e1a00012     	lsl	r0, r2, r0
;     CMP     r1, #0
700a0804: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuEnableCntrs_clear
700a0808: 0a000001     	beq	0x700a0814 <armR5PmuEnableCntrs_clear> @ imm = #0x4
;     MCR     p15, #0, r0, c9, c12, #1        /* Write PMCNTENSET Register (writes of 0 have no effect) */
700a080c: ee090f3c     	mcr	p15, #0x0, r0, c9, c12, #0x1
;     B       armR5PmuEnableCntrs_00
700a0810: ea000000     	b	0x700a0818 <armR5PmuEnableCntrs_00> @ imm = #0x0

700a0814 <armR5PmuEnableCntrs_clear>:
;     MCR     p15, #0, r0, c9, c12, #2        /* Write PMCNTENCLR Register (writes of 0 have no effect) */
700a0814: ee090f5c     	mcr	p15, #0x0, r0, c9, c12, #0x2

700a0818 <armR5PmuEnableCntrs_00>:
;     BX      lr
700a0818: e12fff1e     	bx	lr

700a081c <CSL_armR5PmuReadCntr>:
;     PUSH    {lr}
700a081c: e52de004     	str	lr, [sp, #-0x4]!
;     CMP     r0, #CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM
700a0820: e350001f     	cmp	r0, #31
;     BEQ     armR5PmuReadCntr_cycles
700a0824: 0a000002     	beq	0x700a0834 <armR5PmuReadCntr_cycles> @ imm = #0x8
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a0828: ebffffc5     	bl	0x700a0744 <CSL_armR5PmuSelectCntr> @ imm = #-0xec
;     MRC     p15, #0, r0, c9, c13, #2        /* Read current PMNx Register */
700a082c: ee190f5d     	mrc	p15, #0x0, r0, c9, c13, #0x2
;     B       armR5PmuReadCntr_00
700a0830: ea000000     	b	0x700a0838 <armR5PmuReadCntr_00> @ imm = #0x0

700a0834 <armR5PmuReadCntr_cycles>:
;     MRC     p15, #0, r0, c9, c13, #0        /* Read PMCCNTR Register */
700a0834: ee190f1d     	mrc	p15, #0x0, r0, c9, c13, #0x0

700a0838 <armR5PmuReadCntr_00>:
;     POP     {lr}
700a0838: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a083c: e12fff1e     	bx	lr

700a0840 <CSL_armR5PmuSetCntr>:
;     PUSH    {lr}
700a0840: e52de004     	str	lr, [sp, #-0x4]!
;     CMP     r0, #CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM
700a0844: e350001f     	cmp	r0, #31
;     BEQ     armR5PmuSetCntr_cycles
700a0848: 0a000002     	beq	0x700a0858 <armR5PmuSetCntr_cycles> @ imm = #0x8
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a084c: ebffffbc     	bl	0x700a0744 <CSL_armR5PmuSelectCntr> @ imm = #-0x110
;     MCR     p15, #0, r1, c9, c13, #2        /* Write current PMNx Register */
700a0850: ee091f5d     	mcr	p15, #0x0, r1, c9, c13, #0x2
;     B       armR5PmuSetCntr_00
700a0854: ea000000     	b	0x700a085c <armR5PmuSetCntr_00> @ imm = #0x0

700a0858 <armR5PmuSetCntr_cycles>:
;     MCR     p15, #0, r1, c9, c13, #0        /* Write PMCCNTR Register */
700a0858: ee091f1d     	mcr	p15, #0x0, r1, c9, c13, #0x0

700a085c <armR5PmuSetCntr_00>:
;     POP     {lr}
700a085c: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a0860: e12fff1e     	bx	lr

700a0864 <CSL_armR5PmuReadCntrOverflowStatus>:
;     MRC     p15, #0, r0, c9, c12, #3        /* Read PMOVSR Register */
700a0864: ee190f7c     	mrc	p15, #0x0, r0, c9, c12, #0x3
;     BX      lr
700a0868: e12fff1e     	bx	lr

700a086c <CSL_armR5PmuClearCntrOverflowStatus>:
;     MCR     p15, #0, r0, c9, c12, #3        /* Write PMOVSR Register */
700a086c: ee090f7c     	mcr	p15, #0x0, r0, c9, c12, #0x3
;     BX      lr
700a0870: e12fff1e     	bx	lr

700a0874 <CSL_armR5PmuResetCycleCnt>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR */
700a0874: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     ORR     r0, r0, #(1<<2)                 /* Set C bit to reset the cycle counter, PMCCNTR, to zero */
700a0878: e3800004     	orr	r0, r0, #4
;     MCR     p15, #0, r0, c9, c12, #0        /* Write modified PMCR*/
700a087c: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;     BX      lr
700a0880: e12fff1e     	bx	lr

700a0884 <CSL_armR5PmuResetCntrs>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR */
700a0884: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     ORR     r0, r0, #(1<<1)                 /* Set P bit to reset all event counters to zero */
700a0888: e3800002     	orr	r0, r0, #2
;     MCR     p15, #0, r0, c9, c12, #0        /* Write modified PMCR */
700a088c: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;     BX      lr
700a0890: e12fff1e     	bx	lr
		...

700a08a0 <xTaskResumeAll>:
; BaseType_t xTaskResumeAll(void) {
700a08a0: b580         	push	{r7, lr}
700a08a2: b084         	sub	sp, #0x10
700a08a4: 2000         	movs	r0, #0x0
;   TCB_t *pxTCB = NULL;
700a08a6: 9003         	str	r0, [sp, #0xc]
;   BaseType_t xAlreadyYielded = pdFALSE;
700a08a8: 9002         	str	r0, [sp, #0x8]
;   taskENTER_CRITICAL();
700a08aa: f00c f991    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0xc322
;     --uxSchedulerSuspended;
700a08ae: f640 50d4    	movw	r0, #0xdd4
700a08b2: f2c7 000b    	movt	r0, #0x700b
700a08b6: 6801         	ldr	r1, [r0]
700a08b8: 3901         	subs	r1, #0x1
700a08ba: 6001         	str	r1, [r0]
;     if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a08bc: 6800         	ldr	r0, [r0]
700a08be: 2800         	cmp	r0, #0x0
700a08c0: f040 808f    	bne.w	0x700a09e2 <xTaskResumeAll+0x142> @ imm = #0x11e
700a08c4: e7ff         	b	0x700a08c6 <xTaskResumeAll+0x26> @ imm = #-0x2
;       if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
700a08c6: f640 50cc    	movw	r0, #0xdcc
700a08ca: f2c7 000b    	movt	r0, #0x700b
700a08ce: 6800         	ldr	r0, [r0]
700a08d0: 2800         	cmp	r0, #0x0
700a08d2: f000 8085    	beq.w	0x700a09e0 <xTaskResumeAll+0x140> @ imm = #0x10a
700a08d6: e7ff         	b	0x700a08d8 <xTaskResumeAll+0x38> @ imm = #-0x2
;         while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
700a08d8: e7ff         	b	0x700a08da <xTaskResumeAll+0x3a> @ imm = #-0x2
700a08da: f644 5060    	movw	r0, #0x4d60
700a08de: f2c7 0008    	movt	r0, #0x7008
700a08e2: 6800         	ldr	r0, [r0]
700a08e4: 2800         	cmp	r0, #0x0
700a08e6: d042         	beq	0x700a096e <xTaskResumeAll+0xce> @ imm = #0x84
700a08e8: e7ff         	b	0x700a08ea <xTaskResumeAll+0x4a> @ imm = #-0x2
;           pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a08ea: f644 5060    	movw	r0, #0x4d60
700a08ee: f2c7 0008    	movt	r0, #0x7008
700a08f2: 68c0         	ldr	r0, [r0, #0xc]
700a08f4: 68c0         	ldr	r0, [r0, #0xc]
700a08f6: 9003         	str	r0, [sp, #0xc]
;           (void)uxListRemove(&(pxTCB->xEventListItem));
700a08f8: 9803         	ldr	r0, [sp, #0xc]
700a08fa: 3018         	adds	r0, #0x18
700a08fc: f00b f8f8    	bl	0x700abaf0 <uxListRemove> @ imm = #0xb1f0
;           (void)uxListRemove(&(pxTCB->xStateListItem));
700a0900: 9803         	ldr	r0, [sp, #0xc]
700a0902: 3004         	adds	r0, #0x4
700a0904: f00b f8f4    	bl	0x700abaf0 <uxListRemove> @ imm = #0xb1e8
;           prvAddTaskToReadyList(pxTCB);
700a0908: 9803         	ldr	r0, [sp, #0xc]
700a090a: 6ac0         	ldr	r0, [r0, #0x2c]
700a090c: f640 51dc    	movw	r1, #0xddc
700a0910: f2c7 010b    	movt	r1, #0x700b
700a0914: 6809         	ldr	r1, [r1]
700a0916: 4288         	cmp	r0, r1
700a0918: d908         	bls	0x700a092c <xTaskResumeAll+0x8c> @ imm = #0x10
700a091a: e7ff         	b	0x700a091c <xTaskResumeAll+0x7c> @ imm = #-0x2
700a091c: 9803         	ldr	r0, [sp, #0xc]
700a091e: 6ac0         	ldr	r0, [r0, #0x2c]
700a0920: f640 51dc    	movw	r1, #0xddc
700a0924: f2c7 010b    	movt	r1, #0x700b
700a0928: 6008         	str	r0, [r1]
700a092a: e7ff         	b	0x700a092c <xTaskResumeAll+0x8c> @ imm = #-0x2
700a092c: 9903         	ldr	r1, [sp, #0xc]
700a092e: 6ac8         	ldr	r0, [r1, #0x2c]
700a0930: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a0934: f244 40f8    	movw	r0, #0x44f8
700a0938: f2c7 0008    	movt	r0, #0x7008
700a093c: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a0940: 3104         	adds	r1, #0x4
700a0942: f00b fead    	bl	0x700ac6a0 <vListInsertEnd> @ imm = #0xbd5a
;           if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a0946: 9803         	ldr	r0, [sp, #0xc]
700a0948: 6ac0         	ldr	r0, [r0, #0x2c]
700a094a: f640 51ac    	movw	r1, #0xdac
700a094e: f2c7 010b    	movt	r1, #0x700b
700a0952: 6809         	ldr	r1, [r1]
700a0954: 6ac9         	ldr	r1, [r1, #0x2c]
700a0956: 4288         	cmp	r0, r1
700a0958: d307         	blo	0x700a096a <xTaskResumeAll+0xca> @ imm = #0xe
700a095a: e7ff         	b	0x700a095c <xTaskResumeAll+0xbc> @ imm = #-0x2
;             xYieldPending = pdTRUE;
700a095c: f640 6100    	movw	r1, #0xe00
700a0960: f2c7 010b    	movt	r1, #0x700b
700a0964: 2001         	movs	r0, #0x1
700a0966: 6008         	str	r0, [r1]
;           } else {
700a0968: e000         	b	0x700a096c <xTaskResumeAll+0xcc> @ imm = #0x0
700a096a: e7ff         	b	0x700a096c <xTaskResumeAll+0xcc> @ imm = #-0x2
;         while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
700a096c: e7b5         	b	0x700a08da <xTaskResumeAll+0x3a> @ imm = #-0x96
;         if (pxTCB != NULL) {
700a096e: 9803         	ldr	r0, [sp, #0xc]
700a0970: b118         	cbz	r0, 0x700a097a <xTaskResumeAll+0xda> @ imm = #0x6
700a0972: e7ff         	b	0x700a0974 <xTaskResumeAll+0xd4> @ imm = #-0x2
;           prvResetNextTaskUnblockTime();
700a0974: f00b fe14    	bl	0x700ac5a0 <prvResetNextTaskUnblockTime> @ imm = #0xbc28
;         }
700a0978: e7ff         	b	0x700a097a <xTaskResumeAll+0xda> @ imm = #-0x2
;           TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
700a097a: f640 50ec    	movw	r0, #0xdec
700a097e: f2c7 000b    	movt	r0, #0x700b
700a0982: 6800         	ldr	r0, [r0]
700a0984: 9001         	str	r0, [sp, #0x4]
;           if (xPendedCounts > (TickType_t)0U) {
700a0986: 9801         	ldr	r0, [sp, #0x4]
700a0988: b1e0         	cbz	r0, 0x700a09c4 <xTaskResumeAll+0x124> @ imm = #0x38
700a098a: e7ff         	b	0x700a098c <xTaskResumeAll+0xec> @ imm = #-0x2
;             do {
700a098c: e7ff         	b	0x700a098e <xTaskResumeAll+0xee> @ imm = #-0x2
;               if (xTaskIncrementTick() != pdFALSE) {
700a098e: f7ff f937    	bl	0x7009fc00 <xTaskIncrementTick> @ imm = #-0xd92
700a0992: b138         	cbz	r0, 0x700a09a4 <xTaskResumeAll+0x104> @ imm = #0xe
700a0994: e7ff         	b	0x700a0996 <xTaskResumeAll+0xf6> @ imm = #-0x2
;                 xYieldPending = pdTRUE;
700a0996: f640 6100    	movw	r1, #0xe00
700a099a: f2c7 010b    	movt	r1, #0x700b
700a099e: 2001         	movs	r0, #0x1
700a09a0: 6008         	str	r0, [r1]
;               } else {
700a09a2: e000         	b	0x700a09a6 <xTaskResumeAll+0x106> @ imm = #0x0
700a09a4: e7ff         	b	0x700a09a6 <xTaskResumeAll+0x106> @ imm = #-0x2
;               --xPendedCounts;
700a09a6: 9801         	ldr	r0, [sp, #0x4]
700a09a8: 3801         	subs	r0, #0x1
700a09aa: 9001         	str	r0, [sp, #0x4]
;             } while (xPendedCounts > (TickType_t)0U);
700a09ac: e7ff         	b	0x700a09ae <xTaskResumeAll+0x10e> @ imm = #-0x2
700a09ae: 9801         	ldr	r0, [sp, #0x4]
700a09b0: 2800         	cmp	r0, #0x0
700a09b2: d1ec         	bne	0x700a098e <xTaskResumeAll+0xee> @ imm = #-0x28
700a09b4: e7ff         	b	0x700a09b6 <xTaskResumeAll+0x116> @ imm = #-0x2
;             xPendedTicks = 0;
700a09b6: f640 51ec    	movw	r1, #0xdec
700a09ba: f2c7 010b    	movt	r1, #0x700b
700a09be: 2000         	movs	r0, #0x0
700a09c0: 6008         	str	r0, [r1]
;           } else {
700a09c2: e000         	b	0x700a09c6 <xTaskResumeAll+0x126> @ imm = #0x0
700a09c4: e7ff         	b	0x700a09c6 <xTaskResumeAll+0x126> @ imm = #-0x2
;         if (xYieldPending != pdFALSE) {
700a09c6: f640 6000    	movw	r0, #0xe00
700a09ca: f2c7 000b    	movt	r0, #0x700b
700a09ce: 6800         	ldr	r0, [r0]
700a09d0: b120         	cbz	r0, 0x700a09dc <xTaskResumeAll+0x13c> @ imm = #0x8
700a09d2: e7ff         	b	0x700a09d4 <xTaskResumeAll+0x134> @ imm = #-0x2
700a09d4: 2001         	movs	r0, #0x1
;             xAlreadyYielded = pdTRUE;
700a09d6: 9002         	str	r0, [sp, #0x8]
;           taskYIELD_IF_USING_PREEMPTION();
700a09d8: df00         	svc	#0x0
;         } else {
700a09da: e000         	b	0x700a09de <xTaskResumeAll+0x13e> @ imm = #0x0
700a09dc: e7ff         	b	0x700a09de <xTaskResumeAll+0x13e> @ imm = #-0x2
;       }
700a09de: e7ff         	b	0x700a09e0 <xTaskResumeAll+0x140> @ imm = #-0x2
;     } else {
700a09e0: e000         	b	0x700a09e4 <xTaskResumeAll+0x144> @ imm = #0x0
700a09e2: e7ff         	b	0x700a09e4 <xTaskResumeAll+0x144> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a09e4: f00b f974    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0xb2e8
;   return xAlreadyYielded;
700a09e8: 9802         	ldr	r0, [sp, #0x8]
700a09ea: b004         	add	sp, #0x10
700a09ec: bd80         	pop	{r7, pc}
700a09ee: 0000         	movs	r0, r0

700a09f0 <Udma_chAssignRegOverlay>:
; {
700a09f0: b082         	sub	sp, #0x8
700a09f2: 9001         	str	r0, [sp, #0x4]
700a09f4: 9100         	str	r1, [sp]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a09f6: 9801         	ldr	r0, [sp, #0x4]
700a09f8: 6800         	ldr	r0, [r0]
700a09fa: 2801         	cmp	r0, #0x1
700a09fc: d147         	bne	0x700a0a8e <Udma_chAssignRegOverlay+0x9e> @ imm = #0x8e
700a09fe: e7ff         	b	0x700a0a00 <Udma_chAssignRegOverlay+0x10> @ imm = #-0x2
;         if(chHandle->txChNum != UDMA_DMA_CH_INVALID)
700a0a00: 9800         	ldr	r0, [sp]
700a0a02: 6ec0         	ldr	r0, [r0, #0x6c]
700a0a04: f510 3f80    	cmn.w	r0, #0x10000
700a0a08: d029         	beq	0x700a0a5e <Udma_chAssignRegOverlay+0x6e> @ imm = #0x52
700a0a0a: e7ff         	b	0x700a0a0c <Udma_chAssignRegOverlay+0x1c> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a0a0c: 9800         	ldr	r0, [sp]
700a0a0e: 7800         	ldrb	r0, [r0]
700a0a10: 0740         	lsls	r0, r0, #0x1d
700a0a12: 2800         	cmp	r0, #0x0
700a0a14: d511         	bpl	0x700a0a3a <Udma_chAssignRegOverlay+0x4a> @ imm = #0x22
700a0a16: e7ff         	b	0x700a0a18 <Udma_chAssignRegOverlay+0x28> @ imm = #-0x2
;                     &drvHandle->bcdmaRegs.pBcChanCfgRegs->CHAN[chHandle->txChNum];
700a0a18: 9801         	ldr	r0, [sp, #0x4]
700a0a1a: 68c0         	ldr	r0, [r0, #0xc]
700a0a1c: 9900         	ldr	r1, [sp]
700a0a1e: 6eca         	ldr	r2, [r1, #0x6c]
700a0a20: eb00 2002    	add.w	r0, r0, r2, lsl #8
;                 chHandle->pBcdmaBcCfgRegs =
700a0a24: f8c1 0214    	str.w	r0, [r1, #0x214]
;                     &drvHandle->bcdmaRegs.pBcChanRtRegs->CHAN[chHandle->txChNum];
700a0a28: 9801         	ldr	r0, [sp, #0x4]
700a0a2a: 6900         	ldr	r0, [r0, #0x10]
700a0a2c: 9900         	ldr	r1, [sp]
700a0a2e: 6eca         	ldr	r2, [r1, #0x6c]
700a0a30: eb00 3002    	add.w	r0, r0, r2, lsl #12
;                 chHandle->pBcdmaBcRtRegs  =
700a0a34: f8c1 0218    	str.w	r0, [r1, #0x218]
;             }
700a0a38: e010         	b	0x700a0a5c <Udma_chAssignRegOverlay+0x6c> @ imm = #0x20
;                     &drvHandle->bcdmaRegs.pTxChanCfgRegs->CHAN[chHandle->txChNum];
700a0a3a: 9801         	ldr	r0, [sp, #0x4]
700a0a3c: 6940         	ldr	r0, [r0, #0x14]
700a0a3e: 9900         	ldr	r1, [sp]
700a0a40: 6eca         	ldr	r2, [r1, #0x6c]
700a0a42: eb00 2002    	add.w	r0, r0, r2, lsl #8
;                 chHandle->pBcdmaTxCfgRegs =
700a0a46: f8c1 021c    	str.w	r0, [r1, #0x21c]
;                     &drvHandle->bcdmaRegs.pTxChanRtRegs->CHAN[chHandle->txChNum];
700a0a4a: 9801         	ldr	r0, [sp, #0x4]
700a0a4c: 6980         	ldr	r0, [r0, #0x18]
700a0a4e: 9900         	ldr	r1, [sp]
700a0a50: 6eca         	ldr	r2, [r1, #0x6c]
700a0a52: eb00 3002    	add.w	r0, r0, r2, lsl #12
;                 chHandle->pBcdmaTxRtRegs  =
700a0a56: f8c1 0220    	str.w	r0, [r1, #0x220]
700a0a5a: e7ff         	b	0x700a0a5c <Udma_chAssignRegOverlay+0x6c> @ imm = #-0x2
;         }
700a0a5c: e7ff         	b	0x700a0a5e <Udma_chAssignRegOverlay+0x6e> @ imm = #-0x2
;         if(chHandle->rxChNum != UDMA_DMA_CH_INVALID)
700a0a5e: 9800         	ldr	r0, [sp]
700a0a60: 6f00         	ldr	r0, [r0, #0x70]
700a0a62: f510 3f80    	cmn.w	r0, #0x10000
700a0a66: d011         	beq	0x700a0a8c <Udma_chAssignRegOverlay+0x9c> @ imm = #0x22
700a0a68: e7ff         	b	0x700a0a6a <Udma_chAssignRegOverlay+0x7a> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs.pRxChanCfgRegs->CHAN[chHandle->rxChNum];
700a0a6a: 9801         	ldr	r0, [sp, #0x4]
700a0a6c: 69c0         	ldr	r0, [r0, #0x1c]
700a0a6e: 9900         	ldr	r1, [sp]
700a0a70: 6f0a         	ldr	r2, [r1, #0x70]
700a0a72: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pBcdmaRxCfgRegs =
700a0a76: f8c1 0224    	str.w	r0, [r1, #0x224]
;                 &drvHandle->bcdmaRegs.pRxChanRtRegs->CHAN[chHandle->rxChNum];
700a0a7a: 9801         	ldr	r0, [sp, #0x4]
700a0a7c: 6a00         	ldr	r0, [r0, #0x20]
700a0a7e: 9900         	ldr	r1, [sp]
700a0a80: 6f0a         	ldr	r2, [r1, #0x70]
700a0a82: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pBcdmaRxRtRegs  =
700a0a86: f8c1 0228    	str.w	r0, [r1, #0x228]
;         }
700a0a8a: e7ff         	b	0x700a0a8c <Udma_chAssignRegOverlay+0x9c> @ imm = #-0x2
;     }
700a0a8c: e051         	b	0x700a0b32 <Udma_chAssignRegOverlay+0x142> @ imm = #0xa2
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a0a8e: 9801         	ldr	r0, [sp, #0x4]
700a0a90: 6800         	ldr	r0, [r0]
700a0a92: 2802         	cmp	r0, #0x2
700a0a94: d14c         	bne	0x700a0b30 <Udma_chAssignRegOverlay+0x140> @ imm = #0x98
700a0a96: e7ff         	b	0x700a0a98 <Udma_chAssignRegOverlay+0xa8> @ imm = #-0x2
;         if(chHandle->txChNum != UDMA_DMA_CH_INVALID)
700a0a98: 9800         	ldr	r0, [sp]
700a0a9a: 6ec0         	ldr	r0, [r0, #0x6c]
700a0a9c: f510 3f80    	cmn.w	r0, #0x10000
700a0aa0: d011         	beq	0x700a0ac6 <Udma_chAssignRegOverlay+0xd6> @ imm = #0x22
700a0aa2: e7ff         	b	0x700a0aa4 <Udma_chAssignRegOverlay+0xb4> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[chHandle->txChNum];
700a0aa4: 9801         	ldr	r0, [sp, #0x4]
700a0aa6: 6dc0         	ldr	r0, [r0, #0x5c]
700a0aa8: 9900         	ldr	r1, [sp]
700a0aaa: 6eca         	ldr	r2, [r1, #0x6c]
700a0aac: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaTxCfgRegs =
700a0ab0: f8c1 022c    	str.w	r0, [r1, #0x22c]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[chHandle->txChNum];
700a0ab4: 9801         	ldr	r0, [sp, #0x4]
700a0ab6: 6e40         	ldr	r0, [r0, #0x64]
700a0ab8: 9900         	ldr	r1, [sp]
700a0aba: 6eca         	ldr	r2, [r1, #0x6c]
700a0abc: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaTxRtRegs  =
700a0ac0: f8c1 0230    	str.w	r0, [r1, #0x230]
;         }
700a0ac4: e7ff         	b	0x700a0ac6 <Udma_chAssignRegOverlay+0xd6> @ imm = #-0x2
;         if(chHandle->rxChNum != UDMA_DMA_CH_INVALID)
700a0ac6: 9800         	ldr	r0, [sp]
700a0ac8: 6f00         	ldr	r0, [r0, #0x70]
700a0aca: f510 3f80    	cmn.w	r0, #0x10000
700a0ace: d011         	beq	0x700a0af4 <Udma_chAssignRegOverlay+0x104> @ imm = #0x22
700a0ad0: e7ff         	b	0x700a0ad2 <Udma_chAssignRegOverlay+0xe2> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pRxChanCfgRegs->CHAN[chHandle->rxChNum];
700a0ad2: 9801         	ldr	r0, [sp, #0x4]
700a0ad4: 6e00         	ldr	r0, [r0, #0x60]
700a0ad6: 9900         	ldr	r1, [sp]
700a0ad8: 6f0a         	ldr	r2, [r1, #0x70]
700a0ada: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaRxCfgRegs =
700a0ade: f8c1 0234    	str.w	r0, [r1, #0x234]
;                 &drvHandle->pktdmaRegs.pRxChanRtRegs->CHAN[chHandle->rxChNum];
700a0ae2: 9801         	ldr	r0, [sp, #0x4]
700a0ae4: 6e80         	ldr	r0, [r0, #0x68]
700a0ae6: 9900         	ldr	r1, [sp]
700a0ae8: 6f0a         	ldr	r2, [r1, #0x70]
700a0aea: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaRxRtRegs  =
700a0aee: f8c1 0238    	str.w	r0, [r1, #0x238]
;         }
700a0af2: e7ff         	b	0x700a0af4 <Udma_chAssignRegOverlay+0x104> @ imm = #-0x2
;         if(chHandle->extChNum != UDMA_DMA_CH_INVALID)
700a0af4: 9800         	ldr	r0, [sp]
700a0af6: 6f40         	ldr	r0, [r0, #0x74]
700a0af8: f510 3f80    	cmn.w	r0, #0x10000
700a0afc: d017         	beq	0x700a0b2e <Udma_chAssignRegOverlay+0x13e> @ imm = #0x2e
700a0afe: e7ff         	b	0x700a0b00 <Udma_chAssignRegOverlay+0x110> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a0b00: 9b01         	ldr	r3, [sp, #0x4]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a0b02: 9900         	ldr	r1, [sp]
700a0b04: 6f4a         	ldr	r2, [r1, #0x74]
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a0b06: 6dd8         	ldr	r0, [r3, #0x5c]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a0b08: f8d3 3110    	ldr.w	r3, [r3, #0x110]
700a0b0c: 441a         	add	r2, r3
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a0b0e: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaExtCfgRegs =
700a0b12: f8c1 023c    	str.w	r0, [r1, #0x23c]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a0b16: 9b01         	ldr	r3, [sp, #0x4]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a0b18: 9900         	ldr	r1, [sp]
700a0b1a: 6f4a         	ldr	r2, [r1, #0x74]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a0b1c: 6e58         	ldr	r0, [r3, #0x64]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a0b1e: f8d3 3110    	ldr.w	r3, [r3, #0x110]
700a0b22: 441a         	add	r2, r3
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a0b24: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaExtRtRegs  =
700a0b28: f8c1 0240    	str.w	r0, [r1, #0x240]
;         }
700a0b2c: e7ff         	b	0x700a0b2e <Udma_chAssignRegOverlay+0x13e> @ imm = #-0x2
;     }
700a0b2e: e7ff         	b	0x700a0b30 <Udma_chAssignRegOverlay+0x140> @ imm = #-0x2
700a0b30: e7ff         	b	0x700a0b32 <Udma_chAssignRegOverlay+0x142> @ imm = #-0x2
; }
700a0b32: b002         	add	sp, #0x8
700a0b34: 4770         	bx	lr
		...
700a0b3e: 0000         	movs	r0, r0

700a0b40 <DebugP_memLogWriterPutChar>:
; {
700a0b40: b580         	push	{r7, lr}
700a0b42: b088         	sub	sp, #0x20
700a0b44: f88d 001f    	strb.w	r0, [sp, #0x1f]
;     if(lineBufIndex==0U)
700a0b48: f640 4074    	movw	r0, #0xc74
700a0b4c: f2c7 000b    	movt	r0, #0x700b
700a0b50: 6800         	ldr	r0, [r0]
700a0b52: bb40         	cbnz	r0, 0x700a0ba6 <DebugP_memLogWriterPutChar+0x66> @ imm = #0x50
700a0b54: e7ff         	b	0x700a0b56 <DebugP_memLogWriterPutChar+0x16> @ imm = #-0x2
;         uint64_t curTime = ClockP_getTimeUsec();
700a0b56: f008 fa63    	bl	0x700a9020 <ClockP_getTimeUsec> @ imm = #0x84c6
700a0b5a: 9105         	str	r1, [sp, #0x14]
700a0b5c: 9004         	str	r0, [sp, #0x10]
;                             gDebugP_memTraceLogWriterSelfCoreName,
700a0b5e: f640 5094    	movw	r0, #0xd94
700a0b62: f2c7 000b    	movt	r0, #0x700b
700a0b66: 6800         	ldr	r0, [r0]
;                             (uint32_t)(curTime/TIME_IN_MICRO_SECONDS),
700a0b68: 9003         	str	r0, [sp, #0xc]
700a0b6a: 9804         	ldr	r0, [sp, #0x10]
700a0b6c: 9905         	ldr	r1, [sp, #0x14]
700a0b6e: f244 2240    	movw	r2, #0x4240
700a0b72: f2c0 020f    	movt	r2, #0xf
700a0b76: 2300         	movs	r3, #0x0
;                             (uint32_t)(curTime%TIME_IN_MICRO_SECONDS)
700a0b78: f00c ed8c    	blx	0x700ad694 <__aeabi_uldivmod> @ imm = #0xcb18
700a0b7c: 9b03         	ldr	r3, [sp, #0xc]
;         lineBufIndex = (uint32_t)snprintf_((char*)lineBuf, DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE, "[%6s] %5d.%06ds : ",
700a0b7e: 4669         	mov	r1, sp
700a0b80: 604a         	str	r2, [r1, #0x4]
700a0b82: 6008         	str	r0, [r1]
700a0b84: f644 30c0    	movw	r0, #0x4bc0
700a0b88: f2c7 0008    	movt	r0, #0x7008
700a0b8c: f240 32a4    	movw	r2, #0x3a4
700a0b90: f2c7 020b    	movt	r2, #0x700b
700a0b94: 2178         	movs	r1, #0x78
700a0b96: f00b fd63    	bl	0x700ac660 <snprintf_>  @ imm = #0xbac6
700a0b9a: f640 4174    	movw	r1, #0xc74
700a0b9e: f2c7 010b    	movt	r1, #0x700b
700a0ba2: 6008         	str	r0, [r1]
;     }
700a0ba4: e7ff         	b	0x700a0ba6 <DebugP_memLogWriterPutChar+0x66> @ imm = #-0x2
;     lineBuf[lineBufIndex]=(uint8_t)character;
700a0ba6: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700a0baa: f640 4174    	movw	r1, #0xc74
700a0bae: f2c7 010b    	movt	r1, #0x700b
700a0bb2: 680b         	ldr	r3, [r1]
700a0bb4: f644 32c0    	movw	r2, #0x4bc0
700a0bb8: f2c7 0208    	movt	r2, #0x7008
700a0bbc: 54d0         	strb	r0, [r2, r3]
; 	lineBufIndex = lineBufIndex + 1U;
700a0bbe: 6808         	ldr	r0, [r1]
700a0bc0: 3001         	adds	r0, #0x1
700a0bc2: 6008         	str	r0, [r1]
;     if( (character == '\n') ||
700a0bc4: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700a0bc8: 280a         	cmp	r0, #0xa
700a0bca: d008         	beq	0x700a0bde <DebugP_memLogWriterPutChar+0x9e> @ imm = #0x10
700a0bcc: e7ff         	b	0x700a0bce <DebugP_memLogWriterPutChar+0x8e> @ imm = #-0x2
;         (lineBufIndex >= (DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE)))
700a0bce: f640 4074    	movw	r0, #0xc74
700a0bd2: f2c7 000b    	movt	r0, #0x700b
700a0bd6: 6800         	ldr	r0, [r0]
;     if( (character == '\n') ||
700a0bd8: 2878         	cmp	r0, #0x78
700a0bda: d350         	blo	0x700a0c7e <DebugP_memLogWriterPutChar+0x13e> @ imm = #0xa0
700a0bdc: e7ff         	b	0x700a0bde <DebugP_memLogWriterPutChar+0x9e> @ imm = #-0x2
;         if(lineBufIndex >= (DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE))
700a0bde: f640 4074    	movw	r0, #0xc74
700a0be2: f2c7 000b    	movt	r0, #0x700b
700a0be6: 6800         	ldr	r0, [r0]
700a0be8: 2878         	cmp	r0, #0x78
700a0bea: d315         	blo	0x700a0c18 <DebugP_memLogWriterPutChar+0xd8> @ imm = #0x2a
700a0bec: e7ff         	b	0x700a0bee <DebugP_memLogWriterPutChar+0xae> @ imm = #-0x2
;             lineBuf[lineBufIndex]=(uint8_t)'\r';
700a0bee: f640 4174    	movw	r1, #0xc74
700a0bf2: f2c7 010b    	movt	r1, #0x700b
700a0bf6: 680b         	ldr	r3, [r1]
700a0bf8: f644 32c0    	movw	r2, #0x4bc0
700a0bfc: f2c7 0208    	movt	r2, #0x7008
700a0c00: 200d         	movs	r0, #0xd
700a0c02: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a0c04: 6808         	ldr	r0, [r1]
700a0c06: 3001         	adds	r0, #0x1
700a0c08: 6008         	str	r0, [r1]
;             lineBuf[lineBufIndex]=(uint8_t)'\n';
700a0c0a: 680b         	ldr	r3, [r1]
700a0c0c: 200a         	movs	r0, #0xa
700a0c0e: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a0c10: 6808         	ldr	r0, [r1]
700a0c12: 3001         	adds	r0, #0x1
700a0c14: 6008         	str	r0, [r1]
;         }
700a0c16: e7ff         	b	0x700a0c18 <DebugP_memLogWriterPutChar+0xd8> @ imm = #-0x2
;         if(lineBuf[lineBufIndex-UNSIGNED_INTEGERVAL_TWO]!=(uint8_t)'\r')
700a0c18: f640 4074    	movw	r0, #0xc74
700a0c1c: f2c7 000b    	movt	r0, #0x700b
700a0c20: 6800         	ldr	r0, [r0]
700a0c22: f644 31c0    	movw	r1, #0x4bc0
700a0c26: f2c7 0108    	movt	r1, #0x7008
700a0c2a: 4408         	add	r0, r1
700a0c2c: f810 0c02    	ldrb	r0, [r0, #-2]
700a0c30: 280d         	cmp	r0, #0xd
700a0c32: d014         	beq	0x700a0c5e <DebugP_memLogWriterPutChar+0x11e> @ imm = #0x28
700a0c34: e7ff         	b	0x700a0c36 <DebugP_memLogWriterPutChar+0xf6> @ imm = #-0x2
;             lineBuf[lineBufIndex-1U]=(uint8_t)'\r';
700a0c36: f640 4174    	movw	r1, #0xc74
700a0c3a: f2c7 010b    	movt	r1, #0x700b
700a0c3e: 6808         	ldr	r0, [r1]
700a0c40: f644 32c0    	movw	r2, #0x4bc0
700a0c44: f2c7 0208    	movt	r2, #0x7008
700a0c48: 1883         	adds	r3, r0, r2
700a0c4a: 200d         	movs	r0, #0xd
700a0c4c: f803 0c01    	strb	r0, [r3, #-1]
;             lineBuf[lineBufIndex]=(uint8_t)'\n';
700a0c50: 680b         	ldr	r3, [r1]
700a0c52: 200a         	movs	r0, #0xa
700a0c54: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a0c56: 6808         	ldr	r0, [r1]
700a0c58: 3001         	adds	r0, #0x1
700a0c5a: 6008         	str	r0, [r1]
;         }
700a0c5c: e7ff         	b	0x700a0c5e <DebugP_memLogWriterPutChar+0x11e> @ imm = #-0x2
;         DebugP_memTraceLogWriterPutLine(lineBuf, (uint16_t)lineBufIndex);
700a0c5e: f640 4074    	movw	r0, #0xc74
700a0c62: f2c7 000b    	movt	r0, #0x700b
700a0c66: 9002         	str	r0, [sp, #0x8]
700a0c68: 8801         	ldrh	r1, [r0]
700a0c6a: f644 30c0    	movw	r0, #0x4bc0
700a0c6e: f2c7 0008    	movt	r0, #0x7008
700a0c72: f003 fab5    	bl	0x700a41e0 <DebugP_memTraceLogWriterPutLine> @ imm = #0x356a
700a0c76: 9902         	ldr	r1, [sp, #0x8]
700a0c78: 2000         	movs	r0, #0x0
;         lineBufIndex = 0;
700a0c7a: 6008         	str	r0, [r1]
;     }
700a0c7c: e7ff         	b	0x700a0c7e <DebugP_memLogWriterPutChar+0x13e> @ imm = #-0x2
; }
700a0c7e: b008         	add	sp, #0x20
700a0c80: bd80         	pop	{r7, pc}
		...
700a0c8e: 0000         	movs	r0, r0

700a0c90 <Sciclient_sendMessage>:
; {
700a0c90: b580         	push	{r7, lr}
700a0c92: b08a         	sub	sp, #0x28
700a0c94: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a0c98: 9009         	str	r0, [sp, #0x24]
700a0c9a: 9108         	str	r1, [sp, #0x20]
700a0c9c: 9207         	str	r2, [sp, #0x1c]
700a0c9e: 9306         	str	r3, [sp, #0x18]
700a0ca0: 2200         	movs	r2, #0x0
;     uint32_t        i   = 0U;
700a0ca2: 9205         	str	r2, [sp, #0x14]
;     const uint8_t *msg = pSecHeader;
700a0ca4: 9808         	ldr	r0, [sp, #0x20]
700a0ca6: 9004         	str	r0, [sp, #0x10]
;     uint32_t numWords   = 0U;
700a0ca8: 9203         	str	r2, [sp, #0xc]
;     uint32_t test = 0U;
700a0caa: 9202         	str	r2, [sp, #0x8]
;     uintptr_t threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U);
700a0cac: 9909         	ldr	r1, [sp, #0x24]
700a0cae: f640 4078    	movw	r0, #0xc78
700a0cb2: f2c7 000b    	movt	r0, #0x700b
700a0cb6: f00c fe9b    	bl	0x700ad9f0 <CSL_secProxyGetDataAddr> @ imm = #0xcd36
700a0cba: 9001         	str	r0, [sp, #0x4]
;     if(pSecHeader != NULL)
700a0cbc: 9808         	ldr	r0, [sp, #0x20]
700a0cbe: b1f8         	cbz	r0, 0x700a0d00 <Sciclient_sendMessage+0x70> @ imm = #0x3e
700a0cc0: e7ff         	b	0x700a0cc2 <Sciclient_sendMessage+0x32> @ imm = #-0x2
700a0cc2: 2000         	movs	r0, #0x0
;         for (i = 0U; i < gSecHeaderSizeWords; i++)
700a0cc4: 9005         	str	r0, [sp, #0x14]
700a0cc6: e7ff         	b	0x700a0cc8 <Sciclient_sendMessage+0x38> @ imm = #-0x2
700a0cc8: 9805         	ldr	r0, [sp, #0x14]
700a0cca: f640 6104    	movw	r1, #0xe04
700a0cce: f2c7 010b    	movt	r1, #0x700b
700a0cd2: 7809         	ldrb	r1, [r1]
700a0cd4: 4288         	cmp	r0, r1
700a0cd6: d212         	bhs	0x700a0cfe <Sciclient_sendMessage+0x6e> @ imm = #0x24
700a0cd8: e7ff         	b	0x700a0cda <Sciclient_sendMessage+0x4a> @ imm = #-0x2
;             (void) memcpy((void *)&test, (const void *)msg, 4);
700a0cda: 9804         	ldr	r0, [sp, #0x10]
700a0cdc: 6800         	ldr	r0, [r0]
700a0cde: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(threadAddr, test);
700a0ce0: 9801         	ldr	r0, [sp, #0x4]
700a0ce2: 9902         	ldr	r1, [sp, #0x8]
700a0ce4: f00d f93c    	bl	0x700adf60 <CSL_REG32_WR_RAW> @ imm = #0xd278
;             msg += 4;
700a0ce8: 9804         	ldr	r0, [sp, #0x10]
700a0cea: 3004         	adds	r0, #0x4
700a0cec: 9004         	str	r0, [sp, #0x10]
;             threadAddr+=sizeof(uint32_t);
700a0cee: 9801         	ldr	r0, [sp, #0x4]
700a0cf0: 3004         	adds	r0, #0x4
700a0cf2: 9001         	str	r0, [sp, #0x4]
;         }
700a0cf4: e7ff         	b	0x700a0cf6 <Sciclient_sendMessage+0x66> @ imm = #-0x2
;         for (i = 0U; i < gSecHeaderSizeWords; i++)
700a0cf6: 9805         	ldr	r0, [sp, #0x14]
700a0cf8: 3001         	adds	r0, #0x1
700a0cfa: 9005         	str	r0, [sp, #0x14]
700a0cfc: e7e4         	b	0x700a0cc8 <Sciclient_sendMessage+0x38> @ imm = #-0x38
;     }
700a0cfe: e7ff         	b	0x700a0d00 <Sciclient_sendMessage+0x70> @ imm = #-0x2
;     msg = pHeader;
700a0d00: 9807         	ldr	r0, [sp, #0x1c]
700a0d02: 9004         	str	r0, [sp, #0x10]
700a0d04: 2000         	movs	r0, #0x0
;     for (i = 0U; i < SCICLIENT_HEADER_SIZE_IN_WORDS; i++)
700a0d06: 9005         	str	r0, [sp, #0x14]
700a0d08: e7ff         	b	0x700a0d0a <Sciclient_sendMessage+0x7a> @ imm = #-0x2
700a0d0a: 9805         	ldr	r0, [sp, #0x14]
700a0d0c: 2801         	cmp	r0, #0x1
700a0d0e: d812         	bhi	0x700a0d36 <Sciclient_sendMessage+0xa6> @ imm = #0x24
700a0d10: e7ff         	b	0x700a0d12 <Sciclient_sendMessage+0x82> @ imm = #-0x2
;         (void) memcpy((void *)&test, (const void *)msg, 4);
700a0d12: 9804         	ldr	r0, [sp, #0x10]
700a0d14: 6800         	ldr	r0, [r0]
700a0d16: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(threadAddr, test);
700a0d18: 9801         	ldr	r0, [sp, #0x4]
700a0d1a: 9902         	ldr	r1, [sp, #0x8]
700a0d1c: f00d f920    	bl	0x700adf60 <CSL_REG32_WR_RAW> @ imm = #0xd240
;         msg += 4;
700a0d20: 9804         	ldr	r0, [sp, #0x10]
700a0d22: 3004         	adds	r0, #0x4
700a0d24: 9004         	str	r0, [sp, #0x10]
;         threadAddr+=sizeof(uint32_t);
700a0d26: 9801         	ldr	r0, [sp, #0x4]
700a0d28: 3004         	adds	r0, #0x4
700a0d2a: 9001         	str	r0, [sp, #0x4]
;     }
700a0d2c: e7ff         	b	0x700a0d2e <Sciclient_sendMessage+0x9e> @ imm = #-0x2
;     for (i = 0U; i < SCICLIENT_HEADER_SIZE_IN_WORDS; i++)
700a0d2e: 9805         	ldr	r0, [sp, #0x14]
700a0d30: 3001         	adds	r0, #0x1
700a0d32: 9005         	str	r0, [sp, #0x14]
700a0d34: e7e9         	b	0x700a0d0a <Sciclient_sendMessage+0x7a> @ imm = #-0x2e
;     if (payloadSize > 0U)
700a0d36: 980c         	ldr	r0, [sp, #0x30]
700a0d38: b300         	cbz	r0, 0x700a0d7c <Sciclient_sendMessage+0xec> @ imm = #0x40
700a0d3a: e7ff         	b	0x700a0d3c <Sciclient_sendMessage+0xac> @ imm = #-0x2
;         numWords   = (payloadSize+3U)/4U;
700a0d3c: 980c         	ldr	r0, [sp, #0x30]
700a0d3e: 3003         	adds	r0, #0x3
700a0d40: 0880         	lsrs	r0, r0, #0x2
700a0d42: 9003         	str	r0, [sp, #0xc]
;         msg = pPayload;
700a0d44: 9806         	ldr	r0, [sp, #0x18]
700a0d46: 9004         	str	r0, [sp, #0x10]
;         for (; i < (SCICLIENT_HEADER_SIZE_IN_WORDS + numWords); i++)
700a0d48: e7ff         	b	0x700a0d4a <Sciclient_sendMessage+0xba> @ imm = #-0x2
700a0d4a: 9805         	ldr	r0, [sp, #0x14]
700a0d4c: 9903         	ldr	r1, [sp, #0xc]
700a0d4e: 3102         	adds	r1, #0x2
700a0d50: 4288         	cmp	r0, r1
700a0d52: d212         	bhs	0x700a0d7a <Sciclient_sendMessage+0xea> @ imm = #0x24
700a0d54: e7ff         	b	0x700a0d56 <Sciclient_sendMessage+0xc6> @ imm = #-0x2
;             (void) memcpy((void *)&test, (const void *)msg, 4);
700a0d56: 9804         	ldr	r0, [sp, #0x10]
700a0d58: 6800         	ldr	r0, [r0]
700a0d5a: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(threadAddr, test);
700a0d5c: 9801         	ldr	r0, [sp, #0x4]
700a0d5e: 9902         	ldr	r1, [sp, #0x8]
700a0d60: f00d f8fe    	bl	0x700adf60 <CSL_REG32_WR_RAW> @ imm = #0xd1fc
;             msg += 4;
700a0d64: 9804         	ldr	r0, [sp, #0x10]
700a0d66: 3004         	adds	r0, #0x4
700a0d68: 9004         	str	r0, [sp, #0x10]
;             threadAddr+=sizeof(uint32_t);
700a0d6a: 9801         	ldr	r0, [sp, #0x4]
700a0d6c: 3004         	adds	r0, #0x4
700a0d6e: 9001         	str	r0, [sp, #0x4]
;         }
700a0d70: e7ff         	b	0x700a0d72 <Sciclient_sendMessage+0xe2> @ imm = #-0x2
;         for (; i < (SCICLIENT_HEADER_SIZE_IN_WORDS + numWords); i++)
700a0d72: 9805         	ldr	r0, [sp, #0x14]
700a0d74: 3001         	adds	r0, #0x1
700a0d76: 9005         	str	r0, [sp, #0x14]
700a0d78: e7e7         	b	0x700a0d4a <Sciclient_sendMessage+0xba> @ imm = #-0x32
;     }
700a0d7a: e7ff         	b	0x700a0d7c <Sciclient_sendMessage+0xec> @ imm = #-0x2
;     if ((((uint32_t) gSecHeaderSizeWords*4U)+(SCICLIENT_HEADER_SIZE_IN_WORDS*4U)+payloadSize) <=
700a0d7c: f640 6004    	movw	r0, #0xe04
700a0d80: f2c7 000b    	movt	r0, #0x700b
700a0d84: 7801         	ldrb	r1, [r0]
700a0d86: 980c         	ldr	r0, [sp, #0x30]
700a0d88: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0d8c: 3008         	adds	r0, #0x8
;         (gSciclientHandle.maxMsgSizeBytes - 4U))
700a0d8e: f640 5100    	movw	r1, #0xd00
700a0d92: f2c7 010b    	movt	r1, #0x700b
700a0d96: 6949         	ldr	r1, [r1, #0x14]
700a0d98: 3904         	subs	r1, #0x4
;     if ((((uint32_t) gSecHeaderSizeWords*4U)+(SCICLIENT_HEADER_SIZE_IN_WORDS*4U)+payloadSize) <=
700a0d9a: 4288         	cmp	r0, r1
700a0d9c: d817         	bhi	0x700a0dce <Sciclient_sendMessage+0x13e> @ imm = #0x2e
700a0d9e: e7ff         	b	0x700a0da0 <Sciclient_sendMessage+0x110> @ imm = #-0x2
;         threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U) +
700a0da0: 9909         	ldr	r1, [sp, #0x24]
700a0da2: f640 4078    	movw	r0, #0xc78
700a0da6: f2c7 000b    	movt	r0, #0x700b
700a0daa: 2200         	movs	r2, #0x0
700a0dac: 9200         	str	r2, [sp]
700a0dae: f00c fe1f    	bl	0x700ad9f0 <CSL_secProxyGetDataAddr> @ imm = #0xcc3e
700a0db2: 9900         	ldr	r1, [sp]
700a0db4: 4602         	mov	r2, r0
;         ((uintptr_t) gSciclientHandle.maxMsgSizeBytes  - (uintptr_t) 4U) ;
700a0db6: f640 5000    	movw	r0, #0xd00
700a0dba: f2c7 000b    	movt	r0, #0x700b
700a0dbe: 6940         	ldr	r0, [r0, #0x14]
;         threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U) +
700a0dc0: 4410         	add	r0, r2
700a0dc2: 3804         	subs	r0, #0x4
700a0dc4: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(threadAddr,0U);
700a0dc6: 9801         	ldr	r0, [sp, #0x4]
700a0dc8: f00d f8ca    	bl	0x700adf60 <CSL_REG32_WR_RAW> @ imm = #0xd194
;     }
700a0dcc: e7ff         	b	0x700a0dce <Sciclient_sendMessage+0x13e> @ imm = #-0x2
; }
700a0dce: b00a         	add	sp, #0x28
700a0dd0: bd80         	pop	{r7, pc}
		...
700a0dde: 0000         	movs	r0, r0

700a0de0 <Sciclient_rmIaValidateMapping>:
; {
700a0de0: b580         	push	{r7, lr}
700a0de2: b088         	sub	sp, #0x20
700a0de4: 4684         	mov	r12, r0
700a0de6: 980a         	ldr	r0, [sp, #0x28]
700a0de8: f88d c01f    	strb.w	r12, [sp, #0x1f]
700a0dec: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a0df0: f8ad 201a    	strh.w	r2, [sp, #0x1a]
700a0df4: f8ad 3018    	strh.w	r3, [sp, #0x18]
700a0df8: f88d 0017    	strb.w	r0, [sp, #0x17]
700a0dfc: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a0dfe: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIaInst *inst = NULL;
700a0e00: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIaGetInst(id);
700a0e02: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a0e06: f009 fdab    	bl	0x700aa960 <Sciclient_rmIaGetInst> @ imm = #0x9b56
700a0e0a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a0e0c: 9803         	ldr	r0, [sp, #0xc]
700a0e0e: b920         	cbnz	r0, 0x700a0e1a <Sciclient_rmIaValidateMapping+0x3a> @ imm = #0x8
700a0e10: e7ff         	b	0x700a0e12 <Sciclient_rmIaValidateMapping+0x32> @ imm = #-0x2
700a0e12: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a0e16: 9004         	str	r0, [sp, #0x10]
;     } else {
700a0e18: e00b         	b	0x700a0e32 <Sciclient_rmIaValidateMapping+0x52> @ imm = #0x16
;         if (vint >= inst->n_vint) {
700a0e1a: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a0e1e: 9903         	ldr	r1, [sp, #0xc]
700a0e20: 8989         	ldrh	r1, [r1, #0xc]
700a0e22: 4288         	cmp	r0, r1
700a0e24: db04         	blt	0x700a0e30 <Sciclient_rmIaValidateMapping+0x50> @ imm = #0x8
700a0e26: e7ff         	b	0x700a0e28 <Sciclient_rmIaValidateMapping+0x48> @ imm = #-0x2
700a0e28: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a0e2c: 9004         	str	r0, [sp, #0x10]
;         }
700a0e2e: e7ff         	b	0x700a0e30 <Sciclient_rmIaValidateMapping+0x50> @ imm = #-0x2
700a0e30: e7ff         	b	0x700a0e32 <Sciclient_rmIaValidateMapping+0x52> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (vint_sb_index >= SCICLIENT_IA_VINT_MAX_BITS)) {
700a0e32: 9804         	ldr	r0, [sp, #0x10]
700a0e34: b948         	cbnz	r0, 0x700a0e4a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #0x12
700a0e36: e7ff         	b	0x700a0e38 <Sciclient_rmIaValidateMapping+0x58> @ imm = #-0x2
700a0e38: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a0e3c: 2840         	cmp	r0, #0x40
700a0e3e: d304         	blo	0x700a0e4a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #0x8
700a0e40: e7ff         	b	0x700a0e42 <Sciclient_rmIaValidateMapping+0x62> @ imm = #-0x2
700a0e42: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a0e46: 9004         	str	r0, [sp, #0x10]
;     }
700a0e48: e7ff         	b	0x700a0e4a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a0e4a: 9804         	ldr	r0, [sp, #0x10]
700a0e4c: b998         	cbnz	r0, 0x700a0e76 <Sciclient_rmIaValidateMapping+0x96> @ imm = #0x26
700a0e4e: e7ff         	b	0x700a0e50 <Sciclient_rmIaValidateMapping+0x70> @ imm = #-0x2
;         evt = global_evt - inst->sevt_offset;
700a0e50: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a0e54: 9903         	ldr	r1, [sp, #0xc]
700a0e56: 8909         	ldrh	r1, [r1, #0x8]
700a0e58: 1a40         	subs	r0, r0, r1
700a0e5a: f8ad 000a    	strh.w	r0, [sp, #0xa]
;         if (evt >= inst->n_sevt) {
700a0e5e: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a0e62: 9903         	ldr	r1, [sp, #0xc]
700a0e64: 8949         	ldrh	r1, [r1, #0xa]
700a0e66: 4288         	cmp	r0, r1
700a0e68: db04         	blt	0x700a0e74 <Sciclient_rmIaValidateMapping+0x94> @ imm = #0x8
700a0e6a: e7ff         	b	0x700a0e6c <Sciclient_rmIaValidateMapping+0x8c> @ imm = #-0x2
700a0e6c: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a0e70: 9004         	str	r0, [sp, #0x10]
;         }
700a0e72: e7ff         	b	0x700a0e74 <Sciclient_rmIaValidateMapping+0x94> @ imm = #-0x2
;     }
700a0e74: e7ff         	b	0x700a0e76 <Sciclient_rmIaValidateMapping+0x96> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a0e76: 9804         	ldr	r0, [sp, #0x10]
700a0e78: 2800         	cmp	r0, #0x0
700a0e7a: d14e         	bne	0x700a0f1a <Sciclient_rmIaValidateMapping+0x13a> @ imm = #0x9c
700a0e7c: e7ff         	b	0x700a0e7e <Sciclient_rmIaValidateMapping+0x9e> @ imm = #-0x2
;         entry_int_map_lo = (volatile uint32_t *)(inst->imap + SCICLIENT_IA_ENTRY_INTMAP_LO(evt));
700a0e7e: 9803         	ldr	r0, [sp, #0xc]
700a0e80: 6840         	ldr	r0, [r0, #0x4]
700a0e82: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700a0e86: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a0e8a: 9001         	str	r0, [sp, #0x4]
;         reg_vint = CSL_REG32_FEXT(entry_int_map_lo,
700a0e8c: 9801         	ldr	r0, [sp, #0x4]
700a0e8e: f64f 7100    	movw	r1, #0xff00
700a0e92: f2c0 0101    	movt	r1, #0x1
700a0e96: 2208         	movs	r2, #0x8
700a0e98: f00c fbba    	bl	0x700ad610 <CSL_REG32_FEXT_RAW> @ imm = #0xc774
700a0e9c: f8ad 0002    	strh.w	r0, [sp, #0x2]
;         reg_sb = CSL_REG32_FEXT(entry_int_map_lo,
700a0ea0: 9801         	ldr	r0, [sp, #0x4]
700a0ea2: 213f         	movs	r1, #0x3f
700a0ea4: 2200         	movs	r2, #0x0
700a0ea6: f00c fbb3    	bl	0x700ad610 <CSL_REG32_FEXT_RAW> @ imm = #0xc766
700a0eaa: f8ad 0000    	strh.w	r0, [sp]
;         if ((reg_vint == 0u) && (reg_sb == 0u)) {
700a0eae: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a0eb2: b9f0         	cbnz	r0, 0x700a0ef2 <Sciclient_rmIaValidateMapping+0x112> @ imm = #0x3c
700a0eb4: e7ff         	b	0x700a0eb6 <Sciclient_rmIaValidateMapping+0xd6> @ imm = #-0x2
700a0eb6: f8bd 0000    	ldrh.w	r0, [sp]
700a0eba: b9d0         	cbnz	r0, 0x700a0ef2 <Sciclient_rmIaValidateMapping+0x112> @ imm = #0x34
700a0ebc: e7ff         	b	0x700a0ebe <Sciclient_rmIaValidateMapping+0xde> @ imm = #-0x2
;             if ((vint != reg_vint) &&
700a0ebe: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a0ec2: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a0ec6: 4288         	cmp	r0, r1
700a0ec8: d012         	beq	0x700a0ef0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x24
700a0eca: e7ff         	b	0x700a0ecc <Sciclient_rmIaValidateMapping+0xec> @ imm = #-0x2
;                 (vint_sb_index != reg_sb) &&
700a0ecc: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a0ed0: f8bd 1000    	ldrh.w	r1, [sp]
700a0ed4: 4288         	cmp	r0, r1
700a0ed6: d00b         	beq	0x700a0ef0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x16
700a0ed8: e7ff         	b	0x700a0eda <Sciclient_rmIaValidateMapping+0xfa> @ imm = #-0x2
;                 (evt != inst->v0_b0_evt)) {
700a0eda: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a0ede: 9903         	ldr	r1, [sp, #0xc]
700a0ee0: 8a89         	ldrh	r1, [r1, #0x14]
;             if ((vint != reg_vint) &&
700a0ee2: 4288         	cmp	r0, r1
700a0ee4: d004         	beq	0x700a0ef0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x8
700a0ee6: e7ff         	b	0x700a0ee8 <Sciclient_rmIaValidateMapping+0x108> @ imm = #-0x2
700a0ee8: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a0eec: 9004         	str	r0, [sp, #0x10]
;             }
700a0eee: e7ff         	b	0x700a0ef0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #-0x2
;         } else {
700a0ef0: e012         	b	0x700a0f18 <Sciclient_rmIaValidateMapping+0x138> @ imm = #0x24
;             if ((vint != reg_vint) &&
700a0ef2: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a0ef6: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a0efa: 4288         	cmp	r0, r1
700a0efc: d00b         	beq	0x700a0f16 <Sciclient_rmIaValidateMapping+0x136> @ imm = #0x16
700a0efe: e7ff         	b	0x700a0f00 <Sciclient_rmIaValidateMapping+0x120> @ imm = #-0x2
;                 (vint_sb_index != reg_sb)) {
700a0f00: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a0f04: f8bd 1000    	ldrh.w	r1, [sp]
;             if ((vint != reg_vint) &&
700a0f08: 4288         	cmp	r0, r1
700a0f0a: d004         	beq	0x700a0f16 <Sciclient_rmIaValidateMapping+0x136> @ imm = #0x8
700a0f0c: e7ff         	b	0x700a0f0e <Sciclient_rmIaValidateMapping+0x12e> @ imm = #-0x2
700a0f0e: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a0f12: 9004         	str	r0, [sp, #0x10]
;             }
700a0f14: e7ff         	b	0x700a0f16 <Sciclient_rmIaValidateMapping+0x136> @ imm = #-0x2
700a0f16: e7ff         	b	0x700a0f18 <Sciclient_rmIaValidateMapping+0x138> @ imm = #-0x2
;     }
700a0f18: e7ff         	b	0x700a0f1a <Sciclient_rmIaValidateMapping+0x13a> @ imm = #-0x2
;     return r;
700a0f1a: 9804         	ldr	r0, [sp, #0x10]
700a0f1c: b008         	add	sp, #0x20
700a0f1e: bd80         	pop	{r7, pc}

700a0f20 <Udma_rmAllocMappedRing>:
; {
700a0f20: b580         	push	{r7, lr}
700a0f22: b090         	sub	sp, #0x40
700a0f24: 900f         	str	r0, [sp, #0x3c]
700a0f26: 910e         	str	r1, [sp, #0x38]
700a0f28: 920d         	str	r2, [sp, #0x34]
700a0f2a: f64f 70ff    	movw	r0, #0xffff
;     uint32_t    ringNum = UDMA_RING_INVALID;
700a0f2e: 900c         	str	r0, [sp, #0x30]
700a0f30: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a0f32: 9005         	str	r0, [sp, #0x14]
;     Udma_RmInitPrms             *rmInitPrms = &drvHandle->rmInitPrms;
700a0f34: 980f         	ldr	r0, [sp, #0x3c]
700a0f36: f500 70ea    	add.w	r0, r0, #0x1d4
700a0f3a: 9004         	str	r0, [sp, #0x10]
;     retVal = Udma_getMappedChRingAttributes(drvHandle, mappedRingGrp, mappedChNum, &chAttr);
700a0f3c: 980f         	ldr	r0, [sp, #0x3c]
700a0f3e: 990e         	ldr	r1, [sp, #0x38]
700a0f40: 9a0d         	ldr	r2, [sp, #0x34]
700a0f42: ab01         	add	r3, sp, #0x4
700a0f44: f005 f944    	bl	0x700a61d0 <Udma_getMappedChRingAttributes> @ imm = #0x5288
700a0f48: 9005         	str	r0, [sp, #0x14]
;     if(UDMA_SOK == retVal)
700a0f4a: 9805         	ldr	r0, [sp, #0x14]
700a0f4c: 2800         	cmp	r0, #0x0
700a0f4e: f040 8084    	bne.w	0x700a105a <Udma_rmAllocMappedRing+0x13a> @ imm = #0x108
700a0f52: e7ff         	b	0x700a0f54 <Udma_rmAllocMappedRing+0x34> @ imm = #-0x2
700a0f54: 2000         	movs	r0, #0x0
;         loopStart = 0;
700a0f56: 9007         	str	r0, [sp, #0x1c]
;         loopMax   = rmInitPrms->numMappedRing[mappedRingGrp];
700a0f58: 9804         	ldr	r0, [sp, #0x10]
700a0f5a: 990e         	ldr	r1, [sp, #0x38]
700a0f5c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0f60: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
700a0f64: 9006         	str	r0, [sp, #0x18]
;         if(chAttr.startFreeRing > rmInitPrms->startMappedRing[mappedRingGrp])
700a0f66: 9802         	ldr	r0, [sp, #0x8]
700a0f68: 9904         	ldr	r1, [sp, #0x10]
700a0f6a: 9a0e         	ldr	r2, [sp, #0x38]
700a0f6c: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0f70: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a0f74: 4288         	cmp	r0, r1
700a0f76: d90a         	bls	0x700a0f8e <Udma_rmAllocMappedRing+0x6e> @ imm = #0x14
700a0f78: e7ff         	b	0x700a0f7a <Udma_rmAllocMappedRing+0x5a> @ imm = #-0x2
;             loopStart = chAttr.startFreeRing - rmInitPrms->startMappedRing[mappedRingGrp];
700a0f7a: 9802         	ldr	r0, [sp, #0x8]
700a0f7c: 9904         	ldr	r1, [sp, #0x10]
700a0f7e: 9a0e         	ldr	r2, [sp, #0x38]
700a0f80: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0f84: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a0f88: 1a40         	subs	r0, r0, r1
700a0f8a: 9007         	str	r0, [sp, #0x1c]
;         }
700a0f8c: e7ff         	b	0x700a0f8e <Udma_rmAllocMappedRing+0x6e> @ imm = #-0x2
;         if((chAttr.startFreeRing + chAttr.numFreeRing) < (rmInitPrms->startMappedRing[mappedRingGrp] + rmInitPrms->numMappedRing[mappedRingGrp]))
700a0f8e: 9802         	ldr	r0, [sp, #0x8]
700a0f90: 9903         	ldr	r1, [sp, #0xc]
700a0f92: 4408         	add	r0, r1
700a0f94: 9904         	ldr	r1, [sp, #0x10]
700a0f96: 9a0e         	ldr	r2, [sp, #0x38]
700a0f98: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a0f9c: f8d2 1088    	ldr.w	r1, [r2, #0x88]
700a0fa0: f8d2 20a8    	ldr.w	r2, [r2, #0xa8]
700a0fa4: 4411         	add	r1, r2
700a0fa6: 4288         	cmp	r0, r1
700a0fa8: d20c         	bhs	0x700a0fc4 <Udma_rmAllocMappedRing+0xa4> @ imm = #0x18
700a0faa: e7ff         	b	0x700a0fac <Udma_rmAllocMappedRing+0x8c> @ imm = #-0x2
;             loopMax = (chAttr.startFreeRing + chAttr.numFreeRing) - rmInitPrms->startMappedRing[mappedRingGrp];
700a0fac: 9802         	ldr	r0, [sp, #0x8]
700a0fae: 9903         	ldr	r1, [sp, #0xc]
700a0fb0: 4408         	add	r0, r1
700a0fb2: 9904         	ldr	r1, [sp, #0x10]
700a0fb4: 9a0e         	ldr	r2, [sp, #0x38]
700a0fb6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0fba: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a0fbe: 1a40         	subs	r0, r0, r1
700a0fc0: 9006         	str	r0, [sp, #0x18]
;         }
700a0fc2: e7ff         	b	0x700a0fc4 <Udma_rmAllocMappedRing+0xa4> @ imm = #-0x2
;         SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a0fc4: 980f         	ldr	r0, [sp, #0x3c]
700a0fc6: f500 609f    	add.w	r0, r0, #0x4f8
700a0fca: f04f 31ff    	mov.w	r1, #0xffffffff
700a0fce: f007 fe4f    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x7c9e
;         for(i = loopStart; i < loopMax; i++)
700a0fd2: 9807         	ldr	r0, [sp, #0x1c]
700a0fd4: 900b         	str	r0, [sp, #0x2c]
700a0fd6: e7ff         	b	0x700a0fd8 <Udma_rmAllocMappedRing+0xb8> @ imm = #-0x2
700a0fd8: 980b         	ldr	r0, [sp, #0x2c]
700a0fda: 9906         	ldr	r1, [sp, #0x18]
700a0fdc: 4288         	cmp	r0, r1
700a0fde: d236         	bhs	0x700a104e <Udma_rmAllocMappedRing+0x12e> @ imm = #0x6c
700a0fe0: e7ff         	b	0x700a0fe2 <Udma_rmAllocMappedRing+0xc2> @ imm = #-0x2
;             offset = i >> 5U;
700a0fe2: 980b         	ldr	r0, [sp, #0x2c]
700a0fe4: 0940         	lsrs	r0, r0, #0x5
700a0fe6: 900a         	str	r0, [sp, #0x28]
;             bitPos = i - (offset << 5U);
700a0fe8: 980b         	ldr	r0, [sp, #0x2c]
700a0fea: 990a         	ldr	r1, [sp, #0x28]
700a0fec: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a0ff0: 9009         	str	r0, [sp, #0x24]
;             bitMask = (uint32_t) 1U << bitPos;
700a0ff2: 9909         	ldr	r1, [sp, #0x24]
700a0ff4: 2001         	movs	r0, #0x1
700a0ff6: 4088         	lsls	r0, r1
700a0ff8: 9008         	str	r0, [sp, #0x20]
;             if((drvHandle->mappedRingFlag[mappedRingGrp][offset] & bitMask) == bitMask)
700a0ffa: 980f         	ldr	r0, [sp, #0x3c]
700a0ffc: 990e         	ldr	r1, [sp, #0x38]
700a0ffe: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a1002: 990a         	ldr	r1, [sp, #0x28]
700a1004: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1008: f8d0 0344    	ldr.w	r0, [r0, #0x344]
700a100c: 9908         	ldr	r1, [sp, #0x20]
700a100e: 4008         	ands	r0, r1
700a1010: 4288         	cmp	r0, r1
700a1012: d117         	bne	0x700a1044 <Udma_rmAllocMappedRing+0x124> @ imm = #0x2e
700a1014: e7ff         	b	0x700a1016 <Udma_rmAllocMappedRing+0xf6> @ imm = #-0x2
;                 drvHandle->mappedRingFlag[mappedRingGrp][offset] &= ~bitMask;
700a1016: 9a08         	ldr	r2, [sp, #0x20]
700a1018: 980f         	ldr	r0, [sp, #0x3c]
700a101a: 990e         	ldr	r1, [sp, #0x38]
700a101c: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a1020: 990a         	ldr	r1, [sp, #0x28]
700a1022: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1026: f8d1 0344    	ldr.w	r0, [r1, #0x344]
700a102a: 4390         	bics	r0, r2
700a102c: f8c1 0344    	str.w	r0, [r1, #0x344]
;                 ringNum = i + rmInitPrms->startMappedRing[mappedRingGrp];  /* Add start offset */
700a1030: 980b         	ldr	r0, [sp, #0x2c]
700a1032: 9904         	ldr	r1, [sp, #0x10]
700a1034: 9a0e         	ldr	r2, [sp, #0x38]
700a1036: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a103a: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a103e: 4408         	add	r0, r1
700a1040: 900c         	str	r0, [sp, #0x30]
;                 break;
700a1042: e004         	b	0x700a104e <Udma_rmAllocMappedRing+0x12e> @ imm = #0x8
;         }
700a1044: e7ff         	b	0x700a1046 <Udma_rmAllocMappedRing+0x126> @ imm = #-0x2
;         for(i = loopStart; i < loopMax; i++)
700a1046: 980b         	ldr	r0, [sp, #0x2c]
700a1048: 3001         	adds	r0, #0x1
700a104a: 900b         	str	r0, [sp, #0x2c]
700a104c: e7c4         	b	0x700a0fd8 <Udma_rmAllocMappedRing+0xb8> @ imm = #-0x78
;         SemaphoreP_post(&drvHandle->rmLockObj);
700a104e: 980f         	ldr	r0, [sp, #0x3c]
700a1050: f500 609f    	add.w	r0, r0, #0x4f8
700a1054: f009 f95c    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x92b8
;     }
700a1058: e7ff         	b	0x700a105a <Udma_rmAllocMappedRing+0x13a> @ imm = #-0x2
;     return (ringNum);
700a105a: 980c         	ldr	r0, [sp, #0x30]
700a105c: b010         	add	sp, #0x40
700a105e: bd80         	pop	{r7, pc}

700a1060 <UART_procLineStatusErr>:
; {
700a1060: b580         	push	{r7, lr}
700a1062: b086         	sub	sp, #0x18
700a1064: 9005         	str	r0, [sp, #0x14]
700a1066: 2000         	movs	r0, #0x0
;     int32_t            status = UART_STATUS_SUCCESS;
700a1068: 9004         	str	r0, [sp, #0x10]
;     uint32_t           lineStatus, iteration = 0U;
700a106a: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == hUart)
700a106c: 9805         	ldr	r0, [sp, #0x14]
700a106e: b920         	cbnz	r0, 0x700a107a <UART_procLineStatusErr+0x1a> @ imm = #0x8
700a1070: e7ff         	b	0x700a1072 <UART_procLineStatusErr+0x12> @ imm = #-0x2
700a1072: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a1076: 9004         	str	r0, [sp, #0x10]
;     }
700a1078: e7ff         	b	0x700a107a <UART_procLineStatusErr+0x1a> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a107a: 9804         	ldr	r0, [sp, #0x10]
700a107c: 2800         	cmp	r0, #0x0
700a107e: f040 808b    	bne.w	0x700a1198 <UART_procLineStatusErr+0x138> @ imm = #0x116
700a1082: e7ff         	b	0x700a1084 <UART_procLineStatusErr+0x24> @ imm = #-0x2
;         lineStatus = UART_readLineStatus(hUart->baseAddr);
700a1084: 9805         	ldr	r0, [sp, #0x14]
700a1086: 6800         	ldr	r0, [r0]
700a1088: f00a fdfa    	bl	0x700abc80 <UART_readLineStatus> @ imm = #0xabf4
700a108c: 9003         	str	r0, [sp, #0xc]
;         if(((lineStatus & UART_FIFO_PE_FE_BI_DETECTED) == UART_FIFO_PE_FE_BI_DETECTED)
700a108e: 9803         	ldr	r0, [sp, #0xc]
700a1090: f000 0080    	and	r0, r0, #0x80
;                 || ((lineStatus & UART_OVERRUN_ERROR) == UART_OVERRUN_ERROR))
700a1094: 2880         	cmp	r0, #0x80
700a1096: d006         	beq	0x700a10a6 <UART_procLineStatusErr+0x46> @ imm = #0xc
700a1098: e7ff         	b	0x700a109a <UART_procLineStatusErr+0x3a> @ imm = #-0x2
;         if(((lineStatus & UART_FIFO_PE_FE_BI_DETECTED) == UART_FIFO_PE_FE_BI_DETECTED)
700a109a: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a109e: 0780         	lsls	r0, r0, #0x1e
700a10a0: 2800         	cmp	r0, #0x0
700a10a2: d578         	bpl	0x700a1196 <UART_procLineStatusErr+0x136> @ imm = #0xf0
700a10a4: e7ff         	b	0x700a10a6 <UART_procLineStatusErr+0x46> @ imm = #-0x2
;             if (hUart->readTrans.buf != NULL)
700a10a6: 9805         	ldr	r0, [sp, #0x14]
700a10a8: 6a80         	ldr	r0, [r0, #0x28]
700a10aa: b120         	cbz	r0, 0x700a10b6 <UART_procLineStatusErr+0x56> @ imm = #0x8
700a10ac: e7ff         	b	0x700a10ae <UART_procLineStatusErr+0x4e> @ imm = #-0x2
;                 hUart->readTrans.count = (uint32_t)(hUart->readCount);
700a10ae: 9905         	ldr	r1, [sp, #0x14]
700a10b0: 6988         	ldr	r0, [r1, #0x18]
700a10b2: 62c8         	str	r0, [r1, #0x2c]
;             }
700a10b4: e7ff         	b	0x700a10b6 <UART_procLineStatusErr+0x56> @ imm = #-0x2
700a10b6: 2040         	movs	r0, #0x40
;             iteration = UART_FIFO_SIZE;
700a10b8: 9002         	str	r0, [sp, #0x8]
;             do
700a10ba: e7ff         	b	0x700a10bc <UART_procLineStatusErr+0x5c> @ imm = #-0x2
;                 (void)UART_fifoCharGet(hUart->baseAddr);
700a10bc: 9805         	ldr	r0, [sp, #0x14]
700a10be: 6800         	ldr	r0, [r0]
700a10c0: f00c fd06    	bl	0x700adad0 <UART_fifoCharGet> @ imm = #0xca0c
;                 iteration--;
700a10c4: 9802         	ldr	r0, [sp, #0x8]
700a10c6: 3801         	subs	r0, #0x1
700a10c8: 9002         	str	r0, [sp, #0x8]
;                 lineStatus = (uint32_t) UART_readLineStatus(hUart->baseAddr);
700a10ca: 9805         	ldr	r0, [sp, #0x14]
700a10cc: 6800         	ldr	r0, [r0]
700a10ce: f00a fdd7    	bl	0x700abc80 <UART_readLineStatus> @ imm = #0xabae
700a10d2: 9003         	str	r0, [sp, #0xc]
;                 lineStatus &= (UART_LSR_RX_FIFO_STS_MASK |
700a10d4: 9803         	ldr	r0, [sp, #0xc]
700a10d6: f000 009f    	and	r0, r0, #0x9f
700a10da: 9003         	str	r0, [sp, #0xc]
;             }
700a10dc: e7ff         	b	0x700a10de <UART_procLineStatusErr+0x7e> @ imm = #-0x2
;             while ((lineStatus != 0U) && (iteration != 0U));
700a10de: 9903         	ldr	r1, [sp, #0xc]
700a10e0: 2000         	movs	r0, #0x0
700a10e2: 9001         	str	r0, [sp, #0x4]
700a10e4: b131         	cbz	r1, 0x700a10f4 <UART_procLineStatusErr+0x94> @ imm = #0xc
700a10e6: e7ff         	b	0x700a10e8 <UART_procLineStatusErr+0x88> @ imm = #-0x2
700a10e8: 9802         	ldr	r0, [sp, #0x8]
700a10ea: 2800         	cmp	r0, #0x0
700a10ec: bf18         	it	ne
700a10ee: 2001         	movne	r0, #0x1
700a10f0: 9001         	str	r0, [sp, #0x4]
700a10f2: e7ff         	b	0x700a10f4 <UART_procLineStatusErr+0x94> @ imm = #-0x2
700a10f4: 9801         	ldr	r0, [sp, #0x4]
;             }
700a10f6: 07c0         	lsls	r0, r0, #0x1f
700a10f8: 2800         	cmp	r0, #0x0
700a10fa: d1df         	bne	0x700a10bc <UART_procLineStatusErr+0x5c> @ imm = #-0x42
700a10fc: e7ff         	b	0x700a10fe <UART_procLineStatusErr+0x9e> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a10fe: 9805         	ldr	r0, [sp, #0x14]
700a1100: 6800         	ldr	r0, [r0]
700a1102: 2105         	movs	r1, #0x5
700a1104: f003 fb1c    	bl	0x700a4740 <UART_intrDisable> @ imm = #0x3638
;             hUart->readBuf = (void *)((uint8_t *)hUart->readBuf - hUart->readCount);
700a1108: 9905         	ldr	r1, [sp, #0x14]
700a110a: 6948         	ldr	r0, [r1, #0x14]
700a110c: 698a         	ldr	r2, [r1, #0x18]
700a110e: 1a80         	subs	r0, r0, r2
700a1110: 6148         	str	r0, [r1, #0x14]
;             if (hUart->readTrans.buf != NULL)
700a1112: 9805         	ldr	r0, [sp, #0x14]
700a1114: 6a80         	ldr	r0, [r0, #0x28]
700a1116: b3a8         	cbz	r0, 0x700a1184 <UART_procLineStatusErr+0x124> @ imm = #0x6a
700a1118: e7ff         	b	0x700a111a <UART_procLineStatusErr+0xba> @ imm = #-0x2
;                 if ((lineStatus & UART_BREAK_DETECTED_ERROR) != 0U)
700a111a: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a111e: 06c0         	lsls	r0, r0, #0x1b
700a1120: 2800         	cmp	r0, #0x0
700a1122: d508         	bpl	0x700a1136 <UART_procLineStatusErr+0xd6> @ imm = #0x10
700a1124: e7ff         	b	0x700a1126 <UART_procLineStatusErr+0xc6> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_BI;
700a1126: 9905         	ldr	r1, [sp, #0x14]
700a1128: 2002         	movs	r0, #0x2
700a112a: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a112c: 9905         	ldr	r1, [sp, #0x14]
700a112e: 6a48         	ldr	r0, [r1, #0x24]
700a1130: 3001         	adds	r0, #0x1
700a1132: 6248         	str	r0, [r1, #0x24]
;                 }
700a1134: e025         	b	0x700a1182 <UART_procLineStatusErr+0x122> @ imm = #0x4a
;                 else if ((lineStatus & UART_FRAMING_ERROR) != 0U)
700a1136: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a113a: 0700         	lsls	r0, r0, #0x1c
700a113c: 2800         	cmp	r0, #0x0
700a113e: d508         	bpl	0x700a1152 <UART_procLineStatusErr+0xf2> @ imm = #0x10
700a1140: e7ff         	b	0x700a1142 <UART_procLineStatusErr+0xe2> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_FE;
700a1142: 9905         	ldr	r1, [sp, #0x14]
700a1144: 2003         	movs	r0, #0x3
700a1146: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a1148: 9905         	ldr	r1, [sp, #0x14]
700a114a: 6a48         	ldr	r0, [r1, #0x24]
700a114c: 3001         	adds	r0, #0x1
700a114e: 6248         	str	r0, [r1, #0x24]
;                 }
700a1150: e016         	b	0x700a1180 <UART_procLineStatusErr+0x120> @ imm = #0x2c
;                 else if ((lineStatus & UART_PARITY_ERROR) != 0U)
700a1152: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a1156: 0740         	lsls	r0, r0, #0x1d
700a1158: 2800         	cmp	r0, #0x0
700a115a: d508         	bpl	0x700a116e <UART_procLineStatusErr+0x10e> @ imm = #0x10
700a115c: e7ff         	b	0x700a115e <UART_procLineStatusErr+0xfe> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_PE;
700a115e: 9905         	ldr	r1, [sp, #0x14]
700a1160: 2004         	movs	r0, #0x4
700a1162: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a1164: 9905         	ldr	r1, [sp, #0x14]
700a1166: 6a48         	ldr	r0, [r1, #0x24]
700a1168: 3001         	adds	r0, #0x1
700a116a: 6248         	str	r0, [r1, #0x24]
;                 }
700a116c: e007         	b	0x700a117e <UART_procLineStatusErr+0x11e> @ imm = #0xe
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_OE;
700a116e: 9905         	ldr	r1, [sp, #0x14]
700a1170: 2005         	movs	r0, #0x5
700a1172: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a1174: 9905         	ldr	r1, [sp, #0x14]
700a1176: 6a48         	ldr	r0, [r1, #0x24]
700a1178: 3001         	adds	r0, #0x1
700a117a: 6248         	str	r0, [r1, #0x24]
700a117c: e7ff         	b	0x700a117e <UART_procLineStatusErr+0x11e> @ imm = #-0x2
700a117e: e7ff         	b	0x700a1180 <UART_procLineStatusErr+0x120> @ imm = #-0x2
700a1180: e7ff         	b	0x700a1182 <UART_procLineStatusErr+0x122> @ imm = #-0x2
;             }
700a1182: e7ff         	b	0x700a1184 <UART_procLineStatusErr+0x124> @ imm = #-0x2
;             hUart->hUartInit->errorCallbackFxn(hUart);
700a1184: 9805         	ldr	r0, [sp, #0x14]
700a1186: 6841         	ldr	r1, [r0, #0x4]
700a1188: 6e49         	ldr	r1, [r1, #0x64]
700a118a: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->readTrans);
700a118c: 9805         	ldr	r0, [sp, #0x14]
700a118e: 3028         	adds	r0, #0x28
700a1190: f00c fbbe    	bl	0x700ad910 <UART_lld_Transaction_deInit> @ imm = #0xc77c
;         }
700a1194: e7ff         	b	0x700a1196 <UART_procLineStatusErr+0x136> @ imm = #-0x2
;     }
700a1196: e7ff         	b	0x700a1198 <UART_procLineStatusErr+0x138> @ imm = #-0x2
;     return status;
700a1198: 9804         	ldr	r0, [sp, #0x10]
700a119a: b006         	add	sp, #0x18
700a119c: bd80         	pop	{r7, pc}
700a119e: 0000         	movs	r0, r0

700a11a0 <prvProcessReceivedCommands>:
;     {
700a11a0: b580         	push	{r7, lr}
700a11a2: b08c         	sub	sp, #0x30
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
700a11a4: e7ff         	b	0x700a11a6 <prvProcessReceivedCommands+0x6> @ imm = #-0x2
700a11a6: f640 50f8    	movw	r0, #0xdf8
700a11aa: f2c7 000b    	movt	r0, #0x700b
700a11ae: 6800         	ldr	r0, [r0]
700a11b0: a908         	add	r1, sp, #0x20
700a11b2: 2200         	movs	r2, #0x0
700a11b4: f000 fd6c    	bl	0x700a1c90 <xQueueReceive> @ imm = #0xad8
700a11b8: 2800         	cmp	r0, #0x0
700a11ba: f000 808c    	beq.w	0x700a12d6 <prvProcessReceivedCommands+0x136> @ imm = #0x118
700a11be: e7ff         	b	0x700a11c0 <prvProcessReceivedCommands+0x20> @ imm = #-0x2
;                     if( xMessage.xMessageID < ( BaseType_t ) 0 )
700a11c0: 9808         	ldr	r0, [sp, #0x20]
700a11c2: f1b0 3fff    	cmp.w	r0, #0xffffffff
700a11c6: dc09         	bgt	0x700a11dc <prvProcessReceivedCommands+0x3c> @ imm = #0x12
700a11c8: e7ff         	b	0x700a11ca <prvProcessReceivedCommands+0x2a> @ imm = #-0x2
700a11ca: a808         	add	r0, sp, #0x20
;                         const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
700a11cc: 3004         	adds	r0, #0x4
700a11ce: 9003         	str	r0, [sp, #0xc]
;                         pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
700a11d0: 9903         	ldr	r1, [sp, #0xc]
700a11d2: 680a         	ldr	r2, [r1]
700a11d4: 6848         	ldr	r0, [r1, #0x4]
700a11d6: 6889         	ldr	r1, [r1, #0x8]
700a11d8: 4790         	blx	r2
;                     }
700a11da: e000         	b	0x700a11de <prvProcessReceivedCommands+0x3e> @ imm = #0x0
700a11dc: e7ff         	b	0x700a11de <prvProcessReceivedCommands+0x3e> @ imm = #-0x2
;             if( xMessage.xMessageID >= ( BaseType_t ) 0 )
700a11de: 9808         	ldr	r0, [sp, #0x20]
700a11e0: 2800         	cmp	r0, #0x0
700a11e2: f100 8077    	bmi.w	0x700a12d4 <prvProcessReceivedCommands+0x134> @ imm = #0xee
700a11e6: e7ff         	b	0x700a11e8 <prvProcessReceivedCommands+0x48> @ imm = #-0x2
;                 pxTimer = xMessage.u.xTimerParameters.pxTimer;
700a11e8: 980a         	ldr	r0, [sp, #0x28]
700a11ea: 9007         	str	r0, [sp, #0x1c]
;                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
700a11ec: 9807         	ldr	r0, [sp, #0x1c]
700a11ee: 6940         	ldr	r0, [r0, #0x14]
700a11f0: b128         	cbz	r0, 0x700a11fe <prvProcessReceivedCommands+0x5e> @ imm = #0xa
700a11f2: e7ff         	b	0x700a11f4 <prvProcessReceivedCommands+0x54> @ imm = #-0x2
;                     ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a11f4: 9807         	ldr	r0, [sp, #0x1c]
700a11f6: 3004         	adds	r0, #0x4
700a11f8: f00a fc7a    	bl	0x700abaf0 <uxListRemove> @ imm = #0xa8f4
;                 }
700a11fc: e000         	b	0x700a1200 <prvProcessReceivedCommands+0x60> @ imm = #0x0
700a11fe: e7ff         	b	0x700a1200 <prvProcessReceivedCommands+0x60> @ imm = #-0x2
700a1200: a806         	add	r0, sp, #0x18
;                 xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
700a1202: f00a fddd    	bl	0x700abdc0 <prvSampleTimeNow> @ imm = #0xabba
700a1206: 9004         	str	r0, [sp, #0x10]
;                 switch( xMessage.xMessageID )
700a1208: 9808         	ldr	r0, [sp, #0x20]
700a120a: 9002         	str	r0, [sp, #0x8]
700a120c: 2809         	cmp	r0, #0x9
700a120e: d85f         	bhi	0x700a12d0 <prvProcessReceivedCommands+0x130> @ imm = #0xbe
700a1210: 9902         	ldr	r1, [sp, #0x8]
700a1212: e8df f001    	tbb	[pc, r1]
700a1216: 05 05 05 2f  	.word	0x2f050505
700a121a: 37 49 05 05  	.word	0x05054937
700a121e: 2f 37        	.short	0x372f
;                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
700a1220: 9907         	ldr	r1, [sp, #0x1c]
700a1222: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a1226: f040 0001    	orr	r0, r0, #0x1
700a122a: f881 0028    	strb.w	r0, [r1, #0x28]
;                         if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
700a122e: 9807         	ldr	r0, [sp, #0x1c]
700a1230: 9b09         	ldr	r3, [sp, #0x24]
700a1232: 6981         	ldr	r1, [r0, #0x18]
700a1234: 4419         	add	r1, r3
700a1236: 9a04         	ldr	r2, [sp, #0x10]
700a1238: f007 fbfa    	bl	0x700a8a30 <prvInsertTimerInActiveList> @ imm = #0x77f4
700a123c: b1c0         	cbz	r0, 0x700a1270 <prvProcessReceivedCommands+0xd0> @ imm = #0x30
700a123e: e7ff         	b	0x700a1240 <prvProcessReceivedCommands+0xa0> @ imm = #-0x2
;                             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a1240: 9807         	ldr	r0, [sp, #0x1c]
700a1242: 6a01         	ldr	r1, [r0, #0x20]
700a1244: 4788         	blx	r1
;                             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a1246: 9807         	ldr	r0, [sp, #0x1c]
700a1248: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a124c: 0740         	lsls	r0, r0, #0x1d
700a124e: 2800         	cmp	r0, #0x0
700a1250: d50c         	bpl	0x700a126c <prvProcessReceivedCommands+0xcc> @ imm = #0x18
700a1252: e7ff         	b	0x700a1254 <prvProcessReceivedCommands+0xb4> @ imm = #-0x2
;                                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
700a1254: 9807         	ldr	r0, [sp, #0x1c]
700a1256: 9909         	ldr	r1, [sp, #0x24]
700a1258: 6982         	ldr	r2, [r0, #0x18]
700a125a: 440a         	add	r2, r1
700a125c: 4669         	mov	r1, sp
700a125e: 2300         	movs	r3, #0x0
700a1260: 600b         	str	r3, [r1]
700a1262: 4619         	mov	r1, r3
700a1264: f006 feb4    	bl	0x700a7fd0 <xTimerGenericCommand> @ imm = #0x6d68
700a1268: 9005         	str	r0, [sp, #0x14]
;                             }
700a126a: e000         	b	0x700a126e <prvProcessReceivedCommands+0xce> @ imm = #0x0
700a126c: e7ff         	b	0x700a126e <prvProcessReceivedCommands+0xce> @ imm = #-0x2
;                         }
700a126e: e000         	b	0x700a1272 <prvProcessReceivedCommands+0xd2> @ imm = #0x0
700a1270: e7ff         	b	0x700a1272 <prvProcessReceivedCommands+0xd2> @ imm = #-0x2
;                         break;
700a1272: e02e         	b	0x700a12d2 <prvProcessReceivedCommands+0x132> @ imm = #0x5c
;                         pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a1274: 9907         	ldr	r1, [sp, #0x1c]
700a1276: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a127a: f000 00fe    	and	r0, r0, #0xfe
700a127e: f881 0028    	strb.w	r0, [r1, #0x28]
;                         break;
700a1282: e026         	b	0x700a12d2 <prvProcessReceivedCommands+0x132> @ imm = #0x4c
;                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
700a1284: 9907         	ldr	r1, [sp, #0x1c]
700a1286: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a128a: f040 0001    	orr	r0, r0, #0x1
700a128e: f881 0028    	strb.w	r0, [r1, #0x28]
;                         pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
700a1292: 9809         	ldr	r0, [sp, #0x24]
700a1294: 9907         	ldr	r1, [sp, #0x1c]
700a1296: 6188         	str	r0, [r1, #0x18]
;                         ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
700a1298: 9807         	ldr	r0, [sp, #0x1c]
700a129a: 9b04         	ldr	r3, [sp, #0x10]
700a129c: 6981         	ldr	r1, [r0, #0x18]
700a129e: 4419         	add	r1, r3
700a12a0: 461a         	mov	r2, r3
700a12a2: f007 fbc5    	bl	0x700a8a30 <prvInsertTimerInActiveList> @ imm = #0x778a
;                         break;
700a12a6: e014         	b	0x700a12d2 <prvProcessReceivedCommands+0x132> @ imm = #0x28
;                                 if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
700a12a8: 9807         	ldr	r0, [sp, #0x1c]
700a12aa: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a12ae: 0780         	lsls	r0, r0, #0x1e
700a12b0: 2800         	cmp	r0, #0x0
700a12b2: d404         	bmi	0x700a12be <prvProcessReceivedCommands+0x11e> @ imm = #0x8
700a12b4: e7ff         	b	0x700a12b6 <prvProcessReceivedCommands+0x116> @ imm = #-0x2
;                                     vPortFree( pxTimer );
700a12b6: 9807         	ldr	r0, [sp, #0x1c]
700a12b8: f00c faca    	bl	0x700ad850 <vPortFree>  @ imm = #0xc594
;                                 }
700a12bc: e007         	b	0x700a12ce <prvProcessReceivedCommands+0x12e> @ imm = #0xe
;                                     pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a12be: 9907         	ldr	r1, [sp, #0x1c]
700a12c0: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a12c4: f000 00fe    	and	r0, r0, #0xfe
700a12c8: f881 0028    	strb.w	r0, [r1, #0x28]
700a12cc: e7ff         	b	0x700a12ce <prvProcessReceivedCommands+0x12e> @ imm = #-0x2
;                         break;
700a12ce: e000         	b	0x700a12d2 <prvProcessReceivedCommands+0x132> @ imm = #0x0
;                         break;
700a12d0: e7ff         	b	0x700a12d2 <prvProcessReceivedCommands+0x132> @ imm = #-0x2
;             }
700a12d2: e7ff         	b	0x700a12d4 <prvProcessReceivedCommands+0x134> @ imm = #-0x2
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
700a12d4: e767         	b	0x700a11a6 <prvProcessReceivedCommands+0x6> @ imm = #-0x132
;     }
700a12d6: b00c         	add	sp, #0x30
700a12d8: bd80         	pop	{r7, pc}
700a12da: 0000         	movs	r0, r0
700a12dc: 0000         	movs	r0, r0
700a12de: 0000         	movs	r0, r0

700a12e0 <_ntoa_long_long>:
; {
700a12e0: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
700a12e4: b09e         	sub	sp, #0x78
700a12e6: 469e         	mov	lr, r3
700a12e8: 4614         	mov	r4, r2
700a12ea: 460d         	mov	r5, r1
700a12ec: 4606         	mov	r6, r0
700a12ee: 9929         	ldr	r1, [sp, #0xa4]
700a12f0: 9828         	ldr	r0, [sp, #0xa0]
700a12f2: f8dd c094    	ldr.w	r12, [sp, #0x94]
700a12f6: 9b24         	ldr	r3, [sp, #0x90]
700a12f8: 9a2c         	ldr	r2, [sp, #0xb0]
700a12fa: 9a2b         	ldr	r2, [sp, #0xac]
700a12fc: 9a2a         	ldr	r2, [sp, #0xa8]
700a12fe: 9a26         	ldr	r2, [sp, #0x98]
700a1300: 961d         	str	r6, [sp, #0x74]
700a1302: 951c         	str	r5, [sp, #0x70]
700a1304: 941b         	str	r4, [sp, #0x6c]
700a1306: f8cd e068    	str.w	lr, [sp, #0x68]
700a130a: f8cd c064    	str.w	r12, [sp, #0x64]
700a130e: 9318         	str	r3, [sp, #0x60]
700a1310: f88d 205f    	strb.w	r2, [sp, #0x5f]
700a1314: 9115         	str	r1, [sp, #0x54]
700a1316: 9014         	str	r0, [sp, #0x50]
700a1318: 2000         	movs	r0, #0x0
;   size_t len = 0U;
700a131a: 900b         	str	r0, [sp, #0x2c]
;   if (!value) {
700a131c: 9818         	ldr	r0, [sp, #0x60]
700a131e: 9919         	ldr	r1, [sp, #0x64]
700a1320: 4308         	orrs	r0, r1
700a1322: b928         	cbnz	r0, 0x700a1330 <_ntoa_long_long+0x50> @ imm = #0xa
700a1324: e7ff         	b	0x700a1326 <_ntoa_long_long+0x46> @ imm = #-0x2
;     flags &= ~FLAGS_HASH;
700a1326: 982c         	ldr	r0, [sp, #0xb0]
700a1328: f020 0010    	bic	r0, r0, #0x10
700a132c: 902c         	str	r0, [sp, #0xb0]
;   }
700a132e: e7ff         	b	0x700a1330 <_ntoa_long_long+0x50> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION) || value) {
700a1330: f89d 00b1    	ldrb.w	r0, [sp, #0xb1]
700a1334: 0740         	lsls	r0, r0, #0x1d
700a1336: 2800         	cmp	r0, #0x0
700a1338: d506         	bpl	0x700a1348 <_ntoa_long_long+0x68> @ imm = #0xc
700a133a: e7ff         	b	0x700a133c <_ntoa_long_long+0x5c> @ imm = #-0x2
700a133c: 9818         	ldr	r0, [sp, #0x60]
700a133e: 9919         	ldr	r1, [sp, #0x64]
700a1340: 4308         	orrs	r0, r1
700a1342: 2800         	cmp	r0, #0x0
700a1344: d043         	beq	0x700a13ce <_ntoa_long_long+0xee> @ imm = #0x86
700a1346: e7ff         	b	0x700a1348 <_ntoa_long_long+0x68> @ imm = #-0x2
;     do {
700a1348: e7ff         	b	0x700a134a <_ntoa_long_long+0x6a> @ imm = #-0x2
;       const char digit = (char)(value % base);
700a134a: 9818         	ldr	r0, [sp, #0x60]
700a134c: 9919         	ldr	r1, [sp, #0x64]
700a134e: 9a14         	ldr	r2, [sp, #0x50]
700a1350: 9b15         	ldr	r3, [sp, #0x54]
700a1352: f00c e9a0    	blx	0x700ad694 <__aeabi_uldivmod> @ imm = #0xc340
700a1356: f88d 202b    	strb.w	r2, [sp, #0x2b]
;       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
700a135a: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
700a135e: 2809         	cmp	r0, #0x9
700a1360: dc05         	bgt	0x700a136e <_ntoa_long_long+0x8e> @ imm = #0xa
700a1362: e7ff         	b	0x700a1364 <_ntoa_long_long+0x84> @ imm = #-0x2
700a1364: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
700a1368: 3030         	adds	r0, #0x30
700a136a: 9009         	str	r0, [sp, #0x24]
700a136c: e00c         	b	0x700a1388 <_ntoa_long_long+0xa8> @ imm = #0x18
700a136e: f89d 00b0    	ldrb.w	r0, [sp, #0xb0]
700a1372: 0681         	lsls	r1, r0, #0x1a
700a1374: 2061         	movs	r0, #0x61
700a1376: 2900         	cmp	r1, #0x0
700a1378: bf48         	it	mi
700a137a: 2041         	movmi	r0, #0x41
700a137c: f89d 102b    	ldrb.w	r1, [sp, #0x2b]
700a1380: 4408         	add	r0, r1
700a1382: 380a         	subs	r0, #0xa
700a1384: 9009         	str	r0, [sp, #0x24]
700a1386: e7ff         	b	0x700a1388 <_ntoa_long_long+0xa8> @ imm = #-0x2
700a1388: 9809         	ldr	r0, [sp, #0x24]
700a138a: 9a0b         	ldr	r2, [sp, #0x2c]
700a138c: 1c51         	adds	r1, r2, #0x1
700a138e: 910b         	str	r1, [sp, #0x2c]
700a1390: a90c         	add	r1, sp, #0x30
700a1392: 5488         	strb	r0, [r1, r2]
;       value /= base;
700a1394: 9a14         	ldr	r2, [sp, #0x50]
700a1396: 9b15         	ldr	r3, [sp, #0x54]
700a1398: 9818         	ldr	r0, [sp, #0x60]
700a139a: 9919         	ldr	r1, [sp, #0x64]
700a139c: f00c e97a    	blx	0x700ad694 <__aeabi_uldivmod> @ imm = #0xc2f4
700a13a0: 9119         	str	r1, [sp, #0x64]
700a13a2: 9018         	str	r0, [sp, #0x60]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a13a4: e7ff         	b	0x700a13a6 <_ntoa_long_long+0xc6> @ imm = #-0x2
700a13a6: 9818         	ldr	r0, [sp, #0x60]
700a13a8: 9919         	ldr	r1, [sp, #0x64]
700a13aa: 4301         	orrs	r1, r0
700a13ac: 2000         	movs	r0, #0x0
700a13ae: 9008         	str	r0, [sp, #0x20]
700a13b0: b139         	cbz	r1, 0x700a13c2 <_ntoa_long_long+0xe2> @ imm = #0xe
700a13b2: e7ff         	b	0x700a13b4 <_ntoa_long_long+0xd4> @ imm = #-0x2
700a13b4: 990b         	ldr	r1, [sp, #0x2c]
700a13b6: 2000         	movs	r0, #0x0
700a13b8: 2920         	cmp	r1, #0x20
700a13ba: bf38         	it	lo
700a13bc: 2001         	movlo	r0, #0x1
700a13be: 9008         	str	r0, [sp, #0x20]
700a13c0: e7ff         	b	0x700a13c2 <_ntoa_long_long+0xe2> @ imm = #-0x2
700a13c2: 9808         	ldr	r0, [sp, #0x20]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a13c4: 07c0         	lsls	r0, r0, #0x1f
700a13c6: 2800         	cmp	r0, #0x0
700a13c8: d1bf         	bne	0x700a134a <_ntoa_long_long+0x6a> @ imm = #-0x82
700a13ca: e7ff         	b	0x700a13cc <_ntoa_long_long+0xec> @ imm = #-0x2
;   }
700a13cc: e7ff         	b	0x700a13ce <_ntoa_long_long+0xee> @ imm = #-0x2
;   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
700a13ce: 981d         	ldr	r0, [sp, #0x74]
700a13d0: 991c         	ldr	r1, [sp, #0x70]
700a13d2: 9a1b         	ldr	r2, [sp, #0x6c]
700a13d4: 9b1a         	ldr	r3, [sp, #0x68]
700a13d6: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a13da: 9d14         	ldr	r5, [sp, #0x50]
700a13dc: 9e2a         	ldr	r6, [sp, #0xa8]
700a13de: 9f2b         	ldr	r7, [sp, #0xac]
700a13e0: f8dd 80b0    	ldr.w	r8, [sp, #0xb0]
700a13e4: f89d 405f    	ldrb.w	r4, [sp, #0x5f]
700a13e8: 46ee         	mov	lr, sp
700a13ea: f8ce 8018    	str.w	r8, [lr, #0x18]
700a13ee: f8ce 7014    	str.w	r7, [lr, #0x14]
700a13f2: f8ce 6010    	str.w	r6, [lr, #0x10]
700a13f6: f8ce 500c    	str.w	r5, [lr, #0xc]
700a13fa: f004 0401    	and	r4, r4, #0x1
700a13fe: f8ce 4008    	str.w	r4, [lr, #0x8]
700a1402: f8ce c004    	str.w	r12, [lr, #0x4]
700a1406: f10d 0c30    	add.w	r12, sp, #0x30
700a140a: f8ce c000    	str.w	r12, [lr]
700a140e: f7fb fee7    	bl	0x7009d1e0 <_ntoa_format> @ imm = #-0x4232
700a1412: b01e         	add	sp, #0x78
700a1414: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
		...

700a1420 <Sciclient_rmIrqVintDelete>:
; {
700a1420: b580         	push	{r7, lr}
700a1422: b08c         	sub	sp, #0x30
700a1424: 900b         	str	r0, [sp, #0x2c]
700a1426: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a1428: 900a         	str	r0, [sp, #0x28]
;     bool del_mapping = false;
700a142a: f88d 0026    	strb.w	r0, [sp, #0x26]
;     bool del_whole_route = false;
700a142e: f88d 0025    	strb.w	r0, [sp, #0x25]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a1432: 9008         	str	r0, [sp, #0x20]
;     if (r == SystemP_SUCCESS) {
700a1434: 980a         	ldr	r0, [sp, #0x28]
700a1436: b948         	cbnz	r0, 0x700a144c <Sciclient_rmIrqVintDelete+0x2c> @ imm = #0x12
700a1438: e7ff         	b	0x700a143a <Sciclient_rmIrqVintDelete+0x1a> @ imm = #-0x2
;         r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700a143a: 990b         	ldr	r1, [sp, #0x2c]
700a143c: 8a08         	ldrh	r0, [r1, #0x10]
700a143e: 8a49         	ldrh	r1, [r1, #0x12]
700a1440: f10d 0227    	add.w	r2, sp, #0x27
700a1444: f008 facc    	bl	0x700a99e0 <Sciclient_rmIaVintGetInfo> @ imm = #0x8598
700a1448: 900a         	str	r0, [sp, #0x28]
;     }
700a144a: e7ff         	b	0x700a144c <Sciclient_rmIrqVintDelete+0x2c> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a144c: 980a         	ldr	r0, [sp, #0x28]
700a144e: b9e8         	cbnz	r0, 0x700a148c <Sciclient_rmIrqVintDelete+0x6c> @ imm = #0x3a
700a1450: e7ff         	b	0x700a1452 <Sciclient_rmIrqVintDelete+0x32> @ imm = #-0x2
;         if (num_evts == 0u) {
700a1452: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a1456: b920         	cbnz	r0, 0x700a1462 <Sciclient_rmIrqVintDelete+0x42> @ imm = #0x8
700a1458: e7ff         	b	0x700a145a <Sciclient_rmIrqVintDelete+0x3a> @ imm = #-0x2
700a145a: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a145e: 900a         	str	r0, [sp, #0x28]
;         } else if ((num_evts > 1u) ||
700a1460: e013         	b	0x700a148a <Sciclient_rmIrqVintDelete+0x6a> @ imm = #0x26
700a1462: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a1466: 2801         	cmp	r0, #0x1
700a1468: d806         	bhi	0x700a1478 <Sciclient_rmIrqVintDelete+0x58> @ imm = #0xc
700a146a: e7ff         	b	0x700a146c <Sciclient_rmIrqVintDelete+0x4c> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg->valid_params) ==
700a146c: 980b         	ldr	r0, [sp, #0x2c]
700a146e: 6800         	ldr	r0, [r0]
700a1470: f008 fc3e    	bl	0x700a9cf0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0x887c
;         } else if ((num_evts > 1u) ||
700a1474: b120         	cbz	r0, 0x700a1480 <Sciclient_rmIrqVintDelete+0x60> @ imm = #0x8
700a1476: e7ff         	b	0x700a1478 <Sciclient_rmIrqVintDelete+0x58> @ imm = #-0x2
700a1478: 2001         	movs	r0, #0x1
;             del_mapping = true;
700a147a: f88d 0026    	strb.w	r0, [sp, #0x26]
;         } else {
700a147e: e003         	b	0x700a1488 <Sciclient_rmIrqVintDelete+0x68> @ imm = #0x6
700a1480: 2001         	movs	r0, #0x1
;             del_whole_route = true;
700a1482: f88d 0025    	strb.w	r0, [sp, #0x25]
700a1486: e7ff         	b	0x700a1488 <Sciclient_rmIrqVintDelete+0x68> @ imm = #-0x2
700a1488: e7ff         	b	0x700a148a <Sciclient_rmIrqVintDelete+0x6a> @ imm = #-0x2
;     }
700a148a: e7ff         	b	0x700a148c <Sciclient_rmIrqVintDelete+0x6c> @ imm = #-0x2
;     if (del_mapping == true) {
700a148c: f89d 0026    	ldrb.w	r0, [sp, #0x26]
700a1490: 07c0         	lsls	r0, r0, #0x1f
700a1492: 2800         	cmp	r0, #0x0
700a1494: d049         	beq	0x700a152a <Sciclient_rmIrqVintDelete+0x10a> @ imm = #0x92
700a1496: e7ff         	b	0x700a1498 <Sciclient_rmIrqVintDelete+0x78> @ imm = #-0x2
700a1498: 203c         	movs	r0, #0x3c
700a149a: f2c8 0000    	movt	r0, #0x8000
;         req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a149e: 9003         	str	r0, [sp, #0xc]
;         req.secondary_host = cfg->host;
700a14a0: 980b         	ldr	r0, [sp, #0x2c]
700a14a2: 7900         	ldrb	r0, [r0, #0x4]
700a14a4: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         req.src_id = cfg->s_id;
700a14a8: 980b         	ldr	r0, [sp, #0x2c]
700a14aa: 88c0         	ldrh	r0, [r0, #0x6]
700a14ac: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         req.src_index = cfg->s_idx;
700a14b0: 980b         	ldr	r0, [sp, #0x2c]
700a14b2: 8900         	ldrh	r0, [r0, #0x8]
700a14b4: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         req.ia_id = cfg->s_ia;
700a14b8: 980b         	ldr	r0, [sp, #0x2c]
700a14ba: 8a00         	ldrh	r0, [r0, #0x10]
700a14bc: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         req.vint = cfg->vint;
700a14c0: 980b         	ldr	r0, [sp, #0x2c]
700a14c2: 8a40         	ldrh	r0, [r0, #0x12]
700a14c4: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         req.global_event = cfg->global_evt;
700a14c8: 980b         	ldr	r0, [sp, #0x2c]
700a14ca: 89c0         	ldrh	r0, [r0, #0xe]
700a14cc: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         req.vint_status_bit_index = cfg->vint_sb;
700a14d0: 980b         	ldr	r0, [sp, #0x2c]
700a14d2: 7d00         	ldrb	r0, [r0, #0x14]
700a14d4: f88d 001e    	strb.w	r0, [sp, #0x1e]
700a14d8: a801         	add	r0, sp, #0x4
700a14da: f04f 31ff    	mov.w	r1, #0xffffffff
;         r = Sciclient_rmIrqReleaseRaw(&req,
700a14de: f009 fd67    	bl	0x700aafb0 <Sciclient_rmIrqReleaseRaw> @ imm = #0x9ace
700a14e2: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a14e4: 980a         	ldr	r0, [sp, #0x28]
700a14e6: b9f8         	cbnz	r0, 0x700a1528 <Sciclient_rmIrqVintDelete+0x108> @ imm = #0x3e
700a14e8: e7ff         	b	0x700a14ea <Sciclient_rmIrqVintDelete+0xca> @ imm = #-0x2
;             ia_inst = Sciclient_rmIaGetInst(cfg->s_ia);
700a14ea: 980b         	ldr	r0, [sp, #0x2c]
700a14ec: 8a00         	ldrh	r0, [r0, #0x10]
700a14ee: f009 fa37    	bl	0x700aa960 <Sciclient_rmIaGetInst> @ imm = #0x946e
700a14f2: 9008         	str	r0, [sp, #0x20]
;             if (ia_inst != NULL) {
700a14f4: 9808         	ldr	r0, [sp, #0x20]
700a14f6: b1b0         	cbz	r0, 0x700a1526 <Sciclient_rmIrqVintDelete+0x106> @ imm = #0x2c
700a14f8: e7ff         	b	0x700a14fa <Sciclient_rmIrqVintDelete+0xda> @ imm = #-0x2
;                 ia_inst->vint_usage_count[cfg->vint]--;
700a14fa: 9808         	ldr	r0, [sp, #0x20]
700a14fc: 6901         	ldr	r1, [r0, #0x10]
700a14fe: 980b         	ldr	r0, [sp, #0x2c]
700a1500: 8a42         	ldrh	r2, [r0, #0x12]
700a1502: 5c88         	ldrb	r0, [r1, r2]
700a1504: 3801         	subs	r0, #0x1
700a1506: 5488         	strb	r0, [r1, r2]
;                 if (ia_inst->v0_b0_evt == cfg->global_evt - ia_inst->sevt_offset) {
700a1508: 9a08         	ldr	r2, [sp, #0x20]
700a150a: 8a90         	ldrh	r0, [r2, #0x14]
700a150c: 990b         	ldr	r1, [sp, #0x2c]
700a150e: 89c9         	ldrh	r1, [r1, #0xe]
700a1510: 8912         	ldrh	r2, [r2, #0x8]
700a1512: 1a89         	subs	r1, r1, r2
700a1514: 4288         	cmp	r0, r1
700a1516: d105         	bne	0x700a1524 <Sciclient_rmIrqVintDelete+0x104> @ imm = #0xa
700a1518: e7ff         	b	0x700a151a <Sciclient_rmIrqVintDelete+0xfa> @ imm = #-0x2
;                     ia_inst->v0_b0_evt = SCICLIENT_RM_IA_GENERIC_EVT_RESETVAL;
700a151a: 9908         	ldr	r1, [sp, #0x20]
700a151c: f64f 70ff    	movw	r0, #0xffff
700a1520: 8288         	strh	r0, [r1, #0x14]
;                 }
700a1522: e7ff         	b	0x700a1524 <Sciclient_rmIrqVintDelete+0x104> @ imm = #-0x2
;             }
700a1524: e7ff         	b	0x700a1526 <Sciclient_rmIrqVintDelete+0x106> @ imm = #-0x2
;         }
700a1526: e7ff         	b	0x700a1528 <Sciclient_rmIrqVintDelete+0x108> @ imm = #-0x2
;     }
700a1528: e7ff         	b	0x700a152a <Sciclient_rmIrqVintDelete+0x10a> @ imm = #-0x2
;     if (del_whole_route == true) {
700a152a: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a152e: 07c0         	lsls	r0, r0, #0x1f
700a1530: b170         	cbz	r0, 0x700a1550 <Sciclient_rmIrqVintDelete+0x130> @ imm = #0x1c
700a1532: e7ff         	b	0x700a1534 <Sciclient_rmIrqVintDelete+0x114> @ imm = #-0x2
;         r = Sciclient_rmIrqGetRoute(cfg);
700a1534: 980b         	ldr	r0, [sp, #0x2c]
700a1536: f7fa fa6b    	bl	0x7009ba10 <Sciclient_rmIrqGetRoute> @ imm = #-0x5b2a
700a153a: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a153c: 980a         	ldr	r0, [sp, #0x28]
700a153e: b930         	cbnz	r0, 0x700a154e <Sciclient_rmIrqVintDelete+0x12e> @ imm = #0xc
700a1540: e7ff         	b	0x700a1542 <Sciclient_rmIrqVintDelete+0x122> @ imm = #-0x2
;             r = Sciclient_rmIrqDeleteRoute(cfg, true);
700a1542: 980b         	ldr	r0, [sp, #0x2c]
700a1544: 2101         	movs	r1, #0x1
700a1546: f7fd fdf3    	bl	0x7009f130 <Sciclient_rmIrqDeleteRoute> @ imm = #-0x241a
700a154a: 900a         	str	r0, [sp, #0x28]
;         }
700a154c: e7ff         	b	0x700a154e <Sciclient_rmIrqVintDelete+0x12e> @ imm = #-0x2
;     }
700a154e: e7ff         	b	0x700a1550 <Sciclient_rmIrqVintDelete+0x130> @ imm = #-0x2
;     return r;
700a1550: 980a         	ldr	r0, [sp, #0x28]
700a1552: b00c         	add	sp, #0x30
700a1554: bd80         	pop	{r7, pc}
		...
700a155e: 0000         	movs	r0, r0

700a1560 <UART_writePolling>:
; {
700a1560: b580         	push	{r7, lr}
700a1562: b08c         	sub	sp, #0x30
700a1564: 900b         	str	r0, [sp, #0x2c]
700a1566: 910a         	str	r1, [sp, #0x28]
700a1568: 2000         	movs	r0, #0x0
;     int32_t             retVal          = UART_TRANSFER_STATUS_SUCCESS;
700a156a: 9007         	str	r0, [sp, #0x1c]
;     uint32_t            timeoutElapsed  = FALSE;
700a156c: 9006         	str	r0, [sp, #0x18]
;     uint32_t            baseAddr        = hUart->baseAddr;
700a156e: 990b         	ldr	r1, [sp, #0x2c]
700a1570: 6809         	ldr	r1, [r1]
700a1572: 9105         	str	r1, [sp, #0x14]
;     uint32_t            lineStatus      = 0U;
700a1574: 9004         	str	r0, [sp, #0x10]
;     hUartInit = hUart->hUartInit;
700a1576: 980b         	ldr	r0, [sp, #0x2c]
700a1578: 6840         	ldr	r0, [r0, #0x4]
700a157a: 9003         	str	r0, [sp, #0xc]
;     hUart->writeSizeRemaining = trans->count;
700a157c: 980a         	ldr	r0, [sp, #0x28]
700a157e: 6840         	ldr	r0, [r0, #0x4]
700a1580: 990b         	ldr	r1, [sp, #0x2c]
700a1582: 6108         	str	r0, [r1, #0x10]
;     startTicks = hUartInit->clockP_get();
700a1584: 9803         	ldr	r0, [sp, #0xc]
700a1586: 6d40         	ldr	r0, [r0, #0x54]
700a1588: 4780         	blx	r0
700a158a: 9009         	str	r0, [sp, #0x24]
;     while ((FALSE == timeoutElapsed)
700a158c: e7ff         	b	0x700a158e <UART_writePolling+0x2e> @ imm = #-0x2
700a158e: 9906         	ldr	r1, [sp, #0x18]
700a1590: 2000         	movs	r0, #0x0
;            && (0U != hUart->writeSizeRemaining))
700a1592: 9002         	str	r0, [sp, #0x8]
700a1594: b939         	cbnz	r1, 0x700a15a6 <UART_writePolling+0x46> @ imm = #0xe
700a1596: e7ff         	b	0x700a1598 <UART_writePolling+0x38> @ imm = #-0x2
700a1598: 980b         	ldr	r0, [sp, #0x2c]
700a159a: 6900         	ldr	r0, [r0, #0x10]
700a159c: 2800         	cmp	r0, #0x0
700a159e: bf18         	it	ne
700a15a0: 2001         	movne	r0, #0x1
700a15a2: 9002         	str	r0, [sp, #0x8]
700a15a4: e7ff         	b	0x700a15a6 <UART_writePolling+0x46> @ imm = #-0x2
700a15a6: 9802         	ldr	r0, [sp, #0x8]
;     while ((FALSE == timeoutElapsed)
700a15a8: 07c0         	lsls	r0, r0, #0x1f
700a15aa: b198         	cbz	r0, 0x700a15d4 <UART_writePolling+0x74> @ imm = #0x26
700a15ac: e7ff         	b	0x700a15ae <UART_writePolling+0x4e> @ imm = #-0x2
;         UART_writeDataPolling(hUart);
700a15ae: 980b         	ldr	r0, [sp, #0x2c]
700a15b0: f00b f8f6    	bl	0x700ac7a0 <UART_writeDataPolling> @ imm = #0xb1ec
;         elapsedTicks = hUartInit->clockP_get() - startTicks;
700a15b4: 9803         	ldr	r0, [sp, #0xc]
700a15b6: 6d40         	ldr	r0, [r0, #0x54]
700a15b8: 4780         	blx	r0
700a15ba: 9909         	ldr	r1, [sp, #0x24]
700a15bc: 1a40         	subs	r0, r0, r1
700a15be: 9008         	str	r0, [sp, #0x20]
;         if (elapsedTicks >= trans->timeout)
700a15c0: 9808         	ldr	r0, [sp, #0x20]
700a15c2: 990a         	ldr	r1, [sp, #0x28]
700a15c4: 6889         	ldr	r1, [r1, #0x8]
700a15c6: 4288         	cmp	r0, r1
700a15c8: d303         	blo	0x700a15d2 <UART_writePolling+0x72> @ imm = #0x6
700a15ca: e7ff         	b	0x700a15cc <UART_writePolling+0x6c> @ imm = #-0x2
700a15cc: 2001         	movs	r0, #0x1
;             timeoutElapsed = TRUE;
700a15ce: 9006         	str	r0, [sp, #0x18]
;         }
700a15d0: e7ff         	b	0x700a15d2 <UART_writePolling+0x72> @ imm = #-0x2
;     while ((FALSE == timeoutElapsed)
700a15d2: e7dc         	b	0x700a158e <UART_writePolling+0x2e> @ imm = #-0x48
;     if (0U == hUart->writeSizeRemaining)
700a15d4: 980b         	ldr	r0, [sp, #0x2c]
700a15d6: 6900         	ldr	r0, [r0, #0x10]
700a15d8: 2800         	cmp	r0, #0x0
700a15da: d149         	bne	0x700a1670 <UART_writePolling+0x110> @ imm = #0x92
700a15dc: e7ff         	b	0x700a15de <UART_writePolling+0x7e> @ imm = #-0x2
;         do
700a15de: e7ff         	b	0x700a15e0 <UART_writePolling+0x80> @ imm = #-0x2
;             lineStatus = UART_readLineStatus(baseAddr);
700a15e0: 9805         	ldr	r0, [sp, #0x14]
700a15e2: f00a fb4d    	bl	0x700abc80 <UART_readLineStatus> @ imm = #0xa69a
700a15e6: 9004         	str	r0, [sp, #0x10]
;             elapsedTicks = hUartInit->clockP_get() - startTicks;
700a15e8: 9803         	ldr	r0, [sp, #0xc]
700a15ea: 6d40         	ldr	r0, [r0, #0x54]
700a15ec: 4780         	blx	r0
700a15ee: 9909         	ldr	r1, [sp, #0x24]
700a15f0: 1a40         	subs	r0, r0, r1
700a15f2: 9008         	str	r0, [sp, #0x20]
;         }
700a15f4: e7ff         	b	0x700a15f6 <UART_writePolling+0x96> @ imm = #-0x2
;                (lineStatus & (uint32_t) (UART_LSR_TX_FIFO_E_MASK |
700a15f6: 9804         	ldr	r0, [sp, #0x10]
700a15f8: f000 0160    	and	r1, r0, #0x60
700a15fc: 2000         	movs	r0, #0x0
;                 && (elapsedTicks < hUart->lineStatusTimeout));
700a15fe: 2960         	cmp	r1, #0x60
700a1600: 9001         	str	r0, [sp, #0x4]
700a1602: d00d         	beq	0x700a1620 <UART_writePolling+0xc0> @ imm = #0x1a
700a1604: e7ff         	b	0x700a1606 <UART_writePolling+0xa6> @ imm = #-0x2
700a1606: 9808         	ldr	r0, [sp, #0x20]
700a1608: 990b         	ldr	r1, [sp, #0x2c]
700a160a: 6e8a         	ldr	r2, [r1, #0x68]
700a160c: 6ec9         	ldr	r1, [r1, #0x6c]
700a160e: 1a80         	subs	r0, r0, r2
700a1610: f04f 0000    	mov.w	r0, #0x0
700a1614: eb70 0101    	sbcs.w	r1, r0, r1
700a1618: bf38         	it	lo
700a161a: 2001         	movlo	r0, #0x1
700a161c: 9001         	str	r0, [sp, #0x4]
700a161e: e7ff         	b	0x700a1620 <UART_writePolling+0xc0> @ imm = #-0x2
700a1620: 9801         	ldr	r0, [sp, #0x4]
;         }
700a1622: 07c0         	lsls	r0, r0, #0x1f
700a1624: 2800         	cmp	r0, #0x0
700a1626: d1db         	bne	0x700a15e0 <UART_writePolling+0x80> @ imm = #-0x4a
700a1628: e7ff         	b	0x700a162a <UART_writePolling+0xca> @ imm = #-0x2
;         if(elapsedTicks >= hUart->lineStatusTimeout)
700a162a: 9808         	ldr	r0, [sp, #0x20]
700a162c: 990b         	ldr	r1, [sp, #0x2c]
700a162e: 6e8a         	ldr	r2, [r1, #0x68]
700a1630: 6ec9         	ldr	r1, [r1, #0x6c]
700a1632: 1a80         	subs	r0, r0, r2
700a1634: f04f 0000    	mov.w	r0, #0x0
700a1638: 4188         	sbcs	r0, r1
700a163a: d30f         	blo	0x700a165c <UART_writePolling+0xfc> @ imm = #0x1e
700a163c: e7ff         	b	0x700a163e <UART_writePolling+0xde> @ imm = #-0x2
700a163e: f06f 0001    	mvn	r0, #0x1
;             retVal             = UART_TRANSFER_TIMEOUT;
700a1642: 9007         	str	r0, [sp, #0x1c]
;             trans->status      = UART_TRANSFER_STATUS_TIMEOUT;
700a1644: 990a         	ldr	r1, [sp, #0x28]
700a1646: 2001         	movs	r0, #0x1
700a1648: 60c8         	str	r0, [r1, #0xc]
;             trans->count       = hUart->writeCount;
700a164a: 980b         	ldr	r0, [sp, #0x2c]
700a164c: 68c0         	ldr	r0, [r0, #0xc]
700a164e: 990a         	ldr	r1, [sp, #0x28]
700a1650: 6048         	str	r0, [r1, #0x4]
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a1652: 980b         	ldr	r0, [sp, #0x2c]
700a1654: 303c         	adds	r0, #0x3c
700a1656: f00c f95b    	bl	0x700ad910 <UART_lld_Transaction_deInit> @ imm = #0xc2b6
;         }
700a165a: e008         	b	0x700a166e <UART_writePolling+0x10e> @ imm = #0x10
700a165c: 2000         	movs	r0, #0x0
;             retVal             = UART_TRANSFER_STATUS_SUCCESS;
700a165e: 9007         	str	r0, [sp, #0x1c]
;             trans->status      = UART_TRANSFER_STATUS_SUCCESS;
700a1660: 990a         	ldr	r1, [sp, #0x28]
700a1662: 60c8         	str	r0, [r1, #0xc]
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a1664: 980b         	ldr	r0, [sp, #0x2c]
700a1666: 303c         	adds	r0, #0x3c
700a1668: f00c f952    	bl	0x700ad910 <UART_lld_Transaction_deInit> @ imm = #0xc2a4
700a166c: e7ff         	b	0x700a166e <UART_writePolling+0x10e> @ imm = #-0x2
;     }
700a166e: e00e         	b	0x700a168e <UART_writePolling+0x12e> @ imm = #0x1c
700a1670: f06f 0001    	mvn	r0, #0x1
;         retVal             = UART_TRANSFER_TIMEOUT;
700a1674: 9007         	str	r0, [sp, #0x1c]
;         trans->status      = UART_TRANSFER_STATUS_TIMEOUT;
700a1676: 990a         	ldr	r1, [sp, #0x28]
700a1678: 2001         	movs	r0, #0x1
700a167a: 60c8         	str	r0, [r1, #0xc]
;         trans->count       = hUart->writeCount;
700a167c: 980b         	ldr	r0, [sp, #0x2c]
700a167e: 68c0         	ldr	r0, [r0, #0xc]
700a1680: 990a         	ldr	r1, [sp, #0x28]
700a1682: 6048         	str	r0, [r1, #0x4]
;         UART_lld_Transaction_deInit(&hUart->writeTrans);
700a1684: 980b         	ldr	r0, [sp, #0x2c]
700a1686: 303c         	adds	r0, #0x3c
700a1688: f00c f942    	bl	0x700ad910 <UART_lld_Transaction_deInit> @ imm = #0xc284
700a168c: e7ff         	b	0x700a168e <UART_writePolling+0x12e> @ imm = #-0x2
;     return (retVal);
700a168e: 9807         	ldr	r0, [sp, #0x1c]
700a1690: b00c         	add	sp, #0x30
700a1692: bd80         	pop	{r7, pc}
		...

700a16a0 <Sciclient_recvMessage>:
; {
700a16a0: b580         	push	{r7, lr}
700a16a2: b08e         	sub	sp, #0x38
700a16a4: 900d         	str	r0, [sp, #0x34]
700a16a6: 910c         	str	r1, [sp, #0x30]
700a16a8: 920b         	str	r2, [sp, #0x2c]
700a16aa: 2000         	movs	r0, #0x0
;     uint8_t  trailBytes = 0U;
700a16ac: f88d 0023    	strb.w	r0, [sp, #0x23]
;     numWords   = (uint32_t) (rxPayloadSize / 4U);
700a16b0: 990b         	ldr	r1, [sp, #0x2c]
700a16b2: ea4f 0191    	lsr.w	r1, r1, #0x2
700a16b6: 910a         	str	r1, [sp, #0x28]
;     trailBytes = (uint8_t) (rxPayloadSize - (numWords * 4U));
700a16b8: 990b         	ldr	r1, [sp, #0x2c]
700a16ba: 9a0a         	ldr	r2, [sp, #0x28]
700a16bc: eba1 0182    	sub.w	r1, r1, r2, lsl #2
700a16c0: f88d 1023    	strb.w	r1, [sp, #0x23]
;     for (i = 0; i < numWords; i++)
700a16c4: 9009         	str	r0, [sp, #0x24]
700a16c6: e7ff         	b	0x700a16c8 <Sciclient_recvMessage+0x28> @ imm = #-0x2
700a16c8: 9809         	ldr	r0, [sp, #0x24]
700a16ca: 990a         	ldr	r1, [sp, #0x28]
700a16cc: 4288         	cmp	r0, r1
700a16ce: d22c         	bhs	0x700a172a <Sciclient_recvMessage+0x8a> @ imm = #0x58
700a16d0: e7ff         	b	0x700a16d2 <Sciclient_recvMessage+0x32> @ imm = #-0x2
;             rxThread,
700a16d2: 980d         	ldr	r0, [sp, #0x34]
;             ((uint8_t) i +
700a16d4: 9909         	ldr	r1, [sp, #0x24]
;                 SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a16d6: f640 6204    	movw	r2, #0xe04
700a16da: f2c7 020b    	movt	r2, #0x700b
700a16de: 7812         	ldrb	r2, [r2]
;             ((uint8_t) i +
700a16e0: 4411         	add	r1, r2
;                 SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a16e2: 3102         	adds	r1, #0x2
;         uint32_t tempWord = Sciclient_secProxyReadThread32(
700a16e4: b2c9         	uxtb	r1, r1
700a16e6: f00b fb5b    	bl	0x700acda0 <Sciclient_secProxyReadThread32> @ imm = #0xb6b6
700a16ea: 9007         	str	r0, [sp, #0x1c]
700a16ec: a807         	add	r0, sp, #0x1c
;         uint8_t * tempWordPtr = (uint8_t*) & tempWord;
700a16ee: 9006         	str	r0, [sp, #0x18]
700a16f0: 2000         	movs	r0, #0x0
;         uint32_t j = 0U;
700a16f2: 9005         	str	r0, [sp, #0x14]
;         for (j = 0U; j < 4U; j++)
700a16f4: 9005         	str	r0, [sp, #0x14]
700a16f6: e7ff         	b	0x700a16f8 <Sciclient_recvMessage+0x58> @ imm = #-0x2
700a16f8: 9805         	ldr	r0, [sp, #0x14]
700a16fa: 2803         	cmp	r0, #0x3
700a16fc: d810         	bhi	0x700a1720 <Sciclient_recvMessage+0x80> @ imm = #0x20
700a16fe: e7ff         	b	0x700a1700 <Sciclient_recvMessage+0x60> @ imm = #-0x2
;             *(pLocalRespPayload + i * 4 + j) = *tempWordPtr;
700a1700: 9806         	ldr	r0, [sp, #0x18]
700a1702: 7800         	ldrb	r0, [r0]
700a1704: 990c         	ldr	r1, [sp, #0x30]
700a1706: 9a09         	ldr	r2, [sp, #0x24]
700a1708: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a170c: 9a05         	ldr	r2, [sp, #0x14]
700a170e: 5488         	strb	r0, [r1, r2]
;             tempWordPtr++;
700a1710: 9806         	ldr	r0, [sp, #0x18]
700a1712: 3001         	adds	r0, #0x1
700a1714: 9006         	str	r0, [sp, #0x18]
;         }
700a1716: e7ff         	b	0x700a1718 <Sciclient_recvMessage+0x78> @ imm = #-0x2
;         for (j = 0U; j < 4U; j++)
700a1718: 9805         	ldr	r0, [sp, #0x14]
700a171a: 3001         	adds	r0, #0x1
700a171c: 9005         	str	r0, [sp, #0x14]
700a171e: e7eb         	b	0x700a16f8 <Sciclient_recvMessage+0x58> @ imm = #-0x2a
;     }
700a1720: e7ff         	b	0x700a1722 <Sciclient_recvMessage+0x82> @ imm = #-0x2
;     for (i = 0; i < numWords; i++)
700a1722: 9809         	ldr	r0, [sp, #0x24]
700a1724: 3001         	adds	r0, #0x1
700a1726: 9009         	str	r0, [sp, #0x24]
700a1728: e7ce         	b	0x700a16c8 <Sciclient_recvMessage+0x28> @ imm = #-0x64
;     if (trailBytes > 0U)
700a172a: f89d 0023    	ldrb.w	r0, [sp, #0x23]
700a172e: b368         	cbz	r0, 0x700a178c <Sciclient_recvMessage+0xec> @ imm = #0x5a
700a1730: e7ff         	b	0x700a1732 <Sciclient_recvMessage+0x92> @ imm = #-0x2
;                 rxThread,
700a1732: 980d         	ldr	r0, [sp, #0x34]
;                 ((uint8_t)i +
700a1734: 9909         	ldr	r1, [sp, #0x24]
;                     SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a1736: f640 6204    	movw	r2, #0xe04
700a173a: f2c7 020b    	movt	r2, #0x700b
700a173e: 7812         	ldrb	r2, [r2]
;                 ((uint8_t)i +
700a1740: 4411         	add	r1, r2
;                     SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a1742: 3102         	adds	r1, #0x2
;         uint32_t tempWord = Sciclient_secProxyReadThread32(
700a1744: b2c9         	uxtb	r1, r1
700a1746: f00b fb2b    	bl	0x700acda0 <Sciclient_secProxyReadThread32> @ imm = #0xb656
700a174a: 9004         	str	r0, [sp, #0x10]
700a174c: a804         	add	r0, sp, #0x10
;         uint8_t * pTempWord = (uint8_t*) &tempWord;
700a174e: 9003         	str	r0, [sp, #0xc]
700a1750: 2000         	movs	r0, #0x0
;         for (bytes = 0U; bytes < trailBytes; bytes++)
700a1752: 9002         	str	r0, [sp, #0x8]
700a1754: e7ff         	b	0x700a1756 <Sciclient_recvMessage+0xb6> @ imm = #-0x2
700a1756: 9802         	ldr	r0, [sp, #0x8]
700a1758: f89d 1023    	ldrb.w	r1, [sp, #0x23]
700a175c: 4288         	cmp	r0, r1
700a175e: d214         	bhs	0x700a178a <Sciclient_recvMessage+0xea> @ imm = #0x28
700a1760: e7ff         	b	0x700a1762 <Sciclient_recvMessage+0xc2> @ imm = #-0x2
;             uint8_t * address = (uint8_t*)pLocalRespPayload;
700a1762: 980c         	ldr	r0, [sp, #0x30]
700a1764: 9001         	str	r0, [sp, #0x4]
;             uint8_t value = *(uint8_t*)(pTempWord + bytes);
700a1766: 9803         	ldr	r0, [sp, #0xc]
700a1768: 9902         	ldr	r1, [sp, #0x8]
700a176a: 5c40         	ldrb	r0, [r0, r1]
700a176c: f88d 0003    	strb.w	r0, [sp, #0x3]
;             *(uint8_t*)(address + i*4 + bytes) = value;
700a1770: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a1774: 9901         	ldr	r1, [sp, #0x4]
700a1776: 9a09         	ldr	r2, [sp, #0x24]
700a1778: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a177c: 9a02         	ldr	r2, [sp, #0x8]
700a177e: 5488         	strb	r0, [r1, r2]
;         }
700a1780: e7ff         	b	0x700a1782 <Sciclient_recvMessage+0xe2> @ imm = #-0x2
;         for (bytes = 0U; bytes < trailBytes; bytes++)
700a1782: 9802         	ldr	r0, [sp, #0x8]
700a1784: 3001         	adds	r0, #0x1
700a1786: 9002         	str	r0, [sp, #0x8]
700a1788: e7e5         	b	0x700a1756 <Sciclient_recvMessage+0xb6> @ imm = #-0x36
;     }
700a178a: e7ff         	b	0x700a178c <Sciclient_recvMessage+0xec> @ imm = #-0x2
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a178c: f640 6004    	movw	r0, #0xe04
700a1790: f2c7 000b    	movt	r0, #0x700b
700a1794: 7801         	ldrb	r1, [r0]
;         rxPayloadSize) <=
700a1796: 980b         	ldr	r0, [sp, #0x2c]
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a1798: eb00 0081    	add.w	r0, r0, r1, lsl #2
;         (SCICLIENT_HEADER_SIZE_IN_WORDS*4U) +
700a179c: 3008         	adds	r0, #0x8
;         (gSciclientHandle.maxMsgSizeBytes - 4U))
700a179e: f640 5100    	movw	r1, #0xd00
700a17a2: f2c7 010b    	movt	r1, #0x700b
700a17a6: 6949         	ldr	r1, [r1, #0x14]
700a17a8: 3904         	subs	r1, #0x4
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a17aa: 4288         	cmp	r0, r1
700a17ac: d80e         	bhi	0x700a17cc <Sciclient_recvMessage+0x12c> @ imm = #0x1c
700a17ae: e7ff         	b	0x700a17b0 <Sciclient_recvMessage+0x110> @ imm = #-0x2
;         (void) Sciclient_secProxyReadThread32(rxThread,
700a17b0: 980d         	ldr	r0, [sp, #0x34]
;                         (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U) - 1U));
700a17b2: f640 5100    	movw	r1, #0xd00
700a17b6: f2c7 010b    	movt	r1, #0x700b
700a17ba: 694a         	ldr	r2, [r1, #0x14]
700a17bc: f04f 31ff    	mov.w	r1, #0xffffffff
700a17c0: eb01 0192    	add.w	r1, r1, r2, lsr #2
;         (void) Sciclient_secProxyReadThread32(rxThread,
700a17c4: b2c9         	uxtb	r1, r1
700a17c6: f00b faeb    	bl	0x700acda0 <Sciclient_secProxyReadThread32> @ imm = #0xb5d6
;     }
700a17ca: e7ff         	b	0x700a17cc <Sciclient_recvMessage+0x12c> @ imm = #-0x2
; }
700a17cc: b00e         	add	sp, #0x38
700a17ce: bd80         	pop	{r7, pc}

700a17d0 <Udma_rmAllocIrIntr>:
; {
700a17d0: b580         	push	{r7, lr}
700a17d2: b088         	sub	sp, #0x20
700a17d4: 9007         	str	r0, [sp, #0x1c]
700a17d6: 9106         	str	r1, [sp, #0x18]
700a17d8: 2000         	movs	r0, #0x0
700a17da: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            irIntrNum = UDMA_INTR_INVALID;
700a17de: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a17e0: 9806         	ldr	r0, [sp, #0x18]
700a17e2: f500 70ea    	add.w	r0, r0, #0x1d4
700a17e6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a17e8: 9806         	ldr	r0, [sp, #0x18]
700a17ea: f500 609f    	add.w	r0, r0, #0x4f8
700a17ee: f04f 31ff    	mov.w	r1, #0xffffffff
700a17f2: f007 fa3d    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x747a
;     if(UDMA_CORE_INTR_ANY == preferredIrIntrNum)
700a17f6: 9807         	ldr	r0, [sp, #0x1c]
700a17f8: 2101         	movs	r1, #0x1
700a17fa: f6cf 71ff    	movt	r1, #0xffff
700a17fe: 4288         	cmp	r0, r1
700a1800: d138         	bne	0x700a1874 <Udma_rmAllocIrIntr+0xa4> @ imm = #0x70
700a1802: e7ff         	b	0x700a1804 <Udma_rmAllocIrIntr+0x34> @ imm = #-0x2
700a1804: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numIrIntr; i++)
700a1806: 9005         	str	r0, [sp, #0x14]
700a1808: e7ff         	b	0x700a180a <Udma_rmAllocIrIntr+0x3a> @ imm = #-0x2
700a180a: 9805         	ldr	r0, [sp, #0x14]
700a180c: 9900         	ldr	r1, [sp]
700a180e: f8d1 10ec    	ldr.w	r1, [r1, #0xec]
700a1812: 4288         	cmp	r0, r1
700a1814: d22d         	bhs	0x700a1872 <Udma_rmAllocIrIntr+0xa2> @ imm = #0x5a
700a1816: e7ff         	b	0x700a1818 <Udma_rmAllocIrIntr+0x48> @ imm = #-0x2
;             offset = i >> 5U;
700a1818: 9805         	ldr	r0, [sp, #0x14]
700a181a: 0940         	lsrs	r0, r0, #0x5
700a181c: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a181e: 9805         	ldr	r0, [sp, #0x14]
700a1820: 9904         	ldr	r1, [sp, #0x10]
700a1822: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1826: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1828: 9903         	ldr	r1, [sp, #0xc]
700a182a: 2001         	movs	r0, #0x1
700a182c: 4088         	lsls	r0, r1
700a182e: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->irIntrFlag[offset] & bitMask) == bitMask)
700a1830: 9806         	ldr	r0, [sp, #0x18]
700a1832: 9904         	ldr	r1, [sp, #0x10]
700a1834: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1838: f8d0 04e4    	ldr.w	r0, [r0, #0x4e4]
700a183c: 9902         	ldr	r1, [sp, #0x8]
700a183e: 4008         	ands	r0, r1
700a1840: 4288         	cmp	r0, r1
700a1842: d111         	bne	0x700a1868 <Udma_rmAllocIrIntr+0x98> @ imm = #0x22
700a1844: e7ff         	b	0x700a1846 <Udma_rmAllocIrIntr+0x76> @ imm = #-0x2
;                 drvHandle->irIntrFlag[offset] &= ~bitMask;
700a1846: 9a02         	ldr	r2, [sp, #0x8]
700a1848: 9806         	ldr	r0, [sp, #0x18]
700a184a: 9904         	ldr	r1, [sp, #0x10]
700a184c: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1850: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a1854: 4390         	bics	r0, r2
700a1856: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;                 irIntrNum = i + rmInitPrms->startIrIntr;    /* Add start offset */
700a185a: 9805         	ldr	r0, [sp, #0x14]
700a185c: 9900         	ldr	r1, [sp]
700a185e: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a1862: 4408         	add	r0, r1
700a1864: 9001         	str	r0, [sp, #0x4]
;                 break;
700a1866: e004         	b	0x700a1872 <Udma_rmAllocIrIntr+0xa2> @ imm = #0x8
;         }
700a1868: e7ff         	b	0x700a186a <Udma_rmAllocIrIntr+0x9a> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numIrIntr; i++)
700a186a: 9805         	ldr	r0, [sp, #0x14]
700a186c: 3001         	adds	r0, #0x1
700a186e: 9005         	str	r0, [sp, #0x14]
700a1870: e7cb         	b	0x700a180a <Udma_rmAllocIrIntr+0x3a> @ imm = #-0x6a
;     }
700a1872: e03c         	b	0x700a18ee <Udma_rmAllocIrIntr+0x11e> @ imm = #0x78
;         if((preferredIrIntrNum >= rmInitPrms->startIrIntr) &&
700a1874: 9807         	ldr	r0, [sp, #0x1c]
700a1876: 9900         	ldr	r1, [sp]
700a1878: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a187c: 4288         	cmp	r0, r1
700a187e: d335         	blo	0x700a18ec <Udma_rmAllocIrIntr+0x11c> @ imm = #0x6a
700a1880: e7ff         	b	0x700a1882 <Udma_rmAllocIrIntr+0xb2> @ imm = #-0x2
;            (preferredIrIntrNum < (rmInitPrms->startIrIntr + rmInitPrms->numIrIntr)))
700a1882: 9807         	ldr	r0, [sp, #0x1c]
700a1884: 9a00         	ldr	r2, [sp]
700a1886: f8d2 10e8    	ldr.w	r1, [r2, #0xe8]
700a188a: f8d2 20ec    	ldr.w	r2, [r2, #0xec]
700a188e: 4411         	add	r1, r2
;         if((preferredIrIntrNum >= rmInitPrms->startIrIntr) &&
700a1890: 4288         	cmp	r0, r1
700a1892: d22b         	bhs	0x700a18ec <Udma_rmAllocIrIntr+0x11c> @ imm = #0x56
700a1894: e7ff         	b	0x700a1896 <Udma_rmAllocIrIntr+0xc6> @ imm = #-0x2
;             i = preferredIrIntrNum - rmInitPrms->startIrIntr;
700a1896: 9807         	ldr	r0, [sp, #0x1c]
700a1898: 9900         	ldr	r1, [sp]
700a189a: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a189e: 1a40         	subs	r0, r0, r1
700a18a0: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a18a2: 9805         	ldr	r0, [sp, #0x14]
700a18a4: 0940         	lsrs	r0, r0, #0x5
700a18a6: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a18a8: 9805         	ldr	r0, [sp, #0x14]
700a18aa: 9904         	ldr	r1, [sp, #0x10]
700a18ac: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a18b0: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a18b2: 9903         	ldr	r1, [sp, #0xc]
700a18b4: 2001         	movs	r0, #0x1
700a18b6: 4088         	lsls	r0, r1
700a18b8: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->irIntrFlag[offset] & bitMask) == bitMask)
700a18ba: 9806         	ldr	r0, [sp, #0x18]
700a18bc: 9904         	ldr	r1, [sp, #0x10]
700a18be: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a18c2: f8d0 04e4    	ldr.w	r0, [r0, #0x4e4]
700a18c6: 9902         	ldr	r1, [sp, #0x8]
700a18c8: 4008         	ands	r0, r1
700a18ca: 4288         	cmp	r0, r1
700a18cc: d10d         	bne	0x700a18ea <Udma_rmAllocIrIntr+0x11a> @ imm = #0x1a
700a18ce: e7ff         	b	0x700a18d0 <Udma_rmAllocIrIntr+0x100> @ imm = #-0x2
;                 drvHandle->irIntrFlag[offset] &= ~bitMask;
700a18d0: 9a02         	ldr	r2, [sp, #0x8]
700a18d2: 9806         	ldr	r0, [sp, #0x18]
700a18d4: 9904         	ldr	r1, [sp, #0x10]
700a18d6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a18da: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a18de: 4390         	bics	r0, r2
700a18e0: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;                 irIntrNum = preferredIrIntrNum;
700a18e4: 9807         	ldr	r0, [sp, #0x1c]
700a18e6: 9001         	str	r0, [sp, #0x4]
;             }
700a18e8: e7ff         	b	0x700a18ea <Udma_rmAllocIrIntr+0x11a> @ imm = #-0x2
;         }
700a18ea: e7ff         	b	0x700a18ec <Udma_rmAllocIrIntr+0x11c> @ imm = #-0x2
700a18ec: e7ff         	b	0x700a18ee <Udma_rmAllocIrIntr+0x11e> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a18ee: 9806         	ldr	r0, [sp, #0x18]
700a18f0: f500 609f    	add.w	r0, r0, #0x4f8
700a18f4: f008 fd0c    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x8a18
;     return (irIntrNum);
700a18f8: 9801         	ldr	r0, [sp, #0x4]
700a18fa: b008         	add	sp, #0x20
700a18fc: bd80         	pop	{r7, pc}
700a18fe: 0000         	movs	r0, r0

700a1900 <xQueueGenericSend>:
; {
700a1900: b580         	push	{r7, lr}
700a1902: b08a         	sub	sp, #0x28
700a1904: 9008         	str	r0, [sp, #0x20]
700a1906: 9107         	str	r1, [sp, #0x1c]
700a1908: 9206         	str	r2, [sp, #0x18]
700a190a: 9305         	str	r3, [sp, #0x14]
700a190c: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
700a190e: 9004         	str	r0, [sp, #0x10]
;     Queue_t * const pxQueue = xQueue;
700a1910: 9808         	ldr	r0, [sp, #0x20]
700a1912: 9000         	str	r0, [sp]
;     for( ; ; )
700a1914: e7ff         	b	0x700a1916 <xQueueGenericSend+0x16> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a1916: f00b f95b    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0xb2b6
;             if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
700a191a: 9800         	ldr	r0, [sp]
700a191c: 6b80         	ldr	r0, [r0, #0x38]
700a191e: 9900         	ldr	r1, [sp]
700a1920: 6bc9         	ldr	r1, [r1, #0x3c]
700a1922: 4288         	cmp	r0, r1
700a1924: d304         	blo	0x700a1930 <xQueueGenericSend+0x30> @ imm = #0x8
700a1926: e7ff         	b	0x700a1928 <xQueueGenericSend+0x28> @ imm = #-0x2
700a1928: 9805         	ldr	r0, [sp, #0x14]
700a192a: 2802         	cmp	r0, #0x2
700a192c: d120         	bne	0x700a1970 <xQueueGenericSend+0x70> @ imm = #0x40
700a192e: e7ff         	b	0x700a1930 <xQueueGenericSend+0x30> @ imm = #-0x2
;                         xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
700a1930: 9800         	ldr	r0, [sp]
700a1932: 9907         	ldr	r1, [sp, #0x1c]
700a1934: 9a05         	ldr	r2, [sp, #0x14]
700a1936: f003 fb5b    	bl	0x700a4ff0 <prvCopyDataToQueue> @ imm = #0x36b6
700a193a: 9003         	str	r0, [sp, #0xc]
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a193c: 9800         	ldr	r0, [sp]
700a193e: 6a40         	ldr	r0, [r0, #0x24]
700a1940: b150         	cbz	r0, 0x700a1958 <xQueueGenericSend+0x58> @ imm = #0x14
700a1942: e7ff         	b	0x700a1944 <xQueueGenericSend+0x44> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a1944: 9800         	ldr	r0, [sp]
700a1946: 3024         	adds	r0, #0x24
700a1948: f004 fad2    	bl	0x700a5ef0 <xTaskRemoveFromEventList> @ imm = #0x45a4
700a194c: b110         	cbz	r0, 0x700a1954 <xQueueGenericSend+0x54> @ imm = #0x4
700a194e: e7ff         	b	0x700a1950 <xQueueGenericSend+0x50> @ imm = #-0x2
;                                 queueYIELD_IF_USING_PREEMPTION();
700a1950: df00         	svc	#0x0
;                             }
700a1952: e000         	b	0x700a1956 <xQueueGenericSend+0x56> @ imm = #0x0
700a1954: e7ff         	b	0x700a1956 <xQueueGenericSend+0x56> @ imm = #-0x2
;                         }
700a1956: e006         	b	0x700a1966 <xQueueGenericSend+0x66> @ imm = #0xc
;                         else if( xYieldRequired != pdFALSE )
700a1958: 9803         	ldr	r0, [sp, #0xc]
700a195a: b110         	cbz	r0, 0x700a1962 <xQueueGenericSend+0x62> @ imm = #0x4
700a195c: e7ff         	b	0x700a195e <xQueueGenericSend+0x5e> @ imm = #-0x2
;                             queueYIELD_IF_USING_PREEMPTION();
700a195e: df00         	svc	#0x0
;                         }
700a1960: e000         	b	0x700a1964 <xQueueGenericSend+0x64> @ imm = #0x0
700a1962: e7ff         	b	0x700a1964 <xQueueGenericSend+0x64> @ imm = #-0x2
700a1964: e7ff         	b	0x700a1966 <xQueueGenericSend+0x66> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a1966: f00a f9b3    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0xa366
700a196a: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a196c: 9009         	str	r0, [sp, #0x24]
700a196e: e05b         	b	0x700a1a28 <xQueueGenericSend+0x128> @ imm = #0xb6
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a1970: 9806         	ldr	r0, [sp, #0x18]
700a1972: b928         	cbnz	r0, 0x700a1980 <xQueueGenericSend+0x80> @ imm = #0xa
700a1974: e7ff         	b	0x700a1976 <xQueueGenericSend+0x76> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a1976: f00a f9ab    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0xa356
700a197a: 2000         	movs	r0, #0x0
;                     return errQUEUE_FULL;
700a197c: 9009         	str	r0, [sp, #0x24]
700a197e: e053         	b	0x700a1a28 <xQueueGenericSend+0x128> @ imm = #0xa6
;                 else if( xEntryTimeSet == pdFALSE )
700a1980: 9804         	ldr	r0, [sp, #0x10]
700a1982: b930         	cbnz	r0, 0x700a1992 <xQueueGenericSend+0x92> @ imm = #0xc
700a1984: e7ff         	b	0x700a1986 <xQueueGenericSend+0x86> @ imm = #-0x2
700a1986: a801         	add	r0, sp, #0x4
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a1988: f00b feb2    	bl	0x700ad6f0 <vTaskInternalSetTimeOutState> @ imm = #0xbd64
700a198c: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a198e: 9004         	str	r0, [sp, #0x10]
;                 }
700a1990: e000         	b	0x700a1994 <xQueueGenericSend+0x94> @ imm = #0x0
700a1992: e7ff         	b	0x700a1994 <xQueueGenericSend+0x94> @ imm = #-0x2
700a1994: e7ff         	b	0x700a1996 <xQueueGenericSend+0x96> @ imm = #-0x2
700a1996: e7ff         	b	0x700a1998 <xQueueGenericSend+0x98> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a1998: f00a f99a    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0xa334
;         vTaskSuspendAll();
700a199c: f00c fb48    	bl	0x700ae030 <vTaskSuspendAll> @ imm = #0xc690
;         prvLockQueue( pxQueue );
700a19a0: f00b f916    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0xb22c
700a19a4: 9800         	ldr	r0, [sp]
700a19a6: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a19aa: 3001         	adds	r0, #0x1
700a19ac: b928         	cbnz	r0, 0x700a19ba <xQueueGenericSend+0xba> @ imm = #0xa
700a19ae: e7ff         	b	0x700a19b0 <xQueueGenericSend+0xb0> @ imm = #-0x2
700a19b0: 9900         	ldr	r1, [sp]
700a19b2: 2000         	movs	r0, #0x0
700a19b4: f881 0044    	strb.w	r0, [r1, #0x44]
700a19b8: e7ff         	b	0x700a19ba <xQueueGenericSend+0xba> @ imm = #-0x2
700a19ba: 9800         	ldr	r0, [sp]
700a19bc: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a19c0: 3001         	adds	r0, #0x1
700a19c2: b928         	cbnz	r0, 0x700a19d0 <xQueueGenericSend+0xd0> @ imm = #0xa
700a19c4: e7ff         	b	0x700a19c6 <xQueueGenericSend+0xc6> @ imm = #-0x2
700a19c6: 9900         	ldr	r1, [sp]
700a19c8: 2000         	movs	r0, #0x0
700a19ca: f881 0045    	strb.w	r0, [r1, #0x45]
700a19ce: e7ff         	b	0x700a19d0 <xQueueGenericSend+0xd0> @ imm = #-0x2
700a19d0: f00a f97e    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0xa2fc
700a19d4: a801         	add	r0, sp, #0x4
700a19d6: a906         	add	r1, sp, #0x18
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a19d8: f005 fe9a    	bl	0x700a7710 <xTaskCheckForTimeOut> @ imm = #0x5d34
700a19dc: b9d8         	cbnz	r0, 0x700a1a16 <xQueueGenericSend+0x116> @ imm = #0x36
700a19de: e7ff         	b	0x700a19e0 <xQueueGenericSend+0xe0> @ imm = #-0x2
;             if( prvIsQueueFull( pxQueue ) != pdFALSE )
700a19e0: 9800         	ldr	r0, [sp]
700a19e2: f00b fa3d    	bl	0x700ace60 <prvIsQueueFull> @ imm = #0xb47a
700a19e6: b178         	cbz	r0, 0x700a1a08 <xQueueGenericSend+0x108> @ imm = #0x1e
700a19e8: e7ff         	b	0x700a19ea <xQueueGenericSend+0xea> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
700a19ea: 9800         	ldr	r0, [sp]
700a19ec: 3010         	adds	r0, #0x10
700a19ee: 9906         	ldr	r1, [sp, #0x18]
700a19f0: f00b fd7e    	bl	0x700ad4f0 <vTaskPlaceOnEventList> @ imm = #0xbafc
;                 prvUnlockQueue( pxQueue );
700a19f4: 9800         	ldr	r0, [sp]
700a19f6: f004 fc43    	bl	0x700a6280 <prvUnlockQueue> @ imm = #0x4886
;                 if( xTaskResumeAll() == pdFALSE )
700a19fa: f7fe ff51    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0x115e
700a19fe: b910         	cbnz	r0, 0x700a1a06 <xQueueGenericSend+0x106> @ imm = #0x4
700a1a00: e7ff         	b	0x700a1a02 <xQueueGenericSend+0x102> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a1a02: df00         	svc	#0x0
;                 }
700a1a04: e7ff         	b	0x700a1a06 <xQueueGenericSend+0x106> @ imm = #-0x2
;             }
700a1a06: e005         	b	0x700a1a14 <xQueueGenericSend+0x114> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a1a08: 9800         	ldr	r0, [sp]
700a1a0a: f004 fc39    	bl	0x700a6280 <prvUnlockQueue> @ imm = #0x4872
;                 ( void ) xTaskResumeAll();
700a1a0e: f7fe ff47    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0x1172
700a1a12: e7ff         	b	0x700a1a14 <xQueueGenericSend+0x114> @ imm = #-0x2
;         }
700a1a14: e007         	b	0x700a1a26 <xQueueGenericSend+0x126> @ imm = #0xe
;             prvUnlockQueue( pxQueue );
700a1a16: 9800         	ldr	r0, [sp]
700a1a18: f004 fc32    	bl	0x700a6280 <prvUnlockQueue> @ imm = #0x4864
;             ( void ) xTaskResumeAll();
700a1a1c: f7fe ff40    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0x1180
700a1a20: 2000         	movs	r0, #0x0
;             return errQUEUE_FULL;
700a1a22: 9009         	str	r0, [sp, #0x24]
700a1a24: e000         	b	0x700a1a28 <xQueueGenericSend+0x128> @ imm = #0x0
;     for( ; ; )
700a1a26: e776         	b	0x700a1916 <xQueueGenericSend+0x16> @ imm = #-0x114
; }
700a1a28: 9809         	ldr	r0, [sp, #0x24]
700a1a2a: b00a         	add	sp, #0x28
700a1a2c: bd80         	pop	{r7, pc}
700a1a2e: 0000         	movs	r0, r0

700a1a30 <UART_lld_init>:
; {
700a1a30: b580         	push	{r7, lr}
700a1a32: b084         	sub	sp, #0x10
700a1a34: 9003         	str	r0, [sp, #0xc]
700a1a36: 2000         	movs	r0, #0x0
;     int32_t                status = UART_STATUS_SUCCESS;
700a1a38: 9002         	str	r0, [sp, #0x8]
;     if((hUart != NULL_PTR) && (hUart->hUartInit != NULL_PTR))
700a1a3a: 9803         	ldr	r0, [sp, #0xc]
700a1a3c: b168         	cbz	r0, 0x700a1a5a <UART_lld_init+0x2a> @ imm = #0x1a
700a1a3e: e7ff         	b	0x700a1a40 <UART_lld_init+0x10> @ imm = #-0x2
700a1a40: 9803         	ldr	r0, [sp, #0xc]
700a1a42: 6840         	ldr	r0, [r0, #0x4]
700a1a44: b148         	cbz	r0, 0x700a1a5a <UART_lld_init+0x2a> @ imm = #0x12
700a1a46: e7ff         	b	0x700a1a48 <UART_lld_init+0x18> @ imm = #-0x2
;         if(hUart->state != UART_STATE_RESET)
700a1a48: 9803         	ldr	r0, [sp, #0xc]
700a1a4a: 6d40         	ldr	r0, [r0, #0x54]
700a1a4c: b120         	cbz	r0, 0x700a1a58 <UART_lld_init+0x28> @ imm = #0x8
700a1a4e: e7ff         	b	0x700a1a50 <UART_lld_init+0x20> @ imm = #-0x2
700a1a50: f06f 0004    	mvn	r0, #0x4
;             status = UART_TRANSFER_INVALID_STATE;
700a1a54: 9002         	str	r0, [sp, #0x8]
;         }
700a1a56: e7ff         	b	0x700a1a58 <UART_lld_init+0x28> @ imm = #-0x2
;     }
700a1a58: e003         	b	0x700a1a62 <UART_lld_init+0x32> @ imm = #0x6
700a1a5a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a1a5e: 9002         	str	r0, [sp, #0x8]
700a1a60: e7ff         	b	0x700a1a62 <UART_lld_init+0x32> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a1a62: 9802         	ldr	r0, [sp, #0x8]
700a1a64: 2800         	cmp	r0, #0x0
700a1a66: d176         	bne	0x700a1b56 <UART_lld_init+0x126> @ imm = #0xec
700a1a68: e7ff         	b	0x700a1a6a <UART_lld_init+0x3a> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a1a6a: 9903         	ldr	r1, [sp, #0xc]
700a1a6c: 2002         	movs	r0, #0x2
700a1a6e: 6548         	str	r0, [r1, #0x54]
;         hUartInit = hUart->hUartInit;
700a1a70: 9803         	ldr	r0, [sp, #0xc]
700a1a72: 6840         	ldr	r0, [r0, #0x4]
700a1a74: 9001         	str	r0, [sp, #0x4]
;         hUart->lineStatusTimeout = hUartInit->clockP_usecToTick(UART_READ_LINE_STATUS_TIMEOUT_IN_US);
700a1a76: 9801         	ldr	r0, [sp, #0x4]
700a1a78: 6d82         	ldr	r2, [r0, #0x58]
700a1a7a: f244 2040    	movw	r0, #0x4240
700a1a7e: f2c0 000f    	movt	r0, #0xf
700a1a82: 2100         	movs	r1, #0x0
700a1a84: 9100         	str	r1, [sp]
700a1a86: 4790         	blx	r2
700a1a88: 9a00         	ldr	r2, [sp]
700a1a8a: 9903         	ldr	r1, [sp, #0xc]
700a1a8c: 66ca         	str	r2, [r1, #0x6c]
700a1a8e: 6688         	str	r0, [r1, #0x68]
;         status += UART_IsBaseAddrValid(hUart->baseAddr);
700a1a90: 9803         	ldr	r0, [sp, #0xc]
700a1a92: 6800         	ldr	r0, [r0]
700a1a94: f005 f91c    	bl	0x700a6cd0 <UART_IsBaseAddrValid> @ imm = #0x5238
700a1a98: 4601         	mov	r1, r0
700a1a9a: 9802         	ldr	r0, [sp, #0x8]
700a1a9c: 4408         	add	r0, r1
700a1a9e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->inputClkFreq);
700a1aa0: 9801         	ldr	r0, [sp, #0x4]
700a1aa2: 6800         	ldr	r0, [r0]
700a1aa4: f00b ffb4    	bl	0x700ada10 <UART_IsParameter> @ imm = #0xbf68
700a1aa8: 4601         	mov	r1, r0
700a1aaa: 9802         	ldr	r0, [sp, #0x8]
700a1aac: 4408         	add	r0, r1
700a1aae: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->baudRate);
700a1ab0: 9801         	ldr	r0, [sp, #0x4]
700a1ab2: 6840         	ldr	r0, [r0, #0x4]
700a1ab4: f00b ffac    	bl	0x700ada10 <UART_IsParameter> @ imm = #0xbf58
700a1ab8: 4601         	mov	r1, r0
700a1aba: 9802         	ldr	r0, [sp, #0x8]
700a1abc: 4408         	add	r0, r1
700a1abe: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsDataLengthValid(hUartInit->dataLength);
700a1ac0: 9801         	ldr	r0, [sp, #0x4]
700a1ac2: 6880         	ldr	r0, [r0, #0x8]
700a1ac4: f00a ff6c    	bl	0x700ac9a0 <UART_IsDataLengthValid> @ imm = #0xaed8
700a1ac8: 4601         	mov	r1, r0
700a1aca: 9802         	ldr	r0, [sp, #0x8]
700a1acc: 4408         	add	r0, r1
700a1ace: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsStopBitsValid(hUartInit->stopBits);
700a1ad0: 9801         	ldr	r0, [sp, #0x4]
700a1ad2: 68c0         	ldr	r0, [r0, #0xc]
700a1ad4: f00b fdcc    	bl	0x700ad670 <UART_IsStopBitsValid> @ imm = #0xbb98
700a1ad8: 4601         	mov	r1, r0
700a1ada: 9802         	ldr	r0, [sp, #0x8]
700a1adc: 4408         	add	r0, r1
700a1ade: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParityTypeValid(hUartInit->parityType);
700a1ae0: 9801         	ldr	r0, [sp, #0x4]
700a1ae2: 6900         	ldr	r0, [r0, #0x10]
700a1ae4: f00a fcbc    	bl	0x700ac460 <UART_IsParityTypeValid> @ imm = #0xa978
700a1ae8: 4601         	mov	r1, r0
700a1aea: 9802         	ldr	r0, [sp, #0x8]
700a1aec: 4408         	add	r0, r1
700a1aee: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsHWFlowCtrlValid(hUartInit->hwFlowControlThr);
700a1af0: 9801         	ldr	r0, [sp, #0x4]
700a1af2: 69c0         	ldr	r0, [r0, #0x1c]
700a1af4: f00a fb74    	bl	0x700ac1e0 <UART_IsHWFlowCtrlValid> @ imm = #0xa6e8
700a1af8: 4601         	mov	r1, r0
700a1afa: 9802         	ldr	r0, [sp, #0x8]
700a1afc: 4408         	add	r0, r1
700a1afe: 9002         	str	r0, [sp, #0x8]
;         status += UART_OperModeValid(hUartInit->operMode);
700a1b00: 9801         	ldr	r0, [sp, #0x4]
700a1b02: 6ac0         	ldr	r0, [r0, #0x2c]
700a1b04: f009 fba4    	bl	0x700ab250 <UART_OperModeValid> @ imm = #0x9748
700a1b08: 4601         	mov	r1, r0
700a1b0a: 9802         	ldr	r0, [sp, #0x8]
700a1b0c: 4408         	add	r0, r1
700a1b0e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsRxTrigLvlValid(hUartInit->rxTrigLvl);
700a1b10: 9801         	ldr	r0, [sp, #0x4]
700a1b12: 6b80         	ldr	r0, [r0, #0x38]
700a1b14: f00a fb84    	bl	0x700ac220 <UART_IsRxTrigLvlValid> @ imm = #0xa708
700a1b18: 4601         	mov	r1, r0
700a1b1a: 9802         	ldr	r0, [sp, #0x8]
700a1b1c: 4408         	add	r0, r1
700a1b1e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsTxTrigLvlValid(hUartInit->txTrigLvl);
700a1b20: 9801         	ldr	r0, [sp, #0x4]
700a1b22: 6bc0         	ldr	r0, [r0, #0x3c]
700a1b24: f00a fb9c    	bl	0x700ac260 <UART_IsTxTrigLvlValid> @ imm = #0xa738
700a1b28: 4601         	mov	r1, r0
700a1b2a: 9802         	ldr	r0, [sp, #0x8]
700a1b2c: 4408         	add	r0, r1
700a1b2e: 9002         	str	r0, [sp, #0x8]
;         if(UART_STATUS_SUCCESS == status)
700a1b30: 9802         	ldr	r0, [sp, #0x8]
700a1b32: b938         	cbnz	r0, 0x700a1b44 <UART_lld_init+0x114> @ imm = #0xe
700a1b34: e7ff         	b	0x700a1b36 <UART_lld_init+0x106> @ imm = #-0x2
;             UART_configInstance(hUart);
700a1b36: 9803         	ldr	r0, [sp, #0xc]
700a1b38: f001 ff72    	bl	0x700a3a20 <UART_configInstance> @ imm = #0x1ee4
;             hUart->state = UART_STATE_READY;
700a1b3c: 9903         	ldr	r1, [sp, #0xc]
700a1b3e: 2001         	movs	r0, #0x1
700a1b40: 6548         	str	r0, [r1, #0x54]
;         }
700a1b42: e007         	b	0x700a1b54 <UART_lld_init+0x124> @ imm = #0xe
;             status += UART_lld_deInit(hUart);
700a1b44: 9803         	ldr	r0, [sp, #0xc]
700a1b46: f008 ff6b    	bl	0x700aaa20 <UART_lld_deInit> @ imm = #0x8ed6
700a1b4a: 4601         	mov	r1, r0
700a1b4c: 9802         	ldr	r0, [sp, #0x8]
700a1b4e: 4408         	add	r0, r1
700a1b50: 9002         	str	r0, [sp, #0x8]
700a1b52: e7ff         	b	0x700a1b54 <UART_lld_init+0x124> @ imm = #-0x2
;     }
700a1b54: e7ff         	b	0x700a1b56 <UART_lld_init+0x126> @ imm = #-0x2
;     return status;
700a1b56: 9802         	ldr	r0, [sp, #0x8]
700a1b58: b004         	add	sp, #0x10
700a1b5a: bd80         	pop	{r7, pc}
700a1b5c: 0000         	movs	r0, r0
700a1b5e: 0000         	movs	r0, r0

700a1b60 <Sciclient_pmQueryModuleClkFreq>:
; {
700a1b60: b580         	push	{r7, lr}
700a1b62: b09e         	sub	sp, #0x78
700a1b64: f8dd c084    	ldr.w	r12, [sp, #0x84]
700a1b68: f8dd c080    	ldr.w	r12, [sp, #0x80]
700a1b6c: 901d         	str	r0, [sp, #0x74]
700a1b6e: 911c         	str	r1, [sp, #0x70]
700a1b70: 931b         	str	r3, [sp, #0x6c]
700a1b72: 921a         	str	r2, [sp, #0x68]
700a1b74: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a1b76: 9019         	str	r0, [sp, #0x64]
;     request.device         = (uint32_t) moduleId;
700a1b78: 981d         	ldr	r0, [sp, #0x74]
700a1b7a: 9010         	str	r0, [sp, #0x40]
;     request.min_freq_hz    = (uint64_t) reqFreqHz;
700a1b7c: 981a         	ldr	r0, [sp, #0x68]
700a1b7e: 991b         	ldr	r1, [sp, #0x6c]
700a1b80: 9112         	str	r1, [sp, #0x48]
700a1b82: 9011         	str	r0, [sp, #0x44]
;     request.target_freq_hz = (uint64_t) reqFreqHz;
700a1b84: 981a         	ldr	r0, [sp, #0x68]
700a1b86: 991b         	ldr	r1, [sp, #0x6c]
700a1b88: 9114         	str	r1, [sp, #0x50]
700a1b8a: 9013         	str	r0, [sp, #0x4c]
;     request.max_freq_hz    = (uint64_t) reqFreqHz;
700a1b8c: 981a         	ldr	r0, [sp, #0x68]
700a1b8e: 991b         	ldr	r1, [sp, #0x6c]
700a1b90: 9116         	str	r1, [sp, #0x58]
700a1b92: 9015         	str	r0, [sp, #0x54]
;     if((reqFreqHz%10U) != 0U)
700a1b94: 9b1a         	ldr	r3, [sp, #0x68]
700a1b96: 981b         	ldr	r0, [sp, #0x6c]
700a1b98: f64c 41cd    	movw	r1, #0xcccd
700a1b9c: f6cc 41cc    	movt	r1, #0xcccc
700a1ba0: fba3 2e01    	umull	r2, lr, r3, r1
700a1ba4: f04f 3ccc    	mov.w	r12, #0xcccccccc
700a1ba8: fb03 e30c    	mla	r3, r3, r12, lr
700a1bac: fb00 3101    	mla	r1, r0, r1, r3
700a1bb0: ea4f 70c2    	lsl.w	r0, r2, #0x1f
700a1bb4: ea40 0051    	orr.w	r0, r0, r1, lsr #1
700a1bb8: ea4f 71c1    	lsl.w	r1, r1, #0x1f
700a1bbc: ea41 0152    	orr.w	r1, r1, r2, lsr #1
700a1bc0: f649 129a    	movw	r2, #0x999a
700a1bc4: f6c9 1299    	movt	r2, #0x9999
700a1bc8: 1a89         	subs	r1, r1, r2
700a1bca: f649 1199    	movw	r1, #0x9999
700a1bce: f6c1 1199    	movt	r1, #0x1999
700a1bd2: 4188         	sbcs	r0, r1
700a1bd4: d316         	blo	0x700a1c04 <Sciclient_pmQueryModuleClkFreq+0xa4> @ imm = #0x2c
700a1bd6: e7ff         	b	0x700a1bd8 <Sciclient_pmQueryModuleClkFreq+0x78> @ imm = #-0x2
;         request.min_freq_hz = (uint64_t)(reqFreqHz-(reqFreqHz%10U));
700a1bd8: 981a         	ldr	r0, [sp, #0x68]
700a1bda: 9001         	str	r0, [sp, #0x4]
700a1bdc: 991b         	ldr	r1, [sp, #0x6c]
700a1bde: 9100         	str	r1, [sp]
700a1be0: 220a         	movs	r2, #0xa
700a1be2: 2300         	movs	r3, #0x0
700a1be4: f00b ed56    	blx	0x700ad694 <__aeabi_uldivmod> @ imm = #0xbaac
700a1be8: 9800         	ldr	r0, [sp]
700a1bea: 9901         	ldr	r1, [sp, #0x4]
700a1bec: 1a89         	subs	r1, r1, r2
700a1bee: 4198         	sbcs	r0, r3
700a1bf0: 9111         	str	r1, [sp, #0x44]
700a1bf2: 9012         	str	r0, [sp, #0x48]
;         request.max_freq_hz = (uint64_t)(request.min_freq_hz + 10UL);
700a1bf4: 9911         	ldr	r1, [sp, #0x44]
700a1bf6: 9812         	ldr	r0, [sp, #0x48]
700a1bf8: 310a         	adds	r1, #0xa
700a1bfa: f140 0000    	adc	r0, r0, #0x0
700a1bfe: 9115         	str	r1, [sp, #0x54]
700a1c00: 9016         	str	r0, [sp, #0x58]
;     }
700a1c02: e7ff         	b	0x700a1c04 <Sciclient_pmQueryModuleClkFreq+0xa4> @ imm = #-0x2
;     if (clockId >= 255U)
700a1c04: 981c         	ldr	r0, [sp, #0x70]
700a1c06: 28ff         	cmp	r0, #0xff
700a1c08: d307         	blo	0x700a1c1a <Sciclient_pmQueryModuleClkFreq+0xba> @ imm = #0xe
700a1c0a: e7ff         	b	0x700a1c0c <Sciclient_pmQueryModuleClkFreq+0xac> @ imm = #-0x2
;         request.clk32 = clockId;
700a1c0c: 981c         	ldr	r0, [sp, #0x70]
700a1c0e: f8cd 005d    	str.w	r0, [sp, #0x5d]
700a1c12: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a1c14: f88d 005c    	strb.w	r0, [sp, #0x5c]
;     }
700a1c18: e003         	b	0x700a1c22 <Sciclient_pmQueryModuleClkFreq+0xc2> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a1c1a: 981c         	ldr	r0, [sp, #0x70]
700a1c1c: f88d 005c    	strb.w	r0, [sp, #0x5c]
700a1c20: e7ff         	b	0x700a1c22 <Sciclient_pmQueryModuleClkFreq+0xc2> @ imm = #-0x2
700a1c22: 2000         	movs	r0, #0x0
;     struct tisci_msg_query_freq_resp response = {{0}};
700a1c24: 900d         	str	r0, [sp, #0x34]
700a1c26: 900c         	str	r0, [sp, #0x30]
700a1c28: 900b         	str	r0, [sp, #0x2c]
700a1c2a: 900a         	str	r0, [sp, #0x28]
700a1c2c: f240 110d    	movw	r1, #0x10d
;     reqParam.messageType    = (uint16_t) TISCI_MSG_QUERY_FREQ;
700a1c30: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a1c34: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a1c36: 9106         	str	r1, [sp, #0x18]
700a1c38: a90e         	add	r1, sp, #0x38
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a1c3a: 9107         	str	r1, [sp, #0x1c]
700a1c3c: 2129         	movs	r1, #0x29
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a1c3e: 9108         	str	r1, [sp, #0x20]
;     reqParam.timeout        = (uint32_t) timeout;
700a1c40: 9921         	ldr	r1, [sp, #0x84]
700a1c42: 9109         	str	r1, [sp, #0x24]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a1c44: 9002         	str	r0, [sp, #0x8]
700a1c46: a80a         	add	r0, sp, #0x28
;     respParam.pRespPayload    = (uint8_t *) &response;
700a1c48: 9003         	str	r0, [sp, #0xc]
700a1c4a: 2010         	movs	r0, #0x10
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a1c4c: 9004         	str	r0, [sp, #0x10]
700a1c4e: a805         	add	r0, sp, #0x14
700a1c50: a902         	add	r1, sp, #0x8
;     retVal = Sciclient_service(&reqParam, &respParam);
700a1c52: f7fa f9e5    	bl	0x7009c020 <Sciclient_service> @ imm = #-0x5c36
700a1c56: 9019         	str	r0, [sp, #0x64]
;     if((retVal != SystemP_SUCCESS) ||
700a1c58: 9819         	ldr	r0, [sp, #0x64]
700a1c5a: b930         	cbnz	r0, 0x700a1c6a <Sciclient_pmQueryModuleClkFreq+0x10a> @ imm = #0xc
700a1c5c: e7ff         	b	0x700a1c5e <Sciclient_pmQueryModuleClkFreq+0xfe> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a1c5e: 9802         	ldr	r0, [sp, #0x8]
700a1c60: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a1c64: 2802         	cmp	r0, #0x2
700a1c66: d004         	beq	0x700a1c72 <Sciclient_pmQueryModuleClkFreq+0x112> @ imm = #0x8
700a1c68: e7ff         	b	0x700a1c6a <Sciclient_pmQueryModuleClkFreq+0x10a> @ imm = #-0x2
700a1c6a: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a1c6e: 9019         	str	r0, [sp, #0x64]
;     }
700a1c70: e7ff         	b	0x700a1c72 <Sciclient_pmQueryModuleClkFreq+0x112> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a1c72: 9819         	ldr	r0, [sp, #0x64]
700a1c74: b930         	cbnz	r0, 0x700a1c84 <Sciclient_pmQueryModuleClkFreq+0x124> @ imm = #0xc
700a1c76: e7ff         	b	0x700a1c78 <Sciclient_pmQueryModuleClkFreq+0x118> @ imm = #-0x2
;         *respFreqHz = (uint64_t) response.freq_hz;
700a1c78: 980c         	ldr	r0, [sp, #0x30]
700a1c7a: 9a0d         	ldr	r2, [sp, #0x34]
700a1c7c: 9920         	ldr	r1, [sp, #0x80]
700a1c7e: 604a         	str	r2, [r1, #0x4]
700a1c80: 6008         	str	r0, [r1]
;     }
700a1c82: e7ff         	b	0x700a1c84 <Sciclient_pmQueryModuleClkFreq+0x124> @ imm = #-0x2
;     return retVal;
700a1c84: 9819         	ldr	r0, [sp, #0x64]
700a1c86: b01e         	add	sp, #0x78
700a1c88: bd80         	pop	{r7, pc}
700a1c8a: 0000         	movs	r0, r0
700a1c8c: 0000         	movs	r0, r0
700a1c8e: 0000         	movs	r0, r0

700a1c90 <xQueueReceive>:
; {
700a1c90: b580         	push	{r7, lr}
700a1c92: b08a         	sub	sp, #0x28
700a1c94: 9008         	str	r0, [sp, #0x20]
700a1c96: 9107         	str	r1, [sp, #0x1c]
700a1c98: 9206         	str	r2, [sp, #0x18]
700a1c9a: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
700a1c9c: 9005         	str	r0, [sp, #0x14]
;     Queue_t * const pxQueue = xQueue;
700a1c9e: 9808         	ldr	r0, [sp, #0x20]
700a1ca0: 9002         	str	r0, [sp, #0x8]
;     for( ; ; )
700a1ca2: e7ff         	b	0x700a1ca4 <xQueueReceive+0x14> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a1ca4: f00a ff94    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0xaf28
;             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a1ca8: 9802         	ldr	r0, [sp, #0x8]
700a1caa: 6b80         	ldr	r0, [r0, #0x38]
700a1cac: 9001         	str	r0, [sp, #0x4]
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a1cae: 9801         	ldr	r0, [sp, #0x4]
700a1cb0: b1e0         	cbz	r0, 0x700a1cec <xQueueReceive+0x5c> @ imm = #0x38
700a1cb2: e7ff         	b	0x700a1cb4 <xQueueReceive+0x24> @ imm = #-0x2
;                 prvCopyDataFromQueue( pxQueue, pvBuffer );
700a1cb4: 9802         	ldr	r0, [sp, #0x8]
700a1cb6: 9907         	ldr	r1, [sp, #0x1c]
700a1cb8: f00a f94a    	bl	0x700abf50 <prvCopyDataFromQueue> @ imm = #0xa294
;                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
700a1cbc: 9801         	ldr	r0, [sp, #0x4]
700a1cbe: 3801         	subs	r0, #0x1
700a1cc0: 9902         	ldr	r1, [sp, #0x8]
700a1cc2: 6388         	str	r0, [r1, #0x38]
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a1cc4: 9802         	ldr	r0, [sp, #0x8]
700a1cc6: 6900         	ldr	r0, [r0, #0x10]
700a1cc8: b150         	cbz	r0, 0x700a1ce0 <xQueueReceive+0x50> @ imm = #0x14
700a1cca: e7ff         	b	0x700a1ccc <xQueueReceive+0x3c> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a1ccc: 9802         	ldr	r0, [sp, #0x8]
700a1cce: 3010         	adds	r0, #0x10
700a1cd0: f004 f90e    	bl	0x700a5ef0 <xTaskRemoveFromEventList> @ imm = #0x421c
700a1cd4: b110         	cbz	r0, 0x700a1cdc <xQueueReceive+0x4c> @ imm = #0x4
700a1cd6: e7ff         	b	0x700a1cd8 <xQueueReceive+0x48> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
700a1cd8: df00         	svc	#0x0
;                     }
700a1cda: e000         	b	0x700a1cde <xQueueReceive+0x4e> @ imm = #0x0
700a1cdc: e7ff         	b	0x700a1cde <xQueueReceive+0x4e> @ imm = #-0x2
;                 }
700a1cde: e000         	b	0x700a1ce2 <xQueueReceive+0x52> @ imm = #0x0
700a1ce0: e7ff         	b	0x700a1ce2 <xQueueReceive+0x52> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a1ce2: f009 fff5    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x9fea
700a1ce6: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a1ce8: 9009         	str	r0, [sp, #0x24]
700a1cea: e063         	b	0x700a1db4 <xQueueReceive+0x124> @ imm = #0xc6
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a1cec: 9806         	ldr	r0, [sp, #0x18]
700a1cee: b928         	cbnz	r0, 0x700a1cfc <xQueueReceive+0x6c> @ imm = #0xa
700a1cf0: e7ff         	b	0x700a1cf2 <xQueueReceive+0x62> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a1cf2: f009 ffed    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x9fda
700a1cf6: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
700a1cf8: 9009         	str	r0, [sp, #0x24]
700a1cfa: e05b         	b	0x700a1db4 <xQueueReceive+0x124> @ imm = #0xb6
;                 else if( xEntryTimeSet == pdFALSE )
700a1cfc: 9805         	ldr	r0, [sp, #0x14]
700a1cfe: b930         	cbnz	r0, 0x700a1d0e <xQueueReceive+0x7e> @ imm = #0xc
700a1d00: e7ff         	b	0x700a1d02 <xQueueReceive+0x72> @ imm = #-0x2
700a1d02: a803         	add	r0, sp, #0xc
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a1d04: f00b fcf4    	bl	0x700ad6f0 <vTaskInternalSetTimeOutState> @ imm = #0xb9e8
700a1d08: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a1d0a: 9005         	str	r0, [sp, #0x14]
;                 }
700a1d0c: e000         	b	0x700a1d10 <xQueueReceive+0x80> @ imm = #0x0
700a1d0e: e7ff         	b	0x700a1d10 <xQueueReceive+0x80> @ imm = #-0x2
700a1d10: e7ff         	b	0x700a1d12 <xQueueReceive+0x82> @ imm = #-0x2
700a1d12: e7ff         	b	0x700a1d14 <xQueueReceive+0x84> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a1d14: f009 ffdc    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x9fb8
;         vTaskSuspendAll();
700a1d18: f00c f98a    	bl	0x700ae030 <vTaskSuspendAll> @ imm = #0xc314
;         prvLockQueue( pxQueue );
700a1d1c: f00a ff58    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0xaeb0
700a1d20: 9802         	ldr	r0, [sp, #0x8]
700a1d22: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a1d26: 3001         	adds	r0, #0x1
700a1d28: b928         	cbnz	r0, 0x700a1d36 <xQueueReceive+0xa6> @ imm = #0xa
700a1d2a: e7ff         	b	0x700a1d2c <xQueueReceive+0x9c> @ imm = #-0x2
700a1d2c: 9902         	ldr	r1, [sp, #0x8]
700a1d2e: 2000         	movs	r0, #0x0
700a1d30: f881 0044    	strb.w	r0, [r1, #0x44]
700a1d34: e7ff         	b	0x700a1d36 <xQueueReceive+0xa6> @ imm = #-0x2
700a1d36: 9802         	ldr	r0, [sp, #0x8]
700a1d38: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a1d3c: 3001         	adds	r0, #0x1
700a1d3e: b928         	cbnz	r0, 0x700a1d4c <xQueueReceive+0xbc> @ imm = #0xa
700a1d40: e7ff         	b	0x700a1d42 <xQueueReceive+0xb2> @ imm = #-0x2
700a1d42: 9902         	ldr	r1, [sp, #0x8]
700a1d44: 2000         	movs	r0, #0x0
700a1d46: f881 0045    	strb.w	r0, [r1, #0x45]
700a1d4a: e7ff         	b	0x700a1d4c <xQueueReceive+0xbc> @ imm = #-0x2
700a1d4c: f009 ffc0    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x9f80
700a1d50: a803         	add	r0, sp, #0xc
700a1d52: a906         	add	r1, sp, #0x18
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a1d54: f005 fcdc    	bl	0x700a7710 <xTaskCheckForTimeOut> @ imm = #0x59b8
700a1d58: b9e0         	cbnz	r0, 0x700a1d94 <xQueueReceive+0x104> @ imm = #0x38
700a1d5a: e7ff         	b	0x700a1d5c <xQueueReceive+0xcc> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a1d5c: 9802         	ldr	r0, [sp, #0x8]
700a1d5e: f00b fb07    	bl	0x700ad370 <prvIsQueueEmpty> @ imm = #0xb60e
700a1d62: b180         	cbz	r0, 0x700a1d86 <xQueueReceive+0xf6> @ imm = #0x20
700a1d64: e7ff         	b	0x700a1d66 <xQueueReceive+0xd6> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
700a1d66: 9802         	ldr	r0, [sp, #0x8]
700a1d68: 3024         	adds	r0, #0x24
700a1d6a: 9906         	ldr	r1, [sp, #0x18]
700a1d6c: f00b fbc0    	bl	0x700ad4f0 <vTaskPlaceOnEventList> @ imm = #0xb780
;                 prvUnlockQueue( pxQueue );
700a1d70: 9802         	ldr	r0, [sp, #0x8]
700a1d72: f004 fa85    	bl	0x700a6280 <prvUnlockQueue> @ imm = #0x450a
;                 if( xTaskResumeAll() == pdFALSE )
700a1d76: f7fe fd93    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0x14da
700a1d7a: b910         	cbnz	r0, 0x700a1d82 <xQueueReceive+0xf2> @ imm = #0x4
700a1d7c: e7ff         	b	0x700a1d7e <xQueueReceive+0xee> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a1d7e: df00         	svc	#0x0
;                 }
700a1d80: e000         	b	0x700a1d84 <xQueueReceive+0xf4> @ imm = #0x0
700a1d82: e7ff         	b	0x700a1d84 <xQueueReceive+0xf4> @ imm = #-0x2
;             }
700a1d84: e005         	b	0x700a1d92 <xQueueReceive+0x102> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a1d86: 9802         	ldr	r0, [sp, #0x8]
700a1d88: f004 fa7a    	bl	0x700a6280 <prvUnlockQueue> @ imm = #0x44f4
;                 ( void ) xTaskResumeAll();
700a1d8c: f7fe fd88    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0x14f0
700a1d90: e7ff         	b	0x700a1d92 <xQueueReceive+0x102> @ imm = #-0x2
;         }
700a1d92: e00e         	b	0x700a1db2 <xQueueReceive+0x122> @ imm = #0x1c
;             prvUnlockQueue( pxQueue );
700a1d94: 9802         	ldr	r0, [sp, #0x8]
700a1d96: f004 fa73    	bl	0x700a6280 <prvUnlockQueue> @ imm = #0x44e6
;             ( void ) xTaskResumeAll();
700a1d9a: f7fe fd81    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0x14fe
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a1d9e: 9802         	ldr	r0, [sp, #0x8]
700a1da0: f00b fae6    	bl	0x700ad370 <prvIsQueueEmpty> @ imm = #0xb5cc
700a1da4: b118         	cbz	r0, 0x700a1dae <xQueueReceive+0x11e> @ imm = #0x6
700a1da6: e7ff         	b	0x700a1da8 <xQueueReceive+0x118> @ imm = #-0x2
700a1da8: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
700a1daa: 9009         	str	r0, [sp, #0x24]
700a1dac: e002         	b	0x700a1db4 <xQueueReceive+0x124> @ imm = #0x4
700a1dae: e7ff         	b	0x700a1db0 <xQueueReceive+0x120> @ imm = #-0x2
700a1db0: e7ff         	b	0x700a1db2 <xQueueReceive+0x122> @ imm = #-0x2
;     for( ; ; )
700a1db2: e777         	b	0x700a1ca4 <xQueueReceive+0x14> @ imm = #-0x112
; }
700a1db4: 9809         	ldr	r0, [sp, #0x24]
700a1db6: b00a         	add	sp, #0x28
700a1db8: bd80         	pop	{r7, pc}
700a1dba: 0000         	movs	r0, r0
700a1dbc: 0000         	movs	r0, r0
700a1dbe: 0000         	movs	r0, r0

700a1dc0 <pxPortInitialiseStack>:
;                                    TaskFunction_t pxCode, void *pvParameters) {
700a1dc0: b083         	sub	sp, #0xc
700a1dc2: 9002         	str	r0, [sp, #0x8]
700a1dc4: 9101         	str	r1, [sp, #0x4]
700a1dc6: 9200         	str	r2, [sp]
;   *pxTopOfStack = (StackType_t)NULL;
700a1dc8: 9902         	ldr	r1, [sp, #0x8]
700a1dca: 2000         	movs	r0, #0x0
700a1dcc: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1dce: 9902         	ldr	r1, [sp, #0x8]
700a1dd0: 3904         	subs	r1, #0x4
700a1dd2: 9102         	str	r1, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)NULL;
700a1dd4: 9902         	ldr	r1, [sp, #0x8]
700a1dd6: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1dd8: 9902         	ldr	r1, [sp, #0x8]
700a1dda: 3904         	subs	r1, #0x4
700a1ddc: 9102         	str	r1, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)NULL;
700a1dde: 9902         	ldr	r1, [sp, #0x8]
700a1de0: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1de2: 9802         	ldr	r0, [sp, #0x8]
700a1de4: 3804         	subs	r0, #0x4
700a1de6: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)portINITIAL_SPSR;
700a1de8: 9902         	ldr	r1, [sp, #0x8]
700a1dea: 201f         	movs	r0, #0x1f
700a1dec: 6008         	str	r0, [r1]
;   if (((uint32_t)pxCode & portTHUMB_MODE_ADDRESS) != 0x00UL) {
700a1dee: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a1df2: 07c0         	lsls	r0, r0, #0x1f
700a1df4: b130         	cbz	r0, 0x700a1e04 <pxPortInitialiseStack+0x44> @ imm = #0xc
700a1df6: e7ff         	b	0x700a1df8 <pxPortInitialiseStack+0x38> @ imm = #-0x2
;     *pxTopOfStack |= portTHUMB_MODE_BIT;
700a1df8: 9902         	ldr	r1, [sp, #0x8]
700a1dfa: 6808         	ldr	r0, [r1]
700a1dfc: f040 0020    	orr	r0, r0, #0x20
700a1e00: 6008         	str	r0, [r1]
;   }
700a1e02: e7ff         	b	0x700a1e04 <pxPortInitialiseStack+0x44> @ imm = #-0x2
;   pxTopOfStack--;
700a1e04: 9802         	ldr	r0, [sp, #0x8]
700a1e06: 3804         	subs	r0, #0x4
700a1e08: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)pxCode;
700a1e0a: 9801         	ldr	r0, [sp, #0x4]
700a1e0c: 9902         	ldr	r1, [sp, #0x8]
700a1e0e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1e10: 9802         	ldr	r0, [sp, #0x8]
700a1e12: 3804         	subs	r0, #0x4
700a1e14: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* R14 */
700a1e16: 9902         	ldr	r1, [sp, #0x8]
700a1e18: f24e 1041    	movw	r0, #0xe141
700a1e1c: f2c7 000a    	movt	r0, #0x700a
700a1e20: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1e22: 9802         	ldr	r0, [sp, #0x8]
700a1e24: 3804         	subs	r0, #0x4
700a1e26: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x12121212; /* R12 */
700a1e28: 9902         	ldr	r1, [sp, #0x8]
700a1e2a: f04f 3012    	mov.w	r0, #0x12121212
700a1e2e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1e30: 9802         	ldr	r0, [sp, #0x8]
700a1e32: 3804         	subs	r0, #0x4
700a1e34: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x11111111; /* R11 */
700a1e36: 9902         	ldr	r1, [sp, #0x8]
700a1e38: f04f 3011    	mov.w	r0, #0x11111111
700a1e3c: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1e3e: 9802         	ldr	r0, [sp, #0x8]
700a1e40: 3804         	subs	r0, #0x4
700a1e42: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x10101010; /* R10 */
700a1e44: 9902         	ldr	r1, [sp, #0x8]
700a1e46: f04f 3010    	mov.w	r0, #0x10101010
700a1e4a: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1e4c: 9802         	ldr	r0, [sp, #0x8]
700a1e4e: 3804         	subs	r0, #0x4
700a1e50: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x09090909; /* R9 */
700a1e52: 9902         	ldr	r1, [sp, #0x8]
700a1e54: f04f 3009    	mov.w	r0, #0x9090909
700a1e58: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1e5a: 9802         	ldr	r0, [sp, #0x8]
700a1e5c: 3804         	subs	r0, #0x4
700a1e5e: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x08080808; /* R8 */
700a1e60: 9902         	ldr	r1, [sp, #0x8]
700a1e62: f04f 3008    	mov.w	r0, #0x8080808
700a1e66: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1e68: 9802         	ldr	r0, [sp, #0x8]
700a1e6a: 3804         	subs	r0, #0x4
700a1e6c: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x07070707; /* R7 */
700a1e6e: 9902         	ldr	r1, [sp, #0x8]
700a1e70: f04f 3007    	mov.w	r0, #0x7070707
700a1e74: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1e76: 9802         	ldr	r0, [sp, #0x8]
700a1e78: 3804         	subs	r0, #0x4
700a1e7a: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x06060606; /* R6 */
700a1e7c: 9902         	ldr	r1, [sp, #0x8]
700a1e7e: f04f 3006    	mov.w	r0, #0x6060606
700a1e82: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1e84: 9802         	ldr	r0, [sp, #0x8]
700a1e86: 3804         	subs	r0, #0x4
700a1e88: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x05050505; /* R5 */
700a1e8a: 9902         	ldr	r1, [sp, #0x8]
700a1e8c: f04f 3005    	mov.w	r0, #0x5050505
700a1e90: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1e92: 9802         	ldr	r0, [sp, #0x8]
700a1e94: 3804         	subs	r0, #0x4
700a1e96: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x04040404; /* R4 */
700a1e98: 9902         	ldr	r1, [sp, #0x8]
700a1e9a: f04f 3004    	mov.w	r0, #0x4040404
700a1e9e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1ea0: 9802         	ldr	r0, [sp, #0x8]
700a1ea2: 3804         	subs	r0, #0x4
700a1ea4: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x03030303; /* R3 */
700a1ea6: 9902         	ldr	r1, [sp, #0x8]
700a1ea8: f04f 3003    	mov.w	r0, #0x3030303
700a1eac: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1eae: 9802         	ldr	r0, [sp, #0x8]
700a1eb0: 3804         	subs	r0, #0x4
700a1eb2: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x02020202; /* R2 */
700a1eb4: 9902         	ldr	r1, [sp, #0x8]
700a1eb6: f04f 3002    	mov.w	r0, #0x2020202
700a1eba: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1ebc: 9802         	ldr	r0, [sp, #0x8]
700a1ebe: 3804         	subs	r0, #0x4
700a1ec0: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x01010101; /* R1 */
700a1ec2: 9902         	ldr	r1, [sp, #0x8]
700a1ec4: f04f 3001    	mov.w	r0, #0x1010101
700a1ec8: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1eca: 9802         	ldr	r0, [sp, #0x8]
700a1ecc: 3804         	subs	r0, #0x4
700a1ece: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)pvParameters; /* R0 */
700a1ed0: 9800         	ldr	r0, [sp]
700a1ed2: 9902         	ldr	r1, [sp, #0x8]
700a1ed4: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1ed6: 9802         	ldr	r0, [sp, #0x8]
700a1ed8: 3804         	subs	r0, #0x4
700a1eda: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = portNO_FLOATING_POINT_CONTEXT;
700a1edc: 9902         	ldr	r1, [sp, #0x8]
700a1ede: 2000         	movs	r0, #0x0
700a1ee0: 6008         	str	r0, [r1]
;   return pxTopOfStack;
700a1ee2: 9802         	ldr	r0, [sp, #0x8]
700a1ee4: b003         	add	sp, #0xc
700a1ee6: 4770         	bx	lr
		...

700a1ef0 <Udma_rmAllocBlkCopyCh>:
; {
700a1ef0: b580         	push	{r7, lr}
700a1ef2: b088         	sub	sp, #0x20
700a1ef4: 9007         	str	r0, [sp, #0x1c]
700a1ef6: 9106         	str	r1, [sp, #0x18]
700a1ef8: 2000         	movs	r0, #0x0
700a1efa: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1efe: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1f00: 9806         	ldr	r0, [sp, #0x18]
700a1f02: f500 70ea    	add.w	r0, r0, #0x1d4
700a1f06: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1f08: 9806         	ldr	r0, [sp, #0x18]
700a1f0a: f500 609f    	add.w	r0, r0, #0x4f8
700a1f0e: f04f 31ff    	mov.w	r1, #0xffffffff
700a1f12: f006 fead    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x6d5a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1f16: 9807         	ldr	r0, [sp, #0x1c]
700a1f18: 2101         	movs	r1, #0x1
700a1f1a: f6cf 71ff    	movt	r1, #0xffff
700a1f1e: 4288         	cmp	r0, r1
700a1f20: d136         	bne	0x700a1f90 <Udma_rmAllocBlkCopyCh+0xa0> @ imm = #0x6c
700a1f22: e7ff         	b	0x700a1f24 <Udma_rmAllocBlkCopyCh+0x34> @ imm = #-0x2
700a1f24: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyCh; i++)
700a1f26: 9005         	str	r0, [sp, #0x14]
700a1f28: e7ff         	b	0x700a1f2a <Udma_rmAllocBlkCopyCh+0x3a> @ imm = #-0x2
700a1f2a: 9805         	ldr	r0, [sp, #0x14]
700a1f2c: 9900         	ldr	r1, [sp]
700a1f2e: 6949         	ldr	r1, [r1, #0x14]
700a1f30: 4288         	cmp	r0, r1
700a1f32: d22c         	bhs	0x700a1f8e <Udma_rmAllocBlkCopyCh+0x9e> @ imm = #0x58
700a1f34: e7ff         	b	0x700a1f36 <Udma_rmAllocBlkCopyCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a1f36: 9805         	ldr	r0, [sp, #0x14]
700a1f38: 0940         	lsrs	r0, r0, #0x5
700a1f3a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1f3c: 9805         	ldr	r0, [sp, #0x14]
700a1f3e: 9904         	ldr	r1, [sp, #0x10]
700a1f40: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1f44: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1f46: 9903         	ldr	r1, [sp, #0xc]
700a1f48: 2001         	movs	r0, #0x1
700a1f4a: 4088         	lsls	r0, r1
700a1f4c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyChFlag[offset] & bitMask) == bitMask)
700a1f4e: 9806         	ldr	r0, [sp, #0x18]
700a1f50: 9904         	ldr	r1, [sp, #0x10]
700a1f52: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1f56: f8d0 02c8    	ldr.w	r0, [r0, #0x2c8]
700a1f5a: 9902         	ldr	r1, [sp, #0x8]
700a1f5c: 4008         	ands	r0, r1
700a1f5e: 4288         	cmp	r0, r1
700a1f60: d110         	bne	0x700a1f84 <Udma_rmAllocBlkCopyCh+0x94> @ imm = #0x20
700a1f62: e7ff         	b	0x700a1f64 <Udma_rmAllocBlkCopyCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyChFlag[offset] &= ~bitMask;
700a1f64: 9a02         	ldr	r2, [sp, #0x8]
700a1f66: 9806         	ldr	r0, [sp, #0x18]
700a1f68: 9904         	ldr	r1, [sp, #0x10]
700a1f6a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1f6e: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a1f72: 4390         	bics	r0, r2
700a1f74: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;                 chNum = i + rmInitPrms->startBlkCopyCh;  /* Add start offset */
700a1f78: 9805         	ldr	r0, [sp, #0x14]
700a1f7a: 9900         	ldr	r1, [sp]
700a1f7c: 6909         	ldr	r1, [r1, #0x10]
700a1f7e: 4408         	add	r0, r1
700a1f80: 9001         	str	r0, [sp, #0x4]
;                 break;
700a1f82: e004         	b	0x700a1f8e <Udma_rmAllocBlkCopyCh+0x9e> @ imm = #0x8
;         }
700a1f84: e7ff         	b	0x700a1f86 <Udma_rmAllocBlkCopyCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyCh; i++)
700a1f86: 9805         	ldr	r0, [sp, #0x14]
700a1f88: 3001         	adds	r0, #0x1
700a1f8a: 9005         	str	r0, [sp, #0x14]
700a1f8c: e7cd         	b	0x700a1f2a <Udma_rmAllocBlkCopyCh+0x3a> @ imm = #-0x66
;     }
700a1f8e: e038         	b	0x700a2002 <Udma_rmAllocBlkCopyCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyCh) &&
700a1f90: 9807         	ldr	r0, [sp, #0x1c]
700a1f92: 9900         	ldr	r1, [sp]
700a1f94: 6909         	ldr	r1, [r1, #0x10]
700a1f96: 4288         	cmp	r0, r1
700a1f98: d332         	blo	0x700a2000 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #0x64
700a1f9a: e7ff         	b	0x700a1f9c <Udma_rmAllocBlkCopyCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyCh + rmInitPrms->numBlkCopyCh)))
700a1f9c: 9807         	ldr	r0, [sp, #0x1c]
700a1f9e: 9a00         	ldr	r2, [sp]
700a1fa0: 6911         	ldr	r1, [r2, #0x10]
700a1fa2: 6952         	ldr	r2, [r2, #0x14]
700a1fa4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyCh) &&
700a1fa6: 4288         	cmp	r0, r1
700a1fa8: d22a         	bhs	0x700a2000 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #0x54
700a1faa: e7ff         	b	0x700a1fac <Udma_rmAllocBlkCopyCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyCh;
700a1fac: 9807         	ldr	r0, [sp, #0x1c]
700a1fae: 9900         	ldr	r1, [sp]
700a1fb0: 6909         	ldr	r1, [r1, #0x10]
700a1fb2: 1a40         	subs	r0, r0, r1
700a1fb4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1fb6: 9805         	ldr	r0, [sp, #0x14]
700a1fb8: 0940         	lsrs	r0, r0, #0x5
700a1fba: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1fbc: 9805         	ldr	r0, [sp, #0x14]
700a1fbe: 9904         	ldr	r1, [sp, #0x10]
700a1fc0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1fc4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1fc6: 9903         	ldr	r1, [sp, #0xc]
700a1fc8: 2001         	movs	r0, #0x1
700a1fca: 4088         	lsls	r0, r1
700a1fcc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyChFlag[offset] & bitMask) == bitMask)
700a1fce: 9806         	ldr	r0, [sp, #0x18]
700a1fd0: 9904         	ldr	r1, [sp, #0x10]
700a1fd2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1fd6: f8d0 02c8    	ldr.w	r0, [r0, #0x2c8]
700a1fda: 9902         	ldr	r1, [sp, #0x8]
700a1fdc: 4008         	ands	r0, r1
700a1fde: 4288         	cmp	r0, r1
700a1fe0: d10d         	bne	0x700a1ffe <Udma_rmAllocBlkCopyCh+0x10e> @ imm = #0x1a
700a1fe2: e7ff         	b	0x700a1fe4 <Udma_rmAllocBlkCopyCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyChFlag[offset] &= ~bitMask;
700a1fe4: 9a02         	ldr	r2, [sp, #0x8]
700a1fe6: 9806         	ldr	r0, [sp, #0x18]
700a1fe8: 9904         	ldr	r1, [sp, #0x10]
700a1fea: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1fee: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a1ff2: 4390         	bics	r0, r2
700a1ff4: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;                 chNum = preferredChNum;
700a1ff8: 9807         	ldr	r0, [sp, #0x1c]
700a1ffa: 9001         	str	r0, [sp, #0x4]
;             }
700a1ffc: e7ff         	b	0x700a1ffe <Udma_rmAllocBlkCopyCh+0x10e> @ imm = #-0x2
;         }
700a1ffe: e7ff         	b	0x700a2000 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #-0x2
700a2000: e7ff         	b	0x700a2002 <Udma_rmAllocBlkCopyCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2002: 9806         	ldr	r0, [sp, #0x18]
700a2004: f500 609f    	add.w	r0, r0, #0x4f8
700a2008: f008 f982    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x8304
;     return (chNum);
700a200c: 9801         	ldr	r0, [sp, #0x4]
700a200e: b008         	add	sp, #0x20
700a2010: bd80         	pop	{r7, pc}
		...
700a201e: 0000         	movs	r0, r0

700a2020 <Udma_rmAllocBlkCopyHcCh>:
; {
700a2020: b580         	push	{r7, lr}
700a2022: b088         	sub	sp, #0x20
700a2024: 9007         	str	r0, [sp, #0x1c]
700a2026: 9106         	str	r1, [sp, #0x18]
700a2028: 2000         	movs	r0, #0x0
700a202a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a202e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a2030: 9806         	ldr	r0, [sp, #0x18]
700a2032: f500 70ea    	add.w	r0, r0, #0x1d4
700a2036: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2038: 9806         	ldr	r0, [sp, #0x18]
700a203a: f500 609f    	add.w	r0, r0, #0x4f8
700a203e: f04f 31ff    	mov.w	r1, #0xffffffff
700a2042: f006 fe15    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x6c2a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a2046: 9807         	ldr	r0, [sp, #0x1c]
700a2048: 2101         	movs	r1, #0x1
700a204a: f6cf 71ff    	movt	r1, #0xffff
700a204e: 4288         	cmp	r0, r1
700a2050: d136         	bne	0x700a20c0 <Udma_rmAllocBlkCopyHcCh+0xa0> @ imm = #0x6c
700a2052: e7ff         	b	0x700a2054 <Udma_rmAllocBlkCopyHcCh+0x34> @ imm = #-0x2
700a2054: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyHcCh; i++)
700a2056: 9005         	str	r0, [sp, #0x14]
700a2058: e7ff         	b	0x700a205a <Udma_rmAllocBlkCopyHcCh+0x3a> @ imm = #-0x2
700a205a: 9805         	ldr	r0, [sp, #0x14]
700a205c: 9900         	ldr	r1, [sp]
700a205e: 68c9         	ldr	r1, [r1, #0xc]
700a2060: 4288         	cmp	r0, r1
700a2062: d22c         	bhs	0x700a20be <Udma_rmAllocBlkCopyHcCh+0x9e> @ imm = #0x58
700a2064: e7ff         	b	0x700a2066 <Udma_rmAllocBlkCopyHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a2066: 9805         	ldr	r0, [sp, #0x14]
700a2068: 0940         	lsrs	r0, r0, #0x5
700a206a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a206c: 9805         	ldr	r0, [sp, #0x14]
700a206e: 9904         	ldr	r1, [sp, #0x10]
700a2070: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2074: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2076: 9903         	ldr	r1, [sp, #0xc]
700a2078: 2001         	movs	r0, #0x1
700a207a: 4088         	lsls	r0, r1
700a207c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyHcChFlag[offset] & bitMask) == bitMask)
700a207e: 9806         	ldr	r0, [sp, #0x18]
700a2080: 9904         	ldr	r1, [sp, #0x10]
700a2082: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2086: f8d0 02cc    	ldr.w	r0, [r0, #0x2cc]
700a208a: 9902         	ldr	r1, [sp, #0x8]
700a208c: 4008         	ands	r0, r1
700a208e: 4288         	cmp	r0, r1
700a2090: d110         	bne	0x700a20b4 <Udma_rmAllocBlkCopyHcCh+0x94> @ imm = #0x20
700a2092: e7ff         	b	0x700a2094 <Udma_rmAllocBlkCopyHcCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyHcChFlag[offset] &= ~bitMask;
700a2094: 9a02         	ldr	r2, [sp, #0x8]
700a2096: 9806         	ldr	r0, [sp, #0x18]
700a2098: 9904         	ldr	r1, [sp, #0x10]
700a209a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a209e: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a20a2: 4390         	bics	r0, r2
700a20a4: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;                 chNum = i + rmInitPrms->startBlkCopyHcCh;  /* Add start offset */
700a20a8: 9805         	ldr	r0, [sp, #0x14]
700a20aa: 9900         	ldr	r1, [sp]
700a20ac: 6889         	ldr	r1, [r1, #0x8]
700a20ae: 4408         	add	r0, r1
700a20b0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a20b2: e004         	b	0x700a20be <Udma_rmAllocBlkCopyHcCh+0x9e> @ imm = #0x8
;         }
700a20b4: e7ff         	b	0x700a20b6 <Udma_rmAllocBlkCopyHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyHcCh; i++)
700a20b6: 9805         	ldr	r0, [sp, #0x14]
700a20b8: 3001         	adds	r0, #0x1
700a20ba: 9005         	str	r0, [sp, #0x14]
700a20bc: e7cd         	b	0x700a205a <Udma_rmAllocBlkCopyHcCh+0x3a> @ imm = #-0x66
;     }
700a20be: e038         	b	0x700a2132 <Udma_rmAllocBlkCopyHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyHcCh) &&
700a20c0: 9807         	ldr	r0, [sp, #0x1c]
700a20c2: 9900         	ldr	r1, [sp]
700a20c4: 6889         	ldr	r1, [r1, #0x8]
700a20c6: 4288         	cmp	r0, r1
700a20c8: d332         	blo	0x700a2130 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #0x64
700a20ca: e7ff         	b	0x700a20cc <Udma_rmAllocBlkCopyHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyHcCh + rmInitPrms->numBlkCopyHcCh)))
700a20cc: 9807         	ldr	r0, [sp, #0x1c]
700a20ce: 9a00         	ldr	r2, [sp]
700a20d0: 6891         	ldr	r1, [r2, #0x8]
700a20d2: 68d2         	ldr	r2, [r2, #0xc]
700a20d4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyHcCh) &&
700a20d6: 4288         	cmp	r0, r1
700a20d8: d22a         	bhs	0x700a2130 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #0x54
700a20da: e7ff         	b	0x700a20dc <Udma_rmAllocBlkCopyHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyHcCh;
700a20dc: 9807         	ldr	r0, [sp, #0x1c]
700a20de: 9900         	ldr	r1, [sp]
700a20e0: 6889         	ldr	r1, [r1, #0x8]
700a20e2: 1a40         	subs	r0, r0, r1
700a20e4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a20e6: 9805         	ldr	r0, [sp, #0x14]
700a20e8: 0940         	lsrs	r0, r0, #0x5
700a20ea: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a20ec: 9805         	ldr	r0, [sp, #0x14]
700a20ee: 9904         	ldr	r1, [sp, #0x10]
700a20f0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a20f4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a20f6: 9903         	ldr	r1, [sp, #0xc]
700a20f8: 2001         	movs	r0, #0x1
700a20fa: 4088         	lsls	r0, r1
700a20fc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyHcChFlag[offset] & bitMask) == bitMask)
700a20fe: 9806         	ldr	r0, [sp, #0x18]
700a2100: 9904         	ldr	r1, [sp, #0x10]
700a2102: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2106: f8d0 02cc    	ldr.w	r0, [r0, #0x2cc]
700a210a: 9902         	ldr	r1, [sp, #0x8]
700a210c: 4008         	ands	r0, r1
700a210e: 4288         	cmp	r0, r1
700a2110: d10d         	bne	0x700a212e <Udma_rmAllocBlkCopyHcCh+0x10e> @ imm = #0x1a
700a2112: e7ff         	b	0x700a2114 <Udma_rmAllocBlkCopyHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyHcChFlag[offset] &= ~bitMask;
700a2114: 9a02         	ldr	r2, [sp, #0x8]
700a2116: 9806         	ldr	r0, [sp, #0x18]
700a2118: 9904         	ldr	r1, [sp, #0x10]
700a211a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a211e: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a2122: 4390         	bics	r0, r2
700a2124: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;                 chNum = preferredChNum;
700a2128: 9807         	ldr	r0, [sp, #0x1c]
700a212a: 9001         	str	r0, [sp, #0x4]
;             }
700a212c: e7ff         	b	0x700a212e <Udma_rmAllocBlkCopyHcCh+0x10e> @ imm = #-0x2
;         }
700a212e: e7ff         	b	0x700a2130 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #-0x2
700a2130: e7ff         	b	0x700a2132 <Udma_rmAllocBlkCopyHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2132: 9806         	ldr	r0, [sp, #0x18]
700a2134: f500 609f    	add.w	r0, r0, #0x4f8
700a2138: f008 f8ea    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x81d4
;     return (chNum);
700a213c: 9801         	ldr	r0, [sp, #0x4]
700a213e: b008         	add	sp, #0x20
700a2140: bd80         	pop	{r7, pc}
		...
700a214e: 0000         	movs	r0, r0

700a2150 <Udma_rmAllocBlkCopyUhcCh>:
; {
700a2150: b580         	push	{r7, lr}
700a2152: b088         	sub	sp, #0x20
700a2154: 9007         	str	r0, [sp, #0x1c]
700a2156: 9106         	str	r1, [sp, #0x18]
700a2158: 2000         	movs	r0, #0x0
700a215a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a215e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a2160: 9806         	ldr	r0, [sp, #0x18]
700a2162: f500 70ea    	add.w	r0, r0, #0x1d4
700a2166: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2168: 9806         	ldr	r0, [sp, #0x18]
700a216a: f500 609f    	add.w	r0, r0, #0x4f8
700a216e: f04f 31ff    	mov.w	r1, #0xffffffff
700a2172: f006 fd7d    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x6afa
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a2176: 9807         	ldr	r0, [sp, #0x1c]
700a2178: 2101         	movs	r1, #0x1
700a217a: f6cf 71ff    	movt	r1, #0xffff
700a217e: 4288         	cmp	r0, r1
700a2180: d136         	bne	0x700a21f0 <Udma_rmAllocBlkCopyUhcCh+0xa0> @ imm = #0x6c
700a2182: e7ff         	b	0x700a2184 <Udma_rmAllocBlkCopyUhcCh+0x34> @ imm = #-0x2
700a2184: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyUhcCh; i++)
700a2186: 9005         	str	r0, [sp, #0x14]
700a2188: e7ff         	b	0x700a218a <Udma_rmAllocBlkCopyUhcCh+0x3a> @ imm = #-0x2
700a218a: 9805         	ldr	r0, [sp, #0x14]
700a218c: 9900         	ldr	r1, [sp]
700a218e: 6849         	ldr	r1, [r1, #0x4]
700a2190: 4288         	cmp	r0, r1
700a2192: d22c         	bhs	0x700a21ee <Udma_rmAllocBlkCopyUhcCh+0x9e> @ imm = #0x58
700a2194: e7ff         	b	0x700a2196 <Udma_rmAllocBlkCopyUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a2196: 9805         	ldr	r0, [sp, #0x14]
700a2198: 0940         	lsrs	r0, r0, #0x5
700a219a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a219c: 9805         	ldr	r0, [sp, #0x14]
700a219e: 9904         	ldr	r1, [sp, #0x10]
700a21a0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a21a4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a21a6: 9903         	ldr	r1, [sp, #0xc]
700a21a8: 2001         	movs	r0, #0x1
700a21aa: 4088         	lsls	r0, r1
700a21ac: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyUhcChFlag[offset] & bitMask) == bitMask)
700a21ae: 9806         	ldr	r0, [sp, #0x18]
700a21b0: 9904         	ldr	r1, [sp, #0x10]
700a21b2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a21b6: f8d0 02d0    	ldr.w	r0, [r0, #0x2d0]
700a21ba: 9902         	ldr	r1, [sp, #0x8]
700a21bc: 4008         	ands	r0, r1
700a21be: 4288         	cmp	r0, r1
700a21c0: d110         	bne	0x700a21e4 <Udma_rmAllocBlkCopyUhcCh+0x94> @ imm = #0x20
700a21c2: e7ff         	b	0x700a21c4 <Udma_rmAllocBlkCopyUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyUhcChFlag[offset] &= ~bitMask;
700a21c4: 9a02         	ldr	r2, [sp, #0x8]
700a21c6: 9806         	ldr	r0, [sp, #0x18]
700a21c8: 9904         	ldr	r1, [sp, #0x10]
700a21ca: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a21ce: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a21d2: 4390         	bics	r0, r2
700a21d4: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;                 chNum = i + rmInitPrms->startBlkCopyUhcCh;  /* Add start offset */
700a21d8: 9805         	ldr	r0, [sp, #0x14]
700a21da: 9900         	ldr	r1, [sp]
700a21dc: 6809         	ldr	r1, [r1]
700a21de: 4408         	add	r0, r1
700a21e0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a21e2: e004         	b	0x700a21ee <Udma_rmAllocBlkCopyUhcCh+0x9e> @ imm = #0x8
;         }
700a21e4: e7ff         	b	0x700a21e6 <Udma_rmAllocBlkCopyUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyUhcCh; i++)
700a21e6: 9805         	ldr	r0, [sp, #0x14]
700a21e8: 3001         	adds	r0, #0x1
700a21ea: 9005         	str	r0, [sp, #0x14]
700a21ec: e7cd         	b	0x700a218a <Udma_rmAllocBlkCopyUhcCh+0x3a> @ imm = #-0x66
;     }
700a21ee: e038         	b	0x700a2262 <Udma_rmAllocBlkCopyUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyUhcCh) &&
700a21f0: 9807         	ldr	r0, [sp, #0x1c]
700a21f2: 9900         	ldr	r1, [sp]
700a21f4: 6809         	ldr	r1, [r1]
700a21f6: 4288         	cmp	r0, r1
700a21f8: d332         	blo	0x700a2260 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #0x64
700a21fa: e7ff         	b	0x700a21fc <Udma_rmAllocBlkCopyUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyUhcCh + rmInitPrms->numBlkCopyUhcCh)))
700a21fc: 9807         	ldr	r0, [sp, #0x1c]
700a21fe: 9a00         	ldr	r2, [sp]
700a2200: 6811         	ldr	r1, [r2]
700a2202: 6852         	ldr	r2, [r2, #0x4]
700a2204: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyUhcCh) &&
700a2206: 4288         	cmp	r0, r1
700a2208: d22a         	bhs	0x700a2260 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #0x54
700a220a: e7ff         	b	0x700a220c <Udma_rmAllocBlkCopyUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyUhcCh;
700a220c: 9807         	ldr	r0, [sp, #0x1c]
700a220e: 9900         	ldr	r1, [sp]
700a2210: 6809         	ldr	r1, [r1]
700a2212: 1a40         	subs	r0, r0, r1
700a2214: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a2216: 9805         	ldr	r0, [sp, #0x14]
700a2218: 0940         	lsrs	r0, r0, #0x5
700a221a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a221c: 9805         	ldr	r0, [sp, #0x14]
700a221e: 9904         	ldr	r1, [sp, #0x10]
700a2220: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2224: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2226: 9903         	ldr	r1, [sp, #0xc]
700a2228: 2001         	movs	r0, #0x1
700a222a: 4088         	lsls	r0, r1
700a222c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyUhcChFlag[offset] & bitMask) == bitMask)
700a222e: 9806         	ldr	r0, [sp, #0x18]
700a2230: 9904         	ldr	r1, [sp, #0x10]
700a2232: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2236: f8d0 02d0    	ldr.w	r0, [r0, #0x2d0]
700a223a: 9902         	ldr	r1, [sp, #0x8]
700a223c: 4008         	ands	r0, r1
700a223e: 4288         	cmp	r0, r1
700a2240: d10d         	bne	0x700a225e <Udma_rmAllocBlkCopyUhcCh+0x10e> @ imm = #0x1a
700a2242: e7ff         	b	0x700a2244 <Udma_rmAllocBlkCopyUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyUhcChFlag[offset] &= ~bitMask;
700a2244: 9a02         	ldr	r2, [sp, #0x8]
700a2246: 9806         	ldr	r0, [sp, #0x18]
700a2248: 9904         	ldr	r1, [sp, #0x10]
700a224a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a224e: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a2252: 4390         	bics	r0, r2
700a2254: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;                 chNum = preferredChNum;
700a2258: 9807         	ldr	r0, [sp, #0x1c]
700a225a: 9001         	str	r0, [sp, #0x4]
;             }
700a225c: e7ff         	b	0x700a225e <Udma_rmAllocBlkCopyUhcCh+0x10e> @ imm = #-0x2
;         }
700a225e: e7ff         	b	0x700a2260 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #-0x2
700a2260: e7ff         	b	0x700a2262 <Udma_rmAllocBlkCopyUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2262: 9806         	ldr	r0, [sp, #0x18]
700a2264: f500 609f    	add.w	r0, r0, #0x4f8
700a2268: f008 f852    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x80a4
;     return (chNum);
700a226c: 9801         	ldr	r0, [sp, #0x4]
700a226e: b008         	add	sp, #0x20
700a2270: bd80         	pop	{r7, pc}
		...
700a227e: 0000         	movs	r0, r0

700a2280 <Udma_rmAllocRxCh>:
; {
700a2280: b580         	push	{r7, lr}
700a2282: b088         	sub	sp, #0x20
700a2284: 9007         	str	r0, [sp, #0x1c]
700a2286: 9106         	str	r1, [sp, #0x18]
700a2288: 2000         	movs	r0, #0x0
700a228a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a228e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a2290: 9806         	ldr	r0, [sp, #0x18]
700a2292: f500 70ea    	add.w	r0, r0, #0x1d4
700a2296: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2298: 9806         	ldr	r0, [sp, #0x18]
700a229a: f500 609f    	add.w	r0, r0, #0x4f8
700a229e: f04f 31ff    	mov.w	r1, #0xffffffff
700a22a2: f006 fce5    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x69ca
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a22a6: 9807         	ldr	r0, [sp, #0x1c]
700a22a8: 2101         	movs	r1, #0x1
700a22aa: f6cf 71ff    	movt	r1, #0xffff
700a22ae: 4288         	cmp	r0, r1
700a22b0: d136         	bne	0x700a2320 <Udma_rmAllocRxCh+0xa0> @ imm = #0x6c
700a22b2: e7ff         	b	0x700a22b4 <Udma_rmAllocRxCh+0x34> @ imm = #-0x2
700a22b4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxCh; i++)
700a22b6: 9005         	str	r0, [sp, #0x14]
700a22b8: e7ff         	b	0x700a22ba <Udma_rmAllocRxCh+0x3a> @ imm = #-0x2
700a22ba: 9805         	ldr	r0, [sp, #0x14]
700a22bc: 9900         	ldr	r1, [sp]
700a22be: 6c49         	ldr	r1, [r1, #0x44]
700a22c0: 4288         	cmp	r0, r1
700a22c2: d22c         	bhs	0x700a231e <Udma_rmAllocRxCh+0x9e> @ imm = #0x58
700a22c4: e7ff         	b	0x700a22c6 <Udma_rmAllocRxCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a22c6: 9805         	ldr	r0, [sp, #0x14]
700a22c8: 0940         	lsrs	r0, r0, #0x5
700a22ca: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a22cc: 9805         	ldr	r0, [sp, #0x14]
700a22ce: 9904         	ldr	r1, [sp, #0x10]
700a22d0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a22d4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a22d6: 9903         	ldr	r1, [sp, #0xc]
700a22d8: 2001         	movs	r0, #0x1
700a22da: 4088         	lsls	r0, r1
700a22dc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxChFlag[offset] & bitMask) == bitMask)
700a22de: 9806         	ldr	r0, [sp, #0x18]
700a22e0: 9904         	ldr	r1, [sp, #0x10]
700a22e2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a22e6: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
700a22ea: 9902         	ldr	r1, [sp, #0x8]
700a22ec: 4008         	ands	r0, r1
700a22ee: 4288         	cmp	r0, r1
700a22f0: d110         	bne	0x700a2314 <Udma_rmAllocRxCh+0x94> @ imm = #0x20
700a22f2: e7ff         	b	0x700a22f4 <Udma_rmAllocRxCh+0x74> @ imm = #-0x2
;                 drvHandle->rxChFlag[offset] &= ~bitMask;
700a22f4: 9a02         	ldr	r2, [sp, #0x8]
700a22f6: 9806         	ldr	r0, [sp, #0x18]
700a22f8: 9904         	ldr	r1, [sp, #0x10]
700a22fa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a22fe: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700a2302: 4390         	bics	r0, r2
700a2304: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;                 chNum = i + rmInitPrms->startRxCh;  /* Add start offset */
700a2308: 9805         	ldr	r0, [sp, #0x14]
700a230a: 9900         	ldr	r1, [sp]
700a230c: 6c09         	ldr	r1, [r1, #0x40]
700a230e: 4408         	add	r0, r1
700a2310: 9001         	str	r0, [sp, #0x4]
;                 break;
700a2312: e004         	b	0x700a231e <Udma_rmAllocRxCh+0x9e> @ imm = #0x8
;         }
700a2314: e7ff         	b	0x700a2316 <Udma_rmAllocRxCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxCh; i++)
700a2316: 9805         	ldr	r0, [sp, #0x14]
700a2318: 3001         	adds	r0, #0x1
700a231a: 9005         	str	r0, [sp, #0x14]
700a231c: e7cd         	b	0x700a22ba <Udma_rmAllocRxCh+0x3a> @ imm = #-0x66
;     }
700a231e: e038         	b	0x700a2392 <Udma_rmAllocRxCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxCh) &&
700a2320: 9807         	ldr	r0, [sp, #0x1c]
700a2322: 9900         	ldr	r1, [sp]
700a2324: 6c09         	ldr	r1, [r1, #0x40]
700a2326: 4288         	cmp	r0, r1
700a2328: d332         	blo	0x700a2390 <Udma_rmAllocRxCh+0x110> @ imm = #0x64
700a232a: e7ff         	b	0x700a232c <Udma_rmAllocRxCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxCh + rmInitPrms->numRxCh)))
700a232c: 9807         	ldr	r0, [sp, #0x1c]
700a232e: 9a00         	ldr	r2, [sp]
700a2330: 6c11         	ldr	r1, [r2, #0x40]
700a2332: 6c52         	ldr	r2, [r2, #0x44]
700a2334: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxCh) &&
700a2336: 4288         	cmp	r0, r1
700a2338: d22a         	bhs	0x700a2390 <Udma_rmAllocRxCh+0x110> @ imm = #0x54
700a233a: e7ff         	b	0x700a233c <Udma_rmAllocRxCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxCh;
700a233c: 9807         	ldr	r0, [sp, #0x1c]
700a233e: 9900         	ldr	r1, [sp]
700a2340: 6c09         	ldr	r1, [r1, #0x40]
700a2342: 1a40         	subs	r0, r0, r1
700a2344: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a2346: 9805         	ldr	r0, [sp, #0x14]
700a2348: 0940         	lsrs	r0, r0, #0x5
700a234a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a234c: 9805         	ldr	r0, [sp, #0x14]
700a234e: 9904         	ldr	r1, [sp, #0x10]
700a2350: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2354: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2356: 9903         	ldr	r1, [sp, #0xc]
700a2358: 2001         	movs	r0, #0x1
700a235a: 4088         	lsls	r0, r1
700a235c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxChFlag[offset] & bitMask) == bitMask)
700a235e: 9806         	ldr	r0, [sp, #0x18]
700a2360: 9904         	ldr	r1, [sp, #0x10]
700a2362: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2366: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
700a236a: 9902         	ldr	r1, [sp, #0x8]
700a236c: 4008         	ands	r0, r1
700a236e: 4288         	cmp	r0, r1
700a2370: d10d         	bne	0x700a238e <Udma_rmAllocRxCh+0x10e> @ imm = #0x1a
700a2372: e7ff         	b	0x700a2374 <Udma_rmAllocRxCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxChFlag[offset] &= ~bitMask;
700a2374: 9a02         	ldr	r2, [sp, #0x8]
700a2376: 9806         	ldr	r0, [sp, #0x18]
700a2378: 9904         	ldr	r1, [sp, #0x10]
700a237a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a237e: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700a2382: 4390         	bics	r0, r2
700a2384: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;                 chNum = preferredChNum;
700a2388: 9807         	ldr	r0, [sp, #0x1c]
700a238a: 9001         	str	r0, [sp, #0x4]
;             }
700a238c: e7ff         	b	0x700a238e <Udma_rmAllocRxCh+0x10e> @ imm = #-0x2
;         }
700a238e: e7ff         	b	0x700a2390 <Udma_rmAllocRxCh+0x110> @ imm = #-0x2
700a2390: e7ff         	b	0x700a2392 <Udma_rmAllocRxCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2392: 9806         	ldr	r0, [sp, #0x18]
700a2394: f500 609f    	add.w	r0, r0, #0x4f8
700a2398: f007 ffba    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x7f74
;     return (chNum);
700a239c: 9801         	ldr	r0, [sp, #0x4]
700a239e: b008         	add	sp, #0x20
700a23a0: bd80         	pop	{r7, pc}
		...
700a23ae: 0000         	movs	r0, r0

700a23b0 <Udma_rmAllocRxHcCh>:
; {
700a23b0: b580         	push	{r7, lr}
700a23b2: b088         	sub	sp, #0x20
700a23b4: 9007         	str	r0, [sp, #0x1c]
700a23b6: 9106         	str	r1, [sp, #0x18]
700a23b8: 2000         	movs	r0, #0x0
700a23ba: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a23be: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a23c0: 9806         	ldr	r0, [sp, #0x18]
700a23c2: f500 70ea    	add.w	r0, r0, #0x1d4
700a23c6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a23c8: 9806         	ldr	r0, [sp, #0x18]
700a23ca: f500 609f    	add.w	r0, r0, #0x4f8
700a23ce: f04f 31ff    	mov.w	r1, #0xffffffff
700a23d2: f006 fc4d    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x689a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a23d6: 9807         	ldr	r0, [sp, #0x1c]
700a23d8: 2101         	movs	r1, #0x1
700a23da: f6cf 71ff    	movt	r1, #0xffff
700a23de: 4288         	cmp	r0, r1
700a23e0: d136         	bne	0x700a2450 <Udma_rmAllocRxHcCh+0xa0> @ imm = #0x6c
700a23e2: e7ff         	b	0x700a23e4 <Udma_rmAllocRxHcCh+0x34> @ imm = #-0x2
700a23e4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxHcCh; i++)
700a23e6: 9005         	str	r0, [sp, #0x14]
700a23e8: e7ff         	b	0x700a23ea <Udma_rmAllocRxHcCh+0x3a> @ imm = #-0x2
700a23ea: 9805         	ldr	r0, [sp, #0x14]
700a23ec: 9900         	ldr	r1, [sp]
700a23ee: 6bc9         	ldr	r1, [r1, #0x3c]
700a23f0: 4288         	cmp	r0, r1
700a23f2: d22c         	bhs	0x700a244e <Udma_rmAllocRxHcCh+0x9e> @ imm = #0x58
700a23f4: e7ff         	b	0x700a23f6 <Udma_rmAllocRxHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a23f6: 9805         	ldr	r0, [sp, #0x14]
700a23f8: 0940         	lsrs	r0, r0, #0x5
700a23fa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a23fc: 9805         	ldr	r0, [sp, #0x14]
700a23fe: 9904         	ldr	r1, [sp, #0x10]
700a2400: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2404: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2406: 9903         	ldr	r1, [sp, #0xc]
700a2408: 2001         	movs	r0, #0x1
700a240a: 4088         	lsls	r0, r1
700a240c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxHcChFlag[offset] & bitMask) == bitMask)
700a240e: 9806         	ldr	r0, [sp, #0x18]
700a2410: 9904         	ldr	r1, [sp, #0x10]
700a2412: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2416: f8d0 031c    	ldr.w	r0, [r0, #0x31c]
700a241a: 9902         	ldr	r1, [sp, #0x8]
700a241c: 4008         	ands	r0, r1
700a241e: 4288         	cmp	r0, r1
700a2420: d110         	bne	0x700a2444 <Udma_rmAllocRxHcCh+0x94> @ imm = #0x20
700a2422: e7ff         	b	0x700a2424 <Udma_rmAllocRxHcCh+0x74> @ imm = #-0x2
;                 drvHandle->rxHcChFlag[offset] &= ~bitMask;
700a2424: 9a02         	ldr	r2, [sp, #0x8]
700a2426: 9806         	ldr	r0, [sp, #0x18]
700a2428: 9904         	ldr	r1, [sp, #0x10]
700a242a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a242e: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700a2432: 4390         	bics	r0, r2
700a2434: f8c1 031c    	str.w	r0, [r1, #0x31c]
;                 chNum = i + rmInitPrms->startRxHcCh;  /* Add start offset */
700a2438: 9805         	ldr	r0, [sp, #0x14]
700a243a: 9900         	ldr	r1, [sp]
700a243c: 6b89         	ldr	r1, [r1, #0x38]
700a243e: 4408         	add	r0, r1
700a2440: 9001         	str	r0, [sp, #0x4]
;                 break;
700a2442: e004         	b	0x700a244e <Udma_rmAllocRxHcCh+0x9e> @ imm = #0x8
;         }
700a2444: e7ff         	b	0x700a2446 <Udma_rmAllocRxHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxHcCh; i++)
700a2446: 9805         	ldr	r0, [sp, #0x14]
700a2448: 3001         	adds	r0, #0x1
700a244a: 9005         	str	r0, [sp, #0x14]
700a244c: e7cd         	b	0x700a23ea <Udma_rmAllocRxHcCh+0x3a> @ imm = #-0x66
;     }
700a244e: e038         	b	0x700a24c2 <Udma_rmAllocRxHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxHcCh) &&
700a2450: 9807         	ldr	r0, [sp, #0x1c]
700a2452: 9900         	ldr	r1, [sp]
700a2454: 6b89         	ldr	r1, [r1, #0x38]
700a2456: 4288         	cmp	r0, r1
700a2458: d332         	blo	0x700a24c0 <Udma_rmAllocRxHcCh+0x110> @ imm = #0x64
700a245a: e7ff         	b	0x700a245c <Udma_rmAllocRxHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxHcCh + rmInitPrms->numRxHcCh)))
700a245c: 9807         	ldr	r0, [sp, #0x1c]
700a245e: 9a00         	ldr	r2, [sp]
700a2460: 6b91         	ldr	r1, [r2, #0x38]
700a2462: 6bd2         	ldr	r2, [r2, #0x3c]
700a2464: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxHcCh) &&
700a2466: 4288         	cmp	r0, r1
700a2468: d22a         	bhs	0x700a24c0 <Udma_rmAllocRxHcCh+0x110> @ imm = #0x54
700a246a: e7ff         	b	0x700a246c <Udma_rmAllocRxHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxHcCh;
700a246c: 9807         	ldr	r0, [sp, #0x1c]
700a246e: 9900         	ldr	r1, [sp]
700a2470: 6b89         	ldr	r1, [r1, #0x38]
700a2472: 1a40         	subs	r0, r0, r1
700a2474: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a2476: 9805         	ldr	r0, [sp, #0x14]
700a2478: 0940         	lsrs	r0, r0, #0x5
700a247a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a247c: 9805         	ldr	r0, [sp, #0x14]
700a247e: 9904         	ldr	r1, [sp, #0x10]
700a2480: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2484: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2486: 9903         	ldr	r1, [sp, #0xc]
700a2488: 2001         	movs	r0, #0x1
700a248a: 4088         	lsls	r0, r1
700a248c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxHcChFlag[offset] & bitMask) == bitMask)
700a248e: 9806         	ldr	r0, [sp, #0x18]
700a2490: 9904         	ldr	r1, [sp, #0x10]
700a2492: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2496: f8d0 031c    	ldr.w	r0, [r0, #0x31c]
700a249a: 9902         	ldr	r1, [sp, #0x8]
700a249c: 4008         	ands	r0, r1
700a249e: 4288         	cmp	r0, r1
700a24a0: d10d         	bne	0x700a24be <Udma_rmAllocRxHcCh+0x10e> @ imm = #0x1a
700a24a2: e7ff         	b	0x700a24a4 <Udma_rmAllocRxHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxHcChFlag[offset] &= ~bitMask;
700a24a4: 9a02         	ldr	r2, [sp, #0x8]
700a24a6: 9806         	ldr	r0, [sp, #0x18]
700a24a8: 9904         	ldr	r1, [sp, #0x10]
700a24aa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a24ae: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700a24b2: 4390         	bics	r0, r2
700a24b4: f8c1 031c    	str.w	r0, [r1, #0x31c]
;                 chNum = preferredChNum;
700a24b8: 9807         	ldr	r0, [sp, #0x1c]
700a24ba: 9001         	str	r0, [sp, #0x4]
;             }
700a24bc: e7ff         	b	0x700a24be <Udma_rmAllocRxHcCh+0x10e> @ imm = #-0x2
;         }
700a24be: e7ff         	b	0x700a24c0 <Udma_rmAllocRxHcCh+0x110> @ imm = #-0x2
700a24c0: e7ff         	b	0x700a24c2 <Udma_rmAllocRxHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a24c2: 9806         	ldr	r0, [sp, #0x18]
700a24c4: f500 609f    	add.w	r0, r0, #0x4f8
700a24c8: f007 ff22    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x7e44
;     return (chNum);
700a24cc: 9801         	ldr	r0, [sp, #0x4]
700a24ce: b008         	add	sp, #0x20
700a24d0: bd80         	pop	{r7, pc}
		...
700a24de: 0000         	movs	r0, r0

700a24e0 <Udma_rmAllocRxUhcCh>:
; {
700a24e0: b580         	push	{r7, lr}
700a24e2: b088         	sub	sp, #0x20
700a24e4: 9007         	str	r0, [sp, #0x1c]
700a24e6: 9106         	str	r1, [sp, #0x18]
700a24e8: 2000         	movs	r0, #0x0
700a24ea: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a24ee: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a24f0: 9806         	ldr	r0, [sp, #0x18]
700a24f2: f500 70ea    	add.w	r0, r0, #0x1d4
700a24f6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a24f8: 9806         	ldr	r0, [sp, #0x18]
700a24fa: f500 609f    	add.w	r0, r0, #0x4f8
700a24fe: f04f 31ff    	mov.w	r1, #0xffffffff
700a2502: f006 fbb5    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x676a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a2506: 9807         	ldr	r0, [sp, #0x1c]
700a2508: 2101         	movs	r1, #0x1
700a250a: f6cf 71ff    	movt	r1, #0xffff
700a250e: 4288         	cmp	r0, r1
700a2510: d136         	bne	0x700a2580 <Udma_rmAllocRxUhcCh+0xa0> @ imm = #0x6c
700a2512: e7ff         	b	0x700a2514 <Udma_rmAllocRxUhcCh+0x34> @ imm = #-0x2
700a2514: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxUhcCh; i++)
700a2516: 9005         	str	r0, [sp, #0x14]
700a2518: e7ff         	b	0x700a251a <Udma_rmAllocRxUhcCh+0x3a> @ imm = #-0x2
700a251a: 9805         	ldr	r0, [sp, #0x14]
700a251c: 9900         	ldr	r1, [sp]
700a251e: 6b49         	ldr	r1, [r1, #0x34]
700a2520: 4288         	cmp	r0, r1
700a2522: d22c         	bhs	0x700a257e <Udma_rmAllocRxUhcCh+0x9e> @ imm = #0x58
700a2524: e7ff         	b	0x700a2526 <Udma_rmAllocRxUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a2526: 9805         	ldr	r0, [sp, #0x14]
700a2528: 0940         	lsrs	r0, r0, #0x5
700a252a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a252c: 9805         	ldr	r0, [sp, #0x14]
700a252e: 9904         	ldr	r1, [sp, #0x10]
700a2530: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2534: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2536: 9903         	ldr	r1, [sp, #0xc]
700a2538: 2001         	movs	r0, #0x1
700a253a: 4088         	lsls	r0, r1
700a253c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxUhcChFlag[offset] & bitMask) == bitMask)
700a253e: 9806         	ldr	r0, [sp, #0x18]
700a2540: 9904         	ldr	r1, [sp, #0x10]
700a2542: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2546: f8d0 0320    	ldr.w	r0, [r0, #0x320]
700a254a: 9902         	ldr	r1, [sp, #0x8]
700a254c: 4008         	ands	r0, r1
700a254e: 4288         	cmp	r0, r1
700a2550: d110         	bne	0x700a2574 <Udma_rmAllocRxUhcCh+0x94> @ imm = #0x20
700a2552: e7ff         	b	0x700a2554 <Udma_rmAllocRxUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->rxUhcChFlag[offset] &= ~bitMask;
700a2554: 9a02         	ldr	r2, [sp, #0x8]
700a2556: 9806         	ldr	r0, [sp, #0x18]
700a2558: 9904         	ldr	r1, [sp, #0x10]
700a255a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a255e: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700a2562: 4390         	bics	r0, r2
700a2564: f8c1 0320    	str.w	r0, [r1, #0x320]
;                 chNum = i + rmInitPrms->startRxUhcCh;  /* Add start offset */
700a2568: 9805         	ldr	r0, [sp, #0x14]
700a256a: 9900         	ldr	r1, [sp]
700a256c: 6b09         	ldr	r1, [r1, #0x30]
700a256e: 4408         	add	r0, r1
700a2570: 9001         	str	r0, [sp, #0x4]
;                 break;
700a2572: e004         	b	0x700a257e <Udma_rmAllocRxUhcCh+0x9e> @ imm = #0x8
;         }
700a2574: e7ff         	b	0x700a2576 <Udma_rmAllocRxUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxUhcCh; i++)
700a2576: 9805         	ldr	r0, [sp, #0x14]
700a2578: 3001         	adds	r0, #0x1
700a257a: 9005         	str	r0, [sp, #0x14]
700a257c: e7cd         	b	0x700a251a <Udma_rmAllocRxUhcCh+0x3a> @ imm = #-0x66
;     }
700a257e: e038         	b	0x700a25f2 <Udma_rmAllocRxUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxUhcCh) &&
700a2580: 9807         	ldr	r0, [sp, #0x1c]
700a2582: 9900         	ldr	r1, [sp]
700a2584: 6b09         	ldr	r1, [r1, #0x30]
700a2586: 4288         	cmp	r0, r1
700a2588: d332         	blo	0x700a25f0 <Udma_rmAllocRxUhcCh+0x110> @ imm = #0x64
700a258a: e7ff         	b	0x700a258c <Udma_rmAllocRxUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxUhcCh + rmInitPrms->numRxUhcCh)))
700a258c: 9807         	ldr	r0, [sp, #0x1c]
700a258e: 9a00         	ldr	r2, [sp]
700a2590: 6b11         	ldr	r1, [r2, #0x30]
700a2592: 6b52         	ldr	r2, [r2, #0x34]
700a2594: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxUhcCh) &&
700a2596: 4288         	cmp	r0, r1
700a2598: d22a         	bhs	0x700a25f0 <Udma_rmAllocRxUhcCh+0x110> @ imm = #0x54
700a259a: e7ff         	b	0x700a259c <Udma_rmAllocRxUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxUhcCh;
700a259c: 9807         	ldr	r0, [sp, #0x1c]
700a259e: 9900         	ldr	r1, [sp]
700a25a0: 6b09         	ldr	r1, [r1, #0x30]
700a25a2: 1a40         	subs	r0, r0, r1
700a25a4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a25a6: 9805         	ldr	r0, [sp, #0x14]
700a25a8: 0940         	lsrs	r0, r0, #0x5
700a25aa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a25ac: 9805         	ldr	r0, [sp, #0x14]
700a25ae: 9904         	ldr	r1, [sp, #0x10]
700a25b0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a25b4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a25b6: 9903         	ldr	r1, [sp, #0xc]
700a25b8: 2001         	movs	r0, #0x1
700a25ba: 4088         	lsls	r0, r1
700a25bc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxUhcChFlag[offset] & bitMask) == bitMask)
700a25be: 9806         	ldr	r0, [sp, #0x18]
700a25c0: 9904         	ldr	r1, [sp, #0x10]
700a25c2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a25c6: f8d0 0320    	ldr.w	r0, [r0, #0x320]
700a25ca: 9902         	ldr	r1, [sp, #0x8]
700a25cc: 4008         	ands	r0, r1
700a25ce: 4288         	cmp	r0, r1
700a25d0: d10d         	bne	0x700a25ee <Udma_rmAllocRxUhcCh+0x10e> @ imm = #0x1a
700a25d2: e7ff         	b	0x700a25d4 <Udma_rmAllocRxUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxUhcChFlag[offset] &= ~bitMask;
700a25d4: 9a02         	ldr	r2, [sp, #0x8]
700a25d6: 9806         	ldr	r0, [sp, #0x18]
700a25d8: 9904         	ldr	r1, [sp, #0x10]
700a25da: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a25de: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700a25e2: 4390         	bics	r0, r2
700a25e4: f8c1 0320    	str.w	r0, [r1, #0x320]
;                 chNum = preferredChNum;
700a25e8: 9807         	ldr	r0, [sp, #0x1c]
700a25ea: 9001         	str	r0, [sp, #0x4]
;             }
700a25ec: e7ff         	b	0x700a25ee <Udma_rmAllocRxUhcCh+0x10e> @ imm = #-0x2
;         }
700a25ee: e7ff         	b	0x700a25f0 <Udma_rmAllocRxUhcCh+0x110> @ imm = #-0x2
700a25f0: e7ff         	b	0x700a25f2 <Udma_rmAllocRxUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a25f2: 9806         	ldr	r0, [sp, #0x18]
700a25f4: f500 609f    	add.w	r0, r0, #0x4f8
700a25f8: f007 fe8a    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x7d14
;     return (chNum);
700a25fc: 9801         	ldr	r0, [sp, #0x4]
700a25fe: b008         	add	sp, #0x20
700a2600: bd80         	pop	{r7, pc}
		...
700a260e: 0000         	movs	r0, r0

700a2610 <Udma_rmAllocTxCh>:
; {
700a2610: b580         	push	{r7, lr}
700a2612: b088         	sub	sp, #0x20
700a2614: 9007         	str	r0, [sp, #0x1c]
700a2616: 9106         	str	r1, [sp, #0x18]
700a2618: 2000         	movs	r0, #0x0
700a261a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a261e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a2620: 9806         	ldr	r0, [sp, #0x18]
700a2622: f500 70ea    	add.w	r0, r0, #0x1d4
700a2626: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2628: 9806         	ldr	r0, [sp, #0x18]
700a262a: f500 609f    	add.w	r0, r0, #0x4f8
700a262e: f04f 31ff    	mov.w	r1, #0xffffffff
700a2632: f006 fb1d    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x663a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a2636: 9807         	ldr	r0, [sp, #0x1c]
700a2638: 2101         	movs	r1, #0x1
700a263a: f6cf 71ff    	movt	r1, #0xffff
700a263e: 4288         	cmp	r0, r1
700a2640: d136         	bne	0x700a26b0 <Udma_rmAllocTxCh+0xa0> @ imm = #0x6c
700a2642: e7ff         	b	0x700a2644 <Udma_rmAllocTxCh+0x34> @ imm = #-0x2
700a2644: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxCh; i++)
700a2646: 9005         	str	r0, [sp, #0x14]
700a2648: e7ff         	b	0x700a264a <Udma_rmAllocTxCh+0x3a> @ imm = #-0x2
700a264a: 9805         	ldr	r0, [sp, #0x14]
700a264c: 9900         	ldr	r1, [sp]
700a264e: 6ac9         	ldr	r1, [r1, #0x2c]
700a2650: 4288         	cmp	r0, r1
700a2652: d22c         	bhs	0x700a26ae <Udma_rmAllocTxCh+0x9e> @ imm = #0x58
700a2654: e7ff         	b	0x700a2656 <Udma_rmAllocTxCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a2656: 9805         	ldr	r0, [sp, #0x14]
700a2658: 0940         	lsrs	r0, r0, #0x5
700a265a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a265c: 9805         	ldr	r0, [sp, #0x14]
700a265e: 9904         	ldr	r1, [sp, #0x10]
700a2660: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2664: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2666: 9903         	ldr	r1, [sp, #0xc]
700a2668: 2001         	movs	r0, #0x1
700a266a: 4088         	lsls	r0, r1
700a266c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txChFlag[offset] & bitMask) == bitMask)
700a266e: 9806         	ldr	r0, [sp, #0x18]
700a2670: 9904         	ldr	r1, [sp, #0x10]
700a2672: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2676: f8d0 02d4    	ldr.w	r0, [r0, #0x2d4]
700a267a: 9902         	ldr	r1, [sp, #0x8]
700a267c: 4008         	ands	r0, r1
700a267e: 4288         	cmp	r0, r1
700a2680: d110         	bne	0x700a26a4 <Udma_rmAllocTxCh+0x94> @ imm = #0x20
700a2682: e7ff         	b	0x700a2684 <Udma_rmAllocTxCh+0x74> @ imm = #-0x2
;                 drvHandle->txChFlag[offset] &= ~bitMask;
700a2684: 9a02         	ldr	r2, [sp, #0x8]
700a2686: 9806         	ldr	r0, [sp, #0x18]
700a2688: 9904         	ldr	r1, [sp, #0x10]
700a268a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a268e: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700a2692: 4390         	bics	r0, r2
700a2694: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;                 chNum = i + rmInitPrms->startTxCh;  /* Add start offset */
700a2698: 9805         	ldr	r0, [sp, #0x14]
700a269a: 9900         	ldr	r1, [sp]
700a269c: 6a89         	ldr	r1, [r1, #0x28]
700a269e: 4408         	add	r0, r1
700a26a0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a26a2: e004         	b	0x700a26ae <Udma_rmAllocTxCh+0x9e> @ imm = #0x8
;         }
700a26a4: e7ff         	b	0x700a26a6 <Udma_rmAllocTxCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxCh; i++)
700a26a6: 9805         	ldr	r0, [sp, #0x14]
700a26a8: 3001         	adds	r0, #0x1
700a26aa: 9005         	str	r0, [sp, #0x14]
700a26ac: e7cd         	b	0x700a264a <Udma_rmAllocTxCh+0x3a> @ imm = #-0x66
;     }
700a26ae: e038         	b	0x700a2722 <Udma_rmAllocTxCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxCh) &&
700a26b0: 9807         	ldr	r0, [sp, #0x1c]
700a26b2: 9900         	ldr	r1, [sp]
700a26b4: 6a89         	ldr	r1, [r1, #0x28]
700a26b6: 4288         	cmp	r0, r1
700a26b8: d332         	blo	0x700a2720 <Udma_rmAllocTxCh+0x110> @ imm = #0x64
700a26ba: e7ff         	b	0x700a26bc <Udma_rmAllocTxCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxCh + rmInitPrms->numTxCh)))
700a26bc: 9807         	ldr	r0, [sp, #0x1c]
700a26be: 9a00         	ldr	r2, [sp]
700a26c0: 6a91         	ldr	r1, [r2, #0x28]
700a26c2: 6ad2         	ldr	r2, [r2, #0x2c]
700a26c4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxCh) &&
700a26c6: 4288         	cmp	r0, r1
700a26c8: d22a         	bhs	0x700a2720 <Udma_rmAllocTxCh+0x110> @ imm = #0x54
700a26ca: e7ff         	b	0x700a26cc <Udma_rmAllocTxCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxCh;
700a26cc: 9807         	ldr	r0, [sp, #0x1c]
700a26ce: 9900         	ldr	r1, [sp]
700a26d0: 6a89         	ldr	r1, [r1, #0x28]
700a26d2: 1a40         	subs	r0, r0, r1
700a26d4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a26d6: 9805         	ldr	r0, [sp, #0x14]
700a26d8: 0940         	lsrs	r0, r0, #0x5
700a26da: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a26dc: 9805         	ldr	r0, [sp, #0x14]
700a26de: 9904         	ldr	r1, [sp, #0x10]
700a26e0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a26e4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a26e6: 9903         	ldr	r1, [sp, #0xc]
700a26e8: 2001         	movs	r0, #0x1
700a26ea: 4088         	lsls	r0, r1
700a26ec: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txChFlag[offset] & bitMask) == bitMask)
700a26ee: 9806         	ldr	r0, [sp, #0x18]
700a26f0: 9904         	ldr	r1, [sp, #0x10]
700a26f2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a26f6: f8d0 02d4    	ldr.w	r0, [r0, #0x2d4]
700a26fa: 9902         	ldr	r1, [sp, #0x8]
700a26fc: 4008         	ands	r0, r1
700a26fe: 4288         	cmp	r0, r1
700a2700: d10d         	bne	0x700a271e <Udma_rmAllocTxCh+0x10e> @ imm = #0x1a
700a2702: e7ff         	b	0x700a2704 <Udma_rmAllocTxCh+0xf4> @ imm = #-0x2
;                 drvHandle->txChFlag[offset] &= ~bitMask;
700a2704: 9a02         	ldr	r2, [sp, #0x8]
700a2706: 9806         	ldr	r0, [sp, #0x18]
700a2708: 9904         	ldr	r1, [sp, #0x10]
700a270a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a270e: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700a2712: 4390         	bics	r0, r2
700a2714: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;                 chNum = preferredChNum;
700a2718: 9807         	ldr	r0, [sp, #0x1c]
700a271a: 9001         	str	r0, [sp, #0x4]
;             }
700a271c: e7ff         	b	0x700a271e <Udma_rmAllocTxCh+0x10e> @ imm = #-0x2
;         }
700a271e: e7ff         	b	0x700a2720 <Udma_rmAllocTxCh+0x110> @ imm = #-0x2
700a2720: e7ff         	b	0x700a2722 <Udma_rmAllocTxCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2722: 9806         	ldr	r0, [sp, #0x18]
700a2724: f500 609f    	add.w	r0, r0, #0x4f8
700a2728: f007 fdf2    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x7be4
;     return (chNum);
700a272c: 9801         	ldr	r0, [sp, #0x4]
700a272e: b008         	add	sp, #0x20
700a2730: bd80         	pop	{r7, pc}
		...
700a273e: 0000         	movs	r0, r0

700a2740 <Udma_rmAllocTxHcCh>:
; {
700a2740: b580         	push	{r7, lr}
700a2742: b088         	sub	sp, #0x20
700a2744: 9007         	str	r0, [sp, #0x1c]
700a2746: 9106         	str	r1, [sp, #0x18]
700a2748: 2000         	movs	r0, #0x0
700a274a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a274e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a2750: 9806         	ldr	r0, [sp, #0x18]
700a2752: f500 70ea    	add.w	r0, r0, #0x1d4
700a2756: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2758: 9806         	ldr	r0, [sp, #0x18]
700a275a: f500 609f    	add.w	r0, r0, #0x4f8
700a275e: f04f 31ff    	mov.w	r1, #0xffffffff
700a2762: f006 fa85    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x650a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a2766: 9807         	ldr	r0, [sp, #0x1c]
700a2768: 2101         	movs	r1, #0x1
700a276a: f6cf 71ff    	movt	r1, #0xffff
700a276e: 4288         	cmp	r0, r1
700a2770: d136         	bne	0x700a27e0 <Udma_rmAllocTxHcCh+0xa0> @ imm = #0x6c
700a2772: e7ff         	b	0x700a2774 <Udma_rmAllocTxHcCh+0x34> @ imm = #-0x2
700a2774: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxHcCh; i++)
700a2776: 9005         	str	r0, [sp, #0x14]
700a2778: e7ff         	b	0x700a277a <Udma_rmAllocTxHcCh+0x3a> @ imm = #-0x2
700a277a: 9805         	ldr	r0, [sp, #0x14]
700a277c: 9900         	ldr	r1, [sp]
700a277e: 6a49         	ldr	r1, [r1, #0x24]
700a2780: 4288         	cmp	r0, r1
700a2782: d22c         	bhs	0x700a27de <Udma_rmAllocTxHcCh+0x9e> @ imm = #0x58
700a2784: e7ff         	b	0x700a2786 <Udma_rmAllocTxHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a2786: 9805         	ldr	r0, [sp, #0x14]
700a2788: 0940         	lsrs	r0, r0, #0x5
700a278a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a278c: 9805         	ldr	r0, [sp, #0x14]
700a278e: 9904         	ldr	r1, [sp, #0x10]
700a2790: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2794: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2796: 9903         	ldr	r1, [sp, #0xc]
700a2798: 2001         	movs	r0, #0x1
700a279a: 4088         	lsls	r0, r1
700a279c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txHcChFlag[offset] & bitMask) == bitMask)
700a279e: 9806         	ldr	r0, [sp, #0x18]
700a27a0: 9904         	ldr	r1, [sp, #0x10]
700a27a2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a27a6: f8d0 02f4    	ldr.w	r0, [r0, #0x2f4]
700a27aa: 9902         	ldr	r1, [sp, #0x8]
700a27ac: 4008         	ands	r0, r1
700a27ae: 4288         	cmp	r0, r1
700a27b0: d110         	bne	0x700a27d4 <Udma_rmAllocTxHcCh+0x94> @ imm = #0x20
700a27b2: e7ff         	b	0x700a27b4 <Udma_rmAllocTxHcCh+0x74> @ imm = #-0x2
;                 drvHandle->txHcChFlag[offset] &= ~bitMask;
700a27b4: 9a02         	ldr	r2, [sp, #0x8]
700a27b6: 9806         	ldr	r0, [sp, #0x18]
700a27b8: 9904         	ldr	r1, [sp, #0x10]
700a27ba: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a27be: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700a27c2: 4390         	bics	r0, r2
700a27c4: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;                 chNum = i + rmInitPrms->startTxHcCh;  /* Add start offset */
700a27c8: 9805         	ldr	r0, [sp, #0x14]
700a27ca: 9900         	ldr	r1, [sp]
700a27cc: 6a09         	ldr	r1, [r1, #0x20]
700a27ce: 4408         	add	r0, r1
700a27d0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a27d2: e004         	b	0x700a27de <Udma_rmAllocTxHcCh+0x9e> @ imm = #0x8
;         }
700a27d4: e7ff         	b	0x700a27d6 <Udma_rmAllocTxHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxHcCh; i++)
700a27d6: 9805         	ldr	r0, [sp, #0x14]
700a27d8: 3001         	adds	r0, #0x1
700a27da: 9005         	str	r0, [sp, #0x14]
700a27dc: e7cd         	b	0x700a277a <Udma_rmAllocTxHcCh+0x3a> @ imm = #-0x66
;     }
700a27de: e038         	b	0x700a2852 <Udma_rmAllocTxHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxHcCh) &&
700a27e0: 9807         	ldr	r0, [sp, #0x1c]
700a27e2: 9900         	ldr	r1, [sp]
700a27e4: 6a09         	ldr	r1, [r1, #0x20]
700a27e6: 4288         	cmp	r0, r1
700a27e8: d332         	blo	0x700a2850 <Udma_rmAllocTxHcCh+0x110> @ imm = #0x64
700a27ea: e7ff         	b	0x700a27ec <Udma_rmAllocTxHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxHcCh + rmInitPrms->numTxHcCh)))
700a27ec: 9807         	ldr	r0, [sp, #0x1c]
700a27ee: 9a00         	ldr	r2, [sp]
700a27f0: 6a11         	ldr	r1, [r2, #0x20]
700a27f2: 6a52         	ldr	r2, [r2, #0x24]
700a27f4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxHcCh) &&
700a27f6: 4288         	cmp	r0, r1
700a27f8: d22a         	bhs	0x700a2850 <Udma_rmAllocTxHcCh+0x110> @ imm = #0x54
700a27fa: e7ff         	b	0x700a27fc <Udma_rmAllocTxHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxHcCh;
700a27fc: 9807         	ldr	r0, [sp, #0x1c]
700a27fe: 9900         	ldr	r1, [sp]
700a2800: 6a09         	ldr	r1, [r1, #0x20]
700a2802: 1a40         	subs	r0, r0, r1
700a2804: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a2806: 9805         	ldr	r0, [sp, #0x14]
700a2808: 0940         	lsrs	r0, r0, #0x5
700a280a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a280c: 9805         	ldr	r0, [sp, #0x14]
700a280e: 9904         	ldr	r1, [sp, #0x10]
700a2810: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2814: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2816: 9903         	ldr	r1, [sp, #0xc]
700a2818: 2001         	movs	r0, #0x1
700a281a: 4088         	lsls	r0, r1
700a281c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txHcChFlag[offset] & bitMask) == bitMask)
700a281e: 9806         	ldr	r0, [sp, #0x18]
700a2820: 9904         	ldr	r1, [sp, #0x10]
700a2822: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2826: f8d0 02f4    	ldr.w	r0, [r0, #0x2f4]
700a282a: 9902         	ldr	r1, [sp, #0x8]
700a282c: 4008         	ands	r0, r1
700a282e: 4288         	cmp	r0, r1
700a2830: d10d         	bne	0x700a284e <Udma_rmAllocTxHcCh+0x10e> @ imm = #0x1a
700a2832: e7ff         	b	0x700a2834 <Udma_rmAllocTxHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->txHcChFlag[offset] &= ~bitMask;
700a2834: 9a02         	ldr	r2, [sp, #0x8]
700a2836: 9806         	ldr	r0, [sp, #0x18]
700a2838: 9904         	ldr	r1, [sp, #0x10]
700a283a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a283e: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700a2842: 4390         	bics	r0, r2
700a2844: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;                 chNum = preferredChNum;
700a2848: 9807         	ldr	r0, [sp, #0x1c]
700a284a: 9001         	str	r0, [sp, #0x4]
;             }
700a284c: e7ff         	b	0x700a284e <Udma_rmAllocTxHcCh+0x10e> @ imm = #-0x2
;         }
700a284e: e7ff         	b	0x700a2850 <Udma_rmAllocTxHcCh+0x110> @ imm = #-0x2
700a2850: e7ff         	b	0x700a2852 <Udma_rmAllocTxHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2852: 9806         	ldr	r0, [sp, #0x18]
700a2854: f500 609f    	add.w	r0, r0, #0x4f8
700a2858: f007 fd5a    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x7ab4
;     return (chNum);
700a285c: 9801         	ldr	r0, [sp, #0x4]
700a285e: b008         	add	sp, #0x20
700a2860: bd80         	pop	{r7, pc}
		...
700a286e: 0000         	movs	r0, r0

700a2870 <Udma_rmAllocTxUhcCh>:
; {
700a2870: b580         	push	{r7, lr}
700a2872: b088         	sub	sp, #0x20
700a2874: 9007         	str	r0, [sp, #0x1c]
700a2876: 9106         	str	r1, [sp, #0x18]
700a2878: 2000         	movs	r0, #0x0
700a287a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a287e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a2880: 9806         	ldr	r0, [sp, #0x18]
700a2882: f500 70ea    	add.w	r0, r0, #0x1d4
700a2886: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2888: 9806         	ldr	r0, [sp, #0x18]
700a288a: f500 609f    	add.w	r0, r0, #0x4f8
700a288e: f04f 31ff    	mov.w	r1, #0xffffffff
700a2892: f006 f9ed    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x63da
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a2896: 9807         	ldr	r0, [sp, #0x1c]
700a2898: 2101         	movs	r1, #0x1
700a289a: f6cf 71ff    	movt	r1, #0xffff
700a289e: 4288         	cmp	r0, r1
700a28a0: d136         	bne	0x700a2910 <Udma_rmAllocTxUhcCh+0xa0> @ imm = #0x6c
700a28a2: e7ff         	b	0x700a28a4 <Udma_rmAllocTxUhcCh+0x34> @ imm = #-0x2
700a28a4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxUhcCh; i++)
700a28a6: 9005         	str	r0, [sp, #0x14]
700a28a8: e7ff         	b	0x700a28aa <Udma_rmAllocTxUhcCh+0x3a> @ imm = #-0x2
700a28aa: 9805         	ldr	r0, [sp, #0x14]
700a28ac: 9900         	ldr	r1, [sp]
700a28ae: 69c9         	ldr	r1, [r1, #0x1c]
700a28b0: 4288         	cmp	r0, r1
700a28b2: d22c         	bhs	0x700a290e <Udma_rmAllocTxUhcCh+0x9e> @ imm = #0x58
700a28b4: e7ff         	b	0x700a28b6 <Udma_rmAllocTxUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a28b6: 9805         	ldr	r0, [sp, #0x14]
700a28b8: 0940         	lsrs	r0, r0, #0x5
700a28ba: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a28bc: 9805         	ldr	r0, [sp, #0x14]
700a28be: 9904         	ldr	r1, [sp, #0x10]
700a28c0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a28c4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a28c6: 9903         	ldr	r1, [sp, #0xc]
700a28c8: 2001         	movs	r0, #0x1
700a28ca: 4088         	lsls	r0, r1
700a28cc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txUhcChFlag[offset] & bitMask) == bitMask)
700a28ce: 9806         	ldr	r0, [sp, #0x18]
700a28d0: 9904         	ldr	r1, [sp, #0x10]
700a28d2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a28d6: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a28da: 9902         	ldr	r1, [sp, #0x8]
700a28dc: 4008         	ands	r0, r1
700a28de: 4288         	cmp	r0, r1
700a28e0: d110         	bne	0x700a2904 <Udma_rmAllocTxUhcCh+0x94> @ imm = #0x20
700a28e2: e7ff         	b	0x700a28e4 <Udma_rmAllocTxUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->txUhcChFlag[offset] &= ~bitMask;
700a28e4: 9a02         	ldr	r2, [sp, #0x8]
700a28e6: 9806         	ldr	r0, [sp, #0x18]
700a28e8: 9904         	ldr	r1, [sp, #0x10]
700a28ea: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a28ee: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700a28f2: 4390         	bics	r0, r2
700a28f4: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;                 chNum = i + rmInitPrms->startTxUhcCh;  /* Add start offset */
700a28f8: 9805         	ldr	r0, [sp, #0x14]
700a28fa: 9900         	ldr	r1, [sp]
700a28fc: 6989         	ldr	r1, [r1, #0x18]
700a28fe: 4408         	add	r0, r1
700a2900: 9001         	str	r0, [sp, #0x4]
;                 break;
700a2902: e004         	b	0x700a290e <Udma_rmAllocTxUhcCh+0x9e> @ imm = #0x8
;         }
700a2904: e7ff         	b	0x700a2906 <Udma_rmAllocTxUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxUhcCh; i++)
700a2906: 9805         	ldr	r0, [sp, #0x14]
700a2908: 3001         	adds	r0, #0x1
700a290a: 9005         	str	r0, [sp, #0x14]
700a290c: e7cd         	b	0x700a28aa <Udma_rmAllocTxUhcCh+0x3a> @ imm = #-0x66
;     }
700a290e: e038         	b	0x700a2982 <Udma_rmAllocTxUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxUhcCh) &&
700a2910: 9807         	ldr	r0, [sp, #0x1c]
700a2912: 9900         	ldr	r1, [sp]
700a2914: 6989         	ldr	r1, [r1, #0x18]
700a2916: 4288         	cmp	r0, r1
700a2918: d332         	blo	0x700a2980 <Udma_rmAllocTxUhcCh+0x110> @ imm = #0x64
700a291a: e7ff         	b	0x700a291c <Udma_rmAllocTxUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxUhcCh + rmInitPrms->numTxUhcCh)))
700a291c: 9807         	ldr	r0, [sp, #0x1c]
700a291e: 9a00         	ldr	r2, [sp]
700a2920: 6991         	ldr	r1, [r2, #0x18]
700a2922: 69d2         	ldr	r2, [r2, #0x1c]
700a2924: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxUhcCh) &&
700a2926: 4288         	cmp	r0, r1
700a2928: d22a         	bhs	0x700a2980 <Udma_rmAllocTxUhcCh+0x110> @ imm = #0x54
700a292a: e7ff         	b	0x700a292c <Udma_rmAllocTxUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxUhcCh;
700a292c: 9807         	ldr	r0, [sp, #0x1c]
700a292e: 9900         	ldr	r1, [sp]
700a2930: 6989         	ldr	r1, [r1, #0x18]
700a2932: 1a40         	subs	r0, r0, r1
700a2934: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a2936: 9805         	ldr	r0, [sp, #0x14]
700a2938: 0940         	lsrs	r0, r0, #0x5
700a293a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a293c: 9805         	ldr	r0, [sp, #0x14]
700a293e: 9904         	ldr	r1, [sp, #0x10]
700a2940: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2944: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2946: 9903         	ldr	r1, [sp, #0xc]
700a2948: 2001         	movs	r0, #0x1
700a294a: 4088         	lsls	r0, r1
700a294c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txUhcChFlag[offset] & bitMask) == bitMask)
700a294e: 9806         	ldr	r0, [sp, #0x18]
700a2950: 9904         	ldr	r1, [sp, #0x10]
700a2952: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2956: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a295a: 9902         	ldr	r1, [sp, #0x8]
700a295c: 4008         	ands	r0, r1
700a295e: 4288         	cmp	r0, r1
700a2960: d10d         	bne	0x700a297e <Udma_rmAllocTxUhcCh+0x10e> @ imm = #0x1a
700a2962: e7ff         	b	0x700a2964 <Udma_rmAllocTxUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->txUhcChFlag[offset] &= ~bitMask;
700a2964: 9a02         	ldr	r2, [sp, #0x8]
700a2966: 9806         	ldr	r0, [sp, #0x18]
700a2968: 9904         	ldr	r1, [sp, #0x10]
700a296a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a296e: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700a2972: 4390         	bics	r0, r2
700a2974: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;                 chNum = preferredChNum;
700a2978: 9807         	ldr	r0, [sp, #0x1c]
700a297a: 9001         	str	r0, [sp, #0x4]
;             }
700a297c: e7ff         	b	0x700a297e <Udma_rmAllocTxUhcCh+0x10e> @ imm = #-0x2
;         }
700a297e: e7ff         	b	0x700a2980 <Udma_rmAllocTxUhcCh+0x110> @ imm = #-0x2
700a2980: e7ff         	b	0x700a2982 <Udma_rmAllocTxUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2982: 9806         	ldr	r0, [sp, #0x18]
700a2984: f500 609f    	add.w	r0, r0, #0x4f8
700a2988: f007 fcc2    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x7984
;     return (chNum);
700a298c: 9801         	ldr	r0, [sp, #0x4]
700a298e: b008         	add	sp, #0x20
700a2990: bd80         	pop	{r7, pc}
		...
700a299e: 0000         	movs	r0, r0

700a29a0 <UART_udmaInitRxCh>:
; {
700a29a0: b580         	push	{r7, lr}
700a29a2: b0be         	sub	sp, #0xf8
700a29a4: 903d         	str	r0, [sp, #0xf4]
700a29a6: 913c         	str	r1, [sp, #0xf0]
700a29a8: 200a         	movs	r0, #0xa
;     chType = UDMA_CH_TYPE_PDMA_RX;
700a29aa: 903a         	str	r0, [sp, #0xe8]
;     UdmaChPrms_init(&chPrms, chType);
700a29ac: 993a         	ldr	r1, [sp, #0xe8]
700a29ae: a821         	add	r0, sp, #0x84
700a29b0: f007 f886    	bl	0x700a9ac0 <UdmaChPrms_init> @ imm = #0x710c
;     chPrms.peerChNum                = hUart->hUartInit->rxEvtNum;
700a29b4: 983d         	ldr	r0, [sp, #0xf4]
700a29b6: 6840         	ldr	r0, [r0, #0x4]
700a29b8: 6c00         	ldr	r0, [r0, #0x40]
700a29ba: 9022         	str	r0, [sp, #0x88]
;     chPrms.fqRingPrms.ringMem       = udmaChCfg->rxRingMem;
700a29bc: 983c         	ldr	r0, [sp, #0xf0]
700a29be: 6a80         	ldr	r0, [r0, #0x28]
700a29c0: 9025         	str	r0, [sp, #0x94]
;     chPrms.fqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a29c2: 983c         	ldr	r0, [sp, #0xf0]
700a29c4: 6b00         	ldr	r0, [r0, #0x30]
700a29c6: 9026         	str	r0, [sp, #0x98]
;     chPrms.fqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a29c8: 983c         	ldr	r0, [sp, #0xf0]
700a29ca: 6b40         	ldr	r0, [r0, #0x34]
700a29cc: 9028         	str	r0, [sp, #0xa0]
;     if(udmaChCfg->isCqRingMem == UDMA_COMP_QUEUE_RING_MEM_ENABLED){
700a29ce: 983c         	ldr	r0, [sp, #0xf0]
700a29d0: 6bc0         	ldr	r0, [r0, #0x3c]
700a29d2: 2801         	cmp	r0, #0x1
700a29d4: d10a         	bne	0x700a29ec <UART_udmaInitRxCh+0x4c> @ imm = #0x14
700a29d6: e7ff         	b	0x700a29d8 <UART_udmaInitRxCh+0x38> @ imm = #-0x2
;         chPrms.cqRingPrms.ringMem       = udmaChCfg->cqRxRingMem;
700a29d8: 983c         	ldr	r0, [sp, #0xf0]
700a29da: 6ac0         	ldr	r0, [r0, #0x2c]
700a29dc: 902c         	str	r0, [sp, #0xb0]
;         chPrms.cqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a29de: 983c         	ldr	r0, [sp, #0xf0]
700a29e0: 6b00         	ldr	r0, [r0, #0x30]
700a29e2: 902d         	str	r0, [sp, #0xb4]
;         chPrms.cqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a29e4: 983c         	ldr	r0, [sp, #0xf0]
700a29e6: 6b40         	ldr	r0, [r0, #0x34]
700a29e8: 902f         	str	r0, [sp, #0xbc]
;     }
700a29ea: e7ff         	b	0x700a29ec <UART_udmaInitRxCh+0x4c> @ imm = #-0x2
;     rxChHandle                      = udmaChCfg->rxChHandle;
700a29ec: 983c         	ldr	r0, [sp, #0xf0]
700a29ee: 6880         	ldr	r0, [r0, #0x8]
700a29f0: 9006         	str	r0, [sp, #0x18]
;     drvHandle                       = udmaChCfg->drvHandle;
700a29f2: 983c         	ldr	r0, [sp, #0xf0]
700a29f4: 6800         	ldr	r0, [r0]
700a29f6: 9007         	str	r0, [sp, #0x1c]
;     retVal = Udma_chOpen(drvHandle, rxChHandle, chType, &chPrms);
700a29f8: 9807         	ldr	r0, [sp, #0x1c]
700a29fa: 9906         	ldr	r1, [sp, #0x18]
700a29fc: 9a3a         	ldr	r2, [sp, #0xe8]
700a29fe: ab21         	add	r3, sp, #0x84
700a2a00: f7fd fb2e    	bl	0x700a0060 <Udma_chOpen> @ imm = #-0x29a4
700a2a04: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a2a06: 983b         	ldr	r0, [sp, #0xec]
700a2a08: fab0 f080    	clz	r0, r0
700a2a0c: 0940         	lsrs	r0, r0, #0x5
700a2a0e: f240 316b    	movw	r1, #0x36b
700a2a12: f2c7 010b    	movt	r1, #0x700b
700a2a16: 9103         	str	r1, [sp, #0xc]
700a2a18: 466a         	mov	r2, sp
700a2a1a: 6011         	str	r1, [r2]
700a2a1c: f64f 7142    	movw	r1, #0xff42
700a2a20: f2c7 010a    	movt	r1, #0x700a
700a2a24: 9104         	str	r1, [sp, #0x10]
700a2a26: f240 32ef    	movw	r2, #0x3ef
700a2a2a: f2c7 020b    	movt	r2, #0x700b
700a2a2e: 9205         	str	r2, [sp, #0x14]
700a2a30: 2366         	movs	r3, #0x66
700a2a32: f006 fb75    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x66ea
;     UdmaChRxPrms_init(&rxPrms, chType);
700a2a36: 993a         	ldr	r1, [sp, #0xe8]
700a2a38: a81a         	add	r0, sp, #0x68
700a2a3a: 9001         	str	r0, [sp, #0x4]
700a2a3c: f003 fcd0    	bl	0x700a63e0 <UdmaChRxPrms_init> @ imm = #0x39a0
700a2a40: 9901         	ldr	r1, [sp, #0x4]
;     retVal = Udma_chConfigRx(rxChHandle, &rxPrms);
700a2a42: 9806         	ldr	r0, [sp, #0x18]
700a2a44: f7fa f84c    	bl	0x7009cae0 <Udma_chConfigRx> @ imm = #-0x5f68
700a2a48: 9b03         	ldr	r3, [sp, #0xc]
700a2a4a: 9904         	ldr	r1, [sp, #0x10]
700a2a4c: 9a05         	ldr	r2, [sp, #0x14]
700a2a4e: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a2a50: 983b         	ldr	r0, [sp, #0xec]
700a2a52: fab0 f080    	clz	r0, r0
700a2a56: 0940         	lsrs	r0, r0, #0x5
700a2a58: 46ec         	mov	r12, sp
700a2a5a: f8cc 3000    	str.w	r3, [r12]
700a2a5e: 236b         	movs	r3, #0x6b
700a2a60: f006 fb5e    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x66bc
;     eventHandle = udmaChCfg->cqRxEvtHandle;
700a2a64: 983c         	ldr	r0, [sp, #0xf0]
700a2a66: 6900         	ldr	r0, [r0, #0x10]
700a2a68: 9019         	str	r0, [sp, #0x64]
700a2a6a: a808         	add	r0, sp, #0x20
;     UdmaEventPrms_init(&eventPrms);
700a2a6c: 9002         	str	r0, [sp, #0x8]
700a2a6e: f007 fc87    	bl	0x700aa380 <UdmaEventPrms_init> @ imm = #0x790e
700a2a72: 2001         	movs	r0, #0x1
;     eventPrms.eventType         = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a2a74: 9008         	str	r0, [sp, #0x20]
700a2a76: 2002         	movs	r0, #0x2
;     eventPrms.eventMode         = UDMA_EVENT_MODE_SHARED;
700a2a78: 9009         	str	r0, [sp, #0x24]
;     eventPrms.chHandle          = rxChHandle;
700a2a7a: 9806         	ldr	r0, [sp, #0x18]
700a2a7c: 900a         	str	r0, [sp, #0x28]
;     eventPrms.controllerEventHandle = Udma_eventGetGlobalHandle(drvHandle);
700a2a7e: 9807         	ldr	r0, [sp, #0x1c]
700a2a80: f008 fb56    	bl	0x700ab130 <Udma_eventGetGlobalHandle> @ imm = #0x86ac
700a2a84: 9a02         	ldr	r2, [sp, #0x8]
700a2a86: 900c         	str	r0, [sp, #0x30]
;     eventPrms.eventCb           = &UART_udmaIsrRx;
700a2a88: f647 4011    	movw	r0, #0x7c11
700a2a8c: f2c7 000a    	movt	r0, #0x700a
700a2a90: 900d         	str	r0, [sp, #0x34]
;     eventPrms.appData           = (void *) hUart;
700a2a92: 983d         	ldr	r0, [sp, #0xf4]
700a2a94: 900f         	str	r0, [sp, #0x3c]
;     retVal = Udma_eventRegister(drvHandle, eventHandle, &eventPrms);
700a2a96: 9807         	ldr	r0, [sp, #0x1c]
700a2a98: 9919         	ldr	r1, [sp, #0x64]
700a2a9a: f7fa fcc1    	bl	0x7009d420 <Udma_eventRegister> @ imm = #-0x567e
700a2a9e: 9b03         	ldr	r3, [sp, #0xc]
700a2aa0: 9904         	ldr	r1, [sp, #0x10]
700a2aa2: 9a05         	ldr	r2, [sp, #0x14]
700a2aa4: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a2aa6: 983b         	ldr	r0, [sp, #0xec]
700a2aa8: fab0 f080    	clz	r0, r0
700a2aac: 0940         	lsrs	r0, r0, #0x5
700a2aae: 46ec         	mov	r12, sp
700a2ab0: f8cc 3000    	str.w	r3, [r12]
700a2ab4: 2377         	movs	r3, #0x77
700a2ab6: f006 fb33    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x6666
;     return retVal;
700a2aba: 983b         	ldr	r0, [sp, #0xec]
700a2abc: b03e         	add	sp, #0xf8
700a2abe: bd80         	pop	{r7, pc}

700a2ac0 <UART_udmaInitTxCh>:
; {
700a2ac0: b580         	push	{r7, lr}
700a2ac2: b0bc         	sub	sp, #0xf0
700a2ac4: 903b         	str	r0, [sp, #0xec]
700a2ac6: 913a         	str	r1, [sp, #0xe8]
700a2ac8: 2009         	movs	r0, #0x9
;     chType = UDMA_CH_TYPE_PDMA_TX;
700a2aca: 9038         	str	r0, [sp, #0xe0]
;     UdmaChPrms_init(&chPrms, chType);
700a2acc: 9938         	ldr	r1, [sp, #0xe0]
700a2ace: a81f         	add	r0, sp, #0x7c
700a2ad0: f006 fff6    	bl	0x700a9ac0 <UdmaChPrms_init> @ imm = #0x6fec
;     chPrms.peerChNum                = hUart->hUartInit->txEvtNum;
700a2ad4: 983b         	ldr	r0, [sp, #0xec]
700a2ad6: 6840         	ldr	r0, [r0, #0x4]
700a2ad8: 6c40         	ldr	r0, [r0, #0x44]
700a2ada: 9020         	str	r0, [sp, #0x80]
;     chPrms.fqRingPrms.ringMem       = udmaChCfg->txRingMem;
700a2adc: 983a         	ldr	r0, [sp, #0xe8]
700a2ade: 6a00         	ldr	r0, [r0, #0x20]
700a2ae0: 9023         	str	r0, [sp, #0x8c]
;     chPrms.fqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a2ae2: 983a         	ldr	r0, [sp, #0xe8]
700a2ae4: 6b00         	ldr	r0, [r0, #0x30]
700a2ae6: 9024         	str	r0, [sp, #0x90]
;     chPrms.fqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a2ae8: 983a         	ldr	r0, [sp, #0xe8]
700a2aea: 6b40         	ldr	r0, [r0, #0x34]
700a2aec: 9026         	str	r0, [sp, #0x98]
;     if(udmaChCfg->isCqRingMem == UDMA_COMP_QUEUE_RING_MEM_ENABLED){
700a2aee: 983a         	ldr	r0, [sp, #0xe8]
700a2af0: 6bc0         	ldr	r0, [r0, #0x3c]
700a2af2: 2801         	cmp	r0, #0x1
700a2af4: d10a         	bne	0x700a2b0c <UART_udmaInitTxCh+0x4c> @ imm = #0x14
700a2af6: e7ff         	b	0x700a2af8 <UART_udmaInitTxCh+0x38> @ imm = #-0x2
;         chPrms.cqRingPrms.ringMem       = udmaChCfg->cqTxRingMem;
700a2af8: 983a         	ldr	r0, [sp, #0xe8]
700a2afa: 6a40         	ldr	r0, [r0, #0x24]
700a2afc: 902a         	str	r0, [sp, #0xa8]
;         chPrms.cqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a2afe: 983a         	ldr	r0, [sp, #0xe8]
700a2b00: 6b00         	ldr	r0, [r0, #0x30]
700a2b02: 902b         	str	r0, [sp, #0xac]
;         chPrms.cqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a2b04: 983a         	ldr	r0, [sp, #0xe8]
700a2b06: 6b40         	ldr	r0, [r0, #0x34]
700a2b08: 902d         	str	r0, [sp, #0xb4]
;     }
700a2b0a: e7ff         	b	0x700a2b0c <UART_udmaInitTxCh+0x4c> @ imm = #-0x2
;     txChHandle                      = udmaChCfg->txChHandle;
700a2b0c: 983a         	ldr	r0, [sp, #0xe8]
700a2b0e: 6840         	ldr	r0, [r0, #0x4]
700a2b10: 9006         	str	r0, [sp, #0x18]
;     drvHandle                       = udmaChCfg->drvHandle;
700a2b12: 983a         	ldr	r0, [sp, #0xe8]
700a2b14: 6800         	ldr	r0, [r0]
700a2b16: 9007         	str	r0, [sp, #0x1c]
;     retVal = Udma_chOpen(drvHandle, txChHandle, chType, &chPrms);
700a2b18: 9807         	ldr	r0, [sp, #0x1c]
700a2b1a: 9906         	ldr	r1, [sp, #0x18]
700a2b1c: 9a38         	ldr	r2, [sp, #0xe0]
700a2b1e: ab1f         	add	r3, sp, #0x7c
700a2b20: f7fd fa9e    	bl	0x700a0060 <Udma_chOpen> @ imm = #-0x2ac4
700a2b24: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a2b26: 9839         	ldr	r0, [sp, #0xe4]
700a2b28: fab0 f080    	clz	r0, r0
700a2b2c: 0940         	lsrs	r0, r0, #0x5
700a2b2e: f240 316b    	movw	r1, #0x36b
700a2b32: f2c7 010b    	movt	r1, #0x700b
700a2b36: 9103         	str	r1, [sp, #0xc]
700a2b38: 466a         	mov	r2, sp
700a2b3a: 6011         	str	r1, [r2]
700a2b3c: f64f 7142    	movw	r1, #0xff42
700a2b40: f2c7 010a    	movt	r1, #0x700a
700a2b44: 9104         	str	r1, [sp, #0x10]
700a2b46: f240 4225    	movw	r2, #0x425
700a2b4a: f2c7 020b    	movt	r2, #0x700b
700a2b4e: 9205         	str	r2, [sp, #0x14]
700a2b50: 2398         	movs	r3, #0x98
700a2b52: f006 fae5    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x65ca
;     UdmaChTxPrms_init(&txPrms, chType);
700a2b56: 9938         	ldr	r1, [sp, #0xe0]
700a2b58: a81a         	add	r0, sp, #0x68
700a2b5a: 9001         	str	r0, [sp, #0x4]
700a2b5c: f003 fc98    	bl	0x700a6490 <UdmaChTxPrms_init> @ imm = #0x3930
700a2b60: 9901         	ldr	r1, [sp, #0x4]
;     retVal = Udma_chConfigTx(txChHandle, &txPrms);
700a2b62: 9806         	ldr	r0, [sp, #0x18]
700a2b64: f7fc f94c    	bl	0x7009ee00 <Udma_chConfigTx> @ imm = #-0x3d68
700a2b68: 9b03         	ldr	r3, [sp, #0xc]
700a2b6a: 9904         	ldr	r1, [sp, #0x10]
700a2b6c: 9a05         	ldr	r2, [sp, #0x14]
700a2b6e: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a2b70: 9839         	ldr	r0, [sp, #0xe4]
700a2b72: fab0 f080    	clz	r0, r0
700a2b76: 0940         	lsrs	r0, r0, #0x5
700a2b78: 46ec         	mov	r12, sp
700a2b7a: f8cc 3000    	str.w	r3, [r12]
700a2b7e: 239d         	movs	r3, #0x9d
700a2b80: f006 face    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x659c
;     eventHandle = udmaChCfg->cqTxEvtHandle;
700a2b84: 983a         	ldr	r0, [sp, #0xe8]
700a2b86: 68c0         	ldr	r0, [r0, #0xc]
700a2b88: 9019         	str	r0, [sp, #0x64]
700a2b8a: a808         	add	r0, sp, #0x20
;     UdmaEventPrms_init(&eventPrms);
700a2b8c: 9002         	str	r0, [sp, #0x8]
700a2b8e: f007 fbf7    	bl	0x700aa380 <UdmaEventPrms_init> @ imm = #0x77ee
700a2b92: 2001         	movs	r0, #0x1
;     eventPrms.eventType         = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a2b94: 9008         	str	r0, [sp, #0x20]
700a2b96: 2002         	movs	r0, #0x2
;     eventPrms.eventMode         = UDMA_EVENT_MODE_SHARED;
700a2b98: 9009         	str	r0, [sp, #0x24]
;     eventPrms.chHandle          = txChHandle;
700a2b9a: 9806         	ldr	r0, [sp, #0x18]
700a2b9c: 900a         	str	r0, [sp, #0x28]
;     eventPrms.controllerEventHandle = Udma_eventGetGlobalHandle(drvHandle);
700a2b9e: 9807         	ldr	r0, [sp, #0x1c]
700a2ba0: f008 fac6    	bl	0x700ab130 <Udma_eventGetGlobalHandle> @ imm = #0x858c
700a2ba4: 9a02         	ldr	r2, [sp, #0x8]
700a2ba6: 900c         	str	r0, [sp, #0x30]
;     eventPrms.eventCb           = &UART_udmaIsrTx;
700a2ba8: f647 40b1    	movw	r0, #0x7cb1
700a2bac: f2c7 000a    	movt	r0, #0x700a
700a2bb0: 900d         	str	r0, [sp, #0x34]
;     eventPrms.appData           = (void *) hUart;
700a2bb2: 983b         	ldr	r0, [sp, #0xec]
700a2bb4: 900f         	str	r0, [sp, #0x3c]
;     retVal = Udma_eventRegister(drvHandle, eventHandle, &eventPrms);
700a2bb6: 9807         	ldr	r0, [sp, #0x1c]
700a2bb8: 9919         	ldr	r1, [sp, #0x64]
700a2bba: f7fa fc31    	bl	0x7009d420 <Udma_eventRegister> @ imm = #-0x579e
700a2bbe: 9b03         	ldr	r3, [sp, #0xc]
700a2bc0: 9904         	ldr	r1, [sp, #0x10]
700a2bc2: 9a05         	ldr	r2, [sp, #0x14]
700a2bc4: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a2bc6: 9839         	ldr	r0, [sp, #0xe4]
700a2bc8: fab0 f080    	clz	r0, r0
700a2bcc: 0940         	lsrs	r0, r0, #0x5
700a2bce: 46ec         	mov	r12, sp
700a2bd0: f8cc 3000    	str.w	r3, [r12]
700a2bd4: 23a9         	movs	r3, #0xa9
700a2bd6: f006 faa3    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x6546
;     return retVal;
700a2bda: 9839         	ldr	r0, [sp, #0xe4]
700a2bdc: b03c         	add	sp, #0xf0
700a2bde: bd80         	pop	{r7, pc}

700a2be0 <Sciclient_rmIaValidateEvt>:
; {
700a2be0: b580         	push	{r7, lr}
700a2be2: b086         	sub	sp, #0x18
700a2be4: 4684         	mov	r12, r0
700a2be6: 9808         	ldr	r0, [sp, #0x20]
700a2be8: f8cd c014    	str.w	r12, [sp, #0x14]
700a2bec: f8ad 1012    	strh.w	r1, [sp, #0x12]
700a2bf0: f8ad 2010    	strh.w	r2, [sp, #0x10]
700a2bf4: f88d 300f    	strb.w	r3, [sp, #0xf]
700a2bf8: f88d 000e    	strb.w	r0, [sp, #0xe]
700a2bfc: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a2bfe: 9002         	str	r0, [sp, #0x8]
;     if (evt >= inst->n_sevt) {
700a2c00: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a2c04: 9905         	ldr	r1, [sp, #0x14]
700a2c06: 8949         	ldrh	r1, [r1, #0xa]
700a2c08: 4288         	cmp	r0, r1
700a2c0a: db04         	blt	0x700a2c16 <Sciclient_rmIaValidateEvt+0x36> @ imm = #0x8
700a2c0c: e7ff         	b	0x700a2c0e <Sciclient_rmIaValidateEvt+0x2e> @ imm = #-0x2
700a2c0e: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a2c12: 9002         	str	r0, [sp, #0x8]
;     }
700a2c14: e7ff         	b	0x700a2c16 <Sciclient_rmIaValidateEvt+0x36> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a2c16: 9802         	ldr	r0, [sp, #0x8]
700a2c18: 2800         	cmp	r0, #0x0
700a2c1a: d16d         	bne	0x700a2cf8 <Sciclient_rmIaValidateEvt+0x118> @ imm = #0xda
700a2c1c: e7ff         	b	0x700a2c1e <Sciclient_rmIaValidateEvt+0x3e> @ imm = #-0x2
;         entry_int_map_lo = (volatile uint32_t *)(inst->imap + SCICLIENT_IA_ENTRY_INTMAP_LO(evt));
700a2c1e: 9805         	ldr	r0, [sp, #0x14]
700a2c20: 6840         	ldr	r0, [r0, #0x4]
700a2c22: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a2c26: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a2c2a: 9001         	str	r0, [sp, #0x4]
;         if (in_use == true) {
700a2c2c: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700a2c30: 07c0         	lsls	r0, r0, #0x1f
700a2c32: 2800         	cmp	r0, #0x0
700a2c34: d047         	beq	0x700a2cc6 <Sciclient_rmIaValidateEvt+0xe6> @ imm = #0x8e
700a2c36: e7ff         	b	0x700a2c38 <Sciclient_rmIaValidateEvt+0x58> @ imm = #-0x2
;             reg_vint = CSL_REG32_FEXT(entry_int_map_lo,
700a2c38: 9801         	ldr	r0, [sp, #0x4]
700a2c3a: f64f 7100    	movw	r1, #0xff00
700a2c3e: f2c0 0101    	movt	r1, #0x1
700a2c42: 2208         	movs	r2, #0x8
700a2c44: f00a fce4    	bl	0x700ad610 <CSL_REG32_FEXT_RAW> @ imm = #0xa9c8
700a2c48: f8ad 0002    	strh.w	r0, [sp, #0x2]
;             reg_sb = CSL_REG32_FEXT(entry_int_map_lo,
700a2c4c: 9801         	ldr	r0, [sp, #0x4]
700a2c4e: 213f         	movs	r1, #0x3f
700a2c50: 2200         	movs	r2, #0x0
700a2c52: f00a fcdd    	bl	0x700ad610 <CSL_REG32_FEXT_RAW> @ imm = #0xa9ba
700a2c56: f8ad 0000    	strh.w	r0, [sp]
;             if ((reg_vint == 0u) && (reg_sb == 0u)) {
700a2c5a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a2c5e: b9f0         	cbnz	r0, 0x700a2c9e <Sciclient_rmIaValidateEvt+0xbe> @ imm = #0x3c
700a2c60: e7ff         	b	0x700a2c62 <Sciclient_rmIaValidateEvt+0x82> @ imm = #-0x2
700a2c62: f8bd 0000    	ldrh.w	r0, [sp]
700a2c66: b9d0         	cbnz	r0, 0x700a2c9e <Sciclient_rmIaValidateEvt+0xbe> @ imm = #0x34
700a2c68: e7ff         	b	0x700a2c6a <Sciclient_rmIaValidateEvt+0x8a> @ imm = #-0x2
;                 if ((vint != reg_vint) &&
700a2c6a: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a2c6e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a2c72: 4288         	cmp	r0, r1
700a2c74: d012         	beq	0x700a2c9c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x24
700a2c76: e7ff         	b	0x700a2c78 <Sciclient_rmIaValidateEvt+0x98> @ imm = #-0x2
;                     (vint_sb_index != reg_sb) &&
700a2c78: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a2c7c: f8bd 1000    	ldrh.w	r1, [sp]
700a2c80: 4288         	cmp	r0, r1
700a2c82: d00b         	beq	0x700a2c9c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x16
700a2c84: e7ff         	b	0x700a2c86 <Sciclient_rmIaValidateEvt+0xa6> @ imm = #-0x2
;                     (evt != inst->v0_b0_evt)) {
700a2c86: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a2c8a: 9905         	ldr	r1, [sp, #0x14]
700a2c8c: 8a89         	ldrh	r1, [r1, #0x14]
;                 if ((vint != reg_vint) &&
700a2c8e: 4288         	cmp	r0, r1
700a2c90: d004         	beq	0x700a2c9c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x8
700a2c92: e7ff         	b	0x700a2c94 <Sciclient_rmIaValidateEvt+0xb4> @ imm = #-0x2
700a2c94: f06f 0001    	mvn	r0, #0x1
;                     r = CSL_EBADARGS;
700a2c98: 9002         	str	r0, [sp, #0x8]
;                 }
700a2c9a: e7ff         	b	0x700a2c9c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #-0x2
;             } else {
700a2c9c: e012         	b	0x700a2cc4 <Sciclient_rmIaValidateEvt+0xe4> @ imm = #0x24
;                 if ((vint != reg_vint) &&
700a2c9e: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a2ca2: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a2ca6: 4288         	cmp	r0, r1
700a2ca8: d00b         	beq	0x700a2cc2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #0x16
700a2caa: e7ff         	b	0x700a2cac <Sciclient_rmIaValidateEvt+0xcc> @ imm = #-0x2
;                     (vint_sb_index != reg_sb)) {
700a2cac: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a2cb0: f8bd 1000    	ldrh.w	r1, [sp]
;                 if ((vint != reg_vint) &&
700a2cb4: 4288         	cmp	r0, r1
700a2cb6: d004         	beq	0x700a2cc2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #0x8
700a2cb8: e7ff         	b	0x700a2cba <Sciclient_rmIaValidateEvt+0xda> @ imm = #-0x2
700a2cba: f06f 0001    	mvn	r0, #0x1
;                     r = CSL_EBADARGS;
700a2cbe: 9002         	str	r0, [sp, #0x8]
;                 }
700a2cc0: e7ff         	b	0x700a2cc2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #-0x2
700a2cc2: e7ff         	b	0x700a2cc4 <Sciclient_rmIaValidateEvt+0xe4> @ imm = #-0x2
;         } else {
700a2cc4: e017         	b	0x700a2cf6 <Sciclient_rmIaValidateEvt+0x116> @ imm = #0x2e
;             if (((CSL_REG32_RD(entry_int_map_lo) != 0u) &&
700a2cc6: 9801         	ldr	r0, [sp, #0x4]
700a2cc8: f00b f9f2    	bl	0x700ae0b0 <CSL_REG32_RD_RAW> @ imm = #0xb3e4
700a2ccc: b138         	cbz	r0, 0x700a2cde <Sciclient_rmIaValidateEvt+0xfe> @ imm = #0xe
700a2cce: e7ff         	b	0x700a2cd0 <Sciclient_rmIaValidateEvt+0xf0> @ imm = #-0x2
;                  (Sciclient_rmIaEvtRomMapped(inst, evt) == false)) ||
700a2cd0: 9805         	ldr	r0, [sp, #0x14]
700a2cd2: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a2cd6: f005 fc23    	bl	0x700a8520 <Sciclient_rmIaEvtRomMapped> @ imm = #0x5846
700a2cda: b138         	cbz	r0, 0x700a2cec <Sciclient_rmIaValidateEvt+0x10c> @ imm = #0xe
700a2cdc: e7ff         	b	0x700a2cde <Sciclient_rmIaValidateEvt+0xfe> @ imm = #-0x2
;                 (evt == inst->v0_b0_evt)) {
700a2cde: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a2ce2: 9905         	ldr	r1, [sp, #0x14]
700a2ce4: 8a89         	ldrh	r1, [r1, #0x14]
;             if (((CSL_REG32_RD(entry_int_map_lo) != 0u) &&
700a2ce6: 4288         	cmp	r0, r1
700a2ce8: d104         	bne	0x700a2cf4 <Sciclient_rmIaValidateEvt+0x114> @ imm = #0x8
700a2cea: e7ff         	b	0x700a2cec <Sciclient_rmIaValidateEvt+0x10c> @ imm = #-0x2
700a2cec: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a2cf0: 9002         	str	r0, [sp, #0x8]
;             }
700a2cf2: e7ff         	b	0x700a2cf4 <Sciclient_rmIaValidateEvt+0x114> @ imm = #-0x2
700a2cf4: e7ff         	b	0x700a2cf6 <Sciclient_rmIaValidateEvt+0x116> @ imm = #-0x2
;     }
700a2cf6: e7ff         	b	0x700a2cf8 <Sciclient_rmIaValidateEvt+0x118> @ imm = #-0x2
;     return r;
700a2cf8: 9802         	ldr	r0, [sp, #0x8]
700a2cfa: b006         	add	sp, #0x18
700a2cfc: bd80         	pop	{r7, pc}
700a2cfe: 0000         	movs	r0, r0

700a2d00 <Sciclient_rmIrqVintAdd>:
; {
700a2d00: b580         	push	{r7, lr}
700a2d02: b08c         	sub	sp, #0x30
700a2d04: 900b         	str	r0, [sp, #0x2c]
700a2d06: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a2d08: 900a         	str	r0, [sp, #0x28]
;     bool cfg_new_mapping = false;
700a2d0a: f88d 0026    	strb.w	r0, [sp, #0x26]
;     bool cfg_whole_route = false;
700a2d0e: f88d 0025    	strb.w	r0, [sp, #0x25]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a2d12: 9008         	str	r0, [sp, #0x20]
;     r = Sciclient_rmIrqIsVintRouteSet(cfg, &vint_used);
700a2d14: 980b         	ldr	r0, [sp, #0x2c]
700a2d16: f10d 0127    	add.w	r1, sp, #0x27
700a2d1a: f002 fd11    	bl	0x700a5740 <Sciclient_rmIrqIsVintRouteSet> @ imm = #0x2a22
700a2d1e: 900a         	str	r0, [sp, #0x28]
;     if (r == SystemP_SUCCESS) {
700a2d20: 980a         	ldr	r0, [sp, #0x28]
700a2d22: b9a0         	cbnz	r0, 0x700a2d4e <Sciclient_rmIrqVintAdd+0x4e> @ imm = #0x28
700a2d24: e7ff         	b	0x700a2d26 <Sciclient_rmIrqVintAdd+0x26> @ imm = #-0x2
;         if ((vint_used == true) ||
700a2d26: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a2d2a: 07c0         	lsls	r0, r0, #0x1f
700a2d2c: b930         	cbnz	r0, 0x700a2d3c <Sciclient_rmIrqVintAdd+0x3c> @ imm = #0xc
700a2d2e: e7ff         	b	0x700a2d30 <Sciclient_rmIrqVintAdd+0x30> @ imm = #-0x2
;             (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg->valid_params) ==
700a2d30: 980b         	ldr	r0, [sp, #0x2c]
700a2d32: 6800         	ldr	r0, [r0]
700a2d34: f006 ffdc    	bl	0x700a9cf0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0x6fb8
;         if ((vint_used == true) ||
700a2d38: b120         	cbz	r0, 0x700a2d44 <Sciclient_rmIrqVintAdd+0x44> @ imm = #0x8
700a2d3a: e7ff         	b	0x700a2d3c <Sciclient_rmIrqVintAdd+0x3c> @ imm = #-0x2
700a2d3c: 2001         	movs	r0, #0x1
;             cfg_new_mapping = true;
700a2d3e: f88d 0026    	strb.w	r0, [sp, #0x26]
;         } else {
700a2d42: e003         	b	0x700a2d4c <Sciclient_rmIrqVintAdd+0x4c> @ imm = #0x6
700a2d44: 2001         	movs	r0, #0x1
;             cfg_whole_route = true;
700a2d46: f88d 0025    	strb.w	r0, [sp, #0x25]
700a2d4a: e7ff         	b	0x700a2d4c <Sciclient_rmIrqVintAdd+0x4c> @ imm = #-0x2
;     }
700a2d4c: e7ff         	b	0x700a2d4e <Sciclient_rmIrqVintAdd+0x4e> @ imm = #-0x2
;     if (cfg_new_mapping == true) {
700a2d4e: f89d 0026    	ldrb.w	r0, [sp, #0x26]
700a2d52: 07c0         	lsls	r0, r0, #0x1f
700a2d54: 2800         	cmp	r0, #0x0
700a2d56: d04c         	beq	0x700a2df2 <Sciclient_rmIrqVintAdd+0xf2> @ imm = #0x98
700a2d58: e7ff         	b	0x700a2d5a <Sciclient_rmIrqVintAdd+0x5a> @ imm = #-0x2
700a2d5a: 203c         	movs	r0, #0x3c
700a2d5c: f2c8 0000    	movt	r0, #0x8000
;         req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a2d60: 9003         	str	r0, [sp, #0xc]
;         req.secondary_host = cfg->host;
700a2d62: 980b         	ldr	r0, [sp, #0x2c]
700a2d64: 7900         	ldrb	r0, [r0, #0x4]
700a2d66: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         req.src_id = cfg->s_id;
700a2d6a: 980b         	ldr	r0, [sp, #0x2c]
700a2d6c: 88c0         	ldrh	r0, [r0, #0x6]
700a2d6e: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         req.src_index = cfg->s_idx;
700a2d72: 980b         	ldr	r0, [sp, #0x2c]
700a2d74: 8900         	ldrh	r0, [r0, #0x8]
700a2d76: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         req.ia_id = cfg->s_ia;
700a2d7a: 980b         	ldr	r0, [sp, #0x2c]
700a2d7c: 8a00         	ldrh	r0, [r0, #0x10]
700a2d7e: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         req.vint = cfg->vint;
700a2d82: 980b         	ldr	r0, [sp, #0x2c]
700a2d84: 8a40         	ldrh	r0, [r0, #0x12]
700a2d86: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         req.global_event = cfg->global_evt;
700a2d8a: 980b         	ldr	r0, [sp, #0x2c]
700a2d8c: 89c0         	ldrh	r0, [r0, #0xe]
700a2d8e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         req.vint_status_bit_index = cfg->vint_sb;
700a2d92: 980b         	ldr	r0, [sp, #0x2c]
700a2d94: 7d00         	ldrb	r0, [r0, #0x14]
700a2d96: f88d 001e    	strb.w	r0, [sp, #0x1e]
;                                   cfg->set_resp,
700a2d9a: 980b         	ldr	r0, [sp, #0x2c]
700a2d9c: 6981         	ldr	r1, [r0, #0x18]
700a2d9e: a801         	add	r0, sp, #0x4
700a2da0: f04f 32ff    	mov.w	r2, #0xffffffff
;         r = Sciclient_rmIrqSetRaw(&req,
700a2da4: f007 ff5c    	bl	0x700aac60 <Sciclient_rmIrqSetRaw> @ imm = #0x7eb8
700a2da8: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a2daa: 980a         	ldr	r0, [sp, #0x28]
700a2dac: bb00         	cbnz	r0, 0x700a2df0 <Sciclient_rmIrqVintAdd+0xf0> @ imm = #0x40
700a2dae: e7ff         	b	0x700a2db0 <Sciclient_rmIrqVintAdd+0xb0> @ imm = #-0x2
;             ia_inst = Sciclient_rmIaGetInst(cfg->s_ia);
700a2db0: 980b         	ldr	r0, [sp, #0x2c]
700a2db2: 8a00         	ldrh	r0, [r0, #0x10]
700a2db4: f007 fdd4    	bl	0x700aa960 <Sciclient_rmIaGetInst> @ imm = #0x7ba8
700a2db8: 9008         	str	r0, [sp, #0x20]
;             if (ia_inst != NULL) {
700a2dba: 9808         	ldr	r0, [sp, #0x20]
700a2dbc: b1b8         	cbz	r0, 0x700a2dee <Sciclient_rmIrqVintAdd+0xee> @ imm = #0x2e
700a2dbe: e7ff         	b	0x700a2dc0 <Sciclient_rmIrqVintAdd+0xc0> @ imm = #-0x2
;                 ia_inst->vint_usage_count[cfg->vint]++;
700a2dc0: 9808         	ldr	r0, [sp, #0x20]
700a2dc2: 6901         	ldr	r1, [r0, #0x10]
700a2dc4: 980b         	ldr	r0, [sp, #0x2c]
700a2dc6: 8a42         	ldrh	r2, [r0, #0x12]
700a2dc8: 5c88         	ldrb	r0, [r1, r2]
700a2dca: 3001         	adds	r0, #0x1
700a2dcc: 5488         	strb	r0, [r1, r2]
;                 if ((cfg->vint == 0) && (cfg->vint_sb == 0)) {
700a2dce: 980b         	ldr	r0, [sp, #0x2c]
700a2dd0: 8a40         	ldrh	r0, [r0, #0x12]
700a2dd2: b958         	cbnz	r0, 0x700a2dec <Sciclient_rmIrqVintAdd+0xec> @ imm = #0x16
700a2dd4: e7ff         	b	0x700a2dd6 <Sciclient_rmIrqVintAdd+0xd6> @ imm = #-0x2
700a2dd6: 980b         	ldr	r0, [sp, #0x2c]
700a2dd8: 7d00         	ldrb	r0, [r0, #0x14]
700a2dda: b938         	cbnz	r0, 0x700a2dec <Sciclient_rmIrqVintAdd+0xec> @ imm = #0xe
700a2ddc: e7ff         	b	0x700a2dde <Sciclient_rmIrqVintAdd+0xde> @ imm = #-0x2
;                     ia_inst->v0_b0_evt = cfg->global_evt - ia_inst->sevt_offset;
700a2dde: 980b         	ldr	r0, [sp, #0x2c]
700a2de0: 89c0         	ldrh	r0, [r0, #0xe]
700a2de2: 9908         	ldr	r1, [sp, #0x20]
700a2de4: 890a         	ldrh	r2, [r1, #0x8]
700a2de6: 1a80         	subs	r0, r0, r2
700a2de8: 8288         	strh	r0, [r1, #0x14]
;                 }
700a2dea: e7ff         	b	0x700a2dec <Sciclient_rmIrqVintAdd+0xec> @ imm = #-0x2
;             }
700a2dec: e7ff         	b	0x700a2dee <Sciclient_rmIrqVintAdd+0xee> @ imm = #-0x2
;         }
700a2dee: e7ff         	b	0x700a2df0 <Sciclient_rmIrqVintAdd+0xf0> @ imm = #-0x2
;     }
700a2df0: e7ff         	b	0x700a2df2 <Sciclient_rmIrqVintAdd+0xf2> @ imm = #-0x2
;     if (cfg_whole_route == true) {
700a2df2: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a2df6: 07c0         	lsls	r0, r0, #0x1f
700a2df8: b170         	cbz	r0, 0x700a2e18 <Sciclient_rmIrqVintAdd+0x118> @ imm = #0x1c
700a2dfa: e7ff         	b	0x700a2dfc <Sciclient_rmIrqVintAdd+0xfc> @ imm = #-0x2
;         r = Sciclient_rmIrqFindRoute(cfg);
700a2dfc: 980b         	ldr	r0, [sp, #0x2c]
700a2dfe: f7f9 ff9f    	bl	0x7009cd40 <Sciclient_rmIrqFindRoute> @ imm = #-0x60c2
700a2e02: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a2e04: 980a         	ldr	r0, [sp, #0x28]
700a2e06: b930         	cbnz	r0, 0x700a2e16 <Sciclient_rmIrqVintAdd+0x116> @ imm = #0xc
700a2e08: e7ff         	b	0x700a2e0a <Sciclient_rmIrqVintAdd+0x10a> @ imm = #-0x2
;             r = Sciclient_rmIrqProgramRoute(cfg, true);
700a2e0a: 980b         	ldr	r0, [sp, #0x2c]
700a2e0c: 2101         	movs	r1, #0x1
700a2e0e: f7fc fbe7    	bl	0x7009f5e0 <Sciclient_rmIrqProgramRoute> @ imm = #-0x3832
700a2e12: 900a         	str	r0, [sp, #0x28]
;         }
700a2e14: e7ff         	b	0x700a2e16 <Sciclient_rmIrqVintAdd+0x116> @ imm = #-0x2
;     }
700a2e16: e7ff         	b	0x700a2e18 <Sciclient_rmIrqVintAdd+0x118> @ imm = #-0x2
;     return r;
700a2e18: 980a         	ldr	r0, [sp, #0x28]
700a2e1a: b00c         	add	sp, #0x30
700a2e1c: bd80         	pop	{r7, pc}
700a2e1e: 0000         	movs	r0, r0

700a2e20 <TaskP_loadUpdateAll>:
; {
700a2e20: b580         	push	{r7, lr}
700a2e22: b090         	sub	sp, #0x40
;     vTaskSuspendAll();
700a2e24: f00b f904    	bl	0x700ae030 <vTaskSuspendAll> @ imm = #0xb208
700a2e28: 2000         	movs	r0, #0x0
;     for(i=0; i<TaskP_REGISTRY_MAX_ENTRIES; i++)
700a2e2a: 9005         	str	r0, [sp, #0x14]
700a2e2c: e7ff         	b	0x700a2e2e <TaskP_loadUpdateAll+0xe> @ imm = #-0x2
700a2e2e: 9805         	ldr	r0, [sp, #0x14]
700a2e30: 281f         	cmp	r0, #0x1f
700a2e32: d837         	bhi	0x700a2ea4 <TaskP_loadUpdateAll+0x84> @ imm = #0x6e
700a2e34: e7ff         	b	0x700a2e36 <TaskP_loadUpdateAll+0x16> @ imm = #-0x2
;         if(gTaskP_ctrl.taskRegistry[i]!=NULL)
700a2e36: 9905         	ldr	r1, [sp, #0x14]
700a2e38: f644 1078    	movw	r0, #0x4978
700a2e3c: f2c7 0008    	movt	r0, #0x7008
700a2e40: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a2e44: b348         	cbz	r0, 0x700a2e9a <TaskP_loadUpdateAll+0x7a> @ imm = #0x52
700a2e46: e7ff         	b	0x700a2e48 <TaskP_loadUpdateAll+0x28> @ imm = #-0x2
;             taskObj = gTaskP_ctrl.taskRegistry[i];
700a2e48: 9905         	ldr	r1, [sp, #0x14]
700a2e4a: f644 1078    	movw	r0, #0x4978
700a2e4e: f2c7 0008    	movt	r0, #0x7008
700a2e52: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a2e56: 900f         	str	r0, [sp, #0x3c]
;             vTaskGetInfo(taskObj->taskHndl, &taskStatus, pdFALSE, eReady);
700a2e58: 980f         	ldr	r0, [sp, #0x3c]
700a2e5a: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a2e5e: a906         	add	r1, sp, #0x18
700a2e60: 2200         	movs	r2, #0x0
700a2e62: 2301         	movs	r3, #0x1
700a2e64: f001 faac    	bl	0x700a43c0 <vTaskGetInfo> @ imm = #0x1558
;             delta = TaskP_calcCounterDiff(taskStatus.ulRunTimeCounter, taskObj->lastRunTime);
700a2e68: 980c         	ldr	r0, [sp, #0x30]
700a2e6a: 990f         	ldr	r1, [sp, #0x3c]
700a2e6c: f8d1 108c    	ldr.w	r1, [r1, #0x8c]
700a2e70: f00a f8ce    	bl	0x700ad010 <TaskP_calcCounterDiff> @ imm = #0xa19c
700a2e74: 9004         	str	r0, [sp, #0x10]
;             taskObj->accRunTime += delta;
700a2e76: 9b04         	ldr	r3, [sp, #0x10]
700a2e78: 990f         	ldr	r1, [sp, #0x3c]
700a2e7a: f8d1 2090    	ldr.w	r2, [r1, #0x90]
700a2e7e: f8d1 0094    	ldr.w	r0, [r1, #0x94]
700a2e82: 18d2         	adds	r2, r2, r3
700a2e84: f140 0000    	adc	r0, r0, #0x0
700a2e88: f8c1 2090    	str.w	r2, [r1, #0x90]
700a2e8c: f8c1 0094    	str.w	r0, [r1, #0x94]
;             taskObj->lastRunTime = taskStatus.ulRunTimeCounter;
700a2e90: 980c         	ldr	r0, [sp, #0x30]
700a2e92: 990f         	ldr	r1, [sp, #0x3c]
700a2e94: f8c1 008c    	str.w	r0, [r1, #0x8c]
;         }
700a2e98: e7ff         	b	0x700a2e9a <TaskP_loadUpdateAll+0x7a> @ imm = #-0x2
;     }
700a2e9a: e7ff         	b	0x700a2e9c <TaskP_loadUpdateAll+0x7c> @ imm = #-0x2
;     for(i=0; i<TaskP_REGISTRY_MAX_ENTRIES; i++)
700a2e9c: 9805         	ldr	r0, [sp, #0x14]
700a2e9e: 3001         	adds	r0, #0x1
700a2ea0: 9005         	str	r0, [sp, #0x14]
700a2ea2: e7c4         	b	0x700a2e2e <TaskP_loadUpdateAll+0xe> @ imm = #-0x78
;     idleTskHndl = xTaskGetIdleTaskHandle();
700a2ea4: f00b f934    	bl	0x700ae110 <xTaskGetIdleTaskHandle> @ imm = #0xb268
700a2ea8: 9002         	str	r0, [sp, #0x8]
;     if(idleTskHndl != NULL)
700a2eaa: 9802         	ldr	r0, [sp, #0x8]
700a2eac: b310         	cbz	r0, 0x700a2ef4 <TaskP_loadUpdateAll+0xd4> @ imm = #0x44
700a2eae: e7ff         	b	0x700a2eb0 <TaskP_loadUpdateAll+0x90> @ imm = #-0x2
;         vTaskGetInfo(idleTskHndl, &taskStatus, pdFALSE, eReady);
700a2eb0: 9802         	ldr	r0, [sp, #0x8]
700a2eb2: a906         	add	r1, sp, #0x18
700a2eb4: 2200         	movs	r2, #0x0
700a2eb6: 2301         	movs	r3, #0x1
700a2eb8: f001 fa82    	bl	0x700a43c0 <vTaskGetInfo> @ imm = #0x1504
;         delta = TaskP_calcCounterDiff(taskStatus.ulRunTimeCounter, gTaskP_ctrl.idleTskLastRunTime);
700a2ebc: 980c         	ldr	r0, [sp, #0x30]
700a2ebe: f644 1178    	movw	r1, #0x4978
700a2ec2: f2c7 0108    	movt	r1, #0x7008
700a2ec6: 9101         	str	r1, [sp, #0x4]
700a2ec8: f8d1 1090    	ldr.w	r1, [r1, #0x90]
700a2ecc: f00a f8a0    	bl	0x700ad010 <TaskP_calcCounterDiff> @ imm = #0xa140
700a2ed0: 9901         	ldr	r1, [sp, #0x4]
700a2ed2: 9004         	str	r0, [sp, #0x10]
;         gTaskP_ctrl.idleTskAccRunTime += delta;
700a2ed4: 9b04         	ldr	r3, [sp, #0x10]
700a2ed6: f8d1 2098    	ldr.w	r2, [r1, #0x98]
700a2eda: f8d1 009c    	ldr.w	r0, [r1, #0x9c]
700a2ede: 18d2         	adds	r2, r2, r3
700a2ee0: f140 0000    	adc	r0, r0, #0x0
700a2ee4: f8c1 2098    	str.w	r2, [r1, #0x98]
700a2ee8: f8c1 009c    	str.w	r0, [r1, #0x9c]
;         gTaskP_ctrl.idleTskLastRunTime = taskStatus.ulRunTimeCounter;
700a2eec: 980c         	ldr	r0, [sp, #0x30]
700a2eee: f8c1 0090    	str.w	r0, [r1, #0x90]
;     }
700a2ef2: e7ff         	b	0x700a2ef4 <TaskP_loadUpdateAll+0xd4> @ imm = #-0x2
;     curTotalTime = portGET_RUN_TIME_COUNTER_VALUE();
700a2ef4: f00b f814    	bl	0x700adf20 <uiPortGetRunTimeCounterValue> @ imm = #0xb028
700a2ef8: 9003         	str	r0, [sp, #0xc]
;     delta = TaskP_calcCounterDiff(curTotalTime, gTaskP_ctrl.lastTotalTime);
700a2efa: 9803         	ldr	r0, [sp, #0xc]
700a2efc: f644 1178    	movw	r1, #0x4978
700a2f00: f2c7 0108    	movt	r1, #0x7008
700a2f04: 9100         	str	r1, [sp]
700a2f06: f8d1 1080    	ldr.w	r1, [r1, #0x80]
700a2f0a: f00a f881    	bl	0x700ad010 <TaskP_calcCounterDiff> @ imm = #0xa102
700a2f0e: 9900         	ldr	r1, [sp]
700a2f10: 9004         	str	r0, [sp, #0x10]
;     gTaskP_ctrl.accTotalTime += delta;
700a2f12: 9b04         	ldr	r3, [sp, #0x10]
700a2f14: f8d1 2088    	ldr.w	r2, [r1, #0x88]
700a2f18: f8d1 008c    	ldr.w	r0, [r1, #0x8c]
700a2f1c: 18d2         	adds	r2, r2, r3
700a2f1e: f140 0000    	adc	r0, r0, #0x0
700a2f22: f8c1 2088    	str.w	r2, [r1, #0x88]
700a2f26: f8c1 008c    	str.w	r0, [r1, #0x8c]
;     gTaskP_ctrl.lastTotalTime = curTotalTime;
700a2f2a: 9803         	ldr	r0, [sp, #0xc]
700a2f2c: f8c1 0080    	str.w	r0, [r1, #0x80]
;     (void)xTaskResumeAll();
700a2f30: f7fd fcb6    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0x2694
; }
700a2f34: b010         	add	sp, #0x40
700a2f36: bd80         	pop	{r7, pc}

700a2f38 <__udivmoddi4>:
700a2f38: e1530001     	cmp	r3, r1
700a2f3c: 01520000     	cmpeq	r2, r0
700a2f40: 9a000007     	bls	0x700a2f64 <__udivmoddi4+0x2c> @ imm = #0x1c
700a2f44: e59d2000     	ldr	r2, [sp]
700a2f48: e3520000     	cmp	r2, #0
700a2f4c: 0a000001     	beq	0x700a2f58 <__udivmoddi4+0x20> @ imm = #0x4
700a2f50: e5820000     	str	r0, [r2]
700a2f54: e5821004     	str	r1, [r2, #0x4]
700a2f58: e3b01000     	movs	r1, #0
700a2f5c: e3b00000     	movs	r0, #0
700a2f60: e12fff1e     	bx	lr
700a2f64: e3530000     	cmp	r3, #0
700a2f68: 03520000     	cmpeq	r2, #0
700a2f6c: 1a00000d     	bne	0x700a2fa8 <__udivmoddi4+0x70> @ imm = #0x34
700a2f70: e59d2000     	ldr	r2, [sp]
700a2f74: e3520000     	cmp	r2, #0
700a2f78: 0a000001     	beq	0x700a2f84 <__udivmoddi4+0x4c> @ imm = #0x4
700a2f7c: e5820000     	str	r0, [r2]
700a2f80: e5821004     	str	r1, [r2, #0x4]
700a2f84: e1b02000     	movs	r2, r0
700a2f88: e1b03001     	movs	r3, r1
700a2f8c: e3b01000     	movs	r1, #0
700a2f90: e3b00000     	movs	r0, #0
700a2f94: e3530000     	cmp	r3, #0
700a2f98: 03520000     	cmpeq	r2, #0
700a2f9c: 11e01001     	mvnne	r1, r1
700a2fa0: 11e00000     	mvnne	r0, r0
700a2fa4: ea002c89     	b	0x700ae1d0 <__aeabi_ldiv0> @ imm = #0xb224
700a2fa8: e92d40f0     	push	{r4, r5, r6, r7, lr}
700a2fac: e1a04003     	mov	r4, r3
700a2fb0: e1a05002     	mov	r5, r2
700a2fb4: e1a03001     	mov	r3, r1
700a2fb8: e1a02000     	mov	r2, r0
700a2fbc: e3b00000     	movs	r0, #0
700a2fc0: e3b01000     	movs	r1, #0
700a2fc4: e16f6f14     	clz	r6, r4
700a2fc8: e3560020     	cmp	r6, #32
700a2fcc: 016f6f15     	clzeq	r6, r5
700a2fd0: 02866020     	addeq	r6, r6, #32
700a2fd4: e16f7f13     	clz	r7, r3
700a2fd8: e3570020     	cmp	r7, #32
700a2fdc: 016f7f12     	clzeq	r7, r2
700a2fe0: 02877020     	addeq	r7, r7, #32
700a2fe4: e0566007     	subs	r6, r6, r7
700a2fe8: e2567020     	subs	r7, r6, #32
700a2fec: 21a04715     	lslhs	r4, r5, r7
700a2ff0: 23a05000     	movhs	r5, #0
700a2ff4: 32677000     	rsblo	r7, r7, #0
700a2ff8: 31a04614     	lsllo	r4, r4, r6
700a2ffc: 31a07735     	lsrlo	r7, r5, r7
700a3000: 31844007     	orrlo	r4, r4, r7
700a3004: 31a05615     	lsllo	r5, r5, r6
700a3008: e1530004     	cmp	r3, r4
700a300c: 01520005     	cmpeq	r2, r5
700a3010: 3a000001     	blo	0x700a301c <__udivmoddi4+0xe4> @ imm = #0x4
700a3014: e0522005     	subs	r2, r2, r5
700a3018: e0d33004     	sbcs	r3, r3, r4
700a301c: e0b00000     	adcs	r0, r0, r0
700a3020: e0b11001     	adcs	r1, r1, r1
700a3024: e1b050a5     	lsrs	r5, r5, #1
700a3028: e1855f84     	orr	r5, r5, r4, lsl #31
700a302c: e1b040a4     	lsrs	r4, r4, #1
700a3030: e2566001     	subs	r6, r6, #1
700a3034: 5afffff3     	bpl	0x700a3008 <__udivmoddi4+0xd0> @ imm = #-0x34
700a3038: e59d7014     	ldr	r7, [sp, #0x14]
700a303c: e3570000     	cmp	r7, #0
700a3040: 0a000001     	beq	0x700a304c <__udivmoddi4+0x114> @ imm = #0x4
700a3044: e5872000     	str	r2, [r7]
700a3048: e5873004     	str	r3, [r7, #0x4]
700a304c: e8bd80f0     	pop	{r4, r5, r6, r7, pc}

700a3050 <CSL_bcdmaChanOpDecChanStats>:
; {
700a3050: b580         	push	{r7, lr}
700a3052: b088         	sub	sp, #0x20
700a3054: 9007         	str	r0, [sp, #0x1c]
700a3056: 9106         	str	r1, [sp, #0x18]
700a3058: 9205         	str	r2, [sp, #0x14]
700a305a: 9304         	str	r3, [sp, #0x10]
700a305c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a305e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a3060: 9804         	ldr	r0, [sp, #0x10]
700a3062: b920         	cbnz	r0, 0x700a306e <CSL_bcdmaChanOpDecChanStats+0x1e> @ imm = #0x8
700a3064: e7ff         	b	0x700a3066 <CSL_bcdmaChanOpDecChanStats+0x16> @ imm = #-0x2
700a3066: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a306a: 9003         	str	r0, [sp, #0xc]
;     }
700a306c: e078         	b	0x700a3160 <CSL_bcdmaChanOpDecChanStats+0x110> @ imm = #0xf0
;         CSL_BcdmaChanStats *pChanStats = (CSL_BcdmaChanStats *)pOpData;
700a306e: 9804         	ldr	r0, [sp, #0x10]
700a3070: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a3072: 9806         	ldr	r0, [sp, #0x18]
700a3074: 9001         	str	r0, [sp, #0x4]
700a3076: b140         	cbz	r0, 0x700a308a <CSL_bcdmaChanOpDecChanStats+0x3a> @ imm = #0x10
700a3078: e7ff         	b	0x700a307a <CSL_bcdmaChanOpDecChanStats+0x2a> @ imm = #-0x2
700a307a: 9801         	ldr	r0, [sp, #0x4]
700a307c: 2801         	cmp	r0, #0x1
700a307e: d026         	beq	0x700a30ce <CSL_bcdmaChanOpDecChanStats+0x7e> @ imm = #0x4c
700a3080: e7ff         	b	0x700a3082 <CSL_bcdmaChanOpDecChanStats+0x32> @ imm = #-0x2
700a3082: 9801         	ldr	r0, [sp, #0x4]
700a3084: 2802         	cmp	r0, #0x2
700a3086: d044         	beq	0x700a3112 <CSL_bcdmaChanOpDecChanStats+0xc2> @ imm = #0x88
700a3088: e065         	b	0x700a3156 <CSL_bcdmaChanOpDecChanStats+0x106> @ imm = #0xca
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a308a: 9807         	ldr	r0, [sp, #0x1c]
700a308c: 6880         	ldr	r0, [r0, #0x8]
700a308e: 9905         	ldr	r1, [sp, #0x14]
700a3090: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a3094: f500 6080    	add.w	r0, r0, #0x400
700a3098: 9902         	ldr	r1, [sp, #0x8]
700a309a: 6809         	ldr	r1, [r1]
700a309c: f7f7 ff88    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x80f0
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->txPayloadByteCnt );
700a30a0: 9807         	ldr	r0, [sp, #0x1c]
700a30a2: 6880         	ldr	r0, [r0, #0x8]
700a30a4: 9905         	ldr	r1, [sp, #0x14]
700a30a6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a30aa: f500 6081    	add.w	r0, r0, #0x408
700a30ae: 9902         	ldr	r1, [sp, #0x8]
700a30b0: 6849         	ldr	r1, [r1, #0x4]
700a30b2: f7f7 ff7d    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x8106
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->txStartedByteCnt );
700a30b6: 9807         	ldr	r0, [sp, #0x1c]
700a30b8: 6880         	ldr	r0, [r0, #0x8]
700a30ba: 9905         	ldr	r1, [sp, #0x14]
700a30bc: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a30c0: f500 6082    	add.w	r0, r0, #0x410
700a30c4: 9902         	ldr	r1, [sp, #0x8]
700a30c6: 6889         	ldr	r1, [r1, #0x8]
700a30c8: f7f7 ff72    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x811c
;                 break;
700a30cc: e047         	b	0x700a315e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x8e
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a30ce: 9807         	ldr	r0, [sp, #0x1c]
700a30d0: 6900         	ldr	r0, [r0, #0x10]
700a30d2: 9905         	ldr	r1, [sp, #0x14]
700a30d4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a30d8: f500 6080    	add.w	r0, r0, #0x400
700a30dc: 9902         	ldr	r1, [sp, #0x8]
700a30de: 6809         	ldr	r1, [r1]
700a30e0: f7f7 ff66    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x8134
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->txPayloadByteCnt );
700a30e4: 9807         	ldr	r0, [sp, #0x1c]
700a30e6: 6900         	ldr	r0, [r0, #0x10]
700a30e8: 9905         	ldr	r1, [sp, #0x14]
700a30ea: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a30ee: f500 6081    	add.w	r0, r0, #0x408
700a30f2: 9902         	ldr	r1, [sp, #0x8]
700a30f4: 6849         	ldr	r1, [r1, #0x4]
700a30f6: f7f7 ff5b    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x814a
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->txStartedByteCnt );
700a30fa: 9807         	ldr	r0, [sp, #0x1c]
700a30fc: 6900         	ldr	r0, [r0, #0x10]
700a30fe: 9905         	ldr	r1, [sp, #0x14]
700a3100: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a3104: f500 6082    	add.w	r0, r0, #0x410
700a3108: 9902         	ldr	r1, [sp, #0x8]
700a310a: 6889         	ldr	r1, [r1, #0x8]
700a310c: f7f7 ff50    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x8160
;                 break;
700a3110: e025         	b	0x700a315e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x4a
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a3112: 9807         	ldr	r0, [sp, #0x1c]
700a3114: 6980         	ldr	r0, [r0, #0x18]
700a3116: 9905         	ldr	r1, [sp, #0x14]
700a3118: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a311c: f500 6080    	add.w	r0, r0, #0x400
700a3120: 9902         	ldr	r1, [sp, #0x8]
700a3122: 6809         	ldr	r1, [r1]
700a3124: f7f7 ff44    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x8178
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->rxPayloadByteCnt );
700a3128: 9807         	ldr	r0, [sp, #0x1c]
700a312a: 6980         	ldr	r0, [r0, #0x18]
700a312c: 9905         	ldr	r1, [sp, #0x14]
700a312e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a3132: f500 6081    	add.w	r0, r0, #0x408
700a3136: 9902         	ldr	r1, [sp, #0x8]
700a3138: 68c9         	ldr	r1, [r1, #0xc]
700a313a: f7f7 ff39    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x818e
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->rxStartedByteCnt );
700a313e: 9807         	ldr	r0, [sp, #0x1c]
700a3140: 6980         	ldr	r0, [r0, #0x18]
700a3142: 9905         	ldr	r1, [sp, #0x14]
700a3144: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a3148: f500 6082    	add.w	r0, r0, #0x410
700a314c: 9902         	ldr	r1, [sp, #0x8]
700a314e: 6909         	ldr	r1, [r1, #0x10]
700a3150: f7f7 ff2e    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x81a4
;                 break;
700a3154: e003         	b	0x700a315e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x6
700a3156: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a315a: 9003         	str	r0, [sp, #0xc]
;                 break;
700a315c: e7ff         	b	0x700a315e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #-0x2
700a315e: e7ff         	b	0x700a3160 <CSL_bcdmaChanOpDecChanStats+0x110> @ imm = #-0x2
;     return retVal;
700a3160: 9803         	ldr	r0, [sp, #0xc]
700a3162: b008         	add	sp, #0x20
700a3164: bd80         	pop	{r7, pc}
		...
700a316e: 0000         	movs	r0, r0

700a3170 <UART_divisorLatchWrite>:
; {
700a3170: b580         	push	{r7, lr}
700a3172: b08c         	sub	sp, #0x30
700a3174: 900b         	str	r0, [sp, #0x2c]
700a3176: 910a         	str	r1, [sp, #0x28]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a3178: 980b         	ldr	r0, [sp, #0x2c]
700a317a: 21bf         	movs	r1, #0xbf
700a317c: 9102         	str	r1, [sp, #0x8]
700a317e: f007 fd0f    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #0x7a1e
700a3182: 9007         	str	r0, [sp, #0x1c]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a3184: 980b         	ldr	r0, [sp, #0x2c]
700a3186: 3008         	adds	r0, #0x8
700a3188: 2110         	movs	r1, #0x10
700a318a: 9103         	str	r1, [sp, #0xc]
700a318c: 2204         	movs	r2, #0x4
700a318e: 9204         	str	r2, [sp, #0x10]
700a3190: f00a fb1e    	bl	0x700ad7d0 <HW_RD_FIELD32_RAW> @ imm = #0xa63c
700a3194: 9903         	ldr	r1, [sp, #0xc]
700a3196: 9a04         	ldr	r2, [sp, #0x10]
700a3198: 9009         	str	r0, [sp, #0x24]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a319a: 980b         	ldr	r0, [sp, #0x2c]
700a319c: 3008         	adds	r0, #0x8
700a319e: 2301         	movs	r3, #0x1
700a31a0: f009 fc96    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x992c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a31a4: 980b         	ldr	r0, [sp, #0x2c]
700a31a6: 300c         	adds	r0, #0xc
700a31a8: 9907         	ldr	r1, [sp, #0x1c]
700a31aa: f00a ff21    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0xae42
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700a31ae: 980b         	ldr	r0, [sp, #0x2c]
700a31b0: 217f         	movs	r1, #0x7f
700a31b2: 9101         	str	r1, [sp, #0x4]
700a31b4: f007 fcf4    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #0x79e8
700a31b8: 9903         	ldr	r1, [sp, #0xc]
700a31ba: 9a04         	ldr	r2, [sp, #0x10]
700a31bc: 9007         	str	r0, [sp, #0x1c]
;     sleepMdBitVal = HW_RD_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE);
700a31be: 980b         	ldr	r0, [sp, #0x2c]
700a31c0: 3004         	adds	r0, #0x4
700a31c2: f00a fb05    	bl	0x700ad7d0 <HW_RD_FIELD32_RAW> @ imm = #0xa60a
700a31c6: 9903         	ldr	r1, [sp, #0xc]
700a31c8: 9a04         	ldr	r2, [sp, #0x10]
700a31ca: 9008         	str	r0, [sp, #0x20]
;     HW_WR_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE, 0U);
700a31cc: 980b         	ldr	r0, [sp, #0x2c]
700a31ce: 3004         	adds	r0, #0x4
700a31d0: 2300         	movs	r3, #0x0
700a31d2: f009 fc7d    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x98fa
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a31d6: 980b         	ldr	r0, [sp, #0x2c]
700a31d8: 300c         	adds	r0, #0xc
700a31da: 9907         	ldr	r1, [sp, #0x1c]
700a31dc: f00a ff08    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0xae10
700a31e0: 9902         	ldr	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a31e2: 980b         	ldr	r0, [sp, #0x2c]
700a31e4: f007 fcdc    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #0x79b8
700a31e8: 9007         	str	r0, [sp, #0x1c]
;     divRegVal  = HW_RD_REG32(baseAddr + UART_DLL) & 0xFFU;
700a31ea: 980b         	ldr	r0, [sp, #0x2c]
700a31ec: f00a fef8    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0xadf0
700a31f0: b2c0         	uxtb	r0, r0
700a31f2: 9005         	str	r0, [sp, #0x14]
;     divRegVal |= (HW_RD_REG32(baseAddr + UART_DLH) & 0x3FU) << 8;
700a31f4: 980b         	ldr	r0, [sp, #0x2c]
700a31f6: 3004         	adds	r0, #0x4
700a31f8: f00a fef2    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0xade4
700a31fc: f000 013f    	and	r1, r0, #0x3f
700a3200: 9805         	ldr	r0, [sp, #0x14]
700a3202: ea40 2001    	orr.w	r0, r0, r1, lsl #8
700a3206: 9005         	str	r0, [sp, #0x14]
;     operMode = UART_operatingModeSelect(baseAddr,
700a3208: 980b         	ldr	r0, [sp, #0x2c]
700a320a: 2107         	movs	r1, #0x7
700a320c: f00a f850    	bl	0x700ad2b0 <UART_operatingModeSelect> @ imm = #0xa0a0
700a3210: 9006         	str	r0, [sp, #0x18]
;     HW_WR_REG32(baseAddr + UART_DLL, divisorValue & 0x00FFU);
700a3212: 980b         	ldr	r0, [sp, #0x2c]
700a3214: f89d 1028    	ldrb.w	r1, [sp, #0x28]
700a3218: f00a feea    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0xadd4
;     HW_WR_REG32(baseAddr + UART_DLH, (divisorValue & 0x3F00U) >> 8);
700a321c: 980b         	ldr	r0, [sp, #0x2c]
700a321e: 3004         	adds	r0, #0x4
700a3220: 990a         	ldr	r1, [sp, #0x28]
700a3222: f3c1 2105    	ubfx	r1, r1, #0x8, #0x6
700a3226: f00a fee3    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0xadc6
;     (void) UART_operatingModeSelect(baseAddr, operMode);
700a322a: 980b         	ldr	r0, [sp, #0x2c]
700a322c: 9906         	ldr	r1, [sp, #0x18]
700a322e: f00a f83f    	bl	0x700ad2b0 <UART_operatingModeSelect> @ imm = #0xa07e
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a3232: 980b         	ldr	r0, [sp, #0x2c]
700a3234: 300c         	adds	r0, #0xc
700a3236: 9907         	ldr	r1, [sp, #0x1c]
700a3238: f00a feda    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0xadb4
700a323c: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700a323e: 980b         	ldr	r0, [sp, #0x2c]
700a3240: f007 fcae    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #0x795c
700a3244: 9903         	ldr	r1, [sp, #0xc]
700a3246: 9a04         	ldr	r2, [sp, #0x10]
700a3248: 9007         	str	r0, [sp, #0x1c]
;     HW_WR_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE, sleepMdBitVal);
700a324a: 980b         	ldr	r0, [sp, #0x2c]
700a324c: 3004         	adds	r0, #0x4
700a324e: 9b08         	ldr	r3, [sp, #0x20]
700a3250: f009 fc3e    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x987c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a3254: 980b         	ldr	r0, [sp, #0x2c]
700a3256: 300c         	adds	r0, #0xc
700a3258: 9907         	ldr	r1, [sp, #0x1c]
700a325a: f00a fec9    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0xad92
700a325e: 9902         	ldr	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a3260: 980b         	ldr	r0, [sp, #0x2c]
700a3262: f007 fc9d    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #0x793a
700a3266: 9903         	ldr	r1, [sp, #0xc]
700a3268: 9a04         	ldr	r2, [sp, #0x10]
700a326a: 9007         	str	r0, [sp, #0x1c]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a326c: 980b         	ldr	r0, [sp, #0x2c]
700a326e: 3008         	adds	r0, #0x8
700a3270: 9b09         	ldr	r3, [sp, #0x24]
700a3272: f009 fc2d    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x985a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a3276: 980b         	ldr	r0, [sp, #0x2c]
700a3278: 300c         	adds	r0, #0xc
700a327a: 9907         	ldr	r1, [sp, #0x1c]
700a327c: f00a feb8    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0xad70
;     return divRegVal;
700a3280: 9805         	ldr	r0, [sp, #0x14]
700a3282: b00c         	add	sp, #0x30
700a3284: bd80         	pop	{r7, pc}
		...
700a328e: 0000         	movs	r0, r0

700a3290 <_ntoa_long>:
; {
700a3290: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
700a3294: b098         	sub	sp, #0x60
700a3296: 4684         	mov	r12, r0
700a3298: 9823         	ldr	r0, [sp, #0x8c]
700a329a: 9822         	ldr	r0, [sp, #0x88]
700a329c: 9821         	ldr	r0, [sp, #0x84]
700a329e: 9820         	ldr	r0, [sp, #0x80]
700a32a0: 981f         	ldr	r0, [sp, #0x7c]
700a32a2: f8dd e078    	ldr.w	lr, [sp, #0x78]
700a32a6: f8cd c05c    	str.w	r12, [sp, #0x5c]
700a32aa: 9116         	str	r1, [sp, #0x58]
700a32ac: 9215         	str	r2, [sp, #0x54]
700a32ae: 9314         	str	r3, [sp, #0x50]
700a32b0: f88d 004f    	strb.w	r0, [sp, #0x4f]
700a32b4: 2000         	movs	r0, #0x0
;   size_t len = 0U;
700a32b6: 900a         	str	r0, [sp, #0x28]
;   if (!value) {
700a32b8: 981e         	ldr	r0, [sp, #0x78]
700a32ba: b928         	cbnz	r0, 0x700a32c8 <_ntoa_long+0x38> @ imm = #0xa
700a32bc: e7ff         	b	0x700a32be <_ntoa_long+0x2e> @ imm = #-0x2
;     flags &= ~FLAGS_HASH;
700a32be: 9823         	ldr	r0, [sp, #0x8c]
700a32c0: f020 0010    	bic	r0, r0, #0x10
700a32c4: 9023         	str	r0, [sp, #0x8c]
;   }
700a32c6: e7ff         	b	0x700a32c8 <_ntoa_long+0x38> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION) || value) {
700a32c8: f89d 008d    	ldrb.w	r0, [sp, #0x8d]
700a32cc: 0740         	lsls	r0, r0, #0x1d
700a32ce: 2800         	cmp	r0, #0x0
700a32d0: d504         	bpl	0x700a32dc <_ntoa_long+0x4c> @ imm = #0x8
700a32d2: e7ff         	b	0x700a32d4 <_ntoa_long+0x44> @ imm = #-0x2
700a32d4: 981e         	ldr	r0, [sp, #0x78]
700a32d6: 2800         	cmp	r0, #0x0
700a32d8: d03f         	beq	0x700a335a <_ntoa_long+0xca> @ imm = #0x7e
700a32da: e7ff         	b	0x700a32dc <_ntoa_long+0x4c> @ imm = #-0x2
;     do {
700a32dc: e7ff         	b	0x700a32de <_ntoa_long+0x4e> @ imm = #-0x2
;       const char digit = (char)(value % base);
700a32de: 9a1e         	ldr	r2, [sp, #0x78]
700a32e0: 9920         	ldr	r1, [sp, #0x80]
700a32e2: fbb2 f0f1    	udiv	r0, r2, r1
700a32e6: fb00 2011    	mls	r0, r0, r1, r2
700a32ea: f88d 0027    	strb.w	r0, [sp, #0x27]
;       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
700a32ee: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a32f2: 2809         	cmp	r0, #0x9
700a32f4: dc05         	bgt	0x700a3302 <_ntoa_long+0x72> @ imm = #0xa
700a32f6: e7ff         	b	0x700a32f8 <_ntoa_long+0x68> @ imm = #-0x2
700a32f8: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a32fc: 3030         	adds	r0, #0x30
700a32fe: 9008         	str	r0, [sp, #0x20]
700a3300: e00c         	b	0x700a331c <_ntoa_long+0x8c> @ imm = #0x18
700a3302: f89d 008c    	ldrb.w	r0, [sp, #0x8c]
700a3306: 0681         	lsls	r1, r0, #0x1a
700a3308: 2061         	movs	r0, #0x61
700a330a: 2900         	cmp	r1, #0x0
700a330c: bf48         	it	mi
700a330e: 2041         	movmi	r0, #0x41
700a3310: f89d 1027    	ldrb.w	r1, [sp, #0x27]
700a3314: 4408         	add	r0, r1
700a3316: 380a         	subs	r0, #0xa
700a3318: 9008         	str	r0, [sp, #0x20]
700a331a: e7ff         	b	0x700a331c <_ntoa_long+0x8c> @ imm = #-0x2
700a331c: 9808         	ldr	r0, [sp, #0x20]
700a331e: 9a0a         	ldr	r2, [sp, #0x28]
700a3320: 1c51         	adds	r1, r2, #0x1
700a3322: 910a         	str	r1, [sp, #0x28]
700a3324: f10d 012f    	add.w	r1, sp, #0x2f
700a3328: 5488         	strb	r0, [r1, r2]
;       value /= base;
700a332a: 9920         	ldr	r1, [sp, #0x80]
700a332c: 981e         	ldr	r0, [sp, #0x78]
700a332e: fbb0 f0f1    	udiv	r0, r0, r1
700a3332: 901e         	str	r0, [sp, #0x78]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a3334: e7ff         	b	0x700a3336 <_ntoa_long+0xa6> @ imm = #-0x2
700a3336: 991e         	ldr	r1, [sp, #0x78]
700a3338: 2000         	movs	r0, #0x0
700a333a: 9007         	str	r0, [sp, #0x1c]
700a333c: b139         	cbz	r1, 0x700a334e <_ntoa_long+0xbe> @ imm = #0xe
700a333e: e7ff         	b	0x700a3340 <_ntoa_long+0xb0> @ imm = #-0x2
700a3340: 990a         	ldr	r1, [sp, #0x28]
700a3342: 2000         	movs	r0, #0x0
700a3344: 2920         	cmp	r1, #0x20
700a3346: bf38         	it	lo
700a3348: 2001         	movlo	r0, #0x1
700a334a: 9007         	str	r0, [sp, #0x1c]
700a334c: e7ff         	b	0x700a334e <_ntoa_long+0xbe> @ imm = #-0x2
700a334e: 9807         	ldr	r0, [sp, #0x1c]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a3350: 07c0         	lsls	r0, r0, #0x1f
700a3352: 2800         	cmp	r0, #0x0
700a3354: d1c3         	bne	0x700a32de <_ntoa_long+0x4e> @ imm = #-0x7a
700a3356: e7ff         	b	0x700a3358 <_ntoa_long+0xc8> @ imm = #-0x2
;   }
700a3358: e7ff         	b	0x700a335a <_ntoa_long+0xca> @ imm = #-0x2
;   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
700a335a: 9817         	ldr	r0, [sp, #0x5c]
700a335c: 9916         	ldr	r1, [sp, #0x58]
700a335e: 9a15         	ldr	r2, [sp, #0x54]
700a3360: 9b14         	ldr	r3, [sp, #0x50]
700a3362: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a3366: 9d20         	ldr	r5, [sp, #0x80]
700a3368: 9e21         	ldr	r6, [sp, #0x84]
700a336a: 9f22         	ldr	r7, [sp, #0x88]
700a336c: f8dd 808c    	ldr.w	r8, [sp, #0x8c]
700a3370: f89d 404f    	ldrb.w	r4, [sp, #0x4f]
700a3374: 46ee         	mov	lr, sp
700a3376: f8ce 8018    	str.w	r8, [lr, #0x18]
700a337a: f8ce 7014    	str.w	r7, [lr, #0x14]
700a337e: f8ce 6010    	str.w	r6, [lr, #0x10]
700a3382: f8ce 500c    	str.w	r5, [lr, #0xc]
700a3386: f004 0401    	and	r4, r4, #0x1
700a338a: f8ce 4008    	str.w	r4, [lr, #0x8]
700a338e: f8ce c004    	str.w	r12, [lr, #0x4]
700a3392: f10d 0c2f    	add.w	r12, sp, #0x2f
700a3396: f8ce c000    	str.w	r12, [lr]
700a339a: f7f9 ff21    	bl	0x7009d1e0 <_ntoa_format> @ imm = #-0x61be
700a339e: b018         	add	sp, #0x60
700a33a0: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
		...

700a33b0 <prvInitialiseNewTask>:
;     const MemoryRegion_t *const xRegions) {
700a33b0: b580         	push	{r7, lr}
700a33b2: b088         	sub	sp, #0x20
700a33b4: f8dd c034    	ldr.w	r12, [sp, #0x34]
700a33b8: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a33bc: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a33c0: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a33c4: 9007         	str	r0, [sp, #0x1c]
700a33c6: 9106         	str	r1, [sp, #0x18]
700a33c8: 9205         	str	r2, [sp, #0x14]
700a33ca: 9304         	str	r3, [sp, #0x10]
;     (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE,
700a33cc: 980c         	ldr	r0, [sp, #0x30]
700a33ce: 6b00         	ldr	r0, [r0, #0x30]
;                  (size_t)ulStackDepth * sizeof(StackType_t));
700a33d0: 9905         	ldr	r1, [sp, #0x14]
700a33d2: 0089         	lsls	r1, r1, #0x2
700a33d4: 22a5         	movs	r2, #0xa5
;     (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE,
700a33d6: f00a ee1c    	blx	0x700ae010 <__aeabi_memset8> @ imm = #0xac38
;     pxTopOfStack = &(pxNewTCB->pxStack[ulStackDepth - (uint32_t)1]);
700a33da: 980c         	ldr	r0, [sp, #0x30]
700a33dc: 6b00         	ldr	r0, [r0, #0x30]
700a33de: 9905         	ldr	r1, [sp, #0x14]
700a33e0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a33e4: 3804         	subs	r0, #0x4
700a33e6: 9003         	str	r0, [sp, #0xc]
;              *)(((portPOINTER_SIZE_TYPE)pxTopOfStack) &
700a33e8: 9803         	ldr	r0, [sp, #0xc]
700a33ea: f020 0007    	bic	r0, r0, #0x7
;     pxTopOfStack =
700a33ee: 9003         	str	r0, [sp, #0xc]
;   if (pcName != NULL) {
700a33f0: 9806         	ldr	r0, [sp, #0x18]
700a33f2: b1f8         	cbz	r0, 0x700a3434 <prvInitialiseNewTask+0x84> @ imm = #0x3e
700a33f4: e7ff         	b	0x700a33f6 <prvInitialiseNewTask+0x46> @ imm = #-0x2
700a33f6: 2000         	movs	r0, #0x0
;     for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
700a33f8: 9002         	str	r0, [sp, #0x8]
700a33fa: e7ff         	b	0x700a33fc <prvInitialiseNewTask+0x4c> @ imm = #-0x2
700a33fc: 9802         	ldr	r0, [sp, #0x8]
700a33fe: 281f         	cmp	r0, #0x1f
700a3400: d813         	bhi	0x700a342a <prvInitialiseNewTask+0x7a> @ imm = #0x26
700a3402: e7ff         	b	0x700a3404 <prvInitialiseNewTask+0x54> @ imm = #-0x2
;       pxNewTCB->pcTaskName[x] = pcName[x];
700a3404: 9806         	ldr	r0, [sp, #0x18]
700a3406: 9a02         	ldr	r2, [sp, #0x8]
700a3408: 5c80         	ldrb	r0, [r0, r2]
700a340a: 990c         	ldr	r1, [sp, #0x30]
700a340c: 4411         	add	r1, r2
700a340e: f881 0034    	strb.w	r0, [r1, #0x34]
;       if (pcName[x] == (char)0x00) {
700a3412: 9806         	ldr	r0, [sp, #0x18]
700a3414: 9902         	ldr	r1, [sp, #0x8]
700a3416: 5c40         	ldrb	r0, [r0, r1]
700a3418: b908         	cbnz	r0, 0x700a341e <prvInitialiseNewTask+0x6e> @ imm = #0x2
700a341a: e7ff         	b	0x700a341c <prvInitialiseNewTask+0x6c> @ imm = #-0x2
;         break;
700a341c: e005         	b	0x700a342a <prvInitialiseNewTask+0x7a> @ imm = #0xa
700a341e: e7ff         	b	0x700a3420 <prvInitialiseNewTask+0x70> @ imm = #-0x2
;     }
700a3420: e7ff         	b	0x700a3422 <prvInitialiseNewTask+0x72> @ imm = #-0x2
;     for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
700a3422: 9802         	ldr	r0, [sp, #0x8]
700a3424: 3001         	adds	r0, #0x1
700a3426: 9002         	str	r0, [sp, #0x8]
700a3428: e7e8         	b	0x700a33fc <prvInitialiseNewTask+0x4c> @ imm = #-0x30
;     pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
700a342a: 990c         	ldr	r1, [sp, #0x30]
700a342c: 2000         	movs	r0, #0x0
700a342e: f881 0053    	strb.w	r0, [r1, #0x53]
;   } else {
700a3432: e004         	b	0x700a343e <prvInitialiseNewTask+0x8e> @ imm = #0x8
;     pxNewTCB->pcTaskName[0] = 0x00;
700a3434: 990c         	ldr	r1, [sp, #0x30]
700a3436: 2000         	movs	r0, #0x0
700a3438: f881 0034    	strb.w	r0, [r1, #0x34]
700a343c: e7ff         	b	0x700a343e <prvInitialiseNewTask+0x8e> @ imm = #-0x2
;   if (uxPriority >= (UBaseType_t)configMAX_PRIORITIES) {
700a343e: 980a         	ldr	r0, [sp, #0x28]
700a3440: 2820         	cmp	r0, #0x20
700a3442: d303         	blo	0x700a344c <prvInitialiseNewTask+0x9c> @ imm = #0x6
700a3444: e7ff         	b	0x700a3446 <prvInitialiseNewTask+0x96> @ imm = #-0x2
700a3446: 201f         	movs	r0, #0x1f
;     uxPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
700a3448: 900a         	str	r0, [sp, #0x28]
;   } else {
700a344a: e000         	b	0x700a344e <prvInitialiseNewTask+0x9e> @ imm = #0x0
700a344c: e7ff         	b	0x700a344e <prvInitialiseNewTask+0x9e> @ imm = #-0x2
;   pxNewTCB->uxPriority = uxPriority;
700a344e: 980a         	ldr	r0, [sp, #0x28]
700a3450: 990c         	ldr	r1, [sp, #0x30]
700a3452: 62c8         	str	r0, [r1, #0x2c]
;     pxNewTCB->uxBasePriority = uxPriority;
700a3454: 980a         	ldr	r0, [sp, #0x28]
700a3456: 990c         	ldr	r1, [sp, #0x30]
700a3458: 6608         	str	r0, [r1, #0x60]
;     pxNewTCB->uxMutexesHeld = 0;
700a345a: 990c         	ldr	r1, [sp, #0x30]
700a345c: 2000         	movs	r0, #0x0
700a345e: 9001         	str	r0, [sp, #0x4]
700a3460: 6648         	str	r0, [r1, #0x64]
;   vListInitialiseItem(&(pxNewTCB->xStateListItem));
700a3462: 980c         	ldr	r0, [sp, #0x30]
700a3464: 3004         	adds	r0, #0x4
700a3466: f00a fdf3    	bl	0x700ae050 <vListInitialiseItem> @ imm = #0xabe6
;   vListInitialiseItem(&(pxNewTCB->xEventListItem));
700a346a: 980c         	ldr	r0, [sp, #0x30]
700a346c: 3018         	adds	r0, #0x18
700a346e: f00a fdef    	bl	0x700ae050 <vListInitialiseItem> @ imm = #0xabde
700a3472: 9801         	ldr	r0, [sp, #0x4]
;   listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
700a3474: 990c         	ldr	r1, [sp, #0x30]
700a3476: 6109         	str	r1, [r1, #0x10]
;   listSET_LIST_ITEM_VALUE(
700a3478: 990a         	ldr	r1, [sp, #0x28]
700a347a: f1c1 0120    	rsb.w	r1, r1, #0x20
700a347e: 9a0c         	ldr	r2, [sp, #0x30]
700a3480: 6191         	str	r1, [r2, #0x18]
;   listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
700a3482: 990c         	ldr	r1, [sp, #0x30]
700a3484: 6249         	str	r1, [r1, #0x24]
;     pxNewTCB->uxCriticalNesting = (UBaseType_t)0U;
700a3486: 990c         	ldr	r1, [sp, #0x30]
700a3488: 6548         	str	r0, [r1, #0x54]
;     pxNewTCB->pxTaskTag = NULL;
700a348a: 990c         	ldr	r1, [sp, #0x30]
700a348c: 6688         	str	r0, [r1, #0x68]
;     memset((void *)&(pxNewTCB->pvThreadLocalStoragePointers[0]), 0x00,
700a348e: 990c         	ldr	r1, [sp, #0x30]
700a3490: 6788         	str	r0, [r1, #0x78]
700a3492: 6748         	str	r0, [r1, #0x74]
700a3494: 6708         	str	r0, [r1, #0x70]
700a3496: 66c8         	str	r0, [r1, #0x6c]
;     memset((void *)&(pxNewTCB->ulNotifiedValue[0]), 0x00,
700a3498: 990c         	ldr	r1, [sp, #0x30]
700a349a: 67c8         	str	r0, [r1, #0x7c]
;     memset((void *)&(pxNewTCB->ucNotifyState[0]), 0x00,
700a349c: 990c         	ldr	r1, [sp, #0x30]
700a349e: f881 0080    	strb.w	r0, [r1, #0x80]
;           pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
700a34a2: 9803         	ldr	r0, [sp, #0xc]
700a34a4: 9907         	ldr	r1, [sp, #0x1c]
700a34a6: 9a04         	ldr	r2, [sp, #0x10]
700a34a8: f7fe fc8a    	bl	0x700a1dc0 <pxPortInitialiseStack> @ imm = #-0x16ec
;       pxNewTCB->pxTopOfStack =
700a34ac: 990c         	ldr	r1, [sp, #0x30]
700a34ae: 6008         	str	r0, [r1]
;   if (pxCreatedTask != NULL) {
700a34b0: 980b         	ldr	r0, [sp, #0x2c]
700a34b2: b120         	cbz	r0, 0x700a34be <prvInitialiseNewTask+0x10e> @ imm = #0x8
700a34b4: e7ff         	b	0x700a34b6 <prvInitialiseNewTask+0x106> @ imm = #-0x2
;     *pxCreatedTask = (TaskHandle_t)pxNewTCB;
700a34b6: 980c         	ldr	r0, [sp, #0x30]
700a34b8: 990b         	ldr	r1, [sp, #0x2c]
700a34ba: 6008         	str	r0, [r1]
;   } else {
700a34bc: e000         	b	0x700a34c0 <prvInitialiseNewTask+0x110> @ imm = #0x0
700a34be: e7ff         	b	0x700a34c0 <prvInitialiseNewTask+0x110> @ imm = #-0x2
; }
700a34c0: b008         	add	sp, #0x20
700a34c2: bd80         	pop	{r7, pc}
		...

700a34d0 <Sciclient_pmSetModuleClkFreq>:
; {
700a34d0: b580         	push	{r7, lr}
700a34d2: b09a         	sub	sp, #0x68
700a34d4: f8dd c074    	ldr.w	r12, [sp, #0x74]
700a34d8: f8dd c070    	ldr.w	r12, [sp, #0x70]
700a34dc: 9019         	str	r0, [sp, #0x64]
700a34de: 9118         	str	r1, [sp, #0x60]
700a34e0: 9317         	str	r3, [sp, #0x5c]
700a34e2: 9216         	str	r2, [sp, #0x58]
700a34e4: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a34e6: 9015         	str	r0, [sp, #0x54]
;     request.device         = (uint32_t) moduleId;
700a34e8: 9819         	ldr	r0, [sp, #0x64]
700a34ea: 900c         	str	r0, [sp, #0x30]
;     request.min_freq_hz    = (uint64_t) freqHz;
700a34ec: 9816         	ldr	r0, [sp, #0x58]
700a34ee: 9917         	ldr	r1, [sp, #0x5c]
700a34f0: 910e         	str	r1, [sp, #0x38]
700a34f2: 900d         	str	r0, [sp, #0x34]
;     request.target_freq_hz = (uint64_t) freqHz;
700a34f4: 9816         	ldr	r0, [sp, #0x58]
700a34f6: 9917         	ldr	r1, [sp, #0x5c]
700a34f8: 9110         	str	r1, [sp, #0x40]
700a34fa: 900f         	str	r0, [sp, #0x3c]
;     request.max_freq_hz    = (uint64_t) freqHz;
700a34fc: 9816         	ldr	r0, [sp, #0x58]
700a34fe: 9917         	ldr	r1, [sp, #0x5c]
700a3500: 9112         	str	r1, [sp, #0x48]
700a3502: 9011         	str	r0, [sp, #0x44]
;     if((freqHz%10U) != 0U)
700a3504: 9b16         	ldr	r3, [sp, #0x58]
700a3506: 9817         	ldr	r0, [sp, #0x5c]
700a3508: f64c 41cd    	movw	r1, #0xcccd
700a350c: f6cc 41cc    	movt	r1, #0xcccc
700a3510: fba3 2e01    	umull	r2, lr, r3, r1
700a3514: f04f 3ccc    	mov.w	r12, #0xcccccccc
700a3518: fb03 e30c    	mla	r3, r3, r12, lr
700a351c: fb00 3101    	mla	r1, r0, r1, r3
700a3520: ea4f 70c2    	lsl.w	r0, r2, #0x1f
700a3524: ea40 0051    	orr.w	r0, r0, r1, lsr #1
700a3528: ea4f 71c1    	lsl.w	r1, r1, #0x1f
700a352c: ea41 0152    	orr.w	r1, r1, r2, lsr #1
700a3530: f649 129a    	movw	r2, #0x999a
700a3534: f6c9 1299    	movt	r2, #0x9999
700a3538: 1a89         	subs	r1, r1, r2
700a353a: f649 1199    	movw	r1, #0x9999
700a353e: f6c1 1199    	movt	r1, #0x1999
700a3542: 4188         	sbcs	r0, r1
700a3544: d316         	blo	0x700a3574 <Sciclient_pmSetModuleClkFreq+0xa4> @ imm = #0x2c
700a3546: e7ff         	b	0x700a3548 <Sciclient_pmSetModuleClkFreq+0x78> @ imm = #-0x2
;         request.min_freq_hz = (uint64_t)(freqHz-(freqHz%10U));
700a3548: 9816         	ldr	r0, [sp, #0x58]
700a354a: 9001         	str	r0, [sp, #0x4]
700a354c: 9917         	ldr	r1, [sp, #0x5c]
700a354e: 9100         	str	r1, [sp]
700a3550: 220a         	movs	r2, #0xa
700a3552: 2300         	movs	r3, #0x0
700a3554: f00a e89e    	blx	0x700ad694 <__aeabi_uldivmod> @ imm = #0xa13c
700a3558: 9800         	ldr	r0, [sp]
700a355a: 9901         	ldr	r1, [sp, #0x4]
700a355c: 1a89         	subs	r1, r1, r2
700a355e: 4198         	sbcs	r0, r3
700a3560: 910d         	str	r1, [sp, #0x34]
700a3562: 900e         	str	r0, [sp, #0x38]
;         request.max_freq_hz = (uint64_t)(request.min_freq_hz + 10UL);
700a3564: 990d         	ldr	r1, [sp, #0x34]
700a3566: 980e         	ldr	r0, [sp, #0x38]
700a3568: 310a         	adds	r1, #0xa
700a356a: f140 0000    	adc	r0, r0, #0x0
700a356e: 9111         	str	r1, [sp, #0x44]
700a3570: 9012         	str	r0, [sp, #0x48]
;     }
700a3572: e7ff         	b	0x700a3574 <Sciclient_pmSetModuleClkFreq+0xa4> @ imm = #-0x2
;     if (clockId >= 255U)
700a3574: 9818         	ldr	r0, [sp, #0x60]
700a3576: 28ff         	cmp	r0, #0xff
700a3578: d307         	blo	0x700a358a <Sciclient_pmSetModuleClkFreq+0xba> @ imm = #0xe
700a357a: e7ff         	b	0x700a357c <Sciclient_pmSetModuleClkFreq+0xac> @ imm = #-0x2
;         request.clk32 = clockId;
700a357c: 9818         	ldr	r0, [sp, #0x60]
700a357e: f8cd 004d    	str.w	r0, [sp, #0x4d]
700a3582: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a3584: f88d 004c    	strb.w	r0, [sp, #0x4c]
;     }
700a3588: e003         	b	0x700a3592 <Sciclient_pmSetModuleClkFreq+0xc2> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a358a: 9818         	ldr	r0, [sp, #0x60]
700a358c: f88d 004c    	strb.w	r0, [sp, #0x4c]
700a3590: e7ff         	b	0x700a3592 <Sciclient_pmSetModuleClkFreq+0xc2> @ imm = #-0x2
700a3592: f44f 7086    	mov.w	r0, #0x10c
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_FREQ;
700a3596: f8ad 0014    	strh.w	r0, [sp, #0x14]
;     reqParam.flags          = (uint32_t)(TISCI_MSG_FLAG_AOP | additionalFlag);
700a359a: 981c         	ldr	r0, [sp, #0x70]
700a359c: f040 0002    	orr	r0, r0, #0x2
700a35a0: 9006         	str	r0, [sp, #0x18]
700a35a2: a80a         	add	r0, sp, #0x28
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a35a4: 9007         	str	r0, [sp, #0x1c]
700a35a6: 2029         	movs	r0, #0x29
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a35a8: 9008         	str	r0, [sp, #0x20]
;     reqParam.timeout        = (uint32_t) timeout;
700a35aa: 981d         	ldr	r0, [sp, #0x74]
700a35ac: 9009         	str	r0, [sp, #0x24]
700a35ae: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a35b0: 9002         	str	r0, [sp, #0x8]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a35b2: 9003         	str	r0, [sp, #0xc]
;     respParam.respPayloadSize = (uint32_t) 0;
700a35b4: 9004         	str	r0, [sp, #0x10]
700a35b6: a805         	add	r0, sp, #0x14
700a35b8: a902         	add	r1, sp, #0x8
;     retVal = Sciclient_service(&reqParam, &respParam);
700a35ba: f7f8 fd31    	bl	0x7009c020 <Sciclient_service> @ imm = #-0x759e
700a35be: 9015         	str	r0, [sp, #0x54]
;     if((retVal != SystemP_SUCCESS) ||
700a35c0: 9815         	ldr	r0, [sp, #0x54]
700a35c2: b930         	cbnz	r0, 0x700a35d2 <Sciclient_pmSetModuleClkFreq+0x102> @ imm = #0xc
700a35c4: e7ff         	b	0x700a35c6 <Sciclient_pmSetModuleClkFreq+0xf6> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a35c6: 9802         	ldr	r0, [sp, #0x8]
700a35c8: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a35cc: 2802         	cmp	r0, #0x2
700a35ce: d004         	beq	0x700a35da <Sciclient_pmSetModuleClkFreq+0x10a> @ imm = #0x8
700a35d0: e7ff         	b	0x700a35d2 <Sciclient_pmSetModuleClkFreq+0x102> @ imm = #-0x2
700a35d2: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a35d6: 9015         	str	r0, [sp, #0x54]
;     }
700a35d8: e7ff         	b	0x700a35da <Sciclient_pmSetModuleClkFreq+0x10a> @ imm = #-0x2
;     return retVal;
700a35da: 9815         	ldr	r0, [sp, #0x54]
700a35dc: b01a         	add	sp, #0x68
700a35de: bd80         	pop	{r7, pc}

700a35e0 <prvAddNewTaskToReadyList>:
; static void prvAddNewTaskToReadyList(TCB_t *pxNewTCB) {
700a35e0: b580         	push	{r7, lr}
700a35e2: b082         	sub	sp, #0x8
700a35e4: 9001         	str	r0, [sp, #0x4]
;   taskENTER_CRITICAL();
700a35e6: f009 faf3    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0x95e6
;     uxCurrentNumberOfTasks++;
700a35ea: f640 51cc    	movw	r1, #0xdcc
700a35ee: f2c7 010b    	movt	r1, #0x700b
700a35f2: 6808         	ldr	r0, [r1]
700a35f4: 3001         	adds	r0, #0x1
700a35f6: 6008         	str	r0, [r1]
;     if (pxCurrentTCB == NULL) {
700a35f8: f640 50ac    	movw	r0, #0xdac
700a35fc: f2c7 000b    	movt	r0, #0x700b
700a3600: 6800         	ldr	r0, [r0]
700a3602: b998         	cbnz	r0, 0x700a362c <prvAddNewTaskToReadyList+0x4c> @ imm = #0x26
700a3604: e7ff         	b	0x700a3606 <prvAddNewTaskToReadyList+0x26> @ imm = #-0x2
;       pxCurrentTCB = pxNewTCB;
700a3606: 9801         	ldr	r0, [sp, #0x4]
700a3608: f640 51ac    	movw	r1, #0xdac
700a360c: f2c7 010b    	movt	r1, #0x700b
700a3610: 6008         	str	r0, [r1]
;       if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
700a3612: f640 50cc    	movw	r0, #0xdcc
700a3616: f2c7 000b    	movt	r0, #0x700b
700a361a: 6800         	ldr	r0, [r0]
700a361c: 2801         	cmp	r0, #0x1
700a361e: d103         	bne	0x700a3628 <prvAddNewTaskToReadyList+0x48> @ imm = #0x6
700a3620: e7ff         	b	0x700a3622 <prvAddNewTaskToReadyList+0x42> @ imm = #-0x2
;         prvInitialiseTaskLists();
700a3622: f004 fe5d    	bl	0x700a82e0 <prvInitialiseTaskLists> @ imm = #0x4cba
;       } else {
700a3626: e000         	b	0x700a362a <prvAddNewTaskToReadyList+0x4a> @ imm = #0x0
700a3628: e7ff         	b	0x700a362a <prvAddNewTaskToReadyList+0x4a> @ imm = #-0x2
;     } else {
700a362a: e01c         	b	0x700a3666 <prvAddNewTaskToReadyList+0x86> @ imm = #0x38
;       if (xSchedulerRunning == pdFALSE) {
700a362c: f640 50f0    	movw	r0, #0xdf0
700a3630: f2c7 000b    	movt	r0, #0x700b
700a3634: 6800         	ldr	r0, [r0]
700a3636: b9a0         	cbnz	r0, 0x700a3662 <prvAddNewTaskToReadyList+0x82> @ imm = #0x28
700a3638: e7ff         	b	0x700a363a <prvAddNewTaskToReadyList+0x5a> @ imm = #-0x2
;         if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
700a363a: f640 50ac    	movw	r0, #0xdac
700a363e: f2c7 000b    	movt	r0, #0x700b
700a3642: 6800         	ldr	r0, [r0]
700a3644: 6ac0         	ldr	r0, [r0, #0x2c]
700a3646: 9901         	ldr	r1, [sp, #0x4]
700a3648: 6ac9         	ldr	r1, [r1, #0x2c]
700a364a: 4288         	cmp	r0, r1
700a364c: d807         	bhi	0x700a365e <prvAddNewTaskToReadyList+0x7e> @ imm = #0xe
700a364e: e7ff         	b	0x700a3650 <prvAddNewTaskToReadyList+0x70> @ imm = #-0x2
;           pxCurrentTCB = pxNewTCB;
700a3650: 9801         	ldr	r0, [sp, #0x4]
700a3652: f640 51ac    	movw	r1, #0xdac
700a3656: f2c7 010b    	movt	r1, #0x700b
700a365a: 6008         	str	r0, [r1]
;         } else {
700a365c: e000         	b	0x700a3660 <prvAddNewTaskToReadyList+0x80> @ imm = #0x0
700a365e: e7ff         	b	0x700a3660 <prvAddNewTaskToReadyList+0x80> @ imm = #-0x2
;       } else {
700a3660: e000         	b	0x700a3664 <prvAddNewTaskToReadyList+0x84> @ imm = #0x0
700a3662: e7ff         	b	0x700a3664 <prvAddNewTaskToReadyList+0x84> @ imm = #-0x2
700a3664: e7ff         	b	0x700a3666 <prvAddNewTaskToReadyList+0x86> @ imm = #-0x2
;     uxTaskNumber++;
700a3666: f640 50d8    	movw	r0, #0xdd8
700a366a: f2c7 000b    	movt	r0, #0x700b
700a366e: 6801         	ldr	r1, [r0]
700a3670: 3101         	adds	r1, #0x1
700a3672: 6001         	str	r1, [r0]
;       pxNewTCB->uxTCBNumber = uxTaskNumber;
700a3674: 6800         	ldr	r0, [r0]
700a3676: 9901         	ldr	r1, [sp, #0x4]
700a3678: 6588         	str	r0, [r1, #0x58]
;     prvAddTaskToReadyList(pxNewTCB);
700a367a: 9801         	ldr	r0, [sp, #0x4]
700a367c: 6ac0         	ldr	r0, [r0, #0x2c]
700a367e: f640 51dc    	movw	r1, #0xddc
700a3682: f2c7 010b    	movt	r1, #0x700b
700a3686: 6809         	ldr	r1, [r1]
700a3688: 4288         	cmp	r0, r1
700a368a: d908         	bls	0x700a369e <prvAddNewTaskToReadyList+0xbe> @ imm = #0x10
700a368c: e7ff         	b	0x700a368e <prvAddNewTaskToReadyList+0xae> @ imm = #-0x2
700a368e: 9801         	ldr	r0, [sp, #0x4]
700a3690: 6ac0         	ldr	r0, [r0, #0x2c]
700a3692: f640 51dc    	movw	r1, #0xddc
700a3696: f2c7 010b    	movt	r1, #0x700b
700a369a: 6008         	str	r0, [r1]
700a369c: e7ff         	b	0x700a369e <prvAddNewTaskToReadyList+0xbe> @ imm = #-0x2
700a369e: 9901         	ldr	r1, [sp, #0x4]
700a36a0: 6ac8         	ldr	r0, [r1, #0x2c]
700a36a2: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a36a6: f244 40f8    	movw	r0, #0x44f8
700a36aa: f2c7 0008    	movt	r0, #0x7008
700a36ae: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a36b2: 3104         	adds	r1, #0x4
700a36b4: f008 fff4    	bl	0x700ac6a0 <vListInsertEnd> @ imm = #0x8fe8
;   taskEXIT_CRITICAL();
700a36b8: f008 fb0a    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x8614
;   if (xSchedulerRunning != pdFALSE) {
700a36bc: f640 50f0    	movw	r0, #0xdf0
700a36c0: f2c7 000b    	movt	r0, #0x700b
700a36c4: 6800         	ldr	r0, [r0]
700a36c6: b178         	cbz	r0, 0x700a36e8 <prvAddNewTaskToReadyList+0x108> @ imm = #0x1e
700a36c8: e7ff         	b	0x700a36ca <prvAddNewTaskToReadyList+0xea> @ imm = #-0x2
;     if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
700a36ca: f640 50ac    	movw	r0, #0xdac
700a36ce: f2c7 000b    	movt	r0, #0x700b
700a36d2: 6800         	ldr	r0, [r0]
700a36d4: 6ac0         	ldr	r0, [r0, #0x2c]
700a36d6: 9901         	ldr	r1, [sp, #0x4]
700a36d8: 6ac9         	ldr	r1, [r1, #0x2c]
700a36da: 4288         	cmp	r0, r1
700a36dc: d202         	bhs	0x700a36e4 <prvAddNewTaskToReadyList+0x104> @ imm = #0x4
700a36de: e7ff         	b	0x700a36e0 <prvAddNewTaskToReadyList+0x100> @ imm = #-0x2
;       taskYIELD_IF_USING_PREEMPTION();
700a36e0: df00         	svc	#0x0
;     } else {
700a36e2: e000         	b	0x700a36e6 <prvAddNewTaskToReadyList+0x106> @ imm = #0x0
700a36e4: e7ff         	b	0x700a36e6 <prvAddNewTaskToReadyList+0x106> @ imm = #-0x2
;   } else {
700a36e6: e000         	b	0x700a36ea <prvAddNewTaskToReadyList+0x10a> @ imm = #0x0
700a36e8: e7ff         	b	0x700a36ea <prvAddNewTaskToReadyList+0x10a> @ imm = #-0x2
; }
700a36ea: b002         	add	sp, #0x8
700a36ec: bd80         	pop	{r7, pc}
700a36ee: 0000         	movs	r0, r0

700a36f0 <xTaskPriorityInherit>:
; BaseType_t xTaskPriorityInherit(TaskHandle_t const pxMutexHolder) {
700a36f0: b580         	push	{r7, lr}
700a36f2: b084         	sub	sp, #0x10
700a36f4: 9003         	str	r0, [sp, #0xc]
;   TCB_t *const pxMutexHolderTCB = pxMutexHolder;
700a36f6: 9803         	ldr	r0, [sp, #0xc]
700a36f8: 9002         	str	r0, [sp, #0x8]
700a36fa: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700a36fc: 9001         	str	r0, [sp, #0x4]
;   if (pxMutexHolder != NULL) {
700a36fe: 9803         	ldr	r0, [sp, #0xc]
700a3700: 2800         	cmp	r0, #0x0
700a3702: d078         	beq	0x700a37f6 <xTaskPriorityInherit+0x106> @ imm = #0xf0
700a3704: e7ff         	b	0x700a3706 <xTaskPriorityInherit+0x16> @ imm = #-0x2
;     if (pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority) {
700a3706: 9802         	ldr	r0, [sp, #0x8]
700a3708: 6ac0         	ldr	r0, [r0, #0x2c]
700a370a: f640 51ac    	movw	r1, #0xdac
700a370e: f2c7 010b    	movt	r1, #0x700b
700a3712: 6809         	ldr	r1, [r1]
700a3714: 6ac9         	ldr	r1, [r1, #0x2c]
700a3716: 4288         	cmp	r0, r1
700a3718: d25c         	bhs	0x700a37d4 <xTaskPriorityInherit+0xe4> @ imm = #0xb8
700a371a: e7ff         	b	0x700a371c <xTaskPriorityInherit+0x2c> @ imm = #-0x2
;       if ((listGET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem)) &
700a371c: 9802         	ldr	r0, [sp, #0x8]
700a371e: 7ec0         	ldrb	r0, [r0, #0x1b]
700a3720: 0600         	lsls	r0, r0, #0x18
700a3722: 2800         	cmp	r0, #0x0
700a3724: d40b         	bmi	0x700a373e <xTaskPriorityInherit+0x4e> @ imm = #0x16
700a3726: e7ff         	b	0x700a3728 <xTaskPriorityInherit+0x38> @ imm = #-0x2
;         listSET_LIST_ITEM_VALUE(
700a3728: f640 50ac    	movw	r0, #0xdac
700a372c: f2c7 000b    	movt	r0, #0x700b
700a3730: 6800         	ldr	r0, [r0]
700a3732: 6ac0         	ldr	r0, [r0, #0x2c]
700a3734: f1c0 0020    	rsb.w	r0, r0, #0x20
700a3738: 9902         	ldr	r1, [sp, #0x8]
700a373a: 6188         	str	r0, [r1, #0x18]
;       } else {
700a373c: e000         	b	0x700a3740 <xTaskPriorityInherit+0x50> @ imm = #0x0
700a373e: e7ff         	b	0x700a3740 <xTaskPriorityInherit+0x50> @ imm = #-0x2
;       if (listIS_CONTAINED_WITHIN(
700a3740: 9902         	ldr	r1, [sp, #0x8]
700a3742: 6948         	ldr	r0, [r1, #0x14]
700a3744: 6ac9         	ldr	r1, [r1, #0x2c]
700a3746: eb01 0281    	add.w	r2, r1, r1, lsl #2
700a374a: f244 41f8    	movw	r1, #0x44f8
700a374e: f2c7 0108    	movt	r1, #0x7008
700a3752: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a3756: 4288         	cmp	r0, r1
700a3758: d130         	bne	0x700a37bc <xTaskPriorityInherit+0xcc> @ imm = #0x60
700a375a: e7ff         	b	0x700a375c <xTaskPriorityInherit+0x6c> @ imm = #-0x2
;         if (uxListRemove(&(pxMutexHolderTCB->xStateListItem)) ==
700a375c: 9802         	ldr	r0, [sp, #0x8]
700a375e: 3004         	adds	r0, #0x4
700a3760: f008 f9c6    	bl	0x700abaf0 <uxListRemove> @ imm = #0x838c
700a3764: b908         	cbnz	r0, 0x700a376a <xTaskPriorityInherit+0x7a> @ imm = #0x2
700a3766: e7ff         	b	0x700a3768 <xTaskPriorityInherit+0x78> @ imm = #-0x2
;         } else {
700a3768: e000         	b	0x700a376c <xTaskPriorityInherit+0x7c> @ imm = #0x0
700a376a: e7ff         	b	0x700a376c <xTaskPriorityInherit+0x7c> @ imm = #-0x2
;         pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
700a376c: f640 50ac    	movw	r0, #0xdac
700a3770: f2c7 000b    	movt	r0, #0x700b
700a3774: 6800         	ldr	r0, [r0]
700a3776: 6ac0         	ldr	r0, [r0, #0x2c]
700a3778: 9902         	ldr	r1, [sp, #0x8]
700a377a: 62c8         	str	r0, [r1, #0x2c]
;         prvAddTaskToReadyList(pxMutexHolderTCB);
700a377c: 9802         	ldr	r0, [sp, #0x8]
700a377e: 6ac0         	ldr	r0, [r0, #0x2c]
700a3780: f640 51dc    	movw	r1, #0xddc
700a3784: f2c7 010b    	movt	r1, #0x700b
700a3788: 6809         	ldr	r1, [r1]
700a378a: 4288         	cmp	r0, r1
700a378c: d908         	bls	0x700a37a0 <xTaskPriorityInherit+0xb0> @ imm = #0x10
700a378e: e7ff         	b	0x700a3790 <xTaskPriorityInherit+0xa0> @ imm = #-0x2
700a3790: 9802         	ldr	r0, [sp, #0x8]
700a3792: 6ac0         	ldr	r0, [r0, #0x2c]
700a3794: f640 51dc    	movw	r1, #0xddc
700a3798: f2c7 010b    	movt	r1, #0x700b
700a379c: 6008         	str	r0, [r1]
700a379e: e7ff         	b	0x700a37a0 <xTaskPriorityInherit+0xb0> @ imm = #-0x2
700a37a0: 9902         	ldr	r1, [sp, #0x8]
700a37a2: 6ac8         	ldr	r0, [r1, #0x2c]
700a37a4: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a37a8: f244 40f8    	movw	r0, #0x44f8
700a37ac: f2c7 0008    	movt	r0, #0x7008
700a37b0: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a37b4: 3104         	adds	r1, #0x4
700a37b6: f008 ff73    	bl	0x700ac6a0 <vListInsertEnd> @ imm = #0x8ee6
;       } else {
700a37ba: e008         	b	0x700a37ce <xTaskPriorityInherit+0xde> @ imm = #0x10
;         pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
700a37bc: f640 50ac    	movw	r0, #0xdac
700a37c0: f2c7 000b    	movt	r0, #0x700b
700a37c4: 6800         	ldr	r0, [r0]
700a37c6: 6ac0         	ldr	r0, [r0, #0x2c]
700a37c8: 9902         	ldr	r1, [sp, #0x8]
700a37ca: 62c8         	str	r0, [r1, #0x2c]
700a37cc: e7ff         	b	0x700a37ce <xTaskPriorityInherit+0xde> @ imm = #-0x2
700a37ce: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a37d0: 9001         	str	r0, [sp, #0x4]
;     } else {
700a37d2: e00f         	b	0x700a37f4 <xTaskPriorityInherit+0x104> @ imm = #0x1e
;       if (pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority) {
700a37d4: 9802         	ldr	r0, [sp, #0x8]
700a37d6: 6e00         	ldr	r0, [r0, #0x60]
700a37d8: f640 51ac    	movw	r1, #0xdac
700a37dc: f2c7 010b    	movt	r1, #0x700b
700a37e0: 6809         	ldr	r1, [r1]
700a37e2: 6ac9         	ldr	r1, [r1, #0x2c]
700a37e4: 4288         	cmp	r0, r1
700a37e6: d203         	bhs	0x700a37f0 <xTaskPriorityInherit+0x100> @ imm = #0x6
700a37e8: e7ff         	b	0x700a37ea <xTaskPriorityInherit+0xfa> @ imm = #-0x2
700a37ea: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700a37ec: 9001         	str	r0, [sp, #0x4]
;       } else {
700a37ee: e000         	b	0x700a37f2 <xTaskPriorityInherit+0x102> @ imm = #0x0
700a37f0: e7ff         	b	0x700a37f2 <xTaskPriorityInherit+0x102> @ imm = #-0x2
700a37f2: e7ff         	b	0x700a37f4 <xTaskPriorityInherit+0x104> @ imm = #-0x2
;   } else {
700a37f4: e000         	b	0x700a37f8 <xTaskPriorityInherit+0x108> @ imm = #0x0
700a37f6: e7ff         	b	0x700a37f8 <xTaskPriorityInherit+0x108> @ imm = #-0x2
;   return xReturn;
700a37f8: 9801         	ldr	r0, [sp, #0x4]
700a37fa: b004         	add	sp, #0x10
700a37fc: bd80         	pop	{r7, pc}
700a37fe: 0000         	movs	r0, r0

700a3800 <Udma_eventCheckParams>:
; {
700a3800: b084         	sub	sp, #0x10
700a3802: 9003         	str	r0, [sp, #0xc]
700a3804: 9102         	str	r1, [sp, #0x8]
700a3806: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a3808: 9001         	str	r0, [sp, #0x4]
;     if(UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode)
700a380a: 9802         	ldr	r0, [sp, #0x8]
700a380c: 6840         	ldr	r0, [r0, #0x4]
700a380e: 2801         	cmp	r0, #0x1
700a3810: d109         	bne	0x700a3826 <Udma_eventCheckParams+0x26> @ imm = #0x12
700a3812: e7ff         	b	0x700a3814 <Udma_eventCheckParams+0x14> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a3814: 9802         	ldr	r0, [sp, #0x8]
700a3816: 6900         	ldr	r0, [r0, #0x10]
700a3818: b120         	cbz	r0, 0x700a3824 <Udma_eventCheckParams+0x24> @ imm = #0x8
700a381a: e7ff         	b	0x700a381c <Udma_eventCheckParams+0x1c> @ imm = #-0x2
700a381c: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a3820: 9001         	str	r0, [sp, #0x4]
;         }
700a3822: e7ff         	b	0x700a3824 <Udma_eventCheckParams+0x24> @ imm = #-0x2
;     }
700a3824: e7ff         	b	0x700a3826 <Udma_eventCheckParams+0x26> @ imm = #-0x2
;     if(UDMA_EVENT_MODE_SHARED == eventPrms->eventMode)
700a3826: 9802         	ldr	r0, [sp, #0x8]
700a3828: 6840         	ldr	r0, [r0, #0x4]
700a382a: 2802         	cmp	r0, #0x2
700a382c: d126         	bne	0x700a387c <Udma_eventCheckParams+0x7c> @ imm = #0x4c
700a382e: e7ff         	b	0x700a3830 <Udma_eventCheckParams+0x30> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a3830: 9802         	ldr	r0, [sp, #0x8]
700a3832: 6900         	ldr	r0, [r0, #0x10]
700a3834: b308         	cbz	r0, 0x700a387a <Udma_eventCheckParams+0x7a> @ imm = #0x42
700a3836: e7ff         	b	0x700a3838 <Udma_eventCheckParams+0x38> @ imm = #-0x2
;             controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a3838: 9802         	ldr	r0, [sp, #0x8]
700a383a: 6900         	ldr	r0, [r0, #0x10]
700a383c: 9000         	str	r0, [sp]
;             if(((Udma_EventCallback) NULL_PTR != controllerEventHandle->eventPrms.eventCb) &&
700a383e: 9800         	ldr	r0, [sp]
700a3840: 69c0         	ldr	r0, [r0, #0x1c]
700a3842: b140         	cbz	r0, 0x700a3856 <Udma_eventCheckParams+0x56> @ imm = #0x10
700a3844: e7ff         	b	0x700a3846 <Udma_eventCheckParams+0x46> @ imm = #-0x2
;                ((Udma_EventCallback) NULL_PTR == eventPrms->eventCb))
700a3846: 9802         	ldr	r0, [sp, #0x8]
700a3848: 6940         	ldr	r0, [r0, #0x14]
;             if(((Udma_EventCallback) NULL_PTR != controllerEventHandle->eventPrms.eventCb) &&
700a384a: b920         	cbnz	r0, 0x700a3856 <Udma_eventCheckParams+0x56> @ imm = #0x8
700a384c: e7ff         	b	0x700a384e <Udma_eventCheckParams+0x4e> @ imm = #-0x2
700a384e: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a3852: 9001         	str	r0, [sp, #0x4]
;             }
700a3854: e7ff         	b	0x700a3856 <Udma_eventCheckParams+0x56> @ imm = #-0x2
;             if(((Udma_EventCallback) NULL_PTR == controllerEventHandle->eventPrms.eventCb) &&
700a3856: 9800         	ldr	r0, [sp]
700a3858: 69c0         	ldr	r0, [r0, #0x1c]
700a385a: b968         	cbnz	r0, 0x700a3878 <Udma_eventCheckParams+0x78> @ imm = #0x1a
700a385c: e7ff         	b	0x700a385e <Udma_eventCheckParams+0x5e> @ imm = #-0x2
;                ((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
700a385e: 9802         	ldr	r0, [sp, #0x8]
700a3860: 6940         	ldr	r0, [r0, #0x14]
700a3862: b148         	cbz	r0, 0x700a3878 <Udma_eventCheckParams+0x78> @ imm = #0x12
700a3864: e7ff         	b	0x700a3866 <Udma_eventCheckParams+0x66> @ imm = #-0x2
;                (UDMA_EVENT_TYPE_MASTER != controllerEventHandle->eventPrms.eventType))
700a3866: 9800         	ldr	r0, [sp]
700a3868: 6880         	ldr	r0, [r0, #0x8]
;             if(((Udma_EventCallback) NULL_PTR == controllerEventHandle->eventPrms.eventCb) &&
700a386a: 2805         	cmp	r0, #0x5
700a386c: d004         	beq	0x700a3878 <Udma_eventCheckParams+0x78> @ imm = #0x8
700a386e: e7ff         	b	0x700a3870 <Udma_eventCheckParams+0x70> @ imm = #-0x2
700a3870: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a3874: 9001         	str	r0, [sp, #0x4]
;             }
700a3876: e7ff         	b	0x700a3878 <Udma_eventCheckParams+0x78> @ imm = #-0x2
;         }
700a3878: e7ff         	b	0x700a387a <Udma_eventCheckParams+0x7a> @ imm = #-0x2
;     }
700a387a: e7ff         	b	0x700a387c <Udma_eventCheckParams+0x7c> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a387c: 9802         	ldr	r0, [sp, #0x8]
700a387e: 6800         	ldr	r0, [r0]
700a3880: 2801         	cmp	r0, #0x1
700a3882: d00f         	beq	0x700a38a4 <Udma_eventCheckParams+0xa4> @ imm = #0x1e
700a3884: e7ff         	b	0x700a3886 <Udma_eventCheckParams+0x86> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType) ||
700a3886: 9802         	ldr	r0, [sp, #0x8]
700a3888: 6800         	ldr	r0, [r0]
700a388a: 2806         	cmp	r0, #0x6
700a388c: d00a         	beq	0x700a38a4 <Udma_eventCheckParams+0xa4> @ imm = #0x14
700a388e: e7ff         	b	0x700a3890 <Udma_eventCheckParams+0x90> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType) ||
700a3890: 9802         	ldr	r0, [sp, #0x8]
700a3892: 6800         	ldr	r0, [r0]
700a3894: 2802         	cmp	r0, #0x2
700a3896: d005         	beq	0x700a38a4 <Udma_eventCheckParams+0xa4> @ imm = #0xa
700a3898: e7ff         	b	0x700a389a <Udma_eventCheckParams+0x9a> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TR == eventPrms->eventType))
700a389a: 9802         	ldr	r0, [sp, #0x8]
700a389c: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a389e: 2803         	cmp	r0, #0x3
700a38a0: d109         	bne	0x700a38b6 <Udma_eventCheckParams+0xb6> @ imm = #0x12
700a38a2: e7ff         	b	0x700a38a4 <Udma_eventCheckParams+0xa4> @ imm = #-0x2
;         if(NULL_PTR == eventPrms->chHandle)
700a38a4: 9802         	ldr	r0, [sp, #0x8]
700a38a6: 6880         	ldr	r0, [r0, #0x8]
700a38a8: b920         	cbnz	r0, 0x700a38b4 <Udma_eventCheckParams+0xb4> @ imm = #0x8
700a38aa: e7ff         	b	0x700a38ac <Udma_eventCheckParams+0xac> @ imm = #-0x2
700a38ac: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a38b0: 9001         	str	r0, [sp, #0x4]
;         }
700a38b2: e7ff         	b	0x700a38b4 <Udma_eventCheckParams+0xb4> @ imm = #-0x2
;     }
700a38b4: e7ff         	b	0x700a38b6 <Udma_eventCheckParams+0xb6> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
700a38b6: 9802         	ldr	r0, [sp, #0x8]
700a38b8: 6800         	ldr	r0, [r0]
700a38ba: 2804         	cmp	r0, #0x4
700a38bc: d109         	bne	0x700a38d2 <Udma_eventCheckParams+0xd2> @ imm = #0x12
700a38be: e7ff         	b	0x700a38c0 <Udma_eventCheckParams+0xc0> @ imm = #-0x2
;         if(NULL_PTR == eventPrms->ringHandle)
700a38c0: 9802         	ldr	r0, [sp, #0x8]
700a38c2: 68c0         	ldr	r0, [r0, #0xc]
700a38c4: b920         	cbnz	r0, 0x700a38d0 <Udma_eventCheckParams+0xd0> @ imm = #0x8
700a38c6: e7ff         	b	0x700a38c8 <Udma_eventCheckParams+0xc8> @ imm = #-0x2
700a38c8: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a38cc: 9001         	str	r0, [sp, #0x4]
;         }
700a38ce: e7ff         	b	0x700a38d0 <Udma_eventCheckParams+0xd0> @ imm = #-0x2
;     }
700a38d0: e7ff         	b	0x700a38d2 <Udma_eventCheckParams+0xd2> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_MASTER == eventPrms->eventType)
700a38d2: 9802         	ldr	r0, [sp, #0x8]
700a38d4: 6800         	ldr	r0, [r0]
700a38d6: 2805         	cmp	r0, #0x5
700a38d8: d112         	bne	0x700a3900 <Udma_eventCheckParams+0x100> @ imm = #0x24
700a38da: e7ff         	b	0x700a38dc <Udma_eventCheckParams+0xdc> @ imm = #-0x2
;         if(UDMA_EVENT_MODE_SHARED != eventPrms->eventMode)
700a38dc: 9802         	ldr	r0, [sp, #0x8]
700a38de: 6840         	ldr	r0, [r0, #0x4]
700a38e0: 2802         	cmp	r0, #0x2
700a38e2: d004         	beq	0x700a38ee <Udma_eventCheckParams+0xee> @ imm = #0x8
700a38e4: e7ff         	b	0x700a38e6 <Udma_eventCheckParams+0xe6> @ imm = #-0x2
700a38e6: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a38ea: 9001         	str	r0, [sp, #0x4]
;         }
700a38ec: e7ff         	b	0x700a38ee <Udma_eventCheckParams+0xee> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a38ee: 9802         	ldr	r0, [sp, #0x8]
700a38f0: 6900         	ldr	r0, [r0, #0x10]
700a38f2: b120         	cbz	r0, 0x700a38fe <Udma_eventCheckParams+0xfe> @ imm = #0x8
700a38f4: e7ff         	b	0x700a38f6 <Udma_eventCheckParams+0xf6> @ imm = #-0x2
700a38f6: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a38fa: 9001         	str	r0, [sp, #0x4]
;         }
700a38fc: e7ff         	b	0x700a38fe <Udma_eventCheckParams+0xfe> @ imm = #-0x2
;     }
700a38fe: e7ff         	b	0x700a3900 <Udma_eventCheckParams+0x100> @ imm = #-0x2
;     return (retVal);
700a3900: 9801         	ldr	r0, [sp, #0x4]
700a3902: b004         	add	sp, #0x10
700a3904: 4770         	bx	lr
		...
700a390e: 0000         	movs	r0, r0

700a3910 <CSL_pktdmaTeardownChan>:
; {
700a3910: b580         	push	{r7, lr}
700a3912: b088         	sub	sp, #0x20
700a3914: 4684         	mov	r12, r0
700a3916: 980a         	ldr	r0, [sp, #0x28]
700a3918: f8cd c01c    	str.w	r12, [sp, #0x1c]
700a391c: 9106         	str	r1, [sp, #0x18]
700a391e: 9205         	str	r2, [sp, #0x14]
700a3920: f88d 3013    	strb.w	r3, [sp, #0x13]
700a3924: f88d 0012    	strb.w	r0, [sp, #0x12]
700a3928: 2000         	movs	r0, #0x0
;     int32_t  retVal = CSL_PASS;
700a392a: 9003         	str	r0, [sp, #0xc]
;     if( (pCfg == NULL) || (CSL_pktdmaIsValidChanIdx( pCfg, chanIdx, chanDir) == (bool)false) )
700a392c: 9807         	ldr	r0, [sp, #0x1c]
700a392e: b138         	cbz	r0, 0x700a3940 <CSL_pktdmaTeardownChan+0x30> @ imm = #0xe
700a3930: e7ff         	b	0x700a3932 <CSL_pktdmaTeardownChan+0x22> @ imm = #-0x2
700a3932: 9807         	ldr	r0, [sp, #0x1c]
700a3934: 9906         	ldr	r1, [sp, #0x18]
700a3936: 9a05         	ldr	r2, [sp, #0x14]
700a3938: f007 fc2a    	bl	0x700ab190 <CSL_pktdmaIsValidChanIdx> @ imm = #0x7854
700a393c: b920         	cbnz	r0, 0x700a3948 <CSL_pktdmaTeardownChan+0x38> @ imm = #0x8
700a393e: e7ff         	b	0x700a3940 <CSL_pktdmaTeardownChan+0x30> @ imm = #-0x2
700a3940: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a3944: 9003         	str	r0, [sp, #0xc]
;     }
700a3946: e062         	b	0x700a3a0e <CSL_pktdmaTeardownChan+0xfe> @ imm = #0xc4
;         if( CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true )
700a3948: 9807         	ldr	r0, [sp, #0x1c]
700a394a: 9906         	ldr	r1, [sp, #0x18]
700a394c: 9a05         	ldr	r2, [sp, #0x14]
700a394e: f007 fe4f    	bl	0x700ab5f0 <CSL_pktdmaIsChanEnabled> @ imm = #0x7c9e
700a3952: 2800         	cmp	r0, #0x0
700a3954: d056         	beq	0x700a3a04 <CSL_pktdmaTeardownChan+0xf4> @ imm = #0xac
700a3956: e7ff         	b	0x700a3958 <CSL_pktdmaTeardownChan+0x48> @ imm = #-0x2
;             if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700a3958: 9805         	ldr	r0, [sp, #0x14]
700a395a: b9a8         	cbnz	r0, 0x700a3988 <CSL_pktdmaTeardownChan+0x78> @ imm = #0x2a
700a395c: e7ff         	b	0x700a395e <CSL_pktdmaTeardownChan+0x4e> @ imm = #-0x2
;                 regVal = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a395e: 9807         	ldr	r0, [sp, #0x1c]
700a3960: 6900         	ldr	r0, [r0, #0x10]
700a3962: 9906         	ldr	r1, [sp, #0x18]
700a3964: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a3968: f00a fb92    	bl	0x700ae090 <CSL_REG32_RD_RAW> @ imm = #0xa724
700a396c: 9002         	str	r0, [sp, #0x8]
;                 CSL_FINS( regVal, PKTDMA_TXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a396e: 9802         	ldr	r0, [sp, #0x8]
700a3970: f040 4080    	orr	r0, r0, #0x40000000
700a3974: 9002         	str	r0, [sp, #0x8]
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a3976: 9807         	ldr	r0, [sp, #0x1c]
700a3978: 6900         	ldr	r0, [r0, #0x10]
700a397a: 9906         	ldr	r1, [sp, #0x18]
700a397c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a3980: 9902         	ldr	r1, [sp, #0x8]
700a3982: f00a fadd    	bl	0x700adf40 <CSL_REG32_WR_RAW> @ imm = #0xa5ba
;             }
700a3986: e014         	b	0x700a39b2 <CSL_pktdmaTeardownChan+0xa2> @ imm = #0x28
;                 regVal = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a3988: 9807         	ldr	r0, [sp, #0x1c]
700a398a: 6940         	ldr	r0, [r0, #0x14]
700a398c: 9906         	ldr	r1, [sp, #0x18]
700a398e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a3992: f00a fb7d    	bl	0x700ae090 <CSL_REG32_RD_RAW> @ imm = #0xa6fa
700a3996: 9002         	str	r0, [sp, #0x8]
;                 CSL_FINS( regVal, PKTDMA_RXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a3998: 9802         	ldr	r0, [sp, #0x8]
700a399a: f040 4080    	orr	r0, r0, #0x40000000
700a399e: 9002         	str	r0, [sp, #0x8]
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a39a0: 9807         	ldr	r0, [sp, #0x1c]
700a39a2: 6940         	ldr	r0, [r0, #0x14]
700a39a4: 9906         	ldr	r1, [sp, #0x18]
700a39a6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a39aa: 9902         	ldr	r1, [sp, #0x8]
700a39ac: f00a fac8    	bl	0x700adf40 <CSL_REG32_WR_RAW> @ imm = #0xa590
700a39b0: e7ff         	b	0x700a39b2 <CSL_pktdmaTeardownChan+0xa2> @ imm = #-0x2
;             if( bWait == (bool)true )
700a39b2: f89d 0012    	ldrb.w	r0, [sp, #0x12]
700a39b6: 07c0         	lsls	r0, r0, #0x1f
700a39b8: b318         	cbz	r0, 0x700a3a02 <CSL_pktdmaTeardownChan+0xf2> @ imm = #0x46
700a39ba: e7ff         	b	0x700a39bc <CSL_pktdmaTeardownChan+0xac> @ imm = #-0x2
700a39bc: 2080         	movs	r0, #0x80
;                 uint32_t retryCnt = CSL_PKTDMA_TEARDOWN_COMPLETE_WAIT_MAX_CNT;
700a39be: 9001         	str	r0, [sp, #0x4]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a39c0: e7ff         	b	0x700a39c2 <CSL_pktdmaTeardownChan+0xb2> @ imm = #-0x2
700a39c2: 9807         	ldr	r0, [sp, #0x1c]
700a39c4: 9906         	ldr	r1, [sp, #0x18]
700a39c6: 9a05         	ldr	r2, [sp, #0x14]
700a39c8: f007 fe12    	bl	0x700ab5f0 <CSL_pktdmaIsChanEnabled> @ imm = #0x7c24
700a39cc: 4601         	mov	r1, r0
700a39ce: 2000         	movs	r0, #0x0
700a39d0: 9000         	str	r0, [sp]
700a39d2: b131         	cbz	r1, 0x700a39e2 <CSL_pktdmaTeardownChan+0xd2> @ imm = #0xc
700a39d4: e7ff         	b	0x700a39d6 <CSL_pktdmaTeardownChan+0xc6> @ imm = #-0x2
700a39d6: 9801         	ldr	r0, [sp, #0x4]
700a39d8: 2800         	cmp	r0, #0x0
700a39da: bf18         	it	ne
700a39dc: 2001         	movne	r0, #0x1
700a39de: 9000         	str	r0, [sp]
700a39e0: e7ff         	b	0x700a39e2 <CSL_pktdmaTeardownChan+0xd2> @ imm = #-0x2
700a39e2: 9800         	ldr	r0, [sp]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a39e4: 07c0         	lsls	r0, r0, #0x1f
700a39e6: b120         	cbz	r0, 0x700a39f2 <CSL_pktdmaTeardownChan+0xe2> @ imm = #0x8
700a39e8: e7ff         	b	0x700a39ea <CSL_pktdmaTeardownChan+0xda> @ imm = #-0x2
;                     retryCnt--;
700a39ea: 9801         	ldr	r0, [sp, #0x4]
700a39ec: 3801         	subs	r0, #0x1
700a39ee: 9001         	str	r0, [sp, #0x4]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a39f0: e7e7         	b	0x700a39c2 <CSL_pktdmaTeardownChan+0xb2> @ imm = #-0x32
;                 if( retryCnt == (uint32_t)0U ) {
700a39f2: 9801         	ldr	r0, [sp, #0x4]
700a39f4: b920         	cbnz	r0, 0x700a3a00 <CSL_pktdmaTeardownChan+0xf0> @ imm = #0x8
700a39f6: e7ff         	b	0x700a39f8 <CSL_pktdmaTeardownChan+0xe8> @ imm = #-0x2
700a39f8: f04f 30ff    	mov.w	r0, #0xffffffff
;                     retVal = CSL_EFAIL;
700a39fc: 9003         	str	r0, [sp, #0xc]
;                 }
700a39fe: e7ff         	b	0x700a3a00 <CSL_pktdmaTeardownChan+0xf0> @ imm = #-0x2
;             }
700a3a00: e7ff         	b	0x700a3a02 <CSL_pktdmaTeardownChan+0xf2> @ imm = #-0x2
;         }
700a3a02: e003         	b	0x700a3a0c <CSL_pktdmaTeardownChan+0xfc> @ imm = #0x6
700a3a04: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = CSL_EFAIL;
700a3a08: 9003         	str	r0, [sp, #0xc]
700a3a0a: e7ff         	b	0x700a3a0c <CSL_pktdmaTeardownChan+0xfc> @ imm = #-0x2
700a3a0c: e7ff         	b	0x700a3a0e <CSL_pktdmaTeardownChan+0xfe> @ imm = #-0x2
;     return retVal;
700a3a0e: 9803         	ldr	r0, [sp, #0xc]
700a3a10: b008         	add	sp, #0x20
700a3a12: bd80         	pop	{r7, pc}
		...

700a3a20 <UART_configInstance>:
; {
700a3a20: b580         	push	{r7, lr}
700a3a22: b088         	sub	sp, #0x20
700a3a24: 9007         	str	r0, [sp, #0x1c]
;     baseAddr = hUart->baseAddr;
700a3a26: 9807         	ldr	r0, [sp, #0x1c]
700a3a28: 6800         	ldr	r0, [r0]
700a3a2a: 9006         	str	r0, [sp, #0x18]
;     hUartInit = hUart->hUartInit;
700a3a2c: 9807         	ldr	r0, [sp, #0x1c]
700a3a2e: 6840         	ldr	r0, [r0, #0x4]
700a3a30: 9001         	str	r0, [sp, #0x4]
;     UART_resetModule(hUart);
700a3a32: 9807         	ldr	r0, [sp, #0x1c]
700a3a34: f008 f80c    	bl	0x700aba50 <UART_resetModule> @ imm = #0x8018
;     if(UART_CONFIG_MODE_DMA == hUartInit->transferMode)
700a3a38: 9801         	ldr	r0, [sp, #0x4]
700a3a3a: 6a00         	ldr	r0, [r0, #0x20]
700a3a3c: 2803         	cmp	r0, #0x3
700a3a3e: d10e         	bne	0x700a3a5e <UART_configInstance+0x3e> @ imm = #0x1c
700a3a40: e7ff         	b	0x700a3a42 <UART_configInstance+0x22> @ imm = #-0x2
;         regVal = UART_FIFO_CONFIG(UART_TRIG_LVL_GRANULARITY_1,
700a3a42: 9801         	ldr	r0, [sp, #0x4]
700a3a44: f890 1038    	ldrb.w	r1, [r0, #0x38]
700a3a48: f890 003c    	ldrb.w	r0, [r0, #0x3c]
700a3a4c: 0380         	lsls	r0, r0, #0xe
700a3a4e: ea40 1081    	orr.w	r0, r0, r1, lsl #6
700a3a52: 2131         	movs	r1, #0x31
700a3a54: f2c0 4140    	movt	r1, #0x440
700a3a58: 4308         	orrs	r0, r1
700a3a5a: 9005         	str	r0, [sp, #0x14]
;     }
700a3a5c: e00d         	b	0x700a3a7a <UART_configInstance+0x5a> @ imm = #0x1a
;         regVal = UART_FIFO_CONFIG(UART_TRIG_LVL_GRANULARITY_1,
700a3a5e: 9801         	ldr	r0, [sp, #0x4]
700a3a60: f890 1038    	ldrb.w	r1, [r0, #0x38]
700a3a64: f890 003c    	ldrb.w	r0, [r0, #0x3c]
700a3a68: 0380         	lsls	r0, r0, #0xe
700a3a6a: ea40 1081    	orr.w	r0, r0, r1, lsl #6
700a3a6e: 2130         	movs	r1, #0x30
700a3a70: f2c0 4140    	movt	r1, #0x440
700a3a74: 4308         	orrs	r0, r1
700a3a76: 9005         	str	r0, [sp, #0x14]
700a3a78: e7ff         	b	0x700a3a7a <UART_configInstance+0x5a> @ imm = #-0x2
;     (void)UART_fifoConfig(baseAddr, regVal);
700a3a7a: 9806         	ldr	r0, [sp, #0x18]
700a3a7c: 9905         	ldr	r1, [sp, #0x14]
700a3a7e: f7f9 fa87    	bl	0x7009cf90 <UART_fifoConfig> @ imm = #-0x6af2
;     UART_timeGuardConfig(baseAddr, hUartInit->timeGuardVal);
700a3a82: 9806         	ldr	r0, [sp, #0x18]
700a3a84: 9901         	ldr	r1, [sp, #0x4]
700a3a86: 6d09         	ldr	r1, [r1, #0x50]
700a3a88: f00a f832    	bl	0x700adaf0 <UART_timeGuardConfig> @ imm = #0xa064
;     divisorVal = UART_divisorValCompute(hUartInit->inputClkFreq,
700a3a8c: 9a01         	ldr	r2, [sp, #0x4]
700a3a8e: 6810         	ldr	r0, [r2]
;                                     hUartInit->baudRate,
700a3a90: 6851         	ldr	r1, [r2, #0x4]
;                                     hUartInit->operMode,
700a3a92: 6ad2         	ldr	r2, [r2, #0x2c]
700a3a94: 232a         	movs	r3, #0x2a
;     divisorVal = UART_divisorValCompute(hUartInit->inputClkFreq,
700a3a96: f006 f9d3    	bl	0x700a9e40 <UART_divisorValCompute> @ imm = #0x63a6
700a3a9a: 9004         	str	r0, [sp, #0x10]
;     (void)UART_divisorLatchWrite(baseAddr, divisorVal);
700a3a9c: 9806         	ldr	r0, [sp, #0x18]
700a3a9e: 9904         	ldr	r1, [sp, #0x10]
700a3aa0: f7ff fb66    	bl	0x700a3170 <UART_divisorLatchWrite> @ imm = #-0x934
;     (void)UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a3aa4: 9806         	ldr	r0, [sp, #0x18]
700a3aa6: 21bf         	movs	r1, #0xbf
700a3aa8: f007 f87a    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #0x70f4
;     wLenStbFlag = (hUartInit->dataLength << UART_LCR_CHAR_LENGTH_SHIFT);
700a3aac: 9801         	ldr	r0, [sp, #0x4]
700a3aae: 6880         	ldr	r0, [r0, #0x8]
700a3ab0: 9003         	str	r0, [sp, #0xc]
;     wLenStbFlag |= (hUartInit->stopBits << UART_LCR_NB_STOP_SHIFT);
700a3ab2: 9801         	ldr	r0, [sp, #0x4]
700a3ab4: 68c1         	ldr	r1, [r0, #0xc]
700a3ab6: 9803         	ldr	r0, [sp, #0xc]
700a3ab8: ea40 0081    	orr.w	r0, r0, r1, lsl #2
700a3abc: 9003         	str	r0, [sp, #0xc]
;     parityFlag = (hUartInit->parityType << UART_LCR_PARITY_EN_SHIFT);
700a3abe: 9801         	ldr	r0, [sp, #0x4]
700a3ac0: 6900         	ldr	r0, [r0, #0x10]
700a3ac2: 00c0         	lsls	r0, r0, #0x3
700a3ac4: 9002         	str	r0, [sp, #0x8]
;     UART_lineCharConfig(baseAddr, wLenStbFlag, parityFlag);
700a3ac6: 9806         	ldr	r0, [sp, #0x18]
700a3ac8: 9903         	ldr	r1, [sp, #0xc]
700a3aca: 9a02         	ldr	r2, [sp, #0x8]
700a3acc: f007 ff48    	bl	0x700ab960 <UART_lineCharConfig> @ imm = #0x7e90
;     UART_divisorLatchDisable(baseAddr);
700a3ad0: 9806         	ldr	r0, [sp, #0x18]
700a3ad2: f00a f86d    	bl	0x700adbb0 <UART_divisorLatchDisable> @ imm = #0xa0da
;     UART_breakCtl(baseAddr, UART_BREAK_COND_DISABLE);
700a3ad6: 9806         	ldr	r0, [sp, #0x18]
700a3ad8: 2100         	movs	r1, #0x0
700a3ada: f009 ff09    	bl	0x700ad8f0 <UART_breakCtl> @ imm = #0x9e12
;     (void)UART_operatingModeSelect(baseAddr, hUartInit->operMode);
700a3ade: 9806         	ldr	r0, [sp, #0x18]
700a3ae0: 9901         	ldr	r1, [sp, #0x4]
700a3ae2: 6ac9         	ldr	r1, [r1, #0x2c]
700a3ae4: f009 fbe4    	bl	0x700ad2b0 <UART_operatingModeSelect> @ imm = #0x97c8
;     if (hUartInit->hwFlowControl == (uint32_t)TRUE)
700a3ae8: 9801         	ldr	r0, [sp, #0x4]
700a3aea: 6980         	ldr	r0, [r0, #0x18]
700a3aec: 2801         	cmp	r0, #0x1
700a3aee: d112         	bne	0x700a3b16 <UART_configInstance+0xf6> @ imm = #0x24
700a3af0: e7ff         	b	0x700a3af2 <UART_configInstance+0xd2> @ imm = #-0x2
;         UART_hardwareFlowCtrlOptSet(baseAddr, UART_RTS_CTS_ENABLE);
700a3af2: 9806         	ldr	r0, [sp, #0x18]
700a3af4: 2103         	movs	r1, #0x3
700a3af6: f009 f82b    	bl	0x700acb50 <UART_hardwareFlowCtrlOptSet> @ imm = #0x9056
;         if (hUartInit->hwFlowControlThr >= hUartInit->rxTrigLvl)
700a3afa: 9901         	ldr	r1, [sp, #0x4]
700a3afc: 69c8         	ldr	r0, [r1, #0x1c]
700a3afe: 6b89         	ldr	r1, [r1, #0x38]
700a3b00: 4288         	cmp	r0, r1
700a3b02: d307         	blo	0x700a3b14 <UART_configInstance+0xf4> @ imm = #0xe
700a3b04: e7ff         	b	0x700a3b06 <UART_configInstance+0xe6> @ imm = #-0x2
;             UART_flowCtrlTrigLvlConfig(baseAddr,
700a3b06: 9806         	ldr	r0, [sp, #0x18]
;                                     hUartInit->hwFlowControlThr,
700a3b08: 9a01         	ldr	r2, [sp, #0x4]
700a3b0a: 69d1         	ldr	r1, [r2, #0x1c]
;                                     hUartInit->rxTrigLvl);
700a3b0c: 6b92         	ldr	r2, [r2, #0x38]
;             UART_flowCtrlTrigLvlConfig(baseAddr,
700a3b0e: f009 f8cf    	bl	0x700accb0 <UART_flowCtrlTrigLvlConfig> @ imm = #0x919e
;         }
700a3b12: e7ff         	b	0x700a3b14 <UART_configInstance+0xf4> @ imm = #-0x2
;     }
700a3b14: e004         	b	0x700a3b20 <UART_configInstance+0x100> @ imm = #0x8
;         UART_hardwareFlowCtrlOptSet(baseAddr, UART_NO_HARDWARE_FLOW_CONTROL);
700a3b16: 9806         	ldr	r0, [sp, #0x18]
700a3b18: 2100         	movs	r1, #0x0
700a3b1a: f009 f819    	bl	0x700acb50 <UART_hardwareFlowCtrlOptSet> @ imm = #0x9032
700a3b1e: e7ff         	b	0x700a3b20 <UART_configInstance+0x100> @ imm = #-0x2
;     return;
700a3b20: b008         	add	sp, #0x20
700a3b22: bd80         	pop	{r7, pc}
		...

700a3b30 <Sciclient_rmIrGetOutp>:
; {
700a3b30: b580         	push	{r7, lr}
700a3b32: b088         	sub	sp, #0x20
700a3b34: f8ad 001e    	strh.w	r0, [sp, #0x1e]
700a3b38: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a3b3c: 9206         	str	r2, [sp, #0x18]
700a3b3e: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a3b40: 9005         	str	r0, [sp, #0x14]
;     const struct Sciclient_rmIrInst *inst = NULL;
700a3b42: 9004         	str	r0, [sp, #0x10]
;     if (outp == NULL) {
700a3b44: 9806         	ldr	r0, [sp, #0x18]
700a3b46: b920         	cbnz	r0, 0x700a3b52 <Sciclient_rmIrGetOutp+0x22> @ imm = #0x8
700a3b48: e7ff         	b	0x700a3b4a <Sciclient_rmIrGetOutp+0x1a> @ imm = #-0x2
700a3b4a: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a3b4e: 9005         	str	r0, [sp, #0x14]
;     } else {
700a3b50: e018         	b	0x700a3b84 <Sciclient_rmIrGetOutp+0x54> @ imm = #0x30
;         inst = Sciclient_rmIrGetInst(id);
700a3b52: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
700a3b56: f006 f9e3    	bl	0x700a9f20 <Sciclient_rmIrGetInst> @ imm = #0x63c6
700a3b5a: 9004         	str	r0, [sp, #0x10]
;         if (inst == NULL) {
700a3b5c: 9804         	ldr	r0, [sp, #0x10]
700a3b5e: b920         	cbnz	r0, 0x700a3b6a <Sciclient_rmIrGetOutp+0x3a> @ imm = #0x8
700a3b60: e7ff         	b	0x700a3b62 <Sciclient_rmIrGetOutp+0x32> @ imm = #-0x2
700a3b62: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a3b66: 9005         	str	r0, [sp, #0x14]
;         } else {
700a3b68: e00b         	b	0x700a3b82 <Sciclient_rmIrGetOutp+0x52> @ imm = #0x16
;             if (inp >= inst->n_inp) {
700a3b6a: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a3b6e: 9904         	ldr	r1, [sp, #0x10]
700a3b70: 8909         	ldrh	r1, [r1, #0x8]
700a3b72: 4288         	cmp	r0, r1
700a3b74: db04         	blt	0x700a3b80 <Sciclient_rmIrGetOutp+0x50> @ imm = #0x8
700a3b76: e7ff         	b	0x700a3b78 <Sciclient_rmIrGetOutp+0x48> @ imm = #-0x2
700a3b78: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a3b7c: 9005         	str	r0, [sp, #0x14]
;             }
700a3b7e: e7ff         	b	0x700a3b80 <Sciclient_rmIrGetOutp+0x50> @ imm = #-0x2
700a3b80: e7ff         	b	0x700a3b82 <Sciclient_rmIrGetOutp+0x52> @ imm = #-0x2
700a3b82: e7ff         	b	0x700a3b84 <Sciclient_rmIrGetOutp+0x54> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (inp == 0u)) {
700a3b84: 9805         	ldr	r0, [sp, #0x14]
700a3b86: b9a8         	cbnz	r0, 0x700a3bb4 <Sciclient_rmIrGetOutp+0x84> @ imm = #0x2a
700a3b88: e7ff         	b	0x700a3b8a <Sciclient_rmIrGetOutp+0x5a> @ imm = #-0x2
700a3b8a: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a3b8e: b988         	cbnz	r0, 0x700a3bb4 <Sciclient_rmIrGetOutp+0x84> @ imm = #0x22
700a3b90: e7ff         	b	0x700a3b92 <Sciclient_rmIrGetOutp+0x62> @ imm = #-0x2
;         if (inst->inp0_mapping != SCICLIENT_RM_IR_MAPPING_FREE) {
700a3b92: 9804         	ldr	r0, [sp, #0x10]
700a3b94: 8980         	ldrh	r0, [r0, #0xc]
700a3b96: f64f 71ff    	movw	r1, #0xffff
700a3b9a: 4288         	cmp	r0, r1
700a3b9c: d005         	beq	0x700a3baa <Sciclient_rmIrGetOutp+0x7a> @ imm = #0xa
700a3b9e: e7ff         	b	0x700a3ba0 <Sciclient_rmIrGetOutp+0x70> @ imm = #-0x2
;             *outp = inst->inp0_mapping;
700a3ba0: 9804         	ldr	r0, [sp, #0x10]
700a3ba2: 8980         	ldrh	r0, [r0, #0xc]
700a3ba4: 9906         	ldr	r1, [sp, #0x18]
700a3ba6: 8008         	strh	r0, [r1]
;         } else {
700a3ba8: e003         	b	0x700a3bb2 <Sciclient_rmIrGetOutp+0x82> @ imm = #0x6
700a3baa: f04f 30ff    	mov.w	r0, #0xffffffff
;             r = SystemP_FAILURE;
700a3bae: 9005         	str	r0, [sp, #0x14]
700a3bb0: e7ff         	b	0x700a3bb2 <Sciclient_rmIrGetOutp+0x82> @ imm = #-0x2
;     }
700a3bb2: e7ff         	b	0x700a3bb4 <Sciclient_rmIrGetOutp+0x84> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (inp != 0u)) {
700a3bb4: 9805         	ldr	r0, [sp, #0x14]
700a3bb6: bbb8         	cbnz	r0, 0x700a3c28 <Sciclient_rmIrGetOutp+0xf8> @ imm = #0x6e
700a3bb8: e7ff         	b	0x700a3bba <Sciclient_rmIrGetOutp+0x8a> @ imm = #-0x2
700a3bba: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a3bbe: b398         	cbz	r0, 0x700a3c28 <Sciclient_rmIrGetOutp+0xf8> @ imm = #0x66
700a3bc0: e7ff         	b	0x700a3bc2 <Sciclient_rmIrGetOutp+0x92> @ imm = #-0x2
700a3bc2: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a3bc6: 9005         	str	r0, [sp, #0x14]
700a3bc8: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_outp; i++) {
700a3bca: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a3bce: e7ff         	b	0x700a3bd0 <Sciclient_rmIrGetOutp+0xa0> @ imm = #-0x2
700a3bd0: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a3bd4: 9904         	ldr	r1, [sp, #0x10]
700a3bd6: 8949         	ldrh	r1, [r1, #0xa]
700a3bd8: 4288         	cmp	r0, r1
700a3bda: da24         	bge	0x700a3c26 <Sciclient_rmIrGetOutp+0xf6> @ imm = #0x48
700a3bdc: e7ff         	b	0x700a3bde <Sciclient_rmIrGetOutp+0xae> @ imm = #-0x2
;             int_ctrl_reg = (volatile uint32_t *) Sciclient_getIrAddr (inst->cfg, i);
700a3bde: 9804         	ldr	r0, [sp, #0x10]
700a3be0: 6840         	ldr	r0, [r0, #0x4]
700a3be2: f8bd 100e    	ldrh.w	r1, [sp, #0xe]
700a3be6: f009 f9fb    	bl	0x700acfe0 <Sciclient_getIrAddr> @ imm = #0x93f6
700a3bea: 9002         	str	r0, [sp, #0x8]
;             extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a3bec: 9802         	ldr	r0, [sp, #0x8]
700a3bee: f240 31ff    	movw	r1, #0x3ff
700a3bf2: 2200         	movs	r2, #0x0
700a3bf4: f009 fd0c    	bl	0x700ad610 <CSL_REG32_FEXT_RAW> @ imm = #0x9a18
700a3bf8: f8ad 0006    	strh.w	r0, [sp, #0x6]
;             if (inp == extracted_inp) {
700a3bfc: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a3c00: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700a3c04: 4288         	cmp	r0, r1
700a3c06: d107         	bne	0x700a3c18 <Sciclient_rmIrGetOutp+0xe8> @ imm = #0xe
700a3c08: e7ff         	b	0x700a3c0a <Sciclient_rmIrGetOutp+0xda> @ imm = #-0x2
;                 *outp = i;
700a3c0a: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a3c0e: 9906         	ldr	r1, [sp, #0x18]
700a3c10: 8008         	strh	r0, [r1]
700a3c12: 2000         	movs	r0, #0x0
;                 r = SystemP_SUCCESS;
700a3c14: 9005         	str	r0, [sp, #0x14]
;                 break;
700a3c16: e006         	b	0x700a3c26 <Sciclient_rmIrGetOutp+0xf6> @ imm = #0xc
;         }
700a3c18: e7ff         	b	0x700a3c1a <Sciclient_rmIrGetOutp+0xea> @ imm = #-0x2
;         for (i = 0u; i < inst->n_outp; i++) {
700a3c1a: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a3c1e: 3001         	adds	r0, #0x1
700a3c20: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a3c24: e7d4         	b	0x700a3bd0 <Sciclient_rmIrGetOutp+0xa0> @ imm = #-0x58
;     }
700a3c26: e7ff         	b	0x700a3c28 <Sciclient_rmIrGetOutp+0xf8> @ imm = #-0x2
;     return r;
700a3c28: 9805         	ldr	r0, [sp, #0x14]
700a3c2a: b008         	add	sp, #0x20
700a3c2c: bd80         	pop	{r7, pc}
700a3c2e: 0000         	movs	r0, r0

700a3c30 <eTaskGetState>:
; eTaskState eTaskGetState(TaskHandle_t xTask) {
700a3c30: b580         	push	{r7, lr}
700a3c32: b088         	sub	sp, #0x20
700a3c34: 9007         	str	r0, [sp, #0x1c]
;   const TCB_t *const pxTCB = xTask;
700a3c36: 9807         	ldr	r0, [sp, #0x1c]
700a3c38: 9002         	str	r0, [sp, #0x8]
;   if (pxTCB == pxCurrentTCB) {
700a3c3a: 9802         	ldr	r0, [sp, #0x8]
700a3c3c: f640 51ac    	movw	r1, #0xdac
700a3c40: f2c7 010b    	movt	r1, #0x700b
700a3c44: 6809         	ldr	r1, [r1]
700a3c46: 4288         	cmp	r0, r1
700a3c48: d104         	bne	0x700a3c54 <eTaskGetState+0x24> @ imm = #0x8
700a3c4a: e7ff         	b	0x700a3c4c <eTaskGetState+0x1c> @ imm = #-0x2
700a3c4c: 2000         	movs	r0, #0x0
;     eReturn = eRunning;
700a3c4e: f88d 001b    	strb.w	r0, [sp, #0x1b]
;   } else {
700a3c52: e063         	b	0x700a3d1c <eTaskGetState+0xec> @ imm = #0xc6
;     taskENTER_CRITICAL();
700a3c54: f008 ffbc    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0x8f78
;       pxStateList = listLIST_ITEM_CONTAINER(&(pxTCB->xStateListItem));
700a3c58: 9802         	ldr	r0, [sp, #0x8]
700a3c5a: 6940         	ldr	r0, [r0, #0x14]
700a3c5c: 9005         	str	r0, [sp, #0x14]
;       pxDelayedList = pxDelayedTaskList;
700a3c5e: f644 50b0    	movw	r0, #0x4db0
700a3c62: f2c7 0008    	movt	r0, #0x7008
700a3c66: 6800         	ldr	r0, [r0]
700a3c68: 9004         	str	r0, [sp, #0x10]
;       pxOverflowedDelayedList = pxOverflowDelayedTaskList;
700a3c6a: f644 50b4    	movw	r0, #0x4db4
700a3c6e: f2c7 0008    	movt	r0, #0x7008
700a3c72: 6800         	ldr	r0, [r0]
700a3c74: 9003         	str	r0, [sp, #0xc]
;     taskEXIT_CRITICAL();
700a3c76: f008 f82b    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x8056
;     if ((pxStateList == pxDelayedList) ||
700a3c7a: 9805         	ldr	r0, [sp, #0x14]
700a3c7c: 9904         	ldr	r1, [sp, #0x10]
700a3c7e: 4288         	cmp	r0, r1
700a3c80: d005         	beq	0x700a3c8e <eTaskGetState+0x5e> @ imm = #0xa
700a3c82: e7ff         	b	0x700a3c84 <eTaskGetState+0x54> @ imm = #-0x2
;         (pxStateList == pxOverflowedDelayedList)) {
700a3c84: 9805         	ldr	r0, [sp, #0x14]
700a3c86: 9903         	ldr	r1, [sp, #0xc]
;     if ((pxStateList == pxDelayedList) ||
700a3c88: 4288         	cmp	r0, r1
700a3c8a: d104         	bne	0x700a3c96 <eTaskGetState+0x66> @ imm = #0x8
700a3c8c: e7ff         	b	0x700a3c8e <eTaskGetState+0x5e> @ imm = #-0x2
700a3c8e: 2002         	movs	r0, #0x2
;       eReturn = eBlocked;
700a3c90: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     }
700a3c94: e041         	b	0x700a3d1a <eTaskGetState+0xea> @ imm = #0x82
;     else if (pxStateList == &xSuspendedTaskList) {
700a3c96: 9805         	ldr	r0, [sp, #0x14]
700a3c98: f644 5174    	movw	r1, #0x4d74
700a3c9c: f2c7 0108    	movt	r1, #0x7008
700a3ca0: 4288         	cmp	r0, r1
700a3ca2: d125         	bne	0x700a3cf0 <eTaskGetState+0xc0> @ imm = #0x4a
700a3ca4: e7ff         	b	0x700a3ca6 <eTaskGetState+0x76> @ imm = #-0x2
;       if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL) {
700a3ca6: 9802         	ldr	r0, [sp, #0x8]
700a3ca8: 6a80         	ldr	r0, [r0, #0x28]
700a3caa: b9e0         	cbnz	r0, 0x700a3ce6 <eTaskGetState+0xb6> @ imm = #0x38
700a3cac: e7ff         	b	0x700a3cae <eTaskGetState+0x7e> @ imm = #-0x2
700a3cae: 2003         	movs	r0, #0x3
;           eReturn = eSuspended;
700a3cb0: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a3cb4: 2000         	movs	r0, #0x0
;           for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a3cb6: 9001         	str	r0, [sp, #0x4]
700a3cb8: e7ff         	b	0x700a3cba <eTaskGetState+0x8a> @ imm = #-0x2
700a3cba: 9801         	ldr	r0, [sp, #0x4]
700a3cbc: 2800         	cmp	r0, #0x0
700a3cbe: dc11         	bgt	0x700a3ce4 <eTaskGetState+0xb4> @ imm = #0x22
700a3cc0: e7ff         	b	0x700a3cc2 <eTaskGetState+0x92> @ imm = #-0x2
;             if (pxTCB->ucNotifyState[x] == taskWAITING_NOTIFICATION) {
700a3cc2: 9802         	ldr	r0, [sp, #0x8]
700a3cc4: 9901         	ldr	r1, [sp, #0x4]
700a3cc6: 4408         	add	r0, r1
700a3cc8: f890 0080    	ldrb.w	r0, [r0, #0x80]
700a3ccc: 2801         	cmp	r0, #0x1
700a3cce: d104         	bne	0x700a3cda <eTaskGetState+0xaa> @ imm = #0x8
700a3cd0: e7ff         	b	0x700a3cd2 <eTaskGetState+0xa2> @ imm = #-0x2
700a3cd2: 2002         	movs	r0, #0x2
;               eReturn = eBlocked;
700a3cd4: f88d 001b    	strb.w	r0, [sp, #0x1b]
;               break;
700a3cd8: e004         	b	0x700a3ce4 <eTaskGetState+0xb4> @ imm = #0x8
;           }
700a3cda: e7ff         	b	0x700a3cdc <eTaskGetState+0xac> @ imm = #-0x2
;           for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a3cdc: 9801         	ldr	r0, [sp, #0x4]
700a3cde: 3001         	adds	r0, #0x1
700a3ce0: 9001         	str	r0, [sp, #0x4]
700a3ce2: e7ea         	b	0x700a3cba <eTaskGetState+0x8a> @ imm = #-0x2c
;       } else {
700a3ce4: e003         	b	0x700a3cee <eTaskGetState+0xbe> @ imm = #0x6
700a3ce6: 2002         	movs	r0, #0x2
;         eReturn = eBlocked;
700a3ce8: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a3cec: e7ff         	b	0x700a3cee <eTaskGetState+0xbe> @ imm = #-0x2
;     }
700a3cee: e013         	b	0x700a3d18 <eTaskGetState+0xe8> @ imm = #0x26
;     else if ((pxStateList == &xTasksWaitingTermination) ||
700a3cf0: 9805         	ldr	r0, [sp, #0x14]
700a3cf2: f644 5188    	movw	r1, #0x4d88
700a3cf6: f2c7 0108    	movt	r1, #0x7008
700a3cfa: 4288         	cmp	r0, r1
700a3cfc: d003         	beq	0x700a3d06 <eTaskGetState+0xd6> @ imm = #0x6
700a3cfe: e7ff         	b	0x700a3d00 <eTaskGetState+0xd0> @ imm = #-0x2
;              (pxStateList == NULL)) {
700a3d00: 9805         	ldr	r0, [sp, #0x14]
;     else if ((pxStateList == &xTasksWaitingTermination) ||
700a3d02: b920         	cbnz	r0, 0x700a3d0e <eTaskGetState+0xde> @ imm = #0x8
700a3d04: e7ff         	b	0x700a3d06 <eTaskGetState+0xd6> @ imm = #-0x2
700a3d06: 2004         	movs	r0, #0x4
;       eReturn = eDeleted;
700a3d08: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     }
700a3d0c: e003         	b	0x700a3d16 <eTaskGetState+0xe6> @ imm = #0x6
700a3d0e: 2001         	movs	r0, #0x1
;       eReturn = eReady;
700a3d10: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a3d14: e7ff         	b	0x700a3d16 <eTaskGetState+0xe6> @ imm = #-0x2
700a3d16: e7ff         	b	0x700a3d18 <eTaskGetState+0xe8> @ imm = #-0x2
700a3d18: e7ff         	b	0x700a3d1a <eTaskGetState+0xea> @ imm = #-0x2
700a3d1a: e7ff         	b	0x700a3d1c <eTaskGetState+0xec> @ imm = #-0x2
;   return eReturn;
700a3d1c: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a3d20: b008         	add	sp, #0x20
700a3d22: bd80         	pop	{r7, pc}
		...

700a3d30 <PMU_profileEnd>:
; int32_t PMU_profileEnd(const char *name) {
700a3d30: b580         	push	{r7, lr}
700a3d32: b090         	sub	sp, #0x40
700a3d34: 900e         	str	r0, [sp, #0x38]
;   if (gProfileObject.logIndex >= PMU_MAX_LOG_ENTRIES) {
700a3d36: f243 0080    	movw	r0, #0x3080
700a3d3a: f2c7 0008    	movt	r0, #0x7008
700a3d3e: 6800         	ldr	r0, [r0]
700a3d40: 2840         	cmp	r0, #0x40
700a3d42: d304         	blo	0x700a3d4e <PMU_profileEnd+0x1e> @ imm = #0x8
700a3d44: e7ff         	b	0x700a3d46 <PMU_profileEnd+0x16> @ imm = #-0x2
700a3d46: f04f 30ff    	mov.w	r0, #0xffffffff
;     return SystemP_FAILURE; /* Log is full */
700a3d4a: 900f         	str	r0, [sp, #0x3c]
700a3d4c: e065         	b	0x700a3e1a <PMU_profileEnd+0xea> @ imm = #0xca
700a3d4e: 2000         	movs	r0, #0x0
;   int32_t status = SystemP_SUCCESS;
700a3d50: 9000         	str	r0, [sp]
700a3d52: 900d         	str	r0, [sp, #0x34]
700a3d54: 201f         	movs	r0, #0x1f
;   uint32_t ccount = CSL_armR5PmuReadCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM);
700a3d56: f7fc ed62    	blx	0x700a081c <CSL_armR5PmuReadCntr> @ imm = #-0x353c
700a3d5a: 4601         	mov	r1, r0
700a3d5c: 9800         	ldr	r0, [sp]
700a3d5e: 910c         	str	r1, [sp, #0x30]
;   uint32_t count0 = CSL_armR5PmuReadCntr(0);
700a3d60: f7fc ed5c    	blx	0x700a081c <CSL_armR5PmuReadCntr> @ imm = #-0x3548
700a3d64: 900b         	str	r0, [sp, #0x2c]
700a3d66: 2001         	movs	r0, #0x1
;   uint32_t count1 = CSL_armR5PmuReadCntr(1);
700a3d68: f7fc ed58    	blx	0x700a081c <CSL_armR5PmuReadCntr> @ imm = #-0x3550
700a3d6c: 900a         	str	r0, [sp, #0x28]
700a3d6e: 2002         	movs	r0, #0x2
;   uint32_t count2 = CSL_armR5PmuReadCntr(2);
700a3d70: f7fc ed54    	blx	0x700a081c <CSL_armR5PmuReadCntr> @ imm = #-0x3558
700a3d74: 9009         	str	r0, [sp, #0x24]
;   uint32_t counts[3] = {count0, count1, count2};
700a3d76: 980b         	ldr	r0, [sp, #0x2c]
700a3d78: 9006         	str	r0, [sp, #0x18]
700a3d7a: 980a         	ldr	r0, [sp, #0x28]
700a3d7c: 9007         	str	r0, [sp, #0x1c]
700a3d7e: 9809         	ldr	r0, [sp, #0x24]
700a3d80: 9008         	str	r0, [sp, #0x20]
;   uint32_t i = gProfileObject.logIndex;
700a3d82: f243 0280    	movw	r2, #0x3080
700a3d86: f2c7 0208    	movt	r2, #0x7008
700a3d8a: 6810         	ldr	r0, [r2]
700a3d8c: 9005         	str	r0, [sp, #0x14]
;   uint32_t numEvents = gProfileObject.numEvents;
700a3d8e: 6890         	ldr	r0, [r2, #0x8]
700a3d90: 9003         	str	r0, [sp, #0xc]
;   uint32_t bCCnt = gProfileObject.bCycleCounter;
700a3d92: 6850         	ldr	r0, [r2, #0x4]
700a3d94: 9002         	str	r0, [sp, #0x8]
;   PMU_ProfilePoint *p = &gProfileObject.point[i];
700a3d96: 9805         	ldr	r0, [sp, #0x14]
700a3d98: 2134         	movs	r1, #0x34
700a3d9a: fb00 2001    	mla	r0, r0, r1, r2
700a3d9e: 300c         	adds	r0, #0xc
700a3da0: 9001         	str	r0, [sp, #0x4]
;   if (strcmp(name, p->name) != 0) {
700a3da2: 980e         	ldr	r0, [sp, #0x38]
700a3da4: 9901         	ldr	r1, [sp, #0x4]
700a3da6: 6b09         	ldr	r1, [r1, #0x30]
700a3da8: f7f7 e90a    	blx	0x7009afc0 <strcmp>     @ imm = #-0x8dec
700a3dac: b120         	cbz	r0, 0x700a3db8 <PMU_profileEnd+0x88> @ imm = #0x8
700a3dae: e7ff         	b	0x700a3db0 <PMU_profileEnd+0x80> @ imm = #-0x2
700a3db0: f04f 30ff    	mov.w	r0, #0xffffffff
;     status = SystemP_FAILURE;
700a3db4: 900d         	str	r0, [sp, #0x34]
;   }
700a3db6: e7ff         	b	0x700a3db8 <PMU_profileEnd+0x88> @ imm = #-0x2
;   if (status == SystemP_SUCCESS) {
700a3db8: 980d         	ldr	r0, [sp, #0x34]
700a3dba: bb58         	cbnz	r0, 0x700a3e14 <PMU_profileEnd+0xe4> @ imm = #0x56
700a3dbc: e7ff         	b	0x700a3dbe <PMU_profileEnd+0x8e> @ imm = #-0x2
;     if (bCCnt == TRUE) {
700a3dbe: 9802         	ldr	r0, [sp, #0x8]
700a3dc0: 2801         	cmp	r0, #0x1
700a3dc2: d106         	bne	0x700a3dd2 <PMU_profileEnd+0xa2> @ imm = #0xc
700a3dc4: e7ff         	b	0x700a3dc6 <PMU_profileEnd+0x96> @ imm = #-0x2
;       p->cycleCount.value = ccount - p->cycleCount.value;
700a3dc6: 980c         	ldr	r0, [sp, #0x30]
700a3dc8: 9901         	ldr	r1, [sp, #0x4]
700a3dca: 6aca         	ldr	r2, [r1, #0x2c]
700a3dcc: 1a80         	subs	r0, r0, r2
700a3dce: 62c8         	str	r0, [r1, #0x2c]
;     }
700a3dd0: e7ff         	b	0x700a3dd2 <PMU_profileEnd+0xa2> @ imm = #-0x2
700a3dd2: 2000         	movs	r0, #0x0
;     for (j = 0; j < numEvents; j++) {
700a3dd4: 9004         	str	r0, [sp, #0x10]
700a3dd6: e7ff         	b	0x700a3dd8 <PMU_profileEnd+0xa8> @ imm = #-0x2
700a3dd8: 9804         	ldr	r0, [sp, #0x10]
700a3dda: 9903         	ldr	r1, [sp, #0xc]
700a3ddc: 4288         	cmp	r0, r1
700a3dde: d211         	bhs	0x700a3e04 <PMU_profileEnd+0xd4> @ imm = #0x22
700a3de0: e7ff         	b	0x700a3de2 <PMU_profileEnd+0xb2> @ imm = #-0x2
;       p->events[j].value = counts[j] - p->events[j].value;
700a3de2: 9a04         	ldr	r2, [sp, #0x10]
700a3de4: a806         	add	r0, sp, #0x18
700a3de6: f850 0022    	ldr.w	r0, [r0, r2, lsl #2]
700a3dea: 9901         	ldr	r1, [sp, #0x4]
700a3dec: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a3df0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a3df4: 688a         	ldr	r2, [r1, #0x8]
700a3df6: 1a80         	subs	r0, r0, r2
700a3df8: 6088         	str	r0, [r1, #0x8]
;     }
700a3dfa: e7ff         	b	0x700a3dfc <PMU_profileEnd+0xcc> @ imm = #-0x2
;     for (j = 0; j < numEvents; j++) {
700a3dfc: 9804         	ldr	r0, [sp, #0x10]
700a3dfe: 3001         	adds	r0, #0x1
700a3e00: 9004         	str	r0, [sp, #0x10]
700a3e02: e7e9         	b	0x700a3dd8 <PMU_profileEnd+0xa8> @ imm = #-0x2e
;     gProfileObject.logIndex++;
700a3e04: f243 0180    	movw	r1, #0x3080
700a3e08: f2c7 0108    	movt	r1, #0x7008
700a3e0c: 6808         	ldr	r0, [r1]
700a3e0e: 3001         	adds	r0, #0x1
700a3e10: 6008         	str	r0, [r1]
;   }
700a3e12: e7ff         	b	0x700a3e14 <PMU_profileEnd+0xe4> @ imm = #-0x2
;   return status;
700a3e14: 980d         	ldr	r0, [sp, #0x34]
700a3e16: 900f         	str	r0, [sp, #0x3c]
700a3e18: e7ff         	b	0x700a3e1a <PMU_profileEnd+0xea> @ imm = #-0x2
; }
700a3e1a: 980f         	ldr	r0, [sp, #0x3c]
700a3e1c: b010         	add	sp, #0x40
700a3e1e: bd80         	pop	{r7, pc}

700a3e20 <Udma_eventIsrFxn>:
; {
700a3e20: b580         	push	{r7, lr}
700a3e22: b088         	sub	sp, #0x20
700a3e24: 9007         	str	r0, [sp, #0x1c]
;     Udma_EventHandleInt eventHandle = (Udma_EventHandleInt) args;
700a3e26: 9807         	ldr	r0, [sp, #0x1c]
700a3e28: 9003         	str	r0, [sp, #0xc]
700a3e2a: 2001         	movs	r0, #0x1
;     teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_NA;
700a3e2c: 9004         	str	r0, [sp, #0x10]
700a3e2e: 2000         	movs	r0, #0x0
;     ringHandle = NULL;
700a3e30: 9000         	str	r0, [sp]
;     drvHandle = eventHandle->drvHandle;
700a3e32: 9803         	ldr	r0, [sp, #0xc]
700a3e34: 6800         	ldr	r0, [r0]
700a3e36: 9002         	str	r0, [sp, #0x8]
;     vintrNum = eventHandle->vintrNum;
700a3e38: 9803         	ldr	r0, [sp, #0xc]
700a3e3a: 6cc0         	ldr	r0, [r0, #0x4c]
700a3e3c: 9005         	str	r0, [sp, #0x14]
;     while(eventHandle != NULL_PTR)
700a3e3e: e7ff         	b	0x700a3e40 <Udma_eventIsrFxn+0x20> @ imm = #-0x2
700a3e40: 9803         	ldr	r0, [sp, #0xc]
700a3e42: 2800         	cmp	r0, #0x0
700a3e44: d060         	beq	0x700a3f08 <Udma_eventIsrFxn+0xe8> @ imm = #0xc0
700a3e46: e7ff         	b	0x700a3e48 <Udma_eventIsrFxn+0x28> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_MASTER != eventHandle->eventPrms.eventType)
700a3e48: 9803         	ldr	r0, [sp, #0xc]
700a3e4a: 6880         	ldr	r0, [r0, #0x8]
700a3e4c: 2805         	cmp	r0, #0x5
700a3e4e: d057         	beq	0x700a3f00 <Udma_eventIsrFxn+0xe0> @ imm = #0xae
700a3e50: e7ff         	b	0x700a3e52 <Udma_eventIsrFxn+0x32> @ imm = #-0x2
;             vintrBitNum = vintrNum * UDMA_MAX_EVENTS_PER_VINTR;
700a3e52: 9805         	ldr	r0, [sp, #0x14]
700a3e54: 0180         	lsls	r0, r0, #0x6
700a3e56: 9006         	str	r0, [sp, #0x18]
;             vintrBitNum += eventHandle->vintrBitNum;
700a3e58: 9803         	ldr	r0, [sp, #0xc]
700a3e5a: 6d01         	ldr	r1, [r0, #0x50]
700a3e5c: 9806         	ldr	r0, [sp, #0x18]
700a3e5e: 4408         	add	r0, r1
700a3e60: 9006         	str	r0, [sp, #0x18]
;             if((bool)true == CSL_intaggrIsIntrPending(&drvHandle->iaRegs, vintrBitNum, (bool)true))
700a3e62: 9802         	ldr	r0, [sp, #0x8]
700a3e64: 309c         	adds	r0, #0x9c
700a3e66: 9906         	ldr	r1, [sp, #0x18]
700a3e68: 2201         	movs	r2, #0x1
700a3e6a: f002 fe81    	bl	0x700a6b70 <CSL_intaggrIsIntrPending> @ imm = #0x2d02
700a3e6e: 2800         	cmp	r0, #0x0
700a3e70: d045         	beq	0x700a3efe <Udma_eventIsrFxn+0xde> @ imm = #0x8a
700a3e72: e7ff         	b	0x700a3e74 <Udma_eventIsrFxn+0x54> @ imm = #-0x2
;                 (void) CSL_intaggrClrIntr(&drvHandle->iaRegs, vintrBitNum);
700a3e74: 9802         	ldr	r0, [sp, #0x8]
700a3e76: 309c         	adds	r0, #0x9c
700a3e78: 9906         	ldr	r1, [sp, #0x18]
700a3e7a: f005 fcd1    	bl	0x700a9820 <CSL_intaggrClrIntr> @ imm = #0x59a2
;                 eventPrms = &eventHandle->eventPrms;
700a3e7e: 9803         	ldr	r0, [sp, #0xc]
700a3e80: 3008         	adds	r0, #0x8
700a3e82: 9001         	str	r0, [sp, #0x4]
;                 if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a3e84: 9801         	ldr	r0, [sp, #0x4]
700a3e86: 6800         	ldr	r0, [r0]
700a3e88: 2801         	cmp	r0, #0x1
700a3e8a: d005         	beq	0x700a3e98 <Udma_eventIsrFxn+0x78> @ imm = #0xa
700a3e8c: e7ff         	b	0x700a3e8e <Udma_eventIsrFxn+0x6e> @ imm = #-0x2
;                    (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
700a3e8e: 9801         	ldr	r0, [sp, #0x4]
700a3e90: 6800         	ldr	r0, [r0]
;                 if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a3e92: 2806         	cmp	r0, #0x6
700a3e94: d114         	bne	0x700a3ec0 <Udma_eventIsrFxn+0xa0> @ imm = #0x28
700a3e96: e7ff         	b	0x700a3e98 <Udma_eventIsrFxn+0x78> @ imm = #-0x2
;                     ringHandle = ((Udma_ChHandleInt) (eventPrms->chHandle))->cqRing;
700a3e98: 9801         	ldr	r0, [sp, #0x4]
700a3e9a: 6880         	ldr	r0, [r0, #0x8]
700a3e9c: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a3ea0: 9000         	str	r0, [sp]
;                     if( CSL_lcdma_ringaccIsTeardownComplete(&ringHandle->drvHandle->lcdmaRaRegs, ringHandle->ringNum) == TRUE )
700a3ea2: 9900         	ldr	r1, [sp]
700a3ea4: 6808         	ldr	r0, [r1]
700a3ea6: 308c         	adds	r0, #0x8c
700a3ea8: 8889         	ldrh	r1, [r1, #0x4]
700a3eaa: f008 f879    	bl	0x700abfa0 <CSL_lcdma_ringaccIsTeardownComplete> @ imm = #0x80f2
700a3eae: b118         	cbz	r0, 0x700a3eb8 <Udma_eventIsrFxn+0x98> @ imm = #0x6
700a3eb0: e7ff         	b	0x700a3eb2 <Udma_eventIsrFxn+0x92> @ imm = #-0x2
700a3eb2: 2002         	movs	r0, #0x2
;                         teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE;
700a3eb4: 9004         	str	r0, [sp, #0x10]
;                     }
700a3eb6: e002         	b	0x700a3ebe <Udma_eventIsrFxn+0x9e> @ imm = #0x4
700a3eb8: 2003         	movs	r0, #0x3
;                         teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_INCOMPLETE;
700a3eba: 9004         	str	r0, [sp, #0x10]
700a3ebc: e7ff         	b	0x700a3ebe <Udma_eventIsrFxn+0x9e> @ imm = #-0x2
;                 }
700a3ebe: e7ff         	b	0x700a3ec0 <Udma_eventIsrFxn+0xa0> @ imm = #-0x2
;                 if(!(((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_DMA_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE)) ||
700a3ec0: 9803         	ldr	r0, [sp, #0xc]
700a3ec2: 6880         	ldr	r0, [r0, #0x8]
700a3ec4: 2801         	cmp	r0, #0x1
700a3ec6: d104         	bne	0x700a3ed2 <Udma_eventIsrFxn+0xb2> @ imm = #0x8
700a3ec8: e7ff         	b	0x700a3eca <Udma_eventIsrFxn+0xaa> @ imm = #-0x2
700a3eca: 9804         	ldr	r0, [sp, #0x10]
700a3ecc: 2802         	cmp	r0, #0x2
700a3ece: d015         	beq	0x700a3efc <Udma_eventIsrFxn+0xdc> @ imm = #0x2a
700a3ed0: e7ff         	b	0x700a3ed2 <Udma_eventIsrFxn+0xb2> @ imm = #-0x2
;                  ((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_TEARDOWN_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_INCOMPLETE))))
700a3ed2: 9803         	ldr	r0, [sp, #0xc]
700a3ed4: 6880         	ldr	r0, [r0, #0x8]
700a3ed6: 2806         	cmp	r0, #0x6
700a3ed8: d104         	bne	0x700a3ee4 <Udma_eventIsrFxn+0xc4> @ imm = #0x8
700a3eda: e7ff         	b	0x700a3edc <Udma_eventIsrFxn+0xbc> @ imm = #-0x2
700a3edc: 9804         	ldr	r0, [sp, #0x10]
;                 if(!(((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_DMA_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE)) ||
700a3ede: 2803         	cmp	r0, #0x3
700a3ee0: d00c         	beq	0x700a3efc <Udma_eventIsrFxn+0xdc> @ imm = #0x18
700a3ee2: e7ff         	b	0x700a3ee4 <Udma_eventIsrFxn+0xc4> @ imm = #-0x2
;                     if((Udma_EventCallback) NULL_PTR != eventPrms->eventCb)
700a3ee4: 9801         	ldr	r0, [sp, #0x4]
700a3ee6: 6940         	ldr	r0, [r0, #0x14]
700a3ee8: b138         	cbz	r0, 0x700a3efa <Udma_eventIsrFxn+0xda> @ imm = #0xe
700a3eea: e7ff         	b	0x700a3eec <Udma_eventIsrFxn+0xcc> @ imm = #-0x2
;                         eventPrms->eventCb(
700a3eec: 9a01         	ldr	r2, [sp, #0x4]
;                             eventHandle, eventPrms->eventType, eventPrms->appData);
700a3eee: 9803         	ldr	r0, [sp, #0xc]
700a3ef0: 6811         	ldr	r1, [r2]
;                         eventPrms->eventCb(
700a3ef2: 6953         	ldr	r3, [r2, #0x14]
;                             eventHandle, eventPrms->eventType, eventPrms->appData);
700a3ef4: 69d2         	ldr	r2, [r2, #0x1c]
;                         eventPrms->eventCb(
700a3ef6: 4798         	blx	r3
;                     }
700a3ef8: e7ff         	b	0x700a3efa <Udma_eventIsrFxn+0xda> @ imm = #-0x2
;                 }
700a3efa: e7ff         	b	0x700a3efc <Udma_eventIsrFxn+0xdc> @ imm = #-0x2
;             }
700a3efc: e7ff         	b	0x700a3efe <Udma_eventIsrFxn+0xde> @ imm = #-0x2
;         }
700a3efe: e7ff         	b	0x700a3f00 <Udma_eventIsrFxn+0xe0> @ imm = #-0x2
;         eventHandle = eventHandle->nextEvent;
700a3f00: 9803         	ldr	r0, [sp, #0xc]
700a3f02: 6dc0         	ldr	r0, [r0, #0x5c]
700a3f04: 9003         	str	r0, [sp, #0xc]
;     while(eventHandle != NULL_PTR)
700a3f06: e79b         	b	0x700a3e40 <Udma_eventIsrFxn+0x20> @ imm = #-0xca
;     return;
700a3f08: b008         	add	sp, #0x20
700a3f0a: bd80         	pop	{r7, pc}
700a3f0c: 0000         	movs	r0, r0
700a3f0e: 0000         	movs	r0, r0

700a3f10 <vTaskPriorityDisinheritAfterTimeout>:
;     UBaseType_t uxHighestPriorityWaitingTask) {
700a3f10: b580         	push	{r7, lr}
700a3f12: b086         	sub	sp, #0x18
700a3f14: 9005         	str	r0, [sp, #0x14]
700a3f16: 9104         	str	r1, [sp, #0x10]
;   TCB_t *const pxTCB = pxMutexHolder;
700a3f18: 9805         	ldr	r0, [sp, #0x14]
700a3f1a: 9003         	str	r0, [sp, #0xc]
700a3f1c: 2001         	movs	r0, #0x1
;   const UBaseType_t uxOnlyOneMutexHeld = (UBaseType_t)1;
700a3f1e: 9000         	str	r0, [sp]
;   if (pxMutexHolder != NULL) {
700a3f20: 9805         	ldr	r0, [sp, #0x14]
700a3f22: 2800         	cmp	r0, #0x0
700a3f24: d067         	beq	0x700a3ff6 <vTaskPriorityDisinheritAfterTimeout+0xe6> @ imm = #0xce
700a3f26: e7ff         	b	0x700a3f28 <vTaskPriorityDisinheritAfterTimeout+0x18> @ imm = #-0x2
;     if (pxTCB->uxBasePriority < uxHighestPriorityWaitingTask) {
700a3f28: 9803         	ldr	r0, [sp, #0xc]
700a3f2a: 6e00         	ldr	r0, [r0, #0x60]
700a3f2c: 9904         	ldr	r1, [sp, #0x10]
700a3f2e: 4288         	cmp	r0, r1
700a3f30: d203         	bhs	0x700a3f3a <vTaskPriorityDisinheritAfterTimeout+0x2a> @ imm = #0x6
700a3f32: e7ff         	b	0x700a3f34 <vTaskPriorityDisinheritAfterTimeout+0x24> @ imm = #-0x2
;       uxPriorityToUse = uxHighestPriorityWaitingTask;
700a3f34: 9804         	ldr	r0, [sp, #0x10]
700a3f36: 9001         	str	r0, [sp, #0x4]
;     } else {
700a3f38: e003         	b	0x700a3f42 <vTaskPriorityDisinheritAfterTimeout+0x32> @ imm = #0x6
;       uxPriorityToUse = pxTCB->uxBasePriority;
700a3f3a: 9803         	ldr	r0, [sp, #0xc]
700a3f3c: 6e00         	ldr	r0, [r0, #0x60]
700a3f3e: 9001         	str	r0, [sp, #0x4]
700a3f40: e7ff         	b	0x700a3f42 <vTaskPriorityDisinheritAfterTimeout+0x32> @ imm = #-0x2
;     if (pxTCB->uxPriority != uxPriorityToUse) {
700a3f42: 9803         	ldr	r0, [sp, #0xc]
700a3f44: 6ac0         	ldr	r0, [r0, #0x2c]
700a3f46: 9901         	ldr	r1, [sp, #0x4]
700a3f48: 4288         	cmp	r0, r1
700a3f4a: d052         	beq	0x700a3ff2 <vTaskPriorityDisinheritAfterTimeout+0xe2> @ imm = #0xa4
700a3f4c: e7ff         	b	0x700a3f4e <vTaskPriorityDisinheritAfterTimeout+0x3e> @ imm = #-0x2
;       if (pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld) {
700a3f4e: 9803         	ldr	r0, [sp, #0xc]
700a3f50: 6e40         	ldr	r0, [r0, #0x64]
700a3f52: 2801         	cmp	r0, #0x1
700a3f54: d14b         	bne	0x700a3fee <vTaskPriorityDisinheritAfterTimeout+0xde> @ imm = #0x96
700a3f56: e7ff         	b	0x700a3f58 <vTaskPriorityDisinheritAfterTimeout+0x48> @ imm = #-0x2
;         uxPriorityUsedOnEntry = pxTCB->uxPriority;
700a3f58: 9803         	ldr	r0, [sp, #0xc]
700a3f5a: 6ac0         	ldr	r0, [r0, #0x2c]
700a3f5c: 9002         	str	r0, [sp, #0x8]
;         pxTCB->uxPriority = uxPriorityToUse;
700a3f5e: 9801         	ldr	r0, [sp, #0x4]
700a3f60: 9903         	ldr	r1, [sp, #0xc]
700a3f62: 62c8         	str	r0, [r1, #0x2c]
;         if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) &
700a3f64: 9803         	ldr	r0, [sp, #0xc]
700a3f66: 7ec0         	ldrb	r0, [r0, #0x1b]
700a3f68: 0600         	lsls	r0, r0, #0x18
700a3f6a: 2800         	cmp	r0, #0x0
700a3f6c: d406         	bmi	0x700a3f7c <vTaskPriorityDisinheritAfterTimeout+0x6c> @ imm = #0xc
700a3f6e: e7ff         	b	0x700a3f70 <vTaskPriorityDisinheritAfterTimeout+0x60> @ imm = #-0x2
;           listSET_LIST_ITEM_VALUE(
700a3f70: 9801         	ldr	r0, [sp, #0x4]
700a3f72: f1c0 0020    	rsb.w	r0, r0, #0x20
700a3f76: 9903         	ldr	r1, [sp, #0xc]
700a3f78: 6188         	str	r0, [r1, #0x18]
;         } else {
700a3f7a: e000         	b	0x700a3f7e <vTaskPriorityDisinheritAfterTimeout+0x6e> @ imm = #0x0
700a3f7c: e7ff         	b	0x700a3f7e <vTaskPriorityDisinheritAfterTimeout+0x6e> @ imm = #-0x2
;         if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]),
700a3f7e: 9803         	ldr	r0, [sp, #0xc]
700a3f80: 6940         	ldr	r0, [r0, #0x14]
700a3f82: 9902         	ldr	r1, [sp, #0x8]
700a3f84: eb01 0281    	add.w	r2, r1, r1, lsl #2
700a3f88: f244 41f8    	movw	r1, #0x44f8
700a3f8c: f2c7 0108    	movt	r1, #0x7008
700a3f90: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a3f94: 4288         	cmp	r0, r1
700a3f96: d128         	bne	0x700a3fea <vTaskPriorityDisinheritAfterTimeout+0xda> @ imm = #0x50
700a3f98: e7ff         	b	0x700a3f9a <vTaskPriorityDisinheritAfterTimeout+0x8a> @ imm = #-0x2
;           if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a3f9a: 9803         	ldr	r0, [sp, #0xc]
700a3f9c: 3004         	adds	r0, #0x4
700a3f9e: f007 fda7    	bl	0x700abaf0 <uxListRemove> @ imm = #0x7b4e
700a3fa2: b908         	cbnz	r0, 0x700a3fa8 <vTaskPriorityDisinheritAfterTimeout+0x98> @ imm = #0x2
700a3fa4: e7ff         	b	0x700a3fa6 <vTaskPriorityDisinheritAfterTimeout+0x96> @ imm = #-0x2
;           } else {
700a3fa6: e000         	b	0x700a3faa <vTaskPriorityDisinheritAfterTimeout+0x9a> @ imm = #0x0
700a3fa8: e7ff         	b	0x700a3faa <vTaskPriorityDisinheritAfterTimeout+0x9a> @ imm = #-0x2
;           prvAddTaskToReadyList(pxTCB);
700a3faa: 9803         	ldr	r0, [sp, #0xc]
700a3fac: 6ac0         	ldr	r0, [r0, #0x2c]
700a3fae: f640 51dc    	movw	r1, #0xddc
700a3fb2: f2c7 010b    	movt	r1, #0x700b
700a3fb6: 6809         	ldr	r1, [r1]
700a3fb8: 4288         	cmp	r0, r1
700a3fba: d908         	bls	0x700a3fce <vTaskPriorityDisinheritAfterTimeout+0xbe> @ imm = #0x10
700a3fbc: e7ff         	b	0x700a3fbe <vTaskPriorityDisinheritAfterTimeout+0xae> @ imm = #-0x2
700a3fbe: 9803         	ldr	r0, [sp, #0xc]
700a3fc0: 6ac0         	ldr	r0, [r0, #0x2c]
700a3fc2: f640 51dc    	movw	r1, #0xddc
700a3fc6: f2c7 010b    	movt	r1, #0x700b
700a3fca: 6008         	str	r0, [r1]
700a3fcc: e7ff         	b	0x700a3fce <vTaskPriorityDisinheritAfterTimeout+0xbe> @ imm = #-0x2
700a3fce: 9903         	ldr	r1, [sp, #0xc]
700a3fd0: 6ac8         	ldr	r0, [r1, #0x2c]
700a3fd2: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a3fd6: f244 40f8    	movw	r0, #0x44f8
700a3fda: f2c7 0008    	movt	r0, #0x7008
700a3fde: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a3fe2: 3104         	adds	r1, #0x4
700a3fe4: f008 fb5c    	bl	0x700ac6a0 <vListInsertEnd> @ imm = #0x86b8
;         } else {
700a3fe8: e000         	b	0x700a3fec <vTaskPriorityDisinheritAfterTimeout+0xdc> @ imm = #0x0
700a3fea: e7ff         	b	0x700a3fec <vTaskPriorityDisinheritAfterTimeout+0xdc> @ imm = #-0x2
;       } else {
700a3fec: e000         	b	0x700a3ff0 <vTaskPriorityDisinheritAfterTimeout+0xe0> @ imm = #0x0
700a3fee: e7ff         	b	0x700a3ff0 <vTaskPriorityDisinheritAfterTimeout+0xe0> @ imm = #-0x2
;     } else {
700a3ff0: e000         	b	0x700a3ff4 <vTaskPriorityDisinheritAfterTimeout+0xe4> @ imm = #0x0
700a3ff2: e7ff         	b	0x700a3ff4 <vTaskPriorityDisinheritAfterTimeout+0xe4> @ imm = #-0x2
;   } else {
700a3ff4: e000         	b	0x700a3ff8 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #0x0
700a3ff6: e7ff         	b	0x700a3ff8 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #-0x2
; }
700a3ff8: b006         	add	sp, #0x18
700a3ffa: bd80         	pop	{r7, pc}
700a3ffc: 0000         	movs	r0, r0
700a3ffe: 0000         	movs	r0, r0

700a4000 <AddrTranslateP_getLocalAddr>:
; {
700a4000: b580         	push	{r7, lr}
700a4002: b08e         	sub	sp, #0x38
700a4004: 910d         	str	r1, [sp, #0x34]
700a4006: 900c         	str	r0, [sp, #0x30]
;     DebugP_assertNoLog(gAddrTranslateConfig.numRegions<AddrTranslateP_MAX_REGIONS);
700a4008: f640 502c    	movw	r0, #0xd2c
700a400c: f2c7 000b    	movt	r0, #0x700b
700a4010: 6801         	ldr	r1, [r0]
700a4012: 2000         	movs	r0, #0x0
700a4014: 9001         	str	r0, [sp, #0x4]
700a4016: 2910         	cmp	r1, #0x10
700a4018: bf38         	it	lo
700a401a: 2001         	movlo	r0, #0x1
700a401c: f00b fb90    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0xb720
700a4020: 9801         	ldr	r0, [sp, #0x4]
;     found = 0;
700a4022: 900b         	str	r0, [sp, #0x2c]
;     for(regionId=0; regionId<gAddrTranslateConfig.numRegions; regionId++)
700a4024: 900a         	str	r0, [sp, #0x28]
700a4026: e7ff         	b	0x700a4028 <AddrTranslateP_getLocalAddr+0x28> @ imm = #-0x2
700a4028: 980a         	ldr	r0, [sp, #0x28]
700a402a: f640 512c    	movw	r1, #0xd2c
700a402e: f2c7 010b    	movt	r1, #0x700b
700a4032: 6809         	ldr	r1, [r1]
700a4034: 4288         	cmp	r0, r1
700a4036: d23b         	bhs	0x700a40b0 <AddrTranslateP_getLocalAddr+0xb0> @ imm = #0x76
700a4038: e7ff         	b	0x700a403a <AddrTranslateP_getLocalAddr+0x3a> @ imm = #-0x2
;         sizeMask = ( (uint32_t)( ((uint64_t)1U << gAddrTranslateConfig.regionConfig[regionId].size) - 1U) );
700a403a: f640 502c    	movw	r0, #0xd2c
700a403e: f2c7 000b    	movt	r0, #0x700b
700a4042: 6881         	ldr	r1, [r0, #0x8]
700a4044: 9a0a         	ldr	r2, [sp, #0x28]
700a4046: eb01 1102    	add.w	r1, r1, r2, lsl #4
700a404a: 68ca         	ldr	r2, [r1, #0xc]
700a404c: 2101         	movs	r1, #0x1
700a404e: 4091         	lsls	r1, r2
700a4050: 3a20         	subs	r2, #0x20
700a4052: 2a00         	cmp	r2, #0x0
700a4054: bf58         	it	pl
700a4056: 2100         	movpl	r1, #0x0
700a4058: 3901         	subs	r1, #0x1
700a405a: 9103         	str	r1, [sp, #0xc]
;         startAddr = gAddrTranslateConfig.regionConfig[regionId].systemAddr;
700a405c: 6880         	ldr	r0, [r0, #0x8]
700a405e: 9a0a         	ldr	r2, [sp, #0x28]
700a4060: eb00 1102    	add.w	r1, r0, r2, lsl #4
700a4064: ea4f 1202    	lsl.w	r2, r2, #0x4
700a4068: 5880         	ldr	r0, [r0, r2]
700a406a: 6849         	ldr	r1, [r1, #0x4]
700a406c: 9107         	str	r1, [sp, #0x1c]
700a406e: 9006         	str	r0, [sp, #0x18]
;         endAddr = startAddr + sizeMask;
700a4070: 9906         	ldr	r1, [sp, #0x18]
700a4072: 9807         	ldr	r0, [sp, #0x1c]
700a4074: 9a03         	ldr	r2, [sp, #0xc]
700a4076: 1889         	adds	r1, r1, r2
700a4078: f140 0000    	adc	r0, r0, #0x0
700a407c: 9104         	str	r1, [sp, #0x10]
700a407e: 9005         	str	r0, [sp, #0x14]
;         if((systemAddr >= startAddr) && (systemAddr <= endAddr))
700a4080: 9a0c         	ldr	r2, [sp, #0x30]
700a4082: 980d         	ldr	r0, [sp, #0x34]
700a4084: 9b06         	ldr	r3, [sp, #0x18]
700a4086: 9907         	ldr	r1, [sp, #0x1c]
700a4088: 1ad2         	subs	r2, r2, r3
700a408a: 4188         	sbcs	r0, r1
700a408c: d30b         	blo	0x700a40a6 <AddrTranslateP_getLocalAddr+0xa6> @ imm = #0x16
700a408e: e7ff         	b	0x700a4090 <AddrTranslateP_getLocalAddr+0x90> @ imm = #-0x2
700a4090: 9b0c         	ldr	r3, [sp, #0x30]
700a4092: 990d         	ldr	r1, [sp, #0x34]
700a4094: 9a04         	ldr	r2, [sp, #0x10]
700a4096: 9805         	ldr	r0, [sp, #0x14]
700a4098: 1ad2         	subs	r2, r2, r3
700a409a: 4188         	sbcs	r0, r1
700a409c: d303         	blo	0x700a40a6 <AddrTranslateP_getLocalAddr+0xa6> @ imm = #0x6
700a409e: e7ff         	b	0x700a40a0 <AddrTranslateP_getLocalAddr+0xa0> @ imm = #-0x2
700a40a0: 2001         	movs	r0, #0x1
;             found = 1;
700a40a2: 900b         	str	r0, [sp, #0x2c]
;             break;
700a40a4: e004         	b	0x700a40b0 <AddrTranslateP_getLocalAddr+0xb0> @ imm = #0x8
;     }
700a40a6: e7ff         	b	0x700a40a8 <AddrTranslateP_getLocalAddr+0xa8> @ imm = #-0x2
;     for(regionId=0; regionId<gAddrTranslateConfig.numRegions; regionId++)
700a40a8: 980a         	ldr	r0, [sp, #0x28]
700a40aa: 3001         	adds	r0, #0x1
700a40ac: 900a         	str	r0, [sp, #0x28]
700a40ae: e7bb         	b	0x700a4028 <AddrTranslateP_getLocalAddr+0x28> @ imm = #-0x8a
;     if(found != 0U)
700a40b0: 980b         	ldr	r0, [sp, #0x2c]
700a40b2: b1a0         	cbz	r0, 0x700a40de <AddrTranslateP_getLocalAddr+0xde> @ imm = #0x28
700a40b4: e7ff         	b	0x700a40b6 <AddrTranslateP_getLocalAddr+0xb6> @ imm = #-0x2
;         uint32_t offset = systemAddr - gAddrTranslateConfig.regionConfig[regionId].systemAddr;
700a40b6: 990c         	ldr	r1, [sp, #0x30]
700a40b8: f640 502c    	movw	r0, #0xd2c
700a40bc: f2c7 000b    	movt	r0, #0x700b
700a40c0: 6882         	ldr	r2, [r0, #0x8]
700a40c2: 9b0a         	ldr	r3, [sp, #0x28]
700a40c4: 011b         	lsls	r3, r3, #0x4
700a40c6: 58d2         	ldr	r2, [r2, r3]
700a40c8: 1a89         	subs	r1, r1, r2
700a40ca: 9102         	str	r1, [sp, #0x8]
;         localAddr = (void *) (gAddrTranslateConfig.regionConfig[regionId].localAddr + offset);
700a40cc: 6880         	ldr	r0, [r0, #0x8]
700a40ce: 990a         	ldr	r1, [sp, #0x28]
700a40d0: eb00 1001    	add.w	r0, r0, r1, lsl #4
700a40d4: 6880         	ldr	r0, [r0, #0x8]
700a40d6: 9902         	ldr	r1, [sp, #0x8]
700a40d8: 4408         	add	r0, r1
700a40da: 9009         	str	r0, [sp, #0x24]
;     }
700a40dc: e002         	b	0x700a40e4 <AddrTranslateP_getLocalAddr+0xe4> @ imm = #0x4
;         localAddr = (void *) systemAddr;
700a40de: 980c         	ldr	r0, [sp, #0x30]
700a40e0: 9009         	str	r0, [sp, #0x24]
700a40e2: e7ff         	b	0x700a40e4 <AddrTranslateP_getLocalAddr+0xe4> @ imm = #-0x2
;     return localAddr;
700a40e4: 9809         	ldr	r0, [sp, #0x24]
700a40e6: b00e         	add	sp, #0x38
700a40e8: bd80         	pop	{r7, pc}
700a40ea: 0000         	movs	r0, r0
700a40ec: 0000         	movs	r0, r0
700a40ee: 0000         	movs	r0, r0

700a40f0 <Udma_eventFreeResource>:
; {
700a40f0: b580         	push	{r7, lr}
700a40f2: b084         	sub	sp, #0x10
700a40f4: 9003         	str	r0, [sp, #0xc]
700a40f6: 9102         	str	r1, [sp, #0x8]
;     cookie = HwiP_disable();
700a40f8: f00a ee62    	blx	0x700aedc0 <HwiP_disable> @ imm = #0xacc4
700a40fc: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != eventHandle->prevEvent)
700a40fe: 9802         	ldr	r0, [sp, #0x8]
700a4100: 6e00         	ldr	r0, [r0, #0x60]
700a4102: b128         	cbz	r0, 0x700a4110 <Udma_eventFreeResource+0x20> @ imm = #0xa
700a4104: e7ff         	b	0x700a4106 <Udma_eventFreeResource+0x16> @ imm = #-0x2
;         eventHandle->prevEvent->nextEvent = eventHandle->nextEvent;
700a4106: 9902         	ldr	r1, [sp, #0x8]
700a4108: 6dc8         	ldr	r0, [r1, #0x5c]
700a410a: 6e09         	ldr	r1, [r1, #0x60]
700a410c: 65c8         	str	r0, [r1, #0x5c]
;     }
700a410e: e7ff         	b	0x700a4110 <Udma_eventFreeResource+0x20> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->nextEvent)
700a4110: 9802         	ldr	r0, [sp, #0x8]
700a4112: 6dc0         	ldr	r0, [r0, #0x5c]
700a4114: b128         	cbz	r0, 0x700a4122 <Udma_eventFreeResource+0x32> @ imm = #0xa
700a4116: e7ff         	b	0x700a4118 <Udma_eventFreeResource+0x28> @ imm = #-0x2
;         eventHandle->nextEvent->prevEvent = eventHandle->prevEvent;
700a4118: 9802         	ldr	r0, [sp, #0x8]
700a411a: 6dc1         	ldr	r1, [r0, #0x5c]
700a411c: 6e00         	ldr	r0, [r0, #0x60]
700a411e: 6608         	str	r0, [r1, #0x60]
;     }
700a4120: e7ff         	b	0x700a4122 <Udma_eventFreeResource+0x32> @ imm = #-0x2
;     HwiP_restore(cookie);
700a4122: 9801         	ldr	r0, [sp, #0x4]
700a4124: f00a ee6c    	blx	0x700aee00 <HwiP_restore> @ imm = #0xacd8
;     if(NULL_PTR != eventHandle->hwiHandle)
700a4128: 9802         	ldr	r0, [sp, #0x8]
700a412a: 6e40         	ldr	r0, [r0, #0x64]
700a412c: b140         	cbz	r0, 0x700a4140 <Udma_eventFreeResource+0x50> @ imm = #0x10
700a412e: e7ff         	b	0x700a4130 <Udma_eventFreeResource+0x40> @ imm = #-0x2
;         HwiP_destruct(&eventHandle->hwiObject);
700a4130: 9802         	ldr	r0, [sp, #0x8]
700a4132: 3068         	adds	r0, #0x68
700a4134: f00a fa54    	bl	0x700ae5e0 <HwiP_destruct> @ imm = #0xa4a8
;         eventHandle->hwiHandle = NULL_PTR;
700a4138: 9902         	ldr	r1, [sp, #0x8]
700a413a: 2000         	movs	r0, #0x0
700a413c: 6648         	str	r0, [r1, #0x64]
;     }
700a413e: e7ff         	b	0x700a4140 <Udma_eventFreeResource+0x50> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->irIntrNum)
700a4140: 9802         	ldr	r0, [sp, #0x8]
700a4142: 6d40         	ldr	r0, [r0, #0x54]
700a4144: f510 3f80    	cmn.w	r0, #0x10000
700a4148: d00d         	beq	0x700a4166 <Udma_eventFreeResource+0x76> @ imm = #0x1a
700a414a: e7ff         	b	0x700a414c <Udma_eventFreeResource+0x5c> @ imm = #-0x2
;         Udma_rmFreeIrIntr(eventHandle->irIntrNum, drvHandle);
700a414c: 9802         	ldr	r0, [sp, #0x8]
700a414e: 6d40         	ldr	r0, [r0, #0x54]
700a4150: 9903         	ldr	r1, [sp, #0xc]
700a4152: f005 ffc5    	bl	0x700aa0e0 <Udma_rmFreeIrIntr> @ imm = #0x5f8a
;         eventHandle->irIntrNum = UDMA_INTR_INVALID;
700a4156: 9902         	ldr	r1, [sp, #0x8]
700a4158: 2000         	movs	r0, #0x0
700a415a: f6cf 70ff    	movt	r0, #0xffff
700a415e: 6548         	str	r0, [r1, #0x54]
;         eventHandle->coreIntrNum = UDMA_INTR_INVALID;
700a4160: 9902         	ldr	r1, [sp, #0x8]
700a4162: 6588         	str	r0, [r1, #0x58]
;     }
700a4164: e7ff         	b	0x700a4166 <Udma_eventFreeResource+0x76> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->globalEvent)
700a4166: 9802         	ldr	r0, [sp, #0x8]
700a4168: 6c80         	ldr	r0, [r0, #0x48]
700a416a: f64f 71ff    	movw	r1, #0xffff
700a416e: 4288         	cmp	r0, r1
700a4170: d00e         	beq	0x700a4190 <Udma_eventFreeResource+0xa0> @ imm = #0x1c
700a4172: e7ff         	b	0x700a4174 <Udma_eventFreeResource+0x84> @ imm = #-0x2
;         Udma_eventResetSteering(drvHandle, eventHandle);
700a4174: 9803         	ldr	r0, [sp, #0xc]
700a4176: 9902         	ldr	r1, [sp, #0x8]
700a4178: f009 f8ca    	bl	0x700ad310 <Udma_eventResetSteering> @ imm = #0x9194
;         Udma_rmFreeEvent(eventHandle->globalEvent, drvHandle);
700a417c: 9802         	ldr	r0, [sp, #0x8]
700a417e: 6c80         	ldr	r0, [r0, #0x48]
700a4180: 9903         	ldr	r1, [sp, #0xc]
700a4182: f005 ff75    	bl	0x700aa070 <Udma_rmFreeEvent> @ imm = #0x5eea
;         eventHandle->globalEvent = UDMA_EVENT_INVALID;
700a4186: 9902         	ldr	r1, [sp, #0x8]
700a4188: f64f 70ff    	movw	r0, #0xffff
700a418c: 6488         	str	r0, [r1, #0x48]
;     }
700a418e: e7ff         	b	0x700a4190 <Udma_eventFreeResource+0xa0> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
700a4190: 9802         	ldr	r0, [sp, #0x8]
700a4192: 6d00         	ldr	r0, [r0, #0x50]
700a4194: f64f 71ff    	movw	r1, #0xffff
700a4198: 4288         	cmp	r0, r1
700a419a: d00a         	beq	0x700a41b2 <Udma_eventFreeResource+0xc2> @ imm = #0x14
700a419c: e7ff         	b	0x700a419e <Udma_eventFreeResource+0xae> @ imm = #-0x2
;         Udma_rmFreeVintrBit(eventHandle->vintrBitNum, drvHandle, eventHandle);
700a419e: 9a02         	ldr	r2, [sp, #0x8]
700a41a0: 6d10         	ldr	r0, [r2, #0x50]
700a41a2: 9903         	ldr	r1, [sp, #0xc]
700a41a4: f004 fb24    	bl	0x700a87f0 <Udma_rmFreeVintrBit> @ imm = #0x4648
;         eventHandle->vintrBitNum = UDMA_EVENT_INVALID;
700a41a8: 9902         	ldr	r1, [sp, #0x8]
700a41aa: f64f 70ff    	movw	r0, #0xffff
700a41ae: 6508         	str	r0, [r1, #0x50]
;     }
700a41b0: e7ff         	b	0x700a41b2 <Udma_eventFreeResource+0xc2> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->vintrNum)
700a41b2: 9802         	ldr	r0, [sp, #0x8]
700a41b4: 6cc0         	ldr	r0, [r0, #0x4c]
700a41b6: f64f 71ff    	movw	r1, #0xffff
700a41ba: 4288         	cmp	r0, r1
700a41bc: d00a         	beq	0x700a41d4 <Udma_eventFreeResource+0xe4> @ imm = #0x14
700a41be: e7ff         	b	0x700a41c0 <Udma_eventFreeResource+0xd0> @ imm = #-0x2
;         Udma_rmFreeVintr(eventHandle->vintrNum, drvHandle);
700a41c0: 9802         	ldr	r0, [sp, #0x8]
700a41c2: 6cc0         	ldr	r0, [r0, #0x4c]
700a41c4: 9903         	ldr	r1, [sp, #0xc]
700a41c6: f005 ffc3    	bl	0x700aa150 <Udma_rmFreeVintr> @ imm = #0x5f86
;         eventHandle->vintrNum = UDMA_EVENT_INVALID;
700a41ca: 9902         	ldr	r1, [sp, #0x8]
700a41cc: f64f 70ff    	movw	r0, #0xffff
700a41d0: 64c8         	str	r0, [r1, #0x4c]
;     }
700a41d2: e7ff         	b	0x700a41d4 <Udma_eventFreeResource+0xe4> @ imm = #-0x2
;     return;
700a41d4: b004         	add	sp, #0x10
700a41d6: bd80         	pop	{r7, pc}
		...

700a41e0 <DebugP_memTraceLogWriterPutLine>:
; {
700a41e0: b580         	push	{r7, lr}
700a41e2: b08a         	sub	sp, #0x28
700a41e4: 9009         	str	r0, [sp, #0x24]
700a41e6: f8ad 1022    	strh.w	r1, [sp, #0x22]
700a41ea: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700a41ec: 9007         	str	r0, [sp, #0x1c]
;     if (gDebugMemLogSize == 0U)
700a41ee: f640 508c    	movw	r0, #0xd8c
700a41f2: f2c7 000b    	movt	r0, #0x700b
700a41f6: 6800         	ldr	r0, [r0]
700a41f8: b920         	cbnz	r0, 0x700a4204 <DebugP_memTraceLogWriterPutLine+0x24> @ imm = #0x8
700a41fa: e7ff         	b	0x700a41fc <DebugP_memTraceLogWriterPutLine+0x1c> @ imm = #-0x2
700a41fc: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700a4200: 9007         	str	r0, [sp, #0x1c]
;     }
700a4202: e7ff         	b	0x700a4204 <DebugP_memTraceLogWriterPutLine+0x24> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
700a4204: 9807         	ldr	r0, [sp, #0x1c]
700a4206: 2800         	cmp	r0, #0x0
700a4208: d15a         	bne	0x700a42c0 <DebugP_memTraceLogWriterPutLine+0xe0> @ imm = #0xb4
700a420a: e7ff         	b	0x700a420c <DebugP_memTraceLogWriterPutLine+0x2c> @ imm = #-0x2
;         wr_idx = gDebugMemLogWriteIndex;
700a420c: f640 5090    	movw	r0, #0xd90
700a4210: f2c7 000b    	movt	r0, #0x700b
700a4214: 6800         	ldr	r0, [r0]
700a4216: 9006         	str	r0, [sp, #0x18]
;         dst = (uint8_t*)&gDebugMemLog[0];
700a4218: f241 0080    	movw	r0, #0x1080
700a421c: f2c7 0008    	movt	r0, #0x7008
700a4220: 9003         	str	r0, [sp, #0xc]
700a4222: 2000         	movs	r0, #0x0
;         idx = 0;
700a4224: 9004         	str	r0, [sp, #0x10]
;         for (copy_bytes = 0; copy_bytes < num_bytes; copy_bytes++)
700a4226: 9005         	str	r0, [sp, #0x14]
700a4228: e7ff         	b	0x700a422a <DebugP_memTraceLogWriterPutLine+0x4a> @ imm = #-0x2
700a422a: 9805         	ldr	r0, [sp, #0x14]
700a422c: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a4230: 4288         	cmp	r0, r1
700a4232: d233         	bhs	0x700a429c <DebugP_memTraceLogWriterPutLine+0xbc> @ imm = #0x66
700a4234: e7ff         	b	0x700a4236 <DebugP_memTraceLogWriterPutLine+0x56> @ imm = #-0x2
;             dst[wr_idx] = buf[idx];
700a4236: 9809         	ldr	r0, [sp, #0x24]
700a4238: 9904         	ldr	r1, [sp, #0x10]
700a423a: 5c40         	ldrb	r0, [r0, r1]
700a423c: 9903         	ldr	r1, [sp, #0xc]
700a423e: 9a06         	ldr	r2, [sp, #0x18]
700a4240: 5488         	strb	r0, [r1, r2]
;             wr_idx = wr_idx + 1U;
700a4242: 9806         	ldr	r0, [sp, #0x18]
700a4244: 3001         	adds	r0, #0x1
700a4246: 9006         	str	r0, [sp, #0x18]
;             if (wr_idx >= gDebugMemLogSize)
700a4248: 9806         	ldr	r0, [sp, #0x18]
700a424a: f640 518c    	movw	r1, #0xd8c
700a424e: f2c7 010b    	movt	r1, #0x700b
700a4252: 6809         	ldr	r1, [r1]
700a4254: 4288         	cmp	r0, r1
700a4256: d319         	blo	0x700a428c <DebugP_memTraceLogWriterPutLine+0xac> @ imm = #0x32
700a4258: e7ff         	b	0x700a425a <DebugP_memTraceLogWriterPutLine+0x7a> @ imm = #-0x2
;                         &dst[gDebugMemLogWriteIndex],
700a425a: 9803         	ldr	r0, [sp, #0xc]
700a425c: f640 5290    	movw	r2, #0xd90
700a4260: f2c7 020b    	movt	r2, #0x700b
700a4264: 9202         	str	r2, [sp, #0x8]
700a4266: 6811         	ldr	r1, [r2]
700a4268: 4408         	add	r0, r1
;                         (wr_idx - gDebugMemLogWriteIndex),
700a426a: 9906         	ldr	r1, [sp, #0x18]
700a426c: 6812         	ldr	r2, [r2]
700a426e: 1a89         	subs	r1, r1, r2
700a4270: 220f         	movs	r2, #0xf
;                 CacheP_wbInv(
700a4272: f00a ee9e    	blx	0x700aefb0 <CacheP_wbInv> @ imm = #0xad3c
700a4276: 9902         	ldr	r1, [sp, #0x8]
700a4278: 2000         	movs	r0, #0x0
;                 wr_idx = 0;
700a427a: 9006         	str	r0, [sp, #0x18]
;                 gDebugMemLogWriteIndex = 0;
700a427c: 6008         	str	r0, [r1]
;                 gDebugMemLogIsWrapAround = 1;
700a427e: f640 5188    	movw	r1, #0xd88
700a4282: f2c7 010b    	movt	r1, #0x700b
700a4286: 2001         	movs	r0, #0x1
700a4288: 6008         	str	r0, [r1]
;             }
700a428a: e7ff         	b	0x700a428c <DebugP_memTraceLogWriterPutLine+0xac> @ imm = #-0x2
;             idx ++;
700a428c: 9804         	ldr	r0, [sp, #0x10]
700a428e: 3001         	adds	r0, #0x1
700a4290: 9004         	str	r0, [sp, #0x10]
;         }
700a4292: e7ff         	b	0x700a4294 <DebugP_memTraceLogWriterPutLine+0xb4> @ imm = #-0x2
;         for (copy_bytes = 0; copy_bytes < num_bytes; copy_bytes++)
700a4294: 9805         	ldr	r0, [sp, #0x14]
700a4296: 3001         	adds	r0, #0x1
700a4298: 9005         	str	r0, [sp, #0x14]
700a429a: e7c6         	b	0x700a422a <DebugP_memTraceLogWriterPutLine+0x4a> @ imm = #-0x74
;                 &dst[gDebugMemLogWriteIndex],
700a429c: 9803         	ldr	r0, [sp, #0xc]
700a429e: f640 5290    	movw	r2, #0xd90
700a42a2: f2c7 020b    	movt	r2, #0x700b
700a42a6: 9201         	str	r2, [sp, #0x4]
700a42a8: 6811         	ldr	r1, [r2]
700a42aa: 4408         	add	r0, r1
;                 (wr_idx - gDebugMemLogWriteIndex),
700a42ac: 9906         	ldr	r1, [sp, #0x18]
700a42ae: 6812         	ldr	r2, [r2]
700a42b0: 1a89         	subs	r1, r1, r2
700a42b2: 220f         	movs	r2, #0xf
;         CacheP_wbInv(
700a42b4: f00a ee7c    	blx	0x700aefb0 <CacheP_wbInv> @ imm = #0xacf8
700a42b8: 9901         	ldr	r1, [sp, #0x4]
;         gDebugMemLogWriteIndex = wr_idx;
700a42ba: 9806         	ldr	r0, [sp, #0x18]
700a42bc: 6008         	str	r0, [r1]
;     }
700a42be: e7ff         	b	0x700a42c0 <DebugP_memTraceLogWriterPutLine+0xe0> @ imm = #-0x2
; }
700a42c0: b00a         	add	sp, #0x28
700a42c2: bd80         	pop	{r7, pc}
		...

700a42d0 <Sciclient_rmIrqGetNode>:
; {
700a42d0: b089         	sub	sp, #0x24
700a42d2: f8ad 0022    	strh.w	r0, [sp, #0x22]
700a42d6: 9107         	str	r1, [sp, #0x1c]
700a42d8: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700a42dc: 9006         	str	r0, [sp, #0x18]
700a42de: 2000         	movs	r0, #0x0
;     lower = 0u;
700a42e0: 9004         	str	r0, [sp, #0x10]
;     upper = gRmIrqTreeCount - 1u;
700a42e2: f640 11f4    	movw	r1, #0x9f4
700a42e6: f2c7 010b    	movt	r1, #0x700b
700a42ea: 680a         	ldr	r2, [r1]
700a42ec: 3a01         	subs	r2, #0x1
700a42ee: 9203         	str	r2, [sp, #0xc]
;     count = gRmIrqTreeCount;
700a42f0: 6809         	ldr	r1, [r1]
700a42f2: f8ad 1006    	strh.w	r1, [sp, #0x6]
;     *found_n = NULL;
700a42f6: 9907         	ldr	r1, [sp, #0x1c]
700a42f8: 6008         	str	r0, [r1]
;     while ((lower <= upper) &&
700a42fa: e7ff         	b	0x700a42fc <Sciclient_rmIrqGetNode+0x2c> @ imm = #-0x2
700a42fc: 9904         	ldr	r1, [sp, #0x10]
700a42fe: 9a03         	ldr	r2, [sp, #0xc]
700a4300: 2000         	movs	r0, #0x0
700a4302: 4291         	cmp	r1, r2
700a4304: 9000         	str	r0, [sp]
700a4306: d81d         	bhi	0x700a4344 <Sciclient_rmIrqGetNode+0x74> @ imm = #0x3a
700a4308: e7ff         	b	0x700a430a <Sciclient_rmIrqGetNode+0x3a> @ imm = #-0x2
;            (lower < gRmIrqTreeCount) &&
700a430a: 9904         	ldr	r1, [sp, #0x10]
700a430c: f640 10f4    	movw	r0, #0x9f4
700a4310: f2c7 000b    	movt	r0, #0x700b
700a4314: 6802         	ldr	r2, [r0]
700a4316: 2000         	movs	r0, #0x0
700a4318: 4291         	cmp	r1, r2
700a431a: 9000         	str	r0, [sp]
700a431c: d212         	bhs	0x700a4344 <Sciclient_rmIrqGetNode+0x74> @ imm = #0x24
700a431e: e7ff         	b	0x700a4320 <Sciclient_rmIrqGetNode+0x50> @ imm = #-0x2
;            (upper < gRmIrqTreeCount) &&
700a4320: 9903         	ldr	r1, [sp, #0xc]
700a4322: f640 10f4    	movw	r0, #0x9f4
700a4326: f2c7 000b    	movt	r0, #0x700b
700a432a: 6802         	ldr	r2, [r0]
700a432c: 2000         	movs	r0, #0x0
700a432e: 4291         	cmp	r1, r2
700a4330: 9000         	str	r0, [sp]
700a4332: d207         	bhs	0x700a4344 <Sciclient_rmIrqGetNode+0x74> @ imm = #0xe
700a4334: e7ff         	b	0x700a4336 <Sciclient_rmIrqGetNode+0x66> @ imm = #-0x2
;            (count > 0u)) {
700a4336: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a433a: 2800         	cmp	r0, #0x0
700a433c: bf18         	it	ne
700a433e: 2001         	movne	r0, #0x1
700a4340: 9000         	str	r0, [sp]
700a4342: e7ff         	b	0x700a4344 <Sciclient_rmIrqGetNode+0x74> @ imm = #-0x2
700a4344: 9800         	ldr	r0, [sp]
;     while ((lower <= upper) &&
700a4346: 07c0         	lsls	r0, r0, #0x1f
700a4348: b380         	cbz	r0, 0x700a43ac <Sciclient_rmIrqGetNode+0xdc> @ imm = #0x60
700a434a: e7ff         	b	0x700a434c <Sciclient_rmIrqGetNode+0x7c> @ imm = #-0x2
;         current = (lower + upper) / (2u);
700a434c: 9804         	ldr	r0, [sp, #0x10]
700a434e: 9903         	ldr	r1, [sp, #0xc]
700a4350: 4408         	add	r0, r1
700a4352: 0840         	lsrs	r0, r0, #0x1
700a4354: 9002         	str	r0, [sp, #0x8]
;         cur_n = (const struct Sciclient_rmIrqNode *) gRmIrqTree[current];
700a4356: 9902         	ldr	r1, [sp, #0x8]
700a4358: f64f 401c    	movw	r0, #0xfc1c
700a435c: f2c7 000a    	movt	r0, #0x700a
700a4360: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a4364: 9005         	str	r0, [sp, #0x14]
;         if (cur_n->id == id) {
700a4366: 9805         	ldr	r0, [sp, #0x14]
700a4368: 8800         	ldrh	r0, [r0]
700a436a: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a436e: 4288         	cmp	r0, r1
700a4370: d106         	bne	0x700a4380 <Sciclient_rmIrqGetNode+0xb0> @ imm = #0xc
700a4372: e7ff         	b	0x700a4374 <Sciclient_rmIrqGetNode+0xa4> @ imm = #-0x2
;             *found_n = cur_n;
700a4374: 9805         	ldr	r0, [sp, #0x14]
700a4376: 9907         	ldr	r1, [sp, #0x1c]
700a4378: 6008         	str	r0, [r1]
700a437a: 2000         	movs	r0, #0x0
;             r = SystemP_SUCCESS;
700a437c: 9006         	str	r0, [sp, #0x18]
;             break;
700a437e: e015         	b	0x700a43ac <Sciclient_rmIrqGetNode+0xdc> @ imm = #0x2a
;             if (cur_n->id < id) {
700a4380: 9805         	ldr	r0, [sp, #0x14]
700a4382: 8800         	ldrh	r0, [r0]
700a4384: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a4388: 4288         	cmp	r0, r1
700a438a: da04         	bge	0x700a4396 <Sciclient_rmIrqGetNode+0xc6> @ imm = #0x8
700a438c: e7ff         	b	0x700a438e <Sciclient_rmIrqGetNode+0xbe> @ imm = #-0x2
;                 lower = current + (1u);
700a438e: 9802         	ldr	r0, [sp, #0x8]
700a4390: 3001         	adds	r0, #0x1
700a4392: 9004         	str	r0, [sp, #0x10]
;             } else {
700a4394: e003         	b	0x700a439e <Sciclient_rmIrqGetNode+0xce> @ imm = #0x6
;                 upper = current - (1u);
700a4396: 9802         	ldr	r0, [sp, #0x8]
700a4398: 3801         	subs	r0, #0x1
700a439a: 9003         	str	r0, [sp, #0xc]
700a439c: e7ff         	b	0x700a439e <Sciclient_rmIrqGetNode+0xce> @ imm = #-0x2
700a439e: e7ff         	b	0x700a43a0 <Sciclient_rmIrqGetNode+0xd0> @ imm = #-0x2
;         count--;
700a43a0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a43a4: 3801         	subs	r0, #0x1
700a43a6: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     while ((lower <= upper) &&
700a43aa: e7a7         	b	0x700a42fc <Sciclient_rmIrqGetNode+0x2c> @ imm = #-0xb2
;     return r;
700a43ac: 9806         	ldr	r0, [sp, #0x18]
700a43ae: b009         	add	sp, #0x24
700a43b0: 4770         	bx	lr
		...
700a43be: 0000         	movs	r0, r0

700a43c0 <vTaskGetInfo>:
;                   BaseType_t xGetFreeStackSpace, eTaskState eState) {
700a43c0: b580         	push	{r7, lr}
700a43c2: b086         	sub	sp, #0x18
700a43c4: 9005         	str	r0, [sp, #0x14]
700a43c6: 9104         	str	r1, [sp, #0x10]
700a43c8: 9203         	str	r2, [sp, #0xc]
700a43ca: f88d 300b    	strb.w	r3, [sp, #0xb]
;   pxTCB = prvGetTCBFromHandle(xTask);
700a43ce: 9805         	ldr	r0, [sp, #0x14]
700a43d0: b938         	cbnz	r0, 0x700a43e2 <vTaskGetInfo+0x22> @ imm = #0xe
700a43d2: e7ff         	b	0x700a43d4 <vTaskGetInfo+0x14> @ imm = #-0x2
700a43d4: f640 50ac    	movw	r0, #0xdac
700a43d8: f2c7 000b    	movt	r0, #0x700b
700a43dc: 6800         	ldr	r0, [r0]
700a43de: 9000         	str	r0, [sp]
700a43e0: e002         	b	0x700a43e8 <vTaskGetInfo+0x28> @ imm = #0x4
700a43e2: 9805         	ldr	r0, [sp, #0x14]
700a43e4: 9000         	str	r0, [sp]
700a43e6: e7ff         	b	0x700a43e8 <vTaskGetInfo+0x28> @ imm = #-0x2
700a43e8: 9800         	ldr	r0, [sp]
700a43ea: 9001         	str	r0, [sp, #0x4]
;   pxTaskStatus->xHandle = (TaskHandle_t)pxTCB;
700a43ec: 9801         	ldr	r0, [sp, #0x4]
700a43ee: 9904         	ldr	r1, [sp, #0x10]
700a43f0: 6008         	str	r0, [r1]
;   pxTaskStatus->pcTaskName = (const char *)&(pxTCB->pcTaskName[0]);
700a43f2: 9801         	ldr	r0, [sp, #0x4]
700a43f4: 3034         	adds	r0, #0x34
700a43f6: 9904         	ldr	r1, [sp, #0x10]
700a43f8: 6048         	str	r0, [r1, #0x4]
;   pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
700a43fa: 9801         	ldr	r0, [sp, #0x4]
700a43fc: 6ac0         	ldr	r0, [r0, #0x2c]
700a43fe: 9904         	ldr	r1, [sp, #0x10]
700a4400: 6108         	str	r0, [r1, #0x10]
;   pxTaskStatus->pxStackBase = pxTCB->pxStack;
700a4402: 9801         	ldr	r0, [sp, #0x4]
700a4404: 6b00         	ldr	r0, [r0, #0x30]
700a4406: 9904         	ldr	r1, [sp, #0x10]
700a4408: 61c8         	str	r0, [r1, #0x1c]
;   pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
700a440a: 9801         	ldr	r0, [sp, #0x4]
700a440c: 6d80         	ldr	r0, [r0, #0x58]
700a440e: 9904         	ldr	r1, [sp, #0x10]
700a4410: 6088         	str	r0, [r1, #0x8]
;     pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
700a4412: 9801         	ldr	r0, [sp, #0x4]
700a4414: 6e00         	ldr	r0, [r0, #0x60]
700a4416: 9904         	ldr	r1, [sp, #0x10]
700a4418: 6148         	str	r0, [r1, #0x14]
;     pxTaskStatus->ulRunTimeCounter = 0;
700a441a: 9904         	ldr	r1, [sp, #0x10]
700a441c: 2000         	movs	r0, #0x0
700a441e: 6188         	str	r0, [r1, #0x18]
;   if (eState != eInvalid) {
700a4420: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a4424: 2805         	cmp	r0, #0x5
700a4426: d025         	beq	0x700a4474 <vTaskGetInfo+0xb4> @ imm = #0x4a
700a4428: e7ff         	b	0x700a442a <vTaskGetInfo+0x6a> @ imm = #-0x2
;     if (pxTCB == pxCurrentTCB) {
700a442a: 9801         	ldr	r0, [sp, #0x4]
700a442c: f640 51ac    	movw	r1, #0xdac
700a4430: f2c7 010b    	movt	r1, #0x700b
700a4434: 6809         	ldr	r1, [r1]
700a4436: 4288         	cmp	r0, r1
700a4438: d104         	bne	0x700a4444 <vTaskGetInfo+0x84> @ imm = #0x8
700a443a: e7ff         	b	0x700a443c <vTaskGetInfo+0x7c> @ imm = #-0x2
;       pxTaskStatus->eCurrentState = eRunning;
700a443c: 9904         	ldr	r1, [sp, #0x10]
700a443e: 2000         	movs	r0, #0x0
700a4440: 7308         	strb	r0, [r1, #0xc]
;     } else {
700a4442: e016         	b	0x700a4472 <vTaskGetInfo+0xb2> @ imm = #0x2c
;       pxTaskStatus->eCurrentState = eState;
700a4444: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a4448: 9904         	ldr	r1, [sp, #0x10]
700a444a: 7308         	strb	r0, [r1, #0xc]
;         if (eState == eSuspended) {
700a444c: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a4450: 2803         	cmp	r0, #0x3
700a4452: d10d         	bne	0x700a4470 <vTaskGetInfo+0xb0> @ imm = #0x1a
700a4454: e7ff         	b	0x700a4456 <vTaskGetInfo+0x96> @ imm = #-0x2
;           vTaskSuspendAll();
700a4456: f009 fdeb    	bl	0x700ae030 <vTaskSuspendAll> @ imm = #0x9bd6
;             if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a445a: 9801         	ldr	r0, [sp, #0x4]
700a445c: 6a80         	ldr	r0, [r0, #0x28]
700a445e: b120         	cbz	r0, 0x700a446a <vTaskGetInfo+0xaa> @ imm = #0x8
700a4460: e7ff         	b	0x700a4462 <vTaskGetInfo+0xa2> @ imm = #-0x2
;               pxTaskStatus->eCurrentState = eBlocked;
700a4462: 9904         	ldr	r1, [sp, #0x10]
700a4464: 2002         	movs	r0, #0x2
700a4466: 7308         	strb	r0, [r1, #0xc]
;             }
700a4468: e7ff         	b	0x700a446a <vTaskGetInfo+0xaa> @ imm = #-0x2
;           (void)xTaskResumeAll();
700a446a: f7fc fa19    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0x3bce
;         }
700a446e: e7ff         	b	0x700a4470 <vTaskGetInfo+0xb0> @ imm = #-0x2
700a4470: e7ff         	b	0x700a4472 <vTaskGetInfo+0xb2> @ imm = #-0x2
;   } else {
700a4472: e005         	b	0x700a4480 <vTaskGetInfo+0xc0> @ imm = #0xa
;     pxTaskStatus->eCurrentState = eTaskGetState(pxTCB);
700a4474: 9801         	ldr	r0, [sp, #0x4]
700a4476: f7ff fbdb    	bl	0x700a3c30 <eTaskGetState> @ imm = #-0x84a
700a447a: 9904         	ldr	r1, [sp, #0x10]
700a447c: 7308         	strb	r0, [r1, #0xc]
700a447e: e7ff         	b	0x700a4480 <vTaskGetInfo+0xc0> @ imm = #-0x2
;   if (xGetFreeStackSpace != pdFALSE) {
700a4480: 9803         	ldr	r0, [sp, #0xc]
700a4482: b138         	cbz	r0, 0x700a4494 <vTaskGetInfo+0xd4> @ imm = #0xe
700a4484: e7ff         	b	0x700a4486 <vTaskGetInfo+0xc6> @ imm = #-0x2
;           prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxStack);
700a4486: 9801         	ldr	r0, [sp, #0x4]
700a4488: 6b00         	ldr	r0, [r0, #0x30]
700a448a: f008 fd01    	bl	0x700ace90 <prvTaskCheckFreeStackSpace> @ imm = #0x8a02
;       pxTaskStatus->usStackHighWaterMark =
700a448e: 9904         	ldr	r1, [sp, #0x10]
700a4490: 6208         	str	r0, [r1, #0x20]
;   } else {
700a4492: e003         	b	0x700a449c <vTaskGetInfo+0xdc> @ imm = #0x6
;     pxTaskStatus->usStackHighWaterMark = 0;
700a4494: 9904         	ldr	r1, [sp, #0x10]
700a4496: 2000         	movs	r0, #0x0
700a4498: 6208         	str	r0, [r1, #0x20]
700a449a: e7ff         	b	0x700a449c <vTaskGetInfo+0xdc> @ imm = #-0x2
; }
700a449c: b006         	add	sp, #0x18
700a449e: bd80         	pop	{r7, pc}

700a44a0 <Sciclient_waitForMessage>:
; {
700a44a0: b580         	push	{r7, lr}
700a44a2: b088         	sub	sp, #0x20
700a44a4: 9007         	str	r0, [sp, #0x1c]
700a44a6: 9106         	str	r1, [sp, #0x18]
700a44a8: 9205         	str	r2, [sp, #0x14]
700a44aa: f88d 3013    	strb.w	r3, [sp, #0x13]
;     uint32_t timeToWait = timeout;
700a44ae: 9806         	ldr	r0, [sp, #0x18]
700a44b0: 9002         	str	r0, [sp, #0x8]
700a44b2: 2200         	movs	r2, #0x0
;     int32_t status = SystemP_SUCCESS;
700a44b4: 9201         	str	r2, [sp, #0x4]
;                                         &gSciclientSecProxyCfg, rxThread, 0U)
700a44b6: 9907         	ldr	r1, [sp, #0x1c]
;         (struct tisci_header *)(CSL_secProxyGetDataAddr(
700a44b8: f640 4078    	movw	r0, #0xc78
700a44bc: f2c7 000b    	movt	r0, #0x700b
700a44c0: f009 fa96    	bl	0x700ad9f0 <CSL_secProxyGetDataAddr> @ imm = #0x952c
;                                 + ((uintptr_t) gSecHeaderSizeWords * (uintptr_t) 4U));
700a44c4: f640 6104    	movw	r1, #0xe04
700a44c8: f2c7 010b    	movt	r1, #0x700b
700a44cc: 7809         	ldrb	r1, [r1]
700a44ce: eb00 0081    	add.w	r0, r0, r1, lsl #2
;     pLocalRespHdr =
700a44d2: 9003         	str	r0, [sp, #0xc]
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a44d4: e7ff         	b	0x700a44d6 <Sciclient_waitForMessage+0x36> @ imm = #-0x2
700a44d6: 9807         	ldr	r0, [sp, #0x1c]
700a44d8: f009 fb3a    	bl	0x700adb50 <Sciclient_secProxyThreadStatusReg> @ imm = #0x9674
700a44dc: f009 fde0    	bl	0x700ae0a0 <CSL_REG32_RD_RAW> @ imm = #0x9bc0
700a44e0: b2c0         	uxtb	r0, r0
;             CSL_SEC_PROXY_RT_THREAD_STATUS_CUR_CNT_MASK) - initialCount) <= 0U)
700a44e2: 9905         	ldr	r1, [sp, #0x14]
700a44e4: 1a40         	subs	r0, r0, r1
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a44e6: b960         	cbnz	r0, 0x700a4502 <Sciclient_waitForMessage+0x62> @ imm = #0x18
700a44e8: e7ff         	b	0x700a44ea <Sciclient_waitForMessage+0x4a> @ imm = #-0x2
;         if (timeToWait != 0U)
700a44ea: 9802         	ldr	r0, [sp, #0x8]
700a44ec: b120         	cbz	r0, 0x700a44f8 <Sciclient_waitForMessage+0x58> @ imm = #0x8
700a44ee: e7ff         	b	0x700a44f0 <Sciclient_waitForMessage+0x50> @ imm = #-0x2
;             timeToWait--;
700a44f0: 9802         	ldr	r0, [sp, #0x8]
700a44f2: 3801         	subs	r0, #0x1
700a44f4: 9002         	str	r0, [sp, #0x8]
;         }
700a44f6: e003         	b	0x700a4500 <Sciclient_waitForMessage+0x60> @ imm = #0x6
700a44f8: f06f 0001    	mvn	r0, #0x1
;             status = SystemP_TIMEOUT;
700a44fc: 9001         	str	r0, [sp, #0x4]
;             break;
700a44fe: e000         	b	0x700a4502 <Sciclient_waitForMessage+0x62> @ imm = #0x0
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a4500: e7e9         	b	0x700a44d6 <Sciclient_waitForMessage+0x36> @ imm = #-0x2e
;     if (status == SystemP_SUCCESS)
700a4502: 9801         	ldr	r0, [sp, #0x4]
700a4504: bbc0         	cbnz	r0, 0x700a4578 <Sciclient_waitForMessage+0xd8> @ imm = #0x70
700a4506: e7ff         	b	0x700a4508 <Sciclient_waitForMessage+0x68> @ imm = #-0x2
700a4508: f06f 0001    	mvn	r0, #0x1
;         status = SystemP_TIMEOUT;
700a450c: 9001         	str	r0, [sp, #0x4]
;         timeToWait =  timeout;
700a450e: 9806         	ldr	r0, [sp, #0x18]
700a4510: 9002         	str	r0, [sp, #0x8]
;         while(1)
700a4512: e7ff         	b	0x700a4514 <Sciclient_waitForMessage+0x74> @ imm = #-0x2
;             uint32_t numCurrentMsgs = (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a4514: 9807         	ldr	r0, [sp, #0x1c]
700a4516: f009 fb1b    	bl	0x700adb50 <Sciclient_secProxyThreadStatusReg> @ imm = #0x9636
700a451a: f009 fdc1    	bl	0x700ae0a0 <CSL_REG32_RD_RAW> @ imm = #0x9b82
700a451e: b2c0         	uxtb	r0, r0
;                     CSL_SEC_PROXY_RT_THREAD_STATUS_CUR_CNT_MASK) - initialCount;
700a4520: 9905         	ldr	r1, [sp, #0x14]
700a4522: 1a40         	subs	r0, r0, r1
;             uint32_t numCurrentMsgs = (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a4524: 9000         	str	r0, [sp]
;             if (pLocalRespHdr->seq == (uint32_t)localSeqId)
700a4526: 9803         	ldr	r0, [sp, #0xc]
700a4528: 78c0         	ldrb	r0, [r0, #0x3]
700a452a: f89d 1013    	ldrb.w	r1, [sp, #0x13]
700a452e: 4288         	cmp	r0, r1
700a4530: d103         	bne	0x700a453a <Sciclient_waitForMessage+0x9a> @ imm = #0x6
700a4532: e7ff         	b	0x700a4534 <Sciclient_waitForMessage+0x94> @ imm = #-0x2
700a4534: 2000         	movs	r0, #0x0
;                 status = SystemP_SUCCESS;
700a4536: 9001         	str	r0, [sp, #0x4]
;                 break;
700a4538: e01d         	b	0x700a4576 <Sciclient_waitForMessage+0xd6> @ imm = #0x3a
;             if (numCurrentMsgs > 1U)
700a453a: 9800         	ldr	r0, [sp]
700a453c: 2802         	cmp	r0, #0x2
700a453e: d30e         	blo	0x700a455e <Sciclient_waitForMessage+0xbe> @ imm = #0x1c
700a4540: e7ff         	b	0x700a4542 <Sciclient_waitForMessage+0xa2> @ imm = #-0x2
;                 (void) Sciclient_secProxyReadThread32(rxThread,
700a4542: 9807         	ldr	r0, [sp, #0x1c]
;                                             (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U) - 1U));
700a4544: f640 5100    	movw	r1, #0xd00
700a4548: f2c7 010b    	movt	r1, #0x700b
700a454c: 694a         	ldr	r2, [r1, #0x14]
700a454e: f04f 31ff    	mov.w	r1, #0xffffffff
700a4552: eb01 0192    	add.w	r1, r1, r2, lsr #2
;                 (void) Sciclient_secProxyReadThread32(rxThread,
700a4556: b2c9         	uxtb	r1, r1
700a4558: f008 fc22    	bl	0x700acda0 <Sciclient_secProxyReadThread32> @ imm = #0x8844
;             }
700a455c: e7ff         	b	0x700a455e <Sciclient_waitForMessage+0xbe> @ imm = #-0x2
;             if (timeToWait != 0U)
700a455e: 9802         	ldr	r0, [sp, #0x8]
700a4560: b120         	cbz	r0, 0x700a456c <Sciclient_waitForMessage+0xcc> @ imm = #0x8
700a4562: e7ff         	b	0x700a4564 <Sciclient_waitForMessage+0xc4> @ imm = #-0x2
;                 timeToWait--;
700a4564: 9802         	ldr	r0, [sp, #0x8]
700a4566: 3801         	subs	r0, #0x1
700a4568: 9002         	str	r0, [sp, #0x8]
;             }
700a456a: e003         	b	0x700a4574 <Sciclient_waitForMessage+0xd4> @ imm = #0x6
700a456c: f06f 0001    	mvn	r0, #0x1
;                 status = SystemP_TIMEOUT;
700a4570: 9001         	str	r0, [sp, #0x4]
;                 break;
700a4572: e000         	b	0x700a4576 <Sciclient_waitForMessage+0xd6> @ imm = #0x0
;         while(1)
700a4574: e7ce         	b	0x700a4514 <Sciclient_waitForMessage+0x74> @ imm = #-0x64
;     }
700a4576: e7ff         	b	0x700a4578 <Sciclient_waitForMessage+0xd8> @ imm = #-0x2
;     return status;
700a4578: 9801         	ldr	r0, [sp, #0x4]
700a457a: b008         	add	sp, #0x20
700a457c: bd80         	pop	{r7, pc}
700a457e: 0000         	movs	r0, r0

700a4580 <UART_intrEnable>:
; {
700a4580: b580         	push	{r7, lr}
700a4582: b08a         	sub	sp, #0x28
700a4584: 9009         	str	r0, [sp, #0x24]
700a4586: 9108         	str	r1, [sp, #0x20]
700a4588: 2000         	movs	r0, #0x0
;     uint32_t enhanFnBitVal = 0U;
700a458a: 9007         	str	r0, [sp, #0x1c]
;     uint32_t lcrRegValue   = 0U;
700a458c: 9006         	str	r0, [sp, #0x18]
;     if ((intrFlag & 0xF0U) > 0U)
700a458e: f89d 0020    	ldrb.w	r0, [sp, #0x20]
700a4592: f010 0ff0    	tst.w	r0, #0xf0
700a4596: d053         	beq	0x700a4640 <UART_intrEnable+0xc0> @ imm = #0xa6
700a4598: e7ff         	b	0x700a459a <UART_intrEnable+0x1a> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a459a: 9809         	ldr	r0, [sp, #0x24]
700a459c: 300c         	adds	r0, #0xc
700a459e: f009 fd1f    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x9a3e
700a45a2: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a45a4: 9809         	ldr	r0, [sp, #0x24]
700a45a6: 300c         	adds	r0, #0xc
700a45a8: 21bf         	movs	r1, #0xbf
700a45aa: 9103         	str	r1, [sp, #0xc]
700a45ac: f009 fd20    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x9a40
;         enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a45b0: 9809         	ldr	r0, [sp, #0x24]
700a45b2: 3008         	adds	r0, #0x8
700a45b4: 2110         	movs	r1, #0x10
700a45b6: 9104         	str	r1, [sp, #0x10]
700a45b8: 2204         	movs	r2, #0x4
700a45ba: 9205         	str	r2, [sp, #0x14]
700a45bc: f009 f908    	bl	0x700ad7d0 <HW_RD_FIELD32_RAW> @ imm = #0x9210
700a45c0: 9904         	ldr	r1, [sp, #0x10]
700a45c2: 9a05         	ldr	r2, [sp, #0x14]
700a45c4: 9007         	str	r0, [sp, #0x1c]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a45c6: 9809         	ldr	r0, [sp, #0x24]
700a45c8: 3008         	adds	r0, #0x8
700a45ca: 2301         	movs	r3, #0x1
700a45cc: f008 fa80    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x8500
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a45d0: 9809         	ldr	r0, [sp, #0x24]
700a45d2: 300c         	adds	r0, #0xc
700a45d4: 9906         	ldr	r1, [sp, #0x18]
700a45d6: f009 fd0b    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x9a16
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a45da: 9809         	ldr	r0, [sp, #0x24]
700a45dc: 300c         	adds	r0, #0xc
700a45de: f009 fcff    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x99fe
700a45e2: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700a45e4: 9809         	ldr	r0, [sp, #0x24]
700a45e6: 300c         	adds	r0, #0xc
700a45e8: 9002         	str	r0, [sp, #0x8]
700a45ea: f009 fcf9    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x99f2
700a45ee: 4601         	mov	r1, r0
700a45f0: 9802         	ldr	r0, [sp, #0x8]
700a45f2: f001 017f    	and	r1, r1, #0x7f
700a45f6: f009 fcfb    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x99f6
;         HW_WR_REG32(baseAddr + UART_IER, intrFlag & 0xF0U);
700a45fa: 9809         	ldr	r0, [sp, #0x24]
700a45fc: 3004         	adds	r0, #0x4
700a45fe: 9908         	ldr	r1, [sp, #0x20]
700a4600: f001 01f0    	and	r1, r1, #0xf0
700a4604: f009 fcf4    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x99e8
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4608: 9809         	ldr	r0, [sp, #0x24]
700a460a: 300c         	adds	r0, #0xc
700a460c: 9906         	ldr	r1, [sp, #0x18]
700a460e: f009 fcef    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x99de
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a4612: 9809         	ldr	r0, [sp, #0x24]
700a4614: 300c         	adds	r0, #0xc
700a4616: f009 fce3    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x99c6
700a461a: 9903         	ldr	r1, [sp, #0xc]
700a461c: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a461e: 9809         	ldr	r0, [sp, #0x24]
700a4620: 300c         	adds	r0, #0xc
700a4622: f009 fce5    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x99ca
700a4626: 9904         	ldr	r1, [sp, #0x10]
700a4628: 9a05         	ldr	r2, [sp, #0x14]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a462a: 9809         	ldr	r0, [sp, #0x24]
700a462c: 3008         	adds	r0, #0x8
700a462e: 9b07         	ldr	r3, [sp, #0x1c]
700a4630: f008 fa4e    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x849c
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4634: 9809         	ldr	r0, [sp, #0x24]
700a4636: 300c         	adds	r0, #0xc
700a4638: 9906         	ldr	r1, [sp, #0x18]
700a463a: f009 fcd9    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x99b2
;     }
700a463e: e7ff         	b	0x700a4640 <UART_intrEnable+0xc0> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_IER, HW_RD_REG32(baseAddr + UART_IER) |
700a4640: 9809         	ldr	r0, [sp, #0x24]
700a4642: 3004         	adds	r0, #0x4
700a4644: 9001         	str	r0, [sp, #0x4]
700a4646: f009 fccb    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x9996
700a464a: 4601         	mov	r1, r0
700a464c: 9801         	ldr	r0, [sp, #0x4]
700a464e: 9a08         	ldr	r2, [sp, #0x20]
700a4650: f002 020f    	and	r2, r2, #0xf
700a4654: 4311         	orrs	r1, r2
700a4656: f009 fccb    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x9996
; }
700a465a: b00a         	add	sp, #0x28
700a465c: bd80         	pop	{r7, pc}
700a465e: 0000         	movs	r0, r0

700a4660 <Sciclient_rmIrInpIsFree>:
; {
700a4660: b580         	push	{r7, lr}
700a4662: b086         	sub	sp, #0x18
700a4664: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a4668: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a466c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a466e: 9004         	str	r0, [sp, #0x10]
;     const struct Sciclient_rmIrInst *inst = NULL;
700a4670: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIrGetInst(id);
700a4672: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a4676: f005 fc53    	bl	0x700a9f20 <Sciclient_rmIrGetInst> @ imm = #0x58a6
700a467a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a467c: 9803         	ldr	r0, [sp, #0xc]
700a467e: b920         	cbnz	r0, 0x700a468a <Sciclient_rmIrInpIsFree+0x2a> @ imm = #0x8
700a4680: e7ff         	b	0x700a4682 <Sciclient_rmIrInpIsFree+0x22> @ imm = #-0x2
700a4682: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a4686: 9004         	str	r0, [sp, #0x10]
;     } else {
700a4688: e00b         	b	0x700a46a2 <Sciclient_rmIrInpIsFree+0x42> @ imm = #0x16
;         if (inp >= inst->n_inp) {
700a468a: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a468e: 9903         	ldr	r1, [sp, #0xc]
700a4690: 8909         	ldrh	r1, [r1, #0x8]
700a4692: 4288         	cmp	r0, r1
700a4694: db04         	blt	0x700a46a0 <Sciclient_rmIrInpIsFree+0x40> @ imm = #0x8
700a4696: e7ff         	b	0x700a4698 <Sciclient_rmIrInpIsFree+0x38> @ imm = #-0x2
700a4698: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a469c: 9004         	str	r0, [sp, #0x10]
;         }
700a469e: e7ff         	b	0x700a46a0 <Sciclient_rmIrInpIsFree+0x40> @ imm = #-0x2
700a46a0: e7ff         	b	0x700a46a2 <Sciclient_rmIrInpIsFree+0x42> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a46a2: 9804         	ldr	r0, [sp, #0x10]
700a46a4: 2800         	cmp	r0, #0x0
700a46a6: d145         	bne	0x700a4734 <Sciclient_rmIrInpIsFree+0xd4> @ imm = #0x8a
700a46a8: e7ff         	b	0x700a46aa <Sciclient_rmIrInpIsFree+0x4a> @ imm = #-0x2
;         if (inp == 0u) {
700a46aa: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a46ae: b960         	cbnz	r0, 0x700a46ca <Sciclient_rmIrInpIsFree+0x6a> @ imm = #0x18
700a46b0: e7ff         	b	0x700a46b2 <Sciclient_rmIrInpIsFree+0x52> @ imm = #-0x2
;             if (inst->inp0_mapping != SCICLIENT_RM_IR_MAPPING_FREE) {
700a46b2: 9803         	ldr	r0, [sp, #0xc]
700a46b4: 8980         	ldrh	r0, [r0, #0xc]
700a46b6: f64f 71ff    	movw	r1, #0xffff
700a46ba: 4288         	cmp	r0, r1
700a46bc: d004         	beq	0x700a46c8 <Sciclient_rmIrInpIsFree+0x68> @ imm = #0x8
700a46be: e7ff         	b	0x700a46c0 <Sciclient_rmIrInpIsFree+0x60> @ imm = #-0x2
700a46c0: f04f 30ff    	mov.w	r0, #0xffffffff
;                 r = SystemP_FAILURE;
700a46c4: 9004         	str	r0, [sp, #0x10]
;             }
700a46c6: e7ff         	b	0x700a46c8 <Sciclient_rmIrInpIsFree+0x68> @ imm = #-0x2
;         } else {
700a46c8: e033         	b	0x700a4732 <Sciclient_rmIrInpIsFree+0xd2> @ imm = #0x66
700a46ca: 2000         	movs	r0, #0x0
;             for (i = 0u; i < inst->n_outp; i++) {
700a46cc: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a46d0: e7ff         	b	0x700a46d2 <Sciclient_rmIrInpIsFree+0x72> @ imm = #-0x2
700a46d2: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a46d6: 9903         	ldr	r1, [sp, #0xc]
700a46d8: 8949         	ldrh	r1, [r1, #0xa]
700a46da: 4288         	cmp	r0, r1
700a46dc: da28         	bge	0x700a4730 <Sciclient_rmIrInpIsFree+0xd0> @ imm = #0x50
700a46de: e7ff         	b	0x700a46e0 <Sciclient_rmIrInpIsFree+0x80> @ imm = #-0x2
;                 int_ctrl_reg = (volatile uint32_t *)Sciclient_getIrAddr(inst->cfg, i);
700a46e0: 9803         	ldr	r0, [sp, #0xc]
700a46e2: 6840         	ldr	r0, [r0, #0x4]
700a46e4: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700a46e8: f008 fc7a    	bl	0x700acfe0 <Sciclient_getIrAddr> @ imm = #0x88f4
700a46ec: 9001         	str	r0, [sp, #0x4]
;                 extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a46ee: 9801         	ldr	r0, [sp, #0x4]
700a46f0: f240 31ff    	movw	r1, #0x3ff
700a46f4: 2200         	movs	r2, #0x0
700a46f6: f008 ff8b    	bl	0x700ad610 <CSL_REG32_FEXT_RAW> @ imm = #0x8f16
700a46fa: f8ad 0002    	strh.w	r0, [sp, #0x2]
;                 if ((extracted_inp == inp) &&
700a46fe: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a4702: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a4706: 4288         	cmp	r0, r1
700a4708: d10b         	bne	0x700a4722 <Sciclient_rmIrInpIsFree+0xc2> @ imm = #0x16
700a470a: e7ff         	b	0x700a470c <Sciclient_rmIrInpIsFree+0xac> @ imm = #-0x2
;                     (Sciclient_rmIrInpRomMapped(inst, inp) == false)) {
700a470c: 9803         	ldr	r0, [sp, #0xc]
700a470e: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a4712: f002 f875    	bl	0x700a6800 <Sciclient_rmIrInpRomMapped> @ imm = #0x20ea
;                 if ((extracted_inp == inp) &&
700a4716: b920         	cbnz	r0, 0x700a4722 <Sciclient_rmIrInpIsFree+0xc2> @ imm = #0x8
700a4718: e7ff         	b	0x700a471a <Sciclient_rmIrInpIsFree+0xba> @ imm = #-0x2
700a471a: f04f 30ff    	mov.w	r0, #0xffffffff
;                     r = SystemP_FAILURE;
700a471e: 9004         	str	r0, [sp, #0x10]
;                     break;
700a4720: e006         	b	0x700a4730 <Sciclient_rmIrInpIsFree+0xd0> @ imm = #0xc
;             }
700a4722: e7ff         	b	0x700a4724 <Sciclient_rmIrInpIsFree+0xc4> @ imm = #-0x2
;             for (i = 0u; i < inst->n_outp; i++) {
700a4724: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a4728: 3001         	adds	r0, #0x1
700a472a: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a472e: e7d0         	b	0x700a46d2 <Sciclient_rmIrInpIsFree+0x72> @ imm = #-0x60
700a4730: e7ff         	b	0x700a4732 <Sciclient_rmIrInpIsFree+0xd2> @ imm = #-0x2
;     }
700a4732: e7ff         	b	0x700a4734 <Sciclient_rmIrInpIsFree+0xd4> @ imm = #-0x2
;     return r;
700a4734: 9804         	ldr	r0, [sp, #0x10]
700a4736: b006         	add	sp, #0x18
700a4738: bd80         	pop	{r7, pc}
700a473a: 0000         	movs	r0, r0
700a473c: 0000         	movs	r0, r0
700a473e: 0000         	movs	r0, r0

700a4740 <UART_intrDisable>:
; {
700a4740: b580         	push	{r7, lr}
700a4742: b088         	sub	sp, #0x20
700a4744: 9007         	str	r0, [sp, #0x1c]
700a4746: 9106         	str	r1, [sp, #0x18]
;     if((intrFlag & 0xF0U) > 0U)
700a4748: f89d 0018    	ldrb.w	r0, [sp, #0x18]
700a474c: f010 0ff0    	tst.w	r0, #0xf0
700a4750: d020         	beq	0x700a4794 <UART_intrDisable+0x54> @ imm = #0x40
700a4752: e7ff         	b	0x700a4754 <UART_intrDisable+0x14> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a4754: 9807         	ldr	r0, [sp, #0x1c]
700a4756: 300c         	adds	r0, #0xc
700a4758: f009 fc42    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x9884
700a475c: 9004         	str	r0, [sp, #0x10]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a475e: 9807         	ldr	r0, [sp, #0x1c]
700a4760: 300c         	adds	r0, #0xc
700a4762: 21bf         	movs	r1, #0xbf
700a4764: f009 fc44    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x9888
;         enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a4768: 9807         	ldr	r0, [sp, #0x1c]
700a476a: 3008         	adds	r0, #0x8
700a476c: 2110         	movs	r1, #0x10
700a476e: 9102         	str	r1, [sp, #0x8]
700a4770: 2204         	movs	r2, #0x4
700a4772: 9203         	str	r2, [sp, #0xc]
700a4774: f009 f82c    	bl	0x700ad7d0 <HW_RD_FIELD32_RAW> @ imm = #0x9058
700a4778: 9902         	ldr	r1, [sp, #0x8]
700a477a: 9a03         	ldr	r2, [sp, #0xc]
700a477c: 9005         	str	r0, [sp, #0x14]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a477e: 9807         	ldr	r0, [sp, #0x1c]
700a4780: 3008         	adds	r0, #0x8
700a4782: 2301         	movs	r3, #0x1
700a4784: f008 f9a4    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x8348
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4788: 9807         	ldr	r0, [sp, #0x1c]
700a478a: 300c         	adds	r0, #0xc
700a478c: 9904         	ldr	r1, [sp, #0x10]
700a478e: f009 fc2f    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x985e
;     }
700a4792: e7ff         	b	0x700a4794 <UART_intrDisable+0x54> @ imm = #-0x2
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a4794: 9807         	ldr	r0, [sp, #0x1c]
700a4796: 300c         	adds	r0, #0xc
700a4798: f009 fc22    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x9844
700a479c: 9004         	str	r0, [sp, #0x10]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700a479e: 9807         	ldr	r0, [sp, #0x1c]
700a47a0: 300c         	adds	r0, #0xc
700a47a2: 9000         	str	r0, [sp]
700a47a4: f009 fc1c    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x9838
700a47a8: 4601         	mov	r1, r0
700a47aa: 9800         	ldr	r0, [sp]
700a47ac: f001 017f    	and	r1, r1, #0x7f
700a47b0: f009 fc1e    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x983c
;     HW_WR_REG32(baseAddr + UART_IER, HW_RD_REG32(baseAddr + UART_IER) &
700a47b4: 9807         	ldr	r0, [sp, #0x1c]
700a47b6: 3004         	adds	r0, #0x4
700a47b8: 9001         	str	r0, [sp, #0x4]
700a47ba: f009 fc11    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x9822
700a47be: 4601         	mov	r1, r0
700a47c0: 9801         	ldr	r0, [sp, #0x4]
700a47c2: 9b06         	ldr	r3, [sp, #0x18]
700a47c4: f06f 02ff    	mvn	r2, #0xff
700a47c8: ea62 0203    	orn	r2, r2, r3
700a47cc: 4011         	ands	r1, r2
700a47ce: f009 fc0f    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x981e
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a47d2: 9807         	ldr	r0, [sp, #0x1c]
700a47d4: 300c         	adds	r0, #0xc
700a47d6: 9904         	ldr	r1, [sp, #0x10]
700a47d8: f009 fc0a    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x9814
;     if((intrFlag & 0xF0U) > 0U)
700a47dc: f89d 0018    	ldrb.w	r0, [sp, #0x18]
700a47e0: f010 0ff0    	tst.w	r0, #0xf0
700a47e4: d017         	beq	0x700a4816 <UART_intrDisable+0xd6> @ imm = #0x2e
700a47e6: e7ff         	b	0x700a47e8 <UART_intrDisable+0xa8> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a47e8: 9807         	ldr	r0, [sp, #0x1c]
700a47ea: 300c         	adds	r0, #0xc
700a47ec: f009 fbf8    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x97f0
700a47f0: 9004         	str	r0, [sp, #0x10]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a47f2: 9807         	ldr	r0, [sp, #0x1c]
700a47f4: 300c         	adds	r0, #0xc
700a47f6: 21bf         	movs	r1, #0xbf
700a47f8: f009 fbfa    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x97f4
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a47fc: 9807         	ldr	r0, [sp, #0x1c]
700a47fe: 3008         	adds	r0, #0x8
700a4800: 9b05         	ldr	r3, [sp, #0x14]
700a4802: 2110         	movs	r1, #0x10
700a4804: 2204         	movs	r2, #0x4
700a4806: f008 f963    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x82c6
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a480a: 9807         	ldr	r0, [sp, #0x1c]
700a480c: 300c         	adds	r0, #0xc
700a480e: 9904         	ldr	r1, [sp, #0x10]
700a4810: f009 fbee    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x97dc
;     }
700a4814: e7ff         	b	0x700a4816 <UART_intrDisable+0xd6> @ imm = #-0x2
; }
700a4816: b008         	add	sp, #0x20
700a4818: bd80         	pop	{r7, pc}
700a481a: 0000         	movs	r0, r0
700a481c: 0000         	movs	r0, r0
700a481e: 0000         	movs	r0, r0

700a4820 <UART_udmaConfigPdmaTx>:
; {
700a4820: b580         	push	{r7, lr}
700a4822: b090         	sub	sp, #0x40
700a4824: 900f         	str	r0, [sp, #0x3c]
700a4826: 910e         	str	r1, [sp, #0x38]
;     udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a4828: 980f         	ldr	r0, [sp, #0x3c]
700a482a: 6840         	ldr	r0, [r0, #0x4]
700a482c: 6cc0         	ldr	r0, [r0, #0x4c]
700a482e: 9008         	str	r0, [sp, #0x20]
;     txChHandle  = udmaChCfg->txChHandle;
700a4830: 9808         	ldr	r0, [sp, #0x20]
700a4832: 6840         	ldr	r0, [r0, #0x4]
700a4834: 9009         	str	r0, [sp, #0x24]
700a4836: a80a         	add	r0, sp, #0x28
;     UdmaChPdmaPrms_init(&pdmaPrms);
700a4838: 9002         	str	r0, [sp, #0x8]
700a483a: f009 f889    	bl	0x700ad950 <UdmaChPdmaPrms_init> @ imm = #0x9112
700a483e: 9902         	ldr	r1, [sp, #0x8]
700a4840: 2000         	movs	r0, #0x0
;     pdmaPrms.elemSize = UDMA_PDMA_ES_8BITS;
700a4842: 9003         	str	r0, [sp, #0xc]
700a4844: 900a         	str	r0, [sp, #0x28]
700a4846: 2201         	movs	r2, #0x1
;     pdmaPrms.elemCnt  = 1U;
700a4848: 920b         	str	r2, [sp, #0x2c]
;     pdmaPrms.fifoCnt  = 0U;
700a484a: 900c         	str	r0, [sp, #0x30]
;     retVal = Udma_chConfigPdma(txChHandle, &pdmaPrms);
700a484c: 9809         	ldr	r0, [sp, #0x24]
700a484e: f7fb f857    	bl	0x7009f900 <Udma_chConfigPdma> @ imm = #-0x4f52
700a4852: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a4854: 980d         	ldr	r0, [sp, #0x34]
700a4856: fab0 f080    	clz	r0, r0
700a485a: 0940         	lsrs	r0, r0, #0x5
700a485c: f240 316b    	movw	r1, #0x36b
700a4860: f2c7 010b    	movt	r1, #0x700b
700a4864: 9105         	str	r1, [sp, #0x14]
700a4866: 466a         	mov	r2, sp
700a4868: 6011         	str	r1, [r2]
700a486a: f64f 7142    	movw	r1, #0xff42
700a486e: f2c7 010a    	movt	r1, #0x700a
700a4872: 9106         	str	r1, [sp, #0x18]
700a4874: f240 322e    	movw	r2, #0x32e
700a4878: f2c7 020b    	movt	r2, #0x700b
700a487c: 9207         	str	r2, [sp, #0x1c]
700a487e: 23ee         	movs	r3, #0xee
700a4880: f004 fc4e    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x489c
;     retVal = Udma_chEnable(txChHandle);
700a4884: 9809         	ldr	r0, [sp, #0x24]
700a4886: f004 fecb    	bl	0x700a9620 <Udma_chEnable> @ imm = #0x4d96
700a488a: 9b05         	ldr	r3, [sp, #0x14]
700a488c: 9906         	ldr	r1, [sp, #0x18]
700a488e: 9a07         	ldr	r2, [sp, #0x1c]
700a4890: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a4892: 980d         	ldr	r0, [sp, #0x34]
700a4894: fab0 f080    	clz	r0, r0
700a4898: 0940         	lsrs	r0, r0, #0x5
700a489a: 46ec         	mov	r12, sp
700a489c: f8cc 3000    	str.w	r3, [r12]
700a48a0: 23f1         	movs	r3, #0xf1
700a48a2: f004 fc3d    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x487a
;     UART_udmaHpdInit(txChHandle, (uint8_t *) udmaChCfg->txHpdMem, hUart->writeBuf, transaction->count);
700a48a6: 9809         	ldr	r0, [sp, #0x24]
700a48a8: 9908         	ldr	r1, [sp, #0x20]
700a48aa: 6949         	ldr	r1, [r1, #0x14]
700a48ac: 9a0f         	ldr	r2, [sp, #0x3c]
700a48ae: 6892         	ldr	r2, [r2, #0x8]
700a48b0: 9b0e         	ldr	r3, [sp, #0x38]
700a48b2: 685b         	ldr	r3, [r3, #0x4]
700a48b4: f000 fd3c    	bl	0x700a5330 <UART_udmaHpdInit> @ imm = #0xa78
;                  Udma_chGetFqRingHandle(txChHandle),
700a48b8: 9809         	ldr	r0, [sp, #0x24]
700a48ba: f004 fdf1    	bl	0x700a94a0 <Udma_chGetFqRingHandle> @ imm = #0x4be2
700a48be: 9a03         	ldr	r2, [sp, #0xc]
;                  (uint64_t) Udma_defaultVirtToPhyFxn(udmaChCfg->txHpdMem, 0U, NULL));
700a48c0: 9004         	str	r0, [sp, #0x10]
700a48c2: 9808         	ldr	r0, [sp, #0x20]
700a48c4: 6940         	ldr	r0, [r0, #0x14]
700a48c6: 4611         	mov	r1, r2
700a48c8: f009 fb9a    	bl	0x700ae000 <Udma_defaultVirtToPhyFxn> @ imm = #0x9734
700a48cc: 4602         	mov	r2, r0
700a48ce: 9804         	ldr	r0, [sp, #0x10]
700a48d0: 460b         	mov	r3, r1
;     retVal = Udma_ringQueueRaw(
700a48d2: f002 fecd    	bl	0x700a7670 <Udma_ringQueueRaw> @ imm = #0x2d9a
700a48d6: 9b05         	ldr	r3, [sp, #0x14]
700a48d8: 9906         	ldr	r1, [sp, #0x18]
700a48da: 9a07         	ldr	r2, [sp, #0x1c]
700a48dc: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a48de: 980d         	ldr	r0, [sp, #0x34]
700a48e0: fab0 f080    	clz	r0, r0
700a48e4: 0940         	lsrs	r0, r0, #0x5
700a48e6: 46ec         	mov	r12, sp
700a48e8: f8cc 3000    	str.w	r3, [r12]
700a48ec: 23f9         	movs	r3, #0xf9
700a48ee: f004 fc17    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x482e
;     return (retVal);
700a48f2: 980d         	ldr	r0, [sp, #0x34]
700a48f4: b010         	add	sp, #0x40
700a48f6: bd80         	pop	{r7, pc}
		...

700a4900 <vTaskDelete>:
; void vTaskDelete(TaskHandle_t xTaskToDelete) {
700a4900: b580         	push	{r7, lr}
700a4902: b084         	sub	sp, #0x10
700a4904: 9003         	str	r0, [sp, #0xc]
;   taskENTER_CRITICAL();
700a4906: f008 f963    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0x82c6
;     pxTCB = prvGetTCBFromHandle(xTaskToDelete);
700a490a: 9803         	ldr	r0, [sp, #0xc]
700a490c: b938         	cbnz	r0, 0x700a491e <vTaskDelete+0x1e> @ imm = #0xe
700a490e: e7ff         	b	0x700a4910 <vTaskDelete+0x10> @ imm = #-0x2
700a4910: f640 50ac    	movw	r0, #0xdac
700a4914: f2c7 000b    	movt	r0, #0x700b
700a4918: 6800         	ldr	r0, [r0]
700a491a: 9001         	str	r0, [sp, #0x4]
700a491c: e002         	b	0x700a4924 <vTaskDelete+0x24> @ imm = #0x4
700a491e: 9803         	ldr	r0, [sp, #0xc]
700a4920: 9001         	str	r0, [sp, #0x4]
700a4922: e7ff         	b	0x700a4924 <vTaskDelete+0x24> @ imm = #-0x2
700a4924: 9801         	ldr	r0, [sp, #0x4]
700a4926: 9002         	str	r0, [sp, #0x8]
;     if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a4928: 9802         	ldr	r0, [sp, #0x8]
700a492a: 3004         	adds	r0, #0x4
700a492c: f007 f8e0    	bl	0x700abaf0 <uxListRemove> @ imm = #0x71c0
700a4930: b908         	cbnz	r0, 0x700a4936 <vTaskDelete+0x36> @ imm = #0x2
700a4932: e7ff         	b	0x700a4934 <vTaskDelete+0x34> @ imm = #-0x2
;     } else {
700a4934: e000         	b	0x700a4938 <vTaskDelete+0x38> @ imm = #0x0
700a4936: e7ff         	b	0x700a4938 <vTaskDelete+0x38> @ imm = #-0x2
;     if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a4938: 9802         	ldr	r0, [sp, #0x8]
700a493a: 6a80         	ldr	r0, [r0, #0x28]
700a493c: b128         	cbz	r0, 0x700a494a <vTaskDelete+0x4a> @ imm = #0xa
700a493e: e7ff         	b	0x700a4940 <vTaskDelete+0x40> @ imm = #-0x2
;       (void)uxListRemove(&(pxTCB->xEventListItem));
700a4940: 9802         	ldr	r0, [sp, #0x8]
700a4942: 3018         	adds	r0, #0x18
700a4944: f007 f8d4    	bl	0x700abaf0 <uxListRemove> @ imm = #0x71a8
;     } else {
700a4948: e000         	b	0x700a494c <vTaskDelete+0x4c> @ imm = #0x0
700a494a: e7ff         	b	0x700a494c <vTaskDelete+0x4c> @ imm = #-0x2
;     uxTaskNumber++;
700a494c: f640 51d8    	movw	r1, #0xdd8
700a4950: f2c7 010b    	movt	r1, #0x700b
700a4954: 6808         	ldr	r0, [r1]
700a4956: 3001         	adds	r0, #0x1
700a4958: 6008         	str	r0, [r1]
;     if (pxTCB == pxCurrentTCB) {
700a495a: 9802         	ldr	r0, [sp, #0x8]
700a495c: f640 51ac    	movw	r1, #0xdac
700a4960: f2c7 010b    	movt	r1, #0x700b
700a4964: 6809         	ldr	r1, [r1]
700a4966: 4288         	cmp	r0, r1
700a4968: d110         	bne	0x700a498c <vTaskDelete+0x8c> @ imm = #0x20
700a496a: e7ff         	b	0x700a496c <vTaskDelete+0x6c> @ imm = #-0x2
;       vListInsertEnd(&xTasksWaitingTermination, &(pxTCB->xStateListItem));
700a496c: 9802         	ldr	r0, [sp, #0x8]
700a496e: 1d01         	adds	r1, r0, #0x4
700a4970: f644 5088    	movw	r0, #0x4d88
700a4974: f2c7 0008    	movt	r0, #0x7008
700a4978: f007 fe92    	bl	0x700ac6a0 <vListInsertEnd> @ imm = #0x7d24
;       ++uxDeletedTasksWaitingCleanUp;
700a497c: f640 51d0    	movw	r1, #0xdd0
700a4980: f2c7 010b    	movt	r1, #0x700b
700a4984: 6808         	ldr	r0, [r1]
700a4986: 3001         	adds	r0, #0x1
700a4988: 6008         	str	r0, [r1]
;     } else {
700a498a: e00c         	b	0x700a49a6 <vTaskDelete+0xa6> @ imm = #0x18
;       --uxCurrentNumberOfTasks;
700a498c: f640 51cc    	movw	r1, #0xdcc
700a4990: f2c7 010b    	movt	r1, #0x700b
700a4994: 6808         	ldr	r0, [r1]
700a4996: 3801         	subs	r0, #0x1
700a4998: 6008         	str	r0, [r1]
;       prvDeleteTCB(pxTCB);
700a499a: 9802         	ldr	r0, [sp, #0x8]
700a499c: f007 fde0    	bl	0x700ac560 <prvDeleteTCB> @ imm = #0x7bc0
;       prvResetNextTaskUnblockTime();
700a49a0: f007 fdfe    	bl	0x700ac5a0 <prvResetNextTaskUnblockTime> @ imm = #0x7bfc
700a49a4: e7ff         	b	0x700a49a6 <vTaskDelete+0xa6> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a49a6: f007 f993    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x7326
;   if (xSchedulerRunning != pdFALSE) {
700a49aa: f640 50f0    	movw	r0, #0xdf0
700a49ae: f2c7 000b    	movt	r0, #0x700b
700a49b2: 6800         	ldr	r0, [r0]
700a49b4: b168         	cbz	r0, 0x700a49d2 <vTaskDelete+0xd2> @ imm = #0x1a
700a49b6: e7ff         	b	0x700a49b8 <vTaskDelete+0xb8> @ imm = #-0x2
;     if (pxTCB == pxCurrentTCB) {
700a49b8: 9802         	ldr	r0, [sp, #0x8]
700a49ba: f640 51ac    	movw	r1, #0xdac
700a49be: f2c7 010b    	movt	r1, #0x700b
700a49c2: 6809         	ldr	r1, [r1]
700a49c4: 4288         	cmp	r0, r1
700a49c6: d102         	bne	0x700a49ce <vTaskDelete+0xce> @ imm = #0x4
700a49c8: e7ff         	b	0x700a49ca <vTaskDelete+0xca> @ imm = #-0x2
;       portYIELD_WITHIN_API();
700a49ca: df00         	svc	#0x0
;     } else {
700a49cc: e000         	b	0x700a49d0 <vTaskDelete+0xd0> @ imm = #0x0
700a49ce: e7ff         	b	0x700a49d0 <vTaskDelete+0xd0> @ imm = #-0x2
;   }
700a49d0: e7ff         	b	0x700a49d2 <vTaskDelete+0xd2> @ imm = #-0x2
; }
700a49d2: b004         	add	sp, #0x10
700a49d4: bd80         	pop	{r7, pc}
		...
700a49de: 0000         	movs	r0, r0

700a49e0 <CSL_bcdmaChanOpGetChanRT>:
; {
700a49e0: b580         	push	{r7, lr}
700a49e2: b088         	sub	sp, #0x20
700a49e4: 9007         	str	r0, [sp, #0x1c]
700a49e6: 9106         	str	r1, [sp, #0x18]
700a49e8: 9205         	str	r2, [sp, #0x14]
700a49ea: 9304         	str	r3, [sp, #0x10]
700a49ec: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a49ee: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a49f0: 9804         	ldr	r0, [sp, #0x10]
700a49f2: b920         	cbnz	r0, 0x700a49fe <CSL_bcdmaChanOpGetChanRT+0x1e> @ imm = #0x8
700a49f4: e7ff         	b	0x700a49f6 <CSL_bcdmaChanOpGetChanRT+0x16> @ imm = #-0x2
700a49f6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a49fa: 9003         	str	r0, [sp, #0xc]
;     }
700a49fc: e057         	b	0x700a4aae <CSL_bcdmaChanOpGetChanRT+0xce> @ imm = #0xae
;         switch( chanType )
700a49fe: 9806         	ldr	r0, [sp, #0x18]
700a4a00: 9000         	str	r0, [sp]
700a4a02: b140         	cbz	r0, 0x700a4a16 <CSL_bcdmaChanOpGetChanRT+0x36> @ imm = #0x10
700a4a04: e7ff         	b	0x700a4a06 <CSL_bcdmaChanOpGetChanRT+0x26> @ imm = #-0x2
700a4a06: 9800         	ldr	r0, [sp]
700a4a08: 2801         	cmp	r0, #0x1
700a4a0a: d00d         	beq	0x700a4a28 <CSL_bcdmaChanOpGetChanRT+0x48> @ imm = #0x1a
700a4a0c: e7ff         	b	0x700a4a0e <CSL_bcdmaChanOpGetChanRT+0x2e> @ imm = #-0x2
700a4a0e: 9800         	ldr	r0, [sp]
700a4a10: 2802         	cmp	r0, #0x2
700a4a12: d012         	beq	0x700a4a3a <CSL_bcdmaChanOpGetChanRT+0x5a> @ imm = #0x24
700a4a14: e01a         	b	0x700a4a4c <CSL_bcdmaChanOpGetChanRT+0x6c> @ imm = #0x34
;                 val = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL );
700a4a16: 9807         	ldr	r0, [sp, #0x1c]
700a4a18: 6880         	ldr	r0, [r0, #0x8]
700a4a1a: 9905         	ldr	r1, [sp, #0x14]
700a4a1c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4a20: f009 fb26    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0x964c
700a4a24: 9002         	str	r0, [sp, #0x8]
;                 break;
700a4a26: e015         	b	0x700a4a54 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x2a
;                 val = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a4a28: 9807         	ldr	r0, [sp, #0x1c]
700a4a2a: 6900         	ldr	r0, [r0, #0x10]
700a4a2c: 9905         	ldr	r1, [sp, #0x14]
700a4a2e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4a32: f009 fb1d    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0x963a
700a4a36: 9002         	str	r0, [sp, #0x8]
;                 break;
700a4a38: e00c         	b	0x700a4a54 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x18
;                 val = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a4a3a: 9807         	ldr	r0, [sp, #0x1c]
700a4a3c: 6980         	ldr	r0, [r0, #0x18]
700a4a3e: 9905         	ldr	r1, [sp, #0x14]
700a4a40: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4a44: f009 fb14    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0x9628
700a4a48: 9002         	str	r0, [sp, #0x8]
;                 break;
700a4a4a: e003         	b	0x700a4a54 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x6
700a4a4c: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a4a50: 9003         	str	r0, [sp, #0xc]
;                 break;
700a4a52: e7ff         	b	0x700a4a54 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #-0x2
;         if( retVal == CSL_PASS )
700a4a54: 9803         	ldr	r0, [sp, #0xc]
700a4a56: bb48         	cbnz	r0, 0x700a4aac <CSL_bcdmaChanOpGetChanRT+0xcc> @ imm = #0x52
700a4a58: e7ff         	b	0x700a4a5a <CSL_bcdmaChanOpGetChanRT+0x7a> @ imm = #-0x2
;             CSL_BcdmaRT *pRT = (CSL_BcdmaRT *)pOpData;
700a4a5a: 9804         	ldr	r0, [sp, #0x10]
700a4a5c: 9001         	str	r0, [sp, #0x4]
;             pRT->enable         = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_EN );
700a4a5e: 9802         	ldr	r0, [sp, #0x8]
700a4a60: 0fc0         	lsrs	r0, r0, #0x1f
700a4a62: 9901         	ldr	r1, [sp, #0x4]
700a4a64: 6008         	str	r0, [r1]
;             pRT->teardown       = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_TDOWN );
700a4a66: 9802         	ldr	r0, [sp, #0x8]
700a4a68: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700a4a6c: 9901         	ldr	r1, [sp, #0x4]
700a4a6e: 6048         	str	r0, [r1, #0x4]
;             pRT->forcedTeardown = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_FTDOWN );
700a4a70: 9802         	ldr	r0, [sp, #0x8]
700a4a72: f3c0 7000    	ubfx	r0, r0, #0x1c, #0x1
700a4a76: 9901         	ldr	r1, [sp, #0x4]
700a4a78: 6108         	str	r0, [r1, #0x10]
;             pRT->pause          = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_PAUSE );
700a4a7a: 9802         	ldr	r0, [sp, #0x8]
700a4a7c: f3c0 7040    	ubfx	r0, r0, #0x1d, #0x1
700a4a80: 9901         	ldr	r1, [sp, #0x4]
700a4a82: 6088         	str	r0, [r1, #0x8]
;             pRT->error          = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_ERROR );
700a4a84: 9802         	ldr	r0, [sp, #0x8]
700a4a86: f000 0001    	and	r0, r0, #0x1
700a4a8a: 9901         	ldr	r1, [sp, #0x4]
700a4a8c: 60c8         	str	r0, [r1, #0xc]
;             if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700a4a8e: 9806         	ldr	r0, [sp, #0x18]
700a4a90: 2802         	cmp	r0, #0x2
700a4a92: d106         	bne	0x700a4aa2 <CSL_bcdmaChanOpGetChanRT+0xc2> @ imm = #0xc
700a4a94: e7ff         	b	0x700a4a96 <CSL_bcdmaChanOpGetChanRT+0xb6> @ imm = #-0x2
;                 pRT->starvation = CSL_FEXT( val, BCDMA_RXCRT_CHAN_CTL_STARVATION );
700a4a96: 9802         	ldr	r0, [sp, #0x8]
700a4a98: f3c0 0040    	ubfx	r0, r0, #0x1, #0x1
700a4a9c: 9901         	ldr	r1, [sp, #0x4]
700a4a9e: 6148         	str	r0, [r1, #0x14]
;             }
700a4aa0: e003         	b	0x700a4aaa <CSL_bcdmaChanOpGetChanRT+0xca> @ imm = #0x6
;                 pRT->starvation = (uint32_t)0U;
700a4aa2: 9901         	ldr	r1, [sp, #0x4]
700a4aa4: 2000         	movs	r0, #0x0
700a4aa6: 6148         	str	r0, [r1, #0x14]
700a4aa8: e7ff         	b	0x700a4aaa <CSL_bcdmaChanOpGetChanRT+0xca> @ imm = #-0x2
;         }
700a4aaa: e7ff         	b	0x700a4aac <CSL_bcdmaChanOpGetChanRT+0xcc> @ imm = #-0x2
700a4aac: e7ff         	b	0x700a4aae <CSL_bcdmaChanOpGetChanRT+0xce> @ imm = #-0x2
;     return retVal;
700a4aae: 9803         	ldr	r0, [sp, #0xc]
700a4ab0: b008         	add	sp, #0x20
700a4ab2: bd80         	pop	{r7, pc}
		...

700a4ac0 <Pinmux_unlockMMR>:
; {
700a4ac0: b580         	push	{r7, lr}
700a4ac2: b088         	sub	sp, #0x20
700a4ac4: 9007         	str	r0, [sp, #0x1c]
;     if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a4ac6: 9807         	ldr	r0, [sp, #0x1c]
700a4ac8: bb78         	cbnz	r0, 0x700a4b2a <Pinmux_unlockMMR+0x6a> @ imm = #0x5e
700a4aca: e7ff         	b	0x700a4acc <Pinmux_unlockMMR+0xc> @ imm = #-0x2
700a4acc: f44f 2070    	mov.w	r0, #0xf0000
700a4ad0: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_PADCFG_CTRL0_CFG0_BASE);
700a4ad2: f7ff fa95    	bl	0x700a4000 <AddrTranslateP_getLocalAddr> @ imm = #-0xad6
700a4ad6: 9006         	str	r0, [sp, #0x18]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_PADCONFIG_LOCK0_KICK0_OFFSET);
700a4ad8: 9806         	ldr	r0, [sp, #0x18]
700a4ada: f241 0108    	movw	r1, #0x1008
700a4ade: 4408         	add	r0, r1
700a4ae0: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a4ae2: 9805         	ldr	r0, [sp, #0x14]
700a4ae4: f243 4190    	movw	r1, #0x3490
700a4ae8: f6c6 01ef    	movt	r1, #0x68ef
700a4aec: 9103         	str	r1, [sp, #0xc]
700a4aee: f009 fa2f    	bl	0x700adf50 <CSL_REG32_WR_RAW> @ imm = #0x945e
;         kickAddr++;
700a4af2: 9805         	ldr	r0, [sp, #0x14]
700a4af4: 3004         	adds	r0, #0x4
700a4af6: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a4af8: 9805         	ldr	r0, [sp, #0x14]
700a4afa: f64b 415a    	movw	r1, #0xbc5a
700a4afe: f2cd 1172    	movt	r1, #0xd172
700a4b02: 9104         	str	r1, [sp, #0x10]
700a4b04: f009 fa24    	bl	0x700adf50 <CSL_REG32_WR_RAW> @ imm = #0x9448
700a4b08: 9903         	ldr	r1, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_PADCONFIG_LOCK1_KICK0_OFFSET);
700a4b0a: 9806         	ldr	r0, [sp, #0x18]
700a4b0c: f245 0208    	movw	r2, #0x5008
700a4b10: 4410         	add	r0, r2
700a4b12: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a4b14: 9805         	ldr	r0, [sp, #0x14]
700a4b16: f009 fa1b    	bl	0x700adf50 <CSL_REG32_WR_RAW> @ imm = #0x9436
700a4b1a: 9904         	ldr	r1, [sp, #0x10]
;         kickAddr++;
700a4b1c: 9805         	ldr	r0, [sp, #0x14]
700a4b1e: 3004         	adds	r0, #0x4
700a4b20: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a4b22: 9805         	ldr	r0, [sp, #0x14]
700a4b24: f009 fa14    	bl	0x700adf50 <CSL_REG32_WR_RAW> @ imm = #0x9428
;     }
700a4b28: e7ff         	b	0x700a4b2a <Pinmux_unlockMMR+0x6a> @ imm = #-0x2
;     if(PINMUX_DOMAIN_ID_MCU == domainId)
700a4b2a: 9807         	ldr	r0, [sp, #0x1c]
700a4b2c: 2801         	cmp	r0, #0x1
700a4b2e: d12f         	bne	0x700a4b90 <Pinmux_unlockMMR+0xd0> @ imm = #0x5e
700a4b30: e7ff         	b	0x700a4b32 <Pinmux_unlockMMR+0x72> @ imm = #-0x2
700a4b32: f04f 6081    	mov.w	r0, #0x4080000
700a4b36: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_PADCFG_CTRL0_CFG0_BASE);
700a4b38: f7ff fa62    	bl	0x700a4000 <AddrTranslateP_getLocalAddr> @ imm = #-0xb3c
700a4b3c: 9006         	str	r0, [sp, #0x18]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK0_KICK0_OFFSET);
700a4b3e: 9806         	ldr	r0, [sp, #0x18]
700a4b40: f241 0108    	movw	r1, #0x1008
700a4b44: 4408         	add	r0, r1
700a4b46: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a4b48: 9805         	ldr	r0, [sp, #0x14]
700a4b4a: f243 4190    	movw	r1, #0x3490
700a4b4e: f6c6 01ef    	movt	r1, #0x68ef
700a4b52: 9101         	str	r1, [sp, #0x4]
700a4b54: f009 f9fc    	bl	0x700adf50 <CSL_REG32_WR_RAW> @ imm = #0x93f8
;         kickAddr++;
700a4b58: 9805         	ldr	r0, [sp, #0x14]
700a4b5a: 3004         	adds	r0, #0x4
700a4b5c: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a4b5e: 9805         	ldr	r0, [sp, #0x14]
700a4b60: f64b 415a    	movw	r1, #0xbc5a
700a4b64: f2cd 1172    	movt	r1, #0xd172
700a4b68: 9102         	str	r1, [sp, #0x8]
700a4b6a: f009 f9f1    	bl	0x700adf50 <CSL_REG32_WR_RAW> @ imm = #0x93e2
700a4b6e: 9901         	ldr	r1, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK1_KICK0_OFFSET);
700a4b70: 9806         	ldr	r0, [sp, #0x18]
700a4b72: f245 0208    	movw	r2, #0x5008
700a4b76: 4410         	add	r0, r2
700a4b78: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a4b7a: 9805         	ldr	r0, [sp, #0x14]
700a4b7c: f009 f9e8    	bl	0x700adf50 <CSL_REG32_WR_RAW> @ imm = #0x93d0
700a4b80: 9902         	ldr	r1, [sp, #0x8]
;         kickAddr++;
700a4b82: 9805         	ldr	r0, [sp, #0x14]
700a4b84: 3004         	adds	r0, #0x4
700a4b86: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a4b88: 9805         	ldr	r0, [sp, #0x14]
700a4b8a: f009 f9e1    	bl	0x700adf50 <CSL_REG32_WR_RAW> @ imm = #0x93c2
;     }
700a4b8e: e7ff         	b	0x700a4b90 <Pinmux_unlockMMR+0xd0> @ imm = #-0x2
;     return;
700a4b90: b008         	add	sp, #0x20
700a4b92: bd80         	pop	{r7, pc}
		...

700a4ba0 <prvAddCurrentTaskToDelayedList>:
;                                const BaseType_t xCanBlockIndefinitely) {
700a4ba0: b580         	push	{r7, lr}
700a4ba2: b084         	sub	sp, #0x10
700a4ba4: 9003         	str	r0, [sp, #0xc]
700a4ba6: 9102         	str	r1, [sp, #0x8]
;   const TickType_t xConstTickCount = xTickCount;
700a4ba8: f640 50f4    	movw	r0, #0xdf4
700a4bac: f2c7 000b    	movt	r0, #0x700b
700a4bb0: 6800         	ldr	r0, [r0]
700a4bb2: 9000         	str	r0, [sp]
;   if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
700a4bb4: f640 50ac    	movw	r0, #0xdac
700a4bb8: f2c7 000b    	movt	r0, #0x700b
700a4bbc: 6800         	ldr	r0, [r0]
700a4bbe: 3004         	adds	r0, #0x4
700a4bc0: f006 ff96    	bl	0x700abaf0 <uxListRemove> @ imm = #0x6f2c
700a4bc4: b908         	cbnz	r0, 0x700a4bca <prvAddCurrentTaskToDelayedList+0x2a> @ imm = #0x2
700a4bc6: e7ff         	b	0x700a4bc8 <prvAddCurrentTaskToDelayedList+0x28> @ imm = #-0x2
;   } else {
700a4bc8: e000         	b	0x700a4bcc <prvAddCurrentTaskToDelayedList+0x2c> @ imm = #0x0
700a4bca: e7ff         	b	0x700a4bcc <prvAddCurrentTaskToDelayedList+0x2c> @ imm = #-0x2
;     if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
700a4bcc: 9803         	ldr	r0, [sp, #0xc]
700a4bce: 3001         	adds	r0, #0x1
700a4bd0: b980         	cbnz	r0, 0x700a4bf4 <prvAddCurrentTaskToDelayedList+0x54> @ imm = #0x20
700a4bd2: e7ff         	b	0x700a4bd4 <prvAddCurrentTaskToDelayedList+0x34> @ imm = #-0x2
700a4bd4: 9802         	ldr	r0, [sp, #0x8]
700a4bd6: b168         	cbz	r0, 0x700a4bf4 <prvAddCurrentTaskToDelayedList+0x54> @ imm = #0x1a
700a4bd8: e7ff         	b	0x700a4bda <prvAddCurrentTaskToDelayedList+0x3a> @ imm = #-0x2
;       vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
700a4bda: f640 50ac    	movw	r0, #0xdac
700a4bde: f2c7 000b    	movt	r0, #0x700b
700a4be2: 6800         	ldr	r0, [r0]
700a4be4: 1d01         	adds	r1, r0, #0x4
700a4be6: f644 5074    	movw	r0, #0x4d74
700a4bea: f2c7 0008    	movt	r0, #0x7008
700a4bee: f007 fd57    	bl	0x700ac6a0 <vListInsertEnd> @ imm = #0x7aae
;     } else {
700a4bf2: e03d         	b	0x700a4c70 <prvAddCurrentTaskToDelayedList+0xd0> @ imm = #0x7a
;       xTimeToWake = xConstTickCount + xTicksToWait;
700a4bf4: 9800         	ldr	r0, [sp]
700a4bf6: 9903         	ldr	r1, [sp, #0xc]
700a4bf8: 4408         	add	r0, r1
700a4bfa: 9001         	str	r0, [sp, #0x4]
;       listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
700a4bfc: 9801         	ldr	r0, [sp, #0x4]
700a4bfe: f640 51ac    	movw	r1, #0xdac
700a4c02: f2c7 010b    	movt	r1, #0x700b
700a4c06: 6809         	ldr	r1, [r1]
700a4c08: 6048         	str	r0, [r1, #0x4]
;       if (xTimeToWake < xConstTickCount) {
700a4c0a: 9801         	ldr	r0, [sp, #0x4]
700a4c0c: 9900         	ldr	r1, [sp]
700a4c0e: 4288         	cmp	r0, r1
700a4c10: d20e         	bhs	0x700a4c30 <prvAddCurrentTaskToDelayedList+0x90> @ imm = #0x1c
700a4c12: e7ff         	b	0x700a4c14 <prvAddCurrentTaskToDelayedList+0x74> @ imm = #-0x2
;         vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
700a4c14: f644 50b4    	movw	r0, #0x4db4
700a4c18: f2c7 0008    	movt	r0, #0x7008
700a4c1c: 6800         	ldr	r0, [r0]
700a4c1e: f640 51ac    	movw	r1, #0xdac
700a4c22: f2c7 010b    	movt	r1, #0x700b
700a4c26: 6809         	ldr	r1, [r1]
700a4c28: 3104         	adds	r1, #0x4
700a4c2a: f004 ffb9    	bl	0x700a9ba0 <vListInsert> @ imm = #0x4f72
;       } else {
700a4c2e: e01e         	b	0x700a4c6e <prvAddCurrentTaskToDelayedList+0xce> @ imm = #0x3c
;         vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
700a4c30: f644 50b0    	movw	r0, #0x4db0
700a4c34: f2c7 0008    	movt	r0, #0x7008
700a4c38: 6800         	ldr	r0, [r0]
700a4c3a: f640 51ac    	movw	r1, #0xdac
700a4c3e: f2c7 010b    	movt	r1, #0x700b
700a4c42: 6809         	ldr	r1, [r1]
700a4c44: 3104         	adds	r1, #0x4
700a4c46: f004 ffab    	bl	0x700a9ba0 <vListInsert> @ imm = #0x4f56
;         if (xTimeToWake < xNextTaskUnblockTime) {
700a4c4a: 9801         	ldr	r0, [sp, #0x4]
700a4c4c: f640 51e4    	movw	r1, #0xde4
700a4c50: f2c7 010b    	movt	r1, #0x700b
700a4c54: 6809         	ldr	r1, [r1]
700a4c56: 4288         	cmp	r0, r1
700a4c58: d207         	bhs	0x700a4c6a <prvAddCurrentTaskToDelayedList+0xca> @ imm = #0xe
700a4c5a: e7ff         	b	0x700a4c5c <prvAddCurrentTaskToDelayedList+0xbc> @ imm = #-0x2
;           xNextTaskUnblockTime = xTimeToWake;
700a4c5c: 9801         	ldr	r0, [sp, #0x4]
700a4c5e: f640 51e4    	movw	r1, #0xde4
700a4c62: f2c7 010b    	movt	r1, #0x700b
700a4c66: 6008         	str	r0, [r1]
;         } else {
700a4c68: e000         	b	0x700a4c6c <prvAddCurrentTaskToDelayedList+0xcc> @ imm = #0x0
700a4c6a: e7ff         	b	0x700a4c6c <prvAddCurrentTaskToDelayedList+0xcc> @ imm = #-0x2
700a4c6c: e7ff         	b	0x700a4c6e <prvAddCurrentTaskToDelayedList+0xce> @ imm = #-0x2
700a4c6e: e7ff         	b	0x700a4c70 <prvAddCurrentTaskToDelayedList+0xd0> @ imm = #-0x2
; }
700a4c70: b004         	add	sp, #0x10
700a4c72: bd80         	pop	{r7, pc}
		...

700a4c80 <UART_lld_write>:
; {
700a4c80: b580         	push	{r7, lr}
700a4c82: b086         	sub	sp, #0x18
700a4c84: f8dd c020    	ldr.w	r12, [sp, #0x20]
700a4c88: 9005         	str	r0, [sp, #0x14]
700a4c8a: 9104         	str	r1, [sp, #0x10]
700a4c8c: 9203         	str	r2, [sp, #0xc]
700a4c8e: 9302         	str	r3, [sp, #0x8]
700a4c90: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a4c92: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a4c94: 9805         	ldr	r0, [sp, #0x14]
700a4c96: 2800         	cmp	r0, #0x0
700a4c98: d054         	beq	0x700a4d44 <UART_lld_write+0xc4> @ imm = #0xa8
700a4c9a: e7ff         	b	0x700a4c9c <UART_lld_write+0x1c> @ imm = #-0x2
;          trans = &hUart->writeTrans;
700a4c9c: 9805         	ldr	r0, [sp, #0x14]
700a4c9e: 303c         	adds	r0, #0x3c
700a4ca0: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a4ca2: 9800         	ldr	r0, [sp]
700a4ca4: 6800         	ldr	r0, [r0]
700a4ca6: b138         	cbz	r0, 0x700a4cb8 <UART_lld_write+0x38> @ imm = #0xe
700a4ca8: e7ff         	b	0x700a4caa <UART_lld_write+0x2a> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a4caa: 9900         	ldr	r1, [sp]
700a4cac: 2009         	movs	r0, #0x9
700a4cae: 60c8         	str	r0, [r1, #0xc]
700a4cb0: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a4cb4: 9001         	str	r0, [sp, #0x4]
;         }
700a4cb6: e044         	b	0x700a4d42 <UART_lld_write+0xc2> @ imm = #0x88
;             UART_lld_Transaction_init(trans);
700a4cb8: 9800         	ldr	r0, [sp]
700a4cba: f008 fac9    	bl	0x700ad250 <UART_lld_Transaction_init> @ imm = #0x8592
;             if(extendedParams != NULL)
700a4cbe: 9808         	ldr	r0, [sp, #0x20]
700a4cc0: b128         	cbz	r0, 0x700a4cce <UART_lld_write+0x4e> @ imm = #0xa
700a4cc2: e7ff         	b	0x700a4cc4 <UART_lld_write+0x44> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a4cc4: 9808         	ldr	r0, [sp, #0x20]
700a4cc6: 6800         	ldr	r0, [r0]
700a4cc8: 9900         	ldr	r1, [sp]
700a4cca: 6108         	str	r0, [r1, #0x10]
;             }
700a4ccc: e003         	b	0x700a4cd6 <UART_lld_write+0x56> @ imm = #0x6
;                 trans->args = NULL;
700a4cce: 9900         	ldr	r1, [sp]
700a4cd0: 2000         	movs	r0, #0x0
700a4cd2: 6108         	str	r0, [r1, #0x10]
700a4cd4: e7ff         	b	0x700a4cd6 <UART_lld_write+0x56> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a4cd6: 9804         	ldr	r0, [sp, #0x10]
700a4cd8: 9900         	ldr	r1, [sp]
700a4cda: 6008         	str	r0, [r1]
;             trans->count = size;
700a4cdc: 9803         	ldr	r0, [sp, #0xc]
700a4cde: 9900         	ldr	r1, [sp]
700a4ce0: 6048         	str	r0, [r1, #0x4]
;             trans->timeout = timeout;
700a4ce2: 9802         	ldr	r0, [sp, #0x8]
700a4ce4: 9900         	ldr	r1, [sp]
700a4ce6: 6088         	str	r0, [r1, #0x8]
;             if(hUart->state == UART_STATE_READY)
700a4ce8: 9805         	ldr	r0, [sp, #0x14]
700a4cea: 6d40         	ldr	r0, [r0, #0x54]
700a4cec: 2801         	cmp	r0, #0x1
700a4cee: d105         	bne	0x700a4cfc <UART_lld_write+0x7c> @ imm = #0xa
700a4cf0: e7ff         	b	0x700a4cf2 <UART_lld_write+0x72> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a4cf2: 9800         	ldr	r0, [sp]
700a4cf4: f007 fe74    	bl	0x700ac9e0 <UART_checkTransaction> @ imm = #0x7ce8
700a4cf8: 9001         	str	r0, [sp, #0x4]
;             }
700a4cfa: e003         	b	0x700a4d04 <UART_lld_write+0x84> @ imm = #0x6
700a4cfc: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a4d00: 9001         	str	r0, [sp, #0x4]
700a4d02: e7ff         	b	0x700a4d04 <UART_lld_write+0x84> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a4d04: 9801         	ldr	r0, [sp, #0x4]
700a4d06: b980         	cbnz	r0, 0x700a4d2a <UART_lld_write+0xaa> @ imm = #0x20
700a4d08: e7ff         	b	0x700a4d0a <UART_lld_write+0x8a> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a4d0a: 9800         	ldr	r0, [sp]
700a4d0c: 6800         	ldr	r0, [r0]
700a4d0e: 9905         	ldr	r1, [sp, #0x14]
700a4d10: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a4d12: 9800         	ldr	r0, [sp]
700a4d14: 6880         	ldr	r0, [r0, #0x8]
700a4d16: 9905         	ldr	r1, [sp, #0x14]
700a4d18: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a4d1a: 9905         	ldr	r1, [sp, #0x14]
700a4d1c: 2000         	movs	r0, #0x0
700a4d1e: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a4d20: 9800         	ldr	r0, [sp]
700a4d22: 6840         	ldr	r0, [r0, #0x4]
700a4d24: 9905         	ldr	r1, [sp, #0x14]
700a4d26: 6108         	str	r0, [r1, #0x10]
;             }
700a4d28: e7ff         	b	0x700a4d2a <UART_lld_write+0xaa> @ imm = #-0x2
;             hUart->state = UART_STATE_BUSY;
700a4d2a: 9905         	ldr	r1, [sp, #0x14]
700a4d2c: 2002         	movs	r0, #0x2
700a4d2e: 6548         	str	r0, [r1, #0x54]
;             status = UART_writePolling(hUart, trans);
700a4d30: 9805         	ldr	r0, [sp, #0x14]
700a4d32: 9900         	ldr	r1, [sp]
700a4d34: f7fc fc14    	bl	0x700a1560 <UART_writePolling> @ imm = #-0x37d8
700a4d38: 9001         	str	r0, [sp, #0x4]
;             hUart->state = UART_STATE_READY;
700a4d3a: 9905         	ldr	r1, [sp, #0x14]
700a4d3c: 2001         	movs	r0, #0x1
700a4d3e: 6548         	str	r0, [r1, #0x54]
700a4d40: e7ff         	b	0x700a4d42 <UART_lld_write+0xc2> @ imm = #-0x2
;     }
700a4d42: e003         	b	0x700a4d4c <UART_lld_write+0xcc> @ imm = #0x6
700a4d44: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a4d48: 9001         	str	r0, [sp, #0x4]
700a4d4a: e7ff         	b	0x700a4d4c <UART_lld_write+0xcc> @ imm = #-0x2
;     return status;
700a4d4c: 9801         	ldr	r0, [sp, #0x4]
700a4d4e: b006         	add	sp, #0x18
700a4d50: bd80         	pop	{r7, pc}
		...
700a4d5e: 0000         	movs	r0, r0

700a4d60 <UART_udmaDeInitCh>:
; {
700a4d60: b580         	push	{r7, lr}
700a4d62: b08c         	sub	sp, #0x30
700a4d64: 900b         	str	r0, [sp, #0x2c]
700a4d66: 910a         	str	r1, [sp, #0x28]
700a4d68: 2000         	movs	r0, #0x0
;     int32_t status = UDMA_SOK;
700a4d6a: 9009         	str	r0, [sp, #0x24]
700a4d6c: 2001         	movs	r0, #0x1
;     uint32_t temp = TRUE;
700a4d6e: 9008         	str	r0, [sp, #0x20]
;     status = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
700a4d70: 980b         	ldr	r0, [sp, #0x2c]
700a4d72: 2164         	movs	r1, #0x64
700a4d74: f001 fbe4    	bl	0x700a6540 <Udma_chDisable> @ imm = #0x17c8
700a4d78: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a4d7a: 9809         	ldr	r0, [sp, #0x24]
700a4d7c: fab0 f080    	clz	r0, r0
700a4d80: 0940         	lsrs	r0, r0, #0x5
700a4d82: f240 31b7    	movw	r1, #0x3b7
700a4d86: f2c7 010b    	movt	r1, #0x700b
700a4d8a: 9102         	str	r1, [sp, #0x8]
700a4d8c: 466a         	mov	r2, sp
700a4d8e: 6011         	str	r1, [r2]
700a4d90: f64f 7142    	movw	r1, #0xff42
700a4d94: f2c7 010a    	movt	r1, #0x700a
700a4d98: 9103         	str	r1, [sp, #0xc]
700a4d9a: f240 4201    	movw	r2, #0x401
700a4d9e: f2c7 020b    	movt	r2, #0x700b
700a4da2: 9204         	str	r2, [sp, #0x10]
700a4da4: f240 134b    	movw	r3, #0x14b
700a4da8: f004 f9ba    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x4374
;     status = Udma_eventUnRegister(eventHandle);
700a4dac: 980a         	ldr	r0, [sp, #0x28]
700a4dae: f000 fc5f    	bl	0x700a5670 <Udma_eventUnRegister> @ imm = #0x8be
700a4db2: 9b02         	ldr	r3, [sp, #0x8]
700a4db4: 9903         	ldr	r1, [sp, #0xc]
700a4db6: 9a04         	ldr	r2, [sp, #0x10]
700a4db8: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a4dba: 9809         	ldr	r0, [sp, #0x24]
700a4dbc: fab0 f080    	clz	r0, r0
700a4dc0: 0940         	lsrs	r0, r0, #0x5
700a4dc2: 46ec         	mov	r12, sp
700a4dc4: f8cc 3000    	str.w	r3, [r12]
700a4dc8: f240 134f    	movw	r3, #0x14f
700a4dcc: f004 f9a8    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x4350
;     while(temp == TRUE)
700a4dd0: e7ff         	b	0x700a4dd2 <UART_udmaDeInitCh+0x72> @ imm = #-0x2
700a4dd2: 9808         	ldr	r0, [sp, #0x20]
700a4dd4: 2801         	cmp	r0, #0x1
700a4dd6: d10f         	bne	0x700a4df8 <UART_udmaDeInitCh+0x98> @ imm = #0x1e
700a4dd8: e7ff         	b	0x700a4dda <UART_udmaDeInitCh+0x7a> @ imm = #-0x2
;                          Udma_chGetFqRingHandle(chHandle), &pDesc);
700a4dda: 980b         	ldr	r0, [sp, #0x2c]
700a4ddc: f004 fb60    	bl	0x700a94a0 <Udma_chGetFqRingHandle> @ imm = #0x46c0
700a4de0: a906         	add	r1, sp, #0x18
;         tempRetVal = Udma_ringFlushRaw(
700a4de2: f003 fc2d    	bl	0x700a8640 <Udma_ringFlushRaw> @ imm = #0x385a
700a4de6: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_ETIMEOUT == tempRetVal)
700a4de8: 9805         	ldr	r0, [sp, #0x14]
700a4dea: 3004         	adds	r0, #0x4
700a4dec: b918         	cbnz	r0, 0x700a4df6 <UART_udmaDeInitCh+0x96> @ imm = #0x6
700a4dee: e7ff         	b	0x700a4df0 <UART_udmaDeInitCh+0x90> @ imm = #-0x2
700a4df0: 2000         	movs	r0, #0x0
;             temp = FALSE;
700a4df2: 9008         	str	r0, [sp, #0x20]
;         }
700a4df4: e7ff         	b	0x700a4df6 <UART_udmaDeInitCh+0x96> @ imm = #-0x2
;     while(temp == TRUE)
700a4df6: e7ec         	b	0x700a4dd2 <UART_udmaDeInitCh+0x72> @ imm = #-0x28
;     status = Udma_chClose(chHandle);
700a4df8: 980b         	ldr	r0, [sp, #0x2c]
700a4dfa: f000 fd71    	bl	0x700a58e0 <Udma_chClose> @ imm = #0xae2
700a4dfe: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a4e00: 9809         	ldr	r0, [sp, #0x24]
700a4e02: fab0 f080    	clz	r0, r0
700a4e06: 0940         	lsrs	r0, r0, #0x5
700a4e08: f240 31b7    	movw	r1, #0x3b7
700a4e0c: f2c7 010b    	movt	r1, #0x700b
700a4e10: 466a         	mov	r2, sp
700a4e12: 6011         	str	r1, [r2]
700a4e14: f64f 7142    	movw	r1, #0xff42
700a4e18: f2c7 010a    	movt	r1, #0x700a
700a4e1c: f240 4201    	movw	r2, #0x401
700a4e20: f2c7 020b    	movt	r2, #0x700b
700a4e24: f240 1361    	movw	r3, #0x161
700a4e28: f004 f97a    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x42f4
;     return status;
700a4e2c: 9809         	ldr	r0, [sp, #0x24]
700a4e2e: b00c         	add	sp, #0x30
700a4e30: bd80         	pop	{r7, pc}
		...
700a4e3e: 0000         	movs	r0, r0

700a4e40 <vTaskSwitchContext>:
; void vTaskSwitchContext(void) {
700a4e40: b082         	sub	sp, #0x8
;   if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
700a4e42: f640 50d4    	movw	r0, #0xdd4
700a4e46: f2c7 000b    	movt	r0, #0x700b
700a4e4a: 6800         	ldr	r0, [r0]
700a4e4c: b138         	cbz	r0, 0x700a4e5e <vTaskSwitchContext+0x1e> @ imm = #0xe
700a4e4e: e7ff         	b	0x700a4e50 <vTaskSwitchContext+0x10> @ imm = #-0x2
;     xYieldPending = pdTRUE;
700a4e50: f640 6100    	movw	r1, #0xe00
700a4e54: f2c7 010b    	movt	r1, #0x700b
700a4e58: 2001         	movs	r0, #0x1
700a4e5a: 6008         	str	r0, [r1]
;   } else {
700a4e5c: e057         	b	0x700a4f0e <vTaskSwitchContext+0xce> @ imm = #0xae
;     xYieldPending = pdFALSE;
700a4e5e: f640 6100    	movw	r1, #0xe00
700a4e62: f2c7 010b    	movt	r1, #0x700b
700a4e66: 2000         	movs	r0, #0x0
700a4e68: 6008         	str	r0, [r1]
;       pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
700a4e6a: f640 5064    	movw	r0, #0xd64
700a4e6e: f2c7 000b    	movt	r0, #0x700b
700a4e72: 6800         	ldr	r0, [r0]
700a4e74: f640 51ac    	movw	r1, #0xdac
700a4e78: f2c7 010b    	movt	r1, #0x700b
700a4e7c: 6809         	ldr	r1, [r1]
700a4e7e: f8c1 0084    	str.w	r0, [r1, #0x84]
;     taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this
700a4e82: f640 50dc    	movw	r0, #0xddc
700a4e86: f2c7 000b    	movt	r0, #0x700b
700a4e8a: 6800         	ldr	r0, [r0]
700a4e8c: 9001         	str	r0, [sp, #0x4]
700a4e8e: e7ff         	b	0x700a4e90 <vTaskSwitchContext+0x50> @ imm = #-0x2
700a4e90: 9801         	ldr	r0, [sp, #0x4]
700a4e92: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a4e96: f244 40f8    	movw	r0, #0x44f8
700a4e9a: f2c7 0008    	movt	r0, #0x7008
700a4e9e: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a4ea2: b920         	cbnz	r0, 0x700a4eae <vTaskSwitchContext+0x6e> @ imm = #0x8
700a4ea4: e7ff         	b	0x700a4ea6 <vTaskSwitchContext+0x66> @ imm = #-0x2
700a4ea6: 9801         	ldr	r0, [sp, #0x4]
700a4ea8: 3801         	subs	r0, #0x1
700a4eaa: 9001         	str	r0, [sp, #0x4]
700a4eac: e7f0         	b	0x700a4e90 <vTaskSwitchContext+0x50> @ imm = #-0x20
700a4eae: 9801         	ldr	r0, [sp, #0x4]
700a4eb0: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a4eb4: f244 40f8    	movw	r0, #0x44f8
700a4eb8: f2c7 0008    	movt	r0, #0x7008
700a4ebc: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4ec0: 9000         	str	r0, [sp]
700a4ec2: 9900         	ldr	r1, [sp]
700a4ec4: 6848         	ldr	r0, [r1, #0x4]
700a4ec6: 6840         	ldr	r0, [r0, #0x4]
700a4ec8: 6048         	str	r0, [r1, #0x4]
700a4eca: 9900         	ldr	r1, [sp]
700a4ecc: 6848         	ldr	r0, [r1, #0x4]
700a4ece: 3108         	adds	r1, #0x8
700a4ed0: 4288         	cmp	r0, r1
700a4ed2: d105         	bne	0x700a4ee0 <vTaskSwitchContext+0xa0> @ imm = #0xa
700a4ed4: e7ff         	b	0x700a4ed6 <vTaskSwitchContext+0x96> @ imm = #-0x2
700a4ed6: 9900         	ldr	r1, [sp]
700a4ed8: 6848         	ldr	r0, [r1, #0x4]
700a4eda: 6840         	ldr	r0, [r0, #0x4]
700a4edc: 6048         	str	r0, [r1, #0x4]
700a4ede: e7ff         	b	0x700a4ee0 <vTaskSwitchContext+0xa0> @ imm = #-0x2
700a4ee0: 9800         	ldr	r0, [sp]
700a4ee2: 6840         	ldr	r0, [r0, #0x4]
700a4ee4: 68c1         	ldr	r1, [r0, #0xc]
700a4ee6: f640 50ac    	movw	r0, #0xdac
700a4eea: f2c7 000b    	movt	r0, #0x700b
700a4eee: 6001         	str	r1, [r0]
700a4ef0: 9901         	ldr	r1, [sp, #0x4]
700a4ef2: f640 52dc    	movw	r2, #0xddc
700a4ef6: f2c7 020b    	movt	r2, #0x700b
700a4efa: 6011         	str	r1, [r2]
;       FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
700a4efc: 6800         	ldr	r0, [r0]
700a4efe: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a4f02: f640 5164    	movw	r1, #0xd64
700a4f06: f2c7 010b    	movt	r1, #0x700b
700a4f0a: 6008         	str	r0, [r1]
700a4f0c: e7ff         	b	0x700a4f0e <vTaskSwitchContext+0xce> @ imm = #-0x2
; }
700a4f0e: b002         	add	sp, #0x8
700a4f10: 4770         	bx	lr
		...
700a4f1e: 0000         	movs	r0, r0

700a4f20 <Udma_rmAllocVintrBit>:
; {
700a4f20: b580         	push	{r7, lr}
700a4f22: b08a         	sub	sp, #0x28
700a4f24: 9009         	str	r0, [sp, #0x24]
700a4f26: f64f 70ff    	movw	r0, #0xffff
;     uint32_t                vintrBitNum = UDMA_EVENT_INVALID;
700a4f2a: 9007         	str	r0, [sp, #0x1c]
;     Udma_DrvHandleInt       drvHandle = eventHandle->drvHandle;
700a4f2c: 9809         	ldr	r0, [sp, #0x24]
700a4f2e: 6800         	ldr	r0, [r0]
700a4f30: 9001         	str	r0, [sp, #0x4]
;     controllerEventHandle = eventHandle;
700a4f32: 9809         	ldr	r0, [sp, #0x24]
700a4f34: 9003         	str	r0, [sp, #0xc]
;     eventPrms = &eventHandle->eventPrms;
700a4f36: 9809         	ldr	r0, [sp, #0x24]
700a4f38: 3008         	adds	r0, #0x8
700a4f3a: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != eventPrms->controllerEventHandle)
700a4f3c: 9802         	ldr	r0, [sp, #0x8]
700a4f3e: 6900         	ldr	r0, [r0, #0x10]
700a4f40: b120         	cbz	r0, 0x700a4f4c <Udma_rmAllocVintrBit+0x2c> @ imm = #0x8
700a4f42: e7ff         	b	0x700a4f44 <Udma_rmAllocVintrBit+0x24> @ imm = #-0x2
;         controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a4f44: 9802         	ldr	r0, [sp, #0x8]
700a4f46: 6900         	ldr	r0, [r0, #0x10]
700a4f48: 9003         	str	r0, [sp, #0xc]
;     }
700a4f4a: e7ff         	b	0x700a4f4c <Udma_rmAllocVintrBit+0x2c> @ imm = #-0x2
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a4f4c: 9801         	ldr	r0, [sp, #0x4]
700a4f4e: f500 609f    	add.w	r0, r0, #0x4f8
700a4f52: f04f 31ff    	mov.w	r1, #0xffffffff
700a4f56: f003 fe8b    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x3d16
700a4f5a: 2000         	movs	r0, #0x0
;     for(i = 0U; i < UDMA_MAX_EVENTS_PER_VINTR; i++)
700a4f5c: 9008         	str	r0, [sp, #0x20]
700a4f5e: e7ff         	b	0x700a4f60 <Udma_rmAllocVintrBit+0x40> @ imm = #-0x2
700a4f60: 9808         	ldr	r0, [sp, #0x20]
700a4f62: 283f         	cmp	r0, #0x3f
700a4f64: d83a         	bhi	0x700a4fdc <Udma_rmAllocVintrBit+0xbc> @ imm = #0x74
700a4f66: e7ff         	b	0x700a4f68 <Udma_rmAllocVintrBit+0x48> @ imm = #-0x2
;         bitMask = ((uint64_t) 1U << i);
700a4f68: 9b08         	ldr	r3, [sp, #0x20]
700a4f6a: f1a3 0220    	sub.w	r2, r3, #0x20
700a4f6e: 2101         	movs	r1, #0x1
700a4f70: fa01 fc02    	lsl.w	r12, r1, r2
700a4f74: f1c3 0020    	rsb.w	r0, r3, #0x20
700a4f78: fa21 f000    	lsr.w	r0, r1, r0
700a4f7c: 2a00         	cmp	r2, #0x0
700a4f7e: bf58         	it	pl
700a4f80: 4660         	movpl	r0, r12
700a4f82: fa01 f103    	lsl.w	r1, r1, r3
700a4f86: 2a00         	cmp	r2, #0x0
700a4f88: bf58         	it	pl
700a4f8a: 2100         	movpl	r1, #0x0
700a4f8c: 9104         	str	r1, [sp, #0x10]
700a4f8e: 9005         	str	r0, [sp, #0x14]
;         if((controllerEventHandle->vintrBitAllocFlag & bitMask) == 0U)
700a4f90: 9903         	ldr	r1, [sp, #0xc]
700a4f92: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a4f96: f8d1 108c    	ldr.w	r1, [r1, #0x8c]
700a4f9a: 9a04         	ldr	r2, [sp, #0x10]
700a4f9c: 9b05         	ldr	r3, [sp, #0x14]
700a4f9e: ea01 0103    	and.w	r1, r1, r3
700a4fa2: ea00 0002    	and.w	r0, r0, r2
700a4fa6: ea40 0001    	orr.w	r0, r0, r1
700a4faa: b990         	cbnz	r0, 0x700a4fd2 <Udma_rmAllocVintrBit+0xb2> @ imm = #0x24
700a4fac: e7ff         	b	0x700a4fae <Udma_rmAllocVintrBit+0x8e> @ imm = #-0x2
;             controllerEventHandle->vintrBitAllocFlag |= bitMask;
700a4fae: f8dd c010    	ldr.w	r12, [sp, #0x10]
700a4fb2: 9b05         	ldr	r3, [sp, #0x14]
700a4fb4: 9903         	ldr	r1, [sp, #0xc]
700a4fb6: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a4fba: f8d1 208c    	ldr.w	r2, [r1, #0x8c]
700a4fbe: ea40 000c    	orr.w	r0, r0, r12
700a4fc2: 431a         	orrs	r2, r3
700a4fc4: f8c1 208c    	str.w	r2, [r1, #0x8c]
700a4fc8: f8c1 0088    	str.w	r0, [r1, #0x88]
;             vintrBitNum = i;
700a4fcc: 9808         	ldr	r0, [sp, #0x20]
700a4fce: 9007         	str	r0, [sp, #0x1c]
;             break;
700a4fd0: e004         	b	0x700a4fdc <Udma_rmAllocVintrBit+0xbc> @ imm = #0x8
;     }
700a4fd2: e7ff         	b	0x700a4fd4 <Udma_rmAllocVintrBit+0xb4> @ imm = #-0x2
;     for(i = 0U; i < UDMA_MAX_EVENTS_PER_VINTR; i++)
700a4fd4: 9808         	ldr	r0, [sp, #0x20]
700a4fd6: 3001         	adds	r0, #0x1
700a4fd8: 9008         	str	r0, [sp, #0x20]
700a4fda: e7c1         	b	0x700a4f60 <Udma_rmAllocVintrBit+0x40> @ imm = #-0x7e
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a4fdc: 9801         	ldr	r0, [sp, #0x4]
700a4fde: f500 609f    	add.w	r0, r0, #0x4f8
700a4fe2: f005 f995    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x532a
;     return (vintrBitNum);
700a4fe6: 9807         	ldr	r0, [sp, #0x1c]
700a4fe8: b00a         	add	sp, #0x28
700a4fea: bd80         	pop	{r7, pc}
700a4fec: 0000         	movs	r0, r0
700a4fee: 0000         	movs	r0, r0

700a4ff0 <prvCopyDataToQueue>:
; {
700a4ff0: b580         	push	{r7, lr}
700a4ff2: b086         	sub	sp, #0x18
700a4ff4: 9005         	str	r0, [sp, #0x14]
700a4ff6: 9104         	str	r1, [sp, #0x10]
700a4ff8: 9203         	str	r2, [sp, #0xc]
700a4ffa: 2000         	movs	r0, #0x0
;     BaseType_t xReturn = pdFALSE;
700a4ffc: 9002         	str	r0, [sp, #0x8]
;     uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a4ffe: 9805         	ldr	r0, [sp, #0x14]
700a5000: 6b80         	ldr	r0, [r0, #0x38]
700a5002: 9001         	str	r0, [sp, #0x4]
;     if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
700a5004: 9805         	ldr	r0, [sp, #0x14]
700a5006: 6c00         	ldr	r0, [r0, #0x40]
700a5008: b978         	cbnz	r0, 0x700a502a <prvCopyDataToQueue+0x3a> @ imm = #0x1e
700a500a: e7ff         	b	0x700a500c <prvCopyDataToQueue+0x1c> @ imm = #-0x2
;                 if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a500c: 9805         	ldr	r0, [sp, #0x14]
700a500e: 6800         	ldr	r0, [r0]
700a5010: b948         	cbnz	r0, 0x700a5026 <prvCopyDataToQueue+0x36> @ imm = #0x12
700a5012: e7ff         	b	0x700a5014 <prvCopyDataToQueue+0x24> @ imm = #-0x2
;                     xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
700a5014: 9805         	ldr	r0, [sp, #0x14]
700a5016: 6880         	ldr	r0, [r0, #0x8]
700a5018: f001 fd52    	bl	0x700a6ac0 <xTaskPriorityDisinherit> @ imm = #0x1aa4
700a501c: 9002         	str	r0, [sp, #0x8]
;                     pxQueue->u.xSemaphore.xMutexHolder = NULL;
700a501e: 9905         	ldr	r1, [sp, #0x14]
700a5020: 2000         	movs	r0, #0x0
700a5022: 6088         	str	r0, [r1, #0x8]
;                 }
700a5024: e000         	b	0x700a5028 <prvCopyDataToQueue+0x38> @ imm = #0x0
700a5026: e7ff         	b	0x700a5028 <prvCopyDataToQueue+0x38> @ imm = #-0x2
;     }
700a5028: e041         	b	0x700a50ae <prvCopyDataToQueue+0xbe> @ imm = #0x82
;     else if( xPosition == queueSEND_TO_BACK )
700a502a: 9803         	ldr	r0, [sp, #0xc]
700a502c: b9b8         	cbnz	r0, 0x700a505e <prvCopyDataToQueue+0x6e> @ imm = #0x2e
700a502e: e7ff         	b	0x700a5030 <prvCopyDataToQueue+0x40> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
700a5030: 9a05         	ldr	r2, [sp, #0x14]
700a5032: 9904         	ldr	r1, [sp, #0x10]
700a5034: 6850         	ldr	r0, [r2, #0x4]
700a5036: 6c12         	ldr	r2, [r2, #0x40]
700a5038: f7f5 ebce    	blx	0x7009a7d8 <__aeabi_memcpy8> @ imm = #-0xa864
;         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
700a503c: 9905         	ldr	r1, [sp, #0x14]
700a503e: 6848         	ldr	r0, [r1, #0x4]
700a5040: 6c0a         	ldr	r2, [r1, #0x40]
700a5042: 4410         	add	r0, r2
700a5044: 6048         	str	r0, [r1, #0x4]
;         if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
700a5046: 9905         	ldr	r1, [sp, #0x14]
700a5048: 6848         	ldr	r0, [r1, #0x4]
700a504a: 6889         	ldr	r1, [r1, #0x8]
700a504c: 4288         	cmp	r0, r1
700a504e: d304         	blo	0x700a505a <prvCopyDataToQueue+0x6a> @ imm = #0x8
700a5050: e7ff         	b	0x700a5052 <prvCopyDataToQueue+0x62> @ imm = #-0x2
;             pxQueue->pcWriteTo = pxQueue->pcHead;
700a5052: 9905         	ldr	r1, [sp, #0x14]
700a5054: 6808         	ldr	r0, [r1]
700a5056: 6048         	str	r0, [r1, #0x4]
;         }
700a5058: e000         	b	0x700a505c <prvCopyDataToQueue+0x6c> @ imm = #0x0
700a505a: e7ff         	b	0x700a505c <prvCopyDataToQueue+0x6c> @ imm = #-0x2
;     }
700a505c: e026         	b	0x700a50ac <prvCopyDataToQueue+0xbc> @ imm = #0x4c
;         ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
700a505e: 9a05         	ldr	r2, [sp, #0x14]
700a5060: 9904         	ldr	r1, [sp, #0x10]
700a5062: 68d0         	ldr	r0, [r2, #0xc]
700a5064: 6c12         	ldr	r2, [r2, #0x40]
700a5066: f7f5 ebb8    	blx	0x7009a7d8 <__aeabi_memcpy8> @ imm = #-0xa890
;         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
700a506a: 9905         	ldr	r1, [sp, #0x14]
700a506c: 68c8         	ldr	r0, [r1, #0xc]
700a506e: 6c0a         	ldr	r2, [r1, #0x40]
700a5070: 1a80         	subs	r0, r0, r2
700a5072: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
700a5074: 9805         	ldr	r0, [sp, #0x14]
700a5076: 6801         	ldr	r1, [r0]
700a5078: 68c0         	ldr	r0, [r0, #0xc]
700a507a: 4288         	cmp	r0, r1
700a507c: d206         	bhs	0x700a508c <prvCopyDataToQueue+0x9c> @ imm = #0xc
700a507e: e7ff         	b	0x700a5080 <prvCopyDataToQueue+0x90> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
700a5080: 9905         	ldr	r1, [sp, #0x14]
700a5082: 6888         	ldr	r0, [r1, #0x8]
700a5084: 6c0a         	ldr	r2, [r1, #0x40]
700a5086: 1a80         	subs	r0, r0, r2
700a5088: 60c8         	str	r0, [r1, #0xc]
;         }
700a508a: e000         	b	0x700a508e <prvCopyDataToQueue+0x9e> @ imm = #0x0
700a508c: e7ff         	b	0x700a508e <prvCopyDataToQueue+0x9e> @ imm = #-0x2
;         if( xPosition == queueOVERWRITE )
700a508e: 9803         	ldr	r0, [sp, #0xc]
700a5090: 2802         	cmp	r0, #0x2
700a5092: d109         	bne	0x700a50a8 <prvCopyDataToQueue+0xb8> @ imm = #0x12
700a5094: e7ff         	b	0x700a5096 <prvCopyDataToQueue+0xa6> @ imm = #-0x2
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a5096: 9801         	ldr	r0, [sp, #0x4]
700a5098: b120         	cbz	r0, 0x700a50a4 <prvCopyDataToQueue+0xb4> @ imm = #0x8
700a509a: e7ff         	b	0x700a509c <prvCopyDataToQueue+0xac> @ imm = #-0x2
;                 --uxMessagesWaiting;
700a509c: 9801         	ldr	r0, [sp, #0x4]
700a509e: 3801         	subs	r0, #0x1
700a50a0: 9001         	str	r0, [sp, #0x4]
;             }
700a50a2: e000         	b	0x700a50a6 <prvCopyDataToQueue+0xb6> @ imm = #0x0
700a50a4: e7ff         	b	0x700a50a6 <prvCopyDataToQueue+0xb6> @ imm = #-0x2
;         }
700a50a6: e000         	b	0x700a50aa <prvCopyDataToQueue+0xba> @ imm = #0x0
700a50a8: e7ff         	b	0x700a50aa <prvCopyDataToQueue+0xba> @ imm = #-0x2
700a50aa: e7ff         	b	0x700a50ac <prvCopyDataToQueue+0xbc> @ imm = #-0x2
700a50ac: e7ff         	b	0x700a50ae <prvCopyDataToQueue+0xbe> @ imm = #-0x2
;     pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
700a50ae: 9801         	ldr	r0, [sp, #0x4]
700a50b0: 3001         	adds	r0, #0x1
700a50b2: 9905         	ldr	r1, [sp, #0x14]
700a50b4: 6388         	str	r0, [r1, #0x38]
;     return xReturn;
700a50b6: 9802         	ldr	r0, [sp, #0x8]
700a50b8: b006         	add	sp, #0x18
700a50ba: bd80         	pop	{r7, pc}
700a50bc: 0000         	movs	r0, r0
700a50be: 0000         	movs	r0, r0

700a50c0 <CSL_bcdmaChanOpSetBurstSize>:
; {
700a50c0: b580         	push	{r7, lr}
700a50c2: b088         	sub	sp, #0x20
700a50c4: 9007         	str	r0, [sp, #0x1c]
700a50c6: 9106         	str	r1, [sp, #0x18]
700a50c8: 9205         	str	r2, [sp, #0x14]
700a50ca: 9304         	str	r3, [sp, #0x10]
700a50cc: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a50ce: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a50d0: 9804         	ldr	r0, [sp, #0x10]
700a50d2: b920         	cbnz	r0, 0x700a50de <CSL_bcdmaChanOpSetBurstSize+0x1e> @ imm = #0x8
700a50d4: e7ff         	b	0x700a50d6 <CSL_bcdmaChanOpSetBurstSize+0x16> @ imm = #-0x2
700a50d6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a50da: 9003         	str	r0, [sp, #0xc]
;     }
700a50dc: e052         	b	0x700a5184 <CSL_bcdmaChanOpSetBurstSize+0xc4> @ imm = #0xa4
;         CSL_BcdmaChanBurstSize burstSize = *(CSL_BcdmaChanBurstSize *)pOpData;
700a50de: 9804         	ldr	r0, [sp, #0x10]
700a50e0: 6800         	ldr	r0, [r0]
700a50e2: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a50e4: 9806         	ldr	r0, [sp, #0x18]
700a50e6: 9001         	str	r0, [sp, #0x4]
700a50e8: b140         	cbz	r0, 0x700a50fc <CSL_bcdmaChanOpSetBurstSize+0x3c> @ imm = #0x10
700a50ea: e7ff         	b	0x700a50ec <CSL_bcdmaChanOpSetBurstSize+0x2c> @ imm = #-0x2
700a50ec: 9801         	ldr	r0, [sp, #0x4]
700a50ee: 2801         	cmp	r0, #0x1
700a50f0: d019         	beq	0x700a5126 <CSL_bcdmaChanOpSetBurstSize+0x66> @ imm = #0x32
700a50f2: e7ff         	b	0x700a50f4 <CSL_bcdmaChanOpSetBurstSize+0x34> @ imm = #-0x2
700a50f4: 9801         	ldr	r0, [sp, #0x4]
700a50f6: 2802         	cmp	r0, #0x2
700a50f8: d02a         	beq	0x700a5150 <CSL_bcdmaChanOpSetBurstSize+0x90> @ imm = #0x54
700a50fa: e03e         	b	0x700a517a <CSL_bcdmaChanOpSetBurstSize+0xba> @ imm = #0x7c
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES )   /* Block-copy supports 32, 64, and 128-byte bursts */
700a50fc: 9802         	ldr	r0, [sp, #0x8]
700a50fe: 2803         	cmp	r0, #0x3
700a5100: d304         	blo	0x700a510c <CSL_bcdmaChanOpSetBurstSize+0x4c> @ imm = #0x8
700a5102: e7ff         	b	0x700a5104 <CSL_bcdmaChanOpSetBurstSize+0x44> @ imm = #-0x2
700a5104: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a5108: 9003         	str	r0, [sp, #0xc]
;                 }
700a510a: e00b         	b	0x700a5124 <CSL_bcdmaChanOpSetBurstSize+0x64> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG, BCDMA_BCCFG_CHAN_CFG_BURST_SIZE, burstSize );
700a510c: 9807         	ldr	r0, [sp, #0x1c]
700a510e: 6840         	ldr	r0, [r0, #0x4]
700a5110: 9905         	ldr	r1, [sp, #0x14]
700a5112: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a5116: 9b02         	ldr	r3, [sp, #0x8]
700a5118: f44f 6140    	mov.w	r1, #0xc00
700a511c: 220a         	movs	r2, #0xa
700a511e: f007 fadf    	bl	0x700ac6e0 <CSL_REG32_FINS_RAW> @ imm = #0x75be
700a5122: e7ff         	b	0x700a5124 <CSL_bcdmaChanOpSetBurstSize+0x64> @ imm = #-0x2
;                 break;
700a5124: e02d         	b	0x700a5182 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x5a
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES )    /* Split-tx supports 32, and 64-byte bursts */
700a5126: 9802         	ldr	r0, [sp, #0x8]
700a5128: 2802         	cmp	r0, #0x2
700a512a: d304         	blo	0x700a5136 <CSL_bcdmaChanOpSetBurstSize+0x76> @ imm = #0x8
700a512c: e7ff         	b	0x700a512e <CSL_bcdmaChanOpSetBurstSize+0x6e> @ imm = #-0x2
700a512e: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a5132: 9003         	str	r0, [sp, #0xc]
;                 }
700a5134: e00b         	b	0x700a514e <CSL_bcdmaChanOpSetBurstSize+0x8e> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG, BCDMA_TXCCFG_CHAN_TCFG_BURST_SIZE, burstSize );
700a5136: 9807         	ldr	r0, [sp, #0x1c]
700a5138: 68c0         	ldr	r0, [r0, #0xc]
700a513a: 9905         	ldr	r1, [sp, #0x14]
700a513c: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a5140: 9b02         	ldr	r3, [sp, #0x8]
700a5142: f44f 6140    	mov.w	r1, #0xc00
700a5146: 220a         	movs	r2, #0xa
700a5148: f007 faca    	bl	0x700ac6e0 <CSL_REG32_FINS_RAW> @ imm = #0x7594
700a514c: e7ff         	b	0x700a514e <CSL_bcdmaChanOpSetBurstSize+0x8e> @ imm = #-0x2
;                 break;
700a514e: e018         	b	0x700a5182 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x30
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES )    /* Split-rx supports 32, and 64-byte bursts */
700a5150: 9802         	ldr	r0, [sp, #0x8]
700a5152: 2802         	cmp	r0, #0x2
700a5154: d304         	blo	0x700a5160 <CSL_bcdmaChanOpSetBurstSize+0xa0> @ imm = #0x8
700a5156: e7ff         	b	0x700a5158 <CSL_bcdmaChanOpSetBurstSize+0x98> @ imm = #-0x2
700a5158: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a515c: 9003         	str	r0, [sp, #0xc]
;                 }
700a515e: e00b         	b	0x700a5178 <CSL_bcdmaChanOpSetBurstSize+0xb8> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG, BCDMA_RXCCFG_CHAN_RCFG_BURST_SIZE, burstSize );
700a5160: 9807         	ldr	r0, [sp, #0x1c]
700a5162: 6940         	ldr	r0, [r0, #0x14]
700a5164: 9905         	ldr	r1, [sp, #0x14]
700a5166: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a516a: 9b02         	ldr	r3, [sp, #0x8]
700a516c: f44f 6140    	mov.w	r1, #0xc00
700a5170: 220a         	movs	r2, #0xa
700a5172: f007 fab5    	bl	0x700ac6e0 <CSL_REG32_FINS_RAW> @ imm = #0x756a
700a5176: e7ff         	b	0x700a5178 <CSL_bcdmaChanOpSetBurstSize+0xb8> @ imm = #-0x2
;                 break;
700a5178: e003         	b	0x700a5182 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x6
700a517a: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a517e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a5180: e7ff         	b	0x700a5182 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #-0x2
700a5182: e7ff         	b	0x700a5184 <CSL_bcdmaChanOpSetBurstSize+0xc4> @ imm = #-0x2
;     return retVal;
700a5184: 9803         	ldr	r0, [sp, #0xc]
700a5186: b008         	add	sp, #0x20
700a5188: bd80         	pop	{r7, pc}
700a518a: 0000         	movs	r0, r0
700a518c: 0000         	movs	r0, r0
700a518e: 0000         	movs	r0, r0

700a5190 <Udma_ringCheckParams>:
; {
700a5190: b580         	push	{r7, lr}
700a5192: b084         	sub	sp, #0x10
700a5194: 9003         	str	r0, [sp, #0xc]
700a5196: 9102         	str	r1, [sp, #0x8]
700a5198: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a519a: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR == ringPrms->ringMem)
700a519c: 9802         	ldr	r0, [sp, #0x8]
700a519e: 6800         	ldr	r0, [r0]
700a51a0: b920         	cbnz	r0, 0x700a51ac <Udma_ringCheckParams+0x1c> @ imm = #0x8
700a51a2: e7ff         	b	0x700a51a4 <Udma_ringCheckParams+0x14> @ imm = #-0x2
700a51a4: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a51a8: 9001         	str	r0, [sp, #0x4]
;     }
700a51aa: e009         	b	0x700a51c0 <Udma_ringCheckParams+0x30> @ imm = #0x12
;         if(((uintptr_t)ringPrms->ringMem & (UDMA_CACHELINE_ALIGNMENT - 1U)) != 0U)
700a51ac: 9802         	ldr	r0, [sp, #0x8]
700a51ae: 7800         	ldrb	r0, [r0]
700a51b0: 0640         	lsls	r0, r0, #0x19
700a51b2: b120         	cbz	r0, 0x700a51be <Udma_ringCheckParams+0x2e> @ imm = #0x8
700a51b4: e7ff         	b	0x700a51b6 <Udma_ringCheckParams+0x26> @ imm = #-0x2
700a51b6: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a51ba: 9001         	str	r0, [sp, #0x4]
;         }
700a51bc: e7ff         	b	0x700a51be <Udma_ringCheckParams+0x2e> @ imm = #-0x2
700a51be: e7ff         	b	0x700a51c0 <Udma_ringCheckParams+0x30> @ imm = #-0x2
;     if(0U == ringPrms->elemCnt)
700a51c0: 9802         	ldr	r0, [sp, #0x8]
700a51c2: 68c0         	ldr	r0, [r0, #0xc]
700a51c4: b920         	cbnz	r0, 0x700a51d0 <Udma_ringCheckParams+0x40> @ imm = #0x8
700a51c6: e7ff         	b	0x700a51c8 <Udma_ringCheckParams+0x38> @ imm = #-0x2
700a51c8: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a51cc: 9001         	str	r0, [sp, #0x4]
;     }
700a51ce: e7ff         	b	0x700a51d0 <Udma_ringCheckParams+0x40> @ imm = #-0x2
;     if(UDMA_INST_TYPE_NORMAL != drvHandle->instType)
700a51d0: 9803         	ldr	r0, [sp, #0xc]
700a51d2: 6800         	ldr	r0, [r0]
700a51d4: b148         	cbz	r0, 0x700a51ea <Udma_ringCheckParams+0x5a> @ imm = #0x12
700a51d6: e7ff         	b	0x700a51d8 <Udma_ringCheckParams+0x48> @ imm = #-0x2
;         if(TISCI_MSG_VALUE_RM_RING_MODE_RING != ringPrms->mode)
700a51d8: 9802         	ldr	r0, [sp, #0x8]
700a51da: 7a00         	ldrb	r0, [r0, #0x8]
700a51dc: b120         	cbz	r0, 0x700a51e8 <Udma_ringCheckParams+0x58> @ imm = #0x8
700a51de: e7ff         	b	0x700a51e0 <Udma_ringCheckParams+0x50> @ imm = #-0x2
700a51e0: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a51e4: 9001         	str	r0, [sp, #0x4]
;         }
700a51e6: e7ff         	b	0x700a51e8 <Udma_ringCheckParams+0x58> @ imm = #-0x2
;     }
700a51e8: e7ff         	b	0x700a51ea <Udma_ringCheckParams+0x5a> @ imm = #-0x2
;     if(UDMA_RING_SIZE_CHECK_SKIP != ringPrms->ringMemSize)
700a51ea: 9802         	ldr	r0, [sp, #0x8]
700a51ec: 6840         	ldr	r0, [r0, #0x4]
700a51ee: f64a 31cd    	movw	r1, #0xabcd
700a51f2: f6ca 31dc    	movt	r1, #0xabdc
700a51f6: 4288         	cmp	r0, r1
700a51f8: d012         	beq	0x700a5220 <Udma_ringCheckParams+0x90> @ imm = #0x24
700a51fa: e7ff         	b	0x700a51fc <Udma_ringCheckParams+0x6c> @ imm = #-0x2
;                           ringPrms->mode,
700a51fc: 9a02         	ldr	r2, [sp, #0x8]
700a51fe: 7a10         	ldrb	r0, [r2, #0x8]
;                           ringPrms->elemCnt,
700a5200: 68d1         	ldr	r1, [r2, #0xc]
;                           ringPrms->elemSize);
700a5202: 7c12         	ldrb	r2, [r2, #0x10]
;         ringMemSize = UdmaUtils_getRingMemSize(
700a5204: f006 fe7c    	bl	0x700abf00 <UdmaUtils_getRingMemSize> @ imm = #0x6cf8
700a5208: 9000         	str	r0, [sp]
;         if(ringPrms->ringMemSize < ringMemSize)
700a520a: 9802         	ldr	r0, [sp, #0x8]
700a520c: 6840         	ldr	r0, [r0, #0x4]
700a520e: 9900         	ldr	r1, [sp]
700a5210: 4288         	cmp	r0, r1
700a5212: d204         	bhs	0x700a521e <Udma_ringCheckParams+0x8e> @ imm = #0x8
700a5214: e7ff         	b	0x700a5216 <Udma_ringCheckParams+0x86> @ imm = #-0x2
700a5216: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
700a521a: 9001         	str	r0, [sp, #0x4]
;         }
700a521c: e7ff         	b	0x700a521e <Udma_ringCheckParams+0x8e> @ imm = #-0x2
;     }
700a521e: e7ff         	b	0x700a5220 <Udma_ringCheckParams+0x90> @ imm = #-0x2
;     if (UDMA_RING_ORDERID_MAX < ringPrms->orderId)
700a5220: 9802         	ldr	r0, [sp, #0x8]
700a5222: 7c40         	ldrb	r0, [r0, #0x11]
700a5224: 2810         	cmp	r0, #0x10
700a5226: d304         	blo	0x700a5232 <Udma_ringCheckParams+0xa2> @ imm = #0x8
700a5228: e7ff         	b	0x700a522a <Udma_ringCheckParams+0x9a> @ imm = #-0x2
700a522a: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a522e: 9001         	str	r0, [sp, #0x4]
;     }
700a5230: e7ff         	b	0x700a5232 <Udma_ringCheckParams+0xa2> @ imm = #-0x2
;     if((UDMA_MAPPED_GROUP_INVALID != ringPrms->mappedRingGrp) &&
700a5232: 9802         	ldr	r0, [sp, #0x8]
700a5234: 6940         	ldr	r0, [r0, #0x14]
700a5236: 2104         	movs	r1, #0x4
700a5238: f6cf 71ff    	movt	r1, #0xffff
700a523c: 4288         	cmp	r0, r1
700a523e: d009         	beq	0x700a5254 <Udma_ringCheckParams+0xc4> @ imm = #0x12
700a5240: e7ff         	b	0x700a5242 <Udma_ringCheckParams+0xb2> @ imm = #-0x2
;        (ringPrms->mappedRingGrp >= (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
700a5242: 9802         	ldr	r0, [sp, #0x8]
700a5244: 6940         	ldr	r0, [r0, #0x14]
;     if((UDMA_MAPPED_GROUP_INVALID != ringPrms->mappedRingGrp) &&
700a5246: 2808         	cmp	r0, #0x8
700a5248: d304         	blo	0x700a5254 <Udma_ringCheckParams+0xc4> @ imm = #0x8
700a524a: e7ff         	b	0x700a524c <Udma_ringCheckParams+0xbc> @ imm = #-0x2
700a524c: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a5250: 9001         	str	r0, [sp, #0x4]
;     }
700a5252: e7ff         	b	0x700a5254 <Udma_ringCheckParams+0xc4> @ imm = #-0x2
;     return (retVal);
700a5254: 9801         	ldr	r0, [sp, #0x4]
700a5256: b004         	add	sp, #0x10
700a5258: bd80         	pop	{r7, pc}
700a525a: 0000         	movs	r0, r0
700a525c: 0000         	movs	r0, r0
700a525e: 0000         	movs	r0, r0

700a5260 <UART_lld_writeDma>:
; {
700a5260: b580         	push	{r7, lr}
700a5262: b086         	sub	sp, #0x18
700a5264: 9005         	str	r0, [sp, #0x14]
700a5266: 9104         	str	r1, [sp, #0x10]
700a5268: 9203         	str	r2, [sp, #0xc]
700a526a: 9302         	str	r3, [sp, #0x8]
700a526c: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a526e: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a5270: 9805         	ldr	r0, [sp, #0x14]
700a5272: 2800         	cmp	r0, #0x0
700a5274: d051         	beq	0x700a531a <UART_lld_writeDma+0xba> @ imm = #0xa2
700a5276: e7ff         	b	0x700a5278 <UART_lld_writeDma+0x18> @ imm = #-0x2
;         trans = &hUart->writeTrans;
700a5278: 9805         	ldr	r0, [sp, #0x14]
700a527a: 303c         	adds	r0, #0x3c
700a527c: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a527e: 9800         	ldr	r0, [sp]
700a5280: 6800         	ldr	r0, [r0]
700a5282: b138         	cbz	r0, 0x700a5294 <UART_lld_writeDma+0x34> @ imm = #0xe
700a5284: e7ff         	b	0x700a5286 <UART_lld_writeDma+0x26> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a5286: 9900         	ldr	r1, [sp]
700a5288: 2009         	movs	r0, #0x9
700a528a: 60c8         	str	r0, [r1, #0xc]
700a528c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a5290: 9001         	str	r0, [sp, #0x4]
;         }
700a5292: e041         	b	0x700a5318 <UART_lld_writeDma+0xb8> @ imm = #0x82
;             UART_lld_Transaction_init(trans);
700a5294: 9800         	ldr	r0, [sp]
700a5296: f007 ffdb    	bl	0x700ad250 <UART_lld_Transaction_init> @ imm = #0x7fb6
;             if(extendedParams != NULL)
700a529a: 9802         	ldr	r0, [sp, #0x8]
700a529c: b128         	cbz	r0, 0x700a52aa <UART_lld_writeDma+0x4a> @ imm = #0xa
700a529e: e7ff         	b	0x700a52a0 <UART_lld_writeDma+0x40> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a52a0: 9802         	ldr	r0, [sp, #0x8]
700a52a2: 6800         	ldr	r0, [r0]
700a52a4: 9900         	ldr	r1, [sp]
700a52a6: 6108         	str	r0, [r1, #0x10]
;             }
700a52a8: e003         	b	0x700a52b2 <UART_lld_writeDma+0x52> @ imm = #0x6
;                 trans->args = NULL;
700a52aa: 9900         	ldr	r1, [sp]
700a52ac: 2000         	movs	r0, #0x0
700a52ae: 6108         	str	r0, [r1, #0x10]
700a52b0: e7ff         	b	0x700a52b2 <UART_lld_writeDma+0x52> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a52b2: 9804         	ldr	r0, [sp, #0x10]
700a52b4: 9900         	ldr	r1, [sp]
700a52b6: 6008         	str	r0, [r1]
;             trans->count = size;
700a52b8: 9803         	ldr	r0, [sp, #0xc]
700a52ba: 9900         	ldr	r1, [sp]
700a52bc: 6048         	str	r0, [r1, #0x4]
;             if(hUart->state == UART_STATE_READY)
700a52be: 9805         	ldr	r0, [sp, #0x14]
700a52c0: 6d40         	ldr	r0, [r0, #0x54]
700a52c2: 2801         	cmp	r0, #0x1
700a52c4: d105         	bne	0x700a52d2 <UART_lld_writeDma+0x72> @ imm = #0xa
700a52c6: e7ff         	b	0x700a52c8 <UART_lld_writeDma+0x68> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a52c8: 9800         	ldr	r0, [sp]
700a52ca: f007 fb89    	bl	0x700ac9e0 <UART_checkTransaction> @ imm = #0x7712
700a52ce: 9001         	str	r0, [sp, #0x4]
;             }
700a52d0: e003         	b	0x700a52da <UART_lld_writeDma+0x7a> @ imm = #0x6
700a52d2: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a52d6: 9001         	str	r0, [sp, #0x4]
700a52d8: e7ff         	b	0x700a52da <UART_lld_writeDma+0x7a> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a52da: 9801         	ldr	r0, [sp, #0x4]
700a52dc: b9d8         	cbnz	r0, 0x700a5316 <UART_lld_writeDma+0xb6> @ imm = #0x36
700a52de: e7ff         	b	0x700a52e0 <UART_lld_writeDma+0x80> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a52e0: 9800         	ldr	r0, [sp]
700a52e2: 6800         	ldr	r0, [r0]
700a52e4: 9905         	ldr	r1, [sp, #0x14]
700a52e6: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a52e8: 9800         	ldr	r0, [sp]
700a52ea: 6880         	ldr	r0, [r0, #0x8]
700a52ec: 9905         	ldr	r1, [sp, #0x14]
700a52ee: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a52f0: 9905         	ldr	r1, [sp, #0x14]
700a52f2: 2000         	movs	r0, #0x0
700a52f4: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a52f6: 9800         	ldr	r0, [sp]
700a52f8: 6840         	ldr	r0, [r0, #0x4]
700a52fa: 9905         	ldr	r1, [sp, #0x14]
700a52fc: 6108         	str	r0, [r1, #0x10]
;                 hUart->state = UART_STATE_BUSY;
700a52fe: 9905         	ldr	r1, [sp, #0x14]
700a5300: 2002         	movs	r0, #0x2
700a5302: 6548         	str	r0, [r1, #0x54]
;                 status = UART_lld_dmaWrite(hUart, trans);
700a5304: 9805         	ldr	r0, [sp, #0x14]
700a5306: 9900         	ldr	r1, [sp]
700a5308: f007 ffba    	bl	0x700ad280 <UART_lld_dmaWrite> @ imm = #0x7f74
700a530c: 9001         	str	r0, [sp, #0x4]
;                 hUart->state = UART_STATE_READY;
700a530e: 9905         	ldr	r1, [sp, #0x14]
700a5310: 2001         	movs	r0, #0x1
700a5312: 6548         	str	r0, [r1, #0x54]
;             }
700a5314: e7ff         	b	0x700a5316 <UART_lld_writeDma+0xb6> @ imm = #-0x2
700a5316: e7ff         	b	0x700a5318 <UART_lld_writeDma+0xb8> @ imm = #-0x2
;     }
700a5318: e003         	b	0x700a5322 <UART_lld_writeDma+0xc2> @ imm = #0x6
700a531a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a531e: 9001         	str	r0, [sp, #0x4]
700a5320: e7ff         	b	0x700a5322 <UART_lld_writeDma+0xc2> @ imm = #-0x2
;     return status;
700a5322: 9801         	ldr	r0, [sp, #0x4]
700a5324: b006         	add	sp, #0x18
700a5326: bd80         	pop	{r7, pc}
		...

700a5330 <UART_udmaHpdInit>:
; {
700a5330: b580         	push	{r7, lr}
700a5332: b08a         	sub	sp, #0x28
700a5334: 9009         	str	r0, [sp, #0x24]
700a5336: 9108         	str	r1, [sp, #0x20]
700a5338: 9207         	str	r2, [sp, #0x1c]
700a533a: 9306         	str	r3, [sp, #0x18]
;     CSL_UdmapCppi5HMPD *pHpd = (CSL_UdmapCppi5HMPD *) pHpdMem;
700a533c: 9808         	ldr	r0, [sp, #0x20]
700a533e: 9005         	str	r0, [sp, #0x14]
700a5340: 2001         	movs	r0, #0x1
;     uint32_t descType = (uint32_t)CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST;
700a5342: 9004         	str	r0, [sp, #0x10]
;     CSL_udmapCppi5SetDescType(pHpd, descType);
700a5344: 9805         	ldr	r0, [sp, #0x14]
700a5346: 9904         	ldr	r1, [sp, #0x10]
700a5348: f008 fbb2    	bl	0x700adab0 <CSL_udmapCppi5SetDescType> @ imm = #0x8764
;     CSL_udmapCppi5SetEpiDataPresent(pHpd, FALSE);
700a534c: 9805         	ldr	r0, [sp, #0x14]
700a534e: 2100         	movs	r1, #0x0
700a5350: 9102         	str	r1, [sp, #0x8]
700a5352: f008 fa8d    	bl	0x700ad870 <CSL_udmapCppi5SetEpiDataPresent> @ imm = #0x851a
700a5356: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsDataLoc(pHpd, 0U);
700a5358: 9805         	ldr	r0, [sp, #0x14]
700a535a: f008 fcb1    	bl	0x700adcc0 <CSL_udmapCppi5SetPsDataLoc> @ imm = #0x8962
700a535e: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsDataLen(pHpd, 0U);
700a5360: 9805         	ldr	r0, [sp, #0x14]
700a5362: f008 fbd5    	bl	0x700adb10 <CSL_udmapCppi5SetPsDataLen> @ imm = #0x87aa
;     CSL_udmapCppi5SetPktLen(pHpd, descType, length);
700a5366: 9805         	ldr	r0, [sp, #0x14]
700a5368: 9904         	ldr	r1, [sp, #0x10]
700a536a: 9a06         	ldr	r2, [sp, #0x18]
700a536c: f006 fd50    	bl	0x700abe10 <CSL_udmapCppi5SetPktLen> @ imm = #0x6aa0
700a5370: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsFlags(pHpd, 0U);
700a5372: 9805         	ldr	r0, [sp, #0x14]
700a5374: f008 fcb4    	bl	0x700adce0 <CSL_udmapCppi5SetPsFlags> @ imm = #0x8968
;     CSL_udmapCppi5SetIds(pHpd, descType, 0x321, UDMA_DEFAULT_FLOW_ID);
700a5378: 9805         	ldr	r0, [sp, #0x14]
700a537a: 9904         	ldr	r1, [sp, #0x10]
700a537c: f240 3221    	movw	r2, #0x321
700a5380: f643 73ff    	movw	r3, #0x3fff
700a5384: f004 fd94    	bl	0x700a9eb0 <CSL_udmapCppi5SetIds> @ imm = #0x4b28
700a5388: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetSrcTag(pHpd, 0x0000);     /* Not used */
700a538a: 9805         	ldr	r0, [sp, #0x14]
700a538c: f008 fd68    	bl	0x700ade60 <CSL_udmapCppi5SetSrcTag> @ imm = #0x8ad0
700a5390: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetDstTag(pHpd, 0x0000);     /* Not used */
700a5392: 9805         	ldr	r0, [sp, #0x14]
700a5394: f008 fdfc    	bl	0x700adf90 <CSL_udmapCppi5SetDstTag> @ imm = #0x8bf8
;     UART_udmapSetReturnPolicy(chHandle, pHpdMem);
700a5398: 9809         	ldr	r0, [sp, #0x24]
700a539a: 9908         	ldr	r1, [sp, #0x20]
700a539c: f008 f830    	bl	0x700ad400 <UART_udmapSetReturnPolicy> @ imm = #0x8060
700a53a0: 9b02         	ldr	r3, [sp, #0x8]
;     CSL_udmapCppi5LinkDesc(pHpd, 0U);
700a53a2: 9805         	ldr	r0, [sp, #0x14]
700a53a4: 461a         	mov	r2, r3
700a53a6: f008 fc4b    	bl	0x700adc40 <CSL_udmapCppi5LinkDesc> @ imm = #0x8896
700a53aa: 9a02         	ldr	r2, [sp, #0x8]
;     CSL_udmapCppi5SetBufferAddr(pHpd, (uint64_t) Udma_defaultVirtToPhyFxn(destBuf, 0U, NULL));
700a53ac: 9805         	ldr	r0, [sp, #0x14]
700a53ae: 9001         	str	r0, [sp, #0x4]
700a53b0: 9807         	ldr	r0, [sp, #0x1c]
700a53b2: 4611         	mov	r1, r2
700a53b4: f008 fe24    	bl	0x700ae000 <Udma_defaultVirtToPhyFxn> @ imm = #0x8c48
700a53b8: 4602         	mov	r2, r0
700a53ba: 9801         	ldr	r0, [sp, #0x4]
700a53bc: 460b         	mov	r3, r1
700a53be: f008 fc4f    	bl	0x700adc60 <CSL_udmapCppi5SetBufferAddr> @ imm = #0x889e
;     CSL_udmapCppi5SetBufferLen(pHpd, length);
700a53c2: 9805         	ldr	r0, [sp, #0x14]
700a53c4: 9906         	ldr	r1, [sp, #0x18]
700a53c6: f008 fc5b    	bl	0x700adc80 <CSL_udmapCppi5SetBufferLen> @ imm = #0x88b6
700a53ca: 9a02         	ldr	r2, [sp, #0x8]
;     CSL_udmapCppi5SetOrgBufferAddr(pHpd, (uint64_t) Udma_defaultVirtToPhyFxn(destBuf, 0U, NULL));
700a53cc: 9805         	ldr	r0, [sp, #0x14]
700a53ce: 9003         	str	r0, [sp, #0xc]
700a53d0: 9807         	ldr	r0, [sp, #0x1c]
700a53d2: 4611         	mov	r1, r2
700a53d4: f008 fe14    	bl	0x700ae000 <Udma_defaultVirtToPhyFxn> @ imm = #0x8c28
700a53d8: 4602         	mov	r2, r0
700a53da: 9803         	ldr	r0, [sp, #0xc]
700a53dc: 460b         	mov	r3, r1
700a53de: f008 fc5f    	bl	0x700adca0 <CSL_udmapCppi5SetOrgBufferAddr> @ imm = #0x88be
;     CSL_udmapCppi5SetOrgBufferLen(pHpd, length);
700a53e2: 9805         	ldr	r0, [sp, #0x14]
700a53e4: 9906         	ldr	r1, [sp, #0x18]
700a53e6: f008 fddb    	bl	0x700adfa0 <CSL_udmapCppi5SetOrgBufferLen> @ imm = #0x8bb6
;     CacheP_wb(pHpdMem, sizeof(CSL_UdmapCppi5HMPD), CacheP_TYPE_ALLD);
700a53ea: 9808         	ldr	r0, [sp, #0x20]
700a53ec: 2130         	movs	r1, #0x30
700a53ee: 220a         	movs	r2, #0xa
700a53f0: f009 edc0    	blx	0x700aef74 <CacheP_wb>  @ imm = #0x9b80
;     return;
700a53f4: b00a         	add	sp, #0x28
700a53f6: bd80         	pop	{r7, pc}
		...

700a5400 <Udma_eventCheckUnRegister>:
; {
700a5400: b580         	push	{r7, lr}
700a5402: b088         	sub	sp, #0x20
700a5404: 9007         	str	r0, [sp, #0x1c]
700a5406: 9106         	str	r1, [sp, #0x18]
700a5408: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a540a: 9005         	str	r0, [sp, #0x14]
;     eventPrms = &eventHandle->eventPrms;
700a540c: 9806         	ldr	r0, [sp, #0x18]
700a540e: 3008         	adds	r0, #0x8
700a5410: 9004         	str	r0, [sp, #0x10]
;     if(eventHandle->eventInitDone != UDMA_INIT_DONE)
700a5412: 9806         	ldr	r0, [sp, #0x18]
700a5414: f8d0 0098    	ldr.w	r0, [r0, #0x98]
700a5418: f64a 31cd    	movw	r1, #0xabcd
700a541c: f6ca 31dc    	movt	r1, #0xabdc
700a5420: 4288         	cmp	r0, r1
700a5422: d004         	beq	0x700a542e <Udma_eventCheckUnRegister+0x2e> @ imm = #0x8
700a5424: e7ff         	b	0x700a5426 <Udma_eventCheckUnRegister+0x26> @ imm = #-0x2
700a5426: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = UDMA_EFAIL;
700a542a: 9005         	str	r0, [sp, #0x14]
;     }
700a542c: e7ff         	b	0x700a542e <Udma_eventCheckUnRegister+0x2e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a542e: 9805         	ldr	r0, [sp, #0x14]
700a5430: b968         	cbnz	r0, 0x700a544e <Udma_eventCheckUnRegister+0x4e> @ imm = #0x1a
700a5432: e7ff         	b	0x700a5434 <Udma_eventCheckUnRegister+0x34> @ imm = #-0x2
;         if((NULL_PTR == eventPrms->controllerEventHandle) &&
700a5434: 9804         	ldr	r0, [sp, #0x10]
700a5436: 6900         	ldr	r0, [r0, #0x10]
700a5438: b940         	cbnz	r0, 0x700a544c <Udma_eventCheckUnRegister+0x4c> @ imm = #0x10
700a543a: e7ff         	b	0x700a543c <Udma_eventCheckUnRegister+0x3c> @ imm = #-0x2
;            (NULL_PTR != eventHandle->nextEvent))
700a543c: 9806         	ldr	r0, [sp, #0x18]
700a543e: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((NULL_PTR == eventPrms->controllerEventHandle) &&
700a5440: b120         	cbz	r0, 0x700a544c <Udma_eventCheckUnRegister+0x4c> @ imm = #0x8
700a5442: e7ff         	b	0x700a5444 <Udma_eventCheckUnRegister+0x44> @ imm = #-0x2
700a5444: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a5448: 9005         	str	r0, [sp, #0x14]
;         }
700a544a: e7ff         	b	0x700a544c <Udma_eventCheckUnRegister+0x4c> @ imm = #-0x2
;     }
700a544c: e7ff         	b	0x700a544e <Udma_eventCheckUnRegister+0x4e> @ imm = #-0x2
;      if(UDMA_SOK == retVal)
700a544e: 9805         	ldr	r0, [sp, #0x14]
700a5450: bbb8         	cbnz	r0, 0x700a54c2 <Udma_eventCheckUnRegister+0xc2> @ imm = #0x6e
700a5452: e7ff         	b	0x700a5454 <Udma_eventCheckUnRegister+0x54> @ imm = #-0x2
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a5454: 9804         	ldr	r0, [sp, #0x10]
700a5456: 6800         	ldr	r0, [r0]
700a5458: 2801         	cmp	r0, #0x1
700a545a: d00a         	beq	0x700a5472 <Udma_eventCheckUnRegister+0x72> @ imm = #0x14
700a545c: e7ff         	b	0x700a545e <Udma_eventCheckUnRegister+0x5e> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType) ||
700a545e: 9804         	ldr	r0, [sp, #0x10]
700a5460: 6800         	ldr	r0, [r0]
700a5462: 2806         	cmp	r0, #0x6
700a5464: d005         	beq	0x700a5472 <Udma_eventCheckUnRegister+0x72> @ imm = #0xa
700a5466: e7ff         	b	0x700a5468 <Udma_eventCheckUnRegister+0x68> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_RING == eventPrms->eventType))
700a5468: 9804         	ldr	r0, [sp, #0x10]
700a546a: 6800         	ldr	r0, [r0]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a546c: 2804         	cmp	r0, #0x4
700a546e: d127         	bne	0x700a54c0 <Udma_eventCheckUnRegister+0xc0> @ imm = #0x4e
700a5470: e7ff         	b	0x700a5472 <Udma_eventCheckUnRegister+0x72> @ imm = #-0x2
;             if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
700a5472: 9804         	ldr	r0, [sp, #0x10]
700a5474: 6800         	ldr	r0, [r0]
700a5476: 2801         	cmp	r0, #0x1
700a5478: d005         	beq	0x700a5486 <Udma_eventCheckUnRegister+0x86> @ imm = #0xa
700a547a: e7ff         	b	0x700a547c <Udma_eventCheckUnRegister+0x7c> @ imm = #-0x2
700a547c: 9804         	ldr	r0, [sp, #0x10]
700a547e: 6800         	ldr	r0, [r0]
700a5480: 2806         	cmp	r0, #0x6
700a5482: d106         	bne	0x700a5492 <Udma_eventCheckUnRegister+0x92> @ imm = #0xc
700a5484: e7ff         	b	0x700a5486 <Udma_eventCheckUnRegister+0x86> @ imm = #-0x2
;                 ringHandle = ((Udma_ChHandleInt) (eventPrms->chHandle))->cqRing;
700a5486: 9804         	ldr	r0, [sp, #0x10]
700a5488: 6880         	ldr	r0, [r0, #0x8]
700a548a: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a548e: 9003         	str	r0, [sp, #0xc]
;             }
700a5490: e003         	b	0x700a549a <Udma_eventCheckUnRegister+0x9a> @ imm = #0x6
;                 ringHandle = eventPrms->ringHandle;
700a5492: 9804         	ldr	r0, [sp, #0x10]
700a5494: 68c0         	ldr	r0, [r0, #0xc]
700a5496: 9003         	str	r0, [sp, #0xc]
700a5498: e7ff         	b	0x700a549a <Udma_eventCheckUnRegister+0x9a> @ imm = #-0x2
;             fOcc = Udma_ringGetForwardRingOcc(ringHandle);
700a549a: 9803         	ldr	r0, [sp, #0xc]
700a549c: f007 ffc8    	bl	0x700ad430 <Udma_ringGetForwardRingOcc> @ imm = #0x7f90
700a54a0: 9002         	str	r0, [sp, #0x8]
;             rOcc = Udma_ringGetReverseRingOcc(ringHandle);
700a54a2: 9803         	ldr	r0, [sp, #0xc]
700a54a4: f007 ffdc    	bl	0x700ad460 <Udma_ringGetReverseRingOcc> @ imm = #0x7fb8
700a54a8: 9001         	str	r0, [sp, #0x4]
;             if((0U != fOcc) || (0U != rOcc))
700a54aa: 9802         	ldr	r0, [sp, #0x8]
700a54ac: b918         	cbnz	r0, 0x700a54b6 <Udma_eventCheckUnRegister+0xb6> @ imm = #0x6
700a54ae: e7ff         	b	0x700a54b0 <Udma_eventCheckUnRegister+0xb0> @ imm = #-0x2
700a54b0: 9801         	ldr	r0, [sp, #0x4]
700a54b2: b120         	cbz	r0, 0x700a54be <Udma_eventCheckUnRegister+0xbe> @ imm = #0x8
700a54b4: e7ff         	b	0x700a54b6 <Udma_eventCheckUnRegister+0xb6> @ imm = #-0x2
700a54b6: f04f 30ff    	mov.w	r0, #0xffffffff
;                 retVal = UDMA_EFAIL;
700a54ba: 9005         	str	r0, [sp, #0x14]
;             }
700a54bc: e7ff         	b	0x700a54be <Udma_eventCheckUnRegister+0xbe> @ imm = #-0x2
;         }
700a54be: e7ff         	b	0x700a54c0 <Udma_eventCheckUnRegister+0xc0> @ imm = #-0x2
;     }
700a54c0: e7ff         	b	0x700a54c2 <Udma_eventCheckUnRegister+0xc2> @ imm = #-0x2
;     return (retVal);
700a54c2: 9805         	ldr	r0, [sp, #0x14]
700a54c4: b008         	add	sp, #0x20
700a54c6: bd80         	pop	{r7, pc}
		...

700a54d0 <Udma_ringFree>:
; {
700a54d0: b580         	push	{r7, lr}
700a54d2: b086         	sub	sp, #0x18
700a54d4: 9005         	str	r0, [sp, #0x14]
700a54d6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a54d8: 9004         	str	r0, [sp, #0x10]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a54da: 9805         	ldr	r0, [sp, #0x14]
700a54dc: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == ringHandleInt)
700a54de: 9802         	ldr	r0, [sp, #0x8]
700a54e0: b920         	cbnz	r0, 0x700a54ec <Udma_ringFree+0x1c> @ imm = #0x8
700a54e2: e7ff         	b	0x700a54e4 <Udma_ringFree+0x14> @ imm = #-0x2
700a54e4: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a54e8: 9004         	str	r0, [sp, #0x10]
;     }
700a54ea: e7ff         	b	0x700a54ec <Udma_ringFree+0x1c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a54ec: 9804         	ldr	r0, [sp, #0x10]
700a54ee: b970         	cbnz	r0, 0x700a550e <Udma_ringFree+0x3e> @ imm = #0x1c
700a54f0: e7ff         	b	0x700a54f2 <Udma_ringFree+0x22> @ imm = #-0x2
;         if(ringHandleInt->ringInitDone != UDMA_INIT_DONE)
700a54f2: 9802         	ldr	r0, [sp, #0x8]
700a54f4: 6d80         	ldr	r0, [r0, #0x58]
700a54f6: f64a 31cd    	movw	r1, #0xabcd
700a54fa: f6ca 31dc    	movt	r1, #0xabdc
700a54fe: 4288         	cmp	r0, r1
700a5500: d004         	beq	0x700a550c <Udma_ringFree+0x3c> @ imm = #0x8
700a5502: e7ff         	b	0x700a5504 <Udma_ringFree+0x34> @ imm = #-0x2
700a5504: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a5508: 9004         	str	r0, [sp, #0x10]
;         }
700a550a: e7ff         	b	0x700a550c <Udma_ringFree+0x3c> @ imm = #-0x2
;     }
700a550c: e7ff         	b	0x700a550e <Udma_ringFree+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a550e: 9804         	ldr	r0, [sp, #0x10]
700a5510: b9a8         	cbnz	r0, 0x700a553e <Udma_ringFree+0x6e> @ imm = #0x2a
700a5512: e7ff         	b	0x700a5514 <Udma_ringFree+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a5514: 9802         	ldr	r0, [sp, #0x8]
700a5516: 6800         	ldr	r0, [r0]
700a5518: 9003         	str	r0, [sp, #0xc]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a551a: 9803         	ldr	r0, [sp, #0xc]
700a551c: b150         	cbz	r0, 0x700a5534 <Udma_ringFree+0x64> @ imm = #0x14
700a551e: e7ff         	b	0x700a5520 <Udma_ringFree+0x50> @ imm = #-0x2
700a5520: 9803         	ldr	r0, [sp, #0xc]
700a5522: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a5526: f64a 31cd    	movw	r1, #0xabcd
700a552a: f6ca 31dc    	movt	r1, #0xabdc
700a552e: 4288         	cmp	r0, r1
700a5530: d004         	beq	0x700a553c <Udma_ringFree+0x6c> @ imm = #0x8
700a5532: e7ff         	b	0x700a5534 <Udma_ringFree+0x64> @ imm = #-0x2
700a5534: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a5538: 9004         	str	r0, [sp, #0x10]
;         }
700a553a: e7ff         	b	0x700a553c <Udma_ringFree+0x6c> @ imm = #-0x2
;     }
700a553c: e7ff         	b	0x700a553e <Udma_ringFree+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a553e: 9804         	ldr	r0, [sp, #0x10]
700a5540: bb38         	cbnz	r0, 0x700a5592 <Udma_ringFree+0xc2> @ imm = #0x4e
700a5542: e7ff         	b	0x700a5544 <Udma_ringFree+0x74> @ imm = #-0x2
;         if(UDMA_MAPPED_GROUP_INVALID == ringHandleInt->mappedRingGrp)
700a5544: 9802         	ldr	r0, [sp, #0x8]
700a5546: 6dc0         	ldr	r0, [r0, #0x5c]
700a5548: 2104         	movs	r1, #0x4
700a554a: f6cf 71ff    	movt	r1, #0xffff
700a554e: 4288         	cmp	r0, r1
700a5550: d106         	bne	0x700a5560 <Udma_ringFree+0x90> @ imm = #0xc
700a5552: e7ff         	b	0x700a5554 <Udma_ringFree+0x84> @ imm = #-0x2
;             Udma_rmFreeFreeRing(ringHandleInt->ringNum, drvHandle);
700a5554: 9802         	ldr	r0, [sp, #0x8]
700a5556: 8880         	ldrh	r0, [r0, #0x4]
700a5558: 9903         	ldr	r1, [sp, #0xc]
700a555a: f008 fdd1    	bl	0x700ae100 <Udma_rmFreeFreeRing> @ imm = #0x8ba2
;         }
700a555e: e007         	b	0x700a5570 <Udma_ringFree+0xa0> @ imm = #0xe
;                 ringHandleInt->ringNum,
700a5560: 9b02         	ldr	r3, [sp, #0x8]
700a5562: 8898         	ldrh	r0, [r3, #0x4]
;                 drvHandle,
700a5564: 9903         	ldr	r1, [sp, #0xc]
;                 ringHandleInt->mappedRingGrp,
700a5566: 6dda         	ldr	r2, [r3, #0x5c]
;                 ringHandleInt->mappedChNum);
700a5568: 6e1b         	ldr	r3, [r3, #0x60]
;             Udma_rmFreeMappedRing(
700a556a: f002 fe71    	bl	0x700a8250 <Udma_rmFreeMappedRing> @ imm = #0x2ce2
700a556e: e7ff         	b	0x700a5570 <Udma_ringFree+0xa0> @ imm = #-0x2
;         ringHandleInt->ringNum         = UDMA_RING_INVALID;
700a5570: 9902         	ldr	r1, [sp, #0x8]
700a5572: f64f 70ff    	movw	r0, #0xffff
700a5576: 8088         	strh	r0, [r1, #0x4]
;         ringHandleInt->ringInitDone    = UDMA_DEINIT_DONE;
700a5578: 9902         	ldr	r1, [sp, #0x8]
700a557a: 2000         	movs	r0, #0x0
700a557c: 9001         	str	r0, [sp, #0x4]
700a557e: 6588         	str	r0, [r1, #0x58]
;         drvHandle->ringHandleClearRegs(ringHandleInt);
700a5580: 9803         	ldr	r0, [sp, #0xc]
700a5582: f8d0 15c8    	ldr.w	r1, [r0, #0x5c8]
700a5586: 9802         	ldr	r0, [sp, #0x8]
700a5588: 4788         	blx	r1
700a558a: 9801         	ldr	r0, [sp, #0x4]
;         ringHandleInt->drvHandle       = (Udma_DrvHandleInt) NULL_PTR;
700a558c: 9902         	ldr	r1, [sp, #0x8]
700a558e: 6008         	str	r0, [r1]
;     }
700a5590: e7ff         	b	0x700a5592 <Udma_ringFree+0xc2> @ imm = #-0x2
;     return (retVal);
700a5592: 9804         	ldr	r0, [sp, #0x10]
700a5594: b006         	add	sp, #0x18
700a5596: bd80         	pop	{r7, pc}
		...

700a55a0 <UART_lld_writeIntr>:
; {
700a55a0: b580         	push	{r7, lr}
700a55a2: b086         	sub	sp, #0x18
700a55a4: 9005         	str	r0, [sp, #0x14]
700a55a6: 9104         	str	r1, [sp, #0x10]
700a55a8: 9203         	str	r2, [sp, #0xc]
700a55aa: 9302         	str	r3, [sp, #0x8]
700a55ac: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a55ae: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a55b0: 9805         	ldr	r0, [sp, #0x14]
700a55b2: 2800         	cmp	r0, #0x0
700a55b4: d050         	beq	0x700a5658 <UART_lld_writeIntr+0xb8> @ imm = #0xa0
700a55b6: e7ff         	b	0x700a55b8 <UART_lld_writeIntr+0x18> @ imm = #-0x2
;         trans = &hUart->writeTrans;
700a55b8: 9805         	ldr	r0, [sp, #0x14]
700a55ba: 303c         	adds	r0, #0x3c
700a55bc: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a55be: 9800         	ldr	r0, [sp]
700a55c0: 6800         	ldr	r0, [r0]
700a55c2: b138         	cbz	r0, 0x700a55d4 <UART_lld_writeIntr+0x34> @ imm = #0xe
700a55c4: e7ff         	b	0x700a55c6 <UART_lld_writeIntr+0x26> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a55c6: 9900         	ldr	r1, [sp]
700a55c8: 2009         	movs	r0, #0x9
700a55ca: 60c8         	str	r0, [r1, #0xc]
700a55cc: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a55d0: 9001         	str	r0, [sp, #0x4]
;         }
700a55d2: e040         	b	0x700a5656 <UART_lld_writeIntr+0xb6> @ imm = #0x80
;             UART_lld_Transaction_init(trans);
700a55d4: 9800         	ldr	r0, [sp]
700a55d6: f007 fe3b    	bl	0x700ad250 <UART_lld_Transaction_init> @ imm = #0x7c76
;             if(extendedParams != NULL)
700a55da: 9802         	ldr	r0, [sp, #0x8]
700a55dc: b128         	cbz	r0, 0x700a55ea <UART_lld_writeIntr+0x4a> @ imm = #0xa
700a55de: e7ff         	b	0x700a55e0 <UART_lld_writeIntr+0x40> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a55e0: 9802         	ldr	r0, [sp, #0x8]
700a55e2: 6800         	ldr	r0, [r0]
700a55e4: 9900         	ldr	r1, [sp]
700a55e6: 6108         	str	r0, [r1, #0x10]
;             }
700a55e8: e003         	b	0x700a55f2 <UART_lld_writeIntr+0x52> @ imm = #0x6
;                 trans->args = NULL;
700a55ea: 9900         	ldr	r1, [sp]
700a55ec: 2000         	movs	r0, #0x0
700a55ee: 6108         	str	r0, [r1, #0x10]
700a55f0: e7ff         	b	0x700a55f2 <UART_lld_writeIntr+0x52> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a55f2: 9804         	ldr	r0, [sp, #0x10]
700a55f4: 9900         	ldr	r1, [sp]
700a55f6: 6008         	str	r0, [r1]
;             trans->count = size;
700a55f8: 9803         	ldr	r0, [sp, #0xc]
700a55fa: 9900         	ldr	r1, [sp]
700a55fc: 6048         	str	r0, [r1, #0x4]
;             if(hUart->state == UART_STATE_READY)
700a55fe: 9805         	ldr	r0, [sp, #0x14]
700a5600: 6d40         	ldr	r0, [r0, #0x54]
700a5602: 2801         	cmp	r0, #0x1
700a5604: d105         	bne	0x700a5612 <UART_lld_writeIntr+0x72> @ imm = #0xa
700a5606: e7ff         	b	0x700a5608 <UART_lld_writeIntr+0x68> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a5608: 9800         	ldr	r0, [sp]
700a560a: f007 f9e9    	bl	0x700ac9e0 <UART_checkTransaction> @ imm = #0x73d2
700a560e: 9001         	str	r0, [sp, #0x4]
;             }
700a5610: e003         	b	0x700a561a <UART_lld_writeIntr+0x7a> @ imm = #0x6
700a5612: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a5616: 9001         	str	r0, [sp, #0x4]
700a5618: e7ff         	b	0x700a561a <UART_lld_writeIntr+0x7a> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a561a: 9801         	ldr	r0, [sp, #0x4]
700a561c: b9d0         	cbnz	r0, 0x700a5654 <UART_lld_writeIntr+0xb4> @ imm = #0x34
700a561e: e7ff         	b	0x700a5620 <UART_lld_writeIntr+0x80> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a5620: 9800         	ldr	r0, [sp]
700a5622: 6800         	ldr	r0, [r0]
700a5624: 9905         	ldr	r1, [sp, #0x14]
700a5626: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a5628: 9800         	ldr	r0, [sp]
700a562a: 6880         	ldr	r0, [r0, #0x8]
700a562c: 9905         	ldr	r1, [sp, #0x14]
700a562e: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a5630: 9905         	ldr	r1, [sp, #0x14]
700a5632: 2000         	movs	r0, #0x0
700a5634: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a5636: 9800         	ldr	r0, [sp]
700a5638: 6840         	ldr	r0, [r0, #0x4]
700a563a: 9905         	ldr	r1, [sp, #0x14]
700a563c: 6108         	str	r0, [r1, #0x10]
;                 hUart->state = UART_STATE_BUSY;
700a563e: 9905         	ldr	r1, [sp, #0x14]
700a5640: 2002         	movs	r0, #0x2
700a5642: 6548         	str	r0, [r1, #0x54]
;                 status = UART_writeInterrupt(hUart);
700a5644: 9805         	ldr	r0, [sp, #0x14]
700a5646: f008 f973    	bl	0x700ad930 <UART_writeInterrupt> @ imm = #0x82e6
700a564a: 9001         	str	r0, [sp, #0x4]
;                 hUart->state = UART_STATE_READY;
700a564c: 9905         	ldr	r1, [sp, #0x14]
700a564e: 2001         	movs	r0, #0x1
700a5650: 6548         	str	r0, [r1, #0x54]
;             }
700a5652: e7ff         	b	0x700a5654 <UART_lld_writeIntr+0xb4> @ imm = #-0x2
700a5654: e7ff         	b	0x700a5656 <UART_lld_writeIntr+0xb6> @ imm = #-0x2
;     }
700a5656: e003         	b	0x700a5660 <UART_lld_writeIntr+0xc0> @ imm = #0x6
700a5658: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a565c: 9001         	str	r0, [sp, #0x4]
700a565e: e7ff         	b	0x700a5660 <UART_lld_writeIntr+0xc0> @ imm = #-0x2
;     return status;
700a5660: 9801         	ldr	r0, [sp, #0x4]
700a5662: b006         	add	sp, #0x18
700a5664: bd80         	pop	{r7, pc}
		...
700a566e: 0000         	movs	r0, r0

700a5670 <Udma_eventUnRegister>:
; {
700a5670: b580         	push	{r7, lr}
700a5672: b084         	sub	sp, #0x10
700a5674: 9003         	str	r0, [sp, #0xc]
700a5676: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a5678: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == eventHandle)
700a567a: 9803         	ldr	r0, [sp, #0xc]
700a567c: b920         	cbnz	r0, 0x700a5688 <Udma_eventUnRegister+0x18> @ imm = #0x8
700a567e: e7ff         	b	0x700a5680 <Udma_eventUnRegister+0x10> @ imm = #-0x2
700a5680: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a5684: 9002         	str	r0, [sp, #0x8]
;     }
700a5686: e7ff         	b	0x700a5688 <Udma_eventUnRegister+0x18> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a5688: 9802         	ldr	r0, [sp, #0x8]
700a568a: b9b8         	cbnz	r0, 0x700a56bc <Udma_eventUnRegister+0x4c> @ imm = #0x2e
700a568c: e7ff         	b	0x700a568e <Udma_eventUnRegister+0x1e> @ imm = #-0x2
;         eventHandleInt = (Udma_EventHandleInt) eventHandle;
700a568e: 9803         	ldr	r0, [sp, #0xc]
700a5690: 9000         	str	r0, [sp]
;         drvHandle = eventHandleInt->drvHandle;
700a5692: 9800         	ldr	r0, [sp]
700a5694: 6800         	ldr	r0, [r0]
700a5696: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a5698: 9801         	ldr	r0, [sp, #0x4]
700a569a: b150         	cbz	r0, 0x700a56b2 <Udma_eventUnRegister+0x42> @ imm = #0x14
700a569c: e7ff         	b	0x700a569e <Udma_eventUnRegister+0x2e> @ imm = #-0x2
700a569e: 9801         	ldr	r0, [sp, #0x4]
700a56a0: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a56a4: f64a 31cd    	movw	r1, #0xabcd
700a56a8: f6ca 31dc    	movt	r1, #0xabdc
700a56ac: 4288         	cmp	r0, r1
700a56ae: d004         	beq	0x700a56ba <Udma_eventUnRegister+0x4a> @ imm = #0x8
700a56b0: e7ff         	b	0x700a56b2 <Udma_eventUnRegister+0x42> @ imm = #-0x2
700a56b2: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a56b6: 9002         	str	r0, [sp, #0x8]
;         }
700a56b8: e7ff         	b	0x700a56ba <Udma_eventUnRegister+0x4a> @ imm = #-0x2
;     }
700a56ba: e7ff         	b	0x700a56bc <Udma_eventUnRegister+0x4c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a56bc: 9802         	ldr	r0, [sp, #0x8]
700a56be: bbb8         	cbnz	r0, 0x700a5730 <Udma_eventUnRegister+0xc0> @ imm = #0x6e
700a56c0: e7ff         	b	0x700a56c2 <Udma_eventUnRegister+0x52> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandle->instType) &&
700a56c2: 9801         	ldr	r0, [sp, #0x4]
700a56c4: 6800         	ldr	r0, [r0]
700a56c6: b130         	cbz	r0, 0x700a56d6 <Udma_eventUnRegister+0x66> @ imm = #0xc
700a56c8: e7ff         	b	0x700a56ca <Udma_eventUnRegister+0x5a> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventHandleInt->eventPrms.eventType))
700a56ca: 9800         	ldr	r0, [sp]
700a56cc: 6880         	ldr	r0, [r0, #0x8]
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandle->instType) &&
700a56ce: 2802         	cmp	r0, #0x2
700a56d0: d101         	bne	0x700a56d6 <Udma_eventUnRegister+0x66> @ imm = #0x2
700a56d2: e7ff         	b	0x700a56d4 <Udma_eventUnRegister+0x64> @ imm = #-0x2
;         }
700a56d4: e02b         	b	0x700a572e <Udma_eventUnRegister+0xbe> @ imm = #0x56
;             retVal = Udma_eventCheckUnRegister(drvHandle, eventHandleInt);
700a56d6: 9801         	ldr	r0, [sp, #0x4]
700a56d8: 9900         	ldr	r1, [sp]
700a56da: f7ff fe91    	bl	0x700a5400 <Udma_eventCheckUnRegister> @ imm = #-0x2de
700a56de: 9002         	str	r0, [sp, #0x8]
;             if(UDMA_SOK == retVal)
700a56e0: 9802         	ldr	r0, [sp, #0x8]
700a56e2: bb18         	cbnz	r0, 0x700a572c <Udma_eventUnRegister+0xbc> @ imm = #0x46
700a56e4: e7ff         	b	0x700a56e6 <Udma_eventUnRegister+0x76> @ imm = #-0x2
;                 if(NULL_PTR != eventHandleInt->hwiHandle)
700a56e6: 9800         	ldr	r0, [sp]
700a56e8: 6e40         	ldr	r0, [r0, #0x64]
700a56ea: b128         	cbz	r0, 0x700a56f8 <Udma_eventUnRegister+0x88> @ imm = #0xa
700a56ec: e7ff         	b	0x700a56ee <Udma_eventUnRegister+0x7e> @ imm = #-0x2
;                     HwiP_disableInt(eventHandleInt->coreIntrNum);
700a56ee: 9800         	ldr	r0, [sp]
700a56f0: 6d80         	ldr	r0, [r0, #0x58]
700a56f2: f008 fdd5    	bl	0x700ae2a0 <HwiP_disableInt> @ imm = #0x8baa
;                 }
700a56f6: e7ff         	b	0x700a56f8 <Udma_eventUnRegister+0x88> @ imm = #-0x2
;                 retVal = Udma_eventReset(drvHandle, eventHandleInt);
700a56f8: 9801         	ldr	r0, [sp, #0x4]
700a56fa: 9900         	ldr	r1, [sp]
700a56fc: f7f6 fb10    	bl	0x7009bd20 <Udma_eventReset> @ imm = #-0x99e0
700a5700: 9002         	str	r0, [sp, #0x8]
;                 if(UDMA_SOK != retVal)
700a5702: 9802         	ldr	r0, [sp, #0x8]
700a5704: b108         	cbz	r0, 0x700a570a <Udma_eventUnRegister+0x9a> @ imm = #0x2
700a5706: e7ff         	b	0x700a5708 <Udma_eventUnRegister+0x98> @ imm = #-0x2
;                 }
700a5708: e7ff         	b	0x700a570a <Udma_eventUnRegister+0x9a> @ imm = #-0x2
;                 Udma_eventFreeResource(drvHandle, eventHandleInt);
700a570a: 9801         	ldr	r0, [sp, #0x4]
700a570c: 9900         	ldr	r1, [sp]
700a570e: f7fe fcef    	bl	0x700a40f0 <Udma_eventFreeResource> @ imm = #-0x1622
;                 eventHandleInt->eventInitDone  = UDMA_DEINIT_DONE;
700a5712: 9900         	ldr	r1, [sp]
700a5714: 2000         	movs	r0, #0x0
700a5716: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 eventHandleInt->pIaGeviRegs    = (volatile CSL_intaggr_imapRegs_gevi *) NULL_PTR;
700a571a: 9900         	ldr	r1, [sp]
700a571c: f8c1 0090    	str.w	r0, [r1, #0x90]
;                 eventHandleInt->pIaVintrRegs   = (volatile CSL_intaggr_intrRegs_vint *) NULL_PTR;
700a5720: 9900         	ldr	r1, [sp]
700a5722: f8c1 0094    	str.w	r0, [r1, #0x94]
;                 eventHandleInt->drvHandle      = (Udma_DrvHandleInt) NULL_PTR;
700a5726: 9900         	ldr	r1, [sp]
700a5728: 6008         	str	r0, [r1]
;             }
700a572a: e7ff         	b	0x700a572c <Udma_eventUnRegister+0xbc> @ imm = #-0x2
700a572c: e7ff         	b	0x700a572e <Udma_eventUnRegister+0xbe> @ imm = #-0x2
;     }
700a572e: e7ff         	b	0x700a5730 <Udma_eventUnRegister+0xc0> @ imm = #-0x2
;     return (retVal);
700a5730: 9802         	ldr	r0, [sp, #0x8]
700a5732: b004         	add	sp, #0x10
700a5734: bd80         	pop	{r7, pc}
		...
700a573e: 0000         	movs	r0, r0

700a5740 <Sciclient_rmIrqIsVintRouteSet>:
; {
700a5740: b580         	push	{r7, lr}
700a5742: b088         	sub	sp, #0x20
700a5744: 9007         	str	r0, [sp, #0x1c]
700a5746: 9106         	str	r1, [sp, #0x18]
700a5748: 2000         	movs	r0, #0x0
;     bool found_iface = false;
700a574a: f88d 0007    	strb.w	r0, [sp, #0x7]
;     *vint_used = false;
700a574e: 9906         	ldr	r1, [sp, #0x18]
700a5750: 7008         	strb	r0, [r1]
;     r = Sciclient_rmIrqGetNode(cfg->s_ia, &ia_node);
700a5752: 9807         	ldr	r0, [sp, #0x1c]
700a5754: 8a00         	ldrh	r0, [r0, #0x10]
700a5756: a903         	add	r1, sp, #0xc
700a5758: f7fe fdba    	bl	0x700a42d0 <Sciclient_rmIrqGetNode> @ imm = #-0x148c
700a575c: 9005         	str	r0, [sp, #0x14]
;     if (r == SystemP_SUCCESS) {
700a575e: 9805         	ldr	r0, [sp, #0x14]
700a5760: bb90         	cbnz	r0, 0x700a57c8 <Sciclient_rmIrqIsVintRouteSet+0x88> @ imm = #0x64
700a5762: e7ff         	b	0x700a5764 <Sciclient_rmIrqIsVintRouteSet+0x24> @ imm = #-0x2
700a5764: 2000         	movs	r0, #0x0
;         for (i = 0U; i < ia_node->n_if; i++) {
700a5766: f8ad 0012    	strh.w	r0, [sp, #0x12]
700a576a: e7ff         	b	0x700a576c <Sciclient_rmIrqIsVintRouteSet+0x2c> @ imm = #-0x2
700a576c: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a5770: 9903         	ldr	r1, [sp, #0xc]
700a5772: 8849         	ldrh	r1, [r1, #0x2]
700a5774: 4288         	cmp	r0, r1
700a5776: da26         	bge	0x700a57c6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0x4c
700a5778: e7ff         	b	0x700a577a <Sciclient_rmIrqIsVintRouteSet+0x3a> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(ia_node, i, &iface);
700a577a: 9803         	ldr	r0, [sp, #0xc]
700a577c: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a5780: aa02         	add	r2, sp, #0x8
700a5782: f006 fb6d    	bl	0x700abe60 <Sciclient_rmIrqGetNodeItf> @ imm = #0x66da
700a5786: 9005         	str	r0, [sp, #0x14]
;             if (r != SystemP_SUCCESS) {
700a5788: 9805         	ldr	r0, [sp, #0x14]
700a578a: b108         	cbz	r0, 0x700a5790 <Sciclient_rmIrqIsVintRouteSet+0x50> @ imm = #0x2
700a578c: e7ff         	b	0x700a578e <Sciclient_rmIrqIsVintRouteSet+0x4e> @ imm = #-0x2
;                 break;
700a578e: e01a         	b	0x700a57c6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0x34
;             if ((cfg->vint >= iface->lbase) &&
700a5790: 9807         	ldr	r0, [sp, #0x1c]
700a5792: 8a40         	ldrh	r0, [r0, #0x12]
700a5794: 9902         	ldr	r1, [sp, #0x8]
700a5796: 8809         	ldrh	r1, [r1]
700a5798: 4288         	cmp	r0, r1
700a579a: db0d         	blt	0x700a57b8 <Sciclient_rmIrqIsVintRouteSet+0x78> @ imm = #0x1a
700a579c: e7ff         	b	0x700a579e <Sciclient_rmIrqIsVintRouteSet+0x5e> @ imm = #-0x2
;                 (cfg->vint < (iface->lbase + iface->len))) {
700a579e: 9807         	ldr	r0, [sp, #0x1c]
700a57a0: 8a40         	ldrh	r0, [r0, #0x12]
700a57a2: 9a02         	ldr	r2, [sp, #0x8]
700a57a4: 8811         	ldrh	r1, [r2]
700a57a6: 8892         	ldrh	r2, [r2, #0x4]
700a57a8: 4411         	add	r1, r2
;             if ((cfg->vint >= iface->lbase) &&
700a57aa: 4288         	cmp	r0, r1
700a57ac: da04         	bge	0x700a57b8 <Sciclient_rmIrqIsVintRouteSet+0x78> @ imm = #0x8
700a57ae: e7ff         	b	0x700a57b0 <Sciclient_rmIrqIsVintRouteSet+0x70> @ imm = #-0x2
700a57b0: 2001         	movs	r0, #0x1
;                 found_iface = true;
700a57b2: f88d 0007    	strb.w	r0, [sp, #0x7]
;                 break;
700a57b6: e006         	b	0x700a57c6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0xc
;         }
700a57b8: e7ff         	b	0x700a57ba <Sciclient_rmIrqIsVintRouteSet+0x7a> @ imm = #-0x2
;         for (i = 0U; i < ia_node->n_if; i++) {
700a57ba: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a57be: 3001         	adds	r0, #0x1
700a57c0: f8ad 0012    	strh.w	r0, [sp, #0x12]
700a57c4: e7d2         	b	0x700a576c <Sciclient_rmIrqIsVintRouteSet+0x2c> @ imm = #-0x5c
;     }
700a57c6: e7ff         	b	0x700a57c8 <Sciclient_rmIrqIsVintRouteSet+0x88> @ imm = #-0x2
;     if (found_iface) {
700a57c8: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700a57cc: 07c0         	lsls	r0, r0, #0x1f
700a57ce: b1b0         	cbz	r0, 0x700a57fe <Sciclient_rmIrqIsVintRouteSet+0xbe> @ imm = #0x2c
700a57d0: e7ff         	b	0x700a57d2 <Sciclient_rmIrqIsVintRouteSet+0x92> @ imm = #-0x2
;         ir_inp = SCICLIENT_OUTP_TO_INP(cfg->vint, iface->lbase, iface->rbase);
700a57d2: 9a02         	ldr	r2, [sp, #0x8]
700a57d4: 8850         	ldrh	r0, [r2, #0x2]
700a57d6: 9907         	ldr	r1, [sp, #0x1c]
700a57d8: 8a49         	ldrh	r1, [r1, #0x12]
700a57da: 8812         	ldrh	r2, [r2]
700a57dc: 1a89         	subs	r1, r1, r2
700a57de: 4408         	add	r0, r1
700a57e0: f8ad 0004    	strh.w	r0, [sp, #0x4]
;         if (Sciclient_rmIrInpIsFree(iface->rid, ir_inp) != SystemP_SUCCESS) {
700a57e4: 9802         	ldr	r0, [sp, #0x8]
700a57e6: 88c0         	ldrh	r0, [r0, #0x6]
700a57e8: f8bd 1004    	ldrh.w	r1, [sp, #0x4]
700a57ec: f7fe ff38    	bl	0x700a4660 <Sciclient_rmIrInpIsFree> @ imm = #-0x1190
700a57f0: b120         	cbz	r0, 0x700a57fc <Sciclient_rmIrqIsVintRouteSet+0xbc> @ imm = #0x8
700a57f2: e7ff         	b	0x700a57f4 <Sciclient_rmIrqIsVintRouteSet+0xb4> @ imm = #-0x2
;             *vint_used = true;
700a57f4: 9906         	ldr	r1, [sp, #0x18]
700a57f6: 2001         	movs	r0, #0x1
700a57f8: 7008         	strb	r0, [r1]
;         }
700a57fa: e7ff         	b	0x700a57fc <Sciclient_rmIrqIsVintRouteSet+0xbc> @ imm = #-0x2
;     }
700a57fc: e7ff         	b	0x700a57fe <Sciclient_rmIrqIsVintRouteSet+0xbe> @ imm = #-0x2
;     return r;
700a57fe: 9805         	ldr	r0, [sp, #0x14]
700a5800: b008         	add	sp, #0x20
700a5802: bd80         	pop	{r7, pc}
		...

700a5810 <UART_flushTxFifo>:
; {
700a5810: b580         	push	{r7, lr}
700a5812: b08a         	sub	sp, #0x28
700a5814: 9009         	str	r0, [sp, #0x24]
700a5816: f640 30b8    	movw	r0, #0xbb8
;     uint32_t            timeout = UART_TRANSMITEMPTY_TRIALCOUNT;
700a581a: 9003         	str	r0, [sp, #0xc]
700a581c: 2000         	movs	r0, #0x0
;     uint32_t            timeoutElapsed  = FALSE;
700a581e: 9002         	str	r0, [sp, #0x8]
;     config = (UART_Config *) handle;
700a5820: 9809         	ldr	r0, [sp, #0x24]
700a5822: 9008         	str	r0, [sp, #0x20]
;     if (NULL != config)
700a5824: 9808         	ldr	r0, [sp, #0x20]
700a5826: 2800         	cmp	r0, #0x0
700a5828: d052         	beq	0x700a58d0 <UART_flushTxFifo+0xc0> @ imm = #0xa4
700a582a: e7ff         	b	0x700a582c <UART_flushTxFifo+0x1c> @ imm = #-0x2
;         attrs = config->attrs;
700a582c: 9808         	ldr	r0, [sp, #0x20]
700a582e: 6800         	ldr	r0, [r0]
700a5830: 9007         	str	r0, [sp, #0x1c]
;         DebugP_assert(NULL_PTR != attrs);
700a5832: 9807         	ldr	r0, [sp, #0x1c]
700a5834: 2800         	cmp	r0, #0x0
700a5836: bf18         	it	ne
700a5838: 2001         	movne	r0, #0x1
700a583a: f240 4113    	movw	r1, #0x413
700a583e: f2c7 010b    	movt	r1, #0x700b
700a5842: 466a         	mov	r2, sp
700a5844: 6011         	str	r1, [r2]
700a5846: f240 31dd    	movw	r1, #0x3dd
700a584a: f2c7 010b    	movt	r1, #0x700b
700a584e: f240 4248    	movw	r2, #0x448
700a5852: f2c7 020b    	movt	r2, #0x700b
700a5856: f240 3355    	movw	r3, #0x355
700a585a: f003 fc61    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x38c2
;         startTicks = ClockP_getTicks();
700a585e: f008 fc7f    	bl	0x700ae160 <ClockP_getTicks> @ imm = #0x88fe
700a5862: 9005         	str	r0, [sp, #0x14]
;         while (FALSE == timeoutElapsed)
700a5864: e7ff         	b	0x700a5866 <UART_flushTxFifo+0x56> @ imm = #-0x2
700a5866: 9802         	ldr	r0, [sp, #0x8]
700a5868: b9d8         	cbnz	r0, 0x700a58a2 <UART_flushTxFifo+0x92> @ imm = #0x36
700a586a: e7ff         	b	0x700a586c <UART_flushTxFifo+0x5c> @ imm = #-0x2
;             isTxFifoEmpty = UART_spaceAvail(attrs->baseAddr);
700a586c: 9807         	ldr	r0, [sp, #0x1c]
700a586e: 6800         	ldr	r0, [r0]
700a5870: f006 fd36    	bl	0x700ac2e0 <UART_spaceAvail> @ imm = #0x6a6c
700a5874: 9006         	str	r0, [sp, #0x18]
;             if (TRUE == isTxFifoEmpty)
700a5876: 9806         	ldr	r0, [sp, #0x18]
700a5878: 2801         	cmp	r0, #0x1
700a587a: d101         	bne	0x700a5880 <UART_flushTxFifo+0x70> @ imm = #0x2
700a587c: e7ff         	b	0x700a587e <UART_flushTxFifo+0x6e> @ imm = #-0x2
;                 break;
700a587e: e010         	b	0x700a58a2 <UART_flushTxFifo+0x92> @ imm = #0x20
;             elapsedTicks = ClockP_getTicks() - startTicks;
700a5880: f008 fc6e    	bl	0x700ae160 <ClockP_getTicks> @ imm = #0x88dc
700a5884: 9905         	ldr	r1, [sp, #0x14]
700a5886: 1a40         	subs	r0, r0, r1
700a5888: 9004         	str	r0, [sp, #0x10]
;             if (elapsedTicks >= timeout)
700a588a: 9804         	ldr	r0, [sp, #0x10]
700a588c: 9903         	ldr	r1, [sp, #0xc]
700a588e: 4288         	cmp	r0, r1
700a5890: d303         	blo	0x700a589a <UART_flushTxFifo+0x8a> @ imm = #0x6
700a5892: e7ff         	b	0x700a5894 <UART_flushTxFifo+0x84> @ imm = #-0x2
700a5894: 2001         	movs	r0, #0x1
;                 timeoutElapsed = TRUE;
700a5896: 9002         	str	r0, [sp, #0x8]
;             }
700a5898: e002         	b	0x700a58a0 <UART_flushTxFifo+0x90> @ imm = #0x4
;                 TaskP_yield();
700a589a: f008 fc91    	bl	0x700ae1c0 <TaskP_yield> @ imm = #0x8922
700a589e: e7ff         	b	0x700a58a0 <UART_flushTxFifo+0x90> @ imm = #-0x2
;         while (FALSE == timeoutElapsed)
700a58a0: e7e1         	b	0x700a5866 <UART_flushTxFifo+0x56> @ imm = #-0x3e
;         DebugP_assert(FALSE == timeoutElapsed);
700a58a2: 9802         	ldr	r0, [sp, #0x8]
700a58a4: fab0 f080    	clz	r0, r0
700a58a8: 0940         	lsrs	r0, r0, #0x5
700a58aa: f240 21a1    	movw	r1, #0x2a1
700a58ae: f2c7 010b    	movt	r1, #0x700b
700a58b2: 466a         	mov	r2, sp
700a58b4: 6011         	str	r1, [r2]
700a58b6: f240 31dd    	movw	r1, #0x3dd
700a58ba: f2c7 010b    	movt	r1, #0x700b
700a58be: f240 4248    	movw	r2, #0x448
700a58c2: f2c7 020b    	movt	r2, #0x700b
700a58c6: f240 336f    	movw	r3, #0x36f
700a58ca: f003 fc29    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x3852
;     }
700a58ce: e7ff         	b	0x700a58d0 <UART_flushTxFifo+0xc0> @ imm = #-0x2
;     return;
700a58d0: b00a         	add	sp, #0x28
700a58d2: bd80         	pop	{r7, pc}
		...

700a58e0 <Udma_chClose>:
; {
700a58e0: b580         	push	{r7, lr}
700a58e2: b084         	sub	sp, #0x10
700a58e4: 9003         	str	r0, [sp, #0xc]
700a58e6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a58e8: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a58ea: 9803         	ldr	r0, [sp, #0xc]
700a58ec: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a58ee: 9800         	ldr	r0, [sp]
700a58f0: b150         	cbz	r0, 0x700a5908 <Udma_chClose+0x28> @ imm = #0x14
700a58f2: e7ff         	b	0x700a58f4 <Udma_chClose+0x14> @ imm = #-0x2
700a58f4: 9800         	ldr	r0, [sp]
700a58f6: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a58fa: f64a 31cd    	movw	r1, #0xabcd
700a58fe: f6ca 31dc    	movt	r1, #0xabdc
700a5902: 4288         	cmp	r0, r1
700a5904: d004         	beq	0x700a5910 <Udma_chClose+0x30> @ imm = #0x8
700a5906: e7ff         	b	0x700a5908 <Udma_chClose+0x28> @ imm = #-0x2
700a5908: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a590c: 9002         	str	r0, [sp, #0x8]
;     }
700a590e: e7ff         	b	0x700a5910 <Udma_chClose+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a5910: 9802         	ldr	r0, [sp, #0x8]
700a5912: b9a8         	cbnz	r0, 0x700a5940 <Udma_chClose+0x60> @ imm = #0x2a
700a5914: e7ff         	b	0x700a5916 <Udma_chClose+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a5916: 9800         	ldr	r0, [sp]
700a5918: 6e80         	ldr	r0, [r0, #0x68]
700a591a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a591c: 9801         	ldr	r0, [sp, #0x4]
700a591e: b150         	cbz	r0, 0x700a5936 <Udma_chClose+0x56> @ imm = #0x14
700a5920: e7ff         	b	0x700a5922 <Udma_chClose+0x42> @ imm = #-0x2
700a5922: 9801         	ldr	r0, [sp, #0x4]
700a5924: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a5928: f64a 31cd    	movw	r1, #0xabcd
700a592c: f6ca 31dc    	movt	r1, #0xabdc
700a5930: 4288         	cmp	r0, r1
700a5932: d004         	beq	0x700a593e <Udma_chClose+0x5e> @ imm = #0x8
700a5934: e7ff         	b	0x700a5936 <Udma_chClose+0x56> @ imm = #-0x2
700a5936: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a593a: 9002         	str	r0, [sp, #0x8]
;         }
700a593c: e7ff         	b	0x700a593e <Udma_chClose+0x5e> @ imm = #-0x2
;     }
700a593e: e7ff         	b	0x700a5940 <Udma_chClose+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a5940: 9802         	ldr	r0, [sp, #0x8]
700a5942: b958         	cbnz	r0, 0x700a595c <Udma_chClose+0x7c> @ imm = #0x16
700a5944: e7ff         	b	0x700a5946 <Udma_chClose+0x66> @ imm = #-0x2
;         if(TRUE == chHandleInt->chOesAllocDone)
700a5946: 9800         	ldr	r0, [sp]
700a5948: f8d0 0248    	ldr.w	r0, [r0, #0x248]
700a594c: 2801         	cmp	r0, #0x1
700a594e: d104         	bne	0x700a595a <Udma_chClose+0x7a> @ imm = #0x8
700a5950: e7ff         	b	0x700a5952 <Udma_chClose+0x72> @ imm = #-0x2
700a5952: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a5956: 9002         	str	r0, [sp, #0x8]
;         }
700a5958: e7ff         	b	0x700a595a <Udma_chClose+0x7a> @ imm = #-0x2
;     }
700a595a: e7ff         	b	0x700a595c <Udma_chClose+0x7c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a595c: 9802         	ldr	r0, [sp, #0x8]
700a595e: b9e8         	cbnz	r0, 0x700a599c <Udma_chClose+0xbc> @ imm = #0x3a
700a5960: e7ff         	b	0x700a5962 <Udma_chClose+0x82> @ imm = #-0x2
;         retVal = Udma_chUnpair(chHandleInt);
700a5962: 9800         	ldr	r0, [sp]
700a5964: f003 fa14    	bl	0x700a8d90 <Udma_chUnpair> @ imm = #0x3428
700a5968: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
700a596a: 9802         	ldr	r0, [sp, #0x8]
700a596c: b108         	cbz	r0, 0x700a5972 <Udma_chClose+0x92> @ imm = #0x2
700a596e: e7ff         	b	0x700a5970 <Udma_chClose+0x90> @ imm = #-0x2
;         }
700a5970: e7ff         	b	0x700a5972 <Udma_chClose+0x92> @ imm = #-0x2
;         retVal += Udma_chFreeResource(chHandleInt);
700a5972: 9800         	ldr	r0, [sp]
700a5974: f7f7 ff7c    	bl	0x7009d870 <Udma_chFreeResource> @ imm = #-0x8108
700a5978: 4601         	mov	r1, r0
700a597a: 9802         	ldr	r0, [sp, #0x8]
700a597c: 4408         	add	r0, r1
700a597e: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
700a5980: 9802         	ldr	r0, [sp, #0x8]
700a5982: b108         	cbz	r0, 0x700a5988 <Udma_chClose+0xa8> @ imm = #0x2
700a5984: e7ff         	b	0x700a5986 <Udma_chClose+0xa6> @ imm = #-0x2
;         }
700a5986: e7ff         	b	0x700a5988 <Udma_chClose+0xa8> @ imm = #-0x2
;         (void) memset(chHandleInt, 0, sizeof(*chHandleInt));
700a5988: 9800         	ldr	r0, [sp]
700a598a: f44f 7114    	mov.w	r1, #0x250
700a598e: f7f3 ef52    	blx	0x70099834 <__aeabi_memclr8> @ imm = #-0xc15c
;         chHandleInt->chInitDone = UDMA_DEINIT_DONE;
700a5992: 9900         	ldr	r1, [sp]
700a5994: 2000         	movs	r0, #0x0
700a5996: f8c1 0244    	str.w	r0, [r1, #0x244]
;     }
700a599a: e7ff         	b	0x700a599c <Udma_chClose+0xbc> @ imm = #-0x2
;     return (retVal);
700a599c: 9802         	ldr	r0, [sp, #0x8]
700a599e: b004         	add	sp, #0x10
700a59a0: bd80         	pop	{r7, pc}
		...
700a59ae: 0000         	movs	r0, r0

700a59b0 <CSL_bcdmaChanOpAccessRemotePeerReg>:
; {
700a59b0: b580         	push	{r7, lr}
700a59b2: b08a         	sub	sp, #0x28
700a59b4: 4684         	mov	r12, r0
700a59b6: 980c         	ldr	r0, [sp, #0x30]
700a59b8: f8cd c024    	str.w	r12, [sp, #0x24]
700a59bc: 9108         	str	r1, [sp, #0x20]
700a59be: 9207         	str	r2, [sp, #0x1c]
700a59c0: 9306         	str	r3, [sp, #0x18]
700a59c2: f88d 0017    	strb.w	r0, [sp, #0x17]
700a59c6: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a59c8: 9004         	str	r0, [sp, #0x10]
;     if( pOpData == NULL )
700a59ca: 9806         	ldr	r0, [sp, #0x18]
700a59cc: b920         	cbnz	r0, 0x700a59d8 <CSL_bcdmaChanOpAccessRemotePeerReg+0x28> @ imm = #0x8
700a59ce: e7ff         	b	0x700a59d0 <CSL_bcdmaChanOpAccessRemotePeerReg+0x20> @ imm = #-0x2
700a59d0: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a59d4: 9004         	str	r0, [sp, #0x10]
;     }
700a59d6: e048         	b	0x700a5a6a <CSL_bcdmaChanOpAccessRemotePeerReg+0xba> @ imm = #0x90
700a59d8: 2000         	movs	r0, #0x0
;         uint32_t *pRemotePeerReg = NULL;
700a59da: 9003         	str	r0, [sp, #0xc]
;         switch( chanType )
700a59dc: 9808         	ldr	r0, [sp, #0x20]
700a59de: 9001         	str	r0, [sp, #0x4]
700a59e0: 2801         	cmp	r0, #0x1
700a59e2: d004         	beq	0x700a59ee <CSL_bcdmaChanOpAccessRemotePeerReg+0x3e> @ imm = #0x8
700a59e4: e7ff         	b	0x700a59e6 <CSL_bcdmaChanOpAccessRemotePeerReg+0x36> @ imm = #-0x2
700a59e6: 9801         	ldr	r0, [sp, #0x4]
700a59e8: 2802         	cmp	r0, #0x2
700a59ea: d009         	beq	0x700a5a00 <CSL_bcdmaChanOpAccessRemotePeerReg+0x50> @ imm = #0x12
700a59ec: e011         	b	0x700a5a12 <CSL_bcdmaChanOpAccessRemotePeerReg+0x62> @ imm = #0x22
;                 pRemotePeerReg = (uint32_t *)&pCfg->pTxChanRtRegs->CHAN[chanIdx].PEER0;
700a59ee: 9809         	ldr	r0, [sp, #0x24]
700a59f0: 6900         	ldr	r0, [r0, #0x10]
700a59f2: 9907         	ldr	r1, [sp, #0x1c]
700a59f4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a59f8: f500 7000    	add.w	r0, r0, #0x200
700a59fc: 9003         	str	r0, [sp, #0xc]
;                 break;
700a59fe: e00c         	b	0x700a5a1a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #0x18
;                 pRemotePeerReg = (uint32_t *)&pCfg->pRxChanRtRegs->CHAN[chanIdx].PEER0;
700a5a00: 9809         	ldr	r0, [sp, #0x24]
700a5a02: 6980         	ldr	r0, [r0, #0x18]
700a5a04: 9907         	ldr	r1, [sp, #0x1c]
700a5a06: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a5a0a: f500 7000    	add.w	r0, r0, #0x200
700a5a0e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a5a10: e003         	b	0x700a5a1a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #0x6
700a5a12: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a5a16: 9004         	str	r0, [sp, #0x10]
;                 break;
700a5a18: e7ff         	b	0x700a5a1a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #-0x2
;         if( pRemotePeerReg != NULL )
700a5a1a: 9803         	ldr	r0, [sp, #0xc]
700a5a1c: b320         	cbz	r0, 0x700a5a68 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb8> @ imm = #0x48
700a5a1e: e7ff         	b	0x700a5a20 <CSL_bcdmaChanOpAccessRemotePeerReg+0x70> @ imm = #-0x2
;             CSL_BcdmaRemotePeerOpts *pPeerOpts = (CSL_BcdmaRemotePeerOpts *)pOpData;
700a5a20: 9806         	ldr	r0, [sp, #0x18]
700a5a22: 9002         	str	r0, [sp, #0x8]
;             if( pPeerOpts->regIdx >= (uint32_t)16u )
700a5a24: 9802         	ldr	r0, [sp, #0x8]
700a5a26: 6800         	ldr	r0, [r0]
700a5a28: 2810         	cmp	r0, #0x10
700a5a2a: d304         	blo	0x700a5a36 <CSL_bcdmaChanOpAccessRemotePeerReg+0x86> @ imm = #0x8
700a5a2c: e7ff         	b	0x700a5a2e <CSL_bcdmaChanOpAccessRemotePeerReg+0x7e> @ imm = #-0x2
700a5a2e: f06f 0002    	mvn	r0, #0x2
;                 retVal = CSL_EINVALID_PARAMS;
700a5a32: 9004         	str	r0, [sp, #0x10]
;             }
700a5a34: e017         	b	0x700a5a66 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb6> @ imm = #0x2e
;                 pRemotePeerReg += pPeerOpts->regIdx;    /* Increment to specified peer register */
700a5a36: 9802         	ldr	r0, [sp, #0x8]
700a5a38: 6801         	ldr	r1, [r0]
700a5a3a: 9803         	ldr	r0, [sp, #0xc]
700a5a3c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a5a40: 9003         	str	r0, [sp, #0xc]
;                 if( bRead == (bool)true )
700a5a42: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a5a46: 07c0         	lsls	r0, r0, #0x1f
700a5a48: b130         	cbz	r0, 0x700a5a58 <CSL_bcdmaChanOpAccessRemotePeerReg+0xa8> @ imm = #0xc
700a5a4a: e7ff         	b	0x700a5a4c <CSL_bcdmaChanOpAccessRemotePeerReg+0x9c> @ imm = #-0x2
;                     pPeerOpts->regVal = CSL_REG32_RD( pRemotePeerReg );
700a5a4c: 9803         	ldr	r0, [sp, #0xc]
700a5a4e: f008 fb0f    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0x861e
700a5a52: 9902         	ldr	r1, [sp, #0x8]
700a5a54: 6048         	str	r0, [r1, #0x4]
;                 }
700a5a56: e005         	b	0x700a5a64 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb4> @ imm = #0xa
;                     CSL_REG32_WR( pRemotePeerReg, pPeerOpts->regVal );
700a5a58: 9803         	ldr	r0, [sp, #0xc]
700a5a5a: 9902         	ldr	r1, [sp, #0x8]
700a5a5c: 6849         	ldr	r1, [r1, #0x4]
700a5a5e: f7f5 faa7    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0xaab2
700a5a62: e7ff         	b	0x700a5a64 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb4> @ imm = #-0x2
700a5a64: e7ff         	b	0x700a5a66 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb6> @ imm = #-0x2
;         }
700a5a66: e7ff         	b	0x700a5a68 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb8> @ imm = #-0x2
700a5a68: e7ff         	b	0x700a5a6a <CSL_bcdmaChanOpAccessRemotePeerReg+0xba> @ imm = #-0x2
;     return retVal;
700a5a6a: 9804         	ldr	r0, [sp, #0x10]
700a5a6c: b00a         	add	sp, #0x28
700a5a6e: bd80         	pop	{r7, pc}

700a5a70 <_out_rev>:
; {
700a5a70: b580         	push	{r7, lr}
700a5a72: b086         	sub	sp, #0x18
700a5a74: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a5a78: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a5a7c: f8dd c024    	ldr.w	r12, [sp, #0x24]
700a5a80: f8dd c020    	ldr.w	r12, [sp, #0x20]
700a5a84: 9005         	str	r0, [sp, #0x14]
700a5a86: 9104         	str	r1, [sp, #0x10]
700a5a88: 9203         	str	r2, [sp, #0xc]
700a5a8a: 9302         	str	r3, [sp, #0x8]
;   const size_t start_idx = idx;
700a5a8c: 9803         	ldr	r0, [sp, #0xc]
700a5a8e: 9001         	str	r0, [sp, #0x4]
;   if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
700a5a90: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a5a94: 0780         	lsls	r0, r0, #0x1e
700a5a96: 2800         	cmp	r0, #0x0
700a5a98: d41c         	bmi	0x700a5ad4 <_out_rev+0x64> @ imm = #0x38
700a5a9a: e7ff         	b	0x700a5a9c <_out_rev+0x2c> @ imm = #-0x2
700a5a9c: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a5aa0: 07c0         	lsls	r0, r0, #0x1f
700a5aa2: b9b8         	cbnz	r0, 0x700a5ad4 <_out_rev+0x64> @ imm = #0x2e
700a5aa4: e7ff         	b	0x700a5aa6 <_out_rev+0x36> @ imm = #-0x2
;     for (i = len; i < width; i++) {
700a5aa6: 9809         	ldr	r0, [sp, #0x24]
700a5aa8: 9000         	str	r0, [sp]
700a5aaa: e7ff         	b	0x700a5aac <_out_rev+0x3c> @ imm = #-0x2
700a5aac: 9800         	ldr	r0, [sp]
700a5aae: 990a         	ldr	r1, [sp, #0x28]
700a5ab0: 4288         	cmp	r0, r1
700a5ab2: d20e         	bhs	0x700a5ad2 <_out_rev+0x62> @ imm = #0x1c
700a5ab4: e7ff         	b	0x700a5ab6 <_out_rev+0x46> @ imm = #-0x2
;       out(' ', buffer, idx++, maxlen);
700a5ab6: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a5aba: 9904         	ldr	r1, [sp, #0x10]
700a5abc: 9a03         	ldr	r2, [sp, #0xc]
700a5abe: 1c50         	adds	r0, r2, #0x1
700a5ac0: 9003         	str	r0, [sp, #0xc]
700a5ac2: 9b02         	ldr	r3, [sp, #0x8]
700a5ac4: 2020         	movs	r0, #0x20
700a5ac6: 47e0         	blx	r12
;     }
700a5ac8: e7ff         	b	0x700a5aca <_out_rev+0x5a> @ imm = #-0x2
;     for (i = len; i < width; i++) {
700a5aca: 9800         	ldr	r0, [sp]
700a5acc: 3001         	adds	r0, #0x1
700a5ace: 9000         	str	r0, [sp]
700a5ad0: e7ec         	b	0x700a5aac <_out_rev+0x3c> @ imm = #-0x28
;   }
700a5ad2: e7ff         	b	0x700a5ad4 <_out_rev+0x64> @ imm = #-0x2
;   while (len) {
700a5ad4: e7ff         	b	0x700a5ad6 <_out_rev+0x66> @ imm = #-0x2
700a5ad6: 9809         	ldr	r0, [sp, #0x24]
700a5ad8: b170         	cbz	r0, 0x700a5af8 <_out_rev+0x88> @ imm = #0x1c
700a5ada: e7ff         	b	0x700a5adc <_out_rev+0x6c> @ imm = #-0x2
;     out(buf[--len], buffer, idx++, maxlen);
700a5adc: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a5ae0: 9808         	ldr	r0, [sp, #0x20]
700a5ae2: 9909         	ldr	r1, [sp, #0x24]
700a5ae4: 3901         	subs	r1, #0x1
700a5ae6: 9109         	str	r1, [sp, #0x24]
700a5ae8: 5c40         	ldrb	r0, [r0, r1]
700a5aea: 9904         	ldr	r1, [sp, #0x10]
700a5aec: 9a03         	ldr	r2, [sp, #0xc]
700a5aee: 1c53         	adds	r3, r2, #0x1
700a5af0: 9303         	str	r3, [sp, #0xc]
700a5af2: 9b02         	ldr	r3, [sp, #0x8]
700a5af4: 47e0         	blx	r12
;   while (len) {
700a5af6: e7ee         	b	0x700a5ad6 <_out_rev+0x66> @ imm = #-0x24
;   if (flags & FLAGS_LEFT) {
700a5af8: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a5afc: 0780         	lsls	r0, r0, #0x1e
700a5afe: 2800         	cmp	r0, #0x0
700a5b00: d513         	bpl	0x700a5b2a <_out_rev+0xba> @ imm = #0x26
700a5b02: e7ff         	b	0x700a5b04 <_out_rev+0x94> @ imm = #-0x2
;     while (idx - start_idx < width) {
700a5b04: e7ff         	b	0x700a5b06 <_out_rev+0x96> @ imm = #-0x2
700a5b06: 9803         	ldr	r0, [sp, #0xc]
700a5b08: 9901         	ldr	r1, [sp, #0x4]
700a5b0a: 1a40         	subs	r0, r0, r1
700a5b0c: 990a         	ldr	r1, [sp, #0x28]
700a5b0e: 4288         	cmp	r0, r1
700a5b10: d20a         	bhs	0x700a5b28 <_out_rev+0xb8> @ imm = #0x14
700a5b12: e7ff         	b	0x700a5b14 <_out_rev+0xa4> @ imm = #-0x2
;       out(' ', buffer, idx++, maxlen);
700a5b14: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a5b18: 9904         	ldr	r1, [sp, #0x10]
700a5b1a: 9a03         	ldr	r2, [sp, #0xc]
700a5b1c: 1c50         	adds	r0, r2, #0x1
700a5b1e: 9003         	str	r0, [sp, #0xc]
700a5b20: 9b02         	ldr	r3, [sp, #0x8]
700a5b22: 2020         	movs	r0, #0x20
700a5b24: 47e0         	blx	r12
;     while (idx - start_idx < width) {
700a5b26: e7ee         	b	0x700a5b06 <_out_rev+0x96> @ imm = #-0x24
;   }
700a5b28: e7ff         	b	0x700a5b2a <_out_rev+0xba> @ imm = #-0x2
;   return idx;
700a5b2a: 9803         	ldr	r0, [sp, #0xc]
700a5b2c: b006         	add	sp, #0x18
700a5b2e: bd80         	pop	{r7, pc}

700a5b30 <vTaskStartScheduler>:
; void vTaskStartScheduler(void) {
700a5b30: b580         	push	{r7, lr}
700a5b32: b088         	sub	sp, #0x20
700a5b34: 2000         	movs	r0, #0x0
;     StaticTask_t *pxIdleTaskTCBBuffer = NULL;
700a5b36: 9003         	str	r0, [sp, #0xc]
700a5b38: 9006         	str	r0, [sp, #0x18]
;     StackType_t *pxIdleTaskStackBuffer = NULL;
700a5b3a: 9005         	str	r0, [sp, #0x14]
700a5b3c: a806         	add	r0, sp, #0x18
700a5b3e: a905         	add	r1, sp, #0x14
700a5b40: aa04         	add	r2, sp, #0x10
;     vApplicationGetIdleTaskMemory(&pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer,
700a5b42: f007 fac5    	bl	0x700ad0d0 <vApplicationGetIdleTaskMemory> @ imm = #0x758a
700a5b46: 9b03         	ldr	r3, [sp, #0xc]
;         prvIdleTask, configIDLE_TASK_NAME, ulIdleTaskStackSize,
700a5b48: 9a04         	ldr	r2, [sp, #0x10]
;         pxIdleTaskStackBuffer,
700a5b4a: 9905         	ldr	r1, [sp, #0x14]
;         pxIdleTaskTCBBuffer); /*lint !e961 MISRA exception, justified as it is
700a5b4c: f8dd c018    	ldr.w	r12, [sp, #0x18]
;     xIdleTaskHandle = xTaskCreateStatic(
700a5b50: 4668         	mov	r0, sp
700a5b52: f8c0 c008    	str.w	r12, [r0, #0x8]
700a5b56: 6041         	str	r1, [r0, #0x4]
700a5b58: 6003         	str	r3, [r0]
700a5b5a: f24b 3011    	movw	r0, #0xb311
700a5b5e: f2c7 000a    	movt	r0, #0x700a
700a5b62: f640 11e8    	movw	r1, #0x9e8
700a5b66: f2c7 010b    	movt	r1, #0x700b
700a5b6a: f003 fe19    	bl	0x700a97a0 <xTaskCreateStatic> @ imm = #0x3c32
700a5b6e: 4601         	mov	r1, r0
700a5b70: f640 50e0    	movw	r0, #0xde0
700a5b74: f2c7 000b    	movt	r0, #0x700b
700a5b78: 6001         	str	r1, [r0]
;     if (xIdleTaskHandle != NULL) {
700a5b7a: 6800         	ldr	r0, [r0]
700a5b7c: b118         	cbz	r0, 0x700a5b86 <vTaskStartScheduler+0x56> @ imm = #0x6
700a5b7e: e7ff         	b	0x700a5b80 <vTaskStartScheduler+0x50> @ imm = #-0x2
700a5b80: 2001         	movs	r0, #0x1
;       xReturn = pdPASS;
700a5b82: 9007         	str	r0, [sp, #0x1c]
;     } else {
700a5b84: e002         	b	0x700a5b8c <vTaskStartScheduler+0x5c> @ imm = #0x4
700a5b86: 2000         	movs	r0, #0x0
;       xReturn = pdFAIL;
700a5b88: 9007         	str	r0, [sp, #0x1c]
700a5b8a: e7ff         	b	0x700a5b8c <vTaskStartScheduler+0x5c> @ imm = #-0x2
;     if (xReturn == pdPASS) {
700a5b8c: 9807         	ldr	r0, [sp, #0x1c]
700a5b8e: 2801         	cmp	r0, #0x1
700a5b90: d104         	bne	0x700a5b9c <vTaskStartScheduler+0x6c> @ imm = #0x8
700a5b92: e7ff         	b	0x700a5b94 <vTaskStartScheduler+0x64> @ imm = #-0x2
;       xReturn = xTimerCreateTimerTask();
700a5b94: f003 fb84    	bl	0x700a92a0 <xTimerCreateTimerTask> @ imm = #0x3708
700a5b98: 9007         	str	r0, [sp, #0x1c]
;     } else {
700a5b9a: e000         	b	0x700a5b9e <vTaskStartScheduler+0x6e> @ imm = #0x0
700a5b9c: e7ff         	b	0x700a5b9e <vTaskStartScheduler+0x6e> @ imm = #-0x2
;   if (xReturn == pdPASS) {
700a5b9e: 9807         	ldr	r0, [sp, #0x1c]
700a5ba0: 2801         	cmp	r0, #0x1
700a5ba2: d11d         	bne	0x700a5be0 <vTaskStartScheduler+0xb0> @ imm = #0x3a
700a5ba4: e7ff         	b	0x700a5ba6 <vTaskStartScheduler+0x76> @ imm = #-0x2
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700a5ba6: b672         	cpsid i
;     xNextTaskUnblockTime = portMAX_DELAY;
700a5ba8: f640 51e4    	movw	r1, #0xde4
700a5bac: f2c7 010b    	movt	r1, #0x700b
700a5bb0: f04f 30ff    	mov.w	r0, #0xffffffff
700a5bb4: 6008         	str	r0, [r1]
;     xSchedulerRunning = pdTRUE;
700a5bb6: f640 51f0    	movw	r1, #0xdf0
700a5bba: f2c7 010b    	movt	r1, #0x700b
700a5bbe: 2001         	movs	r0, #0x1
700a5bc0: 6008         	str	r0, [r1]
;     xTickCount = (TickType_t)configINITIAL_TICK_COUNT;
700a5bc2: f640 51f4    	movw	r1, #0xdf4
700a5bc6: f2c7 010b    	movt	r1, #0x700b
700a5bca: 2000         	movs	r0, #0x0
700a5bcc: 6008         	str	r0, [r1]
;     portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
700a5bce: f008 fb37    	bl	0x700ae240 <vPortConfigTimerForRunTimeStats> @ imm = #0x866e
;     if (xPortStartScheduler() != pdFALSE) {
700a5bd2: f007 feed    	bl	0x700ad9b0 <xPortStartScheduler> @ imm = #0x7dda
700a5bd6: b108         	cbz	r0, 0x700a5bdc <vTaskStartScheduler+0xac> @ imm = #0x2
700a5bd8: e7ff         	b	0x700a5bda <vTaskStartScheduler+0xaa> @ imm = #-0x2
;     } else {
700a5bda: e000         	b	0x700a5bde <vTaskStartScheduler+0xae> @ imm = #0x0
700a5bdc: e7ff         	b	0x700a5bde <vTaskStartScheduler+0xae> @ imm = #-0x2
;   } else {
700a5bde: e000         	b	0x700a5be2 <vTaskStartScheduler+0xb2> @ imm = #0x0
700a5be0: e7ff         	b	0x700a5be2 <vTaskStartScheduler+0xb2> @ imm = #-0x2
;   (void)uxTopUsedPriority;
700a5be2: f640 2024    	movw	r0, #0xa24
700a5be6: f2c7 000b    	movt	r0, #0x700b
700a5bea: 6800         	ldr	r0, [r0]
; }
700a5bec: b008         	add	sp, #0x20
700a5bee: bd80         	pop	{r7, pc}

700a5bf0 <PMU_profilePrintEntry>:
; void PMU_profilePrintEntry(const char *name) {
700a5bf0: b580         	push	{r7, lr}
700a5bf2: b086         	sub	sp, #0x18
700a5bf4: 9005         	str	r0, [sp, #0x14]
700a5bf6: 2000         	movs	r0, #0x0
;   for (i = 0; i < gProfileObject.logIndex; i++) {
700a5bf8: 9004         	str	r0, [sp, #0x10]
700a5bfa: e7ff         	b	0x700a5bfc <PMU_profilePrintEntry+0xc> @ imm = #-0x2
700a5bfc: 9804         	ldr	r0, [sp, #0x10]
700a5bfe: f243 0180    	movw	r1, #0x3080
700a5c02: f2c7 0108    	movt	r1, #0x7008
700a5c06: 6809         	ldr	r1, [r1]
700a5c08: 4288         	cmp	r0, r1
700a5c0a: d24d         	bhs	0x700a5ca8 <PMU_profilePrintEntry+0xb8> @ imm = #0x9a
700a5c0c: e7ff         	b	0x700a5c0e <PMU_profilePrintEntry+0x1e> @ imm = #-0x2
;     PMU_ProfilePoint *p = &gProfileObject.point[i];
700a5c0e: 9804         	ldr	r0, [sp, #0x10]
700a5c10: f243 0280    	movw	r2, #0x3080
700a5c14: f2c7 0208    	movt	r2, #0x7008
700a5c18: 2134         	movs	r1, #0x34
700a5c1a: fb00 2001    	mla	r0, r0, r1, r2
700a5c1e: 300c         	adds	r0, #0xc
700a5c20: 9002         	str	r0, [sp, #0x8]
;     if (strcmp(name, p->name) == 0) {
700a5c22: 9805         	ldr	r0, [sp, #0x14]
700a5c24: 9902         	ldr	r1, [sp, #0x8]
700a5c26: 6b09         	ldr	r1, [r1, #0x30]
700a5c28: f7f5 e9ca    	blx	0x7009afc0 <strcmp>     @ imm = #-0xac6c
700a5c2c: bbb8         	cbnz	r0, 0x700a5c9e <PMU_profilePrintEntry+0xae> @ imm = #0x6e
700a5c2e: e7ff         	b	0x700a5c30 <PMU_profilePrintEntry+0x40> @ imm = #-0x2
;       DebugP_log("Profile Point: %-32s\r\n", p->name);
700a5c30: 9802         	ldr	r0, [sp, #0x8]
700a5c32: 6b02         	ldr	r2, [r0, #0x30]
700a5c34: f240 21eb    	movw	r1, #0x2eb
700a5c38: f2c7 010b    	movt	r1, #0x700b
700a5c3c: 2001         	movs	r0, #0x1
700a5c3e: 9001         	str	r0, [sp, #0x4]
700a5c40: f002 fab6    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #0x256c
700a5c44: 9801         	ldr	r0, [sp, #0x4]
;       DebugP_log("Cycle Count: %lu\r\n", p->cycleCount.value);
700a5c46: 9902         	ldr	r1, [sp, #0x8]
700a5c48: 6aca         	ldr	r2, [r1, #0x2c]
700a5c4a: f240 3191    	movw	r1, #0x391
700a5c4e: f2c7 010b    	movt	r1, #0x700b
700a5c52: f002 faad    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #0x255a
700a5c56: 2000         	movs	r0, #0x0
;       for (j = 0; j < PMU_MAX_EVENT_COUNTERS; j++) {
700a5c58: 9003         	str	r0, [sp, #0xc]
700a5c5a: e7ff         	b	0x700a5c5c <PMU_profilePrintEntry+0x6c> @ imm = #-0x2
700a5c5c: 9803         	ldr	r0, [sp, #0xc]
700a5c5e: 2802         	cmp	r0, #0x2
700a5c60: d815         	bhi	0x700a5c8e <PMU_profilePrintEntry+0x9e> @ imm = #0x2a
700a5c62: e7ff         	b	0x700a5c64 <PMU_profilePrintEntry+0x74> @ imm = #-0x2
;         DebugP_log("%s Count: %lu\r\n", p->events[j].name, p->events[j].value);
700a5c64: 9902         	ldr	r1, [sp, #0x8]
700a5c66: 9803         	ldr	r0, [sp, #0xc]
700a5c68: eb00 0240    	add.w	r2, r0, r0, lsl #1
700a5c6c: eb01 0082    	add.w	r0, r1, r2, lsl #2
700a5c70: f851 2022    	ldr.w	r2, [r1, r2, lsl #2]
700a5c74: 6883         	ldr	r3, [r0, #0x8]
700a5c76: f240 417b    	movw	r1, #0x47b
700a5c7a: f2c7 010b    	movt	r1, #0x700b
700a5c7e: 2001         	movs	r0, #0x1
700a5c80: f002 fa96    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #0x252c
;       }
700a5c84: e7ff         	b	0x700a5c86 <PMU_profilePrintEntry+0x96> @ imm = #-0x2
;       for (j = 0; j < PMU_MAX_EVENT_COUNTERS; j++) {
700a5c86: 9803         	ldr	r0, [sp, #0xc]
700a5c88: 3001         	adds	r0, #0x1
700a5c8a: 9003         	str	r0, [sp, #0xc]
700a5c8c: e7e6         	b	0x700a5c5c <PMU_profilePrintEntry+0x6c> @ imm = #-0x34
;       DebugP_log("\r\n");
700a5c8e: f240 11c9    	movw	r1, #0x1c9
700a5c92: f2c7 010b    	movt	r1, #0x700b
700a5c96: 2001         	movs	r0, #0x1
700a5c98: f002 fa8a    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #0x2514
;       break;
700a5c9c: e004         	b	0x700a5ca8 <PMU_profilePrintEntry+0xb8> @ imm = #0x8
;   }
700a5c9e: e7ff         	b	0x700a5ca0 <PMU_profilePrintEntry+0xb0> @ imm = #-0x2
;   for (i = 0; i < gProfileObject.logIndex; i++) {
700a5ca0: 9804         	ldr	r0, [sp, #0x10]
700a5ca2: 3001         	adds	r0, #0x1
700a5ca4: 9004         	str	r0, [sp, #0x10]
700a5ca6: e7a9         	b	0x700a5bfc <PMU_profilePrintEntry+0xc> @ imm = #-0xae
; }
700a5ca8: b006         	add	sp, #0x18
700a5caa: bd80         	pop	{r7, pc}
700a5cac: 0000         	movs	r0, r0
700a5cae: 0000         	movs	r0, r0

700a5cb0 <prvSwitchTimerLists>:
;     {
700a5cb0: b580         	push	{r7, lr}
700a5cb2: b086         	sub	sp, #0x18
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
700a5cb4: e7ff         	b	0x700a5cb6 <prvSwitchTimerLists+0x6> @ imm = #-0x2
700a5cb6: f644 50ac    	movw	r0, #0x4dac
700a5cba: f2c7 0008    	movt	r0, #0x7008
700a5cbe: 6800         	ldr	r0, [r0]
700a5cc0: 6800         	ldr	r0, [r0]
700a5cc2: 2800         	cmp	r0, #0x0
700a5cc4: d040         	beq	0x700a5d48 <prvSwitchTimerLists+0x98> @ imm = #0x80
700a5cc6: e7ff         	b	0x700a5cc8 <prvSwitchTimerLists+0x18> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
700a5cc8: f644 50ac    	movw	r0, #0x4dac
700a5ccc: f2c7 0008    	movt	r0, #0x7008
700a5cd0: 6801         	ldr	r1, [r0]
700a5cd2: 68c9         	ldr	r1, [r1, #0xc]
700a5cd4: 6809         	ldr	r1, [r1]
700a5cd6: 9105         	str	r1, [sp, #0x14]
;             pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
700a5cd8: 6800         	ldr	r0, [r0]
700a5cda: 68c0         	ldr	r0, [r0, #0xc]
700a5cdc: 68c0         	ldr	r0, [r0, #0xc]
700a5cde: 9002         	str	r0, [sp, #0x8]
;             ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a5ce0: 9802         	ldr	r0, [sp, #0x8]
700a5ce2: 3004         	adds	r0, #0x4
700a5ce4: f005 ff04    	bl	0x700abaf0 <uxListRemove> @ imm = #0x5e08
;             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a5ce8: 9802         	ldr	r0, [sp, #0x8]
700a5cea: 6a01         	ldr	r1, [r0, #0x20]
700a5cec: 4788         	blx	r1
;             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a5cee: 9802         	ldr	r0, [sp, #0x8]
700a5cf0: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a5cf4: 0740         	lsls	r0, r0, #0x1d
700a5cf6: 2800         	cmp	r0, #0x0
700a5cf8: d524         	bpl	0x700a5d44 <prvSwitchTimerLists+0x94> @ imm = #0x48
700a5cfa: e7ff         	b	0x700a5cfc <prvSwitchTimerLists+0x4c> @ imm = #-0x2
;                 xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
700a5cfc: 9805         	ldr	r0, [sp, #0x14]
700a5cfe: 9902         	ldr	r1, [sp, #0x8]
700a5d00: 6989         	ldr	r1, [r1, #0x18]
700a5d02: 4408         	add	r0, r1
700a5d04: 9004         	str	r0, [sp, #0x10]
;                 if( xReloadTime > xNextExpireTime )
700a5d06: 9804         	ldr	r0, [sp, #0x10]
700a5d08: 9905         	ldr	r1, [sp, #0x14]
700a5d0a: 4288         	cmp	r0, r1
700a5d0c: d90f         	bls	0x700a5d2e <prvSwitchTimerLists+0x7e> @ imm = #0x1e
700a5d0e: e7ff         	b	0x700a5d10 <prvSwitchTimerLists+0x60> @ imm = #-0x2
;                     listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
700a5d10: 9804         	ldr	r0, [sp, #0x10]
700a5d12: 9902         	ldr	r1, [sp, #0x8]
700a5d14: 6048         	str	r0, [r1, #0x4]
;                     listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
700a5d16: 9802         	ldr	r0, [sp, #0x8]
700a5d18: 6100         	str	r0, [r0, #0x10]
;                     vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
700a5d1a: f644 50ac    	movw	r0, #0x4dac
700a5d1e: f2c7 0008    	movt	r0, #0x7008
700a5d22: 6800         	ldr	r0, [r0]
700a5d24: 9902         	ldr	r1, [sp, #0x8]
700a5d26: 3104         	adds	r1, #0x4
700a5d28: f003 ff3a    	bl	0x700a9ba0 <vListInsert> @ imm = #0x3e74
;                 }
700a5d2c: e009         	b	0x700a5d42 <prvSwitchTimerLists+0x92> @ imm = #0x12
;                     xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
700a5d2e: 9802         	ldr	r0, [sp, #0x8]
700a5d30: 9a05         	ldr	r2, [sp, #0x14]
700a5d32: 4669         	mov	r1, sp
700a5d34: 2300         	movs	r3, #0x0
700a5d36: 600b         	str	r3, [r1]
700a5d38: 4619         	mov	r1, r3
700a5d3a: f002 f949    	bl	0x700a7fd0 <xTimerGenericCommand> @ imm = #0x2292
700a5d3e: 9001         	str	r0, [sp, #0x4]
700a5d40: e7ff         	b	0x700a5d42 <prvSwitchTimerLists+0x92> @ imm = #-0x2
;             }
700a5d42: e000         	b	0x700a5d46 <prvSwitchTimerLists+0x96> @ imm = #0x0
700a5d44: e7ff         	b	0x700a5d46 <prvSwitchTimerLists+0x96> @ imm = #-0x2
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
700a5d46: e7b6         	b	0x700a5cb6 <prvSwitchTimerLists+0x6> @ imm = #-0x94
;         pxTemp = pxCurrentTimerList;
700a5d48: f644 52ac    	movw	r2, #0x4dac
700a5d4c: f2c7 0208    	movt	r2, #0x7008
700a5d50: 6810         	ldr	r0, [r2]
700a5d52: 9003         	str	r0, [sp, #0xc]
;         pxCurrentTimerList = pxOverflowTimerList;
700a5d54: f644 51b8    	movw	r1, #0x4db8
700a5d58: f2c7 0108    	movt	r1, #0x7008
700a5d5c: 6808         	ldr	r0, [r1]
700a5d5e: 6010         	str	r0, [r2]
;         pxOverflowTimerList = pxTemp;
700a5d60: 9803         	ldr	r0, [sp, #0xc]
700a5d62: 6008         	str	r0, [r1]
;     }
700a5d64: b006         	add	sp, #0x18
700a5d66: bd80         	pop	{r7, pc}
		...

700a5d70 <CSL_pktdmaAccessChanPeerReg>:
; {
700a5d70: b580         	push	{r7, lr}
700a5d72: b088         	sub	sp, #0x20
700a5d74: 4684         	mov	r12, r0
700a5d76: 980b         	ldr	r0, [sp, #0x2c]
700a5d78: f8dd e028    	ldr.w	lr, [sp, #0x28]
700a5d7c: f8cd c01c    	str.w	r12, [sp, #0x1c]
700a5d80: 9106         	str	r1, [sp, #0x18]
700a5d82: 9205         	str	r2, [sp, #0x14]
700a5d84: 9304         	str	r3, [sp, #0x10]
700a5d86: f88d 000f    	strb.w	r0, [sp, #0xf]
700a5d8a: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a5d8c: 9002         	str	r0, [sp, #0x8]
;     if( (pCfg == NULL) || (pVal == NULL) || (CSL_pktdmaIsValidChanIdx( pCfg, chanIdx, chanDir) == (bool)false) )
700a5d8e: 9807         	ldr	r0, [sp, #0x1c]
700a5d90: b150         	cbz	r0, 0x700a5da8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #0x14
700a5d92: e7ff         	b	0x700a5d94 <CSL_pktdmaAccessChanPeerReg+0x24> @ imm = #-0x2
700a5d94: 9804         	ldr	r0, [sp, #0x10]
700a5d96: b138         	cbz	r0, 0x700a5da8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #0xe
700a5d98: e7ff         	b	0x700a5d9a <CSL_pktdmaAccessChanPeerReg+0x2a> @ imm = #-0x2
700a5d9a: 9807         	ldr	r0, [sp, #0x1c]
700a5d9c: 9906         	ldr	r1, [sp, #0x18]
700a5d9e: 9a0a         	ldr	r2, [sp, #0x28]
700a5da0: f005 f9f6    	bl	0x700ab190 <CSL_pktdmaIsValidChanIdx> @ imm = #0x53ec
700a5da4: b920         	cbnz	r0, 0x700a5db0 <CSL_pktdmaAccessChanPeerReg+0x40> @ imm = #0x8
700a5da6: e7ff         	b	0x700a5da8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #-0x2
700a5da8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a5dac: 9002         	str	r0, [sp, #0x8]
;     }
700a5dae: e037         	b	0x700a5e20 <CSL_pktdmaAccessChanPeerReg+0xb0> @ imm = #0x6e
;         if( regIdx < CSL_PKTDMA_NUM_PEER_REGS )
700a5db0: 9805         	ldr	r0, [sp, #0x14]
700a5db2: 280f         	cmp	r0, #0xf
700a5db4: d82f         	bhi	0x700a5e16 <CSL_pktdmaAccessChanPeerReg+0xa6> @ imm = #0x5e
700a5db6: e7ff         	b	0x700a5db8 <CSL_pktdmaAccessChanPeerReg+0x48> @ imm = #-0x2
;             if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700a5db8: 980a         	ldr	r0, [sp, #0x28]
700a5dba: b960         	cbnz	r0, 0x700a5dd6 <CSL_pktdmaAccessChanPeerReg+0x66> @ imm = #0x18
700a5dbc: e7ff         	b	0x700a5dbe <CSL_pktdmaAccessChanPeerReg+0x4e> @ imm = #-0x2
;                 pPeerReg = (uint32_t *)(((uintptr_t)pCfg->pTxChanRtRegs) + (uintptr_t)CSL_PKTDMA_TXCRT_CHAN_PEER0(chanIdx) + ((uintptr_t)regIdx * 0x4U));
700a5dbe: 9807         	ldr	r0, [sp, #0x1c]
700a5dc0: 6900         	ldr	r0, [r0, #0x10]
700a5dc2: 9906         	ldr	r1, [sp, #0x18]
700a5dc4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a5dc8: 9905         	ldr	r1, [sp, #0x14]
700a5dca: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a5dce: f500 7000    	add.w	r0, r0, #0x200
700a5dd2: 9001         	str	r0, [sp, #0x4]
;             }
700a5dd4: e00b         	b	0x700a5dee <CSL_pktdmaAccessChanPeerReg+0x7e> @ imm = #0x16
;                 pPeerReg = (uint32_t *)(((uintptr_t)pCfg->pRxChanRtRegs) + (uintptr_t)CSL_PKTDMA_RXCRT_CHAN_PEER0(chanIdx) + ((uintptr_t)regIdx * 0x4U));
700a5dd6: 9807         	ldr	r0, [sp, #0x1c]
700a5dd8: 6940         	ldr	r0, [r0, #0x14]
700a5dda: 9906         	ldr	r1, [sp, #0x18]
700a5ddc: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a5de0: 9905         	ldr	r1, [sp, #0x14]
700a5de2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a5de6: f500 7000    	add.w	r0, r0, #0x200
700a5dea: 9001         	str	r0, [sp, #0x4]
700a5dec: e7ff         	b	0x700a5dee <CSL_pktdmaAccessChanPeerReg+0x7e> @ imm = #-0x2
;             if( bRdAccess == (bool)true )
700a5dee: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a5df2: 07c0         	lsls	r0, r0, #0x1f
700a5df4: b130         	cbz	r0, 0x700a5e04 <CSL_pktdmaAccessChanPeerReg+0x94> @ imm = #0xc
700a5df6: e7ff         	b	0x700a5df8 <CSL_pktdmaAccessChanPeerReg+0x88> @ imm = #-0x2
;                 *pVal = CSL_REG32_RD( pPeerReg );
700a5df8: 9801         	ldr	r0, [sp, #0x4]
700a5dfa: f008 f949    	bl	0x700ae090 <CSL_REG32_RD_RAW> @ imm = #0x8292
700a5dfe: 9904         	ldr	r1, [sp, #0x10]
700a5e00: 6008         	str	r0, [r1]
;             }
700a5e02: e005         	b	0x700a5e10 <CSL_pktdmaAccessChanPeerReg+0xa0> @ imm = #0xa
;                 CSL_REG32_WR( pPeerReg, *pVal );
700a5e04: 9801         	ldr	r0, [sp, #0x4]
700a5e06: 9904         	ldr	r1, [sp, #0x10]
700a5e08: 6809         	ldr	r1, [r1]
700a5e0a: f008 f899    	bl	0x700adf40 <CSL_REG32_WR_RAW> @ imm = #0x8132
700a5e0e: e7ff         	b	0x700a5e10 <CSL_pktdmaAccessChanPeerReg+0xa0> @ imm = #-0x2
700a5e10: 2000         	movs	r0, #0x0
;             retVal = CSL_PASS;
700a5e12: 9002         	str	r0, [sp, #0x8]
;         }
700a5e14: e003         	b	0x700a5e1e <CSL_pktdmaAccessChanPeerReg+0xae> @ imm = #0x6
700a5e16: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = CSL_EFAIL;
700a5e1a: 9002         	str	r0, [sp, #0x8]
700a5e1c: e7ff         	b	0x700a5e1e <CSL_pktdmaAccessChanPeerReg+0xae> @ imm = #-0x2
700a5e1e: e7ff         	b	0x700a5e20 <CSL_pktdmaAccessChanPeerReg+0xb0> @ imm = #-0x2
;     return retVal;
700a5e20: 9802         	ldr	r0, [sp, #0x8]
700a5e22: b008         	add	sp, #0x20
700a5e24: bd80         	pop	{r7, pc}
		...
700a5e2e: 0000         	movs	r0, r0

700a5e30 <UART_fifoWrite>:
; {
700a5e30: b580         	push	{r7, lr}
700a5e32: b08c         	sub	sp, #0x30
700a5e34: 900b         	str	r0, [sp, #0x2c]
700a5e36: 910a         	str	r1, [sp, #0x28]
700a5e38: 9209         	str	r2, [sp, #0x24]
;     uint32_t tempWriteSizeRemaining = writeSizeRemaining;
700a5e3a: 9809         	ldr	r0, [sp, #0x24]
700a5e3c: 9008         	str	r0, [sp, #0x20]
;     uint32_t size                  = tempWriteSizeRemaining;
700a5e3e: 9808         	ldr	r0, [sp, #0x20]
700a5e40: 9007         	str	r0, [sp, #0x1c]
;     const uint8_t *tempBuffer = buffer;
700a5e42: 980a         	ldr	r0, [sp, #0x28]
700a5e44: 9006         	str	r0, [sp, #0x18]
700a5e46: 2000         	movs	r0, #0x0
;     uint32_t lineStatus            = 0U;
700a5e48: 9005         	str	r0, [sp, #0x14]
;     uint32_t tempChunksize         = 0U;
700a5e4a: 9004         	str	r0, [sp, #0x10]
700a5e4c: f640 30b8    	movw	r0, #0xbb8
;     int32_t  maxTrialCount         = (int32_t) UART_TRANSMITEMPTY_TRIALCOUNT;
700a5e50: 9003         	str	r0, [sp, #0xc]
700a5e52: 2040         	movs	r0, #0x40
;     tempChunksize = UART_FIFO_SIZE;
700a5e54: 9004         	str	r0, [sp, #0x10]
;     do
700a5e56: e7ff         	b	0x700a5e58 <UART_fifoWrite+0x28> @ imm = #-0x2
;         lineStatus = (uint32_t) UART_readLineStatus(hUart->baseAddr);
700a5e58: 980b         	ldr	r0, [sp, #0x2c]
700a5e5a: 6800         	ldr	r0, [r0]
700a5e5c: f005 ff10    	bl	0x700abc80 <UART_readLineStatus> @ imm = #0x5e20
700a5e60: 9005         	str	r0, [sp, #0x14]
;         maxTrialCount--;
700a5e62: 9803         	ldr	r0, [sp, #0xc]
700a5e64: 3801         	subs	r0, #0x1
700a5e66: 9003         	str	r0, [sp, #0xc]
;     }
700a5e68: e7ff         	b	0x700a5e6a <UART_fifoWrite+0x3a> @ imm = #-0x2
;                        UART_LSR_TX_FIFO_E_MASK) & lineStatus))
700a5e6a: 9805         	ldr	r0, [sp, #0x14]
700a5e6c: f000 0160    	and	r1, r0, #0x60
700a5e70: 2000         	movs	r0, #0x0
;            && (0 < maxTrialCount));
700a5e72: 2960         	cmp	r1, #0x60
700a5e74: 9002         	str	r0, [sp, #0x8]
700a5e76: d007         	beq	0x700a5e88 <UART_fifoWrite+0x58> @ imm = #0xe
700a5e78: e7ff         	b	0x700a5e7a <UART_fifoWrite+0x4a> @ imm = #-0x2
700a5e7a: 9903         	ldr	r1, [sp, #0xc]
700a5e7c: 2000         	movs	r0, #0x0
700a5e7e: 2900         	cmp	r1, #0x0
700a5e80: bfc8         	it	gt
700a5e82: 2001         	movgt	r0, #0x1
700a5e84: 9002         	str	r0, [sp, #0x8]
700a5e86: e7ff         	b	0x700a5e88 <UART_fifoWrite+0x58> @ imm = #-0x2
700a5e88: 9802         	ldr	r0, [sp, #0x8]
;     }
700a5e8a: 07c0         	lsls	r0, r0, #0x1f
700a5e8c: 2800         	cmp	r0, #0x0
700a5e8e: d1e3         	bne	0x700a5e58 <UART_fifoWrite+0x28> @ imm = #-0x3a
700a5e90: e7ff         	b	0x700a5e92 <UART_fifoWrite+0x62> @ imm = #-0x2
;     if (maxTrialCount > 0)
700a5e92: 9803         	ldr	r0, [sp, #0xc]
700a5e94: 2801         	cmp	r0, #0x1
700a5e96: db21         	blt	0x700a5edc <UART_fifoWrite+0xac> @ imm = #0x42
700a5e98: e7ff         	b	0x700a5e9a <UART_fifoWrite+0x6a> @ imm = #-0x2
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a5e9a: e7ff         	b	0x700a5e9c <UART_fifoWrite+0x6c> @ imm = #-0x2
700a5e9c: 9904         	ldr	r1, [sp, #0x10]
700a5e9e: 2000         	movs	r0, #0x0
700a5ea0: 9001         	str	r0, [sp, #0x4]
700a5ea2: b131         	cbz	r1, 0x700a5eb2 <UART_fifoWrite+0x82> @ imm = #0xc
700a5ea4: e7ff         	b	0x700a5ea6 <UART_fifoWrite+0x76> @ imm = #-0x2
700a5ea6: 9808         	ldr	r0, [sp, #0x20]
700a5ea8: 2800         	cmp	r0, #0x0
700a5eaa: bf18         	it	ne
700a5eac: 2001         	movne	r0, #0x1
700a5eae: 9001         	str	r0, [sp, #0x4]
700a5eb0: e7ff         	b	0x700a5eb2 <UART_fifoWrite+0x82> @ imm = #-0x2
700a5eb2: 9801         	ldr	r0, [sp, #0x4]
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a5eb4: 07c0         	lsls	r0, r0, #0x1f
700a5eb6: b180         	cbz	r0, 0x700a5eda <UART_fifoWrite+0xaa> @ imm = #0x20
700a5eb8: e7ff         	b	0x700a5eba <UART_fifoWrite+0x8a> @ imm = #-0x2
;             UART_putChar(hUart->baseAddr, (*tempBuffer));
700a5eba: 980b         	ldr	r0, [sp, #0x2c]
700a5ebc: 6800         	ldr	r0, [r0]
700a5ebe: 9906         	ldr	r1, [sp, #0x18]
700a5ec0: 7809         	ldrb	r1, [r1]
700a5ec2: f007 fe95    	bl	0x700adbf0 <UART_putChar> @ imm = #0x7d2a
;             tempBuffer++;
700a5ec6: 9806         	ldr	r0, [sp, #0x18]
700a5ec8: 3001         	adds	r0, #0x1
700a5eca: 9006         	str	r0, [sp, #0x18]
;             tempWriteSizeRemaining--;
700a5ecc: 9808         	ldr	r0, [sp, #0x20]
700a5ece: 3801         	subs	r0, #0x1
700a5ed0: 9008         	str	r0, [sp, #0x20]
;             tempChunksize--;
700a5ed2: 9804         	ldr	r0, [sp, #0x10]
700a5ed4: 3801         	subs	r0, #0x1
700a5ed6: 9004         	str	r0, [sp, #0x10]
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a5ed8: e7e0         	b	0x700a5e9c <UART_fifoWrite+0x6c> @ imm = #-0x40
;     }
700a5eda: e7ff         	b	0x700a5edc <UART_fifoWrite+0xac> @ imm = #-0x2
;     return (size - tempWriteSizeRemaining);
700a5edc: 9807         	ldr	r0, [sp, #0x1c]
700a5ede: 9908         	ldr	r1, [sp, #0x20]
700a5ee0: 1a40         	subs	r0, r0, r1
700a5ee2: b00c         	add	sp, #0x30
700a5ee4: bd80         	pop	{r7, pc}
		...
700a5eee: 0000         	movs	r0, r0

700a5ef0 <xTaskRemoveFromEventList>:
; BaseType_t xTaskRemoveFromEventList(const List_t *const pxEventList) {
700a5ef0: b580         	push	{r7, lr}
700a5ef2: b084         	sub	sp, #0x10
700a5ef4: 9003         	str	r0, [sp, #0xc]
;   pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a5ef6: 9803         	ldr	r0, [sp, #0xc]
700a5ef8: 68c0         	ldr	r0, [r0, #0xc]
700a5efa: 68c0         	ldr	r0, [r0, #0xc]
700a5efc: 9002         	str	r0, [sp, #0x8]
;   (void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
700a5efe: 9802         	ldr	r0, [sp, #0x8]
700a5f00: 3018         	adds	r0, #0x18
700a5f02: f005 fdf5    	bl	0x700abaf0 <uxListRemove> @ imm = #0x5bea
;   if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a5f06: f640 50d4    	movw	r0, #0xdd4
700a5f0a: f2c7 000b    	movt	r0, #0x700b
700a5f0e: 6800         	ldr	r0, [r0]
700a5f10: bb30         	cbnz	r0, 0x700a5f60 <xTaskRemoveFromEventList+0x70> @ imm = #0x4c
700a5f12: e7ff         	b	0x700a5f14 <xTaskRemoveFromEventList+0x24> @ imm = #-0x2
;     (void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
700a5f14: 9802         	ldr	r0, [sp, #0x8]
700a5f16: 3004         	adds	r0, #0x4
700a5f18: f005 fdea    	bl	0x700abaf0 <uxListRemove> @ imm = #0x5bd4
;     prvAddTaskToReadyList(pxUnblockedTCB);
700a5f1c: 9802         	ldr	r0, [sp, #0x8]
700a5f1e: 6ac0         	ldr	r0, [r0, #0x2c]
700a5f20: f640 51dc    	movw	r1, #0xddc
700a5f24: f2c7 010b    	movt	r1, #0x700b
700a5f28: 6809         	ldr	r1, [r1]
700a5f2a: 4288         	cmp	r0, r1
700a5f2c: d908         	bls	0x700a5f40 <xTaskRemoveFromEventList+0x50> @ imm = #0x10
700a5f2e: e7ff         	b	0x700a5f30 <xTaskRemoveFromEventList+0x40> @ imm = #-0x2
700a5f30: 9802         	ldr	r0, [sp, #0x8]
700a5f32: 6ac0         	ldr	r0, [r0, #0x2c]
700a5f34: f640 51dc    	movw	r1, #0xddc
700a5f38: f2c7 010b    	movt	r1, #0x700b
700a5f3c: 6008         	str	r0, [r1]
700a5f3e: e7ff         	b	0x700a5f40 <xTaskRemoveFromEventList+0x50> @ imm = #-0x2
700a5f40: 9902         	ldr	r1, [sp, #0x8]
700a5f42: 6ac8         	ldr	r0, [r1, #0x2c]
700a5f44: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a5f48: f244 40f8    	movw	r0, #0x44f8
700a5f4c: f2c7 0008    	movt	r0, #0x7008
700a5f50: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a5f54: 3104         	adds	r1, #0x4
700a5f56: f006 fba3    	bl	0x700ac6a0 <vListInsertEnd> @ imm = #0x6746
;       prvResetNextTaskUnblockTime();
700a5f5a: f006 fb21    	bl	0x700ac5a0 <prvResetNextTaskUnblockTime> @ imm = #0x6642
;   } else {
700a5f5e: e009         	b	0x700a5f74 <xTaskRemoveFromEventList+0x84> @ imm = #0x12
;     vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
700a5f60: 9802         	ldr	r0, [sp, #0x8]
700a5f62: f100 0118    	add.w	r1, r0, #0x18
700a5f66: f644 5060    	movw	r0, #0x4d60
700a5f6a: f2c7 0008    	movt	r0, #0x7008
700a5f6e: f006 fb97    	bl	0x700ac6a0 <vListInsertEnd> @ imm = #0x672e
700a5f72: e7ff         	b	0x700a5f74 <xTaskRemoveFromEventList+0x84> @ imm = #-0x2
;   if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
700a5f74: 9802         	ldr	r0, [sp, #0x8]
700a5f76: 6ac0         	ldr	r0, [r0, #0x2c]
700a5f78: f640 51ac    	movw	r1, #0xdac
700a5f7c: f2c7 010b    	movt	r1, #0x700b
700a5f80: 6809         	ldr	r1, [r1]
700a5f82: 6ac9         	ldr	r1, [r1, #0x2c]
700a5f84: 4288         	cmp	r0, r1
700a5f86: d908         	bls	0x700a5f9a <xTaskRemoveFromEventList+0xaa> @ imm = #0x10
700a5f88: e7ff         	b	0x700a5f8a <xTaskRemoveFromEventList+0x9a> @ imm = #-0x2
700a5f8a: 2001         	movs	r0, #0x1
;     xReturn = pdTRUE;
700a5f8c: 9001         	str	r0, [sp, #0x4]
;     xYieldPending = pdTRUE;
700a5f8e: f640 6100    	movw	r1, #0xe00
700a5f92: f2c7 010b    	movt	r1, #0x700b
700a5f96: 6008         	str	r0, [r1]
;   } else {
700a5f98: e002         	b	0x700a5fa0 <xTaskRemoveFromEventList+0xb0> @ imm = #0x4
700a5f9a: 2000         	movs	r0, #0x0
;     xReturn = pdFALSE;
700a5f9c: 9001         	str	r0, [sp, #0x4]
700a5f9e: e7ff         	b	0x700a5fa0 <xTaskRemoveFromEventList+0xb0> @ imm = #-0x2
;   return xReturn;
700a5fa0: 9801         	ldr	r0, [sp, #0x4]
700a5fa2: b004         	add	sp, #0x10
700a5fa4: bd80         	pop	{r7, pc}
		...
700a5fae: 0000         	movs	r0, r0

700a5fb0 <Sciclient_getCurrentContext>:
; {
700a5fb0: b082         	sub	sp, #0x8
700a5fb2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700a5fb6: 200f         	movs	r0, #0xf
;     uint32_t retVal = SCICLIENT_CONTEXT_MAX_NUM;
700a5fb8: 9000         	str	r0, [sp]
;     if((TISCI_MSG_BOOT_NOTIFICATION == messageType) ||
700a5fba: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5fbe: 280a         	cmp	r0, #0xa
700a5fc0: d03e         	beq	0x700a6040 <Sciclient_getCurrentContext+0x90> @ imm = #0x7c
700a5fc2: e7ff         	b	0x700a5fc4 <Sciclient_getCurrentContext+0x14> @ imm = #-0x2
;        (TISCI_MSG_SEC_HANDOVER == messageType) ||
700a5fc4: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5fc8: f249 0130    	movw	r1, #0x9030
700a5fcc: 4288         	cmp	r0, r1
700a5fce: d037         	beq	0x700a6040 <Sciclient_getCurrentContext+0x90> @ imm = #0x6e
700a5fd0: e7ff         	b	0x700a5fd2 <Sciclient_getCurrentContext+0x22> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG == messageType) ||
700a5fd2: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5fd6: 280b         	cmp	r0, #0xb
700a5fd8: d032         	beq	0x700a6040 <Sciclient_getCurrentContext+0x90> @ imm = #0x64
700a5fda: e7ff         	b	0x700a5fdc <Sciclient_getCurrentContext+0x2c> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_RM == messageType) ||
700a5fdc: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5fe0: 280c         	cmp	r0, #0xc
700a5fe2: d02d         	beq	0x700a6040 <Sciclient_getCurrentContext+0x90> @ imm = #0x5a
700a5fe4: e7ff         	b	0x700a5fe6 <Sciclient_getCurrentContext+0x36> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_SECURITY == messageType) ||
700a5fe6: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5fea: 280d         	cmp	r0, #0xd
700a5fec: d028         	beq	0x700a6040 <Sciclient_getCurrentContext+0x90> @ imm = #0x50
700a5fee: e7ff         	b	0x700a5ff0 <Sciclient_getCurrentContext+0x40> @ imm = #-0x2
;        (TISCI_MSG_KEY_WRITER == messageType) ||
700a5ff0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5ff4: f249 0131    	movw	r1, #0x9031
700a5ff8: 4288         	cmp	r0, r1
700a5ffa: d021         	beq	0x700a6040 <Sciclient_getCurrentContext+0x90> @ imm = #0x42
700a5ffc: e7ff         	b	0x700a5ffe <Sciclient_getCurrentContext+0x4e> @ imm = #-0x2
;        (TISCI_MSG_READ_OTP_MMR == messageType) ||
700a5ffe: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a6002: f249 0122    	movw	r1, #0x9022
700a6006: 4288         	cmp	r0, r1
700a6008: d01a         	beq	0x700a6040 <Sciclient_getCurrentContext+0x90> @ imm = #0x34
700a600a: e7ff         	b	0x700a600c <Sciclient_getCurrentContext+0x5c> @ imm = #-0x2
;        (TISCI_MSG_WRITE_OTP_ROW == messageType) ||
700a600c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a6010: f249 0123    	movw	r1, #0x9023
700a6014: 4288         	cmp	r0, r1
700a6016: d013         	beq	0x700a6040 <Sciclient_getCurrentContext+0x90> @ imm = #0x26
700a6018: e7ff         	b	0x700a601a <Sciclient_getCurrentContext+0x6a> @ imm = #-0x2
;        (TISCI_MSG_READ_SWREV == messageType) ||
700a601a: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a601e: f249 0133    	movw	r1, #0x9033
700a6022: 4288         	cmp	r0, r1
700a6024: d00c         	beq	0x700a6040 <Sciclient_getCurrentContext+0x90> @ imm = #0x18
700a6026: e7ff         	b	0x700a6028 <Sciclient_getCurrentContext+0x78> @ imm = #-0x2
;        (TISCI_MSG_WRITE_SWREV == messageType) ||
700a6028: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a602c: f249 0132    	movw	r1, #0x9032
700a6030: 4288         	cmp	r0, r1
700a6032: d005         	beq	0x700a6040 <Sciclient_getCurrentContext+0x90> @ imm = #0xa
700a6034: e7ff         	b	0x700a6036 <Sciclient_getCurrentContext+0x86> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_PM == messageType))
700a6036: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
;     if((TISCI_MSG_BOOT_NOTIFICATION == messageType) ||
700a603a: 280e         	cmp	r0, #0xe
700a603c: d107         	bne	0x700a604e <Sciclient_getCurrentContext+0x9e> @ imm = #0xe
700a603e: e7ff         	b	0x700a6040 <Sciclient_getCurrentContext+0x90> @ imm = #-0x2
;         retVal = gSciclientHandle.secureContextId;
700a6040: f640 5000    	movw	r0, #0xd00
700a6044: f2c7 000b    	movt	r0, #0x700b
700a6048: 68c0         	ldr	r0, [r0, #0xc]
700a604a: 9000         	str	r0, [sp]
;     }
700a604c: e006         	b	0x700a605c <Sciclient_getCurrentContext+0xac> @ imm = #0xc
;         retVal = gSciclientHandle.nonSecureContextId;
700a604e: f640 5000    	movw	r0, #0xd00
700a6052: f2c7 000b    	movt	r0, #0x700b
700a6056: 6900         	ldr	r0, [r0, #0x10]
700a6058: 9000         	str	r0, [sp]
700a605a: e7ff         	b	0x700a605c <Sciclient_getCurrentContext+0xac> @ imm = #-0x2
;     return retVal;
700a605c: 9800         	ldr	r0, [sp]
700a605e: b002         	add	sp, #0x8
700a6060: 4770         	bx	lr
		...
700a606e: 0000         	movs	r0, r0

700a6070 <UART_init>:
; {
700a6070: b580         	push	{r7, lr}
700a6072: b086         	sub	sp, #0x18
700a6074: 2000         	movs	r0, #0x0
;     for (cnt = 0U; cnt < gUartConfigNum; cnt++)
700a6076: 9004         	str	r0, [sp, #0x10]
700a6078: e7ff         	b	0x700a607a <UART_init+0xa> @ imm = #-0x2
700a607a: 9804         	ldr	r0, [sp, #0x10]
700a607c: f640 51a0    	movw	r1, #0xda0
700a6080: f2c7 010b    	movt	r1, #0x700b
700a6084: 6809         	ldr	r1, [r1]
700a6086: 4288         	cmp	r0, r1
700a6088: d236         	bhs	0x700a60f8 <UART_init+0x88> @ imm = #0x6c
700a608a: e7ff         	b	0x700a608c <UART_init+0x1c> @ imm = #-0x2
;         object = gUartConfig[cnt].object;
700a608c: 9904         	ldr	r1, [sp, #0x10]
700a608e: f640 505c    	movw	r0, #0xd5c
700a6092: f2c7 000b    	movt	r0, #0x700b
700a6096: 9002         	str	r0, [sp, #0x8]
700a6098: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a609c: 6840         	ldr	r0, [r0, #0x4]
700a609e: 9003         	str	r0, [sp, #0xc]
;         DebugP_assert(NULL_PTR != object);
700a60a0: 9803         	ldr	r0, [sp, #0xc]
700a60a2: 2800         	cmp	r0, #0x0
700a60a4: bf18         	it	ne
700a60a6: 2001         	movne	r0, #0x1
700a60a8: f240 31ca    	movw	r1, #0x3ca
700a60ac: f2c7 010b    	movt	r1, #0x700b
700a60b0: 466a         	mov	r2, sp
700a60b2: 6011         	str	r1, [r2]
700a60b4: f240 31dd    	movw	r1, #0x3dd
700a60b8: f2c7 010b    	movt	r1, #0x700b
700a60bc: f240 5215    	movw	r2, #0x515
700a60c0: f2c7 020b    	movt	r2, #0x700b
700a60c4: 23bf         	movs	r3, #0xbf
700a60c6: f003 f82b    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x3056
;         (void)memset(object, 0, sizeof(UART_Object));
700a60ca: 9803         	ldr	r0, [sp, #0xc]
700a60cc: f44f 715a    	mov.w	r1, #0x368
700a60d0: f7f3 ebb0    	blx	0x70099834 <__aeabi_memclr8> @ imm = #-0xc8a0
700a60d4: 9802         	ldr	r0, [sp, #0x8]
;         gUartConfig[cnt].attrs->baseAddr = (uint32_t) AddrTranslateP_getLocalAddr((uint64_t)gUartConfig[cnt].attrs->baseAddr);
700a60d6: 9904         	ldr	r1, [sp, #0x10]
700a60d8: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
700a60dc: 6800         	ldr	r0, [r0]
700a60de: 2100         	movs	r1, #0x0
700a60e0: f7fd ff8e    	bl	0x700a4000 <AddrTranslateP_getLocalAddr> @ imm = #-0x20e4
700a60e4: 9902         	ldr	r1, [sp, #0x8]
700a60e6: 9a04         	ldr	r2, [sp, #0x10]
700a60e8: f851 1032    	ldr.w	r1, [r1, r2, lsl #3]
700a60ec: 6008         	str	r0, [r1]
;     }
700a60ee: e7ff         	b	0x700a60f0 <UART_init+0x80> @ imm = #-0x2
;     for (cnt = 0U; cnt < gUartConfigNum; cnt++)
700a60f0: 9804         	ldr	r0, [sp, #0x10]
700a60f2: 3001         	adds	r0, #0x1
700a60f4: 9004         	str	r0, [sp, #0x10]
700a60f6: e7c0         	b	0x700a607a <UART_init+0xa> @ imm = #-0x80
;     status = SemaphoreP_constructMutex(&gUartDrvObj.lockObj);
700a60f8: f640 20e0    	movw	r0, #0xae0
700a60fc: f2c7 000b    	movt	r0, #0x700b
700a6100: 3004         	adds	r0, #0x4
700a6102: f003 fca5    	bl	0x700a9a50 <SemaphoreP_constructMutex> @ imm = #0x394a
700a6106: 9005         	str	r0, [sp, #0x14]
;     if(SystemP_SUCCESS == status)
700a6108: 9805         	ldr	r0, [sp, #0x14]
700a610a: b938         	cbnz	r0, 0x700a611c <UART_init+0xac> @ imm = #0xe
700a610c: e7ff         	b	0x700a610e <UART_init+0x9e> @ imm = #-0x2
;         gUartDrvObj.lock = &gUartDrvObj.lockObj;
700a610e: f640 21e0    	movw	r1, #0xae0
700a6112: f2c7 010b    	movt	r1, #0x700b
700a6116: 1d08         	adds	r0, r1, #0x4
700a6118: 6008         	str	r0, [r1]
;     }
700a611a: e7ff         	b	0x700a611c <UART_init+0xac> @ imm = #-0x2
;     return;
700a611c: b006         	add	sp, #0x18
700a611e: bd80         	pop	{r7, pc}

700a6120 <Udma_chCheckParams>:
; {
700a6120: b084         	sub	sp, #0x10
700a6122: 9003         	str	r0, [sp, #0xc]
700a6124: 9102         	str	r1, [sp, #0x8]
700a6126: 9201         	str	r2, [sp, #0x4]
700a6128: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a612a: 9000         	str	r0, [sp]
;     if((chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA)
700a612c: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a6130: 0700         	lsls	r0, r0, #0x1c
700a6132: 2800         	cmp	r0, #0x0
700a6134: d513         	bpl	0x700a615e <Udma_chCheckParams+0x3e> @ imm = #0x26
700a6136: e7ff         	b	0x700a6138 <Udma_chCheckParams+0x18> @ imm = #-0x2
;         if((UDMA_DMA_CH_INVALID == chPrms->peerChNum) ||
700a6138: 9801         	ldr	r0, [sp, #0x4]
700a613a: 6840         	ldr	r0, [r0, #0x4]
700a613c: f510 3f80    	cmn.w	r0, #0x10000
700a6140: d008         	beq	0x700a6154 <Udma_chCheckParams+0x34> @ imm = #0x10
700a6142: e7ff         	b	0x700a6144 <Udma_chCheckParams+0x24> @ imm = #-0x2
;            (UDMA_DMA_CH_NA == chPrms->peerChNum))
700a6144: 9801         	ldr	r0, [sp, #0x4]
700a6146: 6840         	ldr	r0, [r0, #0x4]
700a6148: 2102         	movs	r1, #0x2
700a614a: f6cf 71ff    	movt	r1, #0xffff
;         if((UDMA_DMA_CH_INVALID == chPrms->peerChNum) ||
700a614e: 4288         	cmp	r0, r1
700a6150: d104         	bne	0x700a615c <Udma_chCheckParams+0x3c> @ imm = #0x8
700a6152: e7ff         	b	0x700a6154 <Udma_chCheckParams+0x34> @ imm = #-0x2
700a6154: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a6158: 9000         	str	r0, [sp]
;         }
700a615a: e7ff         	b	0x700a615c <Udma_chCheckParams+0x3c> @ imm = #-0x2
;     }
700a615c: e7ff         	b	0x700a615e <Udma_chCheckParams+0x3e> @ imm = #-0x2
;     if((chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
700a615e: f89d 0009    	ldrb.w	r0, [sp, #0x9]
700a6162: 07c0         	lsls	r0, r0, #0x1f
700a6164: b388         	cbz	r0, 0x700a61ca <Udma_chCheckParams+0xaa> @ imm = #0x62
700a6166: e7ff         	b	0x700a6168 <Udma_chCheckParams+0x48> @ imm = #-0x2
;         if(UDMA_MAPPED_GROUP_INVALID == chPrms->mappedChGrp)
700a6168: 9801         	ldr	r0, [sp, #0x4]
700a616a: 6880         	ldr	r0, [r0, #0x8]
700a616c: 2104         	movs	r1, #0x4
700a616e: f6cf 71ff    	movt	r1, #0xffff
700a6172: 4288         	cmp	r0, r1
700a6174: d104         	bne	0x700a6180 <Udma_chCheckParams+0x60> @ imm = #0x8
700a6176: e7ff         	b	0x700a6178 <Udma_chCheckParams+0x58> @ imm = #-0x2
700a6178: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a617c: 9000         	str	r0, [sp]
;         }
700a617e: e7ff         	b	0x700a6180 <Udma_chCheckParams+0x60> @ imm = #-0x2
;         if((chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a6180: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a6184: 07c0         	lsls	r0, r0, #0x1f
700a6186: b150         	cbz	r0, 0x700a619e <Udma_chCheckParams+0x7e> @ imm = #0x14
700a6188: e7ff         	b	0x700a618a <Udma_chCheckParams+0x6a> @ imm = #-0x2
;             if(chPrms->mappedChGrp >= UDMA_NUM_MAPPED_TX_GROUP)
700a618a: 9801         	ldr	r0, [sp, #0x4]
700a618c: 6880         	ldr	r0, [r0, #0x8]
700a618e: 2804         	cmp	r0, #0x4
700a6190: d304         	blo	0x700a619c <Udma_chCheckParams+0x7c> @ imm = #0x8
700a6192: e7ff         	b	0x700a6194 <Udma_chCheckParams+0x74> @ imm = #-0x2
700a6194: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a6198: 9000         	str	r0, [sp]
;             }
700a619a: e7ff         	b	0x700a619c <Udma_chCheckParams+0x7c> @ imm = #-0x2
;         }
700a619c: e7ff         	b	0x700a619e <Udma_chCheckParams+0x7e> @ imm = #-0x2
;         if((chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a619e: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a61a2: 0780         	lsls	r0, r0, #0x1e
700a61a4: 2800         	cmp	r0, #0x0
700a61a6: d50f         	bpl	0x700a61c8 <Udma_chCheckParams+0xa8> @ imm = #0x1e
700a61a8: e7ff         	b	0x700a61aa <Udma_chCheckParams+0x8a> @ imm = #-0x2
;             if((chPrms->mappedChGrp < UDMA_NUM_MAPPED_TX_GROUP) ||
700a61aa: 9801         	ldr	r0, [sp, #0x4]
700a61ac: 6880         	ldr	r0, [r0, #0x8]
700a61ae: 2804         	cmp	r0, #0x4
700a61b0: d305         	blo	0x700a61be <Udma_chCheckParams+0x9e> @ imm = #0xa
700a61b2: e7ff         	b	0x700a61b4 <Udma_chCheckParams+0x94> @ imm = #-0x2
;                (chPrms->mappedChGrp >= (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
700a61b4: 9801         	ldr	r0, [sp, #0x4]
700a61b6: 6880         	ldr	r0, [r0, #0x8]
;             if((chPrms->mappedChGrp < UDMA_NUM_MAPPED_TX_GROUP) ||
700a61b8: 2808         	cmp	r0, #0x8
700a61ba: d304         	blo	0x700a61c6 <Udma_chCheckParams+0xa6> @ imm = #0x8
700a61bc: e7ff         	b	0x700a61be <Udma_chCheckParams+0x9e> @ imm = #-0x2
700a61be: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a61c2: 9000         	str	r0, [sp]
;             }
700a61c4: e7ff         	b	0x700a61c6 <Udma_chCheckParams+0xa6> @ imm = #-0x2
;         }
700a61c6: e7ff         	b	0x700a61c8 <Udma_chCheckParams+0xa8> @ imm = #-0x2
;     }
700a61c8: e7ff         	b	0x700a61ca <Udma_chCheckParams+0xaa> @ imm = #-0x2
;     return (retVal);
700a61ca: 9800         	ldr	r0, [sp]
700a61cc: b004         	add	sp, #0x10
700a61ce: 4770         	bx	lr

700a61d0 <Udma_getMappedChRingAttributes>:
; {
700a61d0: b087         	sub	sp, #0x1c
700a61d2: 9006         	str	r0, [sp, #0x18]
700a61d4: 9105         	str	r1, [sp, #0x14]
700a61d6: 9204         	str	r2, [sp, #0x10]
700a61d8: 9303         	str	r3, [sp, #0xc]
700a61da: 2000         	movs	r0, #0x0
;     uint32_t index = 0U;
700a61dc: 9001         	str	r0, [sp, #0x4]
;     int32_t retVal = UDMA_SOK;
700a61de: 9000         	str	r0, [sp]
;     if(mappedGrp < UDMA_NUM_MAPPED_TX_GROUP) /* Mapped TX Channel */
700a61e0: 9805         	ldr	r0, [sp, #0x14]
700a61e2: 2803         	cmp	r0, #0x3
700a61e4: d81e         	bhi	0x700a6224 <Udma_getMappedChRingAttributes+0x54> @ imm = #0x3c
700a61e6: e7ff         	b	0x700a61e8 <Udma_getMappedChRingAttributes+0x18> @ imm = #-0x2
;         if((chNum < CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START) ||
700a61e8: 9804         	ldr	r0, [sp, #0x10]
700a61ea: 2810         	cmp	r0, #0x10
700a61ec: d304         	blo	0x700a61f8 <Udma_getMappedChRingAttributes+0x28> @ imm = #0x8
700a61ee: e7ff         	b	0x700a61f0 <Udma_getMappedChRingAttributes+0x20> @ imm = #-0x2
;            (chNum >= CSL_DMSS_PKTDMA_NUM_TX_CHANS))
700a61f0: 9804         	ldr	r0, [sp, #0x10]
;         if((chNum < CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START) ||
700a61f2: 282a         	cmp	r0, #0x2a
700a61f4: d304         	blo	0x700a6200 <Udma_getMappedChRingAttributes+0x30> @ imm = #0x8
700a61f6: e7ff         	b	0x700a61f8 <Udma_getMappedChRingAttributes+0x28> @ imm = #-0x2
700a61f8: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a61fc: 9000         	str	r0, [sp]
;         }
700a61fe: e7ff         	b	0x700a6200 <Udma_getMappedChRingAttributes+0x30> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
700a6200: 9800         	ldr	r0, [sp]
700a6202: b970         	cbnz	r0, 0x700a6222 <Udma_getMappedChRingAttributes+0x52> @ imm = #0x1c
700a6204: e7ff         	b	0x700a6206 <Udma_getMappedChRingAttributes+0x36> @ imm = #-0x2
;             index = chNum - CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START;
700a6206: 9804         	ldr	r0, [sp, #0x10]
700a6208: 3810         	subs	r0, #0x10
700a620a: 9001         	str	r0, [sp, #0x4]
;             mappedChRingAttributes = &gUdmaTxMappedChRingAttributes[index];
700a620c: 9801         	ldr	r0, [sp, #0x4]
700a620e: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a6212: f64f 1020    	movw	r0, #0xf920
700a6216: f2c7 000a    	movt	r0, #0x700a
700a621a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a621e: 9002         	str	r0, [sp, #0x8]
;         }
700a6220: e7ff         	b	0x700a6222 <Udma_getMappedChRingAttributes+0x52> @ imm = #-0x2
;     }
700a6222: e01d         	b	0x700a6260 <Udma_getMappedChRingAttributes+0x90> @ imm = #0x3a
;         if((chNum < CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START) ||
700a6224: 9804         	ldr	r0, [sp, #0x10]
700a6226: 2810         	cmp	r0, #0x10
700a6228: d304         	blo	0x700a6234 <Udma_getMappedChRingAttributes+0x64> @ imm = #0x8
700a622a: e7ff         	b	0x700a622c <Udma_getMappedChRingAttributes+0x5c> @ imm = #-0x2
;            (chNum >= CSL_DMSS_PKTDMA_NUM_RX_CHANS))
700a622c: 9804         	ldr	r0, [sp, #0x10]
;         if((chNum < CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START) ||
700a622e: 281d         	cmp	r0, #0x1d
700a6230: d304         	blo	0x700a623c <Udma_getMappedChRingAttributes+0x6c> @ imm = #0x8
700a6232: e7ff         	b	0x700a6234 <Udma_getMappedChRingAttributes+0x64> @ imm = #-0x2
700a6234: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a6238: 9000         	str	r0, [sp]
;         }
700a623a: e7ff         	b	0x700a623c <Udma_getMappedChRingAttributes+0x6c> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
700a623c: 9800         	ldr	r0, [sp]
700a623e: b970         	cbnz	r0, 0x700a625e <Udma_getMappedChRingAttributes+0x8e> @ imm = #0x1c
700a6240: e7ff         	b	0x700a6242 <Udma_getMappedChRingAttributes+0x72> @ imm = #-0x2
;             index = chNum - CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START;
700a6242: 9804         	ldr	r0, [sp, #0x10]
700a6244: 3810         	subs	r0, #0x10
700a6246: 9001         	str	r0, [sp, #0x4]
;             mappedChRingAttributes = &gUdmaRxMappedChRingAttributes[index];
700a6248: 9801         	ldr	r0, [sp, #0x4]
700a624a: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a624e: f64f 2058    	movw	r0, #0xfa58
700a6252: f2c7 000a    	movt	r0, #0x700a
700a6256: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a625a: 9002         	str	r0, [sp, #0x8]
;         }
700a625c: e7ff         	b	0x700a625e <Udma_getMappedChRingAttributes+0x8e> @ imm = #-0x2
700a625e: e7ff         	b	0x700a6260 <Udma_getMappedChRingAttributes+0x90> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a6260: 9800         	ldr	r0, [sp]
700a6262: b948         	cbnz	r0, 0x700a6278 <Udma_getMappedChRingAttributes+0xa8> @ imm = #0x12
700a6264: e7ff         	b	0x700a6266 <Udma_getMappedChRingAttributes+0x96> @ imm = #-0x2
;         (void) memcpy(chAttr, mappedChRingAttributes, sizeof (Udma_MappedChRingAttributes));
700a6266: 9903         	ldr	r1, [sp, #0xc]
700a6268: 9b02         	ldr	r3, [sp, #0x8]
700a626a: 6818         	ldr	r0, [r3]
700a626c: 685a         	ldr	r2, [r3, #0x4]
700a626e: 689b         	ldr	r3, [r3, #0x8]
700a6270: 608b         	str	r3, [r1, #0x8]
700a6272: 604a         	str	r2, [r1, #0x4]
700a6274: 6008         	str	r0, [r1]
;     }
700a6276: e7ff         	b	0x700a6278 <Udma_getMappedChRingAttributes+0xa8> @ imm = #-0x2
;     return(retVal);
700a6278: 9800         	ldr	r0, [sp]
700a627a: b007         	add	sp, #0x1c
700a627c: 4770         	bx	lr
700a627e: 0000         	movs	r0, r0

700a6280 <prvUnlockQueue>:
; {
700a6280: b580         	push	{r7, lr}
700a6282: b082         	sub	sp, #0x8
700a6284: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700a6286: f006 fca3    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0x6946
;         int8_t cTxLock = pxQueue->cTxLock;
700a628a: 9801         	ldr	r0, [sp, #0x4]
700a628c: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a6290: f88d 0003    	strb.w	r0, [sp, #0x3]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
700a6294: e7ff         	b	0x700a6296 <prvUnlockQueue+0x16> @ imm = #-0x2
700a6296: f99d 0003    	ldrsb.w	r0, [sp, #0x3]
700a629a: 2801         	cmp	r0, #0x1
700a629c: db16         	blt	0x700a62cc <prvUnlockQueue+0x4c> @ imm = #0x2c
700a629e: e7ff         	b	0x700a62a0 <prvUnlockQueue+0x20> @ imm = #-0x2
;                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a62a0: 9801         	ldr	r0, [sp, #0x4]
700a62a2: 6a40         	ldr	r0, [r0, #0x24]
700a62a4: b158         	cbz	r0, 0x700a62be <prvUnlockQueue+0x3e> @ imm = #0x16
700a62a6: e7ff         	b	0x700a62a8 <prvUnlockQueue+0x28> @ imm = #-0x2
;                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a62a8: 9801         	ldr	r0, [sp, #0x4]
700a62aa: 3024         	adds	r0, #0x24
700a62ac: f7ff fe20    	bl	0x700a5ef0 <xTaskRemoveFromEventList> @ imm = #-0x3c0
700a62b0: b118         	cbz	r0, 0x700a62ba <prvUnlockQueue+0x3a> @ imm = #0x6
700a62b2: e7ff         	b	0x700a62b4 <prvUnlockQueue+0x34> @ imm = #-0x2
;                             vTaskMissedYield();
700a62b4: f007 fed4    	bl	0x700ae060 <vTaskMissedYield> @ imm = #0x7da8
;                         }
700a62b8: e000         	b	0x700a62bc <prvUnlockQueue+0x3c> @ imm = #0x0
700a62ba: e7ff         	b	0x700a62bc <prvUnlockQueue+0x3c> @ imm = #-0x2
;                     }
700a62bc: e000         	b	0x700a62c0 <prvUnlockQueue+0x40> @ imm = #0x0
;                         break;
700a62be: e005         	b	0x700a62cc <prvUnlockQueue+0x4c> @ imm = #0xa
;             --cTxLock;
700a62c0: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a62c4: 3801         	subs	r0, #0x1
700a62c6: f88d 0003    	strb.w	r0, [sp, #0x3]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
700a62ca: e7e4         	b	0x700a6296 <prvUnlockQueue+0x16> @ imm = #-0x38
;         pxQueue->cTxLock = queueUNLOCKED;
700a62cc: 9901         	ldr	r1, [sp, #0x4]
700a62ce: 20ff         	movs	r0, #0xff
700a62d0: f881 0045    	strb.w	r0, [r1, #0x45]
;     taskEXIT_CRITICAL();
700a62d4: f005 fcfc    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x59f8
;     taskENTER_CRITICAL();
700a62d8: f006 fc7a    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0x68f4
;         int8_t cRxLock = pxQueue->cRxLock;
700a62dc: 9801         	ldr	r0, [sp, #0x4]
700a62de: f890 0044    	ldrb.w	r0, [r0, #0x44]
700a62e2: f88d 0002    	strb.w	r0, [sp, #0x2]
;         while( cRxLock > queueLOCKED_UNMODIFIED )
700a62e6: e7ff         	b	0x700a62e8 <prvUnlockQueue+0x68> @ imm = #-0x2
700a62e8: f99d 0002    	ldrsb.w	r0, [sp, #0x2]
700a62ec: 2801         	cmp	r0, #0x1
700a62ee: db16         	blt	0x700a631e <prvUnlockQueue+0x9e> @ imm = #0x2c
700a62f0: e7ff         	b	0x700a62f2 <prvUnlockQueue+0x72> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a62f2: 9801         	ldr	r0, [sp, #0x4]
700a62f4: 6900         	ldr	r0, [r0, #0x10]
700a62f6: b180         	cbz	r0, 0x700a631a <prvUnlockQueue+0x9a> @ imm = #0x20
700a62f8: e7ff         	b	0x700a62fa <prvUnlockQueue+0x7a> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a62fa: 9801         	ldr	r0, [sp, #0x4]
700a62fc: 3010         	adds	r0, #0x10
700a62fe: f7ff fdf7    	bl	0x700a5ef0 <xTaskRemoveFromEventList> @ imm = #-0x412
700a6302: b118         	cbz	r0, 0x700a630c <prvUnlockQueue+0x8c> @ imm = #0x6
700a6304: e7ff         	b	0x700a6306 <prvUnlockQueue+0x86> @ imm = #-0x2
;                     vTaskMissedYield();
700a6306: f007 feab    	bl	0x700ae060 <vTaskMissedYield> @ imm = #0x7d56
;                 }
700a630a: e000         	b	0x700a630e <prvUnlockQueue+0x8e> @ imm = #0x0
700a630c: e7ff         	b	0x700a630e <prvUnlockQueue+0x8e> @ imm = #-0x2
;                 --cRxLock;
700a630e: f89d 0002    	ldrb.w	r0, [sp, #0x2]
700a6312: 3801         	subs	r0, #0x1
700a6314: f88d 0002    	strb.w	r0, [sp, #0x2]
;             }
700a6318: e000         	b	0x700a631c <prvUnlockQueue+0x9c> @ imm = #0x0
;                 break;
700a631a: e000         	b	0x700a631e <prvUnlockQueue+0x9e> @ imm = #0x0
;         while( cRxLock > queueLOCKED_UNMODIFIED )
700a631c: e7e4         	b	0x700a62e8 <prvUnlockQueue+0x68> @ imm = #-0x38
;         pxQueue->cRxLock = queueUNLOCKED;
700a631e: 9901         	ldr	r1, [sp, #0x4]
700a6320: 20ff         	movs	r0, #0xff
700a6322: f881 0044    	strb.w	r0, [r1, #0x44]
;     taskEXIT_CRITICAL();
700a6326: f005 fcd3    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x59a6
; }
700a632a: b002         	add	sp, #0x8
700a632c: bd80         	pop	{r7, pc}
700a632e: 0000         	movs	r0, r0

700a6330 <SemaphoreP_constructBinary>:
; {
700a6330: b580         	push	{r7, lr}
700a6332: b086         	sub	sp, #0x18
700a6334: 9005         	str	r0, [sp, #0x14]
700a6336: 9104         	str	r1, [sp, #0x10]
700a6338: 2000         	movs	r0, #0x0
;     SemaphoreP_Struct *pSemaphore = NULL;
700a633a: 9003         	str	r0, [sp, #0xc]
700a633c: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700a6340: 9002         	str	r0, [sp, #0x8]
;     DebugP_assert(sizeof(SemaphoreP_Struct) <= sizeof(SemaphoreP_Object) );
700a6342: f64f 5040    	movw	r0, #0xfd40
700a6346: f2c7 000a    	movt	r0, #0x700a
700a634a: 4669         	mov	r1, sp
700a634c: 6008         	str	r0, [r1]
700a634e: f240 017b    	movw	r1, #0x7b
700a6352: f2c7 010b    	movt	r1, #0x700b
700a6356: f240 2204    	movw	r2, #0x204
700a635a: f2c7 020b    	movt	r2, #0x700b
700a635e: 2001         	movs	r0, #0x1
700a6360: 2332         	movs	r3, #0x32
700a6362: f002 fedd    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x2dba
;     if(obj != NULL)
700a6366: 9805         	ldr	r0, [sp, #0x14]
700a6368: b128         	cbz	r0, 0x700a6376 <SemaphoreP_constructBinary+0x46> @ imm = #0xa
700a636a: e7ff         	b	0x700a636c <SemaphoreP_constructBinary+0x3c> @ imm = #-0x2
;         pSemaphore = (SemaphoreP_Struct *)obj;
700a636c: 9805         	ldr	r0, [sp, #0x14]
700a636e: 9003         	str	r0, [sp, #0xc]
700a6370: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700a6372: 9002         	str	r0, [sp, #0x8]
;     }
700a6374: e7ff         	b	0x700a6376 <SemaphoreP_constructBinary+0x46> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
700a6376: 9802         	ldr	r0, [sp, #0x8]
700a6378: bb68         	cbnz	r0, 0x700a63d6 <SemaphoreP_constructBinary+0xa6> @ imm = #0x5a
700a637a: e7ff         	b	0x700a637c <SemaphoreP_constructBinary+0x4c> @ imm = #-0x2
;         pSemaphore->isRecursiveMutex = 0;
700a637c: 9803         	ldr	r0, [sp, #0xc]
700a637e: 2200         	movs	r2, #0x0
700a6380: 6542         	str	r2, [r0, #0x54]
;         pSemaphore->semHndl = xSemaphoreCreateBinaryStatic(&pSemaphore->semObj);
700a6382: 9b03         	ldr	r3, [sp, #0xc]
700a6384: 4669         	mov	r1, sp
700a6386: 2003         	movs	r0, #0x3
700a6388: 6008         	str	r0, [r1]
700a638a: 2001         	movs	r0, #0x1
700a638c: 4611         	mov	r1, r2
700a638e: f005 fb37    	bl	0x700aba00 <xQueueGenericCreateStatic> @ imm = #0x566e
700a6392: 9903         	ldr	r1, [sp, #0xc]
700a6394: 6508         	str	r0, [r1, #0x50]
;         if( pSemaphore->semHndl == NULL )
700a6396: 9803         	ldr	r0, [sp, #0xc]
700a6398: 6d00         	ldr	r0, [r0, #0x50]
700a639a: b920         	cbnz	r0, 0x700a63a6 <SemaphoreP_constructBinary+0x76> @ imm = #0x8
700a639c: e7ff         	b	0x700a639e <SemaphoreP_constructBinary+0x6e> @ imm = #-0x2
700a639e: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
700a63a2: 9002         	str	r0, [sp, #0x8]
;         }
700a63a4: e016         	b	0x700a63d4 <SemaphoreP_constructBinary+0xa4> @ imm = #0x2c
;             vQueueAddToRegistry(pSemaphore->semHndl, "Binary Sem (DPL)");
700a63a6: 9803         	ldr	r0, [sp, #0xc]
700a63a8: 6d00         	ldr	r0, [r0, #0x50]
700a63aa: f240 416a    	movw	r1, #0x46a
700a63ae: f2c7 010b    	movt	r1, #0x700b
700a63b2: f005 f86d    	bl	0x700ab490 <vQueueAddToRegistry> @ imm = #0x50da
;             if(initCount == 1U)
700a63b6: 9804         	ldr	r0, [sp, #0x10]
700a63b8: 2801         	cmp	r0, #0x1
700a63ba: d108         	bne	0x700a63ce <SemaphoreP_constructBinary+0x9e> @ imm = #0x10
700a63bc: e7ff         	b	0x700a63be <SemaphoreP_constructBinary+0x8e> @ imm = #-0x2
;                 (void)xSemaphoreGive(pSemaphore->semHndl);
700a63be: 9803         	ldr	r0, [sp, #0xc]
700a63c0: 6d00         	ldr	r0, [r0, #0x50]
700a63c2: 2300         	movs	r3, #0x0
700a63c4: 4619         	mov	r1, r3
700a63c6: 461a         	mov	r2, r3
700a63c8: f7fb fa9a    	bl	0x700a1900 <xQueueGenericSend> @ imm = #-0x4acc
;             }
700a63cc: e7ff         	b	0x700a63ce <SemaphoreP_constructBinary+0x9e> @ imm = #-0x2
700a63ce: 2000         	movs	r0, #0x0
;             status = SystemP_SUCCESS;
700a63d0: 9002         	str	r0, [sp, #0x8]
700a63d2: e7ff         	b	0x700a63d4 <SemaphoreP_constructBinary+0xa4> @ imm = #-0x2
;     }
700a63d4: e7ff         	b	0x700a63d6 <SemaphoreP_constructBinary+0xa6> @ imm = #-0x2
;     return status;
700a63d6: 9802         	ldr	r0, [sp, #0x8]
700a63d8: b006         	add	sp, #0x18
700a63da: bd80         	pop	{r7, pc}
700a63dc: 0000         	movs	r0, r0
700a63de: 0000         	movs	r0, r0

700a63e0 <UdmaChRxPrms_init>:
; {
700a63e0: b083         	sub	sp, #0xc
700a63e2: 9002         	str	r0, [sp, #0x8]
700a63e4: 9101         	str	r1, [sp, #0x4]
;     if(NULL_PTR != rxPrms)
700a63e6: 9802         	ldr	r0, [sp, #0x8]
700a63e8: 2800         	cmp	r0, #0x0
700a63ea: d04d         	beq	0x700a6488 <UdmaChRxPrms_init+0xa8> @ imm = #0x9a
700a63ec: e7ff         	b	0x700a63ee <UdmaChRxPrms_init+0xe> @ imm = #-0x2
;         rxPrms->pauseOnError        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERROR_DISABLED;
700a63ee: 9902         	ldr	r1, [sp, #0x8]
700a63f0: 2000         	movs	r0, #0x0
700a63f2: 7008         	strb	r0, [r1]
;         rxPrms->addrType            = TISCI_MSG_VALUE_RM_UDMAP_CH_ATYPE_PHYS;
700a63f4: 9902         	ldr	r1, [sp, #0x8]
700a63f6: 7048         	strb	r0, [r1, #0x1]
;         rxPrms->chanType            = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_PACKET;
700a63f8: 9902         	ldr	r1, [sp, #0x8]
700a63fa: 2002         	movs	r0, #0x2
700a63fc: 7088         	strb	r0, [r1, #0x2]
;         if((chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a63fe: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a6402: 0740         	lsls	r0, r0, #0x1d
700a6404: 2800         	cmp	r0, #0x0
700a6406: d504         	bpl	0x700a6412 <UdmaChRxPrms_init+0x32> @ imm = #0x8
700a6408: e7ff         	b	0x700a640a <UdmaChRxPrms_init+0x2a> @ imm = #-0x2
;             rxPrms->chanType        = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_3P_BLOCK_REF;
700a640a: 9902         	ldr	r1, [sp, #0x8]
700a640c: 200c         	movs	r0, #0xc
700a640e: 7088         	strb	r0, [r1, #0x2]
;         }
700a6410: e7ff         	b	0x700a6412 <UdmaChRxPrms_init+0x32> @ imm = #-0x2
;         rxPrms->fetchWordSize       = 16U;  /* sizeof(CSL_UdmapTR15) / sizeof(uint32_t) */
700a6412: 9902         	ldr	r1, [sp, #0x8]
700a6414: 2010         	movs	r0, #0x10
700a6416: 8088         	strh	r0, [r1, #0x4]
;         rxPrms->busPriority         = UDMA_DEFAULT_RX_CH_BUS_PRIORITY;
700a6418: 9902         	ldr	r1, [sp, #0x8]
700a641a: 2004         	movs	r0, #0x4
700a641c: 7188         	strb	r0, [r1, #0x6]
;         rxPrms->busQos              = UDMA_DEFAULT_RX_CH_BUS_QOS;
700a641e: 9902         	ldr	r1, [sp, #0x8]
700a6420: 71c8         	strb	r0, [r1, #0x7]
;         rxPrms->busOrderId          = UDMA_DEFAULT_RX_CH_BUS_ORDERID;
700a6422: 9802         	ldr	r0, [sp, #0x8]
700a6424: 2100         	movs	r1, #0x0
700a6426: 9100         	str	r1, [sp]
700a6428: 7201         	strb	r1, [r0, #0x8]
;         rxPrms->dmaPriority         = UDMA_DEFAULT_RX_CH_DMA_PRIORITY;
700a642a: 9a02         	ldr	r2, [sp, #0x8]
700a642c: 2001         	movs	r0, #0x1
700a642e: 7250         	strb	r0, [r2, #0x9]
;         rxPrms->flowIdFwRangeStart  = 0U;       /* Reset value - to use default flow */
700a6430: 9a02         	ldr	r2, [sp, #0x8]
700a6432: 8151         	strh	r1, [r2, #0xa]
;         rxPrms->flowIdFwRangeCnt    = 0U;       /* Reset value - to use default flow */
700a6434: 9a02         	ldr	r2, [sp, #0x8]
700a6436: 8191         	strh	r1, [r2, #0xc]
;         rxPrms->flowEInfoPresent    = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_EINFO_NOT_PRESENT;       /* Default no EINFO */
700a6438: 9a02         	ldr	r2, [sp, #0x8]
700a643a: 7391         	strb	r1, [r2, #0xe]
;         rxPrms->flowPsInfoPresent   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PSINFO_NOT_PRESENT;      /* Default no PSINFO */
700a643c: 9a02         	ldr	r2, [sp, #0x8]
700a643e: 73d1         	strb	r1, [r2, #0xf]
;         rxPrms->flowErrorHandling   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_ERR_RETRY;       /* Default Re-try descriptor allocation operation on starvation error */
700a6440: 9a02         	ldr	r2, [sp, #0x8]
700a6442: 7410         	strb	r0, [r2, #0x10]
;         rxPrms->flowSopOffset       = 0U;      /* Default SOP offset is 0 */
700a6444: 9a02         	ldr	r2, [sp, #0x8]
700a6446: 7451         	strb	r1, [r2, #0x11]
;         rxPrms->ignoreShortPkts     = TISCI_MSG_VALUE_RM_UDMAP_RX_CH_PACKET_EXCEPTION;
700a6448: 9a02         	ldr	r2, [sp, #0x8]
700a644a: 7491         	strb	r1, [r2, #0x12]
;         rxPrms->ignoreLongPkts      = TISCI_MSG_VALUE_RM_UDMAP_RX_CH_PACKET_EXCEPTION;
700a644c: 9a02         	ldr	r2, [sp, #0x8]
700a644e: 74d1         	strb	r1, [r2, #0x13]
;         rxPrms->configDefaultFlow   = TRUE;
700a6450: 9902         	ldr	r1, [sp, #0x8]
700a6452: 6148         	str	r0, [r1, #0x14]
;         if((chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
700a6454: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a6458: 0600         	lsls	r0, r0, #0x18
700a645a: 2800         	cmp	r0, #0x0
700a645c: d504         	bpl	0x700a6468 <UdmaChRxPrms_init+0x88> @ imm = #0x8
700a645e: e7ff         	b	0x700a6460 <UdmaChRxPrms_init+0x80> @ imm = #-0x2
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a6460: 9902         	ldr	r1, [sp, #0x8]
700a6462: 2003         	movs	r0, #0x3
700a6464: 7608         	strb	r0, [r1, #0x18]
;         }
700a6466: e00e         	b	0x700a6486 <UdmaChRxPrms_init+0xa6> @ imm = #0x1c
;         else if((chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
700a6468: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a646c: 0640         	lsls	r0, r0, #0x19
700a646e: 2800         	cmp	r0, #0x0
700a6470: d504         	bpl	0x700a647c <UdmaChRxPrms_init+0x9c> @ imm = #0x8
700a6472: e7ff         	b	0x700a6474 <UdmaChRxPrms_init+0x94> @ imm = #-0x2
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a6474: 9902         	ldr	r1, [sp, #0x8]
700a6476: 2003         	movs	r0, #0x3
700a6478: 7608         	strb	r0, [r1, #0x18]
;         }
700a647a: e003         	b	0x700a6484 <UdmaChRxPrms_init+0xa4> @ imm = #0x6
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_64_BYTES;
700a647c: 9902         	ldr	r1, [sp, #0x8]
700a647e: 2001         	movs	r0, #0x1
700a6480: 7608         	strb	r0, [r1, #0x18]
700a6482: e7ff         	b	0x700a6484 <UdmaChRxPrms_init+0xa4> @ imm = #-0x2
700a6484: e7ff         	b	0x700a6486 <UdmaChRxPrms_init+0xa6> @ imm = #-0x2
;     }
700a6486: e7ff         	b	0x700a6488 <UdmaChRxPrms_init+0xa8> @ imm = #-0x2
;     return;
700a6488: b003         	add	sp, #0xc
700a648a: 4770         	bx	lr
700a648c: 0000         	movs	r0, r0
700a648e: 0000         	movs	r0, r0

700a6490 <UdmaChTxPrms_init>:
; {
700a6490: b082         	sub	sp, #0x8
700a6492: 9001         	str	r0, [sp, #0x4]
700a6494: 9100         	str	r1, [sp]
;     if(NULL_PTR != txPrms)
700a6496: 9801         	ldr	r0, [sp, #0x4]
700a6498: 2800         	cmp	r0, #0x0
700a649a: d04d         	beq	0x700a6538 <UdmaChTxPrms_init+0xa8> @ imm = #0x9a
700a649c: e7ff         	b	0x700a649e <UdmaChTxPrms_init+0xe> @ imm = #-0x2
;         txPrms->pauseOnError    = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERROR_DISABLED;
700a649e: 9901         	ldr	r1, [sp, #0x4]
700a64a0: 2000         	movs	r0, #0x0
700a64a2: 7008         	strb	r0, [r1]
;         txPrms->filterEinfo     = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_FILT_EINFO_DISABLED;
700a64a4: 9901         	ldr	r1, [sp, #0x4]
700a64a6: 7048         	strb	r0, [r1, #0x1]
;         txPrms->filterPsWords   = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_FILT_PSWORDS_DISABLED;
700a64a8: 9901         	ldr	r1, [sp, #0x4]
700a64aa: 7088         	strb	r0, [r1, #0x2]
;         txPrms->addrType        = TISCI_MSG_VALUE_RM_UDMAP_CH_ATYPE_PHYS;
700a64ac: 9901         	ldr	r1, [sp, #0x4]
700a64ae: 70c8         	strb	r0, [r1, #0x3]
;         txPrms->chanType        = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_PACKET;
700a64b0: 9901         	ldr	r1, [sp, #0x4]
700a64b2: 2002         	movs	r0, #0x2
700a64b4: 7108         	strb	r0, [r1, #0x4]
;         if((chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a64b6: f89d 0000    	ldrb.w	r0, [sp]
700a64ba: 0740         	lsls	r0, r0, #0x1d
700a64bc: 2800         	cmp	r0, #0x0
700a64be: d504         	bpl	0x700a64ca <UdmaChTxPrms_init+0x3a> @ imm = #0x8
700a64c0: e7ff         	b	0x700a64c2 <UdmaChTxPrms_init+0x32> @ imm = #-0x2
;             txPrms->chanType    = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_3P_BLOCK_REF;
700a64c2: 9901         	ldr	r1, [sp, #0x4]
700a64c4: 200c         	movs	r0, #0xc
700a64c6: 7108         	strb	r0, [r1, #0x4]
;         }
700a64c8: e7ff         	b	0x700a64ca <UdmaChTxPrms_init+0x3a> @ imm = #-0x2
;         txPrms->fetchWordSize   = 16U;  /* sizeof(CSL_UdmapTR15) / sizeof(uint32_t) */
700a64ca: 9901         	ldr	r1, [sp, #0x4]
700a64cc: 2010         	movs	r0, #0x10
700a64ce: 80c8         	strh	r0, [r1, #0x6]
;         txPrms->busPriority     = UDMA_DEFAULT_TX_CH_BUS_PRIORITY;
700a64d0: 9901         	ldr	r1, [sp, #0x4]
700a64d2: 2004         	movs	r0, #0x4
700a64d4: 7208         	strb	r0, [r1, #0x8]
;         txPrms->busQos          = UDMA_DEFAULT_TX_CH_BUS_QOS;
700a64d6: 9901         	ldr	r1, [sp, #0x4]
700a64d8: 7248         	strb	r0, [r1, #0x9]
;         txPrms->busOrderId      = UDMA_DEFAULT_TX_CH_BUS_ORDERID;
700a64da: 9901         	ldr	r1, [sp, #0x4]
700a64dc: 2000         	movs	r0, #0x0
700a64de: 7288         	strb	r0, [r1, #0xa]
;         txPrms->dmaPriority     = UDMA_DEFAULT_TX_CH_DMA_PRIORITY;
700a64e0: 9a01         	ldr	r2, [sp, #0x4]
700a64e2: 2101         	movs	r1, #0x1
700a64e4: 72d1         	strb	r1, [r2, #0xb]
;         txPrms->txCredit        = 0U;
700a64e6: 9901         	ldr	r1, [sp, #0x4]
700a64e8: 7308         	strb	r0, [r1, #0xc]
;         if((chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
700a64ea: f89d 0000    	ldrb.w	r0, [sp]
700a64ee: ea4f 6000    	lsl.w	r0, r0, #0x18
700a64f2: 2800         	cmp	r0, #0x0
700a64f4: d507         	bpl	0x700a6506 <UdmaChTxPrms_init+0x76> @ imm = #0xe
700a64f6: e7ff         	b	0x700a64f8 <UdmaChTxPrms_init+0x68> @ imm = #-0x2
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_UHC_CHANS_FDEPTH;
700a64f8: 9901         	ldr	r1, [sp, #0x4]
700a64fa: 2000         	movs	r0, #0x0
700a64fc: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a64fe: 9901         	ldr	r1, [sp, #0x4]
700a6500: 2003         	movs	r0, #0x3
700a6502: 7408         	strb	r0, [r1, #0x10]
;         }
700a6504: e014         	b	0x700a6530 <UdmaChTxPrms_init+0xa0> @ imm = #0x28
;         else if((chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
700a6506: f89d 0000    	ldrb.w	r0, [sp]
700a650a: 0640         	lsls	r0, r0, #0x19
700a650c: 2800         	cmp	r0, #0x0
700a650e: d507         	bpl	0x700a6520 <UdmaChTxPrms_init+0x90> @ imm = #0xe
700a6510: e7ff         	b	0x700a6512 <UdmaChTxPrms_init+0x82> @ imm = #-0x2
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_HC_CHANS_FDEPTH;
700a6512: 9901         	ldr	r1, [sp, #0x4]
700a6514: 2000         	movs	r0, #0x0
700a6516: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a6518: 9901         	ldr	r1, [sp, #0x4]
700a651a: 2003         	movs	r0, #0x3
700a651c: 7408         	strb	r0, [r1, #0x10]
;         }
700a651e: e006         	b	0x700a652e <UdmaChTxPrms_init+0x9e> @ imm = #0xc
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_CHANS_FDEPTH;
700a6520: 9901         	ldr	r1, [sp, #0x4]
700a6522: 20c0         	movs	r0, #0xc0
700a6524: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_64_BYTES;
700a6526: 9901         	ldr	r1, [sp, #0x4]
700a6528: 2001         	movs	r0, #0x1
700a652a: 7408         	strb	r0, [r1, #0x10]
700a652c: e7ff         	b	0x700a652e <UdmaChTxPrms_init+0x9e> @ imm = #-0x2
700a652e: e7ff         	b	0x700a6530 <UdmaChTxPrms_init+0xa0> @ imm = #-0x2
;         txPrms->supressTdCqPkt  = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_SUPPRESS_TD_DISABLED;
700a6530: 9901         	ldr	r1, [sp, #0x4]
700a6532: 2000         	movs	r0, #0x0
700a6534: 7448         	strb	r0, [r1, #0x11]
;     }
700a6536: e7ff         	b	0x700a6538 <UdmaChTxPrms_init+0xa8> @ imm = #-0x2
;     return;
700a6538: b002         	add	sp, #0x8
700a653a: 4770         	bx	lr
700a653c: 0000         	movs	r0, r0
700a653e: 0000         	movs	r0, r0

700a6540 <Udma_chDisable>:
; {
700a6540: b580         	push	{r7, lr}
700a6542: b086         	sub	sp, #0x18
700a6544: 9005         	str	r0, [sp, #0x14]
700a6546: 9104         	str	r1, [sp, #0x10]
700a6548: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a654a: 9003         	str	r0, [sp, #0xc]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a654c: 9805         	ldr	r0, [sp, #0x14]
700a654e: 9001         	str	r0, [sp, #0x4]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a6550: 9801         	ldr	r0, [sp, #0x4]
700a6552: b150         	cbz	r0, 0x700a656a <Udma_chDisable+0x2a> @ imm = #0x14
700a6554: e7ff         	b	0x700a6556 <Udma_chDisable+0x16> @ imm = #-0x2
700a6556: 9801         	ldr	r0, [sp, #0x4]
700a6558: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a655c: f64a 31cd    	movw	r1, #0xabcd
700a6560: f6ca 31dc    	movt	r1, #0xabdc
700a6564: 4288         	cmp	r0, r1
700a6566: d004         	beq	0x700a6572 <Udma_chDisable+0x32> @ imm = #0x8
700a6568: e7ff         	b	0x700a656a <Udma_chDisable+0x2a> @ imm = #-0x2
700a656a: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a656e: 9003         	str	r0, [sp, #0xc]
;     }
700a6570: e7ff         	b	0x700a6572 <Udma_chDisable+0x32> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a6572: 9803         	ldr	r0, [sp, #0xc]
700a6574: b9a8         	cbnz	r0, 0x700a65a2 <Udma_chDisable+0x62> @ imm = #0x2a
700a6576: e7ff         	b	0x700a6578 <Udma_chDisable+0x38> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a6578: 9801         	ldr	r0, [sp, #0x4]
700a657a: 6e80         	ldr	r0, [r0, #0x68]
700a657c: 9002         	str	r0, [sp, #0x8]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a657e: 9802         	ldr	r0, [sp, #0x8]
700a6580: b150         	cbz	r0, 0x700a6598 <Udma_chDisable+0x58> @ imm = #0x14
700a6582: e7ff         	b	0x700a6584 <Udma_chDisable+0x44> @ imm = #-0x2
700a6584: 9802         	ldr	r0, [sp, #0x8]
700a6586: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a658a: f64a 31cd    	movw	r1, #0xabcd
700a658e: f6ca 31dc    	movt	r1, #0xabdc
700a6592: 4288         	cmp	r0, r1
700a6594: d004         	beq	0x700a65a0 <Udma_chDisable+0x60> @ imm = #0x8
700a6596: e7ff         	b	0x700a6598 <Udma_chDisable+0x58> @ imm = #-0x2
700a6598: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a659c: 9003         	str	r0, [sp, #0xc]
;         }
700a659e: e7ff         	b	0x700a65a0 <Udma_chDisable+0x60> @ imm = #-0x2
;     }
700a65a0: e7ff         	b	0x700a65a2 <Udma_chDisable+0x62> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a65a2: 9803         	ldr	r0, [sp, #0xc]
700a65a4: b9f8         	cbnz	r0, 0x700a65e6 <Udma_chDisable+0xa6> @ imm = #0x3e
700a65a6: e7ff         	b	0x700a65a8 <Udma_chDisable+0x68> @ imm = #-0x2
;         if((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a65a8: 9801         	ldr	r0, [sp, #0x4]
700a65aa: 7800         	ldrb	r0, [r0]
700a65ac: 0740         	lsls	r0, r0, #0x1d
700a65ae: 2800         	cmp	r0, #0x0
700a65b0: d506         	bpl	0x700a65c0 <Udma_chDisable+0x80> @ imm = #0xc
700a65b2: e7ff         	b	0x700a65b4 <Udma_chDisable+0x74> @ imm = #-0x2
;             retVal = Udma_chDisableBlkCpyChan(chHandleInt, timeout);
700a65b4: 9801         	ldr	r0, [sp, #0x4]
700a65b6: 9904         	ldr	r1, [sp, #0x10]
700a65b8: f7f7 fb6a    	bl	0x7009dc90 <Udma_chDisableBlkCpyChan> @ imm = #-0x892c
700a65bc: 9003         	str	r0, [sp, #0xc]
;         }
700a65be: e011         	b	0x700a65e4 <Udma_chDisable+0xa4> @ imm = #0x22
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a65c0: 9801         	ldr	r0, [sp, #0x4]
700a65c2: 7800         	ldrb	r0, [r0]
700a65c4: 07c0         	lsls	r0, r0, #0x1f
700a65c6: b130         	cbz	r0, 0x700a65d6 <Udma_chDisable+0x96> @ imm = #0xc
700a65c8: e7ff         	b	0x700a65ca <Udma_chDisable+0x8a> @ imm = #-0x2
;                 retVal = Udma_chDisableTxChan(chHandleInt, timeout);
700a65ca: 9801         	ldr	r0, [sp, #0x4]
700a65cc: 9904         	ldr	r1, [sp, #0x10]
700a65ce: f7f4 febf    	bl	0x7009b350 <Udma_chDisableTxChan> @ imm = #-0xb282
700a65d2: 9003         	str	r0, [sp, #0xc]
;             }
700a65d4: e005         	b	0x700a65e2 <Udma_chDisable+0xa2> @ imm = #0xa
;                 retVal = Udma_chDisableRxChan(chHandleInt, timeout);
700a65d6: 9801         	ldr	r0, [sp, #0x4]
700a65d8: 9904         	ldr	r1, [sp, #0x10]
700a65da: f7f5 fe89    	bl	0x7009c2f0 <Udma_chDisableRxChan> @ imm = #-0xa2ee
700a65de: 9003         	str	r0, [sp, #0xc]
700a65e0: e7ff         	b	0x700a65e2 <Udma_chDisable+0xa2> @ imm = #-0x2
700a65e2: e7ff         	b	0x700a65e4 <Udma_chDisable+0xa4> @ imm = #-0x2
;     }
700a65e4: e7ff         	b	0x700a65e6 <Udma_chDisable+0xa6> @ imm = #-0x2
;     return (retVal);
700a65e6: 9803         	ldr	r0, [sp, #0xc]
700a65e8: b006         	add	sp, #0x18
700a65ea: bd80         	pop	{r7, pc}
700a65ec: 0000         	movs	r0, r0
700a65ee: 0000         	movs	r0, r0

700a65f0 <CSL_bcdmaChanOpSetChanPause>:
; {
700a65f0: b580         	push	{r7, lr}
700a65f2: b086         	sub	sp, #0x18
700a65f4: 9005         	str	r0, [sp, #0x14]
700a65f6: 9104         	str	r1, [sp, #0x10]
700a65f8: 9203         	str	r2, [sp, #0xc]
700a65fa: f88d 300b    	strb.w	r3, [sp, #0xb]
700a65fe: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a6600: 9001         	str	r0, [sp, #0x4]
;     if( CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)false )
700a6602: 9805         	ldr	r0, [sp, #0x14]
700a6604: 9904         	ldr	r1, [sp, #0x10]
700a6606: 9a03         	ldr	r2, [sp, #0xc]
700a6608: f002 fc4a    	bl	0x700a8ea0 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x2894
700a660c: b920         	cbnz	r0, 0x700a6618 <CSL_bcdmaChanOpSetChanPause+0x28> @ imm = #0x8
700a660e: e7ff         	b	0x700a6610 <CSL_bcdmaChanOpSetChanPause+0x20> @ imm = #-0x2
700a6610: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a6614: 9001         	str	r0, [sp, #0x4]
;     }
700a6616: e03d         	b	0x700a6694 <CSL_bcdmaChanOpSetChanPause+0xa4> @ imm = #0x7a
;         switch( chanType )
700a6618: 9804         	ldr	r0, [sp, #0x10]
700a661a: 9000         	str	r0, [sp]
700a661c: b140         	cbz	r0, 0x700a6630 <CSL_bcdmaChanOpSetChanPause+0x40> @ imm = #0x10
700a661e: e7ff         	b	0x700a6620 <CSL_bcdmaChanOpSetChanPause+0x30> @ imm = #-0x2
700a6620: 9800         	ldr	r0, [sp]
700a6622: 2801         	cmp	r0, #0x1
700a6624: d013         	beq	0x700a664e <CSL_bcdmaChanOpSetChanPause+0x5e> @ imm = #0x26
700a6626: e7ff         	b	0x700a6628 <CSL_bcdmaChanOpSetChanPause+0x38> @ imm = #-0x2
700a6628: 9800         	ldr	r0, [sp]
700a662a: 2802         	cmp	r0, #0x2
700a662c: d01e         	beq	0x700a666c <CSL_bcdmaChanOpSetChanPause+0x7c> @ imm = #0x3c
700a662e: e02c         	b	0x700a668a <CSL_bcdmaChanOpSetChanPause+0x9a> @ imm = #0x58
;                 CSL_REG32_FINS( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a6630: 9805         	ldr	r0, [sp, #0x14]
700a6632: 6880         	ldr	r0, [r0, #0x8]
700a6634: 9903         	ldr	r1, [sp, #0xc]
700a6636: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a663a: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a663e: f001 0301    	and	r3, r1, #0x1
700a6642: f04f 5100    	mov.w	r1, #0x20000000
700a6646: 221d         	movs	r2, #0x1d
700a6648: f006 f84a    	bl	0x700ac6e0 <CSL_REG32_FINS_RAW> @ imm = #0x6094
;                 break;
700a664c: e021         	b	0x700a6692 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x42
;                 CSL_REG32_FINS( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a664e: 9805         	ldr	r0, [sp, #0x14]
700a6650: 6900         	ldr	r0, [r0, #0x10]
700a6652: 9903         	ldr	r1, [sp, #0xc]
700a6654: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6658: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a665c: f001 0301    	and	r3, r1, #0x1
700a6660: f04f 5100    	mov.w	r1, #0x20000000
700a6664: 221d         	movs	r2, #0x1d
700a6666: f006 f83b    	bl	0x700ac6e0 <CSL_REG32_FINS_RAW> @ imm = #0x6076
;                 break;
700a666a: e012         	b	0x700a6692 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x24
;                 CSL_REG32_FINS( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a666c: 9805         	ldr	r0, [sp, #0x14]
700a666e: 6980         	ldr	r0, [r0, #0x18]
700a6670: 9903         	ldr	r1, [sp, #0xc]
700a6672: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6676: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a667a: f001 0301    	and	r3, r1, #0x1
700a667e: f04f 5100    	mov.w	r1, #0x20000000
700a6682: 221d         	movs	r2, #0x1d
700a6684: f006 f82c    	bl	0x700ac6e0 <CSL_REG32_FINS_RAW> @ imm = #0x6058
;                 break;
700a6688: e003         	b	0x700a6692 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x6
700a668a: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a668e: 9001         	str	r0, [sp, #0x4]
;                 break;
700a6690: e7ff         	b	0x700a6692 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #-0x2
700a6692: e7ff         	b	0x700a6694 <CSL_bcdmaChanOpSetChanPause+0xa4> @ imm = #-0x2
;     return retVal;
700a6694: 9801         	ldr	r0, [sp, #0x4]
700a6696: b006         	add	sp, #0x18
700a6698: bd80         	pop	{r7, pc}
700a669a: 0000         	movs	r0, r0
700a669c: 0000         	movs	r0, r0
700a669e: 0000         	movs	r0, r0

700a66a0 <CSL_bcdmaChanOpSetChanRT>:
; {
700a66a0: b580         	push	{r7, lr}
700a66a2: b088         	sub	sp, #0x20
700a66a4: 9007         	str	r0, [sp, #0x1c]
700a66a6: 9106         	str	r1, [sp, #0x18]
700a66a8: 9205         	str	r2, [sp, #0x14]
700a66aa: 9304         	str	r3, [sp, #0x10]
700a66ac: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a66ae: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a66b0: 9804         	ldr	r0, [sp, #0x10]
700a66b2: b920         	cbnz	r0, 0x700a66be <CSL_bcdmaChanOpSetChanRT+0x1e> @ imm = #0x8
700a66b4: e7ff         	b	0x700a66b6 <CSL_bcdmaChanOpSetChanRT+0x16> @ imm = #-0x2
700a66b6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a66ba: 9003         	str	r0, [sp, #0xc]
;     }
700a66bc: e042         	b	0x700a6744 <CSL_bcdmaChanOpSetChanRT+0xa4> @ imm = #0x84
;         CSL_BcdmaRT *pRT = (CSL_BcdmaRT *)pOpData;
700a66be: 9804         	ldr	r0, [sp, #0x10]
700a66c0: 9001         	str	r0, [sp, #0x4]
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a66c2: 9801         	ldr	r0, [sp, #0x4]
700a66c4: 6803         	ldr	r3, [r0]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a66c6: f8d0 c004    	ldr.w	r12, [r0, #0x4]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_PAUSE,        pRT->pause);
700a66ca: 6881         	ldr	r1, [r0, #0x8]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a66cc: 6902         	ldr	r2, [r0, #0x10]
700a66ce: f04f 4080    	mov.w	r0, #0x40000000
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a66d2: ea00 708c    	and.w	r0, r0, r12, lsl #30
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a66d6: ea40 70c3    	orr.w	r0, r0, r3, lsl #31
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a66da: f002 0201    	and	r2, r2, #0x1
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a66de: ea40 7002    	orr.w	r0, r0, r2, lsl #28
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_PAUSE,        pRT->pause);
700a66e2: f001 0101    	and	r1, r1, #0x1
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a66e6: ea40 7041    	orr.w	r0, r0, r1, lsl #29
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a66ea: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a66ec: 9806         	ldr	r0, [sp, #0x18]
700a66ee: 9000         	str	r0, [sp]
700a66f0: b140         	cbz	r0, 0x700a6704 <CSL_bcdmaChanOpSetChanRT+0x64> @ imm = #0x10
700a66f2: e7ff         	b	0x700a66f4 <CSL_bcdmaChanOpSetChanRT+0x54> @ imm = #-0x2
700a66f4: 9800         	ldr	r0, [sp]
700a66f6: 2801         	cmp	r0, #0x1
700a66f8: d00d         	beq	0x700a6716 <CSL_bcdmaChanOpSetChanRT+0x76> @ imm = #0x1a
700a66fa: e7ff         	b	0x700a66fc <CSL_bcdmaChanOpSetChanRT+0x5c> @ imm = #-0x2
700a66fc: 9800         	ldr	r0, [sp]
700a66fe: 2802         	cmp	r0, #0x2
700a6700: d012         	beq	0x700a6728 <CSL_bcdmaChanOpSetChanRT+0x88> @ imm = #0x24
700a6702: e01a         	b	0x700a673a <CSL_bcdmaChanOpSetChanRT+0x9a> @ imm = #0x34
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, val );
700a6704: 9807         	ldr	r0, [sp, #0x1c]
700a6706: 6880         	ldr	r0, [r0, #0x8]
700a6708: 9905         	ldr	r1, [sp, #0x14]
700a670a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a670e: 9902         	ldr	r1, [sp, #0x8]
700a6710: f7f4 fc4e    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0xb764
;                 break;
700a6714: e015         	b	0x700a6742 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x2a
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, val );
700a6716: 9807         	ldr	r0, [sp, #0x1c]
700a6718: 6900         	ldr	r0, [r0, #0x10]
700a671a: 9905         	ldr	r1, [sp, #0x14]
700a671c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6720: 9902         	ldr	r1, [sp, #0x8]
700a6722: f7f4 fc45    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0xb776
;                 break;
700a6726: e00c         	b	0x700a6742 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x18
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, val );
700a6728: 9807         	ldr	r0, [sp, #0x1c]
700a672a: 6980         	ldr	r0, [r0, #0x18]
700a672c: 9905         	ldr	r1, [sp, #0x14]
700a672e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6732: 9902         	ldr	r1, [sp, #0x8]
700a6734: f7f4 fc3c    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0xb788
;                 break;
700a6738: e003         	b	0x700a6742 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x6
700a673a: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a673e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a6740: e7ff         	b	0x700a6742 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #-0x2
700a6742: e7ff         	b	0x700a6744 <CSL_bcdmaChanOpSetChanRT+0xa4> @ imm = #-0x2
;     return retVal;
700a6744: 9803         	ldr	r0, [sp, #0xc]
700a6746: b008         	add	sp, #0x20
700a6748: bd80         	pop	{r7, pc}
700a674a: 0000         	movs	r0, r0
700a674c: 0000         	movs	r0, r0
700a674e: 0000         	movs	r0, r0

700a6750 <reporting_thread>:
; {
700a6750: f640 58b0    	movw	r8, #0xdb0
700a6754: f640 59b4    	movw	r9, #0xdb4
700a6758: f240 3b02    	movw	r11, #0x302
700a675c: f64f 66a2    	movw	r6, #0xfea2
700a6760: f240 47ff    	movw	r7, #0x4ff
700a6764: f2c7 080b    	movt	r8, #0x700b
700a6768: f2c7 090b    	movt	r9, #0x700b
700a676c: f2c7 0b0b    	movt	r11, #0x700b
700a6770: f2c7 060a    	movt	r6, #0x700a
700a6774: f2c7 070b    	movt	r7, #0x700b
700a6778: 2500         	movs	r5, #0x0
700a677a: 241e         	movs	r4, #0x1e
700a677c: bf00         	nop
700a677e: bf00         	nop
;       tm_thread_sleep(TM_TEST_DURATION);
700a6780: f04f 001e    	mov.w	r0, #0x1e
700a6784: f007 fce4    	bl	0x700ae150 <tm_thread_sleep> @ imm = #0x79c8
;       printf("**** Task Synchronistation Test **** Relative Time: %lu\r\n", relative_time);
700a6788: f64f 5106    	movw	r1, #0xfd06
700a678c: 4622         	mov	r2, r4
700a678e: f2c7 010a    	movt	r1, #0x700a
700a6792: 2001         	movs	r0, #0x1
700a6794: f001 fd0c    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #0x1a18
;       total = task1_counter + task2_counter;
700a6798: f8d8 0000    	ldr.w	r0, [r8]
700a679c: f8d9 1000    	ldr.w	r1, [r9]
700a67a0: eb01 0a00    	add.w	r10, r1, r0
;       iteration_time_us = calculate_iteration_time(TM_TEST_DURATION, diff);
700a67a4: 201e         	movs	r0, #0x1e
;       unsigned long diff = total - last_total;
700a67a6: ebaa 0505    	sub.w	r5, r10, r5
;       iteration_time_us = calculate_iteration_time(TM_TEST_DURATION, diff);
700a67aa: 4629         	mov	r1, r5
700a67ac: f005 fc98    	bl	0x700ac0e0 <calculate_iteration_time> @ imm = #0x5930
;       printf("Time Period Total:  %lu\r\n", total - last_total);
700a67b0: f240 2154    	movw	r1, #0x254
700a67b4: 462a         	mov	r2, r5
700a67b6: f2c7 010b    	movt	r1, #0x700b
700a67ba: 2001         	movs	r0, #0x1
;       iteration_time_us = calculate_iteration_time(TM_TEST_DURATION, diff);
700a67bc: eeb0 8b40    	vmov.f64	d8, d0
;       printf("Time Period Total:  %lu\r\n", total - last_total);
700a67c0: f001 fcf6    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #0x19ec
;       printf("Task1 Counter:  %lu\r\n", task1_counter);
700a67c4: f240 3118    	movw	r1, #0x318
700a67c8: f8d8 2000    	ldr.w	r2, [r8]
700a67cc: f2c7 010b    	movt	r1, #0x700b
700a67d0: 2001         	movs	r0, #0x1
700a67d2: f001 fced    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #0x19da
;       printf("Task2 Counter:  %lu\r\n", task2_counter);
700a67d6: f8d9 2000    	ldr.w	r2, [r9]
700a67da: 4659         	mov	r1, r11
700a67dc: 2001         	movs	r0, #0x1
700a67de: f001 fce7    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #0x19ce
;       printf("Average Time per Iteration:    %f us\r\n\r\n", iteration_time_us);
700a67e2: ec53 2b18    	vmov	r2, r3, d8
700a67e6: 4631         	mov	r1, r6
700a67e8: 2001         	movs	r0, #0x1
700a67ea: f001 fce1    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #0x19c2
;       tm_pmu_profile_print("SEM_A_perf");
700a67ee: 4638         	mov	r0, r7
700a67f0: f007 fd06    	bl	0x700ae200 <tm_pmu_profile_print> @ imm = #0x7a0c
;    while (1)
700a67f4: 341e         	adds	r4, #0x1e
700a67f6: 4655         	mov	r5, r10
;    while (1)
700a67f8: e7c2         	b	0x700a6780 <reporting_thread+0x30> @ imm = #-0x7c
700a67fa: 0000         	movs	r0, r0
700a67fc: 0000         	movs	r0, r0
700a67fe: 0000         	movs	r0, r0

700a6800 <Sciclient_rmIrInpRomMapped>:
; {
700a6800: b082         	sub	sp, #0x8
700a6802: 9001         	str	r0, [sp, #0x4]
700a6804: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a6808: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a680a: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a680e: 9801         	ldr	r0, [sp, #0x4]
700a6810: 6900         	ldr	r0, [r0, #0x10]
700a6812: 2800         	cmp	r0, #0x0
700a6814: d042         	beq	0x700a689c <Sciclient_rmIrInpRomMapped+0x9c> @ imm = #0x84
700a6816: e7ff         	b	0x700a6818 <Sciclient_rmIrInpRomMapped+0x18> @ imm = #-0x2
700a6818: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a681a: f88d 0000    	strb.w	r0, [sp]
700a681e: e7ff         	b	0x700a6820 <Sciclient_rmIrInpRomMapped+0x20> @ imm = #-0x2
700a6820: f89d 0000    	ldrb.w	r0, [sp]
700a6824: 9901         	ldr	r1, [sp, #0x4]
700a6826: 7d09         	ldrb	r1, [r1, #0x14]
700a6828: 4288         	cmp	r0, r1
700a682a: da36         	bge	0x700a689a <Sciclient_rmIrInpRomMapped+0x9a> @ imm = #0x6c
700a682c: e7ff         	b	0x700a682e <Sciclient_rmIrInpRomMapped+0x2e> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a682e: 9801         	ldr	r0, [sp, #0x4]
700a6830: 6900         	ldr	r0, [r0, #0x10]
700a6832: f89d 1000    	ldrb.w	r1, [sp]
700a6836: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a683a: 7980         	ldrb	r0, [r0, #0x6]
700a683c: 07c0         	lsls	r0, r0, #0x1f
700a683e: bb28         	cbnz	r0, 0x700a688c <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x4a
700a6840: e7ff         	b	0x700a6842 <Sciclient_rmIrInpRomMapped+0x42> @ imm = #-0x2
;                 (inp >= inst->rom_usage[i].inp_start) &&
700a6842: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a6846: 9901         	ldr	r1, [sp, #0x4]
700a6848: 6909         	ldr	r1, [r1, #0x10]
700a684a: f89d 2000    	ldrb.w	r2, [sp]
700a684e: f831 1032    	ldrh.w	r1, [r1, r2, lsl #3]
700a6852: 4288         	cmp	r0, r1
700a6854: db1a         	blt	0x700a688c <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x34
700a6856: e7ff         	b	0x700a6858 <Sciclient_rmIrInpRomMapped+0x58> @ imm = #-0x2
;                 (inp < (inst->rom_usage[i].inp_start +
700a6858: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a685c: 9901         	ldr	r1, [sp, #0x4]
700a685e: 6909         	ldr	r1, [r1, #0x10]
700a6860: f89d 3000    	ldrb.w	r3, [sp]
700a6864: eb01 02c3    	add.w	r2, r1, r3, lsl #3
700a6868: f831 1033    	ldrh.w	r1, [r1, r3, lsl #3]
;                         inst->rom_usage[i].length))) {
700a686c: 8892         	ldrh	r2, [r2, #0x4]
;                 (inp < (inst->rom_usage[i].inp_start +
700a686e: 4411         	add	r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a6870: 4288         	cmp	r0, r1
700a6872: da0b         	bge	0x700a688c <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x16
700a6874: e7ff         	b	0x700a6876 <Sciclient_rmIrInpRomMapped+0x76> @ imm = #-0x2
700a6876: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a6878: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a687c: 9901         	ldr	r1, [sp, #0x4]
700a687e: 6909         	ldr	r1, [r1, #0x10]
700a6880: f89d 2000    	ldrb.w	r2, [sp]
700a6884: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a6888: 7188         	strb	r0, [r1, #0x6]
;                 break;
700a688a: e006         	b	0x700a689a <Sciclient_rmIrInpRomMapped+0x9a> @ imm = #0xc
;         }
700a688c: e7ff         	b	0x700a688e <Sciclient_rmIrInpRomMapped+0x8e> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a688e: f89d 0000    	ldrb.w	r0, [sp]
700a6892: 3001         	adds	r0, #0x1
700a6894: f88d 0000    	strb.w	r0, [sp]
700a6898: e7c2         	b	0x700a6820 <Sciclient_rmIrInpRomMapped+0x20> @ imm = #-0x7c
;     }
700a689a: e7ff         	b	0x700a689c <Sciclient_rmIrInpRomMapped+0x9c> @ imm = #-0x2
;     return rom_mapped;
700a689c: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a68a0: f000 0001    	and	r0, r0, #0x1
700a68a4: b002         	add	sp, #0x8
700a68a6: 4770         	bx	lr
		...

700a68b0 <Sciclient_rmIrOutpRomMapped>:
; {
700a68b0: b082         	sub	sp, #0x8
700a68b2: 9001         	str	r0, [sp, #0x4]
700a68b4: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a68b8: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a68ba: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a68be: 9801         	ldr	r0, [sp, #0x4]
700a68c0: 6900         	ldr	r0, [r0, #0x10]
700a68c2: 2800         	cmp	r0, #0x0
700a68c4: d042         	beq	0x700a694c <Sciclient_rmIrOutpRomMapped+0x9c> @ imm = #0x84
700a68c6: e7ff         	b	0x700a68c8 <Sciclient_rmIrOutpRomMapped+0x18> @ imm = #-0x2
700a68c8: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a68ca: f88d 0000    	strb.w	r0, [sp]
700a68ce: e7ff         	b	0x700a68d0 <Sciclient_rmIrOutpRomMapped+0x20> @ imm = #-0x2
700a68d0: f89d 0000    	ldrb.w	r0, [sp]
700a68d4: 9901         	ldr	r1, [sp, #0x4]
700a68d6: 7d09         	ldrb	r1, [r1, #0x14]
700a68d8: 4288         	cmp	r0, r1
700a68da: da36         	bge	0x700a694a <Sciclient_rmIrOutpRomMapped+0x9a> @ imm = #0x6c
700a68dc: e7ff         	b	0x700a68de <Sciclient_rmIrOutpRomMapped+0x2e> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a68de: 9801         	ldr	r0, [sp, #0x4]
700a68e0: 6900         	ldr	r0, [r0, #0x10]
700a68e2: f89d 1000    	ldrb.w	r1, [sp]
700a68e6: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a68ea: 7980         	ldrb	r0, [r0, #0x6]
700a68ec: 07c0         	lsls	r0, r0, #0x1f
700a68ee: bb28         	cbnz	r0, 0x700a693c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x4a
700a68f0: e7ff         	b	0x700a68f2 <Sciclient_rmIrOutpRomMapped+0x42> @ imm = #-0x2
;                 (outp >= inst->rom_usage[i].outp_start) &&
700a68f2: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a68f6: 9901         	ldr	r1, [sp, #0x4]
700a68f8: 6909         	ldr	r1, [r1, #0x10]
700a68fa: f89d 2000    	ldrb.w	r2, [sp]
700a68fe: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a6902: 8849         	ldrh	r1, [r1, #0x2]
700a6904: 4288         	cmp	r0, r1
700a6906: db19         	blt	0x700a693c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x32
700a6908: e7ff         	b	0x700a690a <Sciclient_rmIrOutpRomMapped+0x5a> @ imm = #-0x2
;                 (outp < (inst->rom_usage[i].outp_start +
700a690a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a690e: 9901         	ldr	r1, [sp, #0x4]
700a6910: 6909         	ldr	r1, [r1, #0x10]
700a6912: f89d 2000    	ldrb.w	r2, [sp]
700a6916: eb01 02c2    	add.w	r2, r1, r2, lsl #3
700a691a: 8851         	ldrh	r1, [r2, #0x2]
;                         inst->rom_usage[i].length))) {
700a691c: 8892         	ldrh	r2, [r2, #0x4]
;                 (outp < (inst->rom_usage[i].outp_start +
700a691e: 4411         	add	r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a6920: 4288         	cmp	r0, r1
700a6922: da0b         	bge	0x700a693c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x16
700a6924: e7ff         	b	0x700a6926 <Sciclient_rmIrOutpRomMapped+0x76> @ imm = #-0x2
700a6926: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a6928: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a692c: 9901         	ldr	r1, [sp, #0x4]
700a692e: 6909         	ldr	r1, [r1, #0x10]
700a6930: f89d 2000    	ldrb.w	r2, [sp]
700a6934: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a6938: 7188         	strb	r0, [r1, #0x6]
;                 break;
700a693a: e006         	b	0x700a694a <Sciclient_rmIrOutpRomMapped+0x9a> @ imm = #0xc
;         }
700a693c: e7ff         	b	0x700a693e <Sciclient_rmIrOutpRomMapped+0x8e> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a693e: f89d 0000    	ldrb.w	r0, [sp]
700a6942: 3001         	adds	r0, #0x1
700a6944: f88d 0000    	strb.w	r0, [sp]
700a6948: e7c2         	b	0x700a68d0 <Sciclient_rmIrOutpRomMapped+0x20> @ imm = #-0x7c
;     }
700a694a: e7ff         	b	0x700a694c <Sciclient_rmIrOutpRomMapped+0x9c> @ imm = #-0x2
;     return rom_mapped;
700a694c: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a6950: f000 0001    	and	r0, r0, #0x1
700a6954: b002         	add	sp, #0x8
700a6956: 4770         	bx	lr
		...

700a6960 <CycleCounterP_init>:
; {
700a6960: b580         	push	{r7, lr}
700a6962: b082         	sub	sp, #0x8
700a6964: 9101         	str	r1, [sp, #0x4]
700a6966: 9000         	str	r0, [sp]
;     gCounterFreqHz = cpuFreqHz/PmuP_SETUP_COUNTER_DIVIDER_VAL;
700a6968: 9800         	ldr	r0, [sp]
700a696a: 9a01         	ldr	r2, [sp, #0x4]
700a696c: f640 5168    	movw	r1, #0xd68
700a6970: f2c7 010b    	movt	r1, #0x700b
700a6974: 604a         	str	r2, [r1, #0x4]
700a6976: 6008         	str	r0, [r1]
;     CycleCounterP_reset();
700a6978: f000 f802    	bl	0x700a6980 <CycleCounterP_reset> @ imm = #0x4
; }
700a697c: b002         	add	sp, #0x8
700a697e: bd80         	pop	{r7, pc}

700a6980 <CycleCounterP_reset>:
; {
700a6980: b580         	push	{r7, lr}
700a6982: b082         	sub	sp, #0x8
700a6984: 2000         	movs	r0, #0x0
;     uint32_t setupFlags = 0;
700a6986: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_CYCLE_COUNTER_RESET;
700a6988: 9801         	ldr	r0, [sp, #0x4]
700a698a: f040 0004    	orr	r0, r0, #0x4
700a698e: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_EVENT_COUNTER_RESET;
700a6990: 9801         	ldr	r0, [sp, #0x4]
700a6992: f040 0002    	orr	r0, r0, #0x2
700a6996: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_ENABLE_ALL_COUNTERS;
700a6998: 9801         	ldr	r0, [sp, #0x4]
700a699a: f040 0001    	orr	r0, r0, #0x1
700a699e: 9001         	str	r0, [sp, #0x4]
700a69a0: f04f 30ff    	mov.w	r0, #0xffffffff
;     PmuP_disableCounters(PmuP_COUNTER_MASK_ALL_COUNTERS); /* disable all counters */
700a69a4: 9000         	str	r0, [sp]
700a69a6: f006 e9a8    	blx	0x700accf8 <PmuP_disableCounters> @ imm = #0x6350
700a69aa: 9800         	ldr	r0, [sp]
;     PmuP_clearOverflowStatus(PmuP_COUNTER_MASK_ALL_COUNTERS); /* clear all overflow flags */
700a69ac: f006 e9ac    	blx	0x700acd08 <PmuP_clearOverflowStatus> @ imm = #0x6358
;     PmuP_setup(setupFlags); /* setup counters */
700a69b0: 9801         	ldr	r0, [sp, #0x4]
700a69b2: f006 e99a    	blx	0x700acce8 <PmuP_setup> @ imm = #0x6334
700a69b6: f04f 4000    	mov.w	r0, #0x80000000
;     PmuP_enableCounters(PmuP_COUNTER_MASK_CYCLE_COUNTER); /* enable cycle counter only */
700a69ba: f006 e99a    	blx	0x700accf0 <PmuP_enableCounters> @ imm = #0x6334
; }
700a69be: b002         	add	sp, #0x8
700a69c0: bd80         	pop	{r7, pc}
700a69c2: bf00         	nop
700a69c4: bf00         	nop
700a69c6: bf00         	nop
700a69c8: bf00         	nop
700a69ca: bf00         	nop
700a69cc: bf00         	nop
700a69ce: bf00         	nop

700a69d0 <CycleCounterP_nsToTicks>:
; {
700a69d0: b580         	push	{r7, lr}
700a69d2: b082         	sub	sp, #0x8
700a69d4: 9101         	str	r1, [sp, #0x4]
700a69d6: 9000         	str	r0, [sp]
;     return (((uint64_t)nanosecs*gCounterFreqHz)/PmuP_SEC_TO_NANOSEC);
700a69d8: 9b00         	ldr	r3, [sp]
700a69da: 9901         	ldr	r1, [sp, #0x4]
700a69dc: f640 5068    	movw	r0, #0xd68
700a69e0: f2c7 000b    	movt	r0, #0x700b
700a69e4: 6802         	ldr	r2, [r0]
700a69e6: f8d0 c004    	ldr.w	r12, [r0, #0x4]
700a69ea: fba3 0e02    	umull	r0, lr, r3, r2
700a69ee: fb03 e30c    	mla	r3, r3, r12, lr
700a69f2: fb01 3102    	mla	r1, r1, r2, r3
700a69f6: f64c 2200    	movw	r2, #0xca00
700a69fa: f6c3 329a    	movt	r2, #0x3b9a
700a69fe: 2300         	movs	r3, #0x0
700a6a00: f006 ee48    	blx	0x700ad694 <__aeabi_uldivmod> @ imm = #0x6c90
700a6a04: b002         	add	sp, #0x8
700a6a06: bd80         	pop	{r7, pc}
		...

700a6a10 <Sciclient_pmGetModuleClkNumParent>:
; {
700a6a10: b580         	push	{r7, lr}
700a6a12: b096         	sub	sp, #0x58
700a6a14: 9015         	str	r0, [sp, #0x54]
700a6a16: 9114         	str	r1, [sp, #0x50]
700a6a18: 9213         	str	r2, [sp, #0x4c]
700a6a1a: 9312         	str	r3, [sp, #0x48]
700a6a1c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a6a1e: 9011         	str	r0, [sp, #0x44]
;     struct tisci_msg_get_num_clock_parents_req request = {{0}};
700a6a20: f88d 0040    	strb.w	r0, [sp, #0x40]
700a6a24: 900f         	str	r0, [sp, #0x3c]
700a6a26: 900e         	str	r0, [sp, #0x38]
700a6a28: 900d         	str	r0, [sp, #0x34]
700a6a2a: 900c         	str	r0, [sp, #0x30]
;     request.device = (uint32_t) moduleId;
700a6a2c: 9815         	ldr	r0, [sp, #0x54]
700a6a2e: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a6a30: 9814         	ldr	r0, [sp, #0x50]
700a6a32: 28ff         	cmp	r0, #0xff
700a6a34: d307         	blo	0x700a6a46 <Sciclient_pmGetModuleClkNumParent+0x36> @ imm = #0xe
700a6a36: e7ff         	b	0x700a6a38 <Sciclient_pmGetModuleClkNumParent+0x28> @ imm = #-0x2
;         request.clk32 = clockId;
700a6a38: 9814         	ldr	r0, [sp, #0x50]
700a6a3a: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a6a3e: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a6a40: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a6a44: e003         	b	0x700a6a4e <Sciclient_pmGetModuleClkNumParent+0x3e> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a6a46: 9814         	ldr	r0, [sp, #0x50]
700a6a48: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a6a4c: e7ff         	b	0x700a6a4e <Sciclient_pmGetModuleClkNumParent+0x3e> @ imm = #-0x2
700a6a4e: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_num_clock_parents_resp response = {{0}};
700a6a50: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a6a54: 900a         	str	r0, [sp, #0x28]
700a6a56: 9009         	str	r0, [sp, #0x24]
700a6a58: 9008         	str	r0, [sp, #0x20]
700a6a5a: f44f 7182    	mov.w	r1, #0x104
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_NUM_CLOCK_PARENTS;
700a6a5e: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a6a62: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a6a64: 9104         	str	r1, [sp, #0x10]
700a6a66: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a6a68: 9105         	str	r1, [sp, #0x14]
700a6a6a: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a6a6c: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a6a6e: 9912         	ldr	r1, [sp, #0x48]
700a6a70: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a6a72: 9000         	str	r0, [sp]
700a6a74: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a6a76: 9001         	str	r0, [sp, #0x4]
700a6a78: 200d         	movs	r0, #0xd
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a6a7a: 9002         	str	r0, [sp, #0x8]
700a6a7c: a803         	add	r0, sp, #0xc
700a6a7e: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a6a80: f7f5 face    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xaa64
700a6a84: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a6a86: 9811         	ldr	r0, [sp, #0x44]
700a6a88: b930         	cbnz	r0, 0x700a6a98 <Sciclient_pmGetModuleClkNumParent+0x88> @ imm = #0xc
700a6a8a: e7ff         	b	0x700a6a8c <Sciclient_pmGetModuleClkNumParent+0x7c> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a6a8c: 9800         	ldr	r0, [sp]
700a6a8e: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a6a92: 2802         	cmp	r0, #0x2
700a6a94: d004         	beq	0x700a6aa0 <Sciclient_pmGetModuleClkNumParent+0x90> @ imm = #0x8
700a6a96: e7ff         	b	0x700a6a98 <Sciclient_pmGetModuleClkNumParent+0x88> @ imm = #-0x2
700a6a98: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a6a9c: 9011         	str	r0, [sp, #0x44]
;     }
700a6a9e: e7ff         	b	0x700a6aa0 <Sciclient_pmGetModuleClkNumParent+0x90> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a6aa0: 9811         	ldr	r0, [sp, #0x44]
700a6aa2: b928         	cbnz	r0, 0x700a6ab0 <Sciclient_pmGetModuleClkNumParent+0xa0> @ imm = #0xa
700a6aa4: e7ff         	b	0x700a6aa6 <Sciclient_pmGetModuleClkNumParent+0x96> @ imm = #-0x2
;         *numParent = (uint32_t) response.num_parents;
700a6aa6: f89d 0028    	ldrb.w	r0, [sp, #0x28]
700a6aaa: 9913         	ldr	r1, [sp, #0x4c]
700a6aac: 6008         	str	r0, [r1]
;     }
700a6aae: e7ff         	b	0x700a6ab0 <Sciclient_pmGetModuleClkNumParent+0xa0> @ imm = #-0x2
;     return retVal;
700a6ab0: 9811         	ldr	r0, [sp, #0x44]
700a6ab2: b016         	add	sp, #0x58
700a6ab4: bd80         	pop	{r7, pc}
		...
700a6abe: 0000         	movs	r0, r0

700a6ac0 <xTaskPriorityDisinherit>:
; BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder) {
700a6ac0: b580         	push	{r7, lr}
700a6ac2: b084         	sub	sp, #0x10
700a6ac4: 9003         	str	r0, [sp, #0xc]
;   TCB_t *const pxTCB = pxMutexHolder;
700a6ac6: 9803         	ldr	r0, [sp, #0xc]
700a6ac8: 9002         	str	r0, [sp, #0x8]
700a6aca: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700a6acc: 9001         	str	r0, [sp, #0x4]
;   if (pxMutexHolder != NULL) {
700a6ace: 9803         	ldr	r0, [sp, #0xc]
700a6ad0: 2800         	cmp	r0, #0x0
700a6ad2: d044         	beq	0x700a6b5e <xTaskPriorityDisinherit+0x9e> @ imm = #0x88
700a6ad4: e7ff         	b	0x700a6ad6 <xTaskPriorityDisinherit+0x16> @ imm = #-0x2
;     (pxTCB->uxMutexesHeld)--;
700a6ad6: 9902         	ldr	r1, [sp, #0x8]
700a6ad8: 6e48         	ldr	r0, [r1, #0x64]
700a6ada: 3801         	subs	r0, #0x1
700a6adc: 6648         	str	r0, [r1, #0x64]
;     if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
700a6ade: 9902         	ldr	r1, [sp, #0x8]
700a6ae0: 6ac8         	ldr	r0, [r1, #0x2c]
700a6ae2: 6e09         	ldr	r1, [r1, #0x60]
700a6ae4: 4288         	cmp	r0, r1
700a6ae6: d038         	beq	0x700a6b5a <xTaskPriorityDisinherit+0x9a> @ imm = #0x70
700a6ae8: e7ff         	b	0x700a6aea <xTaskPriorityDisinherit+0x2a> @ imm = #-0x2
;       if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
700a6aea: 9802         	ldr	r0, [sp, #0x8]
700a6aec: 6e40         	ldr	r0, [r0, #0x64]
700a6aee: bb90         	cbnz	r0, 0x700a6b56 <xTaskPriorityDisinherit+0x96> @ imm = #0x64
700a6af0: e7ff         	b	0x700a6af2 <xTaskPriorityDisinherit+0x32> @ imm = #-0x2
;         if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a6af2: 9802         	ldr	r0, [sp, #0x8]
700a6af4: 3004         	adds	r0, #0x4
700a6af6: f004 fffb    	bl	0x700abaf0 <uxListRemove> @ imm = #0x4ff6
700a6afa: b908         	cbnz	r0, 0x700a6b00 <xTaskPriorityDisinherit+0x40> @ imm = #0x2
700a6afc: e7ff         	b	0x700a6afe <xTaskPriorityDisinherit+0x3e> @ imm = #-0x2
;         } else {
700a6afe: e000         	b	0x700a6b02 <xTaskPriorityDisinherit+0x42> @ imm = #0x0
700a6b00: e7ff         	b	0x700a6b02 <xTaskPriorityDisinherit+0x42> @ imm = #-0x2
;         pxTCB->uxPriority = pxTCB->uxBasePriority;
700a6b02: 9902         	ldr	r1, [sp, #0x8]
700a6b04: 6e08         	ldr	r0, [r1, #0x60]
700a6b06: 62c8         	str	r0, [r1, #0x2c]
;         listSET_LIST_ITEM_VALUE(
700a6b08: 9902         	ldr	r1, [sp, #0x8]
700a6b0a: 6ac8         	ldr	r0, [r1, #0x2c]
700a6b0c: f1c0 0020    	rsb.w	r0, r0, #0x20
700a6b10: 6188         	str	r0, [r1, #0x18]
;         prvAddTaskToReadyList(pxTCB);
700a6b12: 9802         	ldr	r0, [sp, #0x8]
700a6b14: 6ac0         	ldr	r0, [r0, #0x2c]
700a6b16: f640 51dc    	movw	r1, #0xddc
700a6b1a: f2c7 010b    	movt	r1, #0x700b
700a6b1e: 6809         	ldr	r1, [r1]
700a6b20: 4288         	cmp	r0, r1
700a6b22: d908         	bls	0x700a6b36 <xTaskPriorityDisinherit+0x76> @ imm = #0x10
700a6b24: e7ff         	b	0x700a6b26 <xTaskPriorityDisinherit+0x66> @ imm = #-0x2
700a6b26: 9802         	ldr	r0, [sp, #0x8]
700a6b28: 6ac0         	ldr	r0, [r0, #0x2c]
700a6b2a: f640 51dc    	movw	r1, #0xddc
700a6b2e: f2c7 010b    	movt	r1, #0x700b
700a6b32: 6008         	str	r0, [r1]
700a6b34: e7ff         	b	0x700a6b36 <xTaskPriorityDisinherit+0x76> @ imm = #-0x2
700a6b36: 9902         	ldr	r1, [sp, #0x8]
700a6b38: 6ac8         	ldr	r0, [r1, #0x2c]
700a6b3a: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a6b3e: f244 40f8    	movw	r0, #0x44f8
700a6b42: f2c7 0008    	movt	r0, #0x7008
700a6b46: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a6b4a: 3104         	adds	r1, #0x4
700a6b4c: f005 fda8    	bl	0x700ac6a0 <vListInsertEnd> @ imm = #0x5b50
700a6b50: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700a6b52: 9001         	str	r0, [sp, #0x4]
;       } else {
700a6b54: e000         	b	0x700a6b58 <xTaskPriorityDisinherit+0x98> @ imm = #0x0
700a6b56: e7ff         	b	0x700a6b58 <xTaskPriorityDisinherit+0x98> @ imm = #-0x2
;     } else {
700a6b58: e000         	b	0x700a6b5c <xTaskPriorityDisinherit+0x9c> @ imm = #0x0
700a6b5a: e7ff         	b	0x700a6b5c <xTaskPriorityDisinherit+0x9c> @ imm = #-0x2
;   } else {
700a6b5c: e000         	b	0x700a6b60 <xTaskPriorityDisinherit+0xa0> @ imm = #0x0
700a6b5e: e7ff         	b	0x700a6b60 <xTaskPriorityDisinherit+0xa0> @ imm = #-0x2
;   return xReturn;
700a6b60: 9801         	ldr	r0, [sp, #0x4]
700a6b62: b004         	add	sp, #0x10
700a6b64: bd80         	pop	{r7, pc}
		...
700a6b6e: 0000         	movs	r0, r0

700a6b70 <CSL_intaggrIsIntrPending>:
; {
700a6b70: b580         	push	{r7, lr}
700a6b72: b088         	sub	sp, #0x20
700a6b74: 9007         	str	r0, [sp, #0x1c]
700a6b76: 9106         	str	r1, [sp, #0x18]
700a6b78: f88d 2017    	strb.w	r2, [sp, #0x17]
700a6b7c: 2000         	movs	r0, #0x0
;     bool     retVal = (bool)false;
700a6b7e: f88d 0016    	strb.w	r0, [sp, #0x16]
;     if( CSL_intaggrIsValidStatusBitNum(pCfg, statusBitNum) )
700a6b82: 9807         	ldr	r0, [sp, #0x1c]
700a6b84: 9906         	ldr	r1, [sp, #0x18]
700a6b86: f005 fbeb    	bl	0x700ac360 <CSL_intaggrIsValidStatusBitNum> @ imm = #0x57d6
700a6b8a: b3e8         	cbz	r0, 0x700a6c08 <CSL_intaggrIsIntrPending+0x98> @ imm = #0x7a
700a6b8c: e7ff         	b	0x700a6b8e <CSL_intaggrIsIntrPending+0x1e> @ imm = #-0x2
;         regNum = statusBitNum >> 6U;
700a6b8e: 9806         	ldr	r0, [sp, #0x18]
700a6b90: 0980         	lsrs	r0, r0, #0x6
700a6b92: 9001         	str	r0, [sp, #0x4]
;         bitNum = statusBitNum & (uint32_t)0x003FU;
700a6b94: 9806         	ldr	r0, [sp, #0x18]
700a6b96: f000 003f    	and	r0, r0, #0x3f
700a6b9a: 9000         	str	r0, [sp]
;         if( bMaskedStatus == (bool)true )
700a6b9c: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a6ba0: 07c0         	lsls	r0, r0, #0x1f
700a6ba2: b158         	cbz	r0, 0x700a6bbc <CSL_intaggrIsIntrPending+0x4c> @ imm = #0x16
700a6ba4: e7ff         	b	0x700a6ba6 <CSL_intaggrIsIntrPending+0x36> @ imm = #-0x2
;             regVal = CSL_REG64_RD( &pCfg->pIntrRegs->VINT[regNum].STATUSM );
700a6ba6: 9807         	ldr	r0, [sp, #0x1c]
700a6ba8: 6880         	ldr	r0, [r0, #0x8]
700a6baa: 9901         	ldr	r1, [sp, #0x4]
700a6bac: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6bb0: 3020         	adds	r0, #0x20
700a6bb2: f007 fa45    	bl	0x700ae040 <CSL_REG64_RD_RAW> @ imm = #0x748a
700a6bb6: 9103         	str	r1, [sp, #0xc]
700a6bb8: 9002         	str	r0, [sp, #0x8]
;         }
700a6bba: e00a         	b	0x700a6bd2 <CSL_intaggrIsIntrPending+0x62> @ imm = #0x14
;             regVal = CSL_REG64_RD( &pCfg->pIntrRegs->VINT[regNum].STATUS_SET );
700a6bbc: 9807         	ldr	r0, [sp, #0x1c]
700a6bbe: 6880         	ldr	r0, [r0, #0x8]
700a6bc0: 9901         	ldr	r1, [sp, #0x4]
700a6bc2: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6bc6: 3010         	adds	r0, #0x10
700a6bc8: f007 fa3a    	bl	0x700ae040 <CSL_REG64_RD_RAW> @ imm = #0x7474
700a6bcc: 9103         	str	r1, [sp, #0xc]
700a6bce: 9002         	str	r0, [sp, #0x8]
700a6bd0: e7ff         	b	0x700a6bd2 <CSL_intaggrIsIntrPending+0x62> @ imm = #-0x2
;         if( (regVal & (((uint64_t)1U) << bitNum)) == 0U )
700a6bd2: 9802         	ldr	r0, [sp, #0x8]
700a6bd4: 9903         	ldr	r1, [sp, #0xc]
700a6bd6: 9a00         	ldr	r2, [sp]
700a6bd8: 40d0         	lsrs	r0, r2
700a6bda: f1c2 0320    	rsb.w	r3, r2, #0x20
700a6bde: fa01 f303    	lsl.w	r3, r1, r3
700a6be2: 4318         	orrs	r0, r3
700a6be4: 3a20         	subs	r2, #0x20
700a6be6: 40d1         	lsrs	r1, r2
700a6be8: 2a00         	cmp	r2, #0x0
700a6bea: bf58         	it	pl
700a6bec: 4608         	movpl	r0, r1
700a6bee: ea4f 70c0    	lsl.w	r0, r0, #0x1f
700a6bf2: b920         	cbnz	r0, 0x700a6bfe <CSL_intaggrIsIntrPending+0x8e> @ imm = #0x8
700a6bf4: e7ff         	b	0x700a6bf6 <CSL_intaggrIsIntrPending+0x86> @ imm = #-0x2
700a6bf6: 2000         	movs	r0, #0x0
;             retVal = (bool)false; /* Interrupt is not pending */
700a6bf8: f88d 0016    	strb.w	r0, [sp, #0x16]
;         }
700a6bfc: e003         	b	0x700a6c06 <CSL_intaggrIsIntrPending+0x96> @ imm = #0x6
700a6bfe: 2001         	movs	r0, #0x1
;             retVal = (bool)true;  /* Interrupt is pending */
700a6c00: f88d 0016    	strb.w	r0, [sp, #0x16]
700a6c04: e7ff         	b	0x700a6c06 <CSL_intaggrIsIntrPending+0x96> @ imm = #-0x2
;     }
700a6c06: e7ff         	b	0x700a6c08 <CSL_intaggrIsIntrPending+0x98> @ imm = #-0x2
;     return retVal;
700a6c08: f89d 0016    	ldrb.w	r0, [sp, #0x16]
700a6c0c: f000 0001    	and	r0, r0, #0x1
700a6c10: b008         	add	sp, #0x20
700a6c12: bd80         	pop	{r7, pc}
		...

700a6c20 <Sciclient_rmIrqCheckLoop>:
; {
700a6c20: b580         	push	{r7, lr}
700a6c22: b088         	sub	sp, #0x20
700a6c24: 9007         	str	r0, [sp, #0x1c]
700a6c26: 2000         	movs	r0, #0x0
;     bool loop = false;
700a6c28: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a6c2c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a6c30: e7ff         	b	0x700a6c32 <Sciclient_rmIrqCheckLoop+0x12> @ imm = #-0x2
700a6c32: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a6c36: 9002         	str	r0, [sp, #0x8]
700a6c38: f007 fa5a    	bl	0x700ae0f0 <Sciclient_rmPsGetPsp> @ imm = #0x74b4
700a6c3c: 4601         	mov	r1, r0
700a6c3e: 9802         	ldr	r0, [sp, #0x8]
700a6c40: 4288         	cmp	r0, r1
700a6c42: da39         	bge	0x700a6cb8 <Sciclient_rmIrqCheckLoop+0x98> @ imm = #0x72
700a6c44: e7ff         	b	0x700a6c46 <Sciclient_rmIrqCheckLoop+0x26> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a6c46: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a6c4a: f006 fe31    	bl	0x700ad8b0 <Sciclient_rmPsGetIrqNode> @ imm = #0x6c62
700a6c4e: 9004         	str	r0, [sp, #0x10]
;         for (j = i + 1u; j < Sciclient_rmPsGetPsp(); j++) {
700a6c50: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a6c54: 3001         	adds	r0, #0x1
700a6c56: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a6c5a: e7ff         	b	0x700a6c5c <Sciclient_rmIrqCheckLoop+0x3c> @ imm = #-0x2
700a6c5c: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a6c60: 9001         	str	r0, [sp, #0x4]
700a6c62: f007 fa45    	bl	0x700ae0f0 <Sciclient_rmPsGetPsp> @ imm = #0x748a
700a6c66: 4601         	mov	r1, r0
700a6c68: 9801         	ldr	r0, [sp, #0x4]
700a6c6a: 4288         	cmp	r0, r1
700a6c6c: da17         	bge	0x700a6c9e <Sciclient_rmIrqCheckLoop+0x7e> @ imm = #0x2e
700a6c6e: e7ff         	b	0x700a6c70 <Sciclient_rmIrqCheckLoop+0x50> @ imm = #-0x2
;             future_n = Sciclient_rmPsGetIrqNode(j);
700a6c70: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a6c74: f006 fe1c    	bl	0x700ad8b0 <Sciclient_rmPsGetIrqNode> @ imm = #0x6c38
700a6c78: 9003         	str	r0, [sp, #0xc]
;             if (cur_n->id == future_n->id) {
700a6c7a: 9804         	ldr	r0, [sp, #0x10]
700a6c7c: 8800         	ldrh	r0, [r0]
700a6c7e: 9903         	ldr	r1, [sp, #0xc]
700a6c80: 8809         	ldrh	r1, [r1]
700a6c82: 4288         	cmp	r0, r1
700a6c84: d104         	bne	0x700a6c90 <Sciclient_rmIrqCheckLoop+0x70> @ imm = #0x8
700a6c86: e7ff         	b	0x700a6c88 <Sciclient_rmIrqCheckLoop+0x68> @ imm = #-0x2
700a6c88: 2001         	movs	r0, #0x1
;                 loop = true;
700a6c8a: f88d 001b    	strb.w	r0, [sp, #0x1b]
;                 break;
700a6c8e: e006         	b	0x700a6c9e <Sciclient_rmIrqCheckLoop+0x7e> @ imm = #0xc
;         }
700a6c90: e7ff         	b	0x700a6c92 <Sciclient_rmIrqCheckLoop+0x72> @ imm = #-0x2
;         for (j = i + 1u; j < Sciclient_rmPsGetPsp(); j++) {
700a6c92: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a6c96: 3001         	adds	r0, #0x1
700a6c98: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a6c9c: e7de         	b	0x700a6c5c <Sciclient_rmIrqCheckLoop+0x3c> @ imm = #-0x44
;         if (loop == true) {
700a6c9e: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a6ca2: 07c0         	lsls	r0, r0, #0x1f
700a6ca4: b108         	cbz	r0, 0x700a6caa <Sciclient_rmIrqCheckLoop+0x8a> @ imm = #0x2
700a6ca6: e7ff         	b	0x700a6ca8 <Sciclient_rmIrqCheckLoop+0x88> @ imm = #-0x2
;             break;
700a6ca8: e006         	b	0x700a6cb8 <Sciclient_rmIrqCheckLoop+0x98> @ imm = #0xc
;     }
700a6caa: e7ff         	b	0x700a6cac <Sciclient_rmIrqCheckLoop+0x8c> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a6cac: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a6cb0: 3001         	adds	r0, #0x1
700a6cb2: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a6cb6: e7bc         	b	0x700a6c32 <Sciclient_rmIrqCheckLoop+0x12> @ imm = #-0x88
;     return loop;
700a6cb8: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a6cbc: f000 0001    	and	r0, r0, #0x1
700a6cc0: b008         	add	sp, #0x20
700a6cc2: bd80         	pop	{r7, pc}
		...

700a6cd0 <UART_IsBaseAddrValid>:
; {
700a6cd0: b082         	sub	sp, #0x8
700a6cd2: 9001         	str	r0, [sp, #0x4]
700a6cd4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = (int32_t)-3;
700a6cd8: 9000         	str	r0, [sp]
;     if ((baseAddr == CSL_UART0_BASE) ||
700a6cda: 9801         	ldr	r0, [sp, #0x4]
700a6cdc: f1b0 7f20    	cmp.w	r0, #0x2800000
700a6ce0: d042         	beq	0x700a6d68 <UART_IsBaseAddrValid+0x98> @ imm = #0x84
700a6ce2: e7ff         	b	0x700a6ce4 <UART_IsBaseAddrValid+0x14> @ imm = #-0x2
;         (baseAddr == CSL_UART1_BASE) ||
700a6ce4: 9801         	ldr	r0, [sp, #0x4]
700a6ce6: 2100         	movs	r1, #0x0
700a6ce8: f2c0 2181    	movt	r1, #0x281
700a6cec: 4288         	cmp	r0, r1
700a6cee: d03b         	beq	0x700a6d68 <UART_IsBaseAddrValid+0x98> @ imm = #0x76
700a6cf0: e7ff         	b	0x700a6cf2 <UART_IsBaseAddrValid+0x22> @ imm = #-0x2
;         (baseAddr == CSL_UART2_BASE) ||
700a6cf2: 9801         	ldr	r0, [sp, #0x4]
700a6cf4: 2100         	movs	r1, #0x0
700a6cf6: f2c0 2182    	movt	r1, #0x282
700a6cfa: 4288         	cmp	r0, r1
700a6cfc: d034         	beq	0x700a6d68 <UART_IsBaseAddrValid+0x98> @ imm = #0x68
700a6cfe: e7ff         	b	0x700a6d00 <UART_IsBaseAddrValid+0x30> @ imm = #-0x2
;         (baseAddr == CSL_UART3_BASE) ||
700a6d00: 9801         	ldr	r0, [sp, #0x4]
700a6d02: 2100         	movs	r1, #0x0
700a6d04: f2c0 2183    	movt	r1, #0x283
700a6d08: 4288         	cmp	r0, r1
700a6d0a: d02d         	beq	0x700a6d68 <UART_IsBaseAddrValid+0x98> @ imm = #0x5a
700a6d0c: e7ff         	b	0x700a6d0e <UART_IsBaseAddrValid+0x3e> @ imm = #-0x2
;         (baseAddr == CSL_UART4_BASE) ||
700a6d0e: 9801         	ldr	r0, [sp, #0x4]
700a6d10: f1b0 7f21    	cmp.w	r0, #0x2840000
700a6d14: d028         	beq	0x700a6d68 <UART_IsBaseAddrValid+0x98> @ imm = #0x50
700a6d16: e7ff         	b	0x700a6d18 <UART_IsBaseAddrValid+0x48> @ imm = #-0x2
;         (baseAddr == CSL_UART5_BASE) ||
700a6d18: 9801         	ldr	r0, [sp, #0x4]
700a6d1a: 2100         	movs	r1, #0x0
700a6d1c: f2c0 2185    	movt	r1, #0x285
700a6d20: 4288         	cmp	r0, r1
700a6d22: d021         	beq	0x700a6d68 <UART_IsBaseAddrValid+0x98> @ imm = #0x42
700a6d24: e7ff         	b	0x700a6d26 <UART_IsBaseAddrValid+0x56> @ imm = #-0x2
;         (baseAddr == CSL_UART6_BASE) ||
700a6d26: 9801         	ldr	r0, [sp, #0x4]
700a6d28: 2100         	movs	r1, #0x0
700a6d2a: f2c0 2186    	movt	r1, #0x286
700a6d2e: 4288         	cmp	r0, r1
700a6d30: d01a         	beq	0x700a6d68 <UART_IsBaseAddrValid+0x98> @ imm = #0x34
700a6d32: e7ff         	b	0x700a6d34 <UART_IsBaseAddrValid+0x64> @ imm = #-0x2
;         (baseAddr == CSL_MCU_UART0_BASE) ||
700a6d34: 9801         	ldr	r0, [sp, #0x4]
700a6d36: f1b0 6f94    	cmp.w	r0, #0x4a00000
700a6d3a: d015         	beq	0x700a6d68 <UART_IsBaseAddrValid+0x98> @ imm = #0x2a
700a6d3c: e7ff         	b	0x700a6d3e <UART_IsBaseAddrValid+0x6e> @ imm = #-0x2
;         (baseAddr == CSL_MCU_UART1_BASE) ||
700a6d3e: 9801         	ldr	r0, [sp, #0x4]
700a6d40: 2100         	movs	r1, #0x0
700a6d42: f2c0 41a1    	movt	r1, #0x4a1
700a6d46: 4288         	cmp	r0, r1
700a6d48: d00e         	beq	0x700a6d68 <UART_IsBaseAddrValid+0x98> @ imm = #0x1c
700a6d4a: e7ff         	b	0x700a6d4c <UART_IsBaseAddrValid+0x7c> @ imm = #-0x2
;         (baseAddr == MCU_UART0_BASE_AFTER_ADDR_TRANSLATE) ||
700a6d4c: 9801         	ldr	r0, [sp, #0x4]
700a6d4e: 2100         	movs	r1, #0x0
700a6d50: f2c8 41a0    	movt	r1, #0x84a0
700a6d54: 4288         	cmp	r0, r1
700a6d56: d007         	beq	0x700a6d68 <UART_IsBaseAddrValid+0x98> @ imm = #0xe
700a6d58: e7ff         	b	0x700a6d5a <UART_IsBaseAddrValid+0x8a> @ imm = #-0x2
;         (baseAddr == MCU_UART1_BASE_AFTER_ADDR_TRANSLATE))
700a6d5a: 9801         	ldr	r0, [sp, #0x4]
700a6d5c: 2100         	movs	r1, #0x0
700a6d5e: f2c8 41a1    	movt	r1, #0x84a1
;     if ((baseAddr == CSL_UART0_BASE) ||
700a6d62: 4288         	cmp	r0, r1
700a6d64: d103         	bne	0x700a6d6e <UART_IsBaseAddrValid+0x9e> @ imm = #0x6
700a6d66: e7ff         	b	0x700a6d68 <UART_IsBaseAddrValid+0x98> @ imm = #-0x2
700a6d68: 2000         	movs	r0, #0x0
;         status = 0;
700a6d6a: 9000         	str	r0, [sp]
;     }
700a6d6c: e7ff         	b	0x700a6d6e <UART_IsBaseAddrValid+0x9e> @ imm = #-0x2
;     return status;
700a6d6e: 9800         	ldr	r0, [sp]
700a6d70: b002         	add	sp, #0x8
700a6d72: 4770         	bx	lr

700a6d74 <split>:
700a6d74: e92d48f0     	push	{r4, r5, r6, r7, r11, lr}
700a6d78: e1a04000     	mov	r4, r0
700a6d7c: e5900000     	ldr	r0, [r0]
700a6d80: e1a05001     	mov	r5, r1
700a6d84: e3c01001     	bic	r1, r0, #1
700a6d88: e0411005     	sub	r1, r1, r5
700a6d8c: e3510010     	cmp	r1, #16
700a6d90: 3a00001b     	blo	0x700a6e04 <split+0x90> @ imm = #0x6c
700a6d94: e2410008     	sub	r0, r1, #8
700a6d98: e0846005     	add	r6, r4, r5
700a6d9c: e59f106c     	ldr	r1, [pc, #0x6c]         @ 0x700a6e10 <split+0x9c>
700a6da0: e59f206c     	ldr	r2, [pc, #0x6c]         @ 0x700a6e14 <split+0xa0>
700a6da4: e5a60008     	str	r0, [r6, #0x8]!
700a6da8: e3c00001     	bic	r0, r0, #1
700a6dac: e3520007     	cmp	r2, #7
700a6db0: e0860000     	add	r0, r6, r0
700a6db4: e2807008     	add	r7, r0, #8
700a6db8: e0820001     	add	r0, r2, r1
700a6dbc: 82401008     	subhi	r1, r0, #8
700a6dc0: e1570001     	cmp	r7, r1
700a6dc4: 2a00000b     	bhs	0x700a6df8 <split+0x84> @ imm = #0x2c
700a6dc8: e5d70000     	ldrb	r0, [r7]
700a6dcc: e3100001     	tst	r0, #1
700a6dd0: 1a000008     	bne	0x700a6df8 <split+0x84> @ imm = #0x20
700a6dd4: e1a00007     	mov	r0, r7
700a6dd8: eb00170d     	bl	0x700aca14 <free_list_remove> @ imm = #0x5c34
700a6ddc: e5960000     	ldr	r0, [r6]
700a6de0: e5971000     	ldr	r1, [r7]
700a6de4: e2800008     	add	r0, r0, #8
700a6de8: e3c11001     	bic	r1, r1, #1
700a6dec: e3c00001     	bic	r0, r0, #1
700a6df0: e0800001     	add	r0, r0, r1
700a6df4: e5860000     	str	r0, [r6]
700a6df8: e1a00006     	mov	r0, r6
700a6dfc: eb0014c7     	bl	0x700ac120 <free_list_insert> @ imm = #0x531c
700a6e00: e1a00005     	mov	r0, r5
700a6e04: e3800001     	orr	r0, r0, #1
700a6e08: e5840000     	str	r0, [r4]
700a6e0c: e8bd88f0     	pop	{r4, r5, r6, r7, r11, pc}
700a6e10: 00 4e 08 70  	.word	0x70084e00
700a6e14: 00 00 01 00  	.word	0x00010000
700a6e18: 00 00 00 00  	.word	0x00000000
700a6e1c: 00 00 00 00  	.word	0x00000000

700a6e20 <vTaskResume>:
; void vTaskResume(TaskHandle_t xTaskToResume) {
700a6e20: b580         	push	{r7, lr}
700a6e22: b082         	sub	sp, #0x8
700a6e24: 9001         	str	r0, [sp, #0x4]
;   TCB_t *const pxTCB = xTaskToResume;
700a6e26: 9801         	ldr	r0, [sp, #0x4]
700a6e28: 9000         	str	r0, [sp]
;   if ((pxTCB != pxCurrentTCB) && (pxTCB != NULL)) {
700a6e2a: 9800         	ldr	r0, [sp]
700a6e2c: f640 51ac    	movw	r1, #0xdac
700a6e30: f2c7 010b    	movt	r1, #0x700b
700a6e34: 6809         	ldr	r1, [r1]
700a6e36: 4288         	cmp	r0, r1
700a6e38: d041         	beq	0x700a6ebe <vTaskResume+0x9e> @ imm = #0x82
700a6e3a: e7ff         	b	0x700a6e3c <vTaskResume+0x1c> @ imm = #-0x2
700a6e3c: 9800         	ldr	r0, [sp]
700a6e3e: 2800         	cmp	r0, #0x0
700a6e40: d03d         	beq	0x700a6ebe <vTaskResume+0x9e> @ imm = #0x7a
700a6e42: e7ff         	b	0x700a6e44 <vTaskResume+0x24> @ imm = #-0x2
;     taskENTER_CRITICAL();
700a6e44: f005 fec4    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0x5d88
;       if (prvTaskIsTaskSuspended(pxTCB) != pdFALSE) {
700a6e48: 9800         	ldr	r0, [sp]
700a6e4a: f004 fc21    	bl	0x700ab690 <prvTaskIsTaskSuspended> @ imm = #0x4842
700a6e4e: b390         	cbz	r0, 0x700a6eb6 <vTaskResume+0x96> @ imm = #0x64
700a6e50: e7ff         	b	0x700a6e52 <vTaskResume+0x32> @ imm = #-0x2
;         (void)uxListRemove(&(pxTCB->xStateListItem));
700a6e52: 9800         	ldr	r0, [sp]
700a6e54: 3004         	adds	r0, #0x4
700a6e56: f004 fe4b    	bl	0x700abaf0 <uxListRemove> @ imm = #0x4c96
;         prvAddTaskToReadyList(pxTCB);
700a6e5a: 9800         	ldr	r0, [sp]
700a6e5c: 6ac0         	ldr	r0, [r0, #0x2c]
700a6e5e: f640 51dc    	movw	r1, #0xddc
700a6e62: f2c7 010b    	movt	r1, #0x700b
700a6e66: 6809         	ldr	r1, [r1]
700a6e68: 4288         	cmp	r0, r1
700a6e6a: d908         	bls	0x700a6e7e <vTaskResume+0x5e> @ imm = #0x10
700a6e6c: e7ff         	b	0x700a6e6e <vTaskResume+0x4e> @ imm = #-0x2
700a6e6e: 9800         	ldr	r0, [sp]
700a6e70: 6ac0         	ldr	r0, [r0, #0x2c]
700a6e72: f640 51dc    	movw	r1, #0xddc
700a6e76: f2c7 010b    	movt	r1, #0x700b
700a6e7a: 6008         	str	r0, [r1]
700a6e7c: e7ff         	b	0x700a6e7e <vTaskResume+0x5e> @ imm = #-0x2
700a6e7e: 9900         	ldr	r1, [sp]
700a6e80: 6ac8         	ldr	r0, [r1, #0x2c]
700a6e82: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a6e86: f244 40f8    	movw	r0, #0x44f8
700a6e8a: f2c7 0008    	movt	r0, #0x7008
700a6e8e: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a6e92: 3104         	adds	r1, #0x4
700a6e94: f005 fc04    	bl	0x700ac6a0 <vListInsertEnd> @ imm = #0x5808
;         if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a6e98: 9800         	ldr	r0, [sp]
700a6e9a: 6ac0         	ldr	r0, [r0, #0x2c]
700a6e9c: f640 51ac    	movw	r1, #0xdac
700a6ea0: f2c7 010b    	movt	r1, #0x700b
700a6ea4: 6809         	ldr	r1, [r1]
700a6ea6: 6ac9         	ldr	r1, [r1, #0x2c]
700a6ea8: 4288         	cmp	r0, r1
700a6eaa: d302         	blo	0x700a6eb2 <vTaskResume+0x92> @ imm = #0x4
700a6eac: e7ff         	b	0x700a6eae <vTaskResume+0x8e> @ imm = #-0x2
;           taskYIELD_IF_USING_PREEMPTION();
700a6eae: df00         	svc	#0x0
;         } else {
700a6eb0: e000         	b	0x700a6eb4 <vTaskResume+0x94> @ imm = #0x0
700a6eb2: e7ff         	b	0x700a6eb4 <vTaskResume+0x94> @ imm = #-0x2
;       } else {
700a6eb4: e000         	b	0x700a6eb8 <vTaskResume+0x98> @ imm = #0x0
700a6eb6: e7ff         	b	0x700a6eb8 <vTaskResume+0x98> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700a6eb8: f004 ff0a    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x4e14
;   } else {
700a6ebc: e000         	b	0x700a6ec0 <vTaskResume+0xa0> @ imm = #0x0
700a6ebe: e7ff         	b	0x700a6ec0 <vTaskResume+0xa0> @ imm = #-0x2
; }
700a6ec0: b002         	add	sp, #0x8
700a6ec2: bd80         	pop	{r7, pc}
		...

700a6ed0 <xQueueGenericSendFromISR>:
; {
700a6ed0: b580         	push	{r7, lr}
700a6ed2: b08a         	sub	sp, #0x28
700a6ed4: 9009         	str	r0, [sp, #0x24]
700a6ed6: 9108         	str	r1, [sp, #0x20]
700a6ed8: 9207         	str	r2, [sp, #0x1c]
700a6eda: 9306         	str	r3, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a6edc: 9809         	ldr	r0, [sp, #0x24]
700a6ede: 9003         	str	r0, [sp, #0xc]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a6ee0: f007 ef6e    	blx	0x700aedc0 <HwiP_disable> @ imm = #0x7edc
700a6ee4: 9004         	str	r0, [sp, #0x10]
;         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
700a6ee6: 9803         	ldr	r0, [sp, #0xc]
700a6ee8: 6b80         	ldr	r0, [r0, #0x38]
700a6eea: 9903         	ldr	r1, [sp, #0xc]
700a6eec: 6bc9         	ldr	r1, [r1, #0x3c]
700a6eee: 4288         	cmp	r0, r1
700a6ef0: d304         	blo	0x700a6efc <xQueueGenericSendFromISR+0x2c> @ imm = #0x8
700a6ef2: e7ff         	b	0x700a6ef4 <xQueueGenericSendFromISR+0x24> @ imm = #-0x2
700a6ef4: 9806         	ldr	r0, [sp, #0x18]
700a6ef6: 2802         	cmp	r0, #0x2
700a6ef8: d133         	bne	0x700a6f62 <xQueueGenericSendFromISR+0x92> @ imm = #0x66
700a6efa: e7ff         	b	0x700a6efc <xQueueGenericSendFromISR+0x2c> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
700a6efc: 9803         	ldr	r0, [sp, #0xc]
700a6efe: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a6f02: f88d 000b    	strb.w	r0, [sp, #0xb]
;             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
700a6f06: 9803         	ldr	r0, [sp, #0xc]
700a6f08: 6b80         	ldr	r0, [r0, #0x38]
700a6f0a: 9001         	str	r0, [sp, #0x4]
;             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
700a6f0c: 9803         	ldr	r0, [sp, #0xc]
700a6f0e: 9908         	ldr	r1, [sp, #0x20]
700a6f10: 9a06         	ldr	r2, [sp, #0x18]
700a6f12: f7fe f86d    	bl	0x700a4ff0 <prvCopyDataToQueue> @ imm = #-0x1f26
;             if( cTxLock == queueUNLOCKED )
700a6f16: f99d 000b    	ldrsb.w	r0, [sp, #0xb]
700a6f1a: 3001         	adds	r0, #0x1
700a6f1c: b9b8         	cbnz	r0, 0x700a6f4e <xQueueGenericSendFromISR+0x7e> @ imm = #0x2e
700a6f1e: e7ff         	b	0x700a6f20 <xQueueGenericSendFromISR+0x50> @ imm = #-0x2
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a6f20: 9803         	ldr	r0, [sp, #0xc]
700a6f22: 6a40         	ldr	r0, [r0, #0x24]
700a6f24: b188         	cbz	r0, 0x700a6f4a <xQueueGenericSendFromISR+0x7a> @ imm = #0x22
700a6f26: e7ff         	b	0x700a6f28 <xQueueGenericSendFromISR+0x58> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a6f28: 9803         	ldr	r0, [sp, #0xc]
700a6f2a: 3024         	adds	r0, #0x24
700a6f2c: f7fe ffe0    	bl	0x700a5ef0 <xTaskRemoveFromEventList> @ imm = #-0x1040
700a6f30: b148         	cbz	r0, 0x700a6f46 <xQueueGenericSendFromISR+0x76> @ imm = #0x12
700a6f32: e7ff         	b	0x700a6f34 <xQueueGenericSendFromISR+0x64> @ imm = #-0x2
;                                 if( pxHigherPriorityTaskWoken != NULL )
700a6f34: 9807         	ldr	r0, [sp, #0x1c]
700a6f36: b120         	cbz	r0, 0x700a6f42 <xQueueGenericSendFromISR+0x72> @ imm = #0x8
700a6f38: e7ff         	b	0x700a6f3a <xQueueGenericSendFromISR+0x6a> @ imm = #-0x2
;                                     *pxHigherPriorityTaskWoken = pdTRUE;
700a6f3a: 9907         	ldr	r1, [sp, #0x1c]
700a6f3c: 2001         	movs	r0, #0x1
700a6f3e: 6008         	str	r0, [r1]
;                                 }
700a6f40: e000         	b	0x700a6f44 <xQueueGenericSendFromISR+0x74> @ imm = #0x0
700a6f42: e7ff         	b	0x700a6f44 <xQueueGenericSendFromISR+0x74> @ imm = #-0x2
;                             }
700a6f44: e000         	b	0x700a6f48 <xQueueGenericSendFromISR+0x78> @ imm = #0x0
700a6f46: e7ff         	b	0x700a6f48 <xQueueGenericSendFromISR+0x78> @ imm = #-0x2
;                         }
700a6f48: e000         	b	0x700a6f4c <xQueueGenericSendFromISR+0x7c> @ imm = #0x0
700a6f4a: e7ff         	b	0x700a6f4c <xQueueGenericSendFromISR+0x7c> @ imm = #-0x2
;             }
700a6f4c: e006         	b	0x700a6f5c <xQueueGenericSendFromISR+0x8c> @ imm = #0xc
;                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
700a6f4e: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a6f52: 3001         	adds	r0, #0x1
700a6f54: 9903         	ldr	r1, [sp, #0xc]
700a6f56: f881 0045    	strb.w	r0, [r1, #0x45]
700a6f5a: e7ff         	b	0x700a6f5c <xQueueGenericSendFromISR+0x8c> @ imm = #-0x2
700a6f5c: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a6f5e: 9005         	str	r0, [sp, #0x14]
;         }
700a6f60: e002         	b	0x700a6f68 <xQueueGenericSendFromISR+0x98> @ imm = #0x4
700a6f62: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
700a6f64: 9005         	str	r0, [sp, #0x14]
700a6f66: e7ff         	b	0x700a6f68 <xQueueGenericSendFromISR+0x98> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a6f68: 9804         	ldr	r0, [sp, #0x10]
700a6f6a: f007 ef4a    	blx	0x700aee00 <HwiP_restore> @ imm = #0x7e94
;     return xReturn;
700a6f6e: 9805         	ldr	r0, [sp, #0x14]
700a6f70: b00a         	add	sp, #0x28
700a6f72: bd80         	pop	{r7, pc}
		...

700a6f80 <prvCheckForValidListAndQueue>:
;     {
700a6f80: b580         	push	{r7, lr}
700a6f82: b084         	sub	sp, #0x10
;         taskENTER_CRITICAL();
700a6f84: f005 fe24    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0x5c48
;             if( xTimerQueue == NULL )
700a6f88: f640 50f8    	movw	r0, #0xdf8
700a6f8c: f2c7 000b    	movt	r0, #0x700b
700a6f90: 6800         	ldr	r0, [r0]
700a6f92: 2800         	cmp	r0, #0x0
700a6f94: d140         	bne	0x700a7018 <prvCheckForValidListAndQueue+0x98> @ imm = #0x80
700a6f96: e7ff         	b	0x700a6f98 <prvCheckForValidListAndQueue+0x18> @ imm = #-0x2
;                 vListInitialise( &xActiveTimerList1 );
700a6f98: f644 5010    	movw	r0, #0x4d10
700a6f9c: f2c7 0008    	movt	r0, #0x7008
700a6fa0: 9002         	str	r0, [sp, #0x8]
700a6fa2: f005 ff8d    	bl	0x700acec0 <vListInitialise> @ imm = #0x5f1a
;                 vListInitialise( &xActiveTimerList2 );
700a6fa6: f644 5024    	movw	r0, #0x4d24
700a6faa: f2c7 0008    	movt	r0, #0x7008
700a6fae: 9003         	str	r0, [sp, #0xc]
700a6fb0: f005 ff86    	bl	0x700acec0 <vListInitialise> @ imm = #0x5f0c
700a6fb4: 9902         	ldr	r1, [sp, #0x8]
700a6fb6: 9803         	ldr	r0, [sp, #0xc]
;                 pxCurrentTimerList = &xActiveTimerList1;
700a6fb8: f644 52ac    	movw	r2, #0x4dac
700a6fbc: f2c7 0208    	movt	r2, #0x7008
700a6fc0: 6011         	str	r1, [r2]
;                 pxOverflowTimerList = &xActiveTimerList2;
700a6fc2: f644 51b8    	movw	r1, #0x4db8
700a6fc6: f2c7 0108    	movt	r1, #0x7008
700a6fca: 6008         	str	r0, [r1]
;                         xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
700a6fcc: 4669         	mov	r1, sp
700a6fce: 2000         	movs	r0, #0x0
700a6fd0: 6008         	str	r0, [r1]
700a6fd2: f244 7278    	movw	r2, #0x4778
700a6fd6: f2c7 0208    	movt	r2, #0x7008
700a6fda: f241 0308    	movw	r3, #0x1008
700a6fde: f2c7 0308    	movt	r3, #0x7008
700a6fe2: 2110         	movs	r1, #0x10
700a6fe4: 4608         	mov	r0, r1
700a6fe6: f004 fd0b    	bl	0x700aba00 <xQueueGenericCreateStatic> @ imm = #0x4a16
700a6fea: 4601         	mov	r1, r0
700a6fec: f640 50f8    	movw	r0, #0xdf8
700a6ff0: f2c7 000b    	movt	r0, #0x700b
700a6ff4: 6001         	str	r1, [r0]
;                         if( xTimerQueue != NULL )
700a6ff6: 6800         	ldr	r0, [r0]
700a6ff8: b160         	cbz	r0, 0x700a7014 <prvCheckForValidListAndQueue+0x94> @ imm = #0x18
700a6ffa: e7ff         	b	0x700a6ffc <prvCheckForValidListAndQueue+0x7c> @ imm = #-0x2
;                             vQueueAddToRegistry( xTimerQueue, "TmrQ" );
700a6ffc: f640 50f8    	movw	r0, #0xdf8
700a7000: f2c7 000b    	movt	r0, #0x700b
700a7004: 6800         	ldr	r0, [r0]
700a7006: f640 11de    	movw	r1, #0x9de
700a700a: f2c7 010b    	movt	r1, #0x700b
700a700e: f004 fa3f    	bl	0x700ab490 <vQueueAddToRegistry> @ imm = #0x447e
;                         }
700a7012: e000         	b	0x700a7016 <prvCheckForValidListAndQueue+0x96> @ imm = #0x0
700a7014: e7ff         	b	0x700a7016 <prvCheckForValidListAndQueue+0x96> @ imm = #-0x2
;             }
700a7016: e000         	b	0x700a701a <prvCheckForValidListAndQueue+0x9a> @ imm = #0x0
700a7018: e7ff         	b	0x700a701a <prvCheckForValidListAndQueue+0x9a> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a701a: f004 fe59    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x4cb2
;     }
700a701e: b004         	add	sp, #0x10
700a7020: bd80         	pop	{r7, pc}
		...
700a702e: 0000         	movs	r0, r0

700a7030 <Udma_rmAllocEvent>:
; {
700a7030: b580         	push	{r7, lr}
700a7032: b088         	sub	sp, #0x20
700a7034: 9007         	str	r0, [sp, #0x1c]
700a7036: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            globalEvent = UDMA_EVENT_INVALID;
700a703a: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a703c: 9807         	ldr	r0, [sp, #0x1c]
700a703e: f500 70ea    	add.w	r0, r0, #0x1d4
700a7042: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a7044: 9807         	ldr	r0, [sp, #0x1c]
700a7046: f500 609f    	add.w	r0, r0, #0x4f8
700a704a: f04f 31ff    	mov.w	r1, #0xffffffff
700a704e: f001 fe0f    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x1c1e
700a7052: 2000         	movs	r0, #0x0
;     for(i = 0U; i < rmInitPrms->numGlobalEvent; i++)
700a7054: 9005         	str	r0, [sp, #0x14]
700a7056: e7ff         	b	0x700a7058 <Udma_rmAllocEvent+0x28> @ imm = #-0x2
700a7058: 9805         	ldr	r0, [sp, #0x14]
700a705a: 9901         	ldr	r1, [sp, #0x4]
700a705c: f8d1 10dc    	ldr.w	r1, [r1, #0xdc]
700a7060: 4288         	cmp	r0, r1
700a7062: d22d         	bhs	0x700a70c0 <Udma_rmAllocEvent+0x90> @ imm = #0x5a
700a7064: e7ff         	b	0x700a7066 <Udma_rmAllocEvent+0x36> @ imm = #-0x2
;         offset = i >> 5U;
700a7066: 9805         	ldr	r0, [sp, #0x14]
700a7068: 0940         	lsrs	r0, r0, #0x5
700a706a: 9004         	str	r0, [sp, #0x10]
;         bitPos = i - (offset << 5U);
700a706c: 9805         	ldr	r0, [sp, #0x14]
700a706e: 9904         	ldr	r1, [sp, #0x10]
700a7070: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a7074: 9003         	str	r0, [sp, #0xc]
;         bitMask = (uint32_t) 1U << bitPos;
700a7076: 9903         	ldr	r1, [sp, #0xc]
700a7078: 2001         	movs	r0, #0x1
700a707a: 4088         	lsls	r0, r1
700a707c: 9002         	str	r0, [sp, #0x8]
;         if((drvHandle->globalEventFlag[offset] & bitMask) == bitMask)
700a707e: 9807         	ldr	r0, [sp, #0x1c]
700a7080: 9904         	ldr	r1, [sp, #0x10]
700a7082: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7086: f8d0 0424    	ldr.w	r0, [r0, #0x424]
700a708a: 9902         	ldr	r1, [sp, #0x8]
700a708c: 4008         	ands	r0, r1
700a708e: 4288         	cmp	r0, r1
700a7090: d111         	bne	0x700a70b6 <Udma_rmAllocEvent+0x86> @ imm = #0x22
700a7092: e7ff         	b	0x700a7094 <Udma_rmAllocEvent+0x64> @ imm = #-0x2
;             drvHandle->globalEventFlag[offset] &= ~bitMask;
700a7094: 9a02         	ldr	r2, [sp, #0x8]
700a7096: 9807         	ldr	r0, [sp, #0x1c]
700a7098: 9904         	ldr	r1, [sp, #0x10]
700a709a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a709e: f8d1 0424    	ldr.w	r0, [r1, #0x424]
700a70a2: 4390         	bics	r0, r2
700a70a4: f8c1 0424    	str.w	r0, [r1, #0x424]
;             globalEvent = i + rmInitPrms->startGlobalEvent;  /* Add start offset */
700a70a8: 9805         	ldr	r0, [sp, #0x14]
700a70aa: 9901         	ldr	r1, [sp, #0x4]
700a70ac: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a70b0: 4408         	add	r0, r1
700a70b2: 9006         	str	r0, [sp, #0x18]
;             break;
700a70b4: e004         	b	0x700a70c0 <Udma_rmAllocEvent+0x90> @ imm = #0x8
;     }
700a70b6: e7ff         	b	0x700a70b8 <Udma_rmAllocEvent+0x88> @ imm = #-0x2
;     for(i = 0U; i < rmInitPrms->numGlobalEvent; i++)
700a70b8: 9805         	ldr	r0, [sp, #0x14]
700a70ba: 3001         	adds	r0, #0x1
700a70bc: 9005         	str	r0, [sp, #0x14]
700a70be: e7cb         	b	0x700a7058 <Udma_rmAllocEvent+0x28> @ imm = #-0x6a
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a70c0: 9807         	ldr	r0, [sp, #0x1c]
700a70c2: f500 609f    	add.w	r0, r0, #0x4f8
700a70c6: f003 f923    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x3246
;     return (globalEvent);
700a70ca: 9806         	ldr	r0, [sp, #0x18]
700a70cc: b008         	add	sp, #0x20
700a70ce: bd80         	pop	{r7, pc}

700a70d0 <Udma_rmAllocVintr>:
; {
700a70d0: b580         	push	{r7, lr}
700a70d2: b088         	sub	sp, #0x20
700a70d4: 9007         	str	r0, [sp, #0x1c]
700a70d6: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            vintrNum = UDMA_EVENT_INVALID;
700a70da: 9002         	str	r0, [sp, #0x8]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a70dc: 9807         	ldr	r0, [sp, #0x1c]
700a70de: f500 70ea    	add.w	r0, r0, #0x1d4
700a70e2: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a70e4: 9807         	ldr	r0, [sp, #0x1c]
700a70e6: f500 609f    	add.w	r0, r0, #0x4f8
700a70ea: f04f 31ff    	mov.w	r1, #0xffffffff
700a70ee: f001 fdbf    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x1b7e
700a70f2: 2000         	movs	r0, #0x0
;     for(i = 0U; i < rmInitPrms->numVintr; i++)
700a70f4: 9006         	str	r0, [sp, #0x18]
700a70f6: e7ff         	b	0x700a70f8 <Udma_rmAllocVintr+0x28> @ imm = #-0x2
700a70f8: 9806         	ldr	r0, [sp, #0x18]
700a70fa: 9901         	ldr	r1, [sp, #0x4]
700a70fc: f8d1 10e4    	ldr.w	r1, [r1, #0xe4]
700a7100: 4288         	cmp	r0, r1
700a7102: d22d         	bhs	0x700a7160 <Udma_rmAllocVintr+0x90> @ imm = #0x5a
700a7104: e7ff         	b	0x700a7106 <Udma_rmAllocVintr+0x36> @ imm = #-0x2
;         offset = i >> 5U;
700a7106: 9806         	ldr	r0, [sp, #0x18]
700a7108: 0940         	lsrs	r0, r0, #0x5
700a710a: 9005         	str	r0, [sp, #0x14]
;         bitPos = i - (offset << 5U);
700a710c: 9806         	ldr	r0, [sp, #0x18]
700a710e: 9905         	ldr	r1, [sp, #0x14]
700a7110: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a7114: 9004         	str	r0, [sp, #0x10]
;         bitMask = (uint32_t) 1U << bitPos;
700a7116: 9904         	ldr	r1, [sp, #0x10]
700a7118: 2001         	movs	r0, #0x1
700a711a: 4088         	lsls	r0, r1
700a711c: 9003         	str	r0, [sp, #0xc]
;         if((drvHandle->vintrFlag[offset] & bitMask) == bitMask)
700a711e: 9807         	ldr	r0, [sp, #0x1c]
700a7120: 9905         	ldr	r1, [sp, #0x14]
700a7122: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7126: f8d0 04a4    	ldr.w	r0, [r0, #0x4a4]
700a712a: 9903         	ldr	r1, [sp, #0xc]
700a712c: 4008         	ands	r0, r1
700a712e: 4288         	cmp	r0, r1
700a7130: d111         	bne	0x700a7156 <Udma_rmAllocVintr+0x86> @ imm = #0x22
700a7132: e7ff         	b	0x700a7134 <Udma_rmAllocVintr+0x64> @ imm = #-0x2
;             drvHandle->vintrFlag[offset] &= ~bitMask;
700a7134: 9a03         	ldr	r2, [sp, #0xc]
700a7136: 9807         	ldr	r0, [sp, #0x1c]
700a7138: 9905         	ldr	r1, [sp, #0x14]
700a713a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a713e: f8d1 04a4    	ldr.w	r0, [r1, #0x4a4]
700a7142: 4390         	bics	r0, r2
700a7144: f8c1 04a4    	str.w	r0, [r1, #0x4a4]
;             vintrNum = i + rmInitPrms->startVintr;  /* Add start offset */
700a7148: 9806         	ldr	r0, [sp, #0x18]
700a714a: 9901         	ldr	r1, [sp, #0x4]
700a714c: f8d1 10e0    	ldr.w	r1, [r1, #0xe0]
700a7150: 4408         	add	r0, r1
700a7152: 9002         	str	r0, [sp, #0x8]
;             break;
700a7154: e004         	b	0x700a7160 <Udma_rmAllocVintr+0x90> @ imm = #0x8
;     }
700a7156: e7ff         	b	0x700a7158 <Udma_rmAllocVintr+0x88> @ imm = #-0x2
;     for(i = 0U; i < rmInitPrms->numVintr; i++)
700a7158: 9806         	ldr	r0, [sp, #0x18]
700a715a: 3001         	adds	r0, #0x1
700a715c: 9006         	str	r0, [sp, #0x18]
700a715e: e7cb         	b	0x700a70f8 <Udma_rmAllocVintr+0x28> @ imm = #-0x6a
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a7160: 9807         	ldr	r0, [sp, #0x1c]
700a7162: f500 609f    	add.w	r0, r0, #0x4f8
700a7166: f003 f8d3    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x31a6
;     return (vintrNum);
700a716a: 9802         	ldr	r0, [sp, #0x8]
700a716c: b008         	add	sp, #0x20
700a716e: bd80         	pop	{r7, pc}

700a7170 <Sciclient_getContext>:
; {
700a7170: b084         	sub	sp, #0x10
700a7172: 9003         	str	r0, [sp, #0xc]
700a7174: 9102         	str	r1, [sp, #0x8]
700a7176: 200f         	movs	r0, #0xf
;     uint32_t retVal = SCICLIENT_CONTEXT_MAX_NUM;
700a7178: 9001         	str	r0, [sp, #0x4]
;     switch (coreId)
700a717a: 9802         	ldr	r0, [sp, #0x8]
700a717c: 9000         	str	r0, [sp]
700a717e: 2805         	cmp	r0, #0x5
700a7180: d841         	bhi	0x700a7206 <Sciclient_getContext+0x96> @ imm = #0x82
700a7182: 9900         	ldr	r1, [sp]
700a7184: e8df f001    	tbb	[pc, r1]
700a7188: 03 0d 17 21  	.word	0x21170d03
700a718c: 2b 35        	.short	0x352b
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a718e: 9803         	ldr	r0, [sp, #0xc]
700a7190: b918         	cbnz	r0, 0x700a719a <Sciclient_getContext+0x2a> @ imm = #0x6
700a7192: e7ff         	b	0x700a7194 <Sciclient_getContext+0x24> @ imm = #-0x2
700a7194: 200e         	movs	r0, #0xe
;             retVal = SCICLIENT_CONTEXT_M4_SEC_0;
700a7196: 9001         	str	r0, [sp, #0x4]
;         }
700a7198: e002         	b	0x700a71a0 <Sciclient_getContext+0x30> @ imm = #0x4
700a719a: 2008         	movs	r0, #0x8
;             retVal = SCICLIENT_CONTEXT_M4_NONSEC_0;
700a719c: 9001         	str	r0, [sp, #0x4]
700a719e: e7ff         	b	0x700a71a0 <Sciclient_getContext+0x30> @ imm = #-0x2
;         break;
700a71a0: e032         	b	0x700a7208 <Sciclient_getContext+0x98> @ imm = #0x64
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a71a2: 9803         	ldr	r0, [sp, #0xc]
700a71a4: b918         	cbnz	r0, 0x700a71ae <Sciclient_getContext+0x3e> @ imm = #0x6
700a71a6: e7ff         	b	0x700a71a8 <Sciclient_getContext+0x38> @ imm = #-0x2
700a71a8: 2000         	movs	r0, #0x0
;             retVal = SCICLIENT_CONTEXT_R5_0_SEC_0;
700a71aa: 9001         	str	r0, [sp, #0x4]
;         }
700a71ac: e002         	b	0x700a71b4 <Sciclient_getContext+0x44> @ imm = #0x4
700a71ae: 2001         	movs	r0, #0x1
;             retVal = SCICLIENT_CONTEXT_R5_0_NONSEC_0;
700a71b0: 9001         	str	r0, [sp, #0x4]
700a71b2: e7ff         	b	0x700a71b4 <Sciclient_getContext+0x44> @ imm = #-0x2
;         break;
700a71b4: e028         	b	0x700a7208 <Sciclient_getContext+0x98> @ imm = #0x50
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a71b6: 9803         	ldr	r0, [sp, #0xc]
700a71b8: b918         	cbnz	r0, 0x700a71c2 <Sciclient_getContext+0x52> @ imm = #0x6
700a71ba: e7ff         	b	0x700a71bc <Sciclient_getContext+0x4c> @ imm = #-0x2
700a71bc: 2002         	movs	r0, #0x2
;             retVal = SCICLIENT_CONTEXT_R5_0_SEC_1;
700a71be: 9001         	str	r0, [sp, #0x4]
;         }
700a71c0: e002         	b	0x700a71c8 <Sciclient_getContext+0x58> @ imm = #0x4
700a71c2: 2003         	movs	r0, #0x3
;             retVal = SCICLIENT_CONTEXT_R5_0_NONSEC_1;
700a71c4: 9001         	str	r0, [sp, #0x4]
700a71c6: e7ff         	b	0x700a71c8 <Sciclient_getContext+0x58> @ imm = #-0x2
;         break;
700a71c8: e01e         	b	0x700a7208 <Sciclient_getContext+0x98> @ imm = #0x3c
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a71ca: 9803         	ldr	r0, [sp, #0xc]
700a71cc: b918         	cbnz	r0, 0x700a71d6 <Sciclient_getContext+0x66> @ imm = #0x6
700a71ce: e7ff         	b	0x700a71d0 <Sciclient_getContext+0x60> @ imm = #-0x2
700a71d0: 2009         	movs	r0, #0x9
;             retVal = SCICLIENT_CONTEXT_R5_1_SEC_0;
700a71d2: 9001         	str	r0, [sp, #0x4]
;         }
700a71d4: e002         	b	0x700a71dc <Sciclient_getContext+0x6c> @ imm = #0x4
700a71d6: 200a         	movs	r0, #0xa
;             retVal = SCICLIENT_CONTEXT_R5_1_NONSEC_0;
700a71d8: 9001         	str	r0, [sp, #0x4]
700a71da: e7ff         	b	0x700a71dc <Sciclient_getContext+0x6c> @ imm = #-0x2
;         break;
700a71dc: e014         	b	0x700a7208 <Sciclient_getContext+0x98> @ imm = #0x28
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a71de: 9803         	ldr	r0, [sp, #0xc]
700a71e0: b918         	cbnz	r0, 0x700a71ea <Sciclient_getContext+0x7a> @ imm = #0x6
700a71e2: e7ff         	b	0x700a71e4 <Sciclient_getContext+0x74> @ imm = #-0x2
700a71e4: 200b         	movs	r0, #0xb
;             retVal = SCICLIENT_CONTEXT_R5_1_SEC_1;
700a71e6: 9001         	str	r0, [sp, #0x4]
;         }
700a71e8: e002         	b	0x700a71f0 <Sciclient_getContext+0x80> @ imm = #0x4
700a71ea: 200c         	movs	r0, #0xc
;             retVal = SCICLIENT_CONTEXT_R5_1_NONSEC_1;
700a71ec: 9001         	str	r0, [sp, #0x4]
700a71ee: e7ff         	b	0x700a71f0 <Sciclient_getContext+0x80> @ imm = #-0x2
;         break;
700a71f0: e00a         	b	0x700a7208 <Sciclient_getContext+0x98> @ imm = #0x14
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a71f2: 9803         	ldr	r0, [sp, #0xc]
700a71f4: b918         	cbnz	r0, 0x700a71fe <Sciclient_getContext+0x8e> @ imm = #0x6
700a71f6: e7ff         	b	0x700a71f8 <Sciclient_getContext+0x88> @ imm = #-0x2
700a71f8: 2004         	movs	r0, #0x4
;             retVal = SCICLIENT_CONTEXT_A53_SEC_0;
700a71fa: 9001         	str	r0, [sp, #0x4]
;         }
700a71fc: e002         	b	0x700a7204 <Sciclient_getContext+0x94> @ imm = #0x4
700a71fe: 2006         	movs	r0, #0x6
;             retVal = SCICLIENT_CONTEXT_A53_NONSEC_1;
700a7200: 9001         	str	r0, [sp, #0x4]
700a7202: e7ff         	b	0x700a7204 <Sciclient_getContext+0x94> @ imm = #-0x2
;         break;
700a7204: e000         	b	0x700a7208 <Sciclient_getContext+0x98> @ imm = #0x0
;         break;
700a7206: e7ff         	b	0x700a7208 <Sciclient_getContext+0x98> @ imm = #-0x2
;     return retVal;
700a7208: 9801         	ldr	r0, [sp, #0x4]
700a720a: b004         	add	sp, #0x10
700a720c: 4770         	bx	lr
700a720e: 0000         	movs	r0, r0

700a7210 <Pinmux_config>:
; {
700a7210: b580         	push	{r7, lr}
700a7212: b086         	sub	sp, #0x18
700a7214: 9005         	str	r0, [sp, #0x14]
700a7216: 9104         	str	r1, [sp, #0x10]
700a7218: 2000         	movs	r0, #0x0
;     uint32_t            isUnlocked = 0;
700a721a: 9001         	str	r0, [sp, #0x4]
;     if((NULL != pinmuxCfg) && (pinmuxCfg->offset != PINMUX_END))
700a721c: 9805         	ldr	r0, [sp, #0x14]
700a721e: 2800         	cmp	r0, #0x0
700a7220: d042         	beq	0x700a72a8 <Pinmux_config+0x98> @ imm = #0x84
700a7222: e7ff         	b	0x700a7224 <Pinmux_config+0x14> @ imm = #-0x2
700a7224: 9805         	ldr	r0, [sp, #0x14]
700a7226: f9b0 0000    	ldrsh.w	r0, [r0]
700a722a: 3001         	adds	r0, #0x1
700a722c: b3e0         	cbz	r0, 0x700a72a8 <Pinmux_config+0x98> @ imm = #0x78
700a722e: e7ff         	b	0x700a7230 <Pinmux_config+0x20> @ imm = #-0x2
;         if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a7230: 9804         	ldr	r0, [sp, #0x10]
700a7232: b920         	cbnz	r0, 0x700a723e <Pinmux_config+0x2e> @ imm = #0x8
700a7234: e7ff         	b	0x700a7236 <Pinmux_config+0x26> @ imm = #-0x2
700a7236: f44f 2074    	mov.w	r0, #0xf4000
;             baseAddr = CSL_PADCFG_CTRL0_CFG0_BASE + PADCFG_PMUX_OFFSET;
700a723a: 9003         	str	r0, [sp, #0xc]
;         }
700a723c: e005         	b	0x700a724a <Pinmux_config+0x3a> @ imm = #0xa
700a723e: f244 0000    	movw	r0, #0x4000
700a7242: f2c0 4008    	movt	r0, #0x408
;             baseAddr = CSL_MCU_PADCFG_CTRL0_CFG0_BASE + PADCFG_PMUX_OFFSET;
700a7246: 9003         	str	r0, [sp, #0xc]
700a7248: e7ff         	b	0x700a724a <Pinmux_config+0x3a> @ imm = #-0x2
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(baseAddr);
700a724a: 9803         	ldr	r0, [sp, #0xc]
700a724c: 2100         	movs	r1, #0x0
700a724e: f7fc fed7    	bl	0x700a4000 <AddrTranslateP_getLocalAddr> @ imm = #-0x3252
700a7252: 9003         	str	r0, [sp, #0xc]
;         if (pinmuxCfg->offset != PINMUX_END)
700a7254: 9805         	ldr	r0, [sp, #0x14]
700a7256: f9b0 0000    	ldrsh.w	r0, [r0]
700a725a: 3001         	adds	r0, #0x1
700a725c: b130         	cbz	r0, 0x700a726c <Pinmux_config+0x5c> @ imm = #0xc
700a725e: e7ff         	b	0x700a7260 <Pinmux_config+0x50> @ imm = #-0x2
700a7260: 2001         	movs	r0, #0x1
;             isUnlocked = 1;
700a7262: 9001         	str	r0, [sp, #0x4]
;             Pinmux_unlockMMR(domainId);
700a7264: 9804         	ldr	r0, [sp, #0x10]
700a7266: f7fd fc2b    	bl	0x700a4ac0 <Pinmux_unlockMMR> @ imm = #-0x27aa
;         }
700a726a: e7ff         	b	0x700a726c <Pinmux_config+0x5c> @ imm = #-0x2
;         while( pinmuxCfg->offset != PINMUX_END )
700a726c: e7ff         	b	0x700a726e <Pinmux_config+0x5e> @ imm = #-0x2
700a726e: 9805         	ldr	r0, [sp, #0x14]
700a7270: f9b0 0000    	ldrsh.w	r0, [r0]
700a7274: 3001         	adds	r0, #0x1
700a7276: b178         	cbz	r0, 0x700a7298 <Pinmux_config+0x88> @ imm = #0x1e
700a7278: e7ff         	b	0x700a727a <Pinmux_config+0x6a> @ imm = #-0x2
;             regAddr = (volatile uint32_t *)(baseAddr + pinmuxCfg->offset);
700a727a: 9803         	ldr	r0, [sp, #0xc]
700a727c: 9905         	ldr	r1, [sp, #0x14]
700a727e: f9b1 1000    	ldrsh.w	r1, [r1]
700a7282: 4408         	add	r0, r1
700a7284: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(regAddr, pinmuxCfg->settings);
700a7286: 9802         	ldr	r0, [sp, #0x8]
700a7288: 9905         	ldr	r1, [sp, #0x14]
700a728a: 6849         	ldr	r1, [r1, #0x4]
700a728c: f006 fe60    	bl	0x700adf50 <CSL_REG32_WR_RAW> @ imm = #0x6cc0
;             pinmuxCfg++;
700a7290: 9805         	ldr	r0, [sp, #0x14]
700a7292: 3008         	adds	r0, #0x8
700a7294: 9005         	str	r0, [sp, #0x14]
;         while( pinmuxCfg->offset != PINMUX_END )
700a7296: e7ea         	b	0x700a726e <Pinmux_config+0x5e> @ imm = #-0x2c
;         if (isUnlocked)
700a7298: 9801         	ldr	r0, [sp, #0x4]
700a729a: b120         	cbz	r0, 0x700a72a6 <Pinmux_config+0x96> @ imm = #0x8
700a729c: e7ff         	b	0x700a729e <Pinmux_config+0x8e> @ imm = #-0x2
;             Pinmux_lockMMR(domainId);
700a729e: 9804         	ldr	r0, [sp, #0x10]
700a72a0: f002 fc46    	bl	0x700a9b30 <Pinmux_lockMMR> @ imm = #0x288c
;         }
700a72a4: e7ff         	b	0x700a72a6 <Pinmux_config+0x96> @ imm = #-0x2
;     }
700a72a6: e7ff         	b	0x700a72a8 <Pinmux_config+0x98> @ imm = #-0x2
;     return;
700a72a8: b006         	add	sp, #0x18
700a72aa: bd80         	pop	{r7, pc}
700a72ac: 0000         	movs	r0, r0
700a72ae: 0000         	movs	r0, r0

700a72b0 <rtos_main_freertos>:
; {
700a72b0: b082         	sub	sp, #0x8
;    System_init();
700a72b2: f005 fd8d    	bl	0x700acdd0 <System_init> @ imm = #0x5b1a
;    Board_init();
700a72b6: f006 ffb3    	bl	0x700ae220 <Board_init> @ imm = #0x6f66
;    Drivers_open();
700a72ba: f004 f889    	bl	0x700ab3d0 <Drivers_open> @ imm = #0x4112
;    Board_driversOpen();
700a72be: f006 ff6f    	bl	0x700ae1a0 <Board_driversOpen> @ imm = #0x6ede
;    printf("Initializing FreeRTOS system...\r\n");
700a72c2: f240 0138    	movw	r1, #0x38
700a72c6: 2001         	movs	r0, #0x1
700a72c8: f2c7 010b    	movt	r1, #0x700b
700a72cc: f000 ff70    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #0xee0
;    BaseType_t status = xTaskCreate(main_task, "MainTask", MAIN_TASK_STACK_SIZE, NULL, MAIN_TASK_PRI, NULL);
700a72d0: f249 2021    	movw	r0, #0x9221
700a72d4: f240 513c    	movw	r1, #0x53c
700a72d8: f2c7 000a    	movt	r0, #0x700a
700a72dc: f2c7 010b    	movt	r1, #0x700b
700a72e0: 241e         	movs	r4, #0x1e
700a72e2: f44f 5200    	mov.w	r2, #0x2000
700a72e6: 2300         	movs	r3, #0x0
700a72e8: f04f 0c00    	mov.w	r12, #0x0
700a72ec: e9cd 4c00    	strd	r4, r12, [sp]
700a72f0: f000 fb4e    	bl	0x700a7990 <xTaskCreate> @ imm = #0x69c
;    if (status != pdPASS)
700a72f4: 2801         	cmp	r0, #0x1
700a72f6: d010         	beq	0x700a731a <rtos_main_freertos+0x6a> @ imm = #0x20
;       DebugP_assert(status == pdPASS);
700a72f8: f240 21d4    	movw	r1, #0x2d4
700a72fc: f240 3258    	movw	r2, #0x358
700a7300: f240 4437    	movw	r4, #0x437
700a7304: f2c7 010b    	movt	r1, #0x700b
700a7308: f2c7 020b    	movt	r2, #0x700b
700a730c: f2c7 040b    	movt	r4, #0x700b
700a7310: 2000         	movs	r0, #0x0
700a7312: 2381         	movs	r3, #0x81
700a7314: 9400         	str	r4, [sp]
700a7316: f001 ff03    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x1e06
;    vTaskStartScheduler();
700a731a: f7fe fc09    	bl	0x700a5b30 <vTaskStartScheduler> @ imm = #-0x17ee
700a731e: f64f 74f4    	movw	r4, #0xfff4
700a7322: f2c7 040a    	movt	r4, #0x700a
700a7326: bf00         	nop
700a7328: bf00         	nop
700a732a: bf00         	nop
700a732c: bf00         	nop
700a732e: bf00         	nop
;       printf("Scheduler returned unexpectedly\r\n");
700a7330: 4621         	mov	r1, r4
700a7332: f04f 0001    	mov.w	r0, #0x1
700a7336: f000 ff3b    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #0xe76
700a733a: 4621         	mov	r1, r4
700a733c: 2001         	movs	r0, #0x1
700a733e: f000 ff37    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #0xe6e
700a7342: 4621         	mov	r1, r4
700a7344: 2001         	movs	r0, #0x1
700a7346: f000 ff33    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #0xe66
;    for (;;)
700a734a: e7f1         	b	0x700a7330 <rtos_main_freertos+0x80> @ imm = #-0x1e
700a734c: 0000         	movs	r0, r0
700a734e: 0000         	movs	r0, r0

700a7350 <SOC_controlModuleUnlockMMR>:
; {
700a7350: b580         	push	{r7, lr}
700a7352: b084         	sub	sp, #0x10
700a7354: 9003         	str	r0, [sp, #0xc]
700a7356: 9102         	str	r1, [sp, #0x8]
;     if(SOC_DOMAIN_ID_MAIN == domainId)
700a7358: 9803         	ldr	r0, [sp, #0xc]
700a735a: bb00         	cbnz	r0, 0x700a739e <SOC_controlModuleUnlockMMR+0x4e> @ imm = #0x40
700a735c: e7ff         	b	0x700a735e <SOC_controlModuleUnlockMMR+0xe> @ imm = #-0x2
700a735e: f04f 4086    	mov.w	r0, #0x43000000
700a7362: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_CTRL_MMR0_CFG0_BASE);
700a7364: f7fc fe4c    	bl	0x700a4000 <AddrTranslateP_getLocalAddr> @ imm = #-0x3368
700a7368: 9001         	str	r0, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a736a: 9801         	ldr	r0, [sp, #0x4]
700a736c: 9902         	ldr	r1, [sp, #0x8]
700a736e: eb00 3081    	add.w	r0, r0, r1, lsl #14
700a7372: f241 0108    	movw	r1, #0x1008
700a7376: 4408         	add	r0, r1
700a7378: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a737a: 9800         	ldr	r0, [sp]
700a737c: f243 4190    	movw	r1, #0x3490
700a7380: f6c6 01ef    	movt	r1, #0x68ef
700a7384: f006 fdf4    	bl	0x700adf70 <CSL_REG32_WR_RAW> @ imm = #0x6be8
;         kickAddr++;
700a7388: 9800         	ldr	r0, [sp]
700a738a: 3004         	adds	r0, #0x4
700a738c: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a738e: 9800         	ldr	r0, [sp]
700a7390: f64b 415a    	movw	r1, #0xbc5a
700a7394: f2cd 1172    	movt	r1, #0xd172
700a7398: f006 fdea    	bl	0x700adf70 <CSL_REG32_WR_RAW> @ imm = #0x6bd4
;     }
700a739c: e7ff         	b	0x700a739e <SOC_controlModuleUnlockMMR+0x4e> @ imm = #-0x2
;     if(SOC_DOMAIN_ID_MCU == domainId)
700a739e: 9803         	ldr	r0, [sp, #0xc]
700a73a0: 2801         	cmp	r0, #0x1
700a73a2: d120         	bne	0x700a73e6 <SOC_controlModuleUnlockMMR+0x96> @ imm = #0x40
700a73a4: e7ff         	b	0x700a73a6 <SOC_controlModuleUnlockMMR+0x56> @ imm = #-0x2
700a73a6: f04f 608a    	mov.w	r0, #0x4500000
700a73aa: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_CTRL_MMR0_CFG0_BASE);
700a73ac: f7fc fe28    	bl	0x700a4000 <AddrTranslateP_getLocalAddr> @ imm = #-0x33b0
700a73b0: 9001         	str	r0, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a73b2: 9801         	ldr	r0, [sp, #0x4]
700a73b4: 9902         	ldr	r1, [sp, #0x8]
700a73b6: eb00 3081    	add.w	r0, r0, r1, lsl #14
700a73ba: f241 0108    	movw	r1, #0x1008
700a73be: 4408         	add	r0, r1
700a73c0: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a73c2: 9800         	ldr	r0, [sp]
700a73c4: f243 4190    	movw	r1, #0x3490
700a73c8: f6c6 01ef    	movt	r1, #0x68ef
700a73cc: f006 fdd0    	bl	0x700adf70 <CSL_REG32_WR_RAW> @ imm = #0x6ba0
;         kickAddr++;
700a73d0: 9800         	ldr	r0, [sp]
700a73d2: 3004         	adds	r0, #0x4
700a73d4: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a73d6: 9800         	ldr	r0, [sp]
700a73d8: f64b 415a    	movw	r1, #0xbc5a
700a73dc: f2cd 1172    	movt	r1, #0xd172
700a73e0: f006 fdc6    	bl	0x700adf70 <CSL_REG32_WR_RAW> @ imm = #0x6b8c
;     }
700a73e4: e7ff         	b	0x700a73e6 <SOC_controlModuleUnlockMMR+0x96> @ imm = #-0x2
;     return;
700a73e6: b004         	add	sp, #0x10
700a73e8: bd80         	pop	{r7, pc}
700a73ea: 0000         	movs	r0, r0
700a73ec: 0000         	movs	r0, r0
700a73ee: 0000         	movs	r0, r0

700a73f0 <Sciclient_pmGetModuleClkFreq>:
; {
700a73f0: b580         	push	{r7, lr}
700a73f2: b096         	sub	sp, #0x58
700a73f4: 9015         	str	r0, [sp, #0x54]
700a73f6: 9114         	str	r1, [sp, #0x50]
700a73f8: 9213         	str	r2, [sp, #0x4c]
700a73fa: 9312         	str	r3, [sp, #0x48]
700a73fc: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a73fe: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a7400: 9815         	ldr	r0, [sp, #0x54]
700a7402: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a7404: 9814         	ldr	r0, [sp, #0x50]
700a7406: 28ff         	cmp	r0, #0xff
700a7408: d307         	blo	0x700a741a <Sciclient_pmGetModuleClkFreq+0x2a> @ imm = #0xe
700a740a: e7ff         	b	0x700a740c <Sciclient_pmGetModuleClkFreq+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a740c: 9814         	ldr	r0, [sp, #0x50]
700a740e: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a7412: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a7414: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a7418: e003         	b	0x700a7422 <Sciclient_pmGetModuleClkFreq+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a741a: 9814         	ldr	r0, [sp, #0x50]
700a741c: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a7420: e7ff         	b	0x700a7422 <Sciclient_pmGetModuleClkFreq+0x32> @ imm = #-0x2
700a7422: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_freq_resp response = {{0}};
700a7424: 900b         	str	r0, [sp, #0x2c]
700a7426: 900a         	str	r0, [sp, #0x28]
700a7428: 9009         	str	r0, [sp, #0x24]
700a742a: 9008         	str	r0, [sp, #0x20]
700a742c: f44f 7187    	mov.w	r1, #0x10e
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_FREQ;
700a7430: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a7434: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a7436: 9104         	str	r1, [sp, #0x10]
700a7438: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a743a: 9105         	str	r1, [sp, #0x14]
700a743c: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a743e: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a7440: 9912         	ldr	r1, [sp, #0x48]
700a7442: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a7444: 9000         	str	r0, [sp]
700a7446: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a7448: 9001         	str	r0, [sp, #0x4]
700a744a: 2010         	movs	r0, #0x10
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a744c: 9002         	str	r0, [sp, #0x8]
700a744e: a803         	add	r0, sp, #0xc
700a7450: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a7452: f7f4 fde5    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xb436
700a7456: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a7458: 9811         	ldr	r0, [sp, #0x44]
700a745a: b930         	cbnz	r0, 0x700a746a <Sciclient_pmGetModuleClkFreq+0x7a> @ imm = #0xc
700a745c: e7ff         	b	0x700a745e <Sciclient_pmGetModuleClkFreq+0x6e> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a745e: 9800         	ldr	r0, [sp]
700a7460: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a7464: 2802         	cmp	r0, #0x2
700a7466: d004         	beq	0x700a7472 <Sciclient_pmGetModuleClkFreq+0x82> @ imm = #0x8
700a7468: e7ff         	b	0x700a746a <Sciclient_pmGetModuleClkFreq+0x7a> @ imm = #-0x2
700a746a: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a746e: 9011         	str	r0, [sp, #0x44]
;     }
700a7470: e7ff         	b	0x700a7472 <Sciclient_pmGetModuleClkFreq+0x82> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a7472: 9811         	ldr	r0, [sp, #0x44]
700a7474: b930         	cbnz	r0, 0x700a7484 <Sciclient_pmGetModuleClkFreq+0x94> @ imm = #0xc
700a7476: e7ff         	b	0x700a7478 <Sciclient_pmGetModuleClkFreq+0x88> @ imm = #-0x2
;         *freqHz = (uint64_t) response.freq_hz;
700a7478: 980a         	ldr	r0, [sp, #0x28]
700a747a: 9a0b         	ldr	r2, [sp, #0x2c]
700a747c: 9913         	ldr	r1, [sp, #0x4c]
700a747e: 604a         	str	r2, [r1, #0x4]
700a7480: 6008         	str	r0, [r1]
;     }
700a7482: e7ff         	b	0x700a7484 <Sciclient_pmGetModuleClkFreq+0x94> @ imm = #-0x2
;     return retVal;
700a7484: 9811         	ldr	r0, [sp, #0x44]
700a7486: b016         	add	sp, #0x58
700a7488: bd80         	pop	{r7, pc}
700a748a: 0000         	movs	r0, r0
700a748c: 0000         	movs	r0, r0
700a748e: 0000         	movs	r0, r0

700a7490 <Sciclient_pmGetModuleClkParent>:
; {
700a7490: b580         	push	{r7, lr}
700a7492: b096         	sub	sp, #0x58
700a7494: 9015         	str	r0, [sp, #0x54]
700a7496: 9114         	str	r1, [sp, #0x50]
700a7498: 9213         	str	r2, [sp, #0x4c]
700a749a: 9312         	str	r3, [sp, #0x48]
700a749c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a749e: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a74a0: 9815         	ldr	r0, [sp, #0x54]
700a74a2: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a74a4: 9814         	ldr	r0, [sp, #0x50]
700a74a6: 28ff         	cmp	r0, #0xff
700a74a8: d307         	blo	0x700a74ba <Sciclient_pmGetModuleClkParent+0x2a> @ imm = #0xe
700a74aa: e7ff         	b	0x700a74ac <Sciclient_pmGetModuleClkParent+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a74ac: 9814         	ldr	r0, [sp, #0x50]
700a74ae: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a74b2: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a74b4: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a74b8: e003         	b	0x700a74c2 <Sciclient_pmGetModuleClkParent+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a74ba: 9814         	ldr	r0, [sp, #0x50]
700a74bc: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a74c0: e7ff         	b	0x700a74c2 <Sciclient_pmGetModuleClkParent+0x32> @ imm = #-0x2
700a74c2: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_clock_parent_resp response = {{0}};
700a74c4: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a74c8: 900a         	str	r0, [sp, #0x28]
700a74ca: 9009         	str	r0, [sp, #0x24]
700a74cc: 9008         	str	r0, [sp, #0x20]
700a74ce: f240 1103    	movw	r1, #0x103
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_CLOCK_PARENT;
700a74d2: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a74d6: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a74d8: 9104         	str	r1, [sp, #0x10]
700a74da: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a74dc: 9105         	str	r1, [sp, #0x14]
700a74de: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a74e0: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a74e2: 9912         	ldr	r1, [sp, #0x48]
700a74e4: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a74e6: 9000         	str	r0, [sp]
700a74e8: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a74ea: 9001         	str	r0, [sp, #0x4]
700a74ec: 200d         	movs	r0, #0xd
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a74ee: 9002         	str	r0, [sp, #0x8]
700a74f0: a803         	add	r0, sp, #0xc
700a74f2: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a74f4: f7f4 fd94    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xb4d8
700a74f8: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a74fa: 9811         	ldr	r0, [sp, #0x44]
700a74fc: b930         	cbnz	r0, 0x700a750c <Sciclient_pmGetModuleClkParent+0x7c> @ imm = #0xc
700a74fe: e7ff         	b	0x700a7500 <Sciclient_pmGetModuleClkParent+0x70> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a7500: 9800         	ldr	r0, [sp]
700a7502: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a7506: 2802         	cmp	r0, #0x2
700a7508: d004         	beq	0x700a7514 <Sciclient_pmGetModuleClkParent+0x84> @ imm = #0x8
700a750a: e7ff         	b	0x700a750c <Sciclient_pmGetModuleClkParent+0x7c> @ imm = #-0x2
700a750c: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a7510: 9011         	str	r0, [sp, #0x44]
;     }
700a7512: e7ff         	b	0x700a7514 <Sciclient_pmGetModuleClkParent+0x84> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a7514: 9811         	ldr	r0, [sp, #0x44]
700a7516: b928         	cbnz	r0, 0x700a7524 <Sciclient_pmGetModuleClkParent+0x94> @ imm = #0xa
700a7518: e7ff         	b	0x700a751a <Sciclient_pmGetModuleClkParent+0x8a> @ imm = #-0x2
;         *parent = (uint32_t) response.parent;
700a751a: f89d 0028    	ldrb.w	r0, [sp, #0x28]
700a751e: 9913         	ldr	r1, [sp, #0x4c]
700a7520: 6008         	str	r0, [r1]
;     }
700a7522: e7ff         	b	0x700a7524 <Sciclient_pmGetModuleClkParent+0x94> @ imm = #-0x2
;     return retVal;
700a7524: 9811         	ldr	r0, [sp, #0x44]
700a7526: b016         	add	sp, #0x58
700a7528: bd80         	pop	{r7, pc}
700a752a: 0000         	movs	r0, r0
700a752c: 0000         	movs	r0, r0
700a752e: 0000         	movs	r0, r0

700a7530 <Sciclient_pmSetModuleClkParent>:
; {
700a7530: b580         	push	{r7, lr}
700a7532: b094         	sub	sp, #0x50
700a7534: 9013         	str	r0, [sp, #0x4c]
700a7536: 9112         	str	r1, [sp, #0x48]
700a7538: 9211         	str	r2, [sp, #0x44]
700a753a: 9310         	str	r3, [sp, #0x40]
700a753c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a753e: 900f         	str	r0, [sp, #0x3c]
;     request.device = (uint32_t) moduleId;
700a7540: 9813         	ldr	r0, [sp, #0x4c]
700a7542: 900b         	str	r0, [sp, #0x2c]
;     if (clockId >= 255U)
700a7544: 9812         	ldr	r0, [sp, #0x48]
700a7546: 28ff         	cmp	r0, #0xff
700a7548: d307         	blo	0x700a755a <Sciclient_pmSetModuleClkParent+0x2a> @ imm = #0xe
700a754a: e7ff         	b	0x700a754c <Sciclient_pmSetModuleClkParent+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a754c: 9812         	ldr	r0, [sp, #0x48]
700a754e: f8cd 0032    	str.w	r0, [sp, #0x32]
700a7552: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a7554: f88d 0030    	strb.w	r0, [sp, #0x30]
;     }
700a7558: e003         	b	0x700a7562 <Sciclient_pmSetModuleClkParent+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a755a: 9812         	ldr	r0, [sp, #0x48]
700a755c: f88d 0030    	strb.w	r0, [sp, #0x30]
700a7560: e7ff         	b	0x700a7562 <Sciclient_pmSetModuleClkParent+0x32> @ imm = #-0x2
;     if (parent >= 255U)
700a7562: 9811         	ldr	r0, [sp, #0x44]
700a7564: 28ff         	cmp	r0, #0xff
700a7566: d307         	blo	0x700a7578 <Sciclient_pmSetModuleClkParent+0x48> @ imm = #0xe
700a7568: e7ff         	b	0x700a756a <Sciclient_pmSetModuleClkParent+0x3a> @ imm = #-0x2
;         request.parent32 = parent;
700a756a: 9811         	ldr	r0, [sp, #0x44]
700a756c: f8cd 0036    	str.w	r0, [sp, #0x36]
700a7570: 20ff         	movs	r0, #0xff
;         request.parent   = (uint8_t) 255U;
700a7572: f88d 0031    	strb.w	r0, [sp, #0x31]
;     }
700a7576: e003         	b	0x700a7580 <Sciclient_pmSetModuleClkParent+0x50> @ imm = #0x6
;         request.parent = (uint8_t) parent;
700a7578: 9811         	ldr	r0, [sp, #0x44]
700a757a: f88d 0031    	strb.w	r0, [sp, #0x31]
700a757e: e7ff         	b	0x700a7580 <Sciclient_pmSetModuleClkParent+0x50> @ imm = #-0x2
700a7580: f44f 7081    	mov.w	r0, #0x102
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_CLOCK_PARENT;
700a7584: f8ad 0010    	strh.w	r0, [sp, #0x10]
700a7588: 2002         	movs	r0, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a758a: 9005         	str	r0, [sp, #0x14]
700a758c: a809         	add	r0, sp, #0x24
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a758e: 9006         	str	r0, [sp, #0x18]
700a7590: 2016         	movs	r0, #0x16
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a7592: 9007         	str	r0, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a7594: 9810         	ldr	r0, [sp, #0x40]
700a7596: 9008         	str	r0, [sp, #0x20]
700a7598: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a759a: 9001         	str	r0, [sp, #0x4]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a759c: 9002         	str	r0, [sp, #0x8]
;     respParam.respPayloadSize = (uint32_t) 0;
700a759e: 9003         	str	r0, [sp, #0xc]
700a75a0: a804         	add	r0, sp, #0x10
700a75a2: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a75a4: f7f4 fd3c    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xb588
700a75a8: 900f         	str	r0, [sp, #0x3c]
;     if((retVal != SystemP_SUCCESS) ||
700a75aa: 980f         	ldr	r0, [sp, #0x3c]
700a75ac: b930         	cbnz	r0, 0x700a75bc <Sciclient_pmSetModuleClkParent+0x8c> @ imm = #0xc
700a75ae: e7ff         	b	0x700a75b0 <Sciclient_pmSetModuleClkParent+0x80> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a75b0: 9801         	ldr	r0, [sp, #0x4]
700a75b2: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a75b6: 2802         	cmp	r0, #0x2
700a75b8: d004         	beq	0x700a75c4 <Sciclient_pmSetModuleClkParent+0x94> @ imm = #0x8
700a75ba: e7ff         	b	0x700a75bc <Sciclient_pmSetModuleClkParent+0x8c> @ imm = #-0x2
700a75bc: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a75c0: 900f         	str	r0, [sp, #0x3c]
;     }
700a75c2: e7ff         	b	0x700a75c4 <Sciclient_pmSetModuleClkParent+0x94> @ imm = #-0x2
;     return retVal;
700a75c4: 980f         	ldr	r0, [sp, #0x3c]
700a75c6: b014         	add	sp, #0x50
700a75c8: bd80         	pop	{r7, pc}
700a75ca: 0000         	movs	r0, r0
700a75cc: 0000         	movs	r0, r0
700a75ce: 0000         	movs	r0, r0

700a75d0 <Sciclient_rmIrOutpIsFree>:
; {
700a75d0: b580         	push	{r7, lr}
700a75d2: b086         	sub	sp, #0x18
700a75d4: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a75d8: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a75dc: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a75de: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIrInst *inst = NULL;
700a75e0: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIrGetInst(id);
700a75e2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a75e6: f002 fc9b    	bl	0x700a9f20 <Sciclient_rmIrGetInst> @ imm = #0x2936
700a75ea: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a75ec: 9803         	ldr	r0, [sp, #0xc]
700a75ee: b920         	cbnz	r0, 0x700a75fa <Sciclient_rmIrOutpIsFree+0x2a> @ imm = #0x8
700a75f0: e7ff         	b	0x700a75f2 <Sciclient_rmIrOutpIsFree+0x22> @ imm = #-0x2
700a75f2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a75f6: 9004         	str	r0, [sp, #0x10]
;     } else {
700a75f8: e00b         	b	0x700a7612 <Sciclient_rmIrOutpIsFree+0x42> @ imm = #0x16
;         if (outp >= inst->n_outp) {
700a75fa: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a75fe: 9903         	ldr	r1, [sp, #0xc]
700a7600: 8949         	ldrh	r1, [r1, #0xa]
700a7602: 4288         	cmp	r0, r1
700a7604: db04         	blt	0x700a7610 <Sciclient_rmIrOutpIsFree+0x40> @ imm = #0x8
700a7606: e7ff         	b	0x700a7608 <Sciclient_rmIrOutpIsFree+0x38> @ imm = #-0x2
700a7608: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a760c: 9004         	str	r0, [sp, #0x10]
;         }
700a760e: e7ff         	b	0x700a7610 <Sciclient_rmIrOutpIsFree+0x40> @ imm = #-0x2
700a7610: e7ff         	b	0x700a7612 <Sciclient_rmIrOutpIsFree+0x42> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a7612: 9804         	ldr	r0, [sp, #0x10]
700a7614: bb30         	cbnz	r0, 0x700a7664 <Sciclient_rmIrOutpIsFree+0x94> @ imm = #0x4c
700a7616: e7ff         	b	0x700a7618 <Sciclient_rmIrOutpIsFree+0x48> @ imm = #-0x2
;         int_ctrl_reg = (volatile uint32_t *) Sciclient_getIrAddr (inst->cfg, outp);
700a7618: 9803         	ldr	r0, [sp, #0xc]
700a761a: 6840         	ldr	r0, [r0, #0x4]
700a761c: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a7620: f005 fcde    	bl	0x700acfe0 <Sciclient_getIrAddr> @ imm = #0x59bc
700a7624: 9002         	str	r0, [sp, #0x8]
;         extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a7626: 9802         	ldr	r0, [sp, #0x8]
700a7628: f240 31ff    	movw	r1, #0x3ff
700a762c: 2200         	movs	r2, #0x0
700a762e: f005 ffef    	bl	0x700ad610 <CSL_REG32_FEXT_RAW> @ imm = #0x5fde
700a7632: f8ad 0006    	strh.w	r0, [sp, #0x6]
;         if (((extracted_inp != 0u) &&
700a7636: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a763a: b138         	cbz	r0, 0x700a764c <Sciclient_rmIrOutpIsFree+0x7c> @ imm = #0xe
700a763c: e7ff         	b	0x700a763e <Sciclient_rmIrOutpIsFree+0x6e> @ imm = #-0x2
;              (Sciclient_rmIrOutpRomMapped(inst, outp) == false)) ||
700a763e: 9803         	ldr	r0, [sp, #0xc]
700a7640: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a7644: f7ff f934    	bl	0x700a68b0 <Sciclient_rmIrOutpRomMapped> @ imm = #-0xd98
700a7648: b138         	cbz	r0, 0x700a765a <Sciclient_rmIrOutpIsFree+0x8a> @ imm = #0xe
700a764a: e7ff         	b	0x700a764c <Sciclient_rmIrOutpIsFree+0x7c> @ imm = #-0x2
;             (outp == inst->inp0_mapping)) {
700a764c: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a7650: 9903         	ldr	r1, [sp, #0xc]
700a7652: 8989         	ldrh	r1, [r1, #0xc]
;         if (((extracted_inp != 0u) &&
700a7654: 4288         	cmp	r0, r1
700a7656: d104         	bne	0x700a7662 <Sciclient_rmIrOutpIsFree+0x92> @ imm = #0x8
700a7658: e7ff         	b	0x700a765a <Sciclient_rmIrOutpIsFree+0x8a> @ imm = #-0x2
700a765a: f04f 30ff    	mov.w	r0, #0xffffffff
;             r = SystemP_FAILURE;
700a765e: 9004         	str	r0, [sp, #0x10]
;         }
700a7660: e7ff         	b	0x700a7662 <Sciclient_rmIrOutpIsFree+0x92> @ imm = #-0x2
;     }
700a7662: e7ff         	b	0x700a7664 <Sciclient_rmIrOutpIsFree+0x94> @ imm = #-0x2
;     return r;
700a7664: 9804         	ldr	r0, [sp, #0x10]
700a7666: b006         	add	sp, #0x18
700a7668: bd80         	pop	{r7, pc}
700a766a: 0000         	movs	r0, r0
700a766c: 0000         	movs	r0, r0
700a766e: 0000         	movs	r0, r0

700a7670 <Udma_ringQueueRaw>:
; {
700a7670: b580         	push	{r7, lr}
700a7672: b088         	sub	sp, #0x20
700a7674: 9007         	str	r0, [sp, #0x1c]
700a7676: 9305         	str	r3, [sp, #0x14]
700a7678: 9204         	str	r2, [sp, #0x10]
700a767a: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a767c: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a767e: 9807         	ldr	r0, [sp, #0x1c]
700a7680: 9000         	str	r0, [sp]
;     if((NULL_PTR == ringHandleInt) ||
700a7682: 9800         	ldr	r0, [sp]
700a7684: b180         	cbz	r0, 0x700a76a8 <Udma_ringQueueRaw+0x38> @ imm = #0x20
700a7686: e7ff         	b	0x700a7688 <Udma_ringQueueRaw+0x18> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a7688: 9800         	ldr	r0, [sp]
700a768a: 6d80         	ldr	r0, [r0, #0x58]
700a768c: f64a 31cd    	movw	r1, #0xabcd
700a7690: f6ca 31dc    	movt	r1, #0xabdc
700a7694: 4288         	cmp	r0, r1
700a7696: d107         	bne	0x700a76a8 <Udma_ringQueueRaw+0x38> @ imm = #0xe
700a7698: e7ff         	b	0x700a769a <Udma_ringQueueRaw+0x2a> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a769a: 9800         	ldr	r0, [sp]
700a769c: 8880         	ldrh	r0, [r0, #0x4]
700a769e: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a76a2: 4288         	cmp	r0, r1
700a76a4: d104         	bne	0x700a76b0 <Udma_ringQueueRaw+0x40> @ imm = #0x8
700a76a6: e7ff         	b	0x700a76a8 <Udma_ringQueueRaw+0x38> @ imm = #-0x2
700a76a8: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a76ac: 9003         	str	r0, [sp, #0xc]
;     }
700a76ae: e7ff         	b	0x700a76b0 <Udma_ringQueueRaw+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a76b0: 9803         	ldr	r0, [sp, #0xc]
700a76b2: b9a8         	cbnz	r0, 0x700a76e0 <Udma_ringQueueRaw+0x70> @ imm = #0x2a
700a76b4: e7ff         	b	0x700a76b6 <Udma_ringQueueRaw+0x46> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a76b6: 9800         	ldr	r0, [sp]
700a76b8: 6800         	ldr	r0, [r0]
700a76ba: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) ||
700a76bc: 9801         	ldr	r0, [sp, #0x4]
700a76be: b150         	cbz	r0, 0x700a76d6 <Udma_ringQueueRaw+0x66> @ imm = #0x14
700a76c0: e7ff         	b	0x700a76c2 <Udma_ringQueueRaw+0x52> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a76c2: 9801         	ldr	r0, [sp, #0x4]
700a76c4: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a76c8: f64a 31cd    	movw	r1, #0xabcd
700a76cc: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a76d0: 4288         	cmp	r0, r1
700a76d2: d004         	beq	0x700a76de <Udma_ringQueueRaw+0x6e> @ imm = #0x8
700a76d4: e7ff         	b	0x700a76d6 <Udma_ringQueueRaw+0x66> @ imm = #-0x2
700a76d6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a76da: 9003         	str	r0, [sp, #0xc]
;         }
700a76dc: e7ff         	b	0x700a76de <Udma_ringQueueRaw+0x6e> @ imm = #-0x2
;     }
700a76de: e7ff         	b	0x700a76e0 <Udma_ringQueueRaw+0x70> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a76e0: 9803         	ldr	r0, [sp, #0xc]
700a76e2: b978         	cbnz	r0, 0x700a7704 <Udma_ringQueueRaw+0x94> @ imm = #0x1e
700a76e4: e7ff         	b	0x700a76e6 <Udma_ringQueueRaw+0x76> @ imm = #-0x2
;         cookie = HwiP_disable();
700a76e6: f007 eb6c    	blx	0x700aedc0 <HwiP_disable> @ imm = #0x76d8
700a76ea: 9002         	str	r0, [sp, #0x8]
;         retVal = drvHandle->ringQueueRaw(drvHandle, ringHandleInt, phyDescMem);
700a76ec: 9801         	ldr	r0, [sp, #0x4]
700a76ee: f8d0 c594    	ldr.w	r12, [r0, #0x594]
700a76f2: 9900         	ldr	r1, [sp]
700a76f4: 9a04         	ldr	r2, [sp, #0x10]
700a76f6: 9b05         	ldr	r3, [sp, #0x14]
700a76f8: 47e0         	blx	r12
700a76fa: 9003         	str	r0, [sp, #0xc]
;         HwiP_restore(cookie);
700a76fc: 9802         	ldr	r0, [sp, #0x8]
700a76fe: f007 eb80    	blx	0x700aee00 <HwiP_restore> @ imm = #0x7700
;     }
700a7702: e7ff         	b	0x700a7704 <Udma_ringQueueRaw+0x94> @ imm = #-0x2
;     return (retVal);
700a7704: 9803         	ldr	r0, [sp, #0xc]
700a7706: b008         	add	sp, #0x20
700a7708: bd80         	pop	{r7, pc}
700a770a: 0000         	movs	r0, r0
700a770c: 0000         	movs	r0, r0
700a770e: 0000         	movs	r0, r0

700a7710 <xTaskCheckForTimeOut>:
;                                 TickType_t *const pxTicksToWait) {
700a7710: b580         	push	{r7, lr}
700a7712: b086         	sub	sp, #0x18
700a7714: 9005         	str	r0, [sp, #0x14]
700a7716: 9104         	str	r1, [sp, #0x10]
;   taskENTER_CRITICAL();
700a7718: f005 fa5a    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0x54b4
;     const TickType_t xConstTickCount = xTickCount;
700a771c: f640 50f4    	movw	r0, #0xdf4
700a7720: f2c7 000b    	movt	r0, #0x700b
700a7724: 6800         	ldr	r0, [r0]
700a7726: 9002         	str	r0, [sp, #0x8]
;         xConstTickCount - pxTimeOut->xTimeOnEntering;
700a7728: 9802         	ldr	r0, [sp, #0x8]
700a772a: 9905         	ldr	r1, [sp, #0x14]
700a772c: 6849         	ldr	r1, [r1, #0x4]
700a772e: 1a40         	subs	r0, r0, r1
;     const TickType_t xElapsedTime =
700a7730: 9001         	str	r0, [sp, #0x4]
;         if (*pxTicksToWait == portMAX_DELAY) {
700a7732: 9804         	ldr	r0, [sp, #0x10]
700a7734: 6800         	ldr	r0, [r0]
700a7736: 3001         	adds	r0, #0x1
700a7738: b918         	cbnz	r0, 0x700a7742 <xTaskCheckForTimeOut+0x32> @ imm = #0x6
700a773a: e7ff         	b	0x700a773c <xTaskCheckForTimeOut+0x2c> @ imm = #-0x2
700a773c: 2000         	movs	r0, #0x0
;       xReturn = pdFALSE;
700a773e: 9003         	str	r0, [sp, #0xc]
;     } else
700a7740: e02e         	b	0x700a77a0 <xTaskCheckForTimeOut+0x90> @ imm = #0x5c
;         if ((xNumOfOverflows != pxTimeOut->xOverflowCount) &&
700a7742: f640 50e8    	movw	r0, #0xde8
700a7746: f2c7 000b    	movt	r0, #0x700b
700a774a: 6800         	ldr	r0, [r0]
700a774c: 9905         	ldr	r1, [sp, #0x14]
700a774e: 6809         	ldr	r1, [r1]
700a7750: 4288         	cmp	r0, r1
700a7752: d00c         	beq	0x700a776e <xTaskCheckForTimeOut+0x5e> @ imm = #0x18
700a7754: e7ff         	b	0x700a7756 <xTaskCheckForTimeOut+0x46> @ imm = #-0x2
;             (xConstTickCount >=
700a7756: 9802         	ldr	r0, [sp, #0x8]
;              pxTimeOut
700a7758: 9905         	ldr	r1, [sp, #0x14]
;                  ->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to
700a775a: 6849         	ldr	r1, [r1, #0x4]
;         if ((xNumOfOverflows != pxTimeOut->xOverflowCount) &&
700a775c: 4288         	cmp	r0, r1
700a775e: d306         	blo	0x700a776e <xTaskCheckForTimeOut+0x5e> @ imm = #0xc
700a7760: e7ff         	b	0x700a7762 <xTaskCheckForTimeOut+0x52> @ imm = #-0x2
700a7762: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a7764: 9003         	str	r0, [sp, #0xc]
;       *pxTicksToWait = (TickType_t)0;
700a7766: 9904         	ldr	r1, [sp, #0x10]
700a7768: 2000         	movs	r0, #0x0
700a776a: 6008         	str	r0, [r1]
;     } else if (xElapsedTime <
700a776c: e017         	b	0x700a779e <xTaskCheckForTimeOut+0x8e> @ imm = #0x2e
700a776e: 9801         	ldr	r0, [sp, #0x4]
;                *pxTicksToWait) /*lint !e961 Explicit casting is only redundant
700a7770: 9904         	ldr	r1, [sp, #0x10]
700a7772: 6809         	ldr	r1, [r1]
;     } else if (xElapsedTime <
700a7774: 4288         	cmp	r0, r1
700a7776: d20b         	bhs	0x700a7790 <xTaskCheckForTimeOut+0x80> @ imm = #0x16
700a7778: e7ff         	b	0x700a777a <xTaskCheckForTimeOut+0x6a> @ imm = #-0x2
;       *pxTicksToWait -= xElapsedTime;
700a777a: 9a01         	ldr	r2, [sp, #0x4]
700a777c: 9904         	ldr	r1, [sp, #0x10]
700a777e: 6808         	ldr	r0, [r1]
700a7780: 1a80         	subs	r0, r0, r2
700a7782: 6008         	str	r0, [r1]
;       vTaskInternalSetTimeOutState(pxTimeOut);
700a7784: 9805         	ldr	r0, [sp, #0x14]
700a7786: f005 ffb3    	bl	0x700ad6f0 <vTaskInternalSetTimeOutState> @ imm = #0x5f66
700a778a: 2000         	movs	r0, #0x0
;       xReturn = pdFALSE;
700a778c: 9003         	str	r0, [sp, #0xc]
;     } else {
700a778e: e005         	b	0x700a779c <xTaskCheckForTimeOut+0x8c> @ imm = #0xa
;       *pxTicksToWait = (TickType_t)0;
700a7790: 9904         	ldr	r1, [sp, #0x10]
700a7792: 2000         	movs	r0, #0x0
700a7794: 6008         	str	r0, [r1]
700a7796: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a7798: 9003         	str	r0, [sp, #0xc]
700a779a: e7ff         	b	0x700a779c <xTaskCheckForTimeOut+0x8c> @ imm = #-0x2
700a779c: e7ff         	b	0x700a779e <xTaskCheckForTimeOut+0x8e> @ imm = #-0x2
700a779e: e7ff         	b	0x700a77a0 <xTaskCheckForTimeOut+0x90> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a77a0: f004 fa96    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x452c
;   return xReturn;
700a77a4: 9803         	ldr	r0, [sp, #0xc]
700a77a6: b006         	add	sp, #0x18
700a77a8: bd80         	pop	{r7, pc}
700a77aa: 0000         	movs	r0, r0
700a77ac: 0000         	movs	r0, r0
700a77ae: 0000         	movs	r0, r0

700a77b0 <CSL_bcdmaChanOpSetChanEnable>:
; {
700a77b0: b580         	push	{r7, lr}
700a77b2: b086         	sub	sp, #0x18
700a77b4: 9005         	str	r0, [sp, #0x14]
700a77b6: 9104         	str	r1, [sp, #0x10]
700a77b8: 9203         	str	r2, [sp, #0xc]
700a77ba: f88d 300b    	strb.w	r3, [sp, #0xb]
700a77be: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a77c0: 9001         	str	r0, [sp, #0x4]
;     switch( chanType )
700a77c2: 9804         	ldr	r0, [sp, #0x10]
700a77c4: 9000         	str	r0, [sp]
700a77c6: b140         	cbz	r0, 0x700a77da <CSL_bcdmaChanOpSetChanEnable+0x2a> @ imm = #0x10
700a77c8: e7ff         	b	0x700a77ca <CSL_bcdmaChanOpSetChanEnable+0x1a> @ imm = #-0x2
700a77ca: 9800         	ldr	r0, [sp]
700a77cc: 2801         	cmp	r0, #0x1
700a77ce: d014         	beq	0x700a77fa <CSL_bcdmaChanOpSetChanEnable+0x4a> @ imm = #0x28
700a77d0: e7ff         	b	0x700a77d2 <CSL_bcdmaChanOpSetChanEnable+0x22> @ imm = #-0x2
700a77d2: 9800         	ldr	r0, [sp]
700a77d4: 2802         	cmp	r0, #0x2
700a77d6: d020         	beq	0x700a781a <CSL_bcdmaChanOpSetChanEnable+0x6a> @ imm = #0x40
700a77d8: e02f         	b	0x700a783a <CSL_bcdmaChanOpSetChanEnable+0x8a> @ imm = #0x5e
;             CSL_REG32_WR(&pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_BCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a77da: 9805         	ldr	r0, [sp, #0x14]
700a77dc: 6880         	ldr	r0, [r0, #0x8]
700a77de: 9903         	ldr	r1, [sp, #0xc]
700a77e0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a77e4: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a77e8: f001 0101    	and	r1, r1, #0x1
700a77ec: 2900         	cmp	r1, #0x0
700a77ee: bf18         	it	ne
700a77f0: f04f 4100    	movne.w	r1, #0x80000000
700a77f4: f7f3 fbdc    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0xc848
;             break;
700a77f8: e023         	b	0x700a7842 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x46
;             CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a77fa: 9805         	ldr	r0, [sp, #0x14]
700a77fc: 6900         	ldr	r0, [r0, #0x10]
700a77fe: 9903         	ldr	r1, [sp, #0xc]
700a7800: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a7804: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a7808: f001 0101    	and	r1, r1, #0x1
700a780c: 2900         	cmp	r1, #0x0
700a780e: bf18         	it	ne
700a7810: f04f 4100    	movne.w	r1, #0x80000000
700a7814: f7f3 fbcc    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0xc868
;             break;
700a7818: e013         	b	0x700a7842 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x26
;             CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_RXCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a781a: 9805         	ldr	r0, [sp, #0x14]
700a781c: 6980         	ldr	r0, [r0, #0x18]
700a781e: 9903         	ldr	r1, [sp, #0xc]
700a7820: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a7824: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a7828: f001 0101    	and	r1, r1, #0x1
700a782c: 2900         	cmp	r1, #0x0
700a782e: bf18         	it	ne
700a7830: f04f 4100    	movne.w	r1, #0x80000000
700a7834: f7f3 fbbc    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0xc888
;             break;
700a7838: e003         	b	0x700a7842 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x6
700a783a: f06f 0001    	mvn	r0, #0x1
;             retVal = CSL_EBADARGS;
700a783e: 9001         	str	r0, [sp, #0x4]
;             break;
700a7840: e7ff         	b	0x700a7842 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #-0x2
;     return retVal;
700a7842: 9801         	ldr	r0, [sp, #0x4]
700a7844: b006         	add	sp, #0x18
700a7846: bd80         	pop	{r7, pc}
		...

700a7850 <Sciclient_pmModuleGetClkStatus>:
; {
700a7850: b580         	push	{r7, lr}
700a7852: b096         	sub	sp, #0x58
700a7854: 9015         	str	r0, [sp, #0x54]
700a7856: 9114         	str	r1, [sp, #0x50]
700a7858: 9213         	str	r2, [sp, #0x4c]
700a785a: 9312         	str	r3, [sp, #0x48]
700a785c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a785e: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a7860: 9815         	ldr	r0, [sp, #0x54]
700a7862: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a7864: 9814         	ldr	r0, [sp, #0x50]
700a7866: 28ff         	cmp	r0, #0xff
700a7868: d307         	blo	0x700a787a <Sciclient_pmModuleGetClkStatus+0x2a> @ imm = #0xe
700a786a: e7ff         	b	0x700a786c <Sciclient_pmModuleGetClkStatus+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a786c: 9814         	ldr	r0, [sp, #0x50]
700a786e: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a7872: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a7874: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a7878: e003         	b	0x700a7882 <Sciclient_pmModuleGetClkStatus+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a787a: 9814         	ldr	r0, [sp, #0x50]
700a787c: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a7880: e7ff         	b	0x700a7882 <Sciclient_pmModuleGetClkStatus+0x32> @ imm = #-0x2
700a7882: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_clock_resp response = {{0}};
700a7884: f8ad 002c    	strh.w	r0, [sp, #0x2c]
700a7888: 900a         	str	r0, [sp, #0x28]
700a788a: 9009         	str	r0, [sp, #0x24]
700a788c: f240 1101    	movw	r1, #0x101
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_CLOCK;
700a7890: f8ad 1010    	strh.w	r1, [sp, #0x10]
700a7894: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a7896: 9105         	str	r1, [sp, #0x14]
700a7898: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a789a: 9106         	str	r1, [sp, #0x18]
700a789c: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a789e: 9107         	str	r1, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a78a0: 9912         	ldr	r1, [sp, #0x48]
700a78a2: 9108         	str	r1, [sp, #0x20]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a78a4: 9001         	str	r0, [sp, #0x4]
700a78a6: a809         	add	r0, sp, #0x24
;     respParam.pRespPayload    = (uint8_t *) &response;
700a78a8: 9002         	str	r0, [sp, #0x8]
700a78aa: 200a         	movs	r0, #0xa
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a78ac: 9003         	str	r0, [sp, #0xc]
700a78ae: a804         	add	r0, sp, #0x10
700a78b0: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a78b2: f7f4 fbb5    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xb896
700a78b6: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a78b8: 9811         	ldr	r0, [sp, #0x44]
700a78ba: b930         	cbnz	r0, 0x700a78ca <Sciclient_pmModuleGetClkStatus+0x7a> @ imm = #0xc
700a78bc: e7ff         	b	0x700a78be <Sciclient_pmModuleGetClkStatus+0x6e> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a78be: 9801         	ldr	r0, [sp, #0x4]
700a78c0: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a78c4: 2802         	cmp	r0, #0x2
700a78c6: d004         	beq	0x700a78d2 <Sciclient_pmModuleGetClkStatus+0x82> @ imm = #0x8
700a78c8: e7ff         	b	0x700a78ca <Sciclient_pmModuleGetClkStatus+0x7a> @ imm = #-0x2
700a78ca: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a78ce: 9011         	str	r0, [sp, #0x44]
;     }
700a78d0: e7ff         	b	0x700a78d2 <Sciclient_pmModuleGetClkStatus+0x82> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a78d2: 9811         	ldr	r0, [sp, #0x44]
700a78d4: b928         	cbnz	r0, 0x700a78e2 <Sciclient_pmModuleGetClkStatus+0x92> @ imm = #0xa
700a78d6: e7ff         	b	0x700a78d8 <Sciclient_pmModuleGetClkStatus+0x88> @ imm = #-0x2
;         *state = (uint32_t) response.current_state;
700a78d8: f89d 002d    	ldrb.w	r0, [sp, #0x2d]
700a78dc: 9913         	ldr	r1, [sp, #0x4c]
700a78de: 6008         	str	r0, [r1]
;     }
700a78e0: e7ff         	b	0x700a78e2 <Sciclient_pmModuleGetClkStatus+0x92> @ imm = #-0x2
;     return retVal;
700a78e2: 9811         	ldr	r0, [sp, #0x44]
700a78e4: b016         	add	sp, #0x58
700a78e6: bd80         	pop	{r7, pc}
		...

700a78f0 <xQueueReceiveFromISR>:
; {
700a78f0: b580         	push	{r7, lr}
700a78f2: b088         	sub	sp, #0x20
700a78f4: 9007         	str	r0, [sp, #0x1c]
700a78f6: 9106         	str	r1, [sp, #0x18]
700a78f8: 9205         	str	r2, [sp, #0x14]
;     Queue_t * const pxQueue = xQueue;
700a78fa: 9807         	ldr	r0, [sp, #0x1c]
700a78fc: 9002         	str	r0, [sp, #0x8]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a78fe: f007 ea60    	blx	0x700aedc0 <HwiP_disable> @ imm = #0x74c0
700a7902: 9003         	str	r0, [sp, #0xc]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a7904: 9802         	ldr	r0, [sp, #0x8]
700a7906: 6b80         	ldr	r0, [r0, #0x38]
700a7908: 9001         	str	r0, [sp, #0x4]
;         if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a790a: 9801         	ldr	r0, [sp, #0x4]
700a790c: b398         	cbz	r0, 0x700a7976 <xQueueReceiveFromISR+0x86> @ imm = #0x66
700a790e: e7ff         	b	0x700a7910 <xQueueReceiveFromISR+0x20> @ imm = #-0x2
;             const int8_t cRxLock = pxQueue->cRxLock;
700a7910: 9802         	ldr	r0, [sp, #0x8]
700a7912: f890 0044    	ldrb.w	r0, [r0, #0x44]
700a7916: f88d 0003    	strb.w	r0, [sp, #0x3]
;             prvCopyDataFromQueue( pxQueue, pvBuffer );
700a791a: 9802         	ldr	r0, [sp, #0x8]
700a791c: 9906         	ldr	r1, [sp, #0x18]
700a791e: f004 fb17    	bl	0x700abf50 <prvCopyDataFromQueue> @ imm = #0x462e
;             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
700a7922: 9801         	ldr	r0, [sp, #0x4]
700a7924: 3801         	subs	r0, #0x1
700a7926: 9902         	ldr	r1, [sp, #0x8]
700a7928: 6388         	str	r0, [r1, #0x38]
;             if( cRxLock == queueUNLOCKED )
700a792a: f99d 0003    	ldrsb.w	r0, [sp, #0x3]
700a792e: 3001         	adds	r0, #0x1
700a7930: b9b8         	cbnz	r0, 0x700a7962 <xQueueReceiveFromISR+0x72> @ imm = #0x2e
700a7932: e7ff         	b	0x700a7934 <xQueueReceiveFromISR+0x44> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a7934: 9802         	ldr	r0, [sp, #0x8]
700a7936: 6900         	ldr	r0, [r0, #0x10]
700a7938: b188         	cbz	r0, 0x700a795e <xQueueReceiveFromISR+0x6e> @ imm = #0x22
700a793a: e7ff         	b	0x700a793c <xQueueReceiveFromISR+0x4c> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a793c: 9802         	ldr	r0, [sp, #0x8]
700a793e: 3010         	adds	r0, #0x10
700a7940: f7fe fad6    	bl	0x700a5ef0 <xTaskRemoveFromEventList> @ imm = #-0x1a54
700a7944: b148         	cbz	r0, 0x700a795a <xQueueReceiveFromISR+0x6a> @ imm = #0x12
700a7946: e7ff         	b	0x700a7948 <xQueueReceiveFromISR+0x58> @ imm = #-0x2
;                         if( pxHigherPriorityTaskWoken != NULL )
700a7948: 9805         	ldr	r0, [sp, #0x14]
700a794a: b120         	cbz	r0, 0x700a7956 <xQueueReceiveFromISR+0x66> @ imm = #0x8
700a794c: e7ff         	b	0x700a794e <xQueueReceiveFromISR+0x5e> @ imm = #-0x2
;                             *pxHigherPriorityTaskWoken = pdTRUE;
700a794e: 9905         	ldr	r1, [sp, #0x14]
700a7950: 2001         	movs	r0, #0x1
700a7952: 6008         	str	r0, [r1]
;                         }
700a7954: e000         	b	0x700a7958 <xQueueReceiveFromISR+0x68> @ imm = #0x0
700a7956: e7ff         	b	0x700a7958 <xQueueReceiveFromISR+0x68> @ imm = #-0x2
;                     }
700a7958: e000         	b	0x700a795c <xQueueReceiveFromISR+0x6c> @ imm = #0x0
700a795a: e7ff         	b	0x700a795c <xQueueReceiveFromISR+0x6c> @ imm = #-0x2
;                 }
700a795c: e000         	b	0x700a7960 <xQueueReceiveFromISR+0x70> @ imm = #0x0
700a795e: e7ff         	b	0x700a7960 <xQueueReceiveFromISR+0x70> @ imm = #-0x2
;             }
700a7960: e006         	b	0x700a7970 <xQueueReceiveFromISR+0x80> @ imm = #0xc
;                 pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
700a7962: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a7966: 3001         	adds	r0, #0x1
700a7968: 9902         	ldr	r1, [sp, #0x8]
700a796a: f881 0044    	strb.w	r0, [r1, #0x44]
700a796e: e7ff         	b	0x700a7970 <xQueueReceiveFromISR+0x80> @ imm = #-0x2
700a7970: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a7972: 9004         	str	r0, [sp, #0x10]
;         }
700a7974: e002         	b	0x700a797c <xQueueReceiveFromISR+0x8c> @ imm = #0x4
700a7976: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
700a7978: 9004         	str	r0, [sp, #0x10]
700a797a: e7ff         	b	0x700a797c <xQueueReceiveFromISR+0x8c> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a797c: 9803         	ldr	r0, [sp, #0xc]
700a797e: f007 ea40    	blx	0x700aee00 <HwiP_restore> @ imm = #0x7480
;     return xReturn;
700a7982: 9804         	ldr	r0, [sp, #0x10]
700a7984: b008         	add	sp, #0x20
700a7986: bd80         	pop	{r7, pc}
		...

700a7990 <xTaskCreate>:
;     UBaseType_t uxPriority, TaskHandle_t *const pxCreatedTask) {
700a7990: b570         	push	{r4, r5, r6, lr}
700a7992: b08c         	sub	sp, #0x30
700a7994: f8dd c044    	ldr.w	r12, [sp, #0x44]
700a7998: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a799c: 900b         	str	r0, [sp, #0x2c]
700a799e: 910a         	str	r1, [sp, #0x28]
700a79a0: 9209         	str	r2, [sp, #0x24]
700a79a2: 9308         	str	r3, [sp, #0x20]
;         (((size_t)usStackDepth) *
700a79a4: 9809         	ldr	r0, [sp, #0x24]
700a79a6: 0080         	lsls	r0, r0, #0x2
;     pxStack = (StackType_t *)pvPortMalloc(
700a79a8: f006 f842    	bl	0x700ada30 <pvPortMalloc> @ imm = #0x6084
700a79ac: 9005         	str	r0, [sp, #0x14]
;     if (pxStack != NULL) {
700a79ae: 9805         	ldr	r0, [sp, #0x14]
700a79b0: b180         	cbz	r0, 0x700a79d4 <xTaskCreate+0x44> @ imm = #0x20
700a79b2: e7ff         	b	0x700a79b4 <xTaskCreate+0x24> @ imm = #-0x2
700a79b4: 2088         	movs	r0, #0x88
;       pxNewTCB = (TCB_t *)pvPortMalloc(
700a79b6: f006 f83b    	bl	0x700ada30 <pvPortMalloc> @ imm = #0x6076
700a79ba: 9007         	str	r0, [sp, #0x1c]
;       if (pxNewTCB != NULL) {
700a79bc: 9807         	ldr	r0, [sp, #0x1c]
700a79be: b120         	cbz	r0, 0x700a79ca <xTaskCreate+0x3a> @ imm = #0x8
700a79c0: e7ff         	b	0x700a79c2 <xTaskCreate+0x32> @ imm = #-0x2
;         pxNewTCB->pxStack = pxStack;
700a79c2: 9805         	ldr	r0, [sp, #0x14]
700a79c4: 9907         	ldr	r1, [sp, #0x1c]
700a79c6: 6308         	str	r0, [r1, #0x30]
;       } else {
700a79c8: e003         	b	0x700a79d2 <xTaskCreate+0x42> @ imm = #0x6
;         vPortFree(pxStack);
700a79ca: 9805         	ldr	r0, [sp, #0x14]
700a79cc: f005 ff40    	bl	0x700ad850 <vPortFree>  @ imm = #0x5e80
700a79d0: e7ff         	b	0x700a79d2 <xTaskCreate+0x42> @ imm = #-0x2
;     } else {
700a79d2: e002         	b	0x700a79da <xTaskCreate+0x4a> @ imm = #0x4
700a79d4: 2000         	movs	r0, #0x0
;       pxNewTCB = NULL;
700a79d6: 9007         	str	r0, [sp, #0x1c]
700a79d8: e7ff         	b	0x700a79da <xTaskCreate+0x4a> @ imm = #-0x2
;   if (pxNewTCB != NULL) {
700a79da: 9807         	ldr	r0, [sp, #0x1c]
700a79dc: b1e8         	cbz	r0, 0x700a7a1a <xTaskCreate+0x8a> @ imm = #0x3a
700a79de: e7ff         	b	0x700a79e0 <xTaskCreate+0x50> @ imm = #-0x2
;       pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
700a79e0: 9807         	ldr	r0, [sp, #0x1c]
700a79e2: 2600         	movs	r6, #0x0
700a79e4: f880 6081    	strb.w	r6, [r0, #0x81]
;     prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth,
700a79e8: 980b         	ldr	r0, [sp, #0x2c]
700a79ea: 990a         	ldr	r1, [sp, #0x28]
700a79ec: 9a09         	ldr	r2, [sp, #0x24]
;                          pvParameters, uxPriority, pxCreatedTask, pxNewTCB,
700a79ee: 9b08         	ldr	r3, [sp, #0x20]
700a79f0: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a79f4: 9c11         	ldr	r4, [sp, #0x44]
700a79f6: 9d07         	ldr	r5, [sp, #0x1c]
;     prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth,
700a79f8: 46ee         	mov	lr, sp
700a79fa: f8ce 600c    	str.w	r6, [lr, #0xc]
700a79fe: f8ce 5008    	str.w	r5, [lr, #0x8]
700a7a02: f8ce 4004    	str.w	r4, [lr, #0x4]
700a7a06: f8ce c000    	str.w	r12, [lr]
700a7a0a: f7fb fcd1    	bl	0x700a33b0 <prvInitialiseNewTask> @ imm = #-0x465e
;     prvAddNewTaskToReadyList(pxNewTCB);
700a7a0e: 9807         	ldr	r0, [sp, #0x1c]
700a7a10: f7fb fde6    	bl	0x700a35e0 <prvAddNewTaskToReadyList> @ imm = #-0x4434
700a7a14: 2001         	movs	r0, #0x1
;     xReturn = pdPASS;
700a7a16: 9006         	str	r0, [sp, #0x18]
;   } else {
700a7a18: e003         	b	0x700a7a22 <xTaskCreate+0x92> @ imm = #0x6
700a7a1a: f04f 30ff    	mov.w	r0, #0xffffffff
;     xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
700a7a1e: 9006         	str	r0, [sp, #0x18]
700a7a20: e7ff         	b	0x700a7a22 <xTaskCreate+0x92> @ imm = #-0x2
;   return xReturn;
700a7a22: 9806         	ldr	r0, [sp, #0x18]
700a7a24: b00c         	add	sp, #0x30
700a7a26: bd70         	pop	{r4, r5, r6, pc}
		...

700a7a30 <PMU_profileStart>:
; int32_t PMU_profileStart(const char *name) {
700a7a30: b580         	push	{r7, lr}
700a7a32: b088         	sub	sp, #0x20
700a7a34: 9006         	str	r0, [sp, #0x18]
;   if (gProfileObject.logIndex >= PMU_MAX_LOG_ENTRIES) {
700a7a36: f243 0080    	movw	r0, #0x3080
700a7a3a: f2c7 0008    	movt	r0, #0x7008
700a7a3e: 6800         	ldr	r0, [r0]
700a7a40: 2840         	cmp	r0, #0x40
700a7a42: d304         	blo	0x700a7a4e <PMU_profileStart+0x1e> @ imm = #0x8
700a7a44: e7ff         	b	0x700a7a46 <PMU_profileStart+0x16> @ imm = #-0x2
700a7a46: f04f 30ff    	mov.w	r0, #0xffffffff
;     return SystemP_FAILURE; /* Log is full */
700a7a4a: 9007         	str	r0, [sp, #0x1c]
700a7a4c: e038         	b	0x700a7ac0 <PMU_profileStart+0x90> @ imm = #0x70
;   uint32_t i = gProfileObject.logIndex;
700a7a4e: f243 0280    	movw	r2, #0x3080
700a7a52: f2c7 0208    	movt	r2, #0x7008
700a7a56: 6810         	ldr	r0, [r2]
700a7a58: 9005         	str	r0, [sp, #0x14]
;   uint32_t numEvents = gProfileObject.numEvents;
700a7a5a: 6890         	ldr	r0, [r2, #0x8]
700a7a5c: 9003         	str	r0, [sp, #0xc]
;   uint32_t bCCnt = gProfileObject.bCycleCounter;
700a7a5e: 6850         	ldr	r0, [r2, #0x4]
700a7a60: 9002         	str	r0, [sp, #0x8]
;   PMU_ProfilePoint *p = &gProfileObject.point[i];
700a7a62: 9805         	ldr	r0, [sp, #0x14]
700a7a64: 2134         	movs	r1, #0x34
700a7a66: fb00 2001    	mla	r0, r0, r1, r2
700a7a6a: 300c         	adds	r0, #0xc
700a7a6c: 9001         	str	r0, [sp, #0x4]
;   p->name = name;
700a7a6e: 9806         	ldr	r0, [sp, #0x18]
700a7a70: 9901         	ldr	r1, [sp, #0x4]
700a7a72: 6308         	str	r0, [r1, #0x30]
;   PMU_resetCounters();
700a7a74: f006 fb2c    	bl	0x700ae0d0 <PMU_resetCounters> @ imm = #0x6658
;   if (bCCnt == TRUE) {
700a7a78: 9802         	ldr	r0, [sp, #0x8]
700a7a7a: 2801         	cmp	r0, #0x1
700a7a7c: d106         	bne	0x700a7a8c <PMU_profileStart+0x5c> @ imm = #0xc
700a7a7e: e7ff         	b	0x700a7a80 <PMU_profileStart+0x50> @ imm = #-0x2
700a7a80: 201f         	movs	r0, #0x1f
;         CSL_armR5PmuReadCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM);
700a7a82: f7f8 eecc    	blx	0x700a081c <CSL_armR5PmuReadCntr> @ imm = #-0x7268
;     p->cycleCount.value =
700a7a86: 9901         	ldr	r1, [sp, #0x4]
700a7a88: 62c8         	str	r0, [r1, #0x2c]
;   }
700a7a8a: e7ff         	b	0x700a7a8c <PMU_profileStart+0x5c> @ imm = #-0x2
700a7a8c: 2000         	movs	r0, #0x0
;   for (j = 0; j < numEvents; j++) {
700a7a8e: 9004         	str	r0, [sp, #0x10]
700a7a90: e7ff         	b	0x700a7a92 <PMU_profileStart+0x62> @ imm = #-0x2
700a7a92: 9804         	ldr	r0, [sp, #0x10]
700a7a94: 9903         	ldr	r1, [sp, #0xc]
700a7a96: 4288         	cmp	r0, r1
700a7a98: d20f         	bhs	0x700a7aba <PMU_profileStart+0x8a> @ imm = #0x1e
700a7a9a: e7ff         	b	0x700a7a9c <PMU_profileStart+0x6c> @ imm = #-0x2
;     p->events[j].value = CSL_armR5PmuReadCntr(j);
700a7a9c: 9804         	ldr	r0, [sp, #0x10]
700a7a9e: f7f8 eebe    	blx	0x700a081c <CSL_armR5PmuReadCntr> @ imm = #-0x7284
700a7aa2: 9901         	ldr	r1, [sp, #0x4]
700a7aa4: 9a04         	ldr	r2, [sp, #0x10]
700a7aa6: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a7aaa: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a7aae: 6088         	str	r0, [r1, #0x8]
;   }
700a7ab0: e7ff         	b	0x700a7ab2 <PMU_profileStart+0x82> @ imm = #-0x2
;   for (j = 0; j < numEvents; j++) {
700a7ab2: 9804         	ldr	r0, [sp, #0x10]
700a7ab4: 3001         	adds	r0, #0x1
700a7ab6: 9004         	str	r0, [sp, #0x10]
700a7ab8: e7eb         	b	0x700a7a92 <PMU_profileStart+0x62> @ imm = #-0x2a
700a7aba: 2000         	movs	r0, #0x0
;   return SystemP_SUCCESS;
700a7abc: 9007         	str	r0, [sp, #0x1c]
700a7abe: e7ff         	b	0x700a7ac0 <PMU_profileStart+0x90> @ imm = #-0x2
; }
700a7ac0: 9807         	ldr	r0, [sp, #0x1c]
700a7ac2: b008         	add	sp, #0x20
700a7ac4: bd80         	pop	{r7, pc}
		...
700a7ace: 0000         	movs	r0, r0

700a7ad0 <Sciclient_init>:
; {
700a7ad0: b580         	push	{r7, lr}
700a7ad2: b086         	sub	sp, #0x18
700a7ad4: 9005         	str	r0, [sp, #0x14]
700a7ad6: 2100         	movs	r1, #0x0
;     int32_t   status = SystemP_SUCCESS;
700a7ad8: 9101         	str	r1, [sp, #0x4]
700a7ada: 9104         	str	r1, [sp, #0x10]
;         = (CSL_sec_proxyRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyRegs);
700a7adc: f640 4078    	movw	r0, #0xc78
700a7ae0: f2c7 000b    	movt	r0, #0x700b
700a7ae4: 9002         	str	r0, [sp, #0x8]
700a7ae6: 6800         	ldr	r0, [r0]
700a7ae8: f7fc fa8a    	bl	0x700a4000 <AddrTranslateP_getLocalAddr> @ imm = #-0x3aec
700a7aec: 9901         	ldr	r1, [sp, #0x4]
700a7aee: 4602         	mov	r2, r0
700a7af0: 9802         	ldr	r0, [sp, #0x8]
700a7af2: 6002         	str	r2, [r0]
;         = (CSL_sec_proxy_scfgRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyScfgRegs);
700a7af4: 6840         	ldr	r0, [r0, #0x4]
700a7af6: f7fc fa83    	bl	0x700a4000 <AddrTranslateP_getLocalAddr> @ imm = #-0x3afa
700a7afa: 9901         	ldr	r1, [sp, #0x4]
700a7afc: 4602         	mov	r2, r0
700a7afe: 9802         	ldr	r0, [sp, #0x8]
700a7b00: 6042         	str	r2, [r0, #0x4]
;         = (CSL_sec_proxy_rtRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyRtRegs);
700a7b02: 6880         	ldr	r0, [r0, #0x8]
700a7b04: f7fc fa7c    	bl	0x700a4000 <AddrTranslateP_getLocalAddr> @ imm = #-0x3b08
700a7b08: 9902         	ldr	r1, [sp, #0x8]
700a7b0a: 6088         	str	r0, [r1, #0x8]
;         = (uint64_t)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.proxyTargetAddr);
700a7b0c: 6908         	ldr	r0, [r1, #0x10]
700a7b0e: 6949         	ldr	r1, [r1, #0x14]
700a7b10: f7fc fa76    	bl	0x700a4000 <AddrTranslateP_getLocalAddr> @ imm = #-0x3b14
700a7b14: 9a02         	ldr	r2, [sp, #0x8]
700a7b16: 4601         	mov	r1, r0
700a7b18: 9801         	ldr	r0, [sp, #0x4]
700a7b1a: 6150         	str	r0, [r2, #0x14]
700a7b1c: 6111         	str	r1, [r2, #0x10]
;     gSciclientHandle.currSeqId = 0;
700a7b1e: f640 5100    	movw	r1, #0xd00
700a7b22: f2c7 010b    	movt	r1, #0x700b
700a7b26: 9103         	str	r1, [sp, #0xc]
700a7b28: 6008         	str	r0, [r1]
;     gSciclientHandle.coreId = coreId;
700a7b2a: 9805         	ldr	r0, [sp, #0x14]
700a7b2c: 6048         	str	r0, [r1, #0x4]
;     gSciclientHandle.devIdCore = Sciclient_getDevId(coreId);
700a7b2e: 9805         	ldr	r0, [sp, #0x14]
700a7b30: f003 fec6    	bl	0x700ab8c0 <Sciclient_getDevId> @ imm = #0x3d8c
700a7b34: 9a03         	ldr	r2, [sp, #0xc]
700a7b36: 4601         	mov	r1, r0
700a7b38: 9801         	ldr	r0, [sp, #0x4]
700a7b3a: 6091         	str	r1, [r2, #0x8]
;     gSciclientHandle.secureContextId = Sciclient_getContext(SCICLIENT_SECURE_CONTEXT, coreId);
700a7b3c: 9905         	ldr	r1, [sp, #0x14]
700a7b3e: f7ff fb17    	bl	0x700a7170 <Sciclient_getContext> @ imm = #-0x9d2
700a7b42: 9903         	ldr	r1, [sp, #0xc]
700a7b44: 60c8         	str	r0, [r1, #0xc]
;     gSciclientHandle.nonSecureContextId = Sciclient_getContext(SCICLIENT_NON_SECURE_CONTEXT, coreId);
700a7b46: 9905         	ldr	r1, [sp, #0x14]
700a7b48: 2001         	movs	r0, #0x1
700a7b4a: f7ff fb11    	bl	0x700a7170 <Sciclient_getContext> @ imm = #-0x9de
700a7b4e: 9a03         	ldr	r2, [sp, #0xc]
700a7b50: 4601         	mov	r1, r0
700a7b52: 9802         	ldr	r0, [sp, #0x8]
700a7b54: 6111         	str	r1, [r2, #0x10]
;     gSciclientHandle.maxMsgSizeBytes = CSL_secProxyGetMaxMsgSize(&gSciclientSecProxyCfg) -
700a7b56: f005 f8db    	bl	0x700acd10 <CSL_secProxyGetMaxMsgSize> @ imm = #0x51b6
700a7b5a: 9903         	ldr	r1, [sp, #0xc]
700a7b5c: 3804         	subs	r0, #0x4
700a7b5e: 6148         	str	r0, [r1, #0x14]
;     return status;
700a7b60: 9804         	ldr	r0, [sp, #0x10]
700a7b62: b006         	add	sp, #0x18
700a7b64: bd80         	pop	{r7, pc}
		...
700a7b6e: 0000         	movs	r0, r0

700a7b70 <UART_subConfigTCRTLRModeEn>:
; {
700a7b70: b580         	push	{r7, lr}
700a7b72: b088         	sub	sp, #0x20
700a7b74: 9007         	str	r0, [sp, #0x1c]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a7b76: 9807         	ldr	r0, [sp, #0x1c]
700a7b78: 21bf         	movs	r1, #0xbf
700a7b7a: 9101         	str	r1, [sp, #0x4]
700a7b7c: f003 f810    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #0x3020
700a7b80: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a7b82: 9807         	ldr	r0, [sp, #0x1c]
700a7b84: 3008         	adds	r0, #0x8
700a7b86: 2110         	movs	r1, #0x10
700a7b88: 9102         	str	r1, [sp, #0x8]
700a7b8a: 2204         	movs	r2, #0x4
700a7b8c: 9203         	str	r2, [sp, #0xc]
700a7b8e: f005 fe1f    	bl	0x700ad7d0 <HW_RD_FIELD32_RAW> @ imm = #0x5c3e
700a7b92: 9902         	ldr	r1, [sp, #0x8]
700a7b94: 9a03         	ldr	r2, [sp, #0xc]
700a7b96: 9006         	str	r0, [sp, #0x18]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a7b98: 9807         	ldr	r0, [sp, #0x1c]
700a7b9a: 3008         	adds	r0, #0x8
700a7b9c: 2301         	movs	r3, #0x1
700a7b9e: 9300         	str	r3, [sp]
700a7ba0: f004 ff96    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x4f2c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a7ba4: 9807         	ldr	r0, [sp, #0x1c]
700a7ba6: 300c         	adds	r0, #0xc
700a7ba8: 9904         	ldr	r1, [sp, #0x10]
700a7baa: f006 fa21    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x6442
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700a7bae: 9807         	ldr	r0, [sp, #0x1c]
700a7bb0: 2180         	movs	r1, #0x80
700a7bb2: f002 fff5    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #0x2fea
700a7bb6: 9004         	str	r0, [sp, #0x10]
;     tcrTlrValue = HW_RD_REG32(baseAddr + UART_MCR) & UART_MCR_TCR_TLR_MASK;
700a7bb8: 9807         	ldr	r0, [sp, #0x1c]
700a7bba: 3010         	adds	r0, #0x10
700a7bbc: f006 fa10    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x6420
700a7bc0: 9b00         	ldr	r3, [sp]
700a7bc2: f000 0040    	and	r0, r0, #0x40
700a7bc6: 9005         	str	r0, [sp, #0x14]
;     HW_WR_FIELD32(baseAddr + UART_MCR, UART_MCR_TCR_TLR,
700a7bc8: 9807         	ldr	r0, [sp, #0x1c]
700a7bca: 3010         	adds	r0, #0x10
700a7bcc: 2140         	movs	r1, #0x40
700a7bce: 2206         	movs	r2, #0x6
700a7bd0: f004 ff7e    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x4efc
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a7bd4: 9807         	ldr	r0, [sp, #0x1c]
700a7bd6: 300c         	adds	r0, #0xc
700a7bd8: 9904         	ldr	r1, [sp, #0x10]
700a7bda: f006 fa09    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x6412
700a7bde: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a7be0: 9807         	ldr	r0, [sp, #0x1c]
700a7be2: f002 ffdd    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #0x2fba
700a7be6: 9902         	ldr	r1, [sp, #0x8]
700a7be8: 9a03         	ldr	r2, [sp, #0xc]
700a7bea: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a7bec: 9807         	ldr	r0, [sp, #0x1c]
700a7bee: 3008         	adds	r0, #0x8
700a7bf0: 9b06         	ldr	r3, [sp, #0x18]
700a7bf2: f004 ff6d    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x4eda
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a7bf6: 9807         	ldr	r0, [sp, #0x1c]
700a7bf8: 300c         	adds	r0, #0xc
700a7bfa: 9904         	ldr	r1, [sp, #0x10]
700a7bfc: f006 f9f8    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x63f0
;     return tcrTlrValue;
700a7c00: 9805         	ldr	r0, [sp, #0x14]
700a7c02: b008         	add	sp, #0x20
700a7c04: bd80         	pop	{r7, pc}
		...
700a7c0e: 0000         	movs	r0, r0

700a7c10 <UART_udmaIsrRx>:
; {
700a7c10: b580         	push	{r7, lr}
700a7c12: b08a         	sub	sp, #0x28
700a7c14: 9009         	str	r0, [sp, #0x24]
700a7c16: 9108         	str	r1, [sp, #0x20]
700a7c18: 9207         	str	r2, [sp, #0x1c]
;     if(NULL != args)
700a7c1a: 9807         	ldr	r0, [sp, #0x1c]
700a7c1c: 2800         	cmp	r0, #0x0
700a7c1e: d040         	beq	0x700a7ca2 <UART_udmaIsrRx+0x92> @ imm = #0x80
700a7c20: e7ff         	b	0x700a7c22 <UART_udmaIsrRx+0x12> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a7c22: 9807         	ldr	r0, [sp, #0x1c]
700a7c24: 9000         	str	r0, [sp]
;         udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a7c26: 9800         	ldr	r0, [sp]
700a7c28: 6840         	ldr	r0, [r0, #0x4]
700a7c2a: 6cc0         	ldr	r0, [r0, #0x4c]
700a7c2c: 9001         	str	r0, [sp, #0x4]
;         rxChHandle  = udmaChCfg->rxChHandle;
700a7c2e: 9801         	ldr	r0, [sp, #0x4]
700a7c30: 6880         	ldr	r0, [r0, #0x8]
700a7c32: 9002         	str	r0, [sp, #0x8]
;         if (eventType == UDMA_EVENT_TYPE_DMA_COMPLETION)
700a7c34: 9808         	ldr	r0, [sp, #0x20]
700a7c36: 2801         	cmp	r0, #0x1
700a7c38: d12e         	bne	0x700a7c98 <UART_udmaIsrRx+0x88> @ imm = #0x5c
700a7c3a: e7ff         	b	0x700a7c3c <UART_udmaIsrRx+0x2c> @ imm = #-0x2
;             CacheP_inv(udmaChCfg->rxHpdMem, udmaChCfg->hpdMemSize, CacheP_TYPE_ALLD);
700a7c3c: 9901         	ldr	r1, [sp, #0x4]
700a7c3e: 6988         	ldr	r0, [r1, #0x18]
700a7c40: 69c9         	ldr	r1, [r1, #0x1c]
700a7c42: 220a         	movs	r2, #0xa
700a7c44: f007 fb4c    	bl	0x700af2e0 <CacheP_inv> @ imm = #0x7698
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(rxChHandle), &pDesc);
700a7c48: 9802         	ldr	r0, [sp, #0x8]
700a7c4a: f001 fbe9    	bl	0x700a9420 <Udma_chGetCqRingHandle> @ imm = #0x17d2
700a7c4e: a904         	add	r1, sp, #0x10
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(rxChHandle), &pDesc);
700a7c50: f000 f8ce    	bl	0x700a7df0 <Udma_ringDequeueRaw> @ imm = #0x19c
700a7c54: 9006         	str	r0, [sp, #0x18]
;             if ((retVal == UDMA_SOK) && (pDesc != 0UL))
700a7c56: 9806         	ldr	r0, [sp, #0x18]
700a7c58: b988         	cbnz	r0, 0x700a7c7e <UART_udmaIsrRx+0x6e> @ imm = #0x22
700a7c5a: e7ff         	b	0x700a7c5c <UART_udmaIsrRx+0x4c> @ imm = #-0x2
700a7c5c: 9804         	ldr	r0, [sp, #0x10]
700a7c5e: 9905         	ldr	r1, [sp, #0x14]
700a7c60: 4308         	orrs	r0, r1
700a7c62: b160         	cbz	r0, 0x700a7c7e <UART_udmaIsrRx+0x6e> @ imm = #0x18
700a7c64: e7ff         	b	0x700a7c66 <UART_udmaIsrRx+0x56> @ imm = #-0x2
;                 pHpd = (CSL_UdmapCppi5HMPD *)(uintptr_t)pDesc;
700a7c66: 9804         	ldr	r0, [sp, #0x10]
700a7c68: 9003         	str	r0, [sp, #0xc]
;                 hUart->readTrans.count = (pHpd->descInfo & CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_MASK) >> CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_SHIFT;
700a7c6a: 9803         	ldr	r0, [sp, #0xc]
700a7c6c: 6800         	ldr	r0, [r0]
700a7c6e: f36f 509f    	bfc	r0, #22, #10
700a7c72: 9900         	ldr	r1, [sp]
700a7c74: 62c8         	str	r0, [r1, #0x2c]
;                 hUart->readTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a7c76: 9900         	ldr	r1, [sp]
700a7c78: 2000         	movs	r0, #0x0
700a7c7a: 6348         	str	r0, [r1, #0x34]
;             }
700a7c7c: e003         	b	0x700a7c86 <UART_udmaIsrRx+0x76> @ imm = #0x6
;                 hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a7c7e: 9900         	ldr	r1, [sp]
700a7c80: 200a         	movs	r0, #0xa
700a7c82: 6348         	str	r0, [r1, #0x34]
700a7c84: e7ff         	b	0x700a7c86 <UART_udmaIsrRx+0x76> @ imm = #-0x2
;             hUart->hUartInit->readCompleteCallbackFxn(hUart);
700a7c86: 9800         	ldr	r0, [sp]
700a7c88: 6841         	ldr	r1, [r0, #0x4]
700a7c8a: 6dc9         	ldr	r1, [r1, #0x5c]
700a7c8c: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->readTrans);
700a7c8e: 9800         	ldr	r0, [sp]
700a7c90: 3028         	adds	r0, #0x28
700a7c92: f005 fe3d    	bl	0x700ad910 <UART_lld_Transaction_deInit> @ imm = #0x5c7a
;         }
700a7c96: e003         	b	0x700a7ca0 <UART_udmaIsrRx+0x90> @ imm = #0x6
;             hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a7c98: 9900         	ldr	r1, [sp]
700a7c9a: 200a         	movs	r0, #0xa
700a7c9c: 6488         	str	r0, [r1, #0x48]
700a7c9e: e7ff         	b	0x700a7ca0 <UART_udmaIsrRx+0x90> @ imm = #-0x2
;     }
700a7ca0: e7ff         	b	0x700a7ca2 <UART_udmaIsrRx+0x92> @ imm = #-0x2
;     return;
700a7ca2: b00a         	add	sp, #0x28
700a7ca4: bd80         	pop	{r7, pc}
		...
700a7cae: 0000         	movs	r0, r0

700a7cb0 <UART_udmaIsrTx>:
; {
700a7cb0: b580         	push	{r7, lr}
700a7cb2: b08a         	sub	sp, #0x28
700a7cb4: 9009         	str	r0, [sp, #0x24]
700a7cb6: 9108         	str	r1, [sp, #0x20]
700a7cb8: 9207         	str	r2, [sp, #0x1c]
;     if(NULL != args)
700a7cba: 9807         	ldr	r0, [sp, #0x1c]
700a7cbc: 2800         	cmp	r0, #0x0
700a7cbe: d040         	beq	0x700a7d42 <UART_udmaIsrTx+0x92> @ imm = #0x80
700a7cc0: e7ff         	b	0x700a7cc2 <UART_udmaIsrTx+0x12> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a7cc2: 9807         	ldr	r0, [sp, #0x1c]
700a7cc4: 9000         	str	r0, [sp]
;         udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a7cc6: 9800         	ldr	r0, [sp]
700a7cc8: 6840         	ldr	r0, [r0, #0x4]
700a7cca: 6cc0         	ldr	r0, [r0, #0x4c]
700a7ccc: 9001         	str	r0, [sp, #0x4]
;         txChHandle  = udmaChCfg->txChHandle;
700a7cce: 9801         	ldr	r0, [sp, #0x4]
700a7cd0: 6840         	ldr	r0, [r0, #0x4]
700a7cd2: 9002         	str	r0, [sp, #0x8]
;         if (eventType == UDMA_EVENT_TYPE_DMA_COMPLETION)
700a7cd4: 9808         	ldr	r0, [sp, #0x20]
700a7cd6: 2801         	cmp	r0, #0x1
700a7cd8: d12e         	bne	0x700a7d38 <UART_udmaIsrTx+0x88> @ imm = #0x5c
700a7cda: e7ff         	b	0x700a7cdc <UART_udmaIsrTx+0x2c> @ imm = #-0x2
;             CacheP_inv(udmaChCfg->txHpdMem, udmaChCfg->hpdMemSize, CacheP_TYPE_ALLD);
700a7cdc: 9901         	ldr	r1, [sp, #0x4]
700a7cde: 6948         	ldr	r0, [r1, #0x14]
700a7ce0: 69c9         	ldr	r1, [r1, #0x1c]
700a7ce2: 220a         	movs	r2, #0xa
700a7ce4: f007 fafc    	bl	0x700af2e0 <CacheP_inv> @ imm = #0x75f8
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(txChHandle), &pDesc);
700a7ce8: 9802         	ldr	r0, [sp, #0x8]
700a7cea: f001 fb99    	bl	0x700a9420 <Udma_chGetCqRingHandle> @ imm = #0x1732
700a7cee: a904         	add	r1, sp, #0x10
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(txChHandle), &pDesc);
700a7cf0: f000 f87e    	bl	0x700a7df0 <Udma_ringDequeueRaw> @ imm = #0xfc
700a7cf4: 9006         	str	r0, [sp, #0x18]
;             if ((retVal == UDMA_SOK) && (pDesc != 0UL))
700a7cf6: 9806         	ldr	r0, [sp, #0x18]
700a7cf8: b988         	cbnz	r0, 0x700a7d1e <UART_udmaIsrTx+0x6e> @ imm = #0x22
700a7cfa: e7ff         	b	0x700a7cfc <UART_udmaIsrTx+0x4c> @ imm = #-0x2
700a7cfc: 9804         	ldr	r0, [sp, #0x10]
700a7cfe: 9905         	ldr	r1, [sp, #0x14]
700a7d00: 4308         	orrs	r0, r1
700a7d02: b160         	cbz	r0, 0x700a7d1e <UART_udmaIsrTx+0x6e> @ imm = #0x18
700a7d04: e7ff         	b	0x700a7d06 <UART_udmaIsrTx+0x56> @ imm = #-0x2
;                 pHpd = (CSL_UdmapCppi5HMPD *)(uintptr_t)pDesc;
700a7d06: 9804         	ldr	r0, [sp, #0x10]
700a7d08: 9003         	str	r0, [sp, #0xc]
;                 hUart->writeTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a7d0a: 9900         	ldr	r1, [sp]
700a7d0c: 2000         	movs	r0, #0x0
700a7d0e: 6488         	str	r0, [r1, #0x48]
;                 hUart->writeTrans.count = (pHpd->descInfo & CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_MASK) >> CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_SHIFT;
700a7d10: 9803         	ldr	r0, [sp, #0xc]
700a7d12: 6800         	ldr	r0, [r0]
700a7d14: f36f 509f    	bfc	r0, #22, #10
700a7d18: 9900         	ldr	r1, [sp]
700a7d1a: 6408         	str	r0, [r1, #0x40]
;             }
700a7d1c: e003         	b	0x700a7d26 <UART_udmaIsrTx+0x76> @ imm = #0x6
;                 hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a7d1e: 9900         	ldr	r1, [sp]
700a7d20: 200a         	movs	r0, #0xa
700a7d22: 6488         	str	r0, [r1, #0x48]
700a7d24: e7ff         	b	0x700a7d26 <UART_udmaIsrTx+0x76> @ imm = #-0x2
;             hUart->hUartInit->writeCompleteCallbackFxn(hUart);
700a7d26: 9800         	ldr	r0, [sp]
700a7d28: 6841         	ldr	r1, [r0, #0x4]
700a7d2a: 6e09         	ldr	r1, [r1, #0x60]
700a7d2c: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a7d2e: 9800         	ldr	r0, [sp]
700a7d30: 303c         	adds	r0, #0x3c
700a7d32: f005 fded    	bl	0x700ad910 <UART_lld_Transaction_deInit> @ imm = #0x5bda
;         }
700a7d36: e003         	b	0x700a7d40 <UART_udmaIsrTx+0x90> @ imm = #0x6
;             hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a7d38: 9900         	ldr	r1, [sp]
700a7d3a: 200a         	movs	r0, #0xa
700a7d3c: 6488         	str	r0, [r1, #0x48]
700a7d3e: e7ff         	b	0x700a7d40 <UART_udmaIsrTx+0x90> @ imm = #-0x2
;     }
700a7d40: e7ff         	b	0x700a7d42 <UART_udmaIsrTx+0x92> @ imm = #-0x2
;     return;
700a7d42: b00a         	add	sp, #0x28
700a7d44: bd80         	pop	{r7, pc}
		...
700a7d4e: 0000         	movs	r0, r0

700a7d50 <UdmaFlowPrms_init>:
; {
700a7d50: b084         	sub	sp, #0x10
700a7d52: 9003         	str	r0, [sp, #0xc]
700a7d54: 9102         	str	r1, [sp, #0x8]
;     if(NULL_PTR != flowPrms)
700a7d56: 9803         	ldr	r0, [sp, #0xc]
700a7d58: 2800         	cmp	r0, #0x0
700a7d5a: d042         	beq	0x700a7de2 <UdmaFlowPrms_init+0x92> @ imm = #0x84
700a7d5c: e7ff         	b	0x700a7d5e <UdmaFlowPrms_init+0xe> @ imm = #-0x2
;         flowPrms->rxChHandle    = (Udma_ChHandle) NULL_PTR;
700a7d5e: 9803         	ldr	r0, [sp, #0xc]
700a7d60: 2100         	movs	r1, #0x0
700a7d62: 9100         	str	r1, [sp]
700a7d64: 6001         	str	r1, [r0]
;         flowPrms->einfoPresent  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_EINFO_NOT_PRESENT;
700a7d66: 9803         	ldr	r0, [sp, #0xc]
700a7d68: 7101         	strb	r1, [r0, #0x4]
;         flowPrms->psInfoPresent = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PSINFO_NOT_PRESENT;
700a7d6a: 9803         	ldr	r0, [sp, #0xc]
700a7d6c: 7141         	strb	r1, [r0, #0x5]
;         flowPrms->errorHandling = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_ERR_RETRY;
700a7d6e: 9a03         	ldr	r2, [sp, #0xc]
700a7d70: 2001         	movs	r0, #0x1
700a7d72: 7190         	strb	r0, [r2, #0x6]
;         flowPrms->descType      = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DESC_HOST;
700a7d74: 9803         	ldr	r0, [sp, #0xc]
700a7d76: 71c1         	strb	r1, [r0, #0x7]
;         flowPrms->psLocation    = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PS_END_PD;
700a7d78: 9803         	ldr	r0, [sp, #0xc]
700a7d7a: 7201         	strb	r1, [r0, #0x8]
;         flowPrms->sopOffset     = 0U;
700a7d7c: 9803         	ldr	r0, [sp, #0xc]
700a7d7e: 8141         	strh	r1, [r0, #0xa]
;         flowPrms->defaultRxCQ   = UDMA_RING_INVALID;
700a7d80: 9a03         	ldr	r2, [sp, #0xc]
700a7d82: f64f 70ff    	movw	r0, #0xffff
700a7d86: 9001         	str	r0, [sp, #0x4]
700a7d88: 8190         	strh	r0, [r2, #0xc]
;         flowPrms->srcTagLo      = 0U;
700a7d8a: 9a03         	ldr	r2, [sp, #0xc]
700a7d8c: 73d1         	strb	r1, [r2, #0xf]
;         flowPrms->srcTagLoSel   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_SRC_SELECT_SRC_TAG;
700a7d8e: 9b03         	ldr	r3, [sp, #0xc]
700a7d90: 2204         	movs	r2, #0x4
700a7d92: 745a         	strb	r2, [r3, #0x11]
;         flowPrms->srcTagHi      = 0U;
700a7d94: 9b03         	ldr	r3, [sp, #0xc]
700a7d96: 7399         	strb	r1, [r3, #0xe]
;         flowPrms->srcTagHiSel   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_SRC_SELECT_FLOW_ID;
700a7d98: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700a7d9c: 2302         	movs	r3, #0x2
700a7d9e: f88c 3010    	strb.w	r3, [r12, #0x10]
;         flowPrms->destTagLo     = 0U;
700a7da2: 9b03         	ldr	r3, [sp, #0xc]
700a7da4: 74d9         	strb	r1, [r3, #0x13]
;         flowPrms->destTagLoSel  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DEST_SELECT_DEST_TAG_LO;
700a7da6: 9b03         	ldr	r3, [sp, #0xc]
700a7da8: 755a         	strb	r2, [r3, #0x15]
;         flowPrms->destTagHi     = 0U;
700a7daa: 9a03         	ldr	r2, [sp, #0xc]
700a7dac: 7491         	strb	r1, [r2, #0x12]
;         flowPrms->destTagHiSel  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DEST_SELECT_DEST_TAG_HI;
700a7dae: 9b03         	ldr	r3, [sp, #0xc]
700a7db0: 2205         	movs	r2, #0x5
700a7db2: 751a         	strb	r2, [r3, #0x14]
;         flowPrms->sizeThreshEn  = 0U;
700a7db4: 9a03         	ldr	r2, [sp, #0xc]
700a7db6: 7591         	strb	r1, [r2, #0x16]
;         flowPrms->fdq0Sz0Qnum   = UDMA_RING_INVALID;
700a7db8: 9a03         	ldr	r2, [sp, #0xc]
700a7dba: 8310         	strh	r0, [r2, #0x18]
;         flowPrms->fdq1Qnum      = UDMA_RING_INVALID;
700a7dbc: 9a03         	ldr	r2, [sp, #0xc]
700a7dbe: 8350         	strh	r0, [r2, #0x1a]
;         flowPrms->fdq2Qnum      = UDMA_RING_INVALID;
700a7dc0: 9a03         	ldr	r2, [sp, #0xc]
700a7dc2: 8390         	strh	r0, [r2, #0x1c]
;         flowPrms->fdq3Qnum      = UDMA_RING_INVALID;
700a7dc4: 9a03         	ldr	r2, [sp, #0xc]
700a7dc6: 83d0         	strh	r0, [r2, #0x1e]
;         flowPrms->sizeThresh0   = 0U;
700a7dc8: 9a03         	ldr	r2, [sp, #0xc]
700a7dca: 8411         	strh	r1, [r2, #0x20]
;         flowPrms->sizeThresh1   = 0U;
700a7dcc: 9a03         	ldr	r2, [sp, #0xc]
700a7dce: 8451         	strh	r1, [r2, #0x22]
;         flowPrms->sizeThresh2   = 0U;
700a7dd0: 9a03         	ldr	r2, [sp, #0xc]
700a7dd2: 8491         	strh	r1, [r2, #0x24]
;         flowPrms->fdq0Sz1Qnum   = UDMA_RING_INVALID;
700a7dd4: 9903         	ldr	r1, [sp, #0xc]
700a7dd6: 84c8         	strh	r0, [r1, #0x26]
;         flowPrms->fdq0Sz2Qnum   = UDMA_RING_INVALID;
700a7dd8: 9903         	ldr	r1, [sp, #0xc]
700a7dda: 8508         	strh	r0, [r1, #0x28]
;         flowPrms->fdq0Sz3Qnum   = UDMA_RING_INVALID;
700a7ddc: 9903         	ldr	r1, [sp, #0xc]
700a7dde: 8548         	strh	r0, [r1, #0x2a]
;     }
700a7de0: e7ff         	b	0x700a7de2 <UdmaFlowPrms_init+0x92> @ imm = #-0x2
;     return;
700a7de2: b004         	add	sp, #0x10
700a7de4: 4770         	bx	lr
		...
700a7dee: 0000         	movs	r0, r0

700a7df0 <Udma_ringDequeueRaw>:
; {
700a7df0: b580         	push	{r7, lr}
700a7df2: b086         	sub	sp, #0x18
700a7df4: 9005         	str	r0, [sp, #0x14]
700a7df6: 9104         	str	r1, [sp, #0x10]
700a7df8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a7dfa: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a7dfc: 9805         	ldr	r0, [sp, #0x14]
700a7dfe: 9000         	str	r0, [sp]
;     if((NULL_PTR == ringHandleInt) ||
700a7e00: 9800         	ldr	r0, [sp]
700a7e02: b180         	cbz	r0, 0x700a7e26 <Udma_ringDequeueRaw+0x36> @ imm = #0x20
700a7e04: e7ff         	b	0x700a7e06 <Udma_ringDequeueRaw+0x16> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a7e06: 9800         	ldr	r0, [sp]
700a7e08: 6d80         	ldr	r0, [r0, #0x58]
700a7e0a: f64a 31cd    	movw	r1, #0xabcd
700a7e0e: f6ca 31dc    	movt	r1, #0xabdc
700a7e12: 4288         	cmp	r0, r1
700a7e14: d107         	bne	0x700a7e26 <Udma_ringDequeueRaw+0x36> @ imm = #0xe
700a7e16: e7ff         	b	0x700a7e18 <Udma_ringDequeueRaw+0x28> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a7e18: 9800         	ldr	r0, [sp]
700a7e1a: 8880         	ldrh	r0, [r0, #0x4]
700a7e1c: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a7e20: 4288         	cmp	r0, r1
700a7e22: d104         	bne	0x700a7e2e <Udma_ringDequeueRaw+0x3e> @ imm = #0x8
700a7e24: e7ff         	b	0x700a7e26 <Udma_ringDequeueRaw+0x36> @ imm = #-0x2
700a7e26: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a7e2a: 9003         	str	r0, [sp, #0xc]
;     }
700a7e2c: e7ff         	b	0x700a7e2e <Udma_ringDequeueRaw+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7e2e: 9803         	ldr	r0, [sp, #0xc]
700a7e30: b9a8         	cbnz	r0, 0x700a7e5e <Udma_ringDequeueRaw+0x6e> @ imm = #0x2a
700a7e32: e7ff         	b	0x700a7e34 <Udma_ringDequeueRaw+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a7e34: 9800         	ldr	r0, [sp]
700a7e36: 6800         	ldr	r0, [r0]
700a7e38: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) ||
700a7e3a: 9801         	ldr	r0, [sp, #0x4]
700a7e3c: b150         	cbz	r0, 0x700a7e54 <Udma_ringDequeueRaw+0x64> @ imm = #0x14
700a7e3e: e7ff         	b	0x700a7e40 <Udma_ringDequeueRaw+0x50> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a7e40: 9801         	ldr	r0, [sp, #0x4]
700a7e42: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a7e46: f64a 31cd    	movw	r1, #0xabcd
700a7e4a: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a7e4e: 4288         	cmp	r0, r1
700a7e50: d004         	beq	0x700a7e5c <Udma_ringDequeueRaw+0x6c> @ imm = #0x8
700a7e52: e7ff         	b	0x700a7e54 <Udma_ringDequeueRaw+0x64> @ imm = #-0x2
700a7e54: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7e58: 9003         	str	r0, [sp, #0xc]
;         }
700a7e5a: e7ff         	b	0x700a7e5c <Udma_ringDequeueRaw+0x6c> @ imm = #-0x2
;     }
700a7e5c: e7ff         	b	0x700a7e5e <Udma_ringDequeueRaw+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7e5e: 9803         	ldr	r0, [sp, #0xc]
700a7e60: b970         	cbnz	r0, 0x700a7e80 <Udma_ringDequeueRaw+0x90> @ imm = #0x1c
700a7e62: e7ff         	b	0x700a7e64 <Udma_ringDequeueRaw+0x74> @ imm = #-0x2
;         cookie = HwiP_disable();
700a7e64: f006 efac    	blx	0x700aedc0 <HwiP_disable> @ imm = #0x6f58
700a7e68: 9002         	str	r0, [sp, #0x8]
;         retVal = drvHandle->ringDequeueRaw(drvHandle, ringHandleInt, phyDescMem);
700a7e6a: 9801         	ldr	r0, [sp, #0x4]
700a7e6c: f8d0 3590    	ldr.w	r3, [r0, #0x590]
700a7e70: 9900         	ldr	r1, [sp]
700a7e72: 9a04         	ldr	r2, [sp, #0x10]
700a7e74: 4798         	blx	r3
700a7e76: 9003         	str	r0, [sp, #0xc]
;         HwiP_restore(cookie);
700a7e78: 9802         	ldr	r0, [sp, #0x8]
700a7e7a: f006 efc2    	blx	0x700aee00 <HwiP_restore> @ imm = #0x6f84
;     }
700a7e7e: e7ff         	b	0x700a7e80 <Udma_ringDequeueRaw+0x90> @ imm = #-0x2
;     return (retVal);
700a7e80: 9803         	ldr	r0, [sp, #0xc]
700a7e82: b006         	add	sp, #0x18
700a7e84: bd80         	pop	{r7, pc}
		...
700a7e8e: 0000         	movs	r0, r0

700a7e90 <UART_lld_dmaDisableChannel>:
; {
700a7e90: b580         	push	{r7, lr}
700a7e92: b08a         	sub	sp, #0x28
700a7e94: 9009         	str	r0, [sp, #0x24]
700a7e96: 9108         	str	r1, [sp, #0x20]
700a7e98: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a7e9a: 9007         	str	r0, [sp, #0x1c]
700a7e9c: 2001         	movs	r0, #0x1
;     uint32_t temp = TRUE;
700a7e9e: 9006         	str	r0, [sp, #0x18]
;     udmaChCfg   = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a7ea0: 9809         	ldr	r0, [sp, #0x24]
700a7ea2: 6840         	ldr	r0, [r0, #0x4]
700a7ea4: 6cc0         	ldr	r0, [r0, #0x4c]
700a7ea6: 9005         	str	r0, [sp, #0x14]
;     if (isChannelTx == TRUE)
700a7ea8: 9808         	ldr	r0, [sp, #0x20]
700a7eaa: 2801         	cmp	r0, #0x1
700a7eac: d104         	bne	0x700a7eb8 <UART_lld_dmaDisableChannel+0x28> @ imm = #0x8
700a7eae: e7ff         	b	0x700a7eb0 <UART_lld_dmaDisableChannel+0x20> @ imm = #-0x2
;         chHandle = udmaChCfg->txChHandle;
700a7eb0: 9805         	ldr	r0, [sp, #0x14]
700a7eb2: 6840         	ldr	r0, [r0, #0x4]
700a7eb4: 9004         	str	r0, [sp, #0x10]
;     }
700a7eb6: e003         	b	0x700a7ec0 <UART_lld_dmaDisableChannel+0x30> @ imm = #0x6
;         chHandle = udmaChCfg->rxChHandle;
700a7eb8: 9805         	ldr	r0, [sp, #0x14]
700a7eba: 6880         	ldr	r0, [r0, #0x8]
700a7ebc: 9004         	str	r0, [sp, #0x10]
700a7ebe: e7ff         	b	0x700a7ec0 <UART_lld_dmaDisableChannel+0x30> @ imm = #-0x2
;     status = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
700a7ec0: 9804         	ldr	r0, [sp, #0x10]
700a7ec2: 2164         	movs	r1, #0x64
700a7ec4: f7fe fb3c    	bl	0x700a6540 <Udma_chDisable> @ imm = #-0x1988
700a7ec8: 9007         	str	r0, [sp, #0x1c]
;     DebugP_assert(UDMA_SOK == status);
700a7eca: 9807         	ldr	r0, [sp, #0x1c]
700a7ecc: fab0 f080    	clz	r0, r0
700a7ed0: 0940         	lsrs	r0, r0, #0x5
700a7ed2: f240 31b7    	movw	r1, #0x3b7
700a7ed6: f2c7 010b    	movt	r1, #0x700b
700a7eda: 466a         	mov	r2, sp
700a7edc: 6011         	str	r1, [r2]
700a7ede: f64f 7142    	movw	r1, #0xff42
700a7ee2: f2c7 010a    	movt	r1, #0x700a
700a7ee6: f240 221f    	movw	r2, #0x21f
700a7eea: f2c7 020b    	movt	r2, #0x700b
700a7eee: f240 137b    	movw	r3, #0x17b
700a7ef2: f001 f915    	bl	0x700a9120 <_DebugP_assert> @ imm = #0x122a
;     while(temp == TRUE)
700a7ef6: e7ff         	b	0x700a7ef8 <UART_lld_dmaDisableChannel+0x68> @ imm = #-0x2
700a7ef8: 9806         	ldr	r0, [sp, #0x18]
700a7efa: 2801         	cmp	r0, #0x1
700a7efc: d10f         	bne	0x700a7f1e <UART_lld_dmaDisableChannel+0x8e> @ imm = #0x1e
700a7efe: e7ff         	b	0x700a7f00 <UART_lld_dmaDisableChannel+0x70> @ imm = #-0x2
;                          Udma_chGetFqRingHandle(chHandle), &pDesc);
700a7f00: 9804         	ldr	r0, [sp, #0x10]
700a7f02: f001 facd    	bl	0x700a94a0 <Udma_chGetFqRingHandle> @ imm = #0x159a
700a7f06: a902         	add	r1, sp, #0x8
;         tempRetVal = Udma_ringFlushRaw(
700a7f08: f000 fb9a    	bl	0x700a8640 <Udma_ringFlushRaw> @ imm = #0x734
700a7f0c: 9001         	str	r0, [sp, #0x4]
;         if(UDMA_ETIMEOUT == tempRetVal)
700a7f0e: 9801         	ldr	r0, [sp, #0x4]
700a7f10: 3004         	adds	r0, #0x4
700a7f12: b918         	cbnz	r0, 0x700a7f1c <UART_lld_dmaDisableChannel+0x8c> @ imm = #0x6
700a7f14: e7ff         	b	0x700a7f16 <UART_lld_dmaDisableChannel+0x86> @ imm = #-0x2
700a7f16: 2000         	movs	r0, #0x0
;             temp = FALSE;
700a7f18: 9006         	str	r0, [sp, #0x18]
;         }
700a7f1a: e7ff         	b	0x700a7f1c <UART_lld_dmaDisableChannel+0x8c> @ imm = #-0x2
;     while(temp == TRUE)
700a7f1c: e7ec         	b	0x700a7ef8 <UART_lld_dmaDisableChannel+0x68> @ imm = #-0x28
;     return status;
700a7f1e: 9807         	ldr	r0, [sp, #0x1c]
700a7f20: b00a         	add	sp, #0x28
700a7f22: bd80         	pop	{r7, pc}
		...

700a7f30 <xQueueGiveFromISR>:
; {
700a7f30: b580         	push	{r7, lr}
700a7f32: b088         	sub	sp, #0x20
700a7f34: 9007         	str	r0, [sp, #0x1c]
700a7f36: 9106         	str	r1, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a7f38: 9807         	ldr	r0, [sp, #0x1c]
700a7f3a: 9003         	str	r0, [sp, #0xc]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a7f3c: f006 ef40    	blx	0x700aedc0 <HwiP_disable> @ imm = #0x6e80
700a7f40: 9004         	str	r0, [sp, #0x10]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a7f42: 9803         	ldr	r0, [sp, #0xc]
700a7f44: 6b80         	ldr	r0, [r0, #0x38]
700a7f46: 9002         	str	r0, [sp, #0x8]
;         if( uxMessagesWaiting < pxQueue->uxLength )
700a7f48: 9802         	ldr	r0, [sp, #0x8]
700a7f4a: 9903         	ldr	r1, [sp, #0xc]
700a7f4c: 6bc9         	ldr	r1, [r1, #0x3c]
700a7f4e: 4288         	cmp	r0, r1
700a7f50: d22f         	bhs	0x700a7fb2 <xQueueGiveFromISR+0x82> @ imm = #0x5e
700a7f52: e7ff         	b	0x700a7f54 <xQueueGiveFromISR+0x24> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
700a7f54: 9803         	ldr	r0, [sp, #0xc]
700a7f56: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a7f5a: f88d 0007    	strb.w	r0, [sp, #0x7]
;             pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
700a7f5e: 9802         	ldr	r0, [sp, #0x8]
700a7f60: 3001         	adds	r0, #0x1
700a7f62: 9903         	ldr	r1, [sp, #0xc]
700a7f64: 6388         	str	r0, [r1, #0x38]
;             if( cTxLock == queueUNLOCKED )
700a7f66: f99d 0007    	ldrsb.w	r0, [sp, #0x7]
700a7f6a: 3001         	adds	r0, #0x1
700a7f6c: b9b8         	cbnz	r0, 0x700a7f9e <xQueueGiveFromISR+0x6e> @ imm = #0x2e
700a7f6e: e7ff         	b	0x700a7f70 <xQueueGiveFromISR+0x40> @ imm = #-0x2
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a7f70: 9803         	ldr	r0, [sp, #0xc]
700a7f72: 6a40         	ldr	r0, [r0, #0x24]
700a7f74: b188         	cbz	r0, 0x700a7f9a <xQueueGiveFromISR+0x6a> @ imm = #0x22
700a7f76: e7ff         	b	0x700a7f78 <xQueueGiveFromISR+0x48> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a7f78: 9803         	ldr	r0, [sp, #0xc]
700a7f7a: 3024         	adds	r0, #0x24
700a7f7c: f7fd ffb8    	bl	0x700a5ef0 <xTaskRemoveFromEventList> @ imm = #-0x2090
700a7f80: b148         	cbz	r0, 0x700a7f96 <xQueueGiveFromISR+0x66> @ imm = #0x12
700a7f82: e7ff         	b	0x700a7f84 <xQueueGiveFromISR+0x54> @ imm = #-0x2
;                                 if( pxHigherPriorityTaskWoken != NULL )
700a7f84: 9806         	ldr	r0, [sp, #0x18]
700a7f86: b120         	cbz	r0, 0x700a7f92 <xQueueGiveFromISR+0x62> @ imm = #0x8
700a7f88: e7ff         	b	0x700a7f8a <xQueueGiveFromISR+0x5a> @ imm = #-0x2
;                                     *pxHigherPriorityTaskWoken = pdTRUE;
700a7f8a: 9906         	ldr	r1, [sp, #0x18]
700a7f8c: 2001         	movs	r0, #0x1
700a7f8e: 6008         	str	r0, [r1]
;                                 }
700a7f90: e000         	b	0x700a7f94 <xQueueGiveFromISR+0x64> @ imm = #0x0
700a7f92: e7ff         	b	0x700a7f94 <xQueueGiveFromISR+0x64> @ imm = #-0x2
;                             }
700a7f94: e000         	b	0x700a7f98 <xQueueGiveFromISR+0x68> @ imm = #0x0
700a7f96: e7ff         	b	0x700a7f98 <xQueueGiveFromISR+0x68> @ imm = #-0x2
;                         }
700a7f98: e000         	b	0x700a7f9c <xQueueGiveFromISR+0x6c> @ imm = #0x0
700a7f9a: e7ff         	b	0x700a7f9c <xQueueGiveFromISR+0x6c> @ imm = #-0x2
;             }
700a7f9c: e006         	b	0x700a7fac <xQueueGiveFromISR+0x7c> @ imm = #0xc
;                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
700a7f9e: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700a7fa2: 3001         	adds	r0, #0x1
700a7fa4: 9903         	ldr	r1, [sp, #0xc]
700a7fa6: f881 0045    	strb.w	r0, [r1, #0x45]
700a7faa: e7ff         	b	0x700a7fac <xQueueGiveFromISR+0x7c> @ imm = #-0x2
700a7fac: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a7fae: 9005         	str	r0, [sp, #0x14]
;         }
700a7fb0: e002         	b	0x700a7fb8 <xQueueGiveFromISR+0x88> @ imm = #0x4
700a7fb2: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
700a7fb4: 9005         	str	r0, [sp, #0x14]
700a7fb6: e7ff         	b	0x700a7fb8 <xQueueGiveFromISR+0x88> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a7fb8: 9804         	ldr	r0, [sp, #0x10]
700a7fba: f006 ef22    	blx	0x700aee00 <HwiP_restore> @ imm = #0x6e44
;     return xReturn;
700a7fbe: 9805         	ldr	r0, [sp, #0x14]
700a7fc0: b008         	add	sp, #0x20
700a7fc2: bd80         	pop	{r7, pc}
		...

700a7fd0 <xTimerGenericCommand>:
;     {
700a7fd0: b580         	push	{r7, lr}
700a7fd2: b08a         	sub	sp, #0x28
700a7fd4: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a7fd8: 9009         	str	r0, [sp, #0x24]
700a7fda: 9108         	str	r1, [sp, #0x20]
700a7fdc: 9207         	str	r2, [sp, #0x1c]
700a7fde: 9306         	str	r3, [sp, #0x18]
700a7fe0: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
700a7fe2: 9005         	str	r0, [sp, #0x14]
;         if( xTimerQueue != NULL )
700a7fe4: f640 50f8    	movw	r0, #0xdf8
700a7fe8: f2c7 000b    	movt	r0, #0x700b
700a7fec: 6800         	ldr	r0, [r0]
700a7fee: b3a8         	cbz	r0, 0x700a805c <xTimerGenericCommand+0x8c> @ imm = #0x6a
700a7ff0: e7ff         	b	0x700a7ff2 <xTimerGenericCommand+0x22> @ imm = #-0x2
;             xMessage.xMessageID = xCommandID;
700a7ff2: 9808         	ldr	r0, [sp, #0x20]
700a7ff4: 9001         	str	r0, [sp, #0x4]
;             xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
700a7ff6: 9807         	ldr	r0, [sp, #0x1c]
700a7ff8: 9002         	str	r0, [sp, #0x8]
;             xMessage.u.xTimerParameters.pxTimer = xTimer;
700a7ffa: 9809         	ldr	r0, [sp, #0x24]
700a7ffc: 9003         	str	r0, [sp, #0xc]
;             if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
700a7ffe: 9808         	ldr	r0, [sp, #0x20]
700a8000: 2805         	cmp	r0, #0x5
700a8002: dc1e         	bgt	0x700a8042 <xTimerGenericCommand+0x72> @ imm = #0x3c
700a8004: e7ff         	b	0x700a8006 <xTimerGenericCommand+0x36> @ imm = #-0x2
;                 if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
700a8006: f004 fbeb    	bl	0x700ac7e0 <xTaskGetSchedulerState> @ imm = #0x47d6
700a800a: 2802         	cmp	r0, #0x2
700a800c: d10c         	bne	0x700a8028 <xTimerGenericCommand+0x58> @ imm = #0x18
700a800e: e7ff         	b	0x700a8010 <xTimerGenericCommand+0x40> @ imm = #-0x2
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
700a8010: f640 50f8    	movw	r0, #0xdf8
700a8014: f2c7 000b    	movt	r0, #0x700b
700a8018: 6800         	ldr	r0, [r0]
700a801a: 9a0c         	ldr	r2, [sp, #0x30]
700a801c: a901         	add	r1, sp, #0x4
700a801e: 2300         	movs	r3, #0x0
700a8020: f7f9 fc6e    	bl	0x700a1900 <xQueueGenericSend> @ imm = #-0x6724
700a8024: 9005         	str	r0, [sp, #0x14]
;                 }
700a8026: e00b         	b	0x700a8040 <xTimerGenericCommand+0x70> @ imm = #0x16
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
700a8028: f640 50f8    	movw	r0, #0xdf8
700a802c: f2c7 000b    	movt	r0, #0x700b
700a8030: 6800         	ldr	r0, [r0]
700a8032: a901         	add	r1, sp, #0x4
700a8034: 2300         	movs	r3, #0x0
700a8036: 461a         	mov	r2, r3
700a8038: f7f9 fc62    	bl	0x700a1900 <xQueueGenericSend> @ imm = #-0x673c
700a803c: 9005         	str	r0, [sp, #0x14]
700a803e: e7ff         	b	0x700a8040 <xTimerGenericCommand+0x70> @ imm = #-0x2
;             }
700a8040: e00b         	b	0x700a805a <xTimerGenericCommand+0x8a> @ imm = #0x16
;                 xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
700a8042: f640 50f8    	movw	r0, #0xdf8
700a8046: f2c7 000b    	movt	r0, #0x700b
700a804a: 6800         	ldr	r0, [r0]
700a804c: 9a06         	ldr	r2, [sp, #0x18]
700a804e: a901         	add	r1, sp, #0x4
700a8050: 2300         	movs	r3, #0x0
700a8052: f7fe ff3d    	bl	0x700a6ed0 <xQueueGenericSendFromISR> @ imm = #-0x1186
700a8056: 9005         	str	r0, [sp, #0x14]
700a8058: e7ff         	b	0x700a805a <xTimerGenericCommand+0x8a> @ imm = #-0x2
;         }
700a805a: e000         	b	0x700a805e <xTimerGenericCommand+0x8e> @ imm = #0x0
700a805c: e7ff         	b	0x700a805e <xTimerGenericCommand+0x8e> @ imm = #-0x2
;         return xReturn;
700a805e: 9805         	ldr	r0, [sp, #0x14]
700a8060: b00a         	add	sp, #0x28
700a8062: bd80         	pop	{r7, pc}
		...

700a8070 <SOC_moduleClockEnable>:
; {
700a8070: b580         	push	{r7, lr}
700a8072: b088         	sub	sp, #0x20
700a8074: 9007         	str	r0, [sp, #0x1c]
700a8076: 9106         	str	r1, [sp, #0x18]
700a8078: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700a807a: 9005         	str	r0, [sp, #0x14]
700a807c: 2102         	movs	r1, #0x2
;     uint32_t moduleState = TISCI_MSG_VALUE_DEVICE_HW_STATE_TRANS;
700a807e: 9104         	str	r1, [sp, #0x10]
;     uint32_t resetState = 0U;
700a8080: 9003         	str	r0, [sp, #0xc]
;     uint32_t contextLossState = 0U;
700a8082: 9002         	str	r0, [sp, #0x8]
;     status = Sciclient_pmGetModuleState(moduleId,
700a8084: 9807         	ldr	r0, [sp, #0x1c]
700a8086: 466a         	mov	r2, sp
700a8088: f04f 31ff    	mov.w	r1, #0xffffffff
700a808c: 6011         	str	r1, [r2]
700a808e: a904         	add	r1, sp, #0x10
700a8090: aa03         	add	r2, sp, #0xc
700a8092: ab02         	add	r3, sp, #0x8
700a8094: f000 f96c    	bl	0x700a8370 <Sciclient_pmGetModuleState> @ imm = #0x2d8
700a8098: 9005         	str	r0, [sp, #0x14]
;     if(status == SystemP_SUCCESS)
700a809a: 9805         	ldr	r0, [sp, #0x14]
700a809c: bb70         	cbnz	r0, 0x700a80fc <SOC_moduleClockEnable+0x8c> @ imm = #0x5c
700a809e: e7ff         	b	0x700a80a0 <SOC_moduleClockEnable+0x30> @ imm = #-0x2
;         if(moduleState == TISCI_MSG_VALUE_DEVICE_HW_STATE_OFF && (enable == 1))
700a80a0: 9804         	ldr	r0, [sp, #0x10]
700a80a2: b9c8         	cbnz	r0, 0x700a80d8 <SOC_moduleClockEnable+0x68> @ imm = #0x32
700a80a4: e7ff         	b	0x700a80a6 <SOC_moduleClockEnable+0x36> @ imm = #-0x2
700a80a6: 9806         	ldr	r0, [sp, #0x18]
700a80a8: 2801         	cmp	r0, #0x1
700a80aa: d115         	bne	0x700a80d8 <SOC_moduleClockEnable+0x68> @ imm = #0x2a
700a80ac: e7ff         	b	0x700a80ae <SOC_moduleClockEnable+0x3e> @ imm = #-0x2
;             status = Sciclient_pmSetModuleState(moduleId,
700a80ae: 9807         	ldr	r0, [sp, #0x1c]
700a80b0: 2102         	movs	r1, #0x2
700a80b2: f240 2202    	movw	r2, #0x202
700a80b6: f04f 33ff    	mov.w	r3, #0xffffffff
700a80ba: f000 f9e9    	bl	0x700a8490 <Sciclient_pmSetModuleState> @ imm = #0x3d2
700a80be: 9005         	str	r0, [sp, #0x14]
;             if (status == SystemP_SUCCESS)
700a80c0: 9805         	ldr	r0, [sp, #0x14]
700a80c2: b940         	cbnz	r0, 0x700a80d6 <SOC_moduleClockEnable+0x66> @ imm = #0x10
700a80c4: e7ff         	b	0x700a80c6 <SOC_moduleClockEnable+0x56> @ imm = #-0x2
;                 status = Sciclient_pmSetModuleRst(moduleId,
700a80c6: 9807         	ldr	r0, [sp, #0x1c]
700a80c8: 2100         	movs	r1, #0x0
700a80ca: f04f 32ff    	mov.w	r2, #0xffffffff
700a80ce: f002 fc17    	bl	0x700aa900 <Sciclient_pmSetModuleRst> @ imm = #0x282e
700a80d2: 9005         	str	r0, [sp, #0x14]
;             }
700a80d4: e7ff         	b	0x700a80d6 <SOC_moduleClockEnable+0x66> @ imm = #-0x2
;         }
700a80d6: e010         	b	0x700a80fa <SOC_moduleClockEnable+0x8a> @ imm = #0x20
;         if(moduleState == TISCI_MSG_VALUE_DEVICE_HW_STATE_ON && (enable == 0))
700a80d8: 9804         	ldr	r0, [sp, #0x10]
700a80da: 2801         	cmp	r0, #0x1
700a80dc: d10c         	bne	0x700a80f8 <SOC_moduleClockEnable+0x88> @ imm = #0x18
700a80de: e7ff         	b	0x700a80e0 <SOC_moduleClockEnable+0x70> @ imm = #-0x2
700a80e0: 9806         	ldr	r0, [sp, #0x18]
700a80e2: b948         	cbnz	r0, 0x700a80f8 <SOC_moduleClockEnable+0x88> @ imm = #0x12
700a80e4: e7ff         	b	0x700a80e6 <SOC_moduleClockEnable+0x76> @ imm = #-0x2
;             status = Sciclient_pmSetModuleState(moduleId,
700a80e6: 9807         	ldr	r0, [sp, #0x1c]
700a80e8: 2100         	movs	r1, #0x0
700a80ea: 2202         	movs	r2, #0x2
700a80ec: f04f 33ff    	mov.w	r3, #0xffffffff
700a80f0: f000 f9ce    	bl	0x700a8490 <Sciclient_pmSetModuleState> @ imm = #0x39c
700a80f4: 9005         	str	r0, [sp, #0x14]
;         }
700a80f6: e7ff         	b	0x700a80f8 <SOC_moduleClockEnable+0x88> @ imm = #-0x2
700a80f8: e7ff         	b	0x700a80fa <SOC_moduleClockEnable+0x8a> @ imm = #-0x2
;     }
700a80fa: e7ff         	b	0x700a80fc <SOC_moduleClockEnable+0x8c> @ imm = #-0x2
;     return status;
700a80fc: 9805         	ldr	r0, [sp, #0x14]
700a80fe: b008         	add	sp, #0x20
700a8100: bd80         	pop	{r7, pc}
		...
700a810e: 0000         	movs	r0, r0

700a8110 <Sciclient_rmPsPop>:
; {
700a8110: b084         	sub	sp, #0x10
700a8112: 9003         	str	r0, [sp, #0xc]
700a8114: 9102         	str	r1, [sp, #0x8]
700a8116: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a8118: 9001         	str	r0, [sp, #0x4]
;     if ((gPstack.psp > (0u)) && (n != NULL) && (if_idx != NULL)) {
700a811a: f241 0058    	movw	r0, #0x1058
700a811e: f2c7 0008    	movt	r0, #0x7008
700a8122: 8c80         	ldrh	r0, [r0, #0x24]
700a8124: b3b0         	cbz	r0, 0x700a8194 <Sciclient_rmPsPop+0x84> @ imm = #0x6c
700a8126: e7ff         	b	0x700a8128 <Sciclient_rmPsPop+0x18> @ imm = #-0x2
700a8128: 9803         	ldr	r0, [sp, #0xc]
700a812a: b398         	cbz	r0, 0x700a8194 <Sciclient_rmPsPop+0x84> @ imm = #0x66
700a812c: e7ff         	b	0x700a812e <Sciclient_rmPsPop+0x1e> @ imm = #-0x2
700a812e: 9802         	ldr	r0, [sp, #0x8]
700a8130: b380         	cbz	r0, 0x700a8194 <Sciclient_rmPsPop+0x84> @ imm = #0x60
700a8132: e7ff         	b	0x700a8134 <Sciclient_rmPsPop+0x24> @ imm = #-0x2
;         gPstack.psp--;
700a8134: f241 0158    	movw	r1, #0x1058
700a8138: f2c7 0108    	movt	r1, #0x7008
700a813c: 9100         	str	r1, [sp]
700a813e: 8c88         	ldrh	r0, [r1, #0x24]
700a8140: 3801         	subs	r0, #0x1
700a8142: 8488         	strh	r0, [r1, #0x24]
;         *n = gPstack.ps[gPstack.psp].p_n;
700a8144: 8c88         	ldrh	r0, [r1, #0x24]
700a8146: eb00 0040    	add.w	r0, r0, r0, lsl #1
700a814a: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700a814e: 9a03         	ldr	r2, [sp, #0xc]
700a8150: 6010         	str	r0, [r2]
;         *if_idx = gPstack.ps[gPstack.psp].if_idx;
700a8152: 8c88         	ldrh	r0, [r1, #0x24]
700a8154: eb00 0040    	add.w	r0, r0, r0, lsl #1
700a8158: eb01 0080    	add.w	r0, r1, r0, lsl #2
700a815c: 8880         	ldrh	r0, [r0, #0x4]
700a815e: 9a02         	ldr	r2, [sp, #0x8]
700a8160: 8010         	strh	r0, [r2]
;         gPstack.ps[gPstack.psp].p_n = NULL;
700a8162: 8c88         	ldrh	r0, [r1, #0x24]
700a8164: eb00 0240    	add.w	r2, r0, r0, lsl #1
700a8168: 2000         	movs	r0, #0x0
700a816a: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gPstack.ps[gPstack.psp].if_idx = 0;
700a816e: 8c8a         	ldrh	r2, [r1, #0x24]
700a8170: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a8174: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a8178: 8090         	strh	r0, [r2, #0x4]
;         gPstack.ps[gPstack.psp].inp = 0;
700a817a: 8c8a         	ldrh	r2, [r1, #0x24]
700a817c: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a8180: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a8184: 80d0         	strh	r0, [r2, #0x6]
;         gPstack.ps[gPstack.psp].outp = 0;
700a8186: 8c8a         	ldrh	r2, [r1, #0x24]
700a8188: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a818c: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a8190: 8108         	strh	r0, [r1, #0x8]
;     } else {
700a8192: e003         	b	0x700a819c <Sciclient_rmPsPop+0x8c> @ imm = #0x6
700a8194: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a8198: 9001         	str	r0, [sp, #0x4]
700a819a: e7ff         	b	0x700a819c <Sciclient_rmPsPop+0x8c> @ imm = #-0x2
;     return r;
700a819c: 9801         	ldr	r0, [sp, #0x4]
700a819e: b004         	add	sp, #0x10
700a81a0: 4770         	bx	lr
		...
700a81ae: 0000         	movs	r0, r0

700a81b0 <_DebugP_logZone>:
; {
700a81b0: b082         	sub	sp, #0x8
700a81b2: b580         	push	{r7, lr}
700a81b4: b086         	sub	sp, #0x18
700a81b6: 9309         	str	r3, [sp, #0x24]
700a81b8: 9208         	str	r2, [sp, #0x20]
700a81ba: 9005         	str	r0, [sp, #0x14]
700a81bc: 9104         	str	r1, [sp, #0x10]
;     if((HwiP_inISR()) == 0U )
700a81be: f006 fb1f    	bl	0x700ae800 <HwiP_inISR> @ imm = #0x663e
700a81c2: bbc8         	cbnz	r0, 0x700a8238 <_DebugP_logZone+0x88> @ imm = #0x72
700a81c4: e7ff         	b	0x700a81c6 <_DebugP_logZone+0x16> @ imm = #-0x2
;         if(gDebugLogIsInitDone == 0U)
700a81c6: f640 5080    	movw	r0, #0xd80
700a81ca: f2c7 000b    	movt	r0, #0x700b
700a81ce: 6800         	ldr	r0, [r0]
700a81d0: b9a0         	cbnz	r0, 0x700a81fc <_DebugP_logZone+0x4c> @ imm = #0x28
700a81d2: e7ff         	b	0x700a81d4 <_DebugP_logZone+0x24> @ imm = #-0x2
;             status = SemaphoreP_constructMutex(&gDebugLogLockObj);
700a81d4: f644 2018    	movw	r0, #0x4a18
700a81d8: f2c7 0008    	movt	r0, #0x7008
700a81dc: f001 fc38    	bl	0x700a9a50 <SemaphoreP_constructMutex> @ imm = #0x1870
700a81e0: 9003         	str	r0, [sp, #0xc]
;             DebugP_assertNoLog(status == SystemP_SUCCESS);
700a81e2: 9803         	ldr	r0, [sp, #0xc]
700a81e4: fab0 f080    	clz	r0, r0
700a81e8: 0940         	lsrs	r0, r0, #0x5
700a81ea: f007 faa9    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x7552
;             gDebugLogIsInitDone = 1;
700a81ee: f640 5180    	movw	r1, #0xd80
700a81f2: f2c7 010b    	movt	r1, #0x700b
700a81f6: 2001         	movs	r0, #0x1
700a81f8: 6008         	str	r0, [r1]
;         }
700a81fa: e7ff         	b	0x700a81fc <_DebugP_logZone+0x4c> @ imm = #-0x2
;         if( ( gDebugLogZone & logZone ) == logZone )
700a81fc: f640 5084    	movw	r0, #0xd84
700a8200: f2c7 000b    	movt	r0, #0x700b
700a8204: 6800         	ldr	r0, [r0]
700a8206: 9905         	ldr	r1, [sp, #0x14]
700a8208: 4008         	ands	r0, r1
700a820a: 4288         	cmp	r0, r1
700a820c: d113         	bne	0x700a8236 <_DebugP_logZone+0x86> @ imm = #0x26
700a820e: e7ff         	b	0x700a8210 <_DebugP_logZone+0x60> @ imm = #-0x2
;             SemaphoreP_pend(&gDebugLogLockObj, SystemP_WAIT_FOREVER);
700a8210: f644 2018    	movw	r0, #0x4a18
700a8214: f2c7 0008    	movt	r0, #0x7008
700a8218: 9001         	str	r0, [sp, #0x4]
700a821a: f04f 31ff    	mov.w	r1, #0xffffffff
700a821e: f000 fd27    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0xa4e
700a8222: a808         	add	r0, sp, #0x20
;             va_start(va, format);
700a8224: 9002         	str	r0, [sp, #0x8]
;             vprintf_(format, va);
700a8226: 9804         	ldr	r0, [sp, #0x10]
700a8228: 9902         	ldr	r1, [sp, #0x8]
700a822a: f005 f8d1    	bl	0x700ad3d0 <vprintf_>   @ imm = #0x51a2
;             SemaphoreP_post(&gDebugLogLockObj);
700a822e: 9801         	ldr	r0, [sp, #0x4]
700a8230: f002 f86e    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x20dc
;         }
700a8234: e7ff         	b	0x700a8236 <_DebugP_logZone+0x86> @ imm = #-0x2
;     }
700a8236: e7ff         	b	0x700a8238 <_DebugP_logZone+0x88> @ imm = #-0x2
; }
700a8238: b006         	add	sp, #0x18
700a823a: e8bd 4080    	pop.w	{r7, lr}
700a823e: b002         	add	sp, #0x8
700a8240: 4770         	bx	lr
		...
700a824e: 0000         	movs	r0, r0

700a8250 <Udma_rmFreeMappedRing>:
; {
700a8250: b580         	push	{r7, lr}
700a8252: b08e         	sub	sp, #0x38
700a8254: 900d         	str	r0, [sp, #0x34]
700a8256: 910c         	str	r1, [sp, #0x30]
700a8258: 920b         	str	r2, [sp, #0x2c]
700a825a: 930a         	str	r3, [sp, #0x28]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a825c: 980c         	ldr	r0, [sp, #0x30]
700a825e: f500 70ea    	add.w	r0, r0, #0x1d4
700a8262: 9005         	str	r0, [sp, #0x14]
;     retVal = Udma_getMappedChRingAttributes(drvHandle, mappedRingGrp, mappedChNum, &chAttr);
700a8264: 980c         	ldr	r0, [sp, #0x30]
700a8266: 990b         	ldr	r1, [sp, #0x2c]
700a8268: 9a0a         	ldr	r2, [sp, #0x28]
700a826a: ab02         	add	r3, sp, #0x8
700a826c: f7fd ffb0    	bl	0x700a61d0 <Udma_getMappedChRingAttributes> @ imm = #-0x20a0
700a8270: 9001         	str	r0, [sp, #0x4]
;     if(ringNum != chAttr.defaultRing)
700a8272: 980d         	ldr	r0, [sp, #0x34]
700a8274: 9902         	ldr	r1, [sp, #0x8]
700a8276: 4288         	cmp	r0, r1
700a8278: d02f         	beq	0x700a82da <Udma_rmFreeMappedRing+0x8a> @ imm = #0x5e
700a827a: e7ff         	b	0x700a827c <Udma_rmFreeMappedRing+0x2c> @ imm = #-0x2
;         SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a827c: 980c         	ldr	r0, [sp, #0x30]
700a827e: f500 609f    	add.w	r0, r0, #0x4f8
700a8282: f04f 31ff    	mov.w	r1, #0xffffffff
700a8286: f000 fcf3    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x9e6
;         i = ringNum - rmInitPrms->startMappedRing[mappedRingGrp];
700a828a: 980d         	ldr	r0, [sp, #0x34]
700a828c: 9905         	ldr	r1, [sp, #0x14]
700a828e: 9a0b         	ldr	r2, [sp, #0x2c]
700a8290: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a8294: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a8298: 1a40         	subs	r0, r0, r1
700a829a: 9009         	str	r0, [sp, #0x24]
;         offset = i >> 5U;
700a829c: 9809         	ldr	r0, [sp, #0x24]
700a829e: 0940         	lsrs	r0, r0, #0x5
700a82a0: 9008         	str	r0, [sp, #0x20]
;         bitPos = i - (offset << 5U);
700a82a2: 9809         	ldr	r0, [sp, #0x24]
700a82a4: 9908         	ldr	r1, [sp, #0x20]
700a82a6: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a82aa: 9007         	str	r0, [sp, #0x1c]
;         bitMask = (uint32_t) 1U << bitPos;
700a82ac: 9907         	ldr	r1, [sp, #0x1c]
700a82ae: 2001         	movs	r0, #0x1
700a82b0: 4088         	lsls	r0, r1
700a82b2: 9006         	str	r0, [sp, #0x18]
;         drvHandle->mappedRingFlag[mappedRingGrp][offset] |= bitMask;
700a82b4: 9a06         	ldr	r2, [sp, #0x18]
700a82b6: 980c         	ldr	r0, [sp, #0x30]
700a82b8: 990b         	ldr	r1, [sp, #0x2c]
700a82ba: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a82be: 9908         	ldr	r1, [sp, #0x20]
700a82c0: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a82c4: f8d1 0344    	ldr.w	r0, [r1, #0x344]
700a82c8: 4310         	orrs	r0, r2
700a82ca: f8c1 0344    	str.w	r0, [r1, #0x344]
;         SemaphoreP_post(&drvHandle->rmLockObj);
700a82ce: 980c         	ldr	r0, [sp, #0x30]
700a82d0: f500 609f    	add.w	r0, r0, #0x4f8
700a82d4: f002 f81c    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x2038
;     }
700a82d8: e7ff         	b	0x700a82da <Udma_rmFreeMappedRing+0x8a> @ imm = #-0x2
;     return;
700a82da: b00e         	add	sp, #0x38
700a82dc: bd80         	pop	{r7, pc}
700a82de: 0000         	movs	r0, r0

700a82e0 <prvInitialiseTaskLists>:
; static void prvInitialiseTaskLists(void) {
700a82e0: b580         	push	{r7, lr}
700a82e2: b084         	sub	sp, #0x10
700a82e4: 2000         	movs	r0, #0x0
;   for (uxPriority = (UBaseType_t)0U;
700a82e6: 9003         	str	r0, [sp, #0xc]
700a82e8: e7ff         	b	0x700a82ea <prvInitialiseTaskLists+0xa> @ imm = #-0x2
;        uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
700a82ea: 9803         	ldr	r0, [sp, #0xc]
;   for (uxPriority = (UBaseType_t)0U;
700a82ec: 281f         	cmp	r0, #0x1f
700a82ee: d810         	bhi	0x700a8312 <prvInitialiseTaskLists+0x32> @ imm = #0x20
700a82f0: e7ff         	b	0x700a82f2 <prvInitialiseTaskLists+0x12> @ imm = #-0x2
;     vListInitialise(&(pxReadyTasksLists[uxPriority]));
700a82f2: 9803         	ldr	r0, [sp, #0xc]
700a82f4: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a82f8: f244 40f8    	movw	r0, #0x44f8
700a82fc: f2c7 0008    	movt	r0, #0x7008
700a8300: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a8304: f004 fddc    	bl	0x700acec0 <vListInitialise> @ imm = #0x4bb8
;   }
700a8308: e7ff         	b	0x700a830a <prvInitialiseTaskLists+0x2a> @ imm = #-0x2
;        uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
700a830a: 9803         	ldr	r0, [sp, #0xc]
700a830c: 3001         	adds	r0, #0x1
700a830e: 9003         	str	r0, [sp, #0xc]
;   for (uxPriority = (UBaseType_t)0U;
700a8310: e7eb         	b	0x700a82ea <prvInitialiseTaskLists+0xa> @ imm = #-0x2a
;   vListInitialise(&xDelayedTaskList1);
700a8312: f644 5038    	movw	r0, #0x4d38
700a8316: f2c7 0008    	movt	r0, #0x7008
700a831a: 9001         	str	r0, [sp, #0x4]
700a831c: f004 fdd0    	bl	0x700acec0 <vListInitialise> @ imm = #0x4ba0
;   vListInitialise(&xDelayedTaskList2);
700a8320: f644 504c    	movw	r0, #0x4d4c
700a8324: f2c7 0008    	movt	r0, #0x7008
700a8328: 9002         	str	r0, [sp, #0x8]
700a832a: f004 fdc9    	bl	0x700acec0 <vListInitialise> @ imm = #0x4b92
;   vListInitialise(&xPendingReadyList);
700a832e: f644 5060    	movw	r0, #0x4d60
700a8332: f2c7 0008    	movt	r0, #0x7008
700a8336: f004 fdc3    	bl	0x700acec0 <vListInitialise> @ imm = #0x4b86
;     vListInitialise(&xTasksWaitingTermination);
700a833a: f644 5088    	movw	r0, #0x4d88
700a833e: f2c7 0008    	movt	r0, #0x7008
700a8342: f004 fdbd    	bl	0x700acec0 <vListInitialise> @ imm = #0x4b7a
;     vListInitialise(&xSuspendedTaskList);
700a8346: f644 5074    	movw	r0, #0x4d74
700a834a: f2c7 0008    	movt	r0, #0x7008
700a834e: f004 fdb7    	bl	0x700acec0 <vListInitialise> @ imm = #0x4b6e
700a8352: 9901         	ldr	r1, [sp, #0x4]
700a8354: 9802         	ldr	r0, [sp, #0x8]
;   pxDelayedTaskList = &xDelayedTaskList1;
700a8356: f644 52b0    	movw	r2, #0x4db0
700a835a: f2c7 0208    	movt	r2, #0x7008
700a835e: 6011         	str	r1, [r2]
;   pxOverflowDelayedTaskList = &xDelayedTaskList2;
700a8360: f644 51b4    	movw	r1, #0x4db4
700a8364: f2c7 0108    	movt	r1, #0x7008
700a8368: 6008         	str	r0, [r1]
; }
700a836a: b004         	add	sp, #0x10
700a836c: bd80         	pop	{r7, pc}
700a836e: 0000         	movs	r0, r0

700a8370 <Sciclient_pmGetModuleState>:
; {
700a8370: b580         	push	{r7, lr}
700a8372: b096         	sub	sp, #0x58
700a8374: f8dd c060    	ldr.w	r12, [sp, #0x60]
700a8378: 9015         	str	r0, [sp, #0x54]
700a837a: 9114         	str	r1, [sp, #0x50]
700a837c: 9213         	str	r2, [sp, #0x4c]
700a837e: 9312         	str	r3, [sp, #0x48]
700a8380: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a8382: 9011         	str	r0, [sp, #0x44]
;     struct tisci_msg_get_device_resp response = {{0}};
700a8384: f8ad 0034    	strh.w	r0, [sp, #0x34]
700a8388: 900c         	str	r0, [sp, #0x30]
700a838a: 900b         	str	r0, [sp, #0x2c]
700a838c: 900a         	str	r0, [sp, #0x28]
700a838e: 9009         	str	r0, [sp, #0x24]
;     request.id = (uint32_t) moduleId;
700a8390: 9915         	ldr	r1, [sp, #0x54]
700a8392: 9110         	str	r1, [sp, #0x40]
700a8394: f240 2101    	movw	r1, #0x201
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_DEVICE;
700a8398: f8ad 1010    	strh.w	r1, [sp, #0x10]
700a839c: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a839e: 9105         	str	r1, [sp, #0x14]
700a83a0: a90e         	add	r1, sp, #0x38
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a83a2: 9106         	str	r1, [sp, #0x18]
700a83a4: 210c         	movs	r1, #0xc
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a83a6: 9107         	str	r1, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a83a8: 9918         	ldr	r1, [sp, #0x60]
700a83aa: 9108         	str	r1, [sp, #0x20]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a83ac: 9001         	str	r0, [sp, #0x4]
700a83ae: a809         	add	r0, sp, #0x24
;     respParam.pRespPayload    = (uint8_t *) &response;
700a83b0: 9002         	str	r0, [sp, #0x8]
700a83b2: 2012         	movs	r0, #0x12
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a83b4: 9003         	str	r0, [sp, #0xc]
700a83b6: a804         	add	r0, sp, #0x10
700a83b8: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a83ba: f7f3 fe31    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xc39e
700a83be: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a83c0: 9811         	ldr	r0, [sp, #0x44]
700a83c2: b930         	cbnz	r0, 0x700a83d2 <Sciclient_pmGetModuleState+0x62> @ imm = #0xc
700a83c4: e7ff         	b	0x700a83c6 <Sciclient_pmGetModuleState+0x56> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a83c6: 9801         	ldr	r0, [sp, #0x4]
700a83c8: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a83cc: 2802         	cmp	r0, #0x2
700a83ce: d004         	beq	0x700a83da <Sciclient_pmGetModuleState+0x6a> @ imm = #0x8
700a83d0: e7ff         	b	0x700a83d2 <Sciclient_pmGetModuleState+0x62> @ imm = #-0x2
700a83d2: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a83d6: 9011         	str	r0, [sp, #0x44]
;     }
700a83d8: e7ff         	b	0x700a83da <Sciclient_pmGetModuleState+0x6a> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a83da: 9811         	ldr	r0, [sp, #0x44]
700a83dc: b958         	cbnz	r0, 0x700a83f6 <Sciclient_pmGetModuleState+0x86> @ imm = #0x16
700a83de: e7ff         	b	0x700a83e0 <Sciclient_pmGetModuleState+0x70> @ imm = #-0x2
;         *moduleState = (uint32_t) response.current_state;
700a83e0: f89d 0035    	ldrb.w	r0, [sp, #0x35]
700a83e4: 9914         	ldr	r1, [sp, #0x50]
700a83e6: 6008         	str	r0, [r1]
;         *resetState = (uint32_t) response.resets;
700a83e8: 980c         	ldr	r0, [sp, #0x30]
700a83ea: 9913         	ldr	r1, [sp, #0x4c]
700a83ec: 6008         	str	r0, [r1]
;         *contextLossState = (uint32_t) response.context_loss_count;
700a83ee: 980b         	ldr	r0, [sp, #0x2c]
700a83f0: 9912         	ldr	r1, [sp, #0x48]
700a83f2: 6008         	str	r0, [r1]
;     }
700a83f4: e7ff         	b	0x700a83f6 <Sciclient_pmGetModuleState+0x86> @ imm = #-0x2
;     return retVal;
700a83f6: 9811         	ldr	r0, [sp, #0x44]
700a83f8: b016         	add	sp, #0x58
700a83fa: bd80         	pop	{r7, pc}
700a83fc: 0000         	movs	r0, r0
700a83fe: 0000         	movs	r0, r0

700a8400 <Sciclient_pmModuleClkRequest>:
; {
700a8400: b580         	push	{r7, lr}
700a8402: b092         	sub	sp, #0x48
700a8404: f8dd c050    	ldr.w	r12, [sp, #0x50]
700a8408: 9011         	str	r0, [sp, #0x44]
700a840a: 9110         	str	r1, [sp, #0x40]
700a840c: 920f         	str	r2, [sp, #0x3c]
700a840e: 930e         	str	r3, [sp, #0x38]
700a8410: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a8412: 900d         	str	r0, [sp, #0x34]
;     request.device = (uint32_t) moduleId;
700a8414: 9811         	ldr	r0, [sp, #0x44]
700a8416: 900a         	str	r0, [sp, #0x28]
;     if(clockId > (uint32_t)(255U))
700a8418: 9810         	ldr	r0, [sp, #0x40]
700a841a: f5b0 7f80    	cmp.w	r0, #0x100
700a841e: d307         	blo	0x700a8430 <Sciclient_pmModuleClkRequest+0x30> @ imm = #0xe
700a8420: e7ff         	b	0x700a8422 <Sciclient_pmModuleClkRequest+0x22> @ imm = #-0x2
700a8422: 20ff         	movs	r0, #0xff
;         request.clk = (uint8_t)(255U);
700a8424: f88d 002c    	strb.w	r0, [sp, #0x2c]
;         request.clk32 = clockId;
700a8428: 9810         	ldr	r0, [sp, #0x40]
700a842a: f8cd 002e    	str.w	r0, [sp, #0x2e]
;     }
700a842e: e003         	b	0x700a8438 <Sciclient_pmModuleClkRequest+0x38> @ imm = #0x6
;         request.clk    = (uint8_t)clockId;
700a8430: 9810         	ldr	r0, [sp, #0x40]
700a8432: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a8436: e7ff         	b	0x700a8438 <Sciclient_pmModuleClkRequest+0x38> @ imm = #-0x2
;     request.state  = (uint8_t) state;
700a8438: 980f         	ldr	r0, [sp, #0x3c]
700a843a: f88d 002d    	strb.w	r0, [sp, #0x2d]
700a843e: f44f 7080    	mov.w	r0, #0x100
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_CLOCK;
700a8442: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP | additionalFlag;
700a8446: 980e         	ldr	r0, [sp, #0x38]
700a8448: f040 0002    	orr	r0, r0, #0x2
700a844c: 9004         	str	r0, [sp, #0x10]
700a844e: a808         	add	r0, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a8450: 9005         	str	r0, [sp, #0x14]
700a8452: 2012         	movs	r0, #0x12
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a8454: 9006         	str	r0, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a8456: 9814         	ldr	r0, [sp, #0x50]
700a8458: 9007         	str	r0, [sp, #0x1c]
700a845a: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a845c: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a845e: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700a8460: 9002         	str	r0, [sp, #0x8]
700a8462: a803         	add	r0, sp, #0xc
700a8464: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a8466: f7f3 fddb    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xc44a
700a846a: 900d         	str	r0, [sp, #0x34]
;     if((retVal != SystemP_SUCCESS) ||
700a846c: 980d         	ldr	r0, [sp, #0x34]
700a846e: b930         	cbnz	r0, 0x700a847e <Sciclient_pmModuleClkRequest+0x7e> @ imm = #0xc
700a8470: e7ff         	b	0x700a8472 <Sciclient_pmModuleClkRequest+0x72> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a8472: 9800         	ldr	r0, [sp]
700a8474: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a8478: 2802         	cmp	r0, #0x2
700a847a: d004         	beq	0x700a8486 <Sciclient_pmModuleClkRequest+0x86> @ imm = #0x8
700a847c: e7ff         	b	0x700a847e <Sciclient_pmModuleClkRequest+0x7e> @ imm = #-0x2
700a847e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a8482: 900d         	str	r0, [sp, #0x34]
;     }
700a8484: e7ff         	b	0x700a8486 <Sciclient_pmModuleClkRequest+0x86> @ imm = #-0x2
;     return retVal;
700a8486: 980d         	ldr	r0, [sp, #0x34]
700a8488: b012         	add	sp, #0x48
700a848a: bd80         	pop	{r7, pc}
700a848c: 0000         	movs	r0, r0
700a848e: 0000         	movs	r0, r0

700a8490 <Sciclient_pmSetModuleState>:
; {
700a8490: b580         	push	{r7, lr}
700a8492: b092         	sub	sp, #0x48
700a8494: 9011         	str	r0, [sp, #0x44]
700a8496: 9110         	str	r1, [sp, #0x40]
700a8498: 920f         	str	r2, [sp, #0x3c]
700a849a: 930e         	str	r3, [sp, #0x38]
700a849c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a849e: 900d         	str	r0, [sp, #0x34]
;     request.id       = (uint32_t) moduleId;
700a84a0: 9911         	ldr	r1, [sp, #0x44]
700a84a2: 910a         	str	r1, [sp, #0x28]
;     request.reserved = (uint32_t) 0;
700a84a4: 900b         	str	r0, [sp, #0x2c]
;     request.state    = (uint8_t) state;
700a84a6: 9910         	ldr	r1, [sp, #0x40]
700a84a8: f88d 1030    	strb.w	r1, [sp, #0x30]
700a84ac: f44f 7100    	mov.w	r1, #0x200
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_DEVICE;
700a84b0: f8ad 100c    	strh.w	r1, [sp, #0xc]
;     reqParam.flags          = (uint32_t) reqFlag;
700a84b4: 990f         	ldr	r1, [sp, #0x3c]
700a84b6: 9104         	str	r1, [sp, #0x10]
700a84b8: a908         	add	r1, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a84ba: 9105         	str	r1, [sp, #0x14]
700a84bc: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a84be: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a84c0: 990e         	ldr	r1, [sp, #0x38]
700a84c2: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a84c4: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a84c6: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700a84c8: 9002         	str	r0, [sp, #0x8]
;     if (((reqFlag & TISCI_MSG_FLAG_AOP) != TISCI_MSG_FLAG_AOP)&&
700a84ca: 980f         	ldr	r0, [sp, #0x3c]
700a84cc: f000 0002    	and	r0, r0, #0x2
700a84d0: 2802         	cmp	r0, #0x2
700a84d2: d007         	beq	0x700a84e4 <Sciclient_pmSetModuleState+0x54> @ imm = #0xe
700a84d4: e7ff         	b	0x700a84d6 <Sciclient_pmSetModuleState+0x46> @ imm = #-0x2
;         (reqFlag != 0U))
700a84d6: 980f         	ldr	r0, [sp, #0x3c]
;     if (((reqFlag & TISCI_MSG_FLAG_AOP) != TISCI_MSG_FLAG_AOP)&&
700a84d8: b120         	cbz	r0, 0x700a84e4 <Sciclient_pmSetModuleState+0x54> @ imm = #0x8
700a84da: e7ff         	b	0x700a84dc <Sciclient_pmSetModuleState+0x4c> @ imm = #-0x2
700a84dc: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a84e0: 900d         	str	r0, [sp, #0x34]
;     }
700a84e2: e7ff         	b	0x700a84e4 <Sciclient_pmSetModuleState+0x54> @ imm = #-0x2
;     if(retVal == SystemP_SUCCESS)
700a84e4: 980d         	ldr	r0, [sp, #0x34]
700a84e6: b930         	cbnz	r0, 0x700a84f6 <Sciclient_pmSetModuleState+0x66> @ imm = #0xc
700a84e8: e7ff         	b	0x700a84ea <Sciclient_pmSetModuleState+0x5a> @ imm = #-0x2
700a84ea: a803         	add	r0, sp, #0xc
700a84ec: 4669         	mov	r1, sp
;         retVal = Sciclient_service(&reqParam, &respParam);
700a84ee: f7f3 fd97    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xc4d2
700a84f2: 900d         	str	r0, [sp, #0x34]
;     }
700a84f4: e7ff         	b	0x700a84f6 <Sciclient_pmSetModuleState+0x66> @ imm = #-0x2
;     if((retVal != SystemP_SUCCESS) ||
700a84f6: 980d         	ldr	r0, [sp, #0x34]
700a84f8: b948         	cbnz	r0, 0x700a850e <Sciclient_pmSetModuleState+0x7e> @ imm = #0x12
700a84fa: e7ff         	b	0x700a84fc <Sciclient_pmSetModuleState+0x6c> @ imm = #-0x2
;         ((reqFlag != 0U) &&
700a84fc: 980f         	ldr	r0, [sp, #0x3c]
700a84fe: b150         	cbz	r0, 0x700a8516 <Sciclient_pmSetModuleState+0x86> @ imm = #0x14
700a8500: e7ff         	b	0x700a8502 <Sciclient_pmSetModuleState+0x72> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)))
700a8502: 9800         	ldr	r0, [sp]
700a8504: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a8508: 2802         	cmp	r0, #0x2
700a850a: d004         	beq	0x700a8516 <Sciclient_pmSetModuleState+0x86> @ imm = #0x8
700a850c: e7ff         	b	0x700a850e <Sciclient_pmSetModuleState+0x7e> @ imm = #-0x2
700a850e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a8512: 900d         	str	r0, [sp, #0x34]
;     }
700a8514: e7ff         	b	0x700a8516 <Sciclient_pmSetModuleState+0x86> @ imm = #-0x2
;     return retVal;
700a8516: 980d         	ldr	r0, [sp, #0x34]
700a8518: b012         	add	sp, #0x48
700a851a: bd80         	pop	{r7, pc}
700a851c: 0000         	movs	r0, r0
700a851e: 0000         	movs	r0, r0

700a8520 <Sciclient_rmIaEvtRomMapped>:
; {
700a8520: b082         	sub	sp, #0x8
700a8522: 9001         	str	r0, [sp, #0x4]
700a8524: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a8528: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a852a: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a852e: 9801         	ldr	r0, [sp, #0x4]
700a8530: 6980         	ldr	r0, [r0, #0x18]
700a8532: b3a8         	cbz	r0, 0x700a85a0 <Sciclient_rmIaEvtRomMapped+0x80> @ imm = #0x6a
700a8534: e7ff         	b	0x700a8536 <Sciclient_rmIaEvtRomMapped+0x16> @ imm = #-0x2
700a8536: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a8538: f88d 0000    	strb.w	r0, [sp]
700a853c: e7ff         	b	0x700a853e <Sciclient_rmIaEvtRomMapped+0x1e> @ imm = #-0x2
700a853e: f89d 0000    	ldrb.w	r0, [sp]
700a8542: 9901         	ldr	r1, [sp, #0x4]
700a8544: 7f09         	ldrb	r1, [r1, #0x1c]
700a8546: 4288         	cmp	r0, r1
700a8548: da29         	bge	0x700a859e <Sciclient_rmIaEvtRomMapped+0x7e> @ imm = #0x52
700a854a: e7ff         	b	0x700a854c <Sciclient_rmIaEvtRomMapped+0x2c> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a854c: 9801         	ldr	r0, [sp, #0x4]
700a854e: 6980         	ldr	r0, [r0, #0x18]
700a8550: f89d 1000    	ldrb.w	r1, [sp]
700a8554: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a8558: 7880         	ldrb	r0, [r0, #0x2]
700a855a: 07c0         	lsls	r0, r0, #0x1f
700a855c: b9c0         	cbnz	r0, 0x700a8590 <Sciclient_rmIaEvtRomMapped+0x70> @ imm = #0x30
700a855e: e7ff         	b	0x700a8560 <Sciclient_rmIaEvtRomMapped+0x40> @ imm = #-0x2
;                 (evt == (inst->rom_usage[i].event - inst->sevt_offset))) {
700a8560: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a8564: 9a01         	ldr	r2, [sp, #0x4]
700a8566: 6991         	ldr	r1, [r2, #0x18]
700a8568: f89d 3000    	ldrb.w	r3, [sp]
700a856c: f831 1023    	ldrh.w	r1, [r1, r3, lsl #2]
700a8570: 8912         	ldrh	r2, [r2, #0x8]
700a8572: 1a89         	subs	r1, r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a8574: 4288         	cmp	r0, r1
700a8576: d10b         	bne	0x700a8590 <Sciclient_rmIaEvtRomMapped+0x70> @ imm = #0x16
700a8578: e7ff         	b	0x700a857a <Sciclient_rmIaEvtRomMapped+0x5a> @ imm = #-0x2
700a857a: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a857c: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a8580: 9901         	ldr	r1, [sp, #0x4]
700a8582: 6989         	ldr	r1, [r1, #0x18]
700a8584: f89d 2000    	ldrb.w	r2, [sp]
700a8588: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a858c: 7088         	strb	r0, [r1, #0x2]
;                 break;
700a858e: e006         	b	0x700a859e <Sciclient_rmIaEvtRomMapped+0x7e> @ imm = #0xc
;         }
700a8590: e7ff         	b	0x700a8592 <Sciclient_rmIaEvtRomMapped+0x72> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a8592: f89d 0000    	ldrb.w	r0, [sp]
700a8596: 3001         	adds	r0, #0x1
700a8598: f88d 0000    	strb.w	r0, [sp]
700a859c: e7cf         	b	0x700a853e <Sciclient_rmIaEvtRomMapped+0x1e> @ imm = #-0x62
;     }
700a859e: e7ff         	b	0x700a85a0 <Sciclient_rmIaEvtRomMapped+0x80> @ imm = #-0x2
;     return rom_mapped;
700a85a0: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a85a4: f000 0001    	and	r0, r0, #0x1
700a85a8: b002         	add	sp, #0x8
700a85aa: 4770         	bx	lr
700a85ac: 0000         	movs	r0, r0
700a85ae: 0000         	movs	r0, r0

700a85b0 <UART_writeCancelNoCB>:
; {
700a85b0: b580         	push	{r7, lr}
700a85b2: b084         	sub	sp, #0x10
700a85b4: 9003         	str	r0, [sp, #0xc]
700a85b6: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a85b8: 9001         	str	r0, [sp, #0x4]
;     hUartInit = hUart->hUartInit;
700a85ba: 9803         	ldr	r0, [sp, #0xc]
700a85bc: 6840         	ldr	r0, [r0, #0x4]
700a85be: 9000         	str	r0, [sp]
;     UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
700a85c0: 9803         	ldr	r0, [sp, #0xc]
700a85c2: 6800         	ldr	r0, [r0]
700a85c4: 2102         	movs	r1, #0x2
700a85c6: f7fc f8bb    	bl	0x700a4740 <UART_intrDisable> @ imm = #-0x3e8a
;     key = HwiP_disable();
700a85ca: f006 ebfa    	blx	0x700aedc0 <HwiP_disable> @ imm = #0x67f4
700a85ce: 9002         	str	r0, [sp, #0x8]
;     if ((hUart->writeSizeRemaining) == 0U)
700a85d0: 9803         	ldr	r0, [sp, #0xc]
700a85d2: 6900         	ldr	r0, [r0, #0x10]
700a85d4: b920         	cbnz	r0, 0x700a85e0 <UART_writeCancelNoCB+0x30> @ imm = #0x8
700a85d6: e7ff         	b	0x700a85d8 <UART_writeCancelNoCB+0x28> @ imm = #-0x2
700a85d8: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700a85dc: 9001         	str	r0, [sp, #0x4]
;     }
700a85de: e027         	b	0x700a8630 <UART_writeCancelNoCB+0x80> @ imm = #0x4e
;         if (hUartInit->transferMode == UART_CONFIG_MODE_DMA)
700a85e0: 9800         	ldr	r0, [sp]
700a85e2: 6a00         	ldr	r0, [r0, #0x20]
700a85e4: 2803         	cmp	r0, #0x3
700a85e6: d111         	bne	0x700a860c <UART_writeCancelNoCB+0x5c> @ imm = #0x22
700a85e8: e7ff         	b	0x700a85ea <UART_writeCancelNoCB+0x3a> @ imm = #-0x2
;             UART_lld_dmaDisableChannel(hUart, (Bool)TRUE);
700a85ea: 9803         	ldr	r0, [sp, #0xc]
700a85ec: 2101         	movs	r1, #0x1
700a85ee: f7ff fc4f    	bl	0x700a7e90 <UART_lld_dmaDisableChannel> @ imm = #-0x762
;             if (hUart->writeTrans.buf != NULL)
700a85f2: 9803         	ldr	r0, [sp, #0xc]
700a85f4: 6bc0         	ldr	r0, [r0, #0x3c]
700a85f6: b120         	cbz	r0, 0x700a8602 <UART_writeCancelNoCB+0x52> @ imm = #0x8
700a85f8: e7ff         	b	0x700a85fa <UART_writeCancelNoCB+0x4a> @ imm = #-0x2
;                 hUart->writeTrans.count = 0;
700a85fa: 9903         	ldr	r1, [sp, #0xc]
700a85fc: 2000         	movs	r0, #0x0
700a85fe: 6408         	str	r0, [r1, #0x40]
;             }
700a8600: e003         	b	0x700a860a <UART_writeCancelNoCB+0x5a> @ imm = #0x6
;                 hUart->writeCount = 0;
700a8602: 9903         	ldr	r1, [sp, #0xc]
700a8604: 2000         	movs	r0, #0x0
700a8606: 60c8         	str	r0, [r1, #0xc]
700a8608: e7ff         	b	0x700a860a <UART_writeCancelNoCB+0x5a> @ imm = #-0x2
;         }
700a860a: e010         	b	0x700a862e <UART_writeCancelNoCB+0x7e> @ imm = #0x20
;             hUart->writeBuf = (const uint8_t *)hUart->writeBuf - hUart->writeCount;
700a860c: 9903         	ldr	r1, [sp, #0xc]
700a860e: 6888         	ldr	r0, [r1, #0x8]
700a8610: 68ca         	ldr	r2, [r1, #0xc]
700a8612: 1a80         	subs	r0, r0, r2
700a8614: 6088         	str	r0, [r1, #0x8]
;             if (hUart->writeTrans.buf != NULL)
700a8616: 9803         	ldr	r0, [sp, #0xc]
700a8618: 6bc0         	ldr	r0, [r0, #0x3c]
700a861a: b120         	cbz	r0, 0x700a8626 <UART_writeCancelNoCB+0x76> @ imm = #0x8
700a861c: e7ff         	b	0x700a861e <UART_writeCancelNoCB+0x6e> @ imm = #-0x2
;                 hUart->writeTrans.count = (uint32_t)(hUart->writeCount);
700a861e: 9903         	ldr	r1, [sp, #0xc]
700a8620: 68c8         	ldr	r0, [r1, #0xc]
700a8622: 6408         	str	r0, [r1, #0x40]
;             }
700a8624: e7ff         	b	0x700a8626 <UART_writeCancelNoCB+0x76> @ imm = #-0x2
;             hUart->writeSizeRemaining = 0;
700a8626: 9903         	ldr	r1, [sp, #0xc]
700a8628: 2000         	movs	r0, #0x0
700a862a: 6108         	str	r0, [r1, #0x10]
700a862c: e7ff         	b	0x700a862e <UART_writeCancelNoCB+0x7e> @ imm = #-0x2
700a862e: e7ff         	b	0x700a8630 <UART_writeCancelNoCB+0x80> @ imm = #-0x2
;     HwiP_restore(key);
700a8630: 9802         	ldr	r0, [sp, #0x8]
700a8632: f006 ebe6    	blx	0x700aee00 <HwiP_restore> @ imm = #0x67cc
;     return (status);
700a8636: 9801         	ldr	r0, [sp, #0x4]
700a8638: b004         	add	sp, #0x10
700a863a: bd80         	pop	{r7, pc}
700a863c: 0000         	movs	r0, r0
700a863e: 0000         	movs	r0, r0

700a8640 <Udma_ringFlushRaw>:
; {
700a8640: b580         	push	{r7, lr}
700a8642: b086         	sub	sp, #0x18
700a8644: 9005         	str	r0, [sp, #0x14]
700a8646: 9104         	str	r1, [sp, #0x10]
700a8648: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a864a: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a864c: 9805         	ldr	r0, [sp, #0x14]
700a864e: 9001         	str	r0, [sp, #0x4]
;     if((NULL_PTR == ringHandleInt) ||
700a8650: 9801         	ldr	r0, [sp, #0x4]
700a8652: b180         	cbz	r0, 0x700a8676 <Udma_ringFlushRaw+0x36> @ imm = #0x20
700a8654: e7ff         	b	0x700a8656 <Udma_ringFlushRaw+0x16> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a8656: 9801         	ldr	r0, [sp, #0x4]
700a8658: 6d80         	ldr	r0, [r0, #0x58]
700a865a: f64a 31cd    	movw	r1, #0xabcd
700a865e: f6ca 31dc    	movt	r1, #0xabdc
700a8662: 4288         	cmp	r0, r1
700a8664: d107         	bne	0x700a8676 <Udma_ringFlushRaw+0x36> @ imm = #0xe
700a8666: e7ff         	b	0x700a8668 <Udma_ringFlushRaw+0x28> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a8668: 9801         	ldr	r0, [sp, #0x4]
700a866a: 8880         	ldrh	r0, [r0, #0x4]
700a866c: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a8670: 4288         	cmp	r0, r1
700a8672: d104         	bne	0x700a867e <Udma_ringFlushRaw+0x3e> @ imm = #0x8
700a8674: e7ff         	b	0x700a8676 <Udma_ringFlushRaw+0x36> @ imm = #-0x2
700a8676: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a867a: 9003         	str	r0, [sp, #0xc]
;     }
700a867c: e7ff         	b	0x700a867e <Udma_ringFlushRaw+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a867e: 9803         	ldr	r0, [sp, #0xc]
700a8680: b9a8         	cbnz	r0, 0x700a86ae <Udma_ringFlushRaw+0x6e> @ imm = #0x2a
700a8682: e7ff         	b	0x700a8684 <Udma_ringFlushRaw+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a8684: 9801         	ldr	r0, [sp, #0x4]
700a8686: 6800         	ldr	r0, [r0]
700a8688: 9002         	str	r0, [sp, #0x8]
;         if((NULL_PTR == drvHandle) ||
700a868a: 9802         	ldr	r0, [sp, #0x8]
700a868c: b150         	cbz	r0, 0x700a86a4 <Udma_ringFlushRaw+0x64> @ imm = #0x14
700a868e: e7ff         	b	0x700a8690 <Udma_ringFlushRaw+0x50> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a8690: 9802         	ldr	r0, [sp, #0x8]
700a8692: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a8696: f64a 31cd    	movw	r1, #0xabcd
700a869a: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a869e: 4288         	cmp	r0, r1
700a86a0: d004         	beq	0x700a86ac <Udma_ringFlushRaw+0x6c> @ imm = #0x8
700a86a2: e7ff         	b	0x700a86a4 <Udma_ringFlushRaw+0x64> @ imm = #-0x2
700a86a4: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a86a8: 9003         	str	r0, [sp, #0xc]
;         }
700a86aa: e7ff         	b	0x700a86ac <Udma_ringFlushRaw+0x6c> @ imm = #-0x2
;     }
700a86ac: e7ff         	b	0x700a86ae <Udma_ringFlushRaw+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a86ae: 9803         	ldr	r0, [sp, #0xc]
700a86b0: b940         	cbnz	r0, 0x700a86c4 <Udma_ringFlushRaw+0x84> @ imm = #0x10
700a86b2: e7ff         	b	0x700a86b4 <Udma_ringFlushRaw+0x74> @ imm = #-0x2
;         retVal = drvHandle->ringFlushRaw(drvHandle, ringHandleInt, phyDescMem);
700a86b4: 9802         	ldr	r0, [sp, #0x8]
700a86b6: f8d0 3598    	ldr.w	r3, [r0, #0x598]
700a86ba: 9901         	ldr	r1, [sp, #0x4]
700a86bc: 9a04         	ldr	r2, [sp, #0x10]
700a86be: 4798         	blx	r3
700a86c0: 9003         	str	r0, [sp, #0xc]
;     }
700a86c2: e7ff         	b	0x700a86c4 <Udma_ringFlushRaw+0x84> @ imm = #-0x2
;     return (retVal);
700a86c4: 9803         	ldr	r0, [sp, #0xc]
700a86c6: b006         	add	sp, #0x18
700a86c8: bd80         	pop	{r7, pc}
700a86ca: 0000         	movs	r0, r0
700a86cc: 0000         	movs	r0, r0
700a86ce: 0000         	movs	r0, r0

700a86d0 <xQueueGenericReset>:
; {
700a86d0: b580         	push	{r7, lr}
700a86d2: b084         	sub	sp, #0x10
700a86d4: 9003         	str	r0, [sp, #0xc]
700a86d6: 9102         	str	r1, [sp, #0x8]
;     Queue_t * const pxQueue = xQueue;
700a86d8: 9803         	ldr	r0, [sp, #0xc]
700a86da: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700a86dc: f004 fa78    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0x44f0
;         pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700a86e0: 9901         	ldr	r1, [sp, #0x4]
700a86e2: 680b         	ldr	r3, [r1]
700a86e4: 6bc8         	ldr	r0, [r1, #0x3c]
700a86e6: 6c0a         	ldr	r2, [r1, #0x40]
700a86e8: fb00 3002    	mla	r0, r0, r2, r3
700a86ec: 6088         	str	r0, [r1, #0x8]
;         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
700a86ee: 9901         	ldr	r1, [sp, #0x4]
700a86f0: 2000         	movs	r0, #0x0
700a86f2: 6388         	str	r0, [r1, #0x38]
;         pxQueue->pcWriteTo = pxQueue->pcHead;
700a86f4: 9901         	ldr	r1, [sp, #0x4]
700a86f6: 6808         	ldr	r0, [r1]
700a86f8: 6048         	str	r0, [r1, #0x4]
;         pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700a86fa: 9901         	ldr	r1, [sp, #0x4]
700a86fc: 680b         	ldr	r3, [r1]
700a86fe: 6bc8         	ldr	r0, [r1, #0x3c]
700a8700: 6c0a         	ldr	r2, [r1, #0x40]
700a8702: 3801         	subs	r0, #0x1
700a8704: fb00 3002    	mla	r0, r0, r2, r3
700a8708: 60c8         	str	r0, [r1, #0xc]
;         pxQueue->cRxLock = queueUNLOCKED;
700a870a: 9901         	ldr	r1, [sp, #0x4]
700a870c: 20ff         	movs	r0, #0xff
700a870e: f881 0044    	strb.w	r0, [r1, #0x44]
;         pxQueue->cTxLock = queueUNLOCKED;
700a8712: 9901         	ldr	r1, [sp, #0x4]
700a8714: f881 0045    	strb.w	r0, [r1, #0x45]
;         if( xNewQueue == pdFALSE )
700a8718: 9802         	ldr	r0, [sp, #0x8]
700a871a: b980         	cbnz	r0, 0x700a873e <xQueueGenericReset+0x6e> @ imm = #0x20
700a871c: e7ff         	b	0x700a871e <xQueueGenericReset+0x4e> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a871e: 9801         	ldr	r0, [sp, #0x4]
700a8720: 6900         	ldr	r0, [r0, #0x10]
700a8722: b150         	cbz	r0, 0x700a873a <xQueueGenericReset+0x6a> @ imm = #0x14
700a8724: e7ff         	b	0x700a8726 <xQueueGenericReset+0x56> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a8726: 9801         	ldr	r0, [sp, #0x4]
700a8728: 3010         	adds	r0, #0x10
700a872a: f7fd fbe1    	bl	0x700a5ef0 <xTaskRemoveFromEventList> @ imm = #-0x283e
700a872e: b110         	cbz	r0, 0x700a8736 <xQueueGenericReset+0x66> @ imm = #0x4
700a8730: e7ff         	b	0x700a8732 <xQueueGenericReset+0x62> @ imm = #-0x2
;                     queueYIELD_IF_USING_PREEMPTION();
700a8732: df00         	svc	#0x0
;                 }
700a8734: e000         	b	0x700a8738 <xQueueGenericReset+0x68> @ imm = #0x0
700a8736: e7ff         	b	0x700a8738 <xQueueGenericReset+0x68> @ imm = #-0x2
;             }
700a8738: e000         	b	0x700a873c <xQueueGenericReset+0x6c> @ imm = #0x0
700a873a: e7ff         	b	0x700a873c <xQueueGenericReset+0x6c> @ imm = #-0x2
;         }
700a873c: e008         	b	0x700a8750 <xQueueGenericReset+0x80> @ imm = #0x10
;             vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
700a873e: 9801         	ldr	r0, [sp, #0x4]
700a8740: 3010         	adds	r0, #0x10
700a8742: f004 fbbd    	bl	0x700acec0 <vListInitialise> @ imm = #0x477a
;             vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
700a8746: 9801         	ldr	r0, [sp, #0x4]
700a8748: 3024         	adds	r0, #0x24
700a874a: f004 fbb9    	bl	0x700acec0 <vListInitialise> @ imm = #0x4772
700a874e: e7ff         	b	0x700a8750 <xQueueGenericReset+0x80> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700a8750: f003 fabe    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x357c
700a8754: 2001         	movs	r0, #0x1
;     return pdPASS;
700a8756: b004         	add	sp, #0x10
700a8758: bd80         	pop	{r7, pc}
700a875a: 0000         	movs	r0, r0
700a875c: 0000         	movs	r0, r0
700a875e: 0000         	movs	r0, r0

700a8760 <CSL_bcdmaGetCfg>:
; {
700a8760: b580         	push	{r7, lr}
700a8762: b082         	sub	sp, #0x8
700a8764: 9001         	str	r0, [sp, #0x4]
;     if( ! ((pCfg == NULL) || (pCfg->pGenCfgRegs == NULL)) )
700a8766: 9801         	ldr	r0, [sp, #0x4]
700a8768: b3e0         	cbz	r0, 0x700a87e4 <CSL_bcdmaGetCfg+0x84> @ imm = #0x78
700a876a: e7ff         	b	0x700a876c <CSL_bcdmaGetCfg+0xc> @ imm = #-0x2
700a876c: 9801         	ldr	r0, [sp, #0x4]
700a876e: 6800         	ldr	r0, [r0]
700a8770: b3c0         	cbz	r0, 0x700a87e4 <CSL_bcdmaGetCfg+0x84> @ imm = #0x70
700a8772: e7ff         	b	0x700a8774 <CSL_bcdmaGetCfg+0x14> @ imm = #-0x2
;         pCfg->cap0 = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP0 );
700a8774: 9801         	ldr	r0, [sp, #0x4]
700a8776: 6800         	ldr	r0, [r0]
700a8778: 3020         	adds	r0, #0x20
700a877a: f005 fc79    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0x58f2
700a877e: 9901         	ldr	r1, [sp, #0x4]
700a8780: 61c8         	str	r0, [r1, #0x1c]
;         pCfg->cap1 = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP1 );
700a8782: 9801         	ldr	r0, [sp, #0x4]
700a8784: 6800         	ldr	r0, [r0]
700a8786: 3024         	adds	r0, #0x24
700a8788: f005 fc72    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0x58e4
700a878c: 9901         	ldr	r1, [sp, #0x4]
700a878e: 6208         	str	r0, [r1, #0x20]
;         regVal = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP2 );
700a8790: 9801         	ldr	r0, [sp, #0x4]
700a8792: 6800         	ldr	r0, [r0]
700a8794: 3028         	adds	r0, #0x28
700a8796: f005 fc6b    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0x58d6
700a879a: 9000         	str	r0, [sp]
;         pCfg->bcChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_CHAN_CNT );
700a879c: 9800         	ldr	r0, [sp]
700a879e: f36f 205f    	bfc	r0, #9, #23
700a87a2: 9901         	ldr	r1, [sp, #0x4]
700a87a4: 6248         	str	r0, [r1, #0x24]
;         pCfg->splitTxChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_TCHAN_CNT );
700a87a6: 9800         	ldr	r0, [sp]
700a87a8: f3c0 2048    	ubfx	r0, r0, #0x9, #0x9
700a87ac: 9901         	ldr	r1, [sp, #0x4]
700a87ae: 62c8         	str	r0, [r1, #0x2c]
;         pCfg->splitRxChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_RCHAN_CNT );
700a87b0: 9800         	ldr	r0, [sp]
700a87b2: f3c0 4088    	ubfx	r0, r0, #0x12, #0x9
700a87b6: 9901         	ldr	r1, [sp, #0x4]
700a87b8: 6288         	str	r0, [r1, #0x28]
;         pCfg->flowCnt = (uint32_t)0U;
700a87ba: 9901         	ldr	r1, [sp, #0x4]
700a87bc: 2000         	movs	r0, #0x0
700a87be: 6308         	str	r0, [r1, #0x30]
;         pCfg->txChanCnt                     = pCfg->bcChanCnt + pCfg->splitTxChanCnt;
700a87c0: 9a01         	ldr	r2, [sp, #0x4]
700a87c2: 6a51         	ldr	r1, [r2, #0x24]
700a87c4: 6ad3         	ldr	r3, [r2, #0x2c]
700a87c6: 4419         	add	r1, r3
700a87c8: 6351         	str	r1, [r2, #0x34]
;         pCfg->rxChanCnt                     = pCfg->splitRxChanCnt;
700a87ca: 9a01         	ldr	r2, [sp, #0x4]
700a87cc: 6a91         	ldr	r1, [r2, #0x28]
700a87ce: 6391         	str	r1, [r2, #0x38]
;         pCfg->rxFlowCnt                     = pCfg->flowCnt;
700a87d0: 9a01         	ldr	r2, [sp, #0x4]
700a87d2: 6b11         	ldr	r1, [r2, #0x30]
700a87d4: 63d1         	str	r1, [r2, #0x3c]
;         pCfg->txExtUtcChanCnt               = (uint32_t)0U;
700a87d6: 9901         	ldr	r1, [sp, #0x4]
700a87d8: 6408         	str	r0, [r1, #0x40]
;         pCfg->txHighCapacityChanCnt         = (uint32_t)0U;
700a87da: 9901         	ldr	r1, [sp, #0x4]
700a87dc: 6448         	str	r0, [r1, #0x44]
;         pCfg->txUltraHighCapacityChanCnt    = (uint32_t)0U;
700a87de: 9901         	ldr	r1, [sp, #0x4]
700a87e0: 6488         	str	r0, [r1, #0x48]
;     }
700a87e2: e7ff         	b	0x700a87e4 <CSL_bcdmaGetCfg+0x84> @ imm = #-0x2
; }
700a87e4: b002         	add	sp, #0x8
700a87e6: bd80         	pop	{r7, pc}
		...

700a87f0 <Udma_rmFreeVintrBit>:
; {
700a87f0: b580         	push	{r7, lr}
700a87f2: b088         	sub	sp, #0x20
700a87f4: 9007         	str	r0, [sp, #0x1c]
700a87f6: 9106         	str	r1, [sp, #0x18]
700a87f8: 9205         	str	r2, [sp, #0x14]
;     controllerEventHandle = eventHandle;
700a87fa: 9805         	ldr	r0, [sp, #0x14]
700a87fc: 9001         	str	r0, [sp, #0x4]
;     eventPrms = &eventHandle->eventPrms;
700a87fe: 9805         	ldr	r0, [sp, #0x14]
700a8800: 3008         	adds	r0, #0x8
700a8802: 9000         	str	r0, [sp]
;     if(NULL_PTR != eventPrms->controllerEventHandle)
700a8804: 9800         	ldr	r0, [sp]
700a8806: 6900         	ldr	r0, [r0, #0x10]
700a8808: b120         	cbz	r0, 0x700a8814 <Udma_rmFreeVintrBit+0x24> @ imm = #0x8
700a880a: e7ff         	b	0x700a880c <Udma_rmFreeVintrBit+0x1c> @ imm = #-0x2
;         controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a880c: 9800         	ldr	r0, [sp]
700a880e: 6900         	ldr	r0, [r0, #0x10]
700a8810: 9001         	str	r0, [sp, #0x4]
;     }
700a8812: e7ff         	b	0x700a8814 <Udma_rmFreeVintrBit+0x24> @ imm = #-0x2
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a8814: 9806         	ldr	r0, [sp, #0x18]
700a8816: f500 609f    	add.w	r0, r0, #0x4f8
700a881a: f04f 31ff    	mov.w	r1, #0xffffffff
700a881e: f000 fa27    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #0x44e
;     bitMask = ((uint64_t) 1U << vintrBitNum);
700a8822: 9b07         	ldr	r3, [sp, #0x1c]
700a8824: f1a3 0220    	sub.w	r2, r3, #0x20
700a8828: 2101         	movs	r1, #0x1
700a882a: fa01 fc02    	lsl.w	r12, r1, r2
700a882e: f1c3 0020    	rsb.w	r0, r3, #0x20
700a8832: fa21 f000    	lsr.w	r0, r1, r0
700a8836: 2a00         	cmp	r2, #0x0
700a8838: bf58         	it	pl
700a883a: 4660         	movpl	r0, r12
700a883c: fa01 f103    	lsl.w	r1, r1, r3
700a8840: 2a00         	cmp	r2, #0x0
700a8842: bf58         	it	pl
700a8844: 2100         	movpl	r1, #0x0
700a8846: 9102         	str	r1, [sp, #0x8]
700a8848: 9003         	str	r0, [sp, #0xc]
;     controllerEventHandle->vintrBitAllocFlag &= ~bitMask;
700a884a: f8dd c008    	ldr.w	r12, [sp, #0x8]
700a884e: 9b03         	ldr	r3, [sp, #0xc]
700a8850: 9901         	ldr	r1, [sp, #0x4]
700a8852: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a8856: f8d1 208c    	ldr.w	r2, [r1, #0x8c]
700a885a: ea20 000c    	bic.w	r0, r0, r12
700a885e: ea22 0203    	bic.w	r2, r2, r3
700a8862: f8c1 208c    	str.w	r2, [r1, #0x8c]
700a8866: f8c1 0088    	str.w	r0, [r1, #0x88]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a886a: 9806         	ldr	r0, [sp, #0x18]
700a886c: f500 609f    	add.w	r0, r0, #0x4f8
700a8870: f001 fd4e    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x1a9c
;     return;
700a8874: b008         	add	sp, #0x20
700a8876: bd80         	pop	{r7, pc}
		...

700a8880 <SOC_controlModuleLockMMR>:
; {
700a8880: b580         	push	{r7, lr}
700a8882: b086         	sub	sp, #0x18
700a8884: 9005         	str	r0, [sp, #0x14]
700a8886: 9104         	str	r1, [sp, #0x10]
;     if(SOC_DOMAIN_ID_MAIN == domainId)
700a8888: 9805         	ldr	r0, [sp, #0x14]
700a888a: b9d8         	cbnz	r0, 0x700a88c4 <SOC_controlModuleLockMMR+0x44> @ imm = #0x36
700a888c: e7ff         	b	0x700a888e <SOC_controlModuleLockMMR+0xe> @ imm = #-0x2
700a888e: f04f 4086    	mov.w	r0, #0x43000000
700a8892: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_CTRL_MMR0_CFG0_BASE);
700a8894: 9101         	str	r1, [sp, #0x4]
700a8896: f7fb fbb3    	bl	0x700a4000 <AddrTranslateP_getLocalAddr> @ imm = #-0x489a
700a889a: 9901         	ldr	r1, [sp, #0x4]
700a889c: 9003         	str	r0, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a889e: 9803         	ldr	r0, [sp, #0xc]
700a88a0: 9a04         	ldr	r2, [sp, #0x10]
700a88a2: eb00 3082    	add.w	r0, r0, r2, lsl #14
700a88a6: f241 0208    	movw	r2, #0x1008
700a88aa: 4410         	add	r0, r2
700a88ac: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700a88ae: 9802         	ldr	r0, [sp, #0x8]
700a88b0: f005 fb5e    	bl	0x700adf70 <CSL_REG32_WR_RAW> @ imm = #0x56bc
700a88b4: 9901         	ldr	r1, [sp, #0x4]
;         kickAddr++;
700a88b6: 9802         	ldr	r0, [sp, #0x8]
700a88b8: 3004         	adds	r0, #0x4
700a88ba: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700a88bc: 9802         	ldr	r0, [sp, #0x8]
700a88be: f005 fb57    	bl	0x700adf70 <CSL_REG32_WR_RAW> @ imm = #0x56ae
;     }
700a88c2: e7ff         	b	0x700a88c4 <SOC_controlModuleLockMMR+0x44> @ imm = #-0x2
;     if(SOC_DOMAIN_ID_MCU == domainId)
700a88c4: 9805         	ldr	r0, [sp, #0x14]
700a88c6: 2801         	cmp	r0, #0x1
700a88c8: d11b         	bne	0x700a8902 <SOC_controlModuleLockMMR+0x82> @ imm = #0x36
700a88ca: e7ff         	b	0x700a88cc <SOC_controlModuleLockMMR+0x4c> @ imm = #-0x2
700a88cc: f04f 608a    	mov.w	r0, #0x4500000
700a88d0: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_CTRL_MMR0_CFG0_BASE);
700a88d2: 9100         	str	r1, [sp]
700a88d4: f7fb fb94    	bl	0x700a4000 <AddrTranslateP_getLocalAddr> @ imm = #-0x48d8
700a88d8: 9900         	ldr	r1, [sp]
700a88da: 9003         	str	r0, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a88dc: 9803         	ldr	r0, [sp, #0xc]
700a88de: 9a04         	ldr	r2, [sp, #0x10]
700a88e0: eb00 3082    	add.w	r0, r0, r2, lsl #14
700a88e4: f241 0208    	movw	r2, #0x1008
700a88e8: 4410         	add	r0, r2
700a88ea: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700a88ec: 9802         	ldr	r0, [sp, #0x8]
700a88ee: f005 fb3f    	bl	0x700adf70 <CSL_REG32_WR_RAW> @ imm = #0x567e
700a88f2: 9900         	ldr	r1, [sp]
;         kickAddr++;
700a88f4: 9802         	ldr	r0, [sp, #0x8]
700a88f6: 3004         	adds	r0, #0x4
700a88f8: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700a88fa: 9802         	ldr	r0, [sp, #0x8]
700a88fc: f005 fb38    	bl	0x700adf70 <CSL_REG32_WR_RAW> @ imm = #0x5670
;     }
700a8900: e7ff         	b	0x700a8902 <SOC_controlModuleLockMMR+0x82> @ imm = #-0x2
;     return;
700a8902: b006         	add	sp, #0x18
700a8904: bd80         	pop	{r7, pc}
		...
700a890e: 0000         	movs	r0, r0

700a8910 <UART_lld_flushTxFifo>:
; {
700a8910: b580         	push	{r7, lr}
700a8912: b088         	sub	sp, #0x20
700a8914: 9007         	str	r0, [sp, #0x1c]
700a8916: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700a8918: 9006         	str	r0, [sp, #0x18]
700a891a: f640 31b8    	movw	r1, #0xbb8
;     uint32_t            timeout = UART_TRANSMITEMPTY_TRIALCOUNT;
700a891e: 9102         	str	r1, [sp, #0x8]
;     uint32_t            timeoutElapsed  = FALSE;
700a8920: 9001         	str	r0, [sp, #0x4]
;     if (NULL_PTR != hUart)
700a8922: 9807         	ldr	r0, [sp, #0x1c]
700a8924: b380         	cbz	r0, 0x700a8988 <UART_lld_flushTxFifo+0x78> @ imm = #0x60
700a8926: e7ff         	b	0x700a8928 <UART_lld_flushTxFifo+0x18> @ imm = #-0x2
;         hUartInit = hUart->hUartInit;
700a8928: 9807         	ldr	r0, [sp, #0x1c]
700a892a: 6840         	ldr	r0, [r0, #0x4]
700a892c: 9000         	str	r0, [sp]
;         startTicks = hUartInit->clockP_get();
700a892e: 9800         	ldr	r0, [sp]
700a8930: 6d40         	ldr	r0, [r0, #0x54]
700a8932: 4780         	blx	r0
700a8934: 9004         	str	r0, [sp, #0x10]
;         while (FALSE == timeoutElapsed)
700a8936: e7ff         	b	0x700a8938 <UART_lld_flushTxFifo+0x28> @ imm = #-0x2
700a8938: 9801         	ldr	r0, [sp, #0x4]
700a893a: b9e0         	cbnz	r0, 0x700a8976 <UART_lld_flushTxFifo+0x66> @ imm = #0x38
700a893c: e7ff         	b	0x700a893e <UART_lld_flushTxFifo+0x2e> @ imm = #-0x2
;             isTxFifoEmpty = UART_spaceAvail(hUart->baseAddr);
700a893e: 9807         	ldr	r0, [sp, #0x1c]
700a8940: 6800         	ldr	r0, [r0]
700a8942: f003 fccd    	bl	0x700ac2e0 <UART_spaceAvail> @ imm = #0x399a
700a8946: 9005         	str	r0, [sp, #0x14]
;             if ((uint32_t) TRUE == isTxFifoEmpty)
700a8948: 9805         	ldr	r0, [sp, #0x14]
700a894a: 2801         	cmp	r0, #0x1
700a894c: d101         	bne	0x700a8952 <UART_lld_flushTxFifo+0x42> @ imm = #0x2
700a894e: e7ff         	b	0x700a8950 <UART_lld_flushTxFifo+0x40> @ imm = #-0x2
;                 break;
700a8950: e011         	b	0x700a8976 <UART_lld_flushTxFifo+0x66> @ imm = #0x22
;             elapsedTicks = hUartInit->clockP_get() - startTicks;
700a8952: 9800         	ldr	r0, [sp]
700a8954: 6d40         	ldr	r0, [r0, #0x54]
700a8956: 4780         	blx	r0
700a8958: 9904         	ldr	r1, [sp, #0x10]
700a895a: 1a40         	subs	r0, r0, r1
700a895c: 9003         	str	r0, [sp, #0xc]
;             if (elapsedTicks >= timeout)
700a895e: 9803         	ldr	r0, [sp, #0xc]
700a8960: 9902         	ldr	r1, [sp, #0x8]
700a8962: 4288         	cmp	r0, r1
700a8964: d303         	blo	0x700a896e <UART_lld_flushTxFifo+0x5e> @ imm = #0x6
700a8966: e7ff         	b	0x700a8968 <UART_lld_flushTxFifo+0x58> @ imm = #-0x2
700a8968: 2001         	movs	r0, #0x1
;                 timeoutElapsed = TRUE;
700a896a: 9001         	str	r0, [sp, #0x4]
;             }
700a896c: e002         	b	0x700a8974 <UART_lld_flushTxFifo+0x64> @ imm = #0x4
;                 TaskP_yield();
700a896e: f005 fc27    	bl	0x700ae1c0 <TaskP_yield> @ imm = #0x584e
700a8972: e7ff         	b	0x700a8974 <UART_lld_flushTxFifo+0x64> @ imm = #-0x2
;         while (FALSE == timeoutElapsed)
700a8974: e7e0         	b	0x700a8938 <UART_lld_flushTxFifo+0x28> @ imm = #-0x40
;         if(TRUE == timeoutElapsed)
700a8976: 9801         	ldr	r0, [sp, #0x4]
700a8978: 2801         	cmp	r0, #0x1
700a897a: d104         	bne	0x700a8986 <UART_lld_flushTxFifo+0x76> @ imm = #0x8
700a897c: e7ff         	b	0x700a897e <UART_lld_flushTxFifo+0x6e> @ imm = #-0x2
700a897e: f06f 0001    	mvn	r0, #0x1
;             status = UART_TRANSFER_TIMEOUT;
700a8982: 9006         	str	r0, [sp, #0x18]
;         }
700a8984: e7ff         	b	0x700a8986 <UART_lld_flushTxFifo+0x76> @ imm = #-0x2
;     }
700a8986: e003         	b	0x700a8990 <UART_lld_flushTxFifo+0x80> @ imm = #0x6
700a8988: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a898c: 9006         	str	r0, [sp, #0x18]
700a898e: e7ff         	b	0x700a8990 <UART_lld_flushTxFifo+0x80> @ imm = #-0x2
;     return status;
700a8990: 9806         	ldr	r0, [sp, #0x18]
700a8992: b008         	add	sp, #0x20
700a8994: bd80         	pop	{r7, pc}
		...
700a899e: 0000         	movs	r0, r0

700a89a0 <UART_tcrTlrBitValRestore>:
; {
700a89a0: b580         	push	{r7, lr}
700a89a2: b088         	sub	sp, #0x20
700a89a4: 9007         	str	r0, [sp, #0x1c]
700a89a6: 9106         	str	r1, [sp, #0x18]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a89a8: 9807         	ldr	r0, [sp, #0x1c]
700a89aa: 21bf         	movs	r1, #0xbf
700a89ac: 9101         	str	r1, [sp, #0x4]
700a89ae: f002 f8f7    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #0x21ee
700a89b2: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a89b4: 9807         	ldr	r0, [sp, #0x1c]
700a89b6: 3008         	adds	r0, #0x8
700a89b8: 2110         	movs	r1, #0x10
700a89ba: 9102         	str	r1, [sp, #0x8]
700a89bc: 2204         	movs	r2, #0x4
700a89be: 9203         	str	r2, [sp, #0xc]
700a89c0: f004 ff06    	bl	0x700ad7d0 <HW_RD_FIELD32_RAW> @ imm = #0x4e0c
700a89c4: 9902         	ldr	r1, [sp, #0x8]
700a89c6: 9a03         	ldr	r2, [sp, #0xc]
700a89c8: 9005         	str	r0, [sp, #0x14]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a89ca: 9807         	ldr	r0, [sp, #0x1c]
700a89cc: 3008         	adds	r0, #0x8
700a89ce: 2301         	movs	r3, #0x1
700a89d0: f004 f87e    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x40fc
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a89d4: 9807         	ldr	r0, [sp, #0x1c]
700a89d6: 300c         	adds	r0, #0xc
700a89d8: 9904         	ldr	r1, [sp, #0x10]
700a89da: f005 fb09    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x5612
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700a89de: 9807         	ldr	r0, [sp, #0x1c]
700a89e0: 2180         	movs	r1, #0x80
700a89e2: f002 f8dd    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #0x21ba
700a89e6: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_MCR, UART_MCR_TCR_TLR, tcrTlrBitVal);
700a89e8: 9807         	ldr	r0, [sp, #0x1c]
700a89ea: 3010         	adds	r0, #0x10
700a89ec: 9b06         	ldr	r3, [sp, #0x18]
700a89ee: 2140         	movs	r1, #0x40
700a89f0: 2206         	movs	r2, #0x6
700a89f2: f004 f86d    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x40da
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a89f6: 9807         	ldr	r0, [sp, #0x1c]
700a89f8: 300c         	adds	r0, #0xc
700a89fa: 9904         	ldr	r1, [sp, #0x10]
700a89fc: f005 faf8    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x55f0
700a8a00: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a8a02: 9807         	ldr	r0, [sp, #0x1c]
700a8a04: f002 f8cc    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #0x2198
700a8a08: 9902         	ldr	r1, [sp, #0x8]
700a8a0a: 9a03         	ldr	r2, [sp, #0xc]
700a8a0c: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a8a0e: 9807         	ldr	r0, [sp, #0x1c]
700a8a10: 3008         	adds	r0, #0x8
700a8a12: 9b05         	ldr	r3, [sp, #0x14]
700a8a14: f004 f85c    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x40b8
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a8a18: 9807         	ldr	r0, [sp, #0x1c]
700a8a1a: 300c         	adds	r0, #0xc
700a8a1c: 9904         	ldr	r1, [sp, #0x10]
700a8a1e: f005 fae7    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x55ce
; }
700a8a22: b008         	add	sp, #0x20
700a8a24: bd80         	pop	{r7, pc}
		...
700a8a2e: 0000         	movs	r0, r0

700a8a30 <prvInsertTimerInActiveList>:
;     {
700a8a30: b580         	push	{r7, lr}
700a8a32: b086         	sub	sp, #0x18
700a8a34: 9005         	str	r0, [sp, #0x14]
700a8a36: 9104         	str	r1, [sp, #0x10]
700a8a38: 9203         	str	r2, [sp, #0xc]
700a8a3a: 9302         	str	r3, [sp, #0x8]
700a8a3c: 2000         	movs	r0, #0x0
;         BaseType_t xProcessTimerNow = pdFALSE;
700a8a3e: 9001         	str	r0, [sp, #0x4]
;         listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
700a8a40: 9804         	ldr	r0, [sp, #0x10]
700a8a42: 9905         	ldr	r1, [sp, #0x14]
700a8a44: 6048         	str	r0, [r1, #0x4]
;         listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
700a8a46: 9805         	ldr	r0, [sp, #0x14]
700a8a48: 6100         	str	r0, [r0, #0x10]
;         if( xNextExpiryTime <= xTimeNow )
700a8a4a: 9804         	ldr	r0, [sp, #0x10]
700a8a4c: 9903         	ldr	r1, [sp, #0xc]
700a8a4e: 4288         	cmp	r0, r1
700a8a50: d816         	bhi	0x700a8a80 <prvInsertTimerInActiveList+0x50> @ imm = #0x2c
700a8a52: e7ff         	b	0x700a8a54 <prvInsertTimerInActiveList+0x24> @ imm = #-0x2
;             if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
700a8a54: 9803         	ldr	r0, [sp, #0xc]
700a8a56: 9902         	ldr	r1, [sp, #0x8]
700a8a58: 1a40         	subs	r0, r0, r1
700a8a5a: 9905         	ldr	r1, [sp, #0x14]
700a8a5c: 6989         	ldr	r1, [r1, #0x18]
700a8a5e: 4288         	cmp	r0, r1
700a8a60: d303         	blo	0x700a8a6a <prvInsertTimerInActiveList+0x3a> @ imm = #0x6
700a8a62: e7ff         	b	0x700a8a64 <prvInsertTimerInActiveList+0x34> @ imm = #-0x2
700a8a64: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
700a8a66: 9001         	str	r0, [sp, #0x4]
;             }
700a8a68: e009         	b	0x700a8a7e <prvInsertTimerInActiveList+0x4e> @ imm = #0x12
;                 vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
700a8a6a: f644 50b8    	movw	r0, #0x4db8
700a8a6e: f2c7 0008    	movt	r0, #0x7008
700a8a72: 6800         	ldr	r0, [r0]
700a8a74: 9905         	ldr	r1, [sp, #0x14]
700a8a76: 3104         	adds	r1, #0x4
700a8a78: f001 f892    	bl	0x700a9ba0 <vListInsert> @ imm = #0x1124
700a8a7c: e7ff         	b	0x700a8a7e <prvInsertTimerInActiveList+0x4e> @ imm = #-0x2
;         }
700a8a7e: e017         	b	0x700a8ab0 <prvInsertTimerInActiveList+0x80> @ imm = #0x2e
;             if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
700a8a80: 9803         	ldr	r0, [sp, #0xc]
700a8a82: 9902         	ldr	r1, [sp, #0x8]
700a8a84: 4288         	cmp	r0, r1
700a8a86: d208         	bhs	0x700a8a9a <prvInsertTimerInActiveList+0x6a> @ imm = #0x10
700a8a88: e7ff         	b	0x700a8a8a <prvInsertTimerInActiveList+0x5a> @ imm = #-0x2
700a8a8a: 9804         	ldr	r0, [sp, #0x10]
700a8a8c: 9902         	ldr	r1, [sp, #0x8]
700a8a8e: 4288         	cmp	r0, r1
700a8a90: d303         	blo	0x700a8a9a <prvInsertTimerInActiveList+0x6a> @ imm = #0x6
700a8a92: e7ff         	b	0x700a8a94 <prvInsertTimerInActiveList+0x64> @ imm = #-0x2
700a8a94: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
700a8a96: 9001         	str	r0, [sp, #0x4]
;             }
700a8a98: e009         	b	0x700a8aae <prvInsertTimerInActiveList+0x7e> @ imm = #0x12
;                 vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
700a8a9a: f644 50ac    	movw	r0, #0x4dac
700a8a9e: f2c7 0008    	movt	r0, #0x7008
700a8aa2: 6800         	ldr	r0, [r0]
700a8aa4: 9905         	ldr	r1, [sp, #0x14]
700a8aa6: 3104         	adds	r1, #0x4
700a8aa8: f001 f87a    	bl	0x700a9ba0 <vListInsert> @ imm = #0x10f4
700a8aac: e7ff         	b	0x700a8aae <prvInsertTimerInActiveList+0x7e> @ imm = #-0x2
700a8aae: e7ff         	b	0x700a8ab0 <prvInsertTimerInActiveList+0x80> @ imm = #-0x2
;         return xProcessTimerNow;
700a8ab0: 9801         	ldr	r0, [sp, #0x4]
700a8ab2: b006         	add	sp, #0x18
700a8ab4: bd80         	pop	{r7, pc}
		...
700a8abe: 0000         	movs	r0, r0

700a8ac0 <prvProcessTimerOrBlockTask>:
;     {
700a8ac0: b580         	push	{r7, lr}
700a8ac2: b084         	sub	sp, #0x10
700a8ac4: 9003         	str	r0, [sp, #0xc]
700a8ac6: 9102         	str	r1, [sp, #0x8]
;         vTaskSuspendAll();
700a8ac8: f005 fab2    	bl	0x700ae030 <vTaskSuspendAll> @ imm = #0x5564
700a8acc: 4668         	mov	r0, sp
;             xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
700a8ace: f003 f977    	bl	0x700abdc0 <prvSampleTimeNow> @ imm = #0x32ee
700a8ad2: 9001         	str	r0, [sp, #0x4]
;             if( xTimerListsWereSwitched == pdFALSE )
700a8ad4: 9800         	ldr	r0, [sp]
700a8ad6: bb88         	cbnz	r0, 0x700a8b3c <prvProcessTimerOrBlockTask+0x7c> @ imm = #0x62
700a8ad8: e7ff         	b	0x700a8ada <prvProcessTimerOrBlockTask+0x1a> @ imm = #-0x2
;                 if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
700a8ada: 9802         	ldr	r0, [sp, #0x8]
700a8adc: b960         	cbnz	r0, 0x700a8af8 <prvProcessTimerOrBlockTask+0x38> @ imm = #0x18
700a8ade: e7ff         	b	0x700a8ae0 <prvProcessTimerOrBlockTask+0x20> @ imm = #-0x2
700a8ae0: 9803         	ldr	r0, [sp, #0xc]
700a8ae2: 9901         	ldr	r1, [sp, #0x4]
700a8ae4: 4288         	cmp	r0, r1
700a8ae6: d807         	bhi	0x700a8af8 <prvProcessTimerOrBlockTask+0x38> @ imm = #0xe
700a8ae8: e7ff         	b	0x700a8aea <prvProcessTimerOrBlockTask+0x2a> @ imm = #-0x2
;                     ( void ) xTaskResumeAll();
700a8aea: f7f7 fed9    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0x824e
;                     prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
700a8aee: 9803         	ldr	r0, [sp, #0xc]
700a8af0: 9901         	ldr	r1, [sp, #0x4]
700a8af2: f000 fe15    	bl	0x700a9720 <prvProcessExpiredTimer> @ imm = #0xc2a
;                 }
700a8af6: e020         	b	0x700a8b3a <prvProcessTimerOrBlockTask+0x7a> @ imm = #0x40
;                     if( xListWasEmpty != pdFALSE )
700a8af8: 9802         	ldr	r0, [sp, #0x8]
700a8afa: b158         	cbz	r0, 0x700a8b14 <prvProcessTimerOrBlockTask+0x54> @ imm = #0x16
700a8afc: e7ff         	b	0x700a8afe <prvProcessTimerOrBlockTask+0x3e> @ imm = #-0x2
;                         xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
700a8afe: f644 50b8    	movw	r0, #0x4db8
700a8b02: f2c7 0008    	movt	r0, #0x7008
700a8b06: 6800         	ldr	r0, [r0]
700a8b08: 6800         	ldr	r0, [r0]
700a8b0a: fab0 f080    	clz	r0, r0
700a8b0e: 0940         	lsrs	r0, r0, #0x5
700a8b10: 9002         	str	r0, [sp, #0x8]
;                     }
700a8b12: e7ff         	b	0x700a8b14 <prvProcessTimerOrBlockTask+0x54> @ imm = #-0x2
;                     vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
700a8b14: f640 50f8    	movw	r0, #0xdf8
700a8b18: f2c7 000b    	movt	r0, #0x700b
700a8b1c: 6800         	ldr	r0, [r0]
700a8b1e: 9903         	ldr	r1, [sp, #0xc]
700a8b20: 9a01         	ldr	r2, [sp, #0x4]
700a8b22: 1a89         	subs	r1, r1, r2
700a8b24: 9a02         	ldr	r2, [sp, #0x8]
700a8b26: f001 fbbb    	bl	0x700aa2a0 <vQueueWaitForMessageRestricted> @ imm = #0x1776
;                     if( xTaskResumeAll() == pdFALSE )
700a8b2a: f7f7 feb9    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0x828e
700a8b2e: b910         	cbnz	r0, 0x700a8b36 <prvProcessTimerOrBlockTask+0x76> @ imm = #0x4
700a8b30: e7ff         	b	0x700a8b32 <prvProcessTimerOrBlockTask+0x72> @ imm = #-0x2
;                         portYIELD_WITHIN_API();
700a8b32: df00         	svc	#0x0
;                     }
700a8b34: e000         	b	0x700a8b38 <prvProcessTimerOrBlockTask+0x78> @ imm = #0x0
700a8b36: e7ff         	b	0x700a8b38 <prvProcessTimerOrBlockTask+0x78> @ imm = #-0x2
700a8b38: e7ff         	b	0x700a8b3a <prvProcessTimerOrBlockTask+0x7a> @ imm = #-0x2
;             }
700a8b3a: e002         	b	0x700a8b42 <prvProcessTimerOrBlockTask+0x82> @ imm = #0x4
;                 ( void ) xTaskResumeAll();
700a8b3c: f7f7 feb0    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0x82a0
700a8b40: e7ff         	b	0x700a8b42 <prvProcessTimerOrBlockTask+0x82> @ imm = #-0x2
;     }
700a8b42: b004         	add	sp, #0x10
700a8b44: bd80         	pop	{r7, pc}
		...
700a8b4e: 0000         	movs	r0, r0

700a8b50 <PowerClock_init>:
; {
700a8b50: b570         	push	{r4, r5, r6, lr}
700a8b52: b082         	sub	sp, #0x8
;     while(gSocModules[i]!=SOC_MODULES_END)
700a8b54: f640 514c    	movw	r1, #0xd4c
700a8b58: f2c7 010b    	movt	r1, #0x700b
700a8b5c: 6808         	ldr	r0, [r1]
700a8b5e: 1c42         	adds	r2, r0, #0x1
700a8b60: d013         	beq	0x700a8b8a <PowerClock_init+0x3a> @ imm = #0x26
700a8b62: 1d0c         	adds	r4, r1, #0x4
700a8b64: bf00         	nop
700a8b66: bf00         	nop
700a8b68: bf00         	nop
700a8b6a: bf00         	nop
700a8b6c: bf00         	nop
700a8b6e: bf00         	nop
;         status = SOC_moduleClockEnable(gSocModules[i], 1);
700a8b70: f04f 0101    	mov.w	r1, #0x1
700a8b74: f7ff fa7c    	bl	0x700a8070 <SOC_moduleClockEnable> @ imm = #-0xb08
;         DebugP_assertNoLog(status == SystemP_SUCCESS);
700a8b78: fab0 f080    	clz	r0, r0
700a8b7c: 0940         	lsrs	r0, r0, #0x5
700a8b7e: f006 fddf    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x6bbe
;     while(gSocModules[i]!=SOC_MODULES_END)
700a8b82: f854 0b04    	ldr	r0, [r4], #4
700a8b86: 1c41         	adds	r1, r0, #0x1
700a8b88: d1f2         	bne	0x700a8b70 <PowerClock_init+0x20> @ imm = #-0x1c
;     while(gSocModulesClockFrequency[i].moduleId!=SOC_MODULES_END)
700a8b8a: f640 4198    	movw	r1, #0xc98
700a8b8e: f2c7 010b    	movt	r1, #0x700b
700a8b92: 6808         	ldr	r0, [r1]
700a8b94: 1c42         	adds	r2, r0, #0x1
700a8b96: d01b         	beq	0x700a8bd0 <PowerClock_init+0x80> @ imm = #0x36
700a8b98: f101 0408    	add.w	r4, r1, #0x8
700a8b9c: 2600         	movs	r6, #0x0
700a8b9e: e00c         	b	0x700a8bba <PowerClock_init+0x6a> @ imm = #0x18
;             status = SOC_moduleSetClockFrequency(
700a8ba0: 461a         	mov	r2, r3
700a8ba2: 2300         	movs	r3, #0x0
700a8ba4: f7f5 fa5c    	bl	0x7009e060 <SOC_moduleSetClockFrequency> @ imm = #-0xab48
;         DebugP_assertNoLog(status == SystemP_SUCCESS);
700a8ba8: fab0 f080    	clz	r0, r0
700a8bac: 0940         	lsrs	r0, r0, #0x5
700a8bae: f006 fdc7    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x6b8e
;     while(gSocModulesClockFrequency[i].moduleId!=SOC_MODULES_END)
700a8bb2: 68a0         	ldr	r0, [r4, #0x8]
700a8bb4: 3410         	adds	r4, #0x10
700a8bb6: 1c41         	adds	r1, r0, #0x1
700a8bb8: d00a         	beq	0x700a8bd0 <PowerClock_init+0x80> @ imm = #0x14
;         if (gSocModulesClockFrequency[i].clkParentId != -1)
700a8bba: 6862         	ldr	r2, [r4, #0x4]
700a8bbc: f854 1c04    	ldr	r1, [r4, #-4]
700a8bc0: 6823         	ldr	r3, [r4]
;         if (gSocModulesClockFrequency[i].clkParentId != -1)
700a8bc2: 1c55         	adds	r5, r2, #0x1
700a8bc4: d0ec         	beq	0x700a8ba0 <PowerClock_init+0x50> @ imm = #-0x28
;             status = SOC_moduleSetClockFrequencyWithParent(
700a8bc6: e9cd 3600    	strd	r3, r6, [sp]
700a8bca: f7f5 fb29    	bl	0x7009e220 <SOC_moduleSetClockFrequencyWithParent> @ imm = #-0xa9ae
700a8bce: e7eb         	b	0x700a8ba8 <PowerClock_init+0x58> @ imm = #-0x2a
; }
700a8bd0: b002         	add	sp, #0x8
700a8bd2: bd70         	pop	{r4, r5, r6, pc}
		...

700a8be0 <CSL_udmapCppi5SetReturnPolicy>:
; {
700a8be0: b085         	sub	sp, #0x14
700a8be2: f8dd c018    	ldr.w	r12, [sp, #0x18]
700a8be6: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a8bea: 9004         	str	r0, [sp, #0x10]
700a8bec: 9103         	str	r1, [sp, #0xc]
700a8bee: 9202         	str	r2, [sp, #0x8]
700a8bf0: 9301         	str	r3, [sp, #0x4]
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700a8bf2: 9803         	ldr	r0, [sp, #0xc]
700a8bf4: 2803         	cmp	r0, #0x3
700a8bf6: d108         	bne	0x700a8c0a <CSL_udmapCppi5SetReturnPolicy+0x2a> @ imm = #0x10
700a8bf8: e7ff         	b	0x700a8bfa <CSL_udmapCppi5SetReturnPolicy+0x1a> @ imm = #-0x2
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETPOLICY, retPushPolicy )    |
700a8bfa: 9905         	ldr	r1, [sp, #0x14]
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETQ, retQnum ) ;
700a8bfc: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETPOLICY, retPushPolicy )    |
700a8c00: f361 4010    	bfi	r0, r1, #16, #1
;         ((CSL_UdmapCppi5TRPD *)pDesc)->retInfo =
700a8c04: 9904         	ldr	r1, [sp, #0x10]
700a8c06: 6088         	str	r0, [r1, #0x8]
;     }
700a8c08: e029         	b	0x700a8c5e <CSL_udmapCppi5SetReturnPolicy+0x7e> @ imm = #0x52
;         v = ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo2;
700a8c0a: 9804         	ldr	r0, [sp, #0x10]
700a8c0c: 6880         	ldr	r0, [r0, #0x8]
700a8c0e: 9000         	str	r0, [sp]
;         if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_MONO )
700a8c10: 9803         	ldr	r0, [sp, #0xc]
700a8c12: 2802         	cmp	r0, #0x2
700a8c14: d105         	bne	0x700a8c22 <CSL_udmapCppi5SetReturnPolicy+0x42> @ imm = #0xa
700a8c16: e7ff         	b	0x700a8c18 <CSL_udmapCppi5SetReturnPolicy+0x38> @ imm = #-0x2
;             v &= (CSL_UDMAP_CPPI5_PD_PKTINFO2_PKTTYPE_MASK | CSL_UDMAP_CPPI5_PD_PKTINFO2_DATA_OFFSET_MASK);
700a8c18: 9800         	ldr	r0, [sp]
700a8c1a: f36f 0011    	bfc	r0, #0, #18
700a8c1e: 9000         	str	r0, [sp]
;         }
700a8c20: e00b         	b	0x700a8c3a <CSL_udmapCppi5SetReturnPolicy+0x5a> @ imm = #0x16
;             v &= CSL_UDMAP_CPPI5_PD_PKTINFO2_PKTTYPE_MASK;
700a8c22: 9800         	ldr	r0, [sp]
700a8c24: f000 4078    	and	r0, r0, #0xf8000000
700a8c28: 9000         	str	r0, [sp]
;             v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPOLICY, retPolicy );
700a8c2a: 9802         	ldr	r0, [sp, #0x8]
700a8c2c: f000 0101    	and	r1, r0, #0x1
700a8c30: 9800         	ldr	r0, [sp]
700a8c32: ea40 4081    	orr.w	r0, r0, r1, lsl #18
700a8c36: 9000         	str	r0, [sp]
700a8c38: e7ff         	b	0x700a8c3a <CSL_udmapCppi5SetReturnPolicy+0x5a> @ imm = #-0x2
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700a8c3a: 9901         	ldr	r1, [sp, #0x4]
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPUSHPOLICY, retPushPolicy ) |
700a8c3c: 9a05         	ldr	r2, [sp, #0x14]
700a8c3e: f44f 3080    	mov.w	r0, #0x10000
700a8c42: ea00 4002    	and.w	r0, r0, r2, lsl #16
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700a8c46: f361 4051    	bfi	r0, r1, #17, #1
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETQ, retQnum );
700a8c4a: f8bd 1018    	ldrh.w	r1, [sp, #0x18]
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPUSHPOLICY, retPushPolicy ) |
700a8c4e: 4401         	add	r1, r0
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700a8c50: 9800         	ldr	r0, [sp]
700a8c52: 4308         	orrs	r0, r1
700a8c54: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo2 = v;
700a8c56: 9800         	ldr	r0, [sp]
700a8c58: 9904         	ldr	r1, [sp, #0x10]
700a8c5a: 6088         	str	r0, [r1, #0x8]
700a8c5c: e7ff         	b	0x700a8c5e <CSL_udmapCppi5SetReturnPolicy+0x7e> @ imm = #-0x2
; }
700a8c5e: b005         	add	sp, #0x14
700a8c60: 4770         	bx	lr
		...
700a8c6e: 0000         	movs	r0, r0

700a8c70 <SemaphoreP_pend>:
; {
700a8c70: b580         	push	{r7, lr}
700a8c72: b086         	sub	sp, #0x18
700a8c74: 9005         	str	r0, [sp, #0x14]
700a8c76: 9104         	str	r1, [sp, #0x10]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700a8c78: 9805         	ldr	r0, [sp, #0x14]
700a8c7a: 9003         	str	r0, [sp, #0xc]
700a8c7c: 2000         	movs	r0, #0x0
;     uint32_t isSemTaken = 0U;
700a8c7e: 9002         	str	r0, [sp, #0x8]
;     if(pSemaphore->isRecursiveMutex != 0U)
700a8c80: 9803         	ldr	r0, [sp, #0xc]
700a8c82: 6d40         	ldr	r0, [r0, #0x54]
700a8c84: b180         	cbz	r0, 0x700a8ca8 <SemaphoreP_pend+0x38> @ imm = #0x20
700a8c86: e7ff         	b	0x700a8c88 <SemaphoreP_pend+0x18> @ imm = #-0x2
;         if(HwiP_inISR() == 0U )
700a8c88: f005 fdba    	bl	0x700ae800 <HwiP_inISR> @ imm = #0x5b74
700a8c8c: b938         	cbnz	r0, 0x700a8c9e <SemaphoreP_pend+0x2e> @ imm = #0xe
700a8c8e: e7ff         	b	0x700a8c90 <SemaphoreP_pend+0x20> @ imm = #-0x2
;             isSemTaken =(uint32_t) xSemaphoreTakeRecursive(pSemaphore->semHndl, timeout);
700a8c90: 9803         	ldr	r0, [sp, #0xc]
700a8c92: 6d00         	ldr	r0, [r0, #0x50]
700a8c94: 9904         	ldr	r1, [sp, #0x10]
700a8c96: f002 fc2b    	bl	0x700ab4f0 <xQueueTakeMutexRecursive> @ imm = #0x2856
700a8c9a: 9002         	str	r0, [sp, #0x8]
;         }
700a8c9c: e003         	b	0x700a8ca6 <SemaphoreP_pend+0x36> @ imm = #0x6
700a8c9e: 2000         	movs	r0, #0x0
;             DebugP_assertNoLog(0);
700a8ca0: f006 fd4e    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x6a9c
700a8ca4: e7ff         	b	0x700a8ca6 <SemaphoreP_pend+0x36> @ imm = #-0x2
;     }
700a8ca6: e017         	b	0x700a8cd8 <SemaphoreP_pend+0x68> @ imm = #0x2e
;         if( HwiP_inISR() != 0U )
700a8ca8: f005 fdaa    	bl	0x700ae800 <HwiP_inISR> @ imm = #0x5b54
700a8cac: b160         	cbz	r0, 0x700a8cc8 <SemaphoreP_pend+0x58> @ imm = #0x18
700a8cae: e7ff         	b	0x700a8cb0 <SemaphoreP_pend+0x40> @ imm = #-0x2
700a8cb0: 2100         	movs	r1, #0x0
;             BaseType_t xHigherPriorityTaskWoken = 0;
700a8cb2: 9100         	str	r1, [sp]
;             isSemTaken = (uint32_t) xSemaphoreTakeFromISR(pSemaphore->semHndl, &xHigherPriorityTaskWoken);
700a8cb4: 9803         	ldr	r0, [sp, #0xc]
700a8cb6: 6d00         	ldr	r0, [r0, #0x50]
700a8cb8: 466a         	mov	r2, sp
700a8cba: f7fe fe19    	bl	0x700a78f0 <xQueueReceiveFromISR> @ imm = #-0x13ce
700a8cbe: 9002         	str	r0, [sp, #0x8]
;             portYIELD_FROM_ISR((uint32_t)xHigherPriorityTaskWoken);
700a8cc0: 9800         	ldr	r0, [sp]
700a8cc2: f004 fed5    	bl	0x700ada70 <vPortYeildFromISR> @ imm = #0x4daa
;         }
700a8cc6: e006         	b	0x700a8cd6 <SemaphoreP_pend+0x66> @ imm = #0xc
;             isSemTaken = (uint32_t) xSemaphoreTake(pSemaphore->semHndl, timeout);
700a8cc8: 9803         	ldr	r0, [sp, #0xc]
700a8cca: 6d00         	ldr	r0, [r0, #0x50]
700a8ccc: 9904         	ldr	r1, [sp, #0x10]
700a8cce: f7f6 fed7    	bl	0x7009fa80 <xQueueSemaphoreTake> @ imm = #-0x9252
700a8cd2: 9002         	str	r0, [sp, #0x8]
700a8cd4: e7ff         	b	0x700a8cd6 <SemaphoreP_pend+0x66> @ imm = #-0x2
700a8cd6: e7ff         	b	0x700a8cd8 <SemaphoreP_pend+0x68> @ imm = #-0x2
;     if(isSemTaken != 0U)
700a8cd8: 9802         	ldr	r0, [sp, #0x8]
700a8cda: b118         	cbz	r0, 0x700a8ce4 <SemaphoreP_pend+0x74> @ imm = #0x6
700a8cdc: e7ff         	b	0x700a8cde <SemaphoreP_pend+0x6e> @ imm = #-0x2
700a8cde: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700a8ce0: 9001         	str	r0, [sp, #0x4]
;     }
700a8ce2: e003         	b	0x700a8cec <SemaphoreP_pend+0x7c> @ imm = #0x6
700a8ce4: f06f 0001    	mvn	r0, #0x1
;         status = SystemP_TIMEOUT;
700a8ce8: 9001         	str	r0, [sp, #0x4]
700a8cea: e7ff         	b	0x700a8cec <SemaphoreP_pend+0x7c> @ imm = #-0x2
;     return status;
700a8cec: 9801         	ldr	r0, [sp, #0x4]
700a8cee: b006         	add	sp, #0x18
700a8cf0: bd80         	pop	{r7, pc}
		...
700a8cfe: 0000         	movs	r0, r0

700a8d00 <Udma_chPair>:
; {
700a8d00: b580         	push	{r7, lr}
700a8d02: b088         	sub	sp, #0x20
700a8d04: 9007         	str	r0, [sp, #0x1c]
700a8d06: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
700a8d08: 9006         	str	r0, [sp, #0x18]
;     drvHandle = chHandle->drvHandle;
700a8d0a: 9807         	ldr	r0, [sp, #0x1c]
700a8d0c: 6e80         	ldr	r0, [r0, #0x68]
700a8d0e: 9005         	str	r0, [sp, #0x14]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700a8d10: 9805         	ldr	r0, [sp, #0x14]
700a8d12: 6800         	ldr	r0, [r0]
700a8d14: 2801         	cmp	r0, #0x1
700a8d16: d107         	bne	0x700a8d28 <Udma_chPair+0x28> @ imm = #0xe
700a8d18: e7ff         	b	0x700a8d1a <Udma_chPair+0x1a> @ imm = #-0x2
;        ((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
700a8d1a: 9807         	ldr	r0, [sp, #0x1c]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700a8d1c: 7800         	ldrb	r0, [r0]
700a8d1e: 0740         	lsls	r0, r0, #0x1d
700a8d20: 2800         	cmp	r0, #0x0
700a8d22: d501         	bpl	0x700a8d28 <Udma_chPair+0x28> @ imm = #0x2
700a8d24: e7ff         	b	0x700a8d26 <Udma_chPair+0x26> @ imm = #-0x2
;     }
700a8d26: e029         	b	0x700a8d7c <Udma_chPair+0x7c> @ imm = #0x52
;         rmPairReq.nav_id = drvHandle->devIdPsil;
700a8d28: 9805         	ldr	r0, [sp, #0x14]
700a8d2a: f8b0 00e4    	ldrh.w	r0, [r0, #0xe4]
700a8d2e: 9002         	str	r0, [sp, #0x8]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a8d30: 9807         	ldr	r0, [sp, #0x1c]
700a8d32: 7800         	ldrb	r0, [r0]
700a8d34: 07c0         	lsls	r0, r0, #0x1f
700a8d36: b158         	cbz	r0, 0x700a8d50 <Udma_chPair+0x50> @ imm = #0x16
700a8d38: e7ff         	b	0x700a8d3a <Udma_chPair+0x3a> @ imm = #-0x2
;             rmPairReq.src_thread = chHandle->txChNum + drvHandle->udmapSrcThreadOffset;
700a8d3a: 9807         	ldr	r0, [sp, #0x1c]
700a8d3c: 6ec0         	ldr	r0, [r0, #0x6c]
700a8d3e: 9905         	ldr	r1, [sp, #0x14]
700a8d40: f8d1 10d4    	ldr.w	r1, [r1, #0xd4]
700a8d44: 4408         	add	r0, r1
700a8d46: 9003         	str	r0, [sp, #0xc]
;             rmPairReq.dst_thread = chHandle->peerThreadId;
700a8d48: 9807         	ldr	r0, [sp, #0x1c]
700a8d4a: 6fc0         	ldr	r0, [r0, #0x7c]
700a8d4c: 9004         	str	r0, [sp, #0x10]
;         }
700a8d4e: e00a         	b	0x700a8d66 <Udma_chPair+0x66> @ imm = #0x14
;             rmPairReq.src_thread = chHandle->peerThreadId;
700a8d50: 9807         	ldr	r0, [sp, #0x1c]
700a8d52: 6fc0         	ldr	r0, [r0, #0x7c]
700a8d54: 9003         	str	r0, [sp, #0xc]
;             rmPairReq.dst_thread = chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
700a8d56: 9807         	ldr	r0, [sp, #0x1c]
700a8d58: 6f00         	ldr	r0, [r0, #0x70]
700a8d5a: 9905         	ldr	r1, [sp, #0x14]
700a8d5c: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a8d60: 4408         	add	r0, r1
700a8d62: 9004         	str	r0, [sp, #0x10]
700a8d64: e7ff         	b	0x700a8d66 <Udma_chPair+0x66> @ imm = #-0x2
700a8d66: 4668         	mov	r0, sp
700a8d68: f04f 31ff    	mov.w	r1, #0xffffffff
;         retVal = Sciclient_rmPsilPair(&rmPairReq, UDMA_SCICLIENT_TIMEOUT);
700a8d6c: f002 f950    	bl	0x700ab010 <Sciclient_rmPsilPair> @ imm = #0x22a0
700a8d70: 9006         	str	r0, [sp, #0x18]
;         if(CSL_PASS != retVal)
700a8d72: 9806         	ldr	r0, [sp, #0x18]
700a8d74: b108         	cbz	r0, 0x700a8d7a <Udma_chPair+0x7a> @ imm = #0x2
700a8d76: e7ff         	b	0x700a8d78 <Udma_chPair+0x78> @ imm = #-0x2
;         }
700a8d78: e7ff         	b	0x700a8d7a <Udma_chPair+0x7a> @ imm = #-0x2
700a8d7a: e7ff         	b	0x700a8d7c <Udma_chPair+0x7c> @ imm = #-0x2
;     return (retVal);
700a8d7c: 9806         	ldr	r0, [sp, #0x18]
700a8d7e: b008         	add	sp, #0x20
700a8d80: bd80         	pop	{r7, pc}
		...
700a8d8e: 0000         	movs	r0, r0

700a8d90 <Udma_chUnpair>:
; {
700a8d90: b580         	push	{r7, lr}
700a8d92: b088         	sub	sp, #0x20
700a8d94: 9007         	str	r0, [sp, #0x1c]
700a8d96: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a8d98: 9006         	str	r0, [sp, #0x18]
;     drvHandle = chHandle->drvHandle;
700a8d9a: 9807         	ldr	r0, [sp, #0x1c]
700a8d9c: 6e80         	ldr	r0, [r0, #0x68]
700a8d9e: 9005         	str	r0, [sp, #0x14]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700a8da0: 9805         	ldr	r0, [sp, #0x14]
700a8da2: 6800         	ldr	r0, [r0]
700a8da4: 2801         	cmp	r0, #0x1
700a8da6: d107         	bne	0x700a8db8 <Udma_chUnpair+0x28> @ imm = #0xe
700a8da8: e7ff         	b	0x700a8daa <Udma_chUnpair+0x1a> @ imm = #-0x2
;        ((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
700a8daa: 9807         	ldr	r0, [sp, #0x1c]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700a8dac: 7800         	ldrb	r0, [r0]
700a8dae: 0740         	lsls	r0, r0, #0x1d
700a8db0: 2800         	cmp	r0, #0x0
700a8db2: d501         	bpl	0x700a8db8 <Udma_chUnpair+0x28> @ imm = #0x2
700a8db4: e7ff         	b	0x700a8db6 <Udma_chUnpair+0x26> @ imm = #-0x2
;     }
700a8db6: e029         	b	0x700a8e0c <Udma_chUnpair+0x7c> @ imm = #0x52
;         rmUnpairReq.nav_id = drvHandle->devIdPsil;
700a8db8: 9805         	ldr	r0, [sp, #0x14]
700a8dba: f8b0 00e4    	ldrh.w	r0, [r0, #0xe4]
700a8dbe: 9002         	str	r0, [sp, #0x8]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a8dc0: 9807         	ldr	r0, [sp, #0x1c]
700a8dc2: 7800         	ldrb	r0, [r0]
700a8dc4: 07c0         	lsls	r0, r0, #0x1f
700a8dc6: b158         	cbz	r0, 0x700a8de0 <Udma_chUnpair+0x50> @ imm = #0x16
700a8dc8: e7ff         	b	0x700a8dca <Udma_chUnpair+0x3a> @ imm = #-0x2
;             rmUnpairReq.src_thread = chHandle->txChNum + drvHandle->udmapSrcThreadOffset;
700a8dca: 9807         	ldr	r0, [sp, #0x1c]
700a8dcc: 6ec0         	ldr	r0, [r0, #0x6c]
700a8dce: 9905         	ldr	r1, [sp, #0x14]
700a8dd0: f8d1 10d4    	ldr.w	r1, [r1, #0xd4]
700a8dd4: 4408         	add	r0, r1
700a8dd6: 9003         	str	r0, [sp, #0xc]
;             rmUnpairReq.dst_thread = chHandle->peerThreadId;
700a8dd8: 9807         	ldr	r0, [sp, #0x1c]
700a8dda: 6fc0         	ldr	r0, [r0, #0x7c]
700a8ddc: 9004         	str	r0, [sp, #0x10]
;         }
700a8dde: e00a         	b	0x700a8df6 <Udma_chUnpair+0x66> @ imm = #0x14
;             rmUnpairReq.src_thread = chHandle->peerThreadId;
700a8de0: 9807         	ldr	r0, [sp, #0x1c]
700a8de2: 6fc0         	ldr	r0, [r0, #0x7c]
700a8de4: 9003         	str	r0, [sp, #0xc]
;             rmUnpairReq.dst_thread = chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
700a8de6: 9807         	ldr	r0, [sp, #0x1c]
700a8de8: 6f00         	ldr	r0, [r0, #0x70]
700a8dea: 9905         	ldr	r1, [sp, #0x14]
700a8dec: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a8df0: 4408         	add	r0, r1
700a8df2: 9004         	str	r0, [sp, #0x10]
700a8df4: e7ff         	b	0x700a8df6 <Udma_chUnpair+0x66> @ imm = #-0x2
700a8df6: 4668         	mov	r0, sp
700a8df8: f04f 31ff    	mov.w	r1, #0xffffffff
;         retVal = Sciclient_rmPsilUnpair(&rmUnpairReq, UDMA_SCICLIENT_TIMEOUT);
700a8dfc: f002 f938    	bl	0x700ab070 <Sciclient_rmPsilUnpair> @ imm = #0x2270
700a8e00: 9006         	str	r0, [sp, #0x18]
;         if(CSL_PASS != retVal)
700a8e02: 9806         	ldr	r0, [sp, #0x18]
700a8e04: b108         	cbz	r0, 0x700a8e0a <Udma_chUnpair+0x7a> @ imm = #0x2
700a8e06: e7ff         	b	0x700a8e08 <Udma_chUnpair+0x78> @ imm = #-0x2
;         }
700a8e08: e7ff         	b	0x700a8e0a <Udma_chUnpair+0x7a> @ imm = #-0x2
700a8e0a: e7ff         	b	0x700a8e0c <Udma_chUnpair+0x7c> @ imm = #-0x2
;     return (retVal);
700a8e0c: 9806         	ldr	r0, [sp, #0x18]
700a8e0e: b008         	add	sp, #0x20
700a8e10: bd80         	pop	{r7, pc}
		...
700a8e1e: 0000         	movs	r0, r0

700a8e20 <UART_moduleReset>:
; {
700a8e20: b580         	push	{r7, lr}
700a8e22: b088         	sub	sp, #0x20
700a8e24: 9007         	str	r0, [sp, #0x1c]
700a8e26: 2000         	movs	r0, #0x0
;     uint32_t startTicks, elapsedTicks = 0;
700a8e28: 9005         	str	r0, [sp, #0x14]
;     hUartInit = hUart->hUartInit;
700a8e2a: 9807         	ldr	r0, [sp, #0x1c]
700a8e2c: 6840         	ldr	r0, [r0, #0x4]
700a8e2e: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(hUart->baseAddr + UART_SYSC, UART_SYSC_SOFTRESET,
700a8e30: 9807         	ldr	r0, [sp, #0x1c]
700a8e32: 6800         	ldr	r0, [r0]
700a8e34: 3054         	adds	r0, #0x54
700a8e36: 2102         	movs	r1, #0x2
700a8e38: 2301         	movs	r3, #0x1
700a8e3a: 461a         	mov	r2, r3
700a8e3c: f003 fe48    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x3c90
;     startTicks = hUartInit->clockP_get();
700a8e40: 9804         	ldr	r0, [sp, #0x10]
700a8e42: 6d40         	ldr	r0, [r0, #0x54]
700a8e44: 4780         	blx	r0
700a8e46: 9006         	str	r0, [sp, #0x18]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700a8e48: e7ff         	b	0x700a8e4a <UART_moduleReset+0x2a> @ imm = #-0x2
700a8e4a: 9807         	ldr	r0, [sp, #0x1c]
700a8e4c: 6800         	ldr	r0, [r0]
700a8e4e: 3058         	adds	r0, #0x58
700a8e50: 2101         	movs	r1, #0x1
700a8e52: 2200         	movs	r2, #0x0
700a8e54: 9202         	str	r2, [sp, #0x8]
700a8e56: f004 fcbb    	bl	0x700ad7d0 <HW_RD_FIELD32_RAW> @ imm = #0x4976
700a8e5a: 4601         	mov	r1, r0
700a8e5c: 9802         	ldr	r0, [sp, #0x8]
700a8e5e: 9003         	str	r0, [sp, #0xc]
700a8e60: b989         	cbnz	r1, 0x700a8e86 <UART_moduleReset+0x66> @ imm = #0x22
700a8e62: e7ff         	b	0x700a8e64 <UART_moduleReset+0x44> @ imm = #-0x2
700a8e64: 9805         	ldr	r0, [sp, #0x14]
700a8e66: 9000         	str	r0, [sp]
700a8e68: 9804         	ldr	r0, [sp, #0x10]
700a8e6a: 6d82         	ldr	r2, [r0, #0x58]
700a8e6c: f44f 70fa    	mov.w	r0, #0x1f4
700a8e70: 2100         	movs	r1, #0x0
700a8e72: 9101         	str	r1, [sp, #0x4]
700a8e74: 4790         	blx	r2
700a8e76: 9900         	ldr	r1, [sp]
700a8e78: 4602         	mov	r2, r0
700a8e7a: 9801         	ldr	r0, [sp, #0x4]
700a8e7c: 4291         	cmp	r1, r2
700a8e7e: bf38         	it	lo
700a8e80: 2001         	movlo	r0, #0x1
700a8e82: 9003         	str	r0, [sp, #0xc]
700a8e84: e7ff         	b	0x700a8e86 <UART_moduleReset+0x66> @ imm = #-0x2
700a8e86: 9803         	ldr	r0, [sp, #0xc]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700a8e88: 07c0         	lsls	r0, r0, #0x1f
700a8e8a: b138         	cbz	r0, 0x700a8e9c <UART_moduleReset+0x7c> @ imm = #0xe
700a8e8c: e7ff         	b	0x700a8e8e <UART_moduleReset+0x6e> @ imm = #-0x2
;         elapsedTicks = hUartInit->clockP_get() - startTicks;
700a8e8e: 9804         	ldr	r0, [sp, #0x10]
700a8e90: 6d40         	ldr	r0, [r0, #0x54]
700a8e92: 4780         	blx	r0
700a8e94: 9906         	ldr	r1, [sp, #0x18]
700a8e96: 1a40         	subs	r0, r0, r1
700a8e98: 9005         	str	r0, [sp, #0x14]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700a8e9a: e7d6         	b	0x700a8e4a <UART_moduleReset+0x2a> @ imm = #-0x54
; }
700a8e9c: b008         	add	sp, #0x20
700a8e9e: bd80         	pop	{r7, pc}

700a8ea0 <CSL_bcdmaChanOpIsChanEnabled>:
; {
700a8ea0: b580         	push	{r7, lr}
700a8ea2: b086         	sub	sp, #0x18
700a8ea4: 9005         	str	r0, [sp, #0x14]
700a8ea6: 9104         	str	r1, [sp, #0x10]
700a8ea8: 9203         	str	r2, [sp, #0xc]
;     switch( chanType )
700a8eaa: 9804         	ldr	r0, [sp, #0x10]
700a8eac: 9001         	str	r0, [sp, #0x4]
700a8eae: b140         	cbz	r0, 0x700a8ec2 <CSL_bcdmaChanOpIsChanEnabled+0x22> @ imm = #0x10
700a8eb0: e7ff         	b	0x700a8eb2 <CSL_bcdmaChanOpIsChanEnabled+0x12> @ imm = #-0x2
700a8eb2: 9801         	ldr	r0, [sp, #0x4]
700a8eb4: 2801         	cmp	r0, #0x1
700a8eb6: d010         	beq	0x700a8eda <CSL_bcdmaChanOpIsChanEnabled+0x3a> @ imm = #0x20
700a8eb8: e7ff         	b	0x700a8eba <CSL_bcdmaChanOpIsChanEnabled+0x1a> @ imm = #-0x2
700a8eba: 9801         	ldr	r0, [sp, #0x4]
700a8ebc: 2802         	cmp	r0, #0x2
700a8ebe: d018         	beq	0x700a8ef2 <CSL_bcdmaChanOpIsChanEnabled+0x52> @ imm = #0x30
700a8ec0: e023         	b	0x700a8f0a <CSL_bcdmaChanOpIsChanEnabled+0x6a> @ imm = #0x46
;             regVal = CSL_REG32_FEXT( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_EN );
700a8ec2: 9805         	ldr	r0, [sp, #0x14]
700a8ec4: 6880         	ldr	r0, [r0, #0x8]
700a8ec6: 9903         	ldr	r1, [sp, #0xc]
700a8ec8: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8ecc: f04f 4100    	mov.w	r1, #0x80000000
700a8ed0: 221f         	movs	r2, #0x1f
700a8ed2: f004 fb3d    	bl	0x700ad550 <CSL_REG32_FEXT_RAW> @ imm = #0x467a
700a8ed6: 9002         	str	r0, [sp, #0x8]
;             break;
700a8ed8: e01a         	b	0x700a8f10 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x34
;             regVal = CSL_REG32_FEXT( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_EN );
700a8eda: 9805         	ldr	r0, [sp, #0x14]
700a8edc: 6900         	ldr	r0, [r0, #0x10]
700a8ede: 9903         	ldr	r1, [sp, #0xc]
700a8ee0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8ee4: f04f 4100    	mov.w	r1, #0x80000000
700a8ee8: 221f         	movs	r2, #0x1f
700a8eea: f004 fb31    	bl	0x700ad550 <CSL_REG32_FEXT_RAW> @ imm = #0x4662
700a8eee: 9002         	str	r0, [sp, #0x8]
;             break;
700a8ef0: e00e         	b	0x700a8f10 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x1c
;             regVal = CSL_REG32_FEXT( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_EN );
700a8ef2: 9805         	ldr	r0, [sp, #0x14]
700a8ef4: 6980         	ldr	r0, [r0, #0x18]
700a8ef6: 9903         	ldr	r1, [sp, #0xc]
700a8ef8: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8efc: f04f 4100    	mov.w	r1, #0x80000000
700a8f00: 221f         	movs	r2, #0x1f
700a8f02: f004 fb25    	bl	0x700ad550 <CSL_REG32_FEXT_RAW> @ imm = #0x464a
700a8f06: 9002         	str	r0, [sp, #0x8]
;             break;
700a8f08: e002         	b	0x700a8f10 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x4
700a8f0a: 2000         	movs	r0, #0x0
;             regVal = 0U;
700a8f0c: 9002         	str	r0, [sp, #0x8]
;             break;
700a8f0e: e7ff         	b	0x700a8f10 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #-0x2
;     return ((regVal == 1U) ? (bool)true : (bool)false);
700a8f10: 9802         	ldr	r0, [sp, #0x8]
700a8f12: 3801         	subs	r0, #0x1
700a8f14: fab0 f080    	clz	r0, r0
700a8f18: 0940         	lsrs	r0, r0, #0x5
700a8f1a: b006         	add	sp, #0x18
700a8f1c: bd80         	pop	{r7, pc}
700a8f1e: 0000         	movs	r0, r0

700a8f20 <CSL_bcdmaChanOpIsValidChanIdx>:
; {
700a8f20: b084         	sub	sp, #0x10
700a8f22: 9003         	str	r0, [sp, #0xc]
700a8f24: 9102         	str	r1, [sp, #0x8]
700a8f26: 9201         	str	r2, [sp, #0x4]
700a8f28: 2001         	movs	r0, #0x1
;     bool retVal = (bool)true;
700a8f2a: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if( chanType == CSL_BCDMA_CHAN_TYPE_BLOCK_COPY )
700a8f2e: 9802         	ldr	r0, [sp, #0x8]
700a8f30: b958         	cbnz	r0, 0x700a8f4a <CSL_bcdmaChanOpIsValidChanIdx+0x2a> @ imm = #0x16
700a8f32: e7ff         	b	0x700a8f34 <CSL_bcdmaChanOpIsValidChanIdx+0x14> @ imm = #-0x2
;         if( chanIdx > pCfg->bcChanCnt )
700a8f34: 9801         	ldr	r0, [sp, #0x4]
700a8f36: 9903         	ldr	r1, [sp, #0xc]
700a8f38: 6a49         	ldr	r1, [r1, #0x24]
700a8f3a: 4288         	cmp	r0, r1
700a8f3c: d904         	bls	0x700a8f48 <CSL_bcdmaChanOpIsValidChanIdx+0x28> @ imm = #0x8
700a8f3e: e7ff         	b	0x700a8f40 <CSL_bcdmaChanOpIsValidChanIdx+0x20> @ imm = #-0x2
700a8f40: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700a8f42: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700a8f46: e7ff         	b	0x700a8f48 <CSL_bcdmaChanOpIsValidChanIdx+0x28> @ imm = #-0x2
;     }
700a8f48: e023         	b	0x700a8f92 <CSL_bcdmaChanOpIsValidChanIdx+0x72> @ imm = #0x46
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700a8f4a: 9802         	ldr	r0, [sp, #0x8]
700a8f4c: 2802         	cmp	r0, #0x2
700a8f4e: d10b         	bne	0x700a8f68 <CSL_bcdmaChanOpIsValidChanIdx+0x48> @ imm = #0x16
700a8f50: e7ff         	b	0x700a8f52 <CSL_bcdmaChanOpIsValidChanIdx+0x32> @ imm = #-0x2
;         if( chanIdx > pCfg->splitRxChanCnt )
700a8f52: 9801         	ldr	r0, [sp, #0x4]
700a8f54: 9903         	ldr	r1, [sp, #0xc]
700a8f56: 6a89         	ldr	r1, [r1, #0x28]
700a8f58: 4288         	cmp	r0, r1
700a8f5a: d904         	bls	0x700a8f66 <CSL_bcdmaChanOpIsValidChanIdx+0x46> @ imm = #0x8
700a8f5c: e7ff         	b	0x700a8f5e <CSL_bcdmaChanOpIsValidChanIdx+0x3e> @ imm = #-0x2
700a8f5e: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700a8f60: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700a8f64: e7ff         	b	0x700a8f66 <CSL_bcdmaChanOpIsValidChanIdx+0x46> @ imm = #-0x2
;     }
700a8f66: e013         	b	0x700a8f90 <CSL_bcdmaChanOpIsValidChanIdx+0x70> @ imm = #0x26
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_TX )
700a8f68: 9802         	ldr	r0, [sp, #0x8]
700a8f6a: 2801         	cmp	r0, #0x1
700a8f6c: d10b         	bne	0x700a8f86 <CSL_bcdmaChanOpIsValidChanIdx+0x66> @ imm = #0x16
700a8f6e: e7ff         	b	0x700a8f70 <CSL_bcdmaChanOpIsValidChanIdx+0x50> @ imm = #-0x2
;         if( chanIdx > pCfg->splitTxChanCnt )
700a8f70: 9801         	ldr	r0, [sp, #0x4]
700a8f72: 9903         	ldr	r1, [sp, #0xc]
700a8f74: 6ac9         	ldr	r1, [r1, #0x2c]
700a8f76: 4288         	cmp	r0, r1
700a8f78: d904         	bls	0x700a8f84 <CSL_bcdmaChanOpIsValidChanIdx+0x64> @ imm = #0x8
700a8f7a: e7ff         	b	0x700a8f7c <CSL_bcdmaChanOpIsValidChanIdx+0x5c> @ imm = #-0x2
700a8f7c: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700a8f7e: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700a8f82: e7ff         	b	0x700a8f84 <CSL_bcdmaChanOpIsValidChanIdx+0x64> @ imm = #-0x2
;     }
700a8f84: e003         	b	0x700a8f8e <CSL_bcdmaChanOpIsValidChanIdx+0x6e> @ imm = #0x6
700a8f86: 2000         	movs	r0, #0x0
;         retVal = (bool)false;
700a8f88: f88d 0003    	strb.w	r0, [sp, #0x3]
700a8f8c: e7ff         	b	0x700a8f8e <CSL_bcdmaChanOpIsValidChanIdx+0x6e> @ imm = #-0x2
700a8f8e: e7ff         	b	0x700a8f90 <CSL_bcdmaChanOpIsValidChanIdx+0x70> @ imm = #-0x2
700a8f90: e7ff         	b	0x700a8f92 <CSL_bcdmaChanOpIsValidChanIdx+0x72> @ imm = #-0x2
;     return retVal;
700a8f92: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a8f96: f000 0001    	and	r0, r0, #0x1
700a8f9a: b004         	add	sp, #0x10
700a8f9c: 4770         	bx	lr
700a8f9e: 0000         	movs	r0, r0

700a8fa0 <CSL_bcdmaMapChanIdx>:
; {
700a8fa0: b084         	sub	sp, #0x10
700a8fa2: 9003         	str	r0, [sp, #0xc]
700a8fa4: 9102         	str	r1, [sp, #0x8]
700a8fa6: 9201         	str	r2, [sp, #0x4]
;     if( chanIdx < pCfg->bcChanCnt )
700a8fa8: 9802         	ldr	r0, [sp, #0x8]
700a8faa: 9903         	ldr	r1, [sp, #0xc]
700a8fac: 6a49         	ldr	r1, [r1, #0x24]
700a8fae: 4288         	cmp	r0, r1
700a8fb0: d206         	bhs	0x700a8fc0 <CSL_bcdmaMapChanIdx+0x20> @ imm = #0xc
700a8fb2: e7ff         	b	0x700a8fb4 <CSL_bcdmaMapChanIdx+0x14> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_BLOCK_COPY;
700a8fb4: 9901         	ldr	r1, [sp, #0x4]
700a8fb6: 2000         	movs	r0, #0x0
700a8fb8: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx;
700a8fba: 9802         	ldr	r0, [sp, #0x8]
700a8fbc: 9000         	str	r0, [sp]
;     }
700a8fbe: e02b         	b	0x700a9018 <CSL_bcdmaMapChanIdx+0x78> @ imm = #0x56
;     else if( chanIdx < (pCfg->bcChanCnt + pCfg->splitTxChanCnt) )
700a8fc0: 9802         	ldr	r0, [sp, #0x8]
700a8fc2: 9a03         	ldr	r2, [sp, #0xc]
700a8fc4: 6a51         	ldr	r1, [r2, #0x24]
700a8fc6: 6ad2         	ldr	r2, [r2, #0x2c]
700a8fc8: 4411         	add	r1, r2
700a8fca: 4288         	cmp	r0, r1
700a8fcc: d209         	bhs	0x700a8fe2 <CSL_bcdmaMapChanIdx+0x42> @ imm = #0x12
700a8fce: e7ff         	b	0x700a8fd0 <CSL_bcdmaMapChanIdx+0x30> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_SPLIT_TX;
700a8fd0: 9901         	ldr	r1, [sp, #0x4]
700a8fd2: 2001         	movs	r0, #0x1
700a8fd4: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx - pCfg->bcChanCnt;
700a8fd6: 9802         	ldr	r0, [sp, #0x8]
700a8fd8: 9903         	ldr	r1, [sp, #0xc]
700a8fda: 6a49         	ldr	r1, [r1, #0x24]
700a8fdc: 1a40         	subs	r0, r0, r1
700a8fde: 9000         	str	r0, [sp]
;     }
700a8fe0: e019         	b	0x700a9016 <CSL_bcdmaMapChanIdx+0x76> @ imm = #0x32
;     else if( chanIdx < (pCfg->bcChanCnt + pCfg->splitTxChanCnt + pCfg->splitRxChanCnt) )
700a8fe2: 9802         	ldr	r0, [sp, #0x8]
700a8fe4: 9b03         	ldr	r3, [sp, #0xc]
700a8fe6: 6a59         	ldr	r1, [r3, #0x24]
700a8fe8: 6a9a         	ldr	r2, [r3, #0x28]
700a8fea: 6adb         	ldr	r3, [r3, #0x2c]
700a8fec: 4419         	add	r1, r3
700a8fee: 4411         	add	r1, r2
700a8ff0: 4288         	cmp	r0, r1
700a8ff2: d20b         	bhs	0x700a900c <CSL_bcdmaMapChanIdx+0x6c> @ imm = #0x16
700a8ff4: e7ff         	b	0x700a8ff6 <CSL_bcdmaMapChanIdx+0x56> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_SPLIT_RX;
700a8ff6: 9901         	ldr	r1, [sp, #0x4]
700a8ff8: 2002         	movs	r0, #0x2
700a8ffa: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx - pCfg->bcChanCnt - pCfg->splitTxChanCnt;
700a8ffc: 9802         	ldr	r0, [sp, #0x8]
700a8ffe: 9903         	ldr	r1, [sp, #0xc]
700a9000: 6a4a         	ldr	r2, [r1, #0x24]
700a9002: 6ac9         	ldr	r1, [r1, #0x2c]
700a9004: 1a80         	subs	r0, r0, r2
700a9006: 1a40         	subs	r0, r0, r1
700a9008: 9000         	str	r0, [sp]
;     }
700a900a: e003         	b	0x700a9014 <CSL_bcdmaMapChanIdx+0x74> @ imm = #0x6
700a900c: f04f 30ff    	mov.w	r0, #0xffffffff
;         base0chanIdx = CSL_BCDMA_INVALID_CHANNEL_INDEX;
700a9010: 9000         	str	r0, [sp]
700a9012: e7ff         	b	0x700a9014 <CSL_bcdmaMapChanIdx+0x74> @ imm = #-0x2
700a9014: e7ff         	b	0x700a9016 <CSL_bcdmaMapChanIdx+0x76> @ imm = #-0x2
700a9016: e7ff         	b	0x700a9018 <CSL_bcdmaMapChanIdx+0x78> @ imm = #-0x2
;     return base0chanIdx;
700a9018: 9800         	ldr	r0, [sp]
700a901a: b004         	add	sp, #0x10
700a901c: 4770         	bx	lr
700a901e: 0000         	movs	r0, r0

700a9020 <ClockP_getTimeUsec>:
; {
700a9020: b580         	push	{r7, lr}
700a9022: b08a         	sub	sp, #0x28
700a9024: 2000         	movs	r0, #0x0
;     uint64_t ts = 0U;
700a9026: 9009         	str	r0, [sp, #0x24]
700a9028: 9008         	str	r0, [sp, #0x20]
;     do {
700a902a: e7ff         	b	0x700a902c <ClockP_getTimeUsec+0xc> @ imm = #-0x2
;         ticks1 = gClockCtrl.ticks;
700a902c: f644 4090    	movw	r0, #0x4c90
700a9030: f2c7 0008    	movt	r0, #0x7008
700a9034: 9001         	str	r0, [sp, #0x4]
700a9036: 6801         	ldr	r1, [r0]
700a9038: 6842         	ldr	r2, [r0, #0x4]
700a903a: 9205         	str	r2, [sp, #0x14]
700a903c: 9104         	str	r1, [sp, #0x10]
;         timerCount = ClockP_getTimerCount(gClockCtrl.timerBaseAddr);
700a903e: 6ac0         	ldr	r0, [r0, #0x2c]
700a9040: f004 ffb6    	bl	0x700adfb0 <ClockP_getTimerCount> @ imm = #0x4f6c
700a9044: 9901         	ldr	r1, [sp, #0x4]
700a9046: 9007         	str	r0, [sp, #0x1c]
;         ticks2 = gClockCtrl.ticks;
700a9048: 6808         	ldr	r0, [r1]
700a904a: 6849         	ldr	r1, [r1, #0x4]
700a904c: 9103         	str	r1, [sp, #0xc]
700a904e: 9002         	str	r0, [sp, #0x8]
;     } while (ticks1 != ticks2);
700a9050: e7ff         	b	0x700a9052 <ClockP_getTimeUsec+0x32> @ imm = #-0x2
700a9052: 9804         	ldr	r0, [sp, #0x10]
700a9054: 9905         	ldr	r1, [sp, #0x14]
700a9056: 9a02         	ldr	r2, [sp, #0x8]
700a9058: 9b03         	ldr	r3, [sp, #0xc]
700a905a: 4059         	eors	r1, r3
700a905c: ea80 0002    	eor.w	r0, r0, r2
700a9060: 4308         	orrs	r0, r1
700a9062: 2800         	cmp	r0, #0x0
700a9064: d1e2         	bne	0x700a902c <ClockP_getTimeUsec+0xc> @ imm = #-0x3c
700a9066: e7ff         	b	0x700a9068 <ClockP_getTimeUsec+0x48> @ imm = #-0x2
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700a9068: 9a02         	ldr	r2, [sp, #0x8]
700a906a: 9803         	ldr	r0, [sp, #0xc]
700a906c: f644 4190    	movw	r1, #0x4c90
700a9070: f2c7 0108    	movt	r1, #0x7008
700a9074: 688b         	ldr	r3, [r1, #0x8]
;                 (uint64_t)(((timerCount - gClockCtrl.timerReloadCount)*gClockCtrl.usecPerTick)/(MAX_TIMER_COUNT_VALUE - gClockCtrl.timerReloadCount))
700a9076: f8d1 c030    	ldr.w	r12, [r1, #0x30]
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700a907a: fb00 f103    	mul	r1, r0, r3
;                 (uint64_t)(((timerCount - gClockCtrl.timerReloadCount)*gClockCtrl.usecPerTick)/(MAX_TIMER_COUNT_VALUE - gClockCtrl.timerReloadCount))
700a907e: 9807         	ldr	r0, [sp, #0x1c]
700a9080: eba0 000c    	sub.w	r0, r0, r12
700a9084: 4358         	muls	r0, r3, r0
700a9086: ea6f 0c0c    	mvn.w	r12, r12
700a908a: fbb0 f0fc    	udiv	r0, r0, r12
;              + (uint64_t) ( /* convert timer count to usecs */
700a908e: fbe2 0103    	umlal	r0, r1, r2, r3
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700a9092: 9109         	str	r1, [sp, #0x24]
700a9094: 9008         	str	r0, [sp, #0x20]
;     return (ts);
700a9096: 9808         	ldr	r0, [sp, #0x20]
700a9098: 9909         	ldr	r1, [sp, #0x24]
700a909a: b00a         	add	sp, #0x28
700a909c: bd80         	pop	{r7, pc}
700a909e: 0000         	movs	r0, r0

700a90a0 <UART_readData>:
; {
700a90a0: b580         	push	{r7, lr}
700a90a2: b086         	sub	sp, #0x18
700a90a4: 9005         	str	r0, [sp, #0x14]
700a90a6: 9104         	str	r1, [sp, #0x10]
700a90a8: 2000         	movs	r0, #0x0
;     uint8_t             readIn = 0;
700a90aa: f88d 000f    	strb.w	r0, [sp, #0xf]
;     uint32_t             rdSize = size;
700a90ae: 9804         	ldr	r0, [sp, #0x10]
700a90b0: 9001         	str	r0, [sp, #0x4]
;     readSuccess = UART_getChar(hUart->baseAddr, &readIn);
700a90b2: 9805         	ldr	r0, [sp, #0x14]
700a90b4: 6800         	ldr	r0, [r0]
700a90b6: f10d 010f    	add.w	r1, sp, #0xf
700a90ba: f001 fb91    	bl	0x700aa7e0 <UART_getChar> @ imm = #0x1722
700a90be: 9002         	str	r0, [sp, #0x8]
;     while ((rdSize != 0U) && (readSuccess != 0U))
700a90c0: e7ff         	b	0x700a90c2 <UART_readData+0x22> @ imm = #-0x2
700a90c2: 9901         	ldr	r1, [sp, #0x4]
700a90c4: 2000         	movs	r0, #0x0
700a90c6: 9000         	str	r0, [sp]
700a90c8: b131         	cbz	r1, 0x700a90d8 <UART_readData+0x38> @ imm = #0xc
700a90ca: e7ff         	b	0x700a90cc <UART_readData+0x2c> @ imm = #-0x2
700a90cc: 9802         	ldr	r0, [sp, #0x8]
700a90ce: 2800         	cmp	r0, #0x0
700a90d0: bf18         	it	ne
700a90d2: 2001         	movne	r0, #0x1
700a90d4: 9000         	str	r0, [sp]
700a90d6: e7ff         	b	0x700a90d8 <UART_readData+0x38> @ imm = #-0x2
700a90d8: 9800         	ldr	r0, [sp]
;     while ((rdSize != 0U) && (readSuccess != 0U))
700a90da: 07c0         	lsls	r0, r0, #0x1f
700a90dc: b1e0         	cbz	r0, 0x700a9118 <UART_readData+0x78> @ imm = #0x38
700a90de: e7ff         	b	0x700a90e0 <UART_readData+0x40> @ imm = #-0x2
;         *(uint8_t *)hUart->readBuf = readIn;
700a90e0: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a90e4: 9905         	ldr	r1, [sp, #0x14]
700a90e6: 6949         	ldr	r1, [r1, #0x14]
700a90e8: 7008         	strb	r0, [r1]
;         hUart->readBuf = (uint8_t *)hUart->readBuf + 1U;
700a90ea: 9905         	ldr	r1, [sp, #0x14]
700a90ec: 6948         	ldr	r0, [r1, #0x14]
700a90ee: 3001         	adds	r0, #0x1
700a90f0: 6148         	str	r0, [r1, #0x14]
;         hUart->readCount++;
700a90f2: 9905         	ldr	r1, [sp, #0x14]
700a90f4: 6988         	ldr	r0, [r1, #0x18]
700a90f6: 3001         	adds	r0, #0x1
700a90f8: 6188         	str	r0, [r1, #0x18]
;         rdSize--;
700a90fa: 9801         	ldr	r0, [sp, #0x4]
700a90fc: 3801         	subs	r0, #0x1
700a90fe: 9001         	str	r0, [sp, #0x4]
;         if (rdSize != 0U)
700a9100: 9801         	ldr	r0, [sp, #0x4]
700a9102: b140         	cbz	r0, 0x700a9116 <UART_readData+0x76> @ imm = #0x10
700a9104: e7ff         	b	0x700a9106 <UART_readData+0x66> @ imm = #-0x2
;             readSuccess = UART_getChar(hUart->baseAddr, &readIn);
700a9106: 9805         	ldr	r0, [sp, #0x14]
700a9108: 6800         	ldr	r0, [r0]
700a910a: f10d 010f    	add.w	r1, sp, #0xf
700a910e: f001 fb67    	bl	0x700aa7e0 <UART_getChar> @ imm = #0x16ce
700a9112: 9002         	str	r0, [sp, #0x8]
;         }
700a9114: e7ff         	b	0x700a9116 <UART_readData+0x76> @ imm = #-0x2
;     while ((rdSize != 0U) && (readSuccess != 0U))
700a9116: e7d4         	b	0x700a90c2 <UART_readData+0x22> @ imm = #-0x58
;     return (rdSize);
700a9118: 9801         	ldr	r0, [sp, #0x4]
700a911a: b006         	add	sp, #0x18
700a911c: bd80         	pop	{r7, pc}
700a911e: 0000         	movs	r0, r0

700a9120 <_DebugP_assert>:
; {
700a9120: b5b0         	push	{r4, r5, r7, lr}
700a9122: b08e         	sub	sp, #0x38
700a9124: f8dd c048    	ldr.w	r12, [sp, #0x48]
700a9128: 900d         	str	r0, [sp, #0x34]
700a912a: 910c         	str	r1, [sp, #0x30]
700a912c: 920b         	str	r2, [sp, #0x2c]
700a912e: 930a         	str	r3, [sp, #0x28]
;     if(expression==0)
700a9130: 980d         	ldr	r0, [sp, #0x34]
700a9132: bb88         	cbnz	r0, 0x700a9198 <_DebugP_assert+0x78> @ imm = #0x62
700a9134: e7ff         	b	0x700a9136 <_DebugP_assert+0x16> @ imm = #-0x2
700a9136: 2001         	movs	r0, #0x1
;         volatile uint32_t assert_loop = 1;
700a9138: 9004         	str	r0, [sp, #0x10]
700a913a: 9009         	str	r0, [sp, #0x24]
;         uint64_t curTime = ClockP_getTimeUsec();
700a913c: f7ff ff70    	bl	0x700a9020 <ClockP_getTimeUsec> @ imm = #-0x120
700a9140: 9107         	str	r1, [sp, #0x1c]
700a9142: 9006         	str	r0, [sp, #0x18]
;         DebugP_log("ASSERT: %d.%ds: %s:%s:%d: %s failed !!!\r\n",
700a9144: 9806         	ldr	r0, [sp, #0x18]
700a9146: 9907         	ldr	r1, [sp, #0x1c]
700a9148: f244 2240    	movw	r2, #0x4240
700a914c: f2c0 020f    	movt	r2, #0xf
700a9150: 2300         	movs	r3, #0x0
700a9152: f004 eaa0    	blx	0x700ad694 <__aeabi_uldivmod> @ imm = #0x4540
700a9156: 4603         	mov	r3, r0
700a9158: 9804         	ldr	r0, [sp, #0x10]
700a915a: 9305         	str	r3, [sp, #0x14]
700a915c: 4613         	mov	r3, r2
700a915e: 9a05         	ldr	r2, [sp, #0x14]
700a9160: 990c         	ldr	r1, [sp, #0x30]
700a9162: f8dd e02c    	ldr.w	lr, [sp, #0x2c]
700a9166: 9c0a         	ldr	r4, [sp, #0x28]
700a9168: 9d12         	ldr	r5, [sp, #0x48]
700a916a: 46ec         	mov	r12, sp
700a916c: f8cc 500c    	str.w	r5, [r12, #0xc]
700a9170: f8cc 4008    	str.w	r4, [r12, #0x8]
700a9174: f8cc e004    	str.w	lr, [r12, #0x4]
700a9178: f8cc 1000    	str.w	r1, [r12]
700a917c: f64f 6178    	movw	r1, #0xfe78
700a9180: f2c7 010a    	movt	r1, #0x700a
700a9184: f7ff f814    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #-0xfd8
;         (void) HwiP_disable();
700a9188: f005 ee1a    	blx	0x700aedc0 <HwiP_disable> @ imm = #0x5c34
;         while(assert_loop!= 0U)
700a918c: e7ff         	b	0x700a918e <_DebugP_assert+0x6e> @ imm = #-0x2
700a918e: 9809         	ldr	r0, [sp, #0x24]
700a9190: b108         	cbz	r0, 0x700a9196 <_DebugP_assert+0x76> @ imm = #0x2
700a9192: e7ff         	b	0x700a9194 <_DebugP_assert+0x74> @ imm = #-0x2
700a9194: e7fb         	b	0x700a918e <_DebugP_assert+0x6e> @ imm = #-0xa
;     }
700a9196: e7ff         	b	0x700a9198 <_DebugP_assert+0x78> @ imm = #-0x2
; }
700a9198: b00e         	add	sp, #0x38
700a919a: bdb0         	pop	{r4, r5, r7, pc}
700a919c: 0000         	movs	r0, r0
700a919e: 0000         	movs	r0, r0

700a91a0 <UART_Params_init>:
; {
700a91a0: b082         	sub	sp, #0x8
700a91a2: 9001         	str	r0, [sp, #0x4]
;     if(prms != NULL)
700a91a4: 9801         	ldr	r0, [sp, #0x4]
700a91a6: b3b0         	cbz	r0, 0x700a9216 <UART_Params_init+0x76> @ imm = #0x6c
700a91a8: e7ff         	b	0x700a91aa <UART_Params_init+0xa> @ imm = #-0x2
;         prms->baudRate           = 115200U;
700a91aa: 9901         	ldr	r1, [sp, #0x4]
700a91ac: f44f 30e1    	mov.w	r0, #0x1c200
700a91b0: 6008         	str	r0, [r1]
;         prms->dataLength         = UART_LEN_8;
700a91b2: 9901         	ldr	r1, [sp, #0x4]
700a91b4: 2003         	movs	r0, #0x3
700a91b6: 6048         	str	r0, [r1, #0x4]
;         prms->stopBits           = UART_STOPBITS_1;
700a91b8: 9901         	ldr	r1, [sp, #0x4]
700a91ba: 2000         	movs	r0, #0x0
700a91bc: 9000         	str	r0, [sp]
700a91be: 6088         	str	r0, [r1, #0x8]
;         prms->parityType         = UART_PARITY_NONE;
700a91c0: 9901         	ldr	r1, [sp, #0x4]
700a91c2: 60c8         	str	r0, [r1, #0xc]
;         prms->readMode           = UART_TRANSFER_MODE_BLOCKING;
700a91c4: 9901         	ldr	r1, [sp, #0x4]
700a91c6: 6108         	str	r0, [r1, #0x10]
;         prms->readReturnMode     = UART_READ_RETURN_MODE_FULL;
700a91c8: 9901         	ldr	r1, [sp, #0x4]
700a91ca: 6148         	str	r0, [r1, #0x14]
;         prms->writeMode          = UART_TRANSFER_MODE_BLOCKING;
700a91cc: 9901         	ldr	r1, [sp, #0x4]
700a91ce: 6188         	str	r0, [r1, #0x18]
;         prms->readCallbackFxn    = NULL;
700a91d0: 9901         	ldr	r1, [sp, #0x4]
700a91d2: 61c8         	str	r0, [r1, #0x1c]
;         prms->writeCallbackFxn   = NULL;
700a91d4: 9901         	ldr	r1, [sp, #0x4]
700a91d6: 6208         	str	r0, [r1, #0x20]
;         prms->hwFlowControl      = FALSE;
700a91d8: 9901         	ldr	r1, [sp, #0x4]
700a91da: 6248         	str	r0, [r1, #0x24]
;         prms->hwFlowControlThr   = UART_RXTRIGLVL_16;
700a91dc: 9a01         	ldr	r2, [sp, #0x4]
700a91de: 2110         	movs	r1, #0x10
700a91e0: 6291         	str	r1, [r2, #0x28]
;         prms->intrNum            = 0xFFFF;
700a91e2: 9a01         	ldr	r2, [sp, #0x4]
700a91e4: f64f 71ff    	movw	r1, #0xffff
700a91e8: 6311         	str	r1, [r2, #0x30]
;         prms->transferMode       = UART_CONFIG_MODE_INTERRUPT;
700a91ea: 9a01         	ldr	r2, [sp, #0x4]
700a91ec: 2101         	movs	r1, #0x1
700a91ee: 62d1         	str	r1, [r2, #0x2c]
;         prms->intrPriority       = 4U;
700a91f0: 9a01         	ldr	r2, [sp, #0x4]
700a91f2: 2104         	movs	r1, #0x4
700a91f4: f882 1034    	strb.w	r1, [r2, #0x34]
;         prms->skipIntrReg        = FALSE;
700a91f8: 9901         	ldr	r1, [sp, #0x4]
700a91fa: 6388         	str	r0, [r1, #0x38]
;         prms->uartDmaIndex       = -1;
700a91fc: 9a01         	ldr	r2, [sp, #0x4]
700a91fe: f04f 31ff    	mov.w	r1, #0xffffffff
700a9202: 63d1         	str	r1, [r2, #0x3c]
;         prms->operMode           = UART_OPER_MODE_16X;
700a9204: 9901         	ldr	r1, [sp, #0x4]
700a9206: 6408         	str	r0, [r1, #0x40]
;         prms->rxTrigLvl          = UART_RXTRIGLVL_8;
700a9208: 9901         	ldr	r1, [sp, #0x4]
700a920a: 2008         	movs	r0, #0x8
700a920c: 6448         	str	r0, [r1, #0x44]
;         prms->txTrigLvl          = UART_TXTRIGLVL_32;
700a920e: 9901         	ldr	r1, [sp, #0x4]
700a9210: 2020         	movs	r0, #0x20
700a9212: 6488         	str	r0, [r1, #0x48]
;     }
700a9214: e7ff         	b	0x700a9216 <UART_Params_init+0x76> @ imm = #-0x2
; }
700a9216: b002         	add	sp, #0x8
700a9218: 4770         	bx	lr
700a921a: 0000         	movs	r0, r0
700a921c: 0000         	movs	r0, r0
700a921e: 0000         	movs	r0, r0

700a9220 <main_task>:
; {
700a9220: b5b0         	push	{r4, r5, r7, lr}
700a9222: b086         	sub	sp, #0x18
;    printf("Starting Thread-Metric tests...\r\n");
700a9224: f240 0116    	movw	r1, #0x16
700a9228: 2001         	movs	r0, #0x1
700a922a: f2c7 010b    	movt	r1, #0x700b
700a922e: 2501         	movs	r5, #0x1
700a9230: f7fe ffbe    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #-0x1084
;    test_interrupt_handler = tm_interrupt_processing_handler;
700a9234: f64d 6021    	movw	r0, #0xde21
700a9238: f640 51b8    	movw	r1, #0xdb8
700a923c: f2c7 000a    	movt	r0, #0x700a
700a9240: ac01         	add	r4, sp, #0x4
700a9242: f2c7 010b    	movt	r1, #0x700b
700a9246: 6008         	str	r0, [r1]
;    HwiP_Params_init(&hwiParams);
700a9248: 4620         	mov	r0, r4
700a924a: f005 f8b1    	bl	0x700ae3b0 <HwiP_Params_init> @ imm = #0x5162
;    hwiParams.callback = tm_interrupt_handler; /* Interrupt handler */
700a924e: f64d 61e1    	movw	r1, #0xdee1
700a9252: 200a         	movs	r0, #0xa
700a9254: f2c7 010a    	movt	r1, #0x700a
;    hwiParams.priority = 1;                    /* Set a valid priority (lower is higher priority) */
700a9258: f8ad 5012    	strh.w	r5, [sp, #0x12]
;    hwiParams.intNum = SOFTWARE_INTERRUPT_ID;  /* Chosen interrupt ID */
700a925c: e9cd 0101    	strd	r0, r1, [sp, #4]
;    if (HwiP_construct(&hwiObj, &hwiParams) != SystemP_SUCCESS)
700a9260: f644 40f0    	movw	r0, #0x4cf0
700a9264: f2c7 0008    	movt	r0, #0x7008
700a9268: 4621         	mov	r1, r4
700a926a: f005 f8b9    	bl	0x700ae3e0 <HwiP_construct> @ imm = #0x5172
700a926e: b140         	cbz	r0, 0x700a9282 <main_task+0x62> @ imm = #0x10
;       printf("Failed to register interrupt\r\n");
700a9270: f240 111a    	movw	r1, #0x11a
700a9274: 2001         	movs	r0, #0x1
700a9276: f2c7 010b    	movt	r1, #0x700b
700a927a: f7fe ff99    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #-0x10ce
700a927e: bf00         	nop
;       while (1)
700a9280: e7fe         	b	0x700a9280 <main_task+0x60> @ imm = #-0x4
;    HwiP_enableInt(SOFTWARE_INTERRUPT_ID);
700a9282: 200a         	movs	r0, #0xa
700a9284: f004 ffec    	bl	0x700ae260 <HwiP_enableInt> @ imm = #0x4fd8
;    HwiP_enable();
700a9288: f005 edaa    	blx	0x700aede0 <HwiP_enable> @ imm = #0x5b54
;    main_sync();
700a928c: f003 fdd0    	bl	0x700ace30 <main_sync>  @ imm = #0x3ba0
;    vTaskDelete(NULL);
700a9290: 2000         	movs	r0, #0x0
700a9292: f7fb fb35    	bl	0x700a4900 <vTaskDelete> @ imm = #-0x4996
; }
700a9296: b006         	add	sp, #0x18
700a9298: bdb0         	pop	{r4, r5, r7, pc}
700a929a: 0000         	movs	r0, r0
700a929c: 0000         	movs	r0, r0
700a929e: 0000         	movs	r0, r0

700a92a0 <xTimerCreateTimerTask>:
;     {
700a92a0: b580         	push	{r7, lr}
700a92a2: b088         	sub	sp, #0x20
700a92a4: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
700a92a6: 9007         	str	r0, [sp, #0x1c]
;         prvCheckForValidListAndQueue();
700a92a8: f7fd fe6a    	bl	0x700a6f80 <prvCheckForValidListAndQueue> @ imm = #-0x232c
;         if( xTimerQueue != NULL )
700a92ac: f640 50f8    	movw	r0, #0xdf8
700a92b0: f2c7 000b    	movt	r0, #0x700b
700a92b4: 6800         	ldr	r0, [r0]
700a92b6: b358         	cbz	r0, 0x700a9310 <xTimerCreateTimerTask+0x70> @ imm = #0x56
700a92b8: e7ff         	b	0x700a92ba <xTimerCreateTimerTask+0x1a> @ imm = #-0x2
700a92ba: 2000         	movs	r0, #0x0
;                     StaticTask_t * pxTimerTaskTCBBuffer = NULL;
700a92bc: 9003         	str	r0, [sp, #0xc]
700a92be: 9006         	str	r0, [sp, #0x18]
;                     StackType_t * pxTimerTaskStackBuffer = NULL;
700a92c0: 9005         	str	r0, [sp, #0x14]
700a92c2: a806         	add	r0, sp, #0x18
700a92c4: a905         	add	r1, sp, #0x14
700a92c6: aa04         	add	r2, sp, #0x10
;                     vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
700a92c8: f003 ff1a    	bl	0x700ad100 <vApplicationGetTimerTaskMemory> @ imm = #0x3e34
700a92cc: 9b03         	ldr	r3, [sp, #0xc]
;                                                           ulTimerTaskStackSize,
700a92ce: 9a04         	ldr	r2, [sp, #0x10]
;                                                           pxTimerTaskStackBuffer,
700a92d0: 9805         	ldr	r0, [sp, #0x14]
;                                                           pxTimerTaskTCBBuffer );
700a92d2: f8dd c018    	ldr.w	r12, [sp, #0x18]
;                     xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,
700a92d6: 4669         	mov	r1, sp
700a92d8: f8c1 c008    	str.w	r12, [r1, #0x8]
700a92dc: 6048         	str	r0, [r1, #0x4]
700a92de: 201f         	movs	r0, #0x1f
700a92e0: 6008         	str	r0, [r1]
700a92e2: f64d 1071    	movw	r0, #0xd971
700a92e6: f2c7 000a    	movt	r0, #0x700a
700a92ea: f640 01ce    	movw	r1, #0x8ce
700a92ee: f2c7 010b    	movt	r1, #0x700b
700a92f2: f000 fa55    	bl	0x700a97a0 <xTaskCreateStatic> @ imm = #0x4aa
700a92f6: 4601         	mov	r1, r0
700a92f8: f640 50fc    	movw	r0, #0xdfc
700a92fc: f2c7 000b    	movt	r0, #0x700b
700a9300: 6001         	str	r1, [r0]
;                     if( xTimerTaskHandle != NULL )
700a9302: 6800         	ldr	r0, [r0]
700a9304: b118         	cbz	r0, 0x700a930e <xTimerCreateTimerTask+0x6e> @ imm = #0x6
700a9306: e7ff         	b	0x700a9308 <xTimerCreateTimerTask+0x68> @ imm = #-0x2
700a9308: 2001         	movs	r0, #0x1
;                         xReturn = pdPASS;
700a930a: 9007         	str	r0, [sp, #0x1c]
;                     }
700a930c: e7ff         	b	0x700a930e <xTimerCreateTimerTask+0x6e> @ imm = #-0x2
;         }
700a930e: e000         	b	0x700a9312 <xTimerCreateTimerTask+0x72> @ imm = #0x0
700a9310: e7ff         	b	0x700a9312 <xTimerCreateTimerTask+0x72> @ imm = #-0x2
;         return xReturn;
700a9312: 9807         	ldr	r0, [sp, #0x1c]
700a9314: b008         	add	sp, #0x20
700a9316: bd80         	pop	{r7, pc}
		...

700a9320 <CSL_bcdmaChanOpClearError>:
; {
700a9320: b580         	push	{r7, lr}
700a9322: b086         	sub	sp, #0x18
700a9324: 9005         	str	r0, [sp, #0x14]
700a9326: 9104         	str	r1, [sp, #0x10]
700a9328: 9203         	str	r2, [sp, #0xc]
700a932a: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a932c: 9002         	str	r0, [sp, #0x8]
;     switch( chanType )
700a932e: 9804         	ldr	r0, [sp, #0x10]
700a9330: 9001         	str	r0, [sp, #0x4]
700a9332: b140         	cbz	r0, 0x700a9346 <CSL_bcdmaChanOpClearError+0x26> @ imm = #0x10
700a9334: e7ff         	b	0x700a9336 <CSL_bcdmaChanOpClearError+0x16> @ imm = #-0x2
700a9336: 9801         	ldr	r0, [sp, #0x4]
700a9338: 2801         	cmp	r0, #0x1
700a933a: d00f         	beq	0x700a935c <CSL_bcdmaChanOpClearError+0x3c> @ imm = #0x1e
700a933c: e7ff         	b	0x700a933e <CSL_bcdmaChanOpClearError+0x1e> @ imm = #-0x2
700a933e: 9801         	ldr	r0, [sp, #0x4]
700a9340: 2802         	cmp	r0, #0x2
700a9342: d016         	beq	0x700a9372 <CSL_bcdmaChanOpClearError+0x52> @ imm = #0x2c
700a9344: e020         	b	0x700a9388 <CSL_bcdmaChanOpClearError+0x68> @ imm = #0x40
;             CSL_REG32_FINS( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700a9346: 9805         	ldr	r0, [sp, #0x14]
700a9348: 6880         	ldr	r0, [r0, #0x8]
700a934a: 9903         	ldr	r1, [sp, #0xc]
700a934c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a9350: 2101         	movs	r1, #0x1
700a9352: 2300         	movs	r3, #0x0
700a9354: 461a         	mov	r2, r3
700a9356: f003 f9c3    	bl	0x700ac6e0 <CSL_REG32_FINS_RAW> @ imm = #0x3386
;             break;
700a935a: e019         	b	0x700a9390 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x32
;             CSL_REG32_FINS( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700a935c: 9805         	ldr	r0, [sp, #0x14]
700a935e: 6900         	ldr	r0, [r0, #0x10]
700a9360: 9903         	ldr	r1, [sp, #0xc]
700a9362: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a9366: 2101         	movs	r1, #0x1
700a9368: 2300         	movs	r3, #0x0
700a936a: 461a         	mov	r2, r3
700a936c: f003 f9b8    	bl	0x700ac6e0 <CSL_REG32_FINS_RAW> @ imm = #0x3370
;             break;
700a9370: e00e         	b	0x700a9390 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x1c
;             CSL_REG32_FINS( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700a9372: 9805         	ldr	r0, [sp, #0x14]
700a9374: 6980         	ldr	r0, [r0, #0x18]
700a9376: 9903         	ldr	r1, [sp, #0xc]
700a9378: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a937c: 2101         	movs	r1, #0x1
700a937e: 2300         	movs	r3, #0x0
700a9380: 461a         	mov	r2, r3
700a9382: f003 f9ad    	bl	0x700ac6e0 <CSL_REG32_FINS_RAW> @ imm = #0x335a
;             break;
700a9386: e003         	b	0x700a9390 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x6
700a9388: f06f 0001    	mvn	r0, #0x1
;             retVal = CSL_EBADARGS;
700a938c: 9002         	str	r0, [sp, #0x8]
;             break;
700a938e: e7ff         	b	0x700a9390 <CSL_bcdmaChanOpClearError+0x70> @ imm = #-0x2
;     return retVal;
700a9390: 9802         	ldr	r0, [sp, #0x8]
700a9392: b006         	add	sp, #0x18
700a9394: bd80         	pop	{r7, pc}
		...
700a939e: 0000         	movs	r0, r0

700a93a0 <CSL_bcdmaDoChanOp>:
; {
700a93a0: b580         	push	{r7, lr}
700a93a2: b088         	sub	sp, #0x20
700a93a4: 9007         	str	r0, [sp, #0x1c]
700a93a6: 9106         	str	r1, [sp, #0x18]
700a93a8: 9205         	str	r2, [sp, #0x14]
700a93aa: 9304         	str	r3, [sp, #0x10]
700a93ac: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t retVal = CSL_EFAIL;
700a93b0: 9003         	str	r0, [sp, #0xc]
;     if( pCfg == NULL )
700a93b2: 9807         	ldr	r0, [sp, #0x1c]
700a93b4: b920         	cbnz	r0, 0x700a93c0 <CSL_bcdmaDoChanOp+0x20> @ imm = #0x8
700a93b6: e7ff         	b	0x700a93b8 <CSL_bcdmaDoChanOp+0x18> @ imm = #-0x2
700a93b8: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a93bc: 9003         	str	r0, [sp, #0xc]
;     }
700a93be: e027         	b	0x700a9410 <CSL_bcdmaDoChanOp+0x70> @ imm = #0x4e
;         if( (pCfg->bcChanCnt == (uint32_t)0U) || (pCfg->splitTxChanCnt == (uint32_t)0U) || (pCfg->splitRxChanCnt == (uint32_t)0U) ) {
700a93c0: 9807         	ldr	r0, [sp, #0x1c]
700a93c2: 6a40         	ldr	r0, [r0, #0x24]
700a93c4: b140         	cbz	r0, 0x700a93d8 <CSL_bcdmaDoChanOp+0x38> @ imm = #0x10
700a93c6: e7ff         	b	0x700a93c8 <CSL_bcdmaDoChanOp+0x28> @ imm = #-0x2
700a93c8: 9807         	ldr	r0, [sp, #0x1c]
700a93ca: 6ac0         	ldr	r0, [r0, #0x2c]
700a93cc: b120         	cbz	r0, 0x700a93d8 <CSL_bcdmaDoChanOp+0x38> @ imm = #0x8
700a93ce: e7ff         	b	0x700a93d0 <CSL_bcdmaDoChanOp+0x30> @ imm = #-0x2
700a93d0: 9807         	ldr	r0, [sp, #0x1c]
700a93d2: 6a80         	ldr	r0, [r0, #0x28]
700a93d4: b920         	cbnz	r0, 0x700a93e0 <CSL_bcdmaDoChanOp+0x40> @ imm = #0x8
700a93d6: e7ff         	b	0x700a93d8 <CSL_bcdmaDoChanOp+0x38> @ imm = #-0x2
;             CSL_bcdmaGetCfg( pCfg );
700a93d8: 9807         	ldr	r0, [sp, #0x1c]
700a93da: f7ff f9c1    	bl	0x700a8760 <CSL_bcdmaGetCfg> @ imm = #-0xc7e
;         }
700a93de: e7ff         	b	0x700a93e0 <CSL_bcdmaDoChanOp+0x40> @ imm = #-0x2
;         base0chanIdx = CSL_bcdmaMapChanIdx( pCfg, chanIdx, &chanType );
700a93e0: 9807         	ldr	r0, [sp, #0x1c]
700a93e2: 9905         	ldr	r1, [sp, #0x14]
700a93e4: aa01         	add	r2, sp, #0x4
700a93e6: f7ff fddb    	bl	0x700a8fa0 <CSL_bcdmaMapChanIdx> @ imm = #-0x44a
700a93ea: 9002         	str	r0, [sp, #0x8]
;         if( base0chanIdx != CSL_BCDMA_INVALID_CHANNEL_INDEX )
700a93ec: 9802         	ldr	r0, [sp, #0x8]
700a93ee: 3001         	adds	r0, #0x1
700a93f0: b168         	cbz	r0, 0x700a940e <CSL_bcdmaDoChanOp+0x6e> @ imm = #0x1a
700a93f2: e7ff         	b	0x700a93f4 <CSL_bcdmaDoChanOp+0x54> @ imm = #-0x2
;             retVal = CSL_bcdmaChanOp( pCfg, chanOp, chanType, base0chanIdx, pOpData );
700a93f4: 9807         	ldr	r0, [sp, #0x1c]
700a93f6: 9906         	ldr	r1, [sp, #0x18]
700a93f8: 9a01         	ldr	r2, [sp, #0x4]
700a93fa: 9b02         	ldr	r3, [sp, #0x8]
700a93fc: f8dd c010    	ldr.w	r12, [sp, #0x10]
700a9400: 46ee         	mov	lr, sp
700a9402: f8ce c000    	str.w	r12, [lr]
700a9406: f7f6 fd73    	bl	0x7009fef0 <CSL_bcdmaChanOp> @ imm = #-0x951a
700a940a: 9003         	str	r0, [sp, #0xc]
;         }
700a940c: e7ff         	b	0x700a940e <CSL_bcdmaDoChanOp+0x6e> @ imm = #-0x2
700a940e: e7ff         	b	0x700a9410 <CSL_bcdmaDoChanOp+0x70> @ imm = #-0x2
;     return retVal;
700a9410: 9803         	ldr	r0, [sp, #0xc]
700a9412: b008         	add	sp, #0x20
700a9414: bd80         	pop	{r7, pc}
		...
700a941e: 0000         	movs	r0, r0

700a9420 <Udma_chGetCqRingHandle>:
; {
700a9420: b085         	sub	sp, #0x14
700a9422: 9004         	str	r0, [sp, #0x10]
700a9424: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a9426: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandle     cqRing = (Udma_RingHandle) NULL_PTR;
700a9428: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a942a: 9804         	ldr	r0, [sp, #0x10]
700a942c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a942e: 9800         	ldr	r0, [sp]
700a9430: b150         	cbz	r0, 0x700a9448 <Udma_chGetCqRingHandle+0x28> @ imm = #0x14
700a9432: e7ff         	b	0x700a9434 <Udma_chGetCqRingHandle+0x14> @ imm = #-0x2
700a9434: 9800         	ldr	r0, [sp]
700a9436: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a943a: f64a 31cd    	movw	r1, #0xabcd
700a943e: f6ca 31dc    	movt	r1, #0xabdc
700a9442: 4288         	cmp	r0, r1
700a9444: d004         	beq	0x700a9450 <Udma_chGetCqRingHandle+0x30> @ imm = #0x8
700a9446: e7ff         	b	0x700a9448 <Udma_chGetCqRingHandle+0x28> @ imm = #-0x2
700a9448: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a944c: 9003         	str	r0, [sp, #0xc]
;     }
700a944e: e7ff         	b	0x700a9450 <Udma_chGetCqRingHandle+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9450: 9803         	ldr	r0, [sp, #0xc]
700a9452: b9a8         	cbnz	r0, 0x700a9480 <Udma_chGetCqRingHandle+0x60> @ imm = #0x2a
700a9454: e7ff         	b	0x700a9456 <Udma_chGetCqRingHandle+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a9456: 9800         	ldr	r0, [sp]
700a9458: 6e80         	ldr	r0, [r0, #0x68]
700a945a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a945c: 9801         	ldr	r0, [sp, #0x4]
700a945e: b150         	cbz	r0, 0x700a9476 <Udma_chGetCqRingHandle+0x56> @ imm = #0x14
700a9460: e7ff         	b	0x700a9462 <Udma_chGetCqRingHandle+0x42> @ imm = #-0x2
700a9462: 9801         	ldr	r0, [sp, #0x4]
700a9464: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a9468: f64a 31cd    	movw	r1, #0xabcd
700a946c: f6ca 31dc    	movt	r1, #0xabdc
700a9470: 4288         	cmp	r0, r1
700a9472: d004         	beq	0x700a947e <Udma_chGetCqRingHandle+0x5e> @ imm = #0x8
700a9474: e7ff         	b	0x700a9476 <Udma_chGetCqRingHandle+0x56> @ imm = #-0x2
700a9476: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a947a: 9003         	str	r0, [sp, #0xc]
;         }
700a947c: e7ff         	b	0x700a947e <Udma_chGetCqRingHandle+0x5e> @ imm = #-0x2
;     }
700a947e: e7ff         	b	0x700a9480 <Udma_chGetCqRingHandle+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9480: 9803         	ldr	r0, [sp, #0xc]
700a9482: b928         	cbnz	r0, 0x700a9490 <Udma_chGetCqRingHandle+0x70> @ imm = #0xa
700a9484: e7ff         	b	0x700a9486 <Udma_chGetCqRingHandle+0x66> @ imm = #-0x2
;         cqRing = (Udma_RingHandle) chHandleInt->cqRing;
700a9486: 9800         	ldr	r0, [sp]
700a9488: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a948c: 9002         	str	r0, [sp, #0x8]
;     }
700a948e: e7ff         	b	0x700a9490 <Udma_chGetCqRingHandle+0x70> @ imm = #-0x2
;     return (cqRing);
700a9490: 9802         	ldr	r0, [sp, #0x8]
700a9492: b005         	add	sp, #0x14
700a9494: 4770         	bx	lr
		...
700a949e: 0000         	movs	r0, r0

700a94a0 <Udma_chGetFqRingHandle>:
; {
700a94a0: b085         	sub	sp, #0x14
700a94a2: 9004         	str	r0, [sp, #0x10]
700a94a4: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a94a6: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandle     fqRing = (Udma_RingHandle) NULL_PTR;
700a94a8: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a94aa: 9804         	ldr	r0, [sp, #0x10]
700a94ac: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a94ae: 9800         	ldr	r0, [sp]
700a94b0: b150         	cbz	r0, 0x700a94c8 <Udma_chGetFqRingHandle+0x28> @ imm = #0x14
700a94b2: e7ff         	b	0x700a94b4 <Udma_chGetFqRingHandle+0x14> @ imm = #-0x2
700a94b4: 9800         	ldr	r0, [sp]
700a94b6: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a94ba: f64a 31cd    	movw	r1, #0xabcd
700a94be: f6ca 31dc    	movt	r1, #0xabdc
700a94c2: 4288         	cmp	r0, r1
700a94c4: d004         	beq	0x700a94d0 <Udma_chGetFqRingHandle+0x30> @ imm = #0x8
700a94c6: e7ff         	b	0x700a94c8 <Udma_chGetFqRingHandle+0x28> @ imm = #-0x2
700a94c8: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a94cc: 9003         	str	r0, [sp, #0xc]
;     }
700a94ce: e7ff         	b	0x700a94d0 <Udma_chGetFqRingHandle+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a94d0: 9803         	ldr	r0, [sp, #0xc]
700a94d2: b9a8         	cbnz	r0, 0x700a9500 <Udma_chGetFqRingHandle+0x60> @ imm = #0x2a
700a94d4: e7ff         	b	0x700a94d6 <Udma_chGetFqRingHandle+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a94d6: 9800         	ldr	r0, [sp]
700a94d8: 6e80         	ldr	r0, [r0, #0x68]
700a94da: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a94dc: 9801         	ldr	r0, [sp, #0x4]
700a94de: b150         	cbz	r0, 0x700a94f6 <Udma_chGetFqRingHandle+0x56> @ imm = #0x14
700a94e0: e7ff         	b	0x700a94e2 <Udma_chGetFqRingHandle+0x42> @ imm = #-0x2
700a94e2: 9801         	ldr	r0, [sp, #0x4]
700a94e4: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a94e8: f64a 31cd    	movw	r1, #0xabcd
700a94ec: f6ca 31dc    	movt	r1, #0xabdc
700a94f0: 4288         	cmp	r0, r1
700a94f2: d004         	beq	0x700a94fe <Udma_chGetFqRingHandle+0x5e> @ imm = #0x8
700a94f4: e7ff         	b	0x700a94f6 <Udma_chGetFqRingHandle+0x56> @ imm = #-0x2
700a94f6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a94fa: 9003         	str	r0, [sp, #0xc]
;         }
700a94fc: e7ff         	b	0x700a94fe <Udma_chGetFqRingHandle+0x5e> @ imm = #-0x2
;     }
700a94fe: e7ff         	b	0x700a9500 <Udma_chGetFqRingHandle+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9500: 9803         	ldr	r0, [sp, #0xc]
700a9502: b928         	cbnz	r0, 0x700a9510 <Udma_chGetFqRingHandle+0x70> @ imm = #0xa
700a9504: e7ff         	b	0x700a9506 <Udma_chGetFqRingHandle+0x66> @ imm = #-0x2
;         fqRing = (Udma_RingHandle) chHandleInt->fqRing;
700a9506: 9800         	ldr	r0, [sp]
700a9508: f8d0 0080    	ldr.w	r0, [r0, #0x80]
700a950c: 9002         	str	r0, [sp, #0x8]
;     }
700a950e: e7ff         	b	0x700a9510 <Udma_chGetFqRingHandle+0x70> @ imm = #-0x2
;     return (fqRing);
700a9510: 9802         	ldr	r0, [sp, #0x8]
700a9512: b005         	add	sp, #0x14
700a9514: 4770         	bx	lr
		...
700a951e: 0000         	movs	r0, r0

700a9520 <prvGetExpectedIdleTime>:
; static TickType_t prvGetExpectedIdleTime(void) {
700a9520: b082         	sub	sp, #0x8
700a9522: 2000         	movs	r0, #0x0
;   UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
700a9524: 9000         	str	r0, [sp]
;     if (uxTopReadyPriority > tskIDLE_PRIORITY) {
700a9526: f640 50dc    	movw	r0, #0xddc
700a952a: f2c7 000b    	movt	r0, #0x700b
700a952e: 6800         	ldr	r0, [r0]
700a9530: b118         	cbz	r0, 0x700a953a <prvGetExpectedIdleTime+0x1a> @ imm = #0x6
700a9532: e7ff         	b	0x700a9534 <prvGetExpectedIdleTime+0x14> @ imm = #-0x2
700a9534: 2001         	movs	r0, #0x1
;       uxHigherPriorityReadyTasks = pdTRUE;
700a9536: 9000         	str	r0, [sp]
;     }
700a9538: e7ff         	b	0x700a953a <prvGetExpectedIdleTime+0x1a> @ imm = #-0x2
;   if (pxCurrentTCB->uxPriority > tskIDLE_PRIORITY) {
700a953a: f640 50ac    	movw	r0, #0xdac
700a953e: f2c7 000b    	movt	r0, #0x700b
700a9542: 6800         	ldr	r0, [r0]
700a9544: 6ac0         	ldr	r0, [r0, #0x2c]
700a9546: b118         	cbz	r0, 0x700a9550 <prvGetExpectedIdleTime+0x30> @ imm = #0x6
700a9548: e7ff         	b	0x700a954a <prvGetExpectedIdleTime+0x2a> @ imm = #-0x2
700a954a: 2000         	movs	r0, #0x0
;     xReturn = 0;
700a954c: 9001         	str	r0, [sp, #0x4]
;   } else if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) >
700a954e: e01f         	b	0x700a9590 <prvGetExpectedIdleTime+0x70> @ imm = #0x3e
700a9550: f244 40f8    	movw	r0, #0x44f8
700a9554: f2c7 0008    	movt	r0, #0x7008
700a9558: 6800         	ldr	r0, [r0]
700a955a: 2802         	cmp	r0, #0x2
700a955c: d303         	blo	0x700a9566 <prvGetExpectedIdleTime+0x46> @ imm = #0x6
700a955e: e7ff         	b	0x700a9560 <prvGetExpectedIdleTime+0x40> @ imm = #-0x2
700a9560: 2000         	movs	r0, #0x0
;     xReturn = 0;
700a9562: 9001         	str	r0, [sp, #0x4]
;   } else if (uxHigherPriorityReadyTasks != pdFALSE) {
700a9564: e013         	b	0x700a958e <prvGetExpectedIdleTime+0x6e> @ imm = #0x26
700a9566: 9800         	ldr	r0, [sp]
700a9568: b118         	cbz	r0, 0x700a9572 <prvGetExpectedIdleTime+0x52> @ imm = #0x6
700a956a: e7ff         	b	0x700a956c <prvGetExpectedIdleTime+0x4c> @ imm = #-0x2
700a956c: 2000         	movs	r0, #0x0
;     xReturn = 0;
700a956e: 9001         	str	r0, [sp, #0x4]
;   } else {
700a9570: e00c         	b	0x700a958c <prvGetExpectedIdleTime+0x6c> @ imm = #0x18
;     xReturn = xNextTaskUnblockTime - xTickCount;
700a9572: f640 50e4    	movw	r0, #0xde4
700a9576: f2c7 000b    	movt	r0, #0x700b
700a957a: 6800         	ldr	r0, [r0]
700a957c: f640 51f4    	movw	r1, #0xdf4
700a9580: f2c7 010b    	movt	r1, #0x700b
700a9584: 6809         	ldr	r1, [r1]
700a9586: 1a40         	subs	r0, r0, r1
700a9588: 9001         	str	r0, [sp, #0x4]
700a958a: e7ff         	b	0x700a958c <prvGetExpectedIdleTime+0x6c> @ imm = #-0x2
700a958c: e7ff         	b	0x700a958e <prvGetExpectedIdleTime+0x6e> @ imm = #-0x2
700a958e: e7ff         	b	0x700a9590 <prvGetExpectedIdleTime+0x70> @ imm = #-0x2
;   return xReturn;
700a9590: 9801         	ldr	r0, [sp, #0x4]
700a9592: b002         	add	sp, #0x8
700a9594: 4770         	bx	lr
		...
700a959e: 0000         	movs	r0, r0

700a95a0 <ClockP_usleep>:
; {
700a95a0: b580         	push	{r7, lr}
700a95a2: b088         	sub	sp, #0x20
700a95a4: 9007         	str	r0, [sp, #0x1c]
;     curTime = ClockP_getTimeUsec();
700a95a6: f7ff fd3b    	bl	0x700a9020 <ClockP_getTimeUsec> @ imm = #-0x58a
700a95aa: 9105         	str	r1, [sp, #0x14]
700a95ac: 9004         	str	r0, [sp, #0x10]
;     endTime = curTime + usec;
700a95ae: 9904         	ldr	r1, [sp, #0x10]
700a95b0: 9805         	ldr	r0, [sp, #0x14]
700a95b2: 9a07         	ldr	r2, [sp, #0x1c]
700a95b4: 1889         	adds	r1, r1, r2
700a95b6: f140 0000    	adc	r0, r0, #0x0
700a95ba: 9102         	str	r1, [sp, #0x8]
700a95bc: 9003         	str	r0, [sp, #0xc]
;     if (usec >= gClockCtrl.usecPerTick) {
700a95be: 9807         	ldr	r0, [sp, #0x1c]
700a95c0: f644 4190    	movw	r1, #0x4c90
700a95c4: f2c7 0108    	movt	r1, #0x7008
700a95c8: 6889         	ldr	r1, [r1, #0x8]
700a95ca: 4288         	cmp	r0, r1
700a95cc: d30d         	blo	0x700a95ea <ClockP_usleep+0x4a> @ imm = #0x1a
700a95ce: e7ff         	b	0x700a95d0 <ClockP_usleep+0x30> @ imm = #-0x2
;         ticksToSleep = usec / gClockCtrl.usecPerTick;
700a95d0: 9807         	ldr	r0, [sp, #0x1c]
700a95d2: f644 4190    	movw	r1, #0x4c90
700a95d6: f2c7 0108    	movt	r1, #0x7008
700a95da: 6889         	ldr	r1, [r1, #0x8]
700a95dc: fbb0 f0f1    	udiv	r0, r0, r1
700a95e0: 9001         	str	r0, [sp, #0x4]
;         ClockP_sleepTicks(ticksToSleep);
700a95e2: 9801         	ldr	r0, [sp, #0x4]
700a95e4: f004 fcec    	bl	0x700adfc0 <ClockP_sleepTicks> @ imm = #0x49d8
;     }
700a95e8: e012         	b	0x700a9610 <ClockP_usleep+0x70> @ imm = #0x24
;         curTime = ClockP_getTimeUsec();
700a95ea: f7ff fd19    	bl	0x700a9020 <ClockP_getTimeUsec> @ imm = #-0x5ce
700a95ee: 9105         	str	r1, [sp, #0x14]
700a95f0: 9004         	str	r0, [sp, #0x10]
;         while (curTime < endTime) {
700a95f2: e7ff         	b	0x700a95f4 <ClockP_usleep+0x54> @ imm = #-0x2
700a95f4: 9a04         	ldr	r2, [sp, #0x10]
700a95f6: 9805         	ldr	r0, [sp, #0x14]
700a95f8: 9b02         	ldr	r3, [sp, #0x8]
700a95fa: 9903         	ldr	r1, [sp, #0xc]
700a95fc: 1ad2         	subs	r2, r2, r3
700a95fe: 4188         	sbcs	r0, r1
700a9600: d205         	bhs	0x700a960e <ClockP_usleep+0x6e> @ imm = #0xa
700a9602: e7ff         	b	0x700a9604 <ClockP_usleep+0x64> @ imm = #-0x2
;             curTime = ClockP_getTimeUsec();
700a9604: f7ff fd0c    	bl	0x700a9020 <ClockP_getTimeUsec> @ imm = #-0x5e8
700a9608: 9105         	str	r1, [sp, #0x14]
700a960a: 9004         	str	r0, [sp, #0x10]
;         while (curTime < endTime) {
700a960c: e7f2         	b	0x700a95f4 <ClockP_usleep+0x54> @ imm = #-0x1c
700a960e: e7ff         	b	0x700a9610 <ClockP_usleep+0x70> @ imm = #-0x2
; }
700a9610: b008         	add	sp, #0x20
700a9612: bd80         	pop	{r7, pc}
		...

700a9620 <Udma_chEnable>:
; {
700a9620: b580         	push	{r7, lr}
700a9622: b084         	sub	sp, #0x10
700a9624: 9003         	str	r0, [sp, #0xc]
700a9626: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a9628: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a962a: 9803         	ldr	r0, [sp, #0xc]
700a962c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a962e: 9800         	ldr	r0, [sp]
700a9630: b150         	cbz	r0, 0x700a9648 <Udma_chEnable+0x28> @ imm = #0x14
700a9632: e7ff         	b	0x700a9634 <Udma_chEnable+0x14> @ imm = #-0x2
700a9634: 9800         	ldr	r0, [sp]
700a9636: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a963a: f64a 31cd    	movw	r1, #0xabcd
700a963e: f6ca 31dc    	movt	r1, #0xabdc
700a9642: 4288         	cmp	r0, r1
700a9644: d004         	beq	0x700a9650 <Udma_chEnable+0x30> @ imm = #0x8
700a9646: e7ff         	b	0x700a9648 <Udma_chEnable+0x28> @ imm = #-0x2
700a9648: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a964c: 9002         	str	r0, [sp, #0x8]
;     }
700a964e: e7ff         	b	0x700a9650 <Udma_chEnable+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9650: 9802         	ldr	r0, [sp, #0x8]
700a9652: b9a8         	cbnz	r0, 0x700a9680 <Udma_chEnable+0x60> @ imm = #0x2a
700a9654: e7ff         	b	0x700a9656 <Udma_chEnable+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a9656: 9800         	ldr	r0, [sp]
700a9658: 6e80         	ldr	r0, [r0, #0x68]
700a965a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a965c: 9801         	ldr	r0, [sp, #0x4]
700a965e: b150         	cbz	r0, 0x700a9676 <Udma_chEnable+0x56> @ imm = #0x14
700a9660: e7ff         	b	0x700a9662 <Udma_chEnable+0x42> @ imm = #-0x2
700a9662: 9801         	ldr	r0, [sp, #0x4]
700a9664: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a9668: f64a 31cd    	movw	r1, #0xabcd
700a966c: f6ca 31dc    	movt	r1, #0xabdc
700a9670: 4288         	cmp	r0, r1
700a9672: d004         	beq	0x700a967e <Udma_chEnable+0x5e> @ imm = #0x8
700a9674: e7ff         	b	0x700a9676 <Udma_chEnable+0x56> @ imm = #-0x2
700a9676: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a967a: 9002         	str	r0, [sp, #0x8]
;         }
700a967c: e7ff         	b	0x700a967e <Udma_chEnable+0x5e> @ imm = #-0x2
;     }
700a967e: e7ff         	b	0x700a9680 <Udma_chEnable+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9680: 9802         	ldr	r0, [sp, #0x8]
700a9682: b920         	cbnz	r0, 0x700a968e <Udma_chEnable+0x6e> @ imm = #0x8
700a9684: e7ff         	b	0x700a9686 <Udma_chEnable+0x66> @ imm = #-0x2
;         Udma_chEnableLocal(chHandleInt);
700a9686: 9800         	ldr	r0, [sp]
700a9688: f7f6 f872    	bl	0x7009f770 <Udma_chEnableLocal> @ imm = #-0x9f1c
;     }
700a968c: e7ff         	b	0x700a968e <Udma_chEnable+0x6e> @ imm = #-0x2
;     return (retVal);
700a968e: 9802         	ldr	r0, [sp, #0x8]
700a9690: b004         	add	sp, #0x10
700a9692: bd80         	pop	{r7, pc}
		...

700a96a0 <CSL_bcdmaChanOpTriggerChan>:
; {
700a96a0: b580         	push	{r7, lr}
700a96a2: b084         	sub	sp, #0x10
700a96a4: 9003         	str	r0, [sp, #0xc]
700a96a6: 9102         	str	r1, [sp, #0x8]
700a96a8: 9201         	str	r2, [sp, #0x4]
700a96aa: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a96ac: 9000         	str	r0, [sp]
;     if( chanType == CSL_BCDMA_CHAN_TYPE_BLOCK_COPY )
700a96ae: 9802         	ldr	r0, [sp, #0x8]
700a96b0: b950         	cbnz	r0, 0x700a96c8 <CSL_bcdmaChanOpTriggerChan+0x28> @ imm = #0x14
700a96b2: e7ff         	b	0x700a96b4 <CSL_bcdmaChanOpTriggerChan+0x14> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pBcChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_BCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700a96b4: 9803         	ldr	r0, [sp, #0xc]
700a96b6: 6880         	ldr	r0, [r0, #0x8]
700a96b8: 9901         	ldr	r1, [sp, #0x4]
700a96ba: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a96be: 3008         	adds	r0, #0x8
700a96c0: 2101         	movs	r1, #0x1
700a96c2: f7f1 fc75    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0xe716
;     }
700a96c6: e021         	b	0x700a970c <CSL_bcdmaChanOpTriggerChan+0x6c> @ imm = #0x42
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_TX )
700a96c8: 9802         	ldr	r0, [sp, #0x8]
700a96ca: 2801         	cmp	r0, #0x1
700a96cc: d10a         	bne	0x700a96e4 <CSL_bcdmaChanOpTriggerChan+0x44> @ imm = #0x14
700a96ce: e7ff         	b	0x700a96d0 <CSL_bcdmaChanOpTriggerChan+0x30> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_TXCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700a96d0: 9803         	ldr	r0, [sp, #0xc]
700a96d2: 6900         	ldr	r0, [r0, #0x10]
700a96d4: 9901         	ldr	r1, [sp, #0x4]
700a96d6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a96da: 3008         	adds	r0, #0x8
700a96dc: 2101         	movs	r1, #0x1
700a96de: f7f1 fc67    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0xe732
;     }
700a96e2: e012         	b	0x700a970a <CSL_bcdmaChanOpTriggerChan+0x6a> @ imm = #0x24
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700a96e4: 9802         	ldr	r0, [sp, #0x8]
700a96e6: 2802         	cmp	r0, #0x2
700a96e8: d10a         	bne	0x700a9700 <CSL_bcdmaChanOpTriggerChan+0x60> @ imm = #0x14
700a96ea: e7ff         	b	0x700a96ec <CSL_bcdmaChanOpTriggerChan+0x4c> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_RXCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700a96ec: 9803         	ldr	r0, [sp, #0xc]
700a96ee: 6980         	ldr	r0, [r0, #0x18]
700a96f0: 9901         	ldr	r1, [sp, #0x4]
700a96f2: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a96f6: 3008         	adds	r0, #0x8
700a96f8: 2101         	movs	r1, #0x1
700a96fa: f7f1 fc59    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0xe74e
;     }
700a96fe: e003         	b	0x700a9708 <CSL_bcdmaChanOpTriggerChan+0x68> @ imm = #0x6
700a9700: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a9704: 9000         	str	r0, [sp]
700a9706: e7ff         	b	0x700a9708 <CSL_bcdmaChanOpTriggerChan+0x68> @ imm = #-0x2
700a9708: e7ff         	b	0x700a970a <CSL_bcdmaChanOpTriggerChan+0x6a> @ imm = #-0x2
700a970a: e7ff         	b	0x700a970c <CSL_bcdmaChanOpTriggerChan+0x6c> @ imm = #-0x2
;     return retVal;
700a970c: 9800         	ldr	r0, [sp]
700a970e: b004         	add	sp, #0x10
700a9710: bd80         	pop	{r7, pc}
		...
700a971e: 0000         	movs	r0, r0

700a9720 <prvProcessExpiredTimer>:
;     {
700a9720: b580         	push	{r7, lr}
700a9722: b086         	sub	sp, #0x18
700a9724: 9005         	str	r0, [sp, #0x14]
700a9726: 9104         	str	r1, [sp, #0x10]
;         Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
700a9728: f644 50ac    	movw	r0, #0x4dac
700a972c: f2c7 0008    	movt	r0, #0x7008
700a9730: 6800         	ldr	r0, [r0]
700a9732: 68c0         	ldr	r0, [r0, #0xc]
700a9734: 68c0         	ldr	r0, [r0, #0xc]
700a9736: 9002         	str	r0, [sp, #0x8]
;         ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a9738: 9802         	ldr	r0, [sp, #0x8]
700a973a: 3004         	adds	r0, #0x4
700a973c: f002 f9d8    	bl	0x700abaf0 <uxListRemove> @ imm = #0x23b0
;         if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a9740: 9802         	ldr	r0, [sp, #0x8]
700a9742: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a9746: 0740         	lsls	r0, r0, #0x1d
700a9748: 2800         	cmp	r0, #0x0
700a974a: d515         	bpl	0x700a9778 <prvProcessExpiredTimer+0x58> @ imm = #0x2a
700a974c: e7ff         	b	0x700a974e <prvProcessExpiredTimer+0x2e> @ imm = #-0x2
;             if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
700a974e: 9802         	ldr	r0, [sp, #0x8]
700a9750: 9b05         	ldr	r3, [sp, #0x14]
700a9752: 6981         	ldr	r1, [r0, #0x18]
700a9754: 4419         	add	r1, r3
700a9756: 9a04         	ldr	r2, [sp, #0x10]
700a9758: f7ff f96a    	bl	0x700a8a30 <prvInsertTimerInActiveList> @ imm = #-0xd2c
700a975c: b150         	cbz	r0, 0x700a9774 <prvProcessExpiredTimer+0x54> @ imm = #0x14
700a975e: e7ff         	b	0x700a9760 <prvProcessExpiredTimer+0x40> @ imm = #-0x2
;                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
700a9760: 9802         	ldr	r0, [sp, #0x8]
700a9762: 9a05         	ldr	r2, [sp, #0x14]
700a9764: 4669         	mov	r1, sp
700a9766: 2300         	movs	r3, #0x0
700a9768: 600b         	str	r3, [r1]
700a976a: 4619         	mov	r1, r3
700a976c: f7fe fc30    	bl	0x700a7fd0 <xTimerGenericCommand> @ imm = #-0x17a0
700a9770: 9003         	str	r0, [sp, #0xc]
;             }
700a9772: e000         	b	0x700a9776 <prvProcessExpiredTimer+0x56> @ imm = #0x0
700a9774: e7ff         	b	0x700a9776 <prvProcessExpiredTimer+0x56> @ imm = #-0x2
;         }
700a9776: e007         	b	0x700a9788 <prvProcessExpiredTimer+0x68> @ imm = #0xe
;             pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a9778: 9902         	ldr	r1, [sp, #0x8]
700a977a: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a977e: f000 00fe    	and	r0, r0, #0xfe
700a9782: f881 0028    	strb.w	r0, [r1, #0x28]
700a9786: e7ff         	b	0x700a9788 <prvProcessExpiredTimer+0x68> @ imm = #-0x2
;         pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a9788: 9802         	ldr	r0, [sp, #0x8]
700a978a: 6a01         	ldr	r1, [r0, #0x20]
700a978c: 4788         	blx	r1
;     }
700a978e: b006         	add	sp, #0x18
700a9790: bd80         	pop	{r7, pc}
		...
700a979e: 0000         	movs	r0, r0

700a97a0 <xTaskCreateStatic>:
;     StaticTask_t *const pxTaskBuffer) {
700a97a0: b5b0         	push	{r4, r5, r7, lr}
700a97a2: b08a         	sub	sp, #0x28
700a97a4: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a97a8: f8dd c03c    	ldr.w	r12, [sp, #0x3c]
700a97ac: f8dd c038    	ldr.w	r12, [sp, #0x38]
700a97b0: 9009         	str	r0, [sp, #0x24]
700a97b2: 9108         	str	r1, [sp, #0x20]
700a97b4: 9207         	str	r2, [sp, #0x1c]
700a97b6: 9306         	str	r3, [sp, #0x18]
;   if ((pxTaskBuffer != NULL) && (puxStackBuffer != NULL)) {
700a97b8: 9810         	ldr	r0, [sp, #0x40]
700a97ba: b320         	cbz	r0, 0x700a9806 <xTaskCreateStatic+0x66> @ imm = #0x48
700a97bc: e7ff         	b	0x700a97be <xTaskCreateStatic+0x1e> @ imm = #-0x2
700a97be: 980f         	ldr	r0, [sp, #0x3c]
700a97c0: b308         	cbz	r0, 0x700a9806 <xTaskCreateStatic+0x66> @ imm = #0x42
700a97c2: e7ff         	b	0x700a97c4 <xTaskCreateStatic+0x24> @ imm = #-0x2
;         pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures
700a97c4: 9810         	ldr	r0, [sp, #0x40]
;     pxNewTCB = (TCB_t *)
700a97c6: 9005         	str	r0, [sp, #0x14]
;     pxNewTCB->pxStack = (StackType_t *)puxStackBuffer;
700a97c8: 980f         	ldr	r0, [sp, #0x3c]
700a97ca: 9905         	ldr	r1, [sp, #0x14]
700a97cc: 6308         	str	r0, [r1, #0x30]
;       pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
700a97ce: 9905         	ldr	r1, [sp, #0x14]
700a97d0: 2002         	movs	r0, #0x2
700a97d2: f881 0081    	strb.w	r0, [r1, #0x81]
;     prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters,
700a97d6: 9809         	ldr	r0, [sp, #0x24]
700a97d8: 9908         	ldr	r1, [sp, #0x20]
700a97da: 9a07         	ldr	r2, [sp, #0x1c]
700a97dc: 9b06         	ldr	r3, [sp, #0x18]
;                          uxPriority, &xReturn, pxNewTCB, NULL);
700a97de: f8dd c038    	ldr.w	r12, [sp, #0x38]
700a97e2: 9c05         	ldr	r4, [sp, #0x14]
;     prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters,
700a97e4: 46ee         	mov	lr, sp
700a97e6: 2500         	movs	r5, #0x0
700a97e8: f8ce 500c    	str.w	r5, [lr, #0xc]
700a97ec: f8ce 4008    	str.w	r4, [lr, #0x8]
700a97f0: ac04         	add	r4, sp, #0x10
700a97f2: f8ce 4004    	str.w	r4, [lr, #0x4]
700a97f6: f8ce c000    	str.w	r12, [lr]
700a97fa: f7f9 fdd9    	bl	0x700a33b0 <prvInitialiseNewTask> @ imm = #-0x644e
;     prvAddNewTaskToReadyList(pxNewTCB);
700a97fe: 9805         	ldr	r0, [sp, #0x14]
700a9800: f7f9 feee    	bl	0x700a35e0 <prvAddNewTaskToReadyList> @ imm = #-0x6224
;   } else {
700a9804: e002         	b	0x700a980c <xTaskCreateStatic+0x6c> @ imm = #0x4
700a9806: 2000         	movs	r0, #0x0
;     xReturn = NULL;
700a9808: 9004         	str	r0, [sp, #0x10]
700a980a: e7ff         	b	0x700a980c <xTaskCreateStatic+0x6c> @ imm = #-0x2
;   return xReturn;
700a980c: 9804         	ldr	r0, [sp, #0x10]
700a980e: b00a         	add	sp, #0x28
700a9810: bdb0         	pop	{r4, r5, r7, pc}
		...
700a981e: 0000         	movs	r0, r0

700a9820 <CSL_intaggrClrIntr>:
; {
700a9820: b580         	push	{r7, lr}
700a9822: b088         	sub	sp, #0x20
700a9824: 9007         	str	r0, [sp, #0x1c]
700a9826: 9106         	str	r1, [sp, #0x18]
700a9828: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t  retVal = CSL_EFAIL;
700a982c: 9005         	str	r0, [sp, #0x14]
;     if( CSL_intaggrIsValidStatusBitNum(pCfg, statusBitNum) )
700a982e: 9807         	ldr	r0, [sp, #0x1c]
700a9830: 9906         	ldr	r1, [sp, #0x18]
700a9832: f002 fd95    	bl	0x700ac360 <CSL_intaggrIsValidStatusBitNum> @ imm = #0x2b2a
700a9836: b340         	cbz	r0, 0x700a988a <CSL_intaggrClrIntr+0x6a> @ imm = #0x50
700a9838: e7ff         	b	0x700a983a <CSL_intaggrClrIntr+0x1a> @ imm = #-0x2
;         regNum = statusBitNum >> 6U;
700a983a: 9806         	ldr	r0, [sp, #0x18]
700a983c: 0980         	lsrs	r0, r0, #0x6
700a983e: 9001         	str	r0, [sp, #0x4]
;         bitNum = statusBitNum & (uint32_t)0x003FU;
700a9840: 9806         	ldr	r0, [sp, #0x18]
700a9842: f000 003f    	and	r0, r0, #0x3f
700a9846: 9000         	str	r0, [sp]
;         regVal = (((uint64_t)1U) << bitNum);
700a9848: 9b00         	ldr	r3, [sp]
700a984a: f1a3 0220    	sub.w	r2, r3, #0x20
700a984e: 2101         	movs	r1, #0x1
700a9850: fa01 fc02    	lsl.w	r12, r1, r2
700a9854: f1c3 0020    	rsb.w	r0, r3, #0x20
700a9858: fa21 f000    	lsr.w	r0, r1, r0
700a985c: 2a00         	cmp	r2, #0x0
700a985e: bf58         	it	pl
700a9860: 4660         	movpl	r0, r12
700a9862: fa01 f103    	lsl.w	r1, r1, r3
700a9866: 2a00         	cmp	r2, #0x0
700a9868: bf58         	it	pl
700a986a: 2100         	movpl	r1, #0x0
700a986c: 9102         	str	r1, [sp, #0x8]
700a986e: 9003         	str	r0, [sp, #0xc]
;         CSL_REG64_WR( &pCfg->pIntrRegs->VINT[regNum].STATUS_CLEAR, regVal );
700a9870: 9807         	ldr	r0, [sp, #0x1c]
700a9872: 6880         	ldr	r0, [r0, #0x8]
700a9874: 9901         	ldr	r1, [sp, #0x4]
700a9876: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a987a: 3018         	adds	r0, #0x18
700a987c: 9a02         	ldr	r2, [sp, #0x8]
700a987e: 9b03         	ldr	r3, [sp, #0xc]
700a9880: f004 f9ce    	bl	0x700adc20 <CSL_REG64_WR_RAW> @ imm = #0x439c
700a9884: 2000         	movs	r0, #0x0
;         retVal = CSL_PASS;
700a9886: 9005         	str	r0, [sp, #0x14]
;     }
700a9888: e7ff         	b	0x700a988a <CSL_intaggrClrIntr+0x6a> @ imm = #-0x2
;     return retVal;
700a988a: 9805         	ldr	r0, [sp, #0x14]
700a988c: b008         	add	sp, #0x20
700a988e: bd80         	pop	{r7, pc}

700a9890 <Sciclient_rmGetResourceRange>:
; {
700a9890: b580         	push	{r7, lr}
700a9892: b090         	sub	sp, #0x40
700a9894: 900f         	str	r0, [sp, #0x3c]
700a9896: 910e         	str	r1, [sp, #0x38]
700a9898: 920d         	str	r2, [sp, #0x34]
700a989a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a989c: 900c         	str	r0, [sp, #0x30]
700a989e: f44f 51a8    	mov.w	r1, #0x1500
;     sciReq.messageType    = TISCI_MSG_RM_GET_RESOURCE_RANGE;
700a98a2: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a98a6: 2102         	movs	r1, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700a98a8: 9108         	str	r1, [sp, #0x20]
700a98aa: a904         	add	r1, sp, #0x10
;     sciReq.pReqPayload    = (const uint8_t *) &req_copy;
700a98ac: 9109         	str	r1, [sp, #0x24]
700a98ae: 210c         	movs	r1, #0xc
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700a98b0: 910a         	str	r1, [sp, #0x28]
;     sciReq.timeout        = timeout;
700a98b2: 990d         	ldr	r1, [sp, #0x34]
700a98b4: 910b         	str	r1, [sp, #0x2c]
;     sciResp.flags           = 0;
700a98b6: 9001         	str	r0, [sp, #0x4]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700a98b8: 980e         	ldr	r0, [sp, #0x38]
700a98ba: 9002         	str	r0, [sp, #0x8]
700a98bc: 2010         	movs	r0, #0x10
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700a98be: 9003         	str	r0, [sp, #0xc]
;     memcpy(&req_copy, req, sizeof(struct tisci_msg_rm_get_resource_range_req));
700a98c0: 9a0f         	ldr	r2, [sp, #0x3c]
700a98c2: 6810         	ldr	r0, [r2]
700a98c4: 6851         	ldr	r1, [r2, #0x4]
700a98c6: 6892         	ldr	r2, [r2, #0x8]
700a98c8: 9206         	str	r2, [sp, #0x18]
700a98ca: 9105         	str	r1, [sp, #0x14]
700a98cc: 9004         	str	r0, [sp, #0x10]
;     if (SystemP_SUCCESS == r)
700a98ce: 980c         	ldr	r0, [sp, #0x30]
700a98d0: b930         	cbnz	r0, 0x700a98e0 <Sciclient_rmGetResourceRange+0x50> @ imm = #0xc
700a98d2: e7ff         	b	0x700a98d4 <Sciclient_rmGetResourceRange+0x44> @ imm = #-0x2
700a98d4: a807         	add	r0, sp, #0x1c
700a98d6: a901         	add	r1, sp, #0x4
;         r = Sciclient_service(&sciReq, &sciResp);
700a98d8: f7f2 fba2    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xd8bc
700a98dc: 900c         	str	r0, [sp, #0x30]
;     }
700a98de: e7ff         	b	0x700a98e0 <Sciclient_rmGetResourceRange+0x50> @ imm = #-0x2
;     if ((r != SystemP_SUCCESS) ||
700a98e0: 980c         	ldr	r0, [sp, #0x30]
700a98e2: b930         	cbnz	r0, 0x700a98f2 <Sciclient_rmGetResourceRange+0x62> @ imm = #0xc
700a98e4: e7ff         	b	0x700a98e6 <Sciclient_rmGetResourceRange+0x56> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700a98e6: 9801         	ldr	r0, [sp, #0x4]
700a98e8: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700a98ec: 2802         	cmp	r0, #0x2
700a98ee: d004         	beq	0x700a98fa <Sciclient_rmGetResourceRange+0x6a> @ imm = #0x8
700a98f0: e7ff         	b	0x700a98f2 <Sciclient_rmGetResourceRange+0x62> @ imm = #-0x2
700a98f2: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a98f6: 900c         	str	r0, [sp, #0x30]
;     }
700a98f8: e7ff         	b	0x700a98fa <Sciclient_rmGetResourceRange+0x6a> @ imm = #-0x2
;     return r;
700a98fa: 980c         	ldr	r0, [sp, #0x30]
700a98fc: b010         	add	sp, #0x40
700a98fe: bd80         	pop	{r7, pc}

700a9900 <Udma_rmFreeMappedRxCh>:
; {
700a9900: b580         	push	{r7, lr}
700a9902: b088         	sub	sp, #0x20
700a9904: 9007         	str	r0, [sp, #0x1c]
700a9906: 9106         	str	r1, [sp, #0x18]
700a9908: 9205         	str	r2, [sp, #0x14]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a990a: 9806         	ldr	r0, [sp, #0x18]
700a990c: f500 70ea    	add.w	r0, r0, #0x1d4
700a9910: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9912: 9806         	ldr	r0, [sp, #0x18]
700a9914: f500 609f    	add.w	r0, r0, #0x4f8
700a9918: f04f 31ff    	mov.w	r1, #0xffffffff
700a991c: f7ff f9a8    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #-0xcb0
;     i = chNum - rmInitPrms->startMappedRxCh[mappedChGrp];
700a9920: 9807         	ldr	r0, [sp, #0x1c]
700a9922: 9900         	ldr	r1, [sp]
700a9924: 9a05         	ldr	r2, [sp, #0x14]
700a9926: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a992a: 6e89         	ldr	r1, [r1, #0x68]
700a992c: 1a40         	subs	r0, r0, r1
700a992e: 9004         	str	r0, [sp, #0x10]
;     offset = i >> 5U;
700a9930: 9804         	ldr	r0, [sp, #0x10]
700a9932: 0940         	lsrs	r0, r0, #0x5
700a9934: 9003         	str	r0, [sp, #0xc]
;     bitPos = i - (offset << 5U);
700a9936: 9804         	ldr	r0, [sp, #0x10]
700a9938: 9903         	ldr	r1, [sp, #0xc]
700a993a: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a993e: 9002         	str	r0, [sp, #0x8]
;     bitMask = (uint32_t) 1U << bitPos;
700a9940: 9902         	ldr	r1, [sp, #0x8]
700a9942: 2001         	movs	r0, #0x1
700a9944: 4088         	lsls	r0, r1
700a9946: 9001         	str	r0, [sp, #0x4]
;     drvHandle->mappedRxChFlag[mappedChGrp][offset] |= bitMask;
700a9948: 9a01         	ldr	r2, [sp, #0x4]
700a994a: 9806         	ldr	r0, [sp, #0x18]
700a994c: 9905         	ldr	r1, [sp, #0x14]
700a994e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a9952: 9903         	ldr	r1, [sp, #0xc]
700a9954: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9958: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700a995c: 4310         	orrs	r0, r2
700a995e: f8c1 0334    	str.w	r0, [r1, #0x334]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9962: 9806         	ldr	r0, [sp, #0x18]
700a9964: f500 609f    	add.w	r0, r0, #0x4f8
700a9968: f000 fcd2    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x9a4
;     return;
700a996c: b008         	add	sp, #0x20
700a996e: bd80         	pop	{r7, pc}

700a9970 <Udma_rmFreeMappedTxCh>:
; {
700a9970: b580         	push	{r7, lr}
700a9972: b088         	sub	sp, #0x20
700a9974: 9007         	str	r0, [sp, #0x1c]
700a9976: 9106         	str	r1, [sp, #0x18]
700a9978: 9205         	str	r2, [sp, #0x14]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a997a: 9806         	ldr	r0, [sp, #0x18]
700a997c: f500 70ea    	add.w	r0, r0, #0x1d4
700a9980: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9982: 9806         	ldr	r0, [sp, #0x18]
700a9984: f500 609f    	add.w	r0, r0, #0x4f8
700a9988: f04f 31ff    	mov.w	r1, #0xffffffff
700a998c: f7ff f970    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #-0xd20
;     i = chNum - rmInitPrms->startMappedTxCh[mappedChGrp];
700a9990: 9807         	ldr	r0, [sp, #0x1c]
700a9992: 9900         	ldr	r1, [sp]
700a9994: 9a05         	ldr	r2, [sp, #0x14]
700a9996: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a999a: 6c89         	ldr	r1, [r1, #0x48]
700a999c: 1a40         	subs	r0, r0, r1
700a999e: 9004         	str	r0, [sp, #0x10]
;     offset = i >> 5U;
700a99a0: 9804         	ldr	r0, [sp, #0x10]
700a99a2: 0940         	lsrs	r0, r0, #0x5
700a99a4: 9003         	str	r0, [sp, #0xc]
;     bitPos = i - (offset << 5U);
700a99a6: 9804         	ldr	r0, [sp, #0x10]
700a99a8: 9903         	ldr	r1, [sp, #0xc]
700a99aa: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a99ae: 9002         	str	r0, [sp, #0x8]
;     bitMask = (uint32_t) 1U << bitPos;
700a99b0: 9902         	ldr	r1, [sp, #0x8]
700a99b2: 2001         	movs	r0, #0x1
700a99b4: 4088         	lsls	r0, r1
700a99b6: 9001         	str	r0, [sp, #0x4]
;     drvHandle->mappedTxChFlag[mappedChGrp][offset] |= bitMask;
700a99b8: 9a01         	ldr	r2, [sp, #0x4]
700a99ba: 9806         	ldr	r0, [sp, #0x18]
700a99bc: 9905         	ldr	r1, [sp, #0x14]
700a99be: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a99c2: 9903         	ldr	r1, [sp, #0xc]
700a99c4: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a99c8: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a99cc: 4310         	orrs	r0, r2
700a99ce: f8c1 0324    	str.w	r0, [r1, #0x324]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a99d2: 9806         	ldr	r0, [sp, #0x18]
700a99d4: f500 609f    	add.w	r0, r0, #0x4f8
700a99d8: f000 fc9a    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x934
;     return;
700a99dc: b008         	add	sp, #0x20
700a99de: bd80         	pop	{r7, pc}

700a99e0 <Sciclient_rmIaVintGetInfo>:
; {
700a99e0: b580         	push	{r7, lr}
700a99e2: b084         	sub	sp, #0x10
700a99e4: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a99e8: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a99ec: 9202         	str	r2, [sp, #0x8]
700a99ee: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a99f0: 9001         	str	r0, [sp, #0x4]
;     if (n_evts == NULL) {
700a99f2: 9802         	ldr	r0, [sp, #0x8]
700a99f4: b920         	cbnz	r0, 0x700a9a00 <Sciclient_rmIaVintGetInfo+0x20> @ imm = #0x8
700a99f6: e7ff         	b	0x700a99f8 <Sciclient_rmIaVintGetInfo+0x18> @ imm = #-0x2
700a99f8: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a99fc: 9001         	str	r0, [sp, #0x4]
;     } else {
700a99fe: e018         	b	0x700a9a32 <Sciclient_rmIaVintGetInfo+0x52> @ imm = #0x30
;         inst = Sciclient_rmIaGetInst(id);
700a9a00: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a9a04: f000 ffac    	bl	0x700aa960 <Sciclient_rmIaGetInst> @ imm = #0xf58
700a9a08: 9000         	str	r0, [sp]
;         if (inst == NULL) {
700a9a0a: 9800         	ldr	r0, [sp]
700a9a0c: b920         	cbnz	r0, 0x700a9a18 <Sciclient_rmIaVintGetInfo+0x38> @ imm = #0x8
700a9a0e: e7ff         	b	0x700a9a10 <Sciclient_rmIaVintGetInfo+0x30> @ imm = #-0x2
700a9a10: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a9a14: 9001         	str	r0, [sp, #0x4]
;         } else {
700a9a16: e00b         	b	0x700a9a30 <Sciclient_rmIaVintGetInfo+0x50> @ imm = #0x16
;             if (vint >= inst->n_vint) {
700a9a18: f8bd 000c    	ldrh.w	r0, [sp, #0xc]
700a9a1c: 9900         	ldr	r1, [sp]
700a9a1e: 8989         	ldrh	r1, [r1, #0xc]
700a9a20: 4288         	cmp	r0, r1
700a9a22: db04         	blt	0x700a9a2e <Sciclient_rmIaVintGetInfo+0x4e> @ imm = #0x8
700a9a24: e7ff         	b	0x700a9a26 <Sciclient_rmIaVintGetInfo+0x46> @ imm = #-0x2
700a9a26: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a9a2a: 9001         	str	r0, [sp, #0x4]
;             }
700a9a2c: e7ff         	b	0x700a9a2e <Sciclient_rmIaVintGetInfo+0x4e> @ imm = #-0x2
700a9a2e: e7ff         	b	0x700a9a30 <Sciclient_rmIaVintGetInfo+0x50> @ imm = #-0x2
700a9a30: e7ff         	b	0x700a9a32 <Sciclient_rmIaVintGetInfo+0x52> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a9a32: 9801         	ldr	r0, [sp, #0x4]
700a9a34: b940         	cbnz	r0, 0x700a9a48 <Sciclient_rmIaVintGetInfo+0x68> @ imm = #0x10
700a9a36: e7ff         	b	0x700a9a38 <Sciclient_rmIaVintGetInfo+0x58> @ imm = #-0x2
;         *n_evts = inst->vint_usage_count[vint];
700a9a38: 9800         	ldr	r0, [sp]
700a9a3a: 6900         	ldr	r0, [r0, #0x10]
700a9a3c: f8bd 100c    	ldrh.w	r1, [sp, #0xc]
700a9a40: 5c40         	ldrb	r0, [r0, r1]
700a9a42: 9902         	ldr	r1, [sp, #0x8]
700a9a44: 7008         	strb	r0, [r1]
;     }
700a9a46: e7ff         	b	0x700a9a48 <Sciclient_rmIaVintGetInfo+0x68> @ imm = #-0x2
;     return r;
700a9a48: 9801         	ldr	r0, [sp, #0x4]
700a9a4a: b004         	add	sp, #0x10
700a9a4c: bd80         	pop	{r7, pc}
700a9a4e: 0000         	movs	r0, r0

700a9a50 <SemaphoreP_constructMutex>:
; {
700a9a50: b580         	push	{r7, lr}
700a9a52: b086         	sub	sp, #0x18
700a9a54: 9005         	str	r0, [sp, #0x14]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700a9a56: 9805         	ldr	r0, [sp, #0x14]
700a9a58: 9004         	str	r0, [sp, #0x10]
;     DebugP_assert(sizeof(SemaphoreP_Struct) <= sizeof(SemaphoreP_Object) );
700a9a5a: f64f 5040    	movw	r0, #0xfd40
700a9a5e: f2c7 000a    	movt	r0, #0x700a
700a9a62: 4669         	mov	r1, sp
700a9a64: 6008         	str	r0, [r1]
700a9a66: f240 017b    	movw	r1, #0x7b
700a9a6a: f2c7 010b    	movt	r1, #0x700b
700a9a6e: f240 223a    	movw	r2, #0x23a
700a9a72: f2c7 020b    	movt	r2, #0x700b
700a9a76: 2001         	movs	r0, #0x1
700a9a78: 9002         	str	r0, [sp, #0x8]
700a9a7a: 2370         	movs	r3, #0x70
700a9a7c: f7ff fb50    	bl	0x700a9120 <_DebugP_assert> @ imm = #-0x960
700a9a80: 9802         	ldr	r0, [sp, #0x8]
;     pSemaphore->isRecursiveMutex = 1;
700a9a82: 9904         	ldr	r1, [sp, #0x10]
700a9a84: 6548         	str	r0, [r1, #0x54]
;     pSemaphore->semHndl = xSemaphoreCreateRecursiveMutexStatic(&pSemaphore->semObj);
700a9a86: 9904         	ldr	r1, [sp, #0x10]
700a9a88: 2004         	movs	r0, #0x4
700a9a8a: f003 f8c1    	bl	0x700acc10 <xQueueCreateMutexStatic> @ imm = #0x3182
700a9a8e: 9904         	ldr	r1, [sp, #0x10]
700a9a90: 6508         	str	r0, [r1, #0x50]
;     if( pSemaphore->semHndl == NULL )
700a9a92: 9804         	ldr	r0, [sp, #0x10]
700a9a94: 6d00         	ldr	r0, [r0, #0x50]
700a9a96: b920         	cbnz	r0, 0x700a9aa2 <SemaphoreP_constructMutex+0x52> @ imm = #0x8
700a9a98: e7ff         	b	0x700a9a9a <SemaphoreP_constructMutex+0x4a> @ imm = #-0x2
700a9a9a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700a9a9e: 9003         	str	r0, [sp, #0xc]
;     }
700a9aa0: e00a         	b	0x700a9ab8 <SemaphoreP_constructMutex+0x68> @ imm = #0x14
;         vQueueAddToRegistry(pSemaphore->semHndl, "Mutex (DPL)");
700a9aa2: 9804         	ldr	r0, [sp, #0x10]
700a9aa4: 6d00         	ldr	r0, [r0, #0x50]
700a9aa6: f240 41e8    	movw	r1, #0x4e8
700a9aaa: f2c7 010b    	movt	r1, #0x700b
700a9aae: f001 fcef    	bl	0x700ab490 <vQueueAddToRegistry> @ imm = #0x19de
700a9ab2: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700a9ab4: 9003         	str	r0, [sp, #0xc]
700a9ab6: e7ff         	b	0x700a9ab8 <SemaphoreP_constructMutex+0x68> @ imm = #-0x2
;     return status;
700a9ab8: 9803         	ldr	r0, [sp, #0xc]
700a9aba: b006         	add	sp, #0x18
700a9abc: bd80         	pop	{r7, pc}
700a9abe: 0000         	movs	r0, r0

700a9ac0 <UdmaChPrms_init>:
; {
700a9ac0: b580         	push	{r7, lr}
700a9ac2: b082         	sub	sp, #0x8
700a9ac4: 9001         	str	r0, [sp, #0x4]
700a9ac6: 9100         	str	r1, [sp]
;     if(NULL_PTR != chPrms)
700a9ac8: 9801         	ldr	r0, [sp, #0x4]
700a9aca: b368         	cbz	r0, 0x700a9b28 <UdmaChPrms_init+0x68> @ imm = #0x5a
700a9acc: e7ff         	b	0x700a9ace <UdmaChPrms_init+0xe> @ imm = #-0x2
;         chPrms->chNum       = UDMA_DMA_CH_ANY;
700a9ace: 9901         	ldr	r1, [sp, #0x4]
700a9ad0: 2001         	movs	r0, #0x1
700a9ad2: f6cf 70ff    	movt	r0, #0xffff
700a9ad6: 6008         	str	r0, [r1]
;         chPrms->peerChNum   = UDMA_DMA_CH_INVALID;
700a9ad8: 9901         	ldr	r1, [sp, #0x4]
700a9ada: 2000         	movs	r0, #0x0
700a9adc: f6cf 70ff    	movt	r0, #0xffff
700a9ae0: 6048         	str	r0, [r1, #0x4]
;         if(UDMA_CH_TYPE_TR_BLK_COPY == chType)
700a9ae2: 9800         	ldr	r0, [sp]
700a9ae4: 2807         	cmp	r0, #0x7
700a9ae6: d106         	bne	0x700a9af6 <UdmaChPrms_init+0x36> @ imm = #0xc
700a9ae8: e7ff         	b	0x700a9aea <UdmaChPrms_init+0x2a> @ imm = #-0x2
;             chPrms->peerChNum   = UDMA_DMA_CH_NA;
700a9aea: 9901         	ldr	r1, [sp, #0x4]
700a9aec: 2002         	movs	r0, #0x2
700a9aee: f6cf 70ff    	movt	r0, #0xffff
700a9af2: 6048         	str	r0, [r1, #0x4]
;         }
700a9af4: e7ff         	b	0x700a9af6 <UdmaChPrms_init+0x36> @ imm = #-0x2
;         chPrms->mappedChGrp = UDMA_MAPPED_GROUP_INVALID;
700a9af6: 9901         	ldr	r1, [sp, #0x4]
700a9af8: 2004         	movs	r0, #0x4
700a9afa: f6cf 70ff    	movt	r0, #0xffff
700a9afe: 6088         	str	r0, [r1, #0x8]
;         chPrms->appData     = NULL_PTR;
700a9b00: 9901         	ldr	r1, [sp, #0x4]
700a9b02: 2000         	movs	r0, #0x0
700a9b04: 60c8         	str	r0, [r1, #0xc]
;         UdmaRingPrms_init(&chPrms->fqRingPrms);
700a9b06: 9801         	ldr	r0, [sp, #0x4]
700a9b08: 3010         	adds	r0, #0x10
700a9b0a: f001 fbd1    	bl	0x700ab2b0 <UdmaRingPrms_init> @ imm = #0x17a2
;         UdmaRingPrms_init(&chPrms->cqRingPrms);
700a9b0e: 9801         	ldr	r0, [sp, #0x4]
700a9b10: 302c         	adds	r0, #0x2c
700a9b12: f001 fbcd    	bl	0x700ab2b0 <UdmaRingPrms_init> @ imm = #0x179a
;         UdmaRingPrms_init(&chPrms->tdCqRingPrms);
700a9b16: 9801         	ldr	r0, [sp, #0x4]
700a9b18: 3048         	adds	r0, #0x48
700a9b1a: f001 fbc9    	bl	0x700ab2b0 <UdmaRingPrms_init> @ imm = #0x1792
;         chPrms->tdCqRingPrms.elemSize = UDMA_RING_ES_8BYTES;
700a9b1e: 9901         	ldr	r1, [sp, #0x4]
700a9b20: 2001         	movs	r0, #0x1
700a9b22: f881 0058    	strb.w	r0, [r1, #0x58]
;     }
700a9b26: e7ff         	b	0x700a9b28 <UdmaChPrms_init+0x68> @ imm = #-0x2
;     return;
700a9b28: b002         	add	sp, #0x8
700a9b2a: bd80         	pop	{r7, pc}
700a9b2c: 0000         	movs	r0, r0
700a9b2e: 0000         	movs	r0, r0

700a9b30 <Pinmux_lockMMR>:
; {
700a9b30: b580         	push	{r7, lr}
700a9b32: b084         	sub	sp, #0x10
700a9b34: 9003         	str	r0, [sp, #0xc]
;     if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a9b36: 9803         	ldr	r0, [sp, #0xc]
700a9b38: b908         	cbnz	r0, 0x700a9b3e <Pinmux_lockMMR+0xe> @ imm = #0x2
700a9b3a: e7ff         	b	0x700a9b3c <Pinmux_lockMMR+0xc> @ imm = #-0x2
;     }
700a9b3c: e7ff         	b	0x700a9b3e <Pinmux_lockMMR+0xe> @ imm = #-0x2
;     if(PINMUX_DOMAIN_ID_MCU == domainId)
700a9b3e: 9803         	ldr	r0, [sp, #0xc]
700a9b40: 2801         	cmp	r0, #0x1
700a9b42: d128         	bne	0x700a9b96 <Pinmux_lockMMR+0x66> @ imm = #0x50
700a9b44: e7ff         	b	0x700a9b46 <Pinmux_lockMMR+0x16> @ imm = #-0x2
700a9b46: f04f 6081    	mov.w	r0, #0x4080000
700a9b4a: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_PADCFG_CTRL0_CFG0_BASE);
700a9b4c: 9100         	str	r1, [sp]
700a9b4e: f7fa fa57    	bl	0x700a4000 <AddrTranslateP_getLocalAddr> @ imm = #-0x5b52
700a9b52: 9900         	ldr	r1, [sp]
700a9b54: 9002         	str	r0, [sp, #0x8]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK0_KICK0_OFFSET);
700a9b56: 9802         	ldr	r0, [sp, #0x8]
700a9b58: f241 0208    	movw	r2, #0x1008
700a9b5c: 4410         	add	r0, r2
700a9b5e: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700a9b60: 9801         	ldr	r0, [sp, #0x4]
700a9b62: f004 f9f5    	bl	0x700adf50 <CSL_REG32_WR_RAW> @ imm = #0x43ea
700a9b66: 9900         	ldr	r1, [sp]
;         kickAddr++;
700a9b68: 9801         	ldr	r0, [sp, #0x4]
700a9b6a: 3004         	adds	r0, #0x4
700a9b6c: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700a9b6e: 9801         	ldr	r0, [sp, #0x4]
700a9b70: f004 f9ee    	bl	0x700adf50 <CSL_REG32_WR_RAW> @ imm = #0x43dc
700a9b74: 9900         	ldr	r1, [sp]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK1_KICK0_OFFSET);
700a9b76: 9802         	ldr	r0, [sp, #0x8]
700a9b78: f245 0208    	movw	r2, #0x5008
700a9b7c: 4410         	add	r0, r2
700a9b7e: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700a9b80: 9801         	ldr	r0, [sp, #0x4]
700a9b82: f004 f9e5    	bl	0x700adf50 <CSL_REG32_WR_RAW> @ imm = #0x43ca
700a9b86: 9900         	ldr	r1, [sp]
;         kickAddr++;
700a9b88: 9801         	ldr	r0, [sp, #0x4]
700a9b8a: 3004         	adds	r0, #0x4
700a9b8c: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700a9b8e: 9801         	ldr	r0, [sp, #0x4]
700a9b90: f004 f9de    	bl	0x700adf50 <CSL_REG32_WR_RAW> @ imm = #0x43bc
;     }
700a9b94: e7ff         	b	0x700a9b96 <Pinmux_lockMMR+0x66> @ imm = #-0x2
;     return;
700a9b96: b004         	add	sp, #0x10
700a9b98: bd80         	pop	{r7, pc}
700a9b9a: 0000         	movs	r0, r0
700a9b9c: 0000         	movs	r0, r0
700a9b9e: 0000         	movs	r0, r0

700a9ba0 <vListInsert>:
; {
700a9ba0: b084         	sub	sp, #0x10
700a9ba2: 9003         	str	r0, [sp, #0xc]
700a9ba4: 9102         	str	r1, [sp, #0x8]
;     const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
700a9ba6: 9802         	ldr	r0, [sp, #0x8]
700a9ba8: 6800         	ldr	r0, [r0]
700a9baa: 9000         	str	r0, [sp]
;     if( xValueOfInsertion == portMAX_DELAY )
700a9bac: 9800         	ldr	r0, [sp]
700a9bae: 3001         	adds	r0, #0x1
700a9bb0: b920         	cbnz	r0, 0x700a9bbc <vListInsert+0x1c> @ imm = #0x8
700a9bb2: e7ff         	b	0x700a9bb4 <vListInsert+0x14> @ imm = #-0x2
;         pxIterator = pxList->xListEnd.pxPrevious;
700a9bb4: 9803         	ldr	r0, [sp, #0xc]
700a9bb6: 6900         	ldr	r0, [r0, #0x10]
700a9bb8: 9001         	str	r0, [sp, #0x4]
;     }
700a9bba: e010         	b	0x700a9bde <vListInsert+0x3e> @ imm = #0x20
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
700a9bbc: 9803         	ldr	r0, [sp, #0xc]
700a9bbe: 3008         	adds	r0, #0x8
700a9bc0: 9001         	str	r0, [sp, #0x4]
700a9bc2: e7ff         	b	0x700a9bc4 <vListInsert+0x24> @ imm = #-0x2
700a9bc4: 9801         	ldr	r0, [sp, #0x4]
700a9bc6: 6840         	ldr	r0, [r0, #0x4]
700a9bc8: 6800         	ldr	r0, [r0]
700a9bca: 9900         	ldr	r1, [sp]
700a9bcc: 4288         	cmp	r0, r1
700a9bce: d805         	bhi	0x700a9bdc <vListInsert+0x3c> @ imm = #0xa
700a9bd0: e7ff         	b	0x700a9bd2 <vListInsert+0x32> @ imm = #-0x2
;         }
700a9bd2: e7ff         	b	0x700a9bd4 <vListInsert+0x34> @ imm = #-0x2
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
700a9bd4: 9801         	ldr	r0, [sp, #0x4]
700a9bd6: 6840         	ldr	r0, [r0, #0x4]
700a9bd8: 9001         	str	r0, [sp, #0x4]
700a9bda: e7f3         	b	0x700a9bc4 <vListInsert+0x24> @ imm = #-0x1a
700a9bdc: e7ff         	b	0x700a9bde <vListInsert+0x3e> @ imm = #-0x2
;     pxNewListItem->pxNext = pxIterator->pxNext;
700a9bde: 9801         	ldr	r0, [sp, #0x4]
700a9be0: 6840         	ldr	r0, [r0, #0x4]
700a9be2: 9902         	ldr	r1, [sp, #0x8]
700a9be4: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxNext->pxPrevious = pxNewListItem;
700a9be6: 9802         	ldr	r0, [sp, #0x8]
700a9be8: 6841         	ldr	r1, [r0, #0x4]
700a9bea: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxPrevious = pxIterator;
700a9bec: 9801         	ldr	r0, [sp, #0x4]
700a9bee: 9902         	ldr	r1, [sp, #0x8]
700a9bf0: 6088         	str	r0, [r1, #0x8]
;     pxIterator->pxNext = pxNewListItem;
700a9bf2: 9802         	ldr	r0, [sp, #0x8]
700a9bf4: 9901         	ldr	r1, [sp, #0x4]
700a9bf6: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxContainer = pxList;
700a9bf8: 9803         	ldr	r0, [sp, #0xc]
700a9bfa: 9902         	ldr	r1, [sp, #0x8]
700a9bfc: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
700a9bfe: 9903         	ldr	r1, [sp, #0xc]
700a9c00: 6808         	ldr	r0, [r1]
700a9c02: 3001         	adds	r0, #0x1
700a9c04: 6008         	str	r0, [r1]
; }
700a9c06: b004         	add	sp, #0x10
700a9c08: 4770         	bx	lr
700a9c0a: 0000         	movs	r0, r0
700a9c0c: 0000         	movs	r0, r0
700a9c0e: 0000         	movs	r0, r0

700a9c10 <Sciclient_rmIrqCfgIsDirectEvent>:
; {
700a9c10: b580         	push	{r7, lr}
700a9c12: b082         	sub	sp, #0x8
700a9c14: 9001         	str	r0, [sp, #0x4]
700a9c16: 2000         	movs	r0, #0x0
;     bool r = false;
700a9c18: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9c1c: 9801         	ldr	r0, [sp, #0x4]
700a9c1e: 2101         	movs	r1, #0x1
700a9c20: f003 fab6    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x356c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700a9c24: b310         	cbz	r0, 0x700a9c6c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x44
700a9c26: e7ff         	b	0x700a9c28 <Sciclient_rmIrqCfgIsDirectEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9c28: 9801         	ldr	r0, [sp, #0x4]
700a9c2a: 2102         	movs	r1, #0x2
700a9c2c: f003 fab0    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x3560
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700a9c30: b1e0         	cbz	r0, 0x700a9c6c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x38
700a9c32: e7ff         	b	0x700a9c34 <Sciclient_rmIrqCfgIsDirectEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9c34: 9801         	ldr	r0, [sp, #0x4]
700a9c36: 2104         	movs	r1, #0x4
700a9c38: f003 faaa    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x3554
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700a9c3c: b1b0         	cbz	r0, 0x700a9c6c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x2c
700a9c3e: e7ff         	b	0x700a9c40 <Sciclient_rmIrqCfgIsDirectEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9c40: 9801         	ldr	r0, [sp, #0x4]
700a9c42: 2108         	movs	r1, #0x8
700a9c44: f003 faa4    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x3548
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700a9c48: b180         	cbz	r0, 0x700a9c6c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x20
700a9c4a: e7ff         	b	0x700a9c4c <Sciclient_rmIrqCfgIsDirectEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9c4c: 9801         	ldr	r0, [sp, #0x4]
700a9c4e: 2110         	movs	r1, #0x10
700a9c50: f003 fa9e    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x353c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700a9c54: b150         	cbz	r0, 0x700a9c6c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x14
700a9c56: e7ff         	b	0x700a9c58 <Sciclient_rmIrqCfgIsDirectEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9c58: 9801         	ldr	r0, [sp, #0x4]
700a9c5a: 2120         	movs	r1, #0x20
700a9c5c: f003 fa98    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x3530
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9c60: b120         	cbz	r0, 0x700a9c6c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x8
700a9c62: e7ff         	b	0x700a9c64 <Sciclient_rmIrqCfgIsDirectEvent+0x54> @ imm = #-0x2
700a9c64: 2001         	movs	r0, #0x1
;         r = true;
700a9c66: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a9c6a: e7ff         	b	0x700a9c6c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #-0x2
;     return r;
700a9c6c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9c70: f000 0001    	and	r0, r0, #0x1
700a9c74: b002         	add	sp, #0x8
700a9c76: bd80         	pop	{r7, pc}
		...

700a9c80 <Sciclient_rmIrqCfgIsDirectNonEvent>:
; {
700a9c80: b580         	push	{r7, lr}
700a9c82: b082         	sub	sp, #0x8
700a9c84: 9001         	str	r0, [sp, #0x4]
700a9c86: 2000         	movs	r0, #0x0
;     bool r = false;
700a9c88: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9c8c: 9801         	ldr	r0, [sp, #0x4]
700a9c8e: 2101         	movs	r1, #0x1
700a9c90: f003 fa7e    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x34fc
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700a9c94: b310         	cbz	r0, 0x700a9cdc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x44
700a9c96: e7ff         	b	0x700a9c98 <Sciclient_rmIrqCfgIsDirectNonEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9c98: 9801         	ldr	r0, [sp, #0x4]
700a9c9a: 2102         	movs	r1, #0x2
700a9c9c: f003 fa78    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x34f0
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700a9ca0: b1e0         	cbz	r0, 0x700a9cdc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x38
700a9ca2: e7ff         	b	0x700a9ca4 <Sciclient_rmIrqCfgIsDirectNonEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9ca4: 9801         	ldr	r0, [sp, #0x4]
700a9ca6: 2104         	movs	r1, #0x4
700a9ca8: f003 fa72    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x34e4
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == false) &&
700a9cac: b9b0         	cbnz	r0, 0x700a9cdc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x2c
700a9cae: e7ff         	b	0x700a9cb0 <Sciclient_rmIrqCfgIsDirectNonEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9cb0: 9801         	ldr	r0, [sp, #0x4]
700a9cb2: 2108         	movs	r1, #0x8
700a9cb4: f003 fa6c    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x34d8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == false) &&
700a9cb8: b980         	cbnz	r0, 0x700a9cdc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x20
700a9cba: e7ff         	b	0x700a9cbc <Sciclient_rmIrqCfgIsDirectNonEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9cbc: 9801         	ldr	r0, [sp, #0x4]
700a9cbe: 2110         	movs	r1, #0x10
700a9cc0: f003 fa66    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x34cc
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == false) &&
700a9cc4: b950         	cbnz	r0, 0x700a9cdc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x14
700a9cc6: e7ff         	b	0x700a9cc8 <Sciclient_rmIrqCfgIsDirectNonEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9cc8: 9801         	ldr	r0, [sp, #0x4]
700a9cca: 2120         	movs	r1, #0x20
700a9ccc: f003 fa60    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x34c0
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9cd0: b920         	cbnz	r0, 0x700a9cdc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x8
700a9cd2: e7ff         	b	0x700a9cd4 <Sciclient_rmIrqCfgIsDirectNonEvent+0x54> @ imm = #-0x2
700a9cd4: 2001         	movs	r0, #0x1
;         r = true;
700a9cd6: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a9cda: e7ff         	b	0x700a9cdc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #-0x2
;     return r;
700a9cdc: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9ce0: f000 0001    	and	r0, r0, #0x1
700a9ce4: b002         	add	sp, #0x8
700a9ce6: bd80         	pop	{r7, pc}
		...

700a9cf0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly>:
; {
700a9cf0: b580         	push	{r7, lr}
700a9cf2: b082         	sub	sp, #0x8
700a9cf4: 9001         	str	r0, [sp, #0x4]
700a9cf6: 2000         	movs	r0, #0x0
;     bool r = false;
700a9cf8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9cfc: 9801         	ldr	r0, [sp, #0x4]
700a9cfe: 2101         	movs	r1, #0x1
700a9d00: f003 fa46    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x348c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == false) &&
700a9d04: bb10         	cbnz	r0, 0x700a9d4c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x44
700a9d06: e7ff         	b	0x700a9d08 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9d08: 9801         	ldr	r0, [sp, #0x4]
700a9d0a: 2102         	movs	r1, #0x2
700a9d0c: f003 fa40    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x3480
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == false) &&
700a9d10: b9e0         	cbnz	r0, 0x700a9d4c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x38
700a9d12: e7ff         	b	0x700a9d14 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9d14: 9801         	ldr	r0, [sp, #0x4]
700a9d16: 2104         	movs	r1, #0x4
700a9d18: f003 fa3a    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x3474
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700a9d1c: b1b0         	cbz	r0, 0x700a9d4c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x2c
700a9d1e: e7ff         	b	0x700a9d20 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9d20: 9801         	ldr	r0, [sp, #0x4]
700a9d22: 2108         	movs	r1, #0x8
700a9d24: f003 fa34    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x3468
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700a9d28: b180         	cbz	r0, 0x700a9d4c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x20
700a9d2a: e7ff         	b	0x700a9d2c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9d2c: 9801         	ldr	r0, [sp, #0x4]
700a9d2e: 2110         	movs	r1, #0x10
700a9d30: f003 fa2e    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x345c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700a9d34: b150         	cbz	r0, 0x700a9d4c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x14
700a9d36: e7ff         	b	0x700a9d38 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9d38: 9801         	ldr	r0, [sp, #0x4]
700a9d3a: 2120         	movs	r1, #0x20
700a9d3c: f003 fa28    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x3450
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9d40: b120         	cbz	r0, 0x700a9d4c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x8
700a9d42: e7ff         	b	0x700a9d44 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x54> @ imm = #-0x2
700a9d44: 2001         	movs	r0, #0x1
;         r = true;
700a9d46: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a9d4a: e7ff         	b	0x700a9d4c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #-0x2
;     return r;
700a9d4c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9d50: f000 0001    	and	r0, r0, #0x1
700a9d54: b002         	add	sp, #0x8
700a9d56: bd80         	pop	{r7, pc}
		...

700a9d60 <Sciclient_rmIrqCfgIsOesOnly>:
; {
700a9d60: b580         	push	{r7, lr}
700a9d62: b082         	sub	sp, #0x8
700a9d64: 9001         	str	r0, [sp, #0x4]
700a9d66: 2000         	movs	r0, #0x0
;     bool r = false;
700a9d68: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9d6c: 9801         	ldr	r0, [sp, #0x4]
700a9d6e: 2101         	movs	r1, #0x1
700a9d70: f003 fa0e    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x341c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == false) &&
700a9d74: bb10         	cbnz	r0, 0x700a9dbc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x44
700a9d76: e7ff         	b	0x700a9d78 <Sciclient_rmIrqCfgIsOesOnly+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9d78: 9801         	ldr	r0, [sp, #0x4]
700a9d7a: 2102         	movs	r1, #0x2
700a9d7c: f003 fa08    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x3410
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == false) &&
700a9d80: b9e0         	cbnz	r0, 0x700a9dbc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x38
700a9d82: e7ff         	b	0x700a9d84 <Sciclient_rmIrqCfgIsOesOnly+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9d84: 9801         	ldr	r0, [sp, #0x4]
700a9d86: 2104         	movs	r1, #0x4
700a9d88: f003 fa02    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x3404
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == false) &&
700a9d8c: b9b0         	cbnz	r0, 0x700a9dbc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x2c
700a9d8e: e7ff         	b	0x700a9d90 <Sciclient_rmIrqCfgIsOesOnly+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9d90: 9801         	ldr	r0, [sp, #0x4]
700a9d92: 2108         	movs	r1, #0x8
700a9d94: f003 f9fc    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x33f8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == false) &&
700a9d98: b980         	cbnz	r0, 0x700a9dbc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x20
700a9d9a: e7ff         	b	0x700a9d9c <Sciclient_rmIrqCfgIsOesOnly+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9d9c: 9801         	ldr	r0, [sp, #0x4]
700a9d9e: 2110         	movs	r1, #0x10
700a9da0: f003 f9f6    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x33ec
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700a9da4: b150         	cbz	r0, 0x700a9dbc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x14
700a9da6: e7ff         	b	0x700a9da8 <Sciclient_rmIrqCfgIsOesOnly+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9da8: 9801         	ldr	r0, [sp, #0x4]
700a9daa: 2120         	movs	r1, #0x20
700a9dac: f003 f9f0    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x33e0
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9db0: b920         	cbnz	r0, 0x700a9dbc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x8
700a9db2: e7ff         	b	0x700a9db4 <Sciclient_rmIrqCfgIsOesOnly+0x54> @ imm = #-0x2
700a9db4: 2001         	movs	r0, #0x1
;         r = true;
700a9db6: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a9dba: e7ff         	b	0x700a9dbc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #-0x2
;     return r;
700a9dbc: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9dc0: f000 0001    	and	r0, r0, #0x1
700a9dc4: b002         	add	sp, #0x8
700a9dc6: bd80         	pop	{r7, pc}
		...

700a9dd0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent>:
; {
700a9dd0: b580         	push	{r7, lr}
700a9dd2: b082         	sub	sp, #0x8
700a9dd4: 9001         	str	r0, [sp, #0x4]
700a9dd6: 2000         	movs	r0, #0x0
;     bool r = false;
700a9dd8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9ddc: 9801         	ldr	r0, [sp, #0x4]
700a9dde: 2101         	movs	r1, #0x1
700a9de0: f003 f9d6    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x33ac
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700a9de4: b310         	cbz	r0, 0x700a9e2c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x44
700a9de6: e7ff         	b	0x700a9de8 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9de8: 9801         	ldr	r0, [sp, #0x4]
700a9dea: 2102         	movs	r1, #0x2
700a9dec: f003 f9d0    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x33a0
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700a9df0: b1e0         	cbz	r0, 0x700a9e2c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x38
700a9df2: e7ff         	b	0x700a9df4 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9df4: 9801         	ldr	r0, [sp, #0x4]
700a9df6: 2104         	movs	r1, #0x4
700a9df8: f003 f9ca    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x3394
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700a9dfc: b1b0         	cbz	r0, 0x700a9e2c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x2c
700a9dfe: e7ff         	b	0x700a9e00 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9e00: 9801         	ldr	r0, [sp, #0x4]
700a9e02: 2108         	movs	r1, #0x8
700a9e04: f003 f9c4    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x3388
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700a9e08: b180         	cbz	r0, 0x700a9e2c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x20
700a9e0a: e7ff         	b	0x700a9e0c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9e0c: 9801         	ldr	r0, [sp, #0x4]
700a9e0e: 2110         	movs	r1, #0x10
700a9e10: f003 f9be    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x337c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == false) &&
700a9e14: b950         	cbnz	r0, 0x700a9e2c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x14
700a9e16: e7ff         	b	0x700a9e18 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9e18: 9801         	ldr	r0, [sp, #0x4]
700a9e1a: 2120         	movs	r1, #0x20
700a9e1c: f003 f9b8    	bl	0x700ad190 <Sciclient_rmParamIsValid> @ imm = #0x3370
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9e20: b920         	cbnz	r0, 0x700a9e2c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x8
700a9e22: e7ff         	b	0x700a9e24 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x54> @ imm = #-0x2
700a9e24: 2001         	movs	r0, #0x1
;         r = true;
700a9e26: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a9e2a: e7ff         	b	0x700a9e2c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #-0x2
;     return r;
700a9e2c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9e30: f000 0001    	and	r0, r0, #0x1
700a9e34: b002         	add	sp, #0x8
700a9e36: bd80         	pop	{r7, pc}
		...

700a9e40 <UART_divisorValCompute>:
; {
700a9e40: b580         	push	{r7, lr}
700a9e42: b088         	sub	sp, #0x20
700a9e44: 9007         	str	r0, [sp, #0x1c]
700a9e46: 9106         	str	r1, [sp, #0x18]
700a9e48: 9205         	str	r2, [sp, #0x14]
700a9e4a: 9304         	str	r3, [sp, #0x10]
700a9e4c: 2000         	movs	r0, #0x0
;     uint32_t divisorValue = 0U;
700a9e4e: 9003         	str	r0, [sp, #0xc]
;     uint32_t tempModeFlag = modeFlag & UART_MDR1_MODE_SELECT_MASK;
700a9e50: 9805         	ldr	r0, [sp, #0x14]
700a9e52: f000 0007    	and	r0, r0, #0x7
700a9e56: 9002         	str	r0, [sp, #0x8]
;     switch (tempModeFlag)
700a9e58: 9802         	ldr	r0, [sp, #0x8]
700a9e5a: 9001         	str	r0, [sp, #0x4]
700a9e5c: 2805         	cmp	r0, #0x5
700a9e5e: d81f         	bhi	0x700a9ea0 <UART_divisorValCompute+0x60> @ imm = #0x3e
700a9e60: 9901         	ldr	r1, [sp, #0x4]
700a9e62: e8df f001    	tbb	[pc, r1]
700a9e66: 03 03 1d 0a  	.word	0x0a1d0303
700a9e6a: 12 1a        	.short	0x1a12
;             divisorValue = UART_divideRoundCloset(moduleClk, 16U * baudRate);
700a9e6c: 9807         	ldr	r0, [sp, #0x1c]
700a9e6e: 9906         	ldr	r1, [sp, #0x18]
700a9e70: 0109         	lsls	r1, r1, #0x4
700a9e72: f003 ff75    	bl	0x700add60 <UART_divideRoundCloset> @ imm = #0x3eea
700a9e76: 9003         	str	r0, [sp, #0xc]
;             break;
700a9e78: e013         	b	0x700a9ea2 <UART_divisorValCompute+0x62> @ imm = #0x26
;             divisorValue = UART_divideRoundCloset(moduleClk, 13U * baudRate);
700a9e7a: 9807         	ldr	r0, [sp, #0x1c]
700a9e7c: 9906         	ldr	r1, [sp, #0x18]
700a9e7e: 220d         	movs	r2, #0xd
700a9e80: 4351         	muls	r1, r2, r1
700a9e82: f003 ff6d    	bl	0x700add60 <UART_divideRoundCloset> @ imm = #0x3eda
700a9e86: 9003         	str	r0, [sp, #0xc]
;             break;
700a9e88: e00b         	b	0x700a9ea2 <UART_divisorValCompute+0x62> @ imm = #0x16
;             divisorValue = UART_divideRoundCloset(moduleClk, mirOverSampRate * baudRate);
700a9e8a: 9807         	ldr	r0, [sp, #0x1c]
700a9e8c: 9904         	ldr	r1, [sp, #0x10]
700a9e8e: 9a06         	ldr	r2, [sp, #0x18]
700a9e90: 4351         	muls	r1, r2, r1
700a9e92: f003 ff65    	bl	0x700add60 <UART_divideRoundCloset> @ imm = #0x3eca
700a9e96: 9003         	str	r0, [sp, #0xc]
;             break;
700a9e98: e003         	b	0x700a9ea2 <UART_divisorValCompute+0x62> @ imm = #0x6
700a9e9a: 2000         	movs	r0, #0x0
;             divisorValue = 0U;
700a9e9c: 9003         	str	r0, [sp, #0xc]
;             break;
700a9e9e: e000         	b	0x700a9ea2 <UART_divisorValCompute+0x62> @ imm = #0x0
;             break;
700a9ea0: e7ff         	b	0x700a9ea2 <UART_divisorValCompute+0x62> @ imm = #-0x2
;     return divisorValue;
700a9ea2: 9803         	ldr	r0, [sp, #0xc]
700a9ea4: b008         	add	sp, #0x20
700a9ea6: bd80         	pop	{r7, pc}
		...

700a9eb0 <CSL_udmapCppi5SetIds>:
; {
700a9eb0: b085         	sub	sp, #0x14
700a9eb2: 9004         	str	r0, [sp, #0x10]
700a9eb4: 9103         	str	r1, [sp, #0xc]
700a9eb6: 9202         	str	r2, [sp, #0x8]
700a9eb8: 9301         	str	r3, [sp, #0x4]
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700a9eba: 9803         	ldr	r0, [sp, #0xc]
700a9ebc: 2803         	cmp	r0, #0x3
700a9ebe: d114         	bne	0x700a9eea <CSL_udmapCppi5SetIds+0x3a> @ imm = #0x28
700a9ec0: e7ff         	b	0x700a9ec2 <CSL_udmapCppi5SetIds+0x12> @ imm = #-0x2
;         v = ((CSL_UdmapCppi5TRPD *)pDesc)->pktInfo;
700a9ec2: 9804         	ldr	r0, [sp, #0x10]
700a9ec4: 6840         	ldr	r0, [r0, #0x4]
700a9ec6: 9000         	str	r0, [sp]
;         v &= ~(CSL_UDMAP_CPPI5_TRPD_PKTINFO_PKTID_MASK | CSL_UDMAP_CPPI5_TRPD_PKTINFO_FLOWID_MASK);
700a9ec8: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9ecc: 0600         	lsls	r0, r0, #0x18
700a9ece: 9000         	str	r0, [sp]
;         v |= CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_PKTID, pktId )   |
700a9ed0: 9802         	ldr	r0, [sp, #0x8]
;              CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_FLOWID, flowId );
700a9ed2: 9901         	ldr	r1, [sp, #0x4]
700a9ed4: f36f 319f    	bfc	r1, #14, #18
;         v |= CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_PKTID, pktId )   |
700a9ed8: f360 3197    	bfi	r1, r0, #14, #10
700a9edc: 9800         	ldr	r0, [sp]
700a9ede: 4308         	orrs	r0, r1
700a9ee0: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5TRPD *)pDesc)->pktInfo = v;
700a9ee2: 9800         	ldr	r0, [sp]
700a9ee4: 9904         	ldr	r1, [sp, #0x10]
700a9ee6: 6048         	str	r0, [r1, #0x4]
;     }
700a9ee8: e013         	b	0x700a9f12 <CSL_udmapCppi5SetIds+0x62> @ imm = #0x26
;         v = ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1;
700a9eea: 9804         	ldr	r0, [sp, #0x10]
700a9eec: 6840         	ldr	r0, [r0, #0x4]
700a9eee: 9000         	str	r0, [sp]
;         v &= ~(CSL_UDMAP_CPPI5_PD_PKTINFO1_PKTID_MASK | CSL_UDMAP_CPPI5_PD_PKTINFO1_FLOWID_MASK);
700a9ef0: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9ef4: 0600         	lsls	r0, r0, #0x18
700a9ef6: 9000         	str	r0, [sp]
;         v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_PKTID, pktId )   |
700a9ef8: 9802         	ldr	r0, [sp, #0x8]
;              CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_FLOWID, flowId );
700a9efa: 9901         	ldr	r1, [sp, #0x4]
700a9efc: f36f 319f    	bfc	r1, #14, #18
;         v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_PKTID, pktId )   |
700a9f00: f360 3197    	bfi	r1, r0, #14, #10
700a9f04: 9800         	ldr	r0, [sp]
700a9f06: 4308         	orrs	r0, r1
700a9f08: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1 = v;
700a9f0a: 9800         	ldr	r0, [sp]
700a9f0c: 9904         	ldr	r1, [sp, #0x10]
700a9f0e: 6048         	str	r0, [r1, #0x4]
700a9f10: e7ff         	b	0x700a9f12 <CSL_udmapCppi5SetIds+0x62> @ imm = #-0x2
; }
700a9f12: b005         	add	sp, #0x14
700a9f14: 4770         	bx	lr
		...
700a9f1e: 0000         	movs	r0, r0

700a9f20 <Sciclient_rmIrGetInst>:
; {
700a9f20: b083         	sub	sp, #0xc
700a9f22: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a9f26: 2000         	movs	r0, #0x0
;     struct Sciclient_rmIrInst *inst = NULL;
700a9f28: 9001         	str	r0, [sp, #0x4]
;     for (i = 0; i < SCICLIENT_RM_IR_NUM_INST; i++) {
700a9f2a: f8ad 0002    	strh.w	r0, [sp, #0x2]
700a9f2e: e7ff         	b	0x700a9f30 <Sciclient_rmIrGetInst+0x10> @ imm = #-0x2
700a9f30: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a9f34: 2803         	cmp	r0, #0x3
700a9f36: dc22         	bgt	0x700a9f7e <Sciclient_rmIrGetInst+0x5e> @ imm = #0x44
700a9f38: e7ff         	b	0x700a9f3a <Sciclient_rmIrGetInst+0x1a> @ imm = #-0x2
;         if (id == gRmIrInstances[i].dev_id) {
700a9f3a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a9f3e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a9f42: eb01 0241    	add.w	r2, r1, r1, lsl #1
700a9f46: f640 317c    	movw	r1, #0xb7c
700a9f4a: f2c7 010b    	movt	r1, #0x700b
700a9f4e: f831 1032    	ldrh.w	r1, [r1, r2, lsl #3]
700a9f52: 4288         	cmp	r0, r1
700a9f54: d10c         	bne	0x700a9f70 <Sciclient_rmIrGetInst+0x50> @ imm = #0x18
700a9f56: e7ff         	b	0x700a9f58 <Sciclient_rmIrGetInst+0x38> @ imm = #-0x2
;             inst = &gRmIrInstances[i];
700a9f58: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a9f5c: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a9f60: f640 307c    	movw	r0, #0xb7c
700a9f64: f2c7 000b    	movt	r0, #0x700b
700a9f68: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a9f6c: 9001         	str	r0, [sp, #0x4]
;             break;
700a9f6e: e006         	b	0x700a9f7e <Sciclient_rmIrGetInst+0x5e> @ imm = #0xc
;     }
700a9f70: e7ff         	b	0x700a9f72 <Sciclient_rmIrGetInst+0x52> @ imm = #-0x2
;     for (i = 0; i < SCICLIENT_RM_IR_NUM_INST; i++) {
700a9f72: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a9f76: 3001         	adds	r0, #0x1
700a9f78: f8ad 0002    	strh.w	r0, [sp, #0x2]
700a9f7c: e7d8         	b	0x700a9f30 <Sciclient_rmIrGetInst+0x10> @ imm = #-0x50
;     return inst;
700a9f7e: 9801         	ldr	r0, [sp, #0x4]
700a9f80: b003         	add	sp, #0xc
700a9f82: 4770         	bx	lr
		...

700a9f90 <UART_fifoRegisterWrite>:
; {
700a9f90: b580         	push	{r7, lr}
700a9f92: b088         	sub	sp, #0x20
700a9f94: 9007         	str	r0, [sp, #0x1c]
700a9f96: 9106         	str	r1, [sp, #0x18]
700a9f98: 2000         	movs	r0, #0x0
;     uint32_t isTxRxFifoEmpty = FALSE;
700a9f9a: 9001         	str	r0, [sp, #0x4]
700a9f9c: 9002         	str	r0, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700a9f9e: 9807         	ldr	r0, [sp, #0x1c]
700a9fa0: 2180         	movs	r1, #0x80
700a9fa2: f000 fdfd    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #0xbfa
700a9fa6: 9901         	ldr	r1, [sp, #0x4]
700a9fa8: 9003         	str	r0, [sp, #0xc]
;     divLatchRegVal = UART_divisorLatchWrite(baseAddr, 0x0000U);
700a9faa: 9807         	ldr	r0, [sp, #0x1c]
700a9fac: f7f9 f8e0    	bl	0x700a3170 <UART_divisorLatchWrite> @ imm = #-0x6e40
700a9fb0: 9005         	str	r0, [sp, #0x14]
;     enhanFnBitVal = UART_enhanFuncEnable(baseAddr);
700a9fb2: 9807         	ldr	r0, [sp, #0x1c]
700a9fb4: f002 fa94    	bl	0x700ac4e0 <UART_enhanFuncEnable> @ imm = #0x2528
700a9fb8: 9004         	str	r0, [sp, #0x10]
;     HW_WR_REG32(baseAddr + UART_FCR, fcrValue);
700a9fba: 9807         	ldr	r0, [sp, #0x1c]
700a9fbc: 3008         	adds	r0, #0x8
700a9fbe: 9906         	ldr	r1, [sp, #0x18]
700a9fc0: f004 f816    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x402c
;     while(isTxRxFifoEmpty == FALSE)
700a9fc4: e7ff         	b	0x700a9fc6 <UART_fifoRegisterWrite+0x36> @ imm = #-0x2
700a9fc6: 9802         	ldr	r0, [sp, #0x8]
700a9fc8: b928         	cbnz	r0, 0x700a9fd6 <UART_fifoRegisterWrite+0x46> @ imm = #0xa
700a9fca: e7ff         	b	0x700a9fcc <UART_fifoRegisterWrite+0x3c> @ imm = #-0x2
;         isTxRxFifoEmpty = UART_IsTxRxFifoEmpty(baseAddr);
700a9fcc: 9807         	ldr	r0, [sp, #0x1c]
700a9fce: f002 fa67    	bl	0x700ac4a0 <UART_IsTxRxFifoEmpty> @ imm = #0x24ce
700a9fd2: 9002         	str	r0, [sp, #0x8]
;     while(isTxRxFifoEmpty == FALSE)
700a9fd4: e7f7         	b	0x700a9fc6 <UART_fifoRegisterWrite+0x36> @ imm = #-0x12
;     UART_enhanFuncBitValRestore(baseAddr, enhanFnBitVal);
700a9fd6: 9807         	ldr	r0, [sp, #0x1c]
700a9fd8: 9904         	ldr	r1, [sp, #0x10]
700a9fda: f002 fd99    	bl	0x700acb10 <UART_enhanFuncBitValRestore> @ imm = #0x2b32
;     (void) UART_divisorLatchWrite(baseAddr, divLatchRegVal);
700a9fde: 9807         	ldr	r0, [sp, #0x1c]
700a9fe0: 9905         	ldr	r1, [sp, #0x14]
700a9fe2: f7f9 f8c5    	bl	0x700a3170 <UART_divisorLatchWrite> @ imm = #-0x6e76
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a9fe6: 9807         	ldr	r0, [sp, #0x1c]
700a9fe8: 300c         	adds	r0, #0xc
700a9fea: 9903         	ldr	r1, [sp, #0xc]
700a9fec: f004 f800    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x4000
; }
700a9ff0: b008         	add	sp, #0x20
700a9ff2: bd80         	pop	{r7, pc}
		...

700aa000 <UART_lld_deInitDma>:
; {
700aa000: b580         	push	{r7, lr}
700aa002: b084         	sub	sp, #0x10
700aa004: 9003         	str	r0, [sp, #0xc]
700aa006: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700aa008: 9002         	str	r0, [sp, #0x8]
;     if (NULL_PTR != hUart)
700aa00a: 9803         	ldr	r0, [sp, #0xc]
700aa00c: b318         	cbz	r0, 0x700aa056 <UART_lld_deInitDma+0x56> @ imm = #0x46
700aa00e: e7ff         	b	0x700aa010 <UART_lld_deInitDma+0x10> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700aa010: 9903         	ldr	r1, [sp, #0xc]
700aa012: 2002         	movs	r0, #0x2
700aa014: 6548         	str	r0, [r1, #0x54]
;        status = UART_lld_flushTxFifo(hUart);
700aa016: 9803         	ldr	r0, [sp, #0xc]
700aa018: f7fe fc7a    	bl	0x700a8910 <UART_lld_flushTxFifo> @ imm = #-0x170c
700aa01c: 9002         	str	r0, [sp, #0x8]
;         if(status == UART_STATUS_SUCCESS)
700aa01e: 9802         	ldr	r0, [sp, #0x8]
700aa020: b9a0         	cbnz	r0, 0x700aa04c <UART_lld_deInitDma+0x4c> @ imm = #0x28
700aa022: e7ff         	b	0x700aa024 <UART_lld_deInitDma+0x24> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr,
700aa024: 9803         	ldr	r0, [sp, #0xc]
700aa026: 6800         	ldr	r0, [r0]
700aa028: 2107         	movs	r1, #0x7
700aa02a: 9101         	str	r1, [sp, #0x4]
700aa02c: f7fa fb88    	bl	0x700a4740 <UART_intrDisable> @ imm = #-0x58f0
;             UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700aa030: 9803         	ldr	r0, [sp, #0xc]
700aa032: 6800         	ldr	r0, [r0]
700aa034: 2102         	movs	r1, #0x2
700aa036: f003 f8f3    	bl	0x700ad220 <UART_intr2Disable> @ imm = #0x31e6
700aa03a: 9901         	ldr	r1, [sp, #0x4]
;             (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700aa03c: 9803         	ldr	r0, [sp, #0xc]
700aa03e: 6800         	ldr	r0, [r0]
700aa040: f003 f936    	bl	0x700ad2b0 <UART_operatingModeSelect> @ imm = #0x326c
;             hUart->state = UART_STATE_RESET;
700aa044: 9903         	ldr	r1, [sp, #0xc]
700aa046: 2000         	movs	r0, #0x0
700aa048: 6548         	str	r0, [r1, #0x54]
;         }
700aa04a: e7ff         	b	0x700aa04c <UART_lld_deInitDma+0x4c> @ imm = #-0x2
;         status = UART_lld_dmaDeInit(hUart);
700aa04c: 9803         	ldr	r0, [sp, #0xc]
700aa04e: f002 fa67    	bl	0x700ac520 <UART_lld_dmaDeInit> @ imm = #0x24ce
700aa052: 9002         	str	r0, [sp, #0x8]
;     }
700aa054: e003         	b	0x700aa05e <UART_lld_deInitDma+0x5e> @ imm = #0x6
700aa056: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700aa05a: 9002         	str	r0, [sp, #0x8]
700aa05c: e7ff         	b	0x700aa05e <UART_lld_deInitDma+0x5e> @ imm = #-0x2
;     return status;
700aa05e: 9802         	ldr	r0, [sp, #0x8]
700aa060: b004         	add	sp, #0x10
700aa062: bd80         	pop	{r7, pc}
		...

700aa070 <Udma_rmFreeEvent>:
; {
700aa070: b580         	push	{r7, lr}
700aa072: b088         	sub	sp, #0x20
700aa074: 9007         	str	r0, [sp, #0x1c]
700aa076: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa078: 9806         	ldr	r0, [sp, #0x18]
700aa07a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa07e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa080: 9806         	ldr	r0, [sp, #0x18]
700aa082: f500 609f    	add.w	r0, r0, #0x4f8
700aa086: f04f 31ff    	mov.w	r1, #0xffffffff
700aa08a: f7fe fdf1    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #-0x141e
;     i = globalEvent - rmInitPrms->startGlobalEvent;
700aa08e: 9807         	ldr	r0, [sp, #0x1c]
700aa090: 9901         	ldr	r1, [sp, #0x4]
700aa092: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700aa096: 1a40         	subs	r0, r0, r1
700aa098: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa09a: 9805         	ldr	r0, [sp, #0x14]
700aa09c: 0940         	lsrs	r0, r0, #0x5
700aa09e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa0a0: 9805         	ldr	r0, [sp, #0x14]
700aa0a2: 9904         	ldr	r1, [sp, #0x10]
700aa0a4: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa0a8: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa0aa: 9903         	ldr	r1, [sp, #0xc]
700aa0ac: 2001         	movs	r0, #0x1
700aa0ae: 4088         	lsls	r0, r1
700aa0b0: 9002         	str	r0, [sp, #0x8]
;     drvHandle->globalEventFlag[offset] |= bitMask;
700aa0b2: 9a02         	ldr	r2, [sp, #0x8]
700aa0b4: 9806         	ldr	r0, [sp, #0x18]
700aa0b6: 9904         	ldr	r1, [sp, #0x10]
700aa0b8: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa0bc: f8d1 0424    	ldr.w	r0, [r1, #0x424]
700aa0c0: 4310         	orrs	r0, r2
700aa0c2: f8c1 0424    	str.w	r0, [r1, #0x424]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa0c6: 9806         	ldr	r0, [sp, #0x18]
700aa0c8: f500 609f    	add.w	r0, r0, #0x4f8
700aa0cc: f000 f920    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x240
;     return;
700aa0d0: b008         	add	sp, #0x20
700aa0d2: bd80         	pop	{r7, pc}
		...

700aa0e0 <Udma_rmFreeIrIntr>:
; {
700aa0e0: b580         	push	{r7, lr}
700aa0e2: b088         	sub	sp, #0x20
700aa0e4: 9007         	str	r0, [sp, #0x1c]
700aa0e6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa0e8: 9806         	ldr	r0, [sp, #0x18]
700aa0ea: f500 70ea    	add.w	r0, r0, #0x1d4
700aa0ee: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa0f0: 9806         	ldr	r0, [sp, #0x18]
700aa0f2: f500 609f    	add.w	r0, r0, #0x4f8
700aa0f6: f04f 31ff    	mov.w	r1, #0xffffffff
700aa0fa: f7fe fdb9    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #-0x148e
;     i = irIntrNum - rmInitPrms->startIrIntr;
700aa0fe: 9807         	ldr	r0, [sp, #0x1c]
700aa100: 9901         	ldr	r1, [sp, #0x4]
700aa102: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700aa106: 1a40         	subs	r0, r0, r1
700aa108: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa10a: 9805         	ldr	r0, [sp, #0x14]
700aa10c: 0940         	lsrs	r0, r0, #0x5
700aa10e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa110: 9805         	ldr	r0, [sp, #0x14]
700aa112: 9904         	ldr	r1, [sp, #0x10]
700aa114: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa118: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa11a: 9903         	ldr	r1, [sp, #0xc]
700aa11c: 2001         	movs	r0, #0x1
700aa11e: 4088         	lsls	r0, r1
700aa120: 9002         	str	r0, [sp, #0x8]
;     drvHandle->irIntrFlag[offset] |= bitMask;
700aa122: 9a02         	ldr	r2, [sp, #0x8]
700aa124: 9806         	ldr	r0, [sp, #0x18]
700aa126: 9904         	ldr	r1, [sp, #0x10]
700aa128: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa12c: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700aa130: 4310         	orrs	r0, r2
700aa132: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa136: 9806         	ldr	r0, [sp, #0x18]
700aa138: f500 609f    	add.w	r0, r0, #0x4f8
700aa13c: f000 f8e8    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x1d0
;     return;
700aa140: b008         	add	sp, #0x20
700aa142: bd80         	pop	{r7, pc}
		...

700aa150 <Udma_rmFreeVintr>:
; {
700aa150: b580         	push	{r7, lr}
700aa152: b088         	sub	sp, #0x20
700aa154: 9007         	str	r0, [sp, #0x1c]
700aa156: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa158: 9806         	ldr	r0, [sp, #0x18]
700aa15a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa15e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa160: 9806         	ldr	r0, [sp, #0x18]
700aa162: f500 609f    	add.w	r0, r0, #0x4f8
700aa166: f04f 31ff    	mov.w	r1, #0xffffffff
700aa16a: f7fe fd81    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #-0x14fe
;     i = vintrNum - rmInitPrms->startVintr;
700aa16e: 9807         	ldr	r0, [sp, #0x1c]
700aa170: 9901         	ldr	r1, [sp, #0x4]
700aa172: f8d1 10e0    	ldr.w	r1, [r1, #0xe0]
700aa176: 1a40         	subs	r0, r0, r1
700aa178: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa17a: 9805         	ldr	r0, [sp, #0x14]
700aa17c: 0940         	lsrs	r0, r0, #0x5
700aa17e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa180: 9805         	ldr	r0, [sp, #0x14]
700aa182: 9904         	ldr	r1, [sp, #0x10]
700aa184: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa188: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa18a: 9903         	ldr	r1, [sp, #0xc]
700aa18c: 2001         	movs	r0, #0x1
700aa18e: 4088         	lsls	r0, r1
700aa190: 9002         	str	r0, [sp, #0x8]
;     drvHandle->vintrFlag[offset] |= bitMask;
700aa192: 9a02         	ldr	r2, [sp, #0x8]
700aa194: 9806         	ldr	r0, [sp, #0x18]
700aa196: 9904         	ldr	r1, [sp, #0x10]
700aa198: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa19c: f8d1 04a4    	ldr.w	r0, [r1, #0x4a4]
700aa1a0: 4310         	orrs	r0, r2
700aa1a2: f8c1 04a4    	str.w	r0, [r1, #0x4a4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa1a6: 9806         	ldr	r0, [sp, #0x18]
700aa1a8: f500 609f    	add.w	r0, r0, #0x4f8
700aa1ac: f000 f8b0    	bl	0x700aa310 <SemaphoreP_post> @ imm = #0x160
;     return;
700aa1b0: b008         	add	sp, #0x20
700aa1b2: bd80         	pop	{r7, pc}
		...

700aa1c0 <task_synchronisation_initialize>:
; {
700aa1c0: b580         	push	{r7, lr}
;    tm_setup_pmu();
700aa1c2: f003 fe9d    	bl	0x700adf00 <tm_setup_pmu> @ imm = #0x3d3a
;    tm_mutex_create(MUTEX_ID);
700aa1c6: 2001         	movs	r0, #0x1
700aa1c8: f001 fa8a    	bl	0x700ab6e0 <tm_mutex_create> @ imm = #0x1514
;    tm_semaphore_create(SEM_A);
700aa1cc: 2001         	movs	r0, #0x1
700aa1ce: f002 fcdf    	bl	0x700acb90 <tm_semaphore_create> @ imm = #0x29be
;    tm_semaphore_create(SEM_B);
700aa1d2: 2002         	movs	r0, #0x2
700aa1d4: f002 fcdc    	bl	0x700acb90 <tm_semaphore_create> @ imm = #0x29b8
;    tm_semaphore_get(SEM_A);
700aa1d8: 2001         	movs	r0, #0x1
700aa1da: f003 fc39    	bl	0x700ada50 <tm_semaphore_get> @ imm = #0x3872
;    tm_thread_create(1, 5, writer_task1);
700aa1de: f24d 1231    	movw	r2, #0xd131
700aa1e2: 2001         	movs	r0, #0x1
700aa1e4: f2c7 020a    	movt	r2, #0x700a
700aa1e8: 2105         	movs	r1, #0x5
700aa1ea: f002 fb19    	bl	0x700ac820 <tm_thread_create> @ imm = #0x2632
;    tm_thread_create(2, 5, writer_task2);
700aa1ee: f24d 1261    	movw	r2, #0xd161
700aa1f2: 2002         	movs	r0, #0x2
700aa1f4: f2c7 020a    	movt	r2, #0x700a
700aa1f8: 2105         	movs	r1, #0x5
700aa1fa: f002 fb11    	bl	0x700ac820 <tm_thread_create> @ imm = #0x2622
;    tm_thread_create(3, 1, reporting_thread);
700aa1fe: f246 7251    	movw	r2, #0x6751
700aa202: 2003         	movs	r0, #0x3
700aa204: f2c7 020a    	movt	r2, #0x700a
700aa208: 2101         	movs	r1, #0x1
700aa20a: f002 fb09    	bl	0x700ac820 <tm_thread_create> @ imm = #0x2612
;    tm_thread_resume(1);
700aa20e: 2001         	movs	r0, #0x1
700aa210: f003 fdc6    	bl	0x700adda0 <tm_thread_resume> @ imm = #0x3b8c
;    tm_thread_resume(2);
700aa214: 2002         	movs	r0, #0x2
700aa216: f003 fdc3    	bl	0x700adda0 <tm_thread_resume> @ imm = #0x3b86
;    tm_thread_resume(3);
700aa21a: 2003         	movs	r0, #0x3
700aa21c: e8bd 4080    	pop.w	{r7, lr}
700aa220: f003 bdbe    	b.w	0x700adda0 <tm_thread_resume> @ imm = #0x3b7c
		...

700aa230 <vApplicationLoadHook>:
; {
700aa230: b580         	push	{r7, lr}
700aa232: b082         	sub	sp, #0x8
;     uint64_t curUpdateTime = ClockP_getTimeUsec();
700aa234: f7fe fef4    	bl	0x700a9020 <ClockP_getTimeUsec> @ imm = #-0x1218
700aa238: 9101         	str	r1, [sp, #0x4]
700aa23a: 9000         	str	r0, [sp]
;     if( (curUpdateTime > lastUpdateTime) && ((curUpdateTime - lastUpdateTime) > (TaskP_LOAD_UPDATE_WINDOW_MSEC*1000u )) )
700aa23c: 9b00         	ldr	r3, [sp]
700aa23e: 9901         	ldr	r1, [sp, #0x4]
700aa240: f640 5070    	movw	r0, #0xd70
700aa244: f2c7 000b    	movt	r0, #0x700b
700aa248: 6802         	ldr	r2, [r0]
700aa24a: 6840         	ldr	r0, [r0, #0x4]
700aa24c: 1ad2         	subs	r2, r2, r3
700aa24e: 4188         	sbcs	r0, r1
700aa250: d21e         	bhs	0x700aa290 <vApplicationLoadHook+0x60> @ imm = #0x3c
700aa252: e7ff         	b	0x700aa254 <vApplicationLoadHook+0x24> @ imm = #-0x2
700aa254: 9900         	ldr	r1, [sp]
700aa256: 9801         	ldr	r0, [sp, #0x4]
700aa258: f640 5270    	movw	r2, #0xd70
700aa25c: f2c7 020b    	movt	r2, #0x700b
700aa260: 6813         	ldr	r3, [r2]
700aa262: 6852         	ldr	r2, [r2, #0x4]
700aa264: 1ac9         	subs	r1, r1, r3
700aa266: 4190         	sbcs	r0, r2
700aa268: f24a 1221    	movw	r2, #0xa121
700aa26c: f2c0 0207    	movt	r2, #0x7
700aa270: 1a89         	subs	r1, r1, r2
700aa272: f170 0000    	sbcs	r0, r0, #0x0
700aa276: d30b         	blo	0x700aa290 <vApplicationLoadHook+0x60> @ imm = #0x16
700aa278: e7ff         	b	0x700aa27a <vApplicationLoadHook+0x4a> @ imm = #-0x2
;         TaskP_loadUpdateAll();
700aa27a: f7f8 fdd1    	bl	0x700a2e20 <TaskP_loadUpdateAll> @ imm = #-0x745e
;         lastUpdateTime = curUpdateTime;
700aa27e: 9800         	ldr	r0, [sp]
700aa280: 9a01         	ldr	r2, [sp, #0x4]
700aa282: f640 5170    	movw	r1, #0xd70
700aa286: f2c7 010b    	movt	r1, #0x700b
700aa28a: 604a         	str	r2, [r1, #0x4]
700aa28c: 6008         	str	r0, [r1]
;     }
700aa28e: e7ff         	b	0x700aa290 <vApplicationLoadHook+0x60> @ imm = #-0x2
; }
700aa290: b002         	add	sp, #0x8
700aa292: bd80         	pop	{r7, pc}
		...

700aa2a0 <vQueueWaitForMessageRestricted>:
;     {
700aa2a0: b580         	push	{r7, lr}
700aa2a2: b084         	sub	sp, #0x10
700aa2a4: 9003         	str	r0, [sp, #0xc]
700aa2a6: 9102         	str	r1, [sp, #0x8]
700aa2a8: 9201         	str	r2, [sp, #0x4]
;         Queue_t * const pxQueue = xQueue;
700aa2aa: 9803         	ldr	r0, [sp, #0xc]
700aa2ac: 9000         	str	r0, [sp]
;         prvLockQueue( pxQueue );
700aa2ae: f002 fc8f    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0x291e
700aa2b2: 9800         	ldr	r0, [sp]
700aa2b4: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700aa2b8: 3001         	adds	r0, #0x1
700aa2ba: b928         	cbnz	r0, 0x700aa2c8 <vQueueWaitForMessageRestricted+0x28> @ imm = #0xa
700aa2bc: e7ff         	b	0x700aa2be <vQueueWaitForMessageRestricted+0x1e> @ imm = #-0x2
700aa2be: 9900         	ldr	r1, [sp]
700aa2c0: 2000         	movs	r0, #0x0
700aa2c2: f881 0044    	strb.w	r0, [r1, #0x44]
700aa2c6: e7ff         	b	0x700aa2c8 <vQueueWaitForMessageRestricted+0x28> @ imm = #-0x2
700aa2c8: 9800         	ldr	r0, [sp]
700aa2ca: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700aa2ce: 3001         	adds	r0, #0x1
700aa2d0: b928         	cbnz	r0, 0x700aa2de <vQueueWaitForMessageRestricted+0x3e> @ imm = #0xa
700aa2d2: e7ff         	b	0x700aa2d4 <vQueueWaitForMessageRestricted+0x34> @ imm = #-0x2
700aa2d4: 9900         	ldr	r1, [sp]
700aa2d6: 2000         	movs	r0, #0x0
700aa2d8: f881 0045    	strb.w	r0, [r1, #0x45]
700aa2dc: e7ff         	b	0x700aa2de <vQueueWaitForMessageRestricted+0x3e> @ imm = #-0x2
700aa2de: f001 fcf7    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x19ee
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
700aa2e2: 9800         	ldr	r0, [sp]
700aa2e4: 6b80         	ldr	r0, [r0, #0x38]
700aa2e6: b938         	cbnz	r0, 0x700aa2f8 <vQueueWaitForMessageRestricted+0x58> @ imm = #0xe
700aa2e8: e7ff         	b	0x700aa2ea <vQueueWaitForMessageRestricted+0x4a> @ imm = #-0x2
;             vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
700aa2ea: 9800         	ldr	r0, [sp]
700aa2ec: 3024         	adds	r0, #0x24
700aa2ee: 9902         	ldr	r1, [sp, #0x8]
700aa2f0: 9a01         	ldr	r2, [sp, #0x4]
700aa2f2: f002 fad5    	bl	0x700ac8a0 <vTaskPlaceOnEventListRestricted> @ imm = #0x25aa
;         }
700aa2f6: e000         	b	0x700aa2fa <vQueueWaitForMessageRestricted+0x5a> @ imm = #0x0
700aa2f8: e7ff         	b	0x700aa2fa <vQueueWaitForMessageRestricted+0x5a> @ imm = #-0x2
;         prvUnlockQueue( pxQueue );
700aa2fa: 9800         	ldr	r0, [sp]
700aa2fc: f7fb ffc0    	bl	0x700a6280 <prvUnlockQueue> @ imm = #-0x4080
;     }
700aa300: b004         	add	sp, #0x10
700aa302: bd80         	pop	{r7, pc}
		...

700aa310 <SemaphoreP_post>:
; {
700aa310: b580         	push	{r7, lr}
700aa312: b084         	sub	sp, #0x10
700aa314: 9003         	str	r0, [sp, #0xc]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700aa316: 9803         	ldr	r0, [sp, #0xc]
700aa318: 9002         	str	r0, [sp, #0x8]
;     if(pSemaphore->isRecursiveMutex != 0U)
700aa31a: 9802         	ldr	r0, [sp, #0x8]
700aa31c: 6d40         	ldr	r0, [r0, #0x54]
700aa31e: b170         	cbz	r0, 0x700aa33e <SemaphoreP_post+0x2e> @ imm = #0x1c
700aa320: e7ff         	b	0x700aa322 <SemaphoreP_post+0x12> @ imm = #-0x2
;         if( HwiP_inISR() == 0U)
700aa322: f004 fa6d    	bl	0x700ae800 <HwiP_inISR> @ imm = #0x44da
700aa326: b928         	cbnz	r0, 0x700aa334 <SemaphoreP_post+0x24> @ imm = #0xa
700aa328: e7ff         	b	0x700aa32a <SemaphoreP_post+0x1a> @ imm = #-0x2
;             (void)xSemaphoreGiveRecursive(pSemaphore->semHndl);
700aa32a: 9802         	ldr	r0, [sp, #0x8]
700aa32c: 6d00         	ldr	r0, [r0, #0x50]
700aa32e: f001 f937    	bl	0x700ab5a0 <xQueueGiveMutexRecursive> @ imm = #0x126e
;         }
700aa332: e003         	b	0x700aa33c <SemaphoreP_post+0x2c> @ imm = #0x6
700aa334: 2000         	movs	r0, #0x0
;             DebugP_assertNoLog(0);
700aa336: f005 fa03    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x5406
700aa33a: e7ff         	b	0x700aa33c <SemaphoreP_post+0x2c> @ imm = #-0x2
;     }
700aa33c: e017         	b	0x700aa36e <SemaphoreP_post+0x5e> @ imm = #0x2e
;         if( HwiP_inISR() != 0U)
700aa33e: f004 fa5f    	bl	0x700ae800 <HwiP_inISR> @ imm = #0x44be
700aa342: b158         	cbz	r0, 0x700aa35c <SemaphoreP_post+0x4c> @ imm = #0x16
700aa344: e7ff         	b	0x700aa346 <SemaphoreP_post+0x36> @ imm = #-0x2
700aa346: 2000         	movs	r0, #0x0
;             BaseType_t xHigherPriorityTaskWoken = 0;
700aa348: 9001         	str	r0, [sp, #0x4]
;             (void)xSemaphoreGiveFromISR(pSemaphore->semHndl, &xHigherPriorityTaskWoken);
700aa34a: 9802         	ldr	r0, [sp, #0x8]
700aa34c: 6d00         	ldr	r0, [r0, #0x50]
700aa34e: a901         	add	r1, sp, #0x4
700aa350: f7fd fdee    	bl	0x700a7f30 <xQueueGiveFromISR> @ imm = #-0x2424
;             portYIELD_FROM_ISR((uint32_t)xHigherPriorityTaskWoken);
700aa354: 9801         	ldr	r0, [sp, #0x4]
700aa356: f003 fb8b    	bl	0x700ada70 <vPortYeildFromISR> @ imm = #0x3716
;         }
700aa35a: e007         	b	0x700aa36c <SemaphoreP_post+0x5c> @ imm = #0xe
;             (void)xSemaphoreGive(pSemaphore->semHndl);
700aa35c: 9802         	ldr	r0, [sp, #0x8]
700aa35e: 6d00         	ldr	r0, [r0, #0x50]
700aa360: 2300         	movs	r3, #0x0
700aa362: 4619         	mov	r1, r3
700aa364: 461a         	mov	r2, r3
700aa366: f7f7 facb    	bl	0x700a1900 <xQueueGenericSend> @ imm = #-0x8a6a
700aa36a: e7ff         	b	0x700aa36c <SemaphoreP_post+0x5c> @ imm = #-0x2
700aa36c: e7ff         	b	0x700aa36e <SemaphoreP_post+0x5e> @ imm = #-0x2
; }
700aa36e: b004         	add	sp, #0x10
700aa370: bd80         	pop	{r7, pc}
		...
700aa37e: 0000         	movs	r0, r0

700aa380 <UdmaEventPrms_init>:
; {
700aa380: b082         	sub	sp, #0x8
700aa382: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != eventPrms)
700aa384: 9801         	ldr	r0, [sp, #0x4]
700aa386: b350         	cbz	r0, 0x700aa3de <UdmaEventPrms_init+0x5e> @ imm = #0x54
700aa388: e7ff         	b	0x700aa38a <UdmaEventPrms_init+0xa> @ imm = #-0x2
;         eventPrms->eventType            = UDMA_EVENT_TYPE_DMA_COMPLETION;
700aa38a: 9801         	ldr	r0, [sp, #0x4]
700aa38c: 2101         	movs	r1, #0x1
700aa38e: 6001         	str	r1, [r0]
;         eventPrms->eventMode            = UDMA_EVENT_MODE_SHARED;
700aa390: 9a01         	ldr	r2, [sp, #0x4]
700aa392: 2002         	movs	r0, #0x2
700aa394: 6050         	str	r0, [r2, #0x4]
;         eventPrms->chHandle             = (Udma_ChHandle) NULL_PTR;
700aa396: 9a01         	ldr	r2, [sp, #0x4]
700aa398: 2000         	movs	r0, #0x0
700aa39a: 9000         	str	r0, [sp]
700aa39c: 6090         	str	r0, [r2, #0x8]
;         eventPrms->ringHandle           = (Udma_RingHandle) NULL_PTR;
700aa39e: 9a01         	ldr	r2, [sp, #0x4]
700aa3a0: 60d0         	str	r0, [r2, #0xc]
;         eventPrms->controllerEventHandle    = (Udma_EventHandle) NULL_PTR;
700aa3a2: 9a01         	ldr	r2, [sp, #0x4]
700aa3a4: 6110         	str	r0, [r2, #0x10]
;         eventPrms->eventCb              = (Udma_EventCallback) NULL_PTR;
700aa3a6: 9a01         	ldr	r2, [sp, #0x4]
700aa3a8: 6150         	str	r0, [r2, #0x14]
;         eventPrms->intrPriority         = 1U;
700aa3aa: 9a01         	ldr	r2, [sp, #0x4]
700aa3ac: 6191         	str	r1, [r2, #0x18]
;         eventPrms->appData              = NULL_PTR;
700aa3ae: 9901         	ldr	r1, [sp, #0x4]
700aa3b0: 61c8         	str	r0, [r1, #0x1c]
;         eventPrms->preferredCoreIntrNum = UDMA_CORE_INTR_ANY;
700aa3b2: 9a01         	ldr	r2, [sp, #0x4]
700aa3b4: 2101         	movs	r1, #0x1
700aa3b6: f6cf 71ff    	movt	r1, #0xffff
700aa3ba: 6211         	str	r1, [r2, #0x20]
;         eventPrms->intrStatusReg        = (volatile uint64_t *) NULL_PTR;
700aa3bc: 9901         	ldr	r1, [sp, #0x4]
700aa3be: 6248         	str	r0, [r1, #0x24]
;         eventPrms->intrClearReg         = (volatile uint64_t *) NULL_PTR;
700aa3c0: 9901         	ldr	r1, [sp, #0x4]
700aa3c2: 6288         	str	r0, [r1, #0x28]
;         eventPrms->intrMask             = 0U;
700aa3c4: 9901         	ldr	r1, [sp, #0x4]
700aa3c6: 6348         	str	r0, [r1, #0x34]
700aa3c8: 6308         	str	r0, [r1, #0x30]
;         eventPrms->vintrNum             = UDMA_EVENT_INVALID;
700aa3ca: 9901         	ldr	r1, [sp, #0x4]
700aa3cc: f64f 70ff    	movw	r0, #0xffff
700aa3d0: 6388         	str	r0, [r1, #0x38]
;         eventPrms->coreIntrNum          = UDMA_INTR_INVALID;
700aa3d2: 9901         	ldr	r1, [sp, #0x4]
700aa3d4: 2000         	movs	r0, #0x0
700aa3d6: f6cf 70ff    	movt	r0, #0xffff
700aa3da: 63c8         	str	r0, [r1, #0x3c]
;     }
700aa3dc: e7ff         	b	0x700aa3de <UdmaEventPrms_init+0x5e> @ imm = #-0x2
;     return;
700aa3de: b002         	add	sp, #0x8
700aa3e0: 4770         	bx	lr
		...
700aa3ee: 0000         	movs	r0, r0

700aa3f0 <Udma_rmFreeBlkCopyCh>:
; {
700aa3f0: b580         	push	{r7, lr}
700aa3f2: b088         	sub	sp, #0x20
700aa3f4: 9007         	str	r0, [sp, #0x1c]
700aa3f6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa3f8: 9806         	ldr	r0, [sp, #0x18]
700aa3fa: f500 70ea    	add.w	r0, r0, #0x1d4
700aa3fe: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa400: 9806         	ldr	r0, [sp, #0x18]
700aa402: f500 609f    	add.w	r0, r0, #0x4f8
700aa406: f04f 31ff    	mov.w	r1, #0xffffffff
700aa40a: f7fe fc31    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #-0x179e
;     i = chNum - rmInitPrms->startBlkCopyCh;
700aa40e: 9807         	ldr	r0, [sp, #0x1c]
700aa410: 9901         	ldr	r1, [sp, #0x4]
700aa412: 6909         	ldr	r1, [r1, #0x10]
700aa414: 1a40         	subs	r0, r0, r1
700aa416: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa418: 9805         	ldr	r0, [sp, #0x14]
700aa41a: 0940         	lsrs	r0, r0, #0x5
700aa41c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa41e: 9805         	ldr	r0, [sp, #0x14]
700aa420: 9904         	ldr	r1, [sp, #0x10]
700aa422: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa426: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa428: 9903         	ldr	r1, [sp, #0xc]
700aa42a: 2001         	movs	r0, #0x1
700aa42c: 4088         	lsls	r0, r1
700aa42e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyChFlag[offset] |= bitMask;
700aa430: 9a02         	ldr	r2, [sp, #0x8]
700aa432: 9806         	ldr	r0, [sp, #0x18]
700aa434: 9904         	ldr	r1, [sp, #0x10]
700aa436: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa43a: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700aa43e: 4310         	orrs	r0, r2
700aa440: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa444: 9806         	ldr	r0, [sp, #0x18]
700aa446: f500 609f    	add.w	r0, r0, #0x4f8
700aa44a: f7ff ff61    	bl	0x700aa310 <SemaphoreP_post> @ imm = #-0x13e
;     return;
700aa44e: b008         	add	sp, #0x20
700aa450: bd80         	pop	{r7, pc}
		...
700aa45e: 0000         	movs	r0, r0

700aa460 <Udma_rmFreeBlkCopyHcCh>:
; {
700aa460: b580         	push	{r7, lr}
700aa462: b088         	sub	sp, #0x20
700aa464: 9007         	str	r0, [sp, #0x1c]
700aa466: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa468: 9806         	ldr	r0, [sp, #0x18]
700aa46a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa46e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa470: 9806         	ldr	r0, [sp, #0x18]
700aa472: f500 609f    	add.w	r0, r0, #0x4f8
700aa476: f04f 31ff    	mov.w	r1, #0xffffffff
700aa47a: f7fe fbf9    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #-0x180e
;     i = chNum - rmInitPrms->startBlkCopyHcCh;
700aa47e: 9807         	ldr	r0, [sp, #0x1c]
700aa480: 9901         	ldr	r1, [sp, #0x4]
700aa482: 6889         	ldr	r1, [r1, #0x8]
700aa484: 1a40         	subs	r0, r0, r1
700aa486: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa488: 9805         	ldr	r0, [sp, #0x14]
700aa48a: 0940         	lsrs	r0, r0, #0x5
700aa48c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa48e: 9805         	ldr	r0, [sp, #0x14]
700aa490: 9904         	ldr	r1, [sp, #0x10]
700aa492: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa496: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa498: 9903         	ldr	r1, [sp, #0xc]
700aa49a: 2001         	movs	r0, #0x1
700aa49c: 4088         	lsls	r0, r1
700aa49e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyHcChFlag[offset] |= bitMask;
700aa4a0: 9a02         	ldr	r2, [sp, #0x8]
700aa4a2: 9806         	ldr	r0, [sp, #0x18]
700aa4a4: 9904         	ldr	r1, [sp, #0x10]
700aa4a6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa4aa: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700aa4ae: 4310         	orrs	r0, r2
700aa4b0: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa4b4: 9806         	ldr	r0, [sp, #0x18]
700aa4b6: f500 609f    	add.w	r0, r0, #0x4f8
700aa4ba: f7ff ff29    	bl	0x700aa310 <SemaphoreP_post> @ imm = #-0x1ae
;     return;
700aa4be: b008         	add	sp, #0x20
700aa4c0: bd80         	pop	{r7, pc}
		...
700aa4ce: 0000         	movs	r0, r0

700aa4d0 <Udma_rmFreeBlkCopyUhcCh>:
; {
700aa4d0: b580         	push	{r7, lr}
700aa4d2: b088         	sub	sp, #0x20
700aa4d4: 9007         	str	r0, [sp, #0x1c]
700aa4d6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa4d8: 9806         	ldr	r0, [sp, #0x18]
700aa4da: f500 70ea    	add.w	r0, r0, #0x1d4
700aa4de: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa4e0: 9806         	ldr	r0, [sp, #0x18]
700aa4e2: f500 609f    	add.w	r0, r0, #0x4f8
700aa4e6: f04f 31ff    	mov.w	r1, #0xffffffff
700aa4ea: f7fe fbc1    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #-0x187e
;     i = chNum - rmInitPrms->startBlkCopyUhcCh;
700aa4ee: 9807         	ldr	r0, [sp, #0x1c]
700aa4f0: 9901         	ldr	r1, [sp, #0x4]
700aa4f2: 6809         	ldr	r1, [r1]
700aa4f4: 1a40         	subs	r0, r0, r1
700aa4f6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa4f8: 9805         	ldr	r0, [sp, #0x14]
700aa4fa: 0940         	lsrs	r0, r0, #0x5
700aa4fc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa4fe: 9805         	ldr	r0, [sp, #0x14]
700aa500: 9904         	ldr	r1, [sp, #0x10]
700aa502: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa506: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa508: 9903         	ldr	r1, [sp, #0xc]
700aa50a: 2001         	movs	r0, #0x1
700aa50c: 4088         	lsls	r0, r1
700aa50e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyUhcChFlag[offset] |= bitMask;
700aa510: 9a02         	ldr	r2, [sp, #0x8]
700aa512: 9806         	ldr	r0, [sp, #0x18]
700aa514: 9904         	ldr	r1, [sp, #0x10]
700aa516: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa51a: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700aa51e: 4310         	orrs	r0, r2
700aa520: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa524: 9806         	ldr	r0, [sp, #0x18]
700aa526: f500 609f    	add.w	r0, r0, #0x4f8
700aa52a: f7ff fef1    	bl	0x700aa310 <SemaphoreP_post> @ imm = #-0x21e
;     return;
700aa52e: b008         	add	sp, #0x20
700aa530: bd80         	pop	{r7, pc}
		...
700aa53e: 0000         	movs	r0, r0

700aa540 <Udma_rmFreeRxCh>:
; {
700aa540: b580         	push	{r7, lr}
700aa542: b088         	sub	sp, #0x20
700aa544: 9007         	str	r0, [sp, #0x1c]
700aa546: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa548: 9806         	ldr	r0, [sp, #0x18]
700aa54a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa54e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa550: 9806         	ldr	r0, [sp, #0x18]
700aa552: f500 609f    	add.w	r0, r0, #0x4f8
700aa556: f04f 31ff    	mov.w	r1, #0xffffffff
700aa55a: f7fe fb89    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #-0x18ee
;     i = chNum - rmInitPrms->startRxCh;
700aa55e: 9807         	ldr	r0, [sp, #0x1c]
700aa560: 9901         	ldr	r1, [sp, #0x4]
700aa562: 6c09         	ldr	r1, [r1, #0x40]
700aa564: 1a40         	subs	r0, r0, r1
700aa566: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa568: 9805         	ldr	r0, [sp, #0x14]
700aa56a: 0940         	lsrs	r0, r0, #0x5
700aa56c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa56e: 9805         	ldr	r0, [sp, #0x14]
700aa570: 9904         	ldr	r1, [sp, #0x10]
700aa572: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa576: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa578: 9903         	ldr	r1, [sp, #0xc]
700aa57a: 2001         	movs	r0, #0x1
700aa57c: 4088         	lsls	r0, r1
700aa57e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxChFlag[offset] |= bitMask;
700aa580: 9a02         	ldr	r2, [sp, #0x8]
700aa582: 9806         	ldr	r0, [sp, #0x18]
700aa584: 9904         	ldr	r1, [sp, #0x10]
700aa586: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa58a: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700aa58e: 4310         	orrs	r0, r2
700aa590: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa594: 9806         	ldr	r0, [sp, #0x18]
700aa596: f500 609f    	add.w	r0, r0, #0x4f8
700aa59a: f7ff feb9    	bl	0x700aa310 <SemaphoreP_post> @ imm = #-0x28e
;     return;
700aa59e: b008         	add	sp, #0x20
700aa5a0: bd80         	pop	{r7, pc}
		...
700aa5ae: 0000         	movs	r0, r0

700aa5b0 <Udma_rmFreeRxHcCh>:
; {
700aa5b0: b580         	push	{r7, lr}
700aa5b2: b088         	sub	sp, #0x20
700aa5b4: 9007         	str	r0, [sp, #0x1c]
700aa5b6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa5b8: 9806         	ldr	r0, [sp, #0x18]
700aa5ba: f500 70ea    	add.w	r0, r0, #0x1d4
700aa5be: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa5c0: 9806         	ldr	r0, [sp, #0x18]
700aa5c2: f500 609f    	add.w	r0, r0, #0x4f8
700aa5c6: f04f 31ff    	mov.w	r1, #0xffffffff
700aa5ca: f7fe fb51    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #-0x195e
;     i = chNum - rmInitPrms->startRxHcCh;
700aa5ce: 9807         	ldr	r0, [sp, #0x1c]
700aa5d0: 9901         	ldr	r1, [sp, #0x4]
700aa5d2: 6b89         	ldr	r1, [r1, #0x38]
700aa5d4: 1a40         	subs	r0, r0, r1
700aa5d6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa5d8: 9805         	ldr	r0, [sp, #0x14]
700aa5da: 0940         	lsrs	r0, r0, #0x5
700aa5dc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa5de: 9805         	ldr	r0, [sp, #0x14]
700aa5e0: 9904         	ldr	r1, [sp, #0x10]
700aa5e2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa5e6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa5e8: 9903         	ldr	r1, [sp, #0xc]
700aa5ea: 2001         	movs	r0, #0x1
700aa5ec: 4088         	lsls	r0, r1
700aa5ee: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxHcChFlag[offset] |= bitMask;
700aa5f0: 9a02         	ldr	r2, [sp, #0x8]
700aa5f2: 9806         	ldr	r0, [sp, #0x18]
700aa5f4: 9904         	ldr	r1, [sp, #0x10]
700aa5f6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa5fa: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700aa5fe: 4310         	orrs	r0, r2
700aa600: f8c1 031c    	str.w	r0, [r1, #0x31c]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa604: 9806         	ldr	r0, [sp, #0x18]
700aa606: f500 609f    	add.w	r0, r0, #0x4f8
700aa60a: f7ff fe81    	bl	0x700aa310 <SemaphoreP_post> @ imm = #-0x2fe
;     return;
700aa60e: b008         	add	sp, #0x20
700aa610: bd80         	pop	{r7, pc}
		...
700aa61e: 0000         	movs	r0, r0

700aa620 <Udma_rmFreeRxUhcCh>:
; {
700aa620: b580         	push	{r7, lr}
700aa622: b088         	sub	sp, #0x20
700aa624: 9007         	str	r0, [sp, #0x1c]
700aa626: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa628: 9806         	ldr	r0, [sp, #0x18]
700aa62a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa62e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa630: 9806         	ldr	r0, [sp, #0x18]
700aa632: f500 609f    	add.w	r0, r0, #0x4f8
700aa636: f04f 31ff    	mov.w	r1, #0xffffffff
700aa63a: f7fe fb19    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #-0x19ce
;     i = chNum - rmInitPrms->startRxUhcCh;
700aa63e: 9807         	ldr	r0, [sp, #0x1c]
700aa640: 9901         	ldr	r1, [sp, #0x4]
700aa642: 6b09         	ldr	r1, [r1, #0x30]
700aa644: 1a40         	subs	r0, r0, r1
700aa646: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa648: 9805         	ldr	r0, [sp, #0x14]
700aa64a: 0940         	lsrs	r0, r0, #0x5
700aa64c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa64e: 9805         	ldr	r0, [sp, #0x14]
700aa650: 9904         	ldr	r1, [sp, #0x10]
700aa652: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa656: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa658: 9903         	ldr	r1, [sp, #0xc]
700aa65a: 2001         	movs	r0, #0x1
700aa65c: 4088         	lsls	r0, r1
700aa65e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxUhcChFlag[offset] |= bitMask;
700aa660: 9a02         	ldr	r2, [sp, #0x8]
700aa662: 9806         	ldr	r0, [sp, #0x18]
700aa664: 9904         	ldr	r1, [sp, #0x10]
700aa666: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa66a: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700aa66e: 4310         	orrs	r0, r2
700aa670: f8c1 0320    	str.w	r0, [r1, #0x320]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa674: 9806         	ldr	r0, [sp, #0x18]
700aa676: f500 609f    	add.w	r0, r0, #0x4f8
700aa67a: f7ff fe49    	bl	0x700aa310 <SemaphoreP_post> @ imm = #-0x36e
;     return;
700aa67e: b008         	add	sp, #0x20
700aa680: bd80         	pop	{r7, pc}
		...
700aa68e: 0000         	movs	r0, r0

700aa690 <Udma_rmFreeTxCh>:
; {
700aa690: b580         	push	{r7, lr}
700aa692: b088         	sub	sp, #0x20
700aa694: 9007         	str	r0, [sp, #0x1c]
700aa696: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa698: 9806         	ldr	r0, [sp, #0x18]
700aa69a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa69e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa6a0: 9806         	ldr	r0, [sp, #0x18]
700aa6a2: f500 609f    	add.w	r0, r0, #0x4f8
700aa6a6: f04f 31ff    	mov.w	r1, #0xffffffff
700aa6aa: f7fe fae1    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #-0x1a3e
;     i = chNum - rmInitPrms->startTxCh;
700aa6ae: 9807         	ldr	r0, [sp, #0x1c]
700aa6b0: 9901         	ldr	r1, [sp, #0x4]
700aa6b2: 6a89         	ldr	r1, [r1, #0x28]
700aa6b4: 1a40         	subs	r0, r0, r1
700aa6b6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa6b8: 9805         	ldr	r0, [sp, #0x14]
700aa6ba: 0940         	lsrs	r0, r0, #0x5
700aa6bc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa6be: 9805         	ldr	r0, [sp, #0x14]
700aa6c0: 9904         	ldr	r1, [sp, #0x10]
700aa6c2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa6c6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa6c8: 9903         	ldr	r1, [sp, #0xc]
700aa6ca: 2001         	movs	r0, #0x1
700aa6cc: 4088         	lsls	r0, r1
700aa6ce: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txChFlag[offset] |= bitMask;
700aa6d0: 9a02         	ldr	r2, [sp, #0x8]
700aa6d2: 9806         	ldr	r0, [sp, #0x18]
700aa6d4: 9904         	ldr	r1, [sp, #0x10]
700aa6d6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa6da: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700aa6de: 4310         	orrs	r0, r2
700aa6e0: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa6e4: 9806         	ldr	r0, [sp, #0x18]
700aa6e6: f500 609f    	add.w	r0, r0, #0x4f8
700aa6ea: f7ff fe11    	bl	0x700aa310 <SemaphoreP_post> @ imm = #-0x3de
;     return;
700aa6ee: b008         	add	sp, #0x20
700aa6f0: bd80         	pop	{r7, pc}
		...
700aa6fe: 0000         	movs	r0, r0

700aa700 <Udma_rmFreeTxHcCh>:
; {
700aa700: b580         	push	{r7, lr}
700aa702: b088         	sub	sp, #0x20
700aa704: 9007         	str	r0, [sp, #0x1c]
700aa706: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa708: 9806         	ldr	r0, [sp, #0x18]
700aa70a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa70e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa710: 9806         	ldr	r0, [sp, #0x18]
700aa712: f500 609f    	add.w	r0, r0, #0x4f8
700aa716: f04f 31ff    	mov.w	r1, #0xffffffff
700aa71a: f7fe faa9    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #-0x1aae
;     i = chNum - rmInitPrms->startTxHcCh;
700aa71e: 9807         	ldr	r0, [sp, #0x1c]
700aa720: 9901         	ldr	r1, [sp, #0x4]
700aa722: 6a09         	ldr	r1, [r1, #0x20]
700aa724: 1a40         	subs	r0, r0, r1
700aa726: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa728: 9805         	ldr	r0, [sp, #0x14]
700aa72a: 0940         	lsrs	r0, r0, #0x5
700aa72c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa72e: 9805         	ldr	r0, [sp, #0x14]
700aa730: 9904         	ldr	r1, [sp, #0x10]
700aa732: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa736: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa738: 9903         	ldr	r1, [sp, #0xc]
700aa73a: 2001         	movs	r0, #0x1
700aa73c: 4088         	lsls	r0, r1
700aa73e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txHcChFlag[offset] |= bitMask;
700aa740: 9a02         	ldr	r2, [sp, #0x8]
700aa742: 9806         	ldr	r0, [sp, #0x18]
700aa744: 9904         	ldr	r1, [sp, #0x10]
700aa746: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa74a: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700aa74e: 4310         	orrs	r0, r2
700aa750: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa754: 9806         	ldr	r0, [sp, #0x18]
700aa756: f500 609f    	add.w	r0, r0, #0x4f8
700aa75a: f7ff fdd9    	bl	0x700aa310 <SemaphoreP_post> @ imm = #-0x44e
;     return;
700aa75e: b008         	add	sp, #0x20
700aa760: bd80         	pop	{r7, pc}
		...
700aa76e: 0000         	movs	r0, r0

700aa770 <Udma_rmFreeTxUhcCh>:
; {
700aa770: b580         	push	{r7, lr}
700aa772: b088         	sub	sp, #0x20
700aa774: 9007         	str	r0, [sp, #0x1c]
700aa776: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa778: 9806         	ldr	r0, [sp, #0x18]
700aa77a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa77e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa780: 9806         	ldr	r0, [sp, #0x18]
700aa782: f500 609f    	add.w	r0, r0, #0x4f8
700aa786: f04f 31ff    	mov.w	r1, #0xffffffff
700aa78a: f7fe fa71    	bl	0x700a8c70 <SemaphoreP_pend> @ imm = #-0x1b1e
;     i = chNum - rmInitPrms->startTxUhcCh;
700aa78e: 9807         	ldr	r0, [sp, #0x1c]
700aa790: 9901         	ldr	r1, [sp, #0x4]
700aa792: 6989         	ldr	r1, [r1, #0x18]
700aa794: 1a40         	subs	r0, r0, r1
700aa796: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa798: 9805         	ldr	r0, [sp, #0x14]
700aa79a: 0940         	lsrs	r0, r0, #0x5
700aa79c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa79e: 9805         	ldr	r0, [sp, #0x14]
700aa7a0: 9904         	ldr	r1, [sp, #0x10]
700aa7a2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa7a6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa7a8: 9903         	ldr	r1, [sp, #0xc]
700aa7aa: 2001         	movs	r0, #0x1
700aa7ac: 4088         	lsls	r0, r1
700aa7ae: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txUhcChFlag[offset] |= bitMask;
700aa7b0: 9a02         	ldr	r2, [sp, #0x8]
700aa7b2: 9806         	ldr	r0, [sp, #0x18]
700aa7b4: 9904         	ldr	r1, [sp, #0x10]
700aa7b6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa7ba: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700aa7be: 4310         	orrs	r0, r2
700aa7c0: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa7c4: 9806         	ldr	r0, [sp, #0x18]
700aa7c6: f500 609f    	add.w	r0, r0, #0x4f8
700aa7ca: f7ff fda1    	bl	0x700aa310 <SemaphoreP_post> @ imm = #-0x4be
;     return;
700aa7ce: b008         	add	sp, #0x20
700aa7d0: bd80         	pop	{r7, pc}
		...
700aa7de: 0000         	movs	r0, r0

700aa7e0 <UART_getChar>:
; {
700aa7e0: b580         	push	{r7, lr}
700aa7e2: b086         	sub	sp, #0x18
700aa7e4: 9005         	str	r0, [sp, #0x14]
700aa7e6: 9104         	str	r1, [sp, #0x10]
700aa7e8: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700aa7ea: 9003         	str	r0, [sp, #0xc]
;     uint32_t retVal      = FALSE;
700aa7ec: 9002         	str	r0, [sp, #0x8]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700aa7ee: 9805         	ldr	r0, [sp, #0x14]
700aa7f0: 300c         	adds	r0, #0xc
700aa7f2: f003 fbf5    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x37ea
700aa7f6: 9003         	str	r0, [sp, #0xc]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700aa7f8: 9805         	ldr	r0, [sp, #0x14]
700aa7fa: 300c         	adds	r0, #0xc
700aa7fc: 9000         	str	r0, [sp]
700aa7fe: f003 fbef    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x37de
700aa802: 4601         	mov	r1, r0
700aa804: 9800         	ldr	r0, [sp]
700aa806: f001 017f    	and	r1, r1, #0x7f
700aa80a: f003 fbf1    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x37e2
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700aa80e: 9805         	ldr	r0, [sp, #0x14]
700aa810: 3014         	adds	r0, #0x14
700aa812: f003 fbe5    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x37ca
;     if ((uint32_t) UART_LSR_RX_FIFO_E_RX_FIFO_E_VALUE_0 !=
700aa816: 07c0         	lsls	r0, r0, #0x1f
700aa818: b150         	cbz	r0, 0x700aa830 <UART_getChar+0x50> @ imm = #0x14
700aa81a: e7ff         	b	0x700aa81c <UART_getChar+0x3c> @ imm = #-0x2
;         uint32_t tempRetVal = HW_RD_REG32(baseAddr + UART_RHR);
700aa81c: 9805         	ldr	r0, [sp, #0x14]
700aa81e: f003 fbdf    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x37be
700aa822: 9001         	str	r0, [sp, #0x4]
;         *pChar = (uint8_t)tempRetVal;
700aa824: 9801         	ldr	r0, [sp, #0x4]
700aa826: 9904         	ldr	r1, [sp, #0x10]
700aa828: 7008         	strb	r0, [r1]
700aa82a: 2001         	movs	r0, #0x1
;         retVal = TRUE;
700aa82c: 9002         	str	r0, [sp, #0x8]
;     }
700aa82e: e7ff         	b	0x700aa830 <UART_getChar+0x50> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa830: 9805         	ldr	r0, [sp, #0x14]
700aa832: 300c         	adds	r0, #0xc
700aa834: 9903         	ldr	r1, [sp, #0xc]
700aa836: f003 fbdb    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x37b6
;     return retVal;
700aa83a: 9802         	ldr	r0, [sp, #0x8]
700aa83c: b006         	add	sp, #0x18
700aa83e: bd80         	pop	{r7, pc}

700aa840 <UART_writeData>:
; {
700aa840: b580         	push	{r7, lr}
700aa842: b086         	sub	sp, #0x18
700aa844: 9005         	str	r0, [sp, #0x14]
700aa846: 9104         	str	r1, [sp, #0x10]
;     UARTLLD_InitHandle hUartInit = hUart->hUartInit;
700aa848: 9805         	ldr	r0, [sp, #0x14]
700aa84a: 6840         	ldr	r0, [r0, #0x4]
700aa84c: 9001         	str	r0, [sp, #0x4]
;     numBytesToTransfer = writeSizeRemaining;
700aa84e: 9804         	ldr	r0, [sp, #0x10]
700aa850: 9003         	str	r0, [sp, #0xc]
;     if (numBytesToTransfer >= hUartInit->txTrigLvl)
700aa852: 9803         	ldr	r0, [sp, #0xc]
700aa854: 9901         	ldr	r1, [sp, #0x4]
700aa856: 6bc9         	ldr	r1, [r1, #0x3c]
700aa858: 4288         	cmp	r0, r1
700aa85a: d304         	blo	0x700aa866 <UART_writeData+0x26> @ imm = #0x8
700aa85c: e7ff         	b	0x700aa85e <UART_writeData+0x1e> @ imm = #-0x2
;         numBytesToTransfer = hUartInit->txTrigLvl;
700aa85e: 9801         	ldr	r0, [sp, #0x4]
700aa860: 6bc0         	ldr	r0, [r0, #0x3c]
700aa862: 9003         	str	r0, [sp, #0xc]
;     }
700aa864: e7ff         	b	0x700aa866 <UART_writeData+0x26> @ imm = #-0x2
;     numBytesToTransferred = numBytesToTransfer;
700aa866: 9803         	ldr	r0, [sp, #0xc]
700aa868: 9002         	str	r0, [sp, #0x8]
;     while (numBytesToTransfer != 0U)
700aa86a: e7ff         	b	0x700aa86c <UART_writeData+0x2c> @ imm = #-0x2
700aa86c: 9803         	ldr	r0, [sp, #0xc]
700aa86e: b190         	cbz	r0, 0x700aa896 <UART_writeData+0x56> @ imm = #0x24
700aa870: e7ff         	b	0x700aa872 <UART_writeData+0x32> @ imm = #-0x2
;         UART_putChar(hUart->baseAddr, *(const uint8_t *)hUart->writeBuf);
700aa872: 9905         	ldr	r1, [sp, #0x14]
700aa874: 6808         	ldr	r0, [r1]
700aa876: 6889         	ldr	r1, [r1, #0x8]
700aa878: 7809         	ldrb	r1, [r1]
700aa87a: f003 f9b9    	bl	0x700adbf0 <UART_putChar> @ imm = #0x3372
;         hUart->writeBuf = (const uint8_t *)hUart->writeBuf + 1U;
700aa87e: 9905         	ldr	r1, [sp, #0x14]
700aa880: 6888         	ldr	r0, [r1, #0x8]
700aa882: 3001         	adds	r0, #0x1
700aa884: 6088         	str	r0, [r1, #0x8]
;         numBytesToTransfer--;
700aa886: 9803         	ldr	r0, [sp, #0xc]
700aa888: 3801         	subs	r0, #0x1
700aa88a: 9003         	str	r0, [sp, #0xc]
;         hUart->writeCount++;
700aa88c: 9905         	ldr	r1, [sp, #0x14]
700aa88e: 68c8         	ldr	r0, [r1, #0xc]
700aa890: 3001         	adds	r0, #0x1
700aa892: 60c8         	str	r0, [r1, #0xc]
;     while (numBytesToTransfer != 0U)
700aa894: e7ea         	b	0x700aa86c <UART_writeData+0x2c> @ imm = #-0x2c
;     return (writeSizeRemaining - numBytesToTransferred);
700aa896: 9804         	ldr	r0, [sp, #0x10]
700aa898: 9902         	ldr	r1, [sp, #0x8]
700aa89a: 1a40         	subs	r0, r0, r1
700aa89c: b006         	add	sp, #0x18
700aa89e: bd80         	pop	{r7, pc}

700aa8a0 <Udma_virtToPhyFxn>:
; {
700aa8a0: b580         	push	{r7, lr}
700aa8a2: b088         	sub	sp, #0x20
700aa8a4: 9007         	str	r0, [sp, #0x1c]
700aa8a6: 9106         	str	r1, [sp, #0x18]
700aa8a8: 9205         	str	r2, [sp, #0x14]
700aa8aa: 2000         	movs	r0, #0x0
700aa8ac: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700aa8b0: 9004         	str	r0, [sp, #0x10]
700aa8b2: 2000         	movs	r0, #0x0
;     void               *appData = NULL_PTR;
700aa8b4: 9003         	str	r0, [sp, #0xc]
;     if(NULL_PTR != chHandle)
700aa8b6: 9805         	ldr	r0, [sp, #0x14]
700aa8b8: b138         	cbz	r0, 0x700aa8ca <Udma_virtToPhyFxn+0x2a> @ imm = #0xe
700aa8ba: e7ff         	b	0x700aa8bc <Udma_virtToPhyFxn+0x1c> @ imm = #-0x2
;         chNum   = chHandle->chPrms.chNum;
700aa8bc: 9805         	ldr	r0, [sp, #0x14]
700aa8be: 6840         	ldr	r0, [r0, #0x4]
700aa8c0: 9004         	str	r0, [sp, #0x10]
;         appData = chHandle->chPrms.appData;
700aa8c2: 9805         	ldr	r0, [sp, #0x14]
700aa8c4: 6900         	ldr	r0, [r0, #0x10]
700aa8c6: 9003         	str	r0, [sp, #0xc]
;     }
700aa8c8: e7ff         	b	0x700aa8ca <Udma_virtToPhyFxn+0x2a> @ imm = #-0x2
;     if((Udma_VirtToPhyFxn) NULL_PTR != drvHandle->initPrms.virtToPhyFxn)
700aa8ca: 9806         	ldr	r0, [sp, #0x18]
700aa8cc: f8d0 01cc    	ldr.w	r0, [r0, #0x1cc]
700aa8d0: b150         	cbz	r0, 0x700aa8e8 <Udma_virtToPhyFxn+0x48> @ imm = #0x14
700aa8d2: e7ff         	b	0x700aa8d4 <Udma_virtToPhyFxn+0x34> @ imm = #-0x2
;         phyAddr = drvHandle->initPrms.virtToPhyFxn(virtAddr, chNum, appData);
700aa8d4: 9806         	ldr	r0, [sp, #0x18]
700aa8d6: f8d0 31cc    	ldr.w	r3, [r0, #0x1cc]
700aa8da: 9807         	ldr	r0, [sp, #0x1c]
700aa8dc: 9904         	ldr	r1, [sp, #0x10]
700aa8de: 9a03         	ldr	r2, [sp, #0xc]
700aa8e0: 4798         	blx	r3
700aa8e2: 9101         	str	r1, [sp, #0x4]
700aa8e4: 9000         	str	r0, [sp]
;     }
700aa8e6: e007         	b	0x700aa8f8 <Udma_virtToPhyFxn+0x58> @ imm = #0xe
;         phyAddr = Udma_defaultVirtToPhyFxn(virtAddr, chNum, appData);
700aa8e8: 9807         	ldr	r0, [sp, #0x1c]
700aa8ea: 9904         	ldr	r1, [sp, #0x10]
700aa8ec: 9a03         	ldr	r2, [sp, #0xc]
700aa8ee: f003 fb87    	bl	0x700ae000 <Udma_defaultVirtToPhyFxn> @ imm = #0x370e
700aa8f2: 9101         	str	r1, [sp, #0x4]
700aa8f4: 9000         	str	r0, [sp]
700aa8f6: e7ff         	b	0x700aa8f8 <Udma_virtToPhyFxn+0x58> @ imm = #-0x2
;     return (phyAddr);
700aa8f8: 9800         	ldr	r0, [sp]
700aa8fa: 9901         	ldr	r1, [sp, #0x4]
700aa8fc: b008         	add	sp, #0x20
700aa8fe: bd80         	pop	{r7, pc}

700aa900 <Sciclient_pmSetModuleRst>:
; {
700aa900: b580         	push	{r7, lr}
700aa902: b090         	sub	sp, #0x40
700aa904: 900f         	str	r0, [sp, #0x3c]
700aa906: 910e         	str	r1, [sp, #0x38]
700aa908: 920d         	str	r2, [sp, #0x34]
700aa90a: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700aa90c: 900c         	str	r0, [sp, #0x30]
;     request.id     = (uint32_t) moduleId;
700aa90e: 990f         	ldr	r1, [sp, #0x3c]
700aa910: 910a         	str	r1, [sp, #0x28]
;     request.resets = (uint32_t) resetBit;
700aa912: 990e         	ldr	r1, [sp, #0x38]
700aa914: 910b         	str	r1, [sp, #0x2c]
700aa916: f240 2102    	movw	r1, #0x202
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_DEVICE_RESETS;
700aa91a: f8ad 100c    	strh.w	r1, [sp, #0xc]
700aa91e: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700aa920: 9104         	str	r1, [sp, #0x10]
700aa922: a908         	add	r1, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700aa924: 9105         	str	r1, [sp, #0x14]
700aa926: 2110         	movs	r1, #0x10
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700aa928: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700aa92a: 990d         	ldr	r1, [sp, #0x34]
700aa92c: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700aa92e: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700aa930: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700aa932: 9002         	str	r0, [sp, #0x8]
700aa934: a803         	add	r0, sp, #0xc
700aa936: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700aa938: f7f1 fb72    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xe91c
700aa93c: 900c         	str	r0, [sp, #0x30]
;     if((retVal != SystemP_SUCCESS) ||
700aa93e: 980c         	ldr	r0, [sp, #0x30]
700aa940: b930         	cbnz	r0, 0x700aa950 <Sciclient_pmSetModuleRst+0x50> @ imm = #0xc
700aa942: e7ff         	b	0x700aa944 <Sciclient_pmSetModuleRst+0x44> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700aa944: 9800         	ldr	r0, [sp]
700aa946: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700aa94a: 2802         	cmp	r0, #0x2
700aa94c: d004         	beq	0x700aa958 <Sciclient_pmSetModuleRst+0x58> @ imm = #0x8
700aa94e: e7ff         	b	0x700aa950 <Sciclient_pmSetModuleRst+0x50> @ imm = #-0x2
700aa950: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700aa954: 900c         	str	r0, [sp, #0x30]
;     }
700aa956: e7ff         	b	0x700aa958 <Sciclient_pmSetModuleRst+0x58> @ imm = #-0x2
;     return retVal;
700aa958: 980c         	ldr	r0, [sp, #0x30]
700aa95a: b010         	add	sp, #0x40
700aa95c: bd80         	pop	{r7, pc}
700aa95e: 0000         	movs	r0, r0

700aa960 <Sciclient_rmIaGetInst>:
; {
700aa960: b083         	sub	sp, #0xc
700aa962: f8ad 000a    	strh.w	r0, [sp, #0xa]
700aa966: 2000         	movs	r0, #0x0
;     struct Sciclient_rmIaInst *inst = NULL;
700aa968: 9001         	str	r0, [sp, #0x4]
;     for (i = 0; i < SCICLIENT_RM_IA_NUM_INST; i++) {
700aa96a: f8ad 0002    	strh.w	r0, [sp, #0x2]
700aa96e: e7ff         	b	0x700aa970 <Sciclient_rmIaGetInst+0x10> @ imm = #-0x2
700aa970: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700aa974: 2800         	cmp	r0, #0x0
700aa976: dc1e         	bgt	0x700aa9b6 <Sciclient_rmIaGetInst+0x56> @ imm = #0x3c
700aa978: e7ff         	b	0x700aa97a <Sciclient_rmIaGetInst+0x1a> @ imm = #-0x2
;         if (id == gRmIaInstances[i].dev_id) {
700aa97a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700aa97e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700aa982: 014a         	lsls	r2, r1, #0x5
700aa984: f640 4154    	movw	r1, #0xc54
700aa988: f2c7 010b    	movt	r1, #0x700b
700aa98c: 5a89         	ldrh	r1, [r1, r2]
700aa98e: 4288         	cmp	r0, r1
700aa990: d10a         	bne	0x700aa9a8 <Sciclient_rmIaGetInst+0x48> @ imm = #0x14
700aa992: e7ff         	b	0x700aa994 <Sciclient_rmIaGetInst+0x34> @ imm = #-0x2
;             inst = &gRmIaInstances[i];
700aa994: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700aa998: f640 4054    	movw	r0, #0xc54
700aa99c: f2c7 000b    	movt	r0, #0x700b
700aa9a0: eb00 1041    	add.w	r0, r0, r1, lsl #5
700aa9a4: 9001         	str	r0, [sp, #0x4]
;             break;
700aa9a6: e006         	b	0x700aa9b6 <Sciclient_rmIaGetInst+0x56> @ imm = #0xc
;     }
700aa9a8: e7ff         	b	0x700aa9aa <Sciclient_rmIaGetInst+0x4a> @ imm = #-0x2
;     for (i = 0; i < SCICLIENT_RM_IA_NUM_INST; i++) {
700aa9aa: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700aa9ae: 3001         	adds	r0, #0x1
700aa9b0: f8ad 0002    	strh.w	r0, [sp, #0x2]
700aa9b4: e7dc         	b	0x700aa970 <Sciclient_rmIaGetInst+0x10> @ imm = #-0x48
;     return inst;
700aa9b6: 9801         	ldr	r0, [sp, #0x4]
700aa9b8: b003         	add	sp, #0xc
700aa9ba: 4770         	bx	lr
700aa9bc: 0000         	movs	r0, r0
700aa9be: 0000         	movs	r0, r0

700aa9c0 <Sciclient_rmPsPush>:
; {
700aa9c0: b083         	sub	sp, #0xc
700aa9c2: 9002         	str	r0, [sp, #0x8]
700aa9c4: f8ad 1006    	strh.w	r1, [sp, #0x6]
700aa9c8: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700aa9ca: 9000         	str	r0, [sp]
;     if ((gPstack.psp < SCICLIENT_PS_MAX_DEPTH) && (n != NULL)) {
700aa9cc: f241 0058    	movw	r0, #0x1058
700aa9d0: f2c7 0008    	movt	r0, #0x7008
700aa9d4: 8c80         	ldrh	r0, [r0, #0x24]
700aa9d6: 2802         	cmp	r0, #0x2
700aa9d8: dc19         	bgt	0x700aaa0e <Sciclient_rmPsPush+0x4e> @ imm = #0x32
700aa9da: e7ff         	b	0x700aa9dc <Sciclient_rmPsPush+0x1c> @ imm = #-0x2
700aa9dc: 9802         	ldr	r0, [sp, #0x8]
700aa9de: b1b0         	cbz	r0, 0x700aaa0e <Sciclient_rmPsPush+0x4e> @ imm = #0x2c
700aa9e0: e7ff         	b	0x700aa9e2 <Sciclient_rmPsPush+0x22> @ imm = #-0x2
;         gPstack.ps[gPstack.psp].p_n = n;
700aa9e2: 9802         	ldr	r0, [sp, #0x8]
700aa9e4: f241 0158    	movw	r1, #0x1058
700aa9e8: f2c7 0108    	movt	r1, #0x7008
700aa9ec: 8c8a         	ldrh	r2, [r1, #0x24]
700aa9ee: eb02 0242    	add.w	r2, r2, r2, lsl #1
700aa9f2: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gPstack.ps[gPstack.psp].if_idx = if_idx;
700aa9f6: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700aa9fa: 8c8a         	ldrh	r2, [r1, #0x24]
700aa9fc: eb02 0242    	add.w	r2, r2, r2, lsl #1
700aaa00: eb01 0282    	add.w	r2, r1, r2, lsl #2
700aaa04: 8090         	strh	r0, [r2, #0x4]
;         gPstack.psp++;
700aaa06: 8c88         	ldrh	r0, [r1, #0x24]
700aaa08: 3001         	adds	r0, #0x1
700aaa0a: 8488         	strh	r0, [r1, #0x24]
;     } else {
700aaa0c: e003         	b	0x700aaa16 <Sciclient_rmPsPush+0x56> @ imm = #0x6
700aaa0e: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aaa12: 9000         	str	r0, [sp]
700aaa14: e7ff         	b	0x700aaa16 <Sciclient_rmPsPush+0x56> @ imm = #-0x2
;     return r;
700aaa16: 9800         	ldr	r0, [sp]
700aaa18: b003         	add	sp, #0xc
700aaa1a: 4770         	bx	lr
700aaa1c: 0000         	movs	r0, r0
700aaa1e: 0000         	movs	r0, r0

700aaa20 <UART_lld_deInit>:
; {
700aaa20: b580         	push	{r7, lr}
700aaa22: b084         	sub	sp, #0x10
700aaa24: 9003         	str	r0, [sp, #0xc]
700aaa26: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700aaa28: 9002         	str	r0, [sp, #0x8]
;     if (NULL_PTR != hUart)
700aaa2a: 9803         	ldr	r0, [sp, #0xc]
700aaa2c: b1f8         	cbz	r0, 0x700aaa6e <UART_lld_deInit+0x4e> @ imm = #0x3e
700aaa2e: e7ff         	b	0x700aaa30 <UART_lld_deInit+0x10> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700aaa30: 9903         	ldr	r1, [sp, #0xc]
700aaa32: 2002         	movs	r0, #0x2
700aaa34: 6548         	str	r0, [r1, #0x54]
;        status = UART_lld_flushTxFifo(hUart);
700aaa36: 9803         	ldr	r0, [sp, #0xc]
700aaa38: f7fd ff6a    	bl	0x700a8910 <UART_lld_flushTxFifo> @ imm = #-0x212c
700aaa3c: 9002         	str	r0, [sp, #0x8]
;         if(status == UART_STATUS_SUCCESS)
700aaa3e: 9802         	ldr	r0, [sp, #0x8]
700aaa40: b988         	cbnz	r0, 0x700aaa66 <UART_lld_deInit+0x46> @ imm = #0x22
700aaa42: e7ff         	b	0x700aaa44 <UART_lld_deInit+0x24> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr,
700aaa44: 9803         	ldr	r0, [sp, #0xc]
700aaa46: 6800         	ldr	r0, [r0]
700aaa48: 2107         	movs	r1, #0x7
700aaa4a: 9101         	str	r1, [sp, #0x4]
700aaa4c: f7f9 fe78    	bl	0x700a4740 <UART_intrDisable> @ imm = #-0x6310
;             UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700aaa50: 9803         	ldr	r0, [sp, #0xc]
700aaa52: 6800         	ldr	r0, [r0]
700aaa54: 2102         	movs	r1, #0x2
700aaa56: f002 fbe3    	bl	0x700ad220 <UART_intr2Disable> @ imm = #0x27c6
700aaa5a: 9901         	ldr	r1, [sp, #0x4]
;             (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700aaa5c: 9803         	ldr	r0, [sp, #0xc]
700aaa5e: 6800         	ldr	r0, [r0]
700aaa60: f002 fc26    	bl	0x700ad2b0 <UART_operatingModeSelect> @ imm = #0x284c
;         }
700aaa64: e7ff         	b	0x700aaa66 <UART_lld_deInit+0x46> @ imm = #-0x2
;         hUart->state = UART_STATE_RESET;
700aaa66: 9903         	ldr	r1, [sp, #0xc]
700aaa68: 2000         	movs	r0, #0x0
700aaa6a: 6548         	str	r0, [r1, #0x54]
;     }
700aaa6c: e003         	b	0x700aaa76 <UART_lld_deInit+0x56> @ imm = #0x6
700aaa6e: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700aaa72: 9002         	str	r0, [sp, #0x8]
700aaa74: e7ff         	b	0x700aaa76 <UART_lld_deInit+0x56> @ imm = #-0x2
;     return status;
700aaa76: 9802         	ldr	r0, [sp, #0x8]
700aaa78: b004         	add	sp, #0x10
700aaa7a: bd80         	pop	{r7, pc}
700aaa7c: 0000         	movs	r0, r0
700aaa7e: 0000         	movs	r0, r0

700aaa80 <UART_lld_writeCompleteCallback>:
; {
700aaa80: b580         	push	{r7, lr}
700aaa82: b086         	sub	sp, #0x18
700aaa84: 9005         	str	r0, [sp, #0x14]
;     UARTLLD_Handle hUart = (UARTLLD_Handle)args;
700aaa86: 9805         	ldr	r0, [sp, #0x14]
700aaa88: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != hUart)
700aaa8a: 9802         	ldr	r0, [sp, #0x8]
700aaa8c: b320         	cbz	r0, 0x700aaad8 <UART_lld_writeCompleteCallback+0x58> @ imm = #0x48
700aaa8e: e7ff         	b	0x700aaa90 <UART_lld_writeCompleteCallback+0x10> @ imm = #-0x2
;         UART_Handle handle = (UART_Handle)hUart->args;
700aaa90: 9802         	ldr	r0, [sp, #0x8]
700aaa92: 6e00         	ldr	r0, [r0, #0x60]
700aaa94: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != handle)
700aaa96: 9801         	ldr	r0, [sp, #0x4]
700aaa98: b1e8         	cbz	r0, 0x700aaad6 <UART_lld_writeCompleteCallback+0x56> @ imm = #0x3a
700aaa9a: e7ff         	b	0x700aaa9c <UART_lld_writeCompleteCallback+0x1c> @ imm = #-0x2
;             config = (UART_Config *) handle;
700aaa9c: 9801         	ldr	r0, [sp, #0x4]
700aaa9e: 9004         	str	r0, [sp, #0x10]
;             obj = config->object;
700aaaa0: 9804         	ldr	r0, [sp, #0x10]
700aaaa2: 6840         	ldr	r0, [r0, #0x4]
700aaaa4: 9003         	str	r0, [sp, #0xc]
;             obj->writeTrans->count = hUart->writeTrans.count;
700aaaa6: 9802         	ldr	r0, [sp, #0x8]
700aaaa8: 6c00         	ldr	r0, [r0, #0x40]
700aaaaa: 9903         	ldr	r1, [sp, #0xc]
700aaaac: f8d1 1080    	ldr.w	r1, [r1, #0x80]
700aaab0: 6048         	str	r0, [r1, #0x4]
;             if (obj->prms.writeMode == UART_TRANSFER_MODE_CALLBACK)
700aaab2: 9803         	ldr	r0, [sp, #0xc]
700aaab4: 69c0         	ldr	r0, [r0, #0x1c]
700aaab6: 2801         	cmp	r0, #0x1
700aaab8: d107         	bne	0x700aaaca <UART_lld_writeCompleteCallback+0x4a> @ imm = #0xe
700aaaba: e7ff         	b	0x700aaabc <UART_lld_writeCompleteCallback+0x3c> @ imm = #-0x2
;                 obj->prms.writeCallbackFxn(hUart, &hUart->writeTrans);
700aaabc: 9803         	ldr	r0, [sp, #0xc]
700aaabe: 6a42         	ldr	r2, [r0, #0x24]
700aaac0: 9802         	ldr	r0, [sp, #0x8]
700aaac2: f100 013c    	add.w	r1, r0, #0x3c
700aaac6: 4790         	blx	r2
;             }
700aaac8: e004         	b	0x700aaad4 <UART_lld_writeCompleteCallback+0x54> @ imm = #0x8
;                 SemaphoreP_post((SemaphoreP_Object *)hUart->writeTransferMutex);
700aaaca: 9802         	ldr	r0, [sp, #0x8]
700aaacc: 6dc0         	ldr	r0, [r0, #0x5c]
700aaace: f7ff fc1f    	bl	0x700aa310 <SemaphoreP_post> @ imm = #-0x7c2
700aaad2: e7ff         	b	0x700aaad4 <UART_lld_writeCompleteCallback+0x54> @ imm = #-0x2
;         }
700aaad4: e7ff         	b	0x700aaad6 <UART_lld_writeCompleteCallback+0x56> @ imm = #-0x2
;     }
700aaad6: e7ff         	b	0x700aaad8 <UART_lld_writeCompleteCallback+0x58> @ imm = #-0x2
; }
700aaad8: b006         	add	sp, #0x18
700aaada: bd80         	pop	{r7, pc}
700aaadc: 0000         	movs	r0, r0
700aaade: 0000         	movs	r0, r0

700aaae0 <Sciclient_rmIaValidateGlobalEvt>:
; {
700aaae0: b580         	push	{r7, lr}
700aaae2: b086         	sub	sp, #0x18
700aaae4: f8ad 0016    	strh.w	r0, [sp, #0x16]
700aaae8: f8ad 1014    	strh.w	r1, [sp, #0x14]
700aaaec: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700aaaee: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIaInst *inst = NULL;
700aaaf0: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIaGetInst(id);
700aaaf2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700aaaf6: f7ff ff33    	bl	0x700aa960 <Sciclient_rmIaGetInst> @ imm = #-0x19a
700aaafa: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700aaafc: 9803         	ldr	r0, [sp, #0xc]
700aaafe: b920         	cbnz	r0, 0x700aab0a <Sciclient_rmIaValidateGlobalEvt+0x2a> @ imm = #0x8
700aab00: e7ff         	b	0x700aab02 <Sciclient_rmIaValidateGlobalEvt+0x22> @ imm = #-0x2
700aab02: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700aab06: 9004         	str	r0, [sp, #0x10]
;     }
700aab08: e7ff         	b	0x700aab0a <Sciclient_rmIaValidateGlobalEvt+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700aab0a: 9804         	ldr	r0, [sp, #0x10]
700aab0c: b990         	cbnz	r0, 0x700aab34 <Sciclient_rmIaValidateGlobalEvt+0x54> @ imm = #0x24
700aab0e: e7ff         	b	0x700aab10 <Sciclient_rmIaValidateGlobalEvt+0x30> @ imm = #-0x2
;         evt = global_evt - inst->sevt_offset;
700aab10: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700aab14: 9903         	ldr	r1, [sp, #0xc]
700aab16: 8909         	ldrh	r1, [r1, #0x8]
700aab18: 1a40         	subs	r0, r0, r1
700aab1a: f8ad 000a    	strh.w	r0, [sp, #0xa]
;         r = Sciclient_rmIaValidateEvt(inst, evt, 0u, 0u, false);
700aab1e: 9803         	ldr	r0, [sp, #0xc]
700aab20: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700aab24: 466a         	mov	r2, sp
700aab26: 2300         	movs	r3, #0x0
700aab28: 6013         	str	r3, [r2]
700aab2a: 461a         	mov	r2, r3
700aab2c: f7f8 f858    	bl	0x700a2be0 <Sciclient_rmIaValidateEvt> @ imm = #-0x7f50
700aab30: 9004         	str	r0, [sp, #0x10]
;     }
700aab32: e7ff         	b	0x700aab34 <Sciclient_rmIaValidateGlobalEvt+0x54> @ imm = #-0x2
;     return r;
700aab34: 9804         	ldr	r0, [sp, #0x10]
700aab36: b006         	add	sp, #0x18
700aab38: bd80         	pop	{r7, pc}
700aab3a: 0000         	movs	r0, r0
700aab3c: 0000         	movs	r0, r0
700aab3e: 0000         	movs	r0, r0

700aab40 <UART_lld_readCompleteCallback>:
; {
700aab40: b580         	push	{r7, lr}
700aab42: b086         	sub	sp, #0x18
700aab44: 9005         	str	r0, [sp, #0x14]
;     UARTLLD_Handle hUart = (UARTLLD_Handle)args;
700aab46: 9805         	ldr	r0, [sp, #0x14]
700aab48: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != hUart)
700aab4a: 9802         	ldr	r0, [sp, #0x8]
700aab4c: b318         	cbz	r0, 0x700aab96 <UART_lld_readCompleteCallback+0x56> @ imm = #0x46
700aab4e: e7ff         	b	0x700aab50 <UART_lld_readCompleteCallback+0x10> @ imm = #-0x2
;         UART_Handle handle = (UART_Handle)hUart->args;
700aab50: 9802         	ldr	r0, [sp, #0x8]
700aab52: 6e00         	ldr	r0, [r0, #0x60]
700aab54: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != handle)
700aab56: 9801         	ldr	r0, [sp, #0x4]
700aab58: b1e0         	cbz	r0, 0x700aab94 <UART_lld_readCompleteCallback+0x54> @ imm = #0x38
700aab5a: e7ff         	b	0x700aab5c <UART_lld_readCompleteCallback+0x1c> @ imm = #-0x2
;             config = (UART_Config *) handle;
700aab5c: 9801         	ldr	r0, [sp, #0x4]
700aab5e: 9004         	str	r0, [sp, #0x10]
;             obj = config->object;
700aab60: 9804         	ldr	r0, [sp, #0x10]
700aab62: 6840         	ldr	r0, [r0, #0x4]
700aab64: 9003         	str	r0, [sp, #0xc]
;             obj->readTrans->count = hUart->readTrans.count;
700aab66: 9802         	ldr	r0, [sp, #0x8]
700aab68: 6ac0         	ldr	r0, [r0, #0x2c]
700aab6a: 9903         	ldr	r1, [sp, #0xc]
700aab6c: 6fc9         	ldr	r1, [r1, #0x7c]
700aab6e: 6048         	str	r0, [r1, #0x4]
;             if (obj->prms.readMode == UART_TRANSFER_MODE_CALLBACK)
700aab70: 9803         	ldr	r0, [sp, #0xc]
700aab72: 6940         	ldr	r0, [r0, #0x14]
700aab74: 2801         	cmp	r0, #0x1
700aab76: d107         	bne	0x700aab88 <UART_lld_readCompleteCallback+0x48> @ imm = #0xe
700aab78: e7ff         	b	0x700aab7a <UART_lld_readCompleteCallback+0x3a> @ imm = #-0x2
;                 obj->prms.readCallbackFxn(hUart, &hUart->readTrans);
700aab7a: 9803         	ldr	r0, [sp, #0xc]
700aab7c: 6a02         	ldr	r2, [r0, #0x20]
700aab7e: 9802         	ldr	r0, [sp, #0x8]
700aab80: f100 0128    	add.w	r1, r0, #0x28
700aab84: 4790         	blx	r2
;             }
700aab86: e004         	b	0x700aab92 <UART_lld_readCompleteCallback+0x52> @ imm = #0x8
;                 SemaphoreP_post((SemaphoreP_Object *)hUart->readTransferMutex);
700aab88: 9802         	ldr	r0, [sp, #0x8]
700aab8a: 6d80         	ldr	r0, [r0, #0x58]
700aab8c: f7ff fbc0    	bl	0x700aa310 <SemaphoreP_post> @ imm = #-0x880
700aab90: e7ff         	b	0x700aab92 <UART_lld_readCompleteCallback+0x52> @ imm = #-0x2
;         }
700aab92: e7ff         	b	0x700aab94 <UART_lld_readCompleteCallback+0x54> @ imm = #-0x2
;     }
700aab94: e7ff         	b	0x700aab96 <UART_lld_readCompleteCallback+0x56> @ imm = #-0x2
; }
700aab96: b006         	add	sp, #0x18
700aab98: bd80         	pop	{r7, pc}
700aab9a: 0000         	movs	r0, r0
700aab9c: 0000         	movs	r0, r0
700aab9e: 0000         	movs	r0, r0

700aaba0 <UART_regConfigModeEnable>:
; {
700aaba0: b580         	push	{r7, lr}
700aaba2: b086         	sub	sp, #0x18
700aaba4: 9005         	str	r0, [sp, #0x14]
700aaba6: 9104         	str	r1, [sp, #0x10]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700aaba8: 9805         	ldr	r0, [sp, #0x14]
700aabaa: 300c         	adds	r0, #0xc
700aabac: f003 fa18    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x3430
700aabb0: 9003         	str	r0, [sp, #0xc]
;     switch (modeFlag)
700aabb2: 9804         	ldr	r0, [sp, #0x10]
700aabb4: 9002         	str	r0, [sp, #0x8]
700aabb6: 287f         	cmp	r0, #0x7f
700aabb8: d00f         	beq	0x700aabda <UART_regConfigModeEnable+0x3a> @ imm = #0x1e
700aabba: e7ff         	b	0x700aabbc <UART_regConfigModeEnable+0x1c> @ imm = #-0x2
700aabbc: 9802         	ldr	r0, [sp, #0x8]
700aabbe: 2880         	cmp	r0, #0x80
700aabc0: d004         	beq	0x700aabcc <UART_regConfigModeEnable+0x2c> @ imm = #0x8
700aabc2: e7ff         	b	0x700aabc4 <UART_regConfigModeEnable+0x24> @ imm = #-0x2
700aabc4: 9802         	ldr	r0, [sp, #0x8]
700aabc6: 28bf         	cmp	r0, #0xbf
700aabc8: d113         	bne	0x700aabf2 <UART_regConfigModeEnable+0x52> @ imm = #0x26
700aabca: e7ff         	b	0x700aabcc <UART_regConfigModeEnable+0x2c> @ imm = #-0x2
;             HW_WR_REG32(baseAddr + UART_LCR, modeFlag & 0xFFU);
700aabcc: 9805         	ldr	r0, [sp, #0x14]
700aabce: 300c         	adds	r0, #0xc
700aabd0: f89d 1010    	ldrb.w	r1, [sp, #0x10]
700aabd4: f003 fa0c    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x3418
;             break;
700aabd8: e00c         	b	0x700aabf4 <UART_regConfigModeEnable+0x54> @ imm = #0x18
;             HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700aabda: 9805         	ldr	r0, [sp, #0x14]
700aabdc: 300c         	adds	r0, #0xc
700aabde: 9001         	str	r0, [sp, #0x4]
700aabe0: f003 f9fe    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x33fc
700aabe4: 4601         	mov	r1, r0
700aabe6: 9801         	ldr	r0, [sp, #0x4]
700aabe8: f001 017f    	and	r1, r1, #0x7f
700aabec: f003 fa00    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x3400
;             break;
700aabf0: e000         	b	0x700aabf4 <UART_regConfigModeEnable+0x54> @ imm = #0x0
;             break;
700aabf2: e7ff         	b	0x700aabf4 <UART_regConfigModeEnable+0x54> @ imm = #-0x2
;     return lcrRegValue;
700aabf4: 9803         	ldr	r0, [sp, #0xc]
700aabf6: b006         	add	sp, #0x18
700aabf8: bd80         	pop	{r7, pc}
700aabfa: 0000         	movs	r0, r0
700aabfc: 0000         	movs	r0, r0
700aabfe: 0000         	movs	r0, r0

700aac00 <prvCheckTasksWaitingTermination>:
; static void prvCheckTasksWaitingTermination(void) {
700aac00: b580         	push	{r7, lr}
700aac02: b082         	sub	sp, #0x8
;     while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
700aac04: e7ff         	b	0x700aac06 <prvCheckTasksWaitingTermination+0x6> @ imm = #-0x2
700aac06: f640 50d0    	movw	r0, #0xdd0
700aac0a: f2c7 000b    	movt	r0, #0x700b
700aac0e: 6800         	ldr	r0, [r0]
700aac10: b308         	cbz	r0, 0x700aac56 <prvCheckTasksWaitingTermination+0x56> @ imm = #0x42
700aac12: e7ff         	b	0x700aac14 <prvCheckTasksWaitingTermination+0x14> @ imm = #-0x2
;       taskENTER_CRITICAL();
700aac14: f001 ffdc    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0x1fb8
;         pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700aac18: f644 5088    	movw	r0, #0x4d88
700aac1c: f2c7 0008    	movt	r0, #0x7008
700aac20: 68c0         	ldr	r0, [r0, #0xc]
700aac22: 68c0         	ldr	r0, [r0, #0xc]
700aac24: 9001         	str	r0, [sp, #0x4]
;         (void)uxListRemove(&(pxTCB->xStateListItem));
700aac26: 9801         	ldr	r0, [sp, #0x4]
700aac28: 3004         	adds	r0, #0x4
700aac2a: f000 ff61    	bl	0x700abaf0 <uxListRemove> @ imm = #0xec2
;         --uxCurrentNumberOfTasks;
700aac2e: f640 51cc    	movw	r1, #0xdcc
700aac32: f2c7 010b    	movt	r1, #0x700b
700aac36: 6808         	ldr	r0, [r1]
700aac38: 3801         	subs	r0, #0x1
700aac3a: 6008         	str	r0, [r1]
;         --uxDeletedTasksWaitingCleanUp;
700aac3c: f640 51d0    	movw	r1, #0xdd0
700aac40: f2c7 010b    	movt	r1, #0x700b
700aac44: 6808         	ldr	r0, [r1]
700aac46: 3801         	subs	r0, #0x1
700aac48: 6008         	str	r0, [r1]
;       taskEXIT_CRITICAL();
700aac4a: f001 f841    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #0x1082
;       prvDeleteTCB(pxTCB);
700aac4e: 9801         	ldr	r0, [sp, #0x4]
700aac50: f001 fc86    	bl	0x700ac560 <prvDeleteTCB> @ imm = #0x190c
;     while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
700aac54: e7d7         	b	0x700aac06 <prvCheckTasksWaitingTermination+0x6> @ imm = #-0x52
; }
700aac56: b002         	add	sp, #0x8
700aac58: bd80         	pop	{r7, pc}
700aac5a: 0000         	movs	r0, r0
700aac5c: 0000         	movs	r0, r0
700aac5e: 0000         	movs	r0, r0

700aac60 <Sciclient_rmIrqSetRaw>:
; {
700aac60: b580         	push	{r7, lr}
700aac62: b08c         	sub	sp, #0x30
700aac64: 900b         	str	r0, [sp, #0x2c]
700aac66: 910a         	str	r1, [sp, #0x28]
700aac68: 9209         	str	r2, [sp, #0x24]
700aac6a: f44f 5080    	mov.w	r0, #0x1000
;     sciReq.messageType    = TISCI_MSG_RM_IRQ_SET;
700aac6e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aac72: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aac74: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aac76: 980b         	ldr	r0, [sp, #0x2c]
700aac78: 9005         	str	r0, [sp, #0x14]
700aac7a: 201c         	movs	r0, #0x1c
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aac7c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aac7e: 9809         	ldr	r0, [sp, #0x24]
700aac80: 9007         	str	r0, [sp, #0x1c]
700aac82: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aac84: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aac86: 980a         	ldr	r0, [sp, #0x28]
700aac88: 9001         	str	r0, [sp, #0x4]
700aac8a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aac8c: 9002         	str	r0, [sp, #0x8]
700aac8e: a803         	add	r0, sp, #0xc
700aac90: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aac92: f7f1 f9c5    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xec76
700aac96: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aac98: 9808         	ldr	r0, [sp, #0x20]
700aac9a: b930         	cbnz	r0, 0x700aacaa <Sciclient_rmIrqSetRaw+0x4a> @ imm = #0xc
700aac9c: e7ff         	b	0x700aac9e <Sciclient_rmIrqSetRaw+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aac9e: 9800         	ldr	r0, [sp]
700aaca0: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aaca4: 2802         	cmp	r0, #0x2
700aaca6: d004         	beq	0x700aacb2 <Sciclient_rmIrqSetRaw+0x52> @ imm = #0x8
700aaca8: e7ff         	b	0x700aacaa <Sciclient_rmIrqSetRaw+0x4a> @ imm = #-0x2
700aacaa: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aacae: 9008         	str	r0, [sp, #0x20]
;     }
700aacb0: e7ff         	b	0x700aacb2 <Sciclient_rmIrqSetRaw+0x52> @ imm = #-0x2
;     return r;
700aacb2: 9808         	ldr	r0, [sp, #0x20]
700aacb4: b00c         	add	sp, #0x30
700aacb6: bd80         	pop	{r7, pc}
		...

700aacc0 <Sciclient_rmIrqUnmappedVintRouteDelete>:
; {
700aacc0: b580         	push	{r7, lr}
700aacc2: b084         	sub	sp, #0x10
700aacc4: 9003         	str	r0, [sp, #0xc]
700aacc6: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700aacc8: 9002         	str	r0, [sp, #0x8]
;     r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700aacca: 9903         	ldr	r1, [sp, #0xc]
700aaccc: 8a08         	ldrh	r0, [r1, #0x10]
700aacce: 8a49         	ldrh	r1, [r1, #0x12]
700aacd0: f10d 0207    	add.w	r2, sp, #0x7
700aacd4: f7fe fe84    	bl	0x700a99e0 <Sciclient_rmIaVintGetInfo> @ imm = #-0x12f8
700aacd8: 9002         	str	r0, [sp, #0x8]
;     if ((r == SystemP_SUCCESS) && (num_evts > 0U)) {
700aacda: 9802         	ldr	r0, [sp, #0x8]
700aacdc: b940         	cbnz	r0, 0x700aacf0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #0x10
700aacde: e7ff         	b	0x700aace0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x20> @ imm = #-0x2
700aace0: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700aace4: b120         	cbz	r0, 0x700aacf0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #0x8
700aace6: e7ff         	b	0x700aace8 <Sciclient_rmIrqUnmappedVintRouteDelete+0x28> @ imm = #-0x2
700aace8: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700aacec: 9002         	str	r0, [sp, #0x8]
;     }
700aacee: e7ff         	b	0x700aacf0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700aacf0: 9802         	ldr	r0, [sp, #0x8]
700aacf2: b970         	cbnz	r0, 0x700aad12 <Sciclient_rmIrqUnmappedVintRouteDelete+0x52> @ imm = #0x1c
700aacf4: e7ff         	b	0x700aacf6 <Sciclient_rmIrqUnmappedVintRouteDelete+0x36> @ imm = #-0x2
;         r = Sciclient_rmIrqGetRoute(cfg);
700aacf6: 9803         	ldr	r0, [sp, #0xc]
700aacf8: f7f0 fe8a    	bl	0x7009ba10 <Sciclient_rmIrqGetRoute> @ imm = #-0xf2ec
700aacfc: 9002         	str	r0, [sp, #0x8]
;         if (r == SystemP_SUCCESS) {
700aacfe: 9802         	ldr	r0, [sp, #0x8]
700aad00: b930         	cbnz	r0, 0x700aad10 <Sciclient_rmIrqUnmappedVintRouteDelete+0x50> @ imm = #0xc
700aad02: e7ff         	b	0x700aad04 <Sciclient_rmIrqUnmappedVintRouteDelete+0x44> @ imm = #-0x2
;             r = Sciclient_rmIrqDeleteRoute(cfg, false);
700aad04: 9803         	ldr	r0, [sp, #0xc]
700aad06: 2100         	movs	r1, #0x0
700aad08: f7f4 fa12    	bl	0x7009f130 <Sciclient_rmIrqDeleteRoute> @ imm = #-0xbbdc
700aad0c: 9002         	str	r0, [sp, #0x8]
;         }
700aad0e: e7ff         	b	0x700aad10 <Sciclient_rmIrqUnmappedVintRouteDelete+0x50> @ imm = #-0x2
;     }
700aad10: e7ff         	b	0x700aad12 <Sciclient_rmIrqUnmappedVintRouteDelete+0x52> @ imm = #-0x2
;     return r;
700aad12: 9802         	ldr	r0, [sp, #0x8]
700aad14: b004         	add	sp, #0x10
700aad16: bd80         	pop	{r7, pc}
		...

700aad20 <Sciclient_rmRingCfg>:
; {
700aad20: b580         	push	{r7, lr}
700aad22: b08c         	sub	sp, #0x30
700aad24: 900b         	str	r0, [sp, #0x2c]
700aad26: 910a         	str	r1, [sp, #0x28]
700aad28: 9209         	str	r2, [sp, #0x24]
700aad2a: f241 1010    	movw	r0, #0x1110
;     sciReq.messageType    = TISCI_MSG_RM_RING_CFG;
700aad2e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aad32: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aad34: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aad36: 980b         	ldr	r0, [sp, #0x2c]
700aad38: 9005         	str	r0, [sp, #0x14]
700aad3a: 2022         	movs	r0, #0x22
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aad3c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aad3e: 9809         	ldr	r0, [sp, #0x24]
700aad40: 9007         	str	r0, [sp, #0x1c]
700aad42: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aad44: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aad46: 980a         	ldr	r0, [sp, #0x28]
700aad48: 9001         	str	r0, [sp, #0x4]
700aad4a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aad4c: 9002         	str	r0, [sp, #0x8]
700aad4e: a803         	add	r0, sp, #0xc
700aad50: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aad52: f7f1 f965    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xed36
700aad56: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aad58: 9808         	ldr	r0, [sp, #0x20]
700aad5a: b930         	cbnz	r0, 0x700aad6a <Sciclient_rmRingCfg+0x4a> @ imm = #0xc
700aad5c: e7ff         	b	0x700aad5e <Sciclient_rmRingCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aad5e: 9800         	ldr	r0, [sp]
700aad60: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aad64: 2802         	cmp	r0, #0x2
700aad66: d004         	beq	0x700aad72 <Sciclient_rmRingCfg+0x52> @ imm = #0x8
700aad68: e7ff         	b	0x700aad6a <Sciclient_rmRingCfg+0x4a> @ imm = #-0x2
700aad6a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aad6e: 9008         	str	r0, [sp, #0x20]
;     }
700aad70: e7ff         	b	0x700aad72 <Sciclient_rmRingCfg+0x52> @ imm = #-0x2
;     return r;
700aad72: 9808         	ldr	r0, [sp, #0x20]
700aad74: b00c         	add	sp, #0x30
700aad76: bd80         	pop	{r7, pc}
		...

700aad80 <Sciclient_rmUdmapFlowCfg>:
; {
700aad80: b580         	push	{r7, lr}
700aad82: b08c         	sub	sp, #0x30
700aad84: 900b         	str	r0, [sp, #0x2c]
700aad86: 910a         	str	r1, [sp, #0x28]
700aad88: 9209         	str	r2, [sp, #0x24]
700aad8a: f241 2030    	movw	r0, #0x1230
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_FLOW_CFG;
700aad8e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aad92: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aad94: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aad96: 980b         	ldr	r0, [sp, #0x2c]
700aad98: 9005         	str	r0, [sp, #0x14]
700aad9a: 2029         	movs	r0, #0x29
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aad9c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aad9e: 9809         	ldr	r0, [sp, #0x24]
700aada0: 9007         	str	r0, [sp, #0x1c]
700aada2: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aada4: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aada6: 980a         	ldr	r0, [sp, #0x28]
700aada8: 9001         	str	r0, [sp, #0x4]
700aadaa: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aadac: 9002         	str	r0, [sp, #0x8]
700aadae: a803         	add	r0, sp, #0xc
700aadb0: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aadb2: f7f1 f935    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xed96
700aadb6: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aadb8: 9808         	ldr	r0, [sp, #0x20]
700aadba: b930         	cbnz	r0, 0x700aadca <Sciclient_rmUdmapFlowCfg+0x4a> @ imm = #0xc
700aadbc: e7ff         	b	0x700aadbe <Sciclient_rmUdmapFlowCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aadbe: 9800         	ldr	r0, [sp]
700aadc0: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aadc4: 2802         	cmp	r0, #0x2
700aadc6: d004         	beq	0x700aadd2 <Sciclient_rmUdmapFlowCfg+0x52> @ imm = #0x8
700aadc8: e7ff         	b	0x700aadca <Sciclient_rmUdmapFlowCfg+0x4a> @ imm = #-0x2
700aadca: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aadce: 9008         	str	r0, [sp, #0x20]
;     }
700aadd0: e7ff         	b	0x700aadd2 <Sciclient_rmUdmapFlowCfg+0x52> @ imm = #-0x2
;     return r;
700aadd2: 9808         	ldr	r0, [sp, #0x20]
700aadd4: b00c         	add	sp, #0x30
700aadd6: bd80         	pop	{r7, pc}
		...

700aade0 <Sciclient_rmUdmapFlowSizeThreshCfg>:
; {
700aade0: b580         	push	{r7, lr}
700aade2: b08c         	sub	sp, #0x30
700aade4: 900b         	str	r0, [sp, #0x2c]
700aade6: 910a         	str	r1, [sp, #0x28]
700aade8: 9209         	str	r2, [sp, #0x24]
700aadea: f241 2031    	movw	r0, #0x1231
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_FLOW_SIZE_THRESH_CFG;
700aadee: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aadf2: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aadf4: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aadf6: 980b         	ldr	r0, [sp, #0x2c]
700aadf8: 9005         	str	r0, [sp, #0x14]
700aadfa: 201d         	movs	r0, #0x1d
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aadfc: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aadfe: 9809         	ldr	r0, [sp, #0x24]
700aae00: 9007         	str	r0, [sp, #0x1c]
700aae02: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aae04: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aae06: 980a         	ldr	r0, [sp, #0x28]
700aae08: 9001         	str	r0, [sp, #0x4]
700aae0a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aae0c: 9002         	str	r0, [sp, #0x8]
700aae0e: a803         	add	r0, sp, #0xc
700aae10: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aae12: f7f1 f905    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xedf6
700aae16: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aae18: 9808         	ldr	r0, [sp, #0x20]
700aae1a: b930         	cbnz	r0, 0x700aae2a <Sciclient_rmUdmapFlowSizeThreshCfg+0x4a> @ imm = #0xc
700aae1c: e7ff         	b	0x700aae1e <Sciclient_rmUdmapFlowSizeThreshCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aae1e: 9800         	ldr	r0, [sp]
700aae20: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aae24: 2802         	cmp	r0, #0x2
700aae26: d004         	beq	0x700aae32 <Sciclient_rmUdmapFlowSizeThreshCfg+0x52> @ imm = #0x8
700aae28: e7ff         	b	0x700aae2a <Sciclient_rmUdmapFlowSizeThreshCfg+0x4a> @ imm = #-0x2
700aae2a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aae2e: 9008         	str	r0, [sp, #0x20]
;     }
700aae30: e7ff         	b	0x700aae32 <Sciclient_rmUdmapFlowSizeThreshCfg+0x52> @ imm = #-0x2
;     return r;
700aae32: 9808         	ldr	r0, [sp, #0x20]
700aae34: b00c         	add	sp, #0x30
700aae36: bd80         	pop	{r7, pc}
		...

700aae40 <Sciclient_rmUdmapRxChCfg>:
; {
700aae40: b580         	push	{r7, lr}
700aae42: b08c         	sub	sp, #0x30
700aae44: 900b         	str	r0, [sp, #0x2c]
700aae46: 910a         	str	r1, [sp, #0x28]
700aae48: 9209         	str	r2, [sp, #0x24]
700aae4a: f241 2015    	movw	r0, #0x1215
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_RX_CH_CFG;
700aae4e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aae52: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aae54: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aae56: 980b         	ldr	r0, [sp, #0x2c]
700aae58: 9005         	str	r0, [sp, #0x14]
700aae5a: 2022         	movs	r0, #0x22
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aae5c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aae5e: 9809         	ldr	r0, [sp, #0x24]
700aae60: 9007         	str	r0, [sp, #0x1c]
700aae62: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aae64: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aae66: 980a         	ldr	r0, [sp, #0x28]
700aae68: 9001         	str	r0, [sp, #0x4]
700aae6a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aae6c: 9002         	str	r0, [sp, #0x8]
700aae6e: a803         	add	r0, sp, #0xc
700aae70: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aae72: f7f1 f8d5    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xee56
700aae76: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aae78: 9808         	ldr	r0, [sp, #0x20]
700aae7a: b930         	cbnz	r0, 0x700aae8a <Sciclient_rmUdmapRxChCfg+0x4a> @ imm = #0xc
700aae7c: e7ff         	b	0x700aae7e <Sciclient_rmUdmapRxChCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aae7e: 9800         	ldr	r0, [sp]
700aae80: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aae84: 2802         	cmp	r0, #0x2
700aae86: d004         	beq	0x700aae92 <Sciclient_rmUdmapRxChCfg+0x52> @ imm = #0x8
700aae88: e7ff         	b	0x700aae8a <Sciclient_rmUdmapRxChCfg+0x4a> @ imm = #-0x2
700aae8a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aae8e: 9008         	str	r0, [sp, #0x20]
;     }
700aae90: e7ff         	b	0x700aae92 <Sciclient_rmUdmapRxChCfg+0x52> @ imm = #-0x2
;     return r;
700aae92: 9808         	ldr	r0, [sp, #0x20]
700aae94: b00c         	add	sp, #0x30
700aae96: bd80         	pop	{r7, pc}
		...

700aaea0 <Sciclient_rmUdmapTxChCfg>:
; {
700aaea0: b580         	push	{r7, lr}
700aaea2: b08c         	sub	sp, #0x30
700aaea4: 900b         	str	r0, [sp, #0x2c]
700aaea6: 910a         	str	r1, [sp, #0x28]
700aaea8: 9209         	str	r2, [sp, #0x24]
700aaeaa: f241 2005    	movw	r0, #0x1205
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_TX_CH_CFG;
700aaeae: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aaeb2: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aaeb4: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aaeb6: 980b         	ldr	r0, [sp, #0x2c]
700aaeb8: 9005         	str	r0, [sp, #0x14]
700aaeba: 2024         	movs	r0, #0x24
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aaebc: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aaebe: 9809         	ldr	r0, [sp, #0x24]
700aaec0: 9007         	str	r0, [sp, #0x1c]
700aaec2: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aaec4: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aaec6: 980a         	ldr	r0, [sp, #0x28]
700aaec8: 9001         	str	r0, [sp, #0x4]
700aaeca: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aaecc: 9002         	str	r0, [sp, #0x8]
700aaece: a803         	add	r0, sp, #0xc
700aaed0: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aaed2: f7f1 f8a5    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xeeb6
700aaed6: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aaed8: 9808         	ldr	r0, [sp, #0x20]
700aaeda: b930         	cbnz	r0, 0x700aaeea <Sciclient_rmUdmapTxChCfg+0x4a> @ imm = #0xc
700aaedc: e7ff         	b	0x700aaede <Sciclient_rmUdmapTxChCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aaede: 9800         	ldr	r0, [sp]
700aaee0: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aaee4: 2802         	cmp	r0, #0x2
700aaee6: d004         	beq	0x700aaef2 <Sciclient_rmUdmapTxChCfg+0x52> @ imm = #0x8
700aaee8: e7ff         	b	0x700aaeea <Sciclient_rmUdmapTxChCfg+0x4a> @ imm = #-0x2
700aaeea: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aaeee: 9008         	str	r0, [sp, #0x20]
;     }
700aaef0: e7ff         	b	0x700aaef2 <Sciclient_rmUdmapTxChCfg+0x52> @ imm = #-0x2
;     return r;
700aaef2: 9808         	ldr	r0, [sp, #0x20]
700aaef4: b00c         	add	sp, #0x30
700aaef6: bd80         	pop	{r7, pc}
		...

700aaf00 <xQueueGenericCreate>:
;     {
700aaf00: b580         	push	{r7, lr}
700aaf02: b088         	sub	sp, #0x20
700aaf04: 9007         	str	r0, [sp, #0x1c]
700aaf06: 9106         	str	r1, [sp, #0x18]
700aaf08: f88d 2017    	strb.w	r2, [sp, #0x17]
;         xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
700aaf0c: 9807         	ldr	r0, [sp, #0x1c]
700aaf0e: 9906         	ldr	r1, [sp, #0x18]
700aaf10: 4348         	muls	r0, r1, r0
700aaf12: 9003         	str	r0, [sp, #0xc]
;         pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
700aaf14: 9803         	ldr	r0, [sp, #0xc]
700aaf16: 3050         	adds	r0, #0x50
700aaf18: f002 fd8a    	bl	0x700ada30 <pvPortMalloc> @ imm = #0x2b14
700aaf1c: 9004         	str	r0, [sp, #0x10]
;         if( pxNewQueue != NULL )
700aaf1e: 9804         	ldr	r0, [sp, #0x10]
700aaf20: b1b0         	cbz	r0, 0x700aaf50 <xQueueGenericCreate+0x50> @ imm = #0x2c
700aaf22: e7ff         	b	0x700aaf24 <xQueueGenericCreate+0x24> @ imm = #-0x2
;             pucQueueStorage = ( uint8_t * ) pxNewQueue;
700aaf24: 9804         	ldr	r0, [sp, #0x10]
700aaf26: 9002         	str	r0, [sp, #0x8]
;             pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700aaf28: 9802         	ldr	r0, [sp, #0x8]
700aaf2a: 3050         	adds	r0, #0x50
700aaf2c: 9002         	str	r0, [sp, #0x8]
;                     pxNewQueue->ucStaticallyAllocated = pdFALSE;
700aaf2e: 9904         	ldr	r1, [sp, #0x10]
700aaf30: 2000         	movs	r0, #0x0
700aaf32: f881 0046    	strb.w	r0, [r1, #0x46]
;             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
700aaf36: 9807         	ldr	r0, [sp, #0x1c]
700aaf38: 9906         	ldr	r1, [sp, #0x18]
700aaf3a: 9a02         	ldr	r2, [sp, #0x8]
700aaf3c: f89d 3017    	ldrb.w	r3, [sp, #0x17]
700aaf40: f8dd c010    	ldr.w	r12, [sp, #0x10]
700aaf44: 46ee         	mov	lr, sp
700aaf46: f8ce c000    	str.w	r12, [lr]
700aaf4a: f000 fda9    	bl	0x700abaa0 <prvInitialiseNewQueue> @ imm = #0xb52
;         }
700aaf4e: e000         	b	0x700aaf52 <xQueueGenericCreate+0x52> @ imm = #0x0
700aaf50: e7ff         	b	0x700aaf52 <xQueueGenericCreate+0x52> @ imm = #-0x2
;         return pxNewQueue;
700aaf52: 9804         	ldr	r0, [sp, #0x10]
700aaf54: b008         	add	sp, #0x20
700aaf56: bd80         	pop	{r7, pc}

700aaf58 <__TI_auto_init_nobinit_nopinit>:
700aaf58: e92d4070     	push	{r4, r5, r6, lr}
700aaf5c: e59f4040     	ldr	r4, [pc, #0x40]         @ 0x700aafa4 <__TI_auto_init_nobinit_nopinit+0x4c>
700aaf60: e59f0038     	ldr	r0, [pc, #0x38]         @ 0x700aafa0 <__TI_auto_init_nobinit_nopinit+0x48>
700aaf64: e1540000     	cmp	r4, r0
700aaf68: 0a00000a     	beq	0x700aaf98 <__TI_auto_init_nobinit_nopinit+0x40> @ imm = #0x28
700aaf6c: e59f5034     	ldr	r5, [pc, #0x34]         @ 0x700aafa8 <__TI_auto_init_nobinit_nopinit+0x50>
700aaf70: e59f6034     	ldr	r6, [pc, #0x34]         @ 0x700aafac <__TI_auto_init_nobinit_nopinit+0x54>
700aaf74: e1550006     	cmp	r5, r6
700aaf78: 0a000006     	beq	0x700aaf98 <__TI_auto_init_nobinit_nopinit+0x40> @ imm = #0x18
700aaf7c: e5950000     	ldr	r0, [r5]
700aaf80: e5951004     	ldr	r1, [r5, #0x4]
700aaf84: e4d02001     	ldrb	r2, [r0], #1
700aaf88: e7942102     	ldr	r2, [r4, r2, lsl #2]
700aaf8c: e12fff32     	blx	r2
700aaf90: e2855008     	add	r5, r5, #8
700aaf94: eafffff6     	b	0x700aaf74 <__TI_auto_init_nobinit_nopinit+0x1c> @ imm = #-0x28
700aaf98: e1a00000     	mov	r0, r0
700aaf9c: e8bd8070     	pop	{r4, r5, r6, pc}
700aafa0: 00 00 00 00  	.word	0x00000000
700aafa4: 00 00 00 00  	.word	0x00000000
700aafa8: 00 00 00 00  	.word	0x00000000
700aafac: 00 00 00 00  	.word	0x00000000

700aafb0 <Sciclient_rmIrqReleaseRaw>:
; {
700aafb0: b580         	push	{r7, lr}
700aafb2: b08e         	sub	sp, #0x38
700aafb4: 900d         	str	r0, [sp, #0x34]
700aafb6: 910c         	str	r1, [sp, #0x30]
700aafb8: f241 0001    	movw	r0, #0x1001
;     sciReq.messageType    = TISCI_MSG_RM_IRQ_RELEASE;
700aafbc: f8ad 0018    	strh.w	r0, [sp, #0x18]
700aafc0: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aafc2: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aafc4: 980d         	ldr	r0, [sp, #0x34]
700aafc6: 9008         	str	r0, [sp, #0x20]
700aafc8: 201c         	movs	r0, #0x1c
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aafca: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700aafcc: 980c         	ldr	r0, [sp, #0x30]
700aafce: 900a         	str	r0, [sp, #0x28]
700aafd0: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aafd2: 9003         	str	r0, [sp, #0xc]
700aafd4: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t *)&resp;
700aafd6: 9004         	str	r0, [sp, #0x10]
700aafd8: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700aafda: 9005         	str	r0, [sp, #0x14]
700aafdc: a806         	add	r0, sp, #0x18
700aafde: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700aafe0: f7f1 f81e    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xefc4
700aafe4: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700aafe6: 980b         	ldr	r0, [sp, #0x2c]
700aafe8: b930         	cbnz	r0, 0x700aaff8 <Sciclient_rmIrqReleaseRaw+0x48> @ imm = #0xc
700aafea: e7ff         	b	0x700aafec <Sciclient_rmIrqReleaseRaw+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aafec: 9803         	ldr	r0, [sp, #0xc]
700aafee: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aaff2: 2802         	cmp	r0, #0x2
700aaff4: d004         	beq	0x700ab000 <Sciclient_rmIrqReleaseRaw+0x50> @ imm = #0x8
700aaff6: e7ff         	b	0x700aaff8 <Sciclient_rmIrqReleaseRaw+0x48> @ imm = #-0x2
700aaff8: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aaffc: 900b         	str	r0, [sp, #0x2c]
;     }
700aaffe: e7ff         	b	0x700ab000 <Sciclient_rmIrqReleaseRaw+0x50> @ imm = #-0x2
;     return r;
700ab000: 980b         	ldr	r0, [sp, #0x2c]
700ab002: b00e         	add	sp, #0x38
700ab004: bd80         	pop	{r7, pc}
		...
700ab00e: 0000         	movs	r0, r0

700ab010 <Sciclient_rmPsilPair>:
; {
700ab010: b580         	push	{r7, lr}
700ab012: b08e         	sub	sp, #0x38
700ab014: 900d         	str	r0, [sp, #0x34]
700ab016: 910c         	str	r1, [sp, #0x30]
700ab018: f44f 5094    	mov.w	r0, #0x1280
;     sciReq.messageType    = TISCI_MSG_RM_PSIL_PAIR;
700ab01c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700ab020: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ab022: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ab024: 980d         	ldr	r0, [sp, #0x34]
700ab026: 9008         	str	r0, [sp, #0x20]
700ab028: 2014         	movs	r0, #0x14
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ab02a: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700ab02c: 980c         	ldr	r0, [sp, #0x30]
700ab02e: 900a         	str	r0, [sp, #0x28]
700ab030: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ab032: 9003         	str	r0, [sp, #0xc]
700ab034: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t*)&resp;
700ab036: 9004         	str	r0, [sp, #0x10]
700ab038: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700ab03a: 9005         	str	r0, [sp, #0x14]
700ab03c: a806         	add	r0, sp, #0x18
700ab03e: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700ab040: f7f0 ffee    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xf024
700ab044: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700ab046: 980b         	ldr	r0, [sp, #0x2c]
700ab048: b930         	cbnz	r0, 0x700ab058 <Sciclient_rmPsilPair+0x48> @ imm = #0xc
700ab04a: e7ff         	b	0x700ab04c <Sciclient_rmPsilPair+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ab04c: 9803         	ldr	r0, [sp, #0xc]
700ab04e: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ab052: 2802         	cmp	r0, #0x2
700ab054: d004         	beq	0x700ab060 <Sciclient_rmPsilPair+0x50> @ imm = #0x8
700ab056: e7ff         	b	0x700ab058 <Sciclient_rmPsilPair+0x48> @ imm = #-0x2
700ab058: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ab05c: 900b         	str	r0, [sp, #0x2c]
;     }
700ab05e: e7ff         	b	0x700ab060 <Sciclient_rmPsilPair+0x50> @ imm = #-0x2
;     return r;
700ab060: 980b         	ldr	r0, [sp, #0x2c]
700ab062: b00e         	add	sp, #0x38
700ab064: bd80         	pop	{r7, pc}
		...
700ab06e: 0000         	movs	r0, r0

700ab070 <Sciclient_rmPsilUnpair>:
; {
700ab070: b580         	push	{r7, lr}
700ab072: b08e         	sub	sp, #0x38
700ab074: 900d         	str	r0, [sp, #0x34]
700ab076: 910c         	str	r1, [sp, #0x30]
700ab078: f241 2081    	movw	r0, #0x1281
;     sciReq.messageType    = TISCI_MSG_RM_PSIL_UNPAIR;
700ab07c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700ab080: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ab082: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ab084: 980d         	ldr	r0, [sp, #0x34]
700ab086: 9008         	str	r0, [sp, #0x20]
700ab088: 2014         	movs	r0, #0x14
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ab08a: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700ab08c: 980c         	ldr	r0, [sp, #0x30]
700ab08e: 900a         	str	r0, [sp, #0x28]
700ab090: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ab092: 9003         	str	r0, [sp, #0xc]
700ab094: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t *)&resp;
700ab096: 9004         	str	r0, [sp, #0x10]
700ab098: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700ab09a: 9005         	str	r0, [sp, #0x14]
700ab09c: a806         	add	r0, sp, #0x18
700ab09e: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700ab0a0: f7f0 ffbe    	bl	0x7009c020 <Sciclient_service> @ imm = #-0xf084
700ab0a4: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700ab0a6: 980b         	ldr	r0, [sp, #0x2c]
700ab0a8: b930         	cbnz	r0, 0x700ab0b8 <Sciclient_rmPsilUnpair+0x48> @ imm = #0xc
700ab0aa: e7ff         	b	0x700ab0ac <Sciclient_rmPsilUnpair+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ab0ac: 9803         	ldr	r0, [sp, #0xc]
700ab0ae: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ab0b2: 2802         	cmp	r0, #0x2
700ab0b4: d004         	beq	0x700ab0c0 <Sciclient_rmPsilUnpair+0x50> @ imm = #0x8
700ab0b6: e7ff         	b	0x700ab0b8 <Sciclient_rmPsilUnpair+0x48> @ imm = #-0x2
700ab0b8: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ab0bc: 900b         	str	r0, [sp, #0x2c]
;     }
700ab0be: e7ff         	b	0x700ab0c0 <Sciclient_rmPsilUnpair+0x50> @ imm = #-0x2
;     return r;
700ab0c0: 980b         	ldr	r0, [sp, #0x2c]
700ab0c2: b00e         	add	sp, #0x38
700ab0c4: bd80         	pop	{r7, pc}
		...
700ab0ce: 0000         	movs	r0, r0

700ab0d0 <Udma_chSetPeerReg>:
; {
700ab0d0: b580         	push	{r7, lr}
700ab0d2: b086         	sub	sp, #0x18
700ab0d4: f8dd c020    	ldr.w	r12, [sp, #0x20]
700ab0d8: 9005         	str	r0, [sp, #0x14]
700ab0da: 9104         	str	r1, [sp, #0x10]
700ab0dc: 9203         	str	r2, [sp, #0xc]
700ab0de: 9302         	str	r3, [sp, #0x8]
;     regVal = CSL_REG32_RD(PEER8);
700ab0e0: 9803         	ldr	r0, [sp, #0xc]
700ab0e2: f002 ffed    	bl	0x700ae0c0 <CSL_REG32_RD_RAW> @ imm = #0x2fda
700ab0e6: 9001         	str	r0, [sp, #0x4]
;     CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 0U);
700ab0e8: 9801         	ldr	r0, [sp, #0x4]
700ab0ea: f020 4000    	bic	r0, r0, #0x80000000
700ab0ee: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER8, regVal);
700ab0f0: 9803         	ldr	r0, [sp, #0xc]
700ab0f2: 9901         	ldr	r1, [sp, #0x4]
700ab0f4: f002 ff44    	bl	0x700adf80 <CSL_REG32_WR_RAW> @ imm = #0x2e88
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_X, pdmaPrms->elemSize) |
700ab0f8: 9804         	ldr	r0, [sp, #0x10]
700ab0fa: 6801         	ldr	r1, [r0]
;                 CSL_FMK(PSILCFG_REG_STATIC_TR_Y, pdmaPrms->elemCnt);
700ab0fc: 6840         	ldr	r0, [r0, #0x4]
700ab0fe: f36f 301f    	bfc	r0, #12, #20
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_X, pdmaPrms->elemSize) |
700ab102: f361 601a    	bfi	r0, r1, #24, #3
700ab106: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER0, regVal);
700ab108: 9808         	ldr	r0, [sp, #0x20]
700ab10a: 9901         	ldr	r1, [sp, #0x4]
700ab10c: f002 ff38    	bl	0x700adf80 <CSL_REG32_WR_RAW> @ imm = #0x2e70
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_Z, pdmaPrms->fifoCnt);
700ab110: 9804         	ldr	r0, [sp, #0x10]
700ab112: 6880         	ldr	r0, [r0, #0x8]
700ab114: f36f 301f    	bfc	r0, #12, #20
700ab118: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER1, regVal);
700ab11a: 9802         	ldr	r0, [sp, #0x8]
700ab11c: 9901         	ldr	r1, [sp, #0x4]
700ab11e: f002 ff2f    	bl	0x700adf80 <CSL_REG32_WR_RAW> @ imm = #0x2e5e
; }
700ab122: b006         	add	sp, #0x18
700ab124: bd80         	pop	{r7, pc}
		...
700ab12e: 0000         	movs	r0, r0

700ab130 <Udma_eventGetGlobalHandle>:
; {
700ab130: b084         	sub	sp, #0x10
700ab132: 9003         	str	r0, [sp, #0xc]
700ab134: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700ab136: 9002         	str	r0, [sp, #0x8]
;     Udma_EventHandle    eventHandle = (Udma_EventHandle) NULL_PTR;
700ab138: 9000         	str	r0, [sp]
;     if(NULL_PTR == drvHandle)
700ab13a: 9803         	ldr	r0, [sp, #0xc]
700ab13c: b920         	cbnz	r0, 0x700ab148 <Udma_eventGetGlobalHandle+0x18> @ imm = #0x8
700ab13e: e7ff         	b	0x700ab140 <Udma_eventGetGlobalHandle+0x10> @ imm = #-0x2
700ab140: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700ab144: 9002         	str	r0, [sp, #0x8]
;     }
700ab146: e7ff         	b	0x700ab148 <Udma_eventGetGlobalHandle+0x18> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab148: 9802         	ldr	r0, [sp, #0x8]
700ab14a: b988         	cbnz	r0, 0x700ab170 <Udma_eventGetGlobalHandle+0x40> @ imm = #0x22
700ab14c: e7ff         	b	0x700ab14e <Udma_eventGetGlobalHandle+0x1e> @ imm = #-0x2
;         drvHandleInt = (Udma_DrvHandleInt) drvHandle;
700ab14e: 9803         	ldr	r0, [sp, #0xc]
700ab150: 9001         	str	r0, [sp, #0x4]
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
700ab152: 9801         	ldr	r0, [sp, #0x4]
700ab154: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700ab158: f64a 31cd    	movw	r1, #0xabcd
700ab15c: f6ca 31dc    	movt	r1, #0xabdc
700ab160: 4288         	cmp	r0, r1
700ab162: d004         	beq	0x700ab16e <Udma_eventGetGlobalHandle+0x3e> @ imm = #0x8
700ab164: e7ff         	b	0x700ab166 <Udma_eventGetGlobalHandle+0x36> @ imm = #-0x2
700ab166: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700ab16a: 9002         	str	r0, [sp, #0x8]
;         }
700ab16c: e7ff         	b	0x700ab16e <Udma_eventGetGlobalHandle+0x3e> @ imm = #-0x2
;     }
700ab16e: e7ff         	b	0x700ab170 <Udma_eventGetGlobalHandle+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab170: 9802         	ldr	r0, [sp, #0x8]
700ab172: b928         	cbnz	r0, 0x700ab180 <Udma_eventGetGlobalHandle+0x50> @ imm = #0xa
700ab174: e7ff         	b	0x700ab176 <Udma_eventGetGlobalHandle+0x46> @ imm = #-0x2
;         eventHandle = (Udma_EventHandle) drvHandleInt->globalEventHandle;
700ab176: 9801         	ldr	r0, [sp, #0x4]
700ab178: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
700ab17c: 9000         	str	r0, [sp]
;     }
700ab17e: e7ff         	b	0x700ab180 <Udma_eventGetGlobalHandle+0x50> @ imm = #-0x2
;     return (eventHandle);
700ab180: 9800         	ldr	r0, [sp]
700ab182: b004         	add	sp, #0x10
700ab184: 4770         	bx	lr
		...
700ab18e: 0000         	movs	r0, r0

700ab190 <CSL_pktdmaIsValidChanIdx>:
; {
700ab190: b084         	sub	sp, #0x10
700ab192: 9003         	str	r0, [sp, #0xc]
700ab194: 9102         	str	r1, [sp, #0x8]
700ab196: 9201         	str	r2, [sp, #0x4]
;     if( (chanDir == CSL_PKTDMA_CHAN_DIR_TX) && (chanIdx < pCfg->txChanCnt) )
700ab198: 9801         	ldr	r0, [sp, #0x4]
700ab19a: b950         	cbnz	r0, 0x700ab1b2 <CSL_pktdmaIsValidChanIdx+0x22> @ imm = #0x14
700ab19c: e7ff         	b	0x700ab19e <CSL_pktdmaIsValidChanIdx+0xe> @ imm = #-0x2
700ab19e: 9802         	ldr	r0, [sp, #0x8]
700ab1a0: 9903         	ldr	r1, [sp, #0xc]
700ab1a2: 6a09         	ldr	r1, [r1, #0x20]
700ab1a4: 4288         	cmp	r0, r1
700ab1a6: d204         	bhs	0x700ab1b2 <CSL_pktdmaIsValidChanIdx+0x22> @ imm = #0x8
700ab1a8: e7ff         	b	0x700ab1aa <CSL_pktdmaIsValidChanIdx+0x1a> @ imm = #-0x2
700ab1aa: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700ab1ac: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab1b0: e012         	b	0x700ab1d8 <CSL_pktdmaIsValidChanIdx+0x48> @ imm = #0x24
;     else if( (chanDir == CSL_PKTDMA_CHAN_DIR_RX) && (chanIdx < pCfg->rxChanCnt) )
700ab1b2: 9801         	ldr	r0, [sp, #0x4]
700ab1b4: 2801         	cmp	r0, #0x1
700ab1b6: d10a         	bne	0x700ab1ce <CSL_pktdmaIsValidChanIdx+0x3e> @ imm = #0x14
700ab1b8: e7ff         	b	0x700ab1ba <CSL_pktdmaIsValidChanIdx+0x2a> @ imm = #-0x2
700ab1ba: 9802         	ldr	r0, [sp, #0x8]
700ab1bc: 9903         	ldr	r1, [sp, #0xc]
700ab1be: 6a49         	ldr	r1, [r1, #0x24]
700ab1c0: 4288         	cmp	r0, r1
700ab1c2: d204         	bhs	0x700ab1ce <CSL_pktdmaIsValidChanIdx+0x3e> @ imm = #0x8
700ab1c4: e7ff         	b	0x700ab1c6 <CSL_pktdmaIsValidChanIdx+0x36> @ imm = #-0x2
700ab1c6: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700ab1c8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab1cc: e003         	b	0x700ab1d6 <CSL_pktdmaIsValidChanIdx+0x46> @ imm = #0x6
700ab1ce: 2000         	movs	r0, #0x0
;         bRetVal = (bool)false;
700ab1d0: f88d 0003    	strb.w	r0, [sp, #0x3]
700ab1d4: e7ff         	b	0x700ab1d6 <CSL_pktdmaIsValidChanIdx+0x46> @ imm = #-0x2
700ab1d6: e7ff         	b	0x700ab1d8 <CSL_pktdmaIsValidChanIdx+0x48> @ imm = #-0x2
;     return bRetVal;
700ab1d8: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab1dc: f000 0001    	and	r0, r0, #0x1
700ab1e0: b004         	add	sp, #0x10
700ab1e2: 4770         	bx	lr
		...

700ab1f0 <Sciclient_rmUnmappedVintRouteCreate>:
; {
700ab1f0: b580         	push	{r7, lr}
700ab1f2: b084         	sub	sp, #0x10
700ab1f4: 9003         	str	r0, [sp, #0xc]
;     r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700ab1f6: 9903         	ldr	r1, [sp, #0xc]
700ab1f8: 8a08         	ldrh	r0, [r1, #0x10]
700ab1fa: 8a49         	ldrh	r1, [r1, #0x12]
700ab1fc: f10d 0207    	add.w	r2, sp, #0x7
700ab200: f7fe fbee    	bl	0x700a99e0 <Sciclient_rmIaVintGetInfo> @ imm = #-0x1824
700ab204: 9002         	str	r0, [sp, #0x8]
;     if ((r == SystemP_SUCCESS) && (num_evts > 0U)) {
700ab206: 9802         	ldr	r0, [sp, #0x8]
700ab208: b940         	cbnz	r0, 0x700ab21c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #0x10
700ab20a: e7ff         	b	0x700ab20c <Sciclient_rmUnmappedVintRouteCreate+0x1c> @ imm = #-0x2
700ab20c: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ab210: b120         	cbz	r0, 0x700ab21c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #0x8
700ab212: e7ff         	b	0x700ab214 <Sciclient_rmUnmappedVintRouteCreate+0x24> @ imm = #-0x2
700ab214: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ab218: 9002         	str	r0, [sp, #0x8]
;     }
700ab21a: e7ff         	b	0x700ab21c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ab21c: 9802         	ldr	r0, [sp, #0x8]
700ab21e: b970         	cbnz	r0, 0x700ab23e <Sciclient_rmUnmappedVintRouteCreate+0x4e> @ imm = #0x1c
700ab220: e7ff         	b	0x700ab222 <Sciclient_rmUnmappedVintRouteCreate+0x32> @ imm = #-0x2
;         r = Sciclient_rmIrqFindRoute(cfg);
700ab222: 9803         	ldr	r0, [sp, #0xc]
700ab224: f7f1 fd8c    	bl	0x7009cd40 <Sciclient_rmIrqFindRoute> @ imm = #-0xe4e8
700ab228: 9002         	str	r0, [sp, #0x8]
;         if (r == SystemP_SUCCESS) {
700ab22a: 9802         	ldr	r0, [sp, #0x8]
700ab22c: b930         	cbnz	r0, 0x700ab23c <Sciclient_rmUnmappedVintRouteCreate+0x4c> @ imm = #0xc
700ab22e: e7ff         	b	0x700ab230 <Sciclient_rmUnmappedVintRouteCreate+0x40> @ imm = #-0x2
;             r = Sciclient_rmIrqProgramRoute(cfg, false);
700ab230: 9803         	ldr	r0, [sp, #0xc]
700ab232: 2100         	movs	r1, #0x0
700ab234: f7f4 f9d4    	bl	0x7009f5e0 <Sciclient_rmIrqProgramRoute> @ imm = #-0xbc58
700ab238: 9002         	str	r0, [sp, #0x8]
;         }
700ab23a: e7ff         	b	0x700ab23c <Sciclient_rmUnmappedVintRouteCreate+0x4c> @ imm = #-0x2
;     }
700ab23c: e7ff         	b	0x700ab23e <Sciclient_rmUnmappedVintRouteCreate+0x4e> @ imm = #-0x2
;     return r;
700ab23e: 9802         	ldr	r0, [sp, #0x8]
700ab240: b004         	add	sp, #0x10
700ab242: bd80         	pop	{r7, pc}
		...

700ab250 <UART_OperModeValid>:
; {
700ab250: b082         	sub	sp, #0x8
700ab252: 9001         	str	r0, [sp, #0x4]
700ab254: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ab258: 9000         	str	r0, [sp]
;     if(((operMode == UART_OPER_MODE_16X) ||
700ab25a: 9801         	ldr	r0, [sp, #0x4]
700ab25c: b1e0         	cbz	r0, 0x700ab298 <UART_OperModeValid+0x48> @ imm = #0x38
700ab25e: e7ff         	b	0x700ab260 <UART_OperModeValid+0x10> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_SIR) ||
700ab260: 9801         	ldr	r0, [sp, #0x4]
700ab262: 2801         	cmp	r0, #0x1
700ab264: d018         	beq	0x700ab298 <UART_OperModeValid+0x48> @ imm = #0x30
700ab266: e7ff         	b	0x700ab268 <UART_OperModeValid+0x18> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_16X_AUTO_BAUD) ||
700ab268: 9801         	ldr	r0, [sp, #0x4]
700ab26a: 2802         	cmp	r0, #0x2
700ab26c: d014         	beq	0x700ab298 <UART_OperModeValid+0x48> @ imm = #0x28
700ab26e: e7ff         	b	0x700ab270 <UART_OperModeValid+0x20> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_13X) ||
700ab270: 9801         	ldr	r0, [sp, #0x4]
700ab272: 2803         	cmp	r0, #0x3
700ab274: d010         	beq	0x700ab298 <UART_OperModeValid+0x48> @ imm = #0x20
700ab276: e7ff         	b	0x700ab278 <UART_OperModeValid+0x28> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_MIR) ||
700ab278: 9801         	ldr	r0, [sp, #0x4]
700ab27a: 2804         	cmp	r0, #0x4
700ab27c: d00c         	beq	0x700ab298 <UART_OperModeValid+0x48> @ imm = #0x18
700ab27e: e7ff         	b	0x700ab280 <UART_OperModeValid+0x30> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_FIR) ||
700ab280: 9801         	ldr	r0, [sp, #0x4]
700ab282: 2805         	cmp	r0, #0x5
700ab284: d008         	beq	0x700ab298 <UART_OperModeValid+0x48> @ imm = #0x10
700ab286: e7ff         	b	0x700ab288 <UART_OperModeValid+0x38> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_CIR) ||
700ab288: 9801         	ldr	r0, [sp, #0x4]
700ab28a: 2806         	cmp	r0, #0x6
700ab28c: d004         	beq	0x700ab298 <UART_OperModeValid+0x48> @ imm = #0x8
700ab28e: e7ff         	b	0x700ab290 <UART_OperModeValid+0x40> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_DISABLED)))
700ab290: 9801         	ldr	r0, [sp, #0x4]
;     if(((operMode == UART_OPER_MODE_16X) ||
700ab292: 2807         	cmp	r0, #0x7
700ab294: d103         	bne	0x700ab29e <UART_OperModeValid+0x4e> @ imm = #0x6
700ab296: e7ff         	b	0x700ab298 <UART_OperModeValid+0x48> @ imm = #-0x2
700ab298: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ab29a: 9000         	str	r0, [sp]
;     }
700ab29c: e7ff         	b	0x700ab29e <UART_OperModeValid+0x4e> @ imm = #-0x2
;     return status;
700ab29e: 9800         	ldr	r0, [sp]
700ab2a0: b002         	add	sp, #0x8
700ab2a2: 4770         	bx	lr
		...

700ab2b0 <UdmaRingPrms_init>:
; {
700ab2b0: b081         	sub	sp, #0x4
700ab2b2: 9000         	str	r0, [sp]
;     if(NULL_PTR != ringPrms)
700ab2b4: 9800         	ldr	r0, [sp]
700ab2b6: b318         	cbz	r0, 0x700ab300 <UdmaRingPrms_init+0x50> @ imm = #0x46
700ab2b8: e7ff         	b	0x700ab2ba <UdmaRingPrms_init+0xa> @ imm = #-0x2
;         ringPrms->ringMem       = NULL_PTR;
700ab2ba: 9900         	ldr	r1, [sp]
700ab2bc: 2000         	movs	r0, #0x0
700ab2be: 6008         	str	r0, [r1]
;         ringPrms->ringMemSize   = UDMA_RING_SIZE_CHECK_SKIP;
700ab2c0: 9a00         	ldr	r2, [sp]
700ab2c2: f64a 31cd    	movw	r1, #0xabcd
700ab2c6: f6ca 31dc    	movt	r1, #0xabdc
700ab2ca: 6051         	str	r1, [r2, #0x4]
;         ringPrms->mode          = TISCI_MSG_VALUE_RM_RING_MODE_RING;
700ab2cc: 9900         	ldr	r1, [sp]
700ab2ce: 7208         	strb	r0, [r1, #0x8]
;         ringPrms->virtId        = UDMA_RING_VIRTID_INVALID;
700ab2d0: 9a00         	ldr	r2, [sp]
700ab2d2: f64f 71ff    	movw	r1, #0xffff
700ab2d6: 8151         	strh	r1, [r2, #0xa]
;         ringPrms->elemCnt       = 0U;
700ab2d8: 9900         	ldr	r1, [sp]
700ab2da: 60c8         	str	r0, [r1, #0xc]
;         ringPrms->elemSize      = UDMA_RING_ES_8BYTES;
700ab2dc: 9a00         	ldr	r2, [sp]
700ab2de: 2101         	movs	r1, #0x1
700ab2e0: 7411         	strb	r1, [r2, #0x10]
;         ringPrms->orderId       = UDMA_DEFAULT_RING_ORDER_ID;
700ab2e2: 9900         	ldr	r1, [sp]
700ab2e4: 7448         	strb	r0, [r1, #0x11]
;         ringPrms->asel          = UDMA_RINGACC_ASEL_ENDPOINT_PHYSADDR;
700ab2e6: 9900         	ldr	r1, [sp]
700ab2e8: 7488         	strb	r0, [r1, #0x12]
;         ringPrms->mappedRingGrp = UDMA_MAPPED_GROUP_INVALID;
700ab2ea: 9900         	ldr	r1, [sp]
700ab2ec: 2004         	movs	r0, #0x4
700ab2ee: f6cf 70ff    	movt	r0, #0xffff
700ab2f2: 6148         	str	r0, [r1, #0x14]
;         ringPrms->mappedChNum   = UDMA_DMA_CH_INVALID;
700ab2f4: 9900         	ldr	r1, [sp]
700ab2f6: 2000         	movs	r0, #0x0
700ab2f8: f6cf 70ff    	movt	r0, #0xffff
700ab2fc: 6188         	str	r0, [r1, #0x18]
;     }
700ab2fe: e7ff         	b	0x700ab300 <UdmaRingPrms_init+0x50> @ imm = #-0x2
;     return;
700ab300: b001         	add	sp, #0x4
700ab302: 4770         	bx	lr
		...

700ab310 <prvIdleTask>:
; static portTASK_FUNCTION(prvIdleTask, pvParameters) {
700ab310: b580         	push	{r7, lr}
700ab312: b082         	sub	sp, #0x8
700ab314: 9001         	str	r0, [sp, #0x4]
;   for (;;) {
700ab316: e7ff         	b	0x700ab318 <prvIdleTask+0x8> @ imm = #-0x2
;     prvCheckTasksWaitingTermination();
700ab318: f7ff fc72    	bl	0x700aac00 <prvCheckTasksWaitingTermination> @ imm = #-0x71c
;       if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) >
700ab31c: f244 40f8    	movw	r0, #0x44f8
700ab320: f2c7 0008    	movt	r0, #0x7008
700ab324: 6800         	ldr	r0, [r0]
700ab326: 2802         	cmp	r0, #0x2
700ab328: d302         	blo	0x700ab330 <prvIdleTask+0x20> @ imm = #0x4
700ab32a: e7ff         	b	0x700ab32c <prvIdleTask+0x1c> @ imm = #-0x2
;         taskYIELD();
700ab32c: df00         	svc	#0x0
;       } else {
700ab32e: e000         	b	0x700ab332 <prvIdleTask+0x22> @ imm = #0x0
700ab330: e7ff         	b	0x700ab332 <prvIdleTask+0x22> @ imm = #-0x2
;       vApplicationIdleHook();
700ab332: f002 ff2d    	bl	0x700ae190 <vApplicationIdleHook> @ imm = #0x2e5a
;       xExpectedIdleTime = prvGetExpectedIdleTime();
700ab336: f7fe f8f3    	bl	0x700a9520 <prvGetExpectedIdleTime> @ imm = #-0x1e1a
700ab33a: 9000         	str	r0, [sp]
;       if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP) {
700ab33c: 9800         	ldr	r0, [sp]
700ab33e: 2802         	cmp	r0, #0x2
700ab340: d30e         	blo	0x700ab360 <prvIdleTask+0x50> @ imm = #0x1c
700ab342: e7ff         	b	0x700ab344 <prvIdleTask+0x34> @ imm = #-0x2
;         vTaskSuspendAll();
700ab344: f002 fe74    	bl	0x700ae030 <vTaskSuspendAll> @ imm = #0x2ce8
;           xExpectedIdleTime = prvGetExpectedIdleTime();
700ab348: f7fe f8ea    	bl	0x700a9520 <prvGetExpectedIdleTime> @ imm = #-0x1e2c
700ab34c: 9000         	str	r0, [sp]
;           if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP) {
700ab34e: 9800         	ldr	r0, [sp]
700ab350: 2802         	cmp	r0, #0x2
700ab352: d301         	blo	0x700ab358 <prvIdleTask+0x48> @ imm = #0x2
700ab354: e7ff         	b	0x700ab356 <prvIdleTask+0x46> @ imm = #-0x2
;           } else {
700ab356: e000         	b	0x700ab35a <prvIdleTask+0x4a> @ imm = #0x0
700ab358: e7ff         	b	0x700ab35a <prvIdleTask+0x4a> @ imm = #-0x2
;         (void)xTaskResumeAll();
700ab35a: f7f5 faa1    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0xaabe
;       } else {
700ab35e: e000         	b	0x700ab362 <prvIdleTask+0x52> @ imm = #0x0
700ab360: e7ff         	b	0x700ab362 <prvIdleTask+0x52> @ imm = #-0x2
;   for (;;) {
700ab362: e7d9         	b	0x700ab318 <prvIdleTask+0x8> @ imm = #-0x4e
		...

700ab370 <vQueueUnregisterQueue>:
;     {
700ab370: b082         	sub	sp, #0x8
700ab372: 9001         	str	r0, [sp, #0x4]
700ab374: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700ab376: 9000         	str	r0, [sp]
700ab378: e7ff         	b	0x700ab37a <vQueueUnregisterQueue+0xa> @ imm = #-0x2
700ab37a: 9800         	ldr	r0, [sp]
700ab37c: 281f         	cmp	r0, #0x1f
700ab37e: d81f         	bhi	0x700ab3c0 <vQueueUnregisterQueue+0x50> @ imm = #0x3e
700ab380: e7ff         	b	0x700ab382 <vQueueUnregisterQueue+0x12> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].xHandle == xQueue )
700ab382: 9900         	ldr	r1, [sp]
700ab384: f644 0078    	movw	r0, #0x4878
700ab388: f2c7 0008    	movt	r0, #0x7008
700ab38c: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700ab390: 6840         	ldr	r0, [r0, #0x4]
700ab392: 9901         	ldr	r1, [sp, #0x4]
700ab394: 4288         	cmp	r0, r1
700ab396: d10d         	bne	0x700ab3b4 <vQueueUnregisterQueue+0x44> @ imm = #0x1a
700ab398: e7ff         	b	0x700ab39a <vQueueUnregisterQueue+0x2a> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = NULL;
700ab39a: 9a00         	ldr	r2, [sp]
700ab39c: f644 0178    	movw	r1, #0x4878
700ab3a0: f2c7 0108    	movt	r1, #0x7008
700ab3a4: 2000         	movs	r0, #0x0
700ab3a6: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
700ab3aa: 9a00         	ldr	r2, [sp]
700ab3ac: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700ab3b0: 6048         	str	r0, [r1, #0x4]
;                 break;
700ab3b2: e005         	b	0x700ab3c0 <vQueueUnregisterQueue+0x50> @ imm = #0xa
700ab3b4: e7ff         	b	0x700ab3b6 <vQueueUnregisterQueue+0x46> @ imm = #-0x2
;         }
700ab3b6: e7ff         	b	0x700ab3b8 <vQueueUnregisterQueue+0x48> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700ab3b8: 9800         	ldr	r0, [sp]
700ab3ba: 3001         	adds	r0, #0x1
700ab3bc: 9000         	str	r0, [sp]
700ab3be: e7dc         	b	0x700ab37a <vQueueUnregisterQueue+0xa> @ imm = #-0x48
;     } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
700ab3c0: b002         	add	sp, #0x8
700ab3c2: 4770         	bx	lr
		...

700ab3d0 <Drivers_open>:
; {
700ab3d0: b5b0         	push	{r4, r5, r7, lr}
700ab3d2: b082         	sub	sp, #0x8
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700ab3d4: f640 31dc    	movw	r1, #0xbdc
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700ab3d8: f644 54c0    	movw	r4, #0x4dc0
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700ab3dc: f2c7 010b    	movt	r1, #0x700b
700ab3e0: 2500         	movs	r5, #0x0
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700ab3e2: f2c7 0408    	movt	r4, #0x7008
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700ab3e6: 2000         	movs	r0, #0x0
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700ab3e8: 6025         	str	r5, [r4]
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700ab3ea: f7ef f9f9    	bl	0x7009a7e0 <UART_open>  @ imm = #-0x10c0e
700ab3ee: 6020         	str	r0, [r4]
;         if(NULL == gUartHandle[instCnt])
700ab3f0: b108         	cbz	r0, 0x700ab3f6 <Drivers_open+0x26> @ imm = #0x2
; }
700ab3f2: b002         	add	sp, #0x8
700ab3f4: bdb0         	pop	{r4, r5, r7, pc}
;             DebugP_logError("UART open failed for instance %d !!!\r\n", instCnt);
700ab3f6: f64f 5177    	movw	r1, #0xfd77
700ab3fa: f240 4259    	movw	r2, #0x459
700ab3fe: f2c7 010a    	movt	r1, #0x700a
700ab402: f2c7 020b    	movt	r2, #0x700b
700ab406: 2002         	movs	r0, #0x2
700ab408: 236e         	movs	r3, #0x6e
700ab40a: 9500         	str	r5, [sp]
700ab40c: f7fc fed0    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #-0x3260
;         if(gUartHandle[instCnt] != NULL)
700ab410: 6820         	ldr	r0, [r4]
700ab412: 2800         	cmp	r0, #0x0
700ab414: d0ed         	beq	0x700ab3f2 <Drivers_open+0x22> @ imm = #-0x26
;             UART_close(gUartHandle[instCnt]);
700ab416: f7f3 f8bb    	bl	0x7009e590 <UART_close> @ imm = #-0xce8a
700ab41a: 2000         	movs	r0, #0x0
;             gUartHandle[instCnt] = NULL;
700ab41c: 6020         	str	r0, [r4]
; }
700ab41e: b002         	add	sp, #0x8
700ab420: bdb0         	pop	{r4, r5, r7, pc}
		...
700ab42e: 0000         	movs	r0, r0

700ab430 <Udma_chInitRegs>:
; {
700ab430: b081         	sub	sp, #0x4
700ab432: 9000         	str	r0, [sp]
;     chHandle->pBcdmaBcCfgRegs    = (volatile CSL_bcdma_bccfgRegs_chan *) NULL_PTR;
700ab434: 9900         	ldr	r1, [sp]
700ab436: 2000         	movs	r0, #0x0
700ab438: f8c1 0214    	str.w	r0, [r1, #0x214]
;     chHandle->pBcdmaBcRtRegs     = (volatile CSL_bcdma_bcrtRegs_chan *) NULL_PTR;
700ab43c: 9900         	ldr	r1, [sp]
700ab43e: f8c1 0218    	str.w	r0, [r1, #0x218]
;     chHandle->pBcdmaTxCfgRegs   = (volatile CSL_bcdma_txccfgRegs_chan *) NULL_PTR;
700ab442: 9900         	ldr	r1, [sp]
700ab444: f8c1 021c    	str.w	r0, [r1, #0x21c]
;     chHandle->pBcdmaTxRtRegs    = (volatile CSL_bcdma_txcrtRegs_chan *) NULL_PTR;
700ab448: 9900         	ldr	r1, [sp]
700ab44a: f8c1 0220    	str.w	r0, [r1, #0x220]
;     chHandle->pBcdmaRxCfgRegs   = (volatile CSL_bcdma_rxccfgRegs_chan *) NULL_PTR;
700ab44e: 9900         	ldr	r1, [sp]
700ab450: f8c1 0224    	str.w	r0, [r1, #0x224]
;     chHandle->pBcdmaRxRtRegs    = (volatile CSL_bcdma_rxcrtRegs_chan *) NULL_PTR;
700ab454: 9900         	ldr	r1, [sp]
700ab456: f8c1 0228    	str.w	r0, [r1, #0x228]
;     chHandle->pPktdmaTxCfgRegs  = (volatile CSL_pktdma_txccfgRegs_chan *) NULL_PTR;
700ab45a: 9900         	ldr	r1, [sp]
700ab45c: f8c1 022c    	str.w	r0, [r1, #0x22c]
;     chHandle->pPktdmaTxRtRegs   = (volatile CSL_pktdma_txcrtRegs_chan *) NULL_PTR;
700ab460: 9900         	ldr	r1, [sp]
700ab462: f8c1 0230    	str.w	r0, [r1, #0x230]
;     chHandle->pPktdmaRxCfgRegs  = (volatile CSL_pktdma_rxccfgRegs_chan *) NULL_PTR;
700ab466: 9900         	ldr	r1, [sp]
700ab468: f8c1 0234    	str.w	r0, [r1, #0x234]
;     chHandle->pPktdmaRxRtRegs   = (volatile CSL_pktdma_rxcrtRegs_chan *) NULL_PTR;
700ab46c: 9900         	ldr	r1, [sp]
700ab46e: f8c1 0238    	str.w	r0, [r1, #0x238]
;     chHandle->pPktdmaExtCfgRegs = (volatile CSL_pktdma_txccfgRegs_chan *) NULL_PTR;
700ab472: 9900         	ldr	r1, [sp]
700ab474: f8c1 023c    	str.w	r0, [r1, #0x23c]
;     chHandle->pPktdmaExtRtRegs  = (volatile CSL_pktdma_txcrtRegs_chan *) NULL_PTR;
700ab478: 9900         	ldr	r1, [sp]
700ab47a: f8c1 0240    	str.w	r0, [r1, #0x240]
; }
700ab47e: b001         	add	sp, #0x4
700ab480: 4770         	bx	lr
		...
700ab48e: 0000         	movs	r0, r0

700ab490 <vQueueAddToRegistry>:
;     {
700ab490: b083         	sub	sp, #0xc
700ab492: 9002         	str	r0, [sp, #0x8]
700ab494: 9101         	str	r1, [sp, #0x4]
700ab496: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700ab498: 9000         	str	r0, [sp]
700ab49a: e7ff         	b	0x700ab49c <vQueueAddToRegistry+0xc> @ imm = #-0x2
700ab49c: 9800         	ldr	r0, [sp]
700ab49e: 281f         	cmp	r0, #0x1f
700ab4a0: d81d         	bhi	0x700ab4de <vQueueAddToRegistry+0x4e> @ imm = #0x3a
700ab4a2: e7ff         	b	0x700ab4a4 <vQueueAddToRegistry+0x14> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].pcQueueName == NULL )
700ab4a4: 9900         	ldr	r1, [sp]
700ab4a6: f644 0078    	movw	r0, #0x4878
700ab4aa: f2c7 0008    	movt	r0, #0x7008
700ab4ae: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
700ab4b2: b970         	cbnz	r0, 0x700ab4d2 <vQueueAddToRegistry+0x42> @ imm = #0x1c
700ab4b4: e7ff         	b	0x700ab4b6 <vQueueAddToRegistry+0x26> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = pcQueueName;
700ab4b6: 9801         	ldr	r0, [sp, #0x4]
700ab4b8: 9a00         	ldr	r2, [sp]
700ab4ba: f644 0178    	movw	r1, #0x4878
700ab4be: f2c7 0108    	movt	r1, #0x7008
700ab4c2: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = xQueue;
700ab4c6: 9802         	ldr	r0, [sp, #0x8]
700ab4c8: 9a00         	ldr	r2, [sp]
700ab4ca: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700ab4ce: 6048         	str	r0, [r1, #0x4]
;                 break;
700ab4d0: e005         	b	0x700ab4de <vQueueAddToRegistry+0x4e> @ imm = #0xa
700ab4d2: e7ff         	b	0x700ab4d4 <vQueueAddToRegistry+0x44> @ imm = #-0x2
;         }
700ab4d4: e7ff         	b	0x700ab4d6 <vQueueAddToRegistry+0x46> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700ab4d6: 9800         	ldr	r0, [sp]
700ab4d8: 3001         	adds	r0, #0x1
700ab4da: 9000         	str	r0, [sp]
700ab4dc: e7de         	b	0x700ab49c <vQueueAddToRegistry+0xc> @ imm = #-0x44
;     }
700ab4de: b003         	add	sp, #0xc
700ab4e0: 4770         	bx	lr
		...
700ab4ee: 0000         	movs	r0, r0

700ab4f0 <xQueueTakeMutexRecursive>:
;     {
700ab4f0: b580         	push	{r7, lr}
700ab4f2: b086         	sub	sp, #0x18
700ab4f4: 9005         	str	r0, [sp, #0x14]
700ab4f6: 9104         	str	r1, [sp, #0x10]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
700ab4f8: 9805         	ldr	r0, [sp, #0x14]
700ab4fa: 9002         	str	r0, [sp, #0x8]
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
700ab4fc: 9802         	ldr	r0, [sp, #0x8]
700ab4fe: 6880         	ldr	r0, [r0, #0x8]
700ab500: 9001         	str	r0, [sp, #0x4]
700ab502: f002 fc9d    	bl	0x700ade40 <xTaskGetCurrentTaskHandle> @ imm = #0x293a
700ab506: 4601         	mov	r1, r0
700ab508: 9801         	ldr	r0, [sp, #0x4]
700ab50a: 4288         	cmp	r0, r1
700ab50c: d107         	bne	0x700ab51e <xQueueTakeMutexRecursive+0x2e> @ imm = #0xe
700ab50e: e7ff         	b	0x700ab510 <xQueueTakeMutexRecursive+0x20> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
700ab510: 9902         	ldr	r1, [sp, #0x8]
700ab512: 68c8         	ldr	r0, [r1, #0xc]
700ab514: 3001         	adds	r0, #0x1
700ab516: 60c8         	str	r0, [r1, #0xc]
700ab518: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700ab51a: 9003         	str	r0, [sp, #0xc]
;         }
700ab51c: e00e         	b	0x700ab53c <xQueueTakeMutexRecursive+0x4c> @ imm = #0x1c
;             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
700ab51e: 9802         	ldr	r0, [sp, #0x8]
700ab520: 9904         	ldr	r1, [sp, #0x10]
700ab522: f7f4 faad    	bl	0x7009fa80 <xQueueSemaphoreTake> @ imm = #-0xbaa6
700ab526: 9003         	str	r0, [sp, #0xc]
;             if( xReturn != pdFAIL )
700ab528: 9803         	ldr	r0, [sp, #0xc]
700ab52a: b128         	cbz	r0, 0x700ab538 <xQueueTakeMutexRecursive+0x48> @ imm = #0xa
700ab52c: e7ff         	b	0x700ab52e <xQueueTakeMutexRecursive+0x3e> @ imm = #-0x2
;                 ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
700ab52e: 9902         	ldr	r1, [sp, #0x8]
700ab530: 68c8         	ldr	r0, [r1, #0xc]
700ab532: 3001         	adds	r0, #0x1
700ab534: 60c8         	str	r0, [r1, #0xc]
;             }
700ab536: e000         	b	0x700ab53a <xQueueTakeMutexRecursive+0x4a> @ imm = #0x0
700ab538: e7ff         	b	0x700ab53a <xQueueTakeMutexRecursive+0x4a> @ imm = #-0x2
700ab53a: e7ff         	b	0x700ab53c <xQueueTakeMutexRecursive+0x4c> @ imm = #-0x2
;         return xReturn;
700ab53c: 9803         	ldr	r0, [sp, #0xc]
700ab53e: b006         	add	sp, #0x18
700ab540: bd80         	pop	{r7, pc}
		...
700ab54e: 0000         	movs	r0, r0

700ab550 <UART_checkCharsAvailInFifo>:
; {
700ab550: b580         	push	{r7, lr}
700ab552: b084         	sub	sp, #0x10
700ab554: 9003         	str	r0, [sp, #0xc]
700ab556: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700ab558: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700ab55a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ab55c: 9803         	ldr	r0, [sp, #0xc]
700ab55e: 300c         	adds	r0, #0xc
700ab560: f002 fd3e    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x2a7c
700ab564: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ab566: 9803         	ldr	r0, [sp, #0xc]
700ab568: 300c         	adds	r0, #0xc
700ab56a: 9000         	str	r0, [sp]
700ab56c: f002 fd38    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x2a70
700ab570: 4601         	mov	r1, r0
700ab572: 9800         	ldr	r0, [sp]
700ab574: f001 017f    	and	r1, r1, #0x7f
700ab578: f002 fd3a    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x2a74
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700ab57c: 9803         	ldr	r0, [sp, #0xc]
700ab57e: 3014         	adds	r0, #0x14
700ab580: f002 fd2e    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x2a5c
;     if ((uint32_t) UART_LSR_RX_FIFO_E_RX_FIFO_E_VALUE_0 !=
700ab584: 07c0         	lsls	r0, r0, #0x1f
700ab586: b118         	cbz	r0, 0x700ab590 <UART_checkCharsAvailInFifo+0x40> @ imm = #0x6
700ab588: e7ff         	b	0x700ab58a <UART_checkCharsAvailInFifo+0x3a> @ imm = #-0x2
700ab58a: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700ab58c: 9001         	str	r0, [sp, #0x4]
;     }
700ab58e: e7ff         	b	0x700ab590 <UART_checkCharsAvailInFifo+0x40> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ab590: 9803         	ldr	r0, [sp, #0xc]
700ab592: 300c         	adds	r0, #0xc
700ab594: 9902         	ldr	r1, [sp, #0x8]
700ab596: f002 fd2b    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x2a56
;     return retVal;
700ab59a: 9801         	ldr	r0, [sp, #0x4]
700ab59c: b004         	add	sp, #0x10
700ab59e: bd80         	pop	{r7, pc}

700ab5a0 <xQueueGiveMutexRecursive>:
;     {
700ab5a0: b580         	push	{r7, lr}
700ab5a2: b084         	sub	sp, #0x10
700ab5a4: 9003         	str	r0, [sp, #0xc]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
700ab5a6: 9803         	ldr	r0, [sp, #0xc]
700ab5a8: 9001         	str	r0, [sp, #0x4]
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
700ab5aa: 9801         	ldr	r0, [sp, #0x4]
700ab5ac: 6880         	ldr	r0, [r0, #0x8]
700ab5ae: 9000         	str	r0, [sp]
700ab5b0: f002 fc46    	bl	0x700ade40 <xTaskGetCurrentTaskHandle> @ imm = #0x288c
700ab5b4: 4601         	mov	r1, r0
700ab5b6: 9800         	ldr	r0, [sp]
700ab5b8: 4288         	cmp	r0, r1
700ab5ba: d113         	bne	0x700ab5e4 <xQueueGiveMutexRecursive+0x44> @ imm = #0x26
700ab5bc: e7ff         	b	0x700ab5be <xQueueGiveMutexRecursive+0x1e> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
700ab5be: 9901         	ldr	r1, [sp, #0x4]
700ab5c0: 68c8         	ldr	r0, [r1, #0xc]
700ab5c2: 3801         	subs	r0, #0x1
700ab5c4: 60c8         	str	r0, [r1, #0xc]
;             if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
700ab5c6: 9801         	ldr	r0, [sp, #0x4]
700ab5c8: 68c0         	ldr	r0, [r0, #0xc]
700ab5ca: b938         	cbnz	r0, 0x700ab5dc <xQueueGiveMutexRecursive+0x3c> @ imm = #0xe
700ab5cc: e7ff         	b	0x700ab5ce <xQueueGiveMutexRecursive+0x2e> @ imm = #-0x2
;                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
700ab5ce: 9801         	ldr	r0, [sp, #0x4]
700ab5d0: 2300         	movs	r3, #0x0
700ab5d2: 4619         	mov	r1, r3
700ab5d4: 461a         	mov	r2, r3
700ab5d6: f7f6 f993    	bl	0x700a1900 <xQueueGenericSend> @ imm = #-0x9cda
;             }
700ab5da: e000         	b	0x700ab5de <xQueueGiveMutexRecursive+0x3e> @ imm = #0x0
700ab5dc: e7ff         	b	0x700ab5de <xQueueGiveMutexRecursive+0x3e> @ imm = #-0x2
700ab5de: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700ab5e0: 9002         	str	r0, [sp, #0x8]
;         }
700ab5e2: e002         	b	0x700ab5ea <xQueueGiveMutexRecursive+0x4a> @ imm = #0x4
700ab5e4: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
700ab5e6: 9002         	str	r0, [sp, #0x8]
700ab5e8: e7ff         	b	0x700ab5ea <xQueueGiveMutexRecursive+0x4a> @ imm = #-0x2
;         return xReturn;
700ab5ea: 9802         	ldr	r0, [sp, #0x8]
700ab5ec: b004         	add	sp, #0x10
700ab5ee: bd80         	pop	{r7, pc}

700ab5f0 <CSL_pktdmaIsChanEnabled>:
; {
700ab5f0: b580         	push	{r7, lr}
700ab5f2: b084         	sub	sp, #0x10
700ab5f4: 9003         	str	r0, [sp, #0xc]
700ab5f6: 9102         	str	r1, [sp, #0x8]
700ab5f8: 9201         	str	r2, [sp, #0x4]
;     if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700ab5fa: 9801         	ldr	r0, [sp, #0x4]
700ab5fc: b960         	cbnz	r0, 0x700ab618 <CSL_pktdmaIsChanEnabled+0x28> @ imm = #0x18
700ab5fe: e7ff         	b	0x700ab600 <CSL_pktdmaIsChanEnabled+0x10> @ imm = #-0x2
;         regVal = CSL_REG32_FEXT( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, PKTDMA_TXCRT_CHAN_CTL_EN );
700ab600: 9803         	ldr	r0, [sp, #0xc]
700ab602: 6900         	ldr	r0, [r0, #0x10]
700ab604: 9902         	ldr	r1, [sp, #0x8]
700ab606: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab60a: f04f 4100    	mov.w	r1, #0x80000000
700ab60e: 221f         	movs	r2, #0x1f
700ab610: f001 ffce    	bl	0x700ad5b0 <CSL_REG32_FEXT_RAW> @ imm = #0x1f9c
700ab614: 9000         	str	r0, [sp]
;     }
700ab616: e00b         	b	0x700ab630 <CSL_pktdmaIsChanEnabled+0x40> @ imm = #0x16
;         regVal = CSL_REG32_FEXT( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, PKTDMA_RXCRT_CHAN_CTL_EN );
700ab618: 9803         	ldr	r0, [sp, #0xc]
700ab61a: 6940         	ldr	r0, [r0, #0x14]
700ab61c: 9902         	ldr	r1, [sp, #0x8]
700ab61e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab622: f04f 4100    	mov.w	r1, #0x80000000
700ab626: 221f         	movs	r2, #0x1f
700ab628: f001 ffc2    	bl	0x700ad5b0 <CSL_REG32_FEXT_RAW> @ imm = #0x1f84
700ab62c: 9000         	str	r0, [sp]
700ab62e: e7ff         	b	0x700ab630 <CSL_pktdmaIsChanEnabled+0x40> @ imm = #-0x2
;     return ((regVal == 1U) ? (bool)true : (bool)false);
700ab630: 9800         	ldr	r0, [sp]
700ab632: 3801         	subs	r0, #0x1
700ab634: fab0 f080    	clz	r0, r0
700ab638: 0940         	lsrs	r0, r0, #0x5
700ab63a: b004         	add	sp, #0x10
700ab63c: bd80         	pop	{r7, pc}
700ab63e: 0000         	movs	r0, r0

700ab640 <UART_getHandle>:
; {
700ab640: b083         	sub	sp, #0xc
700ab642: 9002         	str	r0, [sp, #0x8]
700ab644: 2000         	movs	r0, #0x0
;     UART_Handle         handle = NULL;
700ab646: 9001         	str	r0, [sp, #0x4]
;     if(index < gUartConfigNum)
700ab648: 9802         	ldr	r0, [sp, #0x8]
700ab64a: f640 51a0    	movw	r1, #0xda0
700ab64e: f2c7 010b    	movt	r1, #0x700b
700ab652: 6809         	ldr	r1, [r1]
700ab654: 4288         	cmp	r0, r1
700ab656: d217         	bhs	0x700ab688 <UART_getHandle+0x48> @ imm = #0x2e
700ab658: e7ff         	b	0x700ab65a <UART_getHandle+0x1a> @ imm = #-0x2
;         object = gUartConfig[index].object;
700ab65a: 9902         	ldr	r1, [sp, #0x8]
700ab65c: f640 505c    	movw	r0, #0xd5c
700ab660: f2c7 000b    	movt	r0, #0x700b
700ab664: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700ab668: 6840         	ldr	r0, [r0, #0x4]
700ab66a: 9000         	str	r0, [sp]
;         if(object && (TRUE == object->isOpen))
700ab66c: 9800         	ldr	r0, [sp]
700ab66e: b150         	cbz	r0, 0x700ab686 <UART_getHandle+0x46> @ imm = #0x14
700ab670: e7ff         	b	0x700ab672 <UART_getHandle+0x32> @ imm = #-0x2
700ab672: 9800         	ldr	r0, [sp]
700ab674: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700ab678: 2801         	cmp	r0, #0x1
700ab67a: d104         	bne	0x700ab686 <UART_getHandle+0x46> @ imm = #0x8
700ab67c: e7ff         	b	0x700ab67e <UART_getHandle+0x3e> @ imm = #-0x2
;             handle = object->handle;
700ab67e: 9800         	ldr	r0, [sp]
700ab680: 6800         	ldr	r0, [r0]
700ab682: 9001         	str	r0, [sp, #0x4]
;         }
700ab684: e7ff         	b	0x700ab686 <UART_getHandle+0x46> @ imm = #-0x2
;     }
700ab686: e7ff         	b	0x700ab688 <UART_getHandle+0x48> @ imm = #-0x2
;     return handle;
700ab688: 9801         	ldr	r0, [sp, #0x4]
700ab68a: b003         	add	sp, #0xc
700ab68c: 4770         	bx	lr
700ab68e: 0000         	movs	r0, r0

700ab690 <prvTaskIsTaskSuspended>:
; static BaseType_t prvTaskIsTaskSuspended(const TaskHandle_t xTask) {
700ab690: b083         	sub	sp, #0xc
700ab692: 9002         	str	r0, [sp, #0x8]
700ab694: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700ab696: 9001         	str	r0, [sp, #0x4]
;   const TCB_t *const pxTCB = xTask;
700ab698: 9802         	ldr	r0, [sp, #0x8]
700ab69a: 9000         	str	r0, [sp]
;   if (listIS_CONTAINED_WITHIN(&xSuspendedTaskList, &(pxTCB->xStateListItem)) !=
700ab69c: 9800         	ldr	r0, [sp]
700ab69e: 6940         	ldr	r0, [r0, #0x14]
700ab6a0: f644 5174    	movw	r1, #0x4d74
700ab6a4: f2c7 0108    	movt	r1, #0x7008
700ab6a8: 4288         	cmp	r0, r1
700ab6aa: d114         	bne	0x700ab6d6 <prvTaskIsTaskSuspended+0x46> @ imm = #0x28
700ab6ac: e7ff         	b	0x700ab6ae <prvTaskIsTaskSuspended+0x1e> @ imm = #-0x2
;     if (listIS_CONTAINED_WITHIN(&xPendingReadyList, &(pxTCB->xEventListItem)) ==
700ab6ae: 9800         	ldr	r0, [sp]
700ab6b0: 6a80         	ldr	r0, [r0, #0x28]
700ab6b2: f644 5160    	movw	r1, #0x4d60
700ab6b6: f2c7 0108    	movt	r1, #0x7008
700ab6ba: 4288         	cmp	r0, r1
700ab6bc: d009         	beq	0x700ab6d2 <prvTaskIsTaskSuspended+0x42> @ imm = #0x12
700ab6be: e7ff         	b	0x700ab6c0 <prvTaskIsTaskSuspended+0x30> @ imm = #-0x2
;       if (listIS_CONTAINED_WITHIN(NULL, &(pxTCB->xEventListItem)) !=
700ab6c0: 9800         	ldr	r0, [sp]
700ab6c2: 6a80         	ldr	r0, [r0, #0x28]
700ab6c4: b918         	cbnz	r0, 0x700ab6ce <prvTaskIsTaskSuspended+0x3e> @ imm = #0x6
700ab6c6: e7ff         	b	0x700ab6c8 <prvTaskIsTaskSuspended+0x38> @ imm = #-0x2
700ab6c8: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700ab6ca: 9001         	str	r0, [sp, #0x4]
;       } else {
700ab6cc: e000         	b	0x700ab6d0 <prvTaskIsTaskSuspended+0x40> @ imm = #0x0
700ab6ce: e7ff         	b	0x700ab6d0 <prvTaskIsTaskSuspended+0x40> @ imm = #-0x2
;     } else {
700ab6d0: e000         	b	0x700ab6d4 <prvTaskIsTaskSuspended+0x44> @ imm = #0x0
700ab6d2: e7ff         	b	0x700ab6d4 <prvTaskIsTaskSuspended+0x44> @ imm = #-0x2
;   } else {
700ab6d4: e000         	b	0x700ab6d8 <prvTaskIsTaskSuspended+0x48> @ imm = #0x0
700ab6d6: e7ff         	b	0x700ab6d8 <prvTaskIsTaskSuspended+0x48> @ imm = #-0x2
;   return xReturn;
700ab6d8: 9801         	ldr	r0, [sp, #0x4]
700ab6da: b003         	add	sp, #0xc
700ab6dc: 4770         	bx	lr
700ab6de: 0000         	movs	r0, r0

700ab6e0 <tm_mutex_create>:
; {
700ab6e0: b510         	push	{r4, lr}
700ab6e2: 4604         	mov	r4, r0
;    if (mutex_id < 0 || mutex_id >= TM_FREERTOS_MAX_SEMAPHORES)
700ab6e4: 2802         	cmp	r0, #0x2
700ab6e6: d30b         	blo	0x700ab700 <tm_mutex_create+0x20> @ imm = #0x16
;       printf("Invalid mutex ID: %d. Max allowed: %d\r\n", mutex_id, TM_FREERTOS_MAX_SEMAPHORES - 1);
700ab6e8: f64f 61f3    	movw	r1, #0xfef3
700ab6ec: 4622         	mov	r2, r4
700ab6ee: f2c7 010a    	movt	r1, #0x700a
700ab6f2: 2001         	movs	r0, #0x1
700ab6f4: 2301         	movs	r3, #0x1
700ab6f6: 2401         	movs	r4, #0x1
700ab6f8: f7fc fd5a    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #-0x354c
; }
700ab6fc: 4620         	mov	r0, r4
700ab6fe: bd10         	pop	{r4, pc}
;    tm_mutex_array[mutex_id] = xSemaphoreCreateMutex();
700ab700: 2001         	movs	r0, #0x1
700ab702: f001 ff0d    	bl	0x700ad520 <xQueueCreateMutex> @ imm = #0x1e1a
700ab706: f644 519c    	movw	r1, #0x4d9c
700ab70a: f2c7 0108    	movt	r1, #0x7008
700ab70e: f841 0024    	str.w	r0, [r1, r4, lsl #2]
;    if (tm_mutex_array[mutex_id] == NULL)
700ab712: b108         	cbz	r0, 0x700ab718 <tm_mutex_create+0x38> @ imm = #0x2
700ab714: 2000         	movs	r0, #0x0
; }
700ab716: bd10         	pop	{r4, pc}
;       printf("Failed to create mutex for ID %d\r\n", mutex_id);
700ab718: f64f 71af    	movw	r1, #0xffaf
700ab71c: 4622         	mov	r2, r4
700ab71e: f2c7 010a    	movt	r1, #0x700a
700ab722: 2001         	movs	r0, #0x1
700ab724: 2401         	movs	r4, #0x1
700ab726: f7fc fd43    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #-0x357a
; }
700ab72a: 4620         	mov	r0, r4
700ab72c: bd10         	pop	{r4, pc}
700ab72e: 0000         	movs	r0, r0

700ab730 <Sciclient_rmPsSetInp>:
; {
700ab730: b082         	sub	sp, #0x8
700ab732: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ab736: f8ad 1004    	strh.w	r1, [sp, #0x4]
700ab73a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab73c: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ab73e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ab742: f241 0158    	movw	r1, #0x1058
700ab746: f2c7 0108    	movt	r1, #0x7008
700ab74a: 8c89         	ldrh	r1, [r1, #0x24]
700ab74c: 4288         	cmp	r0, r1
700ab74e: da0e         	bge	0x700ab76e <Sciclient_rmPsSetInp+0x3e> @ imm = #0x1c
700ab750: e7ff         	b	0x700ab752 <Sciclient_rmPsSetInp+0x22> @ imm = #-0x2
;         gPstack.ps[index].inp = inp;
700ab752: f8bd 0004    	ldrh.w	r0, [sp, #0x4]
700ab756: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ab75a: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ab75e: f241 0158    	movw	r1, #0x1058
700ab762: f2c7 0108    	movt	r1, #0x7008
700ab766: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ab76a: 80c8         	strh	r0, [r1, #0x6]
;     } else {
700ab76c: e003         	b	0x700ab776 <Sciclient_rmPsSetInp+0x46> @ imm = #0x6
700ab76e: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ab772: 9000         	str	r0, [sp]
700ab774: e7ff         	b	0x700ab776 <Sciclient_rmPsSetInp+0x46> @ imm = #-0x2
;     return r;
700ab776: 9800         	ldr	r0, [sp]
700ab778: b002         	add	sp, #0x8
700ab77a: 4770         	bx	lr
700ab77c: 0000         	movs	r0, r0
700ab77e: 0000         	movs	r0, r0

700ab780 <Sciclient_rmPsSetOutp>:
; {
700ab780: b082         	sub	sp, #0x8
700ab782: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ab786: f8ad 1004    	strh.w	r1, [sp, #0x4]
700ab78a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab78c: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ab78e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ab792: f241 0158    	movw	r1, #0x1058
700ab796: f2c7 0108    	movt	r1, #0x7008
700ab79a: 8c89         	ldrh	r1, [r1, #0x24]
700ab79c: 4288         	cmp	r0, r1
700ab79e: da0e         	bge	0x700ab7be <Sciclient_rmPsSetOutp+0x3e> @ imm = #0x1c
700ab7a0: e7ff         	b	0x700ab7a2 <Sciclient_rmPsSetOutp+0x22> @ imm = #-0x2
;         gPstack.ps[index].outp = outp;
700ab7a2: f8bd 0004    	ldrh.w	r0, [sp, #0x4]
700ab7a6: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ab7aa: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ab7ae: f241 0158    	movw	r1, #0x1058
700ab7b2: f2c7 0108    	movt	r1, #0x7008
700ab7b6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ab7ba: 8108         	strh	r0, [r1, #0x8]
;     } else {
700ab7bc: e003         	b	0x700ab7c6 <Sciclient_rmPsSetOutp+0x46> @ imm = #0x6
700ab7be: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ab7c2: 9000         	str	r0, [sp]
700ab7c4: e7ff         	b	0x700ab7c6 <Sciclient_rmPsSetOutp+0x46> @ imm = #-0x2
;     return r;
700ab7c6: 9800         	ldr	r0, [sp]
700ab7c8: b002         	add	sp, #0x8
700ab7ca: 4770         	bx	lr
700ab7cc: 0000         	movs	r0, r0
700ab7ce: 0000         	movs	r0, r0

700ab7d0 <Udma_eventGetId>:
; {
700ab7d0: b084         	sub	sp, #0x10
700ab7d2: 9003         	str	r0, [sp, #0xc]
700ab7d4: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            evtNum = UDMA_EVENT_INVALID;
700ab7d8: 9002         	str	r0, [sp, #0x8]
;     Udma_EventHandleInt eventHandleInt = (Udma_EventHandleInt) eventHandle;
700ab7da: 9803         	ldr	r0, [sp, #0xc]
700ab7dc: 9000         	str	r0, [sp]
;     if((NULL_PTR != eventHandleInt) &&
700ab7de: 9800         	ldr	r0, [sp]
700ab7e0: b1c8         	cbz	r0, 0x700ab816 <Udma_eventGetId+0x46> @ imm = #0x32
700ab7e2: e7ff         	b	0x700ab7e4 <Udma_eventGetId+0x14> @ imm = #-0x2
;        (UDMA_INIT_DONE == eventHandleInt->eventInitDone))
700ab7e4: 9800         	ldr	r0, [sp]
700ab7e6: f8d0 0098    	ldr.w	r0, [r0, #0x98]
700ab7ea: f64a 31cd    	movw	r1, #0xabcd
700ab7ee: f6ca 31dc    	movt	r1, #0xabdc
;     if((NULL_PTR != eventHandleInt) &&
700ab7f2: 4288         	cmp	r0, r1
700ab7f4: d10f         	bne	0x700ab816 <Udma_eventGetId+0x46> @ imm = #0x1e
700ab7f6: e7ff         	b	0x700ab7f8 <Udma_eventGetId+0x28> @ imm = #-0x2
;         drvHandle = eventHandleInt->drvHandle;
700ab7f8: 9800         	ldr	r0, [sp]
700ab7fa: 6800         	ldr	r0, [r0]
700ab7fc: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != drvHandle)
700ab7fe: 9801         	ldr	r0, [sp, #0x4]
700ab800: b140         	cbz	r0, 0x700ab814 <Udma_eventGetId+0x44> @ imm = #0x10
700ab802: e7ff         	b	0x700ab804 <Udma_eventGetId+0x34> @ imm = #-0x2
;             evtNum = drvHandle->iaGemOffset + eventHandleInt->globalEvent;
700ab804: 9801         	ldr	r0, [sp, #0x4]
700ab806: f8d0 0118    	ldr.w	r0, [r0, #0x118]
700ab80a: 9900         	ldr	r1, [sp]
700ab80c: 6c89         	ldr	r1, [r1, #0x48]
700ab80e: 4408         	add	r0, r1
700ab810: 9002         	str	r0, [sp, #0x8]
;         }
700ab812: e7ff         	b	0x700ab814 <Udma_eventGetId+0x44> @ imm = #-0x2
;     }
700ab814: e7ff         	b	0x700ab816 <Udma_eventGetId+0x46> @ imm = #-0x2
;     return (evtNum);
700ab816: 9802         	ldr	r0, [sp, #0x8]
700ab818: b004         	add	sp, #0x10
700ab81a: 4770         	bx	lr
700ab81c: 0000         	movs	r0, r0
700ab81e: 0000         	movs	r0, r0

700ab820 <CSL_pktdmaGetRxRT>:
; {
700ab820: b580         	push	{r7, lr}
700ab822: b084         	sub	sp, #0x10
700ab824: 9003         	str	r0, [sp, #0xc]
700ab826: 9102         	str	r1, [sp, #0x8]
700ab828: 9201         	str	r2, [sp, #0x4]
;     val = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700ab82a: 9803         	ldr	r0, [sp, #0xc]
700ab82c: 6940         	ldr	r0, [r0, #0x14]
700ab82e: 9902         	ldr	r1, [sp, #0x8]
700ab830: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab834: f002 fc2c    	bl	0x700ae090 <CSL_REG32_RD_RAW> @ imm = #0x2858
700ab838: 9000         	str	r0, [sp]
;     pRT->enable         = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_EN );
700ab83a: 9800         	ldr	r0, [sp]
700ab83c: 0fc0         	lsrs	r0, r0, #0x1f
700ab83e: 9901         	ldr	r1, [sp, #0x4]
700ab840: 6008         	str	r0, [r1]
;     pRT->teardown       = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_TDOWN );
700ab842: 9800         	ldr	r0, [sp]
700ab844: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700ab848: 9901         	ldr	r1, [sp, #0x4]
700ab84a: 6048         	str	r0, [r1, #0x4]
;     pRT->forcedTeardown = (uint32_t)0U;
700ab84c: 9901         	ldr	r1, [sp, #0x4]
700ab84e: 2000         	movs	r0, #0x0
700ab850: 6108         	str	r0, [r1, #0x10]
;     pRT->pause          = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_PAUSE );
700ab852: 9900         	ldr	r1, [sp]
700ab854: f3c1 7140    	ubfx	r1, r1, #0x1d, #0x1
700ab858: 9a01         	ldr	r2, [sp, #0x4]
700ab85a: 6091         	str	r1, [r2, #0x8]
;     pRT->error          = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_ERROR );
700ab85c: 9900         	ldr	r1, [sp]
700ab85e: f001 0101    	and	r1, r1, #0x1
700ab862: 9a01         	ldr	r2, [sp, #0x4]
700ab864: 60d1         	str	r1, [r2, #0xc]
;     return CSL_PASS;
700ab866: b004         	add	sp, #0x10
700ab868: bd80         	pop	{r7, pc}
700ab86a: 0000         	movs	r0, r0
700ab86c: 0000         	movs	r0, r0
700ab86e: 0000         	movs	r0, r0

700ab870 <CSL_pktdmaGetTxRT>:
; {
700ab870: b580         	push	{r7, lr}
700ab872: b084         	sub	sp, #0x10
700ab874: 9003         	str	r0, [sp, #0xc]
700ab876: 9102         	str	r1, [sp, #0x8]
700ab878: 9201         	str	r2, [sp, #0x4]
;     val = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700ab87a: 9803         	ldr	r0, [sp, #0xc]
700ab87c: 6900         	ldr	r0, [r0, #0x10]
700ab87e: 9902         	ldr	r1, [sp, #0x8]
700ab880: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab884: f002 fc04    	bl	0x700ae090 <CSL_REG32_RD_RAW> @ imm = #0x2808
700ab888: 9000         	str	r0, [sp]
;     pRT->enable         = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_EN );
700ab88a: 9800         	ldr	r0, [sp]
700ab88c: 0fc0         	lsrs	r0, r0, #0x1f
700ab88e: 9901         	ldr	r1, [sp, #0x4]
700ab890: 6008         	str	r0, [r1]
;     pRT->teardown       = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_TDOWN );
700ab892: 9800         	ldr	r0, [sp]
700ab894: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700ab898: 9901         	ldr	r1, [sp, #0x4]
700ab89a: 6048         	str	r0, [r1, #0x4]
;     pRT->forcedTeardown = (uint32_t)0U;
700ab89c: 9901         	ldr	r1, [sp, #0x4]
700ab89e: 2000         	movs	r0, #0x0
700ab8a0: 6108         	str	r0, [r1, #0x10]
;     pRT->pause          = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_PAUSE );
700ab8a2: 9900         	ldr	r1, [sp]
700ab8a4: f3c1 7140    	ubfx	r1, r1, #0x1d, #0x1
700ab8a8: 9a01         	ldr	r2, [sp, #0x4]
700ab8aa: 6091         	str	r1, [r2, #0x8]
;     pRT->error          = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_ERROR );
700ab8ac: 9900         	ldr	r1, [sp]
700ab8ae: f001 0101    	and	r1, r1, #0x1
700ab8b2: 9a01         	ldr	r2, [sp, #0x4]
700ab8b4: 60d1         	str	r1, [r2, #0xc]
;     return CSL_PASS;
700ab8b6: b004         	add	sp, #0x10
700ab8b8: bd80         	pop	{r7, pc}
700ab8ba: 0000         	movs	r0, r0
700ab8bc: 0000         	movs	r0, r0
700ab8be: 0000         	movs	r0, r0

700ab8c0 <Sciclient_getDevId>:
; {
700ab8c0: b083         	sub	sp, #0xc
700ab8c2: 9002         	str	r0, [sp, #0x8]
700ab8c4: f04f 30ff    	mov.w	r0, #0xffffffff
;     uint32_t retVal = UINT32_MAX;
700ab8c8: 9001         	str	r0, [sp, #0x4]
;     switch (coreId)
700ab8ca: 9802         	ldr	r0, [sp, #0x8]
700ab8cc: 9000         	str	r0, [sp]
700ab8ce: 2805         	cmp	r0, #0x5
700ab8d0: d817         	bhi	0x700ab902 <Sciclient_getDevId+0x42> @ imm = #0x2e
700ab8d2: 9900         	ldr	r1, [sp]
700ab8d4: e8df f001    	tbb	[pc, r1]
700ab8d8: 03 06 09 0c  	.word	0x0c090603
700ab8dc: 0f 12        	.short	0x120f
700ab8de: 2009         	movs	r0, #0x9
;         retVal = TISCI_DEV_MCU_M4FSS0_CORE0;
700ab8e0: 9001         	str	r0, [sp, #0x4]
;         break;
700ab8e2: e00f         	b	0x700ab904 <Sciclient_getDevId+0x44> @ imm = #0x1e
700ab8e4: 2079         	movs	r0, #0x79
;         retVal = TISCI_DEV_R5FSS0_CORE0;
700ab8e6: 9001         	str	r0, [sp, #0x4]
;         break;
700ab8e8: e00c         	b	0x700ab904 <Sciclient_getDevId+0x44> @ imm = #0x18
700ab8ea: 207a         	movs	r0, #0x7a
;         retVal = TISCI_DEV_R5FSS0_CORE1;
700ab8ec: 9001         	str	r0, [sp, #0x4]
;         break;
700ab8ee: e009         	b	0x700ab904 <Sciclient_getDevId+0x44> @ imm = #0x12
700ab8f0: 207b         	movs	r0, #0x7b
;         retVal = TISCI_DEV_R5FSS1_CORE0;
700ab8f2: 9001         	str	r0, [sp, #0x4]
;         break;
700ab8f4: e006         	b	0x700ab904 <Sciclient_getDevId+0x44> @ imm = #0xc
700ab8f6: 207c         	movs	r0, #0x7c
;         retVal = TISCI_DEV_R5FSS1_CORE1;
700ab8f8: 9001         	str	r0, [sp, #0x4]
;         break;
700ab8fa: e003         	b	0x700ab904 <Sciclient_getDevId+0x44> @ imm = #0x6
700ab8fc: 2087         	movs	r0, #0x87
;         retVal = TISCI_DEV_A53SS0_CORE_0;
700ab8fe: 9001         	str	r0, [sp, #0x4]
;         break;
700ab900: e000         	b	0x700ab904 <Sciclient_getDevId+0x44> @ imm = #0x0
;         break;
700ab902: e7ff         	b	0x700ab904 <Sciclient_getDevId+0x44> @ imm = #-0x2
;     return retVal;
700ab904: 9801         	ldr	r0, [sp, #0x4]
700ab906: b003         	add	sp, #0xc
700ab908: 4770         	bx	lr
700ab90a: 0000         	movs	r0, r0
700ab90c: 0000         	movs	r0, r0
700ab90e: 0000         	movs	r0, r0

700ab910 <UART_getIntrIdentityStatus>:
; {
700ab910: b580         	push	{r7, lr}
700ab912: b084         	sub	sp, #0x10
700ab914: 9003         	str	r0, [sp, #0xc]
700ab916: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ab918: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = 0U;
700ab91a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ab91c: 9803         	ldr	r0, [sp, #0xc]
700ab91e: 300c         	adds	r0, #0xc
700ab920: f002 fb5e    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x26bc
700ab924: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ab926: 9803         	ldr	r0, [sp, #0xc]
700ab928: 300c         	adds	r0, #0xc
700ab92a: 9000         	str	r0, [sp]
700ab92c: f002 fb58    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x26b0
700ab930: 4601         	mov	r1, r0
700ab932: 9800         	ldr	r0, [sp]
700ab934: f001 017f    	and	r1, r1, #0x7f
700ab938: f002 fb5a    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x26b4
;     retVal = HW_RD_REG32(baseAddr + UART_IIR) & UART_IIR_IT_TYPE_MASK;
700ab93c: 9803         	ldr	r0, [sp, #0xc]
700ab93e: 3008         	adds	r0, #0x8
700ab940: f002 fb4e    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x269c
700ab944: f000 003e    	and	r0, r0, #0x3e
700ab948: 9001         	str	r0, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ab94a: 9803         	ldr	r0, [sp, #0xc]
700ab94c: 300c         	adds	r0, #0xc
700ab94e: 9902         	ldr	r1, [sp, #0x8]
700ab950: f002 fb4e    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x269c
;     return retVal;
700ab954: 9801         	ldr	r0, [sp, #0x4]
700ab956: b004         	add	sp, #0x10
700ab958: bd80         	pop	{r7, pc}
700ab95a: 0000         	movs	r0, r0
700ab95c: 0000         	movs	r0, r0
700ab95e: 0000         	movs	r0, r0

700ab960 <UART_lineCharConfig>:
; {
700ab960: b580         	push	{r7, lr}
700ab962: b084         	sub	sp, #0x10
700ab964: 9003         	str	r0, [sp, #0xc]
700ab966: 9102         	str	r1, [sp, #0x8]
700ab968: 9201         	str	r2, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ab96a: 9803         	ldr	r0, [sp, #0xc]
700ab96c: 300c         	adds	r0, #0xc
700ab96e: f002 fb37    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x266e
700ab972: 9000         	str	r0, [sp]
;     lcrRegValue &= ~((uint32_t) UART_LCR_NB_STOP_MASK | (uint32_t) UART_LCR_CHAR_LENGTH_MASK);
700ab974: 9800         	ldr	r0, [sp]
700ab976: f020 0007    	bic	r0, r0, #0x7
700ab97a: 9000         	str	r0, [sp]
;     lcrRegValue |= wLenStbFlag & (UART_LCR_NB_STOP_MASK |
700ab97c: 9802         	ldr	r0, [sp, #0x8]
700ab97e: f000 0107    	and	r1, r0, #0x7
700ab982: 9800         	ldr	r0, [sp]
700ab984: 4308         	orrs	r0, r1
700ab986: 9000         	str	r0, [sp]
;     lcrRegValue &= ~((uint32_t) UART_LCR_PARITY_TYPE2_MASK |
700ab988: 9800         	ldr	r0, [sp]
700ab98a: f020 0038    	bic	r0, r0, #0x38
700ab98e: 9000         	str	r0, [sp]
;     lcrRegValue |= parityFlag & (UART_LCR_PARITY_TYPE2_MASK |
700ab990: 9801         	ldr	r0, [sp, #0x4]
700ab992: f000 0138    	and	r1, r0, #0x38
700ab996: 9800         	ldr	r0, [sp]
700ab998: 4308         	orrs	r0, r1
700ab99a: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ab99c: 9803         	ldr	r0, [sp, #0xc]
700ab99e: 300c         	adds	r0, #0xc
700ab9a0: 9900         	ldr	r1, [sp]
700ab9a2: f002 fb25    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x264a
; }
700ab9a6: b004         	add	sp, #0x10
700ab9a8: bd80         	pop	{r7, pc}
700ab9aa: 0000         	movs	r0, r0
700ab9ac: 0000         	movs	r0, r0
700ab9ae: 0000         	movs	r0, r0

700ab9b0 <UART_lld_dmaInit>:
; {
700ab9b0: b580         	push	{r7, lr}
700ab9b2: b084         	sub	sp, #0x10
700ab9b4: 9003         	str	r0, [sp, #0xc]
700ab9b6: 9102         	str	r1, [sp, #0x8]
700ab9b8: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700ab9ba: 9001         	str	r0, [sp, #0x4]
;     UART_UdmaChConfig *udmaChCfg = (UART_UdmaChConfig *)dmaChCfg;
700ab9bc: 9802         	ldr	r0, [sp, #0x8]
700ab9be: 9000         	str	r0, [sp]
;     status  = UART_udmaInitRxCh(hUart, udmaChCfg);
700ab9c0: 9803         	ldr	r0, [sp, #0xc]
700ab9c2: 9900         	ldr	r1, [sp]
700ab9c4: f7f6 ffec    	bl	0x700a29a0 <UART_udmaInitRxCh> @ imm = #-0x9028
700ab9c8: 9001         	str	r0, [sp, #0x4]
;     status += UART_udmaInitTxCh(hUart, udmaChCfg);
700ab9ca: 9803         	ldr	r0, [sp, #0xc]
700ab9cc: 9900         	ldr	r1, [sp]
700ab9ce: f7f7 f877    	bl	0x700a2ac0 <UART_udmaInitTxCh> @ imm = #-0x8f12
700ab9d2: 4601         	mov	r1, r0
700ab9d4: 9801         	ldr	r0, [sp, #0x4]
700ab9d6: 4408         	add	r0, r1
700ab9d8: 9001         	str	r0, [sp, #0x4]
;     if (status == UDMA_SOK)
700ab9da: 9801         	ldr	r0, [sp, #0x4]
700ab9dc: b930         	cbnz	r0, 0x700ab9ec <UART_lld_dmaInit+0x3c> @ imm = #0xc
700ab9de: e7ff         	b	0x700ab9e0 <UART_lld_dmaInit+0x30> @ imm = #-0x2
;         udmaChCfg->isOpen = TRUE;
700ab9e0: 9900         	ldr	r1, [sp]
700ab9e2: 2001         	movs	r0, #0x1
700ab9e4: 6388         	str	r0, [r1, #0x38]
700ab9e6: 2000         	movs	r0, #0x0
;         status = UART_TRANSFER_STATUS_SUCCESS;
700ab9e8: 9001         	str	r0, [sp, #0x4]
;     }
700ab9ea: e003         	b	0x700ab9f4 <UART_lld_dmaInit+0x44> @ imm = #0x6
700ab9ec: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ab9f0: 9001         	str	r0, [sp, #0x4]
700ab9f2: e7ff         	b	0x700ab9f4 <UART_lld_dmaInit+0x44> @ imm = #-0x2
;     return status;
700ab9f4: 9801         	ldr	r0, [sp, #0x4]
700ab9f6: b004         	add	sp, #0x10
700ab9f8: bd80         	pop	{r7, pc}
700ab9fa: 0000         	movs	r0, r0
700ab9fc: 0000         	movs	r0, r0
700ab9fe: 0000         	movs	r0, r0

700aba00 <xQueueGenericCreateStatic>:
;     {
700aba00: b580         	push	{r7, lr}
700aba02: b088         	sub	sp, #0x20
700aba04: 4684         	mov	r12, r0
700aba06: 980a         	ldr	r0, [sp, #0x28]
700aba08: f8cd c01c    	str.w	r12, [sp, #0x1c]
700aba0c: 9106         	str	r1, [sp, #0x18]
700aba0e: 9205         	str	r2, [sp, #0x14]
700aba10: 9304         	str	r3, [sp, #0x10]
700aba12: f88d 000f    	strb.w	r0, [sp, #0xf]
;         pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
700aba16: 9804         	ldr	r0, [sp, #0x10]
700aba18: 9002         	str	r0, [sp, #0x8]
;         if( pxNewQueue != NULL )
700aba1a: 9802         	ldr	r0, [sp, #0x8]
700aba1c: b188         	cbz	r0, 0x700aba42 <xQueueGenericCreateStatic+0x42> @ imm = #0x22
700aba1e: e7ff         	b	0x700aba20 <xQueueGenericCreateStatic+0x20> @ imm = #-0x2
;                     pxNewQueue->ucStaticallyAllocated = pdTRUE;
700aba20: 9902         	ldr	r1, [sp, #0x8]
700aba22: 2001         	movs	r0, #0x1
700aba24: f881 0046    	strb.w	r0, [r1, #0x46]
;             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
700aba28: 9807         	ldr	r0, [sp, #0x1c]
700aba2a: 9906         	ldr	r1, [sp, #0x18]
700aba2c: 9a05         	ldr	r2, [sp, #0x14]
700aba2e: f89d 300f    	ldrb.w	r3, [sp, #0xf]
700aba32: f8dd c008    	ldr.w	r12, [sp, #0x8]
700aba36: 46ee         	mov	lr, sp
700aba38: f8ce c000    	str.w	r12, [lr]
700aba3c: f000 f830    	bl	0x700abaa0 <prvInitialiseNewQueue> @ imm = #0x60
;         }
700aba40: e000         	b	0x700aba44 <xQueueGenericCreateStatic+0x44> @ imm = #0x0
700aba42: e7ff         	b	0x700aba44 <xQueueGenericCreateStatic+0x44> @ imm = #-0x2
;         return pxNewQueue;
700aba44: 9802         	ldr	r0, [sp, #0x8]
700aba46: b008         	add	sp, #0x20
700aba48: bd80         	pop	{r7, pc}
700aba4a: 0000         	movs	r0, r0
700aba4c: 0000         	movs	r0, r0
700aba4e: 0000         	movs	r0, r0

700aba50 <UART_resetModule>:
; {
700aba50: b580         	push	{r7, lr}
700aba52: b082         	sub	sp, #0x8
700aba54: 9001         	str	r0, [sp, #0x4]
;     (void)UART_enhanFuncEnable(hUart->baseAddr);
700aba56: 9801         	ldr	r0, [sp, #0x4]
700aba58: 6800         	ldr	r0, [r0]
700aba5a: f000 fd41    	bl	0x700ac4e0 <UART_enhanFuncEnable> @ imm = #0xa82
;     UART_regConfModeRestore(hUart->baseAddr, 0x00U);
700aba5e: 9801         	ldr	r0, [sp, #0x4]
700aba60: 6800         	ldr	r0, [r0]
700aba62: 2100         	movs	r1, #0x0
700aba64: f002 f98c    	bl	0x700add80 <UART_regConfModeRestore> @ imm = #0x2318
;     UART_modemControlReset(hUart->baseAddr);
700aba68: 9801         	ldr	r0, [sp, #0x4]
700aba6a: 6800         	ldr	r0, [r0]
700aba6c: f002 f8b0    	bl	0x700adbd0 <UART_modemControlReset> @ imm = #0x2160
;     UART_intrDisable(hUart->baseAddr, 0xFFU);
700aba70: 9801         	ldr	r0, [sp, #0x4]
700aba72: 6800         	ldr	r0, [r0]
700aba74: 21ff         	movs	r1, #0xff
700aba76: f7f8 fe63    	bl	0x700a4740 <UART_intrDisable> @ imm = #-0x733a
;     UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700aba7a: 9801         	ldr	r0, [sp, #0x4]
700aba7c: 6800         	ldr	r0, [r0]
700aba7e: 2102         	movs	r1, #0x2
700aba80: f001 fbce    	bl	0x700ad220 <UART_intr2Disable> @ imm = #0x179c
;     (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700aba84: 9801         	ldr	r0, [sp, #0x4]
700aba86: 6800         	ldr	r0, [r0]
700aba88: 2107         	movs	r1, #0x7
700aba8a: f001 fc11    	bl	0x700ad2b0 <UART_operatingModeSelect> @ imm = #0x1822
;     UART_moduleReset(hUart);
700aba8e: 9801         	ldr	r0, [sp, #0x4]
700aba90: f7fd f9c6    	bl	0x700a8e20 <UART_moduleReset> @ imm = #-0x2c74
;     return;
700aba94: b002         	add	sp, #0x8
700aba96: bd80         	pop	{r7, pc}
		...

700abaa0 <prvInitialiseNewQueue>:
; {
700abaa0: b580         	push	{r7, lr}
700abaa2: b084         	sub	sp, #0x10
700abaa4: f8dd c018    	ldr.w	r12, [sp, #0x18]
700abaa8: 9003         	str	r0, [sp, #0xc]
700abaaa: 9102         	str	r1, [sp, #0x8]
700abaac: 9201         	str	r2, [sp, #0x4]
700abaae: f88d 3003    	strb.w	r3, [sp, #0x3]
;     if( uxItemSize == ( UBaseType_t ) 0 )
700abab2: 9802         	ldr	r0, [sp, #0x8]
700abab4: b918         	cbnz	r0, 0x700ababe <prvInitialiseNewQueue+0x1e> @ imm = #0x6
700abab6: e7ff         	b	0x700abab8 <prvInitialiseNewQueue+0x18> @ imm = #-0x2
;         pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
700abab8: 9806         	ldr	r0, [sp, #0x18]
700ababa: 6000         	str	r0, [r0]
;     }
700ababc: e003         	b	0x700abac6 <prvInitialiseNewQueue+0x26> @ imm = #0x6
;         pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
700ababe: 9801         	ldr	r0, [sp, #0x4]
700abac0: 9906         	ldr	r1, [sp, #0x18]
700abac2: 6008         	str	r0, [r1]
700abac4: e7ff         	b	0x700abac6 <prvInitialiseNewQueue+0x26> @ imm = #-0x2
;     pxNewQueue->uxLength = uxQueueLength;
700abac6: 9803         	ldr	r0, [sp, #0xc]
700abac8: 9906         	ldr	r1, [sp, #0x18]
700abaca: 63c8         	str	r0, [r1, #0x3c]
;     pxNewQueue->uxItemSize = uxItemSize;
700abacc: 9802         	ldr	r0, [sp, #0x8]
700abace: 9906         	ldr	r1, [sp, #0x18]
700abad0: 6408         	str	r0, [r1, #0x40]
;     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
700abad2: 9806         	ldr	r0, [sp, #0x18]
700abad4: 2101         	movs	r1, #0x1
700abad6: f7fc fdfb    	bl	0x700a86d0 <xQueueGenericReset> @ imm = #-0x340a
;             pxNewQueue->ucQueueType = ucQueueType;
700abada: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700abade: 9906         	ldr	r1, [sp, #0x18]
700abae0: f881 004c    	strb.w	r0, [r1, #0x4c]
; }
700abae4: b004         	add	sp, #0x10
700abae6: bd80         	pop	{r7, pc}
		...

700abaf0 <uxListRemove>:
; {
700abaf0: b082         	sub	sp, #0x8
700abaf2: 9001         	str	r0, [sp, #0x4]
;     List_t * const pxList = pxItemToRemove->pxContainer;
700abaf4: 9801         	ldr	r0, [sp, #0x4]
700abaf6: 6900         	ldr	r0, [r0, #0x10]
700abaf8: 9000         	str	r0, [sp]
;     pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
700abafa: 9801         	ldr	r0, [sp, #0x4]
700abafc: 6841         	ldr	r1, [r0, #0x4]
700abafe: 6880         	ldr	r0, [r0, #0x8]
700abb00: 6088         	str	r0, [r1, #0x8]
;     pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
700abb02: 9901         	ldr	r1, [sp, #0x4]
700abb04: 6848         	ldr	r0, [r1, #0x4]
700abb06: 6889         	ldr	r1, [r1, #0x8]
700abb08: 6048         	str	r0, [r1, #0x4]
;     if( pxList->pxIndex == pxItemToRemove )
700abb0a: 9800         	ldr	r0, [sp]
700abb0c: 6840         	ldr	r0, [r0, #0x4]
700abb0e: 9901         	ldr	r1, [sp, #0x4]
700abb10: 4288         	cmp	r0, r1
700abb12: d105         	bne	0x700abb20 <uxListRemove+0x30> @ imm = #0xa
700abb14: e7ff         	b	0x700abb16 <uxListRemove+0x26> @ imm = #-0x2
;         pxList->pxIndex = pxItemToRemove->pxPrevious;
700abb16: 9801         	ldr	r0, [sp, #0x4]
700abb18: 6880         	ldr	r0, [r0, #0x8]
700abb1a: 9900         	ldr	r1, [sp]
700abb1c: 6048         	str	r0, [r1, #0x4]
;     }
700abb1e: e000         	b	0x700abb22 <uxListRemove+0x32> @ imm = #0x0
700abb20: e7ff         	b	0x700abb22 <uxListRemove+0x32> @ imm = #-0x2
;     pxItemToRemove->pxContainer = NULL;
700abb22: 9901         	ldr	r1, [sp, #0x4]
700abb24: 2000         	movs	r0, #0x0
700abb26: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )--;
700abb28: 9900         	ldr	r1, [sp]
700abb2a: 6808         	ldr	r0, [r1]
700abb2c: 3801         	subs	r0, #0x1
700abb2e: 6008         	str	r0, [r1]
;     return pxList->uxNumberOfItems;
700abb30: 9800         	ldr	r0, [sp]
700abb32: 6800         	ldr	r0, [r0]
700abb34: b002         	add	sp, #0x8
700abb36: 4770         	bx	lr
		...

700abb40 <CSL_bcdmaTeardownRxChan>:
; {
700abb40: b580         	push	{r7, lr}
700abb42: b086         	sub	sp, #0x18
700abb44: 9005         	str	r0, [sp, #0x14]
700abb46: 9104         	str	r1, [sp, #0x10]
700abb48: f88d 200f    	strb.w	r2, [sp, #0xf]
700abb4c: f88d 300e    	strb.w	r3, [sp, #0xe]
;     teardownOpts.force  = (bForce == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700abb50: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700abb54: f000 0001    	and	r0, r0, #0x1
700abb58: 9000         	str	r0, [sp]
;     teardownOpts.wait   = (bWait  == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700abb5a: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700abb5e: f000 0001    	and	r0, r0, #0x1
700abb62: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_TEARDOWN, chanIdx, (void *)&teardownOpts );
700abb64: 9805         	ldr	r0, [sp, #0x14]
700abb66: 9a04         	ldr	r2, [sp, #0x10]
700abb68: 2105         	movs	r1, #0x5
700abb6a: 466b         	mov	r3, sp
700abb6c: f7fd fc18    	bl	0x700a93a0 <CSL_bcdmaDoChanOp> @ imm = #-0x27d0
700abb70: 9002         	str	r0, [sp, #0x8]
;     if( retVal != CSL_PASS )
700abb72: 9802         	ldr	r0, [sp, #0x8]
700abb74: b120         	cbz	r0, 0x700abb80 <CSL_bcdmaTeardownRxChan+0x40> @ imm = #0x8
700abb76: e7ff         	b	0x700abb78 <CSL_bcdmaTeardownRxChan+0x38> @ imm = #-0x2
700abb78: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700abb7c: 9002         	str	r0, [sp, #0x8]
;     }
700abb7e: e7ff         	b	0x700abb80 <CSL_bcdmaTeardownRxChan+0x40> @ imm = #-0x2
;     return retVal;
700abb80: 9802         	ldr	r0, [sp, #0x8]
700abb82: b006         	add	sp, #0x18
700abb84: bd80         	pop	{r7, pc}
		...
700abb8e: 0000         	movs	r0, r0

700abb90 <CSL_bcdmaTeardownTxChan>:
; {
700abb90: b580         	push	{r7, lr}
700abb92: b086         	sub	sp, #0x18
700abb94: 9005         	str	r0, [sp, #0x14]
700abb96: 9104         	str	r1, [sp, #0x10]
700abb98: f88d 200f    	strb.w	r2, [sp, #0xf]
700abb9c: f88d 300e    	strb.w	r3, [sp, #0xe]
;     teardownOpts.force  = (bForce == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700abba0: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700abba4: f000 0001    	and	r0, r0, #0x1
700abba8: 9000         	str	r0, [sp]
;     teardownOpts.wait   = (bWait  == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700abbaa: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700abbae: f000 0001    	and	r0, r0, #0x1
700abbb2: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_TEARDOWN, chanIdx, (void *)&teardownOpts );
700abbb4: 9805         	ldr	r0, [sp, #0x14]
700abbb6: 9a04         	ldr	r2, [sp, #0x10]
700abbb8: 2105         	movs	r1, #0x5
700abbba: 466b         	mov	r3, sp
700abbbc: f7fd fbf0    	bl	0x700a93a0 <CSL_bcdmaDoChanOp> @ imm = #-0x2820
700abbc0: 9002         	str	r0, [sp, #0x8]
;     if( retVal != CSL_PASS )
700abbc2: 9802         	ldr	r0, [sp, #0x8]
700abbc4: b120         	cbz	r0, 0x700abbd0 <CSL_bcdmaTeardownTxChan+0x40> @ imm = #0x8
700abbc6: e7ff         	b	0x700abbc8 <CSL_bcdmaTeardownTxChan+0x38> @ imm = #-0x2
700abbc8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700abbcc: 9002         	str	r0, [sp, #0x8]
;     }
700abbce: e7ff         	b	0x700abbd0 <CSL_bcdmaTeardownTxChan+0x40> @ imm = #-0x2
;     return retVal;
700abbd0: 9802         	ldr	r0, [sp, #0x8]
700abbd2: b006         	add	sp, #0x18
700abbd4: bd80         	pop	{r7, pc}
		...
700abbde: 0000         	movs	r0, r0

700abbe0 <DebugP_uartLogWriterPutChar>:
; {
700abbe0: b580         	push	{r7, lr}
700abbe2: b088         	sub	sp, #0x20
700abbe4: f88d 001f    	strb.w	r0, [sp, #0x1f]
;     char value = character;
700abbe8: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700abbec: f88d 001e    	strb.w	r0, [sp, #0x1e]
;     UART_Handle uartHandle = UART_getHandle(gDebugP_uartDrvIndex);
700abbf0: f640 5098    	movw	r0, #0xd98
700abbf4: f2c7 000b    	movt	r0, #0x700b
700abbf8: 6800         	ldr	r0, [r0]
700abbfa: f7ff fd21    	bl	0x700ab640 <UART_getHandle> @ imm = #-0x5be
700abbfe: 9006         	str	r0, [sp, #0x18]
;     if(uartHandle!=NULL)
700abc00: 9806         	ldr	r0, [sp, #0x18]
700abc02: b170         	cbz	r0, 0x700abc22 <DebugP_uartLogWriterPutChar+0x42> @ imm = #0x1c
700abc04: e7ff         	b	0x700abc06 <DebugP_uartLogWriterPutChar+0x26> @ imm = #-0x2
700abc06: a801         	add	r0, sp, #0x4
;         UART_Transaction_init(&trans);
700abc08: 9000         	str	r0, [sp]
700abc0a: f001 faf1    	bl	0x700ad1f0 <UART_Transaction_init> @ imm = #0x15e2
700abc0e: 9900         	ldr	r1, [sp]
700abc10: f10d 001e    	add.w	r0, sp, #0x1e
;         trans.buf   = &value;
700abc14: 9001         	str	r0, [sp, #0x4]
700abc16: 2001         	movs	r0, #0x1
;         trans.count = 1;
700abc18: 9002         	str	r0, [sp, #0x8]
;         (void) UART_write(uartHandle, &trans);
700abc1a: 9806         	ldr	r0, [sp, #0x18]
700abc1c: f7f2 ff48    	bl	0x7009eab0 <UART_write> @ imm = #-0xd170
;     }
700abc20: e7ff         	b	0x700abc22 <DebugP_uartLogWriterPutChar+0x42> @ imm = #-0x2
; }
700abc22: b008         	add	sp, #0x20
700abc24: bd80         	pop	{r7, pc}
		...
700abc2e: 0000         	movs	r0, r0

700abc30 <Dpl_init>:
; {
700abc30: b510         	push	{r4, lr}
;     HwiP_init();
700abc32: f002 fd0d    	bl	0x700ae650 <HwiP_init>  @ imm = #0x2a1a
;     DebugP_logZoneEnable(DebugP_LOG_ZONE_ERROR);
700abc36: 2002         	movs	r0, #0x2
700abc38: f001 f9ba    	bl	0x700acfb0 <DebugP_logZoneEnable> @ imm = #0x1374
;     DebugP_logZoneEnable(DebugP_LOG_ZONE_WARN);
700abc3c: 2004         	movs	r0, #0x4
700abc3e: f001 f9b7    	bl	0x700acfb0 <DebugP_logZoneEnable> @ imm = #0x136e
;     DebugP_memLogWriterInit(CSL_CORE_ID_R5FSS0_0);
700abc42: 2001         	movs	r0, #0x1
700abc44: f001 fe24    	bl	0x700ad890 <DebugP_memLogWriterInit> @ imm = #0x1c48
;     DebugP_uartSetDrvIndex(CONFIG_UART_CONSOLE);
700abc48: 2000         	movs	r0, #0x0
700abc4a: 2400         	movs	r4, #0x0
700abc4c: f002 f8b8    	bl	0x700addc0 <DebugP_uartSetDrvIndex> @ imm = #0x2170
;     SOC_controlModuleUnlockMMR(SOC_DOMAIN_ID_MAIN, 2);
700abc50: 2000         	movs	r0, #0x0
700abc52: 2102         	movs	r1, #0x2
700abc54: f7fb fb7c    	bl	0x700a7350 <SOC_controlModuleUnlockMMR> @ imm = #-0x4908
700abc58: f248 10d0    	movw	r0, #0x81d0
;     SOC_controlModuleLockMMR(SOC_DOMAIN_ID_MAIN, 2);
700abc5c: 2102         	movs	r1, #0x2
700abc5e: f2c4 3000    	movt	r0, #0x4300
;     *(volatile uint32_t*)(TIMER8_CLOCK_SRC_MUX_ADDR) = TIMER8_CLOCK_SRC_MCU_HFOSC0;
700abc62: 6004         	str	r4, [r0]
;     SOC_controlModuleLockMMR(SOC_DOMAIN_ID_MAIN, 2);
700abc64: 2000         	movs	r0, #0x0
700abc66: f7fc fe0b    	bl	0x700a8880 <SOC_controlModuleLockMMR> @ imm = #-0x33ea
;     ClockP_init();
700abc6a: f7f3 f999    	bl	0x7009efa0 <ClockP_init> @ imm = #-0xccce
;     HwiP_enable();
700abc6e: e8bd 4010    	pop.w	{r4, lr}
700abc72: f7f0 b851    	b.w	0x7009bd18 <$Ven$TA$L$PI$$HwiP_enable> @ imm = #-0xff5e
		...
700abc7e: 0000         	movs	r0, r0

700abc80 <UART_readLineStatus>:
; {
700abc80: b580         	push	{r7, lr}
700abc82: b084         	sub	sp, #0x10
700abc84: 9003         	str	r0, [sp, #0xc]
700abc86: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700abc88: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = 0U;
700abc8a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700abc8c: 9803         	ldr	r0, [sp, #0xc]
700abc8e: 300c         	adds	r0, #0xc
700abc90: f002 f9a6    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x234c
700abc94: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700abc96: 9803         	ldr	r0, [sp, #0xc]
700abc98: 300c         	adds	r0, #0xc
700abc9a: 9000         	str	r0, [sp]
700abc9c: f002 f9a0    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x2340
700abca0: 4601         	mov	r1, r0
700abca2: 9800         	ldr	r0, [sp]
700abca4: f001 017f    	and	r1, r1, #0x7f
700abca8: f002 f9a2    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x2344
;     retVal = HW_RD_REG32(baseAddr + UART_LSR);
700abcac: 9803         	ldr	r0, [sp, #0xc]
700abcae: 3014         	adds	r0, #0x14
700abcb0: f002 f996    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x232c
700abcb4: 9001         	str	r0, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700abcb6: 9803         	ldr	r0, [sp, #0xc]
700abcb8: 300c         	adds	r0, #0xc
700abcba: 9902         	ldr	r1, [sp, #0x8]
700abcbc: f002 f998    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x2330
;     return retVal;
700abcc0: 9801         	ldr	r0, [sp, #0x4]
700abcc2: b004         	add	sp, #0x10
700abcc4: bd80         	pop	{r7, pc}
		...
700abcce: 0000         	movs	r0, r0

700abcd0 <vTaskExitCritical>:
;   if (xSchedulerRunning != pdFALSE) {
700abcd0: f640 50f0    	movw	r0, #0xdf0
700abcd4: f2c7 000b    	movt	r0, #0x700b
700abcd8: 6800         	ldr	r0, [r0]
700abcda: b1d0         	cbz	r0, 0x700abd12 <vTaskExitCritical+0x42> @ imm = #0x34
700abcdc: e7ff         	b	0x700abcde <vTaskExitCritical+0xe> @ imm = #-0x2
;     if (pxCurrentTCB->uxCriticalNesting > 0U) {
700abcde: f640 50ac    	movw	r0, #0xdac
700abce2: f2c7 000b    	movt	r0, #0x700b
700abce6: 6800         	ldr	r0, [r0]
700abce8: 6d40         	ldr	r0, [r0, #0x54]
700abcea: b180         	cbz	r0, 0x700abd0e <vTaskExitCritical+0x3e> @ imm = #0x20
700abcec: e7ff         	b	0x700abcee <vTaskExitCritical+0x1e> @ imm = #-0x2
;       (pxCurrentTCB->uxCriticalNesting)--;
700abcee: f640 50ac    	movw	r0, #0xdac
700abcf2: f2c7 000b    	movt	r0, #0x700b
700abcf6: 6802         	ldr	r2, [r0]
700abcf8: 6d51         	ldr	r1, [r2, #0x54]
700abcfa: 3901         	subs	r1, #0x1
700abcfc: 6551         	str	r1, [r2, #0x54]
;       if (pxCurrentTCB->uxCriticalNesting == 0U) {
700abcfe: 6800         	ldr	r0, [r0]
700abd00: 6d40         	ldr	r0, [r0, #0x54]
700abd02: b910         	cbnz	r0, 0x700abd0a <vTaskExitCritical+0x3a> @ imm = #0x4
700abd04: e7ff         	b	0x700abd06 <vTaskExitCritical+0x36> @ imm = #-0x2
;     __asm__ volatile ( "CPSIE	i" ::: "cc" );
700abd06: b662         	cpsie i
;       } else {
700abd08: e000         	b	0x700abd0c <vTaskExitCritical+0x3c> @ imm = #0x0
700abd0a: e7ff         	b	0x700abd0c <vTaskExitCritical+0x3c> @ imm = #-0x2
;     } else {
700abd0c: e000         	b	0x700abd10 <vTaskExitCritical+0x40> @ imm = #0x0
700abd0e: e7ff         	b	0x700abd10 <vTaskExitCritical+0x40> @ imm = #-0x2
;   } else {
700abd10: e000         	b	0x700abd14 <vTaskExitCritical+0x44> @ imm = #0x0
700abd12: e7ff         	b	0x700abd14 <vTaskExitCritical+0x44> @ imm = #-0x2
; }
700abd14: 4770         	bx	lr
		...
700abd1e: 0000         	movs	r0, r0

700abd20 <CSL_bcdmaGetChanPeerReg>:
; {
700abd20: b580         	push	{r7, lr}
700abd22: b088         	sub	sp, #0x20
700abd24: f8dd c028    	ldr.w	r12, [sp, #0x28]
700abd28: 9007         	str	r0, [sp, #0x1c]
700abd2a: 9106         	str	r1, [sp, #0x18]
700abd2c: 9205         	str	r2, [sp, #0x14]
700abd2e: 9304         	str	r3, [sp, #0x10]
;     remotePeerOpts.regIdx = regIdx;
700abd30: 9804         	ldr	r0, [sp, #0x10]
700abd32: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_REMOTE_PEER_REG, chanIdx, (void *)&remotePeerOpts );
700abd34: 9807         	ldr	r0, [sp, #0x1c]
700abd36: 9a06         	ldr	r2, [sp, #0x18]
700abd38: 210b         	movs	r1, #0xb
700abd3a: ab01         	add	r3, sp, #0x4
700abd3c: f7fd fb30    	bl	0x700a93a0 <CSL_bcdmaDoChanOp> @ imm = #-0x29a0
700abd40: 9003         	str	r0, [sp, #0xc]
;     if( retVal == CSL_PASS )
700abd42: 9803         	ldr	r0, [sp, #0xc]
700abd44: b920         	cbnz	r0, 0x700abd50 <CSL_bcdmaGetChanPeerReg+0x30> @ imm = #0x8
700abd46: e7ff         	b	0x700abd48 <CSL_bcdmaGetChanPeerReg+0x28> @ imm = #-0x2
;         *pVal = remotePeerOpts.regVal;
700abd48: 9802         	ldr	r0, [sp, #0x8]
700abd4a: 990a         	ldr	r1, [sp, #0x28]
700abd4c: 6008         	str	r0, [r1]
;     }
700abd4e: e006         	b	0x700abd5e <CSL_bcdmaGetChanPeerReg+0x3e> @ imm = #0xc
;         *pVal = (uint32_t)0U;
700abd50: 990a         	ldr	r1, [sp, #0x28]
700abd52: 2000         	movs	r0, #0x0
700abd54: 6008         	str	r0, [r1]
700abd56: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700abd5a: 9003         	str	r0, [sp, #0xc]
700abd5c: e7ff         	b	0x700abd5e <CSL_bcdmaGetChanPeerReg+0x3e> @ imm = #-0x2
;     return retVal;
700abd5e: 9803         	ldr	r0, [sp, #0xc]
700abd60: b008         	add	sp, #0x20
700abd62: bd80         	pop	{r7, pc}
		...

700abd70 <_strnlen_s>:
; {
700abd70: b084         	sub	sp, #0x10
700abd72: 9003         	str	r0, [sp, #0xc]
700abd74: 9102         	str	r1, [sp, #0x8]
;   for (s = str; *s && maxsize--; ++s);
700abd76: 9803         	ldr	r0, [sp, #0xc]
700abd78: 9001         	str	r0, [sp, #0x4]
700abd7a: e7ff         	b	0x700abd7c <_strnlen_s+0xc> @ imm = #-0x2
700abd7c: 9801         	ldr	r0, [sp, #0x4]
700abd7e: 7801         	ldrb	r1, [r0]
700abd80: 2000         	movs	r0, #0x0
700abd82: 9000         	str	r0, [sp]
700abd84: b141         	cbz	r1, 0x700abd98 <_strnlen_s+0x28> @ imm = #0x10
700abd86: e7ff         	b	0x700abd88 <_strnlen_s+0x18> @ imm = #-0x2
700abd88: 9802         	ldr	r0, [sp, #0x8]
700abd8a: 1e41         	subs	r1, r0, #0x1
700abd8c: 9102         	str	r1, [sp, #0x8]
700abd8e: 2800         	cmp	r0, #0x0
700abd90: bf18         	it	ne
700abd92: 2001         	movne	r0, #0x1
700abd94: 9000         	str	r0, [sp]
700abd96: e7ff         	b	0x700abd98 <_strnlen_s+0x28> @ imm = #-0x2
700abd98: 9800         	ldr	r0, [sp]
;   for (s = str; *s && maxsize--; ++s);
700abd9a: 07c0         	lsls	r0, r0, #0x1f
700abd9c: b128         	cbz	r0, 0x700abdaa <_strnlen_s+0x3a> @ imm = #0xa
700abd9e: e7ff         	b	0x700abda0 <_strnlen_s+0x30> @ imm = #-0x2
700abda0: e7ff         	b	0x700abda2 <_strnlen_s+0x32> @ imm = #-0x2
700abda2: 9801         	ldr	r0, [sp, #0x4]
700abda4: 3001         	adds	r0, #0x1
700abda6: 9001         	str	r0, [sp, #0x4]
700abda8: e7e8         	b	0x700abd7c <_strnlen_s+0xc> @ imm = #-0x30
;   return (unsigned int)(s - str);
700abdaa: 9801         	ldr	r0, [sp, #0x4]
700abdac: 9903         	ldr	r1, [sp, #0xc]
700abdae: 1a40         	subs	r0, r0, r1
700abdb0: b004         	add	sp, #0x10
700abdb2: 4770         	bx	lr
		...

700abdc0 <prvSampleTimeNow>:
;     {
700abdc0: b580         	push	{r7, lr}
700abdc2: b082         	sub	sp, #0x8
700abdc4: 9001         	str	r0, [sp, #0x4]
;         xTimeNow = xTaskGetTickCount();
700abdc6: f001 fe03    	bl	0x700ad9d0 <xTaskGetTickCount> @ imm = #0x1c06
700abdca: 9000         	str	r0, [sp]
;         if( xTimeNow < xLastTime )
700abdcc: 9800         	ldr	r0, [sp]
700abdce: f640 51a8    	movw	r1, #0xda8
700abdd2: f2c7 010b    	movt	r1, #0x700b
700abdd6: 6809         	ldr	r1, [r1]
700abdd8: 4288         	cmp	r0, r1
700abdda: d206         	bhs	0x700abdea <prvSampleTimeNow+0x2a> @ imm = #0xc
700abddc: e7ff         	b	0x700abdde <prvSampleTimeNow+0x1e> @ imm = #-0x2
;             prvSwitchTimerLists();
700abdde: f7f9 ff67    	bl	0x700a5cb0 <prvSwitchTimerLists> @ imm = #-0x6132
;             *pxTimerListsWereSwitched = pdTRUE;
700abde2: 9901         	ldr	r1, [sp, #0x4]
700abde4: 2001         	movs	r0, #0x1
700abde6: 6008         	str	r0, [r1]
;         }
700abde8: e003         	b	0x700abdf2 <prvSampleTimeNow+0x32> @ imm = #0x6
;             *pxTimerListsWereSwitched = pdFALSE;
700abdea: 9901         	ldr	r1, [sp, #0x4]
700abdec: 2000         	movs	r0, #0x0
700abdee: 6008         	str	r0, [r1]
700abdf0: e7ff         	b	0x700abdf2 <prvSampleTimeNow+0x32> @ imm = #-0x2
;         xLastTime = xTimeNow;
700abdf2: 9800         	ldr	r0, [sp]
700abdf4: f640 51a8    	movw	r1, #0xda8
700abdf8: f2c7 010b    	movt	r1, #0x700b
700abdfc: 6008         	str	r0, [r1]
;         return xTimeNow;
700abdfe: 9800         	ldr	r0, [sp]
700abe00: b002         	add	sp, #0x8
700abe02: bd80         	pop	{r7, pc}
		...

700abe10 <CSL_udmapCppi5SetPktLen>:
; {
700abe10: b083         	sub	sp, #0xc
700abe12: 9002         	str	r0, [sp, #0x8]
700abe14: 9101         	str	r1, [sp, #0x4]
700abe16: 9200         	str	r2, [sp]
;     if( (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST) ||
700abe18: 9801         	ldr	r0, [sp, #0x4]
700abe1a: 2801         	cmp	r0, #0x1
700abe1c: d004         	beq	0x700abe28 <CSL_udmapCppi5SetPktLen+0x18> @ imm = #0x8
700abe1e: e7ff         	b	0x700abe20 <CSL_udmapCppi5SetPktLen+0x10> @ imm = #-0x2
;         (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_MONO) )
700abe20: 9801         	ldr	r0, [sp, #0x4]
;     if( (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST) ||
700abe22: 2802         	cmp	r0, #0x2
700abe24: d107         	bne	0x700abe36 <CSL_udmapCppi5SetPktLen+0x26> @ imm = #0xe
700abe26: e7ff         	b	0x700abe28 <CSL_udmapCppi5SetPktLen+0x18> @ imm = #-0x2
;         CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PKTLEN, pktLen );
700abe28: 9902         	ldr	r1, [sp, #0x8]
700abe2a: 6808         	ldr	r0, [r1]
700abe2c: 9a00         	ldr	r2, [sp]
700abe2e: f362 0015    	bfi	r0, r2, #0, #22
700abe32: 6008         	str	r0, [r1]
;     }
700abe34: e7ff         	b	0x700abe36 <CSL_udmapCppi5SetPktLen+0x26> @ imm = #-0x2
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700abe36: 9801         	ldr	r0, [sp, #0x4]
700abe38: 2803         	cmp	r0, #0x3
700abe3a: d108         	bne	0x700abe4e <CSL_udmapCppi5SetPktLen+0x3e> @ imm = #0x10
700abe3c: e7ff         	b	0x700abe3e <CSL_udmapCppi5SetPktLen+0x2e> @ imm = #-0x2
;         CSL_FINS( ((CSL_UdmapCppi5TRPD *)pDesc)->descInfo, UDMAP_CPPI5_TRPD_DESCINFO_LASTIDX, pktLen-1U );
700abe3e: 9902         	ldr	r1, [sp, #0x8]
700abe40: 6808         	ldr	r0, [r1]
700abe42: 9a00         	ldr	r2, [sp]
700abe44: 3a01         	subs	r2, #0x1
700abe46: f362 000d    	bfi	r0, r2, #0, #14
700abe4a: 6008         	str	r0, [r1]
;     }
700abe4c: e7ff         	b	0x700abe4e <CSL_udmapCppi5SetPktLen+0x3e> @ imm = #-0x2
; }
700abe4e: b003         	add	sp, #0xc
700abe50: 4770         	bx	lr
		...
700abe5e: 0000         	movs	r0, r0

700abe60 <Sciclient_rmIrqGetNodeItf>:
; {
700abe60: b084         	sub	sp, #0x10
700abe62: 9003         	str	r0, [sp, #0xc]
700abe64: f8ad 100a    	strh.w	r1, [sp, #0xa]
700abe68: 9201         	str	r2, [sp, #0x4]
700abe6a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700abe6c: 9000         	str	r0, [sp]
;     if (n_itf < n->n_if) {
700abe6e: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700abe72: 9903         	ldr	r1, [sp, #0xc]
700abe74: 8849         	ldrh	r1, [r1, #0x2]
700abe76: 4288         	cmp	r0, r1
700abe78: da09         	bge	0x700abe8e <Sciclient_rmIrqGetNodeItf+0x2e> @ imm = #0x12
700abe7a: e7ff         	b	0x700abe7c <Sciclient_rmIrqGetNodeItf+0x1c> @ imm = #-0x2
;         *itf = n->p_if[n_itf];
700abe7c: 9803         	ldr	r0, [sp, #0xc]
700abe7e: 6840         	ldr	r0, [r0, #0x4]
700abe80: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700abe84: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700abe88: 9901         	ldr	r1, [sp, #0x4]
700abe8a: 6008         	str	r0, [r1]
;     } else {
700abe8c: e006         	b	0x700abe9c <Sciclient_rmIrqGetNodeItf+0x3c> @ imm = #0xc
;         *itf = NULL;
700abe8e: 9901         	ldr	r1, [sp, #0x4]
700abe90: 2000         	movs	r0, #0x0
700abe92: 6008         	str	r0, [r1]
700abe94: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700abe98: 9000         	str	r0, [sp]
700abe9a: e7ff         	b	0x700abe9c <Sciclient_rmIrqGetNodeItf+0x3c> @ imm = #-0x2
;     return r;
700abe9c: 9800         	ldr	r0, [sp]
700abe9e: b004         	add	sp, #0x10
700abea0: 4770         	bx	lr
		...
700abeae: 0000         	movs	r0, r0

700abeb0 <UART_checkOpenParams>:
; {
700abeb0: b082         	sub	sp, #0x8
700abeb2: 9001         	str	r0, [sp, #0x4]
700abeb4: 2000         	movs	r0, #0x0
;     int32_t     status = SystemP_SUCCESS;
700abeb6: 9000         	str	r0, [sp]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->readMode) &&
700abeb8: 9801         	ldr	r0, [sp, #0x4]
700abeba: 6900         	ldr	r0, [r0, #0x10]
700abebc: 2801         	cmp	r0, #0x1
700abebe: d108         	bne	0x700abed2 <UART_checkOpenParams+0x22> @ imm = #0x10
700abec0: e7ff         	b	0x700abec2 <UART_checkOpenParams+0x12> @ imm = #-0x2
;        (NULL_PTR == prms->readCallbackFxn))
700abec2: 9801         	ldr	r0, [sp, #0x4]
700abec4: 69c0         	ldr	r0, [r0, #0x1c]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->readMode) &&
700abec6: b920         	cbnz	r0, 0x700abed2 <UART_checkOpenParams+0x22> @ imm = #0x8
700abec8: e7ff         	b	0x700abeca <UART_checkOpenParams+0x1a> @ imm = #-0x2
700abeca: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700abece: 9000         	str	r0, [sp]
;     }
700abed0: e7ff         	b	0x700abed2 <UART_checkOpenParams+0x22> @ imm = #-0x2
;     if((UART_TRANSFER_MODE_CALLBACK == prms->writeMode) &&
700abed2: 9801         	ldr	r0, [sp, #0x4]
700abed4: 6980         	ldr	r0, [r0, #0x18]
700abed6: 2801         	cmp	r0, #0x1
700abed8: d108         	bne	0x700abeec <UART_checkOpenParams+0x3c> @ imm = #0x10
700abeda: e7ff         	b	0x700abedc <UART_checkOpenParams+0x2c> @ imm = #-0x2
;        (NULL_PTR == prms->writeCallbackFxn))
700abedc: 9801         	ldr	r0, [sp, #0x4]
700abede: 6a00         	ldr	r0, [r0, #0x20]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->writeMode) &&
700abee0: b920         	cbnz	r0, 0x700abeec <UART_checkOpenParams+0x3c> @ imm = #0x8
700abee2: e7ff         	b	0x700abee4 <UART_checkOpenParams+0x34> @ imm = #-0x2
700abee4: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700abee8: 9000         	str	r0, [sp]
;     }
700abeea: e7ff         	b	0x700abeec <UART_checkOpenParams+0x3c> @ imm = #-0x2
;     return (status);
700abeec: 9800         	ldr	r0, [sp]
700abeee: b002         	add	sp, #0x8
700abef0: 4770         	bx	lr
		...
700abefe: 0000         	movs	r0, r0

700abf00 <UdmaUtils_getRingMemSize>:
; {
700abf00: b084         	sub	sp, #0x10
700abf02: f88d 000f    	strb.w	r0, [sp, #0xf]
700abf06: 9102         	str	r1, [sp, #0x8]
700abf08: f88d 2007    	strb.w	r2, [sp, #0x7]
;     ringMemSize = ((uint32_t) 1U << (elemSize + 2U));   /* Element size in bytes */
700abf0c: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700abf10: 1c81         	adds	r1, r0, #0x2
700abf12: 2001         	movs	r0, #0x1
700abf14: 4088         	lsls	r0, r1
700abf16: 9000         	str	r0, [sp]
;     ringMemSize *= elemCnt;
700abf18: 9902         	ldr	r1, [sp, #0x8]
700abf1a: 9800         	ldr	r0, [sp]
700abf1c: 4348         	muls	r0, r1, r0
700abf1e: 9000         	str	r0, [sp]
;     if((TISCI_MSG_VALUE_RM_RING_MODE_CREDENTIALS == mode) ||
700abf20: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700abf24: 2802         	cmp	r0, #0x2
700abf26: d005         	beq	0x700abf34 <UdmaUtils_getRingMemSize+0x34> @ imm = #0xa
700abf28: e7ff         	b	0x700abf2a <UdmaUtils_getRingMemSize+0x2a> @ imm = #-0x2
;        (TISCI_MSG_VALUE_RM_RING_MODE_QM == mode))
700abf2a: f89d 000f    	ldrb.w	r0, [sp, #0xf]
;     if((TISCI_MSG_VALUE_RM_RING_MODE_CREDENTIALS == mode) ||
700abf2e: 2803         	cmp	r0, #0x3
700abf30: d104         	bne	0x700abf3c <UdmaUtils_getRingMemSize+0x3c> @ imm = #0x8
700abf32: e7ff         	b	0x700abf34 <UdmaUtils_getRingMemSize+0x34> @ imm = #-0x2
;         ringMemSize <<= 1U;
700abf34: 9800         	ldr	r0, [sp]
700abf36: 0040         	lsls	r0, r0, #0x1
700abf38: 9000         	str	r0, [sp]
;     }
700abf3a: e7ff         	b	0x700abf3c <UdmaUtils_getRingMemSize+0x3c> @ imm = #-0x2
;     return (ringMemSize);
700abf3c: 9800         	ldr	r0, [sp]
700abf3e: b004         	add	sp, #0x10
700abf40: 4770         	bx	lr
		...
700abf4e: 0000         	movs	r0, r0

700abf50 <prvCopyDataFromQueue>:
; {
700abf50: b580         	push	{r7, lr}
700abf52: b082         	sub	sp, #0x8
700abf54: 9001         	str	r0, [sp, #0x4]
700abf56: 9100         	str	r1, [sp]
;     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
700abf58: 9801         	ldr	r0, [sp, #0x4]
700abf5a: 6c00         	ldr	r0, [r0, #0x40]
700abf5c: b1b8         	cbz	r0, 0x700abf8e <prvCopyDataFromQueue+0x3e> @ imm = #0x2e
700abf5e: e7ff         	b	0x700abf60 <prvCopyDataFromQueue+0x10> @ imm = #-0x2
;         pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
700abf60: 9901         	ldr	r1, [sp, #0x4]
700abf62: 68c8         	ldr	r0, [r1, #0xc]
700abf64: 6c0a         	ldr	r2, [r1, #0x40]
700abf66: 4410         	add	r0, r2
700abf68: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
700abf6a: 9801         	ldr	r0, [sp, #0x4]
700abf6c: 6881         	ldr	r1, [r0, #0x8]
700abf6e: 68c0         	ldr	r0, [r0, #0xc]
700abf70: 4288         	cmp	r0, r1
700abf72: d304         	blo	0x700abf7e <prvCopyDataFromQueue+0x2e> @ imm = #0x8
700abf74: e7ff         	b	0x700abf76 <prvCopyDataFromQueue+0x26> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
700abf76: 9901         	ldr	r1, [sp, #0x4]
700abf78: 6808         	ldr	r0, [r1]
700abf7a: 60c8         	str	r0, [r1, #0xc]
;         }
700abf7c: e000         	b	0x700abf80 <prvCopyDataFromQueue+0x30> @ imm = #0x0
700abf7e: e7ff         	b	0x700abf80 <prvCopyDataFromQueue+0x30> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
700abf80: 9800         	ldr	r0, [sp]
700abf82: 9a01         	ldr	r2, [sp, #0x4]
700abf84: 68d1         	ldr	r1, [r2, #0xc]
700abf86: 6c12         	ldr	r2, [r2, #0x40]
700abf88: f7ee ec26    	blx	0x7009a7d8 <__aeabi_memcpy8> @ imm = #-0x117b4
;     }
700abf8c: e7ff         	b	0x700abf8e <prvCopyDataFromQueue+0x3e> @ imm = #-0x2
; }
700abf8e: b002         	add	sp, #0x8
700abf90: bd80         	pop	{r7, pc}
		...
700abf9e: 0000         	movs	r0, r0

700abfa0 <CSL_lcdma_ringaccIsTeardownComplete>:
; {
700abfa0: b580         	push	{r7, lr}
700abfa2: b084         	sub	sp, #0x10
700abfa4: 9003         	str	r0, [sp, #0xc]
700abfa6: 9102         	str	r1, [sp, #0x8]
700abfa8: 2000         	movs	r0, #0x0
;     bool bRetVal = (bool)false;
700abfaa: f88d 0007    	strb.w	r0, [sp, #0x7]
;     if( CSL_REG32_FEXT( &pCfg->pRingRtRegs->RING[ringNum].ROCC, LCDMA_RINGACC_RINGRT_RING_ROCC_COMP ) != (uint32_t)0U )
700abfae: 9803         	ldr	r0, [sp, #0xc]
700abfb0: 6840         	ldr	r0, [r0, #0x4]
700abfb2: 9902         	ldr	r1, [sp, #0x8]
700abfb4: eb00 3041    	add.w	r0, r0, r1, lsl #13
700abfb8: f241 0118    	movw	r1, #0x1018
700abfbc: 4408         	add	r0, r1
700abfbe: f04f 4100    	mov.w	r1, #0x80000000
700abfc2: 221f         	movs	r2, #0x1f
700abfc4: f001 fadc    	bl	0x700ad580 <CSL_REG32_FEXT_RAW> @ imm = #0x15b8
700abfc8: b120         	cbz	r0, 0x700abfd4 <CSL_lcdma_ringaccIsTeardownComplete+0x34> @ imm = #0x8
700abfca: e7ff         	b	0x700abfcc <CSL_lcdma_ringaccIsTeardownComplete+0x2c> @ imm = #-0x2
700abfcc: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700abfce: f88d 0007    	strb.w	r0, [sp, #0x7]
;     }
700abfd2: e7ff         	b	0x700abfd4 <CSL_lcdma_ringaccIsTeardownComplete+0x34> @ imm = #-0x2
;     return bRetVal;
700abfd4: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700abfd8: f000 0001    	and	r0, r0, #0x1
700abfdc: b004         	add	sp, #0x10
700abfde: bd80         	pop	{r7, pc}

700abfe0 <Sciclient_rmIrqProgramOesRegister>:
; {
700abfe0: b580         	push	{r7, lr}
700abfe2: b088         	sub	sp, #0x20
700abfe4: 9007         	str	r0, [sp, #0x1c]
700abfe6: 2010         	movs	r0, #0x10
700abfe8: f2c8 0000    	movt	r0, #0x8000
;     req.valid_params = (TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID |
700abfec: 9002         	str	r0, [sp, #0x8]
;     req.secondary_host = cfg->host;
700abfee: 9807         	ldr	r0, [sp, #0x1c]
700abff0: 7900         	ldrb	r0, [r0, #0x4]
700abff2: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     req.src_id = cfg->s_id;
700abff6: 9807         	ldr	r0, [sp, #0x1c]
700abff8: 88c0         	ldrh	r0, [r0, #0x6]
700abffa: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     req.src_index = cfg->s_idx;
700abffe: 9807         	ldr	r0, [sp, #0x1c]
700ac000: 8900         	ldrh	r0, [r0, #0x8]
700ac002: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     req.global_event = cfg->global_evt;
700ac006: 9807         	ldr	r0, [sp, #0x1c]
700ac008: 89c0         	ldrh	r0, [r0, #0xe]
700ac00a: f8ad 0018    	strh.w	r0, [sp, #0x18]
;                                  cfg->set_resp,
700ac00e: 9807         	ldr	r0, [sp, #0x1c]
700ac010: 6981         	ldr	r1, [r0, #0x18]
700ac012: 4668         	mov	r0, sp
700ac014: f04f 32ff    	mov.w	r2, #0xffffffff
;     return Sciclient_rmIrqSetRaw(&req,
700ac018: f7fe fe22    	bl	0x700aac60 <Sciclient_rmIrqSetRaw> @ imm = #-0x13bc
700ac01c: b008         	add	sp, #0x20
700ac01e: bd80         	pop	{r7, pc}

700ac020 <Sciclient_rmPsGetIfIdx>:
; {
700ac020: b082         	sub	sp, #0x8
700ac022: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ac026: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700ac02a: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ac02c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac030: f241 0158    	movw	r1, #0x1058
700ac034: f2c7 0108    	movt	r1, #0x7008
700ac038: 8c89         	ldrh	r1, [r1, #0x24]
700ac03a: 4288         	cmp	r0, r1
700ac03c: da0d         	bge	0x700ac05a <Sciclient_rmPsGetIfIdx+0x3a> @ imm = #0x1a
700ac03e: e7ff         	b	0x700ac040 <Sciclient_rmPsGetIfIdx+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].if_idx;
700ac040: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac044: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ac048: f241 0058    	movw	r0, #0x1058
700ac04c: f2c7 0008    	movt	r0, #0x7008
700ac050: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ac054: 8880         	ldrh	r0, [r0, #0x4]
700ac056: 9000         	str	r0, [sp]
;     }
700ac058: e7ff         	b	0x700ac05a <Sciclient_rmPsGetIfIdx+0x3a> @ imm = #-0x2
;     return r;
700ac05a: 9800         	ldr	r0, [sp]
700ac05c: b002         	add	sp, #0x8
700ac05e: 4770         	bx	lr

700ac060 <Sciclient_rmPsGetInp>:
; {
700ac060: b082         	sub	sp, #0x8
700ac062: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ac066: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700ac06a: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ac06c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac070: f241 0158    	movw	r1, #0x1058
700ac074: f2c7 0108    	movt	r1, #0x7008
700ac078: 8c89         	ldrh	r1, [r1, #0x24]
700ac07a: 4288         	cmp	r0, r1
700ac07c: da0d         	bge	0x700ac09a <Sciclient_rmPsGetInp+0x3a> @ imm = #0x1a
700ac07e: e7ff         	b	0x700ac080 <Sciclient_rmPsGetInp+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].inp;
700ac080: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac084: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ac088: f241 0058    	movw	r0, #0x1058
700ac08c: f2c7 0008    	movt	r0, #0x7008
700ac090: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ac094: 88c0         	ldrh	r0, [r0, #0x6]
700ac096: 9000         	str	r0, [sp]
;     }
700ac098: e7ff         	b	0x700ac09a <Sciclient_rmPsGetInp+0x3a> @ imm = #-0x2
;     return r;
700ac09a: 9800         	ldr	r0, [sp]
700ac09c: b002         	add	sp, #0x8
700ac09e: 4770         	bx	lr

700ac0a0 <Sciclient_rmPsGetOutp>:
; {
700ac0a0: b082         	sub	sp, #0x8
700ac0a2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ac0a6: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700ac0aa: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ac0ac: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac0b0: f241 0158    	movw	r1, #0x1058
700ac0b4: f2c7 0108    	movt	r1, #0x7008
700ac0b8: 8c89         	ldrh	r1, [r1, #0x24]
700ac0ba: 4288         	cmp	r0, r1
700ac0bc: da0d         	bge	0x700ac0da <Sciclient_rmPsGetOutp+0x3a> @ imm = #0x1a
700ac0be: e7ff         	b	0x700ac0c0 <Sciclient_rmPsGetOutp+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].outp;
700ac0c0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac0c4: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ac0c8: f241 0058    	movw	r0, #0x1058
700ac0cc: f2c7 0008    	movt	r0, #0x7008
700ac0d0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ac0d4: 8900         	ldrh	r0, [r0, #0x8]
700ac0d6: 9000         	str	r0, [sp]
;     }
700ac0d8: e7ff         	b	0x700ac0da <Sciclient_rmPsGetOutp+0x3a> @ imm = #-0x2
;     return r;
700ac0da: 9800         	ldr	r0, [sp]
700ac0dc: b002         	add	sp, #0x8
700ac0de: 4770         	bx	lr

700ac0e0 <calculate_iteration_time>:
;    if (count_diff == 0)
700ac0e0: ee00 0a10    	vmov	s0, r0
700ac0e4: ed9f 1b0a    	vldr	d1, [pc, #40]           @ 0x700ac110 <calculate_iteration_time+0x30>
;    if (count_diff == 0)
700ac0e8: 2900         	cmp	r1, #0x0
700ac0ea: eeb8 0b40    	vcvt.f64.u32	d0, s0
700ac0ee: ee20 0b01    	vmul.f64	d0, d0, d1
700ac0f2: ee01 1a10    	vmov	s2, r1
700ac0f6: eeb8 1b41    	vcvt.f64.u32	d1, s2
700ac0fa: ee80 0b01    	vdiv.f64	d0, d0, d1
700ac0fe: ed9f 1b06    	vldr	d1, [pc, #24]           @ 0x700ac118 <calculate_iteration_time+0x38>
700ac102: bf08         	it	eq
700ac104: eeb0 0b41    	vmoveq.f64	d0, d1
; }
700ac108: 4770         	bx	lr
700ac10a: bf00         	nop
700ac10c: bf00         	nop
700ac10e: bf00         	nop
700ac110: 00 00 00 00  	.word	0x00000000
700ac114: 80 84 2e 41  	.word	0x412e8480
700ac118: 00 00 00 00  	.word	0x00000000
700ac11c: 00 00 00 00  	.word	0x00000000

700ac120 <free_list_insert>:
700ac120: e5902000     	ldr	r2, [r0]
700ac124: e59f1030     	ldr	r1, [pc, #0x30]         @ 0x700ac15c <free_list_insert+0x3c>
700ac128: e3c2c001     	bic	r12, r2, #1
700ac12c: e5913000     	ldr	r3, [r1]
700ac130: e3530000     	cmp	r3, #0
700ac134: 0a000005     	beq	0x700ac150 <free_list_insert+0x30> @ imm = #0x14
700ac138: e5932000     	ldr	r2, [r3]
700ac13c: e3c22001     	bic	r2, r2, #1
700ac140: e152000c     	cmp	r2, r12
700ac144: 2a000001     	bhs	0x700ac150 <free_list_insert+0x30> @ imm = #0x4
700ac148: e2831008     	add	r1, r3, #8
700ac14c: eafffff6     	b	0x700ac12c <free_list_insert+0xc> @ imm = #-0x28
700ac150: e5803008     	str	r3, [r0, #0x8]
700ac154: e5810000     	str	r0, [r1]
700ac158: e12fff1e     	bx	lr
700ac15c: bc 4d 08 70  	.word	0x70084dbc

700ac160 <prvGetNextExpireTime>:
;     {
700ac160: b082         	sub	sp, #0x8
700ac162: 9001         	str	r0, [sp, #0x4]
;         *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
700ac164: f644 50ac    	movw	r0, #0x4dac
700ac168: f2c7 0008    	movt	r0, #0x7008
700ac16c: 6800         	ldr	r0, [r0]
700ac16e: 6800         	ldr	r0, [r0]
700ac170: fab0 f080    	clz	r0, r0
700ac174: 0940         	lsrs	r0, r0, #0x5
700ac176: 9901         	ldr	r1, [sp, #0x4]
700ac178: 6008         	str	r0, [r1]
;         if( *pxListWasEmpty == pdFALSE )
700ac17a: 9801         	ldr	r0, [sp, #0x4]
700ac17c: 6800         	ldr	r0, [r0]
700ac17e: b948         	cbnz	r0, 0x700ac194 <prvGetNextExpireTime+0x34> @ imm = #0x12
700ac180: e7ff         	b	0x700ac182 <prvGetNextExpireTime+0x22> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
700ac182: f644 50ac    	movw	r0, #0x4dac
700ac186: f2c7 0008    	movt	r0, #0x7008
700ac18a: 6800         	ldr	r0, [r0]
700ac18c: 68c0         	ldr	r0, [r0, #0xc]
700ac18e: 6800         	ldr	r0, [r0]
700ac190: 9000         	str	r0, [sp]
;         }
700ac192: e002         	b	0x700ac19a <prvGetNextExpireTime+0x3a> @ imm = #0x4
700ac194: 2000         	movs	r0, #0x0
;             xNextExpireTime = ( TickType_t ) 0U;
700ac196: 9000         	str	r0, [sp]
700ac198: e7ff         	b	0x700ac19a <prvGetNextExpireTime+0x3a> @ imm = #-0x2
;         return xNextExpireTime;
700ac19a: 9800         	ldr	r0, [sp]
700ac19c: b002         	add	sp, #0x8
700ac19e: 4770         	bx	lr

700ac1a0 <Sciclient_secProxyWaitThread>:
; {
700ac1a0: b580         	push	{r7, lr}
700ac1a2: b084         	sub	sp, #0x10
700ac1a4: 9003         	str	r0, [sp, #0xc]
700ac1a6: 9102         	str	r1, [sp, #0x8]
700ac1a8: f06f 0003    	mvn	r0, #0x3
;     int32_t  status     = CSL_ETIMEOUT;
700ac1ac: 9001         	str	r0, [sp, #0x4]
;     uint32_t timeToWait = timeout;
700ac1ae: 9802         	ldr	r0, [sp, #0x8]
700ac1b0: 9000         	str	r0, [sp]
;     while (timeToWait > 0U)
700ac1b2: e7ff         	b	0x700ac1b4 <Sciclient_secProxyWaitThread+0x14> @ imm = #-0x2
700ac1b4: 9800         	ldr	r0, [sp]
700ac1b6: b178         	cbz	r0, 0x700ac1d8 <Sciclient_secProxyWaitThread+0x38> @ imm = #0x1e
700ac1b8: e7ff         	b	0x700ac1ba <Sciclient_secProxyWaitThread+0x1a> @ imm = #-0x2
;         if ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ac1ba: 9803         	ldr	r0, [sp, #0xc]
700ac1bc: f001 fcc8    	bl	0x700adb50 <Sciclient_secProxyThreadStatusReg> @ imm = #0x1990
700ac1c0: f001 ff6e    	bl	0x700ae0a0 <CSL_REG32_RD_RAW> @ imm = #0x1edc
700ac1c4: 0600         	lsls	r0, r0, #0x18
700ac1c6: b118         	cbz	r0, 0x700ac1d0 <Sciclient_secProxyWaitThread+0x30> @ imm = #0x6
700ac1c8: e7ff         	b	0x700ac1ca <Sciclient_secProxyWaitThread+0x2a> @ imm = #-0x2
700ac1ca: 2000         	movs	r0, #0x0
;             status = SystemP_SUCCESS;
700ac1cc: 9001         	str	r0, [sp, #0x4]
;             break;
700ac1ce: e003         	b	0x700ac1d8 <Sciclient_secProxyWaitThread+0x38> @ imm = #0x6
;         timeToWait--;
700ac1d0: 9800         	ldr	r0, [sp]
700ac1d2: 3801         	subs	r0, #0x1
700ac1d4: 9000         	str	r0, [sp]
;     while (timeToWait > 0U)
700ac1d6: e7ed         	b	0x700ac1b4 <Sciclient_secProxyWaitThread+0x14> @ imm = #-0x26
;     return status;
700ac1d8: 9801         	ldr	r0, [sp, #0x4]
700ac1da: b004         	add	sp, #0x10
700ac1dc: bd80         	pop	{r7, pc}
700ac1de: 0000         	movs	r0, r0

700ac1e0 <UART_IsHWFlowCtrlValid>:
; {
700ac1e0: b082         	sub	sp, #0x8
700ac1e2: 9001         	str	r0, [sp, #0x4]
700ac1e4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ac1e8: 9000         	str	r0, [sp]
;     if(((hwFlowControlThr == UART_RXTRIGLVL_1)  ||
700ac1ea: 9801         	ldr	r0, [sp, #0x4]
700ac1ec: 2801         	cmp	r0, #0x1
700ac1ee: d010         	beq	0x700ac212 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x20
700ac1f0: e7ff         	b	0x700ac1f2 <UART_IsHWFlowCtrlValid+0x12> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_8)  ||
700ac1f2: 9801         	ldr	r0, [sp, #0x4]
700ac1f4: 2808         	cmp	r0, #0x8
700ac1f6: d00c         	beq	0x700ac212 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x18
700ac1f8: e7ff         	b	0x700ac1fa <UART_IsHWFlowCtrlValid+0x1a> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_16) ||
700ac1fa: 9801         	ldr	r0, [sp, #0x4]
700ac1fc: 2810         	cmp	r0, #0x10
700ac1fe: d008         	beq	0x700ac212 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x10
700ac200: e7ff         	b	0x700ac202 <UART_IsHWFlowCtrlValid+0x22> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_56) ||
700ac202: 9801         	ldr	r0, [sp, #0x4]
700ac204: 2838         	cmp	r0, #0x38
700ac206: d004         	beq	0x700ac212 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x8
700ac208: e7ff         	b	0x700ac20a <UART_IsHWFlowCtrlValid+0x2a> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_60)))
700ac20a: 9801         	ldr	r0, [sp, #0x4]
;     if(((hwFlowControlThr == UART_RXTRIGLVL_1)  ||
700ac20c: 283c         	cmp	r0, #0x3c
700ac20e: d103         	bne	0x700ac218 <UART_IsHWFlowCtrlValid+0x38> @ imm = #0x6
700ac210: e7ff         	b	0x700ac212 <UART_IsHWFlowCtrlValid+0x32> @ imm = #-0x2
700ac212: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ac214: 9000         	str	r0, [sp]
;     }
700ac216: e7ff         	b	0x700ac218 <UART_IsHWFlowCtrlValid+0x38> @ imm = #-0x2
;     return status;
700ac218: 9800         	ldr	r0, [sp]
700ac21a: b002         	add	sp, #0x8
700ac21c: 4770         	bx	lr
700ac21e: 0000         	movs	r0, r0

700ac220 <UART_IsRxTrigLvlValid>:
; {
700ac220: b082         	sub	sp, #0x8
700ac222: 9001         	str	r0, [sp, #0x4]
700ac224: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ac228: 9000         	str	r0, [sp]
;     if(((rxTrigLvl == UART_RXTRIGLVL_1)  ||
700ac22a: 9801         	ldr	r0, [sp, #0x4]
700ac22c: 2801         	cmp	r0, #0x1
700ac22e: d010         	beq	0x700ac252 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x20
700ac230: e7ff         	b	0x700ac232 <UART_IsRxTrigLvlValid+0x12> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_8)  ||
700ac232: 9801         	ldr	r0, [sp, #0x4]
700ac234: 2808         	cmp	r0, #0x8
700ac236: d00c         	beq	0x700ac252 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x18
700ac238: e7ff         	b	0x700ac23a <UART_IsRxTrigLvlValid+0x1a> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_16) ||
700ac23a: 9801         	ldr	r0, [sp, #0x4]
700ac23c: 2810         	cmp	r0, #0x10
700ac23e: d008         	beq	0x700ac252 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x10
700ac240: e7ff         	b	0x700ac242 <UART_IsRxTrigLvlValid+0x22> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_56) ||
700ac242: 9801         	ldr	r0, [sp, #0x4]
700ac244: 2838         	cmp	r0, #0x38
700ac246: d004         	beq	0x700ac252 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x8
700ac248: e7ff         	b	0x700ac24a <UART_IsRxTrigLvlValid+0x2a> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_60)))
700ac24a: 9801         	ldr	r0, [sp, #0x4]
;     if(((rxTrigLvl == UART_RXTRIGLVL_1)  ||
700ac24c: 283c         	cmp	r0, #0x3c
700ac24e: d103         	bne	0x700ac258 <UART_IsRxTrigLvlValid+0x38> @ imm = #0x6
700ac250: e7ff         	b	0x700ac252 <UART_IsRxTrigLvlValid+0x32> @ imm = #-0x2
700ac252: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ac254: 9000         	str	r0, [sp]
;     }
700ac256: e7ff         	b	0x700ac258 <UART_IsRxTrigLvlValid+0x38> @ imm = #-0x2
;     return status;
700ac258: 9800         	ldr	r0, [sp]
700ac25a: b002         	add	sp, #0x8
700ac25c: 4770         	bx	lr
700ac25e: 0000         	movs	r0, r0

700ac260 <UART_IsTxTrigLvlValid>:
; {
700ac260: b082         	sub	sp, #0x8
700ac262: 9001         	str	r0, [sp, #0x4]
700ac264: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ac268: 9000         	str	r0, [sp]
;     if(((txTrigLvl == UART_TXTRIGLVL_1)  ||
700ac26a: 9801         	ldr	r0, [sp, #0x4]
700ac26c: 2801         	cmp	r0, #0x1
700ac26e: d010         	beq	0x700ac292 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x20
700ac270: e7ff         	b	0x700ac272 <UART_IsTxTrigLvlValid+0x12> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_8)  ||
700ac272: 9801         	ldr	r0, [sp, #0x4]
700ac274: 2808         	cmp	r0, #0x8
700ac276: d00c         	beq	0x700ac292 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x18
700ac278: e7ff         	b	0x700ac27a <UART_IsTxTrigLvlValid+0x1a> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_16) ||
700ac27a: 9801         	ldr	r0, [sp, #0x4]
700ac27c: 2810         	cmp	r0, #0x10
700ac27e: d008         	beq	0x700ac292 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x10
700ac280: e7ff         	b	0x700ac282 <UART_IsTxTrigLvlValid+0x22> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_32) ||
700ac282: 9801         	ldr	r0, [sp, #0x4]
700ac284: 2820         	cmp	r0, #0x20
700ac286: d004         	beq	0x700ac292 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x8
700ac288: e7ff         	b	0x700ac28a <UART_IsTxTrigLvlValid+0x2a> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_56)))
700ac28a: 9801         	ldr	r0, [sp, #0x4]
;     if(((txTrigLvl == UART_TXTRIGLVL_1)  ||
700ac28c: 2838         	cmp	r0, #0x38
700ac28e: d103         	bne	0x700ac298 <UART_IsTxTrigLvlValid+0x38> @ imm = #0x6
700ac290: e7ff         	b	0x700ac292 <UART_IsTxTrigLvlValid+0x32> @ imm = #-0x2
700ac292: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ac294: 9000         	str	r0, [sp]
;     }
700ac296: e7ff         	b	0x700ac298 <UART_IsTxTrigLvlValid+0x38> @ imm = #-0x2
;     return status;
700ac298: 9800         	ldr	r0, [sp]
700ac29a: b002         	add	sp, #0x8
700ac29c: 4770         	bx	lr
700ac29e: 0000         	movs	r0, r0

700ac2a0 <UART_i2310WA>:
; {
700ac2a0: b580         	push	{r7, lr}
700ac2a2: b084         	sub	sp, #0x10
700ac2a4: 9003         	str	r0, [sp, #0xc]
;     HW_WR_REG32(baseAddr + UART_TIMEOUTL, 0xFF);
700ac2a6: 9803         	ldr	r0, [sp, #0xc]
700ac2a8: 3098         	adds	r0, #0x98
700ac2aa: 21ff         	movs	r1, #0xff
700ac2ac: 9101         	str	r1, [sp, #0x4]
700ac2ae: f001 fe9f    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x1d3e
700ac2b2: 9901         	ldr	r1, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_TIMEOUTH, 0xFF);
700ac2b4: 9803         	ldr	r0, [sp, #0xc]
700ac2b6: 309c         	adds	r0, #0x9c
700ac2b8: f001 fe9a    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x1d34
;     HW_WR_FIELD32(baseAddr + UART_EFR2, UART_EFR2_TIMEOUT_BEHAVE, 1);
700ac2bc: 9803         	ldr	r0, [sp, #0xc]
700ac2be: 308c         	adds	r0, #0x8c
700ac2c0: 2206         	movs	r2, #0x6
700ac2c2: 9202         	str	r2, [sp, #0x8]
700ac2c4: 2301         	movs	r3, #0x1
700ac2c6: 4611         	mov	r1, r2
700ac2c8: f000 fc02    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x804
700ac2cc: 9a02         	ldr	r2, [sp, #0x8]
;     HW_WR_FIELD32(baseAddr + UART_EFR2, UART_EFR2_TIMEOUT_BEHAVE, 0);
700ac2ce: 9803         	ldr	r0, [sp, #0xc]
700ac2d0: 308c         	adds	r0, #0x8c
700ac2d2: 2300         	movs	r3, #0x0
700ac2d4: 4611         	mov	r1, r2
700ac2d6: f000 fbfb    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x7f6
; }
700ac2da: b004         	add	sp, #0x10
700ac2dc: bd80         	pop	{r7, pc}
700ac2de: 0000         	movs	r0, r0

700ac2e0 <UART_spaceAvail>:
; {
700ac2e0: b580         	push	{r7, lr}
700ac2e2: b084         	sub	sp, #0x10
700ac2e4: 9003         	str	r0, [sp, #0xc]
700ac2e6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700ac2e8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700ac2ea: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700ac2ec: 9803         	ldr	r0, [sp, #0xc]
700ac2ee: 217f         	movs	r1, #0x7f
700ac2f0: f7fe fc56    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #-0x1754
700ac2f4: 9002         	str	r0, [sp, #0x8]
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700ac2f6: 9803         	ldr	r0, [sp, #0xc]
700ac2f8: 3014         	adds	r0, #0x14
700ac2fa: f001 fe71    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x1ce2
700ac2fe: f000 0060    	and	r0, r0, #0x60
;     if ((UART_LSR_TX_SR_E_MASK | UART_LSR_TX_FIFO_E_MASK) ==
700ac302: 2860         	cmp	r0, #0x60
700ac304: d103         	bne	0x700ac30e <UART_spaceAvail+0x2e> @ imm = #0x6
700ac306: e7ff         	b	0x700ac308 <UART_spaceAvail+0x28> @ imm = #-0x2
700ac308: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700ac30a: 9001         	str	r0, [sp, #0x4]
;     }
700ac30c: e7ff         	b	0x700ac30e <UART_spaceAvail+0x2e> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ac30e: 9803         	ldr	r0, [sp, #0xc]
700ac310: 300c         	adds	r0, #0xc
700ac312: 9902         	ldr	r1, [sp, #0x8]
700ac314: f001 fe6c    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x1cd8
;     return retVal;
700ac318: 9801         	ldr	r0, [sp, #0x4]
700ac31a: b004         	add	sp, #0x10
700ac31c: bd80         	pop	{r7, pc}
700ac31e: 0000         	movs	r0, r0

700ac320 <CSL_bcdmaSetChanPeerReg>:
; {
700ac320: b580         	push	{r7, lr}
700ac322: b088         	sub	sp, #0x20
700ac324: f8dd c028    	ldr.w	r12, [sp, #0x28]
700ac328: 9007         	str	r0, [sp, #0x1c]
700ac32a: 9106         	str	r1, [sp, #0x18]
700ac32c: 9205         	str	r2, [sp, #0x14]
700ac32e: 9304         	str	r3, [sp, #0x10]
;     remotePeerOpts.regIdx = regIdx;
700ac330: 9804         	ldr	r0, [sp, #0x10]
700ac332: 9001         	str	r0, [sp, #0x4]
;     remotePeerOpts.regVal = *pVal;
700ac334: 980a         	ldr	r0, [sp, #0x28]
700ac336: 6800         	ldr	r0, [r0]
700ac338: 9002         	str	r0, [sp, #0x8]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_REMOTE_PEER_REG, chanIdx, (void *)&remotePeerOpts );
700ac33a: 9807         	ldr	r0, [sp, #0x1c]
700ac33c: 9a06         	ldr	r2, [sp, #0x18]
700ac33e: 210c         	movs	r1, #0xc
700ac340: ab01         	add	r3, sp, #0x4
700ac342: f7fd f82d    	bl	0x700a93a0 <CSL_bcdmaDoChanOp> @ imm = #-0x2fa6
700ac346: 9003         	str	r0, [sp, #0xc]
;     if( retVal != CSL_PASS )
700ac348: 9803         	ldr	r0, [sp, #0xc]
700ac34a: b120         	cbz	r0, 0x700ac356 <CSL_bcdmaSetChanPeerReg+0x36> @ imm = #0x8
700ac34c: e7ff         	b	0x700ac34e <CSL_bcdmaSetChanPeerReg+0x2e> @ imm = #-0x2
700ac34e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ac352: 9003         	str	r0, [sp, #0xc]
;     }
700ac354: e7ff         	b	0x700ac356 <CSL_bcdmaSetChanPeerReg+0x36> @ imm = #-0x2
;     return retVal;
700ac356: 9803         	ldr	r0, [sp, #0xc]
700ac358: b008         	add	sp, #0x20
700ac35a: bd80         	pop	{r7, pc}
700ac35c: 0000         	movs	r0, r0
700ac35e: 0000         	movs	r0, r0

700ac360 <CSL_intaggrIsValidStatusBitNum>:
; {
700ac360: b084         	sub	sp, #0x10
700ac362: 9003         	str	r0, [sp, #0xc]
700ac364: 9102         	str	r1, [sp, #0x8]
;     uint32_t localStatusBitNum = statusBitNum;
700ac366: 9802         	ldr	r0, [sp, #0x8]
700ac368: 9000         	str	r0, [sp]
;     localStatusBitNum &= ~CSL_INTAGGR_INTR_MODE_FLAG;   /* Remove intr mode flag */
700ac36a: 9800         	ldr	r0, [sp]
700ac36c: f020 4000    	bic	r0, r0, #0x80000000
700ac370: 9000         	str	r0, [sp]
;     if( localStatusBitNum < (pCfg->virtIntrCnt << 6U) )
700ac372: 9800         	ldr	r0, [sp]
700ac374: 9903         	ldr	r1, [sp, #0xc]
700ac376: 6a49         	ldr	r1, [r1, #0x24]
700ac378: ebb0 1f81    	cmp.w	r0, r1, lsl #6
700ac37c: d204         	bhs	0x700ac388 <CSL_intaggrIsValidStatusBitNum+0x28> @ imm = #0x8
700ac37e: e7ff         	b	0x700ac380 <CSL_intaggrIsValidStatusBitNum+0x20> @ imm = #-0x2
700ac380: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700ac382: f88d 0007    	strb.w	r0, [sp, #0x7]
;     }
700ac386: e003         	b	0x700ac390 <CSL_intaggrIsValidStatusBitNum+0x30> @ imm = #0x6
700ac388: 2000         	movs	r0, #0x0
;         bRetVal = (bool)false;
700ac38a: f88d 0007    	strb.w	r0, [sp, #0x7]
700ac38e: e7ff         	b	0x700ac390 <CSL_intaggrIsValidStatusBitNum+0x30> @ imm = #-0x2
;     return bRetVal;
700ac390: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ac394: f000 0001    	and	r0, r0, #0x1
700ac398: b004         	add	sp, #0x10
700ac39a: 4770         	bx	lr
700ac39c: 0000         	movs	r0, r0
700ac39e: 0000         	movs	r0, r0

700ac3a0 <CSL_pktdmaSetRxRT>:
; {
700ac3a0: b580         	push	{r7, lr}
700ac3a2: b084         	sub	sp, #0x10
700ac3a4: 9003         	str	r0, [sp, #0xc]
700ac3a6: 9102         	str	r1, [sp, #0x8]
700ac3a8: 9201         	str	r2, [sp, #0x4]
;     CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL,
700ac3aa: 9803         	ldr	r0, [sp, #0xc]
700ac3ac: 6940         	ldr	r0, [r0, #0x14]
700ac3ae: 9902         	ldr	r1, [sp, #0x8]
700ac3b0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ac3b4: 9901         	ldr	r1, [sp, #0x4]
700ac3b6: 680b         	ldr	r3, [r1]
700ac3b8: f8d1 c004    	ldr.w	r12, [r1, #0x4]
700ac3bc: 688a         	ldr	r2, [r1, #0x8]
700ac3be: f04f 4180    	mov.w	r1, #0x40000000
700ac3c2: ea01 718c    	and.w	r1, r1, r12, lsl #30
700ac3c6: ea41 71c3    	orr.w	r1, r1, r3, lsl #31
700ac3ca: f002 0201    	and	r2, r2, #0x1
700ac3ce: ea41 7142    	orr.w	r1, r1, r2, lsl #29
700ac3d2: f001 fdb5    	bl	0x700adf40 <CSL_REG32_WR_RAW> @ imm = #0x1b6a
700ac3d6: 2000         	movs	r0, #0x0
;     return CSL_PASS;
700ac3d8: b004         	add	sp, #0x10
700ac3da: bd80         	pop	{r7, pc}
700ac3dc: 0000         	movs	r0, r0
700ac3de: 0000         	movs	r0, r0

700ac3e0 <CSL_pktdmaSetTxRT>:
; {
700ac3e0: b580         	push	{r7, lr}
700ac3e2: b084         	sub	sp, #0x10
700ac3e4: 9003         	str	r0, [sp, #0xc]
700ac3e6: 9102         	str	r1, [sp, #0x8]
700ac3e8: 9201         	str	r2, [sp, #0x4]
;     CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL,
700ac3ea: 9803         	ldr	r0, [sp, #0xc]
700ac3ec: 6900         	ldr	r0, [r0, #0x10]
700ac3ee: 9902         	ldr	r1, [sp, #0x8]
700ac3f0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ac3f4: 9901         	ldr	r1, [sp, #0x4]
700ac3f6: 680b         	ldr	r3, [r1]
700ac3f8: f8d1 c004    	ldr.w	r12, [r1, #0x4]
700ac3fc: 688a         	ldr	r2, [r1, #0x8]
700ac3fe: f04f 4180    	mov.w	r1, #0x40000000
700ac402: ea01 718c    	and.w	r1, r1, r12, lsl #30
700ac406: ea41 71c3    	orr.w	r1, r1, r3, lsl #31
700ac40a: f002 0201    	and	r2, r2, #0x1
700ac40e: ea41 7142    	orr.w	r1, r1, r2, lsl #29
700ac412: f001 fd95    	bl	0x700adf40 <CSL_REG32_WR_RAW> @ imm = #0x1b2a
700ac416: 2000         	movs	r0, #0x0
;     return CSL_PASS;
700ac418: b004         	add	sp, #0x10
700ac41a: bd80         	pop	{r7, pc}
700ac41c: 0000         	movs	r0, r0
700ac41e: 0000         	movs	r0, r0

700ac420 <Sciclient_rmIrqClearOesRegister>:
; {
700ac420: b580         	push	{r7, lr}
700ac422: b088         	sub	sp, #0x20
700ac424: 9007         	str	r0, [sp, #0x1c]
700ac426: 2010         	movs	r0, #0x10
700ac428: f2c8 0000    	movt	r0, #0x8000
;     req.valid_params = (TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID |
700ac42c: 9002         	str	r0, [sp, #0x8]
;     req.secondary_host = cfg->host;
700ac42e: 9807         	ldr	r0, [sp, #0x1c]
700ac430: 7900         	ldrb	r0, [r0, #0x4]
700ac432: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     req.src_id = cfg->s_id;
700ac436: 9807         	ldr	r0, [sp, #0x1c]
700ac438: 88c0         	ldrh	r0, [r0, #0x6]
700ac43a: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     req.src_index = cfg->s_idx;
700ac43e: 9807         	ldr	r0, [sp, #0x1c]
700ac440: 8900         	ldrh	r0, [r0, #0x8]
700ac442: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     req.global_event = cfg->global_evt;
700ac446: 9807         	ldr	r0, [sp, #0x1c]
700ac448: 89c0         	ldrh	r0, [r0, #0xe]
700ac44a: f8ad 0018    	strh.w	r0, [sp, #0x18]
700ac44e: 4668         	mov	r0, sp
700ac450: f04f 31ff    	mov.w	r1, #0xffffffff
;     return Sciclient_rmIrqReleaseRaw(&req,
700ac454: f7fe fdac    	bl	0x700aafb0 <Sciclient_rmIrqReleaseRaw> @ imm = #-0x14a8
700ac458: b008         	add	sp, #0x20
700ac45a: bd80         	pop	{r7, pc}
700ac45c: 0000         	movs	r0, r0
700ac45e: 0000         	movs	r0, r0

700ac460 <UART_IsParityTypeValid>:
; {
700ac460: b082         	sub	sp, #0x8
700ac462: 9001         	str	r0, [sp, #0x4]
700ac464: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ac468: 9000         	str	r0, [sp]
;     if(((parityType == UART_PARITY_NONE)    ||
700ac46a: 9801         	ldr	r0, [sp, #0x4]
700ac46c: b180         	cbz	r0, 0x700ac490 <UART_IsParityTypeValid+0x30> @ imm = #0x20
700ac46e: e7ff         	b	0x700ac470 <UART_IsParityTypeValid+0x10> @ imm = #-0x2
;         (parityType == UART_PARITY_ODD)     ||
700ac470: 9801         	ldr	r0, [sp, #0x4]
700ac472: 2801         	cmp	r0, #0x1
700ac474: d00c         	beq	0x700ac490 <UART_IsParityTypeValid+0x30> @ imm = #0x18
700ac476: e7ff         	b	0x700ac478 <UART_IsParityTypeValid+0x18> @ imm = #-0x2
;         (parityType == UART_PARITY_EVEN)    ||
700ac478: 9801         	ldr	r0, [sp, #0x4]
700ac47a: 2803         	cmp	r0, #0x3
700ac47c: d008         	beq	0x700ac490 <UART_IsParityTypeValid+0x30> @ imm = #0x10
700ac47e: e7ff         	b	0x700ac480 <UART_IsParityTypeValid+0x20> @ imm = #-0x2
;         (parityType == UART_PARITY_FORCED0) ||
700ac480: 9801         	ldr	r0, [sp, #0x4]
700ac482: 2807         	cmp	r0, #0x7
700ac484: d004         	beq	0x700ac490 <UART_IsParityTypeValid+0x30> @ imm = #0x8
700ac486: e7ff         	b	0x700ac488 <UART_IsParityTypeValid+0x28> @ imm = #-0x2
;         (parityType == UART_PARITY_FORCED1)))
700ac488: 9801         	ldr	r0, [sp, #0x4]
;     if(((parityType == UART_PARITY_NONE)    ||
700ac48a: 2805         	cmp	r0, #0x5
700ac48c: d103         	bne	0x700ac496 <UART_IsParityTypeValid+0x36> @ imm = #0x6
700ac48e: e7ff         	b	0x700ac490 <UART_IsParityTypeValid+0x30> @ imm = #-0x2
700ac490: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ac492: 9000         	str	r0, [sp]
;     }
700ac494: e7ff         	b	0x700ac496 <UART_IsParityTypeValid+0x36> @ imm = #-0x2
;     return status;
700ac496: 9800         	ldr	r0, [sp]
700ac498: b002         	add	sp, #0x8
700ac49a: 4770         	bx	lr
700ac49c: 0000         	movs	r0, r0
700ac49e: 0000         	movs	r0, r0

700ac4a0 <UART_IsTxRxFifoEmpty>:
; {
700ac4a0: b580         	push	{r7, lr}
700ac4a2: b084         	sub	sp, #0x10
700ac4a4: 9003         	str	r0, [sp, #0xc]
700ac4a6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700ac4a8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700ac4aa: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700ac4ac: 9803         	ldr	r0, [sp, #0xc]
700ac4ae: 217f         	movs	r1, #0x7f
700ac4b0: f7fe fb76    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #-0x1914
700ac4b4: 9002         	str	r0, [sp, #0x8]
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700ac4b6: 9803         	ldr	r0, [sp, #0xc]
700ac4b8: 3014         	adds	r0, #0x14
700ac4ba: f001 fd91    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x1b22
;     if (((UART_LSR_TX_FIFO_E_TX_FIFO_E_VALUE_1 << UART_LSR_TX_FIFO_E_SHIFT) |
700ac4be: 0680         	lsls	r0, r0, #0x1a
700ac4c0: 2800         	cmp	r0, #0x0
700ac4c2: d503         	bpl	0x700ac4cc <UART_IsTxRxFifoEmpty+0x2c> @ imm = #0x6
700ac4c4: e7ff         	b	0x700ac4c6 <UART_IsTxRxFifoEmpty+0x26> @ imm = #-0x2
700ac4c6: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700ac4c8: 9001         	str	r0, [sp, #0x4]
;     }
700ac4ca: e7ff         	b	0x700ac4cc <UART_IsTxRxFifoEmpty+0x2c> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ac4cc: 9803         	ldr	r0, [sp, #0xc]
700ac4ce: 300c         	adds	r0, #0xc
700ac4d0: 9902         	ldr	r1, [sp, #0x8]
700ac4d2: f001 fd8d    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x1b1a
;     return retVal;
700ac4d6: 9801         	ldr	r0, [sp, #0x4]
700ac4d8: b004         	add	sp, #0x10
700ac4da: bd80         	pop	{r7, pc}
700ac4dc: 0000         	movs	r0, r0
700ac4de: 0000         	movs	r0, r0

700ac4e0 <UART_enhanFuncEnable>:
; {
700ac4e0: b580         	push	{r7, lr}
700ac4e2: b084         	sub	sp, #0x10
700ac4e4: 9003         	str	r0, [sp, #0xc]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ac4e6: 9803         	ldr	r0, [sp, #0xc]
700ac4e8: 21bf         	movs	r1, #0xbf
700ac4ea: f7fe fb59    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #-0x194e
700ac4ee: 9001         	str	r0, [sp, #0x4]
;     enhanFnBitVal = HW_RD_REG32(baseAddr + UART_EFR) & UART_EFR_ENHANCED_EN_MASK;
700ac4f0: 9803         	ldr	r0, [sp, #0xc]
700ac4f2: 3008         	adds	r0, #0x8
700ac4f4: f001 fd74    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x1ae8
700ac4f8: f000 0010    	and	r0, r0, #0x10
700ac4fc: 9002         	str	r0, [sp, #0x8]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700ac4fe: 9803         	ldr	r0, [sp, #0xc]
700ac500: 3008         	adds	r0, #0x8
700ac502: 2110         	movs	r1, #0x10
700ac504: 2204         	movs	r2, #0x4
700ac506: 2301         	movs	r3, #0x1
700ac508: f000 fae2    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #0x5c4
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ac50c: 9803         	ldr	r0, [sp, #0xc]
700ac50e: 300c         	adds	r0, #0xc
700ac510: 9901         	ldr	r1, [sp, #0x4]
700ac512: f001 fd6d    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x1ada
;     return enhanFnBitVal;
700ac516: 9802         	ldr	r0, [sp, #0x8]
700ac518: b004         	add	sp, #0x10
700ac51a: bd80         	pop	{r7, pc}
700ac51c: 0000         	movs	r0, r0
700ac51e: 0000         	movs	r0, r0

700ac520 <UART_lld_dmaDeInit>:
; {
700ac520: b580         	push	{r7, lr}
700ac522: b084         	sub	sp, #0x10
700ac524: 9003         	str	r0, [sp, #0xc]
700ac526: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700ac528: 9002         	str	r0, [sp, #0x8]
;     udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700ac52a: 9803         	ldr	r0, [sp, #0xc]
700ac52c: 6840         	ldr	r0, [r0, #0x4]
700ac52e: 6cc0         	ldr	r0, [r0, #0x4c]
700ac530: 9001         	str	r0, [sp, #0x4]
;     if (udmaChCfg->isOpen != FALSE)
700ac532: 9801         	ldr	r0, [sp, #0x4]
700ac534: 6b80         	ldr	r0, [r0, #0x38]
700ac536: b170         	cbz	r0, 0x700ac556 <UART_lld_dmaDeInit+0x36> @ imm = #0x1c
700ac538: e7ff         	b	0x700ac53a <UART_lld_dmaDeInit+0x1a> @ imm = #-0x2
;         (void)UART_udmaDeInitCh(udmaChCfg->rxChHandle,
700ac53a: 9901         	ldr	r1, [sp, #0x4]
700ac53c: 6888         	ldr	r0, [r1, #0x8]
;                           udmaChCfg->cqRxEvtHandle);
700ac53e: 6909         	ldr	r1, [r1, #0x10]
;         (void)UART_udmaDeInitCh(udmaChCfg->rxChHandle,
700ac540: f7f8 fc0e    	bl	0x700a4d60 <UART_udmaDeInitCh> @ imm = #-0x77e4
;         (void)UART_udmaDeInitCh(udmaChCfg->txChHandle,
700ac544: 9901         	ldr	r1, [sp, #0x4]
700ac546: 6848         	ldr	r0, [r1, #0x4]
;                           udmaChCfg->cqTxEvtHandle);
700ac548: 68c9         	ldr	r1, [r1, #0xc]
;         (void)UART_udmaDeInitCh(udmaChCfg->txChHandle,
700ac54a: f7f8 fc09    	bl	0x700a4d60 <UART_udmaDeInitCh> @ imm = #-0x77ee
;         udmaChCfg->isOpen = FALSE;
700ac54e: 9901         	ldr	r1, [sp, #0x4]
700ac550: 2000         	movs	r0, #0x0
700ac552: 6388         	str	r0, [r1, #0x38]
;     }
700ac554: e7ff         	b	0x700ac556 <UART_lld_dmaDeInit+0x36> @ imm = #-0x2
;     return status;
700ac556: 9802         	ldr	r0, [sp, #0x8]
700ac558: b004         	add	sp, #0x10
700ac55a: bd80         	pop	{r7, pc}
700ac55c: 0000         	movs	r0, r0
700ac55e: 0000         	movs	r0, r0

700ac560 <prvDeleteTCB>:
; static void prvDeleteTCB(TCB_t *pxTCB) {
700ac560: b580         	push	{r7, lr}
700ac562: b082         	sub	sp, #0x8
700ac564: 9001         	str	r0, [sp, #0x4]
;   portCLEAN_UP_TCB(pxTCB);
700ac566: 9801         	ldr	r0, [sp, #0x4]
;     if (pxTCB->ucStaticallyAllocated ==
700ac568: f890 0081    	ldrb.w	r0, [r0, #0x81]
700ac56c: b940         	cbnz	r0, 0x700ac580 <prvDeleteTCB+0x20> @ imm = #0x10
700ac56e: e7ff         	b	0x700ac570 <prvDeleteTCB+0x10> @ imm = #-0x2
;       vPortFree(pxTCB->pxStack);
700ac570: 9801         	ldr	r0, [sp, #0x4]
700ac572: 6b00         	ldr	r0, [r0, #0x30]
700ac574: f001 f96c    	bl	0x700ad850 <vPortFree>  @ imm = #0x12d8
;       vPortFree(pxTCB);
700ac578: 9801         	ldr	r0, [sp, #0x4]
700ac57a: f001 f969    	bl	0x700ad850 <vPortFree>  @ imm = #0x12d2
;     } else if (pxTCB->ucStaticallyAllocated ==
700ac57e: e00b         	b	0x700ac598 <prvDeleteTCB+0x38> @ imm = #0x16
700ac580: 9801         	ldr	r0, [sp, #0x4]
700ac582: f890 0081    	ldrb.w	r0, [r0, #0x81]
700ac586: 2801         	cmp	r0, #0x1
700ac588: d104         	bne	0x700ac594 <prvDeleteTCB+0x34> @ imm = #0x8
700ac58a: e7ff         	b	0x700ac58c <prvDeleteTCB+0x2c> @ imm = #-0x2
;       vPortFree(pxTCB);
700ac58c: 9801         	ldr	r0, [sp, #0x4]
700ac58e: f001 f95f    	bl	0x700ad850 <vPortFree>  @ imm = #0x12be
;     } else {
700ac592: e000         	b	0x700ac596 <prvDeleteTCB+0x36> @ imm = #0x0
700ac594: e7ff         	b	0x700ac596 <prvDeleteTCB+0x36> @ imm = #-0x2
700ac596: e7ff         	b	0x700ac598 <prvDeleteTCB+0x38> @ imm = #-0x2
; }
700ac598: b002         	add	sp, #0x8
700ac59a: bd80         	pop	{r7, pc}
700ac59c: 0000         	movs	r0, r0
700ac59e: 0000         	movs	r0, r0

700ac5a0 <prvResetNextTaskUnblockTime>:
;   if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
700ac5a0: f644 50b0    	movw	r0, #0x4db0
700ac5a4: f2c7 0008    	movt	r0, #0x7008
700ac5a8: 6800         	ldr	r0, [r0]
700ac5aa: 6800         	ldr	r0, [r0]
700ac5ac: b940         	cbnz	r0, 0x700ac5c0 <prvResetNextTaskUnblockTime+0x20> @ imm = #0x10
700ac5ae: e7ff         	b	0x700ac5b0 <prvResetNextTaskUnblockTime+0x10> @ imm = #-0x2
;     xNextTaskUnblockTime = portMAX_DELAY;
700ac5b0: f640 51e4    	movw	r1, #0xde4
700ac5b4: f2c7 010b    	movt	r1, #0x700b
700ac5b8: f04f 30ff    	mov.w	r0, #0xffffffff
700ac5bc: 6008         	str	r0, [r1]
;   } else {
700ac5be: e00c         	b	0x700ac5da <prvResetNextTaskUnblockTime+0x3a> @ imm = #0x18
;     xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxDelayedTaskList);
700ac5c0: f644 50b0    	movw	r0, #0x4db0
700ac5c4: f2c7 0008    	movt	r0, #0x7008
700ac5c8: 6800         	ldr	r0, [r0]
700ac5ca: 68c0         	ldr	r0, [r0, #0xc]
700ac5cc: 6800         	ldr	r0, [r0]
700ac5ce: f640 51e4    	movw	r1, #0xde4
700ac5d2: f2c7 010b    	movt	r1, #0x700b
700ac5d6: 6008         	str	r0, [r1]
700ac5d8: e7ff         	b	0x700ac5da <prvResetNextTaskUnblockTime+0x3a> @ imm = #-0x2
; }
700ac5da: 4770         	bx	lr
700ac5dc: 0000         	movs	r0, r0
700ac5de: 0000         	movs	r0, r0

700ac5e0 <PMU_enableAllCounters>:
; static void PMU_enableAllCounters(uint32_t numCounters) {
700ac5e0: b580         	push	{r7, lr}
700ac5e2: b082         	sub	sp, #0x8
700ac5e4: 9001         	str	r0, [sp, #0x4]
700ac5e6: 2001         	movs	r0, #0x1
;   CSL_armR5PmuEnableAllCntrs(1);
700ac5e8: f7f4 e8d0    	blx	0x700a078c <CSL_armR5PmuEnableAllCntrs> @ imm = #-0xbe60
700ac5ec: 2000         	movs	r0, #0x0
;   for (i = 0; i < numCounters; i++) {
700ac5ee: 9000         	str	r0, [sp]
700ac5f0: e7ff         	b	0x700ac5f2 <PMU_enableAllCounters+0x12> @ imm = #-0x2
700ac5f2: 9800         	ldr	r0, [sp]
700ac5f4: 9901         	ldr	r1, [sp, #0x4]
700ac5f6: 4288         	cmp	r0, r1
700ac5f8: d209         	bhs	0x700ac60e <PMU_enableAllCounters+0x2e> @ imm = #0x12
700ac5fa: e7ff         	b	0x700ac5fc <PMU_enableAllCounters+0x1c> @ imm = #-0x2
;     CSL_armR5PmuEnableCntr(i, 1);
700ac5fc: 9800         	ldr	r0, [sp]
700ac5fe: 2101         	movs	r1, #0x1
700ac600: f7f4 e8fa    	blx	0x700a07f8 <CSL_armR5PmuEnableCntr> @ imm = #-0xbe0c
;   }
700ac604: e7ff         	b	0x700ac606 <PMU_enableAllCounters+0x26> @ imm = #-0x2
;   for (i = 0; i < numCounters; i++) {
700ac606: 9800         	ldr	r0, [sp]
700ac608: 3001         	adds	r0, #0x1
700ac60a: 9000         	str	r0, [sp]
700ac60c: e7f1         	b	0x700ac5f2 <PMU_enableAllCounters+0x12> @ imm = #-0x1e
700ac60e: 201f         	movs	r0, #0x1f
700ac610: 2101         	movs	r1, #0x1
;   CSL_armR5PmuEnableCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM, 1);
700ac612: f7f4 e8f2    	blx	0x700a07f8 <CSL_armR5PmuEnableCntr> @ imm = #-0xbe1c
; }
700ac616: b002         	add	sp, #0x8
700ac618: bd80         	pop	{r7, pc}
700ac61a: 0000         	movs	r0, r0
700ac61c: 0000         	movs	r0, r0
700ac61e: 0000         	movs	r0, r0

700ac620 <_atoi>:
; {
700ac620: b580         	push	{r7, lr}
700ac622: b082         	sub	sp, #0x8
700ac624: 9001         	str	r0, [sp, #0x4]
700ac626: 2000         	movs	r0, #0x0
;   unsigned int i = 0U;
700ac628: 9000         	str	r0, [sp]
;   while (_is_digit(**str)) {
700ac62a: e7ff         	b	0x700ac62c <_atoi+0xc>  @ imm = #-0x2
700ac62c: 9801         	ldr	r0, [sp, #0x4]
700ac62e: 6800         	ldr	r0, [r0]
700ac630: 7800         	ldrb	r0, [r0]
700ac632: f000 fbe5    	bl	0x700ace00 <_is_digit>  @ imm = #0x7ca
700ac636: b168         	cbz	r0, 0x700ac654 <_atoi+0x34> @ imm = #0x1a
700ac638: e7ff         	b	0x700ac63a <_atoi+0x1a> @ imm = #-0x2
;     i = i * 10U + (unsigned int)(*((*str)++) - '0');
700ac63a: 9800         	ldr	r0, [sp]
700ac63c: eb00 0180    	add.w	r1, r0, r0, lsl #2
700ac640: 9b01         	ldr	r3, [sp, #0x4]
700ac642: 6818         	ldr	r0, [r3]
700ac644: 1c42         	adds	r2, r0, #0x1
700ac646: 601a         	str	r2, [r3]
700ac648: 7800         	ldrb	r0, [r0]
700ac64a: eb00 0041    	add.w	r0, r0, r1, lsl #1
700ac64e: 3830         	subs	r0, #0x30
700ac650: 9000         	str	r0, [sp]
;   while (_is_digit(**str)) {
700ac652: e7eb         	b	0x700ac62c <_atoi+0xc>  @ imm = #-0x2a
;   return i;
700ac654: 9800         	ldr	r0, [sp]
700ac656: b002         	add	sp, #0x8
700ac658: bd80         	pop	{r7, pc}
700ac65a: 0000         	movs	r0, r0
700ac65c: 0000         	movs	r0, r0
700ac65e: 0000         	movs	r0, r0

700ac660 <snprintf_>:
; {
700ac660: b081         	sub	sp, #0x4
700ac662: b580         	push	{r7, lr}
700ac664: b087         	sub	sp, #0x1c
700ac666: 9309         	str	r3, [sp, #0x24]
700ac668: 9006         	str	r0, [sp, #0x18]
700ac66a: 9105         	str	r1, [sp, #0x14]
700ac66c: 9204         	str	r2, [sp, #0x10]
700ac66e: a809         	add	r0, sp, #0x24
;   va_start(va, format);
700ac670: 9003         	str	r0, [sp, #0xc]
;   const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
700ac672: 9906         	ldr	r1, [sp, #0x18]
700ac674: 9a05         	ldr	r2, [sp, #0x14]
700ac676: 9b04         	ldr	r3, [sp, #0x10]
700ac678: 9803         	ldr	r0, [sp, #0xc]
700ac67a: 46ec         	mov	r12, sp
700ac67c: f8cc 0000    	str.w	r0, [r12]
700ac680: f24d 4091    	movw	r0, #0xd491
700ac684: f2c7 000a    	movt	r0, #0x700a
700ac688: f7ec fbba    	bl	0x70098e00 <_vsnprintf> @ imm = #-0x1388c
700ac68c: 9002         	str	r0, [sp, #0x8]
;   return ret;
700ac68e: 9802         	ldr	r0, [sp, #0x8]
700ac690: b007         	add	sp, #0x1c
700ac692: e8bd 4080    	pop.w	{r7, lr}
700ac696: b001         	add	sp, #0x4
700ac698: 4770         	bx	lr
700ac69a: 0000         	movs	r0, r0
700ac69c: 0000         	movs	r0, r0
700ac69e: 0000         	movs	r0, r0

700ac6a0 <vListInsertEnd>:
; {
700ac6a0: b083         	sub	sp, #0xc
700ac6a2: 9002         	str	r0, [sp, #0x8]
700ac6a4: 9101         	str	r1, [sp, #0x4]
;     ListItem_t * const pxIndex = pxList->pxIndex;
700ac6a6: 9802         	ldr	r0, [sp, #0x8]
700ac6a8: 6840         	ldr	r0, [r0, #0x4]
700ac6aa: 9000         	str	r0, [sp]
;     pxNewListItem->pxNext = pxIndex;
700ac6ac: 9800         	ldr	r0, [sp]
700ac6ae: 9901         	ldr	r1, [sp, #0x4]
700ac6b0: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxPrevious = pxIndex->pxPrevious;
700ac6b2: 9800         	ldr	r0, [sp]
700ac6b4: 6880         	ldr	r0, [r0, #0x8]
700ac6b6: 9901         	ldr	r1, [sp, #0x4]
700ac6b8: 6088         	str	r0, [r1, #0x8]
;     pxIndex->pxPrevious->pxNext = pxNewListItem;
700ac6ba: 9801         	ldr	r0, [sp, #0x4]
700ac6bc: 9900         	ldr	r1, [sp]
700ac6be: 6889         	ldr	r1, [r1, #0x8]
700ac6c0: 6048         	str	r0, [r1, #0x4]
;     pxIndex->pxPrevious = pxNewListItem;
700ac6c2: 9801         	ldr	r0, [sp, #0x4]
700ac6c4: 9900         	ldr	r1, [sp]
700ac6c6: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxContainer = pxList;
700ac6c8: 9802         	ldr	r0, [sp, #0x8]
700ac6ca: 9901         	ldr	r1, [sp, #0x4]
700ac6cc: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
700ac6ce: 9902         	ldr	r1, [sp, #0x8]
700ac6d0: 6808         	ldr	r0, [r1]
700ac6d2: 3001         	adds	r0, #0x1
700ac6d4: 6008         	str	r0, [r1]
; }
700ac6d6: b003         	add	sp, #0xc
700ac6d8: 4770         	bx	lr
700ac6da: 0000         	movs	r0, r0
700ac6dc: 0000         	movs	r0, r0
700ac6de: 0000         	movs	r0, r0

700ac6e0 <CSL_REG32_FINS_RAW>:
; {
700ac6e0: b580         	push	{r7, lr}
700ac6e2: b086         	sub	sp, #0x18
700ac6e4: 9005         	str	r0, [sp, #0x14]
700ac6e6: 9104         	str	r1, [sp, #0x10]
700ac6e8: 9203         	str	r2, [sp, #0xc]
700ac6ea: 9302         	str	r3, [sp, #0x8]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700ac6ec: 9805         	ldr	r0, [sp, #0x14]
700ac6ee: f001 fcbf    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0x197e
700ac6f2: 9001         	str	r0, [sp, #0x4]
;     regVal = (regVal & ~(mask));
700ac6f4: 9801         	ldr	r0, [sp, #0x4]
700ac6f6: 9904         	ldr	r1, [sp, #0x10]
700ac6f8: 4388         	bics	r0, r1
700ac6fa: 9001         	str	r0, [sp, #0x4]
;     regVal |= (v << shift) & mask;
700ac6fc: 9802         	ldr	r0, [sp, #0x8]
700ac6fe: 9903         	ldr	r1, [sp, #0xc]
700ac700: 4088         	lsls	r0, r1
700ac702: 9904         	ldr	r1, [sp, #0x10]
700ac704: 4001         	ands	r1, r0
700ac706: 9801         	ldr	r0, [sp, #0x4]
700ac708: 4308         	orrs	r0, r1
700ac70a: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR_RAW(p, regVal);
700ac70c: 9805         	ldr	r0, [sp, #0x14]
700ac70e: 9901         	ldr	r1, [sp, #0x4]
700ac710: f7ee fc4e    	bl	0x7009afb0 <CSL_REG32_WR_RAW> @ imm = #-0x11764
;     return;
700ac714: b006         	add	sp, #0x18
700ac716: bd80         	pop	{r7, pc}
		...

700ac720 <SOC_getCoreName>:
; {
700ac720: b082         	sub	sp, #0x8
700ac722: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     if(coreId < CSL_CORE_ID_MAX)
700ac726: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac72a: 2806         	cmp	r0, #0x6
700ac72c: d80a         	bhi	0x700ac744 <SOC_getCoreName+0x24> @ imm = #0x14
700ac72e: e7ff         	b	0x700ac730 <SOC_getCoreName+0x10> @ imm = #-0x2
;         name = coreIdNames[coreId];
700ac730: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ac734: f640 4034    	movw	r0, #0xc34
700ac738: f2c7 000b    	movt	r0, #0x700b
700ac73c: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700ac740: 9000         	str	r0, [sp]
;     }
700ac742: e006         	b	0x700ac752 <SOC_getCoreName+0x32> @ imm = #0xc
;         name = coreIdNames[CSL_CORE_ID_MAX];
700ac744: f640 4034    	movw	r0, #0xc34
700ac748: f2c7 000b    	movt	r0, #0x700b
700ac74c: 69c0         	ldr	r0, [r0, #0x1c]
700ac74e: 9000         	str	r0, [sp]
700ac750: e7ff         	b	0x700ac752 <SOC_getCoreName+0x32> @ imm = #-0x2
;     return name;
700ac752: 9800         	ldr	r0, [sp]
700ac754: b002         	add	sp, #0x8
700ac756: 4770         	bx	lr
		...

700ac760 <Sciclient_secProxyFlush>:
; {
700ac760: b580         	push	{r7, lr}
700ac762: b082         	sub	sp, #0x8
700ac764: 9001         	str	r0, [sp, #0x4]
;     while ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ac766: e7ff         	b	0x700ac768 <Sciclient_secProxyFlush+0x8> @ imm = #-0x2
700ac768: 9801         	ldr	r0, [sp, #0x4]
700ac76a: f001 f9f1    	bl	0x700adb50 <Sciclient_secProxyThreadStatusReg> @ imm = #0x13e2
700ac76e: f001 fc97    	bl	0x700ae0a0 <CSL_REG32_RD_RAW> @ imm = #0x192e
700ac772: 0600         	lsls	r0, r0, #0x18
700ac774: b170         	cbz	r0, 0x700ac794 <Sciclient_secProxyFlush+0x34> @ imm = #0x1c
700ac776: e7ff         	b	0x700ac778 <Sciclient_secProxyFlush+0x18> @ imm = #-0x2
;         (void) Sciclient_secProxyReadThread32(thread,
700ac778: 9801         	ldr	r0, [sp, #0x4]
;                         (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U)-1U));
700ac77a: f640 5100    	movw	r1, #0xd00
700ac77e: f2c7 010b    	movt	r1, #0x700b
700ac782: 694a         	ldr	r2, [r1, #0x14]
700ac784: f04f 31ff    	mov.w	r1, #0xffffffff
700ac788: eb01 0192    	add.w	r1, r1, r2, lsr #2
;         (void) Sciclient_secProxyReadThread32(thread,
700ac78c: b2c9         	uxtb	r1, r1
700ac78e: f000 fb07    	bl	0x700acda0 <Sciclient_secProxyReadThread32> @ imm = #0x60e
;     while ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ac792: e7e9         	b	0x700ac768 <Sciclient_secProxyFlush+0x8> @ imm = #-0x2e
;     return ;
700ac794: b002         	add	sp, #0x8
700ac796: bd80         	pop	{r7, pc}
		...

700ac7a0 <UART_writeDataPolling>:
; {
700ac7a0: b580         	push	{r7, lr}
700ac7a2: b082         	sub	sp, #0x8
700ac7a4: 9001         	str	r0, [sp, #0x4]
700ac7a6: 2000         	movs	r0, #0x0
;     uint32_t numBytesWritten = 0U;
700ac7a8: 9000         	str	r0, [sp]
;     numBytesWritten = UART_fifoWrite(hUart,
700ac7aa: 9801         	ldr	r0, [sp, #0x4]
;                                      (const uint8_t *) hUart->writeBuf,
700ac7ac: 6881         	ldr	r1, [r0, #0x8]
;                                      hUart->writeSizeRemaining);
700ac7ae: 6902         	ldr	r2, [r0, #0x10]
;     numBytesWritten = UART_fifoWrite(hUart,
700ac7b0: f7f9 fb3e    	bl	0x700a5e30 <UART_fifoWrite> @ imm = #-0x6984
700ac7b4: 9000         	str	r0, [sp]
;     hUart->writeSizeRemaining -= numBytesWritten;
700ac7b6: 9a00         	ldr	r2, [sp]
700ac7b8: 9901         	ldr	r1, [sp, #0x4]
700ac7ba: 6908         	ldr	r0, [r1, #0x10]
700ac7bc: 1a80         	subs	r0, r0, r2
700ac7be: 6108         	str	r0, [r1, #0x10]
;     hUart->writeBuf           = (const void *)((uint8_t *)hUart->writeBuf + numBytesWritten);
700ac7c0: 9901         	ldr	r1, [sp, #0x4]
700ac7c2: 6888         	ldr	r0, [r1, #0x8]
700ac7c4: 9a00         	ldr	r2, [sp]
700ac7c6: 4410         	add	r0, r2
700ac7c8: 6088         	str	r0, [r1, #0x8]
;     hUart->writeCount         += numBytesWritten;
700ac7ca: 9a00         	ldr	r2, [sp]
700ac7cc: 9901         	ldr	r1, [sp, #0x4]
700ac7ce: 68c8         	ldr	r0, [r1, #0xc]
700ac7d0: 4410         	add	r0, r2
700ac7d2: 60c8         	str	r0, [r1, #0xc]
;     return;
700ac7d4: b002         	add	sp, #0x8
700ac7d6: bd80         	pop	{r7, pc}
		...

700ac7e0 <xTaskGetSchedulerState>:
; BaseType_t xTaskGetSchedulerState(void) {
700ac7e0: b081         	sub	sp, #0x4
;   if (xSchedulerRunning == pdFALSE) {
700ac7e2: f640 50f0    	movw	r0, #0xdf0
700ac7e6: f2c7 000b    	movt	r0, #0x700b
700ac7ea: 6800         	ldr	r0, [r0]
700ac7ec: b918         	cbnz	r0, 0x700ac7f6 <xTaskGetSchedulerState+0x16> @ imm = #0x6
700ac7ee: e7ff         	b	0x700ac7f0 <xTaskGetSchedulerState+0x10> @ imm = #-0x2
700ac7f0: 2001         	movs	r0, #0x1
;     xReturn = taskSCHEDULER_NOT_STARTED;
700ac7f2: 9000         	str	r0, [sp]
;   } else {
700ac7f4: e00d         	b	0x700ac812 <xTaskGetSchedulerState+0x32> @ imm = #0x1a
;     if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700ac7f6: f640 50d4    	movw	r0, #0xdd4
700ac7fa: f2c7 000b    	movt	r0, #0x700b
700ac7fe: 6800         	ldr	r0, [r0]
700ac800: b918         	cbnz	r0, 0x700ac80a <xTaskGetSchedulerState+0x2a> @ imm = #0x6
700ac802: e7ff         	b	0x700ac804 <xTaskGetSchedulerState+0x24> @ imm = #-0x2
700ac804: 2002         	movs	r0, #0x2
;       xReturn = taskSCHEDULER_RUNNING;
700ac806: 9000         	str	r0, [sp]
;     } else {
700ac808: e002         	b	0x700ac810 <xTaskGetSchedulerState+0x30> @ imm = #0x4
700ac80a: 2000         	movs	r0, #0x0
;       xReturn = taskSCHEDULER_SUSPENDED;
700ac80c: 9000         	str	r0, [sp]
700ac80e: e7ff         	b	0x700ac810 <xTaskGetSchedulerState+0x30> @ imm = #-0x2
700ac810: e7ff         	b	0x700ac812 <xTaskGetSchedulerState+0x32> @ imm = #-0x2
;   return xReturn;
700ac812: 9800         	ldr	r0, [sp]
700ac814: b001         	add	sp, #0x4
700ac816: 4770         	bx	lr
		...

700ac820 <tm_thread_create>:
; {
700ac820: b580         	push	{r7, lr}
700ac822: b082         	sub	sp, #0x8
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ac824: f644 43c8    	movw	r3, #0x4cc8
;    int new_priority = configMAX_PRIORITIES - priority + 1;
700ac828: f1c1 0c21    	rsb.w	r12, r1, #0x21
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ac82c: f2c7 0308    	movt	r3, #0x7008
;    status = xTaskCreate((TaskFunction_t) entry_function, "Thread-Metric test", configMINIMAL_STACK_SIZE, NULL,
700ac830: f240 317e    	movw	r1, #0x37e
700ac834: f2c7 010b    	movt	r1, #0x700b
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ac838: eb03 0e80    	add.w	lr, r3, r0, lsl #2
;    status = xTaskCreate((TaskFunction_t) entry_function, "Thread-Metric test", configMINIMAL_STACK_SIZE, NULL,
700ac83c: 4610         	mov	r0, r2
700ac83e: f44f 6280    	mov.w	r2, #0x400
700ac842: 2300         	movs	r3, #0x0
700ac844: e9cd ce00    	strd	r12, lr, [sp]
700ac848: f7fb f8a2    	bl	0x700a7990 <xTaskCreate> @ imm = #-0x4ebc
;    if (status != pdPASS)
700ac84c: 3801         	subs	r0, #0x1
700ac84e: bf18         	it	ne
700ac850: 2001         	movne	r0, #0x1
; }
700ac852: b002         	add	sp, #0x8
700ac854: bd80         	pop	{r7, pc}
		...
700ac85e: 0000         	movs	r0, r0

700ac860 <vTaskDelay>:
; void vTaskDelay(const TickType_t xTicksToDelay) {
700ac860: b580         	push	{r7, lr}
700ac862: b082         	sub	sp, #0x8
700ac864: 9001         	str	r0, [sp, #0x4]
700ac866: 2000         	movs	r0, #0x0
;   BaseType_t xAlreadyYielded = pdFALSE;
700ac868: 9000         	str	r0, [sp]
;   if (xTicksToDelay > (TickType_t)0U) {
700ac86a: 9801         	ldr	r0, [sp, #0x4]
700ac86c: b150         	cbz	r0, 0x700ac884 <vTaskDelay+0x24> @ imm = #0x14
700ac86e: e7ff         	b	0x700ac870 <vTaskDelay+0x10> @ imm = #-0x2
;     vTaskSuspendAll();
700ac870: f001 fbde    	bl	0x700ae030 <vTaskSuspendAll> @ imm = #0x17bc
;       prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
700ac874: 9801         	ldr	r0, [sp, #0x4]
700ac876: 2100         	movs	r1, #0x0
700ac878: f7f8 f992    	bl	0x700a4ba0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x7cdc
;     xAlreadyYielded = xTaskResumeAll();
700ac87c: f7f4 f810    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0xbfe0
700ac880: 9000         	str	r0, [sp]
;   } else {
700ac882: e000         	b	0x700ac886 <vTaskDelay+0x26> @ imm = #0x0
700ac884: e7ff         	b	0x700ac886 <vTaskDelay+0x26> @ imm = #-0x2
;   if (xAlreadyYielded == pdFALSE) {
700ac886: 9800         	ldr	r0, [sp]
700ac888: b910         	cbnz	r0, 0x700ac890 <vTaskDelay+0x30> @ imm = #0x4
700ac88a: e7ff         	b	0x700ac88c <vTaskDelay+0x2c> @ imm = #-0x2
;     portYIELD_WITHIN_API();
700ac88c: df00         	svc	#0x0
;   } else {
700ac88e: e000         	b	0x700ac892 <vTaskDelay+0x32> @ imm = #0x0
700ac890: e7ff         	b	0x700ac892 <vTaskDelay+0x32> @ imm = #-0x2
; }
700ac892: b002         	add	sp, #0x8
700ac894: bd80         	pop	{r7, pc}
		...
700ac89e: 0000         	movs	r0, r0

700ac8a0 <vTaskPlaceOnEventListRestricted>:
;                                      const BaseType_t xWaitIndefinitely) {
700ac8a0: b580         	push	{r7, lr}
700ac8a2: b084         	sub	sp, #0x10
700ac8a4: 9003         	str	r0, [sp, #0xc]
700ac8a6: 9102         	str	r1, [sp, #0x8]
700ac8a8: 9201         	str	r2, [sp, #0x4]
;   vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
700ac8aa: 9803         	ldr	r0, [sp, #0xc]
700ac8ac: f640 51ac    	movw	r1, #0xdac
700ac8b0: f2c7 010b    	movt	r1, #0x700b
700ac8b4: 6809         	ldr	r1, [r1]
700ac8b6: 3118         	adds	r1, #0x18
700ac8b8: f7ff fef2    	bl	0x700ac6a0 <vListInsertEnd> @ imm = #-0x21c
;   if (xWaitIndefinitely != pdFALSE) {
700ac8bc: 9801         	ldr	r0, [sp, #0x4]
700ac8be: b120         	cbz	r0, 0x700ac8ca <vTaskPlaceOnEventListRestricted+0x2a> @ imm = #0x8
700ac8c0: e7ff         	b	0x700ac8c2 <vTaskPlaceOnEventListRestricted+0x22> @ imm = #-0x2
700ac8c2: f04f 30ff    	mov.w	r0, #0xffffffff
;     xTicksToWait = portMAX_DELAY;
700ac8c6: 9002         	str	r0, [sp, #0x8]
;   }
700ac8c8: e7ff         	b	0x700ac8ca <vTaskPlaceOnEventListRestricted+0x2a> @ imm = #-0x2
;   prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
700ac8ca: 9802         	ldr	r0, [sp, #0x8]
700ac8cc: 9901         	ldr	r1, [sp, #0x4]
700ac8ce: f7f8 f967    	bl	0x700a4ba0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x7d32
; }
700ac8d2: b004         	add	sp, #0x10
700ac8d4: bd80         	pop	{r7, pc}
		...
700ac8de: 0000         	movs	r0, r0

700ac8e0 <CSL_pktdmaTeardownRxChan>:
; {
700ac8e0: b580         	push	{r7, lr}
700ac8e2: b084         	sub	sp, #0x10
700ac8e4: 9003         	str	r0, [sp, #0xc]
700ac8e6: 9102         	str	r1, [sp, #0x8]
700ac8e8: f88d 2007    	strb.w	r2, [sp, #0x7]
700ac8ec: f88d 3006    	strb.w	r3, [sp, #0x6]
;     return CSL_pktdmaTeardownChan( pCfg, chanIdx, CSL_PKTDMA_CHAN_DIR_RX, bForce, bWait );
700ac8f0: 9803         	ldr	r0, [sp, #0xc]
700ac8f2: 9902         	ldr	r1, [sp, #0x8]
700ac8f4: f89d 2007    	ldrb.w	r2, [sp, #0x7]
700ac8f8: f89d 3006    	ldrb.w	r3, [sp, #0x6]
700ac8fc: f003 0301    	and	r3, r3, #0x1
700ac900: 46ec         	mov	r12, sp
700ac902: f8cc 3000    	str.w	r3, [r12]
700ac906: f002 0301    	and	r3, r2, #0x1
700ac90a: 2201         	movs	r2, #0x1
700ac90c: f7f7 f800    	bl	0x700a3910 <CSL_pktdmaTeardownChan> @ imm = #-0x9000
700ac910: b004         	add	sp, #0x10
700ac912: bd80         	pop	{r7, pc}
		...

700ac920 <CSL_pktdmaTeardownTxChan>:
; {
700ac920: b580         	push	{r7, lr}
700ac922: b084         	sub	sp, #0x10
700ac924: 9003         	str	r0, [sp, #0xc]
700ac926: 9102         	str	r1, [sp, #0x8]
700ac928: f88d 2007    	strb.w	r2, [sp, #0x7]
700ac92c: f88d 3006    	strb.w	r3, [sp, #0x6]
;     return CSL_pktdmaTeardownChan( pCfg, chanIdx, CSL_PKTDMA_CHAN_DIR_TX, bForce, bWait );
700ac930: 9803         	ldr	r0, [sp, #0xc]
700ac932: 9902         	ldr	r1, [sp, #0x8]
700ac934: f89d 2007    	ldrb.w	r2, [sp, #0x7]
700ac938: f89d 3006    	ldrb.w	r3, [sp, #0x6]
700ac93c: f003 0301    	and	r3, r3, #0x1
700ac940: 46ec         	mov	r12, sp
700ac942: f8cc 3000    	str.w	r3, [r12]
700ac946: f002 0301    	and	r3, r2, #0x1
700ac94a: 2200         	movs	r2, #0x0
700ac94c: f7f6 ffe0    	bl	0x700a3910 <CSL_pktdmaTeardownChan> @ imm = #-0x9040
700ac950: b004         	add	sp, #0x10
700ac952: bd80         	pop	{r7, pc}
		...

700ac960 <TimerP_Params_init>:
; {
700ac960: b081         	sub	sp, #0x4
700ac962: 9000         	str	r0, [sp]
;     params->inputPreScaler = 1;
700ac964: 9800         	ldr	r0, [sp]
700ac966: 2101         	movs	r1, #0x1
700ac968: 6001         	str	r1, [r0]
;     params->inputClkHz = 25*1000000;
700ac96a: 9a00         	ldr	r2, [sp]
700ac96c: f647 0040    	movw	r0, #0x7840
700ac970: f2c0 107d    	movt	r0, #0x17d
700ac974: 6050         	str	r0, [r2, #0x4]
;     params->periodInUsec = 1000;
700ac976: 9a00         	ldr	r2, [sp]
700ac978: f44f 707a    	mov.w	r0, #0x3e8
700ac97c: 6090         	str	r0, [r2, #0x8]
;     params->periodInNsec = 0; /* periodInUsec is used when periodInNsec is 0 */
700ac97e: 9a00         	ldr	r2, [sp]
700ac980: 2000         	movs	r0, #0x0
700ac982: 60d0         	str	r0, [r2, #0xc]
;     params->oneshotMode = 0;
700ac984: 9a00         	ldr	r2, [sp]
700ac986: 6110         	str	r0, [r2, #0x10]
;     params->enableOverflowInt = 1;
700ac988: 9a00         	ldr	r2, [sp]
700ac98a: 6151         	str	r1, [r2, #0x14]
;     params->enableDmaTrigger = 0; /* NOT USED */
700ac98c: 9900         	ldr	r1, [sp]
700ac98e: 6188         	str	r0, [r1, #0x18]
; }
700ac990: b001         	add	sp, #0x4
700ac992: 4770         	bx	lr
		...

700ac9a0 <UART_IsDataLengthValid>:
; {
700ac9a0: b082         	sub	sp, #0x8
700ac9a2: 9001         	str	r0, [sp, #0x4]
700ac9a4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ac9a8: 9000         	str	r0, [sp]
;     if(((dataLength == UART_LEN_5) ||
700ac9aa: 9801         	ldr	r0, [sp, #0x4]
700ac9ac: b160         	cbz	r0, 0x700ac9c8 <UART_IsDataLengthValid+0x28> @ imm = #0x18
700ac9ae: e7ff         	b	0x700ac9b0 <UART_IsDataLengthValid+0x10> @ imm = #-0x2
;         (dataLength == UART_LEN_6) ||
700ac9b0: 9801         	ldr	r0, [sp, #0x4]
700ac9b2: 2801         	cmp	r0, #0x1
700ac9b4: d008         	beq	0x700ac9c8 <UART_IsDataLengthValid+0x28> @ imm = #0x10
700ac9b6: e7ff         	b	0x700ac9b8 <UART_IsDataLengthValid+0x18> @ imm = #-0x2
;         (dataLength == UART_LEN_7) ||
700ac9b8: 9801         	ldr	r0, [sp, #0x4]
700ac9ba: 2802         	cmp	r0, #0x2
700ac9bc: d004         	beq	0x700ac9c8 <UART_IsDataLengthValid+0x28> @ imm = #0x8
700ac9be: e7ff         	b	0x700ac9c0 <UART_IsDataLengthValid+0x20> @ imm = #-0x2
;         (dataLength == UART_LEN_8)))
700ac9c0: 9801         	ldr	r0, [sp, #0x4]
;     if(((dataLength == UART_LEN_5) ||
700ac9c2: 2803         	cmp	r0, #0x3
700ac9c4: d103         	bne	0x700ac9ce <UART_IsDataLengthValid+0x2e> @ imm = #0x6
700ac9c6: e7ff         	b	0x700ac9c8 <UART_IsDataLengthValid+0x28> @ imm = #-0x2
700ac9c8: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ac9ca: 9000         	str	r0, [sp]
;     }
700ac9cc: e7ff         	b	0x700ac9ce <UART_IsDataLengthValid+0x2e> @ imm = #-0x2
;     return status;
700ac9ce: 9800         	ldr	r0, [sp]
700ac9d0: b002         	add	sp, #0x8
700ac9d2: 4770         	bx	lr
		...

700ac9e0 <UART_checkTransaction>:
; {
700ac9e0: b082         	sub	sp, #0x8
700ac9e2: 9001         	str	r0, [sp, #0x4]
700ac9e4: 2000         	movs	r0, #0x0
;     int32_t     status = UART_TRANSFER_STATUS_SUCCESS;
700ac9e6: 9000         	str	r0, [sp]
;     if(0U == trans->count)
700ac9e8: 9801         	ldr	r0, [sp, #0x4]
700ac9ea: 6840         	ldr	r0, [r0, #0x4]
700ac9ec: b938         	cbnz	r0, 0x700ac9fe <UART_checkTransaction+0x1e> @ imm = #0xe
700ac9ee: e7ff         	b	0x700ac9f0 <UART_checkTransaction+0x10> @ imm = #-0x2
;         trans->status = UART_TRANSFER_STATUS_ERROR_OTH;
700ac9f0: 9901         	ldr	r1, [sp, #0x4]
700ac9f2: 200a         	movs	r0, #0xa
700ac9f4: 60c8         	str	r0, [r1, #0xc]
700ac9f6: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ac9fa: 9000         	str	r0, [sp]
;     }
700ac9fc: e7ff         	b	0x700ac9fe <UART_checkTransaction+0x1e> @ imm = #-0x2
;     if(NULL == trans->buf)
700ac9fe: 9801         	ldr	r0, [sp, #0x4]
700aca00: 6800         	ldr	r0, [r0]
700aca02: b920         	cbnz	r0, 0x700aca0e <UART_checkTransaction+0x2e> @ imm = #0x8
700aca04: e7ff         	b	0x700aca06 <UART_checkTransaction+0x26> @ imm = #-0x2
700aca06: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700aca0a: 9000         	str	r0, [sp]
;     }
700aca0c: e7ff         	b	0x700aca0e <UART_checkTransaction+0x2e> @ imm = #-0x2
;     return (status);
700aca0e: 9800         	ldr	r0, [sp]
700aca10: b002         	add	sp, #0x8
700aca12: 4770         	bx	lr

700aca14 <free_list_remove>:
700aca14: e59f3028     	ldr	r3, [pc, #0x28]         @ 0x700aca44 <free_list_remove+0x30>
700aca18: e5932000     	ldr	r2, [r3]
700aca1c: e1a01003     	mov	r1, r3
700aca20: e3520000     	cmp	r2, #0
700aca24: 12823008     	addne	r3, r2, #8
700aca28: 11520000     	cmpne	r2, r0
700aca2c: 1afffff9     	bne	0x700aca18 <free_list_remove+0x4> @ imm = #-0x1c
700aca30: e3520000     	cmp	r2, #0
700aca34: 012fff1e     	bxeq	lr
700aca38: e5900008     	ldr	r0, [r0, #0x8]
700aca3c: e5810000     	str	r0, [r1]
700aca40: e12fff1e     	bx	lr
700aca44: bc 4d 08 70  	.word	0x70084dbc
700aca48: 00 00 00 00  	.word	0x00000000
700aca4c: 00 00 00 00  	.word	0x00000000

700aca50 <vPortTimerTickHandler>:
; void vPortTimerTickHandler() {
700aca50: b580         	push	{r7, lr}
;   portENTER_CRITICAL();
700aca52: f000 f8bd    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #0x17a
;   if (ulPortSchedularRunning == pdTRUE) {
700aca56: f640 50c0    	movw	r0, #0xdc0
700aca5a: f2c7 000b    	movt	r0, #0x700b
700aca5e: 6800         	ldr	r0, [r0]
700aca60: 2801         	cmp	r0, #0x1
700aca62: d10c         	bne	0x700aca7e <vPortTimerTickHandler+0x2e> @ imm = #0x18
700aca64: e7ff         	b	0x700aca66 <vPortTimerTickHandler+0x16> @ imm = #-0x2
;     if (xTaskIncrementTick() != pdFALSE) {
700aca66: f7f3 f8cb    	bl	0x7009fc00 <xTaskIncrementTick> @ imm = #-0xce6a
700aca6a: b138         	cbz	r0, 0x700aca7c <vPortTimerTickHandler+0x2c> @ imm = #0xe
700aca6c: e7ff         	b	0x700aca6e <vPortTimerTickHandler+0x1e> @ imm = #-0x2
;       ulPortYieldRequired = pdTRUE;
700aca6e: f640 51c8    	movw	r1, #0xdc8
700aca72: f2c7 010b    	movt	r1, #0x700b
700aca76: 2001         	movs	r0, #0x1
700aca78: 6008         	str	r0, [r1]
;     }
700aca7a: e7ff         	b	0x700aca7c <vPortTimerTickHandler+0x2c> @ imm = #-0x2
;   }
700aca7c: e7ff         	b	0x700aca7e <vPortTimerTickHandler+0x2e> @ imm = #-0x2
;   portEXIT_CRITICAL();
700aca7e: f7ff f927    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #-0xdb2
; }
700aca82: bd80         	pop	{r7, pc}
		...

700aca90 <ClockP_timerTickIsr>:
; {
700aca90: b580         	push	{r7, lr}
700aca92: b082         	sub	sp, #0x8
700aca94: 9001         	str	r0, [sp, #0x4]
;     gClockCtrl.ticks++;
700aca96: f644 4190    	movw	r1, #0x4c90
700aca9a: f2c7 0108    	movt	r1, #0x7008
700aca9e: 680a         	ldr	r2, [r1]
700acaa0: 6848         	ldr	r0, [r1, #0x4]
700acaa2: 3201         	adds	r2, #0x1
700acaa4: f140 0000    	adc	r0, r0, #0x0
700acaa8: 600a         	str	r2, [r1]
700acaaa: 6048         	str	r0, [r1, #0x4]
;     vPortTimerTickHandler();
700acaac: f7ff ffd0    	bl	0x700aca50 <vPortTimerTickHandler> @ imm = #-0x60
;     ClockP_timerClearOverflowInt(gClockConfig.timerBaseAddr);
700acab0: f640 40b8    	movw	r0, #0xcb8
700acab4: f2c7 000b    	movt	r0, #0x700b
700acab8: 6800         	ldr	r0, [r0]
700acaba: f001 fa89    	bl	0x700adfd0 <ClockP_timerClearOverflowInt> @ imm = #0x1512
; }
700acabe: b002         	add	sp, #0x8
700acac0: bd80         	pop	{r7, pc}
		...
700acace: 0000         	movs	r0, r0

700acad0 <HW_WR_FIELD32_RAW>:
; {
700acad0: b085         	sub	sp, #0x14
700acad2: 9004         	str	r0, [sp, #0x10]
700acad4: 9103         	str	r1, [sp, #0xc]
700acad6: 9202         	str	r2, [sp, #0x8]
700acad8: 9301         	str	r3, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700acada: 9804         	ldr	r0, [sp, #0x10]
700acadc: 6800         	ldr	r0, [r0]
700acade: 9000         	str	r0, [sp]
;     regVal &= (~mask);
700acae0: 9903         	ldr	r1, [sp, #0xc]
700acae2: 9800         	ldr	r0, [sp]
700acae4: 4388         	bics	r0, r1
700acae6: 9000         	str	r0, [sp]
;     regVal |= (value << shift) & mask;
700acae8: 9801         	ldr	r0, [sp, #0x4]
700acaea: 9902         	ldr	r1, [sp, #0x8]
700acaec: 4088         	lsls	r0, r1
700acaee: 9903         	ldr	r1, [sp, #0xc]
700acaf0: 4001         	ands	r1, r0
700acaf2: 9800         	ldr	r0, [sp]
700acaf4: 4308         	orrs	r0, r1
700acaf6: 9000         	str	r0, [sp]
;     *(volatile uint32_t *) ((uintptr_t) addr) = regVal;
700acaf8: 9800         	ldr	r0, [sp]
700acafa: 9904         	ldr	r1, [sp, #0x10]
700acafc: 6008         	str	r0, [r1]
;     return;
700acafe: b005         	add	sp, #0x14
700acb00: 4770         	bx	lr
		...
700acb0e: 0000         	movs	r0, r0

700acb10 <UART_enhanFuncBitValRestore>:
; {
700acb10: b580         	push	{r7, lr}
700acb12: b084         	sub	sp, #0x10
700acb14: 9003         	str	r0, [sp, #0xc]
700acb16: 9102         	str	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700acb18: 9803         	ldr	r0, [sp, #0xc]
700acb1a: 21bf         	movs	r1, #0xbf
700acb1c: f7fe f840    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #-0x1f80
700acb20: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700acb22: 9803         	ldr	r0, [sp, #0xc]
700acb24: 3008         	adds	r0, #0x8
700acb26: 9902         	ldr	r1, [sp, #0x8]
700acb28: ea4f 1311    	lsr.w	r3, r1, #0x4
700acb2c: 2110         	movs	r1, #0x10
700acb2e: 2204         	movs	r2, #0x4
700acb30: f7ff ffce    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #-0x64
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700acb34: 9803         	ldr	r0, [sp, #0xc]
700acb36: 300c         	adds	r0, #0xc
700acb38: 9901         	ldr	r1, [sp, #0x4]
700acb3a: f001 fa59    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x14b2
; }
700acb3e: b004         	add	sp, #0x10
700acb40: bd80         	pop	{r7, pc}
		...
700acb4e: 0000         	movs	r0, r0

700acb50 <UART_hardwareFlowCtrlOptSet>:
; {
700acb50: b580         	push	{r7, lr}
700acb52: b084         	sub	sp, #0x10
700acb54: 9003         	str	r0, [sp, #0xc]
700acb56: 9102         	str	r1, [sp, #0x8]
700acb58: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700acb5a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700acb5c: 9803         	ldr	r0, [sp, #0xc]
700acb5e: 21bf         	movs	r1, #0xbf
700acb60: f7fe f81e    	bl	0x700aaba0 <UART_regConfigModeEnable> @ imm = #-0x1fc4
700acb64: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_HW_FLOW_CONTROL, hwFlowCtrl);
700acb66: 9803         	ldr	r0, [sp, #0xc]
700acb68: 3008         	adds	r0, #0x8
700acb6a: 9b02         	ldr	r3, [sp, #0x8]
700acb6c: 21c0         	movs	r1, #0xc0
700acb6e: 2206         	movs	r2, #0x6
700acb70: f7ff ffae    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #-0xa4
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700acb74: 9803         	ldr	r0, [sp, #0xc]
700acb76: 300c         	adds	r0, #0xc
700acb78: 9901         	ldr	r1, [sp, #0x4]
700acb7a: f001 fa39    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x1472
; }
700acb7e: b004         	add	sp, #0x10
700acb80: bd80         	pop	{r7, pc}
		...
700acb8e: 0000         	movs	r0, r0

700acb90 <tm_semaphore_create>:
; {
700acb90: b5b0         	push	{r4, r5, r7, lr}
700acb92: 4605         	mov	r5, r0
;    tm_semaphore_array[semaphore_id] = xSemaphoreCreateBinary();
700acb94: 2001         	movs	r0, #0x1
700acb96: 2100         	movs	r1, #0x0
700acb98: 2203         	movs	r2, #0x3
700acb9a: 2401         	movs	r4, #0x1
700acb9c: f7fe f9b0    	bl	0x700aaf00 <xQueueGenericCreate> @ imm = #-0x1ca0
700acba0: f644 51a4    	movw	r1, #0x4da4
700acba4: f2c7 0108    	movt	r1, #0x7008
700acba8: f841 0025    	str.w	r0, [r1, r5, lsl #2]
;    if (tm_semaphore_array[semaphore_id] == NULL)
700acbac: b138         	cbz	r0, 0x700acbbe <tm_semaphore_create+0x2e> @ imm = #0xe
;    status = xSemaphoreGive(tm_semaphore_array[semaphore_id]);
700acbae: 2100         	movs	r1, #0x0
700acbb0: 2200         	movs	r2, #0x0
700acbb2: 2300         	movs	r3, #0x0
700acbb4: f7f4 fea4    	bl	0x700a1900 <xQueueGenericSend> @ imm = #-0xb2b8
;    if (status != pdTRUE)
700acbb8: 1e44         	subs	r4, r0, #0x1
700acbba: bf18         	it	ne
700acbbc: 2401         	movne	r4, #0x1
; }
700acbbe: 4620         	mov	r0, r4
700acbc0: bdb0         	pop	{r4, r5, r7, pc}
		...
700acbce: 0000         	movs	r0, r0

700acbd0 <vTaskEnterCritical>:
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700acbd0: b672         	cpsid i
;   if (xSchedulerRunning != pdFALSE) {
700acbd2: f640 50f0    	movw	r0, #0xdf0
700acbd6: f2c7 000b    	movt	r0, #0x700b
700acbda: 6800         	ldr	r0, [r0]
700acbdc: b178         	cbz	r0, 0x700acbfe <vTaskEnterCritical+0x2e> @ imm = #0x1e
700acbde: e7ff         	b	0x700acbe0 <vTaskEnterCritical+0x10> @ imm = #-0x2
;     (pxCurrentTCB->uxCriticalNesting)++;
700acbe0: f640 50ac    	movw	r0, #0xdac
700acbe4: f2c7 000b    	movt	r0, #0x700b
700acbe8: 6802         	ldr	r2, [r0]
700acbea: 6d51         	ldr	r1, [r2, #0x54]
700acbec: 3101         	adds	r1, #0x1
700acbee: 6551         	str	r1, [r2, #0x54]
;     if (pxCurrentTCB->uxCriticalNesting == 1) {
700acbf0: 6800         	ldr	r0, [r0]
700acbf2: 6d40         	ldr	r0, [r0, #0x54]
700acbf4: 2801         	cmp	r0, #0x1
700acbf6: d101         	bne	0x700acbfc <vTaskEnterCritical+0x2c> @ imm = #0x2
700acbf8: e7ff         	b	0x700acbfa <vTaskEnterCritical+0x2a> @ imm = #-0x2
;     }
700acbfa: e7ff         	b	0x700acbfc <vTaskEnterCritical+0x2c> @ imm = #-0x2
;   } else {
700acbfc: e000         	b	0x700acc00 <vTaskEnterCritical+0x30> @ imm = #0x0
700acbfe: e7ff         	b	0x700acc00 <vTaskEnterCritical+0x30> @ imm = #-0x2
; }
700acc00: 4770         	bx	lr
		...
700acc0e: 0000         	movs	r0, r0

700acc10 <xQueueCreateMutexStatic>:
;     {
700acc10: b580         	push	{r7, lr}
700acc12: b086         	sub	sp, #0x18
700acc14: f88d 0017    	strb.w	r0, [sp, #0x17]
700acc18: 9104         	str	r1, [sp, #0x10]
700acc1a: 2001         	movs	r0, #0x1
;         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
700acc1c: 9002         	str	r0, [sp, #0x8]
700acc1e: 2200         	movs	r2, #0x0
700acc20: 9201         	str	r2, [sp, #0x4]
;         ( void ) ucQueueType;
700acc22: f89d 1017    	ldrb.w	r1, [sp, #0x17]
;         xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
700acc26: 9b04         	ldr	r3, [sp, #0x10]
700acc28: 46ec         	mov	r12, sp
700acc2a: f8cc 1000    	str.w	r1, [r12]
700acc2e: 4611         	mov	r1, r2
700acc30: f7fe fee6    	bl	0x700aba00 <xQueueGenericCreateStatic> @ imm = #-0x1234
700acc34: 9003         	str	r0, [sp, #0xc]
;         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
700acc36: 9803         	ldr	r0, [sp, #0xc]
700acc38: f000 fa1a    	bl	0x700ad070 <prvInitialiseMutex> @ imm = #0x434
;         return xNewQueue;
700acc3c: 9803         	ldr	r0, [sp, #0xc]
700acc3e: b006         	add	sp, #0x18
700acc40: bd80         	pop	{r7, pc}
		...
700acc4e: 0000         	movs	r0, r0

700acc50 <CSL_pktdmaGetChanPeerReg>:
; {
700acc50: b510         	push	{r4, lr}
700acc52: b086         	sub	sp, #0x18
700acc54: f8dd c020    	ldr.w	r12, [sp, #0x20]
700acc58: 9005         	str	r0, [sp, #0x14]
700acc5a: 9104         	str	r1, [sp, #0x10]
700acc5c: 9203         	str	r2, [sp, #0xc]
700acc5e: 9302         	str	r3, [sp, #0x8]
;     return CSL_pktdmaAccessChanPeerReg( pCfg, chanIdx, regIdx, pVal, chanDir, (bool)true );
700acc60: 9805         	ldr	r0, [sp, #0x14]
700acc62: 9904         	ldr	r1, [sp, #0x10]
700acc64: 9a02         	ldr	r2, [sp, #0x8]
700acc66: 9b08         	ldr	r3, [sp, #0x20]
700acc68: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700acc6c: 46ee         	mov	lr, sp
700acc6e: 2401         	movs	r4, #0x1
700acc70: f8ce 4004    	str.w	r4, [lr, #0x4]
700acc74: f8ce c000    	str.w	r12, [lr]
700acc78: f7f9 f87a    	bl	0x700a5d70 <CSL_pktdmaAccessChanPeerReg> @ imm = #-0x6f0c
700acc7c: b006         	add	sp, #0x18
700acc7e: bd10         	pop	{r4, pc}

700acc80 <CSL_pktdmaSetChanPeerReg>:
; {
700acc80: b510         	push	{r4, lr}
700acc82: b086         	sub	sp, #0x18
700acc84: f8dd c020    	ldr.w	r12, [sp, #0x20]
700acc88: 9005         	str	r0, [sp, #0x14]
700acc8a: 9104         	str	r1, [sp, #0x10]
700acc8c: 9203         	str	r2, [sp, #0xc]
700acc8e: 9302         	str	r3, [sp, #0x8]
;     return CSL_pktdmaAccessChanPeerReg( pCfg, chanIdx, regIdx, pVal, chanDir, (bool)false );
700acc90: 9805         	ldr	r0, [sp, #0x14]
700acc92: 9904         	ldr	r1, [sp, #0x10]
700acc94: 9a02         	ldr	r2, [sp, #0x8]
700acc96: 9b08         	ldr	r3, [sp, #0x20]
700acc98: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700acc9c: 46ee         	mov	lr, sp
700acc9e: 2400         	movs	r4, #0x0
700acca0: f8ce 4004    	str.w	r4, [lr, #0x4]
700acca4: f8ce c000    	str.w	r12, [lr]
700acca8: f7f9 f862    	bl	0x700a5d70 <CSL_pktdmaAccessChanPeerReg> @ imm = #-0x6f3c
700accac: b006         	add	sp, #0x18
700accae: bd10         	pop	{r4, pc}

700accb0 <UART_flowCtrlTrigLvlConfig>:
; {
700accb0: b580         	push	{r7, lr}
700accb2: b084         	sub	sp, #0x10
700accb4: 9003         	str	r0, [sp, #0xc]
700accb6: 9102         	str	r1, [sp, #0x8]
700accb8: 9201         	str	r2, [sp, #0x4]
700accba: 2000         	movs	r0, #0x0
;     uint32_t tcrValue = 0;
700accbc: 9000         	str	r0, [sp]
;     tcrValue = rtsHaltFlag & UART_TCR_RX_FIFO_TRIG_HALT_MASK;
700accbe: 9802         	ldr	r0, [sp, #0x8]
700accc0: f000 000f    	and	r0, r0, #0xf
700accc4: 9000         	str	r0, [sp]
;     tcrValue |= (rtsStartFlag <<
700accc6: 9801         	ldr	r0, [sp, #0x4]
700accc8: 0100         	lsls	r0, r0, #0x4
;                  UART_TCR_RX_FIFO_TRIG_START_SHIFT) &
700accca: b2c1         	uxtb	r1, r0
;     tcrValue |= (rtsStartFlag <<
700acccc: 9800         	ldr	r0, [sp]
700accce: 4308         	orrs	r0, r1
700accd0: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_TCR, tcrValue);
700accd2: 9803         	ldr	r0, [sp, #0xc]
700accd4: 3018         	adds	r0, #0x18
700accd6: 9900         	ldr	r1, [sp]
700accd8: f001 f98a    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x1314
; }
700accdc: b004         	add	sp, #0x10
700accde: bd80         	pop	{r7, pc}

700acce0 <CycleCounterP_getCount32>:
;         MRC     p15, #0, r0, c9, c13, 0  // read PMCCNTR
700acce0: ee190f1d     	mrc	p15, #0x0, r0, c9, c13, #0x0
;         bx      LR
700acce4: e12fff1e     	bx	lr

700acce8 <PmuP_setup>:
;         MCR     p15, #0, r0, c9, c12, 0 // write PMCR
700acce8: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;         bx      LR
700accec: e12fff1e     	bx	lr

700accf0 <PmuP_enableCounters>:
;         MCR     p15, #0, r0, c9, c12, 1  // write PMCNTENSET
700accf0: ee090f3c     	mcr	p15, #0x0, r0, c9, c12, #0x1
;         bx      LR
700accf4: e12fff1e     	bx	lr

700accf8 <PmuP_disableCounters>:
;         MCR     p15, #0, r0, c9, c12, 2  // write PMCNTENCLR
700accf8: ee090f5c     	mcr	p15, #0x0, r0, c9, c12, #0x2
;         bx      LR
700accfc: e12fff1e     	bx	lr

700acd00 <PmuP_getOverflowStatus>:
;         MRC     p15, 0, r0, c9, c12, 3  // read PMOVSR
700acd00: ee190f7c     	mrc	p15, #0x0, r0, c9, c12, #0x3
;         bx      LR
700acd04: e12fff1e     	bx	lr

700acd08 <PmuP_clearOverflowStatus>:
;         MCR     p15, 0, r0, c9, c12, 3  // write PMOVSR
700acd08: ee090f7c     	mcr	p15, #0x0, r0, c9, c12, #0x3
;         bx      LR
700acd0c: e12fff1e     	bx	lr

700acd10 <CSL_secProxyGetMaxMsgSize>:
; {
700acd10: b580         	push	{r7, lr}
700acd12: b082         	sub	sp, #0x8
700acd14: 9001         	str	r0, [sp, #0x4]
;     if( pSecProxyCfg->maxMsgSize == (uint32_t)0U )
700acd16: 9801         	ldr	r0, [sp, #0x4]
700acd18: 6980         	ldr	r0, [r0, #0x18]
700acd1a: b960         	cbnz	r0, 0x700acd36 <CSL_secProxyGetMaxMsgSize+0x26> @ imm = #0x18
700acd1c: e7ff         	b	0x700acd1e <CSL_secProxyGetMaxMsgSize+0xe> @ imm = #-0x2
;         pSecProxyCfg->maxMsgSize = (uint32_t)CSL_REG32_FEXT( &pSecProxyCfg->pSecProxyRegs->CONFIG, SEC_PROXY_CONFIG_MSG_SIZE );
700acd1e: 9801         	ldr	r0, [sp, #0x4]
700acd20: 6800         	ldr	r0, [r0]
700acd22: 3004         	adds	r0, #0x4
700acd24: 2100         	movs	r1, #0x0
700acd26: f6cf 71ff    	movt	r1, #0xffff
700acd2a: 2210         	movs	r2, #0x10
700acd2c: f000 fc58    	bl	0x700ad5e0 <CSL_REG32_FEXT_RAW> @ imm = #0x8b0
700acd30: 9901         	ldr	r1, [sp, #0x4]
700acd32: 6188         	str	r0, [r1, #0x18]
;     }
700acd34: e7ff         	b	0x700acd36 <CSL_secProxyGetMaxMsgSize+0x26> @ imm = #-0x2
;     return pSecProxyCfg->maxMsgSize;
700acd36: 9801         	ldr	r0, [sp, #0x4]
700acd38: 6980         	ldr	r0, [r0, #0x18]
700acd3a: b002         	add	sp, #0x8
700acd3c: bd80         	pop	{r7, pc}
700acd3e: 0000         	movs	r0, r0

700acd40 <Sciclient_rmIaIsIa>:
; {
700acd40: b580         	push	{r7, lr}
700acd42: b082         	sub	sp, #0x8
700acd44: f8ad 0006    	strh.w	r0, [sp, #0x6]
700acd48: 2000         	movs	r0, #0x0
;     bool r = false;
700acd4a: f88d 0005    	strb.w	r0, [sp, #0x5]
;     if (Sciclient_rmIaGetInst(id) != NULL) {
700acd4e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700acd52: f7fd fe05    	bl	0x700aa960 <Sciclient_rmIaGetInst> @ imm = #-0x23f6
700acd56: b120         	cbz	r0, 0x700acd62 <Sciclient_rmIaIsIa+0x22> @ imm = #0x8
700acd58: e7ff         	b	0x700acd5a <Sciclient_rmIaIsIa+0x1a> @ imm = #-0x2
700acd5a: 2001         	movs	r0, #0x1
;         r = true;
700acd5c: f88d 0005    	strb.w	r0, [sp, #0x5]
;     }
700acd60: e7ff         	b	0x700acd62 <Sciclient_rmIaIsIa+0x22> @ imm = #-0x2
;     return r;
700acd62: f89d 0005    	ldrb.w	r0, [sp, #0x5]
700acd66: f000 0001    	and	r0, r0, #0x1
700acd6a: b002         	add	sp, #0x8
700acd6c: bd80         	pop	{r7, pc}
700acd6e: 0000         	movs	r0, r0

700acd70 <Sciclient_rmIrIsIr>:
; {
700acd70: b580         	push	{r7, lr}
700acd72: b082         	sub	sp, #0x8
700acd74: f8ad 0006    	strh.w	r0, [sp, #0x6]
700acd78: 2000         	movs	r0, #0x0
;     bool r = false;
700acd7a: f88d 0005    	strb.w	r0, [sp, #0x5]
;     if (Sciclient_rmIrGetInst(id) != NULL) {
700acd7e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700acd82: f7fd f8cd    	bl	0x700a9f20 <Sciclient_rmIrGetInst> @ imm = #-0x2e66
700acd86: b120         	cbz	r0, 0x700acd92 <Sciclient_rmIrIsIr+0x22> @ imm = #0x8
700acd88: e7ff         	b	0x700acd8a <Sciclient_rmIrIsIr+0x1a> @ imm = #-0x2
700acd8a: 2001         	movs	r0, #0x1
;         r = true;
700acd8c: f88d 0005    	strb.w	r0, [sp, #0x5]
;     }
700acd90: e7ff         	b	0x700acd92 <Sciclient_rmIrIsIr+0x22> @ imm = #-0x2
;     return r;
700acd92: f89d 0005    	ldrb.w	r0, [sp, #0x5]
700acd96: f000 0001    	and	r0, r0, #0x1
700acd9a: b002         	add	sp, #0x8
700acd9c: bd80         	pop	{r7, pc}
700acd9e: 0000         	movs	r0, r0

700acda0 <Sciclient_secProxyReadThread32>:
; {
700acda0: b580         	push	{r7, lr}
700acda2: b084         	sub	sp, #0x10
700acda4: 9003         	str	r0, [sp, #0xc]
700acda6: f88d 100b    	strb.w	r1, [sp, #0xb]
;     ret = CSL_REG32_RD(CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg,thread,0U) +
700acdaa: 9903         	ldr	r1, [sp, #0xc]
700acdac: f640 4078    	movw	r0, #0xc78
700acdb0: f2c7 000b    	movt	r0, #0x700b
700acdb4: 2200         	movs	r2, #0x0
700acdb6: f000 fe1b    	bl	0x700ad9f0 <CSL_secProxyGetDataAddr> @ imm = #0xc36
700acdba: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700acdbe: eb00 0081    	add.w	r0, r0, r1, lsl #2
700acdc2: f001 f96d    	bl	0x700ae0a0 <CSL_REG32_RD_RAW> @ imm = #0x12da
700acdc6: 9001         	str	r0, [sp, #0x4]
;     return ret;
700acdc8: 9801         	ldr	r0, [sp, #0x4]
700acdca: b004         	add	sp, #0x10
700acdcc: bd80         	pop	{r7, pc}
700acdce: 0000         	movs	r0, r0

700acdd0 <System_init>:
; {
700acdd0: b580         	push	{r7, lr}
;     Dpl_init();
700acdd2: f7fe ff2d    	bl	0x700abc30 <Dpl_init>   @ imm = #-0x11a6
;         retVal = Sciclient_init(CSL_CORE_ID_R5FSS0_0);
700acdd6: 2001         	movs	r0, #0x1
700acdd8: f7fa fe7a    	bl	0x700a7ad0 <Sciclient_init> @ imm = #-0x530c
;         DebugP_assertNoLog(SystemP_SUCCESS == retVal);
700acddc: fab0 f080    	clz	r0, r0
700acde0: 0940         	lsrs	r0, r0, #0x5
700acde2: f002 fcad    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x295a
;     CycleCounterP_init(SOC_getSelfCpuClk());
700acde6: f000 fc2b    	bl	0x700ad640 <SOC_getSelfCpuClk> @ imm = #0x856
700acdea: f7f9 fdb9    	bl	0x700a6960 <CycleCounterP_init> @ imm = #-0x648e
;     PowerClock_init();
700acdee: f7fb feaf    	bl	0x700a8b50 <PowerClock_init> @ imm = #-0x42a2
;     Pinmux_init();
700acdf2: f000 fc95    	bl	0x700ad720 <Pinmux_init> @ imm = #0x92a
;     UART_init();
700acdf6: e8bd 4080    	pop.w	{r7, lr}
700acdfa: f7f9 b939    	b.w	0x700a6070 <UART_init>  @ imm = #-0x6d8e
700acdfe: 0000         	movs	r0, r0

700ace00 <_is_digit>:
; {
700ace00: b082         	sub	sp, #0x8
700ace02: f88d 0007    	strb.w	r0, [sp, #0x7]
;   return (ch >= '0') && (ch <= '9');
700ace06: f89d 1007    	ldrb.w	r1, [sp, #0x7]
700ace0a: 2000         	movs	r0, #0x0
700ace0c: 2930         	cmp	r1, #0x30
700ace0e: 9000         	str	r0, [sp]
700ace10: db08         	blt	0x700ace24 <_is_digit+0x24> @ imm = #0x10
700ace12: e7ff         	b	0x700ace14 <_is_digit+0x14> @ imm = #-0x2
700ace14: f89d 1007    	ldrb.w	r1, [sp, #0x7]
700ace18: 2000         	movs	r0, #0x0
700ace1a: 293a         	cmp	r1, #0x3a
700ace1c: bfb8         	it	lt
700ace1e: 2001         	movlt	r0, #0x1
700ace20: 9000         	str	r0, [sp]
700ace22: e7ff         	b	0x700ace24 <_is_digit+0x24> @ imm = #-0x2
700ace24: 9800         	ldr	r0, [sp]
;   return (ch >= '0') && (ch <= '9');
700ace26: f000 0001    	and	r0, r0, #0x1
700ace2a: b002         	add	sp, #0x8
700ace2c: 4770         	bx	lr
700ace2e: 0000         	movs	r0, r0

700ace30 <main_sync>:
; {
700ace30: b580         	push	{r7, lr}
;    printf("[Main] Starting Synchronisation Test.\r\n");
700ace32: f64f 61cb    	movw	r1, #0xfecb
700ace36: 2001         	movs	r0, #0x1
700ace38: f2c7 010a    	movt	r1, #0x700a
700ace3c: f7fb f9b8    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #-0x4c90
;    tm_initialize(task_synchronisation_initialize);
700ace40: f24a 10c1    	movw	r0, #0xa1c1
700ace44: f2c7 000a    	movt	r0, #0x700a
700ace48: f001 f9f2    	bl	0x700ae230 <tm_initialize> @ imm = #0x13e4
;    printf("[Main] tm_initialize returned, threads started.\r\n");
700ace4c: f64f 6114    	movw	r1, #0xfe14
700ace50: 2001         	movs	r0, #0x1
700ace52: f2c7 010a    	movt	r1, #0x700a
700ace56: f7fb f9ab    	bl	0x700a81b0 <_DebugP_logZone> @ imm = #-0x4caa
;    return 0;
700ace5a: 2000         	movs	r0, #0x0
700ace5c: bd80         	pop	{r7, pc}
700ace5e: 0000         	movs	r0, r0

700ace60 <prvIsQueueFull>:
; {
700ace60: b580         	push	{r7, lr}
700ace62: b082         	sub	sp, #0x8
700ace64: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700ace66: f7ff feb3    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #-0x29a
;         if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
700ace6a: 9801         	ldr	r0, [sp, #0x4]
700ace6c: 6b80         	ldr	r0, [r0, #0x38]
700ace6e: 9901         	ldr	r1, [sp, #0x4]
700ace70: 6bc9         	ldr	r1, [r1, #0x3c]
700ace72: 4288         	cmp	r0, r1
700ace74: d103         	bne	0x700ace7e <prvIsQueueFull+0x1e> @ imm = #0x6
700ace76: e7ff         	b	0x700ace78 <prvIsQueueFull+0x18> @ imm = #-0x2
700ace78: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
700ace7a: 9000         	str	r0, [sp]
;         }
700ace7c: e002         	b	0x700ace84 <prvIsQueueFull+0x24> @ imm = #0x4
700ace7e: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
700ace80: 9000         	str	r0, [sp]
700ace82: e7ff         	b	0x700ace84 <prvIsQueueFull+0x24> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700ace84: f7fe ff24    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #-0x11b8
;     return xReturn;
700ace88: 9800         	ldr	r0, [sp]
700ace8a: b002         	add	sp, #0x8
700ace8c: bd80         	pop	{r7, pc}
700ace8e: 0000         	movs	r0, r0

700ace90 <prvTaskCheckFreeStackSpace>:
; prvTaskCheckFreeStackSpace(const uint8_t *pucStackByte) {
700ace90: b082         	sub	sp, #0x8
700ace92: 9001         	str	r0, [sp, #0x4]
700ace94: 2000         	movs	r0, #0x0
;   uint32_t ulCount = 0U;
700ace96: 9000         	str	r0, [sp]
;   while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
700ace98: e7ff         	b	0x700ace9a <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x2
700ace9a: 9801         	ldr	r0, [sp, #0x4]
700ace9c: 7800         	ldrb	r0, [r0]
700ace9e: 28a5         	cmp	r0, #0xa5
700acea0: d107         	bne	0x700aceb2 <prvTaskCheckFreeStackSpace+0x22> @ imm = #0xe
700acea2: e7ff         	b	0x700acea4 <prvTaskCheckFreeStackSpace+0x14> @ imm = #-0x2
;     pucStackByte -= portSTACK_GROWTH;
700acea4: 9801         	ldr	r0, [sp, #0x4]
700acea6: 3001         	adds	r0, #0x1
700acea8: 9001         	str	r0, [sp, #0x4]
;     ulCount++;
700aceaa: 9800         	ldr	r0, [sp]
700aceac: 3001         	adds	r0, #0x1
700aceae: 9000         	str	r0, [sp]
;   while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
700aceb0: e7f3         	b	0x700ace9a <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x1a
;   ulCount /=
700aceb2: 9800         	ldr	r0, [sp]
700aceb4: 0880         	lsrs	r0, r0, #0x2
700aceb6: 9000         	str	r0, [sp]
;   return (configSTACK_DEPTH_TYPE)ulCount;
700aceb8: 9800         	ldr	r0, [sp]
700aceba: b002         	add	sp, #0x8
700acebc: 4770         	bx	lr
700acebe: 0000         	movs	r0, r0

700acec0 <vListInitialise>:
; {
700acec0: b081         	sub	sp, #0x4
700acec2: 9000         	str	r0, [sp]
;     pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700acec4: 9900         	ldr	r1, [sp]
700acec6: f101 0008    	add.w	r0, r1, #0x8
700aceca: 6048         	str	r0, [r1, #0x4]
;     pxList->xListEnd.xItemValue = portMAX_DELAY;
700acecc: 9900         	ldr	r1, [sp]
700acece: f04f 30ff    	mov.w	r0, #0xffffffff
700aced2: 6088         	str	r0, [r1, #0x8]
;     pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700aced4: 9900         	ldr	r1, [sp]
700aced6: f101 0008    	add.w	r0, r1, #0x8
700aceda: 60c8         	str	r0, [r1, #0xc]
;     pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700acedc: 9900         	ldr	r1, [sp]
700acede: f101 0008    	add.w	r0, r1, #0x8
700acee2: 6108         	str	r0, [r1, #0x10]
;     pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
700acee4: 9900         	ldr	r1, [sp]
700acee6: 2000         	movs	r0, #0x0
700acee8: 6008         	str	r0, [r1]
; }
700aceea: b001         	add	sp, #0x4
700aceec: 4770         	bx	lr
700aceee: 0000         	movs	r0, r0

700acef0 <CSL_bcdmaGetRxRT>:
; {
700acef0: b580         	push	{r7, lr}
700acef2: b084         	sub	sp, #0x10
700acef4: 9003         	str	r0, [sp, #0xc]
700acef6: 9102         	str	r1, [sp, #0x8]
700acef8: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_RT, chanIdx, (void *)pRT );
700acefa: 9803         	ldr	r0, [sp, #0xc]
700acefc: 9a02         	ldr	r2, [sp, #0x8]
700acefe: 9b01         	ldr	r3, [sp, #0x4]
700acf00: 2107         	movs	r1, #0x7
700acf02: f7fc fa4d    	bl	0x700a93a0 <CSL_bcdmaDoChanOp> @ imm = #-0x3b66
700acf06: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700acf08: 9800         	ldr	r0, [sp]
700acf0a: b120         	cbz	r0, 0x700acf16 <CSL_bcdmaGetRxRT+0x26> @ imm = #0x8
700acf0c: e7ff         	b	0x700acf0e <CSL_bcdmaGetRxRT+0x1e> @ imm = #-0x2
700acf0e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700acf12: 9000         	str	r0, [sp]
;     }
700acf14: e7ff         	b	0x700acf16 <CSL_bcdmaGetRxRT+0x26> @ imm = #-0x2
;     return retVal;
700acf16: 9800         	ldr	r0, [sp]
700acf18: b004         	add	sp, #0x10
700acf1a: bd80         	pop	{r7, pc}
700acf1c: 0000         	movs	r0, r0
700acf1e: 0000         	movs	r0, r0

700acf20 <CSL_bcdmaGetTxRT>:
; {
700acf20: b580         	push	{r7, lr}
700acf22: b084         	sub	sp, #0x10
700acf24: 9003         	str	r0, [sp, #0xc]
700acf26: 9102         	str	r1, [sp, #0x8]
700acf28: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_RT, chanIdx, (void *)pRT );
700acf2a: 9803         	ldr	r0, [sp, #0xc]
700acf2c: 9a02         	ldr	r2, [sp, #0x8]
700acf2e: 9b01         	ldr	r3, [sp, #0x4]
700acf30: 2107         	movs	r1, #0x7
700acf32: f7fc fa35    	bl	0x700a93a0 <CSL_bcdmaDoChanOp> @ imm = #-0x3b96
700acf36: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700acf38: 9800         	ldr	r0, [sp]
700acf3a: b120         	cbz	r0, 0x700acf46 <CSL_bcdmaGetTxRT+0x26> @ imm = #0x8
700acf3c: e7ff         	b	0x700acf3e <CSL_bcdmaGetTxRT+0x1e> @ imm = #-0x2
700acf3e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700acf42: 9000         	str	r0, [sp]
;     }
700acf44: e7ff         	b	0x700acf46 <CSL_bcdmaGetTxRT+0x26> @ imm = #-0x2
;     return retVal;
700acf46: 9800         	ldr	r0, [sp]
700acf48: b004         	add	sp, #0x10
700acf4a: bd80         	pop	{r7, pc}
700acf4c: 0000         	movs	r0, r0
700acf4e: 0000         	movs	r0, r0

700acf50 <CSL_bcdmaSetRxRT>:
; {
700acf50: b580         	push	{r7, lr}
700acf52: b084         	sub	sp, #0x10
700acf54: 9003         	str	r0, [sp, #0xc]
700acf56: 9102         	str	r1, [sp, #0x8]
700acf58: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_RT, chanIdx, (void *)pRT );
700acf5a: 9803         	ldr	r0, [sp, #0xc]
700acf5c: 9a02         	ldr	r2, [sp, #0x8]
700acf5e: 9b01         	ldr	r3, [sp, #0x4]
700acf60: 2108         	movs	r1, #0x8
700acf62: f7fc fa1d    	bl	0x700a93a0 <CSL_bcdmaDoChanOp> @ imm = #-0x3bc6
700acf66: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700acf68: 9800         	ldr	r0, [sp]
700acf6a: b120         	cbz	r0, 0x700acf76 <CSL_bcdmaSetRxRT+0x26> @ imm = #0x8
700acf6c: e7ff         	b	0x700acf6e <CSL_bcdmaSetRxRT+0x1e> @ imm = #-0x2
700acf6e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700acf72: 9000         	str	r0, [sp]
;     }
700acf74: e7ff         	b	0x700acf76 <CSL_bcdmaSetRxRT+0x26> @ imm = #-0x2
;     return retVal;
700acf76: 9800         	ldr	r0, [sp]
700acf78: b004         	add	sp, #0x10
700acf7a: bd80         	pop	{r7, pc}
700acf7c: 0000         	movs	r0, r0
700acf7e: 0000         	movs	r0, r0

700acf80 <CSL_bcdmaSetTxRT>:
; {
700acf80: b580         	push	{r7, lr}
700acf82: b084         	sub	sp, #0x10
700acf84: 9003         	str	r0, [sp, #0xc]
700acf86: 9102         	str	r1, [sp, #0x8]
700acf88: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_RT, chanIdx, (void *)pRT );
700acf8a: 9803         	ldr	r0, [sp, #0xc]
700acf8c: 9a02         	ldr	r2, [sp, #0x8]
700acf8e: 9b01         	ldr	r3, [sp, #0x4]
700acf90: 2108         	movs	r1, #0x8
700acf92: f7fc fa05    	bl	0x700a93a0 <CSL_bcdmaDoChanOp> @ imm = #-0x3bf6
700acf96: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700acf98: 9800         	ldr	r0, [sp]
700acf9a: b120         	cbz	r0, 0x700acfa6 <CSL_bcdmaSetTxRT+0x26> @ imm = #0x8
700acf9c: e7ff         	b	0x700acf9e <CSL_bcdmaSetTxRT+0x1e> @ imm = #-0x2
700acf9e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700acfa2: 9000         	str	r0, [sp]
;     }
700acfa4: e7ff         	b	0x700acfa6 <CSL_bcdmaSetTxRT+0x26> @ imm = #-0x2
;     return retVal;
700acfa6: 9800         	ldr	r0, [sp]
700acfa8: b004         	add	sp, #0x10
700acfaa: bd80         	pop	{r7, pc}
700acfac: 0000         	movs	r0, r0
700acfae: 0000         	movs	r0, r0

700acfb0 <DebugP_logZoneEnable>:
; {
700acfb0: b580         	push	{r7, lr}
700acfb2: b084         	sub	sp, #0x10
700acfb4: 9003         	str	r0, [sp, #0xc]
;     oldIntState = HwiP_disable();
700acfb6: f001 ef04    	blx	0x700aedc0 <HwiP_disable> @ imm = #0x1e08
700acfba: 9001         	str	r0, [sp, #0x4]
;     oldZoneMask = gDebugLogZone;
700acfbc: f640 5184    	movw	r1, #0xd84
700acfc0: f2c7 010b    	movt	r1, #0x700b
700acfc4: 6808         	ldr	r0, [r1]
700acfc6: 9002         	str	r0, [sp, #0x8]
;     gDebugLogZone = gDebugLogZone | (logZoneMask);
700acfc8: 6808         	ldr	r0, [r1]
700acfca: 9a03         	ldr	r2, [sp, #0xc]
700acfcc: 4310         	orrs	r0, r2
700acfce: 6008         	str	r0, [r1]
;     HwiP_restore(oldIntState);
700acfd0: 9801         	ldr	r0, [sp, #0x4]
700acfd2: f001 ef16    	blx	0x700aee00 <HwiP_restore> @ imm = #0x1e2c
;     return oldZoneMask;
700acfd6: 9802         	ldr	r0, [sp, #0x8]
700acfd8: b004         	add	sp, #0x10
700acfda: bd80         	pop	{r7, pc}
700acfdc: 0000         	movs	r0, r0
700acfde: 0000         	movs	r0, r0

700acfe0 <Sciclient_getIrAddr>:
; {
700acfe0: b580         	push	{r7, lr}
700acfe2: b084         	sub	sp, #0x10
700acfe4: 9003         	str	r0, [sp, #0xc]
700acfe6: 9102         	str	r1, [sp, #0x8]
;     int_ctrl_reg = (uint32_t *)(addr + Sciclient_rmIrIntControlReg(i));
700acfe8: 9803         	ldr	r0, [sp, #0xc]
700acfea: 9000         	str	r0, [sp]
700acfec: f8bd 0008    	ldrh.w	r0, [sp, #0x8]
700acff0: f000 fef6    	bl	0x700adde0 <Sciclient_rmIrIntControlReg> @ imm = #0xdec
700acff4: 4601         	mov	r1, r0
700acff6: 9800         	ldr	r0, [sp]
700acff8: 4408         	add	r0, r1
700acffa: 9001         	str	r0, [sp, #0x4]
;     int_ctrl_reg = (uint32_t *)AddrTranslateP_getLocalAddr( (uint64_t)int_ctrl_reg);
700acffc: 9801         	ldr	r0, [sp, #0x4]
700acffe: 2100         	movs	r1, #0x0
700ad000: f7f6 fffe    	bl	0x700a4000 <AddrTranslateP_getLocalAddr> @ imm = #-0x9004
700ad004: 9001         	str	r0, [sp, #0x4]
;     return int_ctrl_reg;
700ad006: 9801         	ldr	r0, [sp, #0x4]
700ad008: b004         	add	sp, #0x10
700ad00a: bd80         	pop	{r7, pc}
700ad00c: 0000         	movs	r0, r0
700ad00e: 0000         	movs	r0, r0

700ad010 <TaskP_calcCounterDiff>:
; {
700ad010: b083         	sub	sp, #0xc
700ad012: 9002         	str	r0, [sp, #0x8]
700ad014: 9101         	str	r1, [sp, #0x4]
;     if(cur >= last)
700ad016: 9802         	ldr	r0, [sp, #0x8]
700ad018: 9901         	ldr	r1, [sp, #0x4]
700ad01a: 4288         	cmp	r0, r1
700ad01c: d305         	blo	0x700ad02a <TaskP_calcCounterDiff+0x1a> @ imm = #0xa
700ad01e: e7ff         	b	0x700ad020 <TaskP_calcCounterDiff+0x10> @ imm = #-0x2
;         delta = cur - last;
700ad020: 9802         	ldr	r0, [sp, #0x8]
700ad022: 9901         	ldr	r1, [sp, #0x4]
700ad024: 1a40         	subs	r0, r0, r1
700ad026: 9000         	str	r0, [sp]
;     }
700ad028: e005         	b	0x700ad036 <TaskP_calcCounterDiff+0x26> @ imm = #0xa
;         delta = (  0xFFFFFFFFU - last ) + cur;
700ad02a: 9801         	ldr	r0, [sp, #0x4]
700ad02c: 9902         	ldr	r1, [sp, #0x8]
700ad02e: 43c0         	mvns	r0, r0
700ad030: 4408         	add	r0, r1
700ad032: 9000         	str	r0, [sp]
700ad034: e7ff         	b	0x700ad036 <TaskP_calcCounterDiff+0x26> @ imm = #-0x2
;     return delta;
700ad036: 9800         	ldr	r0, [sp]
700ad038: b003         	add	sp, #0xc
700ad03a: 4770         	bx	lr
700ad03c: 0000         	movs	r0, r0
700ad03e: 0000         	movs	r0, r0

700ad040 <TimerP_clearOverflowInt>:
; {
700ad040: b083         	sub	sp, #0xc
700ad042: 9002         	str	r0, [sp, #0x8]
700ad044: 2002         	movs	r0, #0x2
;     uint32_t value = (0x1U << TIMER_OVF_INT_SHIFT);
700ad046: 9000         	str	r0, [sp]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_STATUS);
700ad048: 9802         	ldr	r0, [sp, #0x8]
700ad04a: 3028         	adds	r0, #0x28
700ad04c: 9001         	str	r0, [sp, #0x4]
;     *addr = value;
700ad04e: 9800         	ldr	r0, [sp]
700ad050: 9901         	ldr	r1, [sp, #0x4]
700ad052: 6008         	str	r0, [r1]
;     if((*addr & value) != 0U)
700ad054: 9801         	ldr	r0, [sp, #0x4]
700ad056: 6800         	ldr	r0, [r0]
700ad058: 9900         	ldr	r1, [sp]
700ad05a: 4208         	tst	r0, r1
700ad05c: d004         	beq	0x700ad068 <TimerP_clearOverflowInt+0x28> @ imm = #0x8
700ad05e: e7ff         	b	0x700ad060 <TimerP_clearOverflowInt+0x20> @ imm = #-0x2
;         *addr = value;
700ad060: 9800         	ldr	r0, [sp]
700ad062: 9901         	ldr	r1, [sp, #0x4]
700ad064: 6008         	str	r0, [r1]
;     }
700ad066: e7ff         	b	0x700ad068 <TimerP_clearOverflowInt+0x28> @ imm = #-0x2
; }
700ad068: b003         	add	sp, #0xc
700ad06a: 4770         	bx	lr
700ad06c: 0000         	movs	r0, r0
700ad06e: 0000         	movs	r0, r0

700ad070 <prvInitialiseMutex>:
;     {
700ad070: b580         	push	{r7, lr}
700ad072: b082         	sub	sp, #0x8
700ad074: 9001         	str	r0, [sp, #0x4]
;         if( pxNewQueue != NULL )
700ad076: 9801         	ldr	r0, [sp, #0x4]
700ad078: b168         	cbz	r0, 0x700ad096 <prvInitialiseMutex+0x26> @ imm = #0x1a
700ad07a: e7ff         	b	0x700ad07c <prvInitialiseMutex+0xc> @ imm = #-0x2
;             pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
700ad07c: 9801         	ldr	r0, [sp, #0x4]
700ad07e: 2300         	movs	r3, #0x0
700ad080: 6083         	str	r3, [r0, #0x8]
;             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
700ad082: 9801         	ldr	r0, [sp, #0x4]
700ad084: 6003         	str	r3, [r0]
;             pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
700ad086: 9801         	ldr	r0, [sp, #0x4]
700ad088: 60c3         	str	r3, [r0, #0xc]
;             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
700ad08a: 9801         	ldr	r0, [sp, #0x4]
700ad08c: 4619         	mov	r1, r3
700ad08e: 461a         	mov	r2, r3
700ad090: f7f4 fc36    	bl	0x700a1900 <xQueueGenericSend> @ imm = #-0xb794
;         }
700ad094: e000         	b	0x700ad098 <prvInitialiseMutex+0x28> @ imm = #0x0
700ad096: e7ff         	b	0x700ad098 <prvInitialiseMutex+0x28> @ imm = #-0x2
;     }
700ad098: b002         	add	sp, #0x8
700ad09a: bd80         	pop	{r7, pc}
700ad09c: 0000         	movs	r0, r0
700ad09e: 0000         	movs	r0, r0

700ad0a0 <pvTaskIncrementMutexHeldCount>:
;   if (pxCurrentTCB != NULL) {
700ad0a0: f640 50ac    	movw	r0, #0xdac
700ad0a4: f2c7 000b    	movt	r0, #0x700b
700ad0a8: 6800         	ldr	r0, [r0]
700ad0aa: b148         	cbz	r0, 0x700ad0c0 <pvTaskIncrementMutexHeldCount+0x20> @ imm = #0x12
700ad0ac: e7ff         	b	0x700ad0ae <pvTaskIncrementMutexHeldCount+0xe> @ imm = #-0x2
;     (pxCurrentTCB->uxMutexesHeld)++;
700ad0ae: f640 50ac    	movw	r0, #0xdac
700ad0b2: f2c7 000b    	movt	r0, #0x700b
700ad0b6: 6801         	ldr	r1, [r0]
700ad0b8: 6e48         	ldr	r0, [r1, #0x64]
700ad0ba: 3001         	adds	r0, #0x1
700ad0bc: 6648         	str	r0, [r1, #0x64]
;   }
700ad0be: e7ff         	b	0x700ad0c0 <pvTaskIncrementMutexHeldCount+0x20> @ imm = #-0x2
;   return pxCurrentTCB;
700ad0c0: f640 50ac    	movw	r0, #0xdac
700ad0c4: f2c7 000b    	movt	r0, #0x700b
700ad0c8: 6800         	ldr	r0, [r0]
700ad0ca: 4770         	bx	lr
700ad0cc: 0000         	movs	r0, r0
700ad0ce: 0000         	movs	r0, r0

700ad0d0 <vApplicationGetIdleTaskMemory>:
;                                    uint32_t *pulIdleTaskStackSize) {
700ad0d0: b083         	sub	sp, #0xc
700ad0d2: 9002         	str	r0, [sp, #0x8]
700ad0d4: 9101         	str	r1, [sp, #0x4]
700ad0d6: 9200         	str	r2, [sp]
;   *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
700ad0d8: 9902         	ldr	r1, [sp, #0x8]
700ad0da: f644 20b0    	movw	r0, #0x4ab0
700ad0de: f2c7 0008    	movt	r0, #0x7008
700ad0e2: 6008         	str	r0, [r1]
;   *ppxIdleTaskStackBuffer = uxIdleTaskStack;
700ad0e4: 9901         	ldr	r1, [sp, #0x4]
700ad0e6: f242 0080    	movw	r0, #0x2080
700ad0ea: f2c7 0008    	movt	r0, #0x7008
700ad0ee: 6008         	str	r0, [r1]
;   *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
700ad0f0: 9900         	ldr	r1, [sp]
700ad0f2: f44f 6080    	mov.w	r0, #0x400
700ad0f6: 6008         	str	r0, [r1]
; }
700ad0f8: b003         	add	sp, #0xc
700ad0fa: 4770         	bx	lr
700ad0fc: 0000         	movs	r0, r0
700ad0fe: 0000         	movs	r0, r0

700ad100 <vApplicationGetTimerTaskMemory>:
;                                     uint32_t *pulTimerTaskStackSize) {
700ad100: b083         	sub	sp, #0xc
700ad102: 9002         	str	r0, [sp, #0x8]
700ad104: 9101         	str	r1, [sp, #0x4]
700ad106: 9200         	str	r2, [sp]
;   *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
700ad108: 9902         	ldr	r1, [sp, #0x8]
700ad10a: f644 3038    	movw	r0, #0x4b38
700ad10e: f2c7 0008    	movt	r0, #0x7008
700ad112: 6008         	str	r0, [r1]
;   *ppxTimerTaskStackBuffer = uxTimerTaskStack;
700ad114: 9901         	ldr	r1, [sp, #0x4]
700ad116: f643 508c    	movw	r0, #0x3d8c
700ad11a: f2c7 0008    	movt	r0, #0x7008
700ad11e: 6008         	str	r0, [r1]
;   *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
700ad120: 9900         	ldr	r1, [sp]
700ad122: f44f 7080    	mov.w	r0, #0x100
700ad126: 6008         	str	r0, [r1]
; }
700ad128: b003         	add	sp, #0xc
700ad12a: 4770         	bx	lr
700ad12c: 0000         	movs	r0, r0
700ad12e: 0000         	movs	r0, r0

700ad130 <writer_task1>:
; {
700ad130: f240 44ff    	movw	r4, #0x4ff
700ad134: f640 55b0    	movw	r5, #0xdb0
700ad138: f2c7 040b    	movt	r4, #0x700b
700ad13c: f2c7 050b    	movt	r5, #0x700b
;       tm_semaphore_wait(SEM_A);
700ad140: f04f 0001    	mov.w	r0, #0x1
700ad144: f000 fc24    	bl	0x700ad990 <tm_semaphore_wait> @ imm = #0x848
;       tm_pmu_profile_end("SEM_A_perf");
700ad148: 4620         	mov	r0, r4
700ad14a: f001 f851    	bl	0x700ae1f0 <tm_pmu_profile_end> @ imm = #0x10a2
;       task1_counter++;
700ad14e: 6828         	ldr	r0, [r5]
700ad150: 3001         	adds	r0, #0x1
700ad152: 6028         	str	r0, [r5]
;       tm_semaphore_put(SEM_B);
700ad154: 2002         	movs	r0, #0x2
700ad156: f000 fb6b    	bl	0x700ad830 <tm_semaphore_put> @ imm = #0x6d6
;    while (1)
700ad15a: e7f1         	b	0x700ad140 <writer_task1+0x10> @ imm = #-0x1e
700ad15c: 0000         	movs	r0, r0
700ad15e: 0000         	movs	r0, r0

700ad160 <writer_task2>:
; {
700ad160: f640 55b4    	movw	r5, #0xdb4
700ad164: f240 44ff    	movw	r4, #0x4ff
700ad168: f2c7 050b    	movt	r5, #0x700b
700ad16c: f2c7 040b    	movt	r4, #0x700b
;       tm_semaphore_wait(SEM_B);
700ad170: f04f 0002    	mov.w	r0, #0x2
700ad174: f000 fc0c    	bl	0x700ad990 <tm_semaphore_wait> @ imm = #0x818
;       task2_counter++;
700ad178: 6828         	ldr	r0, [r5]
700ad17a: 3001         	adds	r0, #0x1
700ad17c: 6028         	str	r0, [r5]
;       tm_pmu_profile_start("SEM_A_perf");
700ad17e: 4620         	mov	r0, r4
700ad180: f001 f846    	bl	0x700ae210 <tm_pmu_profile_start> @ imm = #0x108c
;       tm_semaphore_put(SEM_A);
700ad184: 2001         	movs	r0, #0x1
700ad186: f000 fb53    	bl	0x700ad830 <tm_semaphore_put> @ imm = #0x6a6
;    while (1)
700ad18a: e7f1         	b	0x700ad170 <writer_task2+0x10> @ imm = #-0x1e
700ad18c: 0000         	movs	r0, r0
700ad18e: 0000         	movs	r0, r0

700ad190 <Sciclient_rmParamIsValid>:
; {
700ad190: b083         	sub	sp, #0xc
700ad192: 9002         	str	r0, [sp, #0x8]
700ad194: 9101         	str	r1, [sp, #0x4]
700ad196: 2000         	movs	r0, #0x0
;     bool r = false;
700ad198: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((valid_params & param_mask) != 0) {
700ad19c: 9802         	ldr	r0, [sp, #0x8]
700ad19e: 9901         	ldr	r1, [sp, #0x4]
700ad1a0: 4208         	tst	r0, r1
700ad1a2: d004         	beq	0x700ad1ae <Sciclient_rmParamIsValid+0x1e> @ imm = #0x8
700ad1a4: e7ff         	b	0x700ad1a6 <Sciclient_rmParamIsValid+0x16> @ imm = #-0x2
700ad1a6: 2001         	movs	r0, #0x1
;         r = true;
700ad1a8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ad1ac: e7ff         	b	0x700ad1ae <Sciclient_rmParamIsValid+0x1e> @ imm = #-0x2
;     return r;
700ad1ae: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ad1b2: f000 0001    	and	r0, r0, #0x1
700ad1b6: b003         	add	sp, #0xc
700ad1b8: 4770         	bx	lr
700ad1ba: 0000         	movs	r0, r0
700ad1bc: 0000         	movs	r0, r0
700ad1be: 0000         	movs	r0, r0

700ad1c0 <Sciclient_rmPsIsEmpty>:
; {
700ad1c0: b081         	sub	sp, #0x4
700ad1c2: 2001         	movs	r0, #0x1
;     bool e = true;
700ad1c4: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if (gPstack.psp != 0) {
700ad1c8: f241 0058    	movw	r0, #0x1058
700ad1cc: f2c7 0008    	movt	r0, #0x7008
700ad1d0: 8c80         	ldrh	r0, [r0, #0x24]
700ad1d2: b120         	cbz	r0, 0x700ad1de <Sciclient_rmPsIsEmpty+0x1e> @ imm = #0x8
700ad1d4: e7ff         	b	0x700ad1d6 <Sciclient_rmPsIsEmpty+0x16> @ imm = #-0x2
700ad1d6: 2000         	movs	r0, #0x0
;         e = false;
700ad1d8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ad1dc: e7ff         	b	0x700ad1de <Sciclient_rmPsIsEmpty+0x1e> @ imm = #-0x2
;     return e;
700ad1de: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ad1e2: f000 0001    	and	r0, r0, #0x1
700ad1e6: b001         	add	sp, #0x4
700ad1e8: 4770         	bx	lr
700ad1ea: 0000         	movs	r0, r0
700ad1ec: 0000         	movs	r0, r0
700ad1ee: 0000         	movs	r0, r0

700ad1f0 <UART_Transaction_init>:
; {
700ad1f0: b081         	sub	sp, #0x4
700ad1f2: 9000         	str	r0, [sp]
;     if(trans != NULL)
700ad1f4: 9800         	ldr	r0, [sp]
700ad1f6: b170         	cbz	r0, 0x700ad216 <UART_Transaction_init+0x26> @ imm = #0x1c
700ad1f8: e7ff         	b	0x700ad1fa <UART_Transaction_init+0xa> @ imm = #-0x2
;         trans->buf              = NULL;
700ad1fa: 9900         	ldr	r1, [sp]
700ad1fc: 2000         	movs	r0, #0x0
700ad1fe: 6008         	str	r0, [r1]
;         trans->count            = 0U;
700ad200: 9900         	ldr	r1, [sp]
700ad202: 6048         	str	r0, [r1, #0x4]
;         trans->timeout          = SystemP_WAIT_FOREVER;
700ad204: 9a00         	ldr	r2, [sp]
700ad206: f04f 31ff    	mov.w	r1, #0xffffffff
700ad20a: 6091         	str	r1, [r2, #0x8]
;         trans->status           = UART_STATUS_SUCCESS;
700ad20c: 9900         	ldr	r1, [sp]
700ad20e: 60c8         	str	r0, [r1, #0xc]
;         trans->args             = NULL;
700ad210: 9900         	ldr	r1, [sp]
700ad212: 6108         	str	r0, [r1, #0x10]
;     }
700ad214: e7ff         	b	0x700ad216 <UART_Transaction_init+0x26> @ imm = #-0x2
; }
700ad216: b001         	add	sp, #0x4
700ad218: 4770         	bx	lr
700ad21a: 0000         	movs	r0, r0
700ad21c: 0000         	movs	r0, r0
700ad21e: 0000         	movs	r0, r0

700ad220 <UART_intr2Disable>:
; {
700ad220: b580         	push	{r7, lr}
700ad222: b084         	sub	sp, #0x10
700ad224: 9003         	str	r0, [sp, #0xc]
700ad226: 9102         	str	r1, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_IER2, HW_RD_REG32(baseAddr + UART_IER2) &
700ad228: 9803         	ldr	r0, [sp, #0xc]
700ad22a: 306c         	adds	r0, #0x6c
700ad22c: 9001         	str	r0, [sp, #0x4]
700ad22e: f000 fed7    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0xdae
700ad232: 4601         	mov	r1, r0
700ad234: 9801         	ldr	r0, [sp, #0x4]
700ad236: 9b02         	ldr	r3, [sp, #0x8]
700ad238: f06f 0203    	mvn	r2, #0x3
700ad23c: ea62 0203    	orn	r2, r2, r3
700ad240: 4011         	ands	r1, r2
700ad242: f000 fed5    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0xdaa
; }
700ad246: b004         	add	sp, #0x10
700ad248: bd80         	pop	{r7, pc}
700ad24a: 0000         	movs	r0, r0
700ad24c: 0000         	movs	r0, r0
700ad24e: 0000         	movs	r0, r0

700ad250 <UART_lld_Transaction_init>:
; {
700ad250: b081         	sub	sp, #0x4
700ad252: 9000         	str	r0, [sp]
;     if(trans != NULL)
700ad254: 9800         	ldr	r0, [sp]
700ad256: b170         	cbz	r0, 0x700ad276 <UART_lld_Transaction_init+0x26> @ imm = #0x1c
700ad258: e7ff         	b	0x700ad25a <UART_lld_Transaction_init+0xa> @ imm = #-0x2
;         trans->buf              = NULL;
700ad25a: 9900         	ldr	r1, [sp]
700ad25c: 2000         	movs	r0, #0x0
700ad25e: 6008         	str	r0, [r1]
;         trans->count            = 0U;
700ad260: 9900         	ldr	r1, [sp]
700ad262: 6048         	str	r0, [r1, #0x4]
;         trans->timeout          = UART_WAIT_FOREVER;
700ad264: 9a00         	ldr	r2, [sp]
700ad266: f04f 31ff    	mov.w	r1, #0xffffffff
700ad26a: 6091         	str	r1, [r2, #0x8]
;         trans->status           = UART_STATUS_SUCCESS;
700ad26c: 9900         	ldr	r1, [sp]
700ad26e: 60c8         	str	r0, [r1, #0xc]
;         trans->args             = NULL;
700ad270: 9900         	ldr	r1, [sp]
700ad272: 6108         	str	r0, [r1, #0x10]
;     }
700ad274: e7ff         	b	0x700ad276 <UART_lld_Transaction_init+0x26> @ imm = #-0x2
; }
700ad276: b001         	add	sp, #0x4
700ad278: 4770         	bx	lr
700ad27a: 0000         	movs	r0, r0
700ad27c: 0000         	movs	r0, r0
700ad27e: 0000         	movs	r0, r0

700ad280 <UART_lld_dmaWrite>:
; {
700ad280: b580         	push	{r7, lr}
700ad282: b084         	sub	sp, #0x10
700ad284: 9003         	str	r0, [sp, #0xc]
700ad286: 9102         	str	r1, [sp, #0x8]
700ad288: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700ad28a: 9001         	str	r0, [sp, #0x4]
;     status = UART_udmaConfigPdmaTx(hUart, transaction);
700ad28c: 9803         	ldr	r0, [sp, #0xc]
700ad28e: 9902         	ldr	r1, [sp, #0x8]
700ad290: f7f7 fac6    	bl	0x700a4820 <UART_udmaConfigPdmaTx> @ imm = #-0x8a74
700ad294: 9001         	str	r0, [sp, #0x4]
;     if (status != UDMA_SOK)
700ad296: 9801         	ldr	r0, [sp, #0x4]
700ad298: b120         	cbz	r0, 0x700ad2a4 <UART_lld_dmaWrite+0x24> @ imm = #0x8
700ad29a: e7ff         	b	0x700ad29c <UART_lld_dmaWrite+0x1c> @ imm = #-0x2
700ad29c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ad2a0: 9001         	str	r0, [sp, #0x4]
;     }
700ad2a2: e7ff         	b	0x700ad2a4 <UART_lld_dmaWrite+0x24> @ imm = #-0x2
;     return status;
700ad2a4: 9801         	ldr	r0, [sp, #0x4]
700ad2a6: b004         	add	sp, #0x10
700ad2a8: bd80         	pop	{r7, pc}
700ad2aa: 0000         	movs	r0, r0
700ad2ac: 0000         	movs	r0, r0
700ad2ae: 0000         	movs	r0, r0

700ad2b0 <UART_operatingModeSelect>:
; {
700ad2b0: b580         	push	{r7, lr}
700ad2b2: b084         	sub	sp, #0x10
700ad2b4: 9003         	str	r0, [sp, #0xc]
700ad2b6: 9102         	str	r1, [sp, #0x8]
;     operMode = HW_RD_REG32(baseAddr + UART_MDR1) & UART_MDR1_MODE_SELECT_MASK;
700ad2b8: 9803         	ldr	r0, [sp, #0xc]
700ad2ba: 3020         	adds	r0, #0x20
700ad2bc: f000 fe90    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0xd20
700ad2c0: f000 0007    	and	r0, r0, #0x7
700ad2c4: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_MDR1, UART_MDR1_MODE_SELECT,
700ad2c6: 9803         	ldr	r0, [sp, #0xc]
700ad2c8: 3020         	adds	r0, #0x20
700ad2ca: 9b02         	ldr	r3, [sp, #0x8]
700ad2cc: 2107         	movs	r1, #0x7
700ad2ce: 2200         	movs	r2, #0x0
700ad2d0: f7ff fbfe    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #-0x804
;     return operMode;
700ad2d4: 9801         	ldr	r0, [sp, #0x4]
700ad2d6: b004         	add	sp, #0x10
700ad2d8: bd80         	pop	{r7, pc}
700ad2da: 0000         	movs	r0, r0
700ad2dc: 0000         	movs	r0, r0
700ad2de: 0000         	movs	r0, r0

700ad2e0 <Udma_eventProgramSteering>:
; {
700ad2e0: b084         	sub	sp, #0x10
700ad2e2: 9003         	str	r0, [sp, #0xc]
700ad2e4: 9102         	str	r1, [sp, #0x8]
;     eventPrms = &eventHandle->eventPrms;
700ad2e6: 9802         	ldr	r0, [sp, #0x8]
700ad2e8: 3008         	adds	r0, #0x8
700ad2ea: 9000         	str	r0, [sp]
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
700ad2ec: 9800         	ldr	r0, [sp]
700ad2ee: 6800         	ldr	r0, [r0]
700ad2f0: 2803         	cmp	r0, #0x3
700ad2f2: d108         	bne	0x700ad306 <Udma_eventProgramSteering+0x26> @ imm = #0x10
700ad2f4: e7ff         	b	0x700ad2f6 <Udma_eventProgramSteering+0x16> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
700ad2f6: 9800         	ldr	r0, [sp]
700ad2f8: 6880         	ldr	r0, [r0, #0x8]
700ad2fa: 9001         	str	r0, [sp, #0x4]
;         chHandle->chOesAllocDone = TRUE;
700ad2fc: 9901         	ldr	r1, [sp, #0x4]
700ad2fe: 2001         	movs	r0, #0x1
700ad300: f8c1 0248    	str.w	r0, [r1, #0x248]
;     }
700ad304: e7ff         	b	0x700ad306 <Udma_eventProgramSteering+0x26> @ imm = #-0x2
;     return;
700ad306: b004         	add	sp, #0x10
700ad308: 4770         	bx	lr
700ad30a: 0000         	movs	r0, r0
700ad30c: 0000         	movs	r0, r0
700ad30e: 0000         	movs	r0, r0

700ad310 <Udma_eventResetSteering>:
; {
700ad310: b084         	sub	sp, #0x10
700ad312: 9003         	str	r0, [sp, #0xc]
700ad314: 9102         	str	r1, [sp, #0x8]
;     eventPrms = &eventHandle->eventPrms;
700ad316: 9802         	ldr	r0, [sp, #0x8]
700ad318: 3008         	adds	r0, #0x8
700ad31a: 9000         	str	r0, [sp]
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
700ad31c: 9800         	ldr	r0, [sp]
700ad31e: 6800         	ldr	r0, [r0]
700ad320: 2803         	cmp	r0, #0x3
700ad322: d108         	bne	0x700ad336 <Udma_eventResetSteering+0x26> @ imm = #0x10
700ad324: e7ff         	b	0x700ad326 <Udma_eventResetSteering+0x16> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
700ad326: 9800         	ldr	r0, [sp]
700ad328: 6880         	ldr	r0, [r0, #0x8]
700ad32a: 9001         	str	r0, [sp, #0x4]
;         chHandle->chOesAllocDone = FALSE;
700ad32c: 9901         	ldr	r1, [sp, #0x4]
700ad32e: 2000         	movs	r0, #0x0
700ad330: f8c1 0248    	str.w	r0, [r1, #0x248]
;     }
700ad334: e7ff         	b	0x700ad336 <Udma_eventResetSteering+0x26> @ imm = #-0x2
;     return;
700ad336: b004         	add	sp, #0x10
700ad338: 4770         	bx	lr
700ad33a: 0000         	movs	r0, r0
700ad33c: 0000         	movs	r0, r0
700ad33e: 0000         	movs	r0, r0

700ad340 <Sciclient_secProxyVerifyThread>:
; {
700ad340: b580         	push	{r7, lr}
700ad342: b082         	sub	sp, #0x8
700ad344: 9001         	str	r0, [sp, #0x4]
700ad346: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700ad348: 9000         	str	r0, [sp]
;     if ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ad34a: 9801         	ldr	r0, [sp, #0x4]
700ad34c: f000 fc00    	bl	0x700adb50 <Sciclient_secProxyThreadStatusReg> @ imm = #0x800
700ad350: f000 fea6    	bl	0x700ae0a0 <CSL_REG32_RD_RAW> @ imm = #0xd4c
700ad354: 0fc0         	lsrs	r0, r0, #0x1f
700ad356: b120         	cbz	r0, 0x700ad362 <Sciclient_secProxyVerifyThread+0x22> @ imm = #0x8
700ad358: e7ff         	b	0x700ad35a <Sciclient_secProxyVerifyThread+0x1a> @ imm = #-0x2
700ad35a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700ad35e: 9000         	str	r0, [sp]
;     }
700ad360: e7ff         	b	0x700ad362 <Sciclient_secProxyVerifyThread+0x22> @ imm = #-0x2
;     return status;
700ad362: 9800         	ldr	r0, [sp]
700ad364: b002         	add	sp, #0x8
700ad366: bd80         	pop	{r7, pc}
		...

700ad370 <prvIsQueueEmpty>:
; {
700ad370: b580         	push	{r7, lr}
700ad372: b082         	sub	sp, #0x8
700ad374: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700ad376: f7ff fc2b    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #-0x7aa
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
700ad37a: 9801         	ldr	r0, [sp, #0x4]
700ad37c: 6b80         	ldr	r0, [r0, #0x38]
700ad37e: b918         	cbnz	r0, 0x700ad388 <prvIsQueueEmpty+0x18> @ imm = #0x6
700ad380: e7ff         	b	0x700ad382 <prvIsQueueEmpty+0x12> @ imm = #-0x2
700ad382: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
700ad384: 9000         	str	r0, [sp]
;         }
700ad386: e002         	b	0x700ad38e <prvIsQueueEmpty+0x1e> @ imm = #0x4
700ad388: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
700ad38a: 9000         	str	r0, [sp]
700ad38c: e7ff         	b	0x700ad38e <prvIsQueueEmpty+0x1e> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700ad38e: f7fe fc9f    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #-0x16c2
;     return xReturn;
700ad392: 9800         	ldr	r0, [sp]
700ad394: b002         	add	sp, #0x8
700ad396: bd80         	pop	{r7, pc}
		...

700ad3a0 <vQueueDelete>:
; {
700ad3a0: b580         	push	{r7, lr}
700ad3a2: b082         	sub	sp, #0x8
700ad3a4: 9001         	str	r0, [sp, #0x4]
;     Queue_t * const pxQueue = xQueue;
700ad3a6: 9801         	ldr	r0, [sp, #0x4]
700ad3a8: 9000         	str	r0, [sp]
;             vQueueUnregisterQueue( pxQueue );
700ad3aa: 9800         	ldr	r0, [sp]
700ad3ac: f7fd ffe0    	bl	0x700ab370 <vQueueUnregisterQueue> @ imm = #-0x2040
;             if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
700ad3b0: 9800         	ldr	r0, [sp]
700ad3b2: f890 0046    	ldrb.w	r0, [r0, #0x46]
700ad3b6: b920         	cbnz	r0, 0x700ad3c2 <vQueueDelete+0x22> @ imm = #0x8
700ad3b8: e7ff         	b	0x700ad3ba <vQueueDelete+0x1a> @ imm = #-0x2
;                 vPortFree( pxQueue );
700ad3ba: 9800         	ldr	r0, [sp]
700ad3bc: f000 fa48    	bl	0x700ad850 <vPortFree>  @ imm = #0x490
;             }
700ad3c0: e000         	b	0x700ad3c4 <vQueueDelete+0x24> @ imm = #0x0
700ad3c2: e7ff         	b	0x700ad3c4 <vQueueDelete+0x24> @ imm = #-0x2
; }
700ad3c4: b002         	add	sp, #0x8
700ad3c6: bd80         	pop	{r7, pc}
		...

700ad3d0 <vprintf_>:
; {
700ad3d0: b580         	push	{r7, lr}
700ad3d2: b084         	sub	sp, #0x10
700ad3d4: 9103         	str	r1, [sp, #0xc]
700ad3d6: 9002         	str	r0, [sp, #0x8]
;   return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
700ad3d8: 9b02         	ldr	r3, [sp, #0x8]
700ad3da: 9803         	ldr	r0, [sp, #0xc]
700ad3dc: 4669         	mov	r1, sp
700ad3de: 6008         	str	r0, [r1]
700ad3e0: f24d 60c1    	movw	r0, #0xd6c1
700ad3e4: f2c7 000a    	movt	r0, #0x700a
700ad3e8: f10d 0107    	add.w	r1, sp, #0x7
700ad3ec: f04f 32ff    	mov.w	r2, #0xffffffff
700ad3f0: f7eb fd06    	bl	0x70098e00 <_vsnprintf> @ imm = #-0x145f4
700ad3f4: b004         	add	sp, #0x10
700ad3f6: bd80         	pop	{r7, pc}
		...

700ad400 <UART_udmapSetReturnPolicy>:
; {
700ad400: b580         	push	{r7, lr}
700ad402: b086         	sub	sp, #0x18
700ad404: 9005         	str	r0, [sp, #0x14]
700ad406: 9104         	str	r1, [sp, #0x10]
700ad408: 2001         	movs	r0, #0x1
;         uint32_t descType = (uint32_t)CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST;
700ad40a: 9003         	str	r0, [sp, #0xc]
;         CSL_UdmapCppi5HMPD *pHpd = (CSL_UdmapCppi5HMPD *) pHpdMem;
700ad40c: 9804         	ldr	r0, [sp, #0x10]
700ad40e: 9002         	str	r0, [sp, #0x8]
;         pHpd,
700ad410: 9802         	ldr	r0, [sp, #0x8]
;         descType,
700ad412: 9903         	ldr	r1, [sp, #0xc]
;         CSL_udmapCppi5SetReturnPolicy(
700ad414: 466a         	mov	r2, sp
700ad416: 2300         	movs	r3, #0x0
700ad418: 6053         	str	r3, [r2, #0x4]
700ad41a: 6013         	str	r3, [r2]
700ad41c: 461a         	mov	r2, r3
700ad41e: f7fb fbdf    	bl	0x700a8be0 <CSL_udmapCppi5SetReturnPolicy> @ imm = #-0x4842
;         return;
700ad422: b006         	add	sp, #0x18
700ad424: bd80         	pop	{r7, pc}
		...
700ad42e: 0000         	movs	r0, r0

700ad430 <Udma_ringGetForwardRingOcc>:
; {
700ad430: b580         	push	{r7, lr}
700ad432: b084         	sub	sp, #0x10
700ad434: 9003         	str	r0, [sp, #0xc]
700ad436: 2000         	movs	r0, #0x0
;     uint32_t            occ = 0U;
700ad438: 9002         	str	r0, [sp, #0x8]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700ad43a: 9803         	ldr	r0, [sp, #0xc]
700ad43c: 9001         	str	r0, [sp, #0x4]
;     Udma_DrvHandleInt   drvHandle = ringHandleInt->drvHandle;
700ad43e: 9801         	ldr	r0, [sp, #0x4]
700ad440: 6800         	ldr	r0, [r0]
700ad442: 9000         	str	r0, [sp]
;     occ = drvHandle->ringGetForwardRingOcc(ringHandleInt);
700ad444: 9800         	ldr	r0, [sp]
700ad446: f8d0 15a8    	ldr.w	r1, [r0, #0x5a8]
700ad44a: 9801         	ldr	r0, [sp, #0x4]
700ad44c: 4788         	blx	r1
700ad44e: 9002         	str	r0, [sp, #0x8]
;     return (occ);
700ad450: 9802         	ldr	r0, [sp, #0x8]
700ad452: b004         	add	sp, #0x10
700ad454: bd80         	pop	{r7, pc}
		...
700ad45e: 0000         	movs	r0, r0

700ad460 <Udma_ringGetReverseRingOcc>:
; {
700ad460: b580         	push	{r7, lr}
700ad462: b084         	sub	sp, #0x10
700ad464: 9003         	str	r0, [sp, #0xc]
700ad466: 2000         	movs	r0, #0x0
;     uint32_t            occ = 0U;
700ad468: 9002         	str	r0, [sp, #0x8]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700ad46a: 9803         	ldr	r0, [sp, #0xc]
700ad46c: 9001         	str	r0, [sp, #0x4]
;     Udma_DrvHandleInt   drvHandle = ringHandleInt->drvHandle;
700ad46e: 9801         	ldr	r0, [sp, #0x4]
700ad470: 6800         	ldr	r0, [r0]
700ad472: 9000         	str	r0, [sp]
;     occ = drvHandle->ringGetReverseRingOcc(ringHandleInt);
700ad474: 9800         	ldr	r0, [sp]
700ad476: f8d0 15ac    	ldr.w	r1, [r0, #0x5ac]
700ad47a: 9801         	ldr	r0, [sp, #0x4]
700ad47c: 4788         	blx	r1
700ad47e: 9002         	str	r0, [sp, #0x8]
;     return (occ);
700ad480: 9802         	ldr	r0, [sp, #0x8]
700ad482: b004         	add	sp, #0x10
700ad484: bd80         	pop	{r7, pc}
		...
700ad48e: 0000         	movs	r0, r0

700ad490 <_out_buffer>:
; {
700ad490: b084         	sub	sp, #0x10
700ad492: f88d 000f    	strb.w	r0, [sp, #0xf]
700ad496: 9102         	str	r1, [sp, #0x8]
700ad498: 9201         	str	r2, [sp, #0x4]
700ad49a: 9300         	str	r3, [sp]
;   if (idx < maxlen) {
700ad49c: 9801         	ldr	r0, [sp, #0x4]
700ad49e: 9900         	ldr	r1, [sp]
700ad4a0: 4288         	cmp	r0, r1
700ad4a2: d206         	bhs	0x700ad4b2 <_out_buffer+0x22> @ imm = #0xc
700ad4a4: e7ff         	b	0x700ad4a6 <_out_buffer+0x16> @ imm = #-0x2
;     ((char*)buffer)[idx] = character;
700ad4a6: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ad4aa: 9902         	ldr	r1, [sp, #0x8]
700ad4ac: 9a01         	ldr	r2, [sp, #0x4]
700ad4ae: 5488         	strb	r0, [r1, r2]
;   }
700ad4b0: e7ff         	b	0x700ad4b2 <_out_buffer+0x22> @ imm = #-0x2
; }
700ad4b2: b004         	add	sp, #0x10
700ad4b4: 4770         	bx	lr
		...
700ad4be: 0000         	movs	r0, r0

700ad4c0 <prvGetDisinheritPriorityAfterTimeout>:
;     {
700ad4c0: b082         	sub	sp, #0x8
700ad4c2: 9001         	str	r0, [sp, #0x4]
;         if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
700ad4c4: 9801         	ldr	r0, [sp, #0x4]
700ad4c6: 6a40         	ldr	r0, [r0, #0x24]
700ad4c8: b138         	cbz	r0, 0x700ad4da <prvGetDisinheritPriorityAfterTimeout+0x1a> @ imm = #0xe
700ad4ca: e7ff         	b	0x700ad4cc <prvGetDisinheritPriorityAfterTimeout+0xc> @ imm = #-0x2
;             uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
700ad4cc: 9801         	ldr	r0, [sp, #0x4]
700ad4ce: 6b00         	ldr	r0, [r0, #0x30]
700ad4d0: 6800         	ldr	r0, [r0]
700ad4d2: f1c0 0020    	rsb.w	r0, r0, #0x20
700ad4d6: 9000         	str	r0, [sp]
;         }
700ad4d8: e002         	b	0x700ad4e0 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #0x4
700ad4da: 2000         	movs	r0, #0x0
;             uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
700ad4dc: 9000         	str	r0, [sp]
700ad4de: e7ff         	b	0x700ad4e0 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #-0x2
;         return uxHighestPriorityOfWaitingTasks;
700ad4e0: 9800         	ldr	r0, [sp]
700ad4e2: b002         	add	sp, #0x8
700ad4e4: 4770         	bx	lr
		...
700ad4ee: 0000         	movs	r0, r0

700ad4f0 <vTaskPlaceOnEventList>:
;                            const TickType_t xTicksToWait) {
700ad4f0: b580         	push	{r7, lr}
700ad4f2: b082         	sub	sp, #0x8
700ad4f4: 9001         	str	r0, [sp, #0x4]
700ad4f6: 9100         	str	r1, [sp]
;   vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
700ad4f8: 9801         	ldr	r0, [sp, #0x4]
700ad4fa: f640 51ac    	movw	r1, #0xdac
700ad4fe: f2c7 010b    	movt	r1, #0x700b
700ad502: 6809         	ldr	r1, [r1]
700ad504: 3118         	adds	r1, #0x18
700ad506: f7fc fb4b    	bl	0x700a9ba0 <vListInsert> @ imm = #-0x396a
;   prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
700ad50a: 9800         	ldr	r0, [sp]
700ad50c: 2101         	movs	r1, #0x1
700ad50e: f7f7 fb47    	bl	0x700a4ba0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x8972
; }
700ad512: b002         	add	sp, #0x8
700ad514: bd80         	pop	{r7, pc}
		...
700ad51e: 0000         	movs	r0, r0

700ad520 <xQueueCreateMutex>:
;     {
700ad520: b580         	push	{r7, lr}
700ad522: b084         	sub	sp, #0x10
700ad524: f88d 000f    	strb.w	r0, [sp, #0xf]
700ad528: 2001         	movs	r0, #0x1
;         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
700ad52a: 9001         	str	r0, [sp, #0x4]
700ad52c: 2100         	movs	r1, #0x0
700ad52e: 9100         	str	r1, [sp]
;         xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
700ad530: f89d 200f    	ldrb.w	r2, [sp, #0xf]
700ad534: f7fd fce4    	bl	0x700aaf00 <xQueueGenericCreate> @ imm = #-0x2638
700ad538: 9002         	str	r0, [sp, #0x8]
;         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
700ad53a: 9802         	ldr	r0, [sp, #0x8]
700ad53c: f7ff fd98    	bl	0x700ad070 <prvInitialiseMutex> @ imm = #-0x4d0
;         return xNewQueue;
700ad540: 9802         	ldr	r0, [sp, #0x8]
700ad542: b004         	add	sp, #0x10
700ad544: bd80         	pop	{r7, pc}
		...
700ad54e: 0000         	movs	r0, r0

700ad550 <CSL_REG32_FEXT_RAW>:
; {
700ad550: b580         	push	{r7, lr}
700ad552: b084         	sub	sp, #0x10
700ad554: 9003         	str	r0, [sp, #0xc]
700ad556: 9102         	str	r1, [sp, #0x8]
700ad558: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700ad55a: 9803         	ldr	r0, [sp, #0xc]
700ad55c: f000 fd88    	bl	0x700ae070 <CSL_REG32_RD_RAW> @ imm = #0xb10
700ad560: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700ad562: 9800         	ldr	r0, [sp]
700ad564: 9902         	ldr	r1, [sp, #0x8]
700ad566: 4008         	ands	r0, r1
700ad568: 9901         	ldr	r1, [sp, #0x4]
700ad56a: 40c8         	lsrs	r0, r1
700ad56c: 9000         	str	r0, [sp]
;     return (regVal);
700ad56e: 9800         	ldr	r0, [sp]
700ad570: b004         	add	sp, #0x10
700ad572: bd80         	pop	{r7, pc}
		...

700ad580 <CSL_REG32_FEXT_RAW>:
; {
700ad580: b580         	push	{r7, lr}
700ad582: b084         	sub	sp, #0x10
700ad584: 9003         	str	r0, [sp, #0xc]
700ad586: 9102         	str	r1, [sp, #0x8]
700ad588: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700ad58a: 9803         	ldr	r0, [sp, #0xc]
700ad58c: f000 fd78    	bl	0x700ae080 <CSL_REG32_RD_RAW> @ imm = #0xaf0
700ad590: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700ad592: 9800         	ldr	r0, [sp]
700ad594: 9902         	ldr	r1, [sp, #0x8]
700ad596: 4008         	ands	r0, r1
700ad598: 9901         	ldr	r1, [sp, #0x4]
700ad59a: 40c8         	lsrs	r0, r1
700ad59c: 9000         	str	r0, [sp]
;     return (regVal);
700ad59e: 9800         	ldr	r0, [sp]
700ad5a0: b004         	add	sp, #0x10
700ad5a2: bd80         	pop	{r7, pc}
		...

700ad5b0 <CSL_REG32_FEXT_RAW>:
; {
700ad5b0: b580         	push	{r7, lr}
700ad5b2: b084         	sub	sp, #0x10
700ad5b4: 9003         	str	r0, [sp, #0xc]
700ad5b6: 9102         	str	r1, [sp, #0x8]
700ad5b8: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700ad5ba: 9803         	ldr	r0, [sp, #0xc]
700ad5bc: f000 fd68    	bl	0x700ae090 <CSL_REG32_RD_RAW> @ imm = #0xad0
700ad5c0: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700ad5c2: 9800         	ldr	r0, [sp]
700ad5c4: 9902         	ldr	r1, [sp, #0x8]
700ad5c6: 4008         	ands	r0, r1
700ad5c8: 9901         	ldr	r1, [sp, #0x4]
700ad5ca: 40c8         	lsrs	r0, r1
700ad5cc: 9000         	str	r0, [sp]
;     return (regVal);
700ad5ce: 9800         	ldr	r0, [sp]
700ad5d0: b004         	add	sp, #0x10
700ad5d2: bd80         	pop	{r7, pc}
		...

700ad5e0 <CSL_REG32_FEXT_RAW>:
; {
700ad5e0: b580         	push	{r7, lr}
700ad5e2: b084         	sub	sp, #0x10
700ad5e4: 9003         	str	r0, [sp, #0xc]
700ad5e6: 9102         	str	r1, [sp, #0x8]
700ad5e8: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700ad5ea: 9803         	ldr	r0, [sp, #0xc]
700ad5ec: f000 fd58    	bl	0x700ae0a0 <CSL_REG32_RD_RAW> @ imm = #0xab0
700ad5f0: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700ad5f2: 9800         	ldr	r0, [sp]
700ad5f4: 9902         	ldr	r1, [sp, #0x8]
700ad5f6: 4008         	ands	r0, r1
700ad5f8: 9901         	ldr	r1, [sp, #0x4]
700ad5fa: 40c8         	lsrs	r0, r1
700ad5fc: 9000         	str	r0, [sp]
;     return (regVal);
700ad5fe: 9800         	ldr	r0, [sp]
700ad600: b004         	add	sp, #0x10
700ad602: bd80         	pop	{r7, pc}
		...

700ad610 <CSL_REG32_FEXT_RAW>:
; {
700ad610: b580         	push	{r7, lr}
700ad612: b084         	sub	sp, #0x10
700ad614: 9003         	str	r0, [sp, #0xc]
700ad616: 9102         	str	r1, [sp, #0x8]
700ad618: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700ad61a: 9803         	ldr	r0, [sp, #0xc]
700ad61c: f000 fd48    	bl	0x700ae0b0 <CSL_REG32_RD_RAW> @ imm = #0xa90
700ad620: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700ad622: 9800         	ldr	r0, [sp]
700ad624: 9902         	ldr	r1, [sp, #0x8]
700ad626: 4008         	ands	r0, r1
700ad628: 9901         	ldr	r1, [sp, #0x4]
700ad62a: 40c8         	lsrs	r0, r1
700ad62c: 9000         	str	r0, [sp]
;     return (regVal);
700ad62e: 9800         	ldr	r0, [sp]
700ad630: b004         	add	sp, #0x10
700ad632: bd80         	pop	{r7, pc}
		...

700ad640 <SOC_getSelfCpuClk>:
; {
700ad640: b580         	push	{r7, lr}
700ad642: b084         	sub	sp, #0x10
700ad644: 2000         	movs	r0, #0x0
;     uint64_t cpuClockRate = 0U;
700ad646: 9001         	str	r0, [sp, #0x4]
700ad648: 9003         	str	r0, [sp, #0xc]
700ad64a: 9002         	str	r0, [sp, #0x8]
;                     Sciclient_getSelfDevIdCore(),
700ad64c: f000 fd48    	bl	0x700ae0e0 <Sciclient_getSelfDevIdCore> @ imm = #0xa90
700ad650: 9901         	ldr	r1, [sp, #0x4]
700ad652: aa02         	add	r2, sp, #0x8
700ad654: f04f 33ff    	mov.w	r3, #0xffffffff
;     Sciclient_pmGetModuleClkFreq(
700ad658: f7f9 feca    	bl	0x700a73f0 <Sciclient_pmGetModuleClkFreq> @ imm = #-0x626c
;     return cpuClockRate;
700ad65c: 9802         	ldr	r0, [sp, #0x8]
700ad65e: 9903         	ldr	r1, [sp, #0xc]
700ad660: b004         	add	sp, #0x10
700ad662: bd80         	pop	{r7, pc}
		...

700ad670 <UART_IsStopBitsValid>:
; {
700ad670: b082         	sub	sp, #0x8
700ad672: 9001         	str	r0, [sp, #0x4]
700ad674: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ad678: 9000         	str	r0, [sp]
;     if((stopBits == UART_STOPBITS_1) ||
700ad67a: 9801         	ldr	r0, [sp, #0x4]
700ad67c: b120         	cbz	r0, 0x700ad688 <UART_IsStopBitsValid+0x18> @ imm = #0x8
700ad67e: e7ff         	b	0x700ad680 <UART_IsStopBitsValid+0x10> @ imm = #-0x2
;         (stopBits == UART_STOPBITS_2))
700ad680: 9801         	ldr	r0, [sp, #0x4]
;     if((stopBits == UART_STOPBITS_1) ||
700ad682: 2801         	cmp	r0, #0x1
700ad684: d103         	bne	0x700ad68e <UART_IsStopBitsValid+0x1e> @ imm = #0x6
700ad686: e7ff         	b	0x700ad688 <UART_IsStopBitsValid+0x18> @ imm = #-0x2
700ad688: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ad68a: 9000         	str	r0, [sp]
;     }
700ad68c: e7ff         	b	0x700ad68e <UART_IsStopBitsValid+0x1e> @ imm = #-0x2
;     return status;
700ad68e: 9800         	ldr	r0, [sp]
700ad690: b002         	add	sp, #0x8
700ad692: 4770         	bx	lr

700ad694 <__aeabi_uldivmod>:
700ad694: e92d4040     	push	{r6, lr}
700ad698: e24dd010     	sub	sp, sp, #16
700ad69c: e28d6008     	add	r6, sp, #8
700ad6a0: e58d6000     	str	r6, [sp]
700ad6a4: ebffd623     	bl	0x700a2f38 <__udivmoddi4> @ imm = #-0xa774
700ad6a8: e59d2008     	ldr	r2, [sp, #0x8]
700ad6ac: e59d300c     	ldr	r3, [sp, #0xc]
700ad6b0: e28dd010     	add	sp, sp, #16
700ad6b4: e8bd8040     	pop	{r6, pc}
		...

700ad6c0 <_out_char>:
; {
700ad6c0: b580         	push	{r7, lr}
700ad6c2: b084         	sub	sp, #0x10
700ad6c4: f88d 000f    	strb.w	r0, [sp, #0xf]
700ad6c8: 9102         	str	r1, [sp, #0x8]
700ad6ca: 9201         	str	r2, [sp, #0x4]
700ad6cc: 9300         	str	r3, [sp]
;   if (character) {
700ad6ce: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ad6d2: b128         	cbz	r0, 0x700ad6e0 <_out_char+0x20> @ imm = #0xa
700ad6d4: e7ff         	b	0x700ad6d6 <_out_char+0x16> @ imm = #-0x2
;     putchar_(character);
700ad6d6: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ad6da: f000 fbf1    	bl	0x700adec0 <putchar_>   @ imm = #0x7e2
;   }
700ad6de: e7ff         	b	0x700ad6e0 <_out_char+0x20> @ imm = #-0x2
; }
700ad6e0: b004         	add	sp, #0x10
700ad6e2: bd80         	pop	{r7, pc}
		...

700ad6f0 <vTaskInternalSetTimeOutState>:
; void vTaskInternalSetTimeOutState(TimeOut_t *const pxTimeOut) {
700ad6f0: b081         	sub	sp, #0x4
700ad6f2: 9000         	str	r0, [sp]
;   pxTimeOut->xOverflowCount = xNumOfOverflows;
700ad6f4: f640 50e8    	movw	r0, #0xde8
700ad6f8: f2c7 000b    	movt	r0, #0x700b
700ad6fc: 6800         	ldr	r0, [r0]
700ad6fe: 9900         	ldr	r1, [sp]
700ad700: 6008         	str	r0, [r1]
;   pxTimeOut->xTimeOnEntering = xTickCount;
700ad702: f640 50f4    	movw	r0, #0xdf4
700ad706: f2c7 000b    	movt	r0, #0x700b
700ad70a: 6800         	ldr	r0, [r0]
700ad70c: 9900         	ldr	r1, [sp]
700ad70e: 6048         	str	r0, [r1, #0x4]
; }
700ad710: b001         	add	sp, #0x4
700ad712: 4770         	bx	lr
		...

700ad720 <Pinmux_init>:
; {
700ad720: b580         	push	{r7, lr}
;     Pinmux_config(gPinMuxMainDomainCfg, PINMUX_DOMAIN_ID_MAIN);
700ad722: f640 40d0    	movw	r0, #0xcd0
700ad726: 2100         	movs	r1, #0x0
700ad728: f2c7 000b    	movt	r0, #0x700b
700ad72c: f7f9 fd70    	bl	0x700a7210 <Pinmux_config> @ imm = #-0x6520
;     Pinmux_config(gPinMuxMcuDomainCfg, PINMUX_DOMAIN_ID_MCU);
700ad730: f640 5044    	movw	r0, #0xd44
700ad734: 2101         	movs	r1, #0x1
700ad736: f2c7 000b    	movt	r0, #0x700b
700ad73a: e8bd 4080    	pop.w	{r7, lr}
700ad73e: f7f9 bd67    	b.w	0x700a7210 <Pinmux_config> @ imm = #-0x6532
		...
700ad74e: 0000         	movs	r0, r0

700ad750 <Udma_rmTranslateCoreIntrInput>:
; {
700ad750: b083         	sub	sp, #0xc
700ad752: 9002         	str	r0, [sp, #0x8]
700ad754: 9101         	str	r1, [sp, #0x4]
700ad756: 2000         	movs	r0, #0x0
700ad758: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t    irIntrNum = UDMA_INTR_INVALID;
700ad75c: 9000         	str	r0, [sp]
;     if(drvHandle->instType != UDMA_INST_TYPE_NORMAL)
700ad75e: 9802         	ldr	r0, [sp, #0x8]
700ad760: 6800         	ldr	r0, [r0]
700ad762: b118         	cbz	r0, 0x700ad76c <Udma_rmTranslateCoreIntrInput+0x1c> @ imm = #0x6
700ad764: e7ff         	b	0x700ad766 <Udma_rmTranslateCoreIntrInput+0x16> @ imm = #-0x2
;         irIntrNum = coreIntrNum;
700ad766: 9801         	ldr	r0, [sp, #0x4]
700ad768: 9000         	str	r0, [sp]
;     }
700ad76a: e7ff         	b	0x700ad76c <Udma_rmTranslateCoreIntrInput+0x1c> @ imm = #-0x2
;     return (irIntrNum);
700ad76c: 9800         	ldr	r0, [sp]
700ad76e: b003         	add	sp, #0xc
700ad770: 4770         	bx	lr
		...
700ad77e: 0000         	movs	r0, r0

700ad780 <Udma_rmTranslateIrOutput>:
; {
700ad780: b083         	sub	sp, #0xc
700ad782: 9002         	str	r0, [sp, #0x8]
700ad784: 9101         	str	r1, [sp, #0x4]
700ad786: 2000         	movs	r0, #0x0
700ad788: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t    coreIntrNum = UDMA_INTR_INVALID;
700ad78c: 9000         	str	r0, [sp]
;     if(drvHandle->instType != UDMA_INST_TYPE_NORMAL)
700ad78e: 9802         	ldr	r0, [sp, #0x8]
700ad790: 6800         	ldr	r0, [r0]
700ad792: b118         	cbz	r0, 0x700ad79c <Udma_rmTranslateIrOutput+0x1c> @ imm = #0x6
700ad794: e7ff         	b	0x700ad796 <Udma_rmTranslateIrOutput+0x16> @ imm = #-0x2
;         coreIntrNum = irIntrNum;
700ad796: 9801         	ldr	r0, [sp, #0x4]
700ad798: 9000         	str	r0, [sp]
;     }
700ad79a: e7ff         	b	0x700ad79c <Udma_rmTranslateIrOutput+0x1c> @ imm = #-0x2
;     return (coreIntrNum);
700ad79c: 9800         	ldr	r0, [sp]
700ad79e: b003         	add	sp, #0xc
700ad7a0: 4770         	bx	lr
		...
700ad7ae: 0000         	movs	r0, r0

700ad7b0 <ClockP_usecToTicks>:
; {
700ad7b0: b580         	push	{r7, lr}
700ad7b2: b082         	sub	sp, #0x8
700ad7b4: 9101         	str	r1, [sp, #0x4]
700ad7b6: 9000         	str	r0, [sp]
;     return (uint32_t)(usecs / gClockCtrl.usecPerTick);
700ad7b8: 9800         	ldr	r0, [sp]
700ad7ba: 9901         	ldr	r1, [sp, #0x4]
700ad7bc: f644 4290    	movw	r2, #0x4c90
700ad7c0: f2c7 0208    	movt	r2, #0x7008
700ad7c4: 6892         	ldr	r2, [r2, #0x8]
700ad7c6: 2300         	movs	r3, #0x0
700ad7c8: f7ff ef64    	blx	0x700ad694 <__aeabi_uldivmod> @ imm = #-0x138
700ad7cc: b002         	add	sp, #0x8
700ad7ce: bd80         	pop	{r7, pc}

700ad7d0 <HW_RD_FIELD32_RAW>:
; {
700ad7d0: b084         	sub	sp, #0x10
700ad7d2: 9003         	str	r0, [sp, #0xc]
700ad7d4: 9102         	str	r1, [sp, #0x8]
700ad7d6: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700ad7d8: 9803         	ldr	r0, [sp, #0xc]
700ad7da: 6800         	ldr	r0, [r0]
700ad7dc: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700ad7de: 9800         	ldr	r0, [sp]
700ad7e0: 9902         	ldr	r1, [sp, #0x8]
700ad7e2: 4008         	ands	r0, r1
700ad7e4: 9901         	ldr	r1, [sp, #0x4]
700ad7e6: 40c8         	lsrs	r0, r1
700ad7e8: 9000         	str	r0, [sp]
;     return (regVal);
700ad7ea: 9800         	ldr	r0, [sp]
700ad7ec: b004         	add	sp, #0x10
700ad7ee: 4770         	bx	lr

700ad7f0 <Sciclient_getRxThreadId>:
; {
700ad7f0: b082         	sub	sp, #0x8
700ad7f2: 9001         	str	r0, [sp, #0x4]
;     rxThread = gSciclientMap[contextId].respThreadId;
700ad7f4: 9801         	ldr	r0, [sp, #0x4]
700ad7f6: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ad7fa: f24f 70b8    	movw	r0, #0xf7b8
700ad7fe: f2c7 000a    	movt	r0, #0x700a
700ad802: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700ad806: 68c0         	ldr	r0, [r0, #0xc]
700ad808: 9000         	str	r0, [sp]
;     return rxThread;
700ad80a: 9800         	ldr	r0, [sp]
700ad80c: b002         	add	sp, #0x8
700ad80e: 4770         	bx	lr

700ad810 <Sciclient_getTxThreadId>:
; {
700ad810: b082         	sub	sp, #0x8
700ad812: 9001         	str	r0, [sp, #0x4]
;     txThread = gSciclientMap[contextId].reqLowPrioThreadId;
700ad814: 9801         	ldr	r0, [sp, #0x4]
700ad816: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ad81a: f24f 70b8    	movw	r0, #0xf7b8
700ad81e: f2c7 000a    	movt	r0, #0x700a
700ad822: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700ad826: 6880         	ldr	r0, [r0, #0x8]
700ad828: 9000         	str	r0, [sp]
;     return txThread;
700ad82a: 9800         	ldr	r0, [sp]
700ad82c: b002         	add	sp, #0x8
700ad82e: 4770         	bx	lr

700ad830 <tm_semaphore_put>:
; {
700ad830: b580         	push	{r7, lr}
;    status = xSemaphoreGive(tm_semaphore_array[semaphore_id]);
700ad832: f644 51a4    	movw	r1, #0x4da4
700ad836: 2200         	movs	r2, #0x0
700ad838: f2c7 0108    	movt	r1, #0x7008
700ad83c: 2300         	movs	r3, #0x0
700ad83e: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700ad842: 2100         	movs	r1, #0x0
700ad844: f7f4 f85c    	bl	0x700a1900 <xQueueGenericSend> @ imm = #-0xbf48
;    if (status != pdTRUE)
700ad848: 3801         	subs	r0, #0x1
700ad84a: bf18         	it	ne
700ad84c: 2001         	movne	r0, #0x1
; }
700ad84e: bd80         	pop	{r7, pc}

700ad850 <vPortFree>:
; {
700ad850: b580         	push	{r7, lr}
700ad852: b082         	sub	sp, #0x8
700ad854: 9001         	str	r0, [sp, #0x4]
;     if( pv )
700ad856: 9801         	ldr	r0, [sp, #0x4]
700ad858: b140         	cbz	r0, 0x700ad86c <vPortFree+0x1c> @ imm = #0x10
700ad85a: e7ff         	b	0x700ad85c <vPortFree+0xc> @ imm = #-0x2
;         vTaskSuspendAll();
700ad85c: f000 fbe8    	bl	0x700ae030 <vTaskSuspendAll> @ imm = #0x7d0
;             free( pv );
700ad860: 9801         	ldr	r0, [sp, #0x4]
700ad862: f7f0 ef70    	blx	0x7009e744 <free>       @ imm = #-0xf120
;         ( void ) xTaskResumeAll();
700ad866: f7f3 f81b    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0xcfca
;     }
700ad86a: e7ff         	b	0x700ad86c <vPortFree+0x1c> @ imm = #-0x2
; }
700ad86c: b002         	add	sp, #0x8
700ad86e: bd80         	pop	{r7, pc}

700ad870 <CSL_udmapCppi5SetEpiDataPresent>:
; {
700ad870: b082         	sub	sp, #0x8
700ad872: 9001         	str	r0, [sp, #0x4]
700ad874: f88d 1003    	strb.w	r1, [sp, #0x3]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_EINFO, (bEpiDataPresent==(bool)true) ? (uint32_t)1U : (uint32_t)0U );
700ad878: 9901         	ldr	r1, [sp, #0x4]
700ad87a: 6808         	ldr	r0, [r1]
700ad87c: f020 5000    	bic	r0, r0, #0x20000000
700ad880: f89d 2003    	ldrb.w	r2, [sp, #0x3]
700ad884: f362 705d    	bfi	r0, r2, #29, #1
700ad888: 6008         	str	r0, [r1]
; }
700ad88a: b002         	add	sp, #0x8
700ad88c: 4770         	bx	lr
700ad88e: 0000         	movs	r0, r0

700ad890 <DebugP_memLogWriterInit>:
; {
700ad890: b580         	push	{r7, lr}
700ad892: b082         	sub	sp, #0x8
700ad894: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     gDebugP_memTraceLogWriterSelfCoreName = SOC_getCoreName(selfCoreId);
700ad898: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ad89c: f7fe ff40    	bl	0x700ac720 <SOC_getCoreName> @ imm = #-0x1180
700ad8a0: f640 5194    	movw	r1, #0xd94
700ad8a4: f2c7 010b    	movt	r1, #0x700b
700ad8a8: 6008         	str	r0, [r1]
; }
700ad8aa: b002         	add	sp, #0x8
700ad8ac: bd80         	pop	{r7, pc}
700ad8ae: 0000         	movs	r0, r0

700ad8b0 <Sciclient_rmPsGetIrqNode>:
; {
700ad8b0: b081         	sub	sp, #0x4
700ad8b2: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return gPstack.ps[index].p_n;
700ad8b6: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ad8ba: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ad8be: f241 0058    	movw	r0, #0x1058
700ad8c2: f2c7 0008    	movt	r0, #0x7008
700ad8c6: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700ad8ca: b001         	add	sp, #0x4
700ad8cc: 4770         	bx	lr
700ad8ce: 0000         	movs	r0, r0

700ad8d0 <Sciclient_rmPsInit>:
; {
700ad8d0: b580         	push	{r7, lr}
700ad8d2: b082         	sub	sp, #0x8
;     memset(&gPstack.ps[0], 0, sizeof(gPstack.ps));
700ad8d4: f241 0058    	movw	r0, #0x1058
700ad8d8: f2c7 0008    	movt	r0, #0x7008
700ad8dc: 9001         	str	r0, [sp, #0x4]
700ad8de: 2124         	movs	r1, #0x24
700ad8e0: f7eb efa8    	blx	0x70099834 <__aeabi_memclr8> @ imm = #-0x140b0
700ad8e4: 9901         	ldr	r1, [sp, #0x4]
700ad8e6: 2000         	movs	r0, #0x0
;     gPstack.psp = 0;
700ad8e8: 8488         	strh	r0, [r1, #0x24]
; }
700ad8ea: b002         	add	sp, #0x8
700ad8ec: bd80         	pop	{r7, pc}
700ad8ee: 0000         	movs	r0, r0

700ad8f0 <UART_breakCtl>:
; {
700ad8f0: b580         	push	{r7, lr}
700ad8f2: b082         	sub	sp, #0x8
700ad8f4: 9001         	str	r0, [sp, #0x4]
700ad8f6: 9100         	str	r1, [sp]
;     HW_WR_FIELD32(baseAddr + UART_LCR, UART_LCR_BREAK_EN,
700ad8f8: 9801         	ldr	r0, [sp, #0x4]
700ad8fa: 300c         	adds	r0, #0xc
700ad8fc: 9900         	ldr	r1, [sp]
700ad8fe: ea4f 1391    	lsr.w	r3, r1, #0x6
700ad902: 2140         	movs	r1, #0x40
700ad904: 2206         	movs	r2, #0x6
700ad906: f7ff f8e3    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #-0xe3a
; }
700ad90a: b002         	add	sp, #0x8
700ad90c: bd80         	pop	{r7, pc}
700ad90e: 0000         	movs	r0, r0

700ad910 <UART_lld_Transaction_deInit>:
; {
700ad910: b081         	sub	sp, #0x4
700ad912: 9000         	str	r0, [sp]
;     trans->buf              = NULL;
700ad914: 9900         	ldr	r1, [sp]
700ad916: 2000         	movs	r0, #0x0
700ad918: 6008         	str	r0, [r1]
;     trans->count            = 0U;
700ad91a: 9900         	ldr	r1, [sp]
700ad91c: 6048         	str	r0, [r1, #0x4]
;     trans->timeout          = 0U;
700ad91e: 9900         	ldr	r1, [sp]
700ad920: 6088         	str	r0, [r1, #0x8]
;     trans->status           = UART_STATUS_SUCCESS;
700ad922: 9900         	ldr	r1, [sp]
700ad924: 60c8         	str	r0, [r1, #0xc]
;     trans->args             = NULL;
700ad926: 9900         	ldr	r1, [sp]
700ad928: 6108         	str	r0, [r1, #0x10]
; }
700ad92a: b001         	add	sp, #0x4
700ad92c: 4770         	bx	lr
700ad92e: 0000         	movs	r0, r0

700ad930 <UART_writeInterrupt>:
; {
700ad930: b580         	push	{r7, lr}
700ad932: b084         	sub	sp, #0x10
700ad934: 9003         	str	r0, [sp, #0xc]
700ad936: 2000         	movs	r0, #0x0
;     int32_t     status = UART_STATUS_SUCCESS;
700ad938: 9002         	str	r0, [sp, #0x8]
;     baseAddr = hUart->baseAddr;
700ad93a: 9803         	ldr	r0, [sp, #0xc]
700ad93c: 6800         	ldr	r0, [r0]
700ad93e: 9001         	str	r0, [sp, #0x4]
;     UART_intrEnable(baseAddr, UART_INTR_THR);
700ad940: 9801         	ldr	r0, [sp, #0x4]
700ad942: 2102         	movs	r1, #0x2
700ad944: f7f6 fe1c    	bl	0x700a4580 <UART_intrEnable> @ imm = #-0x93c8
;     return status;
700ad948: 9802         	ldr	r0, [sp, #0x8]
700ad94a: b004         	add	sp, #0x10
700ad94c: bd80         	pop	{r7, pc}
700ad94e: 0000         	movs	r0, r0

700ad950 <UdmaChPdmaPrms_init>:
; {
700ad950: b081         	sub	sp, #0x4
700ad952: 9000         	str	r0, [sp]
;     if(NULL_PTR != pdmaPrms)
700ad954: 9800         	ldr	r0, [sp]
700ad956: b140         	cbz	r0, 0x700ad96a <UdmaChPdmaPrms_init+0x1a> @ imm = #0x10
700ad958: e7ff         	b	0x700ad95a <UdmaChPdmaPrms_init+0xa> @ imm = #-0x2
;         pdmaPrms->elemSize  = UDMA_PDMA_ES_8BITS;
700ad95a: 9900         	ldr	r1, [sp]
700ad95c: 2000         	movs	r0, #0x0
700ad95e: 6008         	str	r0, [r1]
;         pdmaPrms->elemCnt   = 0U;
700ad960: 9900         	ldr	r1, [sp]
700ad962: 6048         	str	r0, [r1, #0x4]
;         pdmaPrms->fifoCnt   = 0U;
700ad964: 9900         	ldr	r1, [sp]
700ad966: 6088         	str	r0, [r1, #0x8]
;     }
700ad968: e7ff         	b	0x700ad96a <UdmaChPdmaPrms_init+0x1a> @ imm = #-0x2
;     return;
700ad96a: b001         	add	sp, #0x4
700ad96c: 4770         	bx	lr
700ad96e: 0000         	movs	r0, r0

700ad970 <prvTimerTask>:
;     {
700ad970: b580         	push	{r7, lr}
700ad972: b084         	sub	sp, #0x10
700ad974: 9003         	str	r0, [sp, #0xc]
;         for( ; ; )
700ad976: e7ff         	b	0x700ad978 <prvTimerTask+0x8> @ imm = #-0x2
700ad978: a801         	add	r0, sp, #0x4
;             xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
700ad97a: f7fe fbf1    	bl	0x700ac160 <prvGetNextExpireTime> @ imm = #-0x181e
700ad97e: 9002         	str	r0, [sp, #0x8]
;             prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
700ad980: 9802         	ldr	r0, [sp, #0x8]
700ad982: 9901         	ldr	r1, [sp, #0x4]
700ad984: f7fb f89c    	bl	0x700a8ac0 <prvProcessTimerOrBlockTask> @ imm = #-0x4ec8
;             prvProcessReceivedCommands();
700ad988: f7f3 fc0a    	bl	0x700a11a0 <prvProcessReceivedCommands> @ imm = #-0xc7ec
;         for( ; ; )
700ad98c: e7f4         	b	0x700ad978 <prvTimerTask+0x8> @ imm = #-0x18
700ad98e: 0000         	movs	r0, r0

700ad990 <tm_semaphore_wait>:
; {
700ad990: b580         	push	{r7, lr}
;    status = xSemaphoreTake(tm_semaphore_array[semaphore_id], portMAX_DELAY);
700ad992: f644 51a4    	movw	r1, #0x4da4
700ad996: f2c7 0108    	movt	r1, #0x7008
700ad99a: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700ad99e: f04f 31ff    	mov.w	r1, #0xffffffff
700ad9a2: f7f2 f86d    	bl	0x7009fa80 <xQueueSemaphoreTake> @ imm = #-0xdf26
;    if (status != pdTRUE)
700ad9a6: 3801         	subs	r0, #0x1
700ad9a8: bf18         	it	ne
700ad9aa: 2001         	movne	r0, #0x1
; }
700ad9ac: bd80         	pop	{r7, pc}
700ad9ae: 0000         	movs	r0, r0

700ad9b0 <xPortStartScheduler>:
; BaseType_t xPortStartScheduler(void) {
700ad9b0: b580         	push	{r7, lr}
700ad9b2: b082         	sub	sp, #0x8
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700ad9b4: b672         	cpsid i
;   ulPortSchedularRunning = pdTRUE;
700ad9b6: f640 51c0    	movw	r1, #0xdc0
700ad9ba: f2c7 010b    	movt	r1, #0x700b
700ad9be: 2001         	movs	r0, #0x1
700ad9c0: 9001         	str	r0, [sp, #0x4]
700ad9c2: 6008         	str	r0, [r1]
;   vPortRestoreTaskContext();
700ad9c4: f001 e906    	blx	0x700aebd4 <vPortRestoreTaskContext> @ imm = #0x120c
700ad9c8: 9801         	ldr	r0, [sp, #0x4]
;   return pdTRUE;
700ad9ca: b002         	add	sp, #0x8
700ad9cc: bd80         	pop	{r7, pc}
700ad9ce: 0000         	movs	r0, r0

700ad9d0 <xTaskGetTickCount>:
; TickType_t xTaskGetTickCount(void) {
700ad9d0: b580         	push	{r7, lr}
700ad9d2: b082         	sub	sp, #0x8
;   portTICK_TYPE_ENTER_CRITICAL();
700ad9d4: f7ff f8fc    	bl	0x700acbd0 <vTaskEnterCritical> @ imm = #-0xe08
;     xTicks = xTickCount;
700ad9d8: f640 50f4    	movw	r0, #0xdf4
700ad9dc: f2c7 000b    	movt	r0, #0x700b
700ad9e0: 6800         	ldr	r0, [r0]
700ad9e2: 9001         	str	r0, [sp, #0x4]
;   portTICK_TYPE_EXIT_CRITICAL();
700ad9e4: f7fe f974    	bl	0x700abcd0 <vTaskExitCritical> @ imm = #-0x1d18
;   return xTicks;
700ad9e8: 9801         	ldr	r0, [sp, #0x4]
700ad9ea: b002         	add	sp, #0x8
700ad9ec: bd80         	pop	{r7, pc}
700ad9ee: 0000         	movs	r0, r0

700ad9f0 <CSL_secProxyGetDataAddr>:
; {
700ad9f0: b084         	sub	sp, #0x10
700ad9f2: 9003         	str	r0, [sp, #0xc]
700ad9f4: 9102         	str	r1, [sp, #0x8]
700ad9f6: 9201         	str	r2, [sp, #0x4]
;     dataAddr = (uintptr_t)pSecProxyCfg->proxyTargetAddr + ((uintptr_t)threadNum * CSL_SEC_PROXY_TARGET_CHAN_SIZE) + (uintptr_t)CSL_SEC_PROXY_RSVD_MSG_BYTES;
700ad9f8: 9803         	ldr	r0, [sp, #0xc]
700ad9fa: 6900         	ldr	r0, [r0, #0x10]
700ad9fc: 9902         	ldr	r1, [sp, #0x8]
700ad9fe: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ada02: 3004         	adds	r0, #0x4
700ada04: 9000         	str	r0, [sp]
;     return dataAddr;
700ada06: 9800         	ldr	r0, [sp]
700ada08: b004         	add	sp, #0x10
700ada0a: 4770         	bx	lr
700ada0c: 0000         	movs	r0, r0
700ada0e: 0000         	movs	r0, r0

700ada10 <UART_IsParameter>:
; {
700ada10: b082         	sub	sp, #0x8
700ada12: 9001         	str	r0, [sp, #0x4]
700ada14: 2000         	movs	r0, #0x0
;     int32_t status = UART_STATUS_SUCCESS;
700ada16: 9000         	str	r0, [sp]
;     if(InuptParameter == 0U)
700ada18: 9801         	ldr	r0, [sp, #0x4]
700ada1a: b920         	cbnz	r0, 0x700ada26 <UART_IsParameter+0x16> @ imm = #0x8
700ada1c: e7ff         	b	0x700ada1e <UART_IsParameter+0xe> @ imm = #-0x2
700ada1e: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700ada22: 9000         	str	r0, [sp]
;     }
700ada24: e7ff         	b	0x700ada26 <UART_IsParameter+0x16> @ imm = #-0x2
;     return status;
700ada26: 9800         	ldr	r0, [sp]
700ada28: b002         	add	sp, #0x8
700ada2a: 4770         	bx	lr
700ada2c: 0000         	movs	r0, r0
700ada2e: 0000         	movs	r0, r0

700ada30 <pvPortMalloc>:
; {
700ada30: b580         	push	{r7, lr}
700ada32: b082         	sub	sp, #0x8
700ada34: 9001         	str	r0, [sp, #0x4]
;     vTaskSuspendAll();
700ada36: f000 fafb    	bl	0x700ae030 <vTaskSuspendAll> @ imm = #0x5f6
;         pvReturn = malloc( xWantedSize );
700ada3a: 9801         	ldr	r0, [sp, #0x4]
700ada3c: f7ec e9fa    	blx	0x70099e34 <malloc>     @ imm = #-0x13c0c
700ada40: 9000         	str	r0, [sp]
;     ( void ) xTaskResumeAll();
700ada42: f7f2 ff2d    	bl	0x700a08a0 <xTaskResumeAll> @ imm = #-0xd1a6
;     return pvReturn;
700ada46: 9800         	ldr	r0, [sp]
700ada48: b002         	add	sp, #0x8
700ada4a: bd80         	pop	{r7, pc}
700ada4c: 0000         	movs	r0, r0
700ada4e: 0000         	movs	r0, r0

700ada50 <tm_semaphore_get>:
; {
700ada50: b580         	push	{r7, lr}
;    status = xSemaphoreTake(tm_semaphore_array[semaphore_id], (TickType_t) 0);
700ada52: f644 51a4    	movw	r1, #0x4da4
700ada56: f2c7 0108    	movt	r1, #0x7008
700ada5a: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700ada5e: 2100         	movs	r1, #0x0
700ada60: f7f2 f80e    	bl	0x7009fa80 <xQueueSemaphoreTake> @ imm = #-0xdfe4
;    if (status != pdTRUE)
700ada64: 3801         	subs	r0, #0x1
700ada66: bf18         	it	ne
700ada68: 2001         	movne	r0, #0x1
; }
700ada6a: bd80         	pop	{r7, pc}
700ada6c: 0000         	movs	r0, r0
700ada6e: 0000         	movs	r0, r0

700ada70 <vPortYeildFromISR>:
; void vPortYeildFromISR(uint32_t xSwitchRequired) {
700ada70: b081         	sub	sp, #0x4
700ada72: 9000         	str	r0, [sp]
;   if (xSwitchRequired != pdFALSE) {
700ada74: 9800         	ldr	r0, [sp]
700ada76: b138         	cbz	r0, 0x700ada88 <vPortYeildFromISR+0x18> @ imm = #0xe
700ada78: e7ff         	b	0x700ada7a <vPortYeildFromISR+0xa> @ imm = #-0x2
;     ulPortYieldRequired = pdTRUE;
700ada7a: f640 51c8    	movw	r1, #0xdc8
700ada7e: f2c7 010b    	movt	r1, #0x700b
700ada82: 2001         	movs	r0, #0x1
700ada84: 6008         	str	r0, [r1]
;   }
700ada86: e7ff         	b	0x700ada88 <vPortYeildFromISR+0x18> @ imm = #-0x2
; }
700ada88: b001         	add	sp, #0x4
700ada8a: 4770         	bx	lr

700ada8c <TI_memcpy_small>:
700ada8c: e3a0c000     	mov	r12, #0

700ada90 <_loop>:
700ada90: e152000c     	cmp	r2, r12
700ada94: 012fff1e     	bxeq	lr
700ada98: e7d1300c     	ldrb	r3, [r1, r12]
700ada9c: e7c0300c     	strb	r3, [r0, r12]
700adaa0: e28cc001     	add	r12, r12, #1
700adaa4: eafffff9     	b	0x700ada90 <_loop>      @ imm = #-0x1c
		...

700adab0 <CSL_udmapCppi5SetDescType>:
; {
700adab0: b082         	sub	sp, #0x8
700adab2: 9001         	str	r0, [sp, #0x4]
700adab4: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_DTYPE, descType );
700adab6: 9901         	ldr	r1, [sp, #0x4]
700adab8: 6808         	ldr	r0, [r1]
700adaba: f020 4040    	bic	r0, r0, #0xc0000000
700adabe: 9a00         	ldr	r2, [sp]
700adac0: ea40 7082    	orr.w	r0, r0, r2, lsl #30
700adac4: 6008         	str	r0, [r1]
; }
700adac6: b002         	add	sp, #0x8
700adac8: 4770         	bx	lr
700adaca: 0000         	movs	r0, r0
700adacc: 0000         	movs	r0, r0
700adace: 0000         	movs	r0, r0

700adad0 <UART_fifoCharGet>:
; {
700adad0: b580         	push	{r7, lr}
700adad2: b082         	sub	sp, #0x8
700adad4: 9001         	str	r0, [sp, #0x4]
700adad6: 2000         	movs	r0, #0x0
;     uint32_t tempRetVal = 0U;
700adad8: 9000         	str	r0, [sp]
;     tempRetVal = HW_RD_REG32(baseAddr + UART_RHR);
700adada: 9801         	ldr	r0, [sp, #0x4]
700adadc: f000 fa80    	bl	0x700adfe0 <HW_RD_REG32_RAW> @ imm = #0x500
700adae0: 9000         	str	r0, [sp]
;     return ((uint8_t) tempRetVal);
700adae2: f89d 0000    	ldrb.w	r0, [sp]
700adae6: b002         	add	sp, #0x8
700adae8: bd80         	pop	{r7, pc}
700adaea: 0000         	movs	r0, r0
700adaec: 0000         	movs	r0, r0
700adaee: 0000         	movs	r0, r0

700adaf0 <UART_timeGuardConfig>:
; {
700adaf0: b580         	push	{r7, lr}
700adaf2: b082         	sub	sp, #0x8
700adaf4: 9001         	str	r0, [sp, #0x4]
700adaf6: 9100         	str	r1, [sp]
;     HW_WR_FIELD32(baseAddr + UART_TIMEGUARD, UART_TIMEGUARD_TIMEGUARD,
700adaf8: 9801         	ldr	r0, [sp, #0x4]
700adafa: 3094         	adds	r0, #0x94
700adafc: 9b00         	ldr	r3, [sp]
700adafe: 21ff         	movs	r1, #0xff
700adb00: 2200         	movs	r2, #0x0
700adb02: f7fe ffe5    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #-0x1036
; }
700adb06: b002         	add	sp, #0x8
700adb08: bd80         	pop	{r7, pc}
700adb0a: 0000         	movs	r0, r0
700adb0c: 0000         	movs	r0, r0
700adb0e: 0000         	movs	r0, r0

700adb10 <CSL_udmapCppi5SetPsDataLen>:
; {
700adb10: b082         	sub	sp, #0x8
700adb12: 9001         	str	r0, [sp, #0x4]
700adb14: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PSWCNT, (psDataLen/4U) );
700adb16: 9901         	ldr	r1, [sp, #0x4]
700adb18: 6808         	ldr	r0, [r1]
700adb1a: 9a00         	ldr	r2, [sp]
700adb1c: 0892         	lsrs	r2, r2, #0x2
700adb1e: f362 509b    	bfi	r0, r2, #22, #6
700adb22: 6008         	str	r0, [r1]
; }
700adb24: b002         	add	sp, #0x8
700adb26: 4770         	bx	lr
		...

700adb30 <Sciclient_rmIrqSet>:
; {
700adb30: b580         	push	{r7, lr}
700adb32: b084         	sub	sp, #0x10
700adb34: 9003         	str	r0, [sp, #0xc]
700adb36: 9102         	str	r1, [sp, #0x8]
700adb38: 9201         	str	r2, [sp, #0x4]
;     return Sciclient_rmProgramInterruptRoute(req, resp, timeout);
700adb3a: 9803         	ldr	r0, [sp, #0xc]
700adb3c: 9902         	ldr	r1, [sp, #0x8]
700adb3e: 9a01         	ldr	r2, [sp, #0x4]
700adb40: f7f1 fbbe    	bl	0x7009f2c0 <Sciclient_rmProgramInterruptRoute> @ imm = #-0xe884
700adb44: b004         	add	sp, #0x10
700adb46: bd80         	pop	{r7, pc}
		...

700adb50 <Sciclient_secProxyThreadStatusReg>:
; {
700adb50: b081         	sub	sp, #0x4
700adb52: 9000         	str	r0, [sp]
;     return ((uint32_t)(uintptr_t)(gSciclientSecProxyCfg.pSecProxyRtRegs) +
700adb54: f640 4078    	movw	r0, #0xc78
700adb58: f2c7 000b    	movt	r0, #0x700b
700adb5c: 6880         	ldr	r0, [r0, #0x8]
;         CSL_SEC_PROXY_RT_THREAD_STATUS(thread));
700adb5e: 9900         	ldr	r1, [sp]
;     return ((uint32_t)(uintptr_t)(gSciclientSecProxyCfg.pSecProxyRtRegs) +
700adb60: eb00 3001    	add.w	r0, r0, r1, lsl #12
700adb64: b001         	add	sp, #0x4
700adb66: 4770         	bx	lr
		...

700adb70 <TimerP_start>:
; {
700adb70: b082         	sub	sp, #0x8
700adb72: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (uint32_t *)(baseAddr + TIMER_TCLR);
700adb74: 9801         	ldr	r0, [sp, #0x4]
700adb76: 3038         	adds	r0, #0x38
700adb78: 9000         	str	r0, [sp]
;     *addr |= (0x1U << 0);
700adb7a: 9900         	ldr	r1, [sp]
700adb7c: 6808         	ldr	r0, [r1]
700adb7e: f040 0001    	orr	r0, r0, #0x1
700adb82: 6008         	str	r0, [r1]
; }
700adb84: b002         	add	sp, #0x8
700adb86: 4770         	bx	lr
		...

700adb90 <TimerP_stop>:
; {
700adb90: b082         	sub	sp, #0x8
700adb92: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TCLR);
700adb94: 9801         	ldr	r0, [sp, #0x4]
700adb96: 3038         	adds	r0, #0x38
700adb98: 9000         	str	r0, [sp]
;     *addr &= ~(0x1U << 0);
700adb9a: 9900         	ldr	r1, [sp]
700adb9c: 6808         	ldr	r0, [r1]
700adb9e: f020 0001    	bic	r0, r0, #0x1
700adba2: 6008         	str	r0, [r1]
; }
700adba4: b002         	add	sp, #0x8
700adba6: 4770         	bx	lr
		...

700adbb0 <UART_divisorLatchDisable>:
; {
700adbb0: b580         	push	{r7, lr}
700adbb2: b082         	sub	sp, #0x8
700adbb4: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_LCR, UART_LCR_DIV_EN,
700adbb6: 9801         	ldr	r0, [sp, #0x4]
700adbb8: 300c         	adds	r0, #0xc
700adbba: 2180         	movs	r1, #0x80
700adbbc: 2207         	movs	r2, #0x7
700adbbe: 2300         	movs	r3, #0x0
700adbc0: f7fe ff86    	bl	0x700acad0 <HW_WR_FIELD32_RAW> @ imm = #-0x10f4
; }
700adbc4: b002         	add	sp, #0x8
700adbc6: bd80         	pop	{r7, pc}
		...

700adbd0 <UART_modemControlReset>:
; {
700adbd0: b580         	push	{r7, lr}
700adbd2: b082         	sub	sp, #0x8
700adbd4: 9001         	str	r0, [sp, #0x4]
700adbd6: 2000         	movs	r0, #0x0
;     uint32_t mcrResetVal = 0U;
700adbd8: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_MCR, mcrResetVal);
700adbda: 9801         	ldr	r0, [sp, #0x4]
700adbdc: 3010         	adds	r0, #0x10
700adbde: 9900         	ldr	r1, [sp]
700adbe0: f000 fa06    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x40c
; }
700adbe4: b002         	add	sp, #0x8
700adbe6: bd80         	pop	{r7, pc}
		...

700adbf0 <UART_putChar>:
; {
700adbf0: b580         	push	{r7, lr}
700adbf2: b082         	sub	sp, #0x8
700adbf4: 9001         	str	r0, [sp, #0x4]
700adbf6: f88d 1003    	strb.w	r1, [sp, #0x3]
;     HW_WR_REG32(baseAddr + UART_THR, (uint32_t) byteTx);
700adbfa: 9801         	ldr	r0, [sp, #0x4]
700adbfc: f89d 1003    	ldrb.w	r1, [sp, #0x3]
700adc00: f000 f9f6    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x3ec
; }
700adc04: b002         	add	sp, #0x8
700adc06: bd80         	pop	{r7, pc}

700adc08 <TI_memset_small>:
700adc08: e3a03000     	mov	r3, #0

700adc0c <_loop>:
700adc0c: e1520003     	cmp	r2, r3
700adc10: 012fff1e     	bxeq	lr
700adc14: e7c01003     	strb	r1, [r0, r3]
700adc18: e2833001     	add	r3, r3, #1
700adc1c: eafffffa     	b	0x700adc0c <_loop>      @ imm = #-0x18

700adc20 <CSL_REG64_WR_RAW>:
; {
700adc20: b084         	sub	sp, #0x10
700adc22: 9003         	str	r0, [sp, #0xc]
700adc24: 9301         	str	r3, [sp, #0x4]
700adc26: 9200         	str	r2, [sp]
;     *p = v;
700adc28: 9800         	ldr	r0, [sp]
700adc2a: 9901         	ldr	r1, [sp, #0x4]
700adc2c: 9a03         	ldr	r2, [sp, #0xc]
700adc2e: e9c2 0100    	strd	r0, r1, [r2]
;     return;
700adc32: b004         	add	sp, #0x10
700adc34: 4770         	bx	lr
		...
700adc3e: 0000         	movs	r0, r0

700adc40 <CSL_udmapCppi5LinkDesc>:
; {
700adc40: b084         	sub	sp, #0x10
700adc42: 9003         	str	r0, [sp, #0xc]
700adc44: 9301         	str	r3, [sp, #0x4]
700adc46: 9200         	str	r2, [sp]
;     pDesc->nextDescPtr = physBufferDescAddr;
700adc48: 9800         	ldr	r0, [sp]
700adc4a: 9a01         	ldr	r2, [sp, #0x4]
700adc4c: 9903         	ldr	r1, [sp, #0xc]
700adc4e: 614a         	str	r2, [r1, #0x14]
700adc50: 6108         	str	r0, [r1, #0x10]
; }
700adc52: b004         	add	sp, #0x10
700adc54: 4770         	bx	lr
		...
700adc5e: 0000         	movs	r0, r0

700adc60 <CSL_udmapCppi5SetBufferAddr>:
; {
700adc60: b084         	sub	sp, #0x10
700adc62: 9003         	str	r0, [sp, #0xc]
700adc64: 9301         	str	r3, [sp, #0x4]
700adc66: 9200         	str	r2, [sp]
;     pDesc->bufPtr    = physBufferAddr;
700adc68: 9800         	ldr	r0, [sp]
700adc6a: 9a01         	ldr	r2, [sp, #0x4]
700adc6c: 9903         	ldr	r1, [sp, #0xc]
700adc6e: 61ca         	str	r2, [r1, #0x1c]
700adc70: 6188         	str	r0, [r1, #0x18]
; }
700adc72: b004         	add	sp, #0x10
700adc74: 4770         	bx	lr
		...
700adc7e: 0000         	movs	r0, r0

700adc80 <CSL_udmapCppi5SetBufferLen>:
; {
700adc80: b082         	sub	sp, #0x8
700adc82: 9001         	str	r0, [sp, #0x4]
700adc84: 9100         	str	r1, [sp]
;     CSL_FINS( pDesc->bufInfo1, UDMAP_CPPI5_PD_BUFINFO1_LEN, bufferLenBytes );
700adc86: 9901         	ldr	r1, [sp, #0x4]
700adc88: 6a08         	ldr	r0, [r1, #0x20]
700adc8a: 9a00         	ldr	r2, [sp]
700adc8c: f362 0015    	bfi	r0, r2, #0, #22
700adc90: 6208         	str	r0, [r1, #0x20]
; }
700adc92: b002         	add	sp, #0x8
700adc94: 4770         	bx	lr
		...
700adc9e: 0000         	movs	r0, r0

700adca0 <CSL_udmapCppi5SetOrgBufferAddr>:
; {
700adca0: b084         	sub	sp, #0x10
700adca2: 9003         	str	r0, [sp, #0xc]
700adca4: 9301         	str	r3, [sp, #0x4]
700adca6: 9200         	str	r2, [sp]
;     pDesc->orgBufPtr = physBufferAddr;
700adca8: 9800         	ldr	r0, [sp]
700adcaa: 9a01         	ldr	r2, [sp, #0x4]
700adcac: 9903         	ldr	r1, [sp, #0xc]
700adcae: 62ca         	str	r2, [r1, #0x2c]
700adcb0: 6288         	str	r0, [r1, #0x28]
; }
700adcb2: b004         	add	sp, #0x10
700adcb4: 4770         	bx	lr
		...
700adcbe: 0000         	movs	r0, r0

700adcc0 <CSL_udmapCppi5SetPsDataLoc>:
; {
700adcc0: b082         	sub	sp, #0x8
700adcc2: 9001         	str	r0, [sp, #0x4]
700adcc4: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PSINFO, psLoc );
700adcc6: 9901         	ldr	r1, [sp, #0x4]
700adcc8: 6808         	ldr	r0, [r1]
700adcca: 9a00         	ldr	r2, [sp]
700adccc: f362 701c    	bfi	r0, r2, #28, #1
700adcd0: 6008         	str	r0, [r1]
; }
700adcd2: b002         	add	sp, #0x8
700adcd4: 4770         	bx	lr
		...
700adcde: 0000         	movs	r0, r0

700adce0 <CSL_udmapCppi5SetPsFlags>:
; {
700adce0: b082         	sub	sp, #0x8
700adce2: 9001         	str	r0, [sp, #0x4]
700adce4: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1, UDMAP_CPPI5_PD_PKTINFO1_PSFLGS, psFlags );
700adce6: 9901         	ldr	r1, [sp, #0x4]
700adce8: 6848         	ldr	r0, [r1, #0x4]
700adcea: 9a00         	ldr	r2, [sp]
700adcec: f362 601b    	bfi	r0, r2, #24, #4
700adcf0: 6048         	str	r0, [r1, #0x4]
; }
700adcf2: b002         	add	sp, #0x8
700adcf4: 4770         	bx	lr
		...
700adcfe: 0000         	movs	r0, r0

700add00 <Sciclient_rmIrqRelease>:
; {
700add00: b580         	push	{r7, lr}
700add02: b084         	sub	sp, #0x10
700add04: 9003         	str	r0, [sp, #0xc]
700add06: 9102         	str	r1, [sp, #0x8]
;     return Sciclient_rmClearInterruptRoute(req, &resp, timeout);
700add08: 9803         	ldr	r0, [sp, #0xc]
700add0a: 9a02         	ldr	r2, [sp, #0x8]
700add0c: 4669         	mov	r1, sp
700add0e: f7f0 ffa7    	bl	0x7009ec60 <Sciclient_rmClearInterruptRoute> @ imm = #-0xf0b2
700add12: b004         	add	sp, #0x10
700add14: bd80         	pop	{r7, pc}
		...
700add1e: 0000         	movs	r0, r0

700add20 <Sciclient_secProxyReadThreadCount>:
; {
700add20: b580         	push	{r7, lr}
700add22: b082         	sub	sp, #0x8
700add24: 9001         	str	r0, [sp, #0x4]
;     return (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700add26: 9801         	ldr	r0, [sp, #0x4]
700add28: f7ff ff12    	bl	0x700adb50 <Sciclient_secProxyThreadStatusReg> @ imm = #-0x1dc
700add2c: f000 f9b8    	bl	0x700ae0a0 <CSL_REG32_RD_RAW> @ imm = #0x370
700add30: b2c0         	uxtb	r0, r0
700add32: b002         	add	sp, #0x8
700add34: bd80         	pop	{r7, pc}
		...
700add3e: 0000         	movs	r0, r0

700add40 <SemaphoreP_destruct>:
; {
700add40: b580         	push	{r7, lr}
700add42: b082         	sub	sp, #0x8
700add44: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700add46: 9801         	ldr	r0, [sp, #0x4]
700add48: 9000         	str	r0, [sp]
;     vSemaphoreDelete(pSemaphore->semHndl);
700add4a: 9800         	ldr	r0, [sp]
700add4c: 6d00         	ldr	r0, [r0, #0x50]
700add4e: f7ff fb27    	bl	0x700ad3a0 <vQueueDelete> @ imm = #-0x9b2
; }
700add52: b002         	add	sp, #0x8
700add54: bd80         	pop	{r7, pc}
		...
700add5e: 0000         	movs	r0, r0

700add60 <UART_divideRoundCloset>:
; {
700add60: b082         	sub	sp, #0x8
700add62: 9001         	str	r0, [sp, #0x4]
700add64: 9100         	str	r1, [sp]
;     return ((divident + (divisor/2U))/divisor);
700add66: 9801         	ldr	r0, [sp, #0x4]
700add68: 9900         	ldr	r1, [sp]
700add6a: eb00 0051    	add.w	r0, r0, r1, lsr #1
700add6e: fbb0 f0f1    	udiv	r0, r0, r1
700add72: b002         	add	sp, #0x8
700add74: 4770         	bx	lr
		...
700add7e: 0000         	movs	r0, r0

700add80 <UART_regConfModeRestore>:
; {
700add80: b580         	push	{r7, lr}
700add82: b082         	sub	sp, #0x8
700add84: 9001         	str	r0, [sp, #0x4]
700add86: 9100         	str	r1, [sp]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700add88: 9801         	ldr	r0, [sp, #0x4]
700add8a: 300c         	adds	r0, #0xc
700add8c: 9900         	ldr	r1, [sp]
700add8e: f000 f92f    	bl	0x700adff0 <HW_WR_REG32_RAW> @ imm = #0x25e
; }
700add92: b002         	add	sp, #0x8
700add94: bd80         	pop	{r7, pc}
		...
700add9e: 0000         	movs	r0, r0

700adda0 <tm_thread_resume>:
; {
700adda0: b580         	push	{r7, lr}
;    vTaskResume(tm_thread_array[thread_id]);
700adda2: f644 41c8    	movw	r1, #0x4cc8
700adda6: f2c7 0108    	movt	r1, #0x7008
700addaa: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700addae: f7f9 f837    	bl	0x700a6e20 <vTaskResume> @ imm = #-0x6f92
;    return TM_SUCCESS;
700addb2: 2000         	movs	r0, #0x0
700addb4: bd80         	pop	{r7, pc}
		...
700addbe: 0000         	movs	r0, r0

700addc0 <DebugP_uartSetDrvIndex>:
; {
700addc0: b081         	sub	sp, #0x4
700addc2: 9000         	str	r0, [sp]
;     gDebugP_uartDrvIndex = uartDrvIndex;
700addc4: 9800         	ldr	r0, [sp]
700addc6: f640 5198    	movw	r1, #0xd98
700addca: f2c7 010b    	movt	r1, #0x700b
700addce: 6008         	str	r0, [r1]
; }
700addd0: b001         	add	sp, #0x4
700addd2: 4770         	bx	lr
		...

700adde0 <Sciclient_rmIrIntControlReg>:
; {
700adde0: b081         	sub	sp, #0x4
700adde2: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return (outp * SCICLIENT_IR_INT_CONTROL_REG_STEP) +
700adde6: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700addea: 2004         	movs	r0, #0x4
700addec: eb00 0081    	add.w	r0, r0, r1, lsl #2
700addf0: b001         	add	sp, #0x4
700addf2: 4770         	bx	lr
		...

700ade00 <Udma_rmAllocFreeRing>:
; {
700ade00: b082         	sub	sp, #0x8
700ade02: 9001         	str	r0, [sp, #0x4]
700ade04: f64f 70ff    	movw	r0, #0xffff
;     uint16_t            ringNum = UDMA_RING_INVALID;
700ade08: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return (ringNum);
700ade0c: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ade10: b002         	add	sp, #0x8
700ade12: 4770         	bx	lr
		...

700ade20 <tm_interrupt_processing_handler>:
;    tm_interrupt_handler_counter++;
700ade20: f644 51c4    	movw	r1, #0x4dc4
700ade24: f2c7 0108    	movt	r1, #0x7008
700ade28: 6808         	ldr	r0, [r1]
700ade2a: 1c42         	adds	r2, r0, #0x1
;    tm_semaphore_put(0);
700ade2c: 2000         	movs	r0, #0x0
;    tm_interrupt_handler_counter++;
700ade2e: 600a         	str	r2, [r1]
;    tm_semaphore_put(0);
700ade30: f7ff bcfe    	b.w	0x700ad830 <tm_semaphore_put> @ imm = #-0x604
		...

700ade40 <xTaskGetCurrentTaskHandle>:
; TaskHandle_t xTaskGetCurrentTaskHandle(void) {
700ade40: b081         	sub	sp, #0x4
;   xReturn = pxCurrentTCB;
700ade42: f640 50ac    	movw	r0, #0xdac
700ade46: f2c7 000b    	movt	r0, #0x700b
700ade4a: 6800         	ldr	r0, [r0]
700ade4c: 9000         	str	r0, [sp]
;   return xReturn;
700ade4e: 9800         	ldr	r0, [sp]
700ade50: b001         	add	sp, #0x4
700ade52: 4770         	bx	lr
		...

700ade60 <CSL_udmapCppi5SetSrcTag>:
; {
700ade60: b082         	sub	sp, #0x8
700ade62: 9001         	str	r0, [sp, #0x4]
700ade64: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->srcDstTag, UDMAP_CPPI5_PD_SRCDSTTAG_SRCTAG, srcTag );
700ade66: 9901         	ldr	r1, [sp, #0x4]
700ade68: f8bd 0000    	ldrh.w	r0, [sp]
700ade6c: 81c8         	strh	r0, [r1, #0xe]
; }
700ade6e: b002         	add	sp, #0x8
700ade70: 4770         	bx	lr
		...
700ade7e: 0000         	movs	r0, r0

700ade80 <TimerP_getCount>:
; {
700ade80: b082         	sub	sp, #0x8
700ade82: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TCRR);
700ade84: 9801         	ldr	r0, [sp, #0x4]
700ade86: 303c         	adds	r0, #0x3c
700ade88: 9000         	str	r0, [sp]
;     return *addr;
700ade8a: 9800         	ldr	r0, [sp]
700ade8c: 6800         	ldr	r0, [r0]
700ade8e: b002         	add	sp, #0x8
700ade90: 4770         	bx	lr
		...
700ade9e: 0000         	movs	r0, r0

700adea0 <TimerP_getReloadCount>:
; {
700adea0: b082         	sub	sp, #0x8
700adea2: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TLDR);
700adea4: 9801         	ldr	r0, [sp, #0x4]
700adea6: 3040         	adds	r0, #0x40
700adea8: 9000         	str	r0, [sp]
;     return *addr;
700adeaa: 9800         	ldr	r0, [sp]
700adeac: 6800         	ldr	r0, [r0]
700adeae: b002         	add	sp, #0x8
700adeb0: 4770         	bx	lr
		...
700adebe: 0000         	movs	r0, r0

700adec0 <putchar_>:
; {
700adec0: b510         	push	{r4, lr}
700adec2: 4604         	mov	r4, r0
;     DebugP_memLogWriterPutChar(character);
700adec4: f7f2 fe3c    	bl	0x700a0b40 <DebugP_memLogWriterPutChar> @ imm = #-0xd388
;     DebugP_uartLogWriterPutChar(character);
700adec8: 4620         	mov	r0, r4
700adeca: e8bd 4010    	pop.w	{r4, lr}
700adece: f7fd be87    	b.w	0x700abbe0 <DebugP_uartLogWriterPutChar> @ imm = #-0x22f2
		...
700adede: 0000         	movs	r0, r0

700adee0 <tm_interrupt_handler>:
;    if (test_interrupt_handler != NULL)
700adee0: f640 50b8    	movw	r0, #0xdb8
700adee4: f2c7 000b    	movt	r0, #0x700b
700adee8: 6800         	ldr	r0, [r0]
700adeea: 2800         	cmp	r0, #0x0
; }
700adeec: bf08         	it	eq
700adeee: 4770         	bxeq	lr
;       ((void (*)(void)) test_interrupt_handler)();
700adef0: 4700         	bx	r0
		...
700adefe: 0000         	movs	r0, r0

700adf00 <tm_setup_pmu>:
; {
700adf00: b580         	push	{r7, lr}
;    PMU_init(&gPmuConfig);
700adf02: f640 5038    	movw	r0, #0xd38
700adf06: f2c7 000b    	movt	r0, #0x700b
700adf0a: f7f1 faa1    	bl	0x7009f450 <PMU_init>   @ imm = #-0xeabe
;    return 1;
700adf0e: 2001         	movs	r0, #0x1
700adf10: bd80         	pop	{r7, pc}
		...
700adf1e: 0000         	movs	r0, r0

700adf20 <uiPortGetRunTimeCounterValue>:
; uint32_t uiPortGetRunTimeCounterValue() {
700adf20: b580         	push	{r7, lr}
700adf22: b082         	sub	sp, #0x8
;   uint64_t timeInUsecs = ClockP_getTimeUsec();
700adf24: f7fb f87c    	bl	0x700a9020 <ClockP_getTimeUsec> @ imm = #-0x4f08
700adf28: 9101         	str	r1, [sp, #0x4]
700adf2a: 9000         	str	r0, [sp]
;   return (uint32_t)(timeInUsecs);
700adf2c: 9800         	ldr	r0, [sp]
700adf2e: b002         	add	sp, #0x8
700adf30: bd80         	pop	{r7, pc}
		...
700adf3e: 0000         	movs	r0, r0

700adf40 <CSL_REG32_WR_RAW>:
; {
700adf40: b082         	sub	sp, #0x8
700adf42: 9001         	str	r0, [sp, #0x4]
700adf44: 9100         	str	r1, [sp]
;     *p = v;
700adf46: 9800         	ldr	r0, [sp]
700adf48: 9901         	ldr	r1, [sp, #0x4]
700adf4a: 6008         	str	r0, [r1]
;     return;
700adf4c: b002         	add	sp, #0x8
700adf4e: 4770         	bx	lr

700adf50 <CSL_REG32_WR_RAW>:
; {
700adf50: b082         	sub	sp, #0x8
700adf52: 9001         	str	r0, [sp, #0x4]
700adf54: 9100         	str	r1, [sp]
;     *p = v;
700adf56: 9800         	ldr	r0, [sp]
700adf58: 9901         	ldr	r1, [sp, #0x4]
700adf5a: 6008         	str	r0, [r1]
;     return;
700adf5c: b002         	add	sp, #0x8
700adf5e: 4770         	bx	lr

700adf60 <CSL_REG32_WR_RAW>:
; {
700adf60: b082         	sub	sp, #0x8
700adf62: 9001         	str	r0, [sp, #0x4]
700adf64: 9100         	str	r1, [sp]
;     *p = v;
700adf66: 9800         	ldr	r0, [sp]
700adf68: 9901         	ldr	r1, [sp, #0x4]
700adf6a: 6008         	str	r0, [r1]
;     return;
700adf6c: b002         	add	sp, #0x8
700adf6e: 4770         	bx	lr

700adf70 <CSL_REG32_WR_RAW>:
; {
700adf70: b082         	sub	sp, #0x8
700adf72: 9001         	str	r0, [sp, #0x4]
700adf74: 9100         	str	r1, [sp]
;     *p = v;
700adf76: 9800         	ldr	r0, [sp]
700adf78: 9901         	ldr	r1, [sp, #0x4]
700adf7a: 6008         	str	r0, [r1]
;     return;
700adf7c: b002         	add	sp, #0x8
700adf7e: 4770         	bx	lr

700adf80 <CSL_REG32_WR_RAW>:
; {
700adf80: b082         	sub	sp, #0x8
700adf82: 9001         	str	r0, [sp, #0x4]
700adf84: 9100         	str	r1, [sp]
;     *p = v;
700adf86: 9800         	ldr	r0, [sp]
700adf88: 9901         	ldr	r1, [sp, #0x4]
700adf8a: 6008         	str	r0, [r1]
;     return;
700adf8c: b002         	add	sp, #0x8
700adf8e: 4770         	bx	lr

700adf90 <CSL_udmapCppi5SetDstTag>:
; {
700adf90: b082         	sub	sp, #0x8
700adf92: 9001         	str	r0, [sp, #0x4]
700adf94: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->srcDstTag, UDMAP_CPPI5_PD_SRCDSTTAG_DSTTAG, dstTag );
700adf96: 9901         	ldr	r1, [sp, #0x4]
700adf98: 9800         	ldr	r0, [sp]
700adf9a: 8188         	strh	r0, [r1, #0xc]
; }
700adf9c: b002         	add	sp, #0x8
700adf9e: 4770         	bx	lr

700adfa0 <CSL_udmapCppi5SetOrgBufferLen>:
; {
700adfa0: b082         	sub	sp, #0x8
700adfa2: 9001         	str	r0, [sp, #0x4]
700adfa4: 9100         	str	r1, [sp]
;     pDesc->orgBufLen = bufferLenBytes;
700adfa6: 9800         	ldr	r0, [sp]
700adfa8: 9901         	ldr	r1, [sp, #0x4]
700adfaa: 6248         	str	r0, [r1, #0x24]
; }
700adfac: b002         	add	sp, #0x8
700adfae: 4770         	bx	lr

700adfb0 <ClockP_getTimerCount>:
; {
700adfb0: b580         	push	{r7, lr}
700adfb2: b082         	sub	sp, #0x8
700adfb4: 9001         	str	r0, [sp, #0x4]
;     return TimerP_getCount(timerBaseAddr);
700adfb6: 9801         	ldr	r0, [sp, #0x4]
700adfb8: f7ff ff62    	bl	0x700ade80 <TimerP_getCount> @ imm = #-0x13c
700adfbc: b002         	add	sp, #0x8
700adfbe: bd80         	pop	{r7, pc}

700adfc0 <ClockP_sleepTicks>:
; {
700adfc0: b580         	push	{r7, lr}
700adfc2: b082         	sub	sp, #0x8
700adfc4: 9001         	str	r0, [sp, #0x4]
;     vTaskDelay(ticks);
700adfc6: 9801         	ldr	r0, [sp, #0x4]
700adfc8: f7fe fc4a    	bl	0x700ac860 <vTaskDelay> @ imm = #-0x176c
; }
700adfcc: b002         	add	sp, #0x8
700adfce: bd80         	pop	{r7, pc}

700adfd0 <ClockP_timerClearOverflowInt>:
; {
700adfd0: b580         	push	{r7, lr}
700adfd2: b082         	sub	sp, #0x8
700adfd4: 9001         	str	r0, [sp, #0x4]
;     TimerP_clearOverflowInt(timerBaseAddr);
700adfd6: 9801         	ldr	r0, [sp, #0x4]
700adfd8: f7ff f832    	bl	0x700ad040 <TimerP_clearOverflowInt> @ imm = #-0xf9c
; }
700adfdc: b002         	add	sp, #0x8
700adfde: bd80         	pop	{r7, pc}

700adfe0 <HW_RD_REG32_RAW>:
; {
700adfe0: b082         	sub	sp, #0x8
700adfe2: 9001         	str	r0, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700adfe4: 9801         	ldr	r0, [sp, #0x4]
700adfe6: 6800         	ldr	r0, [r0]
700adfe8: 9000         	str	r0, [sp]
;     return (regVal);
700adfea: 9800         	ldr	r0, [sp]
700adfec: b002         	add	sp, #0x8
700adfee: 4770         	bx	lr

700adff0 <HW_WR_REG32_RAW>:
; {
700adff0: b082         	sub	sp, #0x8
700adff2: 9001         	str	r0, [sp, #0x4]
700adff4: 9100         	str	r1, [sp]
;     *(volatile uint32_t *) ((uintptr_t) addr) = value;
700adff6: 9800         	ldr	r0, [sp]
700adff8: 9901         	ldr	r1, [sp, #0x4]
700adffa: 6008         	str	r0, [r1]
;     return;
700adffc: b002         	add	sp, #0x8
700adffe: 4770         	bx	lr

700ae000 <Udma_defaultVirtToPhyFxn>:
; {
700ae000: b083         	sub	sp, #0xc
700ae002: 9002         	str	r0, [sp, #0x8]
700ae004: 9101         	str	r1, [sp, #0x4]
700ae006: 9200         	str	r2, [sp]
;     return ((uint64_t) virtAddr);
700ae008: 9802         	ldr	r0, [sp, #0x8]
700ae00a: 2100         	movs	r1, #0x0
700ae00c: b003         	add	sp, #0xc
700ae00e: 4770         	bx	lr

700ae010 <__aeabi_memset8>:
700ae010: e1a03001     	mov	r3, r1
700ae014: e1a01002     	mov	r1, r2
700ae018: e1a02003     	mov	r2, r3
700ae01c: eafffef9     	b	0x700adc08 <TI_memset_small> @ imm = #-0x41c

700ae020 <_out_null>:
; {
700ae020: b084         	sub	sp, #0x10
700ae022: f88d 000f    	strb.w	r0, [sp, #0xf]
700ae026: 9102         	str	r1, [sp, #0x8]
700ae028: 9201         	str	r2, [sp, #0x4]
700ae02a: 9300         	str	r3, [sp]
; }
700ae02c: b004         	add	sp, #0x10
700ae02e: 4770         	bx	lr

700ae030 <vTaskSuspendAll>:
;   ++uxSchedulerSuspended;
700ae030: f640 51d4    	movw	r1, #0xdd4
700ae034: f2c7 010b    	movt	r1, #0x700b
700ae038: 6808         	ldr	r0, [r1]
700ae03a: 3001         	adds	r0, #0x1
700ae03c: 6008         	str	r0, [r1]
; }
700ae03e: 4770         	bx	lr

700ae040 <CSL_REG64_RD_RAW>:
; {
700ae040: b081         	sub	sp, #0x4
700ae042: 9000         	str	r0, [sp]
;     return (*p);
700ae044: 9800         	ldr	r0, [sp]
700ae046: e9d0 0100    	ldrd	r0, r1, [r0]
700ae04a: b001         	add	sp, #0x4
700ae04c: 4770         	bx	lr
700ae04e: 0000         	movs	r0, r0

700ae050 <vListInitialiseItem>:
; {
700ae050: b081         	sub	sp, #0x4
700ae052: 9000         	str	r0, [sp]
;     pxItem->pxContainer = NULL;
700ae054: 9900         	ldr	r1, [sp]
700ae056: 2000         	movs	r0, #0x0
700ae058: 6108         	str	r0, [r1, #0x10]
; }
700ae05a: b001         	add	sp, #0x4
700ae05c: 4770         	bx	lr
700ae05e: 0000         	movs	r0, r0

700ae060 <vTaskMissedYield>:
; void vTaskMissedYield(void) { xYieldPending = pdTRUE; }
700ae060: f640 6100    	movw	r1, #0xe00
700ae064: f2c7 010b    	movt	r1, #0x700b
700ae068: 2001         	movs	r0, #0x1
700ae06a: 6008         	str	r0, [r1]
700ae06c: 4770         	bx	lr
700ae06e: 0000         	movs	r0, r0

700ae070 <CSL_REG32_RD_RAW>:
; {
700ae070: b081         	sub	sp, #0x4
700ae072: 9000         	str	r0, [sp]
;     return (*p);
700ae074: 9800         	ldr	r0, [sp]
700ae076: 6800         	ldr	r0, [r0]
700ae078: b001         	add	sp, #0x4
700ae07a: 4770         	bx	lr
700ae07c: 0000         	movs	r0, r0
700ae07e: 0000         	movs	r0, r0

700ae080 <CSL_REG32_RD_RAW>:
; {
700ae080: b081         	sub	sp, #0x4
700ae082: 9000         	str	r0, [sp]
;     return (*p);
700ae084: 9800         	ldr	r0, [sp]
700ae086: 6800         	ldr	r0, [r0]
700ae088: b001         	add	sp, #0x4
700ae08a: 4770         	bx	lr
700ae08c: 0000         	movs	r0, r0
700ae08e: 0000         	movs	r0, r0

700ae090 <CSL_REG32_RD_RAW>:
; {
700ae090: b081         	sub	sp, #0x4
700ae092: 9000         	str	r0, [sp]
;     return (*p);
700ae094: 9800         	ldr	r0, [sp]
700ae096: 6800         	ldr	r0, [r0]
700ae098: b001         	add	sp, #0x4
700ae09a: 4770         	bx	lr
700ae09c: 0000         	movs	r0, r0
700ae09e: 0000         	movs	r0, r0

700ae0a0 <CSL_REG32_RD_RAW>:
; {
700ae0a0: b081         	sub	sp, #0x4
700ae0a2: 9000         	str	r0, [sp]
;     return (*p);
700ae0a4: 9800         	ldr	r0, [sp]
700ae0a6: 6800         	ldr	r0, [r0]
700ae0a8: b001         	add	sp, #0x4
700ae0aa: 4770         	bx	lr
700ae0ac: 0000         	movs	r0, r0
700ae0ae: 0000         	movs	r0, r0

700ae0b0 <CSL_REG32_RD_RAW>:
; {
700ae0b0: b081         	sub	sp, #0x4
700ae0b2: 9000         	str	r0, [sp]
;     return (*p);
700ae0b4: 9800         	ldr	r0, [sp]
700ae0b6: 6800         	ldr	r0, [r0]
700ae0b8: b001         	add	sp, #0x4
700ae0ba: 4770         	bx	lr
700ae0bc: 0000         	movs	r0, r0
700ae0be: 0000         	movs	r0, r0

700ae0c0 <CSL_REG32_RD_RAW>:
; {
700ae0c0: b081         	sub	sp, #0x4
700ae0c2: 9000         	str	r0, [sp]
;     return (*p);
700ae0c4: 9800         	ldr	r0, [sp]
700ae0c6: 6800         	ldr	r0, [r0]
700ae0c8: b001         	add	sp, #0x4
700ae0ca: 4770         	bx	lr
700ae0cc: 0000         	movs	r0, r0
700ae0ce: 0000         	movs	r0, r0

700ae0d0 <PMU_resetCounters>:
; static void PMU_resetCounters(void) {
700ae0d0: b580         	push	{r7, lr}
;   CSL_armR5PmuResetCycleCnt();
700ae0d2: f7f2 ebd0    	blx	0x700a0874 <CSL_armR5PmuResetCycleCnt> @ imm = #-0xd860
;   CSL_armR5PmuResetCntrs();
700ae0d6: f7f2 ebd6    	blx	0x700a0884 <CSL_armR5PmuResetCntrs> @ imm = #-0xd854
; }
700ae0da: bd80         	pop	{r7, pc}
700ae0dc: 0000         	movs	r0, r0
700ae0de: 0000         	movs	r0, r0

700ae0e0 <Sciclient_getSelfDevIdCore>:
;     return gSciclientHandle.devIdCore;
700ae0e0: f640 5000    	movw	r0, #0xd00
700ae0e4: f2c7 000b    	movt	r0, #0x700b
700ae0e8: 6880         	ldr	r0, [r0, #0x8]
700ae0ea: 4770         	bx	lr
700ae0ec: 0000         	movs	r0, r0
700ae0ee: 0000         	movs	r0, r0

700ae0f0 <Sciclient_rmPsGetPsp>:
;     return gPstack.psp;
700ae0f0: f241 0058    	movw	r0, #0x1058
700ae0f4: f2c7 0008    	movt	r0, #0x7008
700ae0f8: 8c80         	ldrh	r0, [r0, #0x24]
700ae0fa: 4770         	bx	lr
700ae0fc: 0000         	movs	r0, r0
700ae0fe: 0000         	movs	r0, r0

700ae100 <Udma_rmFreeFreeRing>:
; {
700ae100: b082         	sub	sp, #0x8
700ae102: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ae106: 9100         	str	r1, [sp]
;     return;
700ae108: b002         	add	sp, #0x8
700ae10a: 4770         	bx	lr
700ae10c: 0000         	movs	r0, r0
700ae10e: 0000         	movs	r0, r0

700ae110 <xTaskGetIdleTaskHandle>:
;   return xIdleTaskHandle;
700ae110: f640 50e0    	movw	r0, #0xde0
700ae114: f2c7 000b    	movt	r0, #0x700b
700ae118: 6800         	ldr	r0, [r0]
700ae11a: 4770         	bx	lr
700ae11c: 0000         	movs	r0, r0
700ae11e: 0000         	movs	r0, r0

700ae120 <.Lfastpath_exit>:
700ae120: e0420003     	sub	r0, r2, r3
700ae124: e12fff1e     	bx	lr
700ae128: e320f000     	nop
700ae12c: 00000000     	andeq	r0, r0, r0

700ae130 <Hwip_dataAndInstructionBarrier>:
;     __asm__ __volatile__ (" isb"   "\n\t": : : "memory");
700ae130: f3bf 8f6f    	isb	sy
;     __asm__ __volatile__ (" dsb"   "\n\t": : : "memory");
700ae134: f3bf 8f4f    	dsb	sy
; }
700ae138: 4770         	bx	lr
700ae13a: 0000         	movs	r0, r0
700ae13c: 0000         	movs	r0, r0
700ae13e: 0000         	movs	r0, r0

700ae140 <prvTaskExitError>:
; static void prvTaskExitError(void) {
700ae140: b580         	push	{r7, lr}
700ae142: 2000         	movs	r0, #0x0
;   DebugP_assertNoLog(0);
700ae144: f001 fafc    	bl	0x700af740 <_DebugP_assertNoLog> @ imm = #0x15f8
; }
700ae148: bd80         	pop	{r7, pc}
700ae14a: 0000         	movs	r0, r0
700ae14c: 0000         	movs	r0, r0
700ae14e: 0000         	movs	r0, r0

700ae150 <tm_thread_sleep>:
; {
700ae150: f44f 717a    	mov.w	r1, #0x3e8
;    vTaskDelay((seconds * 1000U) / portTICK_RATE_MS);
700ae154: 4348         	muls	r0, r1, r0
700ae156: f7fe bb83    	b.w	0x700ac860 <vTaskDelay> @ imm = #-0x18fa
700ae15a: 0000         	movs	r0, r0
700ae15c: 0000         	movs	r0, r0
700ae15e: 0000         	movs	r0, r0

700ae160 <ClockP_getTicks>:
; {
700ae160: b580         	push	{r7, lr}
;     return ((uint32_t)xTaskGetTickCount());
700ae162: f7ff fc35    	bl	0x700ad9d0 <xTaskGetTickCount> @ imm = #-0x796
700ae166: bd80         	pop	{r7, pc}
		...

700ae170 <UART_lld_errorCallback>:
; {
700ae170: b081         	sub	sp, #0x4
700ae172: 9000         	str	r0, [sp]
; }
700ae174: b001         	add	sp, #0x4
700ae176: 4770         	bx	lr
		...

700ae180 <Udma_ringAssertFnPointers>:
; {
700ae180: b081         	sub	sp, #0x4
700ae182: 9000         	str	r0, [sp]
;     return;
700ae184: b001         	add	sp, #0x4
700ae186: 4770         	bx	lr
		...

700ae190 <vApplicationIdleHook>:
; void vApplicationIdleHook(void) {
700ae190: b580         	push	{r7, lr}
;   vApplicationLoadHook();
700ae192: f7fc f84d    	bl	0x700aa230 <vApplicationLoadHook> @ imm = #-0x3f66
; }
700ae196: bd80         	pop	{r7, pc}
		...

700ae1a0 <Board_driversOpen>:
;     return status;
700ae1a0: 2000         	movs	r0, #0x0
700ae1a2: 4770         	bx	lr
		...

700ae1b0 <Sciclient_rmPsGetMaxPsp>:
; {
700ae1b0: 2003         	movs	r0, #0x3
;     return SCICLIENT_PS_MAX_DEPTH;
700ae1b2: 4770         	bx	lr
		...

700ae1c0 <TaskP_yield>:
;     taskYIELD();
700ae1c0: df00         	svc	#0x0
; }
700ae1c2: 4770         	bx	lr
		...

700ae1d0 <__aeabi_ldiv0>:
700ae1d0: e12fff1e     	bx	lr
		...

700ae1e0 <main>:
;    return rtos_main_freertos();
700ae1e0: f7f9 b866    	b.w	0x700a72b0 <rtos_main_freertos> @ imm = #-0x6f34
		...

700ae1f0 <tm_pmu_profile_end>:
;    PMU_profileEnd(name);
700ae1f0: f7f5 bd9e    	b.w	0x700a3d30 <PMU_profileEnd> @ imm = #-0xa4c4
		...

700ae200 <tm_pmu_profile_print>:
;    PMU_profilePrintEntry(name);
700ae200: f7f7 bcf6    	b.w	0x700a5bf0 <PMU_profilePrintEntry> @ imm = #-0x8614
		...

700ae210 <tm_pmu_profile_start>:
;    PMU_profileStart(name);
700ae210: f7f9 bc0e    	b.w	0x700a7a30 <PMU_profileStart> @ imm = #-0x67e4
		...

700ae220 <Board_init>:
; }
700ae220: 4770         	bx	lr
		...
700ae22e: 0000         	movs	r0, r0

700ae230 <tm_initialize>:
;    test_initialization_function();
700ae230: 4700         	bx	r0
		...
700ae23e: 0000         	movs	r0, r0

700ae240 <vPortConfigTimerForRunTimeStats>:
; }
700ae240: 4770         	bx	lr
		...
700ae25e: 0000         	movs	r0, r0
